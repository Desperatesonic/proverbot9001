From Coq Require Import Bool.
-----
From Coq Require Import List.
-----
From Coq Require Import Arith.
-----
Require Import   Coq.Arith.Even .
-----
Require Import BellantoniCook.Lib BellantoniCook.Bitstring BellantoniCook.BC.
-----
Definition inv_e (e : BC) : BC :=\n  comp 2 0 e (proj 2 0 1 :: proj 2 0 0 :: nil) nil.
-----
Definition from_11_to_20 (e : BC) : BC :=\n  comp 2 0 e (proj 2 0 0 :: nil) (proj 2 0 1 :: nil).
-----
Lemma from_11_to_20_correct e v1 v2 :\n  sem e [v1] [v2] = sem (from_11_to_20 e) [v1 ; v2] nil.
-----
Lemma from_11_to_20_correct e v1 v2 : sem e [v1] [v2] = sem (from_11_to_20 e) [v1 ; v2] nil.

*****
v1,v2 : list bool
e : BC
*****
eq (sem e (cons v1 nil) (cons v2 nil)) (sem (from_11_to_20 e) (cons v1 (cons v2 nil)) nil)
+++++
Proof.
-----
Lemma from_11_to_20_correct e v1 v2 : sem e [v1] [v2] = sem (from_11_to_20 e) [v1 ; v2] nil.
Proof.

*****
v1,v2 : list bool
e : BC
*****
eq (sem e (cons v1 nil) (cons v2 nil)) (sem (from_11_to_20 e) (cons v1 (cons v2 nil)) nil)
+++++
intros.
-----
Lemma from_11_to_20_correct e v1 v2 : sem e [v1] [v2] = sem (from_11_to_20 e) [v1 ; v2] nil.
Proof.
intros.

*****
v1,v2 : list bool
e : BC
*****
eq (sem e (cons v1 nil) (cons v2 nil)) (sem (from_11_to_20 e) (cons v1 (cons v2 nil)) nil)
+++++
simpl.
-----
Lemma from_11_to_20_correct e v1 v2 : sem e [v1] [v2] = sem (from_11_to_20 e) [v1 ; v2] nil.
Proof.
intros.
simpl.

*****
v1,v2 : list bool
e : BC
*****
eq (sem e (cons v1 nil) (cons v2 nil)) (sem e (cons v1 nil) (cons v2 nil))
+++++
trivial.
-----
Lemma from_11_to_20_correct e v1 v2 : sem e [v1] [v2] = sem (from_11_to_20 e) [v1 ; v2] nil.
Proof.
intros.
simpl.
trivial.

*****

*****

+++++
Qed.
-----
Definition app_e : BC :=\n  rec (proj 0 1 0)\n      (comp 1 2 (succ false) nil ((proj 1 2 1) :: nil))\n      (comp 1 2 (succ true) nil ((proj 1 2 1) :: nil)).
-----
Lemma app_correct v1 v2 :\n  sem app_e [v1] [v2] = v1 ++ v2.
-----
Lemma app_correct v1 v2 : sem app_e [v1] [v2] = v1 ++ v2.

*****
v1,v2 : list bool
*****
eq (sem app_e (cons v1 nil) (cons v2 nil)) (app v1 v2)
+++++
Proof.
-----
Lemma app_correct v1 v2 : sem app_e [v1] [v2] = v1 ++ v2.
Proof.

*****
v1,v2 : list bool
*****
eq (sem app_e (cons v1 nil) (cons v2 nil)) (app v1 v2)
+++++
induction v1.
-----
Lemma app_correct v1 v2 : sem app_e [v1] [v2] = v1 ++ v2.
Proof.
induction v1.

*****
v2 : list bool
*****
eq (sem app_e (cons nil nil) (cons v2 nil)) (app nil v2)
+++++
simpl in *.
-----
Lemma app_correct v1 v2 : sem app_e [v1] [v2] = v1 ++ v2.
Proof.
induction v1.
simpl in *.

*****
v2 : list bool
*****
eq v2 v2
+++++
trivial.
-----
Lemma app_correct v1 v2 : sem app_e [v1] [v2] = v1 ++ v2.
Proof.
induction v1.

*****
IHv1 : eq (sem app_e (cons v1 nil) (cons v2 nil)) (app v1 v2)
v1,v2 : list bool
a : bool
*****
eq (sem app_e (cons (cons a v1) nil) (cons v2 nil)) (app (cons a v1) v2)
+++++
simpl in *.
-----
Lemma app_correct v1 v2 : sem app_e [v1] [v2] = v1 ++ v2.
Proof.
induction v1.
simpl in *.

*****
IHv1 : eq\n (sem_rec (fun _ vsl : list (list bool) => nth O vsl nil)\n (fun _ vsl : list (list bool) => cons false (nth O vsl nil))\n (fun _ vsl : list (list bool) => cons true (nth O vsl nil)) v1 nil\n (cons v2 nil)) (app v1 v2)
v1,v2 : list bool
a : bool
*****
eq (if a then cons true (sem_rec (fun _ vsl : list (list bool) => nth O vsl nil) (fun _ vsl : list (list bool) => cons false (nth O vsl nil)) (fun _ vsl : list (list bool) => cons true (nth O vsl nil)) v1 nil (cons v2 nil)) else cons false (sem_rec (fun _ vsl : list (list bool) => nth O vsl nil) (fun _ vsl : list (list bool) => cons false (nth O vsl nil)) (fun _ vsl : list (list bool) => cons true (nth O vsl nil)) v1 nil (cons v2 nil))) (cons a (app v1 v2))
+++++
trivial.
-----
Lemma app_correct v1 v2 : sem app_e [v1] [v2] = v1 ++ v2.
Proof.
induction v1.
simpl in *.
trivial.

*****
IHv1 : eq\n (sem_rec (fun _ vsl : list (list bool) => nth O vsl nil)\n (fun _ vsl : list (list bool) => cons false (nth O vsl nil))\n (fun _ vsl : list (list bool) => cons true (nth O vsl nil)) v1 nil\n (cons v2 nil)) (app v1 v2)
v1,v2 : list bool
a : bool
*****
eq (if a then cons true (sem_rec (fun _ vsl : list (list bool) => nth O vsl nil) (fun _ vsl : list (list bool) => cons false (nth O vsl nil)) (fun _ vsl : list (list bool) => cons true (nth O vsl nil)) v1 nil (cons v2 nil)) else cons false (sem_rec (fun _ vsl : list (list bool) => nth O vsl nil) (fun _ vsl : list (list bool) => cons false (nth O vsl nil)) (fun _ vsl : list (list bool) => cons true (nth O vsl nil)) v1 nil (cons v2 nil))) (cons a (app v1 v2))
+++++
intros.
-----
Lemma app_correct v1 v2 : sem app_e [v1] [v2] = v1 ++ v2.
Proof.
induction v1.
simpl in *.
trivial.
intros.

*****
IHv1 : eq\n (sem_rec (fun _ vsl : list (list bool) => nth O vsl nil)\n (fun _ vsl : list (list bool) => cons false (nth O vsl nil))\n (fun _ vsl : list (list bool) => cons true (nth O vsl nil)) v1 nil\n (cons v2 nil)) (app v1 v2)
v1,v2 : list bool
a : bool
*****
eq (if a then cons true (sem_rec (fun _ vsl : list (list bool) => nth O vsl nil) (fun _ vsl : list (list bool) => cons false (nth O vsl nil)) (fun _ vsl : list (list bool) => cons true (nth O vsl nil)) v1 nil (cons v2 nil)) else cons false (sem_rec (fun _ vsl : list (list bool) => nth O vsl nil) (fun _ vsl : list (list bool) => cons false (nth O vsl nil)) (fun _ vsl : list (list bool) => cons true (nth O vsl nil)) v1 nil (cons v2 nil))) (cons a (app v1 v2))
+++++
rewrite IHv1.
-----
Lemma app_correct v1 v2 : sem app_e [v1] [v2] = v1 ++ v2.
Proof.
induction v1.
simpl in *.
trivial.
intros.
rewrite IHv1.

*****
IHv1 : eq\n (sem_rec (fun _ vsl : list (list bool) => nth O vsl nil)\n (fun _ vsl : list (list bool) => cons false (nth O vsl nil))\n (fun _ vsl : list (list bool) => cons true (nth O vsl nil)) v1 nil\n (cons v2 nil)) (app v1 v2)
v1,v2 : list bool
a : bool
*****
eq (if a then cons true (app v1 v2) else cons false (app v1 v2)) (cons a (app v1 v2))
+++++
case a.
-----
Lemma app_correct v1 v2 : sem app_e [v1] [v2] = v1 ++ v2.
Proof.
induction v1.
simpl in *.
trivial.
intros.
rewrite IHv1.
case a.

*****
IHv1 : eq\n (sem_rec (fun _ vsl : list (list bool) => nth O vsl nil)\n (fun _ vsl : list (list bool) => cons false (nth O vsl nil))\n (fun _ vsl : list (list bool) => cons true (nth O vsl nil)) v1 nil\n (cons v2 nil)) (app v1 v2)
v1,v2 : list bool
a : bool
*****
eq (cons true (app v1 v2)) (cons true (app v1 v2))
+++++
trivial.
-----
Lemma app_correct v1 v2 : sem app_e [v1] [v2] = v1 ++ v2.
Proof.
induction v1.
simpl in *.
trivial.
intros.
rewrite IHv1.
case a.

*****
IHv1 : eq\n (sem_rec (fun _ vsl : list (list bool) => nth O vsl nil)\n (fun _ vsl : list (list bool) => cons false (nth O vsl nil))\n (fun _ vsl : list (list bool) => cons true (nth O vsl nil)) v1 nil\n (cons v2 nil)) (app v1 v2)
v1,v2 : list bool
a : bool
*****
eq (cons false (app v1 v2)) (cons false (app v1 v2))
+++++
trivial.
-----
Lemma app_correct v1 v2 : sem app_e [v1] [v2] = v1 ++ v2.
Proof.
induction v1.

*****

*****

+++++
Qed.
-----
Program Fixpoint constant (v:bs) : { e : BC | arities e = ok_arities 0 0 /\ sem e nil nil = v } :=\n  match v with\n  | nil => BC.zero\n  | b :: v' => BC.comp 0 0 (BC.succ b) nil [constant v']\n  end.
-----
Next Obligation.
-----
Next Obligation.

*****

*****
forall (v : list bool) (_ : eq nil v), (fun e : BC => and (eq (arities e) (ok_arities O O)) (eq (sem e nil nil) nil)) zero
+++++
simpl.
-----
Next Obligation.
simpl.

*****

*****
forall (v : list bool) (_ : eq nil v), and (eq (ok_arities O O) (ok_arities O O)) (eq nil nil)
+++++
tauto.
-----
Next Obligation.
simpl.
tauto.

*****

*****

+++++
Qed.
-----
Next Obligation.
-----
Next Obligation.

*****

*****
forall (constant : Tactics.fix_proto (forall v : list bool, sig (fun e : BC => and (eq (arities e) (ok_arities O O)) (eq (sem e nil nil) v)))) (v : list bool) (b : bool) (v' : list bool) (_ : eq (cons b v') v), (fun e : BC => and (eq (arities e) (ok_arities O O)) (eq (sem e nil nil) (cons b v'))) (comp O O (succ b) nil (cons (proj1_sig (constant v')) nil))
+++++
simpl.
-----
Next Obligation.
simpl.

*****

*****
forall (constant : Tactics.fix_proto (forall v : list bool, sig (fun e : BC => and (eq (arities e) (ok_arities O O)) (eq (sem e nil nil) v)))) (v : list bool) (b : bool) (v' : list bool) (_ : eq (cons b v') v), and (eq (if andb (aeq (arities (proj1_sig (constant v'))) (ok_arities O O)) true then ok_arities O O else error_comp (ok_arities O (S O)) nil (cons (arities (proj1_sig (constant v'))) nil)) (ok_arities O O)) (eq (cons b (sem (proj1_sig (constant v')) nil nil)) (cons b v'))
+++++
intros bs_to_BC v b v' Hv.
-----
Next Obligation.
simpl.
intros bs_to_BC v b v' Hv.

*****
Hv : eq (cons b v') v
v' : list bool
b : bool
v : list bool
bs_to_BC : Tactics.fix_proto\n (forall v : list bool,\n sig\n (fun e : BC =>\n and (eq (arities e) (ok_arities O O)) (eq (sem e nil nil) v)))
*****
and (eq (if andb (aeq (arities (proj1_sig (bs_to_BC v'))) (ok_arities O O)) true then ok_arities O O else error_comp (ok_arities O (S O)) nil (cons (arities (proj1_sig (bs_to_BC v'))) nil)) (ok_arities O O)) (eq (cons b (sem (proj1_sig (bs_to_BC v')) nil nil)) (cons b v'))
+++++
subst v.
-----
Next Obligation.
simpl.
intros bs_to_BC v b v' Hv.
subst v.

*****
v' : list bool
b : bool
bs_to_BC : Tactics.fix_proto\n (forall v : list bool,\n sig\n (fun e : BC =>\n and (eq (arities e) (ok_arities O O)) (eq (sem e nil nil) v)))
*****
and (eq (if andb (aeq (arities (proj1_sig (bs_to_BC v'))) (ok_arities O O)) true then ok_arities O O else error_comp (ok_arities O (S O)) nil (cons (arities (proj1_sig (bs_to_BC v'))) nil)) (ok_arities O O)) (eq (cons b (sem (proj1_sig (bs_to_BC v')) nil nil)) (cons b v'))
+++++
destruct (bs_to_BC v') as [e [H1 H2] ].
-----
Next Obligation.
simpl.
intros bs_to_BC v b v' Hv.
subst v.
destruct (bs_to_BC v') as [e [H1 H2] ].

*****
H2 : eq (sem e nil nil) v'
H1 : eq (arities e) (ok_arities O O)
e : BC
v' : list bool
b : bool
bs_to_BC : Tactics.fix_proto\n (forall v : list bool,\n sig\n (fun e : BC =>\n and (eq (arities e) (ok_arities O O)) (eq (sem e nil nil) v)))
*****
and (eq (if andb (aeq (arities (proj1_sig (exist (fun e : BC => and (eq (arities e) (ok_arities O O)) (eq (sem e nil nil) v')) e (conj H1 H2)))) (ok_arities O O)) true then ok_arities O O else error_comp (ok_arities O (S O)) nil (cons (arities (proj1_sig (exist (fun e : BC => and (eq (arities e) (ok_arities O O)) (eq (sem e nil nil) v')) e (conj H1 H2)))) nil)) (ok_arities O O)) (eq (cons b (sem (proj1_sig (exist (fun e : BC => and (eq (arities e) (ok_arities O O)) (eq (sem e nil nil) v')) e (conj H1 H2))) nil nil)) (cons b v'))
+++++
simpl.
-----
Next Obligation.
simpl.
intros bs_to_BC v b v' Hv.
subst v.
destruct (bs_to_BC v') as [e [H1 H2] ].
simpl.

*****
H2 : eq (sem e nil nil) v'
H1 : eq (arities e) (ok_arities O O)
e : BC
v' : list bool
b : bool
bs_to_BC : Tactics.fix_proto\n (forall v : list bool,\n sig\n (fun e : BC =>\n and (eq (arities e) (ok_arities O O)) (eq (sem e nil nil) v)))
*****
and (eq (if andb (aeq (arities e) (ok_arities O O)) true then ok_arities O O else error_comp (ok_arities O (S O)) nil (cons (arities e) nil)) (ok_arities O O)) (eq (cons b (sem e nil nil)) (cons b v'))
+++++
rewrite H1.
-----
Next Obligation.
simpl.
intros bs_to_BC v b v' Hv.
subst v.
destruct (bs_to_BC v') as [e [H1 H2] ].
simpl.
rewrite H1.

*****
H2 : eq (sem e nil nil) v'
H1 : eq (arities e) (ok_arities O O)
e : BC
v' : list bool
b : bool
bs_to_BC : Tactics.fix_proto\n (forall v : list bool,\n sig\n (fun e : BC =>\n and (eq (arities e) (ok_arities O O)) (eq (sem e nil nil) v)))
*****
and (eq (if andb (aeq (ok_arities O O) (ok_arities O O)) true then ok_arities O O else error_comp (ok_arities O (S O)) nil (cons (ok_arities O O) nil)) (ok_arities O O)) (eq (cons b (sem e nil nil)) (cons b v'))
+++++
rewrite H2.
-----
Next Obligation.
simpl.
intros bs_to_BC v b v' Hv.
subst v.
destruct (bs_to_BC v') as [e [H1 H2] ].
simpl.
rewrite H1.
rewrite H2.

*****
H2 : eq (sem e nil nil) v'
H1 : eq (arities e) (ok_arities O O)
e : BC
v' : list bool
b : bool
bs_to_BC : Tactics.fix_proto\n (forall v : list bool,\n sig\n (fun e : BC =>\n and (eq (arities e) (ok_arities O O)) (eq (sem e nil nil) v)))
*****
and (eq (if andb (aeq (ok_arities O O) (ok_arities O O)) true then ok_arities O O else error_comp (ok_arities O (S O)) nil (cons (ok_arities O O) nil)) (ok_arities O O)) (eq (cons b v') (cons b v'))
+++++
tauto.
-----
Next Obligation.
simpl.
intros bs_to_BC v b v' Hv.
subst v.
destruct (bs_to_BC v') as [e [H1 H2] ].
simpl.
rewrite H1.
rewrite H2.
tauto.

*****

*****

+++++
Defined.
-----
Definition rec2 g h := rec g h h.
-----
Lemma rec2_correct v1 v2 g h0 h1 :\n  unary (hd nil v1) = true ->\n  sem (rec g h0 h1) v1 v2 = sem (rec2 g h1) v1 v2.
-----
Lemma rec2_correct v1 v2 g h0 h1 : unary (hd nil v1) = true -> sem (rec g h0 h1) v1 v2 = sem (rec2 g h1) v1 v2.

*****
g,h0,h1 : BC
v1,v2 : list (list bool)
*****
forall _ : eq (unary (hd nil v1)) true, eq (sem (rec g h0 h1) v1 v2) (sem (rec2 g h1) v1 v2)
+++++
Proof.
-----
Lemma rec2_correct v1 v2 g h0 h1 : unary (hd nil v1) = true -> sem (rec g h0 h1) v1 v2 = sem (rec2 g h1) v1 v2.
Proof.

*****
g,h0,h1 : BC
v1,v2 : list (list bool)
*****
forall _ : eq (unary (hd nil v1)) true, eq (sem (rec g h0 h1) v1 v2) (sem (rec2 g h1) v1 v2)
+++++
intros.
-----
Lemma rec2_correct v1 v2 g h0 h1 : unary (hd nil v1) = true -> sem (rec g h0 h1) v1 v2 = sem (rec2 g h1) v1 v2.
Proof.
intros.

*****
H : eq (unary (hd nil v1)) true
g,h0,h1 : BC
v1,v2 : list (list bool)
*****
eq (sem (rec g h0 h1) v1 v2) (sem (rec2 g h1) v1 v2)
+++++
simpl.
-----
Lemma rec2_correct v1 v2 g h0 h1 : unary (hd nil v1) = true -> sem (rec g h0 h1) v1 v2 = sem (rec2 g h1) v1 v2.
Proof.
intros.
simpl.

*****
H : eq (unary (hd nil v1)) true
g,h0,h1 : BC
v1,v2 : list (list bool)
*****
eq (sem_rec (sem g) (sem h0) (sem h1) (hd nil v1) (tl v1) v2) (sem_rec (sem g) (sem h1) (sem h1) (hd nil v1) (tl v1) v2)
+++++
revert H.
-----
Lemma rec2_correct v1 v2 g h0 h1 : unary (hd nil v1) = true -> sem (rec g h0 h1) v1 v2 = sem (rec2 g h1) v1 v2.
Proof.
intros.
simpl.
revert H.

*****
g,h0,h1 : BC
v1,v2 : list (list bool)
*****
forall _ : eq (unary (hd nil v1)) true, eq (sem_rec (sem g) (sem h0) (sem h1) (hd nil v1) (tl v1) v2) (sem_rec (sem g) (sem h1) (sem h1) (hd nil v1) (tl v1) v2)
+++++
induction (hd nil v1).
-----
Lemma rec2_correct v1 v2 g h0 h1 : unary (hd nil v1) = true -> sem (rec g h0 h1) v1 v2 = sem (rec2 g h1) v1 v2.
Proof.
intros.
simpl.
revert H.
induction (hd nil v1).

*****
g,h0,h1 : BC
v1,v2 : list (list bool)
*****
forall _ : eq (unary nil) true, eq (sem_rec (sem g) (sem h0) (sem h1) nil (tl v1) v2) (sem_rec (sem g) (sem h1) (sem h1) nil (tl v1) v2)
+++++
simpl.
-----
Lemma rec2_correct v1 v2 g h0 h1 : unary (hd nil v1) = true -> sem (rec g h0 h1) v1 v2 = sem (rec2 g h1) v1 v2.
Proof.
intros.
simpl.
revert H.
induction (hd nil v1).
simpl.

*****
g,h0,h1 : BC
v1,v2 : list (list bool)
*****
forall _ : eq true true, eq (sem g (tl v1) v2) (sem g (tl v1) v2)
+++++
trivial.
-----
Lemma rec2_correct v1 v2 g h0 h1 : unary (hd nil v1) = true -> sem (rec g h0 h1) v1 v2 = sem (rec2 g h1) v1 v2.
Proof.
intros.
simpl.
revert H.
induction (hd nil v1).

*****
IHl : forall _ : eq (unary l) true,\neq (sem_rec (sem g) (sem h0) (sem h1) l (tl v1) v2)\n (sem_rec (sem g) (sem h1) (sem h1) l (tl v1) v2)
l : list bool
a : bool
g,h0,h1 : BC
v1,v2 : list (list bool)
*****
forall _ : eq (unary (cons a l)) true, eq (sem_rec (sem g) (sem h0) (sem h1) (cons a l) (tl v1) v2) (sem_rec (sem g) (sem h1) (sem h1) (cons a l) (tl v1) v2)
+++++
simpl.
-----
Lemma rec2_correct v1 v2 g h0 h1 : unary (hd nil v1) = true -> sem (rec g h0 h1) v1 v2 = sem (rec2 g h1) v1 v2.
Proof.
intros.
simpl.
revert H.
induction (hd nil v1).
simpl.

*****
IHl : forall _ : eq (unary l) true,\neq (sem_rec (sem g) (sem h0) (sem h1) l (tl v1) v2)\n (sem_rec (sem g) (sem h1) (sem h1) l (tl v1) v2)
l : list bool
a : bool
g,h0,h1 : BC
v1,v2 : list (list bool)
*****
forall _ : eq (andb (id a) (unary l)) true, eq (if a then sem h1 (cons l (tl v1)) (cons (sem_rec (sem g) (sem h0) (sem h1) l (tl v1) v2) v2) else sem h0 (cons l (tl v1)) (cons (sem_rec (sem g) (sem h0) (sem h1) l (tl v1) v2) v2)) (if a then sem h1 (cons l (tl v1)) (cons (sem_rec (sem g) (sem h1) (sem h1) l (tl v1) v2) v2) else sem h1 (cons l (tl v1)) (cons (sem_rec (sem g) (sem h1) (sem h1) l (tl v1) v2) v2))
+++++
trivial.
-----
Lemma rec2_correct v1 v2 g h0 h1 : unary (hd nil v1) = true -> sem (rec g h0 h1) v1 v2 = sem (rec2 g h1) v1 v2.
Proof.
intros.
simpl.
revert H.
induction (hd nil v1).
simpl.
trivial.

*****
IHl : forall _ : eq (unary l) true,\neq (sem_rec (sem g) (sem h0) (sem h1) l (tl v1) v2)\n (sem_rec (sem g) (sem h1) (sem h1) l (tl v1) v2)
l : list bool
a : bool
g,h0,h1 : BC
v1,v2 : list (list bool)
*****
forall _ : eq (andb (id a) (unary l)) true, eq (if a then sem h1 (cons l (tl v1)) (cons (sem_rec (sem g) (sem h0) (sem h1) l (tl v1) v2) v2) else sem h0 (cons l (tl v1)) (cons (sem_rec (sem g) (sem h0) (sem h1) l (tl v1) v2) v2)) (if a then sem h1 (cons l (tl v1)) (cons (sem_rec (sem g) (sem h1) (sem h1) l (tl v1) v2) v2) else sem h1 (cons l (tl v1)) (cons (sem_rec (sem g) (sem h1) (sem h1) l (tl v1) v2) v2))
+++++
intros.
-----
Lemma rec2_correct v1 v2 g h0 h1 : unary (hd nil v1) = true -> sem (rec g h0 h1) v1 v2 = sem (rec2 g h1) v1 v2.
Proof.
intros.
simpl.
revert H.
induction (hd nil v1).
simpl.
trivial.
intros.

*****
H : eq (andb (id a) (unary l)) true
IHl : forall _ : eq (unary l) true,\neq (sem_rec (sem g) (sem h0) (sem h1) l (tl v1) v2)\n (sem_rec (sem g) (sem h1) (sem h1) l (tl v1) v2)
l : list bool
a : bool
g,h0,h1 : BC
v1,v2 : list (list bool)
*****
eq (if a then sem h1 (cons l (tl v1)) (cons (sem_rec (sem g) (sem h0) (sem h1) l (tl v1) v2) v2) else sem h0 (cons l (tl v1)) (cons (sem_rec (sem g) (sem h0) (sem h1) l (tl v1) v2) v2)) (if a then sem h1 (cons l (tl v1)) (cons (sem_rec (sem g) (sem h1) (sem h1) l (tl v1) v2) v2) else sem h1 (cons l (tl v1)) (cons (sem_rec (sem g) (sem h1) (sem h1) l (tl v1) v2) v2))
+++++
rewrite andb_true_iff in H.
-----
Lemma rec2_correct v1 v2 g h0 h1 : unary (hd nil v1) = true -> sem (rec g h0 h1) v1 v2 = sem (rec2 g h1) v1 v2.
Proof.
intros.
simpl.
revert H.
induction (hd nil v1).
simpl.
trivial.
intros.
rewrite andb_true_iff in H.

*****
H : and (eq (id a) true) (eq (unary l) true)
IHl : forall _ : eq (unary l) true,\neq (sem_rec (sem g) (sem h0) (sem h1) l (tl v1) v2)\n (sem_rec (sem g) (sem h1) (sem h1) l (tl v1) v2)
l : list bool
a : bool
g,h0,h1 : BC
v1,v2 : list (list bool)
*****
eq (if a then sem h1 (cons l (tl v1)) (cons (sem_rec (sem g) (sem h0) (sem h1) l (tl v1) v2) v2) else sem h0 (cons l (tl v1)) (cons (sem_rec (sem g) (sem h0) (sem h1) l (tl v1) v2) v2)) (if a then sem h1 (cons l (tl v1)) (cons (sem_rec (sem g) (sem h1) (sem h1) l (tl v1) v2) v2) else sem h1 (cons l (tl v1)) (cons (sem_rec (sem g) (sem h1) (sem h1) l (tl v1) v2) v2))
+++++
decompose [and] H.
-----
Lemma rec2_correct v1 v2 g h0 h1 : unary (hd nil v1) = true -> sem (rec g h0 h1) v1 v2 = sem (rec2 g h1) v1 v2.
Proof.
intros.
simpl.
revert H.
induction (hd nil v1).
simpl.
trivial.
intros.
rewrite andb_true_iff in H.
decompose [and] H.

*****
H1 : eq (unary l) true
H0 : eq (id a) true
H : and (eq (id a) true) (eq (unary l) true)
IHl : forall _ : eq (unary l) true,\neq (sem_rec (sem g) (sem h0) (sem h1) l (tl v1) v2)\n (sem_rec (sem g) (sem h1) (sem h1) l (tl v1) v2)
l : list bool
a : bool
g,h0,h1 : BC
v1,v2 : list (list bool)
*****
eq (if a then sem h1 (cons l (tl v1)) (cons (sem_rec (sem g) (sem h0) (sem h1) l (tl v1) v2) v2) else sem h0 (cons l (tl v1)) (cons (sem_rec (sem g) (sem h0) (sem h1) l (tl v1) v2) v2)) (if a then sem h1 (cons l (tl v1)) (cons (sem_rec (sem g) (sem h1) (sem h1) l (tl v1) v2) v2) else sem h1 (cons l (tl v1)) (cons (sem_rec (sem g) (sem h1) (sem h1) l (tl v1) v2) v2))
+++++
clear H.
-----
Lemma rec2_correct v1 v2 g h0 h1 : unary (hd nil v1) = true -> sem (rec g h0 h1) v1 v2 = sem (rec2 g h1) v1 v2.
Proof.
intros.
simpl.
revert H.
induction (hd nil v1).
simpl.
trivial.
intros.
rewrite andb_true_iff in H.
decompose [and] H.
clear H.

*****
H1 : eq (unary l) true
H0 : eq (id a) true
IHl : forall _ : eq (unary l) true,\neq (sem_rec (sem g) (sem h0) (sem h1) l (tl v1) v2)\n (sem_rec (sem g) (sem h1) (sem h1) l (tl v1) v2)
l : list bool
a : bool
g,h0,h1 : BC
v1,v2 : list (list bool)
*****
eq (if a then sem h1 (cons l (tl v1)) (cons (sem_rec (sem g) (sem h0) (sem h1) l (tl v1) v2) v2) else sem h0 (cons l (tl v1)) (cons (sem_rec (sem g) (sem h0) (sem h1) l (tl v1) v2) v2)) (if a then sem h1 (cons l (tl v1)) (cons (sem_rec (sem g) (sem h1) (sem h1) l (tl v1) v2) v2) else sem h1 (cons l (tl v1)) (cons (sem_rec (sem g) (sem h1) (sem h1) l (tl v1) v2) v2))
+++++
destruct a.
-----
Lemma rec2_correct v1 v2 g h0 h1 : unary (hd nil v1) = true -> sem (rec g h0 h1) v1 v2 = sem (rec2 g h1) v1 v2.
Proof.
intros.
simpl.
revert H.
induction (hd nil v1).
simpl.
trivial.
intros.
rewrite andb_true_iff in H.
decompose [and] H.
clear H.
destruct a.

*****
H1 : eq (unary l) true
H0 : eq (id true) true
IHl : forall _ : eq (unary l) true,\neq (sem_rec (sem g) (sem h0) (sem h1) l (tl v1) v2)\n (sem_rec (sem g) (sem h1) (sem h1) l (tl v1) v2)
l : list bool
g,h0,h1 : BC
v1,v2 : list (list bool)
*****
eq (sem h1 (cons l (tl v1)) (cons (sem_rec (sem g) (sem h0) (sem h1) l (tl v1) v2) v2)) (sem h1 (cons l (tl v1)) (cons (sem_rec (sem g) (sem h1) (sem h1) l (tl v1) v2) v2))
+++++
rewrite IHl.
-----
Lemma rec2_correct v1 v2 g h0 h1 : unary (hd nil v1) = true -> sem (rec g h0 h1) v1 v2 = sem (rec2 g h1) v1 v2.
Proof.
intros.
simpl.
revert H.
induction (hd nil v1).
simpl.
trivial.
intros.
rewrite andb_true_iff in H.
decompose [and] H.
clear H.
destruct a.
rewrite IHl.

*****
H1 : eq (unary l) true
H0 : eq (id true) true
IHl : forall _ : eq (unary l) true,\neq (sem_rec (sem g) (sem h0) (sem h1) l (tl v1) v2)\n (sem_rec (sem g) (sem h1) (sem h1) l (tl v1) v2)
l : list bool
g,h0,h1 : BC
v1,v2 : list (list bool)
*****
eq (sem h1 (cons l (tl v1)) (cons (sem_rec (sem g) (sem h1) (sem h1) l (tl v1) v2) v2)) (sem h1 (cons l (tl v1)) (cons (sem_rec (sem g) (sem h1) (sem h1) l (tl v1) v2) v2))
+++++
trivial.
-----
Lemma rec2_correct v1 v2 g h0 h1 : unary (hd nil v1) = true -> sem (rec g h0 h1) v1 v2 = sem (rec2 g h1) v1 v2.
Proof.
intros.
simpl.
revert H.
induction (hd nil v1).
simpl.
trivial.
intros.
rewrite andb_true_iff in H.
decompose [and] H.
clear H.
destruct a.
rewrite IHl.

*****
H1 : eq (unary l) true
H0 : eq (id true) true
IHl : forall _ : eq (unary l) true,\neq (sem_rec (sem g) (sem h0) (sem h1) l (tl v1) v2)\n (sem_rec (sem g) (sem h1) (sem h1) l (tl v1) v2)
l : list bool
g,h0,h1 : BC
v1,v2 : list (list bool)
*****
eq (unary l) true
+++++
trivial.
-----
Lemma rec2_correct v1 v2 g h0 h1 : unary (hd nil v1) = true -> sem (rec g h0 h1) v1 v2 = sem (rec2 g h1) v1 v2.
Proof.
intros.
simpl.
revert H.
induction (hd nil v1).
simpl.
trivial.
intros.
rewrite andb_true_iff in H.
decompose [and] H.
clear H.
destruct a.

*****
H1 : eq (unary l) true
H0 : eq (id false) true
IHl : forall _ : eq (unary l) true,\neq (sem_rec (sem g) (sem h0) (sem h1) l (tl v1) v2)\n (sem_rec (sem g) (sem h1) (sem h1) l (tl v1) v2)
l : list bool
g,h0,h1 : BC
v1,v2 : list (list bool)
*****
eq (sem h0 (cons l (tl v1)) (cons (sem_rec (sem g) (sem h0) (sem h1) l (tl v1) v2) v2)) (sem h1 (cons l (tl v1)) (cons (sem_rec (sem g) (sem h1) (sem h1) l (tl v1) v2) v2))
+++++
unfold id in H0.
-----
Lemma rec2_correct v1 v2 g h0 h1 : unary (hd nil v1) = true -> sem (rec g h0 h1) v1 v2 = sem (rec2 g h1) v1 v2.
Proof.
intros.
simpl.
revert H.
induction (hd nil v1).
simpl.
trivial.
intros.
rewrite andb_true_iff in H.
decompose [and] H.
clear H.
destruct a.
unfold id in H0.

*****
H1 : eq (unary l) true
H0 : eq false true
IHl : forall _ : eq (unary l) true,\neq (sem_rec (sem g) (sem h0) (sem h1) l (tl v1) v2)\n (sem_rec (sem g) (sem h1) (sem h1) l (tl v1) v2)
l : list bool
g,h0,h1 : BC
v1,v2 : list (list bool)
*****
eq (sem h0 (cons l (tl v1)) (cons (sem_rec (sem g) (sem h0) (sem h1) l (tl v1) v2) v2)) (sem h1 (cons l (tl v1)) (cons (sem_rec (sem g) (sem h1) (sem h1) l (tl v1) v2) v2))
+++++
discriminate.
-----
Lemma rec2_correct v1 v2 g h0 h1 : unary (hd nil v1) = true -> sem (rec g h0 h1) v1 v2 = sem (rec2 g h1) v1 v2.
Proof.
intros.
simpl.
revert H.
induction (hd nil v1).

*****

*****

+++++
Qed.
-----
Lemma rec2_simpl g h i z l1 l2 :\n  sem (rec2 g h) ((i :: z) :: l1) l2 = sem h (z :: l1) (sem_rec (sem g) (sem h) (sem h) z l1 l2 :: l2).
-----
Lemma rec2_simpl g h i z l1 l2 : sem (rec2 g h) ((i :: z) :: l1) l2 = sem h (z :: l1) (sem_rec (sem g) (sem h) (sem h) z l1 l2 :: l2).

*****
l1,l2 : list (list bool)
z : list bool
i : bool
g,h : BC
*****
eq (sem (rec2 g h) (cons (cons i z) l1) l2) (sem h (cons z l1) (cons (sem_rec (sem g) (sem h) (sem h) z l1 l2) l2))
+++++
Proof.
-----
Lemma rec2_simpl g h i z l1 l2 : sem (rec2 g h) ((i :: z) :: l1) l2 = sem h (z :: l1) (sem_rec (sem g) (sem h) (sem h) z l1 l2 :: l2).
Proof.

*****
l1,l2 : list (list bool)
z : list bool
i : bool
g,h : BC
*****
eq (sem (rec2 g h) (cons (cons i z) l1) l2) (sem h (cons z l1) (cons (sem_rec (sem g) (sem h) (sem h) z l1 l2) l2))
+++++
intros.
-----
Lemma rec2_simpl g h i z l1 l2 : sem (rec2 g h) ((i :: z) :: l1) l2 = sem h (z :: l1) (sem_rec (sem g) (sem h) (sem h) z l1 l2 :: l2).
Proof.
intros.

*****
l1,l2 : list (list bool)
z : list bool
i : bool
g,h : BC
*****
eq (sem (rec2 g h) (cons (cons i z) l1) l2) (sem h (cons z l1) (cons (sem_rec (sem g) (sem h) (sem h) z l1 l2) l2))
+++++
simpl.
-----
Lemma rec2_simpl g h i z l1 l2 : sem (rec2 g h) ((i :: z) :: l1) l2 = sem h (z :: l1) (sem_rec (sem g) (sem h) (sem h) z l1 l2 :: l2).
Proof.
intros.
simpl.

*****
l1,l2 : list (list bool)
z : list bool
i : bool
g,h : BC
*****
eq (if i then sem h (cons z l1) (cons (sem_rec (sem g) (sem h) (sem h) z l1 l2) l2) else sem h (cons z l1) (cons (sem_rec (sem g) (sem h) (sem h) z l1 l2) l2)) (sem h (cons z l1) (cons (sem_rec (sem g) (sem h) (sem h) z l1 l2) l2))
+++++
case i.
-----
Lemma rec2_simpl g h i z l1 l2 : sem (rec2 g h) ((i :: z) :: l1) l2 = sem h (z :: l1) (sem_rec (sem g) (sem h) (sem h) z l1 l2 :: l2).
Proof.
intros.
simpl.
case i.

*****
l1,l2 : list (list bool)
z : list bool
i : bool
g,h : BC
*****
eq (sem h (cons z l1) (cons (sem_rec (sem g) (sem h) (sem h) z l1 l2) l2)) (sem h (cons z l1) (cons (sem_rec (sem g) (sem h) (sem h) z l1 l2) l2))
+++++
trivial.
-----
Lemma rec2_simpl g h i z l1 l2 : sem (rec2 g h) ((i :: z) :: l1) l2 = sem h (z :: l1) (sem_rec (sem g) (sem h) (sem h) z l1 l2 :: l2).
Proof.
intros.
simpl.
case i.

*****
l1,l2 : list (list bool)
z : list bool
i : bool
g,h : BC
*****
eq (sem h (cons z l1) (cons (sem_rec (sem g) (sem h) (sem h) z l1 l2) l2)) (sem h (cons z l1) (cons (sem_rec (sem g) (sem h) (sem h) z l1 l2) l2))
+++++
trivial.
-----
Lemma rec2_simpl g h i z l1 l2 : sem (rec2 g h) ((i :: z) :: l1) l2 = sem h (z :: l1) (sem_rec (sem g) (sem h) (sem h) z l1 l2 :: l2).
Proof.
intros.
simpl.
case i.

*****

*****

+++++
Qed.
-----
Lemma rec2_sem_rec g h z l1 l2 :\n  sem (rec2 g h) (z :: l1) l2 = sem_rec (sem g) (sem h) (sem h) z l1 l2.
-----
Lemma rec2_sem_rec g h z l1 l2 : sem (rec2 g h) (z :: l1) l2 = sem_rec (sem g) (sem h) (sem h) z l1 l2.

*****
l1,l2 : list (list bool)
z : list bool
g,h : BC
*****
eq (sem (rec2 g h) (cons z l1) l2) (sem_rec (sem g) (sem h) (sem h) z l1 l2)
+++++
Proof.
-----
Lemma rec2_sem_rec g h z l1 l2 : sem (rec2 g h) (z :: l1) l2 = sem_rec (sem g) (sem h) (sem h) z l1 l2.
Proof.

*****
l1,l2 : list (list bool)
z : list bool
g,h : BC
*****
eq (sem (rec2 g h) (cons z l1) l2) (sem_rec (sem g) (sem h) (sem h) z l1 l2)
+++++
intros.
-----
Lemma rec2_sem_rec g h z l1 l2 : sem (rec2 g h) (z :: l1) l2 = sem_rec (sem g) (sem h) (sem h) z l1 l2.
Proof.
intros.

*****
l1,l2 : list (list bool)
z : list bool
g,h : BC
*****
eq (sem (rec2 g h) (cons z l1) l2) (sem_rec (sem g) (sem h) (sem h) z l1 l2)
+++++
simpl.
-----
Lemma rec2_sem_rec g h z l1 l2 : sem (rec2 g h) (z :: l1) l2 = sem_rec (sem g) (sem h) (sem h) z l1 l2.
Proof.
intros.
simpl.

*****
l1,l2 : list (list bool)
z : list bool
g,h : BC
*****
eq (sem_rec (sem g) (sem h) (sem h) z l1 l2) (sem_rec (sem g) (sem h) (sem h) z l1 l2)
+++++
trivial.
-----
Lemma rec2_sem_rec g h z l1 l2 : sem (rec2 g h) (z :: l1) l2 = sem_rec (sem g) (sem h) (sem h) z l1 l2.
Proof.
intros.
simpl.
trivial.

*****

*****

+++++
Qed.
-----
Definition cond2 n s x g h0 h1 : BC :=\n  comp n s\n    cond nil [\n      x;\n      g;\n      comp n s h0\n        (map (proj n 0) (seq 0 n))\n        (comp n s pred nil [x] :: map (proj n s) (seq n s));\n      comp n s h1\n        (map (proj n 0) (seq 0 n))\n        (comp n s pred nil [x] :: map (proj n s) (seq n s))\n    ].
-----
Lemma arities_cond2 n s x g h0 h1\n  (Hx : arities x = ok_arities n s)\n  (Hg : arities g = ok_arities n s)\n  (Hh0 : arities h0 = ok_arities n (S s))\n  (Hh1 : arities h1 = ok_arities n (S s)) :\n  arities (cond2 n s x g h0 h1) = ok_arities n s.
-----
Lemma arities_cond2 n s x g h0 h1 (Hx : arities x = ok_arities n s) (Hg : arities g = ok_arities n s) (Hh0 : arities h0 = ok_arities n (S s)) (Hh1 : arities h1 = ok_arities n (S s)) : arities (cond2 n s x g h0 h1) = ok_arities n s.

*****
Hh1 : eq (arities h1) (ok_arities n (S s))
Hh0 : eq (arities h0) (ok_arities n (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n s)
x,g,h0,h1 : BC
n,s : nat
*****
eq (arities (cond2 n s x g h0 h1)) (ok_arities n s)
+++++
Proof.
-----
Lemma arities_cond2 n s x g h0 h1 (Hx : arities x = ok_arities n s) (Hg : arities g = ok_arities n s) (Hh0 : arities h0 = ok_arities n (S s)) (Hh1 : arities h1 = ok_arities n (S s)) : arities (cond2 n s x g h0 h1) = ok_arities n s.
Proof.

*****
Hh1 : eq (arities h1) (ok_arities n (S s))
Hh0 : eq (arities h0) (ok_arities n (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n s)
x,g,h0,h1 : BC
n,s : nat
*****
eq (arities (cond2 n s x g h0 h1)) (ok_arities n s)
+++++
simpl.
-----
Lemma arities_cond2 n s x g h0 h1 (Hx : arities x = ok_arities n s) (Hg : arities g = ok_arities n s) (Hh0 : arities h0 = ok_arities n (S s)) (Hh1 : arities h1 = ok_arities n (S s)) : arities (cond2 n s x g h0 h1) = ok_arities n s.
Proof.
simpl.

*****
Hh1 : eq (arities h1) (ok_arities n (S s))
Hh0 : eq (arities h0) (ok_arities n (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n s)
x,g,h0,h1 : BC
n,s : nat
*****
eq (if andb (aeq (arities x) (ok_arities n s)) (andb (aeq (arities g) (ok_arities n s)) (andb (aeq match arities h0 with | error_rec a a0 a1 => error_comp (error_rec a a0 a1) (map arities (map (proj n O) (seq O n))) (cons (if andb (aeq (arities x) (ok_arities n s)) true then ok_arities n s else error_comp (ok_arities O (S O)) nil (cons (arities x) nil)) (map arities (map (proj n s) (seq n s)))) | error_comp a l l0 => error_comp (error_comp a l l0) (map arities (map (proj n O) (seq O n))) (cons (if andb (aeq (arities x) (ok_arities n s)) true then ok_arities n s else error_comp (ok_arities O (S O)) nil (cons (arities x) nil)) (map arities (map (proj n s) (seq n s)))) | error_proj n0 n1 n2 => error_comp (error_proj n0 n1 n2) (map arities (map (proj n O) (seq O n))) (cons (if andb (aeq (arities x) (ok_arities n s)) true then ok_arities n s else error_comp (ok_arities O (S O)) nil (cons (arities x) nil)) (map arities (map (proj n s) (seq n s)))) | ok_arities hn hs => if andb (andb (andb (Nat.eqb hn (length (map (proj n O) (seq O n)))) (Nat.eqb hs (S (length (map (proj n s) (seq n s)))))) (forallb (fun ne : BC => aeq (arities ne) (ok_arities n O)) (map (proj n O) (seq O n)))) (andb (aeq (if andb (aeq (arities x) (ok_arities n s)) true then ok_arities n s else error_comp (ok_arities O (S O)) nil (cons (arities x) nil)) (ok_arities n s)) (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s)))) then ok_arities n s else error_comp (ok_arities hn hs) (map arities (map (proj n O) (seq O n))) (cons (if andb (aeq (arities x) (ok_arities n s)) true then ok_arities n s else error_comp (ok_arities O (S O)) nil (cons (arities x) nil)) (map arities (map (proj n s) (seq n s)))) end (ok_arities n s)) (andb (aeq match arities h1 with | error_rec a a0 a1 => error_comp (error_rec a a0 a1) (map arities (map (proj n O) (seq O n))) (cons (if andb (aeq (arities x) (ok_arities n s)) true then ok_arities n s else error_comp (ok_arities O (S O)) nil (cons (arities x) nil)) (map arities (map (proj n s) (seq n s)))) | error_comp a l l0 => error_comp (error_comp a l l0) (map arities (map (proj n O) (seq O n))) (cons (if andb (aeq (arities x) (ok_arities n s)) true then ok_arities n s else error_comp (ok_arities O (S O)) nil (cons (arities x) nil)) (map arities (map (proj n s) (seq n s)))) | error_proj n0 n1 n2 => error_comp (error_proj n0 n1 n2) (map arities (map (proj n O) (seq O n))) (cons (if andb (aeq (arities x) (ok_arities n s)) true then ok_arities n s else error_comp (ok_arities O (S O)) nil (cons (arities x) nil)) (map arities (map (proj n s) (seq n s)))) | ok_arities hn hs => if andb (andb (andb (Nat.eqb hn (length (map (proj n O) (seq O n)))) (Nat.eqb hs (S (length (map (proj n s) (seq n s)))))) (forallb (fun ne : BC => aeq (arities ne) (ok_arities n O)) (map (proj n O) (seq O n)))) (andb (aeq (if andb (aeq (arities x) (ok_arities n s)) true then ok_arities n s else error_comp (ok_arities O (S O)) nil (cons (arities x) nil)) (ok_arities n s)) (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s)))) then ok_arities n s else error_comp (ok_arities hn hs) (map arities (map (proj n O) (seq O n))) (cons (if andb (aeq (arities x) (ok_arities n s)) true then ok_arities n s else error_comp (ok_arities O (S O)) nil (cons (arities x) nil)) (map arities (map (proj n s) (seq n s)))) end (ok_arities n s)) true))) then ok_arities n s else error_comp (ok_arities O (S (S (S (S O))))) nil (cons (arities x) (cons (arities g) (cons match arities h0 with | error_rec a a0 a1 => error_comp (error_rec a a0 a1) (map arities (map (proj n O) (seq O n))) (cons (if andb (aeq (arities x) (ok_arities n s)) true then ok_arities n s else error_comp (ok_arities O (S O)) nil (cons (arities x) nil)) (map arities (map (proj n s) (seq n s)))) | error_comp a l l0 => error_comp (error_comp a l l0) (map arities (map (proj n O) (seq O n))) (cons (if andb (aeq (arities x) (ok_arities n s)) true then ok_arities n s else error_comp (ok_arities O (S O)) nil (cons (arities x) nil)) (map arities (map (proj n s) (seq n s)))) | error_proj n0 n1 n2 => error_comp (error_proj n0 n1 n2) (map arities (map (proj n O) (seq O n))) (cons (if andb (aeq (arities x) (ok_arities n s)) true then ok_arities n s else error_comp (ok_arities O (S O)) nil (cons (arities x) nil)) (map arities (map (proj n s) (seq n s)))) | ok_arities hn hs => if andb (andb (andb (Nat.eqb hn (length (map (proj n O) (seq O n)))) (Nat.eqb hs (S (length (map (proj n s) (seq n s)))))) (forallb (fun ne : BC => aeq (arities ne) (ok_arities n O)) (map (proj n O) (seq O n)))) (andb (aeq (if andb (aeq (arities x) (ok_arities n s)) true then ok_arities n s else error_comp (ok_arities O (S O)) nil (cons (arities x) nil)) (ok_arities n s)) (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s)))) then ok_arities n s else error_comp (ok_arities hn hs) (map arities (map (proj n O) (seq O n))) (cons (if andb (aeq (arities x) (ok_arities n s)) true then ok_arities n s else error_comp (ok_arities O (S O)) nil (cons (arities x) nil)) (map arities (map (proj n s) (seq n s)))) end (cons match arities h1 with | error_rec a a0 a1 => error_comp (error_rec a a0 a1) (map arities (map (proj n O) (seq O n))) (cons (if andb (aeq (arities x) (ok_arities n s)) true then ok_arities n s else error_comp (ok_arities O (S O)) nil (cons (arities x) nil)) (map arities (map (proj n s) (seq n s)))) | error_comp a l l0 => error_comp (error_comp a l l0) (map arities (map (proj n O) (seq O n))) (cons (if andb (aeq (arities x) (ok_arities n s)) true then ok_arities n s else error_comp (ok_arities O (S O)) nil (cons (arities x) nil)) (map arities (map (proj n s) (seq n s)))) | error_proj n0 n1 n2 => error_comp (error_proj n0 n1 n2) (map arities (map (proj n O) (seq O n))) (cons (if andb (aeq (arities x) (ok_arities n s)) true then ok_arities n s else error_comp (ok_arities O (S O)) nil (cons (arities x) nil)) (map arities (map (proj n s) (seq n s)))) | ok_arities hn hs => if andb (andb (andb (Nat.eqb hn (length (map (proj n O) (seq O n)))) (Nat.eqb hs (S (length (map (proj n s) (seq n s)))))) (forallb (fun ne : BC => aeq (arities ne) (ok_arities n O)) (map (proj n O) (seq O n)))) (andb (aeq (if andb (aeq (arities x) (ok_arities n s)) true then ok_arities n s else error_comp (ok_arities O (S O)) nil (cons (arities x) nil)) (ok_arities n s)) (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s)))) then ok_arities n s else error_comp (ok_arities hn hs) (map arities (map (proj n O) (seq O n))) (cons (if andb (aeq (arities x) (ok_arities n s)) true then ok_arities n s else error_comp (ok_arities O (S O)) nil (cons (arities x) nil)) (map arities (map (proj n s) (seq n s)))) end nil))))) (ok_arities n s)
+++++
rewrite Hx, Hg, Hh0, Hh1.
-----
Lemma arities_cond2 n s x g h0 h1 (Hx : arities x = ok_arities n s) (Hg : arities g = ok_arities n s) (Hh0 : arities h0 = ok_arities n (S s)) (Hh1 : arities h1 = ok_arities n (S s)) : arities (cond2 n s x g h0 h1) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh0, Hh1.

*****
Hh1 : eq (arities h1) (ok_arities n (S s))
Hh0 : eq (arities h0) (ok_arities n (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n s)
x,g,h0,h1 : BC
n,s : nat
*****
eq (if andb (aeq (ok_arities n s) (ok_arities n s)) (andb (aeq (ok_arities n s) (ok_arities n s)) (andb (aeq (if andb (andb (andb (Nat.eqb n (length (map (proj n O) (seq O n)))) (Nat.eqb (S s) (S (length (map (proj n s) (seq n s)))))) (forallb (fun ne : BC => aeq (arities ne) (ok_arities n O)) (map (proj n O) (seq O n)))) (andb (aeq (if andb (aeq (ok_arities n s) (ok_arities n s)) true then ok_arities n s else error_comp (ok_arities O (S O)) nil (cons (ok_arities n s) nil)) (ok_arities n s)) (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s)))) then ok_arities n s else error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (if andb (aeq (ok_arities n s) (ok_arities n s)) true then ok_arities n s else error_comp (ok_arities O (S O)) nil (cons (ok_arities n s) nil)) (map arities (map (proj n s) (seq n s))))) (ok_arities n s)) (andb (aeq (if andb (andb (andb (Nat.eqb n (length (map (proj n O) (seq O n)))) (Nat.eqb (S s) (S (length (map (proj n s) (seq n s)))))) (forallb (fun ne : BC => aeq (arities ne) (ok_arities n O)) (map (proj n O) (seq O n)))) (andb (aeq (if andb (aeq (ok_arities n s) (ok_arities n s)) true then ok_arities n s else error_comp (ok_arities O (S O)) nil (cons (ok_arities n s) nil)) (ok_arities n s)) (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s)))) then ok_arities n s else error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (if andb (aeq (ok_arities n s) (ok_arities n s)) true then ok_arities n s else error_comp (ok_arities O (S O)) nil (cons (ok_arities n s) nil)) (map arities (map (proj n s) (seq n s))))) (ok_arities n s)) true))) then ok_arities n s else error_comp (ok_arities O (S (S (S (S O))))) nil (cons (ok_arities n s) (cons (ok_arities n s) (cons (if andb (andb (andb (Nat.eqb n (length (map (proj n O) (seq O n)))) (Nat.eqb (S s) (S (length (map (proj n s) (seq n s)))))) (forallb (fun ne : BC => aeq (arities ne) (ok_arities n O)) (map (proj n O) (seq O n)))) (andb (aeq (if andb (aeq (ok_arities n s) (ok_arities n s)) true then ok_arities n s else error_comp (ok_arities O (S O)) nil (cons (ok_arities n s) nil)) (ok_arities n s)) (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s)))) then ok_arities n s else error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (if andb (aeq (ok_arities n s) (ok_arities n s)) true then ok_arities n s else error_comp (ok_arities O (S O)) nil (cons (ok_arities n s) nil)) (map arities (map (proj n s) (seq n s))))) (cons (if andb (andb (andb (Nat.eqb n (length (map (proj n O) (seq O n)))) (Nat.eqb (S s) (S (length (map (proj n s) (seq n s)))))) (forallb (fun ne : BC => aeq (arities ne) (ok_arities n O)) (map (proj n O) (seq O n)))) (andb (aeq (if andb (aeq (ok_arities n s) (ok_arities n s)) true then ok_arities n s else error_comp (ok_arities O (S O)) nil (cons (ok_arities n s) nil)) (ok_arities n s)) (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s)))) then ok_arities n s else error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (if andb (aeq (ok_arities n s) (ok_arities n s)) true then ok_arities n s else error_comp (ok_arities O (S O)) nil (cons (ok_arities n s) nil)) (map arities (map (proj n s) (seq n s))))) nil))))) (ok_arities n s)
+++++
simpl.
-----
Lemma arities_cond2 n s x g h0 h1 (Hx : arities x = ok_arities n s) (Hg : arities g = ok_arities n s) (Hh0 : arities h0 = ok_arities n (S s)) (Hh1 : arities h1 = ok_arities n (S s)) : arities (cond2 n s x g h0 h1) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh0, Hh1.
simpl.

*****
Hh1 : eq (arities h1) (ok_arities n (S s))
Hh0 : eq (arities h0) (ok_arities n (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n s)
x,g,h0,h1 : BC
n,s : nat
*****
eq (if andb (andb (Nat.eqb n n) (Nat.eqb s s)) (andb (andb (Nat.eqb n n) (Nat.eqb s s)) (andb (aeq (if andb (andb (andb (Nat.eqb n (length (map (proj n O) (seq O n)))) (Nat.eqb s (length (map (proj n s) (seq n s))))) (forallb (fun ne : BC => aeq (arities ne) (ok_arities n O)) (map (proj n O) (seq O n)))) (andb (aeq (if andb (andb (Nat.eqb n n) (Nat.eqb s s)) true then ok_arities n s else error_comp (ok_arities O (S O)) nil (cons (ok_arities n s) nil)) (ok_arities n s)) (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s)))) then ok_arities n s else error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (if andb (andb (Nat.eqb n n) (Nat.eqb s s)) true then ok_arities n s else error_comp (ok_arities O (S O)) nil (cons (ok_arities n s) nil)) (map arities (map (proj n s) (seq n s))))) (ok_arities n s)) (andb (aeq (if andb (andb (andb (Nat.eqb n (length (map (proj n O) (seq O n)))) (Nat.eqb s (length (map (proj n s) (seq n s))))) (forallb (fun ne : BC => aeq (arities ne) (ok_arities n O)) (map (proj n O) (seq O n)))) (andb (aeq (if andb (andb (Nat.eqb n n) (Nat.eqb s s)) true then ok_arities n s else error_comp (ok_arities O (S O)) nil (cons (ok_arities n s) nil)) (ok_arities n s)) (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s)))) then ok_arities n s else error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (if andb (andb (Nat.eqb n n) (Nat.eqb s s)) true then ok_arities n s else error_comp (ok_arities O (S O)) nil (cons (ok_arities n s) nil)) (map arities (map (proj n s) (seq n s))))) (ok_arities n s)) true))) then ok_arities n s else error_comp (ok_arities O (S (S (S (S O))))) nil (cons (ok_arities n s) (cons (ok_arities n s) (cons (if andb (andb (andb (Nat.eqb n (length (map (proj n O) (seq O n)))) (Nat.eqb s (length (map (proj n s) (seq n s))))) (forallb (fun ne : BC => aeq (arities ne) (ok_arities n O)) (map (proj n O) (seq O n)))) (andb (aeq (if andb (andb (Nat.eqb n n) (Nat.eqb s s)) true then ok_arities n s else error_comp (ok_arities O (S O)) nil (cons (ok_arities n s) nil)) (ok_arities n s)) (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s)))) then ok_arities n s else error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (if andb (andb (Nat.eqb n n) (Nat.eqb s s)) true then ok_arities n s else error_comp (ok_arities O (S O)) nil (cons (ok_arities n s) nil)) (map arities (map (proj n s) (seq n s))))) (cons (if andb (andb (andb (Nat.eqb n (length (map (proj n O) (seq O n)))) (Nat.eqb s (length (map (proj n s) (seq n s))))) (forallb (fun ne : BC => aeq (arities ne) (ok_arities n O)) (map (proj n O) (seq O n)))) (andb (aeq (if andb (andb (Nat.eqb n n) (Nat.eqb s s)) true then ok_arities n s else error_comp (ok_arities O (S O)) nil (cons (ok_arities n s) nil)) (ok_arities n s)) (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s)))) then ok_arities n s else error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (if andb (andb (Nat.eqb n n) (Nat.eqb s s)) true then ok_arities n s else error_comp (ok_arities O (S O)) nil (cons (ok_arities n s) nil)) (map arities (map (proj n s) (seq n s))))) nil))))) (ok_arities n s)
+++++
do 2 rewrite <- beq_nat_refl.
-----
Lemma arities_cond2 n s x g h0 h1 (Hx : arities x = ok_arities n s) (Hg : arities g = ok_arities n s) (Hh0 : arities h0 = ok_arities n (S s)) (Hh1 : arities h1 = ok_arities n (S s)) : arities (cond2 n s x g h0 h1) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh0, Hh1.
simpl.
do 2 rewrite <- beq_nat_refl.

*****
Hh1 : eq (arities h1) (ok_arities n (S s))
Hh0 : eq (arities h0) (ok_arities n (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n s)
x,g,h0,h1 : BC
n,s : nat
*****
eq (if andb (andb true true) (andb (andb true true) (andb (aeq (if andb (andb (andb (Nat.eqb n (length (map (proj n O) (seq O n)))) (Nat.eqb s (length (map (proj n s) (seq n s))))) (forallb (fun ne : BC => aeq (arities ne) (ok_arities n O)) (map (proj n O) (seq O n)))) (andb (aeq (if andb (andb true true) true then ok_arities n s else error_comp (ok_arities O (S O)) nil (cons (ok_arities n s) nil)) (ok_arities n s)) (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s)))) then ok_arities n s else error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (if andb (andb true true) true then ok_arities n s else error_comp (ok_arities O (S O)) nil (cons (ok_arities n s) nil)) (map arities (map (proj n s) (seq n s))))) (ok_arities n s)) (andb (aeq (if andb (andb (andb (Nat.eqb n (length (map (proj n O) (seq O n)))) (Nat.eqb s (length (map (proj n s) (seq n s))))) (forallb (fun ne : BC => aeq (arities ne) (ok_arities n O)) (map (proj n O) (seq O n)))) (andb (aeq (if andb (andb true true) true then ok_arities n s else error_comp (ok_arities O (S O)) nil (cons (ok_arities n s) nil)) (ok_arities n s)) (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s)))) then ok_arities n s else error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (if andb (andb true true) true then ok_arities n s else error_comp (ok_arities O (S O)) nil (cons (ok_arities n s) nil)) (map arities (map (proj n s) (seq n s))))) (ok_arities n s)) true))) then ok_arities n s else error_comp (ok_arities O (S (S (S (S O))))) nil (cons (ok_arities n s) (cons (ok_arities n s) (cons (if andb (andb (andb (Nat.eqb n (length (map (proj n O) (seq O n)))) (Nat.eqb s (length (map (proj n s) (seq n s))))) (forallb (fun ne : BC => aeq (arities ne) (ok_arities n O)) (map (proj n O) (seq O n)))) (andb (aeq (if andb (andb true true) true then ok_arities n s else error_comp (ok_arities O (S O)) nil (cons (ok_arities n s) nil)) (ok_arities n s)) (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s)))) then ok_arities n s else error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (if andb (andb true true) true then ok_arities n s else error_comp (ok_arities O (S O)) nil (cons (ok_arities n s) nil)) (map arities (map (proj n s) (seq n s))))) (cons (if andb (andb (andb (Nat.eqb n (length (map (proj n O) (seq O n)))) (Nat.eqb s (length (map (proj n s) (seq n s))))) (forallb (fun ne : BC => aeq (arities ne) (ok_arities n O)) (map (proj n O) (seq O n)))) (andb (aeq (if andb (andb true true) true then ok_arities n s else error_comp (ok_arities O (S O)) nil (cons (ok_arities n s) nil)) (ok_arities n s)) (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s)))) then ok_arities n s else error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (if andb (andb true true) true then ok_arities n s else error_comp (ok_arities O (S O)) nil (cons (ok_arities n s) nil)) (map arities (map (proj n s) (seq n s))))) nil))))) (ok_arities n s)
+++++
simpl.
-----
Lemma arities_cond2 n s x g h0 h1 (Hx : arities x = ok_arities n s) (Hg : arities g = ok_arities n s) (Hh0 : arities h0 = ok_arities n (S s)) (Hh1 : arities h1 = ok_arities n (S s)) : arities (cond2 n s x g h0 h1) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh0, Hh1.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.

*****
Hh1 : eq (arities h1) (ok_arities n (S s))
Hh0 : eq (arities h0) (ok_arities n (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n s)
x,g,h0,h1 : BC
n,s : nat
*****
eq (if andb (aeq (if andb (andb (andb (Nat.eqb n (length (map (proj n O) (seq O n)))) (Nat.eqb s (length (map (proj n s) (seq n s))))) (forallb (fun ne : BC => aeq (arities ne) (ok_arities n O)) (map (proj n O) (seq O n)))) (andb (andb (Nat.eqb n n) (Nat.eqb s s)) (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s)))) then ok_arities n s else error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) (ok_arities n s)) (andb (aeq (if andb (andb (andb (Nat.eqb n (length (map (proj n O) (seq O n)))) (Nat.eqb s (length (map (proj n s) (seq n s))))) (forallb (fun ne : BC => aeq (arities ne) (ok_arities n O)) (map (proj n O) (seq O n)))) (andb (andb (Nat.eqb n n) (Nat.eqb s s)) (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s)))) then ok_arities n s else error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) (ok_arities n s)) true) then ok_arities n s else error_comp (ok_arities O (S (S (S (S O))))) nil (cons (ok_arities n s) (cons (ok_arities n s) (cons (if andb (andb (andb (Nat.eqb n (length (map (proj n O) (seq O n)))) (Nat.eqb s (length (map (proj n s) (seq n s))))) (forallb (fun ne : BC => aeq (arities ne) (ok_arities n O)) (map (proj n O) (seq O n)))) (andb (andb (Nat.eqb n n) (Nat.eqb s s)) (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s)))) then ok_arities n s else error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) (cons (if andb (andb (andb (Nat.eqb n (length (map (proj n O) (seq O n)))) (Nat.eqb s (length (map (proj n s) (seq n s))))) (forallb (fun ne : BC => aeq (arities ne) (ok_arities n O)) (map (proj n O) (seq O n)))) (andb (andb (Nat.eqb n n) (Nat.eqb s s)) (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s)))) then ok_arities n s else error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) nil))))) (ok_arities n s)
+++++
do 2 rewrite map_length, seq_length.
-----
Lemma arities_cond2 n s x g h0 h1 (Hx : arities x = ok_arities n s) (Hg : arities g = ok_arities n s) (Hh0 : arities h0 = ok_arities n (S s)) (Hh1 : arities h1 = ok_arities n (S s)) : arities (cond2 n s x g h0 h1) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh0, Hh1.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
do 2 rewrite map_length, seq_length.

*****
Hh1 : eq (arities h1) (ok_arities n (S s))
Hh0 : eq (arities h0) (ok_arities n (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n s)
x,g,h0,h1 : BC
n,s : nat
*****
eq (if andb (aeq (if andb (andb (andb (Nat.eqb n n) (Nat.eqb s s)) (forallb (fun ne : BC => aeq (arities ne) (ok_arities n O)) (map (proj n O) (seq O n)))) (andb (andb (Nat.eqb n n) (Nat.eqb s s)) (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s)))) then ok_arities n s else error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) (ok_arities n s)) (andb (aeq (if andb (andb (andb (Nat.eqb n n) (Nat.eqb s s)) (forallb (fun ne : BC => aeq (arities ne) (ok_arities n O)) (map (proj n O) (seq O n)))) (andb (andb (Nat.eqb n n) (Nat.eqb s s)) (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s)))) then ok_arities n s else error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) (ok_arities n s)) true) then ok_arities n s else error_comp (ok_arities O (S (S (S (S O))))) nil (cons (ok_arities n s) (cons (ok_arities n s) (cons (if andb (andb (andb (Nat.eqb n n) (Nat.eqb s s)) (forallb (fun ne : BC => aeq (arities ne) (ok_arities n O)) (map (proj n O) (seq O n)))) (andb (andb (Nat.eqb n n) (Nat.eqb s s)) (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s)))) then ok_arities n s else error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) (cons (if andb (andb (andb (Nat.eqb n n) (Nat.eqb s s)) (forallb (fun ne : BC => aeq (arities ne) (ok_arities n O)) (map (proj n O) (seq O n)))) (andb (andb (Nat.eqb n n) (Nat.eqb s s)) (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s)))) then ok_arities n s else error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) nil))))) (ok_arities n s)
+++++
do 2 rewrite <- beq_nat_refl.
-----
Lemma arities_cond2 n s x g h0 h1 (Hx : arities x = ok_arities n s) (Hg : arities g = ok_arities n s) (Hh0 : arities h0 = ok_arities n (S s)) (Hh1 : arities h1 = ok_arities n (S s)) : arities (cond2 n s x g h0 h1) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh0, Hh1.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
do 2 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.

*****
Hh1 : eq (arities h1) (ok_arities n (S s))
Hh0 : eq (arities h0) (ok_arities n (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n s)
x,g,h0,h1 : BC
n,s : nat
*****
eq (if andb (aeq (if andb (andb (andb true true) (forallb (fun ne : BC => aeq (arities ne) (ok_arities n O)) (map (proj n O) (seq O n)))) (andb (andb true true) (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s)))) then ok_arities n s else error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) (ok_arities n s)) (andb (aeq (if andb (andb (andb true true) (forallb (fun ne : BC => aeq (arities ne) (ok_arities n O)) (map (proj n O) (seq O n)))) (andb (andb true true) (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s)))) then ok_arities n s else error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) (ok_arities n s)) true) then ok_arities n s else error_comp (ok_arities O (S (S (S (S O))))) nil (cons (ok_arities n s) (cons (ok_arities n s) (cons (if andb (andb (andb true true) (forallb (fun ne : BC => aeq (arities ne) (ok_arities n O)) (map (proj n O) (seq O n)))) (andb (andb true true) (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s)))) then ok_arities n s else error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) (cons (if andb (andb (andb true true) (forallb (fun ne : BC => aeq (arities ne) (ok_arities n O)) (map (proj n O) (seq O n)))) (andb (andb true true) (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s)))) then ok_arities n s else error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) nil))))) (ok_arities n s)
+++++
simpl.
-----
Lemma arities_cond2 n s x g h0 h1 (Hx : arities x = ok_arities n s) (Hg : arities g = ok_arities n s) (Hh0 : arities h0 = ok_arities n (S s)) (Hh1 : arities h1 = ok_arities n (S s)) : arities (cond2 n s x g h0 h1) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh0, Hh1.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
do 2 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.

*****
Hh1 : eq (arities h1) (ok_arities n (S s))
Hh0 : eq (arities h0) (ok_arities n (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n s)
x,g,h0,h1 : BC
n,s : nat
*****
eq (if andb (aeq (if andb (forallb (fun ne : BC => aeq (arities ne) (ok_arities n O)) (map (proj n O) (seq O n))) (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s))) then ok_arities n s else error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) (ok_arities n s)) (andb (aeq (if andb (forallb (fun ne : BC => aeq (arities ne) (ok_arities n O)) (map (proj n O) (seq O n))) (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s))) then ok_arities n s else error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) (ok_arities n s)) true) then ok_arities n s else error_comp (ok_arities O (S (S (S (S O))))) nil (cons (ok_arities n s) (cons (ok_arities n s) (cons (if andb (forallb (fun ne : BC => aeq (arities ne) (ok_arities n O)) (map (proj n O) (seq O n))) (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s))) then ok_arities n s else error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) (cons (if andb (forallb (fun ne : BC => aeq (arities ne) (ok_arities n O)) (map (proj n O) (seq O n))) (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s))) then ok_arities n s else error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) nil))))) (ok_arities n s)
+++++
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
-----
Lemma arities_cond2 n s x g h0 h1 (Hx : arities x = ok_arities n s) (Hg : arities g = ok_arities n s) (Hh0 : arities h0 = ok_arities n (S s)) (Hh1 : arities h1 = ok_arities n (S s)) : arities (cond2 n s x g h0 h1) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh0, Hh1.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
do 2 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.

*****
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities n O))\n (map (proj n O) (seq O n))) true
Hh1 : eq (arities h1) (ok_arities n (S s))
Hh0 : eq (arities h0) (ok_arities n (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n s)
x,g,h0,h1 : BC
n,s : nat
*****
eq (if andb (aeq (if andb true (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s))) then ok_arities n s else error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) (ok_arities n s)) (andb (aeq (if andb true (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s))) then ok_arities n s else error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) (ok_arities n s)) true) then ok_arities n s else error_comp (ok_arities O (S (S (S (S O))))) nil (cons (ok_arities n s) (cons (ok_arities n s) (cons (if andb true (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s))) then ok_arities n s else error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) (cons (if andb true (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s))) then ok_arities n s else error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) nil))))) (ok_arities n s)
+++++
simpl.
-----
Lemma arities_cond2 n s x g h0 h1 (Hx : arities x = ok_arities n s) (Hg : arities g = ok_arities n s) (Hh0 : arities h0 = ok_arities n (S s)) (Hh1 : arities h1 = ok_arities n (S s)) : arities (cond2 n s x g h0 h1) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh0, Hh1.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
do 2 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.

*****
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities n O))\n (map (proj n O) (seq O n))) true
Hh1 : eq (arities h1) (ok_arities n (S s))
Hh0 : eq (arities h0) (ok_arities n (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n s)
x,g,h0,h1 : BC
n,s : nat
*****
eq (if andb (aeq (if forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s)) then ok_arities n s else error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) (ok_arities n s)) (andb (aeq (if forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s)) then ok_arities n s else error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) (ok_arities n s)) true) then ok_arities n s else error_comp (ok_arities O (S (S (S (S O))))) nil (cons (ok_arities n s) (cons (ok_arities n s) (cons (if forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s)) then ok_arities n s else error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) (cons (if forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s)) then ok_arities n s else error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) nil))))) (ok_arities n s)
+++++
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H2 end.
-----
Lemma arities_cond2 n s x g h0 h1 (Hx : arities x = ok_arities n s) (Hg : arities g = ok_arities n s) (Hh0 : arities h0 = ok_arities n (S s)) (Hh1 : arities h1 = ok_arities n (S s)) : arities (cond2 n s x g h0 h1) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh0, Hh1.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
do 2 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H2 end.

*****
H2 : eq\n (forallb (fun se : BC => aeq (arities se) (ok_arities n s))\n (map (proj n s) (seq n s))) true
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities n O))\n (map (proj n O) (seq O n))) true
Hh1 : eq (arities h1) (ok_arities n (S s))
Hh0 : eq (arities h0) (ok_arities n (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n s)
x,g,h0,h1 : BC
n,s : nat
*****
eq (if andb (aeq (ok_arities n s) (ok_arities n s)) (andb (aeq (ok_arities n s) (ok_arities n s)) true) then ok_arities n s else error_comp (ok_arities O (S (S (S (S O))))) nil (cons (ok_arities n s) (cons (ok_arities n s) (cons (ok_arities n s) (cons (ok_arities n s) nil))))) (ok_arities n s)
+++++
simpl.
-----
Lemma arities_cond2 n s x g h0 h1 (Hx : arities x = ok_arities n s) (Hg : arities g = ok_arities n s) (Hh0 : arities h0 = ok_arities n (S s)) (Hh1 : arities h1 = ok_arities n (S s)) : arities (cond2 n s x g h0 h1) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh0, Hh1.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
do 2 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H2 end.
simpl.

*****
H2 : eq\n (forallb (fun se : BC => aeq (arities se) (ok_arities n s))\n (map (proj n s) (seq n s))) true
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities n O))\n (map (proj n O) (seq O n))) true
Hh1 : eq (arities h1) (ok_arities n (S s))
Hh0 : eq (arities h0) (ok_arities n (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n s)
x,g,h0,h1 : BC
n,s : nat
*****
eq (if andb (andb (Nat.eqb n n) (Nat.eqb s s)) (andb (andb (Nat.eqb n n) (Nat.eqb s s)) true) then ok_arities n s else error_comp (ok_arities O (S (S (S (S O))))) nil (cons (ok_arities n s) (cons (ok_arities n s) (cons (ok_arities n s) (cons (ok_arities n s) nil))))) (ok_arities n s)
+++++
do 2 rewrite <- beq_nat_refl.
-----
Lemma arities_cond2 n s x g h0 h1 (Hx : arities x = ok_arities n s) (Hg : arities g = ok_arities n s) (Hh0 : arities h0 = ok_arities n (S s)) (Hh1 : arities h1 = ok_arities n (S s)) : arities (cond2 n s x g h0 h1) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh0, Hh1.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
do 2 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H2 end.
simpl.
do 2 rewrite <- beq_nat_refl.

*****
H2 : eq\n (forallb (fun se : BC => aeq (arities se) (ok_arities n s))\n (map (proj n s) (seq n s))) true
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities n O))\n (map (proj n O) (seq O n))) true
Hh1 : eq (arities h1) (ok_arities n (S s))
Hh0 : eq (arities h0) (ok_arities n (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n s)
x,g,h0,h1 : BC
n,s : nat
*****
eq (if andb (andb true true) (andb (andb true true) true) then ok_arities n s else error_comp (ok_arities O (S (S (S (S O))))) nil (cons (ok_arities n s) (cons (ok_arities n s) (cons (ok_arities n s) (cons (ok_arities n s) nil))))) (ok_arities n s)
+++++
reflexivity.
-----
Lemma arities_cond2 n s x g h0 h1 (Hx : arities x = ok_arities n s) (Hg : arities g = ok_arities n s) (Hh0 : arities h0 = ok_arities n (S s)) (Hh1 : arities h1 = ok_arities n (S s)) : arities (cond2 n s x g h0 h1) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh0, Hh1.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
do 2 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H2 end.
simpl.
do 2 rewrite <- beq_nat_refl.
reflexivity.

*****
H2 : eq\n (forallb (fun se : BC => aeq (arities se) (ok_arities n s))\n (map (proj n s) (seq n s))) false
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities n O))\n (map (proj n O) (seq O n))) true
Hh1 : eq (arities h1) (ok_arities n (S s))
Hh0 : eq (arities h0) (ok_arities n (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n s)
x,g,h0,h1 : BC
n,s : nat
*****
eq (if andb (aeq (error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) (ok_arities n s)) (andb (aeq (error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) (ok_arities n s)) true) then ok_arities n s else error_comp (ok_arities O (S (S (S (S O))))) nil (cons (ok_arities n s) (cons (ok_arities n s) (cons (error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) (cons (error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) nil))))) (ok_arities n s)
+++++
rewrite forallb_forall_conv in H2.
-----
Lemma arities_cond2 n s x g h0 h1 (Hx : arities x = ok_arities n s) (Hg : arities g = ok_arities n s) (Hh0 : arities h0 = ok_arities n (S s)) (Hh1 : arities h1 = ok_arities n (S s)) : arities (cond2 n s x g h0 h1) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh0, Hh1.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
do 2 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H2 end.
simpl.
do 2 rewrite <- beq_nat_refl.
reflexivity.
rewrite forallb_forall_conv in H2.

*****
H2 : ex\n (fun x : BC =>\n and (In x (map (proj n s) (seq n s)))\n (eq (aeq (arities x) (ok_arities n s)) false))
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities n O))\n (map (proj n O) (seq O n))) true
Hh1 : eq (arities h1) (ok_arities n (S s))
Hh0 : eq (arities h0) (ok_arities n (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n s)
x,g,h0,h1 : BC
n,s : nat
*****
eq (if andb (aeq (error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) (ok_arities n s)) (andb (aeq (error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) (ok_arities n s)) true) then ok_arities n s else error_comp (ok_arities O (S (S (S (S O))))) nil (cons (ok_arities n s) (cons (ok_arities n s) (cons (error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) (cons (error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) nil))))) (ok_arities n s)
+++++
destruct H2 as [e [H2 H3] ].
-----
Lemma arities_cond2 n s x g h0 h1 (Hx : arities x = ok_arities n s) (Hg : arities g = ok_arities n s) (Hh0 : arities h0 = ok_arities n (S s)) (Hh1 : arities h1 = ok_arities n (S s)) : arities (cond2 n s x g h0 h1) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh0, Hh1.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
do 2 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H2 end.
simpl.
do 2 rewrite <- beq_nat_refl.
reflexivity.
rewrite forallb_forall_conv in H2.
destruct H2 as [e [H2 H3] ].

*****
H3 : eq (aeq (arities e) (ok_arities n s)) false
H2 : In e (map (proj n s) (seq n s))
e : BC
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities n O))\n (map (proj n O) (seq O n))) true
Hh1 : eq (arities h1) (ok_arities n (S s))
Hh0 : eq (arities h0) (ok_arities n (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n s)
x,g,h0,h1 : BC
n,s : nat
*****
eq (if andb (aeq (error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) (ok_arities n s)) (andb (aeq (error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) (ok_arities n s)) true) then ok_arities n s else error_comp (ok_arities O (S (S (S (S O))))) nil (cons (ok_arities n s) (cons (ok_arities n s) (cons (error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) (cons (error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) nil))))) (ok_arities n s)
+++++
rewrite in_map_iff in H2.
-----
Lemma arities_cond2 n s x g h0 h1 (Hx : arities x = ok_arities n s) (Hg : arities g = ok_arities n s) (Hh0 : arities h0 = ok_arities n (S s)) (Hh1 : arities h1 = ok_arities n (S s)) : arities (cond2 n s x g h0 h1) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh0, Hh1.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
do 2 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H2 end.
simpl.
do 2 rewrite <- beq_nat_refl.
reflexivity.
rewrite forallb_forall_conv in H2.
destruct H2 as [e [H2 H3] ].
rewrite in_map_iff in H2.

*****
H3 : eq (aeq (arities e) (ok_arities n s)) false
H2 : ex (fun x : nat => and (eq (proj n s x) e) (In x (seq n s)))
e : BC
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities n O))\n (map (proj n O) (seq O n))) true
Hh1 : eq (arities h1) (ok_arities n (S s))
Hh0 : eq (arities h0) (ok_arities n (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n s)
x,g,h0,h1 : BC
n,s : nat
*****
eq (if andb (aeq (error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) (ok_arities n s)) (andb (aeq (error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) (ok_arities n s)) true) then ok_arities n s else error_comp (ok_arities O (S (S (S (S O))))) nil (cons (ok_arities n s) (cons (ok_arities n s) (cons (error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) (cons (error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) nil))))) (ok_arities n s)
+++++
destruct H2 as [p [H2 H4] ].
-----
Lemma arities_cond2 n s x g h0 h1 (Hx : arities x = ok_arities n s) (Hg : arities g = ok_arities n s) (Hh0 : arities h0 = ok_arities n (S s)) (Hh1 : arities h1 = ok_arities n (S s)) : arities (cond2 n s x g h0 h1) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh0, Hh1.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
do 2 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H2 end.
simpl.
do 2 rewrite <- beq_nat_refl.
reflexivity.
rewrite forallb_forall_conv in H2.
destruct H2 as [e [H2 H3] ].
rewrite in_map_iff in H2.
destruct H2 as [p [H2 H4] ].

*****
H3 : eq (aeq (arities e) (ok_arities n s)) false
H4 : In p (seq n s)
H2 : eq (proj n s p) e
p : nat
e : BC
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities n O))\n (map (proj n O) (seq O n))) true
Hh1 : eq (arities h1) (ok_arities n (S s))
Hh0 : eq (arities h0) (ok_arities n (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n s)
x,g,h0,h1 : BC
n,s : nat
*****
eq (if andb (aeq (error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) (ok_arities n s)) (andb (aeq (error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) (ok_arities n s)) true) then ok_arities n s else error_comp (ok_arities O (S (S (S (S O))))) nil (cons (ok_arities n s) (cons (ok_arities n s) (cons (error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) (cons (error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) nil))))) (ok_arities n s)
+++++
rewrite in_seq_iff in H4.
-----
Lemma arities_cond2 n s x g h0 h1 (Hx : arities x = ok_arities n s) (Hg : arities g = ok_arities n s) (Hh0 : arities h0 = ok_arities n (S s)) (Hh1 : arities h1 = ok_arities n (S s)) : arities (cond2 n s x g h0 h1) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh0, Hh1.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
do 2 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H2 end.
simpl.
do 2 rewrite <- beq_nat_refl.
reflexivity.
rewrite forallb_forall_conv in H2.
destruct H2 as [e [H2 H3] ].
rewrite in_map_iff in H2.
destruct H2 as [p [H2 H4] ].
rewrite in_seq_iff in H4.

*****
H3 : eq (aeq (arities e) (ok_arities n s)) false
H4 : and (le n p) (lt p (Init.Nat.add n s))
H2 : eq (proj n s p) e
p : nat
e : BC
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities n O))\n (map (proj n O) (seq O n))) true
Hh1 : eq (arities h1) (ok_arities n (S s))
Hh0 : eq (arities h0) (ok_arities n (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n s)
x,g,h0,h1 : BC
n,s : nat
*****
eq (if andb (aeq (error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) (ok_arities n s)) (andb (aeq (error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) (ok_arities n s)) true) then ok_arities n s else error_comp (ok_arities O (S (S (S (S O))))) nil (cons (ok_arities n s) (cons (ok_arities n s) (cons (error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) (cons (error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) nil))))) (ok_arities n s)
+++++
subst e.
-----
Lemma arities_cond2 n s x g h0 h1 (Hx : arities x = ok_arities n s) (Hg : arities g = ok_arities n s) (Hh0 : arities h0 = ok_arities n (S s)) (Hh1 : arities h1 = ok_arities n (S s)) : arities (cond2 n s x g h0 h1) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh0, Hh1.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
do 2 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H2 end.
simpl.
do 2 rewrite <- beq_nat_refl.
reflexivity.
rewrite forallb_forall_conv in H2.
destruct H2 as [e [H2 H3] ].
rewrite in_map_iff in H2.
destruct H2 as [p [H2 H4] ].
rewrite in_seq_iff in H4.
subst e.

*****
H3 : eq (aeq (arities (proj n s p)) (ok_arities n s)) false
H4 : and (le n p) (lt p (Init.Nat.add n s))
p : nat
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities n O))\n (map (proj n O) (seq O n))) true
Hh1 : eq (arities h1) (ok_arities n (S s))
Hh0 : eq (arities h0) (ok_arities n (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n s)
x,g,h0,h1 : BC
n,s : nat
*****
eq (if andb (aeq (error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) (ok_arities n s)) (andb (aeq (error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) (ok_arities n s)) true) then ok_arities n s else error_comp (ok_arities O (S (S (S (S O))))) nil (cons (ok_arities n s) (cons (ok_arities n s) (cons (error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) (cons (error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) nil))))) (ok_arities n s)
+++++
simpl in H3.
-----
Lemma arities_cond2 n s x g h0 h1 (Hx : arities x = ok_arities n s) (Hg : arities g = ok_arities n s) (Hh0 : arities h0 = ok_arities n (S s)) (Hh1 : arities h1 = ok_arities n (S s)) : arities (cond2 n s x g h0 h1) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh0, Hh1.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
do 2 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H2 end.
simpl.
do 2 rewrite <- beq_nat_refl.
reflexivity.
rewrite forallb_forall_conv in H2.
destruct H2 as [e [H2 H3] ].
rewrite in_map_iff in H2.
destruct H2 as [p [H2 H4] ].
rewrite in_seq_iff in H4.
subst e.
simpl in H3.

*****
H3 : eq\n (aeq\n (if\n match Init.Nat.add n s with\n | O => false\n | S m' => Nat.leb p m'\n end\n then ok_arities n s\n else error_proj n s p) (ok_arities n s)) false
H4 : and (le n p) (lt p (Init.Nat.add n s))
p : nat
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities n O))\n (map (proj n O) (seq O n))) true
Hh1 : eq (arities h1) (ok_arities n (S s))
Hh0 : eq (arities h0) (ok_arities n (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n s)
x,g,h0,h1 : BC
n,s : nat
*****
eq (if andb (aeq (error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) (ok_arities n s)) (andb (aeq (error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) (ok_arities n s)) true) then ok_arities n s else error_comp (ok_arities O (S (S (S (S O))))) nil (cons (ok_arities n s) (cons (ok_arities n s) (cons (error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) (cons (error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) nil))))) (ok_arities n s)
+++++
case_eq (n + s).
-----
Lemma arities_cond2 n s x g h0 h1 (Hx : arities x = ok_arities n s) (Hg : arities g = ok_arities n s) (Hh0 : arities h0 = ok_arities n (S s)) (Hh1 : arities h1 = ok_arities n (S s)) : arities (cond2 n s x g h0 h1) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh0, Hh1.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
do 2 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H2 end.
simpl.
do 2 rewrite <- beq_nat_refl.
reflexivity.
rewrite forallb_forall_conv in H2.
destruct H2 as [e [H2 H3] ].
rewrite in_map_iff in H2.
destruct H2 as [p [H2 H4] ].
rewrite in_seq_iff in H4.
subst e.
simpl in H3.
case_eq (n + s).

*****
H3 : eq\n (aeq\n (if\n match Init.Nat.add n s with\n | O => false\n | S m' => Nat.leb p m'\n end\n then ok_arities n s\n else error_proj n s p) (ok_arities n s)) false
H4 : and (le n p) (lt p (Init.Nat.add n s))
p : nat
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities n O))\n (map (proj n O) (seq O n))) true
Hh1 : eq (arities h1) (ok_arities n (S s))
Hh0 : eq (arities h0) (ok_arities n (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n s)
x,g,h0,h1 : BC
n,s : nat
*****
forall _ : eq (Init.Nat.add n s) O, eq (if andb (aeq (error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) (ok_arities n s)) (andb (aeq (error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) (ok_arities n s)) true) then ok_arities n s else error_comp (ok_arities O (S (S (S (S O))))) nil (cons (ok_arities n s) (cons (ok_arities n s) (cons (error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) (cons (error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) nil))))) (ok_arities n s)
+++++
intro H5.
-----
Lemma arities_cond2 n s x g h0 h1 (Hx : arities x = ok_arities n s) (Hg : arities g = ok_arities n s) (Hh0 : arities h0 = ok_arities n (S s)) (Hh1 : arities h1 = ok_arities n (S s)) : arities (cond2 n s x g h0 h1) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh0, Hh1.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
do 2 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H2 end.
simpl.
do 2 rewrite <- beq_nat_refl.
reflexivity.
rewrite forallb_forall_conv in H2.
destruct H2 as [e [H2 H3] ].
rewrite in_map_iff in H2.
destruct H2 as [p [H2 H4] ].
rewrite in_seq_iff in H4.
subst e.
simpl in H3.
case_eq (n + s).
intro H5.

*****
H5 : eq (Init.Nat.add n s) O
H3 : eq\n (aeq\n (if\n match Init.Nat.add n s with\n | O => false\n | S m' => Nat.leb p m'\n end\n then ok_arities n s\n else error_proj n s p) (ok_arities n s)) false
H4 : and (le n p) (lt p (Init.Nat.add n s))
p : nat
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities n O))\n (map (proj n O) (seq O n))) true
Hh1 : eq (arities h1) (ok_arities n (S s))
Hh0 : eq (arities h0) (ok_arities n (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n s)
x,g,h0,h1 : BC
n,s : nat
*****
eq (if andb (aeq (error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) (ok_arities n s)) (andb (aeq (error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) (ok_arities n s)) true) then ok_arities n s else error_comp (ok_arities O (S (S (S (S O))))) nil (cons (ok_arities n s) (cons (ok_arities n s) (cons (error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) (cons (error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) nil))))) (ok_arities n s)
+++++
contradict H5.
-----
Lemma arities_cond2 n s x g h0 h1 (Hx : arities x = ok_arities n s) (Hg : arities g = ok_arities n s) (Hh0 : arities h0 = ok_arities n (S s)) (Hh1 : arities h1 = ok_arities n (S s)) : arities (cond2 n s x g h0 h1) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh0, Hh1.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
do 2 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H2 end.
simpl.
do 2 rewrite <- beq_nat_refl.
reflexivity.
rewrite forallb_forall_conv in H2.
destruct H2 as [e [H2 H3] ].
rewrite in_map_iff in H2.
destruct H2 as [p [H2 H4] ].
rewrite in_seq_iff in H4.
subst e.
simpl in H3.
case_eq (n + s).
intro H5.
contradict H5.

*****
H3 : eq\n (aeq\n (if\n match Init.Nat.add n s with\n | O => false\n | S m' => Nat.leb p m'\n end\n then ok_arities n s\n else error_proj n s p) (ok_arities n s)) false
H4 : and (le n p) (lt p (Init.Nat.add n s))
p : nat
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities n O))\n (map (proj n O) (seq O n))) true
Hh1 : eq (arities h1) (ok_arities n (S s))
Hh0 : eq (arities h0) (ok_arities n (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n s)
x,g,h0,h1 : BC
n,s : nat
*****
not (eq (Init.Nat.add n s) O)
+++++
omega.
-----
Lemma arities_cond2 n s x g h0 h1 (Hx : arities x = ok_arities n s) (Hg : arities g = ok_arities n s) (Hh0 : arities h0 = ok_arities n (S s)) (Hh1 : arities h1 = ok_arities n (S s)) : arities (cond2 n s x g h0 h1) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh0, Hh1.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
do 2 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H2 end.
simpl.
do 2 rewrite <- beq_nat_refl.
reflexivity.
rewrite forallb_forall_conv in H2.
destruct H2 as [e [H2 H3] ].
rewrite in_map_iff in H2.
destruct H2 as [p [H2 H4] ].
rewrite in_seq_iff in H4.
subst e.
simpl in H3.
case_eq (n + s).
intro H5.
contradict H5.
omega.

*****
H3 : eq\n (aeq\n (if\n match Init.Nat.add n s with\n | O => false\n | S m' => Nat.leb p m'\n end\n then ok_arities n s\n else error_proj n s p) (ok_arities n s)) false
H4 : and (le n p) (lt p (Init.Nat.add n s))
p : nat
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities n O))\n (map (proj n O) (seq O n))) true
Hh1 : eq (arities h1) (ok_arities n (S s))
Hh0 : eq (arities h0) (ok_arities n (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n s)
x,g,h0,h1 : BC
n,s : nat
*****
forall (n0 : nat) (_ : eq (Init.Nat.add n s) (S n0)), eq (if andb (aeq (error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) (ok_arities n s)) (andb (aeq (error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) (ok_arities n s)) true) then ok_arities n s else error_comp (ok_arities O (S (S (S (S O))))) nil (cons (ok_arities n s) (cons (ok_arities n s) (cons (error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) (cons (error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) nil))))) (ok_arities n s)
+++++
intros q H5.
-----
Lemma arities_cond2 n s x g h0 h1 (Hx : arities x = ok_arities n s) (Hg : arities g = ok_arities n s) (Hh0 : arities h0 = ok_arities n (S s)) (Hh1 : arities h1 = ok_arities n (S s)) : arities (cond2 n s x g h0 h1) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh0, Hh1.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
do 2 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H2 end.
simpl.
do 2 rewrite <- beq_nat_refl.
reflexivity.
rewrite forallb_forall_conv in H2.
destruct H2 as [e [H2 H3] ].
rewrite in_map_iff in H2.
destruct H2 as [p [H2 H4] ].
rewrite in_seq_iff in H4.
subst e.
simpl in H3.
case_eq (n + s).
intro H5.
contradict H5.
omega.
intros q H5.

*****
H5 : eq (Init.Nat.add n s) (S q)
q : nat
H3 : eq\n (aeq\n (if\n match Init.Nat.add n s with\n | O => false\n | S m' => Nat.leb p m'\n end\n then ok_arities n s\n else error_proj n s p) (ok_arities n s)) false
H4 : and (le n p) (lt p (Init.Nat.add n s))
p : nat
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities n O))\n (map (proj n O) (seq O n))) true
Hh1 : eq (arities h1) (ok_arities n (S s))
Hh0 : eq (arities h0) (ok_arities n (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n s)
x,g,h0,h1 : BC
n,s : nat
*****
eq (if andb (aeq (error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) (ok_arities n s)) (andb (aeq (error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) (ok_arities n s)) true) then ok_arities n s else error_comp (ok_arities O (S (S (S (S O))))) nil (cons (ok_arities n s) (cons (ok_arities n s) (cons (error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) (cons (error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) nil))))) (ok_arities n s)
+++++
rewrite H5 in H3.
-----
Lemma arities_cond2 n s x g h0 h1 (Hx : arities x = ok_arities n s) (Hg : arities g = ok_arities n s) (Hh0 : arities h0 = ok_arities n (S s)) (Hh1 : arities h1 = ok_arities n (S s)) : arities (cond2 n s x g h0 h1) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh0, Hh1.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
do 2 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H2 end.
simpl.
do 2 rewrite <- beq_nat_refl.
reflexivity.
rewrite forallb_forall_conv in H2.
destruct H2 as [e [H2 H3] ].
rewrite in_map_iff in H2.
destruct H2 as [p [H2 H4] ].
rewrite in_seq_iff in H4.
subst e.
simpl in H3.
case_eq (n + s).
intro H5.
contradict H5.
omega.
intros q H5.
rewrite H5 in H3.

*****
H5 : eq (Init.Nat.add n s) (S q)
H3 : eq\n (aeq (if Nat.leb p q then ok_arities n s else error_proj n s p)\n (ok_arities n s)) false
q : nat
H4 : and (le n p) (lt p (Init.Nat.add n s))
p : nat
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities n O))\n (map (proj n O) (seq O n))) true
Hh1 : eq (arities h1) (ok_arities n (S s))
Hh0 : eq (arities h0) (ok_arities n (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n s)
x,g,h0,h1 : BC
n,s : nat
*****
eq (if andb (aeq (error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) (ok_arities n s)) (andb (aeq (error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) (ok_arities n s)) true) then ok_arities n s else error_comp (ok_arities O (S (S (S (S O))))) nil (cons (ok_arities n s) (cons (ok_arities n s) (cons (error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) (cons (error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) nil))))) (ok_arities n s)
+++++
case_eq (leb p q); intro H6.
-----
Lemma arities_cond2 n s x g h0 h1 (Hx : arities x = ok_arities n s) (Hg : arities g = ok_arities n s) (Hh0 : arities h0 = ok_arities n (S s)) (Hh1 : arities h1 = ok_arities n (S s)) : arities (cond2 n s x g h0 h1) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh0, Hh1.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
do 2 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H2 end.
simpl.
do 2 rewrite <- beq_nat_refl.
reflexivity.
rewrite forallb_forall_conv in H2.
destruct H2 as [e [H2 H3] ].
rewrite in_map_iff in H2.
destruct H2 as [p [H2 H4] ].
rewrite in_seq_iff in H4.
subst e.
simpl in H3.
case_eq (n + s).
intro H5.
contradict H5.
omega.
intros q H5.
rewrite H5 in H3.
case_eq (leb p q); intro H6.

*****
H6 : eq (Nat.leb p q) true
H5 : eq (Init.Nat.add n s) (S q)
H3 : eq\n (aeq (if Nat.leb p q then ok_arities n s else error_proj n s p)\n (ok_arities n s)) false
q : nat
H4 : and (le n p) (lt p (Init.Nat.add n s))
p : nat
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities n O))\n (map (proj n O) (seq O n))) true
Hh1 : eq (arities h1) (ok_arities n (S s))
Hh0 : eq (arities h0) (ok_arities n (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n s)
x,g,h0,h1 : BC
n,s : nat
*****
eq (if andb (aeq (error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) (ok_arities n s)) (andb (aeq (error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) (ok_arities n s)) true) then ok_arities n s else error_comp (ok_arities O (S (S (S (S O))))) nil (cons (ok_arities n s) (cons (ok_arities n s) (cons (error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) (cons (error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) nil))))) (ok_arities n s)
+++++
rewrite H6 in H3.
-----
Lemma arities_cond2 n s x g h0 h1 (Hx : arities x = ok_arities n s) (Hg : arities g = ok_arities n s) (Hh0 : arities h0 = ok_arities n (S s)) (Hh1 : arities h1 = ok_arities n (S s)) : arities (cond2 n s x g h0 h1) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh0, Hh1.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
do 2 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H2 end.
simpl.
do 2 rewrite <- beq_nat_refl.
reflexivity.
rewrite forallb_forall_conv in H2.
destruct H2 as [e [H2 H3] ].
rewrite in_map_iff in H2.
destruct H2 as [p [H2 H4] ].
rewrite in_seq_iff in H4.
subst e.
simpl in H3.
case_eq (n + s).
intro H5.
contradict H5.
omega.
intros q H5.
rewrite H5 in H3.
case_eq (leb p q); intro H6.
rewrite H6 in H3.

*****
H6 : eq (Nat.leb p q) true
H5 : eq (Init.Nat.add n s) (S q)
H3 : eq (aeq (ok_arities n s) (ok_arities n s)) false
q : nat
H4 : and (le n p) (lt p (Init.Nat.add n s))
p : nat
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities n O))\n (map (proj n O) (seq O n))) true
Hh1 : eq (arities h1) (ok_arities n (S s))
Hh0 : eq (arities h0) (ok_arities n (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n s)
x,g,h0,h1 : BC
n,s : nat
*****
eq (if andb (aeq (error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) (ok_arities n s)) (andb (aeq (error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) (ok_arities n s)) true) then ok_arities n s else error_comp (ok_arities O (S (S (S (S O))))) nil (cons (ok_arities n s) (cons (ok_arities n s) (cons (error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) (cons (error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) nil))))) (ok_arities n s)
+++++
simpl in H3.
-----
Lemma arities_cond2 n s x g h0 h1 (Hx : arities x = ok_arities n s) (Hg : arities g = ok_arities n s) (Hh0 : arities h0 = ok_arities n (S s)) (Hh1 : arities h1 = ok_arities n (S s)) : arities (cond2 n s x g h0 h1) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh0, Hh1.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
do 2 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H2 end.
simpl.
do 2 rewrite <- beq_nat_refl.
reflexivity.
rewrite forallb_forall_conv in H2.
destruct H2 as [e [H2 H3] ].
rewrite in_map_iff in H2.
destruct H2 as [p [H2 H4] ].
rewrite in_seq_iff in H4.
subst e.
simpl in H3.
case_eq (n + s).
intro H5.
contradict H5.
omega.
intros q H5.
rewrite H5 in H3.
case_eq (leb p q); intro H6.
rewrite H6 in H3.
simpl in H3.

*****
H6 : eq (Nat.leb p q) true
H5 : eq (Init.Nat.add n s) (S q)
H3 : eq (andb (Nat.eqb n n) (Nat.eqb s s)) false
q : nat
H4 : and (le n p) (lt p (Init.Nat.add n s))
p : nat
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities n O))\n (map (proj n O) (seq O n))) true
Hh1 : eq (arities h1) (ok_arities n (S s))
Hh0 : eq (arities h0) (ok_arities n (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n s)
x,g,h0,h1 : BC
n,s : nat
*****
eq (if andb (aeq (error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) (ok_arities n s)) (andb (aeq (error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) (ok_arities n s)) true) then ok_arities n s else error_comp (ok_arities O (S (S (S (S O))))) nil (cons (ok_arities n s) (cons (ok_arities n s) (cons (error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) (cons (error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) nil))))) (ok_arities n s)
+++++
do 2 rewrite <- beq_nat_refl in H3.
-----
Lemma arities_cond2 n s x g h0 h1 (Hx : arities x = ok_arities n s) (Hg : arities g = ok_arities n s) (Hh0 : arities h0 = ok_arities n (S s)) (Hh1 : arities h1 = ok_arities n (S s)) : arities (cond2 n s x g h0 h1) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh0, Hh1.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
do 2 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H2 end.
simpl.
do 2 rewrite <- beq_nat_refl.
reflexivity.
rewrite forallb_forall_conv in H2.
destruct H2 as [e [H2 H3] ].
rewrite in_map_iff in H2.
destruct H2 as [p [H2 H4] ].
rewrite in_seq_iff in H4.
subst e.
simpl in H3.
case_eq (n + s).
intro H5.
contradict H5.
omega.
intros q H5.
rewrite H5 in H3.
case_eq (leb p q); intro H6.
rewrite H6 in H3.
simpl in H3.
do 2 rewrite <- beq_nat_refl in H3.

*****
H6 : eq (Nat.leb p q) true
H5 : eq (Init.Nat.add n s) (S q)
H3 : eq (andb true true) false
q : nat
H4 : and (le n p) (lt p (Init.Nat.add n s))
p : nat
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities n O))\n (map (proj n O) (seq O n))) true
Hh1 : eq (arities h1) (ok_arities n (S s))
Hh0 : eq (arities h0) (ok_arities n (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n s)
x,g,h0,h1 : BC
n,s : nat
*****
eq (if andb (aeq (error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) (ok_arities n s)) (andb (aeq (error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) (ok_arities n s)) true) then ok_arities n s else error_comp (ok_arities O (S (S (S (S O))))) nil (cons (ok_arities n s) (cons (ok_arities n s) (cons (error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) (cons (error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) nil))))) (ok_arities n s)
+++++
discriminate H3.
-----
Lemma arities_cond2 n s x g h0 h1 (Hx : arities x = ok_arities n s) (Hg : arities g = ok_arities n s) (Hh0 : arities h0 = ok_arities n (S s)) (Hh1 : arities h1 = ok_arities n (S s)) : arities (cond2 n s x g h0 h1) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh0, Hh1.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
do 2 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H2 end.
simpl.
do 2 rewrite <- beq_nat_refl.
reflexivity.
rewrite forallb_forall_conv in H2.
destruct H2 as [e [H2 H3] ].
rewrite in_map_iff in H2.
destruct H2 as [p [H2 H4] ].
rewrite in_seq_iff in H4.
subst e.
simpl in H3.
case_eq (n + s).
intro H5.
contradict H5.
omega.
intros q H5.
rewrite H5 in H3.
case_eq (leb p q); intro H6.
rewrite H6 in H3.
simpl in H3.
do 2 rewrite <- beq_nat_refl in H3.
discriminate H3.

*****
H6 : eq (Nat.leb p q) false
H5 : eq (Init.Nat.add n s) (S q)
H3 : eq\n (aeq (if Nat.leb p q then ok_arities n s else error_proj n s p)\n (ok_arities n s)) false
q : nat
H4 : and (le n p) (lt p (Init.Nat.add n s))
p : nat
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities n O))\n (map (proj n O) (seq O n))) true
Hh1 : eq (arities h1) (ok_arities n (S s))
Hh0 : eq (arities h0) (ok_arities n (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n s)
x,g,h0,h1 : BC
n,s : nat
*****
eq (if andb (aeq (error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) (ok_arities n s)) (andb (aeq (error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) (ok_arities n s)) true) then ok_arities n s else error_comp (ok_arities O (S (S (S (S O))))) nil (cons (ok_arities n s) (cons (ok_arities n s) (cons (error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) (cons (error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) nil))))) (ok_arities n s)
+++++
rewrite leb_iff_conv in H6.
-----
Lemma arities_cond2 n s x g h0 h1 (Hx : arities x = ok_arities n s) (Hg : arities g = ok_arities n s) (Hh0 : arities h0 = ok_arities n (S s)) (Hh1 : arities h1 = ok_arities n (S s)) : arities (cond2 n s x g h0 h1) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh0, Hh1.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
do 2 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H2 end.
simpl.
do 2 rewrite <- beq_nat_refl.
reflexivity.
rewrite forallb_forall_conv in H2.
destruct H2 as [e [H2 H3] ].
rewrite in_map_iff in H2.
destruct H2 as [p [H2 H4] ].
rewrite in_seq_iff in H4.
subst e.
simpl in H3.
case_eq (n + s).
intro H5.
contradict H5.
omega.
intros q H5.
rewrite H5 in H3.
case_eq (leb p q); intro H6.
rewrite H6 in H3.
simpl in H3.
do 2 rewrite <- beq_nat_refl in H3.
discriminate H3.
rewrite leb_iff_conv in H6.

*****
H6 : lt q p
H5 : eq (Init.Nat.add n s) (S q)
H3 : eq\n (aeq (if Nat.leb p q then ok_arities n s else error_proj n s p)\n (ok_arities n s)) false
q : nat
H4 : and (le n p) (lt p (Init.Nat.add n s))
p : nat
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities n O))\n (map (proj n O) (seq O n))) true
Hh1 : eq (arities h1) (ok_arities n (S s))
Hh0 : eq (arities h0) (ok_arities n (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n s)
x,g,h0,h1 : BC
n,s : nat
*****
eq (if andb (aeq (error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) (ok_arities n s)) (andb (aeq (error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) (ok_arities n s)) true) then ok_arities n s else error_comp (ok_arities O (S (S (S (S O))))) nil (cons (ok_arities n s) (cons (ok_arities n s) (cons (error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) (cons (error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) nil))))) (ok_arities n s)
+++++
contradict H6.
-----
Lemma arities_cond2 n s x g h0 h1 (Hx : arities x = ok_arities n s) (Hg : arities g = ok_arities n s) (Hh0 : arities h0 = ok_arities n (S s)) (Hh1 : arities h1 = ok_arities n (S s)) : arities (cond2 n s x g h0 h1) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh0, Hh1.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
do 2 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H2 end.
simpl.
do 2 rewrite <- beq_nat_refl.
reflexivity.
rewrite forallb_forall_conv in H2.
destruct H2 as [e [H2 H3] ].
rewrite in_map_iff in H2.
destruct H2 as [p [H2 H4] ].
rewrite in_seq_iff in H4.
subst e.
simpl in H3.
case_eq (n + s).
intro H5.
contradict H5.
omega.
intros q H5.
rewrite H5 in H3.
case_eq (leb p q); intro H6.
rewrite H6 in H3.
simpl in H3.
do 2 rewrite <- beq_nat_refl in H3.
discriminate H3.
rewrite leb_iff_conv in H6.
contradict H6.

*****
H5 : eq (Init.Nat.add n s) (S q)
H3 : eq\n (aeq (if Nat.leb p q then ok_arities n s else error_proj n s p)\n (ok_arities n s)) false
q : nat
H4 : and (le n p) (lt p (Init.Nat.add n s))
p : nat
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities n O))\n (map (proj n O) (seq O n))) true
Hh1 : eq (arities h1) (ok_arities n (S s))
Hh0 : eq (arities h0) (ok_arities n (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n s)
x,g,h0,h1 : BC
n,s : nat
*****
not (lt q p)
+++++
omega.
-----
Lemma arities_cond2 n s x g h0 h1 (Hx : arities x = ok_arities n s) (Hg : arities g = ok_arities n s) (Hh0 : arities h0 = ok_arities n (S s)) (Hh1 : arities h1 = ok_arities n (S s)) : arities (cond2 n s x g h0 h1) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh0, Hh1.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
do 2 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H2 end.
simpl.
do 2 rewrite <- beq_nat_refl.
reflexivity.
rewrite forallb_forall_conv in H2.
destruct H2 as [e [H2 H3] ].
rewrite in_map_iff in H2.
destruct H2 as [p [H2 H4] ].
rewrite in_seq_iff in H4.
subst e.
simpl in H3.
case_eq (n + s).
intro H5.
contradict H5.
omega.
intros q H5.
rewrite H5 in H3.
case_eq (leb p q); intro H6.
rewrite H6 in H3.
simpl in H3.
do 2 rewrite <- beq_nat_refl in H3.
discriminate H3.
rewrite leb_iff_conv in H6.
contradict H6.
omega.

*****
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities n O))\n (map (proj n O) (seq O n))) false
Hh1 : eq (arities h1) (ok_arities n (S s))
Hh0 : eq (arities h0) (ok_arities n (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n s)
x,g,h0,h1 : BC
n,s : nat
*****
eq (if andb (aeq (if andb false (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s))) then ok_arities n s else error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) (ok_arities n s)) (andb (aeq (if andb false (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s))) then ok_arities n s else error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) (ok_arities n s)) true) then ok_arities n s else error_comp (ok_arities O (S (S (S (S O))))) nil (cons (ok_arities n s) (cons (ok_arities n s) (cons (if andb false (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s))) then ok_arities n s else error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) (cons (if andb false (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s))) then ok_arities n s else error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) nil))))) (ok_arities n s)
+++++
rewrite forallb_forall_conv in H1.
-----
Lemma arities_cond2 n s x g h0 h1 (Hx : arities x = ok_arities n s) (Hg : arities g = ok_arities n s) (Hh0 : arities h0 = ok_arities n (S s)) (Hh1 : arities h1 = ok_arities n (S s)) : arities (cond2 n s x g h0 h1) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh0, Hh1.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
do 2 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H2 end.
simpl.
do 2 rewrite <- beq_nat_refl.
reflexivity.
rewrite forallb_forall_conv in H2.
destruct H2 as [e [H2 H3] ].
rewrite in_map_iff in H2.
destruct H2 as [p [H2 H4] ].
rewrite in_seq_iff in H4.
subst e.
simpl in H3.
case_eq (n + s).
intro H5.
contradict H5.
omega.
intros q H5.
rewrite H5 in H3.
case_eq (leb p q); intro H6.
rewrite H6 in H3.
simpl in H3.
do 2 rewrite <- beq_nat_refl in H3.
discriminate H3.
rewrite leb_iff_conv in H6.
contradict H6.
omega.
rewrite forallb_forall_conv in H1.

*****
H1 : ex\n (fun x : BC =>\n and (In x (map (proj n O) (seq O n)))\n (eq (aeq (arities x) (ok_arities n O)) false))
Hh1 : eq (arities h1) (ok_arities n (S s))
Hh0 : eq (arities h0) (ok_arities n (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n s)
x,g,h0,h1 : BC
n,s : nat
*****
eq (if andb (aeq (if andb false (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s))) then ok_arities n s else error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) (ok_arities n s)) (andb (aeq (if andb false (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s))) then ok_arities n s else error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) (ok_arities n s)) true) then ok_arities n s else error_comp (ok_arities O (S (S (S (S O))))) nil (cons (ok_arities n s) (cons (ok_arities n s) (cons (if andb false (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s))) then ok_arities n s else error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) (cons (if andb false (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s))) then ok_arities n s else error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) nil))))) (ok_arities n s)
+++++
destruct H1 as [e [H1 H2] ].
-----
Lemma arities_cond2 n s x g h0 h1 (Hx : arities x = ok_arities n s) (Hg : arities g = ok_arities n s) (Hh0 : arities h0 = ok_arities n (S s)) (Hh1 : arities h1 = ok_arities n (S s)) : arities (cond2 n s x g h0 h1) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh0, Hh1.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
do 2 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H2 end.
simpl.
do 2 rewrite <- beq_nat_refl.
reflexivity.
rewrite forallb_forall_conv in H2.
destruct H2 as [e [H2 H3] ].
rewrite in_map_iff in H2.
destruct H2 as [p [H2 H4] ].
rewrite in_seq_iff in H4.
subst e.
simpl in H3.
case_eq (n + s).
intro H5.
contradict H5.
omega.
intros q H5.
rewrite H5 in H3.
case_eq (leb p q); intro H6.
rewrite H6 in H3.
simpl in H3.
do 2 rewrite <- beq_nat_refl in H3.
discriminate H3.
rewrite leb_iff_conv in H6.
contradict H6.
omega.
rewrite forallb_forall_conv in H1.
destruct H1 as [e [H1 H2] ].

*****
H2 : eq (aeq (arities e) (ok_arities n O)) false
H1 : In e (map (proj n O) (seq O n))
e : BC
Hh1 : eq (arities h1) (ok_arities n (S s))
Hh0 : eq (arities h0) (ok_arities n (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n s)
x,g,h0,h1 : BC
n,s : nat
*****
eq (if andb (aeq (if andb false (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s))) then ok_arities n s else error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) (ok_arities n s)) (andb (aeq (if andb false (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s))) then ok_arities n s else error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) (ok_arities n s)) true) then ok_arities n s else error_comp (ok_arities O (S (S (S (S O))))) nil (cons (ok_arities n s) (cons (ok_arities n s) (cons (if andb false (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s))) then ok_arities n s else error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) (cons (if andb false (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s))) then ok_arities n s else error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) nil))))) (ok_arities n s)
+++++
rewrite in_map_iff in H1.
-----
Lemma arities_cond2 n s x g h0 h1 (Hx : arities x = ok_arities n s) (Hg : arities g = ok_arities n s) (Hh0 : arities h0 = ok_arities n (S s)) (Hh1 : arities h1 = ok_arities n (S s)) : arities (cond2 n s x g h0 h1) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh0, Hh1.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
do 2 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H2 end.
simpl.
do 2 rewrite <- beq_nat_refl.
reflexivity.
rewrite forallb_forall_conv in H2.
destruct H2 as [e [H2 H3] ].
rewrite in_map_iff in H2.
destruct H2 as [p [H2 H4] ].
rewrite in_seq_iff in H4.
subst e.
simpl in H3.
case_eq (n + s).
intro H5.
contradict H5.
omega.
intros q H5.
rewrite H5 in H3.
case_eq (leb p q); intro H6.
rewrite H6 in H3.
simpl in H3.
do 2 rewrite <- beq_nat_refl in H3.
discriminate H3.
rewrite leb_iff_conv in H6.
contradict H6.
omega.
rewrite forallb_forall_conv in H1.
destruct H1 as [e [H1 H2] ].
rewrite in_map_iff in H1.

*****
H2 : eq (aeq (arities e) (ok_arities n O)) false
H1 : ex (fun x : nat => and (eq (proj n O x) e) (In x (seq O n)))
e : BC
Hh1 : eq (arities h1) (ok_arities n (S s))
Hh0 : eq (arities h0) (ok_arities n (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n s)
x,g,h0,h1 : BC
n,s : nat
*****
eq (if andb (aeq (if andb false (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s))) then ok_arities n s else error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) (ok_arities n s)) (andb (aeq (if andb false (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s))) then ok_arities n s else error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) (ok_arities n s)) true) then ok_arities n s else error_comp (ok_arities O (S (S (S (S O))))) nil (cons (ok_arities n s) (cons (ok_arities n s) (cons (if andb false (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s))) then ok_arities n s else error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) (cons (if andb false (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s))) then ok_arities n s else error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) nil))))) (ok_arities n s)
+++++
destruct H1 as [p [H1 H3] ].
-----
Lemma arities_cond2 n s x g h0 h1 (Hx : arities x = ok_arities n s) (Hg : arities g = ok_arities n s) (Hh0 : arities h0 = ok_arities n (S s)) (Hh1 : arities h1 = ok_arities n (S s)) : arities (cond2 n s x g h0 h1) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh0, Hh1.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
do 2 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H2 end.
simpl.
do 2 rewrite <- beq_nat_refl.
reflexivity.
rewrite forallb_forall_conv in H2.
destruct H2 as [e [H2 H3] ].
rewrite in_map_iff in H2.
destruct H2 as [p [H2 H4] ].
rewrite in_seq_iff in H4.
subst e.
simpl in H3.
case_eq (n + s).
intro H5.
contradict H5.
omega.
intros q H5.
rewrite H5 in H3.
case_eq (leb p q); intro H6.
rewrite H6 in H3.
simpl in H3.
do 2 rewrite <- beq_nat_refl in H3.
discriminate H3.
rewrite leb_iff_conv in H6.
contradict H6.
omega.
rewrite forallb_forall_conv in H1.
destruct H1 as [e [H1 H2] ].
rewrite in_map_iff in H1.
destruct H1 as [p [H1 H3] ].

*****
H2 : eq (aeq (arities e) (ok_arities n O)) false
H3 : In p (seq O n)
H1 : eq (proj n O p) e
p : nat
e : BC
Hh1 : eq (arities h1) (ok_arities n (S s))
Hh0 : eq (arities h0) (ok_arities n (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n s)
x,g,h0,h1 : BC
n,s : nat
*****
eq (if andb (aeq (if andb false (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s))) then ok_arities n s else error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) (ok_arities n s)) (andb (aeq (if andb false (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s))) then ok_arities n s else error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) (ok_arities n s)) true) then ok_arities n s else error_comp (ok_arities O (S (S (S (S O))))) nil (cons (ok_arities n s) (cons (ok_arities n s) (cons (if andb false (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s))) then ok_arities n s else error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) (cons (if andb false (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s))) then ok_arities n s else error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) nil))))) (ok_arities n s)
+++++
rewrite in_seq_iff in H3.
-----
Lemma arities_cond2 n s x g h0 h1 (Hx : arities x = ok_arities n s) (Hg : arities g = ok_arities n s) (Hh0 : arities h0 = ok_arities n (S s)) (Hh1 : arities h1 = ok_arities n (S s)) : arities (cond2 n s x g h0 h1) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh0, Hh1.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
do 2 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H2 end.
simpl.
do 2 rewrite <- beq_nat_refl.
reflexivity.
rewrite forallb_forall_conv in H2.
destruct H2 as [e [H2 H3] ].
rewrite in_map_iff in H2.
destruct H2 as [p [H2 H4] ].
rewrite in_seq_iff in H4.
subst e.
simpl in H3.
case_eq (n + s).
intro H5.
contradict H5.
omega.
intros q H5.
rewrite H5 in H3.
case_eq (leb p q); intro H6.
rewrite H6 in H3.
simpl in H3.
do 2 rewrite <- beq_nat_refl in H3.
discriminate H3.
rewrite leb_iff_conv in H6.
contradict H6.
omega.
rewrite forallb_forall_conv in H1.
destruct H1 as [e [H1 H2] ].
rewrite in_map_iff in H1.
destruct H1 as [p [H1 H3] ].
rewrite in_seq_iff in H3.

*****
H2 : eq (aeq (arities e) (ok_arities n O)) false
H3 : and (le O p) (lt p (Init.Nat.add O n))
H1 : eq (proj n O p) e
p : nat
e : BC
Hh1 : eq (arities h1) (ok_arities n (S s))
Hh0 : eq (arities h0) (ok_arities n (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n s)
x,g,h0,h1 : BC
n,s : nat
*****
eq (if andb (aeq (if andb false (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s))) then ok_arities n s else error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) (ok_arities n s)) (andb (aeq (if andb false (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s))) then ok_arities n s else error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) (ok_arities n s)) true) then ok_arities n s else error_comp (ok_arities O (S (S (S (S O))))) nil (cons (ok_arities n s) (cons (ok_arities n s) (cons (if andb false (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s))) then ok_arities n s else error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) (cons (if andb false (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s))) then ok_arities n s else error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) nil))))) (ok_arities n s)
+++++
subst e.
-----
Lemma arities_cond2 n s x g h0 h1 (Hx : arities x = ok_arities n s) (Hg : arities g = ok_arities n s) (Hh0 : arities h0 = ok_arities n (S s)) (Hh1 : arities h1 = ok_arities n (S s)) : arities (cond2 n s x g h0 h1) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh0, Hh1.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
do 2 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H2 end.
simpl.
do 2 rewrite <- beq_nat_refl.
reflexivity.
rewrite forallb_forall_conv in H2.
destruct H2 as [e [H2 H3] ].
rewrite in_map_iff in H2.
destruct H2 as [p [H2 H4] ].
rewrite in_seq_iff in H4.
subst e.
simpl in H3.
case_eq (n + s).
intro H5.
contradict H5.
omega.
intros q H5.
rewrite H5 in H3.
case_eq (leb p q); intro H6.
rewrite H6 in H3.
simpl in H3.
do 2 rewrite <- beq_nat_refl in H3.
discriminate H3.
rewrite leb_iff_conv in H6.
contradict H6.
omega.
rewrite forallb_forall_conv in H1.
destruct H1 as [e [H1 H2] ].
rewrite in_map_iff in H1.
destruct H1 as [p [H1 H3] ].
rewrite in_seq_iff in H3.
subst e.

*****
H2 : eq (aeq (arities (proj n O p)) (ok_arities n O)) false
H3 : and (le O p) (lt p (Init.Nat.add O n))
p : nat
Hh1 : eq (arities h1) (ok_arities n (S s))
Hh0 : eq (arities h0) (ok_arities n (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n s)
x,g,h0,h1 : BC
n,s : nat
*****
eq (if andb (aeq (if andb false (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s))) then ok_arities n s else error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) (ok_arities n s)) (andb (aeq (if andb false (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s))) then ok_arities n s else error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) (ok_arities n s)) true) then ok_arities n s else error_comp (ok_arities O (S (S (S (S O))))) nil (cons (ok_arities n s) (cons (ok_arities n s) (cons (if andb false (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s))) then ok_arities n s else error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) (cons (if andb false (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s))) then ok_arities n s else error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) nil))))) (ok_arities n s)
+++++
simpl in H2.
-----
Lemma arities_cond2 n s x g h0 h1 (Hx : arities x = ok_arities n s) (Hg : arities g = ok_arities n s) (Hh0 : arities h0 = ok_arities n (S s)) (Hh1 : arities h1 = ok_arities n (S s)) : arities (cond2 n s x g h0 h1) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh0, Hh1.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
do 2 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H2 end.
simpl.
do 2 rewrite <- beq_nat_refl.
reflexivity.
rewrite forallb_forall_conv in H2.
destruct H2 as [e [H2 H3] ].
rewrite in_map_iff in H2.
destruct H2 as [p [H2 H4] ].
rewrite in_seq_iff in H4.
subst e.
simpl in H3.
case_eq (n + s).
intro H5.
contradict H5.
omega.
intros q H5.
rewrite H5 in H3.
case_eq (leb p q); intro H6.
rewrite H6 in H3.
simpl in H3.
do 2 rewrite <- beq_nat_refl in H3.
discriminate H3.
rewrite leb_iff_conv in H6.
contradict H6.
omega.
rewrite forallb_forall_conv in H1.
destruct H1 as [e [H1 H2] ].
rewrite in_map_iff in H1.
destruct H1 as [p [H1 H3] ].
rewrite in_seq_iff in H3.
subst e.
simpl in H2.

*****
H2 : eq\n (aeq\n (if\n match Init.Nat.add n O with\n | O => false\n | S m' => Nat.leb p m'\n end\n then ok_arities n O\n else error_proj n O p) (ok_arities n O)) false
H3 : and (le O p) (lt p (Init.Nat.add O n))
p : nat
Hh1 : eq (arities h1) (ok_arities n (S s))
Hh0 : eq (arities h0) (ok_arities n (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n s)
x,g,h0,h1 : BC
n,s : nat
*****
eq (if andb (aeq (if andb false (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s))) then ok_arities n s else error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) (ok_arities n s)) (andb (aeq (if andb false (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s))) then ok_arities n s else error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) (ok_arities n s)) true) then ok_arities n s else error_comp (ok_arities O (S (S (S (S O))))) nil (cons (ok_arities n s) (cons (ok_arities n s) (cons (if andb false (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s))) then ok_arities n s else error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) (cons (if andb false (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s))) then ok_arities n s else error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) nil))))) (ok_arities n s)
+++++
case_eq (n + 0).
-----
Lemma arities_cond2 n s x g h0 h1 (Hx : arities x = ok_arities n s) (Hg : arities g = ok_arities n s) (Hh0 : arities h0 = ok_arities n (S s)) (Hh1 : arities h1 = ok_arities n (S s)) : arities (cond2 n s x g h0 h1) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh0, Hh1.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
do 2 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H2 end.
simpl.
do 2 rewrite <- beq_nat_refl.
reflexivity.
rewrite forallb_forall_conv in H2.
destruct H2 as [e [H2 H3] ].
rewrite in_map_iff in H2.
destruct H2 as [p [H2 H4] ].
rewrite in_seq_iff in H4.
subst e.
simpl in H3.
case_eq (n + s).
intro H5.
contradict H5.
omega.
intros q H5.
rewrite H5 in H3.
case_eq (leb p q); intro H6.
rewrite H6 in H3.
simpl in H3.
do 2 rewrite <- beq_nat_refl in H3.
discriminate H3.
rewrite leb_iff_conv in H6.
contradict H6.
omega.
rewrite forallb_forall_conv in H1.
destruct H1 as [e [H1 H2] ].
rewrite in_map_iff in H1.
destruct H1 as [p [H1 H3] ].
rewrite in_seq_iff in H3.
subst e.
simpl in H2.
case_eq (n + 0).

*****
H2 : eq\n (aeq\n (if\n match Init.Nat.add n O with\n | O => false\n | S m' => Nat.leb p m'\n end\n then ok_arities n O\n else error_proj n O p) (ok_arities n O)) false
H3 : and (le O p) (lt p (Init.Nat.add O n))
p : nat
Hh1 : eq (arities h1) (ok_arities n (S s))
Hh0 : eq (arities h0) (ok_arities n (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n s)
x,g,h0,h1 : BC
n,s : nat
*****
forall _ : eq (Init.Nat.add n O) O, eq (if andb (aeq (if andb false (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s))) then ok_arities n s else error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) (ok_arities n s)) (andb (aeq (if andb false (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s))) then ok_arities n s else error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) (ok_arities n s)) true) then ok_arities n s else error_comp (ok_arities O (S (S (S (S O))))) nil (cons (ok_arities n s) (cons (ok_arities n s) (cons (if andb false (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s))) then ok_arities n s else error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) (cons (if andb false (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s))) then ok_arities n s else error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) nil))))) (ok_arities n s)
+++++
intro H4.
-----
Lemma arities_cond2 n s x g h0 h1 (Hx : arities x = ok_arities n s) (Hg : arities g = ok_arities n s) (Hh0 : arities h0 = ok_arities n (S s)) (Hh1 : arities h1 = ok_arities n (S s)) : arities (cond2 n s x g h0 h1) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh0, Hh1.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
do 2 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H2 end.
simpl.
do 2 rewrite <- beq_nat_refl.
reflexivity.
rewrite forallb_forall_conv in H2.
destruct H2 as [e [H2 H3] ].
rewrite in_map_iff in H2.
destruct H2 as [p [H2 H4] ].
rewrite in_seq_iff in H4.
subst e.
simpl in H3.
case_eq (n + s).
intro H5.
contradict H5.
omega.
intros q H5.
rewrite H5 in H3.
case_eq (leb p q); intro H6.
rewrite H6 in H3.
simpl in H3.
do 2 rewrite <- beq_nat_refl in H3.
discriminate H3.
rewrite leb_iff_conv in H6.
contradict H6.
omega.
rewrite forallb_forall_conv in H1.
destruct H1 as [e [H1 H2] ].
rewrite in_map_iff in H1.
destruct H1 as [p [H1 H3] ].
rewrite in_seq_iff in H3.
subst e.
simpl in H2.
case_eq (n + 0).
intro H4.

*****
H4 : eq (Init.Nat.add n O) O
H2 : eq\n (aeq\n (if\n match Init.Nat.add n O with\n | O => false\n | S m' => Nat.leb p m'\n end\n then ok_arities n O\n else error_proj n O p) (ok_arities n O)) false
H3 : and (le O p) (lt p (Init.Nat.add O n))
p : nat
Hh1 : eq (arities h1) (ok_arities n (S s))
Hh0 : eq (arities h0) (ok_arities n (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n s)
x,g,h0,h1 : BC
n,s : nat
*****
eq (if andb (aeq (if andb false (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s))) then ok_arities n s else error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) (ok_arities n s)) (andb (aeq (if andb false (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s))) then ok_arities n s else error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) (ok_arities n s)) true) then ok_arities n s else error_comp (ok_arities O (S (S (S (S O))))) nil (cons (ok_arities n s) (cons (ok_arities n s) (cons (if andb false (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s))) then ok_arities n s else error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) (cons (if andb false (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s))) then ok_arities n s else error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) nil))))) (ok_arities n s)
+++++
contradict H4.
-----
Lemma arities_cond2 n s x g h0 h1 (Hx : arities x = ok_arities n s) (Hg : arities g = ok_arities n s) (Hh0 : arities h0 = ok_arities n (S s)) (Hh1 : arities h1 = ok_arities n (S s)) : arities (cond2 n s x g h0 h1) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh0, Hh1.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
do 2 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H2 end.
simpl.
do 2 rewrite <- beq_nat_refl.
reflexivity.
rewrite forallb_forall_conv in H2.
destruct H2 as [e [H2 H3] ].
rewrite in_map_iff in H2.
destruct H2 as [p [H2 H4] ].
rewrite in_seq_iff in H4.
subst e.
simpl in H3.
case_eq (n + s).
intro H5.
contradict H5.
omega.
intros q H5.
rewrite H5 in H3.
case_eq (leb p q); intro H6.
rewrite H6 in H3.
simpl in H3.
do 2 rewrite <- beq_nat_refl in H3.
discriminate H3.
rewrite leb_iff_conv in H6.
contradict H6.
omega.
rewrite forallb_forall_conv in H1.
destruct H1 as [e [H1 H2] ].
rewrite in_map_iff in H1.
destruct H1 as [p [H1 H3] ].
rewrite in_seq_iff in H3.
subst e.
simpl in H2.
case_eq (n + 0).
intro H4.
contradict H4.

*****
H2 : eq\n (aeq\n (if\n match Init.Nat.add n O with\n | O => false\n | S m' => Nat.leb p m'\n end\n then ok_arities n O\n else error_proj n O p) (ok_arities n O)) false
H3 : and (le O p) (lt p (Init.Nat.add O n))
p : nat
Hh1 : eq (arities h1) (ok_arities n (S s))
Hh0 : eq (arities h0) (ok_arities n (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n s)
x,g,h0,h1 : BC
n,s : nat
*****
not (eq (Init.Nat.add n O) O)
+++++
omega.
-----
Lemma arities_cond2 n s x g h0 h1 (Hx : arities x = ok_arities n s) (Hg : arities g = ok_arities n s) (Hh0 : arities h0 = ok_arities n (S s)) (Hh1 : arities h1 = ok_arities n (S s)) : arities (cond2 n s x g h0 h1) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh0, Hh1.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
do 2 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H2 end.
simpl.
do 2 rewrite <- beq_nat_refl.
reflexivity.
rewrite forallb_forall_conv in H2.
destruct H2 as [e [H2 H3] ].
rewrite in_map_iff in H2.
destruct H2 as [p [H2 H4] ].
rewrite in_seq_iff in H4.
subst e.
simpl in H3.
case_eq (n + s).
intro H5.
contradict H5.
omega.
intros q H5.
rewrite H5 in H3.
case_eq (leb p q); intro H6.
rewrite H6 in H3.
simpl in H3.
do 2 rewrite <- beq_nat_refl in H3.
discriminate H3.
rewrite leb_iff_conv in H6.
contradict H6.
omega.
rewrite forallb_forall_conv in H1.
destruct H1 as [e [H1 H2] ].
rewrite in_map_iff in H1.
destruct H1 as [p [H1 H3] ].
rewrite in_seq_iff in H3.
subst e.
simpl in H2.
case_eq (n + 0).
intro H4.
contradict H4.
omega.

*****
H2 : eq\n (aeq\n (if\n match Init.Nat.add n O with\n | O => false\n | S m' => Nat.leb p m'\n end\n then ok_arities n O\n else error_proj n O p) (ok_arities n O)) false
H3 : and (le O p) (lt p (Init.Nat.add O n))
p : nat
Hh1 : eq (arities h1) (ok_arities n (S s))
Hh0 : eq (arities h0) (ok_arities n (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n s)
x,g,h0,h1 : BC
n,s : nat
*****
forall (n0 : nat) (_ : eq (Init.Nat.add n O) (S n0)), eq (if andb (aeq (if andb false (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s))) then ok_arities n s else error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) (ok_arities n s)) (andb (aeq (if andb false (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s))) then ok_arities n s else error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) (ok_arities n s)) true) then ok_arities n s else error_comp (ok_arities O (S (S (S (S O))))) nil (cons (ok_arities n s) (cons (ok_arities n s) (cons (if andb false (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s))) then ok_arities n s else error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) (cons (if andb false (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s))) then ok_arities n s else error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) nil))))) (ok_arities n s)
+++++
intros q H4.
-----
Lemma arities_cond2 n s x g h0 h1 (Hx : arities x = ok_arities n s) (Hg : arities g = ok_arities n s) (Hh0 : arities h0 = ok_arities n (S s)) (Hh1 : arities h1 = ok_arities n (S s)) : arities (cond2 n s x g h0 h1) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh0, Hh1.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
do 2 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H2 end.
simpl.
do 2 rewrite <- beq_nat_refl.
reflexivity.
rewrite forallb_forall_conv in H2.
destruct H2 as [e [H2 H3] ].
rewrite in_map_iff in H2.
destruct H2 as [p [H2 H4] ].
rewrite in_seq_iff in H4.
subst e.
simpl in H3.
case_eq (n + s).
intro H5.
contradict H5.
omega.
intros q H5.
rewrite H5 in H3.
case_eq (leb p q); intro H6.
rewrite H6 in H3.
simpl in H3.
do 2 rewrite <- beq_nat_refl in H3.
discriminate H3.
rewrite leb_iff_conv in H6.
contradict H6.
omega.
rewrite forallb_forall_conv in H1.
destruct H1 as [e [H1 H2] ].
rewrite in_map_iff in H1.
destruct H1 as [p [H1 H3] ].
rewrite in_seq_iff in H3.
subst e.
simpl in H2.
case_eq (n + 0).
intro H4.
contradict H4.
omega.
intros q H4.

*****
H4 : eq (Init.Nat.add n O) (S q)
q : nat
H2 : eq\n (aeq\n (if\n match Init.Nat.add n O with\n | O => false\n | S m' => Nat.leb p m'\n end\n then ok_arities n O\n else error_proj n O p) (ok_arities n O)) false
H3 : and (le O p) (lt p (Init.Nat.add O n))
p : nat
Hh1 : eq (arities h1) (ok_arities n (S s))
Hh0 : eq (arities h0) (ok_arities n (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n s)
x,g,h0,h1 : BC
n,s : nat
*****
eq (if andb (aeq (if andb false (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s))) then ok_arities n s else error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) (ok_arities n s)) (andb (aeq (if andb false (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s))) then ok_arities n s else error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) (ok_arities n s)) true) then ok_arities n s else error_comp (ok_arities O (S (S (S (S O))))) nil (cons (ok_arities n s) (cons (ok_arities n s) (cons (if andb false (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s))) then ok_arities n s else error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) (cons (if andb false (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s))) then ok_arities n s else error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) nil))))) (ok_arities n s)
+++++
rewrite H4 in H2.
-----
Lemma arities_cond2 n s x g h0 h1 (Hx : arities x = ok_arities n s) (Hg : arities g = ok_arities n s) (Hh0 : arities h0 = ok_arities n (S s)) (Hh1 : arities h1 = ok_arities n (S s)) : arities (cond2 n s x g h0 h1) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh0, Hh1.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
do 2 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H2 end.
simpl.
do 2 rewrite <- beq_nat_refl.
reflexivity.
rewrite forallb_forall_conv in H2.
destruct H2 as [e [H2 H3] ].
rewrite in_map_iff in H2.
destruct H2 as [p [H2 H4] ].
rewrite in_seq_iff in H4.
subst e.
simpl in H3.
case_eq (n + s).
intro H5.
contradict H5.
omega.
intros q H5.
rewrite H5 in H3.
case_eq (leb p q); intro H6.
rewrite H6 in H3.
simpl in H3.
do 2 rewrite <- beq_nat_refl in H3.
discriminate H3.
rewrite leb_iff_conv in H6.
contradict H6.
omega.
rewrite forallb_forall_conv in H1.
destruct H1 as [e [H1 H2] ].
rewrite in_map_iff in H1.
destruct H1 as [p [H1 H3] ].
rewrite in_seq_iff in H3.
subst e.
simpl in H2.
case_eq (n + 0).
intro H4.
contradict H4.
omega.
intros q H4.
rewrite H4 in H2.

*****
H4 : eq (Init.Nat.add n O) (S q)
H2 : eq\n (aeq (if Nat.leb p q then ok_arities n O else error_proj n O p)\n (ok_arities n O)) false
q : nat
H3 : and (le O p) (lt p (Init.Nat.add O n))
p : nat
Hh1 : eq (arities h1) (ok_arities n (S s))
Hh0 : eq (arities h0) (ok_arities n (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n s)
x,g,h0,h1 : BC
n,s : nat
*****
eq (if andb (aeq (if andb false (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s))) then ok_arities n s else error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) (ok_arities n s)) (andb (aeq (if andb false (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s))) then ok_arities n s else error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) (ok_arities n s)) true) then ok_arities n s else error_comp (ok_arities O (S (S (S (S O))))) nil (cons (ok_arities n s) (cons (ok_arities n s) (cons (if andb false (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s))) then ok_arities n s else error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) (cons (if andb false (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s))) then ok_arities n s else error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) nil))))) (ok_arities n s)
+++++
case_eq (leb p q); intro H5.
-----
Lemma arities_cond2 n s x g h0 h1 (Hx : arities x = ok_arities n s) (Hg : arities g = ok_arities n s) (Hh0 : arities h0 = ok_arities n (S s)) (Hh1 : arities h1 = ok_arities n (S s)) : arities (cond2 n s x g h0 h1) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh0, Hh1.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
do 2 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H2 end.
simpl.
do 2 rewrite <- beq_nat_refl.
reflexivity.
rewrite forallb_forall_conv in H2.
destruct H2 as [e [H2 H3] ].
rewrite in_map_iff in H2.
destruct H2 as [p [H2 H4] ].
rewrite in_seq_iff in H4.
subst e.
simpl in H3.
case_eq (n + s).
intro H5.
contradict H5.
omega.
intros q H5.
rewrite H5 in H3.
case_eq (leb p q); intro H6.
rewrite H6 in H3.
simpl in H3.
do 2 rewrite <- beq_nat_refl in H3.
discriminate H3.
rewrite leb_iff_conv in H6.
contradict H6.
omega.
rewrite forallb_forall_conv in H1.
destruct H1 as [e [H1 H2] ].
rewrite in_map_iff in H1.
destruct H1 as [p [H1 H3] ].
rewrite in_seq_iff in H3.
subst e.
simpl in H2.
case_eq (n + 0).
intro H4.
contradict H4.
omega.
intros q H4.
rewrite H4 in H2.
case_eq (leb p q); intro H5.

*****
H5 : eq (Nat.leb p q) true
H4 : eq (Init.Nat.add n O) (S q)
H2 : eq\n (aeq (if Nat.leb p q then ok_arities n O else error_proj n O p)\n (ok_arities n O)) false
q : nat
H3 : and (le O p) (lt p (Init.Nat.add O n))
p : nat
Hh1 : eq (arities h1) (ok_arities n (S s))
Hh0 : eq (arities h0) (ok_arities n (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n s)
x,g,h0,h1 : BC
n,s : nat
*****
eq (if andb (aeq (if andb false (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s))) then ok_arities n s else error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) (ok_arities n s)) (andb (aeq (if andb false (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s))) then ok_arities n s else error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) (ok_arities n s)) true) then ok_arities n s else error_comp (ok_arities O (S (S (S (S O))))) nil (cons (ok_arities n s) (cons (ok_arities n s) (cons (if andb false (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s))) then ok_arities n s else error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) (cons (if andb false (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s))) then ok_arities n s else error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) nil))))) (ok_arities n s)
+++++
rewrite H5 in H2.
-----
Lemma arities_cond2 n s x g h0 h1 (Hx : arities x = ok_arities n s) (Hg : arities g = ok_arities n s) (Hh0 : arities h0 = ok_arities n (S s)) (Hh1 : arities h1 = ok_arities n (S s)) : arities (cond2 n s x g h0 h1) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh0, Hh1.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
do 2 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H2 end.
simpl.
do 2 rewrite <- beq_nat_refl.
reflexivity.
rewrite forallb_forall_conv in H2.
destruct H2 as [e [H2 H3] ].
rewrite in_map_iff in H2.
destruct H2 as [p [H2 H4] ].
rewrite in_seq_iff in H4.
subst e.
simpl in H3.
case_eq (n + s).
intro H5.
contradict H5.
omega.
intros q H5.
rewrite H5 in H3.
case_eq (leb p q); intro H6.
rewrite H6 in H3.
simpl in H3.
do 2 rewrite <- beq_nat_refl in H3.
discriminate H3.
rewrite leb_iff_conv in H6.
contradict H6.
omega.
rewrite forallb_forall_conv in H1.
destruct H1 as [e [H1 H2] ].
rewrite in_map_iff in H1.
destruct H1 as [p [H1 H3] ].
rewrite in_seq_iff in H3.
subst e.
simpl in H2.
case_eq (n + 0).
intro H4.
contradict H4.
omega.
intros q H4.
rewrite H4 in H2.
case_eq (leb p q); intro H5.
rewrite H5 in H2.

*****
H5 : eq (Nat.leb p q) true
H4 : eq (Init.Nat.add n O) (S q)
H2 : eq (aeq (ok_arities n O) (ok_arities n O)) false
q : nat
H3 : and (le O p) (lt p (Init.Nat.add O n))
p : nat
Hh1 : eq (arities h1) (ok_arities n (S s))
Hh0 : eq (arities h0) (ok_arities n (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n s)
x,g,h0,h1 : BC
n,s : nat
*****
eq (if andb (aeq (if andb false (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s))) then ok_arities n s else error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) (ok_arities n s)) (andb (aeq (if andb false (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s))) then ok_arities n s else error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) (ok_arities n s)) true) then ok_arities n s else error_comp (ok_arities O (S (S (S (S O))))) nil (cons (ok_arities n s) (cons (ok_arities n s) (cons (if andb false (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s))) then ok_arities n s else error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) (cons (if andb false (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s))) then ok_arities n s else error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) nil))))) (ok_arities n s)
+++++
simpl in H2.
-----
Lemma arities_cond2 n s x g h0 h1 (Hx : arities x = ok_arities n s) (Hg : arities g = ok_arities n s) (Hh0 : arities h0 = ok_arities n (S s)) (Hh1 : arities h1 = ok_arities n (S s)) : arities (cond2 n s x g h0 h1) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh0, Hh1.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
do 2 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H2 end.
simpl.
do 2 rewrite <- beq_nat_refl.
reflexivity.
rewrite forallb_forall_conv in H2.
destruct H2 as [e [H2 H3] ].
rewrite in_map_iff in H2.
destruct H2 as [p [H2 H4] ].
rewrite in_seq_iff in H4.
subst e.
simpl in H3.
case_eq (n + s).
intro H5.
contradict H5.
omega.
intros q H5.
rewrite H5 in H3.
case_eq (leb p q); intro H6.
rewrite H6 in H3.
simpl in H3.
do 2 rewrite <- beq_nat_refl in H3.
discriminate H3.
rewrite leb_iff_conv in H6.
contradict H6.
omega.
rewrite forallb_forall_conv in H1.
destruct H1 as [e [H1 H2] ].
rewrite in_map_iff in H1.
destruct H1 as [p [H1 H3] ].
rewrite in_seq_iff in H3.
subst e.
simpl in H2.
case_eq (n + 0).
intro H4.
contradict H4.
omega.
intros q H4.
rewrite H4 in H2.
case_eq (leb p q); intro H5.
rewrite H5 in H2.
simpl in H2.

*****
H5 : eq (Nat.leb p q) true
H4 : eq (Init.Nat.add n O) (S q)
H2 : eq (andb (Nat.eqb n n) true) false
q : nat
H3 : and (le O p) (lt p (Init.Nat.add O n))
p : nat
Hh1 : eq (arities h1) (ok_arities n (S s))
Hh0 : eq (arities h0) (ok_arities n (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n s)
x,g,h0,h1 : BC
n,s : nat
*****
eq (if andb (aeq (if andb false (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s))) then ok_arities n s else error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) (ok_arities n s)) (andb (aeq (if andb false (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s))) then ok_arities n s else error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) (ok_arities n s)) true) then ok_arities n s else error_comp (ok_arities O (S (S (S (S O))))) nil (cons (ok_arities n s) (cons (ok_arities n s) (cons (if andb false (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s))) then ok_arities n s else error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) (cons (if andb false (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s))) then ok_arities n s else error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) nil))))) (ok_arities n s)
+++++
rewrite <- beq_nat_refl in H2.
-----
Lemma arities_cond2 n s x g h0 h1 (Hx : arities x = ok_arities n s) (Hg : arities g = ok_arities n s) (Hh0 : arities h0 = ok_arities n (S s)) (Hh1 : arities h1 = ok_arities n (S s)) : arities (cond2 n s x g h0 h1) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh0, Hh1.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
do 2 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H2 end.
simpl.
do 2 rewrite <- beq_nat_refl.
reflexivity.
rewrite forallb_forall_conv in H2.
destruct H2 as [e [H2 H3] ].
rewrite in_map_iff in H2.
destruct H2 as [p [H2 H4] ].
rewrite in_seq_iff in H4.
subst e.
simpl in H3.
case_eq (n + s).
intro H5.
contradict H5.
omega.
intros q H5.
rewrite H5 in H3.
case_eq (leb p q); intro H6.
rewrite H6 in H3.
simpl in H3.
do 2 rewrite <- beq_nat_refl in H3.
discriminate H3.
rewrite leb_iff_conv in H6.
contradict H6.
omega.
rewrite forallb_forall_conv in H1.
destruct H1 as [e [H1 H2] ].
rewrite in_map_iff in H1.
destruct H1 as [p [H1 H3] ].
rewrite in_seq_iff in H3.
subst e.
simpl in H2.
case_eq (n + 0).
intro H4.
contradict H4.
omega.
intros q H4.
rewrite H4 in H2.
case_eq (leb p q); intro H5.
rewrite H5 in H2.
simpl in H2.
rewrite <- beq_nat_refl in H2.

*****
H5 : eq (Nat.leb p q) true
H4 : eq (Init.Nat.add n O) (S q)
H2 : eq (andb true true) false
q : nat
H3 : and (le O p) (lt p (Init.Nat.add O n))
p : nat
Hh1 : eq (arities h1) (ok_arities n (S s))
Hh0 : eq (arities h0) (ok_arities n (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n s)
x,g,h0,h1 : BC
n,s : nat
*****
eq (if andb (aeq (if andb false (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s))) then ok_arities n s else error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) (ok_arities n s)) (andb (aeq (if andb false (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s))) then ok_arities n s else error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) (ok_arities n s)) true) then ok_arities n s else error_comp (ok_arities O (S (S (S (S O))))) nil (cons (ok_arities n s) (cons (ok_arities n s) (cons (if andb false (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s))) then ok_arities n s else error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) (cons (if andb false (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s))) then ok_arities n s else error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) nil))))) (ok_arities n s)
+++++
discriminate H2.
-----
Lemma arities_cond2 n s x g h0 h1 (Hx : arities x = ok_arities n s) (Hg : arities g = ok_arities n s) (Hh0 : arities h0 = ok_arities n (S s)) (Hh1 : arities h1 = ok_arities n (S s)) : arities (cond2 n s x g h0 h1) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh0, Hh1.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
do 2 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H2 end.
simpl.
do 2 rewrite <- beq_nat_refl.
reflexivity.
rewrite forallb_forall_conv in H2.
destruct H2 as [e [H2 H3] ].
rewrite in_map_iff in H2.
destruct H2 as [p [H2 H4] ].
rewrite in_seq_iff in H4.
subst e.
simpl in H3.
case_eq (n + s).
intro H5.
contradict H5.
omega.
intros q H5.
rewrite H5 in H3.
case_eq (leb p q); intro H6.
rewrite H6 in H3.
simpl in H3.
do 2 rewrite <- beq_nat_refl in H3.
discriminate H3.
rewrite leb_iff_conv in H6.
contradict H6.
omega.
rewrite forallb_forall_conv in H1.
destruct H1 as [e [H1 H2] ].
rewrite in_map_iff in H1.
destruct H1 as [p [H1 H3] ].
rewrite in_seq_iff in H3.
subst e.
simpl in H2.
case_eq (n + 0).
intro H4.
contradict H4.
omega.
intros q H4.
rewrite H4 in H2.
case_eq (leb p q); intro H5.
rewrite H5 in H2.
simpl in H2.
rewrite <- beq_nat_refl in H2.
discriminate H2.

*****
H5 : eq (Nat.leb p q) false
H4 : eq (Init.Nat.add n O) (S q)
H2 : eq\n (aeq (if Nat.leb p q then ok_arities n O else error_proj n O p)\n (ok_arities n O)) false
q : nat
H3 : and (le O p) (lt p (Init.Nat.add O n))
p : nat
Hh1 : eq (arities h1) (ok_arities n (S s))
Hh0 : eq (arities h0) (ok_arities n (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n s)
x,g,h0,h1 : BC
n,s : nat
*****
eq (if andb (aeq (if andb false (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s))) then ok_arities n s else error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) (ok_arities n s)) (andb (aeq (if andb false (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s))) then ok_arities n s else error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) (ok_arities n s)) true) then ok_arities n s else error_comp (ok_arities O (S (S (S (S O))))) nil (cons (ok_arities n s) (cons (ok_arities n s) (cons (if andb false (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s))) then ok_arities n s else error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) (cons (if andb false (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s))) then ok_arities n s else error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) nil))))) (ok_arities n s)
+++++
rewrite leb_iff_conv in H5.
-----
Lemma arities_cond2 n s x g h0 h1 (Hx : arities x = ok_arities n s) (Hg : arities g = ok_arities n s) (Hh0 : arities h0 = ok_arities n (S s)) (Hh1 : arities h1 = ok_arities n (S s)) : arities (cond2 n s x g h0 h1) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh0, Hh1.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
do 2 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H2 end.
simpl.
do 2 rewrite <- beq_nat_refl.
reflexivity.
rewrite forallb_forall_conv in H2.
destruct H2 as [e [H2 H3] ].
rewrite in_map_iff in H2.
destruct H2 as [p [H2 H4] ].
rewrite in_seq_iff in H4.
subst e.
simpl in H3.
case_eq (n + s).
intro H5.
contradict H5.
omega.
intros q H5.
rewrite H5 in H3.
case_eq (leb p q); intro H6.
rewrite H6 in H3.
simpl in H3.
do 2 rewrite <- beq_nat_refl in H3.
discriminate H3.
rewrite leb_iff_conv in H6.
contradict H6.
omega.
rewrite forallb_forall_conv in H1.
destruct H1 as [e [H1 H2] ].
rewrite in_map_iff in H1.
destruct H1 as [p [H1 H3] ].
rewrite in_seq_iff in H3.
subst e.
simpl in H2.
case_eq (n + 0).
intro H4.
contradict H4.
omega.
intros q H4.
rewrite H4 in H2.
case_eq (leb p q); intro H5.
rewrite H5 in H2.
simpl in H2.
rewrite <- beq_nat_refl in H2.
discriminate H2.
rewrite leb_iff_conv in H5.

*****
H5 : lt q p
H4 : eq (Init.Nat.add n O) (S q)
H2 : eq\n (aeq (if Nat.leb p q then ok_arities n O else error_proj n O p)\n (ok_arities n O)) false
q : nat
H3 : and (le O p) (lt p (Init.Nat.add O n))
p : nat
Hh1 : eq (arities h1) (ok_arities n (S s))
Hh0 : eq (arities h0) (ok_arities n (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n s)
x,g,h0,h1 : BC
n,s : nat
*****
eq (if andb (aeq (if andb false (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s))) then ok_arities n s else error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) (ok_arities n s)) (andb (aeq (if andb false (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s))) then ok_arities n s else error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) (ok_arities n s)) true) then ok_arities n s else error_comp (ok_arities O (S (S (S (S O))))) nil (cons (ok_arities n s) (cons (ok_arities n s) (cons (if andb false (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s))) then ok_arities n s else error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) (cons (if andb false (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s))) then ok_arities n s else error_comp (ok_arities n (S s)) (map arities (map (proj n O) (seq O n))) (cons (ok_arities n s) (map arities (map (proj n s) (seq n s))))) nil))))) (ok_arities n s)
+++++
contradict H5.
-----
Lemma arities_cond2 n s x g h0 h1 (Hx : arities x = ok_arities n s) (Hg : arities g = ok_arities n s) (Hh0 : arities h0 = ok_arities n (S s)) (Hh1 : arities h1 = ok_arities n (S s)) : arities (cond2 n s x g h0 h1) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh0, Hh1.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
do 2 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H2 end.
simpl.
do 2 rewrite <- beq_nat_refl.
reflexivity.
rewrite forallb_forall_conv in H2.
destruct H2 as [e [H2 H3] ].
rewrite in_map_iff in H2.
destruct H2 as [p [H2 H4] ].
rewrite in_seq_iff in H4.
subst e.
simpl in H3.
case_eq (n + s).
intro H5.
contradict H5.
omega.
intros q H5.
rewrite H5 in H3.
case_eq (leb p q); intro H6.
rewrite H6 in H3.
simpl in H3.
do 2 rewrite <- beq_nat_refl in H3.
discriminate H3.
rewrite leb_iff_conv in H6.
contradict H6.
omega.
rewrite forallb_forall_conv in H1.
destruct H1 as [e [H1 H2] ].
rewrite in_map_iff in H1.
destruct H1 as [p [H1 H3] ].
rewrite in_seq_iff in H3.
subst e.
simpl in H2.
case_eq (n + 0).
intro H4.
contradict H4.
omega.
intros q H4.
rewrite H4 in H2.
case_eq (leb p q); intro H5.
rewrite H5 in H2.
simpl in H2.
rewrite <- beq_nat_refl in H2.
discriminate H2.
rewrite leb_iff_conv in H5.
contradict H5.

*****
H4 : eq (Init.Nat.add n O) (S q)
H2 : eq\n (aeq (if Nat.leb p q then ok_arities n O else error_proj n O p)\n (ok_arities n O)) false
q : nat
H3 : and (le O p) (lt p (Init.Nat.add O n))
p : nat
Hh1 : eq (arities h1) (ok_arities n (S s))
Hh0 : eq (arities h0) (ok_arities n (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n s)
x,g,h0,h1 : BC
n,s : nat
*****
not (lt q p)
+++++
omega.
-----
Lemma arities_cond2 n s x g h0 h1 (Hx : arities x = ok_arities n s) (Hg : arities g = ok_arities n s) (Hh0 : arities h0 = ok_arities n (S s)) (Hh1 : arities h1 = ok_arities n (S s)) : arities (cond2 n s x g h0 h1) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh0, Hh1.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
do 2 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H2 end.
simpl.
do 2 rewrite <- beq_nat_refl.
reflexivity.
rewrite forallb_forall_conv in H2.
destruct H2 as [e [H2 H3] ].
rewrite in_map_iff in H2.
destruct H2 as [p [H2 H4] ].
rewrite in_seq_iff in H4.
subst e.
simpl in H3.
case_eq (n + s).
intro H5.
contradict H5.
omega.
intros q H5.
rewrite H5 in H3.
case_eq (leb p q); intro H6.
rewrite H6 in H3.
simpl in H3.
do 2 rewrite <- beq_nat_refl in H3.
discriminate H3.
rewrite leb_iff_conv in H6.
contradict H6.
omega.
rewrite forallb_forall_conv in H1.
destruct H1 as [e [H1 H2] ].
rewrite in_map_iff in H1.
destruct H1 as [p [H1 H3] ].
rewrite in_seq_iff in H3.
subst e.
simpl in H2.
case_eq (n + 0).
intro H4.
contradict H4.
omega.
intros q H4.
rewrite H4 in H2.
case_eq (leb p q); intro H5.
rewrite H5 in H2.
simpl in H2.
rewrite <- beq_nat_refl in H2.
discriminate H2.
rewrite leb_iff_conv in H5.
contradict H5.
omega.

*****

*****

+++++
Qed.
-----
Definition cond2_correct n s x g h0 h1 vnl vsl :\n  length vnl = n ->\n  length vsl = s ->\n  sem (cond2 n s x g h0 h1) vnl vsl =\n  match sem x vnl vsl with\n  | nil => sem g vnl vsl\n  | true  :: _ => sem h0 vnl (tl (sem x vnl vsl) :: vsl)\n  | false :: _ => sem h1 vnl (tl (sem x vnl vsl) :: vsl)\n  end.
-----
Definition cond2_correct n s x g h0 h1 vnl vsl : length vnl = n -> length vsl = s -> sem (cond2 n s x g h0 h1) vnl vsl = match sem x vnl vsl with | nil => sem g vnl vsl | true :: _ => sem h0 vnl (tl (sem x vnl vsl) :: vsl) | false :: _ => sem h1 vnl (tl (sem x vnl vsl) :: vsl) end.

*****
vnl,vsl : list (list bool)
x,g,h0,h1 : BC
n,s : nat
*****
forall (_ : eq (length vnl) n) (_ : eq (length vsl) s), eq (sem (cond2 n s x g h0 h1) vnl vsl) match sem x vnl vsl with | nil => sem g vnl vsl | cons true _ => sem h0 vnl (cons (tl (sem x vnl vsl)) vsl) | cons false _ => sem h1 vnl (cons (tl (sem x vnl vsl)) vsl) end
+++++
Proof.
-----
Definition cond2_correct n s x g h0 h1 vnl vsl : length vnl = n -> length vsl = s -> sem (cond2 n s x g h0 h1) vnl vsl = match sem x vnl vsl with | nil => sem g vnl vsl | true :: _ => sem h0 vnl (tl (sem x vnl vsl) :: vsl) | false :: _ => sem h1 vnl (tl (sem x vnl vsl) :: vsl) end.
Proof.

*****
vnl,vsl : list (list bool)
x,g,h0,h1 : BC
n,s : nat
*****
forall (_ : eq (length vnl) n) (_ : eq (length vsl) s), eq (sem (cond2 n s x g h0 h1) vnl vsl) match sem x vnl vsl with | nil => sem g vnl vsl | cons true _ => sem h0 vnl (cons (tl (sem x vnl vsl)) vsl) | cons false _ => sem h1 vnl (cons (tl (sem x vnl vsl)) vsl) end
+++++
intros Hn Hs.
-----
Definition cond2_correct n s x g h0 h1 vnl vsl : length vnl = n -> length vsl = s -> sem (cond2 n s x g h0 h1) vnl vsl = match sem x vnl vsl with | nil => sem g vnl vsl | true :: _ => sem h0 vnl (tl (sem x vnl vsl) :: vsl) | false :: _ => sem h1 vnl (tl (sem x vnl vsl) :: vsl) end.
Proof.
intros Hn Hs.

*****
Hs : eq (length vsl) s
Hn : eq (length vnl) n
vnl,vsl : list (list bool)
x,g,h0,h1 : BC
n,s : nat
*****
eq (sem (cond2 n s x g h0 h1) vnl vsl) match sem x vnl vsl with | nil => sem g vnl vsl | cons true _ => sem h0 vnl (cons (tl (sem x vnl vsl)) vsl) | cons false _ => sem h1 vnl (cons (tl (sem x vnl vsl)) vsl) end
+++++
simpl.
-----
Definition cond2_correct n s x g h0 h1 vnl vsl : length vnl = n -> length vsl = s -> sem (cond2 n s x g h0 h1) vnl vsl = match sem x vnl vsl with | nil => sem g vnl vsl | true :: _ => sem h0 vnl (tl (sem x vnl vsl) :: vsl) | false :: _ => sem h1 vnl (tl (sem x vnl vsl) :: vsl) end.
Proof.
intros Hn Hs.
simpl.

*****
Hs : eq (length vsl) s
Hn : eq (length vnl) n
vnl,vsl : list (list bool)
x,g,h0,h1 : BC
n,s : nat
*****
eq match sem x vnl vsl with | nil => sem g vnl vsl | cons true _ => sem h0 (map (fun ne : BC => sem ne vnl nil) (map (proj n O) (seq O n))) (cons (tl (sem x vnl vsl)) (map (fun se : BC => sem se vnl vsl) (map (proj n s) (seq n s)))) | cons false _ => sem h1 (map (fun ne : BC => sem ne vnl nil) (map (proj n O) (seq O n))) (cons (tl (sem x vnl vsl)) (map (fun se : BC => sem se vnl vsl) (map (proj n s) (seq n s)))) end match sem x vnl vsl with | nil => sem g vnl vsl | cons true _ => sem h0 vnl (cons (tl (sem x vnl vsl)) vsl) | cons false _ => sem h1 vnl (cons (tl (sem x vnl vsl)) vsl) end
+++++
destruct (sem x vnl vsl) as [ | [ | ] v].
-----
Definition cond2_correct n s x g h0 h1 vnl vsl : length vnl = n -> length vsl = s -> sem (cond2 n s x g h0 h1) vnl vsl = match sem x vnl vsl with | nil => sem g vnl vsl | true :: _ => sem h0 vnl (tl (sem x vnl vsl) :: vsl) | false :: _ => sem h1 vnl (tl (sem x vnl vsl) :: vsl) end.
Proof.
intros Hn Hs.
simpl.
destruct (sem x vnl vsl) as [ | [ | ] v].

*****
Hs : eq (length vsl) s
Hn : eq (length vnl) n
vnl,vsl : list (list bool)
x,g,h0,h1 : BC
n,s : nat
*****
eq (sem g vnl vsl) (sem g vnl vsl)
+++++
simpl.
-----
Definition cond2_correct n s x g h0 h1 vnl vsl : length vnl = n -> length vsl = s -> sem (cond2 n s x g h0 h1) vnl vsl = match sem x vnl vsl with | nil => sem g vnl vsl | true :: _ => sem h0 vnl (tl (sem x vnl vsl) :: vsl) | false :: _ => sem h1 vnl (tl (sem x vnl vsl) :: vsl) end.
Proof.
intros Hn Hs.
simpl.
destruct (sem x vnl vsl) as [ | [ | ] v].
simpl.

*****
Hs : eq (length vsl) s
Hn : eq (length vnl) n
vnl,vsl : list (list bool)
x,g,h0,h1 : BC
n,s : nat
*****
eq (sem g vnl vsl) (sem g vnl vsl)
+++++
reflexivity.
-----
Definition cond2_correct n s x g h0 h1 vnl vsl : length vnl = n -> length vsl = s -> sem (cond2 n s x g h0 h1) vnl vsl = match sem x vnl vsl with | nil => sem g vnl vsl | true :: _ => sem h0 vnl (tl (sem x vnl vsl) :: vsl) | false :: _ => sem h1 vnl (tl (sem x vnl vsl) :: vsl) end.
Proof.
intros Hn Hs.
simpl.
destruct (sem x vnl vsl) as [ | [ | ] v].

*****
v : list bool
Hs : eq (length vsl) s
Hn : eq (length vnl) n
vnl,vsl : list (list bool)
x,g,h0,h1 : BC
n,s : nat
*****
eq (sem h0 (map (fun ne : BC => sem ne vnl nil) (map (proj n O) (seq O n))) (cons (tl (cons true v)) (map (fun se : BC => sem se vnl vsl) (map (proj n s) (seq n s))))) (sem h0 vnl (cons (tl (cons true v)) vsl))
+++++
simpl.
-----
Definition cond2_correct n s x g h0 h1 vnl vsl : length vnl = n -> length vsl = s -> sem (cond2 n s x g h0 h1) vnl vsl = match sem x vnl vsl with | nil => sem g vnl vsl | true :: _ => sem h0 vnl (tl (sem x vnl vsl) :: vsl) | false :: _ => sem h1 vnl (tl (sem x vnl vsl) :: vsl) end.
Proof.
intros Hn Hs.
simpl.
destruct (sem x vnl vsl) as [ | [ | ] v].
simpl.

*****
v : list bool
Hs : eq (length vsl) s
Hn : eq (length vnl) n
vnl,vsl : list (list bool)
x,g,h0,h1 : BC
n,s : nat
*****
eq (sem h0 (map (fun ne : BC => sem ne vnl nil) (map (proj n O) (seq O n))) (cons v (map (fun se : BC => sem se vnl vsl) (map (proj n s) (seq n s))))) (sem h0 vnl (cons v vsl))
+++++
rewrite map_proj_seq_normal.
-----
Definition cond2_correct n s x g h0 h1 vnl vsl : length vnl = n -> length vsl = s -> sem (cond2 n s x g h0 h1) vnl vsl = match sem x vnl vsl with | nil => sem g vnl vsl | true :: _ => sem h0 vnl (tl (sem x vnl vsl) :: vsl) | false :: _ => sem h1 vnl (tl (sem x vnl vsl) :: vsl) end.
Proof.
intros Hn Hs.
simpl.
destruct (sem x vnl vsl) as [ | [ | ] v].
simpl.
rewrite map_proj_seq_normal.

*****
v : list bool
Hs : eq (length vsl) s
Hn : eq (length vnl) n
vnl,vsl : list (list bool)
x,g,h0,h1 : BC
n,s : nat
*****
eq (sem h0 (app (firstn n vnl) (repeat (Init.Nat.sub n (length vnl)) nil)) (cons v (map (fun se : BC => sem se vnl vsl) (map (proj n s) (seq n s))))) (sem h0 vnl (cons v vsl))
+++++
rewrite map_proj_seq_safe.
-----
Definition cond2_correct n s x g h0 h1 vnl vsl : length vnl = n -> length vsl = s -> sem (cond2 n s x g h0 h1) vnl vsl = match sem x vnl vsl with | nil => sem g vnl vsl | true :: _ => sem h0 vnl (tl (sem x vnl vsl) :: vsl) | false :: _ => sem h1 vnl (tl (sem x vnl vsl) :: vsl) end.
Proof.
intros Hn Hs.
simpl.
destruct (sem x vnl vsl) as [ | [ | ] v].
simpl.
rewrite map_proj_seq_normal.
rewrite map_proj_seq_safe.

*****
v : list bool
Hs : eq (length vsl) s
Hn : eq (length vnl) n
vnl,vsl : list (list bool)
x,g,h0,h1 : BC
n,s : nat
*****
eq (sem h0 (app (firstn n vnl) (repeat (Init.Nat.sub n (length vnl)) nil)) (cons v (app (firstn s vsl) (repeat (Init.Nat.sub s (length vsl)) nil)))) (sem h0 vnl (cons v vsl))
+++++
f_equal.
-----
Definition cond2_correct n s x g h0 h1 vnl vsl : length vnl = n -> length vsl = s -> sem (cond2 n s x g h0 h1) vnl vsl = match sem x vnl vsl with | nil => sem g vnl vsl | true :: _ => sem h0 vnl (tl (sem x vnl vsl) :: vsl) | false :: _ => sem h1 vnl (tl (sem x vnl vsl) :: vsl) end.
Proof.
intros Hn Hs.
simpl.
destruct (sem x vnl vsl) as [ | [ | ] v].
simpl.
rewrite map_proj_seq_normal.
rewrite map_proj_seq_safe.
f_equal.

*****
v : list bool
Hs : eq (length vsl) s
Hn : eq (length vnl) n
vnl,vsl : list (list bool)
x,g,h0,h1 : BC
n,s : nat
*****
eq (app (firstn n vnl) (repeat (Init.Nat.sub n (length vnl)) nil)) vnl
+++++
subst n.
-----
Definition cond2_correct n s x g h0 h1 vnl vsl : length vnl = n -> length vsl = s -> sem (cond2 n s x g h0 h1) vnl vsl = match sem x vnl vsl with | nil => sem g vnl vsl | true :: _ => sem h0 vnl (tl (sem x vnl vsl) :: vsl) | false :: _ => sem h1 vnl (tl (sem x vnl vsl) :: vsl) end.
Proof.
intros Hn Hs.
simpl.
destruct (sem x vnl vsl) as [ | [ | ] v].
simpl.
rewrite map_proj_seq_normal.
rewrite map_proj_seq_safe.
f_equal.
subst n.

*****
v : list bool
Hs : eq (length vsl) s
vnl,vsl : list (list bool)
x,g,h0,h1 : BC
s : nat
*****
eq (app (firstn (length vnl) vnl) (repeat (Init.Nat.sub (length vnl) (length vnl)) nil)) vnl
+++++
rewrite minus_diag.
-----
Definition cond2_correct n s x g h0 h1 vnl vsl : length vnl = n -> length vsl = s -> sem (cond2 n s x g h0 h1) vnl vsl = match sem x vnl vsl with | nil => sem g vnl vsl | true :: _ => sem h0 vnl (tl (sem x vnl vsl) :: vsl) | false :: _ => sem h1 vnl (tl (sem x vnl vsl) :: vsl) end.
Proof.
intros Hn Hs.
simpl.
destruct (sem x vnl vsl) as [ | [ | ] v].
simpl.
rewrite map_proj_seq_normal.
rewrite map_proj_seq_safe.
f_equal.
subst n.
rewrite minus_diag.

*****
v : list bool
Hs : eq (length vsl) s
vnl,vsl : list (list bool)
x,g,h0,h1 : BC
s : nat
*****
eq (app (firstn (length vnl) vnl) (repeat O nil)) vnl
+++++
simpl.
-----
Definition cond2_correct n s x g h0 h1 vnl vsl : length vnl = n -> length vsl = s -> sem (cond2 n s x g h0 h1) vnl vsl = match sem x vnl vsl with | nil => sem g vnl vsl | true :: _ => sem h0 vnl (tl (sem x vnl vsl) :: vsl) | false :: _ => sem h1 vnl (tl (sem x vnl vsl) :: vsl) end.
Proof.
intros Hn Hs.
simpl.
destruct (sem x vnl vsl) as [ | [ | ] v].
simpl.
rewrite map_proj_seq_normal.
rewrite map_proj_seq_safe.
f_equal.
subst n.
rewrite minus_diag.
simpl.

*****
v : list bool
Hs : eq (length vsl) s
vnl,vsl : list (list bool)
x,g,h0,h1 : BC
s : nat
*****
eq (app (firstn (length vnl) vnl) nil) vnl
+++++
rewrite app_nil_r.
-----
Definition cond2_correct n s x g h0 h1 vnl vsl : length vnl = n -> length vsl = s -> sem (cond2 n s x g h0 h1) vnl vsl = match sem x vnl vsl with | nil => sem g vnl vsl | true :: _ => sem h0 vnl (tl (sem x vnl vsl) :: vsl) | false :: _ => sem h1 vnl (tl (sem x vnl vsl) :: vsl) end.
Proof.
intros Hn Hs.
simpl.
destruct (sem x vnl vsl) as [ | [ | ] v].
simpl.
rewrite map_proj_seq_normal.
rewrite map_proj_seq_safe.
f_equal.
subst n.
rewrite minus_diag.
simpl.
rewrite app_nil_r.

*****
v : list bool
Hs : eq (length vsl) s
vnl,vsl : list (list bool)
x,g,h0,h1 : BC
s : nat
*****
eq (firstn (length vnl) vnl) vnl
+++++
rewrite <- (app_nil_r vnl) at 2.
-----
Definition cond2_correct n s x g h0 h1 vnl vsl : length vnl = n -> length vsl = s -> sem (cond2 n s x g h0 h1) vnl vsl = match sem x vnl vsl with | nil => sem g vnl vsl | true :: _ => sem h0 vnl (tl (sem x vnl vsl) :: vsl) | false :: _ => sem h1 vnl (tl (sem x vnl vsl) :: vsl) end.
Proof.
intros Hn Hs.
simpl.
destruct (sem x vnl vsl) as [ | [ | ] v].
simpl.
rewrite map_proj_seq_normal.
rewrite map_proj_seq_safe.
f_equal.
subst n.
rewrite minus_diag.
simpl.
rewrite app_nil_r.
rewrite <- (app_nil_r vnl) at 2.

*****
v : list bool
Hs : eq (length vsl) s
vnl,vsl : list (list bool)
x,g,h0,h1 : BC
s : nat
*****
eq (firstn (length vnl) (app vnl nil)) vnl
+++++
apply firstn_app.
-----
Definition cond2_correct n s x g h0 h1 vnl vsl : length vnl = n -> length vsl = s -> sem (cond2 n s x g h0 h1) vnl vsl = match sem x vnl vsl with | nil => sem g vnl vsl | true :: _ => sem h0 vnl (tl (sem x vnl vsl) :: vsl) | false :: _ => sem h1 vnl (tl (sem x vnl vsl) :: vsl) end.
Proof.
intros Hn Hs.
simpl.
destruct (sem x vnl vsl) as [ | [ | ] v].
simpl.
rewrite map_proj_seq_normal.
rewrite map_proj_seq_safe.
f_equal.

*****
v : list bool
Hs : eq (length vsl) s
Hn : eq (length vnl) n
vnl,vsl : list (list bool)
x,g,h0,h1 : BC
n,s : nat
*****
eq (cons v (app (firstn s vsl) (repeat (Init.Nat.sub s (length vsl)) nil))) (cons v vsl)
+++++
f_equal.
-----
Definition cond2_correct n s x g h0 h1 vnl vsl : length vnl = n -> length vsl = s -> sem (cond2 n s x g h0 h1) vnl vsl = match sem x vnl vsl with | nil => sem g vnl vsl | true :: _ => sem h0 vnl (tl (sem x vnl vsl) :: vsl) | false :: _ => sem h1 vnl (tl (sem x vnl vsl) :: vsl) end.
Proof.
intros Hn Hs.
simpl.
destruct (sem x vnl vsl) as [ | [ | ] v].
simpl.
rewrite map_proj_seq_normal.
rewrite map_proj_seq_safe.
f_equal.
f_equal.

*****
v : list bool
Hs : eq (length vsl) s
Hn : eq (length vnl) n
vnl,vsl : list (list bool)
x,g,h0,h1 : BC
n,s : nat
*****
eq (app (firstn s vsl) (repeat (Init.Nat.sub s (length vsl)) nil)) vsl
+++++
subst s.
-----
Definition cond2_correct n s x g h0 h1 vnl vsl : length vnl = n -> length vsl = s -> sem (cond2 n s x g h0 h1) vnl vsl = match sem x vnl vsl with | nil => sem g vnl vsl | true :: _ => sem h0 vnl (tl (sem x vnl vsl) :: vsl) | false :: _ => sem h1 vnl (tl (sem x vnl vsl) :: vsl) end.
Proof.
intros Hn Hs.
simpl.
destruct (sem x vnl vsl) as [ | [ | ] v].
simpl.
rewrite map_proj_seq_normal.
rewrite map_proj_seq_safe.
f_equal.
f_equal.
subst s.

*****
v : list bool
Hn : eq (length vnl) n
vnl,vsl : list (list bool)
x,g,h0,h1 : BC
n : nat
*****
eq (app (firstn (length vsl) vsl) (repeat (Init.Nat.sub (length vsl) (length vsl)) nil)) vsl
+++++
rewrite minus_diag.
-----
Definition cond2_correct n s x g h0 h1 vnl vsl : length vnl = n -> length vsl = s -> sem (cond2 n s x g h0 h1) vnl vsl = match sem x vnl vsl with | nil => sem g vnl vsl | true :: _ => sem h0 vnl (tl (sem x vnl vsl) :: vsl) | false :: _ => sem h1 vnl (tl (sem x vnl vsl) :: vsl) end.
Proof.
intros Hn Hs.
simpl.
destruct (sem x vnl vsl) as [ | [ | ] v].
simpl.
rewrite map_proj_seq_normal.
rewrite map_proj_seq_safe.
f_equal.
f_equal.
subst s.
rewrite minus_diag.

*****
v : list bool
Hn : eq (length vnl) n
vnl,vsl : list (list bool)
x,g,h0,h1 : BC
n : nat
*****
eq (app (firstn (length vsl) vsl) (repeat O nil)) vsl
+++++
simpl.
-----
Definition cond2_correct n s x g h0 h1 vnl vsl : length vnl = n -> length vsl = s -> sem (cond2 n s x g h0 h1) vnl vsl = match sem x vnl vsl with | nil => sem g vnl vsl | true :: _ => sem h0 vnl (tl (sem x vnl vsl) :: vsl) | false :: _ => sem h1 vnl (tl (sem x vnl vsl) :: vsl) end.
Proof.
intros Hn Hs.
simpl.
destruct (sem x vnl vsl) as [ | [ | ] v].
simpl.
rewrite map_proj_seq_normal.
rewrite map_proj_seq_safe.
f_equal.
f_equal.
subst s.
rewrite minus_diag.
simpl.

*****
v : list bool
Hn : eq (length vnl) n
vnl,vsl : list (list bool)
x,g,h0,h1 : BC
n : nat
*****
eq (app (firstn (length vsl) vsl) nil) vsl
+++++
rewrite app_nil_r.
-----
Definition cond2_correct n s x g h0 h1 vnl vsl : length vnl = n -> length vsl = s -> sem (cond2 n s x g h0 h1) vnl vsl = match sem x vnl vsl with | nil => sem g vnl vsl | true :: _ => sem h0 vnl (tl (sem x vnl vsl) :: vsl) | false :: _ => sem h1 vnl (tl (sem x vnl vsl) :: vsl) end.
Proof.
intros Hn Hs.
simpl.
destruct (sem x vnl vsl) as [ | [ | ] v].
simpl.
rewrite map_proj_seq_normal.
rewrite map_proj_seq_safe.
f_equal.
f_equal.
subst s.
rewrite minus_diag.
simpl.
rewrite app_nil_r.

*****
v : list bool
Hn : eq (length vnl) n
vnl,vsl : list (list bool)
x,g,h0,h1 : BC
n : nat
*****
eq (firstn (length vsl) vsl) vsl
+++++
rewrite <- (app_nil_r vsl) at 2.
-----
Definition cond2_correct n s x g h0 h1 vnl vsl : length vnl = n -> length vsl = s -> sem (cond2 n s x g h0 h1) vnl vsl = match sem x vnl vsl with | nil => sem g vnl vsl | true :: _ => sem h0 vnl (tl (sem x vnl vsl) :: vsl) | false :: _ => sem h1 vnl (tl (sem x vnl vsl) :: vsl) end.
Proof.
intros Hn Hs.
simpl.
destruct (sem x vnl vsl) as [ | [ | ] v].
simpl.
rewrite map_proj_seq_normal.
rewrite map_proj_seq_safe.
f_equal.
f_equal.
subst s.
rewrite minus_diag.
simpl.
rewrite app_nil_r.
rewrite <- (app_nil_r vsl) at 2.

*****
v : list bool
Hn : eq (length vnl) n
vnl,vsl : list (list bool)
x,g,h0,h1 : BC
n : nat
*****
eq (firstn (length vsl) (app vsl nil)) vsl
+++++
apply firstn_app.
-----
Definition cond2_correct n s x g h0 h1 vnl vsl : length vnl = n -> length vsl = s -> sem (cond2 n s x g h0 h1) vnl vsl = match sem x vnl vsl with | nil => sem g vnl vsl | true :: _ => sem h0 vnl (tl (sem x vnl vsl) :: vsl) | false :: _ => sem h1 vnl (tl (sem x vnl vsl) :: vsl) end.
Proof.
intros Hn Hs.
simpl.
destruct (sem x vnl vsl) as [ | [ | ] v].

*****
v : list bool
Hs : eq (length vsl) s
Hn : eq (length vnl) n
vnl,vsl : list (list bool)
x,g,h0,h1 : BC
n,s : nat
*****
eq (sem h1 (map (fun ne : BC => sem ne vnl nil) (map (proj n O) (seq O n))) (cons (tl (cons false v)) (map (fun se : BC => sem se vnl vsl) (map (proj n s) (seq n s))))) (sem h1 vnl (cons (tl (cons false v)) vsl))
+++++
simpl.
-----
Definition cond2_correct n s x g h0 h1 vnl vsl : length vnl = n -> length vsl = s -> sem (cond2 n s x g h0 h1) vnl vsl = match sem x vnl vsl with | nil => sem g vnl vsl | true :: _ => sem h0 vnl (tl (sem x vnl vsl) :: vsl) | false :: _ => sem h1 vnl (tl (sem x vnl vsl) :: vsl) end.
Proof.
intros Hn Hs.
simpl.
destruct (sem x vnl vsl) as [ | [ | ] v].
simpl.

*****
v : list bool
Hs : eq (length vsl) s
Hn : eq (length vnl) n
vnl,vsl : list (list bool)
x,g,h0,h1 : BC
n,s : nat
*****
eq (sem h1 (map (fun ne : BC => sem ne vnl nil) (map (proj n O) (seq O n))) (cons v (map (fun se : BC => sem se vnl vsl) (map (proj n s) (seq n s))))) (sem h1 vnl (cons v vsl))
+++++
rewrite map_proj_seq_normal.
-----
Definition cond2_correct n s x g h0 h1 vnl vsl : length vnl = n -> length vsl = s -> sem (cond2 n s x g h0 h1) vnl vsl = match sem x vnl vsl with | nil => sem g vnl vsl | true :: _ => sem h0 vnl (tl (sem x vnl vsl) :: vsl) | false :: _ => sem h1 vnl (tl (sem x vnl vsl) :: vsl) end.
Proof.
intros Hn Hs.
simpl.
destruct (sem x vnl vsl) as [ | [ | ] v].
simpl.
rewrite map_proj_seq_normal.

*****
v : list bool
Hs : eq (length vsl) s
Hn : eq (length vnl) n
vnl,vsl : list (list bool)
x,g,h0,h1 : BC
n,s : nat
*****
eq (sem h1 (app (firstn n vnl) (repeat (Init.Nat.sub n (length vnl)) nil)) (cons v (map (fun se : BC => sem se vnl vsl) (map (proj n s) (seq n s))))) (sem h1 vnl (cons v vsl))
+++++
rewrite map_proj_seq_safe.
-----
Definition cond2_correct n s x g h0 h1 vnl vsl : length vnl = n -> length vsl = s -> sem (cond2 n s x g h0 h1) vnl vsl = match sem x vnl vsl with | nil => sem g vnl vsl | true :: _ => sem h0 vnl (tl (sem x vnl vsl) :: vsl) | false :: _ => sem h1 vnl (tl (sem x vnl vsl) :: vsl) end.
Proof.
intros Hn Hs.
simpl.
destruct (sem x vnl vsl) as [ | [ | ] v].
simpl.
rewrite map_proj_seq_normal.
rewrite map_proj_seq_safe.

*****
v : list bool
Hs : eq (length vsl) s
Hn : eq (length vnl) n
vnl,vsl : list (list bool)
x,g,h0,h1 : BC
n,s : nat
*****
eq (sem h1 (app (firstn n vnl) (repeat (Init.Nat.sub n (length vnl)) nil)) (cons v (app (firstn s vsl) (repeat (Init.Nat.sub s (length vsl)) nil)))) (sem h1 vnl (cons v vsl))
+++++
f_equal.
-----
Definition cond2_correct n s x g h0 h1 vnl vsl : length vnl = n -> length vsl = s -> sem (cond2 n s x g h0 h1) vnl vsl = match sem x vnl vsl with | nil => sem g vnl vsl | true :: _ => sem h0 vnl (tl (sem x vnl vsl) :: vsl) | false :: _ => sem h1 vnl (tl (sem x vnl vsl) :: vsl) end.
Proof.
intros Hn Hs.
simpl.
destruct (sem x vnl vsl) as [ | [ | ] v].
simpl.
rewrite map_proj_seq_normal.
rewrite map_proj_seq_safe.
f_equal.

*****
v : list bool
Hs : eq (length vsl) s
Hn : eq (length vnl) n
vnl,vsl : list (list bool)
x,g,h0,h1 : BC
n,s : nat
*****
eq (app (firstn n vnl) (repeat (Init.Nat.sub n (length vnl)) nil)) vnl
+++++
subst n.
-----
Definition cond2_correct n s x g h0 h1 vnl vsl : length vnl = n -> length vsl = s -> sem (cond2 n s x g h0 h1) vnl vsl = match sem x vnl vsl with | nil => sem g vnl vsl | true :: _ => sem h0 vnl (tl (sem x vnl vsl) :: vsl) | false :: _ => sem h1 vnl (tl (sem x vnl vsl) :: vsl) end.
Proof.
intros Hn Hs.
simpl.
destruct (sem x vnl vsl) as [ | [ | ] v].
simpl.
rewrite map_proj_seq_normal.
rewrite map_proj_seq_safe.
f_equal.
subst n.

*****
v : list bool
Hs : eq (length vsl) s
vnl,vsl : list (list bool)
x,g,h0,h1 : BC
s : nat
*****
eq (app (firstn (length vnl) vnl) (repeat (Init.Nat.sub (length vnl) (length vnl)) nil)) vnl
+++++
rewrite minus_diag.
-----
Definition cond2_correct n s x g h0 h1 vnl vsl : length vnl = n -> length vsl = s -> sem (cond2 n s x g h0 h1) vnl vsl = match sem x vnl vsl with | nil => sem g vnl vsl | true :: _ => sem h0 vnl (tl (sem x vnl vsl) :: vsl) | false :: _ => sem h1 vnl (tl (sem x vnl vsl) :: vsl) end.
Proof.
intros Hn Hs.
simpl.
destruct (sem x vnl vsl) as [ | [ | ] v].
simpl.
rewrite map_proj_seq_normal.
rewrite map_proj_seq_safe.
f_equal.
subst n.
rewrite minus_diag.

*****
v : list bool
Hs : eq (length vsl) s
vnl,vsl : list (list bool)
x,g,h0,h1 : BC
s : nat
*****
eq (app (firstn (length vnl) vnl) (repeat O nil)) vnl
+++++
simpl.
-----
Definition cond2_correct n s x g h0 h1 vnl vsl : length vnl = n -> length vsl = s -> sem (cond2 n s x g h0 h1) vnl vsl = match sem x vnl vsl with | nil => sem g vnl vsl | true :: _ => sem h0 vnl (tl (sem x vnl vsl) :: vsl) | false :: _ => sem h1 vnl (tl (sem x vnl vsl) :: vsl) end.
Proof.
intros Hn Hs.
simpl.
destruct (sem x vnl vsl) as [ | [ | ] v].
simpl.
rewrite map_proj_seq_normal.
rewrite map_proj_seq_safe.
f_equal.
subst n.
rewrite minus_diag.
simpl.

*****
v : list bool
Hs : eq (length vsl) s
vnl,vsl : list (list bool)
x,g,h0,h1 : BC
s : nat
*****
eq (app (firstn (length vnl) vnl) nil) vnl
+++++
rewrite app_nil_r.
-----
Definition cond2_correct n s x g h0 h1 vnl vsl : length vnl = n -> length vsl = s -> sem (cond2 n s x g h0 h1) vnl vsl = match sem x vnl vsl with | nil => sem g vnl vsl | true :: _ => sem h0 vnl (tl (sem x vnl vsl) :: vsl) | false :: _ => sem h1 vnl (tl (sem x vnl vsl) :: vsl) end.
Proof.
intros Hn Hs.
simpl.
destruct (sem x vnl vsl) as [ | [ | ] v].
simpl.
rewrite map_proj_seq_normal.
rewrite map_proj_seq_safe.
f_equal.
subst n.
rewrite minus_diag.
simpl.
rewrite app_nil_r.

*****
v : list bool
Hs : eq (length vsl) s
vnl,vsl : list (list bool)
x,g,h0,h1 : BC
s : nat
*****
eq (firstn (length vnl) vnl) vnl
+++++
rewrite <- (app_nil_r vnl) at 2.
-----
Definition cond2_correct n s x g h0 h1 vnl vsl : length vnl = n -> length vsl = s -> sem (cond2 n s x g h0 h1) vnl vsl = match sem x vnl vsl with | nil => sem g vnl vsl | true :: _ => sem h0 vnl (tl (sem x vnl vsl) :: vsl) | false :: _ => sem h1 vnl (tl (sem x vnl vsl) :: vsl) end.
Proof.
intros Hn Hs.
simpl.
destruct (sem x vnl vsl) as [ | [ | ] v].
simpl.
rewrite map_proj_seq_normal.
rewrite map_proj_seq_safe.
f_equal.
subst n.
rewrite minus_diag.
simpl.
rewrite app_nil_r.
rewrite <- (app_nil_r vnl) at 2.

*****
v : list bool
Hs : eq (length vsl) s
vnl,vsl : list (list bool)
x,g,h0,h1 : BC
s : nat
*****
eq (firstn (length vnl) (app vnl nil)) vnl
+++++
apply firstn_app.
-----
Definition cond2_correct n s x g h0 h1 vnl vsl : length vnl = n -> length vsl = s -> sem (cond2 n s x g h0 h1) vnl vsl = match sem x vnl vsl with | nil => sem g vnl vsl | true :: _ => sem h0 vnl (tl (sem x vnl vsl) :: vsl) | false :: _ => sem h1 vnl (tl (sem x vnl vsl) :: vsl) end.
Proof.
intros Hn Hs.
simpl.
destruct (sem x vnl vsl) as [ | [ | ] v].
simpl.
rewrite map_proj_seq_normal.
rewrite map_proj_seq_safe.
f_equal.

*****
v : list bool
Hs : eq (length vsl) s
Hn : eq (length vnl) n
vnl,vsl : list (list bool)
x,g,h0,h1 : BC
n,s : nat
*****
eq (cons v (app (firstn s vsl) (repeat (Init.Nat.sub s (length vsl)) nil))) (cons v vsl)
+++++
f_equal.
-----
Definition cond2_correct n s x g h0 h1 vnl vsl : length vnl = n -> length vsl = s -> sem (cond2 n s x g h0 h1) vnl vsl = match sem x vnl vsl with | nil => sem g vnl vsl | true :: _ => sem h0 vnl (tl (sem x vnl vsl) :: vsl) | false :: _ => sem h1 vnl (tl (sem x vnl vsl) :: vsl) end.
Proof.
intros Hn Hs.
simpl.
destruct (sem x vnl vsl) as [ | [ | ] v].
simpl.
rewrite map_proj_seq_normal.
rewrite map_proj_seq_safe.
f_equal.
f_equal.

*****
v : list bool
Hs : eq (length vsl) s
Hn : eq (length vnl) n
vnl,vsl : list (list bool)
x,g,h0,h1 : BC
n,s : nat
*****
eq (app (firstn s vsl) (repeat (Init.Nat.sub s (length vsl)) nil)) vsl
+++++
subst s.
-----
Definition cond2_correct n s x g h0 h1 vnl vsl : length vnl = n -> length vsl = s -> sem (cond2 n s x g h0 h1) vnl vsl = match sem x vnl vsl with | nil => sem g vnl vsl | true :: _ => sem h0 vnl (tl (sem x vnl vsl) :: vsl) | false :: _ => sem h1 vnl (tl (sem x vnl vsl) :: vsl) end.
Proof.
intros Hn Hs.
simpl.
destruct (sem x vnl vsl) as [ | [ | ] v].
simpl.
rewrite map_proj_seq_normal.
rewrite map_proj_seq_safe.
f_equal.
f_equal.
subst s.

*****
v : list bool
Hn : eq (length vnl) n
vnl,vsl : list (list bool)
x,g,h0,h1 : BC
n : nat
*****
eq (app (firstn (length vsl) vsl) (repeat (Init.Nat.sub (length vsl) (length vsl)) nil)) vsl
+++++
rewrite minus_diag.
-----
Definition cond2_correct n s x g h0 h1 vnl vsl : length vnl = n -> length vsl = s -> sem (cond2 n s x g h0 h1) vnl vsl = match sem x vnl vsl with | nil => sem g vnl vsl | true :: _ => sem h0 vnl (tl (sem x vnl vsl) :: vsl) | false :: _ => sem h1 vnl (tl (sem x vnl vsl) :: vsl) end.
Proof.
intros Hn Hs.
simpl.
destruct (sem x vnl vsl) as [ | [ | ] v].
simpl.
rewrite map_proj_seq_normal.
rewrite map_proj_seq_safe.
f_equal.
f_equal.
subst s.
rewrite minus_diag.

*****
v : list bool
Hn : eq (length vnl) n
vnl,vsl : list (list bool)
x,g,h0,h1 : BC
n : nat
*****
eq (app (firstn (length vsl) vsl) (repeat O nil)) vsl
+++++
simpl.
-----
Definition cond2_correct n s x g h0 h1 vnl vsl : length vnl = n -> length vsl = s -> sem (cond2 n s x g h0 h1) vnl vsl = match sem x vnl vsl with | nil => sem g vnl vsl | true :: _ => sem h0 vnl (tl (sem x vnl vsl) :: vsl) | false :: _ => sem h1 vnl (tl (sem x vnl vsl) :: vsl) end.
Proof.
intros Hn Hs.
simpl.
destruct (sem x vnl vsl) as [ | [ | ] v].
simpl.
rewrite map_proj_seq_normal.
rewrite map_proj_seq_safe.
f_equal.
f_equal.
subst s.
rewrite minus_diag.
simpl.

*****
v : list bool
Hn : eq (length vnl) n
vnl,vsl : list (list bool)
x,g,h0,h1 : BC
n : nat
*****
eq (app (firstn (length vsl) vsl) nil) vsl
+++++
rewrite app_nil_r.
-----
Definition cond2_correct n s x g h0 h1 vnl vsl : length vnl = n -> length vsl = s -> sem (cond2 n s x g h0 h1) vnl vsl = match sem x vnl vsl with | nil => sem g vnl vsl | true :: _ => sem h0 vnl (tl (sem x vnl vsl) :: vsl) | false :: _ => sem h1 vnl (tl (sem x vnl vsl) :: vsl) end.
Proof.
intros Hn Hs.
simpl.
destruct (sem x vnl vsl) as [ | [ | ] v].
simpl.
rewrite map_proj_seq_normal.
rewrite map_proj_seq_safe.
f_equal.
f_equal.
subst s.
rewrite minus_diag.
simpl.
rewrite app_nil_r.

*****
v : list bool
Hn : eq (length vnl) n
vnl,vsl : list (list bool)
x,g,h0,h1 : BC
n : nat
*****
eq (firstn (length vsl) vsl) vsl
+++++
rewrite <- (app_nil_r vsl) at 2.
-----
Definition cond2_correct n s x g h0 h1 vnl vsl : length vnl = n -> length vsl = s -> sem (cond2 n s x g h0 h1) vnl vsl = match sem x vnl vsl with | nil => sem g vnl vsl | true :: _ => sem h0 vnl (tl (sem x vnl vsl) :: vsl) | false :: _ => sem h1 vnl (tl (sem x vnl vsl) :: vsl) end.
Proof.
intros Hn Hs.
simpl.
destruct (sem x vnl vsl) as [ | [ | ] v].
simpl.
rewrite map_proj_seq_normal.
rewrite map_proj_seq_safe.
f_equal.
f_equal.
subst s.
rewrite minus_diag.
simpl.
rewrite app_nil_r.
rewrite <- (app_nil_r vsl) at 2.

*****
v : list bool
Hn : eq (length vnl) n
vnl,vsl : list (list bool)
x,g,h0,h1 : BC
n : nat
*****
eq (firstn (length vsl) (app vsl nil)) vsl
+++++
apply firstn_app.
-----
Definition cond2_correct n s x g h0 h1 vnl vsl : length vnl = n -> length vsl = s -> sem (cond2 n s x g h0 h1) vnl vsl = match sem x vnl vsl with | nil => sem g vnl vsl | true :: _ => sem h0 vnl (tl (sem x vnl vsl) :: vsl) | false :: _ => sem h1 vnl (tl (sem x vnl vsl) :: vsl) end.
Proof.
intros Hn Hs.
simpl.
destruct (sem x vnl vsl) as [ | [ | ] v].

*****

*****

+++++
Qed.
-----
Definition rec1 n s g h :=\n  rec\n    g\n    (comp (S n) (S s) h\n      (comp (S n) 0 (succ false) nil [proj (S n) 0 0] ::\n       map (proj (S n) 0)     (seq 1     n))\n      (map (proj (S n) (S s)) (seq (S n) (S s))))\n    (comp (S n) (S s) h\n      (comp (S n) 0 (succ true) nil [proj (S n) 0 0] ::\n       map (proj (S n) 0)     (seq 1     n))\n      (map (proj (S n) (S s)) (seq (S n) (S s)))).
-----
Lemma sem_rec_false g h0 h1 vnl vsl v :\n  sem (rec g h0 h1) ((false :: v) :: vnl) vsl =\n  sem h0 (v :: vnl) (sem (rec g h0 h1) (v :: vnl) vsl :: vsl).
-----
Lemma sem_rec_false g h0 h1 vnl vsl v : sem (rec g h0 h1) ((false :: v) :: vnl) vsl = sem h0 (v :: vnl) (sem (rec g h0 h1) (v :: vnl) vsl :: vsl).

*****
v : list bool
vnl,vsl : list (list bool)
g,h0,h1 : BC
*****
eq (sem (rec g h0 h1) (cons (cons false v) vnl) vsl) (sem h0 (cons v vnl) (cons (sem (rec g h0 h1) (cons v vnl) vsl) vsl))
+++++
Proof.
-----
Lemma sem_rec_false g h0 h1 vnl vsl v : sem (rec g h0 h1) ((false :: v) :: vnl) vsl = sem h0 (v :: vnl) (sem (rec g h0 h1) (v :: vnl) vsl :: vsl).
Proof.

*****
v : list bool
vnl,vsl : list (list bool)
g,h0,h1 : BC
*****
eq (sem (rec g h0 h1) (cons (cons false v) vnl) vsl) (sem h0 (cons v vnl) (cons (sem (rec g h0 h1) (cons v vnl) vsl) vsl))
+++++
reflexivity.
-----
Lemma sem_rec_false g h0 h1 vnl vsl v : sem (rec g h0 h1) ((false :: v) :: vnl) vsl = sem h0 (v :: vnl) (sem (rec g h0 h1) (v :: vnl) vsl :: vsl).
Proof.
reflexivity.

*****

*****

+++++
Qed.
-----
Lemma sem_rec_true g h0 h1 vnl vsl v :\n  sem (rec g h0 h1) ((true :: v) :: vnl) vsl =\n  sem h1 (v :: vnl) (sem (rec g h0 h1) (v :: vnl) vsl :: vsl).
-----
Lemma sem_rec_true g h0 h1 vnl vsl v : sem (rec g h0 h1) ((true :: v) :: vnl) vsl = sem h1 (v :: vnl) (sem (rec g h0 h1) (v :: vnl) vsl :: vsl).

*****
v : list bool
vnl,vsl : list (list bool)
g,h0,h1 : BC
*****
eq (sem (rec g h0 h1) (cons (cons true v) vnl) vsl) (sem h1 (cons v vnl) (cons (sem (rec g h0 h1) (cons v vnl) vsl) vsl))
+++++
Proof.
-----
Lemma sem_rec_true g h0 h1 vnl vsl v : sem (rec g h0 h1) ((true :: v) :: vnl) vsl = sem h1 (v :: vnl) (sem (rec g h0 h1) (v :: vnl) vsl :: vsl).
Proof.

*****
v : list bool
vnl,vsl : list (list bool)
g,h0,h1 : BC
*****
eq (sem (rec g h0 h1) (cons (cons true v) vnl) vsl) (sem h1 (cons v vnl) (cons (sem (rec g h0 h1) (cons v vnl) vsl) vsl))
+++++
reflexivity.
-----
Lemma sem_rec_true g h0 h1 vnl vsl v : sem (rec g h0 h1) ((true :: v) :: vnl) vsl = sem h1 (v :: vnl) (sem (rec g h0 h1) (v :: vnl) vsl :: vsl).
Proof.
reflexivity.

*****

*****

+++++
Qed.
-----
Lemma rec1_arities n s g h\n  (Hg : arities g = ok_arities n s)\n  (Hh : arities h = ok_arities (S n) (S s)) :\n  arities (rec1 n s g h) = ok_arities (S n) s.
-----
Lemma rec1_arities n s g h (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec1 n s g h) = ok_arities (S n) s.

*****
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
g,h : BC
n,s : nat
*****
eq (arities (rec1 n s g h)) (ok_arities (S n) s)
+++++
Proof.
-----
Lemma rec1_arities n s g h (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec1 n s g h) = ok_arities (S n) s.
Proof.

*****
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
g,h : BC
n,s : nat
*****
eq (arities (rec1 n s g h)) (ok_arities (S n) s)
+++++
simpl.
-----
Lemma rec1_arities n s g h (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec1 n s g h) = ok_arities (S n) s.
Proof.
simpl.

*****
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
g,h : BC
n,s : nat
*****
eq match arities g with | error_rec a a0 a1 => error_rec (error_rec a a0 a1) match arities h with | error_rec a2 a3 a4 => error_comp (error_rec a2 a3 a4) (cons (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s)))) | error_comp a2 l l0 => error_comp (error_comp a2 l l0) (cons (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s)))) | error_proj n0 n1 n2 => error_comp (error_proj n0 n1 n2) (cons (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s)))) | ok_arities hn hs => if andb (andb (andb (Nat.eqb hn (S (length (map (proj (S n) O) (seq (S O) n))))) (Nat.eqb hs (S (length (map (proj (S n) (S s)) (seq (S (S n)) s)))))) (andb (aeq (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (ok_arities (S n) O)) (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O)) (map (proj (S n) O) (seq (S O) n))))) (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities hn hs) (cons (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s)))) end match arities h with | error_rec a2 a3 a4 => error_comp (error_rec a2 a3 a4) (cons (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s)))) | error_comp a2 l l0 => error_comp (error_comp a2 l l0) (cons (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s)))) | error_proj n0 n1 n2 => error_comp (error_proj n0 n1 n2) (cons (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s)))) | ok_arities hn hs => if andb (andb (andb (Nat.eqb hn (S (length (map (proj (S n) O) (seq (S O) n))))) (Nat.eqb hs (S (length (map (proj (S n) (S s)) (seq (S (S n)) s)))))) (andb (aeq (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (ok_arities (S n) O)) (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O)) (map (proj (S n) O) (seq (S O) n))))) (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities hn hs) (cons (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s)))) end | error_comp a l l0 => error_rec (error_comp a l l0) match arities h with | error_rec a0 a1 a2 => error_comp (error_rec a0 a1 a2) (cons (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s)))) | error_comp a0 l1 l2 => error_comp (error_comp a0 l1 l2) (cons (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s)))) | error_proj n0 n1 n2 => error_comp (error_proj n0 n1 n2) (cons (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s)))) | ok_arities hn hs => if andb (andb (andb (Nat.eqb hn (S (length (map (proj (S n) O) (seq (S O) n))))) (Nat.eqb hs (S (length (map (proj (S n) (S s)) (seq (S (S n)) s)))))) (andb (aeq (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (ok_arities (S n) O)) (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O)) (map (proj (S n) O) (seq (S O) n))))) (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities hn hs) (cons (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s)))) end match arities h with | error_rec a0 a1 a2 => error_comp (error_rec a0 a1 a2) (cons (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s)))) | error_comp a0 l1 l2 => error_comp (error_comp a0 l1 l2) (cons (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s)))) | error_proj n0 n1 n2 => error_comp (error_proj n0 n1 n2) (cons (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s)))) | ok_arities hn hs => if andb (andb (andb (Nat.eqb hn (S (length (map (proj (S n) O) (seq (S O) n))))) (Nat.eqb hs (S (length (map (proj (S n) (S s)) (seq (S (S n)) s)))))) (andb (aeq (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (ok_arities (S n) O)) (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O)) (map (proj (S n) O) (seq (S O) n))))) (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities hn hs) (cons (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s)))) end | error_proj n0 n1 n2 => error_rec (error_proj n0 n1 n2) match arities h with | error_rec a a0 a1 => error_comp (error_rec a a0 a1) (cons (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s)))) | error_comp a l l0 => error_comp (error_comp a l l0) (cons (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s)))) | error_proj n3 n4 n5 => error_comp (error_proj n3 n4 n5) (cons (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s)))) | ok_arities hn hs => if andb (andb (andb (Nat.eqb hn (S (length (map (proj (S n) O) (seq (S O) n))))) (Nat.eqb hs (S (length (map (proj (S n) (S s)) (seq (S (S n)) s)))))) (andb (aeq (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (ok_arities (S n) O)) (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O)) (map (proj (S n) O) (seq (S O) n))))) (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities hn hs) (cons (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s)))) end match arities h with | error_rec a a0 a1 => error_comp (error_rec a a0 a1) (cons (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s)))) | error_comp a l l0 => error_comp (error_comp a l l0) (cons (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s)))) | error_proj n3 n4 n5 => error_comp (error_proj n3 n4 n5) (cons (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s)))) | ok_arities hn hs => if andb (andb (andb (Nat.eqb hn (S (length (map (proj (S n) O) (seq (S O) n))))) (Nat.eqb hs (S (length (map (proj (S n) (S s)) (seq (S (S n)) s)))))) (andb (aeq (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (ok_arities (S n) O)) (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O)) (map (proj (S n) O) (seq (S O) n))))) (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities hn hs) (cons (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s)))) end | ok_arities gn gs => match match arities h with | error_rec a a0 a1 => error_comp (error_rec a a0 a1) (cons (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s)))) | error_comp a l l0 => error_comp (error_comp a l l0) (cons (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s)))) | error_proj n0 n1 n2 => error_comp (error_proj n0 n1 n2) (cons (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s)))) | ok_arities hn hs => if andb (andb (andb (Nat.eqb hn (S (length (map (proj (S n) O) (seq (S O) n))))) (Nat.eqb hs (S (length (map (proj (S n) (S s)) (seq (S (S n)) s)))))) (andb (aeq (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (ok_arities (S n) O)) (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O)) (map (proj (S n) O) (seq (S O) n))))) (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities hn hs) (cons (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s)))) end with | error_rec a a0 a1 => error_rec (ok_arities gn gs) (error_rec a a0 a1) match arities h with | error_rec a2 a3 a4 => error_comp (error_rec a2 a3 a4) (cons (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s)))) | error_comp a2 l l0 => error_comp (error_comp a2 l l0) (cons (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s)))) | error_proj n0 n1 n2 => error_comp (error_proj n0 n1 n2) (cons (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s)))) | ok_arities hn hs => if andb (andb (andb (Nat.eqb hn (S (length (map (proj (S n) O) (seq (S O) n))))) (Nat.eqb hs (S (length (map (proj (S n) (S s)) (seq (S (S n)) s)))))) (andb (aeq (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (ok_arities (S n) O)) (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O)) (map (proj (S n) O) (seq (S O) n))))) (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities hn hs) (cons (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s)))) end | error_comp a l l0 => error_rec (ok_arities gn gs) (error_comp a l l0) match arities h with | error_rec a0 a1 a2 => error_comp (error_rec a0 a1 a2) (cons (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s)))) | error_comp a0 l1 l2 => error_comp (error_comp a0 l1 l2) (cons (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s)))) | error_proj n0 n1 n2 => error_comp (error_proj n0 n1 n2) (cons (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s)))) | ok_arities hn hs => if andb (andb (andb (Nat.eqb hn (S (length (map (proj (S n) O) (seq (S O) n))))) (Nat.eqb hs (S (length (map (proj (S n) (S s)) (seq (S (S n)) s)))))) (andb (aeq (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (ok_arities (S n) O)) (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O)) (map (proj (S n) O) (seq (S O) n))))) (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities hn hs) (cons (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s)))) end | error_proj n0 n1 n2 => error_rec (ok_arities gn gs) (error_proj n0 n1 n2) match arities h with | error_rec a a0 a1 => error_comp (error_rec a a0 a1) (cons (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s)))) | error_comp a l l0 => error_comp (error_comp a l l0) (cons (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s)))) | error_proj n3 n4 n5 => error_comp (error_proj n3 n4 n5) (cons (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s)))) | ok_arities hn hs => if andb (andb (andb (Nat.eqb hn (S (length (map (proj (S n) O) (seq (S O) n))))) (Nat.eqb hs (S (length (map (proj (S n) (S s)) (seq (S (S n)) s)))))) (andb (aeq (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (ok_arities (S n) O)) (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O)) (map (proj (S n) O) (seq (S O) n))))) (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities hn hs) (cons (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s)))) end | ok_arities h0n h0s => match match arities h with | error_rec a a0 a1 => error_comp (error_rec a a0 a1) (cons (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s)))) | error_comp a l l0 => error_comp (error_comp a l l0) (cons (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s)))) | error_proj n0 n1 n2 => error_comp (error_proj n0 n1 n2) (cons (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s)))) | ok_arities hn hs => if andb (andb (andb (Nat.eqb hn (S (length (map (proj (S n) O) (seq (S O) n))))) (Nat.eqb hs (S (length (map (proj (S n) (S s)) (seq (S (S n)) s)))))) (andb (aeq (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (ok_arities (S n) O)) (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O)) (map (proj (S n) O) (seq (S O) n))))) (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities hn hs) (cons (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s)))) end with | error_rec a a0 a1 => error_rec (ok_arities gn gs) (ok_arities h0n h0s) (error_rec a a0 a1) | error_comp a l l0 => error_rec (ok_arities gn gs) (ok_arities h0n h0s) (error_comp a l l0) | error_proj n n0 n1 => error_rec (ok_arities gn gs) (ok_arities h0n h0s) (error_proj n n0 n1) | ok_arities h1n h1s => if andb (andb (andb match h0n with | O => false | S m' => Nat.eqb gn m' end (Nat.eqb h0n h1n)) match h0s with | O => false | S m' => Nat.eqb gs m' end) (Nat.eqb h0s h1s) then ok_arities h0n gs else error_rec (ok_arities gn gs) (ok_arities h0n h0s) (ok_arities h1n h1s) end end end (ok_arities (S n) s)
+++++
rewrite Hg, Hh.
-----
Lemma rec1_arities n s g h (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec1 n s g h) = ok_arities (S n) s.
Proof.
simpl.
rewrite Hg, Hh.

*****
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
g,h : BC
n,s : nat
*****
eq match (if andb (andb (andb (Nat.eqb (S n) (S (length (map (proj (S n) O) (seq (S O) n))))) (Nat.eqb (S s) (S (length (map (proj (S n) (S s)) (seq (S (S n)) s)))))) (andb (aeq (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (ok_arities (S n) O)) (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O)) (map (proj (S n) O) (seq (S O) n))))) (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) with | error_rec a a0 a1 => error_rec (ok_arities n s) (error_rec a a0 a1) (if andb (andb (andb (Nat.eqb (S n) (S (length (map (proj (S n) O) (seq (S O) n))))) (Nat.eqb (S s) (S (length (map (proj (S n) (S s)) (seq (S (S n)) s)))))) (andb (aeq (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (ok_arities (S n) O)) (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O)) (map (proj (S n) O) (seq (S O) n))))) (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | error_comp a l l0 => error_rec (ok_arities n s) (error_comp a l l0) (if andb (andb (andb (Nat.eqb (S n) (S (length (map (proj (S n) O) (seq (S O) n))))) (Nat.eqb (S s) (S (length (map (proj (S n) (S s)) (seq (S (S n)) s)))))) (andb (aeq (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (ok_arities (S n) O)) (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O)) (map (proj (S n) O) (seq (S O) n))))) (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | error_proj n0 n1 n2 => error_rec (ok_arities n s) (error_proj n0 n1 n2) (if andb (andb (andb (Nat.eqb (S n) (S (length (map (proj (S n) O) (seq (S O) n))))) (Nat.eqb (S s) (S (length (map (proj (S n) (S s)) (seq (S (S n)) s)))))) (andb (aeq (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (ok_arities (S n) O)) (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O)) (map (proj (S n) O) (seq (S O) n))))) (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | ok_arities h0n h0s => match (if andb (andb (andb (Nat.eqb (S n) (S (length (map (proj (S n) O) (seq (S O) n))))) (Nat.eqb (S s) (S (length (map (proj (S n) (S s)) (seq (S (S n)) s)))))) (andb (aeq (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (ok_arities (S n) O)) (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O)) (map (proj (S n) O) (seq (S O) n))))) (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) with | error_rec a a0 a1 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_rec a a0 a1) | error_comp a l l0 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_comp a l l0) | error_proj n0 n1 n2 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_proj n0 n1 n2) | ok_arities h1n h1s => if andb (andb (andb match h0n with | O => false | S m' => Nat.eqb n m' end (Nat.eqb h0n h1n)) match h0s with | O => false | S m' => Nat.eqb s m' end) (Nat.eqb h0s h1s) then ok_arities h0n s else error_rec (ok_arities n s) (ok_arities h0n h0s) (ok_arities h1n h1s) end end (ok_arities (S n) s)
+++++
simpl.
-----
Lemma rec1_arities n s g h (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec1 n s g h) = ok_arities (S n) s.
Proof.
simpl.
rewrite Hg, Hh.
simpl.

*****
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
g,h : BC
n,s : nat
*****
eq match (if andb (andb (andb (Nat.eqb n (length (map (proj (S n) O) (seq (S O) n)))) (Nat.eqb s (length (map (proj (S n) (S s)) (seq (S (S n)) s))))) (andb (aeq (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (ok_arities (S n) O)) (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O)) (map (proj (S n) O) (seq (S O) n))))) (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) with | error_rec a a0 a1 => error_rec (ok_arities n s) (error_rec a a0 a1) (if andb (andb (andb (Nat.eqb n (length (map (proj (S n) O) (seq (S O) n)))) (Nat.eqb s (length (map (proj (S n) (S s)) (seq (S (S n)) s))))) (andb (aeq (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (ok_arities (S n) O)) (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O)) (map (proj (S n) O) (seq (S O) n))))) (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | error_comp a l l0 => error_rec (ok_arities n s) (error_comp a l l0) (if andb (andb (andb (Nat.eqb n (length (map (proj (S n) O) (seq (S O) n)))) (Nat.eqb s (length (map (proj (S n) (S s)) (seq (S (S n)) s))))) (andb (aeq (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (ok_arities (S n) O)) (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O)) (map (proj (S n) O) (seq (S O) n))))) (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | error_proj n0 n1 n2 => error_rec (ok_arities n s) (error_proj n0 n1 n2) (if andb (andb (andb (Nat.eqb n (length (map (proj (S n) O) (seq (S O) n)))) (Nat.eqb s (length (map (proj (S n) (S s)) (seq (S (S n)) s))))) (andb (aeq (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (ok_arities (S n) O)) (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O)) (map (proj (S n) O) (seq (S O) n))))) (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | ok_arities h0n h0s => match (if andb (andb (andb (Nat.eqb n (length (map (proj (S n) O) (seq (S O) n)))) (Nat.eqb s (length (map (proj (S n) (S s)) (seq (S (S n)) s))))) (andb (aeq (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (ok_arities (S n) O)) (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O)) (map (proj (S n) O) (seq (S O) n))))) (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) with | error_rec a a0 a1 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_rec a a0 a1) | error_comp a l l0 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_comp a l l0) | error_proj n0 n1 n2 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_proj n0 n1 n2) | ok_arities h1n h1s => if andb (andb (andb match h0n with | O => false | S m' => Nat.eqb n m' end (Nat.eqb h0n h1n)) match h0s with | O => false | S m' => Nat.eqb s m' end) (Nat.eqb h0s h1s) then ok_arities h0n s else error_rec (ok_arities n s) (ok_arities h0n h0s) (ok_arities h1n h1s) end end (ok_arities (S n) s)
+++++
do 2 rewrite map_length, seq_length.
-----
Lemma rec1_arities n s g h (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec1 n s g h) = ok_arities (S n) s.
Proof.
simpl.
rewrite Hg, Hh.
simpl.
do 2 rewrite map_length, seq_length.

*****
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
g,h : BC
n,s : nat
*****
eq match (if andb (andb (andb (Nat.eqb n n) (Nat.eqb s s)) (andb (aeq (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (ok_arities (S n) O)) (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O)) (map (proj (S n) O) (seq (S O) n))))) (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) with | error_rec a a0 a1 => error_rec (ok_arities n s) (error_rec a a0 a1) (if andb (andb (andb (Nat.eqb n n) (Nat.eqb s s)) (andb (aeq (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (ok_arities (S n) O)) (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O)) (map (proj (S n) O) (seq (S O) n))))) (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | error_comp a l l0 => error_rec (ok_arities n s) (error_comp a l l0) (if andb (andb (andb (Nat.eqb n n) (Nat.eqb s s)) (andb (aeq (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (ok_arities (S n) O)) (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O)) (map (proj (S n) O) (seq (S O) n))))) (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | error_proj n0 n1 n2 => error_rec (ok_arities n s) (error_proj n0 n1 n2) (if andb (andb (andb (Nat.eqb n n) (Nat.eqb s s)) (andb (aeq (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (ok_arities (S n) O)) (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O)) (map (proj (S n) O) (seq (S O) n))))) (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | ok_arities h0n h0s => match (if andb (andb (andb (Nat.eqb n n) (Nat.eqb s s)) (andb (aeq (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (ok_arities (S n) O)) (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O)) (map (proj (S n) O) (seq (S O) n))))) (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) with | error_rec a a0 a1 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_rec a a0 a1) | error_comp a l l0 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_comp a l l0) | error_proj n0 n1 n2 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_proj n0 n1 n2) | ok_arities h1n h1s => if andb (andb (andb match h0n with | O => false | S m' => Nat.eqb n m' end (Nat.eqb h0n h1n)) match h0s with | O => false | S m' => Nat.eqb s m' end) (Nat.eqb h0s h1s) then ok_arities h0n s else error_rec (ok_arities n s) (ok_arities h0n h0s) (ok_arities h1n h1s) end end (ok_arities (S n) s)
+++++
do 2 rewrite <- beq_nat_refl.
-----
Lemma rec1_arities n s g h (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec1 n s g h) = ok_arities (S n) s.
Proof.
simpl.
rewrite Hg, Hh.
simpl.
do 2 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.

*****
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
g,h : BC
n,s : nat
*****
eq match (if andb (andb (andb true true) (andb (aeq (if andb (andb true true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (ok_arities (S n) O)) (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O)) (map (proj (S n) O) (seq (S O) n))))) (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (if andb (andb true true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) with | error_rec a a0 a1 => error_rec (ok_arities n s) (error_rec a a0 a1) (if andb (andb (andb true true) (andb (aeq (if andb (andb true true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (ok_arities (S n) O)) (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O)) (map (proj (S n) O) (seq (S O) n))))) (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (if andb (andb true true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | error_comp a l l0 => error_rec (ok_arities n s) (error_comp a l l0) (if andb (andb (andb true true) (andb (aeq (if andb (andb true true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (ok_arities (S n) O)) (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O)) (map (proj (S n) O) (seq (S O) n))))) (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (if andb (andb true true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | error_proj n0 n1 n2 => error_rec (ok_arities n s) (error_proj n0 n1 n2) (if andb (andb (andb true true) (andb (aeq (if andb (andb true true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (ok_arities (S n) O)) (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O)) (map (proj (S n) O) (seq (S O) n))))) (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (if andb (andb true true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | ok_arities h0n h0s => match (if andb (andb (andb true true) (andb (aeq (if andb (andb true true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (ok_arities (S n) O)) (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O)) (map (proj (S n) O) (seq (S O) n))))) (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (if andb (andb true true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) with | error_rec a a0 a1 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_rec a a0 a1) | error_comp a l l0 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_comp a l l0) | error_proj n0 n1 n2 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_proj n0 n1 n2) | ok_arities h1n h1s => if andb (andb (andb match h0n with | O => false | S m' => Nat.eqb n m' end (Nat.eqb h0n h1n)) match h0s with | O => false | S m' => Nat.eqb s m' end) (Nat.eqb h0s h1s) then ok_arities h0n s else error_rec (ok_arities n s) (ok_arities h0n h0s) (ok_arities h1n h1s) end end (ok_arities (S n) s)
+++++
simpl.
-----
Lemma rec1_arities n s g h (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec1 n s g h) = ok_arities (S n) s.
Proof.
simpl.
rewrite Hg, Hh.
simpl.
do 2 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.

*****
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
g,h : BC
n,s : nat
*****
eq match (if andb (andb (andb (Nat.eqb n n) true) (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O)) (map (proj (S n) O) (seq (S O) n)))) (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) with | error_rec a a0 a1 => error_rec (ok_arities n s) (error_rec a a0 a1) (if andb (andb (andb (Nat.eqb n n) true) (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O)) (map (proj (S n) O) (seq (S O) n)))) (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | error_comp a l l0 => error_rec (ok_arities n s) (error_comp a l l0) (if andb (andb (andb (Nat.eqb n n) true) (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O)) (map (proj (S n) O) (seq (S O) n)))) (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | error_proj n0 n1 n2 => error_rec (ok_arities n s) (error_proj n0 n1 n2) (if andb (andb (andb (Nat.eqb n n) true) (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O)) (map (proj (S n) O) (seq (S O) n)))) (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | ok_arities h0n h0s => match (if andb (andb (andb (Nat.eqb n n) true) (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O)) (map (proj (S n) O) (seq (S O) n)))) (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) with | error_rec a a0 a1 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_rec a a0 a1) | error_comp a l l0 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_comp a l l0) | error_proj n0 n1 n2 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_proj n0 n1 n2) | ok_arities h1n h1s => if andb (andb (andb match h0n with | O => false | S m' => Nat.eqb n m' end (Nat.eqb h0n h1n)) match h0s with | O => false | S m' => Nat.eqb s m' end) (Nat.eqb h0s h1s) then ok_arities h0n s else error_rec (ok_arities n s) (ok_arities h0n h0s) (ok_arities h1n h1s) end end (ok_arities (S n) s)
+++++
rewrite <- beq_nat_refl.
-----
Lemma rec1_arities n s g h (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec1 n s g h) = ok_arities (S n) s.
Proof.
simpl.
rewrite Hg, Hh.
simpl.
do 2 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.

*****
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
g,h : BC
n,s : nat
*****
eq match (if andb (andb (andb true true) (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O)) (map (proj (S n) O) (seq (S O) n)))) (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) with | error_rec a a0 a1 => error_rec (ok_arities n s) (error_rec a a0 a1) (if andb (andb (andb true true) (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O)) (map (proj (S n) O) (seq (S O) n)))) (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | error_comp a l l0 => error_rec (ok_arities n s) (error_comp a l l0) (if andb (andb (andb true true) (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O)) (map (proj (S n) O) (seq (S O) n)))) (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | error_proj n0 n1 n2 => error_rec (ok_arities n s) (error_proj n0 n1 n2) (if andb (andb (andb true true) (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O)) (map (proj (S n) O) (seq (S O) n)))) (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | ok_arities h0n h0s => match (if andb (andb (andb true true) (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O)) (map (proj (S n) O) (seq (S O) n)))) (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) with | error_rec a a0 a1 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_rec a a0 a1) | error_comp a l l0 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_comp a l l0) | error_proj n0 n1 n2 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_proj n0 n1 n2) | ok_arities h1n h1s => if andb (andb (andb match h0n with | O => false | S m' => Nat.eqb n m' end (Nat.eqb h0n h1n)) match h0s with | O => false | S m' => Nat.eqb s m' end) (Nat.eqb h0s h1s) then ok_arities h0n s else error_rec (ok_arities n s) (ok_arities h0n h0s) (ok_arities h1n h1s) end end (ok_arities (S n) s)
+++++
simpl.
-----
Lemma rec1_arities n s g h (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec1 n s g h) = ok_arities (S n) s.
Proof.
simpl.
rewrite Hg, Hh.
simpl.
do 2 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.

*****
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
g,h : BC
n,s : nat
*****
eq match (if andb (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O)) (map (proj (S n) O) (seq (S O) n))) (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) with | error_rec a a0 a1 => error_rec (ok_arities n s) (error_rec a a0 a1) (if andb (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O)) (map (proj (S n) O) (seq (S O) n))) (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | error_comp a l l0 => error_rec (ok_arities n s) (error_comp a l l0) (if andb (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O)) (map (proj (S n) O) (seq (S O) n))) (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | error_proj n0 n1 n2 => error_rec (ok_arities n s) (error_proj n0 n1 n2) (if andb (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O)) (map (proj (S n) O) (seq (S O) n))) (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | ok_arities h0n h0s => match (if andb (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O)) (map (proj (S n) O) (seq (S O) n))) (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) with | error_rec a a0 a1 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_rec a a0 a1) | error_comp a l l0 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_comp a l l0) | error_proj n0 n1 n2 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_proj n0 n1 n2) | ok_arities h1n h1s => if andb (andb (andb match h0n with | O => false | S m' => Nat.eqb n m' end (Nat.eqb h0n h1n)) match h0s with | O => false | S m' => Nat.eqb s m' end) (Nat.eqb h0s h1s) then ok_arities h0n s else error_rec (ok_arities n s) (ok_arities h0n h0s) (ok_arities h1n h1s) end end (ok_arities (S n) s)
+++++
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
-----
Lemma rec1_arities n s g h (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec1 n s g h) = ok_arities (S n) s.
Proof.
simpl.
rewrite Hg, Hh.
simpl.
do 2 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.

*****
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O))\n (map (proj (S n) O) (seq (S O) n))) true
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
g,h : BC
n,s : nat
*****
eq match (if andb true (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) with | error_rec a a0 a1 => error_rec (ok_arities n s) (error_rec a a0 a1) (if andb true (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | error_comp a l l0 => error_rec (ok_arities n s) (error_comp a l l0) (if andb true (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | error_proj n0 n1 n2 => error_rec (ok_arities n s) (error_proj n0 n1 n2) (if andb true (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | ok_arities h0n h0s => match (if andb true (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) with | error_rec a a0 a1 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_rec a a0 a1) | error_comp a l l0 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_comp a l l0) | error_proj n0 n1 n2 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_proj n0 n1 n2) | ok_arities h1n h1s => if andb (andb (andb match h0n with | O => false | S m' => Nat.eqb n m' end (Nat.eqb h0n h1n)) match h0s with | O => false | S m' => Nat.eqb s m' end) (Nat.eqb h0s h1s) then ok_arities h0n s else error_rec (ok_arities n s) (ok_arities h0n h0s) (ok_arities h1n h1s) end end (ok_arities (S n) s)
+++++
simpl.
-----
Lemma rec1_arities n s g h (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec1 n s g h) = ok_arities (S n) s.
Proof.
simpl.
rewrite Hg, Hh.
simpl.
do 2 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.

*****
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O))\n (map (proj (S n) O) (seq (S O) n))) true
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
g,h : BC
n,s : nat
*****
eq match (if andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) with | error_rec a a0 a1 => error_rec (ok_arities n s) (error_rec a a0 a1) (if andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | error_comp a l l0 => error_rec (ok_arities n s) (error_comp a l l0) (if andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | error_proj n0 n1 n2 => error_rec (ok_arities n s) (error_proj n0 n1 n2) (if andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | ok_arities h0n h0s => match (if andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) with | error_rec a a0 a1 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_rec a a0 a1) | error_comp a l l0 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_comp a l l0) | error_proj n0 n1 n2 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_proj n0 n1 n2) | ok_arities h1n h1s => if andb (andb (andb match h0n with | O => false | S m' => Nat.eqb n m' end (Nat.eqb h0n h1n)) match h0s with | O => false | S m' => Nat.eqb s m' end) (Nat.eqb h0s h1s) then ok_arities h0n s else error_rec (ok_arities n s) (ok_arities h0n h0s) (ok_arities h1n h1s) end end (ok_arities (S n) s)
+++++
case_eq (n + S s).
-----
Lemma rec1_arities n s g h (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec1 n s g h) = ok_arities (S n) s.
Proof.
simpl.
rewrite Hg, Hh.
simpl.
do 2 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).

*****
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O))\n (map (proj (S n) O) (seq (S O) n))) true
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
g,h : BC
n,s : nat
*****
forall _ : eq (Init.Nat.add n (S s)) O, eq match (if andb (aeq (error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) with | error_rec a a0 a1 => error_rec (ok_arities n s) (error_rec a a0 a1) (if andb (aeq (error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | error_comp a l l0 => error_rec (ok_arities n s) (error_comp a l l0) (if andb (aeq (error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | error_proj n0 n1 n2 => error_rec (ok_arities n s) (error_proj n0 n1 n2) (if andb (aeq (error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | ok_arities h0n h0s => match (if andb (aeq (error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) with | error_rec a a0 a1 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_rec a a0 a1) | error_comp a l l0 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_comp a l l0) | error_proj n0 n1 n2 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_proj n0 n1 n2) | ok_arities h1n h1s => if andb (andb (andb match h0n with | O => false | S m' => Nat.eqb n m' end (Nat.eqb h0n h1n)) match h0s with | O => false | S m' => Nat.eqb s m' end) (Nat.eqb h0s h1s) then ok_arities h0n s else error_rec (ok_arities n s) (ok_arities h0n h0s) (ok_arities h1n h1s) end end (ok_arities (S n) s)
+++++
intro H2.
-----
Lemma rec1_arities n s g h (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec1 n s g h) = ok_arities (S n) s.
Proof.
simpl.
rewrite Hg, Hh.
simpl.
do 2 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).
intro H2.

*****
H2 : eq (Init.Nat.add n (S s)) O
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O))\n (map (proj (S n) O) (seq (S O) n))) true
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
g,h : BC
n,s : nat
*****
eq match (if andb (aeq (error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) with | error_rec a a0 a1 => error_rec (ok_arities n s) (error_rec a a0 a1) (if andb (aeq (error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | error_comp a l l0 => error_rec (ok_arities n s) (error_comp a l l0) (if andb (aeq (error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | error_proj n0 n1 n2 => error_rec (ok_arities n s) (error_proj n0 n1 n2) (if andb (aeq (error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | ok_arities h0n h0s => match (if andb (aeq (error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) with | error_rec a a0 a1 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_rec a a0 a1) | error_comp a l l0 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_comp a l l0) | error_proj n0 n1 n2 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_proj n0 n1 n2) | ok_arities h1n h1s => if andb (andb (andb match h0n with | O => false | S m' => Nat.eqb n m' end (Nat.eqb h0n h1n)) match h0s with | O => false | S m' => Nat.eqb s m' end) (Nat.eqb h0s h1s) then ok_arities h0n s else error_rec (ok_arities n s) (ok_arities h0n h0s) (ok_arities h1n h1s) end end (ok_arities (S n) s)
+++++
contradict H2.
-----
Lemma rec1_arities n s g h (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec1 n s g h) = ok_arities (S n) s.
Proof.
simpl.
rewrite Hg, Hh.
simpl.
do 2 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).
intro H2.
contradict H2.

*****
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O))\n (map (proj (S n) O) (seq (S O) n))) true
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
g,h : BC
n,s : nat
*****
not (eq (Init.Nat.add n (S s)) O)
+++++
omega.
-----
Lemma rec1_arities n s g h (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec1 n s g h) = ok_arities (S n) s.
Proof.
simpl.
rewrite Hg, Hh.
simpl.
do 2 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).
intro H2.
contradict H2.
omega.

*****
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O))\n (map (proj (S n) O) (seq (S O) n))) true
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
g,h : BC
n,s : nat
*****
forall (n0 : nat) (_ : eq (Init.Nat.add n (S s)) (S n0)), eq match (if andb (aeq (if Nat.leb n n0 then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if Nat.leb n n0 then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) with | error_rec a a0 a1 => error_rec (ok_arities n s) (error_rec a a0 a1) (if andb (aeq (if Nat.leb n n0 then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if Nat.leb n n0 then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | error_comp a l l0 => error_rec (ok_arities n s) (error_comp a l l0) (if andb (aeq (if Nat.leb n n0 then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if Nat.leb n n0 then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | error_proj n1 n2 n3 => error_rec (ok_arities n s) (error_proj n1 n2 n3) (if andb (aeq (if Nat.leb n n0 then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if Nat.leb n n0 then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | ok_arities h0n h0s => match (if andb (aeq (if Nat.leb n n0 then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if Nat.leb n n0 then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) with | error_rec a a0 a1 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_rec a a0 a1) | error_comp a l l0 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_comp a l l0) | error_proj n1 n2 n3 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_proj n1 n2 n3) | ok_arities h1n h1s => if andb (andb (andb match h0n with | O => false | S m' => Nat.eqb n m' end (Nat.eqb h0n h1n)) match h0s with | O => false | S m' => Nat.eqb s m' end) (Nat.eqb h0s h1s) then ok_arities h0n s else error_rec (ok_arities n s) (ok_arities h0n h0s) (ok_arities h1n h1s) end end (ok_arities (S n) s)
+++++
intros p H2.
-----
Lemma rec1_arities n s g h (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec1 n s g h) = ok_arities (S n) s.
Proof.
simpl.
rewrite Hg, Hh.
simpl.
do 2 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).
intro H2.
contradict H2.
omega.
intros p H2.

*****
H2 : eq (Init.Nat.add n (S s)) (S p)
p : nat
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O))\n (map (proj (S n) O) (seq (S O) n))) true
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
g,h : BC
n,s : nat
*****
eq match (if andb (aeq (if Nat.leb n p then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if Nat.leb n p then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) with | error_rec a a0 a1 => error_rec (ok_arities n s) (error_rec a a0 a1) (if andb (aeq (if Nat.leb n p then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if Nat.leb n p then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | error_comp a l l0 => error_rec (ok_arities n s) (error_comp a l l0) (if andb (aeq (if Nat.leb n p then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if Nat.leb n p then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | error_proj n0 n1 n2 => error_rec (ok_arities n s) (error_proj n0 n1 n2) (if andb (aeq (if Nat.leb n p then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if Nat.leb n p then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | ok_arities h0n h0s => match (if andb (aeq (if Nat.leb n p then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if Nat.leb n p then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) with | error_rec a a0 a1 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_rec a a0 a1) | error_comp a l l0 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_comp a l l0) | error_proj n0 n1 n2 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_proj n0 n1 n2) | ok_arities h1n h1s => if andb (andb (andb match h0n with | O => false | S m' => Nat.eqb n m' end (Nat.eqb h0n h1n)) match h0s with | O => false | S m' => Nat.eqb s m' end) (Nat.eqb h0s h1s) then ok_arities h0n s else error_rec (ok_arities n s) (ok_arities h0n h0s) (ok_arities h1n h1s) end end (ok_arities (S n) s)
+++++
case_eq (leb n p); intro H3.
-----
Lemma rec1_arities n s g h (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec1 n s g h) = ok_arities (S n) s.
Proof.
simpl.
rewrite Hg, Hh.
simpl.
do 2 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).
intro H2.
contradict H2.
omega.
intros p H2.
case_eq (leb n p); intro H3.

*****
H3 : eq (Nat.leb n p) true
H2 : eq (Init.Nat.add n (S s)) (S p)
p : nat
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O))\n (map (proj (S n) O) (seq (S O) n))) true
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
g,h : BC
n,s : nat
*****
eq match (if andb (aeq (ok_arities (S n) (S s)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (ok_arities (S n) (S s)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) with | error_rec a a0 a1 => error_rec (ok_arities n s) (error_rec a a0 a1) (if andb (aeq (ok_arities (S n) (S s)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (ok_arities (S n) (S s)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | error_comp a l l0 => error_rec (ok_arities n s) (error_comp a l l0) (if andb (aeq (ok_arities (S n) (S s)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (ok_arities (S n) (S s)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | error_proj n0 n1 n2 => error_rec (ok_arities n s) (error_proj n0 n1 n2) (if andb (aeq (ok_arities (S n) (S s)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (ok_arities (S n) (S s)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | ok_arities h0n h0s => match (if andb (aeq (ok_arities (S n) (S s)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (ok_arities (S n) (S s)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) with | error_rec a a0 a1 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_rec a a0 a1) | error_comp a l l0 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_comp a l l0) | error_proj n0 n1 n2 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_proj n0 n1 n2) | ok_arities h1n h1s => if andb (andb (andb match h0n with | O => false | S m' => Nat.eqb n m' end (Nat.eqb h0n h1n)) match h0s with | O => false | S m' => Nat.eqb s m' end) (Nat.eqb h0s h1s) then ok_arities h0n s else error_rec (ok_arities n s) (ok_arities h0n h0s) (ok_arities h1n h1s) end end (ok_arities (S n) s)
+++++
simpl.
-----
Lemma rec1_arities n s g h (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec1 n s g h) = ok_arities (S n) s.
Proof.
simpl.
rewrite Hg, Hh.
simpl.
do 2 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).
intro H2.
contradict H2.
omega.
intros p H2.
case_eq (leb n p); intro H3.
simpl.

*****
H3 : eq (Nat.leb n p) true
H2 : eq (Init.Nat.add n (S s)) (S p)
p : nat
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O))\n (map (proj (S n) O) (seq (S O) n))) true
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
g,h : BC
n,s : nat
*****
eq match (if andb (andb (Nat.eqb n n) (Nat.eqb s s)) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (ok_arities (S n) (S s)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) with | error_rec a a0 a1 => error_rec (ok_arities n s) (error_rec a a0 a1) (if andb (andb (Nat.eqb n n) (Nat.eqb s s)) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (ok_arities (S n) (S s)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | error_comp a l l0 => error_rec (ok_arities n s) (error_comp a l l0) (if andb (andb (Nat.eqb n n) (Nat.eqb s s)) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (ok_arities (S n) (S s)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | error_proj n0 n1 n2 => error_rec (ok_arities n s) (error_proj n0 n1 n2) (if andb (andb (Nat.eqb n n) (Nat.eqb s s)) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (ok_arities (S n) (S s)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | ok_arities h0n h0s => match (if andb (andb (Nat.eqb n n) (Nat.eqb s s)) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (ok_arities (S n) (S s)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) with | error_rec a a0 a1 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_rec a a0 a1) | error_comp a l l0 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_comp a l l0) | error_proj n0 n1 n2 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_proj n0 n1 n2) | ok_arities h1n h1s => if andb (andb (andb match h0n with | O => false | S m' => Nat.eqb n m' end (Nat.eqb h0n h1n)) match h0s with | O => false | S m' => Nat.eqb s m' end) (Nat.eqb h0s h1s) then ok_arities h0n s else error_rec (ok_arities n s) (ok_arities h0n h0s) (ok_arities h1n h1s) end end (ok_arities (S n) s)
+++++
do 2 rewrite <- beq_nat_refl.
-----
Lemma rec1_arities n s g h (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec1 n s g h) = ok_arities (S n) s.
Proof.
simpl.
rewrite Hg, Hh.
simpl.
do 2 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).
intro H2.
contradict H2.
omega.
intros p H2.
case_eq (leb n p); intro H3.
simpl.
do 2 rewrite <- beq_nat_refl.

*****
H3 : eq (Nat.leb n p) true
H2 : eq (Init.Nat.add n (S s)) (S p)
p : nat
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O))\n (map (proj (S n) O) (seq (S O) n))) true
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
g,h : BC
n,s : nat
*****
eq match (if andb (andb true true) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (ok_arities (S n) (S s)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) with | error_rec a a0 a1 => error_rec (ok_arities n s) (error_rec a a0 a1) (if andb (andb true true) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (ok_arities (S n) (S s)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | error_comp a l l0 => error_rec (ok_arities n s) (error_comp a l l0) (if andb (andb true true) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (ok_arities (S n) (S s)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | error_proj n0 n1 n2 => error_rec (ok_arities n s) (error_proj n0 n1 n2) (if andb (andb true true) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (ok_arities (S n) (S s)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | ok_arities h0n h0s => match (if andb (andb true true) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (ok_arities (S n) (S s)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) with | error_rec a a0 a1 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_rec a a0 a1) | error_comp a l l0 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_comp a l l0) | error_proj n0 n1 n2 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_proj n0 n1 n2) | ok_arities h1n h1s => if andb (andb (andb match h0n with | O => false | S m' => Nat.eqb n m' end (Nat.eqb h0n h1n)) match h0s with | O => false | S m' => Nat.eqb s m' end) (Nat.eqb h0s h1s) then ok_arities h0n s else error_rec (ok_arities n s) (ok_arities h0n h0s) (ok_arities h1n h1s) end end (ok_arities (S n) s)
+++++
simpl.
-----
Lemma rec1_arities n s g h (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec1 n s g h) = ok_arities (S n) s.
Proof.
simpl.
rewrite Hg, Hh.
simpl.
do 2 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).
intro H2.
contradict H2.
omega.
intros p H2.
case_eq (leb n p); intro H3.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.

*****
H3 : eq (Nat.leb n p) true
H2 : eq (Init.Nat.add n (S s)) (S p)
p : nat
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O))\n (map (proj (S n) O) (seq (S O) n))) true
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
g,h : BC
n,s : nat
*****
eq match (if forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (ok_arities (S n) (S s)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) with | error_rec a a0 a1 => error_rec (ok_arities n s) (error_rec a a0 a1) (if forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (ok_arities (S n) (S s)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | error_comp a l l0 => error_rec (ok_arities n s) (error_comp a l l0) (if forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (ok_arities (S n) (S s)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | error_proj n0 n1 n2 => error_rec (ok_arities n s) (error_proj n0 n1 n2) (if forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (ok_arities (S n) (S s)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | ok_arities h0n h0s => match (if forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (ok_arities (S n) (S s)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) with | error_rec a a0 a1 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_rec a a0 a1) | error_comp a l l0 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_comp a l l0) | error_proj n0 n1 n2 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_proj n0 n1 n2) | ok_arities h1n h1s => if andb (andb (andb match h0n with | O => false | S m' => Nat.eqb n m' end (Nat.eqb h0n h1n)) match h0s with | O => false | S m' => Nat.eqb s m' end) (Nat.eqb h0s h1s) then ok_arities h0n s else error_rec (ok_arities n s) (ok_arities h0n h0s) (ok_arities h1n h1s) end end (ok_arities (S n) s)
+++++
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H4 end.
-----
Lemma rec1_arities n s g h (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec1 n s g h) = ok_arities (S n) s.
Proof.
simpl.
rewrite Hg, Hh.
simpl.
do 2 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).
intro H2.
contradict H2.
omega.
intros p H2.
case_eq (leb n p); intro H3.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H4 end.

*****
H4 : eq\n (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s)))\n (map (proj (S n) (S s)) (seq (S (S n)) s))) true
H3 : eq (Nat.leb n p) true
H2 : eq (Init.Nat.add n (S s)) (S p)
p : nat
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O))\n (map (proj (S n) O) (seq (S O) n))) true
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
g,h : BC
n,s : nat
*****
eq (if andb (andb (andb (Nat.eqb n n) (Nat.eqb (S n) (S n))) (Nat.eqb s s)) (Nat.eqb (S s) (S s)) then ok_arities (S n) s else error_rec (ok_arities n s) (ok_arities (S n) (S s)) (ok_arities (S n) (S s))) (ok_arities (S n) s)
+++++
do 4 rewrite <- beq_nat_refl.
-----
Lemma rec1_arities n s g h (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec1 n s g h) = ok_arities (S n) s.
Proof.
simpl.
rewrite Hg, Hh.
simpl.
do 2 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).
intro H2.
contradict H2.
omega.
intros p H2.
case_eq (leb n p); intro H3.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H4 end.
do 4 rewrite <- beq_nat_refl.

*****
H4 : eq\n (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s)))\n (map (proj (S n) (S s)) (seq (S (S n)) s))) true
H3 : eq (Nat.leb n p) true
H2 : eq (Init.Nat.add n (S s)) (S p)
p : nat
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O))\n (map (proj (S n) O) (seq (S O) n))) true
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
g,h : BC
n,s : nat
*****
eq (if andb (andb (andb true true) true) true then ok_arities (S n) s else error_rec (ok_arities n s) (ok_arities (S n) (S s)) (ok_arities (S n) (S s))) (ok_arities (S n) s)
+++++
simpl.
-----
Lemma rec1_arities n s g h (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec1 n s g h) = ok_arities (S n) s.
Proof.
simpl.
rewrite Hg, Hh.
simpl.
do 2 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).
intro H2.
contradict H2.
omega.
intros p H2.
case_eq (leb n p); intro H3.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H4 end.
do 4 rewrite <- beq_nat_refl.
simpl.

*****
H4 : eq\n (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s)))\n (map (proj (S n) (S s)) (seq (S (S n)) s))) true
H3 : eq (Nat.leb n p) true
H2 : eq (Init.Nat.add n (S s)) (S p)
p : nat
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O))\n (map (proj (S n) O) (seq (S O) n))) true
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
g,h : BC
n,s : nat
*****
eq (ok_arities (S n) s) (ok_arities (S n) s)
+++++
reflexivity.
-----
Lemma rec1_arities n s g h (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec1 n s g h) = ok_arities (S n) s.
Proof.
simpl.
rewrite Hg, Hh.
simpl.
do 2 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).
intro H2.
contradict H2.
omega.
intros p H2.
case_eq (leb n p); intro H3.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H4 end.
do 4 rewrite <- beq_nat_refl.
simpl.
reflexivity.

*****
H4 : eq\n (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s)))\n (map (proj (S n) (S s)) (seq (S (S n)) s))) false
H3 : eq (Nat.leb n p) true
H2 : eq (Init.Nat.add n (S s)) (S p)
p : nat
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O))\n (map (proj (S n) O) (seq (S O) n))) true
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
g,h : BC
n,s : nat
*****
eq (error_rec (ok_arities n s) (error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (ok_arities (S n) (S s)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) (error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (ok_arities (S n) (S s)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s)))))) (ok_arities (S n) s)
+++++
rewrite forallb_forall_conv in H4.
-----
Lemma rec1_arities n s g h (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec1 n s g h) = ok_arities (S n) s.
Proof.
simpl.
rewrite Hg, Hh.
simpl.
do 2 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).
intro H2.
contradict H2.
omega.
intros p H2.
case_eq (leb n p); intro H3.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H4 end.
do 4 rewrite <- beq_nat_refl.
simpl.
reflexivity.
rewrite forallb_forall_conv in H4.

*****
H4 : ex\n (fun x : BC =>\n and (In x (map (proj (S n) (S s)) (seq (S (S n)) s)))\n (eq (aeq (arities x) (ok_arities (S n) (S s))) false))
H3 : eq (Nat.leb n p) true
H2 : eq (Init.Nat.add n (S s)) (S p)
p : nat
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O))\n (map (proj (S n) O) (seq (S O) n))) true
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
g,h : BC
n,s : nat
*****
eq (error_rec (ok_arities n s) (error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (ok_arities (S n) (S s)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) (error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (ok_arities (S n) (S s)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s)))))) (ok_arities (S n) s)
+++++
destruct H4 as [e [H4 H5] ].
-----
Lemma rec1_arities n s g h (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec1 n s g h) = ok_arities (S n) s.
Proof.
simpl.
rewrite Hg, Hh.
simpl.
do 2 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).
intro H2.
contradict H2.
omega.
intros p H2.
case_eq (leb n p); intro H3.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H4 end.
do 4 rewrite <- beq_nat_refl.
simpl.
reflexivity.
rewrite forallb_forall_conv in H4.
destruct H4 as [e [H4 H5] ].

*****
H5 : eq (aeq (arities e) (ok_arities (S n) (S s))) false
H4 : In e (map (proj (S n) (S s)) (seq (S (S n)) s))
e : BC
H3 : eq (Nat.leb n p) true
H2 : eq (Init.Nat.add n (S s)) (S p)
p : nat
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O))\n (map (proj (S n) O) (seq (S O) n))) true
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
g,h : BC
n,s : nat
*****
eq (error_rec (ok_arities n s) (error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (ok_arities (S n) (S s)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) (error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (ok_arities (S n) (S s)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s)))))) (ok_arities (S n) s)
+++++
rewrite in_map_iff in H4.
-----
Lemma rec1_arities n s g h (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec1 n s g h) = ok_arities (S n) s.
Proof.
simpl.
rewrite Hg, Hh.
simpl.
do 2 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).
intro H2.
contradict H2.
omega.
intros p H2.
case_eq (leb n p); intro H3.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H4 end.
do 4 rewrite <- beq_nat_refl.
simpl.
reflexivity.
rewrite forallb_forall_conv in H4.
destruct H4 as [e [H4 H5] ].
rewrite in_map_iff in H4.

*****
H5 : eq (aeq (arities e) (ok_arities (S n) (S s))) false
H4 : ex\n (fun x : nat =>\n and (eq (proj (S n) (S s) x) e) (In x (seq (S (S n)) s)))
e : BC
H3 : eq (Nat.leb n p) true
H2 : eq (Init.Nat.add n (S s)) (S p)
p : nat
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O))\n (map (proj (S n) O) (seq (S O) n))) true
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
g,h : BC
n,s : nat
*****
eq (error_rec (ok_arities n s) (error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (ok_arities (S n) (S s)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) (error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (ok_arities (S n) (S s)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s)))))) (ok_arities (S n) s)
+++++
destruct H4 as [q [H4 H6] ].
-----
Lemma rec1_arities n s g h (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec1 n s g h) = ok_arities (S n) s.
Proof.
simpl.
rewrite Hg, Hh.
simpl.
do 2 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).
intro H2.
contradict H2.
omega.
intros p H2.
case_eq (leb n p); intro H3.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H4 end.
do 4 rewrite <- beq_nat_refl.
simpl.
reflexivity.
rewrite forallb_forall_conv in H4.
destruct H4 as [e [H4 H5] ].
rewrite in_map_iff in H4.
destruct H4 as [q [H4 H6] ].

*****
H5 : eq (aeq (arities e) (ok_arities (S n) (S s))) false
H6 : In q (seq (S (S n)) s)
H4 : eq (proj (S n) (S s) q) e
q : nat
e : BC
H3 : eq (Nat.leb n p) true
H2 : eq (Init.Nat.add n (S s)) (S p)
p : nat
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O))\n (map (proj (S n) O) (seq (S O) n))) true
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
g,h : BC
n,s : nat
*****
eq (error_rec (ok_arities n s) (error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (ok_arities (S n) (S s)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) (error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (ok_arities (S n) (S s)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s)))))) (ok_arities (S n) s)
+++++
rewrite in_seq_iff in H6.
-----
Lemma rec1_arities n s g h (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec1 n s g h) = ok_arities (S n) s.
Proof.
simpl.
rewrite Hg, Hh.
simpl.
do 2 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).
intro H2.
contradict H2.
omega.
intros p H2.
case_eq (leb n p); intro H3.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H4 end.
do 4 rewrite <- beq_nat_refl.
simpl.
reflexivity.
rewrite forallb_forall_conv in H4.
destruct H4 as [e [H4 H5] ].
rewrite in_map_iff in H4.
destruct H4 as [q [H4 H6] ].
rewrite in_seq_iff in H6.

*****
H5 : eq (aeq (arities e) (ok_arities (S n) (S s))) false
H6 : and (le (S (S n)) q) (lt q (Init.Nat.add (S (S n)) s))
H4 : eq (proj (S n) (S s) q) e
q : nat
e : BC
H3 : eq (Nat.leb n p) true
H2 : eq (Init.Nat.add n (S s)) (S p)
p : nat
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O))\n (map (proj (S n) O) (seq (S O) n))) true
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
g,h : BC
n,s : nat
*****
eq (error_rec (ok_arities n s) (error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (ok_arities (S n) (S s)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) (error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (ok_arities (S n) (S s)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s)))))) (ok_arities (S n) s)
+++++
subst e.
-----
Lemma rec1_arities n s g h (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec1 n s g h) = ok_arities (S n) s.
Proof.
simpl.
rewrite Hg, Hh.
simpl.
do 2 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).
intro H2.
contradict H2.
omega.
intros p H2.
case_eq (leb n p); intro H3.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H4 end.
do 4 rewrite <- beq_nat_refl.
simpl.
reflexivity.
rewrite forallb_forall_conv in H4.
destruct H4 as [e [H4 H5] ].
rewrite in_map_iff in H4.
destruct H4 as [q [H4 H6] ].
rewrite in_seq_iff in H6.
subst e.

*****
H5 : eq (aeq (arities (proj (S n) (S s) q)) (ok_arities (S n) (S s))) false
H6 : and (le (S (S n)) q) (lt q (Init.Nat.add (S (S n)) s))
q : nat
H3 : eq (Nat.leb n p) true
H2 : eq (Init.Nat.add n (S s)) (S p)
p : nat
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O))\n (map (proj (S n) O) (seq (S O) n))) true
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
g,h : BC
n,s : nat
*****
eq (error_rec (ok_arities n s) (error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (ok_arities (S n) (S s)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) (error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (ok_arities (S n) (S s)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s)))))) (ok_arities (S n) s)
+++++
simpl in H5.
-----
Lemma rec1_arities n s g h (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec1 n s g h) = ok_arities (S n) s.
Proof.
simpl.
rewrite Hg, Hh.
simpl.
do 2 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).
intro H2.
contradict H2.
omega.
intros p H2.
case_eq (leb n p); intro H3.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H4 end.
do 4 rewrite <- beq_nat_refl.
simpl.
reflexivity.
rewrite forallb_forall_conv in H4.
destruct H4 as [e [H4 H5] ].
rewrite in_map_iff in H4.
destruct H4 as [q [H4 H6] ].
rewrite in_seq_iff in H6.
subst e.
simpl in H5.

*****
H5 : eq\n (aeq\n (if Nat.leb q (Init.Nat.add n (S s))\n then ok_arities (S n) (S s)\n else error_proj (S n) (S s) q) (ok_arities (S n) (S s))) false
H6 : and (le (S (S n)) q) (lt q (Init.Nat.add (S (S n)) s))
q : nat
H3 : eq (Nat.leb n p) true
H2 : eq (Init.Nat.add n (S s)) (S p)
p : nat
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O))\n (map (proj (S n) O) (seq (S O) n))) true
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
g,h : BC
n,s : nat
*****
eq (error_rec (ok_arities n s) (error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (ok_arities (S n) (S s)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) (error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (ok_arities (S n) (S s)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s)))))) (ok_arities (S n) s)
+++++
case_eq (leb q (n + S s)); intro H7.
-----
Lemma rec1_arities n s g h (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec1 n s g h) = ok_arities (S n) s.
Proof.
simpl.
rewrite Hg, Hh.
simpl.
do 2 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).
intro H2.
contradict H2.
omega.
intros p H2.
case_eq (leb n p); intro H3.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H4 end.
do 4 rewrite <- beq_nat_refl.
simpl.
reflexivity.
rewrite forallb_forall_conv in H4.
destruct H4 as [e [H4 H5] ].
rewrite in_map_iff in H4.
destruct H4 as [q [H4 H6] ].
rewrite in_seq_iff in H6.
subst e.
simpl in H5.
case_eq (leb q (n + S s)); intro H7.

*****
H7 : eq (Nat.leb q (Init.Nat.add n (S s))) true
H5 : eq\n (aeq\n (if Nat.leb q (Init.Nat.add n (S s))\n then ok_arities (S n) (S s)\n else error_proj (S n) (S s) q) (ok_arities (S n) (S s))) false
H6 : and (le (S (S n)) q) (lt q (Init.Nat.add (S (S n)) s))
q : nat
H3 : eq (Nat.leb n p) true
H2 : eq (Init.Nat.add n (S s)) (S p)
p : nat
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O))\n (map (proj (S n) O) (seq (S O) n))) true
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
g,h : BC
n,s : nat
*****
eq (error_rec (ok_arities n s) (error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (ok_arities (S n) (S s)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) (error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (ok_arities (S n) (S s)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s)))))) (ok_arities (S n) s)
+++++
rewrite H7 in H5.
-----
Lemma rec1_arities n s g h (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec1 n s g h) = ok_arities (S n) s.
Proof.
simpl.
rewrite Hg, Hh.
simpl.
do 2 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).
intro H2.
contradict H2.
omega.
intros p H2.
case_eq (leb n p); intro H3.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H4 end.
do 4 rewrite <- beq_nat_refl.
simpl.
reflexivity.
rewrite forallb_forall_conv in H4.
destruct H4 as [e [H4 H5] ].
rewrite in_map_iff in H4.
destruct H4 as [q [H4 H6] ].
rewrite in_seq_iff in H6.
subst e.
simpl in H5.
case_eq (leb q (n + S s)); intro H7.
rewrite H7 in H5.

*****
H7 : eq (Nat.leb q (Init.Nat.add n (S s))) true
H5 : eq (aeq (ok_arities (S n) (S s)) (ok_arities (S n) (S s))) false
H6 : and (le (S (S n)) q) (lt q (Init.Nat.add (S (S n)) s))
q : nat
H3 : eq (Nat.leb n p) true
H2 : eq (Init.Nat.add n (S s)) (S p)
p : nat
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O))\n (map (proj (S n) O) (seq (S O) n))) true
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
g,h : BC
n,s : nat
*****
eq (error_rec (ok_arities n s) (error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (ok_arities (S n) (S s)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) (error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (ok_arities (S n) (S s)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s)))))) (ok_arities (S n) s)
+++++
simpl in H5.
-----
Lemma rec1_arities n s g h (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec1 n s g h) = ok_arities (S n) s.
Proof.
simpl.
rewrite Hg, Hh.
simpl.
do 2 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).
intro H2.
contradict H2.
omega.
intros p H2.
case_eq (leb n p); intro H3.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H4 end.
do 4 rewrite <- beq_nat_refl.
simpl.
reflexivity.
rewrite forallb_forall_conv in H4.
destruct H4 as [e [H4 H5] ].
rewrite in_map_iff in H4.
destruct H4 as [q [H4 H6] ].
rewrite in_seq_iff in H6.
subst e.
simpl in H5.
case_eq (leb q (n + S s)); intro H7.
rewrite H7 in H5.
simpl in H5.

*****
H7 : eq (Nat.leb q (Init.Nat.add n (S s))) true
H5 : eq (andb (Nat.eqb n n) (Nat.eqb s s)) false
H6 : and (le (S (S n)) q) (lt q (Init.Nat.add (S (S n)) s))
q : nat
H3 : eq (Nat.leb n p) true
H2 : eq (Init.Nat.add n (S s)) (S p)
p : nat
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O))\n (map (proj (S n) O) (seq (S O) n))) true
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
g,h : BC
n,s : nat
*****
eq (error_rec (ok_arities n s) (error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (ok_arities (S n) (S s)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) (error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (ok_arities (S n) (S s)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s)))))) (ok_arities (S n) s)
+++++
do 2 rewrite <- beq_nat_refl in H5.
-----
Lemma rec1_arities n s g h (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec1 n s g h) = ok_arities (S n) s.
Proof.
simpl.
rewrite Hg, Hh.
simpl.
do 2 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).
intro H2.
contradict H2.
omega.
intros p H2.
case_eq (leb n p); intro H3.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H4 end.
do 4 rewrite <- beq_nat_refl.
simpl.
reflexivity.
rewrite forallb_forall_conv in H4.
destruct H4 as [e [H4 H5] ].
rewrite in_map_iff in H4.
destruct H4 as [q [H4 H6] ].
rewrite in_seq_iff in H6.
subst e.
simpl in H5.
case_eq (leb q (n + S s)); intro H7.
rewrite H7 in H5.
simpl in H5.
do 2 rewrite <- beq_nat_refl in H5.

*****
H7 : eq (Nat.leb q (Init.Nat.add n (S s))) true
H5 : eq (andb true true) false
H6 : and (le (S (S n)) q) (lt q (Init.Nat.add (S (S n)) s))
q : nat
H3 : eq (Nat.leb n p) true
H2 : eq (Init.Nat.add n (S s)) (S p)
p : nat
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O))\n (map (proj (S n) O) (seq (S O) n))) true
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
g,h : BC
n,s : nat
*****
eq (error_rec (ok_arities n s) (error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (ok_arities (S n) (S s)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) (error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (ok_arities (S n) (S s)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s)))))) (ok_arities (S n) s)
+++++
discriminate H5.
-----
Lemma rec1_arities n s g h (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec1 n s g h) = ok_arities (S n) s.
Proof.
simpl.
rewrite Hg, Hh.
simpl.
do 2 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).
intro H2.
contradict H2.
omega.
intros p H2.
case_eq (leb n p); intro H3.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H4 end.
do 4 rewrite <- beq_nat_refl.
simpl.
reflexivity.
rewrite forallb_forall_conv in H4.
destruct H4 as [e [H4 H5] ].
rewrite in_map_iff in H4.
destruct H4 as [q [H4 H6] ].
rewrite in_seq_iff in H6.
subst e.
simpl in H5.
case_eq (leb q (n + S s)); intro H7.
rewrite H7 in H5.
simpl in H5.
do 2 rewrite <- beq_nat_refl in H5.
discriminate H5.

*****
H7 : eq (Nat.leb q (Init.Nat.add n (S s))) false
H5 : eq\n (aeq\n (if Nat.leb q (Init.Nat.add n (S s))\n then ok_arities (S n) (S s)\n else error_proj (S n) (S s) q) (ok_arities (S n) (S s))) false
H6 : and (le (S (S n)) q) (lt q (Init.Nat.add (S (S n)) s))
q : nat
H3 : eq (Nat.leb n p) true
H2 : eq (Init.Nat.add n (S s)) (S p)
p : nat
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O))\n (map (proj (S n) O) (seq (S O) n))) true
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
g,h : BC
n,s : nat
*****
eq (error_rec (ok_arities n s) (error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (ok_arities (S n) (S s)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) (error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (ok_arities (S n) (S s)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s)))))) (ok_arities (S n) s)
+++++
rewrite leb_iff_conv in H7.
-----
Lemma rec1_arities n s g h (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec1 n s g h) = ok_arities (S n) s.
Proof.
simpl.
rewrite Hg, Hh.
simpl.
do 2 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).
intro H2.
contradict H2.
omega.
intros p H2.
case_eq (leb n p); intro H3.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H4 end.
do 4 rewrite <- beq_nat_refl.
simpl.
reflexivity.
rewrite forallb_forall_conv in H4.
destruct H4 as [e [H4 H5] ].
rewrite in_map_iff in H4.
destruct H4 as [q [H4 H6] ].
rewrite in_seq_iff in H6.
subst e.
simpl in H5.
case_eq (leb q (n + S s)); intro H7.
rewrite H7 in H5.
simpl in H5.
do 2 rewrite <- beq_nat_refl in H5.
discriminate H5.
rewrite leb_iff_conv in H7.

*****
H7 : lt (Init.Nat.add n (S s)) q
H5 : eq\n (aeq\n (if Nat.leb q (Init.Nat.add n (S s))\n then ok_arities (S n) (S s)\n else error_proj (S n) (S s) q) (ok_arities (S n) (S s))) false
H6 : and (le (S (S n)) q) (lt q (Init.Nat.add (S (S n)) s))
q : nat
H3 : eq (Nat.leb n p) true
H2 : eq (Init.Nat.add n (S s)) (S p)
p : nat
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O))\n (map (proj (S n) O) (seq (S O) n))) true
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
g,h : BC
n,s : nat
*****
eq (error_rec (ok_arities n s) (error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (ok_arities (S n) (S s)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) (error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (ok_arities (S n) (S s)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s)))))) (ok_arities (S n) s)
+++++
contradict H7.
-----
Lemma rec1_arities n s g h (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec1 n s g h) = ok_arities (S n) s.
Proof.
simpl.
rewrite Hg, Hh.
simpl.
do 2 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).
intro H2.
contradict H2.
omega.
intros p H2.
case_eq (leb n p); intro H3.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H4 end.
do 4 rewrite <- beq_nat_refl.
simpl.
reflexivity.
rewrite forallb_forall_conv in H4.
destruct H4 as [e [H4 H5] ].
rewrite in_map_iff in H4.
destruct H4 as [q [H4 H6] ].
rewrite in_seq_iff in H6.
subst e.
simpl in H5.
case_eq (leb q (n + S s)); intro H7.
rewrite H7 in H5.
simpl in H5.
do 2 rewrite <- beq_nat_refl in H5.
discriminate H5.
rewrite leb_iff_conv in H7.
contradict H7.

*****
H5 : eq\n (aeq\n (if Nat.leb q (Init.Nat.add n (S s))\n then ok_arities (S n) (S s)\n else error_proj (S n) (S s) q) (ok_arities (S n) (S s))) false
H6 : and (le (S (S n)) q) (lt q (Init.Nat.add (S (S n)) s))
q : nat
H3 : eq (Nat.leb n p) true
H2 : eq (Init.Nat.add n (S s)) (S p)
p : nat
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O))\n (map (proj (S n) O) (seq (S O) n))) true
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
g,h : BC
n,s : nat
*****
not (lt (Init.Nat.add n (S s)) q)
+++++
omega.
-----
Lemma rec1_arities n s g h (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec1 n s g h) = ok_arities (S n) s.
Proof.
simpl.
rewrite Hg, Hh.
simpl.
do 2 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).
intro H2.
contradict H2.
omega.
intros p H2.
case_eq (leb n p); intro H3.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H4 end.
do 4 rewrite <- beq_nat_refl.
simpl.
reflexivity.
rewrite forallb_forall_conv in H4.
destruct H4 as [e [H4 H5] ].
rewrite in_map_iff in H4.
destruct H4 as [q [H4 H6] ].
rewrite in_seq_iff in H6.
subst e.
simpl in H5.
case_eq (leb q (n + S s)); intro H7.
rewrite H7 in H5.
simpl in H5.
do 2 rewrite <- beq_nat_refl in H5.
discriminate H5.
rewrite leb_iff_conv in H7.
contradict H7.
omega.

*****
H3 : eq (Nat.leb n p) false
H2 : eq (Init.Nat.add n (S s)) (S p)
p : nat
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O))\n (map (proj (S n) O) (seq (S O) n))) true
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
g,h : BC
n,s : nat
*****
eq match (if andb (aeq (error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) with | error_rec a a0 a1 => error_rec (ok_arities n s) (error_rec a a0 a1) (if andb (aeq (error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | error_comp a l l0 => error_rec (ok_arities n s) (error_comp a l l0) (if andb (aeq (error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | error_proj n0 n1 n2 => error_rec (ok_arities n s) (error_proj n0 n1 n2) (if andb (aeq (error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | ok_arities h0n h0s => match (if andb (aeq (error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) with | error_rec a a0 a1 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_rec a a0 a1) | error_comp a l l0 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_comp a l l0) | error_proj n0 n1 n2 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_proj n0 n1 n2) | ok_arities h1n h1s => if andb (andb (andb match h0n with | O => false | S m' => Nat.eqb n m' end (Nat.eqb h0n h1n)) match h0s with | O => false | S m' => Nat.eqb s m' end) (Nat.eqb h0s h1s) then ok_arities h0n s else error_rec (ok_arities n s) (ok_arities h0n h0s) (ok_arities h1n h1s) end end (ok_arities (S n) s)
+++++
rewrite leb_iff_conv in H3.
-----
Lemma rec1_arities n s g h (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec1 n s g h) = ok_arities (S n) s.
Proof.
simpl.
rewrite Hg, Hh.
simpl.
do 2 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).
intro H2.
contradict H2.
omega.
intros p H2.
case_eq (leb n p); intro H3.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H4 end.
do 4 rewrite <- beq_nat_refl.
simpl.
reflexivity.
rewrite forallb_forall_conv in H4.
destruct H4 as [e [H4 H5] ].
rewrite in_map_iff in H4.
destruct H4 as [q [H4 H6] ].
rewrite in_seq_iff in H6.
subst e.
simpl in H5.
case_eq (leb q (n + S s)); intro H7.
rewrite H7 in H5.
simpl in H5.
do 2 rewrite <- beq_nat_refl in H5.
discriminate H5.
rewrite leb_iff_conv in H7.
contradict H7.
omega.
rewrite leb_iff_conv in H3.

*****
H3 : lt p n
H2 : eq (Init.Nat.add n (S s)) (S p)
p : nat
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O))\n (map (proj (S n) O) (seq (S O) n))) true
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
g,h : BC
n,s : nat
*****
eq match (if andb (aeq (error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) with | error_rec a a0 a1 => error_rec (ok_arities n s) (error_rec a a0 a1) (if andb (aeq (error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | error_comp a l l0 => error_rec (ok_arities n s) (error_comp a l l0) (if andb (aeq (error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | error_proj n0 n1 n2 => error_rec (ok_arities n s) (error_proj n0 n1 n2) (if andb (aeq (error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | ok_arities h0n h0s => match (if andb (aeq (error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) with | error_rec a a0 a1 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_rec a a0 a1) | error_comp a l l0 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_comp a l l0) | error_proj n0 n1 n2 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_proj n0 n1 n2) | ok_arities h1n h1s => if andb (andb (andb match h0n with | O => false | S m' => Nat.eqb n m' end (Nat.eqb h0n h1n)) match h0s with | O => false | S m' => Nat.eqb s m' end) (Nat.eqb h0s h1s) then ok_arities h0n s else error_rec (ok_arities n s) (ok_arities h0n h0s) (ok_arities h1n h1s) end end (ok_arities (S n) s)
+++++
contradict H3.
-----
Lemma rec1_arities n s g h (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec1 n s g h) = ok_arities (S n) s.
Proof.
simpl.
rewrite Hg, Hh.
simpl.
do 2 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).
intro H2.
contradict H2.
omega.
intros p H2.
case_eq (leb n p); intro H3.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H4 end.
do 4 rewrite <- beq_nat_refl.
simpl.
reflexivity.
rewrite forallb_forall_conv in H4.
destruct H4 as [e [H4 H5] ].
rewrite in_map_iff in H4.
destruct H4 as [q [H4 H6] ].
rewrite in_seq_iff in H6.
subst e.
simpl in H5.
case_eq (leb q (n + S s)); intro H7.
rewrite H7 in H5.
simpl in H5.
do 2 rewrite <- beq_nat_refl in H5.
discriminate H5.
rewrite leb_iff_conv in H7.
contradict H7.
omega.
rewrite leb_iff_conv in H3.
contradict H3.

*****
H2 : eq (Init.Nat.add n (S s)) (S p)
p : nat
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O))\n (map (proj (S n) O) (seq (S O) n))) true
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
g,h : BC
n,s : nat
*****
not (lt p n)
+++++
omega.
-----
Lemma rec1_arities n s g h (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec1 n s g h) = ok_arities (S n) s.
Proof.
simpl.
rewrite Hg, Hh.
simpl.
do 2 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).
intro H2.
contradict H2.
omega.
intros p H2.
case_eq (leb n p); intro H3.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H4 end.
do 4 rewrite <- beq_nat_refl.
simpl.
reflexivity.
rewrite forallb_forall_conv in H4.
destruct H4 as [e [H4 H5] ].
rewrite in_map_iff in H4.
destruct H4 as [q [H4 H6] ].
rewrite in_seq_iff in H6.
subst e.
simpl in H5.
case_eq (leb q (n + S s)); intro H7.
rewrite H7 in H5.
simpl in H5.
do 2 rewrite <- beq_nat_refl in H5.
discriminate H5.
rewrite leb_iff_conv in H7.
contradict H7.
omega.
rewrite leb_iff_conv in H3.
contradict H3.
omega.

*****
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O))\n (map (proj (S n) O) (seq (S O) n))) false
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
g,h : BC
n,s : nat
*****
eq match (if andb false (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) with | error_rec a a0 a1 => error_rec (ok_arities n s) (error_rec a a0 a1) (if andb false (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | error_comp a l l0 => error_rec (ok_arities n s) (error_comp a l l0) (if andb false (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | error_proj n0 n1 n2 => error_rec (ok_arities n s) (error_proj n0 n1 n2) (if andb false (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | ok_arities h0n h0s => match (if andb false (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) with | error_rec a a0 a1 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_rec a a0 a1) | error_comp a l l0 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_comp a l l0) | error_proj n0 n1 n2 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_proj n0 n1 n2) | ok_arities h1n h1s => if andb (andb (andb match h0n with | O => false | S m' => Nat.eqb n m' end (Nat.eqb h0n h1n)) match h0s with | O => false | S m' => Nat.eqb s m' end) (Nat.eqb h0s h1s) then ok_arities h0n s else error_rec (ok_arities n s) (ok_arities h0n h0s) (ok_arities h1n h1s) end end (ok_arities (S n) s)
+++++
rewrite forallb_forall_conv in H1.
-----
Lemma rec1_arities n s g h (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec1 n s g h) = ok_arities (S n) s.
Proof.
simpl.
rewrite Hg, Hh.
simpl.
do 2 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).
intro H2.
contradict H2.
omega.
intros p H2.
case_eq (leb n p); intro H3.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H4 end.
do 4 rewrite <- beq_nat_refl.
simpl.
reflexivity.
rewrite forallb_forall_conv in H4.
destruct H4 as [e [H4 H5] ].
rewrite in_map_iff in H4.
destruct H4 as [q [H4 H6] ].
rewrite in_seq_iff in H6.
subst e.
simpl in H5.
case_eq (leb q (n + S s)); intro H7.
rewrite H7 in H5.
simpl in H5.
do 2 rewrite <- beq_nat_refl in H5.
discriminate H5.
rewrite leb_iff_conv in H7.
contradict H7.
omega.
rewrite leb_iff_conv in H3.
contradict H3.
omega.
rewrite forallb_forall_conv in H1.

*****
H1 : ex\n (fun x : BC =>\n and (In x (map (proj (S n) O) (seq (S O) n)))\n (eq (aeq (arities x) (ok_arities (S n) O)) false))
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
g,h : BC
n,s : nat
*****
eq match (if andb false (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) with | error_rec a a0 a1 => error_rec (ok_arities n s) (error_rec a a0 a1) (if andb false (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | error_comp a l l0 => error_rec (ok_arities n s) (error_comp a l l0) (if andb false (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | error_proj n0 n1 n2 => error_rec (ok_arities n s) (error_proj n0 n1 n2) (if andb false (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | ok_arities h0n h0s => match (if andb false (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) with | error_rec a a0 a1 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_rec a a0 a1) | error_comp a l l0 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_comp a l l0) | error_proj n0 n1 n2 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_proj n0 n1 n2) | ok_arities h1n h1s => if andb (andb (andb match h0n with | O => false | S m' => Nat.eqb n m' end (Nat.eqb h0n h1n)) match h0s with | O => false | S m' => Nat.eqb s m' end) (Nat.eqb h0s h1s) then ok_arities h0n s else error_rec (ok_arities n s) (ok_arities h0n h0s) (ok_arities h1n h1s) end end (ok_arities (S n) s)
+++++
destruct H1 as [e [H1 H2] ].
-----
Lemma rec1_arities n s g h (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec1 n s g h) = ok_arities (S n) s.
Proof.
simpl.
rewrite Hg, Hh.
simpl.
do 2 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).
intro H2.
contradict H2.
omega.
intros p H2.
case_eq (leb n p); intro H3.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H4 end.
do 4 rewrite <- beq_nat_refl.
simpl.
reflexivity.
rewrite forallb_forall_conv in H4.
destruct H4 as [e [H4 H5] ].
rewrite in_map_iff in H4.
destruct H4 as [q [H4 H6] ].
rewrite in_seq_iff in H6.
subst e.
simpl in H5.
case_eq (leb q (n + S s)); intro H7.
rewrite H7 in H5.
simpl in H5.
do 2 rewrite <- beq_nat_refl in H5.
discriminate H5.
rewrite leb_iff_conv in H7.
contradict H7.
omega.
rewrite leb_iff_conv in H3.
contradict H3.
omega.
rewrite forallb_forall_conv in H1.
destruct H1 as [e [H1 H2] ].

*****
H2 : eq (aeq (arities e) (ok_arities (S n) O)) false
H1 : In e (map (proj (S n) O) (seq (S O) n))
e : BC
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
g,h : BC
n,s : nat
*****
eq match (if andb false (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) with | error_rec a a0 a1 => error_rec (ok_arities n s) (error_rec a a0 a1) (if andb false (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | error_comp a l l0 => error_rec (ok_arities n s) (error_comp a l l0) (if andb false (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | error_proj n0 n1 n2 => error_rec (ok_arities n s) (error_proj n0 n1 n2) (if andb false (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | ok_arities h0n h0s => match (if andb false (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) with | error_rec a a0 a1 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_rec a a0 a1) | error_comp a l l0 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_comp a l l0) | error_proj n0 n1 n2 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_proj n0 n1 n2) | ok_arities h1n h1s => if andb (andb (andb match h0n with | O => false | S m' => Nat.eqb n m' end (Nat.eqb h0n h1n)) match h0s with | O => false | S m' => Nat.eqb s m' end) (Nat.eqb h0s h1s) then ok_arities h0n s else error_rec (ok_arities n s) (ok_arities h0n h0s) (ok_arities h1n h1s) end end (ok_arities (S n) s)
+++++
rewrite in_map_iff in H1.
-----
Lemma rec1_arities n s g h (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec1 n s g h) = ok_arities (S n) s.
Proof.
simpl.
rewrite Hg, Hh.
simpl.
do 2 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).
intro H2.
contradict H2.
omega.
intros p H2.
case_eq (leb n p); intro H3.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H4 end.
do 4 rewrite <- beq_nat_refl.
simpl.
reflexivity.
rewrite forallb_forall_conv in H4.
destruct H4 as [e [H4 H5] ].
rewrite in_map_iff in H4.
destruct H4 as [q [H4 H6] ].
rewrite in_seq_iff in H6.
subst e.
simpl in H5.
case_eq (leb q (n + S s)); intro H7.
rewrite H7 in H5.
simpl in H5.
do 2 rewrite <- beq_nat_refl in H5.
discriminate H5.
rewrite leb_iff_conv in H7.
contradict H7.
omega.
rewrite leb_iff_conv in H3.
contradict H3.
omega.
rewrite forallb_forall_conv in H1.
destruct H1 as [e [H1 H2] ].
rewrite in_map_iff in H1.

*****
H2 : eq (aeq (arities e) (ok_arities (S n) O)) false
H1 : ex (fun x : nat => and (eq (proj (S n) O x) e) (In x (seq (S O) n)))
e : BC
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
g,h : BC
n,s : nat
*****
eq match (if andb false (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) with | error_rec a a0 a1 => error_rec (ok_arities n s) (error_rec a a0 a1) (if andb false (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | error_comp a l l0 => error_rec (ok_arities n s) (error_comp a l l0) (if andb false (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | error_proj n0 n1 n2 => error_rec (ok_arities n s) (error_proj n0 n1 n2) (if andb false (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | ok_arities h0n h0s => match (if andb false (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) with | error_rec a a0 a1 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_rec a a0 a1) | error_comp a l l0 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_comp a l l0) | error_proj n0 n1 n2 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_proj n0 n1 n2) | ok_arities h1n h1s => if andb (andb (andb match h0n with | O => false | S m' => Nat.eqb n m' end (Nat.eqb h0n h1n)) match h0s with | O => false | S m' => Nat.eqb s m' end) (Nat.eqb h0s h1s) then ok_arities h0n s else error_rec (ok_arities n s) (ok_arities h0n h0s) (ok_arities h1n h1s) end end (ok_arities (S n) s)
+++++
destruct H1 as [q [H1 H3] ].
-----
Lemma rec1_arities n s g h (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec1 n s g h) = ok_arities (S n) s.
Proof.
simpl.
rewrite Hg, Hh.
simpl.
do 2 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).
intro H2.
contradict H2.
omega.
intros p H2.
case_eq (leb n p); intro H3.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H4 end.
do 4 rewrite <- beq_nat_refl.
simpl.
reflexivity.
rewrite forallb_forall_conv in H4.
destruct H4 as [e [H4 H5] ].
rewrite in_map_iff in H4.
destruct H4 as [q [H4 H6] ].
rewrite in_seq_iff in H6.
subst e.
simpl in H5.
case_eq (leb q (n + S s)); intro H7.
rewrite H7 in H5.
simpl in H5.
do 2 rewrite <- beq_nat_refl in H5.
discriminate H5.
rewrite leb_iff_conv in H7.
contradict H7.
omega.
rewrite leb_iff_conv in H3.
contradict H3.
omega.
rewrite forallb_forall_conv in H1.
destruct H1 as [e [H1 H2] ].
rewrite in_map_iff in H1.
destruct H1 as [q [H1 H3] ].

*****
H2 : eq (aeq (arities e) (ok_arities (S n) O)) false
H3 : In q (seq (S O) n)
H1 : eq (proj (S n) O q) e
q : nat
e : BC
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
g,h : BC
n,s : nat
*****
eq match (if andb false (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) with | error_rec a a0 a1 => error_rec (ok_arities n s) (error_rec a a0 a1) (if andb false (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | error_comp a l l0 => error_rec (ok_arities n s) (error_comp a l l0) (if andb false (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | error_proj n0 n1 n2 => error_rec (ok_arities n s) (error_proj n0 n1 n2) (if andb false (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | ok_arities h0n h0s => match (if andb false (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) with | error_rec a a0 a1 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_rec a a0 a1) | error_comp a l l0 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_comp a l l0) | error_proj n0 n1 n2 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_proj n0 n1 n2) | ok_arities h1n h1s => if andb (andb (andb match h0n with | O => false | S m' => Nat.eqb n m' end (Nat.eqb h0n h1n)) match h0s with | O => false | S m' => Nat.eqb s m' end) (Nat.eqb h0s h1s) then ok_arities h0n s else error_rec (ok_arities n s) (ok_arities h0n h0s) (ok_arities h1n h1s) end end (ok_arities (S n) s)
+++++
rewrite in_seq_iff in H3.
-----
Lemma rec1_arities n s g h (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec1 n s g h) = ok_arities (S n) s.
Proof.
simpl.
rewrite Hg, Hh.
simpl.
do 2 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).
intro H2.
contradict H2.
omega.
intros p H2.
case_eq (leb n p); intro H3.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H4 end.
do 4 rewrite <- beq_nat_refl.
simpl.
reflexivity.
rewrite forallb_forall_conv in H4.
destruct H4 as [e [H4 H5] ].
rewrite in_map_iff in H4.
destruct H4 as [q [H4 H6] ].
rewrite in_seq_iff in H6.
subst e.
simpl in H5.
case_eq (leb q (n + S s)); intro H7.
rewrite H7 in H5.
simpl in H5.
do 2 rewrite <- beq_nat_refl in H5.
discriminate H5.
rewrite leb_iff_conv in H7.
contradict H7.
omega.
rewrite leb_iff_conv in H3.
contradict H3.
omega.
rewrite forallb_forall_conv in H1.
destruct H1 as [e [H1 H2] ].
rewrite in_map_iff in H1.
destruct H1 as [q [H1 H3] ].
rewrite in_seq_iff in H3.

*****
H2 : eq (aeq (arities e) (ok_arities (S n) O)) false
H3 : and (le (S O) q) (lt q (Init.Nat.add (S O) n))
H1 : eq (proj (S n) O q) e
q : nat
e : BC
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
g,h : BC
n,s : nat
*****
eq match (if andb false (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) with | error_rec a a0 a1 => error_rec (ok_arities n s) (error_rec a a0 a1) (if andb false (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | error_comp a l l0 => error_rec (ok_arities n s) (error_comp a l l0) (if andb false (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | error_proj n0 n1 n2 => error_rec (ok_arities n s) (error_proj n0 n1 n2) (if andb false (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | ok_arities h0n h0s => match (if andb false (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) with | error_rec a a0 a1 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_rec a a0 a1) | error_comp a l l0 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_comp a l l0) | error_proj n0 n1 n2 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_proj n0 n1 n2) | ok_arities h1n h1s => if andb (andb (andb match h0n with | O => false | S m' => Nat.eqb n m' end (Nat.eqb h0n h1n)) match h0s with | O => false | S m' => Nat.eqb s m' end) (Nat.eqb h0s h1s) then ok_arities h0n s else error_rec (ok_arities n s) (ok_arities h0n h0s) (ok_arities h1n h1s) end end (ok_arities (S n) s)
+++++
subst e.
-----
Lemma rec1_arities n s g h (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec1 n s g h) = ok_arities (S n) s.
Proof.
simpl.
rewrite Hg, Hh.
simpl.
do 2 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).
intro H2.
contradict H2.
omega.
intros p H2.
case_eq (leb n p); intro H3.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H4 end.
do 4 rewrite <- beq_nat_refl.
simpl.
reflexivity.
rewrite forallb_forall_conv in H4.
destruct H4 as [e [H4 H5] ].
rewrite in_map_iff in H4.
destruct H4 as [q [H4 H6] ].
rewrite in_seq_iff in H6.
subst e.
simpl in H5.
case_eq (leb q (n + S s)); intro H7.
rewrite H7 in H5.
simpl in H5.
do 2 rewrite <- beq_nat_refl in H5.
discriminate H5.
rewrite leb_iff_conv in H7.
contradict H7.
omega.
rewrite leb_iff_conv in H3.
contradict H3.
omega.
rewrite forallb_forall_conv in H1.
destruct H1 as [e [H1 H2] ].
rewrite in_map_iff in H1.
destruct H1 as [q [H1 H3] ].
rewrite in_seq_iff in H3.
subst e.

*****
H2 : eq (aeq (arities (proj (S n) O q)) (ok_arities (S n) O)) false
H3 : and (le (S O) q) (lt q (Init.Nat.add (S O) n))
q : nat
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
g,h : BC
n,s : nat
*****
eq match (if andb false (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) with | error_rec a a0 a1 => error_rec (ok_arities n s) (error_rec a a0 a1) (if andb false (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | error_comp a l l0 => error_rec (ok_arities n s) (error_comp a l l0) (if andb false (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | error_proj n0 n1 n2 => error_rec (ok_arities n s) (error_proj n0 n1 n2) (if andb false (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | ok_arities h0n h0s => match (if andb false (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) with | error_rec a a0 a1 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_rec a a0 a1) | error_comp a l l0 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_comp a l l0) | error_proj n0 n1 n2 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_proj n0 n1 n2) | ok_arities h1n h1s => if andb (andb (andb match h0n with | O => false | S m' => Nat.eqb n m' end (Nat.eqb h0n h1n)) match h0s with | O => false | S m' => Nat.eqb s m' end) (Nat.eqb h0s h1s) then ok_arities h0n s else error_rec (ok_arities n s) (ok_arities h0n h0s) (ok_arities h1n h1s) end end (ok_arities (S n) s)
+++++
simpl in H2.
-----
Lemma rec1_arities n s g h (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec1 n s g h) = ok_arities (S n) s.
Proof.
simpl.
rewrite Hg, Hh.
simpl.
do 2 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).
intro H2.
contradict H2.
omega.
intros p H2.
case_eq (leb n p); intro H3.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H4 end.
do 4 rewrite <- beq_nat_refl.
simpl.
reflexivity.
rewrite forallb_forall_conv in H4.
destruct H4 as [e [H4 H5] ].
rewrite in_map_iff in H4.
destruct H4 as [q [H4 H6] ].
rewrite in_seq_iff in H6.
subst e.
simpl in H5.
case_eq (leb q (n + S s)); intro H7.
rewrite H7 in H5.
simpl in H5.
do 2 rewrite <- beq_nat_refl in H5.
discriminate H5.
rewrite leb_iff_conv in H7.
contradict H7.
omega.
rewrite leb_iff_conv in H3.
contradict H3.
omega.
rewrite forallb_forall_conv in H1.
destruct H1 as [e [H1 H2] ].
rewrite in_map_iff in H1.
destruct H1 as [q [H1 H3] ].
rewrite in_seq_iff in H3.
subst e.
simpl in H2.

*****
H2 : eq\n (aeq\n (if Nat.leb q (Init.Nat.add n O)\n then ok_arities (S n) O\n else error_proj (S n) O q) (ok_arities (S n) O)) false
H3 : and (le (S O) q) (lt q (Init.Nat.add (S O) n))
q : nat
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
g,h : BC
n,s : nat
*****
eq match (if andb false (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) with | error_rec a a0 a1 => error_rec (ok_arities n s) (error_rec a a0 a1) (if andb false (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | error_comp a l l0 => error_rec (ok_arities n s) (error_comp a l l0) (if andb false (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | error_proj n0 n1 n2 => error_rec (ok_arities n s) (error_proj n0 n1 n2) (if andb false (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | ok_arities h0n h0s => match (if andb false (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) with | error_rec a a0 a1 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_rec a a0 a1) | error_comp a l l0 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_comp a l l0) | error_proj n0 n1 n2 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_proj n0 n1 n2) | ok_arities h1n h1s => if andb (andb (andb match h0n with | O => false | S m' => Nat.eqb n m' end (Nat.eqb h0n h1n)) match h0s with | O => false | S m' => Nat.eqb s m' end) (Nat.eqb h0s h1s) then ok_arities h0n s else error_rec (ok_arities n s) (ok_arities h0n h0s) (ok_arities h1n h1s) end end (ok_arities (S n) s)
+++++
case_eq (leb q (n+0)); intro H4.
-----
Lemma rec1_arities n s g h (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec1 n s g h) = ok_arities (S n) s.
Proof.
simpl.
rewrite Hg, Hh.
simpl.
do 2 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).
intro H2.
contradict H2.
omega.
intros p H2.
case_eq (leb n p); intro H3.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H4 end.
do 4 rewrite <- beq_nat_refl.
simpl.
reflexivity.
rewrite forallb_forall_conv in H4.
destruct H4 as [e [H4 H5] ].
rewrite in_map_iff in H4.
destruct H4 as [q [H4 H6] ].
rewrite in_seq_iff in H6.
subst e.
simpl in H5.
case_eq (leb q (n + S s)); intro H7.
rewrite H7 in H5.
simpl in H5.
do 2 rewrite <- beq_nat_refl in H5.
discriminate H5.
rewrite leb_iff_conv in H7.
contradict H7.
omega.
rewrite leb_iff_conv in H3.
contradict H3.
omega.
rewrite forallb_forall_conv in H1.
destruct H1 as [e [H1 H2] ].
rewrite in_map_iff in H1.
destruct H1 as [q [H1 H3] ].
rewrite in_seq_iff in H3.
subst e.
simpl in H2.
case_eq (leb q (n+0)); intro H4.

*****
H4 : eq (Nat.leb q (Init.Nat.add n O)) true
H2 : eq\n (aeq\n (if Nat.leb q (Init.Nat.add n O)\n then ok_arities (S n) O\n else error_proj (S n) O q) (ok_arities (S n) O)) false
H3 : and (le (S O) q) (lt q (Init.Nat.add (S O) n))
q : nat
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
g,h : BC
n,s : nat
*****
eq match (if andb false (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) with | error_rec a a0 a1 => error_rec (ok_arities n s) (error_rec a a0 a1) (if andb false (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | error_comp a l l0 => error_rec (ok_arities n s) (error_comp a l l0) (if andb false (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | error_proj n0 n1 n2 => error_rec (ok_arities n s) (error_proj n0 n1 n2) (if andb false (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | ok_arities h0n h0s => match (if andb false (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) with | error_rec a a0 a1 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_rec a a0 a1) | error_comp a l l0 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_comp a l l0) | error_proj n0 n1 n2 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_proj n0 n1 n2) | ok_arities h1n h1s => if andb (andb (andb match h0n with | O => false | S m' => Nat.eqb n m' end (Nat.eqb h0n h1n)) match h0s with | O => false | S m' => Nat.eqb s m' end) (Nat.eqb h0s h1s) then ok_arities h0n s else error_rec (ok_arities n s) (ok_arities h0n h0s) (ok_arities h1n h1s) end end (ok_arities (S n) s)
+++++
rewrite H4 in H2.
-----
Lemma rec1_arities n s g h (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec1 n s g h) = ok_arities (S n) s.
Proof.
simpl.
rewrite Hg, Hh.
simpl.
do 2 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).
intro H2.
contradict H2.
omega.
intros p H2.
case_eq (leb n p); intro H3.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H4 end.
do 4 rewrite <- beq_nat_refl.
simpl.
reflexivity.
rewrite forallb_forall_conv in H4.
destruct H4 as [e [H4 H5] ].
rewrite in_map_iff in H4.
destruct H4 as [q [H4 H6] ].
rewrite in_seq_iff in H6.
subst e.
simpl in H5.
case_eq (leb q (n + S s)); intro H7.
rewrite H7 in H5.
simpl in H5.
do 2 rewrite <- beq_nat_refl in H5.
discriminate H5.
rewrite leb_iff_conv in H7.
contradict H7.
omega.
rewrite leb_iff_conv in H3.
contradict H3.
omega.
rewrite forallb_forall_conv in H1.
destruct H1 as [e [H1 H2] ].
rewrite in_map_iff in H1.
destruct H1 as [q [H1 H3] ].
rewrite in_seq_iff in H3.
subst e.
simpl in H2.
case_eq (leb q (n+0)); intro H4.
rewrite H4 in H2.

*****
H4 : eq (Nat.leb q (Init.Nat.add n O)) true
H2 : eq (aeq (ok_arities (S n) O) (ok_arities (S n) O)) false
H3 : and (le (S O) q) (lt q (Init.Nat.add (S O) n))
q : nat
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
g,h : BC
n,s : nat
*****
eq match (if andb false (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) with | error_rec a a0 a1 => error_rec (ok_arities n s) (error_rec a a0 a1) (if andb false (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | error_comp a l l0 => error_rec (ok_arities n s) (error_comp a l l0) (if andb false (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | error_proj n0 n1 n2 => error_rec (ok_arities n s) (error_proj n0 n1 n2) (if andb false (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | ok_arities h0n h0s => match (if andb false (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) with | error_rec a a0 a1 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_rec a a0 a1) | error_comp a l l0 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_comp a l l0) | error_proj n0 n1 n2 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_proj n0 n1 n2) | ok_arities h1n h1s => if andb (andb (andb match h0n with | O => false | S m' => Nat.eqb n m' end (Nat.eqb h0n h1n)) match h0s with | O => false | S m' => Nat.eqb s m' end) (Nat.eqb h0s h1s) then ok_arities h0n s else error_rec (ok_arities n s) (ok_arities h0n h0s) (ok_arities h1n h1s) end end (ok_arities (S n) s)
+++++
simpl in H2.
-----
Lemma rec1_arities n s g h (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec1 n s g h) = ok_arities (S n) s.
Proof.
simpl.
rewrite Hg, Hh.
simpl.
do 2 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).
intro H2.
contradict H2.
omega.
intros p H2.
case_eq (leb n p); intro H3.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H4 end.
do 4 rewrite <- beq_nat_refl.
simpl.
reflexivity.
rewrite forallb_forall_conv in H4.
destruct H4 as [e [H4 H5] ].
rewrite in_map_iff in H4.
destruct H4 as [q [H4 H6] ].
rewrite in_seq_iff in H6.
subst e.
simpl in H5.
case_eq (leb q (n + S s)); intro H7.
rewrite H7 in H5.
simpl in H5.
do 2 rewrite <- beq_nat_refl in H5.
discriminate H5.
rewrite leb_iff_conv in H7.
contradict H7.
omega.
rewrite leb_iff_conv in H3.
contradict H3.
omega.
rewrite forallb_forall_conv in H1.
destruct H1 as [e [H1 H2] ].
rewrite in_map_iff in H1.
destruct H1 as [q [H1 H3] ].
rewrite in_seq_iff in H3.
subst e.
simpl in H2.
case_eq (leb q (n+0)); intro H4.
rewrite H4 in H2.
simpl in H2.

*****
H4 : eq (Nat.leb q (Init.Nat.add n O)) true
H2 : eq (andb (Nat.eqb n n) true) false
H3 : and (le (S O) q) (lt q (Init.Nat.add (S O) n))
q : nat
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
g,h : BC
n,s : nat
*****
eq match (if andb false (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) with | error_rec a a0 a1 => error_rec (ok_arities n s) (error_rec a a0 a1) (if andb false (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | error_comp a l l0 => error_rec (ok_arities n s) (error_comp a l l0) (if andb false (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | error_proj n0 n1 n2 => error_rec (ok_arities n s) (error_proj n0 n1 n2) (if andb false (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | ok_arities h0n h0s => match (if andb false (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) with | error_rec a a0 a1 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_rec a a0 a1) | error_comp a l l0 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_comp a l l0) | error_proj n0 n1 n2 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_proj n0 n1 n2) | ok_arities h1n h1s => if andb (andb (andb match h0n with | O => false | S m' => Nat.eqb n m' end (Nat.eqb h0n h1n)) match h0s with | O => false | S m' => Nat.eqb s m' end) (Nat.eqb h0s h1s) then ok_arities h0n s else error_rec (ok_arities n s) (ok_arities h0n h0s) (ok_arities h1n h1s) end end (ok_arities (S n) s)
+++++
rewrite <- beq_nat_refl in H2.
-----
Lemma rec1_arities n s g h (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec1 n s g h) = ok_arities (S n) s.
Proof.
simpl.
rewrite Hg, Hh.
simpl.
do 2 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).
intro H2.
contradict H2.
omega.
intros p H2.
case_eq (leb n p); intro H3.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H4 end.
do 4 rewrite <- beq_nat_refl.
simpl.
reflexivity.
rewrite forallb_forall_conv in H4.
destruct H4 as [e [H4 H5] ].
rewrite in_map_iff in H4.
destruct H4 as [q [H4 H6] ].
rewrite in_seq_iff in H6.
subst e.
simpl in H5.
case_eq (leb q (n + S s)); intro H7.
rewrite H7 in H5.
simpl in H5.
do 2 rewrite <- beq_nat_refl in H5.
discriminate H5.
rewrite leb_iff_conv in H7.
contradict H7.
omega.
rewrite leb_iff_conv in H3.
contradict H3.
omega.
rewrite forallb_forall_conv in H1.
destruct H1 as [e [H1 H2] ].
rewrite in_map_iff in H1.
destruct H1 as [q [H1 H3] ].
rewrite in_seq_iff in H3.
subst e.
simpl in H2.
case_eq (leb q (n+0)); intro H4.
rewrite H4 in H2.
simpl in H2.
rewrite <- beq_nat_refl in H2.

*****
H4 : eq (Nat.leb q (Init.Nat.add n O)) true
H2 : eq (andb true true) false
H3 : and (le (S O) q) (lt q (Init.Nat.add (S O) n))
q : nat
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
g,h : BC
n,s : nat
*****
eq match (if andb false (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) with | error_rec a a0 a1 => error_rec (ok_arities n s) (error_rec a a0 a1) (if andb false (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | error_comp a l l0 => error_rec (ok_arities n s) (error_comp a l l0) (if andb false (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | error_proj n0 n1 n2 => error_rec (ok_arities n s) (error_proj n0 n1 n2) (if andb false (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | ok_arities h0n h0s => match (if andb false (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) with | error_rec a a0 a1 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_rec a a0 a1) | error_comp a l l0 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_comp a l l0) | error_proj n0 n1 n2 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_proj n0 n1 n2) | ok_arities h1n h1s => if andb (andb (andb match h0n with | O => false | S m' => Nat.eqb n m' end (Nat.eqb h0n h1n)) match h0s with | O => false | S m' => Nat.eqb s m' end) (Nat.eqb h0s h1s) then ok_arities h0n s else error_rec (ok_arities n s) (ok_arities h0n h0s) (ok_arities h1n h1s) end end (ok_arities (S n) s)
+++++
discriminate H2.
-----
Lemma rec1_arities n s g h (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec1 n s g h) = ok_arities (S n) s.
Proof.
simpl.
rewrite Hg, Hh.
simpl.
do 2 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).
intro H2.
contradict H2.
omega.
intros p H2.
case_eq (leb n p); intro H3.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H4 end.
do 4 rewrite <- beq_nat_refl.
simpl.
reflexivity.
rewrite forallb_forall_conv in H4.
destruct H4 as [e [H4 H5] ].
rewrite in_map_iff in H4.
destruct H4 as [q [H4 H6] ].
rewrite in_seq_iff in H6.
subst e.
simpl in H5.
case_eq (leb q (n + S s)); intro H7.
rewrite H7 in H5.
simpl in H5.
do 2 rewrite <- beq_nat_refl in H5.
discriminate H5.
rewrite leb_iff_conv in H7.
contradict H7.
omega.
rewrite leb_iff_conv in H3.
contradict H3.
omega.
rewrite forallb_forall_conv in H1.
destruct H1 as [e [H1 H2] ].
rewrite in_map_iff in H1.
destruct H1 as [q [H1 H3] ].
rewrite in_seq_iff in H3.
subst e.
simpl in H2.
case_eq (leb q (n+0)); intro H4.
rewrite H4 in H2.
simpl in H2.
rewrite <- beq_nat_refl in H2.
discriminate H2.

*****
H4 : eq (Nat.leb q (Init.Nat.add n O)) false
H2 : eq\n (aeq\n (if Nat.leb q (Init.Nat.add n O)\n then ok_arities (S n) O\n else error_proj (S n) O q) (ok_arities (S n) O)) false
H3 : and (le (S O) q) (lt q (Init.Nat.add (S O) n))
q : nat
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
g,h : BC
n,s : nat
*****
eq match (if andb false (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) with | error_rec a a0 a1 => error_rec (ok_arities n s) (error_rec a a0 a1) (if andb false (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | error_comp a l l0 => error_rec (ok_arities n s) (error_comp a l l0) (if andb false (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | error_proj n0 n1 n2 => error_rec (ok_arities n s) (error_proj n0 n1 n2) (if andb false (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | ok_arities h0n h0s => match (if andb false (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) with | error_rec a a0 a1 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_rec a a0 a1) | error_comp a l l0 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_comp a l l0) | error_proj n0 n1 n2 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_proj n0 n1 n2) | ok_arities h1n h1s => if andb (andb (andb match h0n with | O => false | S m' => Nat.eqb n m' end (Nat.eqb h0n h1n)) match h0s with | O => false | S m' => Nat.eqb s m' end) (Nat.eqb h0s h1s) then ok_arities h0n s else error_rec (ok_arities n s) (ok_arities h0n h0s) (ok_arities h1n h1s) end end (ok_arities (S n) s)
+++++
rewrite leb_iff_conv in H4.
-----
Lemma rec1_arities n s g h (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec1 n s g h) = ok_arities (S n) s.
Proof.
simpl.
rewrite Hg, Hh.
simpl.
do 2 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).
intro H2.
contradict H2.
omega.
intros p H2.
case_eq (leb n p); intro H3.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H4 end.
do 4 rewrite <- beq_nat_refl.
simpl.
reflexivity.
rewrite forallb_forall_conv in H4.
destruct H4 as [e [H4 H5] ].
rewrite in_map_iff in H4.
destruct H4 as [q [H4 H6] ].
rewrite in_seq_iff in H6.
subst e.
simpl in H5.
case_eq (leb q (n + S s)); intro H7.
rewrite H7 in H5.
simpl in H5.
do 2 rewrite <- beq_nat_refl in H5.
discriminate H5.
rewrite leb_iff_conv in H7.
contradict H7.
omega.
rewrite leb_iff_conv in H3.
contradict H3.
omega.
rewrite forallb_forall_conv in H1.
destruct H1 as [e [H1 H2] ].
rewrite in_map_iff in H1.
destruct H1 as [q [H1 H3] ].
rewrite in_seq_iff in H3.
subst e.
simpl in H2.
case_eq (leb q (n+0)); intro H4.
rewrite H4 in H2.
simpl in H2.
rewrite <- beq_nat_refl in H2.
discriminate H2.
rewrite leb_iff_conv in H4.

*****
H4 : lt (Init.Nat.add n O) q
H2 : eq\n (aeq\n (if Nat.leb q (Init.Nat.add n O)\n then ok_arities (S n) O\n else error_proj (S n) O q) (ok_arities (S n) O)) false
H3 : and (le (S O) q) (lt q (Init.Nat.add (S O) n))
q : nat
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
g,h : BC
n,s : nat
*****
eq match (if andb false (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) with | error_rec a a0 a1 => error_rec (ok_arities n s) (error_rec a a0 a1) (if andb false (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | error_comp a l l0 => error_rec (ok_arities n s) (error_comp a l l0) (if andb false (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | error_proj n0 n1 n2 => error_rec (ok_arities n s) (error_proj n0 n1 n2) (if andb false (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | ok_arities h0n h0s => match (if andb false (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) with | error_rec a a0 a1 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_rec a a0 a1) | error_comp a l l0 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_comp a l l0) | error_proj n0 n1 n2 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_proj n0 n1 n2) | ok_arities h1n h1s => if andb (andb (andb match h0n with | O => false | S m' => Nat.eqb n m' end (Nat.eqb h0n h1n)) match h0s with | O => false | S m' => Nat.eqb s m' end) (Nat.eqb h0s h1s) then ok_arities h0n s else error_rec (ok_arities n s) (ok_arities h0n h0s) (ok_arities h1n h1s) end end (ok_arities (S n) s)
+++++
contradict H4.
-----
Lemma rec1_arities n s g h (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec1 n s g h) = ok_arities (S n) s.
Proof.
simpl.
rewrite Hg, Hh.
simpl.
do 2 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).
intro H2.
contradict H2.
omega.
intros p H2.
case_eq (leb n p); intro H3.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H4 end.
do 4 rewrite <- beq_nat_refl.
simpl.
reflexivity.
rewrite forallb_forall_conv in H4.
destruct H4 as [e [H4 H5] ].
rewrite in_map_iff in H4.
destruct H4 as [q [H4 H6] ].
rewrite in_seq_iff in H6.
subst e.
simpl in H5.
case_eq (leb q (n + S s)); intro H7.
rewrite H7 in H5.
simpl in H5.
do 2 rewrite <- beq_nat_refl in H5.
discriminate H5.
rewrite leb_iff_conv in H7.
contradict H7.
omega.
rewrite leb_iff_conv in H3.
contradict H3.
omega.
rewrite forallb_forall_conv in H1.
destruct H1 as [e [H1 H2] ].
rewrite in_map_iff in H1.
destruct H1 as [q [H1 H3] ].
rewrite in_seq_iff in H3.
subst e.
simpl in H2.
case_eq (leb q (n+0)); intro H4.
rewrite H4 in H2.
simpl in H2.
rewrite <- beq_nat_refl in H2.
discriminate H2.
rewrite leb_iff_conv in H4.
contradict H4.

*****
H2 : eq\n (aeq\n (if Nat.leb q (Init.Nat.add n O)\n then ok_arities (S n) O\n else error_proj (S n) O q) (ok_arities (S n) O)) false
H3 : and (le (S O) q) (lt q (Init.Nat.add (S O) n))
q : nat
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
g,h : BC
n,s : nat
*****
not (lt (Init.Nat.add n O) q)
+++++
omega.
-----
Lemma rec1_arities n s g h (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec1 n s g h) = ok_arities (S n) s.
Proof.
simpl.
rewrite Hg, Hh.
simpl.
do 2 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).
intro H2.
contradict H2.
omega.
intros p H2.
case_eq (leb n p); intro H3.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H4 end.
do 4 rewrite <- beq_nat_refl.
simpl.
reflexivity.
rewrite forallb_forall_conv in H4.
destruct H4 as [e [H4 H5] ].
rewrite in_map_iff in H4.
destruct H4 as [q [H4 H6] ].
rewrite in_seq_iff in H6.
subst e.
simpl in H5.
case_eq (leb q (n + S s)); intro H7.
rewrite H7 in H5.
simpl in H5.
do 2 rewrite <- beq_nat_refl in H5.
discriminate H5.
rewrite leb_iff_conv in H7.
contradict H7.
omega.
rewrite leb_iff_conv in H3.
contradict H3.
omega.
rewrite forallb_forall_conv in H1.
destruct H1 as [e [H1 H2] ].
rewrite in_map_iff in H1.
destruct H1 as [q [H1 H3] ].
rewrite in_seq_iff in H3.
subst e.
simpl in H2.
case_eq (leb q (n+0)); intro H4.
rewrite H4 in H2.
simpl in H2.
rewrite <- beq_nat_refl in H2.
discriminate H2.
rewrite leb_iff_conv in H4.
contradict H4.
omega.

*****

*****

+++++
Qed.
-----
Fixpoint sem_rec1\n  (g h:BC)(v : bs)(vnl vsl : list bs) {struct v} :=\n  match v with\n    | nil => sem g vnl vsl\n    | _::v' => sem h (v::vnl) (sem_rec1 g h v' vnl vsl :: vsl)\n  end.
-----
Lemma rec1_correct n s g h vnl vsl :\n  length vnl = S n ->\n  length vsl = s ->\n  sem (rec1 n s g h) vnl vsl =\n  sem_rec1 g h (hd nil vnl) (tl vnl) vsl.
-----
Lemma rec1_correct n s g h vnl vsl : length vnl = S n -> length vsl = s -> sem (rec1 n s g h) vnl vsl = sem_rec1 g h (hd nil vnl) (tl vnl) vsl.

*****
vnl,vsl : list (list bool)
g,h : BC
n,s : nat
*****
forall (_ : eq (length vnl) (S n)) (_ : eq (length vsl) s), eq (sem (rec1 n s g h) vnl vsl) (sem_rec1 g h (hd nil vnl) (tl vnl) vsl)
+++++
Proof.
-----
Lemma rec1_correct n s g h vnl vsl : length vnl = S n -> length vsl = s -> sem (rec1 n s g h) vnl vsl = sem_rec1 g h (hd nil vnl) (tl vnl) vsl.
Proof.

*****
vnl,vsl : list (list bool)
g,h : BC
n,s : nat
*****
forall (_ : eq (length vnl) (S n)) (_ : eq (length vsl) s), eq (sem (rec1 n s g h) vnl vsl) (sem_rec1 g h (hd nil vnl) (tl vnl) vsl)
+++++
intros Hn Hs.
-----
Lemma rec1_correct n s g h vnl vsl : length vnl = S n -> length vsl = s -> sem (rec1 n s g h) vnl vsl = sem_rec1 g h (hd nil vnl) (tl vnl) vsl.
Proof.
intros Hn Hs.

*****
Hs : eq (length vsl) s
Hn : eq (length vnl) (S n)
vnl,vsl : list (list bool)
g,h : BC
n,s : nat
*****
eq (sem (rec1 n s g h) vnl vsl) (sem_rec1 g h (hd nil vnl) (tl vnl) vsl)
+++++
destruct vnl as [ | v vnl].
-----
Lemma rec1_correct n s g h vnl vsl : length vnl = S n -> length vsl = s -> sem (rec1 n s g h) vnl vsl = sem_rec1 g h (hd nil vnl) (tl vnl) vsl.
Proof.
intros Hn Hs.
destruct vnl as [ | v vnl].

*****
Hs : eq (length vsl) s
Hn : eq (length nil) (S n)
vsl : list (list bool)
g,h : BC
n,s : nat
*****
eq (sem (rec1 n s g h) nil vsl) (sem_rec1 g h (hd nil nil) (tl nil) vsl)
+++++
reflexivity.
-----
Lemma rec1_correct n s g h vnl vsl : length vnl = S n -> length vsl = s -> sem (rec1 n s g h) vnl vsl = sem_rec1 g h (hd nil vnl) (tl vnl) vsl.
Proof.
intros Hn Hs.
destruct vnl as [ | v vnl].

*****
Hs : eq (length vsl) s
Hn : eq (length (cons v vnl)) (S n)
vnl,vsl : list (list bool)
v : list bool
g,h : BC
n,s : nat
*****
eq (sem (rec1 n s g h) (cons v vnl) vsl) (sem_rec1 g h (hd nil (cons v vnl)) (tl (cons v vnl)) vsl)
+++++
simpl in Hn.
-----
Lemma rec1_correct n s g h vnl vsl : length vnl = S n -> length vsl = s -> sem (rec1 n s g h) vnl vsl = sem_rec1 g h (hd nil vnl) (tl vnl) vsl.
Proof.
intros Hn Hs.
destruct vnl as [ | v vnl].
simpl in Hn.

*****
Hs : eq (length vsl) s
Hn : eq (S (length vnl)) (S n)
vnl,vsl : list (list bool)
v : list bool
g,h : BC
n,s : nat
*****
eq (sem (rec1 n s g h) (cons v vnl) vsl) (sem_rec1 g h (hd nil (cons v vnl)) (tl (cons v vnl)) vsl)
+++++
induction v as [ | b v IH].
-----
Lemma rec1_correct n s g h vnl vsl : length vnl = S n -> length vsl = s -> sem (rec1 n s g h) vnl vsl = sem_rec1 g h (hd nil vnl) (tl vnl) vsl.
Proof.
intros Hn Hs.
destruct vnl as [ | v vnl].
simpl in Hn.
induction v as [ | b v IH].

*****
Hs : eq (length vsl) s
Hn : eq (S (length vnl)) (S n)
vnl,vsl : list (list bool)
g,h : BC
n,s : nat
*****
eq (sem (rec1 n s g h) (cons nil vnl) vsl) (sem_rec1 g h (hd nil (cons nil vnl)) (tl (cons nil vnl)) vsl)
+++++
reflexivity.
-----
Lemma rec1_correct n s g h vnl vsl : length vnl = S n -> length vsl = s -> sem (rec1 n s g h) vnl vsl = sem_rec1 g h (hd nil vnl) (tl vnl) vsl.
Proof.
intros Hn Hs.
destruct vnl as [ | v vnl].
simpl in Hn.
induction v as [ | b v IH].

*****
IH : eq (sem (rec1 n s g h) (cons v vnl) vsl)\n (sem_rec1 g h (hd nil (cons v vnl)) (tl (cons v vnl)) vsl)
Hs : eq (length vsl) s
Hn : eq (S (length vnl)) (S n)
vnl,vsl : list (list bool)
v : list bool
b : bool
g,h : BC
n,s : nat
*****
eq (sem (rec1 n s g h) (cons (cons b v) vnl) vsl) (sem_rec1 g h (hd nil (cons (cons b v) vnl)) (tl (cons (cons b v) vnl)) vsl)
+++++
simpl sem_rec1.
-----
Lemma rec1_correct n s g h vnl vsl : length vnl = S n -> length vsl = s -> sem (rec1 n s g h) vnl vsl = sem_rec1 g h (hd nil vnl) (tl vnl) vsl.
Proof.
intros Hn Hs.
destruct vnl as [ | v vnl].
simpl in Hn.
induction v as [ | b v IH].
simpl sem_rec1.

*****
IH : eq (sem (rec1 n s g h) (cons v vnl) vsl)\n (sem_rec1 g h (hd nil (cons v vnl)) (tl (cons v vnl)) vsl)
Hs : eq (length vsl) s
Hn : eq (S (length vnl)) (S n)
vnl,vsl : list (list bool)
v : list bool
b : bool
g,h : BC
n,s : nat
*****
eq (sem (rec1 n s g h) (cons (cons b v) vnl) vsl) (sem h (cons (cons b v) vnl) (cons (sem_rec1 g h v vnl vsl) vsl))
+++++
simpl hd in IH.
-----
Lemma rec1_correct n s g h vnl vsl : length vnl = S n -> length vsl = s -> sem (rec1 n s g h) vnl vsl = sem_rec1 g h (hd nil vnl) (tl vnl) vsl.
Proof.
intros Hn Hs.
destruct vnl as [ | v vnl].
simpl in Hn.
induction v as [ | b v IH].
simpl sem_rec1.
simpl hd in IH.

*****
IH : eq (sem (rec1 n s g h) (cons v vnl) vsl)\n (sem_rec1 g h v (tl (cons v vnl)) vsl)
Hs : eq (length vsl) s
Hn : eq (S (length vnl)) (S n)
vnl,vsl : list (list bool)
v : list bool
b : bool
g,h : BC
n,s : nat
*****
eq (sem (rec1 n s g h) (cons (cons b v) vnl) vsl) (sem h (cons (cons b v) vnl) (cons (sem_rec1 g h v vnl vsl) vsl))
+++++
simpl tl in IH.
-----
Lemma rec1_correct n s g h vnl vsl : length vnl = S n -> length vsl = s -> sem (rec1 n s g h) vnl vsl = sem_rec1 g h (hd nil vnl) (tl vnl) vsl.
Proof.
intros Hn Hs.
destruct vnl as [ | v vnl].
simpl in Hn.
induction v as [ | b v IH].
simpl sem_rec1.
simpl hd in IH.
simpl tl in IH.

*****
IH : eq (sem (rec1 n s g h) (cons v vnl) vsl) (sem_rec1 g h v vnl vsl)
Hs : eq (length vsl) s
Hn : eq (S (length vnl)) (S n)
vnl,vsl : list (list bool)
v : list bool
b : bool
g,h : BC
n,s : nat
*****
eq (sem (rec1 n s g h) (cons (cons b v) vnl) vsl) (sem h (cons (cons b v) vnl) (cons (sem_rec1 g h v vnl vsl) vsl))
+++++
rewrite <- IH.
-----
Lemma rec1_correct n s g h vnl vsl : length vnl = S n -> length vsl = s -> sem (rec1 n s g h) vnl vsl = sem_rec1 g h (hd nil vnl) (tl vnl) vsl.
Proof.
intros Hn Hs.
destruct vnl as [ | v vnl].
simpl in Hn.
induction v as [ | b v IH].
simpl sem_rec1.
simpl hd in IH.
simpl tl in IH.
rewrite <- IH.

*****
IH : eq (sem (rec1 n s g h) (cons v vnl) vsl) (sem_rec1 g h v vnl vsl)
Hs : eq (length vsl) s
Hn : eq (S (length vnl)) (S n)
vnl,vsl : list (list bool)
v : list bool
b : bool
g,h : BC
n,s : nat
*****
eq (sem (rec1 n s g h) (cons (cons b v) vnl) vsl) (sem h (cons (cons b v) vnl) (cons (sem (rec1 n s g h) (cons v vnl) vsl) vsl))
+++++
clear IH.
-----
Lemma rec1_correct n s g h vnl vsl : length vnl = S n -> length vsl = s -> sem (rec1 n s g h) vnl vsl = sem_rec1 g h (hd nil vnl) (tl vnl) vsl.
Proof.
intros Hn Hs.
destruct vnl as [ | v vnl].
simpl in Hn.
induction v as [ | b v IH].
simpl sem_rec1.
simpl hd in IH.
simpl tl in IH.
rewrite <- IH.
clear IH.

*****
Hs : eq (length vsl) s
Hn : eq (S (length vnl)) (S n)
vnl,vsl : list (list bool)
v : list bool
b : bool
g,h : BC
n,s : nat
*****
eq (sem (rec1 n s g h) (cons (cons b v) vnl) vsl) (sem h (cons (cons b v) vnl) (cons (sem (rec1 n s g h) (cons v vnl) vsl) vsl))
+++++
unfold rec1.
-----
Lemma rec1_correct n s g h vnl vsl : length vnl = S n -> length vsl = s -> sem (rec1 n s g h) vnl vsl = sem_rec1 g h (hd nil vnl) (tl vnl) vsl.
Proof.
intros Hn Hs.
destruct vnl as [ | v vnl].
simpl in Hn.
induction v as [ | b v IH].
simpl sem_rec1.
simpl hd in IH.
simpl tl in IH.
rewrite <- IH.
clear IH.
unfold rec1.

*****
Hs : eq (length vsl) s
Hn : eq (S (length vnl)) (S n)
vnl,vsl : list (list bool)
v : list bool
b : bool
g,h : BC
n,s : nat
*****
eq (sem (rec g (comp (S n) (S s) h (cons (comp (S n) O (succ false) nil (cons (proj (S n) O O) nil)) (map (proj (S n) O) (seq (S O) n))) (map (proj (S n) (S s)) (seq (S n) (S s)))) (comp (S n) (S s) h (cons (comp (S n) O (succ true) nil (cons (proj (S n) O O) nil)) (map (proj (S n) O) (seq (S O) n))) (map (proj (S n) (S s)) (seq (S n) (S s))))) (cons (cons b v) vnl) vsl) (sem h (cons (cons b v) vnl) (cons (sem (rec g (comp (S n) (S s) h (cons (comp (S n) O (succ false) nil (cons (proj (S n) O O) nil)) (map (proj (S n) O) (seq (S O) n))) (map (proj (S n) (S s)) (seq (S n) (S s)))) (comp (S n) (S s) h (cons (comp (S n) O (succ true) nil (cons (proj (S n) O O) nil)) (map (proj (S n) O) (seq (S O) n))) (map (proj (S n) (S s)) (seq (S n) (S s))))) (cons v vnl) vsl) vsl))
+++++
case b.
-----
Lemma rec1_correct n s g h vnl vsl : length vnl = S n -> length vsl = s -> sem (rec1 n s g h) vnl vsl = sem_rec1 g h (hd nil vnl) (tl vnl) vsl.
Proof.
intros Hn Hs.
destruct vnl as [ | v vnl].
simpl in Hn.
induction v as [ | b v IH].
simpl sem_rec1.
simpl hd in IH.
simpl tl in IH.
rewrite <- IH.
clear IH.
unfold rec1.
case b.

*****
Hs : eq (length vsl) s
Hn : eq (S (length vnl)) (S n)
vnl,vsl : list (list bool)
v : list bool
b : bool
g,h : BC
n,s : nat
*****
eq (sem (rec g (comp (S n) (S s) h (cons (comp (S n) O (succ false) nil (cons (proj (S n) O O) nil)) (map (proj (S n) O) (seq (S O) n))) (map (proj (S n) (S s)) (seq (S n) (S s)))) (comp (S n) (S s) h (cons (comp (S n) O (succ true) nil (cons (proj (S n) O O) nil)) (map (proj (S n) O) (seq (S O) n))) (map (proj (S n) (S s)) (seq (S n) (S s))))) (cons (cons true v) vnl) vsl) (sem h (cons (cons true v) vnl) (cons (sem (rec g (comp (S n) (S s) h (cons (comp (S n) O (succ false) nil (cons (proj (S n) O O) nil)) (map (proj (S n) O) (seq (S O) n))) (map (proj (S n) (S s)) (seq (S n) (S s)))) (comp (S n) (S s) h (cons (comp (S n) O (succ true) nil (cons (proj (S n) O O) nil)) (map (proj (S n) O) (seq (S O) n))) (map (proj (S n) (S s)) (seq (S n) (S s))))) (cons v vnl) vsl) vsl))
+++++
rewrite sem_rec_true.
-----
Lemma rec1_correct n s g h vnl vsl : length vnl = S n -> length vsl = s -> sem (rec1 n s g h) vnl vsl = sem_rec1 g h (hd nil vnl) (tl vnl) vsl.
Proof.
intros Hn Hs.
destruct vnl as [ | v vnl].
simpl in Hn.
induction v as [ | b v IH].
simpl sem_rec1.
simpl hd in IH.
simpl tl in IH.
rewrite <- IH.
clear IH.
unfold rec1.
case b.
rewrite sem_rec_true.

*****
Hs : eq (length vsl) s
Hn : eq (S (length vnl)) (S n)
vnl,vsl : list (list bool)
v : list bool
b : bool
g,h : BC
n,s : nat
*****
eq (sem (comp (S n) (S s) h (cons (comp (S n) O (succ true) nil (cons (proj (S n) O O) nil)) (map (proj (S n) O) (seq (S O) n))) (map (proj (S n) (S s)) (seq (S n) (S s)))) (cons v vnl) (cons (sem (rec g (comp (S n) (S s) h (cons (comp (S n) O (succ false) nil (cons (proj (S n) O O) nil)) (map (proj (S n) O) (seq (S O) n))) (map (proj (S n) (S s)) (seq (S n) (S s)))) (comp (S n) (S s) h (cons (comp (S n) O (succ true) nil (cons (proj (S n) O O) nil)) (map (proj (S n) O) (seq (S O) n))) (map (proj (S n) (S s)) (seq (S n) (S s))))) (cons v vnl) vsl) vsl)) (sem h (cons (cons true v) vnl) (cons (sem (rec g (comp (S n) (S s) h (cons (comp (S n) O (succ false) nil (cons (proj (S n) O O) nil)) (map (proj (S n) O) (seq (S O) n))) (map (proj (S n) (S s)) (seq (S n) (S s)))) (comp (S n) (S s) h (cons (comp (S n) O (succ true) nil (cons (proj (S n) O O) nil)) (map (proj (S n) O) (seq (S O) n))) (map (proj (S n) (S s)) (seq (S n) (S s))))) (cons v vnl) vsl) vsl))
+++++
match goal with | |- context [sem (rec ?g ?h0 ?h1) ?vnl ?vsl] => set (e0 := sem (rec g h0 h1) vnl vsl) end.
-----
Lemma rec1_correct n s g h vnl vsl : length vnl = S n -> length vsl = s -> sem (rec1 n s g h) vnl vsl = sem_rec1 g h (hd nil vnl) (tl vnl) vsl.
Proof.
intros Hn Hs.
destruct vnl as [ | v vnl].
simpl in Hn.
induction v as [ | b v IH].
simpl sem_rec1.
simpl hd in IH.
simpl tl in IH.
rewrite <- IH.
clear IH.
unfold rec1.
case b.
rewrite sem_rec_true.
match goal with | |- context [sem (rec ?g ?h0 ?h1) ?vnl ?vsl] => set (e0 := sem (rec g h0 h1) vnl vsl) end.

*****
e0 : list bool
Hs : eq (length vsl) s
Hn : eq (S (length vnl)) (S n)
vnl,vsl : list (list bool)
v : list bool
b : bool
g,h : BC
n,s : nat
*****
eq (sem (comp (S n) (S s) h (cons (comp (S n) O (succ true) nil (cons (proj (S n) O O) nil)) (map (proj (S n) O) (seq (S O) n))) (map (proj (S n) (S s)) (seq (S n) (S s)))) (cons v vnl) (cons e0 vsl)) (sem h (cons (cons true v) vnl) (cons e0 vsl))
+++++
rewrite sem_comp.
-----
Lemma rec1_correct n s g h vnl vsl : length vnl = S n -> length vsl = s -> sem (rec1 n s g h) vnl vsl = sem_rec1 g h (hd nil vnl) (tl vnl) vsl.
Proof.
intros Hn Hs.
destruct vnl as [ | v vnl].
simpl in Hn.
induction v as [ | b v IH].
simpl sem_rec1.
simpl hd in IH.
simpl tl in IH.
rewrite <- IH.
clear IH.
unfold rec1.
case b.
rewrite sem_rec_true.
match goal with | |- context [sem (rec ?g ?h0 ?h1) ?vnl ?vsl] => set (e0 := sem (rec g h0 h1) vnl vsl) end.
rewrite sem_comp.

*****
e0 : list bool
Hs : eq (length vsl) s
Hn : eq (S (length vnl)) (S n)
vnl,vsl : list (list bool)
v : list bool
b : bool
g,h : BC
n,s : nat
*****
eq (sem h (map (fun ne : BC => sem ne (cons v vnl) nil) (cons (comp (S n) O (succ true) nil (cons (proj (S n) O O) nil)) (map (proj (S n) O) (seq (S O) n)))) (map (fun se : BC => sem se (cons v vnl) (cons e0 vsl)) (map (proj (S n) (S s)) (seq (S n) (S s))))) (sem h (cons (cons true v) vnl) (cons e0 vsl))
+++++
rewrite map_map.
-----
Lemma rec1_correct n s g h vnl vsl : length vnl = S n -> length vsl = s -> sem (rec1 n s g h) vnl vsl = sem_rec1 g h (hd nil vnl) (tl vnl) vsl.
Proof.
intros Hn Hs.
destruct vnl as [ | v vnl].
simpl in Hn.
induction v as [ | b v IH].
simpl sem_rec1.
simpl hd in IH.
simpl tl in IH.
rewrite <- IH.
clear IH.
unfold rec1.
case b.
rewrite sem_rec_true.
match goal with | |- context [sem (rec ?g ?h0 ?h1) ?vnl ?vsl] => set (e0 := sem (rec g h0 h1) vnl vsl) end.
rewrite sem_comp.
rewrite map_map.

*****
e0 : list bool
Hs : eq (length vsl) s
Hn : eq (S (length vnl)) (S n)
vnl,vsl : list (list bool)
v : list bool
b : bool
g,h : BC
n,s : nat
*****
eq (sem h (map (fun ne : BC => sem ne (cons v vnl) nil) (cons (comp (S n) O (succ true) nil (cons (proj (S n) O O) nil)) (map (proj (S n) O) (seq (S O) n)))) (map (fun x : nat => sem (proj (S n) (S s) x) (cons v vnl) (cons e0 vsl)) (seq (S n) (S s)))) (sem h (cons (cons true v) vnl) (cons e0 vsl))
+++++
f_equal.
-----
Lemma rec1_correct n s g h vnl vsl : length vnl = S n -> length vsl = s -> sem (rec1 n s g h) vnl vsl = sem_rec1 g h (hd nil vnl) (tl vnl) vsl.
Proof.
intros Hn Hs.
destruct vnl as [ | v vnl].
simpl in Hn.
induction v as [ | b v IH].
simpl sem_rec1.
simpl hd in IH.
simpl tl in IH.
rewrite <- IH.
clear IH.
unfold rec1.
case b.
rewrite sem_rec_true.
match goal with | |- context [sem (rec ?g ?h0 ?h1) ?vnl ?vsl] => set (e0 := sem (rec g h0 h1) vnl vsl) end.
rewrite sem_comp.
rewrite map_map.
f_equal.

*****
e0 : list bool
Hs : eq (length vsl) s
Hn : eq (S (length vnl)) (S n)
vnl,vsl : list (list bool)
v : list bool
b : bool
g,h : BC
n,s : nat
*****
eq (map (fun ne : BC => sem ne (cons v vnl) nil) (cons (comp (S n) O (succ true) nil (cons (proj (S n) O O) nil)) (map (proj (S n) O) (seq (S O) n)))) (cons (cons true v) vnl)
+++++
rewrite map_cons.
-----
Lemma rec1_correct n s g h vnl vsl : length vnl = S n -> length vsl = s -> sem (rec1 n s g h) vnl vsl = sem_rec1 g h (hd nil vnl) (tl vnl) vsl.
Proof.
intros Hn Hs.
destruct vnl as [ | v vnl].
simpl in Hn.
induction v as [ | b v IH].
simpl sem_rec1.
simpl hd in IH.
simpl tl in IH.
rewrite <- IH.
clear IH.
unfold rec1.
case b.
rewrite sem_rec_true.
match goal with | |- context [sem (rec ?g ?h0 ?h1) ?vnl ?vsl] => set (e0 := sem (rec g h0 h1) vnl vsl) end.
rewrite sem_comp.
rewrite map_map.
f_equal.
rewrite map_cons.

*****
e0 : list bool
Hs : eq (length vsl) s
Hn : eq (S (length vnl)) (S n)
vnl,vsl : list (list bool)
v : list bool
b : bool
g,h : BC
n,s : nat
*****
eq (cons (sem (comp (S n) O (succ true) nil (cons (proj (S n) O O) nil)) (cons v vnl) nil) (map (fun ne : BC => sem ne (cons v vnl) nil) (map (proj (S n) O) (seq (S O) n)))) (cons (cons true v) vnl)
+++++
f_equal.
-----
Lemma rec1_correct n s g h vnl vsl : length vnl = S n -> length vsl = s -> sem (rec1 n s g h) vnl vsl = sem_rec1 g h (hd nil vnl) (tl vnl) vsl.
Proof.
intros Hn Hs.
destruct vnl as [ | v vnl].
simpl in Hn.
induction v as [ | b v IH].
simpl sem_rec1.
simpl hd in IH.
simpl tl in IH.
rewrite <- IH.
clear IH.
unfold rec1.
case b.
rewrite sem_rec_true.
match goal with | |- context [sem (rec ?g ?h0 ?h1) ?vnl ?vsl] => set (e0 := sem (rec g h0 h1) vnl vsl) end.
rewrite sem_comp.
rewrite map_map.
f_equal.
rewrite map_cons.
f_equal.

*****
e0 : list bool
Hs : eq (length vsl) s
Hn : eq (S (length vnl)) (S n)
vnl,vsl : list (list bool)
v : list bool
b : bool
g,h : BC
n,s : nat
*****
eq (map (fun ne : BC => sem ne (cons v vnl) nil) (map (proj (S n) O) (seq (S O) n))) vnl
+++++
replace (S n) with (n+1) by omega.
-----
Lemma rec1_correct n s g h vnl vsl : length vnl = S n -> length vsl = s -> sem (rec1 n s g h) vnl vsl = sem_rec1 g h (hd nil vnl) (tl vnl) vsl.
Proof.
intros Hn Hs.
destruct vnl as [ | v vnl].
simpl in Hn.
induction v as [ | b v IH].
simpl sem_rec1.
simpl hd in IH.
simpl tl in IH.
rewrite <- IH.
clear IH.
unfold rec1.
case b.
rewrite sem_rec_true.
match goal with | |- context [sem (rec ?g ?h0 ?h1) ?vnl ?vsl] => set (e0 := sem (rec g h0 h1) vnl vsl) end.
rewrite sem_comp.
rewrite map_map.
f_equal.
rewrite map_cons.
f_equal.
replace (S n) with (n+1) by omega.

*****
e0 : list bool
Hs : eq (length vsl) s
Hn : eq (S (length vnl)) (S n)
vnl,vsl : list (list bool)
v : list bool
b : bool
g,h : BC
n,s : nat
*****
eq (map (fun ne : BC => sem ne (cons v vnl) nil) (map (proj (Init.Nat.add n (S O)) O) (seq (S O) n))) vnl
+++++
rewrite map_proj_seq_normal_gen.
-----
Lemma rec1_correct n s g h vnl vsl : length vnl = S n -> length vsl = s -> sem (rec1 n s g h) vnl vsl = sem_rec1 g h (hd nil vnl) (tl vnl) vsl.
Proof.
intros Hn Hs.
destruct vnl as [ | v vnl].
simpl in Hn.
induction v as [ | b v IH].
simpl sem_rec1.
simpl hd in IH.
simpl tl in IH.
rewrite <- IH.
clear IH.
unfold rec1.
case b.
rewrite sem_rec_true.
match goal with | |- context [sem (rec ?g ?h0 ?h1) ?vnl ?vsl] => set (e0 := sem (rec g h0 h1) vnl vsl) end.
rewrite sem_comp.
rewrite map_map.
f_equal.
rewrite map_cons.
f_equal.
replace (S n) with (n+1) by omega.
rewrite map_proj_seq_normal_gen.

*****
e0 : list bool
Hs : eq (length vsl) s
Hn : eq (S (length vnl)) (S n)
vnl,vsl : list (list bool)
v : list bool
b : bool
g,h : BC
n,s : nat
*****
eq (firstn n (skipn (S O) (cons v vnl))) vnl
+++++
idtac.
-----
Lemma rec1_correct n s g h vnl vsl : length vnl = S n -> length vsl = s -> sem (rec1 n s g h) vnl vsl = sem_rec1 g h (hd nil vnl) (tl vnl) vsl.
Proof.
intros Hn Hs.
destruct vnl as [ | v vnl].
simpl in Hn.
induction v as [ | b v IH].
simpl sem_rec1.
simpl hd in IH.
simpl tl in IH.
rewrite <- IH.
clear IH.
unfold rec1.
case b.
rewrite sem_rec_true.
match goal with | |- context [sem (rec ?g ?h0 ?h1) ?vnl ?vsl] => set (e0 := sem (rec g h0 h1) vnl vsl) end.
rewrite sem_comp.
rewrite map_map.
f_equal.
rewrite map_cons.
f_equal.
replace (S n) with (n+1) by omega.
rewrite map_proj_seq_normal_gen.
idtac.

*****
e0 : list bool
Hs : eq (length vsl) s
Hn : eq (S (length vnl)) (S n)
vnl,vsl : list (list bool)
v : list bool
b : bool
g,h : BC
n,s : nat
*****
eq (firstn n (skipn (S O) (cons v vnl))) vnl
+++++
erewrite firstn_map_nth by (simpl; omega).
-----
Lemma rec1_correct n s g h vnl vsl : length vnl = S n -> length vsl = s -> sem (rec1 n s g h) vnl vsl = sem_rec1 g h (hd nil vnl) (tl vnl) vsl.
Proof.
intros Hn Hs.
destruct vnl as [ | v vnl].
simpl in Hn.
induction v as [ | b v IH].
simpl sem_rec1.
simpl hd in IH.
simpl tl in IH.
rewrite <- IH.
clear IH.
unfold rec1.
case b.
rewrite sem_rec_true.
match goal with | |- context [sem (rec ?g ?h0 ?h1) ?vnl ?vsl] => set (e0 := sem (rec g h0 h1) vnl vsl) end.
rewrite sem_comp.
rewrite map_map.
f_equal.
rewrite map_cons.
f_equal.
replace (S n) with (n+1) by omega.
rewrite map_proj_seq_normal_gen.
idtac.
erewrite firstn_map_nth by (simpl; omega).

*****
e0 : list bool
Hs : eq (length vsl) s
Hn : eq (S (length vnl)) (S n)
vnl,vsl : list (list bool)
v : list bool
b : bool
g,h : BC
n,s : nat
*****
eq (map (fun i : nat => nth i (cons v vnl) ?d) (seq (S O) n)) vnl
+++++
instantiate (1:=nil).
-----
Lemma rec1_correct n s g h vnl vsl : length vnl = S n -> length vsl = s -> sem (rec1 n s g h) vnl vsl = sem_rec1 g h (hd nil vnl) (tl vnl) vsl.
Proof.
intros Hn Hs.
destruct vnl as [ | v vnl].
simpl in Hn.
induction v as [ | b v IH].
simpl sem_rec1.
simpl hd in IH.
simpl tl in IH.
rewrite <- IH.
clear IH.
unfold rec1.
case b.
rewrite sem_rec_true.
match goal with | |- context [sem (rec ?g ?h0 ?h1) ?vnl ?vsl] => set (e0 := sem (rec g h0 h1) vnl vsl) end.
rewrite sem_comp.
rewrite map_map.
f_equal.
rewrite map_cons.
f_equal.
replace (S n) with (n+1) by omega.
rewrite map_proj_seq_normal_gen.
idtac.
erewrite firstn_map_nth by (simpl; omega).
instantiate (1:=nil).

*****
e0 : list bool
Hs : eq (length vsl) s
Hn : eq (S (length vnl)) (S n)
vnl,vsl : list (list bool)
v : list bool
b : bool
g,h : BC
n,s : nat
*****
eq (map (fun i : nat => nth i (cons v vnl) nil) (seq (S O) n)) vnl
+++++
rewrite <- seq_shift.
-----
Lemma rec1_correct n s g h vnl vsl : length vnl = S n -> length vsl = s -> sem (rec1 n s g h) vnl vsl = sem_rec1 g h (hd nil vnl) (tl vnl) vsl.
Proof.
intros Hn Hs.
destruct vnl as [ | v vnl].
simpl in Hn.
induction v as [ | b v IH].
simpl sem_rec1.
simpl hd in IH.
simpl tl in IH.
rewrite <- IH.
clear IH.
unfold rec1.
case b.
rewrite sem_rec_true.
match goal with | |- context [sem (rec ?g ?h0 ?h1) ?vnl ?vsl] => set (e0 := sem (rec g h0 h1) vnl vsl) end.
rewrite sem_comp.
rewrite map_map.
f_equal.
rewrite map_cons.
f_equal.
replace (S n) with (n+1) by omega.
rewrite map_proj_seq_normal_gen.
idtac.
erewrite firstn_map_nth by (simpl; omega).
instantiate (1:=nil).
rewrite <- seq_shift.

*****
e0 : list bool
Hs : eq (length vsl) s
Hn : eq (S (length vnl)) (S n)
vnl,vsl : list (list bool)
v : list bool
b : bool
g,h : BC
n,s : nat
*****
eq (map (fun i : nat => nth i (cons v vnl) nil) (map S (seq O n))) vnl
+++++
rewrite map_map.
-----
Lemma rec1_correct n s g h vnl vsl : length vnl = S n -> length vsl = s -> sem (rec1 n s g h) vnl vsl = sem_rec1 g h (hd nil vnl) (tl vnl) vsl.
Proof.
intros Hn Hs.
destruct vnl as [ | v vnl].
simpl in Hn.
induction v as [ | b v IH].
simpl sem_rec1.
simpl hd in IH.
simpl tl in IH.
rewrite <- IH.
clear IH.
unfold rec1.
case b.
rewrite sem_rec_true.
match goal with | |- context [sem (rec ?g ?h0 ?h1) ?vnl ?vsl] => set (e0 := sem (rec g h0 h1) vnl vsl) end.
rewrite sem_comp.
rewrite map_map.
f_equal.
rewrite map_cons.
f_equal.
replace (S n) with (n+1) by omega.
rewrite map_proj_seq_normal_gen.
idtac.
erewrite firstn_map_nth by (simpl; omega).
instantiate (1:=nil).
rewrite <- seq_shift.
rewrite map_map.

*****
e0 : list bool
Hs : eq (length vsl) s
Hn : eq (S (length vnl)) (S n)
vnl,vsl : list (list bool)
v : list bool
b : bool
g,h : BC
n,s : nat
*****
eq (map (fun x : nat => nth (S x) (cons v vnl) nil) (seq O n)) vnl
+++++
simpl.
-----
Lemma rec1_correct n s g h vnl vsl : length vnl = S n -> length vsl = s -> sem (rec1 n s g h) vnl vsl = sem_rec1 g h (hd nil vnl) (tl vnl) vsl.
Proof.
intros Hn Hs.
destruct vnl as [ | v vnl].
simpl in Hn.
induction v as [ | b v IH].
simpl sem_rec1.
simpl hd in IH.
simpl tl in IH.
rewrite <- IH.
clear IH.
unfold rec1.
case b.
rewrite sem_rec_true.
match goal with | |- context [sem (rec ?g ?h0 ?h1) ?vnl ?vsl] => set (e0 := sem (rec g h0 h1) vnl vsl) end.
rewrite sem_comp.
rewrite map_map.
f_equal.
rewrite map_cons.
f_equal.
replace (S n) with (n+1) by omega.
rewrite map_proj_seq_normal_gen.
idtac.
erewrite firstn_map_nth by (simpl; omega).
instantiate (1:=nil).
rewrite <- seq_shift.
rewrite map_map.
simpl.

*****
e0 : list bool
Hs : eq (length vsl) s
Hn : eq (S (length vnl)) (S n)
vnl,vsl : list (list bool)
v : list bool
b : bool
g,h : BC
n,s : nat
*****
eq (map (fun x : nat => nth x vnl nil) (seq O n)) vnl
+++++
apply map_nth_seq.
-----
Lemma rec1_correct n s g h vnl vsl : length vnl = S n -> length vsl = s -> sem (rec1 n s g h) vnl vsl = sem_rec1 g h (hd nil vnl) (tl vnl) vsl.
Proof.
intros Hn Hs.
destruct vnl as [ | v vnl].
simpl in Hn.
induction v as [ | b v IH].
simpl sem_rec1.
simpl hd in IH.
simpl tl in IH.
rewrite <- IH.
clear IH.
unfold rec1.
case b.
rewrite sem_rec_true.
match goal with | |- context [sem (rec ?g ?h0 ?h1) ?vnl ?vsl] => set (e0 := sem (rec g h0 h1) vnl vsl) end.
rewrite sem_comp.
rewrite map_map.
f_equal.
rewrite map_cons.
f_equal.
replace (S n) with (n+1) by omega.
rewrite map_proj_seq_normal_gen.
idtac.
erewrite firstn_map_nth by (simpl; omega).
instantiate (1:=nil).
rewrite <- seq_shift.
rewrite map_map.
simpl.
apply map_nth_seq.

*****
e0 : list bool
Hs : eq (length vsl) s
Hn : eq (S (length vnl)) (S n)
vnl,vsl : list (list bool)
v : list bool
b : bool
g,h : BC
n,s : nat
*****
eq (length vnl) (Init.Nat.add n O)
+++++
omega.
-----
Lemma rec1_correct n s g h vnl vsl : length vnl = S n -> length vsl = s -> sem (rec1 n s g h) vnl vsl = sem_rec1 g h (hd nil vnl) (tl vnl) vsl.
Proof.
intros Hn Hs.
destruct vnl as [ | v vnl].
simpl in Hn.
induction v as [ | b v IH].
simpl sem_rec1.
simpl hd in IH.
simpl tl in IH.
rewrite <- IH.
clear IH.
unfold rec1.
case b.
rewrite sem_rec_true.
match goal with | |- context [sem (rec ?g ?h0 ?h1) ?vnl ?vsl] => set (e0 := sem (rec g h0 h1) vnl vsl) end.
rewrite sem_comp.
rewrite map_map.
f_equal.
rewrite map_cons.
f_equal.
replace (S n) with (n+1) by omega.
rewrite map_proj_seq_normal_gen.

*****
e0 : list bool
Hs : eq (length vsl) s
Hn : eq (S (length vnl)) (S n)
vnl,vsl : list (list bool)
v : list bool
b : bool
g,h : BC
n,s : nat
*****
le (Init.Nat.add n (S O)) (length (cons v vnl))
+++++
simpl.
-----
Lemma rec1_correct n s g h vnl vsl : length vnl = S n -> length vsl = s -> sem (rec1 n s g h) vnl vsl = sem_rec1 g h (hd nil vnl) (tl vnl) vsl.
Proof.
intros Hn Hs.
destruct vnl as [ | v vnl].
simpl in Hn.
induction v as [ | b v IH].
simpl sem_rec1.
simpl hd in IH.
simpl tl in IH.
rewrite <- IH.
clear IH.
unfold rec1.
case b.
rewrite sem_rec_true.
match goal with | |- context [sem (rec ?g ?h0 ?h1) ?vnl ?vsl] => set (e0 := sem (rec g h0 h1) vnl vsl) end.
rewrite sem_comp.
rewrite map_map.
f_equal.
rewrite map_cons.
f_equal.
replace (S n) with (n+1) by omega.
rewrite map_proj_seq_normal_gen.
simpl.

*****
e0 : list bool
Hs : eq (length vsl) s
Hn : eq (S (length vnl)) (S n)
vnl,vsl : list (list bool)
v : list bool
b : bool
g,h : BC
n,s : nat
*****
le (Init.Nat.add n (S O)) (S (length vnl))
+++++
omega .
-----
Lemma rec1_correct n s g h vnl vsl : length vnl = S n -> length vsl = s -> sem (rec1 n s g h) vnl vsl = sem_rec1 g h (hd nil vnl) (tl vnl) vsl.
Proof.
intros Hn Hs.
destruct vnl as [ | v vnl].
simpl in Hn.
induction v as [ | b v IH].
simpl sem_rec1.
simpl hd in IH.
simpl tl in IH.
rewrite <- IH.
clear IH.
unfold rec1.
case b.
rewrite sem_rec_true.
match goal with | |- context [sem (rec ?g ?h0 ?h1) ?vnl ?vsl] => set (e0 := sem (rec g h0 h1) vnl vsl) end.
rewrite sem_comp.
rewrite map_map.
f_equal.

*****
e0 : list bool
Hs : eq (length vsl) s
Hn : eq (S (length vnl)) (S n)
vnl,vsl : list (list bool)
v : list bool
b : bool
g,h : BC
n,s : nat
*****
eq (map (fun x : nat => sem (proj (S n) (S s) x) (cons v vnl) (cons e0 vsl)) (seq (S n) (S s))) (cons e0 vsl)
+++++
rewrite <- ( map_map (proj (S n) (S s)) (fun e => sem e (v :: vnl) (e0 :: vsl)) ).
-----
Lemma rec1_correct n s g h vnl vsl : length vnl = S n -> length vsl = s -> sem (rec1 n s g h) vnl vsl = sem_rec1 g h (hd nil vnl) (tl vnl) vsl.
Proof.
intros Hn Hs.
destruct vnl as [ | v vnl].
simpl in Hn.
induction v as [ | b v IH].
simpl sem_rec1.
simpl hd in IH.
simpl tl in IH.
rewrite <- IH.
clear IH.
unfold rec1.
case b.
rewrite sem_rec_true.
match goal with | |- context [sem (rec ?g ?h0 ?h1) ?vnl ?vsl] => set (e0 := sem (rec g h0 h1) vnl vsl) end.
rewrite sem_comp.
rewrite map_map.
f_equal.
rewrite <- ( map_map (proj (S n) (S s)) (fun e => sem e (v :: vnl) (e0 :: vsl)) ).

*****
e0 : list bool
Hs : eq (length vsl) s
Hn : eq (S (length vnl)) (S n)
vnl,vsl : list (list bool)
v : list bool
b : bool
g,h : BC
n,s : nat
*****
eq (map (fun e : BC => sem e (cons v vnl) (cons e0 vsl)) (map (proj (S n) (S s)) (seq (S n) (S s)))) (cons e0 vsl)
+++++
rewrite map_proj_seq_safe.
-----
Lemma rec1_correct n s g h vnl vsl : length vnl = S n -> length vsl = s -> sem (rec1 n s g h) vnl vsl = sem_rec1 g h (hd nil vnl) (tl vnl) vsl.
Proof.
intros Hn Hs.
destruct vnl as [ | v vnl].
simpl in Hn.
induction v as [ | b v IH].
simpl sem_rec1.
simpl hd in IH.
simpl tl in IH.
rewrite <- IH.
clear IH.
unfold rec1.
case b.
rewrite sem_rec_true.
match goal with | |- context [sem (rec ?g ?h0 ?h1) ?vnl ?vsl] => set (e0 := sem (rec g h0 h1) vnl vsl) end.
rewrite sem_comp.
rewrite map_map.
f_equal.
rewrite <- ( map_map (proj (S n) (S s)) (fun e => sem e (v :: vnl) (e0 :: vsl)) ).
rewrite map_proj_seq_safe.

*****
e0 : list bool
Hs : eq (length vsl) s
Hn : eq (S (length vnl)) (S n)
vnl,vsl : list (list bool)
v : list bool
b : bool
g,h : BC
n,s : nat
*****
eq (app (firstn (S s) (cons e0 vsl)) (repeat (Init.Nat.sub (S s) (length (cons e0 vsl))) nil)) (cons e0 vsl)
+++++
simpl.
-----
Lemma rec1_correct n s g h vnl vsl : length vnl = S n -> length vsl = s -> sem (rec1 n s g h) vnl vsl = sem_rec1 g h (hd nil vnl) (tl vnl) vsl.
Proof.
intros Hn Hs.
destruct vnl as [ | v vnl].
simpl in Hn.
induction v as [ | b v IH].
simpl sem_rec1.
simpl hd in IH.
simpl tl in IH.
rewrite <- IH.
clear IH.
unfold rec1.
case b.
rewrite sem_rec_true.
match goal with | |- context [sem (rec ?g ?h0 ?h1) ?vnl ?vsl] => set (e0 := sem (rec g h0 h1) vnl vsl) end.
rewrite sem_comp.
rewrite map_map.
f_equal.
rewrite <- ( map_map (proj (S n) (S s)) (fun e => sem e (v :: vnl) (e0 :: vsl)) ).
rewrite map_proj_seq_safe.
simpl.

*****
e0 : list bool
Hs : eq (length vsl) s
Hn : eq (S (length vnl)) (S n)
vnl,vsl : list (list bool)
v : list bool
b : bool
g,h : BC
n,s : nat
*****
eq (cons e0 (app (firstn s vsl) (repeat (Init.Nat.sub s (length vsl)) nil))) (cons e0 vsl)
+++++
f_equal.
-----
Lemma rec1_correct n s g h vnl vsl : length vnl = S n -> length vsl = s -> sem (rec1 n s g h) vnl vsl = sem_rec1 g h (hd nil vnl) (tl vnl) vsl.
Proof.
intros Hn Hs.
destruct vnl as [ | v vnl].
simpl in Hn.
induction v as [ | b v IH].
simpl sem_rec1.
simpl hd in IH.
simpl tl in IH.
rewrite <- IH.
clear IH.
unfold rec1.
case b.
rewrite sem_rec_true.
match goal with | |- context [sem (rec ?g ?h0 ?h1) ?vnl ?vsl] => set (e0 := sem (rec g h0 h1) vnl vsl) end.
rewrite sem_comp.
rewrite map_map.
f_equal.
rewrite <- ( map_map (proj (S n) (S s)) (fun e => sem e (v :: vnl) (e0 :: vsl)) ).
rewrite map_proj_seq_safe.
simpl.
f_equal.

*****
e0 : list bool
Hs : eq (length vsl) s
Hn : eq (S (length vnl)) (S n)
vnl,vsl : list (list bool)
v : list bool
b : bool
g,h : BC
n,s : nat
*****
eq (app (firstn s vsl) (repeat (Init.Nat.sub s (length vsl)) nil)) vsl
+++++
subst s.
-----
Lemma rec1_correct n s g h vnl vsl : length vnl = S n -> length vsl = s -> sem (rec1 n s g h) vnl vsl = sem_rec1 g h (hd nil vnl) (tl vnl) vsl.
Proof.
intros Hn Hs.
destruct vnl as [ | v vnl].
simpl in Hn.
induction v as [ | b v IH].
simpl sem_rec1.
simpl hd in IH.
simpl tl in IH.
rewrite <- IH.
clear IH.
unfold rec1.
case b.
rewrite sem_rec_true.
match goal with | |- context [sem (rec ?g ?h0 ?h1) ?vnl ?vsl] => set (e0 := sem (rec g h0 h1) vnl vsl) end.
rewrite sem_comp.
rewrite map_map.
f_equal.
rewrite <- ( map_map (proj (S n) (S s)) (fun e => sem e (v :: vnl) (e0 :: vsl)) ).
rewrite map_proj_seq_safe.
simpl.
f_equal.
subst s.

*****
e0 : list bool
Hn : eq (S (length vnl)) (S n)
vnl,vsl : list (list bool)
v : list bool
b : bool
g,h : BC
n : nat
*****
eq (app (firstn (length vsl) vsl) (repeat (Init.Nat.sub (length vsl) (length vsl)) nil)) vsl
+++++
rewrite minus_diag.
-----
Lemma rec1_correct n s g h vnl vsl : length vnl = S n -> length vsl = s -> sem (rec1 n s g h) vnl vsl = sem_rec1 g h (hd nil vnl) (tl vnl) vsl.
Proof.
intros Hn Hs.
destruct vnl as [ | v vnl].
simpl in Hn.
induction v as [ | b v IH].
simpl sem_rec1.
simpl hd in IH.
simpl tl in IH.
rewrite <- IH.
clear IH.
unfold rec1.
case b.
rewrite sem_rec_true.
match goal with | |- context [sem (rec ?g ?h0 ?h1) ?vnl ?vsl] => set (e0 := sem (rec g h0 h1) vnl vsl) end.
rewrite sem_comp.
rewrite map_map.
f_equal.
rewrite <- ( map_map (proj (S n) (S s)) (fun e => sem e (v :: vnl) (e0 :: vsl)) ).
rewrite map_proj_seq_safe.
simpl.
f_equal.
subst s.
rewrite minus_diag.

*****
e0 : list bool
Hn : eq (S (length vnl)) (S n)
vnl,vsl : list (list bool)
v : list bool
b : bool
g,h : BC
n : nat
*****
eq (app (firstn (length vsl) vsl) (repeat O nil)) vsl
+++++
simpl.
-----
Lemma rec1_correct n s g h vnl vsl : length vnl = S n -> length vsl = s -> sem (rec1 n s g h) vnl vsl = sem_rec1 g h (hd nil vnl) (tl vnl) vsl.
Proof.
intros Hn Hs.
destruct vnl as [ | v vnl].
simpl in Hn.
induction v as [ | b v IH].
simpl sem_rec1.
simpl hd in IH.
simpl tl in IH.
rewrite <- IH.
clear IH.
unfold rec1.
case b.
rewrite sem_rec_true.
match goal with | |- context [sem (rec ?g ?h0 ?h1) ?vnl ?vsl] => set (e0 := sem (rec g h0 h1) vnl vsl) end.
rewrite sem_comp.
rewrite map_map.
f_equal.
rewrite <- ( map_map (proj (S n) (S s)) (fun e => sem e (v :: vnl) (e0 :: vsl)) ).
rewrite map_proj_seq_safe.
simpl.
f_equal.
subst s.
rewrite minus_diag.
simpl.

*****
e0 : list bool
Hn : eq (S (length vnl)) (S n)
vnl,vsl : list (list bool)
v : list bool
b : bool
g,h : BC
n : nat
*****
eq (app (firstn (length vsl) vsl) nil) vsl
+++++
rewrite app_nil_r.
-----
Lemma rec1_correct n s g h vnl vsl : length vnl = S n -> length vsl = s -> sem (rec1 n s g h) vnl vsl = sem_rec1 g h (hd nil vnl) (tl vnl) vsl.
Proof.
intros Hn Hs.
destruct vnl as [ | v vnl].
simpl in Hn.
induction v as [ | b v IH].
simpl sem_rec1.
simpl hd in IH.
simpl tl in IH.
rewrite <- IH.
clear IH.
unfold rec1.
case b.
rewrite sem_rec_true.
match goal with | |- context [sem (rec ?g ?h0 ?h1) ?vnl ?vsl] => set (e0 := sem (rec g h0 h1) vnl vsl) end.
rewrite sem_comp.
rewrite map_map.
f_equal.
rewrite <- ( map_map (proj (S n) (S s)) (fun e => sem e (v :: vnl) (e0 :: vsl)) ).
rewrite map_proj_seq_safe.
simpl.
f_equal.
subst s.
rewrite minus_diag.
simpl.
rewrite app_nil_r.

*****
e0 : list bool
Hn : eq (S (length vnl)) (S n)
vnl,vsl : list (list bool)
v : list bool
b : bool
g,h : BC
n : nat
*****
eq (firstn (length vsl) vsl) vsl
+++++
rewrite <- (app_nil_r vsl) at 2.
-----
Lemma rec1_correct n s g h vnl vsl : length vnl = S n -> length vsl = s -> sem (rec1 n s g h) vnl vsl = sem_rec1 g h (hd nil vnl) (tl vnl) vsl.
Proof.
intros Hn Hs.
destruct vnl as [ | v vnl].
simpl in Hn.
induction v as [ | b v IH].
simpl sem_rec1.
simpl hd in IH.
simpl tl in IH.
rewrite <- IH.
clear IH.
unfold rec1.
case b.
rewrite sem_rec_true.
match goal with | |- context [sem (rec ?g ?h0 ?h1) ?vnl ?vsl] => set (e0 := sem (rec g h0 h1) vnl vsl) end.
rewrite sem_comp.
rewrite map_map.
f_equal.
rewrite <- ( map_map (proj (S n) (S s)) (fun e => sem e (v :: vnl) (e0 :: vsl)) ).
rewrite map_proj_seq_safe.
simpl.
f_equal.
subst s.
rewrite minus_diag.
simpl.
rewrite app_nil_r.
rewrite <- (app_nil_r vsl) at 2.

*****
e0 : list bool
Hn : eq (S (length vnl)) (S n)
vnl,vsl : list (list bool)
v : list bool
b : bool
g,h : BC
n : nat
*****
eq (firstn (length vsl) (app vsl nil)) vsl
+++++
apply firstn_app.
-----
Lemma rec1_correct n s g h vnl vsl : length vnl = S n -> length vsl = s -> sem (rec1 n s g h) vnl vsl = sem_rec1 g h (hd nil vnl) (tl vnl) vsl.
Proof.
intros Hn Hs.
destruct vnl as [ | v vnl].
simpl in Hn.
induction v as [ | b v IH].
simpl sem_rec1.
simpl hd in IH.
simpl tl in IH.
rewrite <- IH.
clear IH.
unfold rec1.
case b.

*****
Hs : eq (length vsl) s
Hn : eq (S (length vnl)) (S n)
vnl,vsl : list (list bool)
v : list bool
b : bool
g,h : BC
n,s : nat
*****
eq (sem (rec g (comp (S n) (S s) h (cons (comp (S n) O (succ false) nil (cons (proj (S n) O O) nil)) (map (proj (S n) O) (seq (S O) n))) (map (proj (S n) (S s)) (seq (S n) (S s)))) (comp (S n) (S s) h (cons (comp (S n) O (succ true) nil (cons (proj (S n) O O) nil)) (map (proj (S n) O) (seq (S O) n))) (map (proj (S n) (S s)) (seq (S n) (S s))))) (cons (cons false v) vnl) vsl) (sem h (cons (cons false v) vnl) (cons (sem (rec g (comp (S n) (S s) h (cons (comp (S n) O (succ false) nil (cons (proj (S n) O O) nil)) (map (proj (S n) O) (seq (S O) n))) (map (proj (S n) (S s)) (seq (S n) (S s)))) (comp (S n) (S s) h (cons (comp (S n) O (succ true) nil (cons (proj (S n) O O) nil)) (map (proj (S n) O) (seq (S O) n))) (map (proj (S n) (S s)) (seq (S n) (S s))))) (cons v vnl) vsl) vsl))
+++++
rewrite sem_rec_false.
-----
Lemma rec1_correct n s g h vnl vsl : length vnl = S n -> length vsl = s -> sem (rec1 n s g h) vnl vsl = sem_rec1 g h (hd nil vnl) (tl vnl) vsl.
Proof.
intros Hn Hs.
destruct vnl as [ | v vnl].
simpl in Hn.
induction v as [ | b v IH].
simpl sem_rec1.
simpl hd in IH.
simpl tl in IH.
rewrite <- IH.
clear IH.
unfold rec1.
case b.
rewrite sem_rec_false.

*****
Hs : eq (length vsl) s
Hn : eq (S (length vnl)) (S n)
vnl,vsl : list (list bool)
v : list bool
b : bool
g,h : BC
n,s : nat
*****
eq (sem (comp (S n) (S s) h (cons (comp (S n) O (succ false) nil (cons (proj (S n) O O) nil)) (map (proj (S n) O) (seq (S O) n))) (map (proj (S n) (S s)) (seq (S n) (S s)))) (cons v vnl) (cons (sem (rec g (comp (S n) (S s) h (cons (comp (S n) O (succ false) nil (cons (proj (S n) O O) nil)) (map (proj (S n) O) (seq (S O) n))) (map (proj (S n) (S s)) (seq (S n) (S s)))) (comp (S n) (S s) h (cons (comp (S n) O (succ true) nil (cons (proj (S n) O O) nil)) (map (proj (S n) O) (seq (S O) n))) (map (proj (S n) (S s)) (seq (S n) (S s))))) (cons v vnl) vsl) vsl)) (sem h (cons (cons false v) vnl) (cons (sem (rec g (comp (S n) (S s) h (cons (comp (S n) O (succ false) nil (cons (proj (S n) O O) nil)) (map (proj (S n) O) (seq (S O) n))) (map (proj (S n) (S s)) (seq (S n) (S s)))) (comp (S n) (S s) h (cons (comp (S n) O (succ true) nil (cons (proj (S n) O O) nil)) (map (proj (S n) O) (seq (S O) n))) (map (proj (S n) (S s)) (seq (S n) (S s))))) (cons v vnl) vsl) vsl))
+++++
match goal with | |- context [sem (rec ?g ?h0 ?h1) ?vnl ?vsl] => set (e0 := sem (rec g h0 h1) vnl vsl) end.
-----
Lemma rec1_correct n s g h vnl vsl : length vnl = S n -> length vsl = s -> sem (rec1 n s g h) vnl vsl = sem_rec1 g h (hd nil vnl) (tl vnl) vsl.
Proof.
intros Hn Hs.
destruct vnl as [ | v vnl].
simpl in Hn.
induction v as [ | b v IH].
simpl sem_rec1.
simpl hd in IH.
simpl tl in IH.
rewrite <- IH.
clear IH.
unfold rec1.
case b.
rewrite sem_rec_false.
match goal with | |- context [sem (rec ?g ?h0 ?h1) ?vnl ?vsl] => set (e0 := sem (rec g h0 h1) vnl vsl) end.

*****
e0 : list bool
Hs : eq (length vsl) s
Hn : eq (S (length vnl)) (S n)
vnl,vsl : list (list bool)
v : list bool
b : bool
g,h : BC
n,s : nat
*****
eq (sem (comp (S n) (S s) h (cons (comp (S n) O (succ false) nil (cons (proj (S n) O O) nil)) (map (proj (S n) O) (seq (S O) n))) (map (proj (S n) (S s)) (seq (S n) (S s)))) (cons v vnl) (cons e0 vsl)) (sem h (cons (cons false v) vnl) (cons e0 vsl))
+++++
rewrite sem_comp.
-----
Lemma rec1_correct n s g h vnl vsl : length vnl = S n -> length vsl = s -> sem (rec1 n s g h) vnl vsl = sem_rec1 g h (hd nil vnl) (tl vnl) vsl.
Proof.
intros Hn Hs.
destruct vnl as [ | v vnl].
simpl in Hn.
induction v as [ | b v IH].
simpl sem_rec1.
simpl hd in IH.
simpl tl in IH.
rewrite <- IH.
clear IH.
unfold rec1.
case b.
rewrite sem_rec_false.
match goal with | |- context [sem (rec ?g ?h0 ?h1) ?vnl ?vsl] => set (e0 := sem (rec g h0 h1) vnl vsl) end.
rewrite sem_comp.

*****
e0 : list bool
Hs : eq (length vsl) s
Hn : eq (S (length vnl)) (S n)
vnl,vsl : list (list bool)
v : list bool
b : bool
g,h : BC
n,s : nat
*****
eq (sem h (map (fun ne : BC => sem ne (cons v vnl) nil) (cons (comp (S n) O (succ false) nil (cons (proj (S n) O O) nil)) (map (proj (S n) O) (seq (S O) n)))) (map (fun se : BC => sem se (cons v vnl) (cons e0 vsl)) (map (proj (S n) (S s)) (seq (S n) (S s))))) (sem h (cons (cons false v) vnl) (cons e0 vsl))
+++++
rewrite map_map.
-----
Lemma rec1_correct n s g h vnl vsl : length vnl = S n -> length vsl = s -> sem (rec1 n s g h) vnl vsl = sem_rec1 g h (hd nil vnl) (tl vnl) vsl.
Proof.
intros Hn Hs.
destruct vnl as [ | v vnl].
simpl in Hn.
induction v as [ | b v IH].
simpl sem_rec1.
simpl hd in IH.
simpl tl in IH.
rewrite <- IH.
clear IH.
unfold rec1.
case b.
rewrite sem_rec_false.
match goal with | |- context [sem (rec ?g ?h0 ?h1) ?vnl ?vsl] => set (e0 := sem (rec g h0 h1) vnl vsl) end.
rewrite sem_comp.
rewrite map_map.

*****
e0 : list bool
Hs : eq (length vsl) s
Hn : eq (S (length vnl)) (S n)
vnl,vsl : list (list bool)
v : list bool
b : bool
g,h : BC
n,s : nat
*****
eq (sem h (map (fun ne : BC => sem ne (cons v vnl) nil) (cons (comp (S n) O (succ false) nil (cons (proj (S n) O O) nil)) (map (proj (S n) O) (seq (S O) n)))) (map (fun x : nat => sem (proj (S n) (S s) x) (cons v vnl) (cons e0 vsl)) (seq (S n) (S s)))) (sem h (cons (cons false v) vnl) (cons e0 vsl))
+++++
f_equal.
-----
Lemma rec1_correct n s g h vnl vsl : length vnl = S n -> length vsl = s -> sem (rec1 n s g h) vnl vsl = sem_rec1 g h (hd nil vnl) (tl vnl) vsl.
Proof.
intros Hn Hs.
destruct vnl as [ | v vnl].
simpl in Hn.
induction v as [ | b v IH].
simpl sem_rec1.
simpl hd in IH.
simpl tl in IH.
rewrite <- IH.
clear IH.
unfold rec1.
case b.
rewrite sem_rec_false.
match goal with | |- context [sem (rec ?g ?h0 ?h1) ?vnl ?vsl] => set (e0 := sem (rec g h0 h1) vnl vsl) end.
rewrite sem_comp.
rewrite map_map.
f_equal.

*****
e0 : list bool
Hs : eq (length vsl) s
Hn : eq (S (length vnl)) (S n)
vnl,vsl : list (list bool)
v : list bool
b : bool
g,h : BC
n,s : nat
*****
eq (map (fun ne : BC => sem ne (cons v vnl) nil) (cons (comp (S n) O (succ false) nil (cons (proj (S n) O O) nil)) (map (proj (S n) O) (seq (S O) n)))) (cons (cons false v) vnl)
+++++
rewrite map_cons.
-----
Lemma rec1_correct n s g h vnl vsl : length vnl = S n -> length vsl = s -> sem (rec1 n s g h) vnl vsl = sem_rec1 g h (hd nil vnl) (tl vnl) vsl.
Proof.
intros Hn Hs.
destruct vnl as [ | v vnl].
simpl in Hn.
induction v as [ | b v IH].
simpl sem_rec1.
simpl hd in IH.
simpl tl in IH.
rewrite <- IH.
clear IH.
unfold rec1.
case b.
rewrite sem_rec_false.
match goal with | |- context [sem (rec ?g ?h0 ?h1) ?vnl ?vsl] => set (e0 := sem (rec g h0 h1) vnl vsl) end.
rewrite sem_comp.
rewrite map_map.
f_equal.
rewrite map_cons.

*****
e0 : list bool
Hs : eq (length vsl) s
Hn : eq (S (length vnl)) (S n)
vnl,vsl : list (list bool)
v : list bool
b : bool
g,h : BC
n,s : nat
*****
eq (cons (sem (comp (S n) O (succ false) nil (cons (proj (S n) O O) nil)) (cons v vnl) nil) (map (fun ne : BC => sem ne (cons v vnl) nil) (map (proj (S n) O) (seq (S O) n)))) (cons (cons false v) vnl)
+++++
f_equal.
-----
Lemma rec1_correct n s g h vnl vsl : length vnl = S n -> length vsl = s -> sem (rec1 n s g h) vnl vsl = sem_rec1 g h (hd nil vnl) (tl vnl) vsl.
Proof.
intros Hn Hs.
destruct vnl as [ | v vnl].
simpl in Hn.
induction v as [ | b v IH].
simpl sem_rec1.
simpl hd in IH.
simpl tl in IH.
rewrite <- IH.
clear IH.
unfold rec1.
case b.
rewrite sem_rec_false.
match goal with | |- context [sem (rec ?g ?h0 ?h1) ?vnl ?vsl] => set (e0 := sem (rec g h0 h1) vnl vsl) end.
rewrite sem_comp.
rewrite map_map.
f_equal.
rewrite map_cons.
f_equal.

*****
e0 : list bool
Hs : eq (length vsl) s
Hn : eq (S (length vnl)) (S n)
vnl,vsl : list (list bool)
v : list bool
b : bool
g,h : BC
n,s : nat
*****
eq (map (fun ne : BC => sem ne (cons v vnl) nil) (map (proj (S n) O) (seq (S O) n))) vnl
+++++
replace (S n) with (n+1) by omega.
-----
Lemma rec1_correct n s g h vnl vsl : length vnl = S n -> length vsl = s -> sem (rec1 n s g h) vnl vsl = sem_rec1 g h (hd nil vnl) (tl vnl) vsl.
Proof.
intros Hn Hs.
destruct vnl as [ | v vnl].
simpl in Hn.
induction v as [ | b v IH].
simpl sem_rec1.
simpl hd in IH.
simpl tl in IH.
rewrite <- IH.
clear IH.
unfold rec1.
case b.
rewrite sem_rec_false.
match goal with | |- context [sem (rec ?g ?h0 ?h1) ?vnl ?vsl] => set (e0 := sem (rec g h0 h1) vnl vsl) end.
rewrite sem_comp.
rewrite map_map.
f_equal.
rewrite map_cons.
f_equal.
replace (S n) with (n+1) by omega.

*****
e0 : list bool
Hs : eq (length vsl) s
Hn : eq (S (length vnl)) (S n)
vnl,vsl : list (list bool)
v : list bool
b : bool
g,h : BC
n,s : nat
*****
eq (map (fun ne : BC => sem ne (cons v vnl) nil) (map (proj (Init.Nat.add n (S O)) O) (seq (S O) n))) vnl
+++++
rewrite map_proj_seq_normal_gen.
-----
Lemma rec1_correct n s g h vnl vsl : length vnl = S n -> length vsl = s -> sem (rec1 n s g h) vnl vsl = sem_rec1 g h (hd nil vnl) (tl vnl) vsl.
Proof.
intros Hn Hs.
destruct vnl as [ | v vnl].
simpl in Hn.
induction v as [ | b v IH].
simpl sem_rec1.
simpl hd in IH.
simpl tl in IH.
rewrite <- IH.
clear IH.
unfold rec1.
case b.
rewrite sem_rec_false.
match goal with | |- context [sem (rec ?g ?h0 ?h1) ?vnl ?vsl] => set (e0 := sem (rec g h0 h1) vnl vsl) end.
rewrite sem_comp.
rewrite map_map.
f_equal.
rewrite map_cons.
f_equal.
replace (S n) with (n+1) by omega.
rewrite map_proj_seq_normal_gen.

*****
e0 : list bool
Hs : eq (length vsl) s
Hn : eq (S (length vnl)) (S n)
vnl,vsl : list (list bool)
v : list bool
b : bool
g,h : BC
n,s : nat
*****
eq (firstn n (skipn (S O) (cons v vnl))) vnl
+++++
idtac.
-----
Lemma rec1_correct n s g h vnl vsl : length vnl = S n -> length vsl = s -> sem (rec1 n s g h) vnl vsl = sem_rec1 g h (hd nil vnl) (tl vnl) vsl.
Proof.
intros Hn Hs.
destruct vnl as [ | v vnl].
simpl in Hn.
induction v as [ | b v IH].
simpl sem_rec1.
simpl hd in IH.
simpl tl in IH.
rewrite <- IH.
clear IH.
unfold rec1.
case b.
rewrite sem_rec_false.
match goal with | |- context [sem (rec ?g ?h0 ?h1) ?vnl ?vsl] => set (e0 := sem (rec g h0 h1) vnl vsl) end.
rewrite sem_comp.
rewrite map_map.
f_equal.
rewrite map_cons.
f_equal.
replace (S n) with (n+1) by omega.
rewrite map_proj_seq_normal_gen.
idtac.

*****
e0 : list bool
Hs : eq (length vsl) s
Hn : eq (S (length vnl)) (S n)
vnl,vsl : list (list bool)
v : list bool
b : bool
g,h : BC
n,s : nat
*****
eq (firstn n (skipn (S O) (cons v vnl))) vnl
+++++
erewrite firstn_map_nth by (simpl; omega).
-----
Lemma rec1_correct n s g h vnl vsl : length vnl = S n -> length vsl = s -> sem (rec1 n s g h) vnl vsl = sem_rec1 g h (hd nil vnl) (tl vnl) vsl.
Proof.
intros Hn Hs.
destruct vnl as [ | v vnl].
simpl in Hn.
induction v as [ | b v IH].
simpl sem_rec1.
simpl hd in IH.
simpl tl in IH.
rewrite <- IH.
clear IH.
unfold rec1.
case b.
rewrite sem_rec_false.
match goal with | |- context [sem (rec ?g ?h0 ?h1) ?vnl ?vsl] => set (e0 := sem (rec g h0 h1) vnl vsl) end.
rewrite sem_comp.
rewrite map_map.
f_equal.
rewrite map_cons.
f_equal.
replace (S n) with (n+1) by omega.
rewrite map_proj_seq_normal_gen.
idtac.
erewrite firstn_map_nth by (simpl; omega).

*****
e0 : list bool
Hs : eq (length vsl) s
Hn : eq (S (length vnl)) (S n)
vnl,vsl : list (list bool)
v : list bool
b : bool
g,h : BC
n,s : nat
*****
eq (map (fun i : nat => nth i (cons v vnl) ?d) (seq (S O) n)) vnl
+++++
instantiate (1:=nil).
-----
Lemma rec1_correct n s g h vnl vsl : length vnl = S n -> length vsl = s -> sem (rec1 n s g h) vnl vsl = sem_rec1 g h (hd nil vnl) (tl vnl) vsl.
Proof.
intros Hn Hs.
destruct vnl as [ | v vnl].
simpl in Hn.
induction v as [ | b v IH].
simpl sem_rec1.
simpl hd in IH.
simpl tl in IH.
rewrite <- IH.
clear IH.
unfold rec1.
case b.
rewrite sem_rec_false.
match goal with | |- context [sem (rec ?g ?h0 ?h1) ?vnl ?vsl] => set (e0 := sem (rec g h0 h1) vnl vsl) end.
rewrite sem_comp.
rewrite map_map.
f_equal.
rewrite map_cons.
f_equal.
replace (S n) with (n+1) by omega.
rewrite map_proj_seq_normal_gen.
idtac.
erewrite firstn_map_nth by (simpl; omega).
instantiate (1:=nil).

*****
e0 : list bool
Hs : eq (length vsl) s
Hn : eq (S (length vnl)) (S n)
vnl,vsl : list (list bool)
v : list bool
b : bool
g,h : BC
n,s : nat
*****
eq (map (fun i : nat => nth i (cons v vnl) nil) (seq (S O) n)) vnl
+++++
rewrite <- seq_shift.
-----
Lemma rec1_correct n s g h vnl vsl : length vnl = S n -> length vsl = s -> sem (rec1 n s g h) vnl vsl = sem_rec1 g h (hd nil vnl) (tl vnl) vsl.
Proof.
intros Hn Hs.
destruct vnl as [ | v vnl].
simpl in Hn.
induction v as [ | b v IH].
simpl sem_rec1.
simpl hd in IH.
simpl tl in IH.
rewrite <- IH.
clear IH.
unfold rec1.
case b.
rewrite sem_rec_false.
match goal with | |- context [sem (rec ?g ?h0 ?h1) ?vnl ?vsl] => set (e0 := sem (rec g h0 h1) vnl vsl) end.
rewrite sem_comp.
rewrite map_map.
f_equal.
rewrite map_cons.
f_equal.
replace (S n) with (n+1) by omega.
rewrite map_proj_seq_normal_gen.
idtac.
erewrite firstn_map_nth by (simpl; omega).
instantiate (1:=nil).
rewrite <- seq_shift.

*****
e0 : list bool
Hs : eq (length vsl) s
Hn : eq (S (length vnl)) (S n)
vnl,vsl : list (list bool)
v : list bool
b : bool
g,h : BC
n,s : nat
*****
eq (map (fun i : nat => nth i (cons v vnl) nil) (map S (seq O n))) vnl
+++++
rewrite map_map.
-----
Lemma rec1_correct n s g h vnl vsl : length vnl = S n -> length vsl = s -> sem (rec1 n s g h) vnl vsl = sem_rec1 g h (hd nil vnl) (tl vnl) vsl.
Proof.
intros Hn Hs.
destruct vnl as [ | v vnl].
simpl in Hn.
induction v as [ | b v IH].
simpl sem_rec1.
simpl hd in IH.
simpl tl in IH.
rewrite <- IH.
clear IH.
unfold rec1.
case b.
rewrite sem_rec_false.
match goal with | |- context [sem (rec ?g ?h0 ?h1) ?vnl ?vsl] => set (e0 := sem (rec g h0 h1) vnl vsl) end.
rewrite sem_comp.
rewrite map_map.
f_equal.
rewrite map_cons.
f_equal.
replace (S n) with (n+1) by omega.
rewrite map_proj_seq_normal_gen.
idtac.
erewrite firstn_map_nth by (simpl; omega).
instantiate (1:=nil).
rewrite <- seq_shift.
rewrite map_map.

*****
e0 : list bool
Hs : eq (length vsl) s
Hn : eq (S (length vnl)) (S n)
vnl,vsl : list (list bool)
v : list bool
b : bool
g,h : BC
n,s : nat
*****
eq (map (fun x : nat => nth (S x) (cons v vnl) nil) (seq O n)) vnl
+++++
simpl.
-----
Lemma rec1_correct n s g h vnl vsl : length vnl = S n -> length vsl = s -> sem (rec1 n s g h) vnl vsl = sem_rec1 g h (hd nil vnl) (tl vnl) vsl.
Proof.
intros Hn Hs.
destruct vnl as [ | v vnl].
simpl in Hn.
induction v as [ | b v IH].
simpl sem_rec1.
simpl hd in IH.
simpl tl in IH.
rewrite <- IH.
clear IH.
unfold rec1.
case b.
rewrite sem_rec_false.
match goal with | |- context [sem (rec ?g ?h0 ?h1) ?vnl ?vsl] => set (e0 := sem (rec g h0 h1) vnl vsl) end.
rewrite sem_comp.
rewrite map_map.
f_equal.
rewrite map_cons.
f_equal.
replace (S n) with (n+1) by omega.
rewrite map_proj_seq_normal_gen.
idtac.
erewrite firstn_map_nth by (simpl; omega).
instantiate (1:=nil).
rewrite <- seq_shift.
rewrite map_map.
simpl.

*****
e0 : list bool
Hs : eq (length vsl) s
Hn : eq (S (length vnl)) (S n)
vnl,vsl : list (list bool)
v : list bool
b : bool
g,h : BC
n,s : nat
*****
eq (map (fun x : nat => nth x vnl nil) (seq O n)) vnl
+++++
apply map_nth_seq.
-----
Lemma rec1_correct n s g h vnl vsl : length vnl = S n -> length vsl = s -> sem (rec1 n s g h) vnl vsl = sem_rec1 g h (hd nil vnl) (tl vnl) vsl.
Proof.
intros Hn Hs.
destruct vnl as [ | v vnl].
simpl in Hn.
induction v as [ | b v IH].
simpl sem_rec1.
simpl hd in IH.
simpl tl in IH.
rewrite <- IH.
clear IH.
unfold rec1.
case b.
rewrite sem_rec_false.
match goal with | |- context [sem (rec ?g ?h0 ?h1) ?vnl ?vsl] => set (e0 := sem (rec g h0 h1) vnl vsl) end.
rewrite sem_comp.
rewrite map_map.
f_equal.
rewrite map_cons.
f_equal.
replace (S n) with (n+1) by omega.
rewrite map_proj_seq_normal_gen.
idtac.
erewrite firstn_map_nth by (simpl; omega).
instantiate (1:=nil).
rewrite <- seq_shift.
rewrite map_map.
simpl.
apply map_nth_seq.

*****
e0 : list bool
Hs : eq (length vsl) s
Hn : eq (S (length vnl)) (S n)
vnl,vsl : list (list bool)
v : list bool
b : bool
g,h : BC
n,s : nat
*****
eq (length vnl) (Init.Nat.add n O)
+++++
omega.
-----
Lemma rec1_correct n s g h vnl vsl : length vnl = S n -> length vsl = s -> sem (rec1 n s g h) vnl vsl = sem_rec1 g h (hd nil vnl) (tl vnl) vsl.
Proof.
intros Hn Hs.
destruct vnl as [ | v vnl].
simpl in Hn.
induction v as [ | b v IH].
simpl sem_rec1.
simpl hd in IH.
simpl tl in IH.
rewrite <- IH.
clear IH.
unfold rec1.
case b.
rewrite sem_rec_false.
match goal with | |- context [sem (rec ?g ?h0 ?h1) ?vnl ?vsl] => set (e0 := sem (rec g h0 h1) vnl vsl) end.
rewrite sem_comp.
rewrite map_map.
f_equal.
rewrite map_cons.
f_equal.
replace (S n) with (n+1) by omega.
rewrite map_proj_seq_normal_gen.

*****
e0 : list bool
Hs : eq (length vsl) s
Hn : eq (S (length vnl)) (S n)
vnl,vsl : list (list bool)
v : list bool
b : bool
g,h : BC
n,s : nat
*****
le (Init.Nat.add n (S O)) (length (cons v vnl))
+++++
simpl.
-----
Lemma rec1_correct n s g h vnl vsl : length vnl = S n -> length vsl = s -> sem (rec1 n s g h) vnl vsl = sem_rec1 g h (hd nil vnl) (tl vnl) vsl.
Proof.
intros Hn Hs.
destruct vnl as [ | v vnl].
simpl in Hn.
induction v as [ | b v IH].
simpl sem_rec1.
simpl hd in IH.
simpl tl in IH.
rewrite <- IH.
clear IH.
unfold rec1.
case b.
rewrite sem_rec_false.
match goal with | |- context [sem (rec ?g ?h0 ?h1) ?vnl ?vsl] => set (e0 := sem (rec g h0 h1) vnl vsl) end.
rewrite sem_comp.
rewrite map_map.
f_equal.
rewrite map_cons.
f_equal.
replace (S n) with (n+1) by omega.
rewrite map_proj_seq_normal_gen.
simpl.

*****
e0 : list bool
Hs : eq (length vsl) s
Hn : eq (S (length vnl)) (S n)
vnl,vsl : list (list bool)
v : list bool
b : bool
g,h : BC
n,s : nat
*****
le (Init.Nat.add n (S O)) (S (length vnl))
+++++
omega .
-----
Lemma rec1_correct n s g h vnl vsl : length vnl = S n -> length vsl = s -> sem (rec1 n s g h) vnl vsl = sem_rec1 g h (hd nil vnl) (tl vnl) vsl.
Proof.
intros Hn Hs.
destruct vnl as [ | v vnl].
simpl in Hn.
induction v as [ | b v IH].
simpl sem_rec1.
simpl hd in IH.
simpl tl in IH.
rewrite <- IH.
clear IH.
unfold rec1.
case b.
rewrite sem_rec_false.
match goal with | |- context [sem (rec ?g ?h0 ?h1) ?vnl ?vsl] => set (e0 := sem (rec g h0 h1) vnl vsl) end.
rewrite sem_comp.
rewrite map_map.
f_equal.

*****
e0 : list bool
Hs : eq (length vsl) s
Hn : eq (S (length vnl)) (S n)
vnl,vsl : list (list bool)
v : list bool
b : bool
g,h : BC
n,s : nat
*****
eq (map (fun x : nat => sem (proj (S n) (S s) x) (cons v vnl) (cons e0 vsl)) (seq (S n) (S s))) (cons e0 vsl)
+++++
rewrite <- ( map_map (proj (S n) (S s)) (fun e => sem e (v :: vnl) (e0 :: vsl)) ).
-----
Lemma rec1_correct n s g h vnl vsl : length vnl = S n -> length vsl = s -> sem (rec1 n s g h) vnl vsl = sem_rec1 g h (hd nil vnl) (tl vnl) vsl.
Proof.
intros Hn Hs.
destruct vnl as [ | v vnl].
simpl in Hn.
induction v as [ | b v IH].
simpl sem_rec1.
simpl hd in IH.
simpl tl in IH.
rewrite <- IH.
clear IH.
unfold rec1.
case b.
rewrite sem_rec_false.
match goal with | |- context [sem (rec ?g ?h0 ?h1) ?vnl ?vsl] => set (e0 := sem (rec g h0 h1) vnl vsl) end.
rewrite sem_comp.
rewrite map_map.
f_equal.
rewrite <- ( map_map (proj (S n) (S s)) (fun e => sem e (v :: vnl) (e0 :: vsl)) ).

*****
e0 : list bool
Hs : eq (length vsl) s
Hn : eq (S (length vnl)) (S n)
vnl,vsl : list (list bool)
v : list bool
b : bool
g,h : BC
n,s : nat
*****
eq (map (fun e : BC => sem e (cons v vnl) (cons e0 vsl)) (map (proj (S n) (S s)) (seq (S n) (S s)))) (cons e0 vsl)
+++++
rewrite map_proj_seq_safe.
-----
Lemma rec1_correct n s g h vnl vsl : length vnl = S n -> length vsl = s -> sem (rec1 n s g h) vnl vsl = sem_rec1 g h (hd nil vnl) (tl vnl) vsl.
Proof.
intros Hn Hs.
destruct vnl as [ | v vnl].
simpl in Hn.
induction v as [ | b v IH].
simpl sem_rec1.
simpl hd in IH.
simpl tl in IH.
rewrite <- IH.
clear IH.
unfold rec1.
case b.
rewrite sem_rec_false.
match goal with | |- context [sem (rec ?g ?h0 ?h1) ?vnl ?vsl] => set (e0 := sem (rec g h0 h1) vnl vsl) end.
rewrite sem_comp.
rewrite map_map.
f_equal.
rewrite <- ( map_map (proj (S n) (S s)) (fun e => sem e (v :: vnl) (e0 :: vsl)) ).
rewrite map_proj_seq_safe.

*****
e0 : list bool
Hs : eq (length vsl) s
Hn : eq (S (length vnl)) (S n)
vnl,vsl : list (list bool)
v : list bool
b : bool
g,h : BC
n,s : nat
*****
eq (app (firstn (S s) (cons e0 vsl)) (repeat (Init.Nat.sub (S s) (length (cons e0 vsl))) nil)) (cons e0 vsl)
+++++
simpl.
-----
Lemma rec1_correct n s g h vnl vsl : length vnl = S n -> length vsl = s -> sem (rec1 n s g h) vnl vsl = sem_rec1 g h (hd nil vnl) (tl vnl) vsl.
Proof.
intros Hn Hs.
destruct vnl as [ | v vnl].
simpl in Hn.
induction v as [ | b v IH].
simpl sem_rec1.
simpl hd in IH.
simpl tl in IH.
rewrite <- IH.
clear IH.
unfold rec1.
case b.
rewrite sem_rec_false.
match goal with | |- context [sem (rec ?g ?h0 ?h1) ?vnl ?vsl] => set (e0 := sem (rec g h0 h1) vnl vsl) end.
rewrite sem_comp.
rewrite map_map.
f_equal.
rewrite <- ( map_map (proj (S n) (S s)) (fun e => sem e (v :: vnl) (e0 :: vsl)) ).
rewrite map_proj_seq_safe.
simpl.

*****
e0 : list bool
Hs : eq (length vsl) s
Hn : eq (S (length vnl)) (S n)
vnl,vsl : list (list bool)
v : list bool
b : bool
g,h : BC
n,s : nat
*****
eq (cons e0 (app (firstn s vsl) (repeat (Init.Nat.sub s (length vsl)) nil))) (cons e0 vsl)
+++++
f_equal.
-----
Lemma rec1_correct n s g h vnl vsl : length vnl = S n -> length vsl = s -> sem (rec1 n s g h) vnl vsl = sem_rec1 g h (hd nil vnl) (tl vnl) vsl.
Proof.
intros Hn Hs.
destruct vnl as [ | v vnl].
simpl in Hn.
induction v as [ | b v IH].
simpl sem_rec1.
simpl hd in IH.
simpl tl in IH.
rewrite <- IH.
clear IH.
unfold rec1.
case b.
rewrite sem_rec_false.
match goal with | |- context [sem (rec ?g ?h0 ?h1) ?vnl ?vsl] => set (e0 := sem (rec g h0 h1) vnl vsl) end.
rewrite sem_comp.
rewrite map_map.
f_equal.
rewrite <- ( map_map (proj (S n) (S s)) (fun e => sem e (v :: vnl) (e0 :: vsl)) ).
rewrite map_proj_seq_safe.
simpl.
f_equal.

*****
e0 : list bool
Hs : eq (length vsl) s
Hn : eq (S (length vnl)) (S n)
vnl,vsl : list (list bool)
v : list bool
b : bool
g,h : BC
n,s : nat
*****
eq (app (firstn s vsl) (repeat (Init.Nat.sub s (length vsl)) nil)) vsl
+++++
subst s.
-----
Lemma rec1_correct n s g h vnl vsl : length vnl = S n -> length vsl = s -> sem (rec1 n s g h) vnl vsl = sem_rec1 g h (hd nil vnl) (tl vnl) vsl.
Proof.
intros Hn Hs.
destruct vnl as [ | v vnl].
simpl in Hn.
induction v as [ | b v IH].
simpl sem_rec1.
simpl hd in IH.
simpl tl in IH.
rewrite <- IH.
clear IH.
unfold rec1.
case b.
rewrite sem_rec_false.
match goal with | |- context [sem (rec ?g ?h0 ?h1) ?vnl ?vsl] => set (e0 := sem (rec g h0 h1) vnl vsl) end.
rewrite sem_comp.
rewrite map_map.
f_equal.
rewrite <- ( map_map (proj (S n) (S s)) (fun e => sem e (v :: vnl) (e0 :: vsl)) ).
rewrite map_proj_seq_safe.
simpl.
f_equal.
subst s.

*****
e0 : list bool
Hn : eq (S (length vnl)) (S n)
vnl,vsl : list (list bool)
v : list bool
b : bool
g,h : BC
n : nat
*****
eq (app (firstn (length vsl) vsl) (repeat (Init.Nat.sub (length vsl) (length vsl)) nil)) vsl
+++++
rewrite minus_diag.
-----
Lemma rec1_correct n s g h vnl vsl : length vnl = S n -> length vsl = s -> sem (rec1 n s g h) vnl vsl = sem_rec1 g h (hd nil vnl) (tl vnl) vsl.
Proof.
intros Hn Hs.
destruct vnl as [ | v vnl].
simpl in Hn.
induction v as [ | b v IH].
simpl sem_rec1.
simpl hd in IH.
simpl tl in IH.
rewrite <- IH.
clear IH.
unfold rec1.
case b.
rewrite sem_rec_false.
match goal with | |- context [sem (rec ?g ?h0 ?h1) ?vnl ?vsl] => set (e0 := sem (rec g h0 h1) vnl vsl) end.
rewrite sem_comp.
rewrite map_map.
f_equal.
rewrite <- ( map_map (proj (S n) (S s)) (fun e => sem e (v :: vnl) (e0 :: vsl)) ).
rewrite map_proj_seq_safe.
simpl.
f_equal.
subst s.
rewrite minus_diag.

*****
e0 : list bool
Hn : eq (S (length vnl)) (S n)
vnl,vsl : list (list bool)
v : list bool
b : bool
g,h : BC
n : nat
*****
eq (app (firstn (length vsl) vsl) (repeat O nil)) vsl
+++++
simpl.
-----
Lemma rec1_correct n s g h vnl vsl : length vnl = S n -> length vsl = s -> sem (rec1 n s g h) vnl vsl = sem_rec1 g h (hd nil vnl) (tl vnl) vsl.
Proof.
intros Hn Hs.
destruct vnl as [ | v vnl].
simpl in Hn.
induction v as [ | b v IH].
simpl sem_rec1.
simpl hd in IH.
simpl tl in IH.
rewrite <- IH.
clear IH.
unfold rec1.
case b.
rewrite sem_rec_false.
match goal with | |- context [sem (rec ?g ?h0 ?h1) ?vnl ?vsl] => set (e0 := sem (rec g h0 h1) vnl vsl) end.
rewrite sem_comp.
rewrite map_map.
f_equal.
rewrite <- ( map_map (proj (S n) (S s)) (fun e => sem e (v :: vnl) (e0 :: vsl)) ).
rewrite map_proj_seq_safe.
simpl.
f_equal.
subst s.
rewrite minus_diag.
simpl.

*****
e0 : list bool
Hn : eq (S (length vnl)) (S n)
vnl,vsl : list (list bool)
v : list bool
b : bool
g,h : BC
n : nat
*****
eq (app (firstn (length vsl) vsl) nil) vsl
+++++
rewrite app_nil_r.
-----
Lemma rec1_correct n s g h vnl vsl : length vnl = S n -> length vsl = s -> sem (rec1 n s g h) vnl vsl = sem_rec1 g h (hd nil vnl) (tl vnl) vsl.
Proof.
intros Hn Hs.
destruct vnl as [ | v vnl].
simpl in Hn.
induction v as [ | b v IH].
simpl sem_rec1.
simpl hd in IH.
simpl tl in IH.
rewrite <- IH.
clear IH.
unfold rec1.
case b.
rewrite sem_rec_false.
match goal with | |- context [sem (rec ?g ?h0 ?h1) ?vnl ?vsl] => set (e0 := sem (rec g h0 h1) vnl vsl) end.
rewrite sem_comp.
rewrite map_map.
f_equal.
rewrite <- ( map_map (proj (S n) (S s)) (fun e => sem e (v :: vnl) (e0 :: vsl)) ).
rewrite map_proj_seq_safe.
simpl.
f_equal.
subst s.
rewrite minus_diag.
simpl.
rewrite app_nil_r.

*****
e0 : list bool
Hn : eq (S (length vnl)) (S n)
vnl,vsl : list (list bool)
v : list bool
b : bool
g,h : BC
n : nat
*****
eq (firstn (length vsl) vsl) vsl
+++++
rewrite <- (app_nil_r vsl) at 2.
-----
Lemma rec1_correct n s g h vnl vsl : length vnl = S n -> length vsl = s -> sem (rec1 n s g h) vnl vsl = sem_rec1 g h (hd nil vnl) (tl vnl) vsl.
Proof.
intros Hn Hs.
destruct vnl as [ | v vnl].
simpl in Hn.
induction v as [ | b v IH].
simpl sem_rec1.
simpl hd in IH.
simpl tl in IH.
rewrite <- IH.
clear IH.
unfold rec1.
case b.
rewrite sem_rec_false.
match goal with | |- context [sem (rec ?g ?h0 ?h1) ?vnl ?vsl] => set (e0 := sem (rec g h0 h1) vnl vsl) end.
rewrite sem_comp.
rewrite map_map.
f_equal.
rewrite <- ( map_map (proj (S n) (S s)) (fun e => sem e (v :: vnl) (e0 :: vsl)) ).
rewrite map_proj_seq_safe.
simpl.
f_equal.
subst s.
rewrite minus_diag.
simpl.
rewrite app_nil_r.
rewrite <- (app_nil_r vsl) at 2.

*****
e0 : list bool
Hn : eq (S (length vnl)) (S n)
vnl,vsl : list (list bool)
v : list bool
b : bool
g,h : BC
n : nat
*****
eq (firstn (length vsl) (app vsl nil)) vsl
+++++
apply firstn_app.
-----
Lemma rec1_correct n s g h vnl vsl : length vnl = S n -> length vsl = s -> sem (rec1 n s g h) vnl vsl = sem_rec1 g h (hd nil vnl) (tl vnl) vsl.
Proof.
intros Hn Hs.
destruct vnl as [ | v vnl].

*****

*****

+++++
Qed.
-----
Definition rec3 n s x g h : BC :=\n  comp n s\n    (rec1 n s g h)\n    (x ::\n     map (proj n 0) (seq 0 n))\n    (map (proj n s) (seq n s)).
-----
Lemma arities_rec3 n s x g h\n  (Hx : arities x = ok_arities n 0)\n  (Hg : arities g = ok_arities n s)\n  (Hh : arities h = ok_arities (S n) (S s)) :\n  arities (rec3 n s x g h) = ok_arities n s.
-----
Lemma arities_rec3 n s x g h (Hx : arities x = ok_arities n 0) (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec3 n s x g h) = ok_arities n s.

*****
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n O)
x,g,h : BC
n,s : nat
*****
eq (arities (rec3 n s x g h)) (ok_arities n s)
+++++
Proof.
-----
Lemma arities_rec3 n s x g h (Hx : arities x = ok_arities n 0) (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec3 n s x g h) = ok_arities n s.
Proof.

*****
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n O)
x,g,h : BC
n,s : nat
*****
eq (arities (rec3 n s x g h)) (ok_arities n s)
+++++
simpl.
-----
Lemma arities_rec3 n s x g h (Hx : arities x = ok_arities n 0) (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec3 n s x g h) = ok_arities n s.
Proof.
simpl.

*****
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n O)
x,g,h : BC
n,s : nat
*****
eq match match arities g with | error_rec a a0 a1 => error_rec (error_rec a a0 a1) match arities h with | error_rec a2 a3 a4 => error_comp (error_rec a2 a3 a4) (cons (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s)))) | error_comp a2 l l0 => error_comp (error_comp a2 l l0) (cons (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s)))) | error_proj n0 n1 n2 => error_comp (error_proj n0 n1 n2) (cons (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s)))) | ok_arities hn hs => if andb (andb (andb (Nat.eqb hn (S (length (map (proj (S n) O) (seq (S O) n))))) (Nat.eqb hs (S (length (map (proj (S n) (S s)) (seq (S (S n)) s)))))) (andb (aeq (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (ok_arities (S n) O)) (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O)) (map (proj (S n) O) (seq (S O) n))))) (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities hn hs) (cons (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s)))) end match arities h with | error_rec a2 a3 a4 => error_comp (error_rec a2 a3 a4) (cons (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s)))) | error_comp a2 l l0 => error_comp (error_comp a2 l l0) (cons (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s)))) | error_proj n0 n1 n2 => error_comp (error_proj n0 n1 n2) (cons (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s)))) | ok_arities hn hs => if andb (andb (andb (Nat.eqb hn (S (length (map (proj (S n) O) (seq (S O) n))))) (Nat.eqb hs (S (length (map (proj (S n) (S s)) (seq (S (S n)) s)))))) (andb (aeq (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (ok_arities (S n) O)) (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O)) (map (proj (S n) O) (seq (S O) n))))) (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities hn hs) (cons (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s)))) end | error_comp a l l0 => error_rec (error_comp a l l0) match arities h with | error_rec a0 a1 a2 => error_comp (error_rec a0 a1 a2) (cons (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s)))) | error_comp a0 l1 l2 => error_comp (error_comp a0 l1 l2) (cons (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s)))) | error_proj n0 n1 n2 => error_comp (error_proj n0 n1 n2) (cons (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s)))) | ok_arities hn hs => if andb (andb (andb (Nat.eqb hn (S (length (map (proj (S n) O) (seq (S O) n))))) (Nat.eqb hs (S (length (map (proj (S n) (S s)) (seq (S (S n)) s)))))) (andb (aeq (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (ok_arities (S n) O)) (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O)) (map (proj (S n) O) (seq (S O) n))))) (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities hn hs) (cons (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s)))) end match arities h with | error_rec a0 a1 a2 => error_comp (error_rec a0 a1 a2) (cons (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s)))) | error_comp a0 l1 l2 => error_comp (error_comp a0 l1 l2) (cons (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s)))) | error_proj n0 n1 n2 => error_comp (error_proj n0 n1 n2) (cons (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s)))) | ok_arities hn hs => if andb (andb (andb (Nat.eqb hn (S (length (map (proj (S n) O) (seq (S O) n))))) (Nat.eqb hs (S (length (map (proj (S n) (S s)) (seq (S (S n)) s)))))) (andb (aeq (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (ok_arities (S n) O)) (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O)) (map (proj (S n) O) (seq (S O) n))))) (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities hn hs) (cons (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s)))) end | error_proj n0 n1 n2 => error_rec (error_proj n0 n1 n2) match arities h with | error_rec a a0 a1 => error_comp (error_rec a a0 a1) (cons (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s)))) | error_comp a l l0 => error_comp (error_comp a l l0) (cons (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s)))) | error_proj n3 n4 n5 => error_comp (error_proj n3 n4 n5) (cons (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s)))) | ok_arities hn hs => if andb (andb (andb (Nat.eqb hn (S (length (map (proj (S n) O) (seq (S O) n))))) (Nat.eqb hs (S (length (map (proj (S n) (S s)) (seq (S (S n)) s)))))) (andb (aeq (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (ok_arities (S n) O)) (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O)) (map (proj (S n) O) (seq (S O) n))))) (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities hn hs) (cons (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s)))) end match arities h with | error_rec a a0 a1 => error_comp (error_rec a a0 a1) (cons (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s)))) | error_comp a l l0 => error_comp (error_comp a l l0) (cons (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s)))) | error_proj n3 n4 n5 => error_comp (error_proj n3 n4 n5) (cons (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s)))) | ok_arities hn hs => if andb (andb (andb (Nat.eqb hn (S (length (map (proj (S n) O) (seq (S O) n))))) (Nat.eqb hs (S (length (map (proj (S n) (S s)) (seq (S (S n)) s)))))) (andb (aeq (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (ok_arities (S n) O)) (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O)) (map (proj (S n) O) (seq (S O) n))))) (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities hn hs) (cons (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s)))) end | ok_arities gn gs => match match arities h with | error_rec a a0 a1 => error_comp (error_rec a a0 a1) (cons (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s)))) | error_comp a l l0 => error_comp (error_comp a l l0) (cons (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s)))) | error_proj n0 n1 n2 => error_comp (error_proj n0 n1 n2) (cons (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s)))) | ok_arities hn hs => if andb (andb (andb (Nat.eqb hn (S (length (map (proj (S n) O) (seq (S O) n))))) (Nat.eqb hs (S (length (map (proj (S n) (S s)) (seq (S (S n)) s)))))) (andb (aeq (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (ok_arities (S n) O)) (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O)) (map (proj (S n) O) (seq (S O) n))))) (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities hn hs) (cons (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s)))) end with | error_rec a a0 a1 => error_rec (ok_arities gn gs) (error_rec a a0 a1) match arities h with | error_rec a2 a3 a4 => error_comp (error_rec a2 a3 a4) (cons (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s)))) | error_comp a2 l l0 => error_comp (error_comp a2 l l0) (cons (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s)))) | error_proj n0 n1 n2 => error_comp (error_proj n0 n1 n2) (cons (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s)))) | ok_arities hn hs => if andb (andb (andb (Nat.eqb hn (S (length (map (proj (S n) O) (seq (S O) n))))) (Nat.eqb hs (S (length (map (proj (S n) (S s)) (seq (S (S n)) s)))))) (andb (aeq (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (ok_arities (S n) O)) (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O)) (map (proj (S n) O) (seq (S O) n))))) (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities hn hs) (cons (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s)))) end | error_comp a l l0 => error_rec (ok_arities gn gs) (error_comp a l l0) match arities h with | error_rec a0 a1 a2 => error_comp (error_rec a0 a1 a2) (cons (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s)))) | error_comp a0 l1 l2 => error_comp (error_comp a0 l1 l2) (cons (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s)))) | error_proj n0 n1 n2 => error_comp (error_proj n0 n1 n2) (cons (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s)))) | ok_arities hn hs => if andb (andb (andb (Nat.eqb hn (S (length (map (proj (S n) O) (seq (S O) n))))) (Nat.eqb hs (S (length (map (proj (S n) (S s)) (seq (S (S n)) s)))))) (andb (aeq (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (ok_arities (S n) O)) (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O)) (map (proj (S n) O) (seq (S O) n))))) (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities hn hs) (cons (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s)))) end | error_proj n0 n1 n2 => error_rec (ok_arities gn gs) (error_proj n0 n1 n2) match arities h with | error_rec a a0 a1 => error_comp (error_rec a a0 a1) (cons (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s)))) | error_comp a l l0 => error_comp (error_comp a l l0) (cons (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s)))) | error_proj n3 n4 n5 => error_comp (error_proj n3 n4 n5) (cons (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s)))) | ok_arities hn hs => if andb (andb (andb (Nat.eqb hn (S (length (map (proj (S n) O) (seq (S O) n))))) (Nat.eqb hs (S (length (map (proj (S n) (S s)) (seq (S (S n)) s)))))) (andb (aeq (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (ok_arities (S n) O)) (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O)) (map (proj (S n) O) (seq (S O) n))))) (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities hn hs) (cons (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s)))) end | ok_arities h0n h0s => match match arities h with | error_rec a a0 a1 => error_comp (error_rec a a0 a1) (cons (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s)))) | error_comp a l l0 => error_comp (error_comp a l l0) (cons (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s)))) | error_proj n0 n1 n2 => error_comp (error_proj n0 n1 n2) (cons (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s)))) | ok_arities hn hs => if andb (andb (andb (Nat.eqb hn (S (length (map (proj (S n) O) (seq (S O) n))))) (Nat.eqb hs (S (length (map (proj (S n) (S s)) (seq (S (S n)) s)))))) (andb (aeq (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (ok_arities (S n) O)) (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O)) (map (proj (S n) O) (seq (S O) n))))) (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities hn hs) (cons (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s)))) end with | error_rec a a0 a1 => error_rec (ok_arities gn gs) (ok_arities h0n h0s) (error_rec a a0 a1) | error_comp a l l0 => error_rec (ok_arities gn gs) (ok_arities h0n h0s) (error_comp a l l0) | error_proj n n0 n1 => error_rec (ok_arities gn gs) (ok_arities h0n h0s) (error_proj n n0 n1) | ok_arities h1n h1s => if andb (andb (andb match h0n with | O => false | S m' => Nat.eqb gn m' end (Nat.eqb h0n h1n)) match h0s with | O => false | S m' => Nat.eqb gs m' end) (Nat.eqb h0s h1s) then ok_arities h0n gs else error_rec (ok_arities gn gs) (ok_arities h0n h0s) (ok_arities h1n h1s) end end end with | error_rec a a0 a1 => error_comp (error_rec a a0 a1) (cons (arities x) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s))) | error_comp a l l0 => error_comp (error_comp a l l0) (cons (arities x) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s))) | error_proj n0 n1 n2 => error_comp (error_proj n0 n1 n2) (cons (arities x) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s))) | ok_arities hn hs => if andb (andb (andb (Nat.eqb hn (S (length (map (proj n O) (seq O n))))) (Nat.eqb hs (length (map (proj n s) (seq n s))))) (andb (aeq (arities x) (ok_arities n O)) (forallb (fun ne : BC => aeq (arities ne) (ok_arities n O)) (map (proj n O) (seq O n))))) (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s))) then ok_arities n s else error_comp (ok_arities hn hs) (cons (arities x) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s))) end (ok_arities n s)
+++++
rewrite Hx, Hg, Hh.
-----
Lemma arities_rec3 n s x g h (Hx : arities x = ok_arities n 0) (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec3 n s x g h) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh.

*****
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n O)
x,g,h : BC
n,s : nat
*****
eq match match (if andb (andb (andb (Nat.eqb (S n) (S (length (map (proj (S n) O) (seq (S O) n))))) (Nat.eqb (S s) (S (length (map (proj (S n) (S s)) (seq (S (S n)) s)))))) (andb (aeq (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (ok_arities (S n) O)) (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O)) (map (proj (S n) O) (seq (S O) n))))) (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) with | error_rec a a0 a1 => error_rec (ok_arities n s) (error_rec a a0 a1) (if andb (andb (andb (Nat.eqb (S n) (S (length (map (proj (S n) O) (seq (S O) n))))) (Nat.eqb (S s) (S (length (map (proj (S n) (S s)) (seq (S (S n)) s)))))) (andb (aeq (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (ok_arities (S n) O)) (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O)) (map (proj (S n) O) (seq (S O) n))))) (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | error_comp a l l0 => error_rec (ok_arities n s) (error_comp a l l0) (if andb (andb (andb (Nat.eqb (S n) (S (length (map (proj (S n) O) (seq (S O) n))))) (Nat.eqb (S s) (S (length (map (proj (S n) (S s)) (seq (S (S n)) s)))))) (andb (aeq (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (ok_arities (S n) O)) (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O)) (map (proj (S n) O) (seq (S O) n))))) (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | error_proj n0 n1 n2 => error_rec (ok_arities n s) (error_proj n0 n1 n2) (if andb (andb (andb (Nat.eqb (S n) (S (length (map (proj (S n) O) (seq (S O) n))))) (Nat.eqb (S s) (S (length (map (proj (S n) (S s)) (seq (S (S n)) s)))))) (andb (aeq (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (ok_arities (S n) O)) (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O)) (map (proj (S n) O) (seq (S O) n))))) (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | ok_arities h0n h0s => match (if andb (andb (andb (Nat.eqb (S n) (S (length (map (proj (S n) O) (seq (S O) n))))) (Nat.eqb (S s) (S (length (map (proj (S n) (S s)) (seq (S (S n)) s)))))) (andb (aeq (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (ok_arities (S n) O)) (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O)) (map (proj (S n) O) (seq (S O) n))))) (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) with | error_rec a a0 a1 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_rec a a0 a1) | error_comp a l l0 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_comp a l l0) | error_proj n0 n1 n2 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_proj n0 n1 n2) | ok_arities h1n h1s => if andb (andb (andb match h0n with | O => false | S m' => Nat.eqb n m' end (Nat.eqb h0n h1n)) match h0s with | O => false | S m' => Nat.eqb s m' end) (Nat.eqb h0s h1s) then ok_arities h0n s else error_rec (ok_arities n s) (ok_arities h0n h0s) (ok_arities h1n h1s) end end with | error_rec a a0 a1 => error_comp (error_rec a a0 a1) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s))) | error_comp a l l0 => error_comp (error_comp a l l0) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s))) | error_proj n0 n1 n2 => error_comp (error_proj n0 n1 n2) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s))) | ok_arities hn hs => if andb (andb (andb (Nat.eqb hn (S (length (map (proj n O) (seq O n))))) (Nat.eqb hs (length (map (proj n s) (seq n s))))) (andb (aeq (ok_arities n O) (ok_arities n O)) (forallb (fun ne : BC => aeq (arities ne) (ok_arities n O)) (map (proj n O) (seq O n))))) (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s))) then ok_arities n s else error_comp (ok_arities hn hs) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s))) end (ok_arities n s)
+++++
simpl.
-----
Lemma arities_rec3 n s x g h (Hx : arities x = ok_arities n 0) (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec3 n s x g h) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh.
simpl.

*****
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n O)
x,g,h : BC
n,s : nat
*****
eq match match (if andb (andb (andb (Nat.eqb n (length (map (proj (S n) O) (seq (S O) n)))) (Nat.eqb s (length (map (proj (S n) (S s)) (seq (S (S n)) s))))) (andb (aeq (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (ok_arities (S n) O)) (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O)) (map (proj (S n) O) (seq (S O) n))))) (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) with | error_rec a a0 a1 => error_rec (ok_arities n s) (error_rec a a0 a1) (if andb (andb (andb (Nat.eqb n (length (map (proj (S n) O) (seq (S O) n)))) (Nat.eqb s (length (map (proj (S n) (S s)) (seq (S (S n)) s))))) (andb (aeq (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (ok_arities (S n) O)) (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O)) (map (proj (S n) O) (seq (S O) n))))) (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | error_comp a l l0 => error_rec (ok_arities n s) (error_comp a l l0) (if andb (andb (andb (Nat.eqb n (length (map (proj (S n) O) (seq (S O) n)))) (Nat.eqb s (length (map (proj (S n) (S s)) (seq (S (S n)) s))))) (andb (aeq (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (ok_arities (S n) O)) (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O)) (map (proj (S n) O) (seq (S O) n))))) (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | error_proj n0 n1 n2 => error_rec (ok_arities n s) (error_proj n0 n1 n2) (if andb (andb (andb (Nat.eqb n (length (map (proj (S n) O) (seq (S O) n)))) (Nat.eqb s (length (map (proj (S n) (S s)) (seq (S (S n)) s))))) (andb (aeq (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (ok_arities (S n) O)) (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O)) (map (proj (S n) O) (seq (S O) n))))) (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | ok_arities h0n h0s => match (if andb (andb (andb (Nat.eqb n (length (map (proj (S n) O) (seq (S O) n)))) (Nat.eqb s (length (map (proj (S n) (S s)) (seq (S (S n)) s))))) (andb (aeq (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (ok_arities (S n) O)) (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O)) (map (proj (S n) O) (seq (S O) n))))) (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) with | error_rec a a0 a1 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_rec a a0 a1) | error_comp a l l0 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_comp a l l0) | error_proj n0 n1 n2 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_proj n0 n1 n2) | ok_arities h1n h1s => if andb (andb (andb match h0n with | O => false | S m' => Nat.eqb n m' end (Nat.eqb h0n h1n)) match h0s with | O => false | S m' => Nat.eqb s m' end) (Nat.eqb h0s h1s) then ok_arities h0n s else error_rec (ok_arities n s) (ok_arities h0n h0s) (ok_arities h1n h1s) end end with | error_rec a a0 a1 => error_comp (error_rec a a0 a1) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s))) | error_comp a l l0 => error_comp (error_comp a l l0) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s))) | error_proj n0 n1 n2 => error_comp (error_proj n0 n1 n2) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s))) | ok_arities hn hs => if andb (andb (andb (Nat.eqb hn (S (length (map (proj n O) (seq O n))))) (Nat.eqb hs (length (map (proj n s) (seq n s))))) (andb (andb (Nat.eqb n n) true) (forallb (fun ne : BC => aeq (arities ne) (ok_arities n O)) (map (proj n O) (seq O n))))) (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s))) then ok_arities n s else error_comp (ok_arities hn hs) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s))) end (ok_arities n s)
+++++
do 4 rewrite map_length, seq_length.
-----
Lemma arities_rec3 n s x g h (Hx : arities x = ok_arities n 0) (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec3 n s x g h) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh.
simpl.
do 4 rewrite map_length, seq_length.

*****
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n O)
x,g,h : BC
n,s : nat
*****
eq match match (if andb (andb (andb (Nat.eqb n n) (Nat.eqb s s)) (andb (aeq (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (ok_arities (S n) O)) (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O)) (map (proj (S n) O) (seq (S O) n))))) (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) with | error_rec a a0 a1 => error_rec (ok_arities n s) (error_rec a a0 a1) (if andb (andb (andb (Nat.eqb n n) (Nat.eqb s s)) (andb (aeq (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (ok_arities (S n) O)) (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O)) (map (proj (S n) O) (seq (S O) n))))) (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | error_comp a l l0 => error_rec (ok_arities n s) (error_comp a l l0) (if andb (andb (andb (Nat.eqb n n) (Nat.eqb s s)) (andb (aeq (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (ok_arities (S n) O)) (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O)) (map (proj (S n) O) (seq (S O) n))))) (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | error_proj n0 n1 n2 => error_rec (ok_arities n s) (error_proj n0 n1 n2) (if andb (andb (andb (Nat.eqb n n) (Nat.eqb s s)) (andb (aeq (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (ok_arities (S n) O)) (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O)) (map (proj (S n) O) (seq (S O) n))))) (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | ok_arities h0n h0s => match (if andb (andb (andb (Nat.eqb n n) (Nat.eqb s s)) (andb (aeq (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (ok_arities (S n) O)) (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O)) (map (proj (S n) O) (seq (S O) n))))) (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (if andb (andb (Nat.eqb n n) true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) with | error_rec a a0 a1 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_rec a a0 a1) | error_comp a l l0 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_comp a l l0) | error_proj n0 n1 n2 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_proj n0 n1 n2) | ok_arities h1n h1s => if andb (andb (andb match h0n with | O => false | S m' => Nat.eqb n m' end (Nat.eqb h0n h1n)) match h0s with | O => false | S m' => Nat.eqb s m' end) (Nat.eqb h0s h1s) then ok_arities h0n s else error_rec (ok_arities n s) (ok_arities h0n h0s) (ok_arities h1n h1s) end end with | error_rec a a0 a1 => error_comp (error_rec a a0 a1) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s))) | error_comp a l l0 => error_comp (error_comp a l l0) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s))) | error_proj n0 n1 n2 => error_comp (error_proj n0 n1 n2) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s))) | ok_arities hn hs => if andb (andb (andb (Nat.eqb hn (S n)) (Nat.eqb hs s)) (andb (andb (Nat.eqb n n) true) (forallb (fun ne : BC => aeq (arities ne) (ok_arities n O)) (map (proj n O) (seq O n))))) (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s))) then ok_arities n s else error_comp (ok_arities hn hs) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s))) end (ok_arities n s)
+++++
do 2 rewrite <- beq_nat_refl.
-----
Lemma arities_rec3 n s x g h (Hx : arities x = ok_arities n 0) (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec3 n s x g h) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh.
simpl.
do 4 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.

*****
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n O)
x,g,h : BC
n,s : nat
*****
eq match match (if andb (andb (andb true true) (andb (aeq (if andb (andb true true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (ok_arities (S n) O)) (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O)) (map (proj (S n) O) (seq (S O) n))))) (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (if andb (andb true true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) with | error_rec a a0 a1 => error_rec (ok_arities n s) (error_rec a a0 a1) (if andb (andb (andb true true) (andb (aeq (if andb (andb true true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (ok_arities (S n) O)) (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O)) (map (proj (S n) O) (seq (S O) n))))) (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (if andb (andb true true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | error_comp a l l0 => error_rec (ok_arities n s) (error_comp a l l0) (if andb (andb (andb true true) (andb (aeq (if andb (andb true true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (ok_arities (S n) O)) (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O)) (map (proj (S n) O) (seq (S O) n))))) (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (if andb (andb true true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | error_proj n0 n1 n2 => error_rec (ok_arities n s) (error_proj n0 n1 n2) (if andb (andb (andb true true) (andb (aeq (if andb (andb true true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (ok_arities (S n) O)) (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O)) (map (proj (S n) O) (seq (S O) n))))) (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (if andb (andb true true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | ok_arities h0n h0s => match (if andb (andb (andb true true) (andb (aeq (if andb (andb true true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (ok_arities (S n) O)) (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O)) (map (proj (S n) O) (seq (S O) n))))) (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (if andb (andb true true) true then ok_arities (S n) O else error_comp (ok_arities O (S O)) nil (cons (ok_arities (S n) O) nil)) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) with | error_rec a a0 a1 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_rec a a0 a1) | error_comp a l l0 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_comp a l l0) | error_proj n0 n1 n2 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_proj n0 n1 n2) | ok_arities h1n h1s => if andb (andb (andb match h0n with | O => false | S m' => Nat.eqb n m' end (Nat.eqb h0n h1n)) match h0s with | O => false | S m' => Nat.eqb s m' end) (Nat.eqb h0s h1s) then ok_arities h0n s else error_rec (ok_arities n s) (ok_arities h0n h0s) (ok_arities h1n h1s) end end with | error_rec a a0 a1 => error_comp (error_rec a a0 a1) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s))) | error_comp a l l0 => error_comp (error_comp a l l0) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s))) | error_proj n0 n1 n2 => error_comp (error_proj n0 n1 n2) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s))) | ok_arities hn hs => if andb (andb (andb (Nat.eqb hn (S n)) (Nat.eqb hs s)) (andb (andb true true) (forallb (fun ne : BC => aeq (arities ne) (ok_arities n O)) (map (proj n O) (seq O n))))) (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s))) then ok_arities n s else error_comp (ok_arities hn hs) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s))) end (ok_arities n s)
+++++
simpl.
-----
Lemma arities_rec3 n s x g h (Hx : arities x = ok_arities n 0) (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec3 n s x g h) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh.
simpl.
do 4 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.

*****
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n O)
x,g,h : BC
n,s : nat
*****
eq match match (if andb (andb (andb (Nat.eqb n n) true) (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O)) (map (proj (S n) O) (seq (S O) n)))) (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) with | error_rec a a0 a1 => error_rec (ok_arities n s) (error_rec a a0 a1) (if andb (andb (andb (Nat.eqb n n) true) (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O)) (map (proj (S n) O) (seq (S O) n)))) (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | error_comp a l l0 => error_rec (ok_arities n s) (error_comp a l l0) (if andb (andb (andb (Nat.eqb n n) true) (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O)) (map (proj (S n) O) (seq (S O) n)))) (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | error_proj n0 n1 n2 => error_rec (ok_arities n s) (error_proj n0 n1 n2) (if andb (andb (andb (Nat.eqb n n) true) (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O)) (map (proj (S n) O) (seq (S O) n)))) (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | ok_arities h0n h0s => match (if andb (andb (andb (Nat.eqb n n) true) (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O)) (map (proj (S n) O) (seq (S O) n)))) (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) with | error_rec a a0 a1 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_rec a a0 a1) | error_comp a l l0 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_comp a l l0) | error_proj n0 n1 n2 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_proj n0 n1 n2) | ok_arities h1n h1s => if andb (andb (andb match h0n with | O => false | S m' => Nat.eqb n m' end (Nat.eqb h0n h1n)) match h0s with | O => false | S m' => Nat.eqb s m' end) (Nat.eqb h0s h1s) then ok_arities h0n s else error_rec (ok_arities n s) (ok_arities h0n h0s) (ok_arities h1n h1s) end end with | error_rec a a0 a1 => error_comp (error_rec a a0 a1) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s))) | error_comp a l l0 => error_comp (error_comp a l l0) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s))) | error_proj n0 n1 n2 => error_comp (error_proj n0 n1 n2) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s))) | ok_arities hn hs => if andb (andb (andb (Nat.eqb hn (S n)) (Nat.eqb hs s)) (forallb (fun ne : BC => aeq (arities ne) (ok_arities n O)) (map (proj n O) (seq O n)))) (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s))) then ok_arities n s else error_comp (ok_arities hn hs) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s))) end (ok_arities n s)
+++++
rewrite <- beq_nat_refl.
-----
Lemma arities_rec3 n s x g h (Hx : arities x = ok_arities n 0) (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec3 n s x g h) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh.
simpl.
do 4 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.

*****
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n O)
x,g,h : BC
n,s : nat
*****
eq match match (if andb (andb (andb true true) (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O)) (map (proj (S n) O) (seq (S O) n)))) (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) with | error_rec a a0 a1 => error_rec (ok_arities n s) (error_rec a a0 a1) (if andb (andb (andb true true) (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O)) (map (proj (S n) O) (seq (S O) n)))) (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | error_comp a l l0 => error_rec (ok_arities n s) (error_comp a l l0) (if andb (andb (andb true true) (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O)) (map (proj (S n) O) (seq (S O) n)))) (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | error_proj n0 n1 n2 => error_rec (ok_arities n s) (error_proj n0 n1 n2) (if andb (andb (andb true true) (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O)) (map (proj (S n) O) (seq (S O) n)))) (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | ok_arities h0n h0s => match (if andb (andb (andb true true) (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O)) (map (proj (S n) O) (seq (S O) n)))) (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) with | error_rec a a0 a1 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_rec a a0 a1) | error_comp a l l0 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_comp a l l0) | error_proj n0 n1 n2 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_proj n0 n1 n2) | ok_arities h1n h1s => if andb (andb (andb match h0n with | O => false | S m' => Nat.eqb n m' end (Nat.eqb h0n h1n)) match h0s with | O => false | S m' => Nat.eqb s m' end) (Nat.eqb h0s h1s) then ok_arities h0n s else error_rec (ok_arities n s) (ok_arities h0n h0s) (ok_arities h1n h1s) end end with | error_rec a a0 a1 => error_comp (error_rec a a0 a1) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s))) | error_comp a l l0 => error_comp (error_comp a l l0) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s))) | error_proj n0 n1 n2 => error_comp (error_proj n0 n1 n2) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s))) | ok_arities hn hs => if andb (andb (andb (Nat.eqb hn (S n)) (Nat.eqb hs s)) (forallb (fun ne : BC => aeq (arities ne) (ok_arities n O)) (map (proj n O) (seq O n)))) (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s))) then ok_arities n s else error_comp (ok_arities hn hs) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s))) end (ok_arities n s)
+++++
simpl.
-----
Lemma arities_rec3 n s x g h (Hx : arities x = ok_arities n 0) (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec3 n s x g h) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh.
simpl.
do 4 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.

*****
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n O)
x,g,h : BC
n,s : nat
*****
eq match match (if andb (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O)) (map (proj (S n) O) (seq (S O) n))) (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) with | error_rec a a0 a1 => error_rec (ok_arities n s) (error_rec a a0 a1) (if andb (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O)) (map (proj (S n) O) (seq (S O) n))) (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | error_comp a l l0 => error_rec (ok_arities n s) (error_comp a l l0) (if andb (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O)) (map (proj (S n) O) (seq (S O) n))) (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | error_proj n0 n1 n2 => error_rec (ok_arities n s) (error_proj n0 n1 n2) (if andb (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O)) (map (proj (S n) O) (seq (S O) n))) (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | ok_arities h0n h0s => match (if andb (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O)) (map (proj (S n) O) (seq (S O) n))) (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) with | error_rec a a0 a1 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_rec a a0 a1) | error_comp a l l0 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_comp a l l0) | error_proj n0 n1 n2 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_proj n0 n1 n2) | ok_arities h1n h1s => if andb (andb (andb match h0n with | O => false | S m' => Nat.eqb n m' end (Nat.eqb h0n h1n)) match h0s with | O => false | S m' => Nat.eqb s m' end) (Nat.eqb h0s h1s) then ok_arities h0n s else error_rec (ok_arities n s) (ok_arities h0n h0s) (ok_arities h1n h1s) end end with | error_rec a a0 a1 => error_comp (error_rec a a0 a1) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s))) | error_comp a l l0 => error_comp (error_comp a l l0) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s))) | error_proj n0 n1 n2 => error_comp (error_proj n0 n1 n2) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s))) | ok_arities hn hs => if andb (andb (andb (Nat.eqb hn (S n)) (Nat.eqb hs s)) (forallb (fun ne : BC => aeq (arities ne) (ok_arities n O)) (map (proj n O) (seq O n)))) (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s))) then ok_arities n s else error_comp (ok_arities hn hs) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s))) end (ok_arities n s)
+++++
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
-----
Lemma arities_rec3 n s x g h (Hx : arities x = ok_arities n 0) (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec3 n s x g h) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh.
simpl.
do 4 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.

*****
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O))\n (map (proj (S n) O) (seq (S O) n))) true
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n O)
x,g,h : BC
n,s : nat
*****
eq match match (if andb true (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) with | error_rec a a0 a1 => error_rec (ok_arities n s) (error_rec a a0 a1) (if andb true (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | error_comp a l l0 => error_rec (ok_arities n s) (error_comp a l l0) (if andb true (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | error_proj n0 n1 n2 => error_rec (ok_arities n s) (error_proj n0 n1 n2) (if andb true (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | ok_arities h0n h0s => match (if andb true (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) with | error_rec a a0 a1 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_rec a a0 a1) | error_comp a l l0 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_comp a l l0) | error_proj n0 n1 n2 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_proj n0 n1 n2) | ok_arities h1n h1s => if andb (andb (andb match h0n with | O => false | S m' => Nat.eqb n m' end (Nat.eqb h0n h1n)) match h0s with | O => false | S m' => Nat.eqb s m' end) (Nat.eqb h0s h1s) then ok_arities h0n s else error_rec (ok_arities n s) (ok_arities h0n h0s) (ok_arities h1n h1s) end end with | error_rec a a0 a1 => error_comp (error_rec a a0 a1) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s))) | error_comp a l l0 => error_comp (error_comp a l l0) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s))) | error_proj n0 n1 n2 => error_comp (error_proj n0 n1 n2) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s))) | ok_arities hn hs => if andb (andb (andb (Nat.eqb hn (S n)) (Nat.eqb hs s)) (forallb (fun ne : BC => aeq (arities ne) (ok_arities n O)) (map (proj n O) (seq O n)))) (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s))) then ok_arities n s else error_comp (ok_arities hn hs) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s))) end (ok_arities n s)
+++++
simpl.
-----
Lemma arities_rec3 n s x g h (Hx : arities x = ok_arities n 0) (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec3 n s x g h) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh.
simpl.
do 4 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.

*****
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O))\n (map (proj (S n) O) (seq (S O) n))) true
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n O)
x,g,h : BC
n,s : nat
*****
eq match match (if andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) with | error_rec a a0 a1 => error_rec (ok_arities n s) (error_rec a a0 a1) (if andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | error_comp a l l0 => error_rec (ok_arities n s) (error_comp a l l0) (if andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | error_proj n0 n1 n2 => error_rec (ok_arities n s) (error_proj n0 n1 n2) (if andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | ok_arities h0n h0s => match (if andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) with | error_rec a a0 a1 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_rec a a0 a1) | error_comp a l l0 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_comp a l l0) | error_proj n0 n1 n2 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_proj n0 n1 n2) | ok_arities h1n h1s => if andb (andb (andb match h0n with | O => false | S m' => Nat.eqb n m' end (Nat.eqb h0n h1n)) match h0s with | O => false | S m' => Nat.eqb s m' end) (Nat.eqb h0s h1s) then ok_arities h0n s else error_rec (ok_arities n s) (ok_arities h0n h0s) (ok_arities h1n h1s) end end with | error_rec a a0 a1 => error_comp (error_rec a a0 a1) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s))) | error_comp a l l0 => error_comp (error_comp a l l0) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s))) | error_proj n0 n1 n2 => error_comp (error_proj n0 n1 n2) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s))) | ok_arities hn hs => if andb (andb (andb (Nat.eqb hn (S n)) (Nat.eqb hs s)) (forallb (fun ne : BC => aeq (arities ne) (ok_arities n O)) (map (proj n O) (seq O n)))) (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s))) then ok_arities n s else error_comp (ok_arities hn hs) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s))) end (ok_arities n s)
+++++
case_eq (n + S s).
-----
Lemma arities_rec3 n s x g h (Hx : arities x = ok_arities n 0) (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec3 n s x g h) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh.
simpl.
do 4 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).

*****
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O))\n (map (proj (S n) O) (seq (S O) n))) true
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n O)
x,g,h : BC
n,s : nat
*****
forall _ : eq (Init.Nat.add n (S s)) O, eq match match (if andb (aeq (error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) with | error_rec a a0 a1 => error_rec (ok_arities n s) (error_rec a a0 a1) (if andb (aeq (error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | error_comp a l l0 => error_rec (ok_arities n s) (error_comp a l l0) (if andb (aeq (error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | error_proj n0 n1 n2 => error_rec (ok_arities n s) (error_proj n0 n1 n2) (if andb (aeq (error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | ok_arities h0n h0s => match (if andb (aeq (error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) with | error_rec a a0 a1 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_rec a a0 a1) | error_comp a l l0 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_comp a l l0) | error_proj n0 n1 n2 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_proj n0 n1 n2) | ok_arities h1n h1s => if andb (andb (andb match h0n with | O => false | S m' => Nat.eqb n m' end (Nat.eqb h0n h1n)) match h0s with | O => false | S m' => Nat.eqb s m' end) (Nat.eqb h0s h1s) then ok_arities h0n s else error_rec (ok_arities n s) (ok_arities h0n h0s) (ok_arities h1n h1s) end end with | error_rec a a0 a1 => error_comp (error_rec a a0 a1) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s))) | error_comp a l l0 => error_comp (error_comp a l l0) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s))) | error_proj n0 n1 n2 => error_comp (error_proj n0 n1 n2) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s))) | ok_arities hn hs => if andb (andb (andb (Nat.eqb hn (S n)) (Nat.eqb hs s)) (forallb (fun ne : BC => aeq (arities ne) (ok_arities n O)) (map (proj n O) (seq O n)))) (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s))) then ok_arities n s else error_comp (ok_arities hn hs) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s))) end (ok_arities n s)
+++++
intro H2.
-----
Lemma arities_rec3 n s x g h (Hx : arities x = ok_arities n 0) (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec3 n s x g h) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh.
simpl.
do 4 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).
intro H2.

*****
H2 : eq (Init.Nat.add n (S s)) O
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O))\n (map (proj (S n) O) (seq (S O) n))) true
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n O)
x,g,h : BC
n,s : nat
*****
eq match match (if andb (aeq (error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) with | error_rec a a0 a1 => error_rec (ok_arities n s) (error_rec a a0 a1) (if andb (aeq (error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | error_comp a l l0 => error_rec (ok_arities n s) (error_comp a l l0) (if andb (aeq (error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | error_proj n0 n1 n2 => error_rec (ok_arities n s) (error_proj n0 n1 n2) (if andb (aeq (error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | ok_arities h0n h0s => match (if andb (aeq (error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) with | error_rec a a0 a1 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_rec a a0 a1) | error_comp a l l0 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_comp a l l0) | error_proj n0 n1 n2 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_proj n0 n1 n2) | ok_arities h1n h1s => if andb (andb (andb match h0n with | O => false | S m' => Nat.eqb n m' end (Nat.eqb h0n h1n)) match h0s with | O => false | S m' => Nat.eqb s m' end) (Nat.eqb h0s h1s) then ok_arities h0n s else error_rec (ok_arities n s) (ok_arities h0n h0s) (ok_arities h1n h1s) end end with | error_rec a a0 a1 => error_comp (error_rec a a0 a1) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s))) | error_comp a l l0 => error_comp (error_comp a l l0) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s))) | error_proj n0 n1 n2 => error_comp (error_proj n0 n1 n2) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s))) | ok_arities hn hs => if andb (andb (andb (Nat.eqb hn (S n)) (Nat.eqb hs s)) (forallb (fun ne : BC => aeq (arities ne) (ok_arities n O)) (map (proj n O) (seq O n)))) (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s))) then ok_arities n s else error_comp (ok_arities hn hs) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s))) end (ok_arities n s)
+++++
contradict H2.
-----
Lemma arities_rec3 n s x g h (Hx : arities x = ok_arities n 0) (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec3 n s x g h) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh.
simpl.
do 4 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).
intro H2.
contradict H2.

*****
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O))\n (map (proj (S n) O) (seq (S O) n))) true
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n O)
x,g,h : BC
n,s : nat
*****
not (eq (Init.Nat.add n (S s)) O)
+++++
omega.
-----
Lemma arities_rec3 n s x g h (Hx : arities x = ok_arities n 0) (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec3 n s x g h) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh.
simpl.
do 4 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).
intro H2.
contradict H2.
omega.

*****
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O))\n (map (proj (S n) O) (seq (S O) n))) true
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n O)
x,g,h : BC
n,s : nat
*****
forall (n0 : nat) (_ : eq (Init.Nat.add n (S s)) (S n0)), eq match match (if andb (aeq (if Nat.leb n n0 then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if Nat.leb n n0 then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) with | error_rec a a0 a1 => error_rec (ok_arities n s) (error_rec a a0 a1) (if andb (aeq (if Nat.leb n n0 then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if Nat.leb n n0 then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | error_comp a l l0 => error_rec (ok_arities n s) (error_comp a l l0) (if andb (aeq (if Nat.leb n n0 then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if Nat.leb n n0 then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | error_proj n1 n2 n3 => error_rec (ok_arities n s) (error_proj n1 n2 n3) (if andb (aeq (if Nat.leb n n0 then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if Nat.leb n n0 then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | ok_arities h0n h0s => match (if andb (aeq (if Nat.leb n n0 then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if Nat.leb n n0 then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) with | error_rec a a0 a1 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_rec a a0 a1) | error_comp a l l0 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_comp a l l0) | error_proj n1 n2 n3 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_proj n1 n2 n3) | ok_arities h1n h1s => if andb (andb (andb match h0n with | O => false | S m' => Nat.eqb n m' end (Nat.eqb h0n h1n)) match h0s with | O => false | S m' => Nat.eqb s m' end) (Nat.eqb h0s h1s) then ok_arities h0n s else error_rec (ok_arities n s) (ok_arities h0n h0s) (ok_arities h1n h1s) end end with | error_rec a a0 a1 => error_comp (error_rec a a0 a1) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s))) | error_comp a l l0 => error_comp (error_comp a l l0) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s))) | error_proj n1 n2 n3 => error_comp (error_proj n1 n2 n3) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s))) | ok_arities hn hs => if andb (andb (andb (Nat.eqb hn (S n)) (Nat.eqb hs s)) (forallb (fun ne : BC => aeq (arities ne) (ok_arities n O)) (map (proj n O) (seq O n)))) (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s))) then ok_arities n s else error_comp (ok_arities hn hs) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s))) end (ok_arities n s)
+++++
intros p H2.
-----
Lemma arities_rec3 n s x g h (Hx : arities x = ok_arities n 0) (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec3 n s x g h) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh.
simpl.
do 4 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).
intro H2.
contradict H2.
omega.
intros p H2.

*****
H2 : eq (Init.Nat.add n (S s)) (S p)
p : nat
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O))\n (map (proj (S n) O) (seq (S O) n))) true
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n O)
x,g,h : BC
n,s : nat
*****
eq match match (if andb (aeq (if Nat.leb n p then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if Nat.leb n p then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) with | error_rec a a0 a1 => error_rec (ok_arities n s) (error_rec a a0 a1) (if andb (aeq (if Nat.leb n p then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if Nat.leb n p then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | error_comp a l l0 => error_rec (ok_arities n s) (error_comp a l l0) (if andb (aeq (if Nat.leb n p then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if Nat.leb n p then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | error_proj n0 n1 n2 => error_rec (ok_arities n s) (error_proj n0 n1 n2) (if andb (aeq (if Nat.leb n p then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if Nat.leb n p then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | ok_arities h0n h0s => match (if andb (aeq (if Nat.leb n p then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if Nat.leb n p then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) with | error_rec a a0 a1 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_rec a a0 a1) | error_comp a l l0 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_comp a l l0) | error_proj n0 n1 n2 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_proj n0 n1 n2) | ok_arities h1n h1s => if andb (andb (andb match h0n with | O => false | S m' => Nat.eqb n m' end (Nat.eqb h0n h1n)) match h0s with | O => false | S m' => Nat.eqb s m' end) (Nat.eqb h0s h1s) then ok_arities h0n s else error_rec (ok_arities n s) (ok_arities h0n h0s) (ok_arities h1n h1s) end end with | error_rec a a0 a1 => error_comp (error_rec a a0 a1) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s))) | error_comp a l l0 => error_comp (error_comp a l l0) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s))) | error_proj n0 n1 n2 => error_comp (error_proj n0 n1 n2) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s))) | ok_arities hn hs => if andb (andb (andb (Nat.eqb hn (S n)) (Nat.eqb hs s)) (forallb (fun ne : BC => aeq (arities ne) (ok_arities n O)) (map (proj n O) (seq O n)))) (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s))) then ok_arities n s else error_comp (ok_arities hn hs) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s))) end (ok_arities n s)
+++++
case_eq (leb n p); intro H3.
-----
Lemma arities_rec3 n s x g h (Hx : arities x = ok_arities n 0) (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec3 n s x g h) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh.
simpl.
do 4 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).
intro H2.
contradict H2.
omega.
intros p H2.
case_eq (leb n p); intro H3.

*****
H3 : eq (Nat.leb n p) true
H2 : eq (Init.Nat.add n (S s)) (S p)
p : nat
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O))\n (map (proj (S n) O) (seq (S O) n))) true
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n O)
x,g,h : BC
n,s : nat
*****
eq match match (if andb (aeq (ok_arities (S n) (S s)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (ok_arities (S n) (S s)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) with | error_rec a a0 a1 => error_rec (ok_arities n s) (error_rec a a0 a1) (if andb (aeq (ok_arities (S n) (S s)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (ok_arities (S n) (S s)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | error_comp a l l0 => error_rec (ok_arities n s) (error_comp a l l0) (if andb (aeq (ok_arities (S n) (S s)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (ok_arities (S n) (S s)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | error_proj n0 n1 n2 => error_rec (ok_arities n s) (error_proj n0 n1 n2) (if andb (aeq (ok_arities (S n) (S s)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (ok_arities (S n) (S s)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | ok_arities h0n h0s => match (if andb (aeq (ok_arities (S n) (S s)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (ok_arities (S n) (S s)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) with | error_rec a a0 a1 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_rec a a0 a1) | error_comp a l l0 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_comp a l l0) | error_proj n0 n1 n2 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_proj n0 n1 n2) | ok_arities h1n h1s => if andb (andb (andb match h0n with | O => false | S m' => Nat.eqb n m' end (Nat.eqb h0n h1n)) match h0s with | O => false | S m' => Nat.eqb s m' end) (Nat.eqb h0s h1s) then ok_arities h0n s else error_rec (ok_arities n s) (ok_arities h0n h0s) (ok_arities h1n h1s) end end with | error_rec a a0 a1 => error_comp (error_rec a a0 a1) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s))) | error_comp a l l0 => error_comp (error_comp a l l0) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s))) | error_proj n0 n1 n2 => error_comp (error_proj n0 n1 n2) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s))) | ok_arities hn hs => if andb (andb (andb (Nat.eqb hn (S n)) (Nat.eqb hs s)) (forallb (fun ne : BC => aeq (arities ne) (ok_arities n O)) (map (proj n O) (seq O n)))) (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s))) then ok_arities n s else error_comp (ok_arities hn hs) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s))) end (ok_arities n s)
+++++
simpl.
-----
Lemma arities_rec3 n s x g h (Hx : arities x = ok_arities n 0) (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec3 n s x g h) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh.
simpl.
do 4 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).
intro H2.
contradict H2.
omega.
intros p H2.
case_eq (leb n p); intro H3.
simpl.

*****
H3 : eq (Nat.leb n p) true
H2 : eq (Init.Nat.add n (S s)) (S p)
p : nat
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O))\n (map (proj (S n) O) (seq (S O) n))) true
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n O)
x,g,h : BC
n,s : nat
*****
eq match match (if andb (andb (Nat.eqb n n) (Nat.eqb s s)) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (ok_arities (S n) (S s)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) with | error_rec a a0 a1 => error_rec (ok_arities n s) (error_rec a a0 a1) (if andb (andb (Nat.eqb n n) (Nat.eqb s s)) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (ok_arities (S n) (S s)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | error_comp a l l0 => error_rec (ok_arities n s) (error_comp a l l0) (if andb (andb (Nat.eqb n n) (Nat.eqb s s)) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (ok_arities (S n) (S s)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | error_proj n0 n1 n2 => error_rec (ok_arities n s) (error_proj n0 n1 n2) (if andb (andb (Nat.eqb n n) (Nat.eqb s s)) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (ok_arities (S n) (S s)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | ok_arities h0n h0s => match (if andb (andb (Nat.eqb n n) (Nat.eqb s s)) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (ok_arities (S n) (S s)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) with | error_rec a a0 a1 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_rec a a0 a1) | error_comp a l l0 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_comp a l l0) | error_proj n0 n1 n2 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_proj n0 n1 n2) | ok_arities h1n h1s => if andb (andb (andb match h0n with | O => false | S m' => Nat.eqb n m' end (Nat.eqb h0n h1n)) match h0s with | O => false | S m' => Nat.eqb s m' end) (Nat.eqb h0s h1s) then ok_arities h0n s else error_rec (ok_arities n s) (ok_arities h0n h0s) (ok_arities h1n h1s) end end with | error_rec a a0 a1 => error_comp (error_rec a a0 a1) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s))) | error_comp a l l0 => error_comp (error_comp a l l0) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s))) | error_proj n0 n1 n2 => error_comp (error_proj n0 n1 n2) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s))) | ok_arities hn hs => if andb (andb (andb (Nat.eqb hn (S n)) (Nat.eqb hs s)) (forallb (fun ne : BC => aeq (arities ne) (ok_arities n O)) (map (proj n O) (seq O n)))) (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s))) then ok_arities n s else error_comp (ok_arities hn hs) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s))) end (ok_arities n s)
+++++
do 2 rewrite <- beq_nat_refl.
-----
Lemma arities_rec3 n s x g h (Hx : arities x = ok_arities n 0) (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec3 n s x g h) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh.
simpl.
do 4 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).
intro H2.
contradict H2.
omega.
intros p H2.
case_eq (leb n p); intro H3.
simpl.
do 2 rewrite <- beq_nat_refl.

*****
H3 : eq (Nat.leb n p) true
H2 : eq (Init.Nat.add n (S s)) (S p)
p : nat
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O))\n (map (proj (S n) O) (seq (S O) n))) true
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n O)
x,g,h : BC
n,s : nat
*****
eq match match (if andb (andb true true) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (ok_arities (S n) (S s)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) with | error_rec a a0 a1 => error_rec (ok_arities n s) (error_rec a a0 a1) (if andb (andb true true) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (ok_arities (S n) (S s)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | error_comp a l l0 => error_rec (ok_arities n s) (error_comp a l l0) (if andb (andb true true) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (ok_arities (S n) (S s)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | error_proj n0 n1 n2 => error_rec (ok_arities n s) (error_proj n0 n1 n2) (if andb (andb true true) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (ok_arities (S n) (S s)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | ok_arities h0n h0s => match (if andb (andb true true) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (ok_arities (S n) (S s)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) with | error_rec a a0 a1 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_rec a a0 a1) | error_comp a l l0 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_comp a l l0) | error_proj n0 n1 n2 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_proj n0 n1 n2) | ok_arities h1n h1s => if andb (andb (andb match h0n with | O => false | S m' => Nat.eqb n m' end (Nat.eqb h0n h1n)) match h0s with | O => false | S m' => Nat.eqb s m' end) (Nat.eqb h0s h1s) then ok_arities h0n s else error_rec (ok_arities n s) (ok_arities h0n h0s) (ok_arities h1n h1s) end end with | error_rec a a0 a1 => error_comp (error_rec a a0 a1) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s))) | error_comp a l l0 => error_comp (error_comp a l l0) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s))) | error_proj n0 n1 n2 => error_comp (error_proj n0 n1 n2) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s))) | ok_arities hn hs => if andb (andb (andb (Nat.eqb hn (S n)) (Nat.eqb hs s)) (forallb (fun ne : BC => aeq (arities ne) (ok_arities n O)) (map (proj n O) (seq O n)))) (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s))) then ok_arities n s else error_comp (ok_arities hn hs) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s))) end (ok_arities n s)
+++++
simpl.
-----
Lemma arities_rec3 n s x g h (Hx : arities x = ok_arities n 0) (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec3 n s x g h) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh.
simpl.
do 4 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).
intro H2.
contradict H2.
omega.
intros p H2.
case_eq (leb n p); intro H3.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.

*****
H3 : eq (Nat.leb n p) true
H2 : eq (Init.Nat.add n (S s)) (S p)
p : nat
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O))\n (map (proj (S n) O) (seq (S O) n))) true
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n O)
x,g,h : BC
n,s : nat
*****
eq match match (if forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (ok_arities (S n) (S s)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) with | error_rec a a0 a1 => error_rec (ok_arities n s) (error_rec a a0 a1) (if forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (ok_arities (S n) (S s)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | error_comp a l l0 => error_rec (ok_arities n s) (error_comp a l l0) (if forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (ok_arities (S n) (S s)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | error_proj n0 n1 n2 => error_rec (ok_arities n s) (error_proj n0 n1 n2) (if forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (ok_arities (S n) (S s)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | ok_arities h0n h0s => match (if forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (ok_arities (S n) (S s)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) with | error_rec a a0 a1 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_rec a a0 a1) | error_comp a l l0 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_comp a l l0) | error_proj n0 n1 n2 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_proj n0 n1 n2) | ok_arities h1n h1s => if andb (andb (andb match h0n with | O => false | S m' => Nat.eqb n m' end (Nat.eqb h0n h1n)) match h0s with | O => false | S m' => Nat.eqb s m' end) (Nat.eqb h0s h1s) then ok_arities h0n s else error_rec (ok_arities n s) (ok_arities h0n h0s) (ok_arities h1n h1s) end end with | error_rec a a0 a1 => error_comp (error_rec a a0 a1) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s))) | error_comp a l l0 => error_comp (error_comp a l l0) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s))) | error_proj n0 n1 n2 => error_comp (error_proj n0 n1 n2) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s))) | ok_arities hn hs => if andb (andb (andb (Nat.eqb hn (S n)) (Nat.eqb hs s)) (forallb (fun ne : BC => aeq (arities ne) (ok_arities n O)) (map (proj n O) (seq O n)))) (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s))) then ok_arities n s else error_comp (ok_arities hn hs) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s))) end (ok_arities n s)
+++++
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H4 end.
-----
Lemma arities_rec3 n s x g h (Hx : arities x = ok_arities n 0) (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec3 n s x g h) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh.
simpl.
do 4 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).
intro H2.
contradict H2.
omega.
intros p H2.
case_eq (leb n p); intro H3.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H4 end.

*****
H4 : eq\n (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s)))\n (map (proj (S n) (S s)) (seq (S (S n)) s))) true
H3 : eq (Nat.leb n p) true
H2 : eq (Init.Nat.add n (S s)) (S p)
p : nat
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O))\n (map (proj (S n) O) (seq (S O) n))) true
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n O)
x,g,h : BC
n,s : nat
*****
eq match (if andb (andb (andb (Nat.eqb n n) (Nat.eqb (S n) (S n))) (Nat.eqb s s)) (Nat.eqb (S s) (S s)) then ok_arities (S n) s else error_rec (ok_arities n s) (ok_arities (S n) (S s)) (ok_arities (S n) (S s))) with | error_rec a a0 a1 => error_comp (error_rec a a0 a1) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s))) | error_comp a l l0 => error_comp (error_comp a l l0) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s))) | error_proj n0 n1 n2 => error_comp (error_proj n0 n1 n2) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s))) | ok_arities hn hs => if andb (andb (andb (Nat.eqb hn (S n)) (Nat.eqb hs s)) (forallb (fun ne : BC => aeq (arities ne) (ok_arities n O)) (map (proj n O) (seq O n)))) (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s))) then ok_arities n s else error_comp (ok_arities hn hs) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s))) end (ok_arities n s)
+++++
do 4 rewrite <- beq_nat_refl.
-----
Lemma arities_rec3 n s x g h (Hx : arities x = ok_arities n 0) (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec3 n s x g h) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh.
simpl.
do 4 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).
intro H2.
contradict H2.
omega.
intros p H2.
case_eq (leb n p); intro H3.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H4 end.
do 4 rewrite <- beq_nat_refl.

*****
H4 : eq\n (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s)))\n (map (proj (S n) (S s)) (seq (S (S n)) s))) true
H3 : eq (Nat.leb n p) true
H2 : eq (Init.Nat.add n (S s)) (S p)
p : nat
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O))\n (map (proj (S n) O) (seq (S O) n))) true
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n O)
x,g,h : BC
n,s : nat
*****
eq match (if andb (andb (andb true true) true) true then ok_arities (S n) s else error_rec (ok_arities n s) (ok_arities (S n) (S s)) (ok_arities (S n) (S s))) with | error_rec a a0 a1 => error_comp (error_rec a a0 a1) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s))) | error_comp a l l0 => error_comp (error_comp a l l0) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s))) | error_proj n0 n1 n2 => error_comp (error_proj n0 n1 n2) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s))) | ok_arities hn hs => if andb (andb (andb (Nat.eqb hn (S n)) (Nat.eqb hs s)) (forallb (fun ne : BC => aeq (arities ne) (ok_arities n O)) (map (proj n O) (seq O n)))) (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s))) then ok_arities n s else error_comp (ok_arities hn hs) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s))) end (ok_arities n s)
+++++
simpl.
-----
Lemma arities_rec3 n s x g h (Hx : arities x = ok_arities n 0) (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec3 n s x g h) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh.
simpl.
do 4 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).
intro H2.
contradict H2.
omega.
intros p H2.
case_eq (leb n p); intro H3.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H4 end.
do 4 rewrite <- beq_nat_refl.
simpl.

*****
H4 : eq\n (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s)))\n (map (proj (S n) (S s)) (seq (S (S n)) s))) true
H3 : eq (Nat.leb n p) true
H2 : eq (Init.Nat.add n (S s)) (S p)
p : nat
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O))\n (map (proj (S n) O) (seq (S O) n))) true
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n O)
x,g,h : BC
n,s : nat
*****
eq (if andb (andb (andb (Nat.eqb n n) (Nat.eqb s s)) (forallb (fun ne : BC => aeq (arities ne) (ok_arities n O)) (map (proj n O) (seq O n)))) (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s))) then ok_arities n s else error_comp (ok_arities (S n) s) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s)))) (ok_arities n s)
+++++
do 2 rewrite <- beq_nat_refl.
-----
Lemma arities_rec3 n s x g h (Hx : arities x = ok_arities n 0) (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec3 n s x g h) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh.
simpl.
do 4 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).
intro H2.
contradict H2.
omega.
intros p H2.
case_eq (leb n p); intro H3.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H4 end.
do 4 rewrite <- beq_nat_refl.
simpl.
do 2 rewrite <- beq_nat_refl.

*****
H4 : eq\n (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s)))\n (map (proj (S n) (S s)) (seq (S (S n)) s))) true
H3 : eq (Nat.leb n p) true
H2 : eq (Init.Nat.add n (S s)) (S p)
p : nat
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O))\n (map (proj (S n) O) (seq (S O) n))) true
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n O)
x,g,h : BC
n,s : nat
*****
eq (if andb (andb (andb true true) (forallb (fun ne : BC => aeq (arities ne) (ok_arities n O)) (map (proj n O) (seq O n)))) (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s))) then ok_arities n s else error_comp (ok_arities (S n) s) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s)))) (ok_arities n s)
+++++
simpl.
-----
Lemma arities_rec3 n s x g h (Hx : arities x = ok_arities n 0) (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec3 n s x g h) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh.
simpl.
do 4 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).
intro H2.
contradict H2.
omega.
intros p H2.
case_eq (leb n p); intro H3.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H4 end.
do 4 rewrite <- beq_nat_refl.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.

*****
H4 : eq\n (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s)))\n (map (proj (S n) (S s)) (seq (S (S n)) s))) true
H3 : eq (Nat.leb n p) true
H2 : eq (Init.Nat.add n (S s)) (S p)
p : nat
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O))\n (map (proj (S n) O) (seq (S O) n))) true
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n O)
x,g,h : BC
n,s : nat
*****
eq (if andb (forallb (fun ne : BC => aeq (arities ne) (ok_arities n O)) (map (proj n O) (seq O n))) (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s))) then ok_arities n s else error_comp (ok_arities (S n) s) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s)))) (ok_arities n s)
+++++
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H5 end.
-----
Lemma arities_rec3 n s x g h (Hx : arities x = ok_arities n 0) (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec3 n s x g h) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh.
simpl.
do 4 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).
intro H2.
contradict H2.
omega.
intros p H2.
case_eq (leb n p); intro H3.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H4 end.
do 4 rewrite <- beq_nat_refl.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H5 end.

*****
H5 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities n O))\n (map (proj n O) (seq O n))) true
H4 : eq\n (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s)))\n (map (proj (S n) (S s)) (seq (S (S n)) s))) true
H3 : eq (Nat.leb n p) true
H2 : eq (Init.Nat.add n (S s)) (S p)
p : nat
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O))\n (map (proj (S n) O) (seq (S O) n))) true
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n O)
x,g,h : BC
n,s : nat
*****
eq (if andb true (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s))) then ok_arities n s else error_comp (ok_arities (S n) s) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s)))) (ok_arities n s)
+++++
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H6 end.
-----
Lemma arities_rec3 n s x g h (Hx : arities x = ok_arities n 0) (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec3 n s x g h) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh.
simpl.
do 4 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).
intro H2.
contradict H2.
omega.
intros p H2.
case_eq (leb n p); intro H3.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H4 end.
do 4 rewrite <- beq_nat_refl.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H5 end.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H6 end.

*****
H6 : eq\n (forallb (fun se : BC => aeq (arities se) (ok_arities n s))\n (map (proj n s) (seq n s))) true
H5 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities n O))\n (map (proj n O) (seq O n))) true
H4 : eq\n (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s)))\n (map (proj (S n) (S s)) (seq (S (S n)) s))) true
H3 : eq (Nat.leb n p) true
H2 : eq (Init.Nat.add n (S s)) (S p)
p : nat
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O))\n (map (proj (S n) O) (seq (S O) n))) true
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n O)
x,g,h : BC
n,s : nat
*****
eq (if andb true true then ok_arities n s else error_comp (ok_arities (S n) s) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s)))) (ok_arities n s)
+++++
simpl.
-----
Lemma arities_rec3 n s x g h (Hx : arities x = ok_arities n 0) (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec3 n s x g h) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh.
simpl.
do 4 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).
intro H2.
contradict H2.
omega.
intros p H2.
case_eq (leb n p); intro H3.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H4 end.
do 4 rewrite <- beq_nat_refl.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H5 end.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H6 end.
simpl.

*****
H6 : eq\n (forallb (fun se : BC => aeq (arities se) (ok_arities n s))\n (map (proj n s) (seq n s))) true
H5 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities n O))\n (map (proj n O) (seq O n))) true
H4 : eq\n (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s)))\n (map (proj (S n) (S s)) (seq (S (S n)) s))) true
H3 : eq (Nat.leb n p) true
H2 : eq (Init.Nat.add n (S s)) (S p)
p : nat
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O))\n (map (proj (S n) O) (seq (S O) n))) true
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n O)
x,g,h : BC
n,s : nat
*****
eq (ok_arities n s) (ok_arities n s)
+++++
reflexivity.
-----
Lemma arities_rec3 n s x g h (Hx : arities x = ok_arities n 0) (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec3 n s x g h) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh.
simpl.
do 4 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).
intro H2.
contradict H2.
omega.
intros p H2.
case_eq (leb n p); intro H3.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H4 end.
do 4 rewrite <- beq_nat_refl.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H5 end.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H6 end.
simpl.
reflexivity.

*****
H6 : eq\n (forallb (fun se : BC => aeq (arities se) (ok_arities n s))\n (map (proj n s) (seq n s))) false
H5 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities n O))\n (map (proj n O) (seq O n))) true
H4 : eq\n (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s)))\n (map (proj (S n) (S s)) (seq (S (S n)) s))) true
H3 : eq (Nat.leb n p) true
H2 : eq (Init.Nat.add n (S s)) (S p)
p : nat
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O))\n (map (proj (S n) O) (seq (S O) n))) true
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n O)
x,g,h : BC
n,s : nat
*****
eq (if andb true false then ok_arities n s else error_comp (ok_arities (S n) s) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s)))) (ok_arities n s)
+++++
rewrite forallb_forall_conv in H6.
-----
Lemma arities_rec3 n s x g h (Hx : arities x = ok_arities n 0) (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec3 n s x g h) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh.
simpl.
do 4 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).
intro H2.
contradict H2.
omega.
intros p H2.
case_eq (leb n p); intro H3.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H4 end.
do 4 rewrite <- beq_nat_refl.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H5 end.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H6 end.
simpl.
reflexivity.
rewrite forallb_forall_conv in H6.

*****
H6 : ex\n (fun x : BC =>\n and (In x (map (proj n s) (seq n s)))\n (eq (aeq (arities x) (ok_arities n s)) false))
H5 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities n O))\n (map (proj n O) (seq O n))) true
H4 : eq\n (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s)))\n (map (proj (S n) (S s)) (seq (S (S n)) s))) true
H3 : eq (Nat.leb n p) true
H2 : eq (Init.Nat.add n (S s)) (S p)
p : nat
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O))\n (map (proj (S n) O) (seq (S O) n))) true
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n O)
x,g,h : BC
n,s : nat
*****
eq (if andb true false then ok_arities n s else error_comp (ok_arities (S n) s) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s)))) (ok_arities n s)
+++++
destruct H6 as [e [H6 H7] ].
-----
Lemma arities_rec3 n s x g h (Hx : arities x = ok_arities n 0) (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec3 n s x g h) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh.
simpl.
do 4 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).
intro H2.
contradict H2.
omega.
intros p H2.
case_eq (leb n p); intro H3.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H4 end.
do 4 rewrite <- beq_nat_refl.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H5 end.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H6 end.
simpl.
reflexivity.
rewrite forallb_forall_conv in H6.
destruct H6 as [e [H6 H7] ].

*****
H7 : eq (aeq (arities e) (ok_arities n s)) false
H6 : In e (map (proj n s) (seq n s))
e : BC
H5 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities n O))\n (map (proj n O) (seq O n))) true
H4 : eq\n (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s)))\n (map (proj (S n) (S s)) (seq (S (S n)) s))) true
H3 : eq (Nat.leb n p) true
H2 : eq (Init.Nat.add n (S s)) (S p)
p : nat
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O))\n (map (proj (S n) O) (seq (S O) n))) true
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n O)
x,g,h : BC
n,s : nat
*****
eq (if andb true false then ok_arities n s else error_comp (ok_arities (S n) s) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s)))) (ok_arities n s)
+++++
rewrite in_map_iff in H6.
-----
Lemma arities_rec3 n s x g h (Hx : arities x = ok_arities n 0) (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec3 n s x g h) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh.
simpl.
do 4 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).
intro H2.
contradict H2.
omega.
intros p H2.
case_eq (leb n p); intro H3.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H4 end.
do 4 rewrite <- beq_nat_refl.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H5 end.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H6 end.
simpl.
reflexivity.
rewrite forallb_forall_conv in H6.
destruct H6 as [e [H6 H7] ].
rewrite in_map_iff in H6.

*****
H7 : eq (aeq (arities e) (ok_arities n s)) false
H6 : ex (fun x : nat => and (eq (proj n s x) e) (In x (seq n s)))
e : BC
H5 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities n O))\n (map (proj n O) (seq O n))) true
H4 : eq\n (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s)))\n (map (proj (S n) (S s)) (seq (S (S n)) s))) true
H3 : eq (Nat.leb n p) true
H2 : eq (Init.Nat.add n (S s)) (S p)
p : nat
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O))\n (map (proj (S n) O) (seq (S O) n))) true
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n O)
x,g,h : BC
n,s : nat
*****
eq (if andb true false then ok_arities n s else error_comp (ok_arities (S n) s) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s)))) (ok_arities n s)
+++++
destruct H6 as [q [H6 H8] ].
-----
Lemma arities_rec3 n s x g h (Hx : arities x = ok_arities n 0) (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec3 n s x g h) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh.
simpl.
do 4 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).
intro H2.
contradict H2.
omega.
intros p H2.
case_eq (leb n p); intro H3.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H4 end.
do 4 rewrite <- beq_nat_refl.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H5 end.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H6 end.
simpl.
reflexivity.
rewrite forallb_forall_conv in H6.
destruct H6 as [e [H6 H7] ].
rewrite in_map_iff in H6.
destruct H6 as [q [H6 H8] ].

*****
H7 : eq (aeq (arities e) (ok_arities n s)) false
H8 : In q (seq n s)
H6 : eq (proj n s q) e
q : nat
e : BC
H5 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities n O))\n (map (proj n O) (seq O n))) true
H4 : eq\n (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s)))\n (map (proj (S n) (S s)) (seq (S (S n)) s))) true
H3 : eq (Nat.leb n p) true
H2 : eq (Init.Nat.add n (S s)) (S p)
p : nat
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O))\n (map (proj (S n) O) (seq (S O) n))) true
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n O)
x,g,h : BC
n,s : nat
*****
eq (if andb true false then ok_arities n s else error_comp (ok_arities (S n) s) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s)))) (ok_arities n s)
+++++
rewrite in_seq_iff in H8.
-----
Lemma arities_rec3 n s x g h (Hx : arities x = ok_arities n 0) (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec3 n s x g h) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh.
simpl.
do 4 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).
intro H2.
contradict H2.
omega.
intros p H2.
case_eq (leb n p); intro H3.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H4 end.
do 4 rewrite <- beq_nat_refl.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H5 end.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H6 end.
simpl.
reflexivity.
rewrite forallb_forall_conv in H6.
destruct H6 as [e [H6 H7] ].
rewrite in_map_iff in H6.
destruct H6 as [q [H6 H8] ].
rewrite in_seq_iff in H8.

*****
H7 : eq (aeq (arities e) (ok_arities n s)) false
H8 : and (le n q) (lt q (Init.Nat.add n s))
H6 : eq (proj n s q) e
q : nat
e : BC
H5 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities n O))\n (map (proj n O) (seq O n))) true
H4 : eq\n (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s)))\n (map (proj (S n) (S s)) (seq (S (S n)) s))) true
H3 : eq (Nat.leb n p) true
H2 : eq (Init.Nat.add n (S s)) (S p)
p : nat
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O))\n (map (proj (S n) O) (seq (S O) n))) true
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n O)
x,g,h : BC
n,s : nat
*****
eq (if andb true false then ok_arities n s else error_comp (ok_arities (S n) s) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s)))) (ok_arities n s)
+++++
subst e.
-----
Lemma arities_rec3 n s x g h (Hx : arities x = ok_arities n 0) (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec3 n s x g h) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh.
simpl.
do 4 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).
intro H2.
contradict H2.
omega.
intros p H2.
case_eq (leb n p); intro H3.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H4 end.
do 4 rewrite <- beq_nat_refl.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H5 end.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H6 end.
simpl.
reflexivity.
rewrite forallb_forall_conv in H6.
destruct H6 as [e [H6 H7] ].
rewrite in_map_iff in H6.
destruct H6 as [q [H6 H8] ].
rewrite in_seq_iff in H8.
subst e.

*****
H7 : eq (aeq (arities (proj n s q)) (ok_arities n s)) false
H8 : and (le n q) (lt q (Init.Nat.add n s))
q : nat
H5 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities n O))\n (map (proj n O) (seq O n))) true
H4 : eq\n (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s)))\n (map (proj (S n) (S s)) (seq (S (S n)) s))) true
H3 : eq (Nat.leb n p) true
H2 : eq (Init.Nat.add n (S s)) (S p)
p : nat
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O))\n (map (proj (S n) O) (seq (S O) n))) true
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n O)
x,g,h : BC
n,s : nat
*****
eq (if andb true false then ok_arities n s else error_comp (ok_arities (S n) s) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s)))) (ok_arities n s)
+++++
simpl in H7.
-----
Lemma arities_rec3 n s x g h (Hx : arities x = ok_arities n 0) (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec3 n s x g h) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh.
simpl.
do 4 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).
intro H2.
contradict H2.
omega.
intros p H2.
case_eq (leb n p); intro H3.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H4 end.
do 4 rewrite <- beq_nat_refl.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H5 end.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H6 end.
simpl.
reflexivity.
rewrite forallb_forall_conv in H6.
destruct H6 as [e [H6 H7] ].
rewrite in_map_iff in H6.
destruct H6 as [q [H6 H8] ].
rewrite in_seq_iff in H8.
subst e.
simpl in H7.

*****
H7 : eq\n (aeq\n (if\n match Init.Nat.add n s with\n | O => false\n | S m' => Nat.leb q m'\n end\n then ok_arities n s\n else error_proj n s q) (ok_arities n s)) false
H8 : and (le n q) (lt q (Init.Nat.add n s))
q : nat
H5 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities n O))\n (map (proj n O) (seq O n))) true
H4 : eq\n (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s)))\n (map (proj (S n) (S s)) (seq (S (S n)) s))) true
H3 : eq (Nat.leb n p) true
H2 : eq (Init.Nat.add n (S s)) (S p)
p : nat
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O))\n (map (proj (S n) O) (seq (S O) n))) true
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n O)
x,g,h : BC
n,s : nat
*****
eq (if andb true false then ok_arities n s else error_comp (ok_arities (S n) s) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s)))) (ok_arities n s)
+++++
case_eq (n+s).
-----
Lemma arities_rec3 n s x g h (Hx : arities x = ok_arities n 0) (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec3 n s x g h) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh.
simpl.
do 4 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).
intro H2.
contradict H2.
omega.
intros p H2.
case_eq (leb n p); intro H3.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H4 end.
do 4 rewrite <- beq_nat_refl.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H5 end.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H6 end.
simpl.
reflexivity.
rewrite forallb_forall_conv in H6.
destruct H6 as [e [H6 H7] ].
rewrite in_map_iff in H6.
destruct H6 as [q [H6 H8] ].
rewrite in_seq_iff in H8.
subst e.
simpl in H7.
case_eq (n+s).

*****
H7 : eq\n (aeq\n (if\n match Init.Nat.add n s with\n | O => false\n | S m' => Nat.leb q m'\n end\n then ok_arities n s\n else error_proj n s q) (ok_arities n s)) false
H8 : and (le n q) (lt q (Init.Nat.add n s))
q : nat
H5 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities n O))\n (map (proj n O) (seq O n))) true
H4 : eq\n (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s)))\n (map (proj (S n) (S s)) (seq (S (S n)) s))) true
H3 : eq (Nat.leb n p) true
H2 : eq (Init.Nat.add n (S s)) (S p)
p : nat
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O))\n (map (proj (S n) O) (seq (S O) n))) true
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n O)
x,g,h : BC
n,s : nat
*****
forall _ : eq (Init.Nat.add n s) O, eq (if andb true false then ok_arities n s else error_comp (ok_arities (S n) s) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s)))) (ok_arities n s)
+++++
intro H9.
-----
Lemma arities_rec3 n s x g h (Hx : arities x = ok_arities n 0) (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec3 n s x g h) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh.
simpl.
do 4 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).
intro H2.
contradict H2.
omega.
intros p H2.
case_eq (leb n p); intro H3.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H4 end.
do 4 rewrite <- beq_nat_refl.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H5 end.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H6 end.
simpl.
reflexivity.
rewrite forallb_forall_conv in H6.
destruct H6 as [e [H6 H7] ].
rewrite in_map_iff in H6.
destruct H6 as [q [H6 H8] ].
rewrite in_seq_iff in H8.
subst e.
simpl in H7.
case_eq (n+s).
intro H9.

*****
H9 : eq (Init.Nat.add n s) O
H7 : eq\n (aeq\n (if\n match Init.Nat.add n s with\n | O => false\n | S m' => Nat.leb q m'\n end\n then ok_arities n s\n else error_proj n s q) (ok_arities n s)) false
H8 : and (le n q) (lt q (Init.Nat.add n s))
q : nat
H5 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities n O))\n (map (proj n O) (seq O n))) true
H4 : eq\n (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s)))\n (map (proj (S n) (S s)) (seq (S (S n)) s))) true
H3 : eq (Nat.leb n p) true
H2 : eq (Init.Nat.add n (S s)) (S p)
p : nat
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O))\n (map (proj (S n) O) (seq (S O) n))) true
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n O)
x,g,h : BC
n,s : nat
*****
eq (if andb true false then ok_arities n s else error_comp (ok_arities (S n) s) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s)))) (ok_arities n s)
+++++
contradict H8.
-----
Lemma arities_rec3 n s x g h (Hx : arities x = ok_arities n 0) (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec3 n s x g h) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh.
simpl.
do 4 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).
intro H2.
contradict H2.
omega.
intros p H2.
case_eq (leb n p); intro H3.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H4 end.
do 4 rewrite <- beq_nat_refl.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H5 end.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H6 end.
simpl.
reflexivity.
rewrite forallb_forall_conv in H6.
destruct H6 as [e [H6 H7] ].
rewrite in_map_iff in H6.
destruct H6 as [q [H6 H8] ].
rewrite in_seq_iff in H8.
subst e.
simpl in H7.
case_eq (n+s).
intro H9.
contradict H8.

*****
H9 : eq (Init.Nat.add n s) O
H7 : eq\n (aeq\n (if\n match Init.Nat.add n s with\n | O => false\n | S m' => Nat.leb q m'\n end\n then ok_arities n s\n else error_proj n s q) (ok_arities n s)) false
q : nat
H5 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities n O))\n (map (proj n O) (seq O n))) true
H4 : eq\n (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s)))\n (map (proj (S n) (S s)) (seq (S (S n)) s))) true
H3 : eq (Nat.leb n p) true
H2 : eq (Init.Nat.add n (S s)) (S p)
p : nat
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O))\n (map (proj (S n) O) (seq (S O) n))) true
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n O)
x,g,h : BC
n,s : nat
*****
not (and (le n q) (lt q (Init.Nat.add n s)))
+++++
omega.
-----
Lemma arities_rec3 n s x g h (Hx : arities x = ok_arities n 0) (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec3 n s x g h) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh.
simpl.
do 4 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).
intro H2.
contradict H2.
omega.
intros p H2.
case_eq (leb n p); intro H3.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H4 end.
do 4 rewrite <- beq_nat_refl.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H5 end.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H6 end.
simpl.
reflexivity.
rewrite forallb_forall_conv in H6.
destruct H6 as [e [H6 H7] ].
rewrite in_map_iff in H6.
destruct H6 as [q [H6 H8] ].
rewrite in_seq_iff in H8.
subst e.
simpl in H7.
case_eq (n+s).
intro H9.
contradict H8.
omega.

*****
H7 : eq\n (aeq\n (if\n match Init.Nat.add n s with\n | O => false\n | S m' => Nat.leb q m'\n end\n then ok_arities n s\n else error_proj n s q) (ok_arities n s)) false
H8 : and (le n q) (lt q (Init.Nat.add n s))
q : nat
H5 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities n O))\n (map (proj n O) (seq O n))) true
H4 : eq\n (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s)))\n (map (proj (S n) (S s)) (seq (S (S n)) s))) true
H3 : eq (Nat.leb n p) true
H2 : eq (Init.Nat.add n (S s)) (S p)
p : nat
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O))\n (map (proj (S n) O) (seq (S O) n))) true
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n O)
x,g,h : BC
n,s : nat
*****
forall (n0 : nat) (_ : eq (Init.Nat.add n s) (S n0)), eq (if andb true false then ok_arities n s else error_comp (ok_arities (S n) s) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s)))) (ok_arities n s)
+++++
intros r H9.
-----
Lemma arities_rec3 n s x g h (Hx : arities x = ok_arities n 0) (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec3 n s x g h) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh.
simpl.
do 4 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).
intro H2.
contradict H2.
omega.
intros p H2.
case_eq (leb n p); intro H3.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H4 end.
do 4 rewrite <- beq_nat_refl.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H5 end.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H6 end.
simpl.
reflexivity.
rewrite forallb_forall_conv in H6.
destruct H6 as [e [H6 H7] ].
rewrite in_map_iff in H6.
destruct H6 as [q [H6 H8] ].
rewrite in_seq_iff in H8.
subst e.
simpl in H7.
case_eq (n+s).
intro H9.
contradict H8.
omega.
intros r H9.

*****
H9 : eq (Init.Nat.add n s) (S r)
r : nat
H7 : eq\n (aeq\n (if\n match Init.Nat.add n s with\n | O => false\n | S m' => Nat.leb q m'\n end\n then ok_arities n s\n else error_proj n s q) (ok_arities n s)) false
H8 : and (le n q) (lt q (Init.Nat.add n s))
q : nat
H5 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities n O))\n (map (proj n O) (seq O n))) true
H4 : eq\n (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s)))\n (map (proj (S n) (S s)) (seq (S (S n)) s))) true
H3 : eq (Nat.leb n p) true
H2 : eq (Init.Nat.add n (S s)) (S p)
p : nat
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O))\n (map (proj (S n) O) (seq (S O) n))) true
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n O)
x,g,h : BC
n,s : nat
*****
eq (if andb true false then ok_arities n s else error_comp (ok_arities (S n) s) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s)))) (ok_arities n s)
+++++
rewrite H9 in H7.
-----
Lemma arities_rec3 n s x g h (Hx : arities x = ok_arities n 0) (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec3 n s x g h) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh.
simpl.
do 4 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).
intro H2.
contradict H2.
omega.
intros p H2.
case_eq (leb n p); intro H3.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H4 end.
do 4 rewrite <- beq_nat_refl.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H5 end.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H6 end.
simpl.
reflexivity.
rewrite forallb_forall_conv in H6.
destruct H6 as [e [H6 H7] ].
rewrite in_map_iff in H6.
destruct H6 as [q [H6 H8] ].
rewrite in_seq_iff in H8.
subst e.
simpl in H7.
case_eq (n+s).
intro H9.
contradict H8.
omega.
intros r H9.
rewrite H9 in H7.

*****
H9 : eq (Init.Nat.add n s) (S r)
H7 : eq\n (aeq (if Nat.leb q r then ok_arities n s else error_proj n s q)\n (ok_arities n s)) false
r : nat
H8 : and (le n q) (lt q (Init.Nat.add n s))
q : nat
H5 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities n O))\n (map (proj n O) (seq O n))) true
H4 : eq\n (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s)))\n (map (proj (S n) (S s)) (seq (S (S n)) s))) true
H3 : eq (Nat.leb n p) true
H2 : eq (Init.Nat.add n (S s)) (S p)
p : nat
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O))\n (map (proj (S n) O) (seq (S O) n))) true
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n O)
x,g,h : BC
n,s : nat
*****
eq (if andb true false then ok_arities n s else error_comp (ok_arities (S n) s) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s)))) (ok_arities n s)
+++++
case_eq (leb q r); intro H10.
-----
Lemma arities_rec3 n s x g h (Hx : arities x = ok_arities n 0) (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec3 n s x g h) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh.
simpl.
do 4 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).
intro H2.
contradict H2.
omega.
intros p H2.
case_eq (leb n p); intro H3.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H4 end.
do 4 rewrite <- beq_nat_refl.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H5 end.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H6 end.
simpl.
reflexivity.
rewrite forallb_forall_conv in H6.
destruct H6 as [e [H6 H7] ].
rewrite in_map_iff in H6.
destruct H6 as [q [H6 H8] ].
rewrite in_seq_iff in H8.
subst e.
simpl in H7.
case_eq (n+s).
intro H9.
contradict H8.
omega.
intros r H9.
rewrite H9 in H7.
case_eq (leb q r); intro H10.

*****
H10 : eq (Nat.leb q r) true
H9 : eq (Init.Nat.add n s) (S r)
H7 : eq\n (aeq (if Nat.leb q r then ok_arities n s else error_proj n s q)\n (ok_arities n s)) false
r : nat
H8 : and (le n q) (lt q (Init.Nat.add n s))
q : nat
H5 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities n O))\n (map (proj n O) (seq O n))) true
H4 : eq\n (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s)))\n (map (proj (S n) (S s)) (seq (S (S n)) s))) true
H3 : eq (Nat.leb n p) true
H2 : eq (Init.Nat.add n (S s)) (S p)
p : nat
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O))\n (map (proj (S n) O) (seq (S O) n))) true
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n O)
x,g,h : BC
n,s : nat
*****
eq (if andb true false then ok_arities n s else error_comp (ok_arities (S n) s) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s)))) (ok_arities n s)
+++++
rewrite H10 in H7.
-----
Lemma arities_rec3 n s x g h (Hx : arities x = ok_arities n 0) (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec3 n s x g h) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh.
simpl.
do 4 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).
intro H2.
contradict H2.
omega.
intros p H2.
case_eq (leb n p); intro H3.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H4 end.
do 4 rewrite <- beq_nat_refl.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H5 end.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H6 end.
simpl.
reflexivity.
rewrite forallb_forall_conv in H6.
destruct H6 as [e [H6 H7] ].
rewrite in_map_iff in H6.
destruct H6 as [q [H6 H8] ].
rewrite in_seq_iff in H8.
subst e.
simpl in H7.
case_eq (n+s).
intro H9.
contradict H8.
omega.
intros r H9.
rewrite H9 in H7.
case_eq (leb q r); intro H10.
rewrite H10 in H7.

*****
H10 : eq (Nat.leb q r) true
H9 : eq (Init.Nat.add n s) (S r)
H7 : eq (aeq (ok_arities n s) (ok_arities n s)) false
r : nat
H8 : and (le n q) (lt q (Init.Nat.add n s))
q : nat
H5 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities n O))\n (map (proj n O) (seq O n))) true
H4 : eq\n (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s)))\n (map (proj (S n) (S s)) (seq (S (S n)) s))) true
H3 : eq (Nat.leb n p) true
H2 : eq (Init.Nat.add n (S s)) (S p)
p : nat
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O))\n (map (proj (S n) O) (seq (S O) n))) true
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n O)
x,g,h : BC
n,s : nat
*****
eq (if andb true false then ok_arities n s else error_comp (ok_arities (S n) s) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s)))) (ok_arities n s)
+++++
simpl in H7.
-----
Lemma arities_rec3 n s x g h (Hx : arities x = ok_arities n 0) (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec3 n s x g h) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh.
simpl.
do 4 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).
intro H2.
contradict H2.
omega.
intros p H2.
case_eq (leb n p); intro H3.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H4 end.
do 4 rewrite <- beq_nat_refl.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H5 end.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H6 end.
simpl.
reflexivity.
rewrite forallb_forall_conv in H6.
destruct H6 as [e [H6 H7] ].
rewrite in_map_iff in H6.
destruct H6 as [q [H6 H8] ].
rewrite in_seq_iff in H8.
subst e.
simpl in H7.
case_eq (n+s).
intro H9.
contradict H8.
omega.
intros r H9.
rewrite H9 in H7.
case_eq (leb q r); intro H10.
rewrite H10 in H7.
simpl in H7.

*****
H10 : eq (Nat.leb q r) true
H9 : eq (Init.Nat.add n s) (S r)
H7 : eq (andb (Nat.eqb n n) (Nat.eqb s s)) false
r : nat
H8 : and (le n q) (lt q (Init.Nat.add n s))
q : nat
H5 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities n O))\n (map (proj n O) (seq O n))) true
H4 : eq\n (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s)))\n (map (proj (S n) (S s)) (seq (S (S n)) s))) true
H3 : eq (Nat.leb n p) true
H2 : eq (Init.Nat.add n (S s)) (S p)
p : nat
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O))\n (map (proj (S n) O) (seq (S O) n))) true
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n O)
x,g,h : BC
n,s : nat
*****
eq (if andb true false then ok_arities n s else error_comp (ok_arities (S n) s) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s)))) (ok_arities n s)
+++++
do 2 rewrite <- beq_nat_refl in H7.
-----
Lemma arities_rec3 n s x g h (Hx : arities x = ok_arities n 0) (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec3 n s x g h) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh.
simpl.
do 4 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).
intro H2.
contradict H2.
omega.
intros p H2.
case_eq (leb n p); intro H3.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H4 end.
do 4 rewrite <- beq_nat_refl.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H5 end.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H6 end.
simpl.
reflexivity.
rewrite forallb_forall_conv in H6.
destruct H6 as [e [H6 H7] ].
rewrite in_map_iff in H6.
destruct H6 as [q [H6 H8] ].
rewrite in_seq_iff in H8.
subst e.
simpl in H7.
case_eq (n+s).
intro H9.
contradict H8.
omega.
intros r H9.
rewrite H9 in H7.
case_eq (leb q r); intro H10.
rewrite H10 in H7.
simpl in H7.
do 2 rewrite <- beq_nat_refl in H7.

*****
H10 : eq (Nat.leb q r) true
H9 : eq (Init.Nat.add n s) (S r)
H7 : eq (andb true true) false
r : nat
H8 : and (le n q) (lt q (Init.Nat.add n s))
q : nat
H5 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities n O))\n (map (proj n O) (seq O n))) true
H4 : eq\n (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s)))\n (map (proj (S n) (S s)) (seq (S (S n)) s))) true
H3 : eq (Nat.leb n p) true
H2 : eq (Init.Nat.add n (S s)) (S p)
p : nat
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O))\n (map (proj (S n) O) (seq (S O) n))) true
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n O)
x,g,h : BC
n,s : nat
*****
eq (if andb true false then ok_arities n s else error_comp (ok_arities (S n) s) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s)))) (ok_arities n s)
+++++
discriminate H7.
-----
Lemma arities_rec3 n s x g h (Hx : arities x = ok_arities n 0) (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec3 n s x g h) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh.
simpl.
do 4 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).
intro H2.
contradict H2.
omega.
intros p H2.
case_eq (leb n p); intro H3.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H4 end.
do 4 rewrite <- beq_nat_refl.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H5 end.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H6 end.
simpl.
reflexivity.
rewrite forallb_forall_conv in H6.
destruct H6 as [e [H6 H7] ].
rewrite in_map_iff in H6.
destruct H6 as [q [H6 H8] ].
rewrite in_seq_iff in H8.
subst e.
simpl in H7.
case_eq (n+s).
intro H9.
contradict H8.
omega.
intros r H9.
rewrite H9 in H7.
case_eq (leb q r); intro H10.
rewrite H10 in H7.
simpl in H7.
do 2 rewrite <- beq_nat_refl in H7.
discriminate H7.

*****
H10 : eq (Nat.leb q r) false
H9 : eq (Init.Nat.add n s) (S r)
H7 : eq\n (aeq (if Nat.leb q r then ok_arities n s else error_proj n s q)\n (ok_arities n s)) false
r : nat
H8 : and (le n q) (lt q (Init.Nat.add n s))
q : nat
H5 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities n O))\n (map (proj n O) (seq O n))) true
H4 : eq\n (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s)))\n (map (proj (S n) (S s)) (seq (S (S n)) s))) true
H3 : eq (Nat.leb n p) true
H2 : eq (Init.Nat.add n (S s)) (S p)
p : nat
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O))\n (map (proj (S n) O) (seq (S O) n))) true
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n O)
x,g,h : BC
n,s : nat
*****
eq (if andb true false then ok_arities n s else error_comp (ok_arities (S n) s) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s)))) (ok_arities n s)
+++++
rewrite leb_iff_conv in H10.
-----
Lemma arities_rec3 n s x g h (Hx : arities x = ok_arities n 0) (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec3 n s x g h) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh.
simpl.
do 4 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).
intro H2.
contradict H2.
omega.
intros p H2.
case_eq (leb n p); intro H3.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H4 end.
do 4 rewrite <- beq_nat_refl.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H5 end.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H6 end.
simpl.
reflexivity.
rewrite forallb_forall_conv in H6.
destruct H6 as [e [H6 H7] ].
rewrite in_map_iff in H6.
destruct H6 as [q [H6 H8] ].
rewrite in_seq_iff in H8.
subst e.
simpl in H7.
case_eq (n+s).
intro H9.
contradict H8.
omega.
intros r H9.
rewrite H9 in H7.
case_eq (leb q r); intro H10.
rewrite H10 in H7.
simpl in H7.
do 2 rewrite <- beq_nat_refl in H7.
discriminate H7.
rewrite leb_iff_conv in H10.

*****
H10 : lt r q
H9 : eq (Init.Nat.add n s) (S r)
H7 : eq\n (aeq (if Nat.leb q r then ok_arities n s else error_proj n s q)\n (ok_arities n s)) false
r : nat
H8 : and (le n q) (lt q (Init.Nat.add n s))
q : nat
H5 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities n O))\n (map (proj n O) (seq O n))) true
H4 : eq\n (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s)))\n (map (proj (S n) (S s)) (seq (S (S n)) s))) true
H3 : eq (Nat.leb n p) true
H2 : eq (Init.Nat.add n (S s)) (S p)
p : nat
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O))\n (map (proj (S n) O) (seq (S O) n))) true
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n O)
x,g,h : BC
n,s : nat
*****
eq (if andb true false then ok_arities n s else error_comp (ok_arities (S n) s) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s)))) (ok_arities n s)
+++++
contradict H10.
-----
Lemma arities_rec3 n s x g h (Hx : arities x = ok_arities n 0) (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec3 n s x g h) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh.
simpl.
do 4 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).
intro H2.
contradict H2.
omega.
intros p H2.
case_eq (leb n p); intro H3.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H4 end.
do 4 rewrite <- beq_nat_refl.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H5 end.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H6 end.
simpl.
reflexivity.
rewrite forallb_forall_conv in H6.
destruct H6 as [e [H6 H7] ].
rewrite in_map_iff in H6.
destruct H6 as [q [H6 H8] ].
rewrite in_seq_iff in H8.
subst e.
simpl in H7.
case_eq (n+s).
intro H9.
contradict H8.
omega.
intros r H9.
rewrite H9 in H7.
case_eq (leb q r); intro H10.
rewrite H10 in H7.
simpl in H7.
do 2 rewrite <- beq_nat_refl in H7.
discriminate H7.
rewrite leb_iff_conv in H10.
contradict H10.

*****
H9 : eq (Init.Nat.add n s) (S r)
H7 : eq\n (aeq (if Nat.leb q r then ok_arities n s else error_proj n s q)\n (ok_arities n s)) false
r : nat
H8 : and (le n q) (lt q (Init.Nat.add n s))
q : nat
H5 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities n O))\n (map (proj n O) (seq O n))) true
H4 : eq\n (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s)))\n (map (proj (S n) (S s)) (seq (S (S n)) s))) true
H3 : eq (Nat.leb n p) true
H2 : eq (Init.Nat.add n (S s)) (S p)
p : nat
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O))\n (map (proj (S n) O) (seq (S O) n))) true
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n O)
x,g,h : BC
n,s : nat
*****
not (lt r q)
+++++
omega.
-----
Lemma arities_rec3 n s x g h (Hx : arities x = ok_arities n 0) (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec3 n s x g h) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh.
simpl.
do 4 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).
intro H2.
contradict H2.
omega.
intros p H2.
case_eq (leb n p); intro H3.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H4 end.
do 4 rewrite <- beq_nat_refl.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H5 end.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H6 end.
simpl.
reflexivity.
rewrite forallb_forall_conv in H6.
destruct H6 as [e [H6 H7] ].
rewrite in_map_iff in H6.
destruct H6 as [q [H6 H8] ].
rewrite in_seq_iff in H8.
subst e.
simpl in H7.
case_eq (n+s).
intro H9.
contradict H8.
omega.
intros r H9.
rewrite H9 in H7.
case_eq (leb q r); intro H10.
rewrite H10 in H7.
simpl in H7.
do 2 rewrite <- beq_nat_refl in H7.
discriminate H7.
rewrite leb_iff_conv in H10.
contradict H10.
omega.

*****
H5 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities n O))\n (map (proj n O) (seq O n))) false
H4 : eq\n (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s)))\n (map (proj (S n) (S s)) (seq (S (S n)) s))) true
H3 : eq (Nat.leb n p) true
H2 : eq (Init.Nat.add n (S s)) (S p)
p : nat
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O))\n (map (proj (S n) O) (seq (S O) n))) true
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n O)
x,g,h : BC
n,s : nat
*****
eq (if andb false (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s))) then ok_arities n s else error_comp (ok_arities (S n) s) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s)))) (ok_arities n s)
+++++
rewrite forallb_forall_conv in H5.
-----
Lemma arities_rec3 n s x g h (Hx : arities x = ok_arities n 0) (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec3 n s x g h) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh.
simpl.
do 4 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).
intro H2.
contradict H2.
omega.
intros p H2.
case_eq (leb n p); intro H3.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H4 end.
do 4 rewrite <- beq_nat_refl.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H5 end.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H6 end.
simpl.
reflexivity.
rewrite forallb_forall_conv in H6.
destruct H6 as [e [H6 H7] ].
rewrite in_map_iff in H6.
destruct H6 as [q [H6 H8] ].
rewrite in_seq_iff in H8.
subst e.
simpl in H7.
case_eq (n+s).
intro H9.
contradict H8.
omega.
intros r H9.
rewrite H9 in H7.
case_eq (leb q r); intro H10.
rewrite H10 in H7.
simpl in H7.
do 2 rewrite <- beq_nat_refl in H7.
discriminate H7.
rewrite leb_iff_conv in H10.
contradict H10.
omega.
rewrite forallb_forall_conv in H5.

*****
H5 : ex\n (fun x : BC =>\n and (In x (map (proj n O) (seq O n)))\n (eq (aeq (arities x) (ok_arities n O)) false))
H4 : eq\n (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s)))\n (map (proj (S n) (S s)) (seq (S (S n)) s))) true
H3 : eq (Nat.leb n p) true
H2 : eq (Init.Nat.add n (S s)) (S p)
p : nat
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O))\n (map (proj (S n) O) (seq (S O) n))) true
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n O)
x,g,h : BC
n,s : nat
*****
eq (if andb false (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s))) then ok_arities n s else error_comp (ok_arities (S n) s) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s)))) (ok_arities n s)
+++++
destruct H5 as [e [H5 H6] ].
-----
Lemma arities_rec3 n s x g h (Hx : arities x = ok_arities n 0) (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec3 n s x g h) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh.
simpl.
do 4 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).
intro H2.
contradict H2.
omega.
intros p H2.
case_eq (leb n p); intro H3.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H4 end.
do 4 rewrite <- beq_nat_refl.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H5 end.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H6 end.
simpl.
reflexivity.
rewrite forallb_forall_conv in H6.
destruct H6 as [e [H6 H7] ].
rewrite in_map_iff in H6.
destruct H6 as [q [H6 H8] ].
rewrite in_seq_iff in H8.
subst e.
simpl in H7.
case_eq (n+s).
intro H9.
contradict H8.
omega.
intros r H9.
rewrite H9 in H7.
case_eq (leb q r); intro H10.
rewrite H10 in H7.
simpl in H7.
do 2 rewrite <- beq_nat_refl in H7.
discriminate H7.
rewrite leb_iff_conv in H10.
contradict H10.
omega.
rewrite forallb_forall_conv in H5.
destruct H5 as [e [H5 H6] ].

*****
H6 : eq (aeq (arities e) (ok_arities n O)) false
H5 : In e (map (proj n O) (seq O n))
e : BC
H4 : eq\n (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s)))\n (map (proj (S n) (S s)) (seq (S (S n)) s))) true
H3 : eq (Nat.leb n p) true
H2 : eq (Init.Nat.add n (S s)) (S p)
p : nat
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O))\n (map (proj (S n) O) (seq (S O) n))) true
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n O)
x,g,h : BC
n,s : nat
*****
eq (if andb false (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s))) then ok_arities n s else error_comp (ok_arities (S n) s) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s)))) (ok_arities n s)
+++++
rewrite in_map_iff in H5.
-----
Lemma arities_rec3 n s x g h (Hx : arities x = ok_arities n 0) (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec3 n s x g h) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh.
simpl.
do 4 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).
intro H2.
contradict H2.
omega.
intros p H2.
case_eq (leb n p); intro H3.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H4 end.
do 4 rewrite <- beq_nat_refl.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H5 end.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H6 end.
simpl.
reflexivity.
rewrite forallb_forall_conv in H6.
destruct H6 as [e [H6 H7] ].
rewrite in_map_iff in H6.
destruct H6 as [q [H6 H8] ].
rewrite in_seq_iff in H8.
subst e.
simpl in H7.
case_eq (n+s).
intro H9.
contradict H8.
omega.
intros r H9.
rewrite H9 in H7.
case_eq (leb q r); intro H10.
rewrite H10 in H7.
simpl in H7.
do 2 rewrite <- beq_nat_refl in H7.
discriminate H7.
rewrite leb_iff_conv in H10.
contradict H10.
omega.
rewrite forallb_forall_conv in H5.
destruct H5 as [e [H5 H6] ].
rewrite in_map_iff in H5.

*****
H6 : eq (aeq (arities e) (ok_arities n O)) false
H5 : ex (fun x : nat => and (eq (proj n O x) e) (In x (seq O n)))
e : BC
H4 : eq\n (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s)))\n (map (proj (S n) (S s)) (seq (S (S n)) s))) true
H3 : eq (Nat.leb n p) true
H2 : eq (Init.Nat.add n (S s)) (S p)
p : nat
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O))\n (map (proj (S n) O) (seq (S O) n))) true
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n O)
x,g,h : BC
n,s : nat
*****
eq (if andb false (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s))) then ok_arities n s else error_comp (ok_arities (S n) s) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s)))) (ok_arities n s)
+++++
destruct H5 as [q [H5 H7] ].
-----
Lemma arities_rec3 n s x g h (Hx : arities x = ok_arities n 0) (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec3 n s x g h) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh.
simpl.
do 4 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).
intro H2.
contradict H2.
omega.
intros p H2.
case_eq (leb n p); intro H3.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H4 end.
do 4 rewrite <- beq_nat_refl.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H5 end.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H6 end.
simpl.
reflexivity.
rewrite forallb_forall_conv in H6.
destruct H6 as [e [H6 H7] ].
rewrite in_map_iff in H6.
destruct H6 as [q [H6 H8] ].
rewrite in_seq_iff in H8.
subst e.
simpl in H7.
case_eq (n+s).
intro H9.
contradict H8.
omega.
intros r H9.
rewrite H9 in H7.
case_eq (leb q r); intro H10.
rewrite H10 in H7.
simpl in H7.
do 2 rewrite <- beq_nat_refl in H7.
discriminate H7.
rewrite leb_iff_conv in H10.
contradict H10.
omega.
rewrite forallb_forall_conv in H5.
destruct H5 as [e [H5 H6] ].
rewrite in_map_iff in H5.
destruct H5 as [q [H5 H7] ].

*****
H6 : eq (aeq (arities e) (ok_arities n O)) false
H7 : In q (seq O n)
H5 : eq (proj n O q) e
q : nat
e : BC
H4 : eq\n (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s)))\n (map (proj (S n) (S s)) (seq (S (S n)) s))) true
H3 : eq (Nat.leb n p) true
H2 : eq (Init.Nat.add n (S s)) (S p)
p : nat
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O))\n (map (proj (S n) O) (seq (S O) n))) true
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n O)
x,g,h : BC
n,s : nat
*****
eq (if andb false (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s))) then ok_arities n s else error_comp (ok_arities (S n) s) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s)))) (ok_arities n s)
+++++
rewrite in_seq_iff in H7.
-----
Lemma arities_rec3 n s x g h (Hx : arities x = ok_arities n 0) (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec3 n s x g h) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh.
simpl.
do 4 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).
intro H2.
contradict H2.
omega.
intros p H2.
case_eq (leb n p); intro H3.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H4 end.
do 4 rewrite <- beq_nat_refl.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H5 end.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H6 end.
simpl.
reflexivity.
rewrite forallb_forall_conv in H6.
destruct H6 as [e [H6 H7] ].
rewrite in_map_iff in H6.
destruct H6 as [q [H6 H8] ].
rewrite in_seq_iff in H8.
subst e.
simpl in H7.
case_eq (n+s).
intro H9.
contradict H8.
omega.
intros r H9.
rewrite H9 in H7.
case_eq (leb q r); intro H10.
rewrite H10 in H7.
simpl in H7.
do 2 rewrite <- beq_nat_refl in H7.
discriminate H7.
rewrite leb_iff_conv in H10.
contradict H10.
omega.
rewrite forallb_forall_conv in H5.
destruct H5 as [e [H5 H6] ].
rewrite in_map_iff in H5.
destruct H5 as [q [H5 H7] ].
rewrite in_seq_iff in H7.

*****
H6 : eq (aeq (arities e) (ok_arities n O)) false
H7 : and (le O q) (lt q (Init.Nat.add O n))
H5 : eq (proj n O q) e
q : nat
e : BC
H4 : eq\n (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s)))\n (map (proj (S n) (S s)) (seq (S (S n)) s))) true
H3 : eq (Nat.leb n p) true
H2 : eq (Init.Nat.add n (S s)) (S p)
p : nat
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O))\n (map (proj (S n) O) (seq (S O) n))) true
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n O)
x,g,h : BC
n,s : nat
*****
eq (if andb false (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s))) then ok_arities n s else error_comp (ok_arities (S n) s) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s)))) (ok_arities n s)
+++++
subst e.
-----
Lemma arities_rec3 n s x g h (Hx : arities x = ok_arities n 0) (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec3 n s x g h) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh.
simpl.
do 4 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).
intro H2.
contradict H2.
omega.
intros p H2.
case_eq (leb n p); intro H3.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H4 end.
do 4 rewrite <- beq_nat_refl.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H5 end.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H6 end.
simpl.
reflexivity.
rewrite forallb_forall_conv in H6.
destruct H6 as [e [H6 H7] ].
rewrite in_map_iff in H6.
destruct H6 as [q [H6 H8] ].
rewrite in_seq_iff in H8.
subst e.
simpl in H7.
case_eq (n+s).
intro H9.
contradict H8.
omega.
intros r H9.
rewrite H9 in H7.
case_eq (leb q r); intro H10.
rewrite H10 in H7.
simpl in H7.
do 2 rewrite <- beq_nat_refl in H7.
discriminate H7.
rewrite leb_iff_conv in H10.
contradict H10.
omega.
rewrite forallb_forall_conv in H5.
destruct H5 as [e [H5 H6] ].
rewrite in_map_iff in H5.
destruct H5 as [q [H5 H7] ].
rewrite in_seq_iff in H7.
subst e.

*****
H6 : eq (aeq (arities (proj n O q)) (ok_arities n O)) false
H7 : and (le O q) (lt q (Init.Nat.add O n))
q : nat
H4 : eq\n (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s)))\n (map (proj (S n) (S s)) (seq (S (S n)) s))) true
H3 : eq (Nat.leb n p) true
H2 : eq (Init.Nat.add n (S s)) (S p)
p : nat
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O))\n (map (proj (S n) O) (seq (S O) n))) true
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n O)
x,g,h : BC
n,s : nat
*****
eq (if andb false (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s))) then ok_arities n s else error_comp (ok_arities (S n) s) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s)))) (ok_arities n s)
+++++
simpl in H6.
-----
Lemma arities_rec3 n s x g h (Hx : arities x = ok_arities n 0) (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec3 n s x g h) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh.
simpl.
do 4 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).
intro H2.
contradict H2.
omega.
intros p H2.
case_eq (leb n p); intro H3.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H4 end.
do 4 rewrite <- beq_nat_refl.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H5 end.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H6 end.
simpl.
reflexivity.
rewrite forallb_forall_conv in H6.
destruct H6 as [e [H6 H7] ].
rewrite in_map_iff in H6.
destruct H6 as [q [H6 H8] ].
rewrite in_seq_iff in H8.
subst e.
simpl in H7.
case_eq (n+s).
intro H9.
contradict H8.
omega.
intros r H9.
rewrite H9 in H7.
case_eq (leb q r); intro H10.
rewrite H10 in H7.
simpl in H7.
do 2 rewrite <- beq_nat_refl in H7.
discriminate H7.
rewrite leb_iff_conv in H10.
contradict H10.
omega.
rewrite forallb_forall_conv in H5.
destruct H5 as [e [H5 H6] ].
rewrite in_map_iff in H5.
destruct H5 as [q [H5 H7] ].
rewrite in_seq_iff in H7.
subst e.
simpl in H6.

*****
H6 : eq\n (aeq\n (if\n match Init.Nat.add n O with\n | O => false\n | S m' => Nat.leb q m'\n end\n then ok_arities n O\n else error_proj n O q) (ok_arities n O)) false
H7 : and (le O q) (lt q (Init.Nat.add O n))
q : nat
H4 : eq\n (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s)))\n (map (proj (S n) (S s)) (seq (S (S n)) s))) true
H3 : eq (Nat.leb n p) true
H2 : eq (Init.Nat.add n (S s)) (S p)
p : nat
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O))\n (map (proj (S n) O) (seq (S O) n))) true
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n O)
x,g,h : BC
n,s : nat
*****
eq (if andb false (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s))) then ok_arities n s else error_comp (ok_arities (S n) s) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s)))) (ok_arities n s)
+++++
case_eq (n+0).
-----
Lemma arities_rec3 n s x g h (Hx : arities x = ok_arities n 0) (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec3 n s x g h) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh.
simpl.
do 4 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).
intro H2.
contradict H2.
omega.
intros p H2.
case_eq (leb n p); intro H3.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H4 end.
do 4 rewrite <- beq_nat_refl.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H5 end.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H6 end.
simpl.
reflexivity.
rewrite forallb_forall_conv in H6.
destruct H6 as [e [H6 H7] ].
rewrite in_map_iff in H6.
destruct H6 as [q [H6 H8] ].
rewrite in_seq_iff in H8.
subst e.
simpl in H7.
case_eq (n+s).
intro H9.
contradict H8.
omega.
intros r H9.
rewrite H9 in H7.
case_eq (leb q r); intro H10.
rewrite H10 in H7.
simpl in H7.
do 2 rewrite <- beq_nat_refl in H7.
discriminate H7.
rewrite leb_iff_conv in H10.
contradict H10.
omega.
rewrite forallb_forall_conv in H5.
destruct H5 as [e [H5 H6] ].
rewrite in_map_iff in H5.
destruct H5 as [q [H5 H7] ].
rewrite in_seq_iff in H7.
subst e.
simpl in H6.
case_eq (n+0).

*****
H6 : eq\n (aeq\n (if\n match Init.Nat.add n O with\n | O => false\n | S m' => Nat.leb q m'\n end\n then ok_arities n O\n else error_proj n O q) (ok_arities n O)) false
H7 : and (le O q) (lt q (Init.Nat.add O n))
q : nat
H4 : eq\n (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s)))\n (map (proj (S n) (S s)) (seq (S (S n)) s))) true
H3 : eq (Nat.leb n p) true
H2 : eq (Init.Nat.add n (S s)) (S p)
p : nat
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O))\n (map (proj (S n) O) (seq (S O) n))) true
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n O)
x,g,h : BC
n,s : nat
*****
forall _ : eq (Init.Nat.add n O) O, eq (if andb false (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s))) then ok_arities n s else error_comp (ok_arities (S n) s) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s)))) (ok_arities n s)
+++++
intro H8.
-----
Lemma arities_rec3 n s x g h (Hx : arities x = ok_arities n 0) (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec3 n s x g h) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh.
simpl.
do 4 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).
intro H2.
contradict H2.
omega.
intros p H2.
case_eq (leb n p); intro H3.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H4 end.
do 4 rewrite <- beq_nat_refl.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H5 end.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H6 end.
simpl.
reflexivity.
rewrite forallb_forall_conv in H6.
destruct H6 as [e [H6 H7] ].
rewrite in_map_iff in H6.
destruct H6 as [q [H6 H8] ].
rewrite in_seq_iff in H8.
subst e.
simpl in H7.
case_eq (n+s).
intro H9.
contradict H8.
omega.
intros r H9.
rewrite H9 in H7.
case_eq (leb q r); intro H10.
rewrite H10 in H7.
simpl in H7.
do 2 rewrite <- beq_nat_refl in H7.
discriminate H7.
rewrite leb_iff_conv in H10.
contradict H10.
omega.
rewrite forallb_forall_conv in H5.
destruct H5 as [e [H5 H6] ].
rewrite in_map_iff in H5.
destruct H5 as [q [H5 H7] ].
rewrite in_seq_iff in H7.
subst e.
simpl in H6.
case_eq (n+0).
intro H8.

*****
H8 : eq (Init.Nat.add n O) O
H6 : eq\n (aeq\n (if\n match Init.Nat.add n O with\n | O => false\n | S m' => Nat.leb q m'\n end\n then ok_arities n O\n else error_proj n O q) (ok_arities n O)) false
H7 : and (le O q) (lt q (Init.Nat.add O n))
q : nat
H4 : eq\n (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s)))\n (map (proj (S n) (S s)) (seq (S (S n)) s))) true
H3 : eq (Nat.leb n p) true
H2 : eq (Init.Nat.add n (S s)) (S p)
p : nat
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O))\n (map (proj (S n) O) (seq (S O) n))) true
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n O)
x,g,h : BC
n,s : nat
*****
eq (if andb false (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s))) then ok_arities n s else error_comp (ok_arities (S n) s) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s)))) (ok_arities n s)
+++++
contradict H7.
-----
Lemma arities_rec3 n s x g h (Hx : arities x = ok_arities n 0) (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec3 n s x g h) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh.
simpl.
do 4 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).
intro H2.
contradict H2.
omega.
intros p H2.
case_eq (leb n p); intro H3.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H4 end.
do 4 rewrite <- beq_nat_refl.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H5 end.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H6 end.
simpl.
reflexivity.
rewrite forallb_forall_conv in H6.
destruct H6 as [e [H6 H7] ].
rewrite in_map_iff in H6.
destruct H6 as [q [H6 H8] ].
rewrite in_seq_iff in H8.
subst e.
simpl in H7.
case_eq (n+s).
intro H9.
contradict H8.
omega.
intros r H9.
rewrite H9 in H7.
case_eq (leb q r); intro H10.
rewrite H10 in H7.
simpl in H7.
do 2 rewrite <- beq_nat_refl in H7.
discriminate H7.
rewrite leb_iff_conv in H10.
contradict H10.
omega.
rewrite forallb_forall_conv in H5.
destruct H5 as [e [H5 H6] ].
rewrite in_map_iff in H5.
destruct H5 as [q [H5 H7] ].
rewrite in_seq_iff in H7.
subst e.
simpl in H6.
case_eq (n+0).
intro H8.
contradict H7.

*****
H8 : eq (Init.Nat.add n O) O
H6 : eq\n (aeq\n (if\n match Init.Nat.add n O with\n | O => false\n | S m' => Nat.leb q m'\n end\n then ok_arities n O\n else error_proj n O q) (ok_arities n O)) false
q : nat
H4 : eq\n (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s)))\n (map (proj (S n) (S s)) (seq (S (S n)) s))) true
H3 : eq (Nat.leb n p) true
H2 : eq (Init.Nat.add n (S s)) (S p)
p : nat
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O))\n (map (proj (S n) O) (seq (S O) n))) true
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n O)
x,g,h : BC
n,s : nat
*****
not (and (le O q) (lt q (Init.Nat.add O n)))
+++++
omega.
-----
Lemma arities_rec3 n s x g h (Hx : arities x = ok_arities n 0) (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec3 n s x g h) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh.
simpl.
do 4 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).
intro H2.
contradict H2.
omega.
intros p H2.
case_eq (leb n p); intro H3.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H4 end.
do 4 rewrite <- beq_nat_refl.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H5 end.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H6 end.
simpl.
reflexivity.
rewrite forallb_forall_conv in H6.
destruct H6 as [e [H6 H7] ].
rewrite in_map_iff in H6.
destruct H6 as [q [H6 H8] ].
rewrite in_seq_iff in H8.
subst e.
simpl in H7.
case_eq (n+s).
intro H9.
contradict H8.
omega.
intros r H9.
rewrite H9 in H7.
case_eq (leb q r); intro H10.
rewrite H10 in H7.
simpl in H7.
do 2 rewrite <- beq_nat_refl in H7.
discriminate H7.
rewrite leb_iff_conv in H10.
contradict H10.
omega.
rewrite forallb_forall_conv in H5.
destruct H5 as [e [H5 H6] ].
rewrite in_map_iff in H5.
destruct H5 as [q [H5 H7] ].
rewrite in_seq_iff in H7.
subst e.
simpl in H6.
case_eq (n+0).
intro H8.
contradict H7.
omega.

*****
H6 : eq\n (aeq\n (if\n match Init.Nat.add n O with\n | O => false\n | S m' => Nat.leb q m'\n end\n then ok_arities n O\n else error_proj n O q) (ok_arities n O)) false
H7 : and (le O q) (lt q (Init.Nat.add O n))
q : nat
H4 : eq\n (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s)))\n (map (proj (S n) (S s)) (seq (S (S n)) s))) true
H3 : eq (Nat.leb n p) true
H2 : eq (Init.Nat.add n (S s)) (S p)
p : nat
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O))\n (map (proj (S n) O) (seq (S O) n))) true
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n O)
x,g,h : BC
n,s : nat
*****
forall (n0 : nat) (_ : eq (Init.Nat.add n O) (S n0)), eq (if andb false (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s))) then ok_arities n s else error_comp (ok_arities (S n) s) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s)))) (ok_arities n s)
+++++
intros r H8.
-----
Lemma arities_rec3 n s x g h (Hx : arities x = ok_arities n 0) (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec3 n s x g h) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh.
simpl.
do 4 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).
intro H2.
contradict H2.
omega.
intros p H2.
case_eq (leb n p); intro H3.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H4 end.
do 4 rewrite <- beq_nat_refl.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H5 end.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H6 end.
simpl.
reflexivity.
rewrite forallb_forall_conv in H6.
destruct H6 as [e [H6 H7] ].
rewrite in_map_iff in H6.
destruct H6 as [q [H6 H8] ].
rewrite in_seq_iff in H8.
subst e.
simpl in H7.
case_eq (n+s).
intro H9.
contradict H8.
omega.
intros r H9.
rewrite H9 in H7.
case_eq (leb q r); intro H10.
rewrite H10 in H7.
simpl in H7.
do 2 rewrite <- beq_nat_refl in H7.
discriminate H7.
rewrite leb_iff_conv in H10.
contradict H10.
omega.
rewrite forallb_forall_conv in H5.
destruct H5 as [e [H5 H6] ].
rewrite in_map_iff in H5.
destruct H5 as [q [H5 H7] ].
rewrite in_seq_iff in H7.
subst e.
simpl in H6.
case_eq (n+0).
intro H8.
contradict H7.
omega.
intros r H8.

*****
H8 : eq (Init.Nat.add n O) (S r)
r : nat
H6 : eq\n (aeq\n (if\n match Init.Nat.add n O with\n | O => false\n | S m' => Nat.leb q m'\n end\n then ok_arities n O\n else error_proj n O q) (ok_arities n O)) false
H7 : and (le O q) (lt q (Init.Nat.add O n))
q : nat
H4 : eq\n (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s)))\n (map (proj (S n) (S s)) (seq (S (S n)) s))) true
H3 : eq (Nat.leb n p) true
H2 : eq (Init.Nat.add n (S s)) (S p)
p : nat
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O))\n (map (proj (S n) O) (seq (S O) n))) true
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n O)
x,g,h : BC
n,s : nat
*****
eq (if andb false (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s))) then ok_arities n s else error_comp (ok_arities (S n) s) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s)))) (ok_arities n s)
+++++
rewrite H8 in H6.
-----
Lemma arities_rec3 n s x g h (Hx : arities x = ok_arities n 0) (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec3 n s x g h) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh.
simpl.
do 4 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).
intro H2.
contradict H2.
omega.
intros p H2.
case_eq (leb n p); intro H3.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H4 end.
do 4 rewrite <- beq_nat_refl.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H5 end.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H6 end.
simpl.
reflexivity.
rewrite forallb_forall_conv in H6.
destruct H6 as [e [H6 H7] ].
rewrite in_map_iff in H6.
destruct H6 as [q [H6 H8] ].
rewrite in_seq_iff in H8.
subst e.
simpl in H7.
case_eq (n+s).
intro H9.
contradict H8.
omega.
intros r H9.
rewrite H9 in H7.
case_eq (leb q r); intro H10.
rewrite H10 in H7.
simpl in H7.
do 2 rewrite <- beq_nat_refl in H7.
discriminate H7.
rewrite leb_iff_conv in H10.
contradict H10.
omega.
rewrite forallb_forall_conv in H5.
destruct H5 as [e [H5 H6] ].
rewrite in_map_iff in H5.
destruct H5 as [q [H5 H7] ].
rewrite in_seq_iff in H7.
subst e.
simpl in H6.
case_eq (n+0).
intro H8.
contradict H7.
omega.
intros r H8.
rewrite H8 in H6.

*****
H8 : eq (Init.Nat.add n O) (S r)
H6 : eq\n (aeq (if Nat.leb q r then ok_arities n O else error_proj n O q)\n (ok_arities n O)) false
r : nat
H7 : and (le O q) (lt q (Init.Nat.add O n))
q : nat
H4 : eq\n (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s)))\n (map (proj (S n) (S s)) (seq (S (S n)) s))) true
H3 : eq (Nat.leb n p) true
H2 : eq (Init.Nat.add n (S s)) (S p)
p : nat
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O))\n (map (proj (S n) O) (seq (S O) n))) true
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n O)
x,g,h : BC
n,s : nat
*****
eq (if andb false (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s))) then ok_arities n s else error_comp (ok_arities (S n) s) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s)))) (ok_arities n s)
+++++
case_eq (leb q r); intro H9.
-----
Lemma arities_rec3 n s x g h (Hx : arities x = ok_arities n 0) (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec3 n s x g h) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh.
simpl.
do 4 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).
intro H2.
contradict H2.
omega.
intros p H2.
case_eq (leb n p); intro H3.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H4 end.
do 4 rewrite <- beq_nat_refl.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H5 end.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H6 end.
simpl.
reflexivity.
rewrite forallb_forall_conv in H6.
destruct H6 as [e [H6 H7] ].
rewrite in_map_iff in H6.
destruct H6 as [q [H6 H8] ].
rewrite in_seq_iff in H8.
subst e.
simpl in H7.
case_eq (n+s).
intro H9.
contradict H8.
omega.
intros r H9.
rewrite H9 in H7.
case_eq (leb q r); intro H10.
rewrite H10 in H7.
simpl in H7.
do 2 rewrite <- beq_nat_refl in H7.
discriminate H7.
rewrite leb_iff_conv in H10.
contradict H10.
omega.
rewrite forallb_forall_conv in H5.
destruct H5 as [e [H5 H6] ].
rewrite in_map_iff in H5.
destruct H5 as [q [H5 H7] ].
rewrite in_seq_iff in H7.
subst e.
simpl in H6.
case_eq (n+0).
intro H8.
contradict H7.
omega.
intros r H8.
rewrite H8 in H6.
case_eq (leb q r); intro H9.

*****
H9 : eq (Nat.leb q r) true
H8 : eq (Init.Nat.add n O) (S r)
H6 : eq\n (aeq (if Nat.leb q r then ok_arities n O else error_proj n O q)\n (ok_arities n O)) false
r : nat
H7 : and (le O q) (lt q (Init.Nat.add O n))
q : nat
H4 : eq\n (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s)))\n (map (proj (S n) (S s)) (seq (S (S n)) s))) true
H3 : eq (Nat.leb n p) true
H2 : eq (Init.Nat.add n (S s)) (S p)
p : nat
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O))\n (map (proj (S n) O) (seq (S O) n))) true
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n O)
x,g,h : BC
n,s : nat
*****
eq (if andb false (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s))) then ok_arities n s else error_comp (ok_arities (S n) s) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s)))) (ok_arities n s)
+++++
rewrite H9 in H6.
-----
Lemma arities_rec3 n s x g h (Hx : arities x = ok_arities n 0) (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec3 n s x g h) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh.
simpl.
do 4 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).
intro H2.
contradict H2.
omega.
intros p H2.
case_eq (leb n p); intro H3.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H4 end.
do 4 rewrite <- beq_nat_refl.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H5 end.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H6 end.
simpl.
reflexivity.
rewrite forallb_forall_conv in H6.
destruct H6 as [e [H6 H7] ].
rewrite in_map_iff in H6.
destruct H6 as [q [H6 H8] ].
rewrite in_seq_iff in H8.
subst e.
simpl in H7.
case_eq (n+s).
intro H9.
contradict H8.
omega.
intros r H9.
rewrite H9 in H7.
case_eq (leb q r); intro H10.
rewrite H10 in H7.
simpl in H7.
do 2 rewrite <- beq_nat_refl in H7.
discriminate H7.
rewrite leb_iff_conv in H10.
contradict H10.
omega.
rewrite forallb_forall_conv in H5.
destruct H5 as [e [H5 H6] ].
rewrite in_map_iff in H5.
destruct H5 as [q [H5 H7] ].
rewrite in_seq_iff in H7.
subst e.
simpl in H6.
case_eq (n+0).
intro H8.
contradict H7.
omega.
intros r H8.
rewrite H8 in H6.
case_eq (leb q r); intro H9.
rewrite H9 in H6.

*****
H9 : eq (Nat.leb q r) true
H8 : eq (Init.Nat.add n O) (S r)
H6 : eq (aeq (ok_arities n O) (ok_arities n O)) false
r : nat
H7 : and (le O q) (lt q (Init.Nat.add O n))
q : nat
H4 : eq\n (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s)))\n (map (proj (S n) (S s)) (seq (S (S n)) s))) true
H3 : eq (Nat.leb n p) true
H2 : eq (Init.Nat.add n (S s)) (S p)
p : nat
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O))\n (map (proj (S n) O) (seq (S O) n))) true
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n O)
x,g,h : BC
n,s : nat
*****
eq (if andb false (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s))) then ok_arities n s else error_comp (ok_arities (S n) s) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s)))) (ok_arities n s)
+++++
simpl in H6.
-----
Lemma arities_rec3 n s x g h (Hx : arities x = ok_arities n 0) (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec3 n s x g h) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh.
simpl.
do 4 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).
intro H2.
contradict H2.
omega.
intros p H2.
case_eq (leb n p); intro H3.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H4 end.
do 4 rewrite <- beq_nat_refl.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H5 end.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H6 end.
simpl.
reflexivity.
rewrite forallb_forall_conv in H6.
destruct H6 as [e [H6 H7] ].
rewrite in_map_iff in H6.
destruct H6 as [q [H6 H8] ].
rewrite in_seq_iff in H8.
subst e.
simpl in H7.
case_eq (n+s).
intro H9.
contradict H8.
omega.
intros r H9.
rewrite H9 in H7.
case_eq (leb q r); intro H10.
rewrite H10 in H7.
simpl in H7.
do 2 rewrite <- beq_nat_refl in H7.
discriminate H7.
rewrite leb_iff_conv in H10.
contradict H10.
omega.
rewrite forallb_forall_conv in H5.
destruct H5 as [e [H5 H6] ].
rewrite in_map_iff in H5.
destruct H5 as [q [H5 H7] ].
rewrite in_seq_iff in H7.
subst e.
simpl in H6.
case_eq (n+0).
intro H8.
contradict H7.
omega.
intros r H8.
rewrite H8 in H6.
case_eq (leb q r); intro H9.
rewrite H9 in H6.
simpl in H6.

*****
H9 : eq (Nat.leb q r) true
H8 : eq (Init.Nat.add n O) (S r)
H6 : eq (andb (Nat.eqb n n) true) false
r : nat
H7 : and (le O q) (lt q (Init.Nat.add O n))
q : nat
H4 : eq\n (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s)))\n (map (proj (S n) (S s)) (seq (S (S n)) s))) true
H3 : eq (Nat.leb n p) true
H2 : eq (Init.Nat.add n (S s)) (S p)
p : nat
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O))\n (map (proj (S n) O) (seq (S O) n))) true
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n O)
x,g,h : BC
n,s : nat
*****
eq (if andb false (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s))) then ok_arities n s else error_comp (ok_arities (S n) s) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s)))) (ok_arities n s)
+++++
rewrite <- beq_nat_refl in H6.
-----
Lemma arities_rec3 n s x g h (Hx : arities x = ok_arities n 0) (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec3 n s x g h) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh.
simpl.
do 4 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).
intro H2.
contradict H2.
omega.
intros p H2.
case_eq (leb n p); intro H3.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H4 end.
do 4 rewrite <- beq_nat_refl.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H5 end.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H6 end.
simpl.
reflexivity.
rewrite forallb_forall_conv in H6.
destruct H6 as [e [H6 H7] ].
rewrite in_map_iff in H6.
destruct H6 as [q [H6 H8] ].
rewrite in_seq_iff in H8.
subst e.
simpl in H7.
case_eq (n+s).
intro H9.
contradict H8.
omega.
intros r H9.
rewrite H9 in H7.
case_eq (leb q r); intro H10.
rewrite H10 in H7.
simpl in H7.
do 2 rewrite <- beq_nat_refl in H7.
discriminate H7.
rewrite leb_iff_conv in H10.
contradict H10.
omega.
rewrite forallb_forall_conv in H5.
destruct H5 as [e [H5 H6] ].
rewrite in_map_iff in H5.
destruct H5 as [q [H5 H7] ].
rewrite in_seq_iff in H7.
subst e.
simpl in H6.
case_eq (n+0).
intro H8.
contradict H7.
omega.
intros r H8.
rewrite H8 in H6.
case_eq (leb q r); intro H9.
rewrite H9 in H6.
simpl in H6.
rewrite <- beq_nat_refl in H6.

*****
H9 : eq (Nat.leb q r) true
H8 : eq (Init.Nat.add n O) (S r)
H6 : eq (andb true true) false
r : nat
H7 : and (le O q) (lt q (Init.Nat.add O n))
q : nat
H4 : eq\n (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s)))\n (map (proj (S n) (S s)) (seq (S (S n)) s))) true
H3 : eq (Nat.leb n p) true
H2 : eq (Init.Nat.add n (S s)) (S p)
p : nat
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O))\n (map (proj (S n) O) (seq (S O) n))) true
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n O)
x,g,h : BC
n,s : nat
*****
eq (if andb false (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s))) then ok_arities n s else error_comp (ok_arities (S n) s) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s)))) (ok_arities n s)
+++++
discriminate H6.
-----
Lemma arities_rec3 n s x g h (Hx : arities x = ok_arities n 0) (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec3 n s x g h) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh.
simpl.
do 4 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).
intro H2.
contradict H2.
omega.
intros p H2.
case_eq (leb n p); intro H3.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H4 end.
do 4 rewrite <- beq_nat_refl.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H5 end.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H6 end.
simpl.
reflexivity.
rewrite forallb_forall_conv in H6.
destruct H6 as [e [H6 H7] ].
rewrite in_map_iff in H6.
destruct H6 as [q [H6 H8] ].
rewrite in_seq_iff in H8.
subst e.
simpl in H7.
case_eq (n+s).
intro H9.
contradict H8.
omega.
intros r H9.
rewrite H9 in H7.
case_eq (leb q r); intro H10.
rewrite H10 in H7.
simpl in H7.
do 2 rewrite <- beq_nat_refl in H7.
discriminate H7.
rewrite leb_iff_conv in H10.
contradict H10.
omega.
rewrite forallb_forall_conv in H5.
destruct H5 as [e [H5 H6] ].
rewrite in_map_iff in H5.
destruct H5 as [q [H5 H7] ].
rewrite in_seq_iff in H7.
subst e.
simpl in H6.
case_eq (n+0).
intro H8.
contradict H7.
omega.
intros r H8.
rewrite H8 in H6.
case_eq (leb q r); intro H9.
rewrite H9 in H6.
simpl in H6.
rewrite <- beq_nat_refl in H6.
discriminate H6.

*****
H9 : eq (Nat.leb q r) false
H8 : eq (Init.Nat.add n O) (S r)
H6 : eq\n (aeq (if Nat.leb q r then ok_arities n O else error_proj n O q)\n (ok_arities n O)) false
r : nat
H7 : and (le O q) (lt q (Init.Nat.add O n))
q : nat
H4 : eq\n (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s)))\n (map (proj (S n) (S s)) (seq (S (S n)) s))) true
H3 : eq (Nat.leb n p) true
H2 : eq (Init.Nat.add n (S s)) (S p)
p : nat
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O))\n (map (proj (S n) O) (seq (S O) n))) true
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n O)
x,g,h : BC
n,s : nat
*****
eq (if andb false (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s))) then ok_arities n s else error_comp (ok_arities (S n) s) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s)))) (ok_arities n s)
+++++
rewrite leb_iff_conv in H9.
-----
Lemma arities_rec3 n s x g h (Hx : arities x = ok_arities n 0) (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec3 n s x g h) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh.
simpl.
do 4 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).
intro H2.
contradict H2.
omega.
intros p H2.
case_eq (leb n p); intro H3.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H4 end.
do 4 rewrite <- beq_nat_refl.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H5 end.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H6 end.
simpl.
reflexivity.
rewrite forallb_forall_conv in H6.
destruct H6 as [e [H6 H7] ].
rewrite in_map_iff in H6.
destruct H6 as [q [H6 H8] ].
rewrite in_seq_iff in H8.
subst e.
simpl in H7.
case_eq (n+s).
intro H9.
contradict H8.
omega.
intros r H9.
rewrite H9 in H7.
case_eq (leb q r); intro H10.
rewrite H10 in H7.
simpl in H7.
do 2 rewrite <- beq_nat_refl in H7.
discriminate H7.
rewrite leb_iff_conv in H10.
contradict H10.
omega.
rewrite forallb_forall_conv in H5.
destruct H5 as [e [H5 H6] ].
rewrite in_map_iff in H5.
destruct H5 as [q [H5 H7] ].
rewrite in_seq_iff in H7.
subst e.
simpl in H6.
case_eq (n+0).
intro H8.
contradict H7.
omega.
intros r H8.
rewrite H8 in H6.
case_eq (leb q r); intro H9.
rewrite H9 in H6.
simpl in H6.
rewrite <- beq_nat_refl in H6.
discriminate H6.
rewrite leb_iff_conv in H9.

*****
H9 : lt r q
H8 : eq (Init.Nat.add n O) (S r)
H6 : eq\n (aeq (if Nat.leb q r then ok_arities n O else error_proj n O q)\n (ok_arities n O)) false
r : nat
H7 : and (le O q) (lt q (Init.Nat.add O n))
q : nat
H4 : eq\n (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s)))\n (map (proj (S n) (S s)) (seq (S (S n)) s))) true
H3 : eq (Nat.leb n p) true
H2 : eq (Init.Nat.add n (S s)) (S p)
p : nat
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O))\n (map (proj (S n) O) (seq (S O) n))) true
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n O)
x,g,h : BC
n,s : nat
*****
eq (if andb false (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s))) then ok_arities n s else error_comp (ok_arities (S n) s) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s)))) (ok_arities n s)
+++++
contradict H9.
-----
Lemma arities_rec3 n s x g h (Hx : arities x = ok_arities n 0) (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec3 n s x g h) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh.
simpl.
do 4 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).
intro H2.
contradict H2.
omega.
intros p H2.
case_eq (leb n p); intro H3.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H4 end.
do 4 rewrite <- beq_nat_refl.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H5 end.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H6 end.
simpl.
reflexivity.
rewrite forallb_forall_conv in H6.
destruct H6 as [e [H6 H7] ].
rewrite in_map_iff in H6.
destruct H6 as [q [H6 H8] ].
rewrite in_seq_iff in H8.
subst e.
simpl in H7.
case_eq (n+s).
intro H9.
contradict H8.
omega.
intros r H9.
rewrite H9 in H7.
case_eq (leb q r); intro H10.
rewrite H10 in H7.
simpl in H7.
do 2 rewrite <- beq_nat_refl in H7.
discriminate H7.
rewrite leb_iff_conv in H10.
contradict H10.
omega.
rewrite forallb_forall_conv in H5.
destruct H5 as [e [H5 H6] ].
rewrite in_map_iff in H5.
destruct H5 as [q [H5 H7] ].
rewrite in_seq_iff in H7.
subst e.
simpl in H6.
case_eq (n+0).
intro H8.
contradict H7.
omega.
intros r H8.
rewrite H8 in H6.
case_eq (leb q r); intro H9.
rewrite H9 in H6.
simpl in H6.
rewrite <- beq_nat_refl in H6.
discriminate H6.
rewrite leb_iff_conv in H9.
contradict H9.

*****
H8 : eq (Init.Nat.add n O) (S r)
H6 : eq\n (aeq (if Nat.leb q r then ok_arities n O else error_proj n O q)\n (ok_arities n O)) false
r : nat
H7 : and (le O q) (lt q (Init.Nat.add O n))
q : nat
H4 : eq\n (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s)))\n (map (proj (S n) (S s)) (seq (S (S n)) s))) true
H3 : eq (Nat.leb n p) true
H2 : eq (Init.Nat.add n (S s)) (S p)
p : nat
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O))\n (map (proj (S n) O) (seq (S O) n))) true
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n O)
x,g,h : BC
n,s : nat
*****
not (lt r q)
+++++
omega.
-----
Lemma arities_rec3 n s x g h (Hx : arities x = ok_arities n 0) (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec3 n s x g h) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh.
simpl.
do 4 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).
intro H2.
contradict H2.
omega.
intros p H2.
case_eq (leb n p); intro H3.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H4 end.
do 4 rewrite <- beq_nat_refl.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H5 end.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H6 end.
simpl.
reflexivity.
rewrite forallb_forall_conv in H6.
destruct H6 as [e [H6 H7] ].
rewrite in_map_iff in H6.
destruct H6 as [q [H6 H8] ].
rewrite in_seq_iff in H8.
subst e.
simpl in H7.
case_eq (n+s).
intro H9.
contradict H8.
omega.
intros r H9.
rewrite H9 in H7.
case_eq (leb q r); intro H10.
rewrite H10 in H7.
simpl in H7.
do 2 rewrite <- beq_nat_refl in H7.
discriminate H7.
rewrite leb_iff_conv in H10.
contradict H10.
omega.
rewrite forallb_forall_conv in H5.
destruct H5 as [e [H5 H6] ].
rewrite in_map_iff in H5.
destruct H5 as [q [H5 H7] ].
rewrite in_seq_iff in H7.
subst e.
simpl in H6.
case_eq (n+0).
intro H8.
contradict H7.
omega.
intros r H8.
rewrite H8 in H6.
case_eq (leb q r); intro H9.
rewrite H9 in H6.
simpl in H6.
rewrite <- beq_nat_refl in H6.
discriminate H6.
rewrite leb_iff_conv in H9.
contradict H9.
omega.

*****
H4 : eq\n (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s)))\n (map (proj (S n) (S s)) (seq (S (S n)) s))) false
H3 : eq (Nat.leb n p) true
H2 : eq (Init.Nat.add n (S s)) (S p)
p : nat
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O))\n (map (proj (S n) O) (seq (S O) n))) true
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n O)
x,g,h : BC
n,s : nat
*****
eq (error_comp (error_rec (ok_arities n s) (error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (ok_arities (S n) (S s)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) (error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (ok_arities (S n) (S s)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s)))))) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s)))) (ok_arities n s)
+++++
rewrite forallb_forall_conv in H4.
-----
Lemma arities_rec3 n s x g h (Hx : arities x = ok_arities n 0) (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec3 n s x g h) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh.
simpl.
do 4 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).
intro H2.
contradict H2.
omega.
intros p H2.
case_eq (leb n p); intro H3.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H4 end.
do 4 rewrite <- beq_nat_refl.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H5 end.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H6 end.
simpl.
reflexivity.
rewrite forallb_forall_conv in H6.
destruct H6 as [e [H6 H7] ].
rewrite in_map_iff in H6.
destruct H6 as [q [H6 H8] ].
rewrite in_seq_iff in H8.
subst e.
simpl in H7.
case_eq (n+s).
intro H9.
contradict H8.
omega.
intros r H9.
rewrite H9 in H7.
case_eq (leb q r); intro H10.
rewrite H10 in H7.
simpl in H7.
do 2 rewrite <- beq_nat_refl in H7.
discriminate H7.
rewrite leb_iff_conv in H10.
contradict H10.
omega.
rewrite forallb_forall_conv in H5.
destruct H5 as [e [H5 H6] ].
rewrite in_map_iff in H5.
destruct H5 as [q [H5 H7] ].
rewrite in_seq_iff in H7.
subst e.
simpl in H6.
case_eq (n+0).
intro H8.
contradict H7.
omega.
intros r H8.
rewrite H8 in H6.
case_eq (leb q r); intro H9.
rewrite H9 in H6.
simpl in H6.
rewrite <- beq_nat_refl in H6.
discriminate H6.
rewrite leb_iff_conv in H9.
contradict H9.
omega.
rewrite forallb_forall_conv in H4.

*****
H4 : ex\n (fun x : BC =>\n and (In x (map (proj (S n) (S s)) (seq (S (S n)) s)))\n (eq (aeq (arities x) (ok_arities (S n) (S s))) false))
H3 : eq (Nat.leb n p) true
H2 : eq (Init.Nat.add n (S s)) (S p)
p : nat
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O))\n (map (proj (S n) O) (seq (S O) n))) true
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n O)
x,g,h : BC
n,s : nat
*****
eq (error_comp (error_rec (ok_arities n s) (error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (ok_arities (S n) (S s)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) (error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (ok_arities (S n) (S s)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s)))))) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s)))) (ok_arities n s)
+++++
destruct H4 as [e [H4 H5] ].
-----
Lemma arities_rec3 n s x g h (Hx : arities x = ok_arities n 0) (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec3 n s x g h) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh.
simpl.
do 4 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).
intro H2.
contradict H2.
omega.
intros p H2.
case_eq (leb n p); intro H3.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H4 end.
do 4 rewrite <- beq_nat_refl.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H5 end.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H6 end.
simpl.
reflexivity.
rewrite forallb_forall_conv in H6.
destruct H6 as [e [H6 H7] ].
rewrite in_map_iff in H6.
destruct H6 as [q [H6 H8] ].
rewrite in_seq_iff in H8.
subst e.
simpl in H7.
case_eq (n+s).
intro H9.
contradict H8.
omega.
intros r H9.
rewrite H9 in H7.
case_eq (leb q r); intro H10.
rewrite H10 in H7.
simpl in H7.
do 2 rewrite <- beq_nat_refl in H7.
discriminate H7.
rewrite leb_iff_conv in H10.
contradict H10.
omega.
rewrite forallb_forall_conv in H5.
destruct H5 as [e [H5 H6] ].
rewrite in_map_iff in H5.
destruct H5 as [q [H5 H7] ].
rewrite in_seq_iff in H7.
subst e.
simpl in H6.
case_eq (n+0).
intro H8.
contradict H7.
omega.
intros r H8.
rewrite H8 in H6.
case_eq (leb q r); intro H9.
rewrite H9 in H6.
simpl in H6.
rewrite <- beq_nat_refl in H6.
discriminate H6.
rewrite leb_iff_conv in H9.
contradict H9.
omega.
rewrite forallb_forall_conv in H4.
destruct H4 as [e [H4 H5] ].

*****
H5 : eq (aeq (arities e) (ok_arities (S n) (S s))) false
H4 : In e (map (proj (S n) (S s)) (seq (S (S n)) s))
e : BC
H3 : eq (Nat.leb n p) true
H2 : eq (Init.Nat.add n (S s)) (S p)
p : nat
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O))\n (map (proj (S n) O) (seq (S O) n))) true
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n O)
x,g,h : BC
n,s : nat
*****
eq (error_comp (error_rec (ok_arities n s) (error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (ok_arities (S n) (S s)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) (error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (ok_arities (S n) (S s)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s)))))) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s)))) (ok_arities n s)
+++++
rewrite in_map_iff in H4.
-----
Lemma arities_rec3 n s x g h (Hx : arities x = ok_arities n 0) (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec3 n s x g h) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh.
simpl.
do 4 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).
intro H2.
contradict H2.
omega.
intros p H2.
case_eq (leb n p); intro H3.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H4 end.
do 4 rewrite <- beq_nat_refl.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H5 end.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H6 end.
simpl.
reflexivity.
rewrite forallb_forall_conv in H6.
destruct H6 as [e [H6 H7] ].
rewrite in_map_iff in H6.
destruct H6 as [q [H6 H8] ].
rewrite in_seq_iff in H8.
subst e.
simpl in H7.
case_eq (n+s).
intro H9.
contradict H8.
omega.
intros r H9.
rewrite H9 in H7.
case_eq (leb q r); intro H10.
rewrite H10 in H7.
simpl in H7.
do 2 rewrite <- beq_nat_refl in H7.
discriminate H7.
rewrite leb_iff_conv in H10.
contradict H10.
omega.
rewrite forallb_forall_conv in H5.
destruct H5 as [e [H5 H6] ].
rewrite in_map_iff in H5.
destruct H5 as [q [H5 H7] ].
rewrite in_seq_iff in H7.
subst e.
simpl in H6.
case_eq (n+0).
intro H8.
contradict H7.
omega.
intros r H8.
rewrite H8 in H6.
case_eq (leb q r); intro H9.
rewrite H9 in H6.
simpl in H6.
rewrite <- beq_nat_refl in H6.
discriminate H6.
rewrite leb_iff_conv in H9.
contradict H9.
omega.
rewrite forallb_forall_conv in H4.
destruct H4 as [e [H4 H5] ].
rewrite in_map_iff in H4.

*****
H5 : eq (aeq (arities e) (ok_arities (S n) (S s))) false
H4 : ex\n (fun x : nat =>\n and (eq (proj (S n) (S s) x) e) (In x (seq (S (S n)) s)))
e : BC
H3 : eq (Nat.leb n p) true
H2 : eq (Init.Nat.add n (S s)) (S p)
p : nat
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O))\n (map (proj (S n) O) (seq (S O) n))) true
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n O)
x,g,h : BC
n,s : nat
*****
eq (error_comp (error_rec (ok_arities n s) (error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (ok_arities (S n) (S s)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) (error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (ok_arities (S n) (S s)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s)))))) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s)))) (ok_arities n s)
+++++
destruct H4 as [q [H4 H6] ].
-----
Lemma arities_rec3 n s x g h (Hx : arities x = ok_arities n 0) (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec3 n s x g h) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh.
simpl.
do 4 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).
intro H2.
contradict H2.
omega.
intros p H2.
case_eq (leb n p); intro H3.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H4 end.
do 4 rewrite <- beq_nat_refl.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H5 end.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H6 end.
simpl.
reflexivity.
rewrite forallb_forall_conv in H6.
destruct H6 as [e [H6 H7] ].
rewrite in_map_iff in H6.
destruct H6 as [q [H6 H8] ].
rewrite in_seq_iff in H8.
subst e.
simpl in H7.
case_eq (n+s).
intro H9.
contradict H8.
omega.
intros r H9.
rewrite H9 in H7.
case_eq (leb q r); intro H10.
rewrite H10 in H7.
simpl in H7.
do 2 rewrite <- beq_nat_refl in H7.
discriminate H7.
rewrite leb_iff_conv in H10.
contradict H10.
omega.
rewrite forallb_forall_conv in H5.
destruct H5 as [e [H5 H6] ].
rewrite in_map_iff in H5.
destruct H5 as [q [H5 H7] ].
rewrite in_seq_iff in H7.
subst e.
simpl in H6.
case_eq (n+0).
intro H8.
contradict H7.
omega.
intros r H8.
rewrite H8 in H6.
case_eq (leb q r); intro H9.
rewrite H9 in H6.
simpl in H6.
rewrite <- beq_nat_refl in H6.
discriminate H6.
rewrite leb_iff_conv in H9.
contradict H9.
omega.
rewrite forallb_forall_conv in H4.
destruct H4 as [e [H4 H5] ].
rewrite in_map_iff in H4.
destruct H4 as [q [H4 H6] ].

*****
H5 : eq (aeq (arities e) (ok_arities (S n) (S s))) false
H6 : In q (seq (S (S n)) s)
H4 : eq (proj (S n) (S s) q) e
q : nat
e : BC
H3 : eq (Nat.leb n p) true
H2 : eq (Init.Nat.add n (S s)) (S p)
p : nat
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O))\n (map (proj (S n) O) (seq (S O) n))) true
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n O)
x,g,h : BC
n,s : nat
*****
eq (error_comp (error_rec (ok_arities n s) (error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (ok_arities (S n) (S s)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) (error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (ok_arities (S n) (S s)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s)))))) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s)))) (ok_arities n s)
+++++
rewrite in_seq_iff in H6.
-----
Lemma arities_rec3 n s x g h (Hx : arities x = ok_arities n 0) (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec3 n s x g h) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh.
simpl.
do 4 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).
intro H2.
contradict H2.
omega.
intros p H2.
case_eq (leb n p); intro H3.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H4 end.
do 4 rewrite <- beq_nat_refl.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H5 end.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H6 end.
simpl.
reflexivity.
rewrite forallb_forall_conv in H6.
destruct H6 as [e [H6 H7] ].
rewrite in_map_iff in H6.
destruct H6 as [q [H6 H8] ].
rewrite in_seq_iff in H8.
subst e.
simpl in H7.
case_eq (n+s).
intro H9.
contradict H8.
omega.
intros r H9.
rewrite H9 in H7.
case_eq (leb q r); intro H10.
rewrite H10 in H7.
simpl in H7.
do 2 rewrite <- beq_nat_refl in H7.
discriminate H7.
rewrite leb_iff_conv in H10.
contradict H10.
omega.
rewrite forallb_forall_conv in H5.
destruct H5 as [e [H5 H6] ].
rewrite in_map_iff in H5.
destruct H5 as [q [H5 H7] ].
rewrite in_seq_iff in H7.
subst e.
simpl in H6.
case_eq (n+0).
intro H8.
contradict H7.
omega.
intros r H8.
rewrite H8 in H6.
case_eq (leb q r); intro H9.
rewrite H9 in H6.
simpl in H6.
rewrite <- beq_nat_refl in H6.
discriminate H6.
rewrite leb_iff_conv in H9.
contradict H9.
omega.
rewrite forallb_forall_conv in H4.
destruct H4 as [e [H4 H5] ].
rewrite in_map_iff in H4.
destruct H4 as [q [H4 H6] ].
rewrite in_seq_iff in H6.

*****
H5 : eq (aeq (arities e) (ok_arities (S n) (S s))) false
H6 : and (le (S (S n)) q) (lt q (Init.Nat.add (S (S n)) s))
H4 : eq (proj (S n) (S s) q) e
q : nat
e : BC
H3 : eq (Nat.leb n p) true
H2 : eq (Init.Nat.add n (S s)) (S p)
p : nat
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O))\n (map (proj (S n) O) (seq (S O) n))) true
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n O)
x,g,h : BC
n,s : nat
*****
eq (error_comp (error_rec (ok_arities n s) (error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (ok_arities (S n) (S s)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) (error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (ok_arities (S n) (S s)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s)))))) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s)))) (ok_arities n s)
+++++
subst e.
-----
Lemma arities_rec3 n s x g h (Hx : arities x = ok_arities n 0) (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec3 n s x g h) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh.
simpl.
do 4 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).
intro H2.
contradict H2.
omega.
intros p H2.
case_eq (leb n p); intro H3.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H4 end.
do 4 rewrite <- beq_nat_refl.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H5 end.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H6 end.
simpl.
reflexivity.
rewrite forallb_forall_conv in H6.
destruct H6 as [e [H6 H7] ].
rewrite in_map_iff in H6.
destruct H6 as [q [H6 H8] ].
rewrite in_seq_iff in H8.
subst e.
simpl in H7.
case_eq (n+s).
intro H9.
contradict H8.
omega.
intros r H9.
rewrite H9 in H7.
case_eq (leb q r); intro H10.
rewrite H10 in H7.
simpl in H7.
do 2 rewrite <- beq_nat_refl in H7.
discriminate H7.
rewrite leb_iff_conv in H10.
contradict H10.
omega.
rewrite forallb_forall_conv in H5.
destruct H5 as [e [H5 H6] ].
rewrite in_map_iff in H5.
destruct H5 as [q [H5 H7] ].
rewrite in_seq_iff in H7.
subst e.
simpl in H6.
case_eq (n+0).
intro H8.
contradict H7.
omega.
intros r H8.
rewrite H8 in H6.
case_eq (leb q r); intro H9.
rewrite H9 in H6.
simpl in H6.
rewrite <- beq_nat_refl in H6.
discriminate H6.
rewrite leb_iff_conv in H9.
contradict H9.
omega.
rewrite forallb_forall_conv in H4.
destruct H4 as [e [H4 H5] ].
rewrite in_map_iff in H4.
destruct H4 as [q [H4 H6] ].
rewrite in_seq_iff in H6.
subst e.

*****
H5 : eq (aeq (arities (proj (S n) (S s) q)) (ok_arities (S n) (S s))) false
H6 : and (le (S (S n)) q) (lt q (Init.Nat.add (S (S n)) s))
q : nat
H3 : eq (Nat.leb n p) true
H2 : eq (Init.Nat.add n (S s)) (S p)
p : nat
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O))\n (map (proj (S n) O) (seq (S O) n))) true
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n O)
x,g,h : BC
n,s : nat
*****
eq (error_comp (error_rec (ok_arities n s) (error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (ok_arities (S n) (S s)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) (error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (ok_arities (S n) (S s)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s)))))) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s)))) (ok_arities n s)
+++++
simpl in H5.
-----
Lemma arities_rec3 n s x g h (Hx : arities x = ok_arities n 0) (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec3 n s x g h) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh.
simpl.
do 4 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).
intro H2.
contradict H2.
omega.
intros p H2.
case_eq (leb n p); intro H3.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H4 end.
do 4 rewrite <- beq_nat_refl.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H5 end.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H6 end.
simpl.
reflexivity.
rewrite forallb_forall_conv in H6.
destruct H6 as [e [H6 H7] ].
rewrite in_map_iff in H6.
destruct H6 as [q [H6 H8] ].
rewrite in_seq_iff in H8.
subst e.
simpl in H7.
case_eq (n+s).
intro H9.
contradict H8.
omega.
intros r H9.
rewrite H9 in H7.
case_eq (leb q r); intro H10.
rewrite H10 in H7.
simpl in H7.
do 2 rewrite <- beq_nat_refl in H7.
discriminate H7.
rewrite leb_iff_conv in H10.
contradict H10.
omega.
rewrite forallb_forall_conv in H5.
destruct H5 as [e [H5 H6] ].
rewrite in_map_iff in H5.
destruct H5 as [q [H5 H7] ].
rewrite in_seq_iff in H7.
subst e.
simpl in H6.
case_eq (n+0).
intro H8.
contradict H7.
omega.
intros r H8.
rewrite H8 in H6.
case_eq (leb q r); intro H9.
rewrite H9 in H6.
simpl in H6.
rewrite <- beq_nat_refl in H6.
discriminate H6.
rewrite leb_iff_conv in H9.
contradict H9.
omega.
rewrite forallb_forall_conv in H4.
destruct H4 as [e [H4 H5] ].
rewrite in_map_iff in H4.
destruct H4 as [q [H4 H6] ].
rewrite in_seq_iff in H6.
subst e.
simpl in H5.

*****
H5 : eq\n (aeq\n (if Nat.leb q (Init.Nat.add n (S s))\n then ok_arities (S n) (S s)\n else error_proj (S n) (S s) q) (ok_arities (S n) (S s))) false
H6 : and (le (S (S n)) q) (lt q (Init.Nat.add (S (S n)) s))
q : nat
H3 : eq (Nat.leb n p) true
H2 : eq (Init.Nat.add n (S s)) (S p)
p : nat
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O))\n (map (proj (S n) O) (seq (S O) n))) true
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n O)
x,g,h : BC
n,s : nat
*****
eq (error_comp (error_rec (ok_arities n s) (error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (ok_arities (S n) (S s)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) (error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (ok_arities (S n) (S s)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s)))))) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s)))) (ok_arities n s)
+++++
case_eq (n+S s).
-----
Lemma arities_rec3 n s x g h (Hx : arities x = ok_arities n 0) (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec3 n s x g h) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh.
simpl.
do 4 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).
intro H2.
contradict H2.
omega.
intros p H2.
case_eq (leb n p); intro H3.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H4 end.
do 4 rewrite <- beq_nat_refl.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H5 end.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H6 end.
simpl.
reflexivity.
rewrite forallb_forall_conv in H6.
destruct H6 as [e [H6 H7] ].
rewrite in_map_iff in H6.
destruct H6 as [q [H6 H8] ].
rewrite in_seq_iff in H8.
subst e.
simpl in H7.
case_eq (n+s).
intro H9.
contradict H8.
omega.
intros r H9.
rewrite H9 in H7.
case_eq (leb q r); intro H10.
rewrite H10 in H7.
simpl in H7.
do 2 rewrite <- beq_nat_refl in H7.
discriminate H7.
rewrite leb_iff_conv in H10.
contradict H10.
omega.
rewrite forallb_forall_conv in H5.
destruct H5 as [e [H5 H6] ].
rewrite in_map_iff in H5.
destruct H5 as [q [H5 H7] ].
rewrite in_seq_iff in H7.
subst e.
simpl in H6.
case_eq (n+0).
intro H8.
contradict H7.
omega.
intros r H8.
rewrite H8 in H6.
case_eq (leb q r); intro H9.
rewrite H9 in H6.
simpl in H6.
rewrite <- beq_nat_refl in H6.
discriminate H6.
rewrite leb_iff_conv in H9.
contradict H9.
omega.
rewrite forallb_forall_conv in H4.
destruct H4 as [e [H4 H5] ].
rewrite in_map_iff in H4.
destruct H4 as [q [H4 H6] ].
rewrite in_seq_iff in H6.
subst e.
simpl in H5.
case_eq (n+S s).

*****
H5 : eq\n (aeq\n (if Nat.leb q (Init.Nat.add n (S s))\n then ok_arities (S n) (S s)\n else error_proj (S n) (S s) q) (ok_arities (S n) (S s))) false
H6 : and (le (S (S n)) q) (lt q (Init.Nat.add (S (S n)) s))
q : nat
H3 : eq (Nat.leb n p) true
H2 : eq (Init.Nat.add n (S s)) (S p)
p : nat
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O))\n (map (proj (S n) O) (seq (S O) n))) true
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n O)
x,g,h : BC
n,s : nat
*****
forall _ : eq (Init.Nat.add n (S s)) O, eq (error_comp (error_rec (ok_arities n s) (error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (ok_arities (S n) (S s)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) (error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (ok_arities (S n) (S s)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s)))))) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s)))) (ok_arities n s)
+++++
intro H7.
-----
Lemma arities_rec3 n s x g h (Hx : arities x = ok_arities n 0) (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec3 n s x g h) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh.
simpl.
do 4 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).
intro H2.
contradict H2.
omega.
intros p H2.
case_eq (leb n p); intro H3.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H4 end.
do 4 rewrite <- beq_nat_refl.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H5 end.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H6 end.
simpl.
reflexivity.
rewrite forallb_forall_conv in H6.
destruct H6 as [e [H6 H7] ].
rewrite in_map_iff in H6.
destruct H6 as [q [H6 H8] ].
rewrite in_seq_iff in H8.
subst e.
simpl in H7.
case_eq (n+s).
intro H9.
contradict H8.
omega.
intros r H9.
rewrite H9 in H7.
case_eq (leb q r); intro H10.
rewrite H10 in H7.
simpl in H7.
do 2 rewrite <- beq_nat_refl in H7.
discriminate H7.
rewrite leb_iff_conv in H10.
contradict H10.
omega.
rewrite forallb_forall_conv in H5.
destruct H5 as [e [H5 H6] ].
rewrite in_map_iff in H5.
destruct H5 as [q [H5 H7] ].
rewrite in_seq_iff in H7.
subst e.
simpl in H6.
case_eq (n+0).
intro H8.
contradict H7.
omega.
intros r H8.
rewrite H8 in H6.
case_eq (leb q r); intro H9.
rewrite H9 in H6.
simpl in H6.
rewrite <- beq_nat_refl in H6.
discriminate H6.
rewrite leb_iff_conv in H9.
contradict H9.
omega.
rewrite forallb_forall_conv in H4.
destruct H4 as [e [H4 H5] ].
rewrite in_map_iff in H4.
destruct H4 as [q [H4 H6] ].
rewrite in_seq_iff in H6.
subst e.
simpl in H5.
case_eq (n+S s).
intro H7.

*****
H7 : eq (Init.Nat.add n (S s)) O
H5 : eq\n (aeq\n (if Nat.leb q (Init.Nat.add n (S s))\n then ok_arities (S n) (S s)\n else error_proj (S n) (S s) q) (ok_arities (S n) (S s))) false
H6 : and (le (S (S n)) q) (lt q (Init.Nat.add (S (S n)) s))
q : nat
H3 : eq (Nat.leb n p) true
H2 : eq (Init.Nat.add n (S s)) (S p)
p : nat
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O))\n (map (proj (S n) O) (seq (S O) n))) true
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n O)
x,g,h : BC
n,s : nat
*****
eq (error_comp (error_rec (ok_arities n s) (error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (ok_arities (S n) (S s)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) (error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (ok_arities (S n) (S s)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s)))))) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s)))) (ok_arities n s)
+++++
contradict H6.
-----
Lemma arities_rec3 n s x g h (Hx : arities x = ok_arities n 0) (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec3 n s x g h) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh.
simpl.
do 4 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).
intro H2.
contradict H2.
omega.
intros p H2.
case_eq (leb n p); intro H3.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H4 end.
do 4 rewrite <- beq_nat_refl.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H5 end.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H6 end.
simpl.
reflexivity.
rewrite forallb_forall_conv in H6.
destruct H6 as [e [H6 H7] ].
rewrite in_map_iff in H6.
destruct H6 as [q [H6 H8] ].
rewrite in_seq_iff in H8.
subst e.
simpl in H7.
case_eq (n+s).
intro H9.
contradict H8.
omega.
intros r H9.
rewrite H9 in H7.
case_eq (leb q r); intro H10.
rewrite H10 in H7.
simpl in H7.
do 2 rewrite <- beq_nat_refl in H7.
discriminate H7.
rewrite leb_iff_conv in H10.
contradict H10.
omega.
rewrite forallb_forall_conv in H5.
destruct H5 as [e [H5 H6] ].
rewrite in_map_iff in H5.
destruct H5 as [q [H5 H7] ].
rewrite in_seq_iff in H7.
subst e.
simpl in H6.
case_eq (n+0).
intro H8.
contradict H7.
omega.
intros r H8.
rewrite H8 in H6.
case_eq (leb q r); intro H9.
rewrite H9 in H6.
simpl in H6.
rewrite <- beq_nat_refl in H6.
discriminate H6.
rewrite leb_iff_conv in H9.
contradict H9.
omega.
rewrite forallb_forall_conv in H4.
destruct H4 as [e [H4 H5] ].
rewrite in_map_iff in H4.
destruct H4 as [q [H4 H6] ].
rewrite in_seq_iff in H6.
subst e.
simpl in H5.
case_eq (n+S s).
intro H7.
contradict H6.

*****
H7 : eq (Init.Nat.add n (S s)) O
H5 : eq\n (aeq\n (if Nat.leb q (Init.Nat.add n (S s))\n then ok_arities (S n) (S s)\n else error_proj (S n) (S s) q) (ok_arities (S n) (S s))) false
q : nat
H3 : eq (Nat.leb n p) true
H2 : eq (Init.Nat.add n (S s)) (S p)
p : nat
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O))\n (map (proj (S n) O) (seq (S O) n))) true
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n O)
x,g,h : BC
n,s : nat
*****
not (and (le (S (S n)) q) (lt q (Init.Nat.add (S (S n)) s)))
+++++
omega.
-----
Lemma arities_rec3 n s x g h (Hx : arities x = ok_arities n 0) (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec3 n s x g h) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh.
simpl.
do 4 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).
intro H2.
contradict H2.
omega.
intros p H2.
case_eq (leb n p); intro H3.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H4 end.
do 4 rewrite <- beq_nat_refl.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H5 end.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H6 end.
simpl.
reflexivity.
rewrite forallb_forall_conv in H6.
destruct H6 as [e [H6 H7] ].
rewrite in_map_iff in H6.
destruct H6 as [q [H6 H8] ].
rewrite in_seq_iff in H8.
subst e.
simpl in H7.
case_eq (n+s).
intro H9.
contradict H8.
omega.
intros r H9.
rewrite H9 in H7.
case_eq (leb q r); intro H10.
rewrite H10 in H7.
simpl in H7.
do 2 rewrite <- beq_nat_refl in H7.
discriminate H7.
rewrite leb_iff_conv in H10.
contradict H10.
omega.
rewrite forallb_forall_conv in H5.
destruct H5 as [e [H5 H6] ].
rewrite in_map_iff in H5.
destruct H5 as [q [H5 H7] ].
rewrite in_seq_iff in H7.
subst e.
simpl in H6.
case_eq (n+0).
intro H8.
contradict H7.
omega.
intros r H8.
rewrite H8 in H6.
case_eq (leb q r); intro H9.
rewrite H9 in H6.
simpl in H6.
rewrite <- beq_nat_refl in H6.
discriminate H6.
rewrite leb_iff_conv in H9.
contradict H9.
omega.
rewrite forallb_forall_conv in H4.
destruct H4 as [e [H4 H5] ].
rewrite in_map_iff in H4.
destruct H4 as [q [H4 H6] ].
rewrite in_seq_iff in H6.
subst e.
simpl in H5.
case_eq (n+S s).
intro H7.
contradict H6.
omega.

*****
H5 : eq\n (aeq\n (if Nat.leb q (Init.Nat.add n (S s))\n then ok_arities (S n) (S s)\n else error_proj (S n) (S s) q) (ok_arities (S n) (S s))) false
H6 : and (le (S (S n)) q) (lt q (Init.Nat.add (S (S n)) s))
q : nat
H3 : eq (Nat.leb n p) true
H2 : eq (Init.Nat.add n (S s)) (S p)
p : nat
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O))\n (map (proj (S n) O) (seq (S O) n))) true
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n O)
x,g,h : BC
n,s : nat
*****
forall (n0 : nat) (_ : eq (Init.Nat.add n (S s)) (S n0)), eq (error_comp (error_rec (ok_arities n s) (error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (ok_arities (S n) (S s)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) (error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (ok_arities (S n) (S s)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s)))))) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s)))) (ok_arities n s)
+++++
intros r H7.
-----
Lemma arities_rec3 n s x g h (Hx : arities x = ok_arities n 0) (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec3 n s x g h) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh.
simpl.
do 4 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).
intro H2.
contradict H2.
omega.
intros p H2.
case_eq (leb n p); intro H3.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H4 end.
do 4 rewrite <- beq_nat_refl.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H5 end.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H6 end.
simpl.
reflexivity.
rewrite forallb_forall_conv in H6.
destruct H6 as [e [H6 H7] ].
rewrite in_map_iff in H6.
destruct H6 as [q [H6 H8] ].
rewrite in_seq_iff in H8.
subst e.
simpl in H7.
case_eq (n+s).
intro H9.
contradict H8.
omega.
intros r H9.
rewrite H9 in H7.
case_eq (leb q r); intro H10.
rewrite H10 in H7.
simpl in H7.
do 2 rewrite <- beq_nat_refl in H7.
discriminate H7.
rewrite leb_iff_conv in H10.
contradict H10.
omega.
rewrite forallb_forall_conv in H5.
destruct H5 as [e [H5 H6] ].
rewrite in_map_iff in H5.
destruct H5 as [q [H5 H7] ].
rewrite in_seq_iff in H7.
subst e.
simpl in H6.
case_eq (n+0).
intro H8.
contradict H7.
omega.
intros r H8.
rewrite H8 in H6.
case_eq (leb q r); intro H9.
rewrite H9 in H6.
simpl in H6.
rewrite <- beq_nat_refl in H6.
discriminate H6.
rewrite leb_iff_conv in H9.
contradict H9.
omega.
rewrite forallb_forall_conv in H4.
destruct H4 as [e [H4 H5] ].
rewrite in_map_iff in H4.
destruct H4 as [q [H4 H6] ].
rewrite in_seq_iff in H6.
subst e.
simpl in H5.
case_eq (n+S s).
intro H7.
contradict H6.
omega.
intros r H7.

*****
H7 : eq (Init.Nat.add n (S s)) (S r)
r : nat
H5 : eq\n (aeq\n (if Nat.leb q (Init.Nat.add n (S s))\n then ok_arities (S n) (S s)\n else error_proj (S n) (S s) q) (ok_arities (S n) (S s))) false
H6 : and (le (S (S n)) q) (lt q (Init.Nat.add (S (S n)) s))
q : nat
H3 : eq (Nat.leb n p) true
H2 : eq (Init.Nat.add n (S s)) (S p)
p : nat
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O))\n (map (proj (S n) O) (seq (S O) n))) true
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n O)
x,g,h : BC
n,s : nat
*****
eq (error_comp (error_rec (ok_arities n s) (error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (ok_arities (S n) (S s)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) (error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (ok_arities (S n) (S s)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s)))))) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s)))) (ok_arities n s)
+++++
rewrite H7 in H5.
-----
Lemma arities_rec3 n s x g h (Hx : arities x = ok_arities n 0) (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec3 n s x g h) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh.
simpl.
do 4 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).
intro H2.
contradict H2.
omega.
intros p H2.
case_eq (leb n p); intro H3.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H4 end.
do 4 rewrite <- beq_nat_refl.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H5 end.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H6 end.
simpl.
reflexivity.
rewrite forallb_forall_conv in H6.
destruct H6 as [e [H6 H7] ].
rewrite in_map_iff in H6.
destruct H6 as [q [H6 H8] ].
rewrite in_seq_iff in H8.
subst e.
simpl in H7.
case_eq (n+s).
intro H9.
contradict H8.
omega.
intros r H9.
rewrite H9 in H7.
case_eq (leb q r); intro H10.
rewrite H10 in H7.
simpl in H7.
do 2 rewrite <- beq_nat_refl in H7.
discriminate H7.
rewrite leb_iff_conv in H10.
contradict H10.
omega.
rewrite forallb_forall_conv in H5.
destruct H5 as [e [H5 H6] ].
rewrite in_map_iff in H5.
destruct H5 as [q [H5 H7] ].
rewrite in_seq_iff in H7.
subst e.
simpl in H6.
case_eq (n+0).
intro H8.
contradict H7.
omega.
intros r H8.
rewrite H8 in H6.
case_eq (leb q r); intro H9.
rewrite H9 in H6.
simpl in H6.
rewrite <- beq_nat_refl in H6.
discriminate H6.
rewrite leb_iff_conv in H9.
contradict H9.
omega.
rewrite forallb_forall_conv in H4.
destruct H4 as [e [H4 H5] ].
rewrite in_map_iff in H4.
destruct H4 as [q [H4 H6] ].
rewrite in_seq_iff in H6.
subst e.
simpl in H5.
case_eq (n+S s).
intro H7.
contradict H6.
omega.
intros r H7.
rewrite H7 in H5.

*****
H7 : eq (Init.Nat.add n (S s)) (S r)
H5 : eq\n (aeq\n (if Nat.leb q (S r)\n then ok_arities (S n) (S s)\n else error_proj (S n) (S s) q) (ok_arities (S n) (S s))) false
r : nat
H6 : and (le (S (S n)) q) (lt q (Init.Nat.add (S (S n)) s))
q : nat
H3 : eq (Nat.leb n p) true
H2 : eq (Init.Nat.add n (S s)) (S p)
p : nat
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O))\n (map (proj (S n) O) (seq (S O) n))) true
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n O)
x,g,h : BC
n,s : nat
*****
eq (error_comp (error_rec (ok_arities n s) (error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (ok_arities (S n) (S s)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) (error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (ok_arities (S n) (S s)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s)))))) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s)))) (ok_arities n s)
+++++
case_eq (leb q (S r)); intro H8.
-----
Lemma arities_rec3 n s x g h (Hx : arities x = ok_arities n 0) (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec3 n s x g h) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh.
simpl.
do 4 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).
intro H2.
contradict H2.
omega.
intros p H2.
case_eq (leb n p); intro H3.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H4 end.
do 4 rewrite <- beq_nat_refl.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H5 end.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H6 end.
simpl.
reflexivity.
rewrite forallb_forall_conv in H6.
destruct H6 as [e [H6 H7] ].
rewrite in_map_iff in H6.
destruct H6 as [q [H6 H8] ].
rewrite in_seq_iff in H8.
subst e.
simpl in H7.
case_eq (n+s).
intro H9.
contradict H8.
omega.
intros r H9.
rewrite H9 in H7.
case_eq (leb q r); intro H10.
rewrite H10 in H7.
simpl in H7.
do 2 rewrite <- beq_nat_refl in H7.
discriminate H7.
rewrite leb_iff_conv in H10.
contradict H10.
omega.
rewrite forallb_forall_conv in H5.
destruct H5 as [e [H5 H6] ].
rewrite in_map_iff in H5.
destruct H5 as [q [H5 H7] ].
rewrite in_seq_iff in H7.
subst e.
simpl in H6.
case_eq (n+0).
intro H8.
contradict H7.
omega.
intros r H8.
rewrite H8 in H6.
case_eq (leb q r); intro H9.
rewrite H9 in H6.
simpl in H6.
rewrite <- beq_nat_refl in H6.
discriminate H6.
rewrite leb_iff_conv in H9.
contradict H9.
omega.
rewrite forallb_forall_conv in H4.
destruct H4 as [e [H4 H5] ].
rewrite in_map_iff in H4.
destruct H4 as [q [H4 H6] ].
rewrite in_seq_iff in H6.
subst e.
simpl in H5.
case_eq (n+S s).
intro H7.
contradict H6.
omega.
intros r H7.
rewrite H7 in H5.
case_eq (leb q (S r)); intro H8.

*****
H8 : eq (Nat.leb q (S r)) true
H7 : eq (Init.Nat.add n (S s)) (S r)
H5 : eq\n (aeq\n (if Nat.leb q (S r)\n then ok_arities (S n) (S s)\n else error_proj (S n) (S s) q) (ok_arities (S n) (S s))) false
r : nat
H6 : and (le (S (S n)) q) (lt q (Init.Nat.add (S (S n)) s))
q : nat
H3 : eq (Nat.leb n p) true
H2 : eq (Init.Nat.add n (S s)) (S p)
p : nat
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O))\n (map (proj (S n) O) (seq (S O) n))) true
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n O)
x,g,h : BC
n,s : nat
*****
eq (error_comp (error_rec (ok_arities n s) (error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (ok_arities (S n) (S s)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) (error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (ok_arities (S n) (S s)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s)))))) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s)))) (ok_arities n s)
+++++
rewrite H8 in H5.
-----
Lemma arities_rec3 n s x g h (Hx : arities x = ok_arities n 0) (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec3 n s x g h) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh.
simpl.
do 4 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).
intro H2.
contradict H2.
omega.
intros p H2.
case_eq (leb n p); intro H3.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H4 end.
do 4 rewrite <- beq_nat_refl.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H5 end.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H6 end.
simpl.
reflexivity.
rewrite forallb_forall_conv in H6.
destruct H6 as [e [H6 H7] ].
rewrite in_map_iff in H6.
destruct H6 as [q [H6 H8] ].
rewrite in_seq_iff in H8.
subst e.
simpl in H7.
case_eq (n+s).
intro H9.
contradict H8.
omega.
intros r H9.
rewrite H9 in H7.
case_eq (leb q r); intro H10.
rewrite H10 in H7.
simpl in H7.
do 2 rewrite <- beq_nat_refl in H7.
discriminate H7.
rewrite leb_iff_conv in H10.
contradict H10.
omega.
rewrite forallb_forall_conv in H5.
destruct H5 as [e [H5 H6] ].
rewrite in_map_iff in H5.
destruct H5 as [q [H5 H7] ].
rewrite in_seq_iff in H7.
subst e.
simpl in H6.
case_eq (n+0).
intro H8.
contradict H7.
omega.
intros r H8.
rewrite H8 in H6.
case_eq (leb q r); intro H9.
rewrite H9 in H6.
simpl in H6.
rewrite <- beq_nat_refl in H6.
discriminate H6.
rewrite leb_iff_conv in H9.
contradict H9.
omega.
rewrite forallb_forall_conv in H4.
destruct H4 as [e [H4 H5] ].
rewrite in_map_iff in H4.
destruct H4 as [q [H4 H6] ].
rewrite in_seq_iff in H6.
subst e.
simpl in H5.
case_eq (n+S s).
intro H7.
contradict H6.
omega.
intros r H7.
rewrite H7 in H5.
case_eq (leb q (S r)); intro H8.
rewrite H8 in H5.

*****
H8 : eq (Nat.leb q (S r)) true
H7 : eq (Init.Nat.add n (S s)) (S r)
H5 : eq (aeq (ok_arities (S n) (S s)) (ok_arities (S n) (S s))) false
r : nat
H6 : and (le (S (S n)) q) (lt q (Init.Nat.add (S (S n)) s))
q : nat
H3 : eq (Nat.leb n p) true
H2 : eq (Init.Nat.add n (S s)) (S p)
p : nat
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O))\n (map (proj (S n) O) (seq (S O) n))) true
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n O)
x,g,h : BC
n,s : nat
*****
eq (error_comp (error_rec (ok_arities n s) (error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (ok_arities (S n) (S s)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) (error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (ok_arities (S n) (S s)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s)))))) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s)))) (ok_arities n s)
+++++
simpl in H5.
-----
Lemma arities_rec3 n s x g h (Hx : arities x = ok_arities n 0) (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec3 n s x g h) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh.
simpl.
do 4 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).
intro H2.
contradict H2.
omega.
intros p H2.
case_eq (leb n p); intro H3.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H4 end.
do 4 rewrite <- beq_nat_refl.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H5 end.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H6 end.
simpl.
reflexivity.
rewrite forallb_forall_conv in H6.
destruct H6 as [e [H6 H7] ].
rewrite in_map_iff in H6.
destruct H6 as [q [H6 H8] ].
rewrite in_seq_iff in H8.
subst e.
simpl in H7.
case_eq (n+s).
intro H9.
contradict H8.
omega.
intros r H9.
rewrite H9 in H7.
case_eq (leb q r); intro H10.
rewrite H10 in H7.
simpl in H7.
do 2 rewrite <- beq_nat_refl in H7.
discriminate H7.
rewrite leb_iff_conv in H10.
contradict H10.
omega.
rewrite forallb_forall_conv in H5.
destruct H5 as [e [H5 H6] ].
rewrite in_map_iff in H5.
destruct H5 as [q [H5 H7] ].
rewrite in_seq_iff in H7.
subst e.
simpl in H6.
case_eq (n+0).
intro H8.
contradict H7.
omega.
intros r H8.
rewrite H8 in H6.
case_eq (leb q r); intro H9.
rewrite H9 in H6.
simpl in H6.
rewrite <- beq_nat_refl in H6.
discriminate H6.
rewrite leb_iff_conv in H9.
contradict H9.
omega.
rewrite forallb_forall_conv in H4.
destruct H4 as [e [H4 H5] ].
rewrite in_map_iff in H4.
destruct H4 as [q [H4 H6] ].
rewrite in_seq_iff in H6.
subst e.
simpl in H5.
case_eq (n+S s).
intro H7.
contradict H6.
omega.
intros r H7.
rewrite H7 in H5.
case_eq (leb q (S r)); intro H8.
rewrite H8 in H5.
simpl in H5.

*****
H8 : eq (Nat.leb q (S r)) true
H7 : eq (Init.Nat.add n (S s)) (S r)
H5 : eq (andb (Nat.eqb n n) (Nat.eqb s s)) false
r : nat
H6 : and (le (S (S n)) q) (lt q (Init.Nat.add (S (S n)) s))
q : nat
H3 : eq (Nat.leb n p) true
H2 : eq (Init.Nat.add n (S s)) (S p)
p : nat
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O))\n (map (proj (S n) O) (seq (S O) n))) true
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n O)
x,g,h : BC
n,s : nat
*****
eq (error_comp (error_rec (ok_arities n s) (error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (ok_arities (S n) (S s)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) (error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (ok_arities (S n) (S s)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s)))))) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s)))) (ok_arities n s)
+++++
do 2 rewrite <- beq_nat_refl in H5.
-----
Lemma arities_rec3 n s x g h (Hx : arities x = ok_arities n 0) (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec3 n s x g h) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh.
simpl.
do 4 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).
intro H2.
contradict H2.
omega.
intros p H2.
case_eq (leb n p); intro H3.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H4 end.
do 4 rewrite <- beq_nat_refl.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H5 end.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H6 end.
simpl.
reflexivity.
rewrite forallb_forall_conv in H6.
destruct H6 as [e [H6 H7] ].
rewrite in_map_iff in H6.
destruct H6 as [q [H6 H8] ].
rewrite in_seq_iff in H8.
subst e.
simpl in H7.
case_eq (n+s).
intro H9.
contradict H8.
omega.
intros r H9.
rewrite H9 in H7.
case_eq (leb q r); intro H10.
rewrite H10 in H7.
simpl in H7.
do 2 rewrite <- beq_nat_refl in H7.
discriminate H7.
rewrite leb_iff_conv in H10.
contradict H10.
omega.
rewrite forallb_forall_conv in H5.
destruct H5 as [e [H5 H6] ].
rewrite in_map_iff in H5.
destruct H5 as [q [H5 H7] ].
rewrite in_seq_iff in H7.
subst e.
simpl in H6.
case_eq (n+0).
intro H8.
contradict H7.
omega.
intros r H8.
rewrite H8 in H6.
case_eq (leb q r); intro H9.
rewrite H9 in H6.
simpl in H6.
rewrite <- beq_nat_refl in H6.
discriminate H6.
rewrite leb_iff_conv in H9.
contradict H9.
omega.
rewrite forallb_forall_conv in H4.
destruct H4 as [e [H4 H5] ].
rewrite in_map_iff in H4.
destruct H4 as [q [H4 H6] ].
rewrite in_seq_iff in H6.
subst e.
simpl in H5.
case_eq (n+S s).
intro H7.
contradict H6.
omega.
intros r H7.
rewrite H7 in H5.
case_eq (leb q (S r)); intro H8.
rewrite H8 in H5.
simpl in H5.
do 2 rewrite <- beq_nat_refl in H5.

*****
H8 : eq (Nat.leb q (S r)) true
H7 : eq (Init.Nat.add n (S s)) (S r)
H5 : eq (andb true true) false
r : nat
H6 : and (le (S (S n)) q) (lt q (Init.Nat.add (S (S n)) s))
q : nat
H3 : eq (Nat.leb n p) true
H2 : eq (Init.Nat.add n (S s)) (S p)
p : nat
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O))\n (map (proj (S n) O) (seq (S O) n))) true
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n O)
x,g,h : BC
n,s : nat
*****
eq (error_comp (error_rec (ok_arities n s) (error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (ok_arities (S n) (S s)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) (error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (ok_arities (S n) (S s)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s)))))) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s)))) (ok_arities n s)
+++++
discriminate H5.
-----
Lemma arities_rec3 n s x g h (Hx : arities x = ok_arities n 0) (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec3 n s x g h) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh.
simpl.
do 4 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).
intro H2.
contradict H2.
omega.
intros p H2.
case_eq (leb n p); intro H3.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H4 end.
do 4 rewrite <- beq_nat_refl.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H5 end.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H6 end.
simpl.
reflexivity.
rewrite forallb_forall_conv in H6.
destruct H6 as [e [H6 H7] ].
rewrite in_map_iff in H6.
destruct H6 as [q [H6 H8] ].
rewrite in_seq_iff in H8.
subst e.
simpl in H7.
case_eq (n+s).
intro H9.
contradict H8.
omega.
intros r H9.
rewrite H9 in H7.
case_eq (leb q r); intro H10.
rewrite H10 in H7.
simpl in H7.
do 2 rewrite <- beq_nat_refl in H7.
discriminate H7.
rewrite leb_iff_conv in H10.
contradict H10.
omega.
rewrite forallb_forall_conv in H5.
destruct H5 as [e [H5 H6] ].
rewrite in_map_iff in H5.
destruct H5 as [q [H5 H7] ].
rewrite in_seq_iff in H7.
subst e.
simpl in H6.
case_eq (n+0).
intro H8.
contradict H7.
omega.
intros r H8.
rewrite H8 in H6.
case_eq (leb q r); intro H9.
rewrite H9 in H6.
simpl in H6.
rewrite <- beq_nat_refl in H6.
discriminate H6.
rewrite leb_iff_conv in H9.
contradict H9.
omega.
rewrite forallb_forall_conv in H4.
destruct H4 as [e [H4 H5] ].
rewrite in_map_iff in H4.
destruct H4 as [q [H4 H6] ].
rewrite in_seq_iff in H6.
subst e.
simpl in H5.
case_eq (n+S s).
intro H7.
contradict H6.
omega.
intros r H7.
rewrite H7 in H5.
case_eq (leb q (S r)); intro H8.
rewrite H8 in H5.
simpl in H5.
do 2 rewrite <- beq_nat_refl in H5.
discriminate H5.

*****
H8 : eq (Nat.leb q (S r)) false
H7 : eq (Init.Nat.add n (S s)) (S r)
H5 : eq\n (aeq\n (if Nat.leb q (S r)\n then ok_arities (S n) (S s)\n else error_proj (S n) (S s) q) (ok_arities (S n) (S s))) false
r : nat
H6 : and (le (S (S n)) q) (lt q (Init.Nat.add (S (S n)) s))
q : nat
H3 : eq (Nat.leb n p) true
H2 : eq (Init.Nat.add n (S s)) (S p)
p : nat
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O))\n (map (proj (S n) O) (seq (S O) n))) true
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n O)
x,g,h : BC
n,s : nat
*****
eq (error_comp (error_rec (ok_arities n s) (error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (ok_arities (S n) (S s)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) (error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (ok_arities (S n) (S s)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s)))))) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s)))) (ok_arities n s)
+++++
rewrite leb_iff_conv in H8.
-----
Lemma arities_rec3 n s x g h (Hx : arities x = ok_arities n 0) (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec3 n s x g h) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh.
simpl.
do 4 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).
intro H2.
contradict H2.
omega.
intros p H2.
case_eq (leb n p); intro H3.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H4 end.
do 4 rewrite <- beq_nat_refl.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H5 end.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H6 end.
simpl.
reflexivity.
rewrite forallb_forall_conv in H6.
destruct H6 as [e [H6 H7] ].
rewrite in_map_iff in H6.
destruct H6 as [q [H6 H8] ].
rewrite in_seq_iff in H8.
subst e.
simpl in H7.
case_eq (n+s).
intro H9.
contradict H8.
omega.
intros r H9.
rewrite H9 in H7.
case_eq (leb q r); intro H10.
rewrite H10 in H7.
simpl in H7.
do 2 rewrite <- beq_nat_refl in H7.
discriminate H7.
rewrite leb_iff_conv in H10.
contradict H10.
omega.
rewrite forallb_forall_conv in H5.
destruct H5 as [e [H5 H6] ].
rewrite in_map_iff in H5.
destruct H5 as [q [H5 H7] ].
rewrite in_seq_iff in H7.
subst e.
simpl in H6.
case_eq (n+0).
intro H8.
contradict H7.
omega.
intros r H8.
rewrite H8 in H6.
case_eq (leb q r); intro H9.
rewrite H9 in H6.
simpl in H6.
rewrite <- beq_nat_refl in H6.
discriminate H6.
rewrite leb_iff_conv in H9.
contradict H9.
omega.
rewrite forallb_forall_conv in H4.
destruct H4 as [e [H4 H5] ].
rewrite in_map_iff in H4.
destruct H4 as [q [H4 H6] ].
rewrite in_seq_iff in H6.
subst e.
simpl in H5.
case_eq (n+S s).
intro H7.
contradict H6.
omega.
intros r H7.
rewrite H7 in H5.
case_eq (leb q (S r)); intro H8.
rewrite H8 in H5.
simpl in H5.
do 2 rewrite <- beq_nat_refl in H5.
discriminate H5.
rewrite leb_iff_conv in H8.

*****
H8 : lt (S r) q
H7 : eq (Init.Nat.add n (S s)) (S r)
H5 : eq\n (aeq\n (if Nat.leb q (S r)\n then ok_arities (S n) (S s)\n else error_proj (S n) (S s) q) (ok_arities (S n) (S s))) false
r : nat
H6 : and (le (S (S n)) q) (lt q (Init.Nat.add (S (S n)) s))
q : nat
H3 : eq (Nat.leb n p) true
H2 : eq (Init.Nat.add n (S s)) (S p)
p : nat
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O))\n (map (proj (S n) O) (seq (S O) n))) true
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n O)
x,g,h : BC
n,s : nat
*****
eq (error_comp (error_rec (ok_arities n s) (error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (ok_arities (S n) (S s)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) (error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (ok_arities (S n) (S s)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s)))))) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s)))) (ok_arities n s)
+++++
contradict H8.
-----
Lemma arities_rec3 n s x g h (Hx : arities x = ok_arities n 0) (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec3 n s x g h) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh.
simpl.
do 4 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).
intro H2.
contradict H2.
omega.
intros p H2.
case_eq (leb n p); intro H3.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H4 end.
do 4 rewrite <- beq_nat_refl.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H5 end.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H6 end.
simpl.
reflexivity.
rewrite forallb_forall_conv in H6.
destruct H6 as [e [H6 H7] ].
rewrite in_map_iff in H6.
destruct H6 as [q [H6 H8] ].
rewrite in_seq_iff in H8.
subst e.
simpl in H7.
case_eq (n+s).
intro H9.
contradict H8.
omega.
intros r H9.
rewrite H9 in H7.
case_eq (leb q r); intro H10.
rewrite H10 in H7.
simpl in H7.
do 2 rewrite <- beq_nat_refl in H7.
discriminate H7.
rewrite leb_iff_conv in H10.
contradict H10.
omega.
rewrite forallb_forall_conv in H5.
destruct H5 as [e [H5 H6] ].
rewrite in_map_iff in H5.
destruct H5 as [q [H5 H7] ].
rewrite in_seq_iff in H7.
subst e.
simpl in H6.
case_eq (n+0).
intro H8.
contradict H7.
omega.
intros r H8.
rewrite H8 in H6.
case_eq (leb q r); intro H9.
rewrite H9 in H6.
simpl in H6.
rewrite <- beq_nat_refl in H6.
discriminate H6.
rewrite leb_iff_conv in H9.
contradict H9.
omega.
rewrite forallb_forall_conv in H4.
destruct H4 as [e [H4 H5] ].
rewrite in_map_iff in H4.
destruct H4 as [q [H4 H6] ].
rewrite in_seq_iff in H6.
subst e.
simpl in H5.
case_eq (n+S s).
intro H7.
contradict H6.
omega.
intros r H7.
rewrite H7 in H5.
case_eq (leb q (S r)); intro H8.
rewrite H8 in H5.
simpl in H5.
do 2 rewrite <- beq_nat_refl in H5.
discriminate H5.
rewrite leb_iff_conv in H8.
contradict H8.

*****
H7 : eq (Init.Nat.add n (S s)) (S r)
H5 : eq\n (aeq\n (if Nat.leb q (S r)\n then ok_arities (S n) (S s)\n else error_proj (S n) (S s) q) (ok_arities (S n) (S s))) false
r : nat
H6 : and (le (S (S n)) q) (lt q (Init.Nat.add (S (S n)) s))
q : nat
H3 : eq (Nat.leb n p) true
H2 : eq (Init.Nat.add n (S s)) (S p)
p : nat
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O))\n (map (proj (S n) O) (seq (S O) n))) true
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n O)
x,g,h : BC
n,s : nat
*****
not (lt (S r) q)
+++++
omega.
-----
Lemma arities_rec3 n s x g h (Hx : arities x = ok_arities n 0) (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec3 n s x g h) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh.
simpl.
do 4 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).
intro H2.
contradict H2.
omega.
intros p H2.
case_eq (leb n p); intro H3.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H4 end.
do 4 rewrite <- beq_nat_refl.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H5 end.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H6 end.
simpl.
reflexivity.
rewrite forallb_forall_conv in H6.
destruct H6 as [e [H6 H7] ].
rewrite in_map_iff in H6.
destruct H6 as [q [H6 H8] ].
rewrite in_seq_iff in H8.
subst e.
simpl in H7.
case_eq (n+s).
intro H9.
contradict H8.
omega.
intros r H9.
rewrite H9 in H7.
case_eq (leb q r); intro H10.
rewrite H10 in H7.
simpl in H7.
do 2 rewrite <- beq_nat_refl in H7.
discriminate H7.
rewrite leb_iff_conv in H10.
contradict H10.
omega.
rewrite forallb_forall_conv in H5.
destruct H5 as [e [H5 H6] ].
rewrite in_map_iff in H5.
destruct H5 as [q [H5 H7] ].
rewrite in_seq_iff in H7.
subst e.
simpl in H6.
case_eq (n+0).
intro H8.
contradict H7.
omega.
intros r H8.
rewrite H8 in H6.
case_eq (leb q r); intro H9.
rewrite H9 in H6.
simpl in H6.
rewrite <- beq_nat_refl in H6.
discriminate H6.
rewrite leb_iff_conv in H9.
contradict H9.
omega.
rewrite forallb_forall_conv in H4.
destruct H4 as [e [H4 H5] ].
rewrite in_map_iff in H4.
destruct H4 as [q [H4 H6] ].
rewrite in_seq_iff in H6.
subst e.
simpl in H5.
case_eq (n+S s).
intro H7.
contradict H6.
omega.
intros r H7.
rewrite H7 in H5.
case_eq (leb q (S r)); intro H8.
rewrite H8 in H5.
simpl in H5.
do 2 rewrite <- beq_nat_refl in H5.
discriminate H5.
rewrite leb_iff_conv in H8.
contradict H8.
omega.

*****
H3 : eq (Nat.leb n p) false
H2 : eq (Init.Nat.add n (S s)) (S p)
p : nat
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O))\n (map (proj (S n) O) (seq (S O) n))) true
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n O)
x,g,h : BC
n,s : nat
*****
eq match match (if andb (aeq (error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) with | error_rec a a0 a1 => error_rec (ok_arities n s) (error_rec a a0 a1) (if andb (aeq (error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | error_comp a l l0 => error_rec (ok_arities n s) (error_comp a l l0) (if andb (aeq (error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | error_proj n0 n1 n2 => error_rec (ok_arities n s) (error_proj n0 n1 n2) (if andb (aeq (error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | ok_arities h0n h0s => match (if andb (aeq (error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) with | error_rec a a0 a1 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_rec a a0 a1) | error_comp a l l0 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_comp a l l0) | error_proj n0 n1 n2 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_proj n0 n1 n2) | ok_arities h1n h1s => if andb (andb (andb match h0n with | O => false | S m' => Nat.eqb n m' end (Nat.eqb h0n h1n)) match h0s with | O => false | S m' => Nat.eqb s m' end) (Nat.eqb h0s h1s) then ok_arities h0n s else error_rec (ok_arities n s) (ok_arities h0n h0s) (ok_arities h1n h1s) end end with | error_rec a a0 a1 => error_comp (error_rec a a0 a1) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s))) | error_comp a l l0 => error_comp (error_comp a l l0) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s))) | error_proj n0 n1 n2 => error_comp (error_proj n0 n1 n2) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s))) | ok_arities hn hs => if andb (andb (andb (Nat.eqb hn (S n)) (Nat.eqb hs s)) (forallb (fun ne : BC => aeq (arities ne) (ok_arities n O)) (map (proj n O) (seq O n)))) (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s))) then ok_arities n s else error_comp (ok_arities hn hs) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s))) end (ok_arities n s)
+++++
rewrite leb_iff_conv in H3.
-----
Lemma arities_rec3 n s x g h (Hx : arities x = ok_arities n 0) (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec3 n s x g h) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh.
simpl.
do 4 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).
intro H2.
contradict H2.
omega.
intros p H2.
case_eq (leb n p); intro H3.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H4 end.
do 4 rewrite <- beq_nat_refl.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H5 end.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H6 end.
simpl.
reflexivity.
rewrite forallb_forall_conv in H6.
destruct H6 as [e [H6 H7] ].
rewrite in_map_iff in H6.
destruct H6 as [q [H6 H8] ].
rewrite in_seq_iff in H8.
subst e.
simpl in H7.
case_eq (n+s).
intro H9.
contradict H8.
omega.
intros r H9.
rewrite H9 in H7.
case_eq (leb q r); intro H10.
rewrite H10 in H7.
simpl in H7.
do 2 rewrite <- beq_nat_refl in H7.
discriminate H7.
rewrite leb_iff_conv in H10.
contradict H10.
omega.
rewrite forallb_forall_conv in H5.
destruct H5 as [e [H5 H6] ].
rewrite in_map_iff in H5.
destruct H5 as [q [H5 H7] ].
rewrite in_seq_iff in H7.
subst e.
simpl in H6.
case_eq (n+0).
intro H8.
contradict H7.
omega.
intros r H8.
rewrite H8 in H6.
case_eq (leb q r); intro H9.
rewrite H9 in H6.
simpl in H6.
rewrite <- beq_nat_refl in H6.
discriminate H6.
rewrite leb_iff_conv in H9.
contradict H9.
omega.
rewrite forallb_forall_conv in H4.
destruct H4 as [e [H4 H5] ].
rewrite in_map_iff in H4.
destruct H4 as [q [H4 H6] ].
rewrite in_seq_iff in H6.
subst e.
simpl in H5.
case_eq (n+S s).
intro H7.
contradict H6.
omega.
intros r H7.
rewrite H7 in H5.
case_eq (leb q (S r)); intro H8.
rewrite H8 in H5.
simpl in H5.
do 2 rewrite <- beq_nat_refl in H5.
discriminate H5.
rewrite leb_iff_conv in H8.
contradict H8.
omega.
rewrite leb_iff_conv in H3.

*****
H3 : lt p n
H2 : eq (Init.Nat.add n (S s)) (S p)
p : nat
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O))\n (map (proj (S n) O) (seq (S O) n))) true
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n O)
x,g,h : BC
n,s : nat
*****
eq match match (if andb (aeq (error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) with | error_rec a a0 a1 => error_rec (ok_arities n s) (error_rec a a0 a1) (if andb (aeq (error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | error_comp a l l0 => error_rec (ok_arities n s) (error_comp a l l0) (if andb (aeq (error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | error_proj n0 n1 n2 => error_rec (ok_arities n s) (error_proj n0 n1 n2) (if andb (aeq (error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | ok_arities h0n h0s => match (if andb (aeq (error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) with | error_rec a a0 a1 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_rec a a0 a1) | error_comp a l l0 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_comp a l l0) | error_proj n0 n1 n2 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_proj n0 n1 n2) | ok_arities h1n h1s => if andb (andb (andb match h0n with | O => false | S m' => Nat.eqb n m' end (Nat.eqb h0n h1n)) match h0s with | O => false | S m' => Nat.eqb s m' end) (Nat.eqb h0s h1s) then ok_arities h0n s else error_rec (ok_arities n s) (ok_arities h0n h0s) (ok_arities h1n h1s) end end with | error_rec a a0 a1 => error_comp (error_rec a a0 a1) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s))) | error_comp a l l0 => error_comp (error_comp a l l0) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s))) | error_proj n0 n1 n2 => error_comp (error_proj n0 n1 n2) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s))) | ok_arities hn hs => if andb (andb (andb (Nat.eqb hn (S n)) (Nat.eqb hs s)) (forallb (fun ne : BC => aeq (arities ne) (ok_arities n O)) (map (proj n O) (seq O n)))) (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s))) then ok_arities n s else error_comp (ok_arities hn hs) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s))) end (ok_arities n s)
+++++
contradict H3.
-----
Lemma arities_rec3 n s x g h (Hx : arities x = ok_arities n 0) (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec3 n s x g h) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh.
simpl.
do 4 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).
intro H2.
contradict H2.
omega.
intros p H2.
case_eq (leb n p); intro H3.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H4 end.
do 4 rewrite <- beq_nat_refl.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H5 end.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H6 end.
simpl.
reflexivity.
rewrite forallb_forall_conv in H6.
destruct H6 as [e [H6 H7] ].
rewrite in_map_iff in H6.
destruct H6 as [q [H6 H8] ].
rewrite in_seq_iff in H8.
subst e.
simpl in H7.
case_eq (n+s).
intro H9.
contradict H8.
omega.
intros r H9.
rewrite H9 in H7.
case_eq (leb q r); intro H10.
rewrite H10 in H7.
simpl in H7.
do 2 rewrite <- beq_nat_refl in H7.
discriminate H7.
rewrite leb_iff_conv in H10.
contradict H10.
omega.
rewrite forallb_forall_conv in H5.
destruct H5 as [e [H5 H6] ].
rewrite in_map_iff in H5.
destruct H5 as [q [H5 H7] ].
rewrite in_seq_iff in H7.
subst e.
simpl in H6.
case_eq (n+0).
intro H8.
contradict H7.
omega.
intros r H8.
rewrite H8 in H6.
case_eq (leb q r); intro H9.
rewrite H9 in H6.
simpl in H6.
rewrite <- beq_nat_refl in H6.
discriminate H6.
rewrite leb_iff_conv in H9.
contradict H9.
omega.
rewrite forallb_forall_conv in H4.
destruct H4 as [e [H4 H5] ].
rewrite in_map_iff in H4.
destruct H4 as [q [H4 H6] ].
rewrite in_seq_iff in H6.
subst e.
simpl in H5.
case_eq (n+S s).
intro H7.
contradict H6.
omega.
intros r H7.
rewrite H7 in H5.
case_eq (leb q (S r)); intro H8.
rewrite H8 in H5.
simpl in H5.
do 2 rewrite <- beq_nat_refl in H5.
discriminate H5.
rewrite leb_iff_conv in H8.
contradict H8.
omega.
rewrite leb_iff_conv in H3.
contradict H3.

*****
H2 : eq (Init.Nat.add n (S s)) (S p)
p : nat
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O))\n (map (proj (S n) O) (seq (S O) n))) true
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n O)
x,g,h : BC
n,s : nat
*****
not (lt p n)
+++++
omega.
-----
Lemma arities_rec3 n s x g h (Hx : arities x = ok_arities n 0) (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec3 n s x g h) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh.
simpl.
do 4 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).
intro H2.
contradict H2.
omega.
intros p H2.
case_eq (leb n p); intro H3.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H4 end.
do 4 rewrite <- beq_nat_refl.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H5 end.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H6 end.
simpl.
reflexivity.
rewrite forallb_forall_conv in H6.
destruct H6 as [e [H6 H7] ].
rewrite in_map_iff in H6.
destruct H6 as [q [H6 H8] ].
rewrite in_seq_iff in H8.
subst e.
simpl in H7.
case_eq (n+s).
intro H9.
contradict H8.
omega.
intros r H9.
rewrite H9 in H7.
case_eq (leb q r); intro H10.
rewrite H10 in H7.
simpl in H7.
do 2 rewrite <- beq_nat_refl in H7.
discriminate H7.
rewrite leb_iff_conv in H10.
contradict H10.
omega.
rewrite forallb_forall_conv in H5.
destruct H5 as [e [H5 H6] ].
rewrite in_map_iff in H5.
destruct H5 as [q [H5 H7] ].
rewrite in_seq_iff in H7.
subst e.
simpl in H6.
case_eq (n+0).
intro H8.
contradict H7.
omega.
intros r H8.
rewrite H8 in H6.
case_eq (leb q r); intro H9.
rewrite H9 in H6.
simpl in H6.
rewrite <- beq_nat_refl in H6.
discriminate H6.
rewrite leb_iff_conv in H9.
contradict H9.
omega.
rewrite forallb_forall_conv in H4.
destruct H4 as [e [H4 H5] ].
rewrite in_map_iff in H4.
destruct H4 as [q [H4 H6] ].
rewrite in_seq_iff in H6.
subst e.
simpl in H5.
case_eq (n+S s).
intro H7.
contradict H6.
omega.
intros r H7.
rewrite H7 in H5.
case_eq (leb q (S r)); intro H8.
rewrite H8 in H5.
simpl in H5.
do 2 rewrite <- beq_nat_refl in H5.
discriminate H5.
rewrite leb_iff_conv in H8.
contradict H8.
omega.
rewrite leb_iff_conv in H3.
contradict H3.
omega.

*****
H1 : eq\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities (S n) O))\n (map (proj (S n) O) (seq (S O) n))) false
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n O)
x,g,h : BC
n,s : nat
*****
eq match match (if andb false (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) with | error_rec a a0 a1 => error_rec (ok_arities n s) (error_rec a a0 a1) (if andb false (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | error_comp a l l0 => error_rec (ok_arities n s) (error_comp a l l0) (if andb false (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | error_proj n0 n1 n2 => error_rec (ok_arities n s) (error_proj n0 n1 n2) (if andb false (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | ok_arities h0n h0s => match (if andb false (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) with | error_rec a a0 a1 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_rec a a0 a1) | error_comp a l l0 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_comp a l l0) | error_proj n0 n1 n2 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_proj n0 n1 n2) | ok_arities h1n h1s => if andb (andb (andb match h0n with | O => false | S m' => Nat.eqb n m' end (Nat.eqb h0n h1n)) match h0s with | O => false | S m' => Nat.eqb s m' end) (Nat.eqb h0s h1s) then ok_arities h0n s else error_rec (ok_arities n s) (ok_arities h0n h0s) (ok_arities h1n h1s) end end with | error_rec a a0 a1 => error_comp (error_rec a a0 a1) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s))) | error_comp a l l0 => error_comp (error_comp a l l0) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s))) | error_proj n0 n1 n2 => error_comp (error_proj n0 n1 n2) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s))) | ok_arities hn hs => if andb (andb (andb (Nat.eqb hn (S n)) (Nat.eqb hs s)) (forallb (fun ne : BC => aeq (arities ne) (ok_arities n O)) (map (proj n O) (seq O n)))) (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s))) then ok_arities n s else error_comp (ok_arities hn hs) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s))) end (ok_arities n s)
+++++
rewrite forallb_forall_conv in H1.
-----
Lemma arities_rec3 n s x g h (Hx : arities x = ok_arities n 0) (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec3 n s x g h) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh.
simpl.
do 4 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).
intro H2.
contradict H2.
omega.
intros p H2.
case_eq (leb n p); intro H3.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H4 end.
do 4 rewrite <- beq_nat_refl.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H5 end.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H6 end.
simpl.
reflexivity.
rewrite forallb_forall_conv in H6.
destruct H6 as [e [H6 H7] ].
rewrite in_map_iff in H6.
destruct H6 as [q [H6 H8] ].
rewrite in_seq_iff in H8.
subst e.
simpl in H7.
case_eq (n+s).
intro H9.
contradict H8.
omega.
intros r H9.
rewrite H9 in H7.
case_eq (leb q r); intro H10.
rewrite H10 in H7.
simpl in H7.
do 2 rewrite <- beq_nat_refl in H7.
discriminate H7.
rewrite leb_iff_conv in H10.
contradict H10.
omega.
rewrite forallb_forall_conv in H5.
destruct H5 as [e [H5 H6] ].
rewrite in_map_iff in H5.
destruct H5 as [q [H5 H7] ].
rewrite in_seq_iff in H7.
subst e.
simpl in H6.
case_eq (n+0).
intro H8.
contradict H7.
omega.
intros r H8.
rewrite H8 in H6.
case_eq (leb q r); intro H9.
rewrite H9 in H6.
simpl in H6.
rewrite <- beq_nat_refl in H6.
discriminate H6.
rewrite leb_iff_conv in H9.
contradict H9.
omega.
rewrite forallb_forall_conv in H4.
destruct H4 as [e [H4 H5] ].
rewrite in_map_iff in H4.
destruct H4 as [q [H4 H6] ].
rewrite in_seq_iff in H6.
subst e.
simpl in H5.
case_eq (n+S s).
intro H7.
contradict H6.
omega.
intros r H7.
rewrite H7 in H5.
case_eq (leb q (S r)); intro H8.
rewrite H8 in H5.
simpl in H5.
do 2 rewrite <- beq_nat_refl in H5.
discriminate H5.
rewrite leb_iff_conv in H8.
contradict H8.
omega.
rewrite leb_iff_conv in H3.
contradict H3.
omega.
rewrite forallb_forall_conv in H1.

*****
H1 : ex\n (fun x : BC =>\n and (In x (map (proj (S n) O) (seq (S O) n)))\n (eq (aeq (arities x) (ok_arities (S n) O)) false))
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n O)
x,g,h : BC
n,s : nat
*****
eq match match (if andb false (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) with | error_rec a a0 a1 => error_rec (ok_arities n s) (error_rec a a0 a1) (if andb false (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | error_comp a l l0 => error_rec (ok_arities n s) (error_comp a l l0) (if andb false (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | error_proj n0 n1 n2 => error_rec (ok_arities n s) (error_proj n0 n1 n2) (if andb false (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | ok_arities h0n h0s => match (if andb false (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) with | error_rec a a0 a1 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_rec a a0 a1) | error_comp a l l0 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_comp a l l0) | error_proj n0 n1 n2 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_proj n0 n1 n2) | ok_arities h1n h1s => if andb (andb (andb match h0n with | O => false | S m' => Nat.eqb n m' end (Nat.eqb h0n h1n)) match h0s with | O => false | S m' => Nat.eqb s m' end) (Nat.eqb h0s h1s) then ok_arities h0n s else error_rec (ok_arities n s) (ok_arities h0n h0s) (ok_arities h1n h1s) end end with | error_rec a a0 a1 => error_comp (error_rec a a0 a1) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s))) | error_comp a l l0 => error_comp (error_comp a l l0) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s))) | error_proj n0 n1 n2 => error_comp (error_proj n0 n1 n2) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s))) | ok_arities hn hs => if andb (andb (andb (Nat.eqb hn (S n)) (Nat.eqb hs s)) (forallb (fun ne : BC => aeq (arities ne) (ok_arities n O)) (map (proj n O) (seq O n)))) (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s))) then ok_arities n s else error_comp (ok_arities hn hs) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s))) end (ok_arities n s)
+++++
destruct H1 as [e [H1 H2] ].
-----
Lemma arities_rec3 n s x g h (Hx : arities x = ok_arities n 0) (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec3 n s x g h) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh.
simpl.
do 4 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).
intro H2.
contradict H2.
omega.
intros p H2.
case_eq (leb n p); intro H3.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H4 end.
do 4 rewrite <- beq_nat_refl.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H5 end.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H6 end.
simpl.
reflexivity.
rewrite forallb_forall_conv in H6.
destruct H6 as [e [H6 H7] ].
rewrite in_map_iff in H6.
destruct H6 as [q [H6 H8] ].
rewrite in_seq_iff in H8.
subst e.
simpl in H7.
case_eq (n+s).
intro H9.
contradict H8.
omega.
intros r H9.
rewrite H9 in H7.
case_eq (leb q r); intro H10.
rewrite H10 in H7.
simpl in H7.
do 2 rewrite <- beq_nat_refl in H7.
discriminate H7.
rewrite leb_iff_conv in H10.
contradict H10.
omega.
rewrite forallb_forall_conv in H5.
destruct H5 as [e [H5 H6] ].
rewrite in_map_iff in H5.
destruct H5 as [q [H5 H7] ].
rewrite in_seq_iff in H7.
subst e.
simpl in H6.
case_eq (n+0).
intro H8.
contradict H7.
omega.
intros r H8.
rewrite H8 in H6.
case_eq (leb q r); intro H9.
rewrite H9 in H6.
simpl in H6.
rewrite <- beq_nat_refl in H6.
discriminate H6.
rewrite leb_iff_conv in H9.
contradict H9.
omega.
rewrite forallb_forall_conv in H4.
destruct H4 as [e [H4 H5] ].
rewrite in_map_iff in H4.
destruct H4 as [q [H4 H6] ].
rewrite in_seq_iff in H6.
subst e.
simpl in H5.
case_eq (n+S s).
intro H7.
contradict H6.
omega.
intros r H7.
rewrite H7 in H5.
case_eq (leb q (S r)); intro H8.
rewrite H8 in H5.
simpl in H5.
do 2 rewrite <- beq_nat_refl in H5.
discriminate H5.
rewrite leb_iff_conv in H8.
contradict H8.
omega.
rewrite leb_iff_conv in H3.
contradict H3.
omega.
rewrite forallb_forall_conv in H1.
destruct H1 as [e [H1 H2] ].

*****
H2 : eq (aeq (arities e) (ok_arities (S n) O)) false
H1 : In e (map (proj (S n) O) (seq (S O) n))
e : BC
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n O)
x,g,h : BC
n,s : nat
*****
eq match match (if andb false (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) with | error_rec a a0 a1 => error_rec (ok_arities n s) (error_rec a a0 a1) (if andb false (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | error_comp a l l0 => error_rec (ok_arities n s) (error_comp a l l0) (if andb false (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | error_proj n0 n1 n2 => error_rec (ok_arities n s) (error_proj n0 n1 n2) (if andb false (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | ok_arities h0n h0s => match (if andb false (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) with | error_rec a a0 a1 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_rec a a0 a1) | error_comp a l l0 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_comp a l l0) | error_proj n0 n1 n2 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_proj n0 n1 n2) | ok_arities h1n h1s => if andb (andb (andb match h0n with | O => false | S m' => Nat.eqb n m' end (Nat.eqb h0n h1n)) match h0s with | O => false | S m' => Nat.eqb s m' end) (Nat.eqb h0s h1s) then ok_arities h0n s else error_rec (ok_arities n s) (ok_arities h0n h0s) (ok_arities h1n h1s) end end with | error_rec a a0 a1 => error_comp (error_rec a a0 a1) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s))) | error_comp a l l0 => error_comp (error_comp a l l0) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s))) | error_proj n0 n1 n2 => error_comp (error_proj n0 n1 n2) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s))) | ok_arities hn hs => if andb (andb (andb (Nat.eqb hn (S n)) (Nat.eqb hs s)) (forallb (fun ne : BC => aeq (arities ne) (ok_arities n O)) (map (proj n O) (seq O n)))) (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s))) then ok_arities n s else error_comp (ok_arities hn hs) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s))) end (ok_arities n s)
+++++
rewrite in_map_iff in H1.
-----
Lemma arities_rec3 n s x g h (Hx : arities x = ok_arities n 0) (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec3 n s x g h) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh.
simpl.
do 4 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).
intro H2.
contradict H2.
omega.
intros p H2.
case_eq (leb n p); intro H3.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H4 end.
do 4 rewrite <- beq_nat_refl.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H5 end.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H6 end.
simpl.
reflexivity.
rewrite forallb_forall_conv in H6.
destruct H6 as [e [H6 H7] ].
rewrite in_map_iff in H6.
destruct H6 as [q [H6 H8] ].
rewrite in_seq_iff in H8.
subst e.
simpl in H7.
case_eq (n+s).
intro H9.
contradict H8.
omega.
intros r H9.
rewrite H9 in H7.
case_eq (leb q r); intro H10.
rewrite H10 in H7.
simpl in H7.
do 2 rewrite <- beq_nat_refl in H7.
discriminate H7.
rewrite leb_iff_conv in H10.
contradict H10.
omega.
rewrite forallb_forall_conv in H5.
destruct H5 as [e [H5 H6] ].
rewrite in_map_iff in H5.
destruct H5 as [q [H5 H7] ].
rewrite in_seq_iff in H7.
subst e.
simpl in H6.
case_eq (n+0).
intro H8.
contradict H7.
omega.
intros r H8.
rewrite H8 in H6.
case_eq (leb q r); intro H9.
rewrite H9 in H6.
simpl in H6.
rewrite <- beq_nat_refl in H6.
discriminate H6.
rewrite leb_iff_conv in H9.
contradict H9.
omega.
rewrite forallb_forall_conv in H4.
destruct H4 as [e [H4 H5] ].
rewrite in_map_iff in H4.
destruct H4 as [q [H4 H6] ].
rewrite in_seq_iff in H6.
subst e.
simpl in H5.
case_eq (n+S s).
intro H7.
contradict H6.
omega.
intros r H7.
rewrite H7 in H5.
case_eq (leb q (S r)); intro H8.
rewrite H8 in H5.
simpl in H5.
do 2 rewrite <- beq_nat_refl in H5.
discriminate H5.
rewrite leb_iff_conv in H8.
contradict H8.
omega.
rewrite leb_iff_conv in H3.
contradict H3.
omega.
rewrite forallb_forall_conv in H1.
destruct H1 as [e [H1 H2] ].
rewrite in_map_iff in H1.

*****
H2 : eq (aeq (arities e) (ok_arities (S n) O)) false
H1 : ex (fun x : nat => and (eq (proj (S n) O x) e) (In x (seq (S O) n)))
e : BC
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n O)
x,g,h : BC
n,s : nat
*****
eq match match (if andb false (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) with | error_rec a a0 a1 => error_rec (ok_arities n s) (error_rec a a0 a1) (if andb false (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | error_comp a l l0 => error_rec (ok_arities n s) (error_comp a l l0) (if andb false (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | error_proj n0 n1 n2 => error_rec (ok_arities n s) (error_proj n0 n1 n2) (if andb false (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | ok_arities h0n h0s => match (if andb false (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) with | error_rec a a0 a1 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_rec a a0 a1) | error_comp a l l0 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_comp a l l0) | error_proj n0 n1 n2 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_proj n0 n1 n2) | ok_arities h1n h1s => if andb (andb (andb match h0n with | O => false | S m' => Nat.eqb n m' end (Nat.eqb h0n h1n)) match h0s with | O => false | S m' => Nat.eqb s m' end) (Nat.eqb h0s h1s) then ok_arities h0n s else error_rec (ok_arities n s) (ok_arities h0n h0s) (ok_arities h1n h1s) end end with | error_rec a a0 a1 => error_comp (error_rec a a0 a1) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s))) | error_comp a l l0 => error_comp (error_comp a l l0) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s))) | error_proj n0 n1 n2 => error_comp (error_proj n0 n1 n2) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s))) | ok_arities hn hs => if andb (andb (andb (Nat.eqb hn (S n)) (Nat.eqb hs s)) (forallb (fun ne : BC => aeq (arities ne) (ok_arities n O)) (map (proj n O) (seq O n)))) (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s))) then ok_arities n s else error_comp (ok_arities hn hs) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s))) end (ok_arities n s)
+++++
destruct H1 as [q [H1 H3] ].
-----
Lemma arities_rec3 n s x g h (Hx : arities x = ok_arities n 0) (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec3 n s x g h) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh.
simpl.
do 4 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).
intro H2.
contradict H2.
omega.
intros p H2.
case_eq (leb n p); intro H3.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H4 end.
do 4 rewrite <- beq_nat_refl.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H5 end.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H6 end.
simpl.
reflexivity.
rewrite forallb_forall_conv in H6.
destruct H6 as [e [H6 H7] ].
rewrite in_map_iff in H6.
destruct H6 as [q [H6 H8] ].
rewrite in_seq_iff in H8.
subst e.
simpl in H7.
case_eq (n+s).
intro H9.
contradict H8.
omega.
intros r H9.
rewrite H9 in H7.
case_eq (leb q r); intro H10.
rewrite H10 in H7.
simpl in H7.
do 2 rewrite <- beq_nat_refl in H7.
discriminate H7.
rewrite leb_iff_conv in H10.
contradict H10.
omega.
rewrite forallb_forall_conv in H5.
destruct H5 as [e [H5 H6] ].
rewrite in_map_iff in H5.
destruct H5 as [q [H5 H7] ].
rewrite in_seq_iff in H7.
subst e.
simpl in H6.
case_eq (n+0).
intro H8.
contradict H7.
omega.
intros r H8.
rewrite H8 in H6.
case_eq (leb q r); intro H9.
rewrite H9 in H6.
simpl in H6.
rewrite <- beq_nat_refl in H6.
discriminate H6.
rewrite leb_iff_conv in H9.
contradict H9.
omega.
rewrite forallb_forall_conv in H4.
destruct H4 as [e [H4 H5] ].
rewrite in_map_iff in H4.
destruct H4 as [q [H4 H6] ].
rewrite in_seq_iff in H6.
subst e.
simpl in H5.
case_eq (n+S s).
intro H7.
contradict H6.
omega.
intros r H7.
rewrite H7 in H5.
case_eq (leb q (S r)); intro H8.
rewrite H8 in H5.
simpl in H5.
do 2 rewrite <- beq_nat_refl in H5.
discriminate H5.
rewrite leb_iff_conv in H8.
contradict H8.
omega.
rewrite leb_iff_conv in H3.
contradict H3.
omega.
rewrite forallb_forall_conv in H1.
destruct H1 as [e [H1 H2] ].
rewrite in_map_iff in H1.
destruct H1 as [q [H1 H3] ].

*****
H2 : eq (aeq (arities e) (ok_arities (S n) O)) false
H3 : In q (seq (S O) n)
H1 : eq (proj (S n) O q) e
q : nat
e : BC
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n O)
x,g,h : BC
n,s : nat
*****
eq match match (if andb false (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) with | error_rec a a0 a1 => error_rec (ok_arities n s) (error_rec a a0 a1) (if andb false (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | error_comp a l l0 => error_rec (ok_arities n s) (error_comp a l l0) (if andb false (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | error_proj n0 n1 n2 => error_rec (ok_arities n s) (error_proj n0 n1 n2) (if andb false (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | ok_arities h0n h0s => match (if andb false (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) with | error_rec a a0 a1 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_rec a a0 a1) | error_comp a l l0 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_comp a l l0) | error_proj n0 n1 n2 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_proj n0 n1 n2) | ok_arities h1n h1s => if andb (andb (andb match h0n with | O => false | S m' => Nat.eqb n m' end (Nat.eqb h0n h1n)) match h0s with | O => false | S m' => Nat.eqb s m' end) (Nat.eqb h0s h1s) then ok_arities h0n s else error_rec (ok_arities n s) (ok_arities h0n h0s) (ok_arities h1n h1s) end end with | error_rec a a0 a1 => error_comp (error_rec a a0 a1) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s))) | error_comp a l l0 => error_comp (error_comp a l l0) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s))) | error_proj n0 n1 n2 => error_comp (error_proj n0 n1 n2) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s))) | ok_arities hn hs => if andb (andb (andb (Nat.eqb hn (S n)) (Nat.eqb hs s)) (forallb (fun ne : BC => aeq (arities ne) (ok_arities n O)) (map (proj n O) (seq O n)))) (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s))) then ok_arities n s else error_comp (ok_arities hn hs) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s))) end (ok_arities n s)
+++++
rewrite in_seq_iff in H3.
-----
Lemma arities_rec3 n s x g h (Hx : arities x = ok_arities n 0) (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec3 n s x g h) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh.
simpl.
do 4 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).
intro H2.
contradict H2.
omega.
intros p H2.
case_eq (leb n p); intro H3.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H4 end.
do 4 rewrite <- beq_nat_refl.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H5 end.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H6 end.
simpl.
reflexivity.
rewrite forallb_forall_conv in H6.
destruct H6 as [e [H6 H7] ].
rewrite in_map_iff in H6.
destruct H6 as [q [H6 H8] ].
rewrite in_seq_iff in H8.
subst e.
simpl in H7.
case_eq (n+s).
intro H9.
contradict H8.
omega.
intros r H9.
rewrite H9 in H7.
case_eq (leb q r); intro H10.
rewrite H10 in H7.
simpl in H7.
do 2 rewrite <- beq_nat_refl in H7.
discriminate H7.
rewrite leb_iff_conv in H10.
contradict H10.
omega.
rewrite forallb_forall_conv in H5.
destruct H5 as [e [H5 H6] ].
rewrite in_map_iff in H5.
destruct H5 as [q [H5 H7] ].
rewrite in_seq_iff in H7.
subst e.
simpl in H6.
case_eq (n+0).
intro H8.
contradict H7.
omega.
intros r H8.
rewrite H8 in H6.
case_eq (leb q r); intro H9.
rewrite H9 in H6.
simpl in H6.
rewrite <- beq_nat_refl in H6.
discriminate H6.
rewrite leb_iff_conv in H9.
contradict H9.
omega.
rewrite forallb_forall_conv in H4.
destruct H4 as [e [H4 H5] ].
rewrite in_map_iff in H4.
destruct H4 as [q [H4 H6] ].
rewrite in_seq_iff in H6.
subst e.
simpl in H5.
case_eq (n+S s).
intro H7.
contradict H6.
omega.
intros r H7.
rewrite H7 in H5.
case_eq (leb q (S r)); intro H8.
rewrite H8 in H5.
simpl in H5.
do 2 rewrite <- beq_nat_refl in H5.
discriminate H5.
rewrite leb_iff_conv in H8.
contradict H8.
omega.
rewrite leb_iff_conv in H3.
contradict H3.
omega.
rewrite forallb_forall_conv in H1.
destruct H1 as [e [H1 H2] ].
rewrite in_map_iff in H1.
destruct H1 as [q [H1 H3] ].
rewrite in_seq_iff in H3.

*****
H2 : eq (aeq (arities e) (ok_arities (S n) O)) false
H3 : and (le (S O) q) (lt q (Init.Nat.add (S O) n))
H1 : eq (proj (S n) O q) e
q : nat
e : BC
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n O)
x,g,h : BC
n,s : nat
*****
eq match match (if andb false (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) with | error_rec a a0 a1 => error_rec (ok_arities n s) (error_rec a a0 a1) (if andb false (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | error_comp a l l0 => error_rec (ok_arities n s) (error_comp a l l0) (if andb false (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | error_proj n0 n1 n2 => error_rec (ok_arities n s) (error_proj n0 n1 n2) (if andb false (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | ok_arities h0n h0s => match (if andb false (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) with | error_rec a a0 a1 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_rec a a0 a1) | error_comp a l l0 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_comp a l l0) | error_proj n0 n1 n2 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_proj n0 n1 n2) | ok_arities h1n h1s => if andb (andb (andb match h0n with | O => false | S m' => Nat.eqb n m' end (Nat.eqb h0n h1n)) match h0s with | O => false | S m' => Nat.eqb s m' end) (Nat.eqb h0s h1s) then ok_arities h0n s else error_rec (ok_arities n s) (ok_arities h0n h0s) (ok_arities h1n h1s) end end with | error_rec a a0 a1 => error_comp (error_rec a a0 a1) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s))) | error_comp a l l0 => error_comp (error_comp a l l0) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s))) | error_proj n0 n1 n2 => error_comp (error_proj n0 n1 n2) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s))) | ok_arities hn hs => if andb (andb (andb (Nat.eqb hn (S n)) (Nat.eqb hs s)) (forallb (fun ne : BC => aeq (arities ne) (ok_arities n O)) (map (proj n O) (seq O n)))) (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s))) then ok_arities n s else error_comp (ok_arities hn hs) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s))) end (ok_arities n s)
+++++
subst e.
-----
Lemma arities_rec3 n s x g h (Hx : arities x = ok_arities n 0) (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec3 n s x g h) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh.
simpl.
do 4 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).
intro H2.
contradict H2.
omega.
intros p H2.
case_eq (leb n p); intro H3.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H4 end.
do 4 rewrite <- beq_nat_refl.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H5 end.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H6 end.
simpl.
reflexivity.
rewrite forallb_forall_conv in H6.
destruct H6 as [e [H6 H7] ].
rewrite in_map_iff in H6.
destruct H6 as [q [H6 H8] ].
rewrite in_seq_iff in H8.
subst e.
simpl in H7.
case_eq (n+s).
intro H9.
contradict H8.
omega.
intros r H9.
rewrite H9 in H7.
case_eq (leb q r); intro H10.
rewrite H10 in H7.
simpl in H7.
do 2 rewrite <- beq_nat_refl in H7.
discriminate H7.
rewrite leb_iff_conv in H10.
contradict H10.
omega.
rewrite forallb_forall_conv in H5.
destruct H5 as [e [H5 H6] ].
rewrite in_map_iff in H5.
destruct H5 as [q [H5 H7] ].
rewrite in_seq_iff in H7.
subst e.
simpl in H6.
case_eq (n+0).
intro H8.
contradict H7.
omega.
intros r H8.
rewrite H8 in H6.
case_eq (leb q r); intro H9.
rewrite H9 in H6.
simpl in H6.
rewrite <- beq_nat_refl in H6.
discriminate H6.
rewrite leb_iff_conv in H9.
contradict H9.
omega.
rewrite forallb_forall_conv in H4.
destruct H4 as [e [H4 H5] ].
rewrite in_map_iff in H4.
destruct H4 as [q [H4 H6] ].
rewrite in_seq_iff in H6.
subst e.
simpl in H5.
case_eq (n+S s).
intro H7.
contradict H6.
omega.
intros r H7.
rewrite H7 in H5.
case_eq (leb q (S r)); intro H8.
rewrite H8 in H5.
simpl in H5.
do 2 rewrite <- beq_nat_refl in H5.
discriminate H5.
rewrite leb_iff_conv in H8.
contradict H8.
omega.
rewrite leb_iff_conv in H3.
contradict H3.
omega.
rewrite forallb_forall_conv in H1.
destruct H1 as [e [H1 H2] ].
rewrite in_map_iff in H1.
destruct H1 as [q [H1 H3] ].
rewrite in_seq_iff in H3.
subst e.

*****
H2 : eq (aeq (arities (proj (S n) O q)) (ok_arities (S n) O)) false
H3 : and (le (S O) q) (lt q (Init.Nat.add (S O) n))
q : nat
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n O)
x,g,h : BC
n,s : nat
*****
eq match match (if andb false (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) with | error_rec a a0 a1 => error_rec (ok_arities n s) (error_rec a a0 a1) (if andb false (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | error_comp a l l0 => error_rec (ok_arities n s) (error_comp a l l0) (if andb false (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | error_proj n0 n1 n2 => error_rec (ok_arities n s) (error_proj n0 n1 n2) (if andb false (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | ok_arities h0n h0s => match (if andb false (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) with | error_rec a a0 a1 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_rec a a0 a1) | error_comp a l l0 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_comp a l l0) | error_proj n0 n1 n2 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_proj n0 n1 n2) | ok_arities h1n h1s => if andb (andb (andb match h0n with | O => false | S m' => Nat.eqb n m' end (Nat.eqb h0n h1n)) match h0s with | O => false | S m' => Nat.eqb s m' end) (Nat.eqb h0s h1s) then ok_arities h0n s else error_rec (ok_arities n s) (ok_arities h0n h0s) (ok_arities h1n h1s) end end with | error_rec a a0 a1 => error_comp (error_rec a a0 a1) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s))) | error_comp a l l0 => error_comp (error_comp a l l0) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s))) | error_proj n0 n1 n2 => error_comp (error_proj n0 n1 n2) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s))) | ok_arities hn hs => if andb (andb (andb (Nat.eqb hn (S n)) (Nat.eqb hs s)) (forallb (fun ne : BC => aeq (arities ne) (ok_arities n O)) (map (proj n O) (seq O n)))) (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s))) then ok_arities n s else error_comp (ok_arities hn hs) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s))) end (ok_arities n s)
+++++
simpl in H2.
-----
Lemma arities_rec3 n s x g h (Hx : arities x = ok_arities n 0) (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec3 n s x g h) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh.
simpl.
do 4 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).
intro H2.
contradict H2.
omega.
intros p H2.
case_eq (leb n p); intro H3.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H4 end.
do 4 rewrite <- beq_nat_refl.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H5 end.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H6 end.
simpl.
reflexivity.
rewrite forallb_forall_conv in H6.
destruct H6 as [e [H6 H7] ].
rewrite in_map_iff in H6.
destruct H6 as [q [H6 H8] ].
rewrite in_seq_iff in H8.
subst e.
simpl in H7.
case_eq (n+s).
intro H9.
contradict H8.
omega.
intros r H9.
rewrite H9 in H7.
case_eq (leb q r); intro H10.
rewrite H10 in H7.
simpl in H7.
do 2 rewrite <- beq_nat_refl in H7.
discriminate H7.
rewrite leb_iff_conv in H10.
contradict H10.
omega.
rewrite forallb_forall_conv in H5.
destruct H5 as [e [H5 H6] ].
rewrite in_map_iff in H5.
destruct H5 as [q [H5 H7] ].
rewrite in_seq_iff in H7.
subst e.
simpl in H6.
case_eq (n+0).
intro H8.
contradict H7.
omega.
intros r H8.
rewrite H8 in H6.
case_eq (leb q r); intro H9.
rewrite H9 in H6.
simpl in H6.
rewrite <- beq_nat_refl in H6.
discriminate H6.
rewrite leb_iff_conv in H9.
contradict H9.
omega.
rewrite forallb_forall_conv in H4.
destruct H4 as [e [H4 H5] ].
rewrite in_map_iff in H4.
destruct H4 as [q [H4 H6] ].
rewrite in_seq_iff in H6.
subst e.
simpl in H5.
case_eq (n+S s).
intro H7.
contradict H6.
omega.
intros r H7.
rewrite H7 in H5.
case_eq (leb q (S r)); intro H8.
rewrite H8 in H5.
simpl in H5.
do 2 rewrite <- beq_nat_refl in H5.
discriminate H5.
rewrite leb_iff_conv in H8.
contradict H8.
omega.
rewrite leb_iff_conv in H3.
contradict H3.
omega.
rewrite forallb_forall_conv in H1.
destruct H1 as [e [H1 H2] ].
rewrite in_map_iff in H1.
destruct H1 as [q [H1 H3] ].
rewrite in_seq_iff in H3.
subst e.
simpl in H2.

*****
H2 : eq\n (aeq\n (if Nat.leb q (Init.Nat.add n O)\n then ok_arities (S n) O\n else error_proj (S n) O q) (ok_arities (S n) O)) false
H3 : and (le (S O) q) (lt q (Init.Nat.add (S O) n))
q : nat
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n O)
x,g,h : BC
n,s : nat
*****
eq match match (if andb false (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) with | error_rec a a0 a1 => error_rec (ok_arities n s) (error_rec a a0 a1) (if andb false (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | error_comp a l l0 => error_rec (ok_arities n s) (error_comp a l l0) (if andb false (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | error_proj n0 n1 n2 => error_rec (ok_arities n s) (error_proj n0 n1 n2) (if andb false (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | ok_arities h0n h0s => match (if andb false (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) with | error_rec a a0 a1 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_rec a a0 a1) | error_comp a l l0 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_comp a l l0) | error_proj n0 n1 n2 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_proj n0 n1 n2) | ok_arities h1n h1s => if andb (andb (andb match h0n with | O => false | S m' => Nat.eqb n m' end (Nat.eqb h0n h1n)) match h0s with | O => false | S m' => Nat.eqb s m' end) (Nat.eqb h0s h1s) then ok_arities h0n s else error_rec (ok_arities n s) (ok_arities h0n h0s) (ok_arities h1n h1s) end end with | error_rec a a0 a1 => error_comp (error_rec a a0 a1) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s))) | error_comp a l l0 => error_comp (error_comp a l l0) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s))) | error_proj n0 n1 n2 => error_comp (error_proj n0 n1 n2) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s))) | ok_arities hn hs => if andb (andb (andb (Nat.eqb hn (S n)) (Nat.eqb hs s)) (forallb (fun ne : BC => aeq (arities ne) (ok_arities n O)) (map (proj n O) (seq O n)))) (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s))) then ok_arities n s else error_comp (ok_arities hn hs) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s))) end (ok_arities n s)
+++++
case_eq (leb q (n+0)); intro H4.
-----
Lemma arities_rec3 n s x g h (Hx : arities x = ok_arities n 0) (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec3 n s x g h) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh.
simpl.
do 4 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).
intro H2.
contradict H2.
omega.
intros p H2.
case_eq (leb n p); intro H3.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H4 end.
do 4 rewrite <- beq_nat_refl.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H5 end.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H6 end.
simpl.
reflexivity.
rewrite forallb_forall_conv in H6.
destruct H6 as [e [H6 H7] ].
rewrite in_map_iff in H6.
destruct H6 as [q [H6 H8] ].
rewrite in_seq_iff in H8.
subst e.
simpl in H7.
case_eq (n+s).
intro H9.
contradict H8.
omega.
intros r H9.
rewrite H9 in H7.
case_eq (leb q r); intro H10.
rewrite H10 in H7.
simpl in H7.
do 2 rewrite <- beq_nat_refl in H7.
discriminate H7.
rewrite leb_iff_conv in H10.
contradict H10.
omega.
rewrite forallb_forall_conv in H5.
destruct H5 as [e [H5 H6] ].
rewrite in_map_iff in H5.
destruct H5 as [q [H5 H7] ].
rewrite in_seq_iff in H7.
subst e.
simpl in H6.
case_eq (n+0).
intro H8.
contradict H7.
omega.
intros r H8.
rewrite H8 in H6.
case_eq (leb q r); intro H9.
rewrite H9 in H6.
simpl in H6.
rewrite <- beq_nat_refl in H6.
discriminate H6.
rewrite leb_iff_conv in H9.
contradict H9.
omega.
rewrite forallb_forall_conv in H4.
destruct H4 as [e [H4 H5] ].
rewrite in_map_iff in H4.
destruct H4 as [q [H4 H6] ].
rewrite in_seq_iff in H6.
subst e.
simpl in H5.
case_eq (n+S s).
intro H7.
contradict H6.
omega.
intros r H7.
rewrite H7 in H5.
case_eq (leb q (S r)); intro H8.
rewrite H8 in H5.
simpl in H5.
do 2 rewrite <- beq_nat_refl in H5.
discriminate H5.
rewrite leb_iff_conv in H8.
contradict H8.
omega.
rewrite leb_iff_conv in H3.
contradict H3.
omega.
rewrite forallb_forall_conv in H1.
destruct H1 as [e [H1 H2] ].
rewrite in_map_iff in H1.
destruct H1 as [q [H1 H3] ].
rewrite in_seq_iff in H3.
subst e.
simpl in H2.
case_eq (leb q (n+0)); intro H4.

*****
H4 : eq (Nat.leb q (Init.Nat.add n O)) true
H2 : eq\n (aeq\n (if Nat.leb q (Init.Nat.add n O)\n then ok_arities (S n) O\n else error_proj (S n) O q) (ok_arities (S n) O)) false
H3 : and (le (S O) q) (lt q (Init.Nat.add (S O) n))
q : nat
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n O)
x,g,h : BC
n,s : nat
*****
eq match match (if andb false (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) with | error_rec a a0 a1 => error_rec (ok_arities n s) (error_rec a a0 a1) (if andb false (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | error_comp a l l0 => error_rec (ok_arities n s) (error_comp a l l0) (if andb false (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | error_proj n0 n1 n2 => error_rec (ok_arities n s) (error_proj n0 n1 n2) (if andb false (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | ok_arities h0n h0s => match (if andb false (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) with | error_rec a a0 a1 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_rec a a0 a1) | error_comp a l l0 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_comp a l l0) | error_proj n0 n1 n2 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_proj n0 n1 n2) | ok_arities h1n h1s => if andb (andb (andb match h0n with | O => false | S m' => Nat.eqb n m' end (Nat.eqb h0n h1n)) match h0s with | O => false | S m' => Nat.eqb s m' end) (Nat.eqb h0s h1s) then ok_arities h0n s else error_rec (ok_arities n s) (ok_arities h0n h0s) (ok_arities h1n h1s) end end with | error_rec a a0 a1 => error_comp (error_rec a a0 a1) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s))) | error_comp a l l0 => error_comp (error_comp a l l0) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s))) | error_proj n0 n1 n2 => error_comp (error_proj n0 n1 n2) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s))) | ok_arities hn hs => if andb (andb (andb (Nat.eqb hn (S n)) (Nat.eqb hs s)) (forallb (fun ne : BC => aeq (arities ne) (ok_arities n O)) (map (proj n O) (seq O n)))) (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s))) then ok_arities n s else error_comp (ok_arities hn hs) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s))) end (ok_arities n s)
+++++
rewrite H4 in H2.
-----
Lemma arities_rec3 n s x g h (Hx : arities x = ok_arities n 0) (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec3 n s x g h) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh.
simpl.
do 4 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).
intro H2.
contradict H2.
omega.
intros p H2.
case_eq (leb n p); intro H3.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H4 end.
do 4 rewrite <- beq_nat_refl.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H5 end.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H6 end.
simpl.
reflexivity.
rewrite forallb_forall_conv in H6.
destruct H6 as [e [H6 H7] ].
rewrite in_map_iff in H6.
destruct H6 as [q [H6 H8] ].
rewrite in_seq_iff in H8.
subst e.
simpl in H7.
case_eq (n+s).
intro H9.
contradict H8.
omega.
intros r H9.
rewrite H9 in H7.
case_eq (leb q r); intro H10.
rewrite H10 in H7.
simpl in H7.
do 2 rewrite <- beq_nat_refl in H7.
discriminate H7.
rewrite leb_iff_conv in H10.
contradict H10.
omega.
rewrite forallb_forall_conv in H5.
destruct H5 as [e [H5 H6] ].
rewrite in_map_iff in H5.
destruct H5 as [q [H5 H7] ].
rewrite in_seq_iff in H7.
subst e.
simpl in H6.
case_eq (n+0).
intro H8.
contradict H7.
omega.
intros r H8.
rewrite H8 in H6.
case_eq (leb q r); intro H9.
rewrite H9 in H6.
simpl in H6.
rewrite <- beq_nat_refl in H6.
discriminate H6.
rewrite leb_iff_conv in H9.
contradict H9.
omega.
rewrite forallb_forall_conv in H4.
destruct H4 as [e [H4 H5] ].
rewrite in_map_iff in H4.
destruct H4 as [q [H4 H6] ].
rewrite in_seq_iff in H6.
subst e.
simpl in H5.
case_eq (n+S s).
intro H7.
contradict H6.
omega.
intros r H7.
rewrite H7 in H5.
case_eq (leb q (S r)); intro H8.
rewrite H8 in H5.
simpl in H5.
do 2 rewrite <- beq_nat_refl in H5.
discriminate H5.
rewrite leb_iff_conv in H8.
contradict H8.
omega.
rewrite leb_iff_conv in H3.
contradict H3.
omega.
rewrite forallb_forall_conv in H1.
destruct H1 as [e [H1 H2] ].
rewrite in_map_iff in H1.
destruct H1 as [q [H1 H3] ].
rewrite in_seq_iff in H3.
subst e.
simpl in H2.
case_eq (leb q (n+0)); intro H4.
rewrite H4 in H2.

*****
H4 : eq (Nat.leb q (Init.Nat.add n O)) true
H2 : eq (aeq (ok_arities (S n) O) (ok_arities (S n) O)) false
H3 : and (le (S O) q) (lt q (Init.Nat.add (S O) n))
q : nat
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n O)
x,g,h : BC
n,s : nat
*****
eq match match (if andb false (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) with | error_rec a a0 a1 => error_rec (ok_arities n s) (error_rec a a0 a1) (if andb false (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | error_comp a l l0 => error_rec (ok_arities n s) (error_comp a l l0) (if andb false (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | error_proj n0 n1 n2 => error_rec (ok_arities n s) (error_proj n0 n1 n2) (if andb false (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | ok_arities h0n h0s => match (if andb false (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) with | error_rec a a0 a1 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_rec a a0 a1) | error_comp a l l0 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_comp a l l0) | error_proj n0 n1 n2 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_proj n0 n1 n2) | ok_arities h1n h1s => if andb (andb (andb match h0n with | O => false | S m' => Nat.eqb n m' end (Nat.eqb h0n h1n)) match h0s with | O => false | S m' => Nat.eqb s m' end) (Nat.eqb h0s h1s) then ok_arities h0n s else error_rec (ok_arities n s) (ok_arities h0n h0s) (ok_arities h1n h1s) end end with | error_rec a a0 a1 => error_comp (error_rec a a0 a1) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s))) | error_comp a l l0 => error_comp (error_comp a l l0) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s))) | error_proj n0 n1 n2 => error_comp (error_proj n0 n1 n2) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s))) | ok_arities hn hs => if andb (andb (andb (Nat.eqb hn (S n)) (Nat.eqb hs s)) (forallb (fun ne : BC => aeq (arities ne) (ok_arities n O)) (map (proj n O) (seq O n)))) (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s))) then ok_arities n s else error_comp (ok_arities hn hs) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s))) end (ok_arities n s)
+++++
simpl in H2.
-----
Lemma arities_rec3 n s x g h (Hx : arities x = ok_arities n 0) (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec3 n s x g h) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh.
simpl.
do 4 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).
intro H2.
contradict H2.
omega.
intros p H2.
case_eq (leb n p); intro H3.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H4 end.
do 4 rewrite <- beq_nat_refl.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H5 end.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H6 end.
simpl.
reflexivity.
rewrite forallb_forall_conv in H6.
destruct H6 as [e [H6 H7] ].
rewrite in_map_iff in H6.
destruct H6 as [q [H6 H8] ].
rewrite in_seq_iff in H8.
subst e.
simpl in H7.
case_eq (n+s).
intro H9.
contradict H8.
omega.
intros r H9.
rewrite H9 in H7.
case_eq (leb q r); intro H10.
rewrite H10 in H7.
simpl in H7.
do 2 rewrite <- beq_nat_refl in H7.
discriminate H7.
rewrite leb_iff_conv in H10.
contradict H10.
omega.
rewrite forallb_forall_conv in H5.
destruct H5 as [e [H5 H6] ].
rewrite in_map_iff in H5.
destruct H5 as [q [H5 H7] ].
rewrite in_seq_iff in H7.
subst e.
simpl in H6.
case_eq (n+0).
intro H8.
contradict H7.
omega.
intros r H8.
rewrite H8 in H6.
case_eq (leb q r); intro H9.
rewrite H9 in H6.
simpl in H6.
rewrite <- beq_nat_refl in H6.
discriminate H6.
rewrite leb_iff_conv in H9.
contradict H9.
omega.
rewrite forallb_forall_conv in H4.
destruct H4 as [e [H4 H5] ].
rewrite in_map_iff in H4.
destruct H4 as [q [H4 H6] ].
rewrite in_seq_iff in H6.
subst e.
simpl in H5.
case_eq (n+S s).
intro H7.
contradict H6.
omega.
intros r H7.
rewrite H7 in H5.
case_eq (leb q (S r)); intro H8.
rewrite H8 in H5.
simpl in H5.
do 2 rewrite <- beq_nat_refl in H5.
discriminate H5.
rewrite leb_iff_conv in H8.
contradict H8.
omega.
rewrite leb_iff_conv in H3.
contradict H3.
omega.
rewrite forallb_forall_conv in H1.
destruct H1 as [e [H1 H2] ].
rewrite in_map_iff in H1.
destruct H1 as [q [H1 H3] ].
rewrite in_seq_iff in H3.
subst e.
simpl in H2.
case_eq (leb q (n+0)); intro H4.
rewrite H4 in H2.
simpl in H2.

*****
H4 : eq (Nat.leb q (Init.Nat.add n O)) true
H2 : eq (andb (Nat.eqb n n) true) false
H3 : and (le (S O) q) (lt q (Init.Nat.add (S O) n))
q : nat
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n O)
x,g,h : BC
n,s : nat
*****
eq match match (if andb false (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) with | error_rec a a0 a1 => error_rec (ok_arities n s) (error_rec a a0 a1) (if andb false (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | error_comp a l l0 => error_rec (ok_arities n s) (error_comp a l l0) (if andb false (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | error_proj n0 n1 n2 => error_rec (ok_arities n s) (error_proj n0 n1 n2) (if andb false (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | ok_arities h0n h0s => match (if andb false (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) with | error_rec a a0 a1 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_rec a a0 a1) | error_comp a l l0 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_comp a l l0) | error_proj n0 n1 n2 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_proj n0 n1 n2) | ok_arities h1n h1s => if andb (andb (andb match h0n with | O => false | S m' => Nat.eqb n m' end (Nat.eqb h0n h1n)) match h0s with | O => false | S m' => Nat.eqb s m' end) (Nat.eqb h0s h1s) then ok_arities h0n s else error_rec (ok_arities n s) (ok_arities h0n h0s) (ok_arities h1n h1s) end end with | error_rec a a0 a1 => error_comp (error_rec a a0 a1) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s))) | error_comp a l l0 => error_comp (error_comp a l l0) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s))) | error_proj n0 n1 n2 => error_comp (error_proj n0 n1 n2) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s))) | ok_arities hn hs => if andb (andb (andb (Nat.eqb hn (S n)) (Nat.eqb hs s)) (forallb (fun ne : BC => aeq (arities ne) (ok_arities n O)) (map (proj n O) (seq O n)))) (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s))) then ok_arities n s else error_comp (ok_arities hn hs) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s))) end (ok_arities n s)
+++++
rewrite <- beq_nat_refl in H2.
-----
Lemma arities_rec3 n s x g h (Hx : arities x = ok_arities n 0) (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec3 n s x g h) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh.
simpl.
do 4 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).
intro H2.
contradict H2.
omega.
intros p H2.
case_eq (leb n p); intro H3.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H4 end.
do 4 rewrite <- beq_nat_refl.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H5 end.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H6 end.
simpl.
reflexivity.
rewrite forallb_forall_conv in H6.
destruct H6 as [e [H6 H7] ].
rewrite in_map_iff in H6.
destruct H6 as [q [H6 H8] ].
rewrite in_seq_iff in H8.
subst e.
simpl in H7.
case_eq (n+s).
intro H9.
contradict H8.
omega.
intros r H9.
rewrite H9 in H7.
case_eq (leb q r); intro H10.
rewrite H10 in H7.
simpl in H7.
do 2 rewrite <- beq_nat_refl in H7.
discriminate H7.
rewrite leb_iff_conv in H10.
contradict H10.
omega.
rewrite forallb_forall_conv in H5.
destruct H5 as [e [H5 H6] ].
rewrite in_map_iff in H5.
destruct H5 as [q [H5 H7] ].
rewrite in_seq_iff in H7.
subst e.
simpl in H6.
case_eq (n+0).
intro H8.
contradict H7.
omega.
intros r H8.
rewrite H8 in H6.
case_eq (leb q r); intro H9.
rewrite H9 in H6.
simpl in H6.
rewrite <- beq_nat_refl in H6.
discriminate H6.
rewrite leb_iff_conv in H9.
contradict H9.
omega.
rewrite forallb_forall_conv in H4.
destruct H4 as [e [H4 H5] ].
rewrite in_map_iff in H4.
destruct H4 as [q [H4 H6] ].
rewrite in_seq_iff in H6.
subst e.
simpl in H5.
case_eq (n+S s).
intro H7.
contradict H6.
omega.
intros r H7.
rewrite H7 in H5.
case_eq (leb q (S r)); intro H8.
rewrite H8 in H5.
simpl in H5.
do 2 rewrite <- beq_nat_refl in H5.
discriminate H5.
rewrite leb_iff_conv in H8.
contradict H8.
omega.
rewrite leb_iff_conv in H3.
contradict H3.
omega.
rewrite forallb_forall_conv in H1.
destruct H1 as [e [H1 H2] ].
rewrite in_map_iff in H1.
destruct H1 as [q [H1 H3] ].
rewrite in_seq_iff in H3.
subst e.
simpl in H2.
case_eq (leb q (n+0)); intro H4.
rewrite H4 in H2.
simpl in H2.
rewrite <- beq_nat_refl in H2.

*****
H4 : eq (Nat.leb q (Init.Nat.add n O)) true
H2 : eq (andb true true) false
H3 : and (le (S O) q) (lt q (Init.Nat.add (S O) n))
q : nat
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n O)
x,g,h : BC
n,s : nat
*****
eq match match (if andb false (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) with | error_rec a a0 a1 => error_rec (ok_arities n s) (error_rec a a0 a1) (if andb false (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | error_comp a l l0 => error_rec (ok_arities n s) (error_comp a l l0) (if andb false (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | error_proj n0 n1 n2 => error_rec (ok_arities n s) (error_proj n0 n1 n2) (if andb false (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | ok_arities h0n h0s => match (if andb false (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) with | error_rec a a0 a1 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_rec a a0 a1) | error_comp a l l0 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_comp a l l0) | error_proj n0 n1 n2 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_proj n0 n1 n2) | ok_arities h1n h1s => if andb (andb (andb match h0n with | O => false | S m' => Nat.eqb n m' end (Nat.eqb h0n h1n)) match h0s with | O => false | S m' => Nat.eqb s m' end) (Nat.eqb h0s h1s) then ok_arities h0n s else error_rec (ok_arities n s) (ok_arities h0n h0s) (ok_arities h1n h1s) end end with | error_rec a a0 a1 => error_comp (error_rec a a0 a1) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s))) | error_comp a l l0 => error_comp (error_comp a l l0) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s))) | error_proj n0 n1 n2 => error_comp (error_proj n0 n1 n2) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s))) | ok_arities hn hs => if andb (andb (andb (Nat.eqb hn (S n)) (Nat.eqb hs s)) (forallb (fun ne : BC => aeq (arities ne) (ok_arities n O)) (map (proj n O) (seq O n)))) (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s))) then ok_arities n s else error_comp (ok_arities hn hs) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s))) end (ok_arities n s)
+++++
discriminate H2.
-----
Lemma arities_rec3 n s x g h (Hx : arities x = ok_arities n 0) (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec3 n s x g h) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh.
simpl.
do 4 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).
intro H2.
contradict H2.
omega.
intros p H2.
case_eq (leb n p); intro H3.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H4 end.
do 4 rewrite <- beq_nat_refl.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H5 end.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H6 end.
simpl.
reflexivity.
rewrite forallb_forall_conv in H6.
destruct H6 as [e [H6 H7] ].
rewrite in_map_iff in H6.
destruct H6 as [q [H6 H8] ].
rewrite in_seq_iff in H8.
subst e.
simpl in H7.
case_eq (n+s).
intro H9.
contradict H8.
omega.
intros r H9.
rewrite H9 in H7.
case_eq (leb q r); intro H10.
rewrite H10 in H7.
simpl in H7.
do 2 rewrite <- beq_nat_refl in H7.
discriminate H7.
rewrite leb_iff_conv in H10.
contradict H10.
omega.
rewrite forallb_forall_conv in H5.
destruct H5 as [e [H5 H6] ].
rewrite in_map_iff in H5.
destruct H5 as [q [H5 H7] ].
rewrite in_seq_iff in H7.
subst e.
simpl in H6.
case_eq (n+0).
intro H8.
contradict H7.
omega.
intros r H8.
rewrite H8 in H6.
case_eq (leb q r); intro H9.
rewrite H9 in H6.
simpl in H6.
rewrite <- beq_nat_refl in H6.
discriminate H6.
rewrite leb_iff_conv in H9.
contradict H9.
omega.
rewrite forallb_forall_conv in H4.
destruct H4 as [e [H4 H5] ].
rewrite in_map_iff in H4.
destruct H4 as [q [H4 H6] ].
rewrite in_seq_iff in H6.
subst e.
simpl in H5.
case_eq (n+S s).
intro H7.
contradict H6.
omega.
intros r H7.
rewrite H7 in H5.
case_eq (leb q (S r)); intro H8.
rewrite H8 in H5.
simpl in H5.
do 2 rewrite <- beq_nat_refl in H5.
discriminate H5.
rewrite leb_iff_conv in H8.
contradict H8.
omega.
rewrite leb_iff_conv in H3.
contradict H3.
omega.
rewrite forallb_forall_conv in H1.
destruct H1 as [e [H1 H2] ].
rewrite in_map_iff in H1.
destruct H1 as [q [H1 H3] ].
rewrite in_seq_iff in H3.
subst e.
simpl in H2.
case_eq (leb q (n+0)); intro H4.
rewrite H4 in H2.
simpl in H2.
rewrite <- beq_nat_refl in H2.
discriminate H2.

*****
H4 : eq (Nat.leb q (Init.Nat.add n O)) false
H2 : eq\n (aeq\n (if Nat.leb q (Init.Nat.add n O)\n then ok_arities (S n) O\n else error_proj (S n) O q) (ok_arities (S n) O)) false
H3 : and (le (S O) q) (lt q (Init.Nat.add (S O) n))
q : nat
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n O)
x,g,h : BC
n,s : nat
*****
eq match match (if andb false (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) with | error_rec a a0 a1 => error_rec (ok_arities n s) (error_rec a a0 a1) (if andb false (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | error_comp a l l0 => error_rec (ok_arities n s) (error_comp a l l0) (if andb false (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | error_proj n0 n1 n2 => error_rec (ok_arities n s) (error_proj n0 n1 n2) (if andb false (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | ok_arities h0n h0s => match (if andb false (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) with | error_rec a a0 a1 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_rec a a0 a1) | error_comp a l l0 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_comp a l l0) | error_proj n0 n1 n2 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_proj n0 n1 n2) | ok_arities h1n h1s => if andb (andb (andb match h0n with | O => false | S m' => Nat.eqb n m' end (Nat.eqb h0n h1n)) match h0s with | O => false | S m' => Nat.eqb s m' end) (Nat.eqb h0s h1s) then ok_arities h0n s else error_rec (ok_arities n s) (ok_arities h0n h0s) (ok_arities h1n h1s) end end with | error_rec a a0 a1 => error_comp (error_rec a a0 a1) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s))) | error_comp a l l0 => error_comp (error_comp a l l0) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s))) | error_proj n0 n1 n2 => error_comp (error_proj n0 n1 n2) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s))) | ok_arities hn hs => if andb (andb (andb (Nat.eqb hn (S n)) (Nat.eqb hs s)) (forallb (fun ne : BC => aeq (arities ne) (ok_arities n O)) (map (proj n O) (seq O n)))) (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s))) then ok_arities n s else error_comp (ok_arities hn hs) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s))) end (ok_arities n s)
+++++
rewrite leb_iff_conv in H4.
-----
Lemma arities_rec3 n s x g h (Hx : arities x = ok_arities n 0) (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec3 n s x g h) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh.
simpl.
do 4 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).
intro H2.
contradict H2.
omega.
intros p H2.
case_eq (leb n p); intro H3.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H4 end.
do 4 rewrite <- beq_nat_refl.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H5 end.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H6 end.
simpl.
reflexivity.
rewrite forallb_forall_conv in H6.
destruct H6 as [e [H6 H7] ].
rewrite in_map_iff in H6.
destruct H6 as [q [H6 H8] ].
rewrite in_seq_iff in H8.
subst e.
simpl in H7.
case_eq (n+s).
intro H9.
contradict H8.
omega.
intros r H9.
rewrite H9 in H7.
case_eq (leb q r); intro H10.
rewrite H10 in H7.
simpl in H7.
do 2 rewrite <- beq_nat_refl in H7.
discriminate H7.
rewrite leb_iff_conv in H10.
contradict H10.
omega.
rewrite forallb_forall_conv in H5.
destruct H5 as [e [H5 H6] ].
rewrite in_map_iff in H5.
destruct H5 as [q [H5 H7] ].
rewrite in_seq_iff in H7.
subst e.
simpl in H6.
case_eq (n+0).
intro H8.
contradict H7.
omega.
intros r H8.
rewrite H8 in H6.
case_eq (leb q r); intro H9.
rewrite H9 in H6.
simpl in H6.
rewrite <- beq_nat_refl in H6.
discriminate H6.
rewrite leb_iff_conv in H9.
contradict H9.
omega.
rewrite forallb_forall_conv in H4.
destruct H4 as [e [H4 H5] ].
rewrite in_map_iff in H4.
destruct H4 as [q [H4 H6] ].
rewrite in_seq_iff in H6.
subst e.
simpl in H5.
case_eq (n+S s).
intro H7.
contradict H6.
omega.
intros r H7.
rewrite H7 in H5.
case_eq (leb q (S r)); intro H8.
rewrite H8 in H5.
simpl in H5.
do 2 rewrite <- beq_nat_refl in H5.
discriminate H5.
rewrite leb_iff_conv in H8.
contradict H8.
omega.
rewrite leb_iff_conv in H3.
contradict H3.
omega.
rewrite forallb_forall_conv in H1.
destruct H1 as [e [H1 H2] ].
rewrite in_map_iff in H1.
destruct H1 as [q [H1 H3] ].
rewrite in_seq_iff in H3.
subst e.
simpl in H2.
case_eq (leb q (n+0)); intro H4.
rewrite H4 in H2.
simpl in H2.
rewrite <- beq_nat_refl in H2.
discriminate H2.
rewrite leb_iff_conv in H4.

*****
H4 : lt (Init.Nat.add n O) q
H2 : eq\n (aeq\n (if Nat.leb q (Init.Nat.add n O)\n then ok_arities (S n) O\n else error_proj (S n) O q) (ok_arities (S n) O)) false
H3 : and (le (S O) q) (lt q (Init.Nat.add (S O) n))
q : nat
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n O)
x,g,h : BC
n,s : nat
*****
eq match match (if andb false (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) with | error_rec a a0 a1 => error_rec (ok_arities n s) (error_rec a a0 a1) (if andb false (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | error_comp a l l0 => error_rec (ok_arities n s) (error_comp a l l0) (if andb false (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | error_proj n0 n1 n2 => error_rec (ok_arities n s) (error_proj n0 n1 n2) (if andb false (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) | ok_arities h0n h0s => match (if andb false (andb (aeq (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (ok_arities (S n) (S s))) (forallb (fun se : BC => aeq (arities se) (ok_arities (S n) (S s))) (map (proj (S n) (S s)) (seq (S (S n)) s)))) then ok_arities (S n) (S s) else error_comp (ok_arities (S n) (S s)) (cons (ok_arities (S n) O) (map arities (map (proj (S n) O) (seq (S O) n)))) (cons (if match Init.Nat.add n (S s) with | O => false | S m' => Nat.leb n m' end then ok_arities (S n) (S s) else error_proj (S n) (S s) (S n)) (map arities (map (proj (S n) (S s)) (seq (S (S n)) s))))) with | error_rec a a0 a1 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_rec a a0 a1) | error_comp a l l0 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_comp a l l0) | error_proj n0 n1 n2 => error_rec (ok_arities n s) (ok_arities h0n h0s) (error_proj n0 n1 n2) | ok_arities h1n h1s => if andb (andb (andb match h0n with | O => false | S m' => Nat.eqb n m' end (Nat.eqb h0n h1n)) match h0s with | O => false | S m' => Nat.eqb s m' end) (Nat.eqb h0s h1s) then ok_arities h0n s else error_rec (ok_arities n s) (ok_arities h0n h0s) (ok_arities h1n h1s) end end with | error_rec a a0 a1 => error_comp (error_rec a a0 a1) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s))) | error_comp a l l0 => error_comp (error_comp a l l0) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s))) | error_proj n0 n1 n2 => error_comp (error_proj n0 n1 n2) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s))) | ok_arities hn hs => if andb (andb (andb (Nat.eqb hn (S n)) (Nat.eqb hs s)) (forallb (fun ne : BC => aeq (arities ne) (ok_arities n O)) (map (proj n O) (seq O n)))) (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (proj n s) (seq n s))) then ok_arities n s else error_comp (ok_arities hn hs) (cons (ok_arities n O) (map arities (map (proj n O) (seq O n)))) (map arities (map (proj n s) (seq n s))) end (ok_arities n s)
+++++
contradict H4.
-----
Lemma arities_rec3 n s x g h (Hx : arities x = ok_arities n 0) (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec3 n s x g h) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh.
simpl.
do 4 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).
intro H2.
contradict H2.
omega.
intros p H2.
case_eq (leb n p); intro H3.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H4 end.
do 4 rewrite <- beq_nat_refl.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H5 end.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H6 end.
simpl.
reflexivity.
rewrite forallb_forall_conv in H6.
destruct H6 as [e [H6 H7] ].
rewrite in_map_iff in H6.
destruct H6 as [q [H6 H8] ].
rewrite in_seq_iff in H8.
subst e.
simpl in H7.
case_eq (n+s).
intro H9.
contradict H8.
omega.
intros r H9.
rewrite H9 in H7.
case_eq (leb q r); intro H10.
rewrite H10 in H7.
simpl in H7.
do 2 rewrite <- beq_nat_refl in H7.
discriminate H7.
rewrite leb_iff_conv in H10.
contradict H10.
omega.
rewrite forallb_forall_conv in H5.
destruct H5 as [e [H5 H6] ].
rewrite in_map_iff in H5.
destruct H5 as [q [H5 H7] ].
rewrite in_seq_iff in H7.
subst e.
simpl in H6.
case_eq (n+0).
intro H8.
contradict H7.
omega.
intros r H8.
rewrite H8 in H6.
case_eq (leb q r); intro H9.
rewrite H9 in H6.
simpl in H6.
rewrite <- beq_nat_refl in H6.
discriminate H6.
rewrite leb_iff_conv in H9.
contradict H9.
omega.
rewrite forallb_forall_conv in H4.
destruct H4 as [e [H4 H5] ].
rewrite in_map_iff in H4.
destruct H4 as [q [H4 H6] ].
rewrite in_seq_iff in H6.
subst e.
simpl in H5.
case_eq (n+S s).
intro H7.
contradict H6.
omega.
intros r H7.
rewrite H7 in H5.
case_eq (leb q (S r)); intro H8.
rewrite H8 in H5.
simpl in H5.
do 2 rewrite <- beq_nat_refl in H5.
discriminate H5.
rewrite leb_iff_conv in H8.
contradict H8.
omega.
rewrite leb_iff_conv in H3.
contradict H3.
omega.
rewrite forallb_forall_conv in H1.
destruct H1 as [e [H1 H2] ].
rewrite in_map_iff in H1.
destruct H1 as [q [H1 H3] ].
rewrite in_seq_iff in H3.
subst e.
simpl in H2.
case_eq (leb q (n+0)); intro H4.
rewrite H4 in H2.
simpl in H2.
rewrite <- beq_nat_refl in H2.
discriminate H2.
rewrite leb_iff_conv in H4.
contradict H4.

*****
H2 : eq\n (aeq\n (if Nat.leb q (Init.Nat.add n O)\n then ok_arities (S n) O\n else error_proj (S n) O q) (ok_arities (S n) O)) false
H3 : and (le (S O) q) (lt q (Init.Nat.add (S O) n))
q : nat
Hh : eq (arities h) (ok_arities (S n) (S s))
Hg : eq (arities g) (ok_arities n s)
Hx : eq (arities x) (ok_arities n O)
x,g,h : BC
n,s : nat
*****
not (lt (Init.Nat.add n O) q)
+++++
omega.
-----
Lemma arities_rec3 n s x g h (Hx : arities x = ok_arities n 0) (Hg : arities g = ok_arities n s) (Hh : arities h = ok_arities (S n) (S s)) : arities (rec3 n s x g h) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh.
simpl.
do 4 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1 end.
simpl.
case_eq (n + S s).
intro H2.
contradict H2.
omega.
intros p H2.
case_eq (leb n p); intro H3.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H4 end.
do 4 rewrite <- beq_nat_refl.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H5 end.
match goal with | |- context [forallb ?P ?l] => case_eq (forallb P l); intro H6 end.
simpl.
reflexivity.
rewrite forallb_forall_conv in H6.
destruct H6 as [e [H6 H7] ].
rewrite in_map_iff in H6.
destruct H6 as [q [H6 H8] ].
rewrite in_seq_iff in H8.
subst e.
simpl in H7.
case_eq (n+s).
intro H9.
contradict H8.
omega.
intros r H9.
rewrite H9 in H7.
case_eq (leb q r); intro H10.
rewrite H10 in H7.
simpl in H7.
do 2 rewrite <- beq_nat_refl in H7.
discriminate H7.
rewrite leb_iff_conv in H10.
contradict H10.
omega.
rewrite forallb_forall_conv in H5.
destruct H5 as [e [H5 H6] ].
rewrite in_map_iff in H5.
destruct H5 as [q [H5 H7] ].
rewrite in_seq_iff in H7.
subst e.
simpl in H6.
case_eq (n+0).
intro H8.
contradict H7.
omega.
intros r H8.
rewrite H8 in H6.
case_eq (leb q r); intro H9.
rewrite H9 in H6.
simpl in H6.
rewrite <- beq_nat_refl in H6.
discriminate H6.
rewrite leb_iff_conv in H9.
contradict H9.
omega.
rewrite forallb_forall_conv in H4.
destruct H4 as [e [H4 H5] ].
rewrite in_map_iff in H4.
destruct H4 as [q [H4 H6] ].
rewrite in_seq_iff in H6.
subst e.
simpl in H5.
case_eq (n+S s).
intro H7.
contradict H6.
omega.
intros r H7.
rewrite H7 in H5.
case_eq (leb q (S r)); intro H8.
rewrite H8 in H5.
simpl in H5.
do 2 rewrite <- beq_nat_refl in H5.
discriminate H5.
rewrite leb_iff_conv in H8.
contradict H8.
omega.
rewrite leb_iff_conv in H3.
contradict H3.
omega.
rewrite forallb_forall_conv in H1.
destruct H1 as [e [H1 H2] ].
rewrite in_map_iff in H1.
destruct H1 as [q [H1 H3] ].
rewrite in_seq_iff in H3.
subst e.
simpl in H2.
case_eq (leb q (n+0)); intro H4.
rewrite H4 in H2.
simpl in H2.
rewrite <- beq_nat_refl in H2.
discriminate H2.
rewrite leb_iff_conv in H4.
contradict H4.
omega.

*****

*****

+++++
Qed.
-----
Lemma rec3_correct n s x g h vnl vsl :\n  length vnl = n ->\n  length vsl = s ->\n  sem (rec3 n s x g h) vnl vsl =\n  sem_rec1 g h (sem x vnl nil) vnl vsl.
-----
Lemma rec3_correct n s x g h vnl vsl : length vnl = n -> length vsl = s -> sem (rec3 n s x g h) vnl vsl = sem_rec1 g h (sem x vnl nil) vnl vsl.

*****
vnl,vsl : list (list bool)
x,g,h : BC
n,s : nat
*****
forall (_ : eq (length vnl) n) (_ : eq (length vsl) s), eq (sem (rec3 n s x g h) vnl vsl) (sem_rec1 g h (sem x vnl nil) vnl vsl)
+++++
Proof.
-----
Lemma rec3_correct n s x g h vnl vsl : length vnl = n -> length vsl = s -> sem (rec3 n s x g h) vnl vsl = sem_rec1 g h (sem x vnl nil) vnl vsl.
Proof.

*****
vnl,vsl : list (list bool)
x,g,h : BC
n,s : nat
*****
forall (_ : eq (length vnl) n) (_ : eq (length vsl) s), eq (sem (rec3 n s x g h) vnl vsl) (sem_rec1 g h (sem x vnl nil) vnl vsl)
+++++
intros Hn Hs.
-----
Lemma rec3_correct n s x g h vnl vsl : length vnl = n -> length vsl = s -> sem (rec3 n s x g h) vnl vsl = sem_rec1 g h (sem x vnl nil) vnl vsl.
Proof.
intros Hn Hs.

*****
Hs : eq (length vsl) s
Hn : eq (length vnl) n
vnl,vsl : list (list bool)
x,g,h : BC
n,s : nat
*****
eq (sem (rec3 n s x g h) vnl vsl) (sem_rec1 g h (sem x vnl nil) vnl vsl)
+++++
unfold rec3.
-----
Lemma rec3_correct n s x g h vnl vsl : length vnl = n -> length vsl = s -> sem (rec3 n s x g h) vnl vsl = sem_rec1 g h (sem x vnl nil) vnl vsl.
Proof.
intros Hn Hs.
unfold rec3.

*****
Hs : eq (length vsl) s
Hn : eq (length vnl) n
vnl,vsl : list (list bool)
x,g,h : BC
n,s : nat
*****
eq (sem (comp n s (rec1 n s g h) (cons x (map (proj n O) (seq O n))) (map (proj n s) (seq n s))) vnl vsl) (sem_rec1 g h (sem x vnl nil) vnl vsl)
+++++
rewrite sem_comp.
-----
Lemma rec3_correct n s x g h vnl vsl : length vnl = n -> length vsl = s -> sem (rec3 n s x g h) vnl vsl = sem_rec1 g h (sem x vnl nil) vnl vsl.
Proof.
intros Hn Hs.
unfold rec3.
rewrite sem_comp.

*****
Hs : eq (length vsl) s
Hn : eq (length vnl) n
vnl,vsl : list (list bool)
x,g,h : BC
n,s : nat
*****
eq (sem (rec1 n s g h) (map (fun ne : BC => sem ne vnl nil) (cons x (map (proj n O) (seq O n)))) (map (fun se : BC => sem se vnl vsl) (map (proj n s) (seq n s)))) (sem_rec1 g h (sem x vnl nil) vnl vsl)
+++++
rewrite rec1_correct.
-----
Lemma rec3_correct n s x g h vnl vsl : length vnl = n -> length vsl = s -> sem (rec3 n s x g h) vnl vsl = sem_rec1 g h (sem x vnl nil) vnl vsl.
Proof.
intros Hn Hs.
unfold rec3.
rewrite sem_comp.
rewrite rec1_correct.

*****
Hs : eq (length vsl) s
Hn : eq (length vnl) n
vnl,vsl : list (list bool)
x,g,h : BC
n,s : nat
*****
eq (sem_rec1 g h (hd nil (map (fun ne : BC => sem ne vnl nil) (cons x (map (proj n O) (seq O n))))) (tl (map (fun ne : BC => sem ne vnl nil) (cons x (map (proj n O) (seq O n))))) (map (fun se : BC => sem se vnl vsl) (map (proj n s) (seq n s)))) (sem_rec1 g h (sem x vnl nil) vnl vsl)
+++++
simpl.
-----
Lemma rec3_correct n s x g h vnl vsl : length vnl = n -> length vsl = s -> sem (rec3 n s x g h) vnl vsl = sem_rec1 g h (sem x vnl nil) vnl vsl.
Proof.
intros Hn Hs.
unfold rec3.
rewrite sem_comp.
rewrite rec1_correct.
simpl.

*****
Hs : eq (length vsl) s
Hn : eq (length vnl) n
vnl,vsl : list (list bool)
x,g,h : BC
n,s : nat
*****
eq (sem_rec1 g h (sem x vnl nil) (map (fun ne : BC => sem ne vnl nil) (map (proj n O) (seq O n))) (map (fun se : BC => sem se vnl vsl) (map (proj n s) (seq n s)))) (sem_rec1 g h (sem x vnl nil) vnl vsl)
+++++
f_equal.
-----
Lemma rec3_correct n s x g h vnl vsl : length vnl = n -> length vsl = s -> sem (rec3 n s x g h) vnl vsl = sem_rec1 g h (sem x vnl nil) vnl vsl.
Proof.
intros Hn Hs.
unfold rec3.
rewrite sem_comp.
rewrite rec1_correct.
simpl.
f_equal.

*****
Hs : eq (length vsl) s
Hn : eq (length vnl) n
vnl,vsl : list (list bool)
x,g,h : BC
n,s : nat
*****
eq (map (fun ne : BC => sem ne vnl nil) (map (proj n O) (seq O n))) vnl
+++++
rewrite map_proj_seq_normal.
-----
Lemma rec3_correct n s x g h vnl vsl : length vnl = n -> length vsl = s -> sem (rec3 n s x g h) vnl vsl = sem_rec1 g h (sem x vnl nil) vnl vsl.
Proof.
intros Hn Hs.
unfold rec3.
rewrite sem_comp.
rewrite rec1_correct.
simpl.
f_equal.
rewrite map_proj_seq_normal.

*****
Hs : eq (length vsl) s
Hn : eq (length vnl) n
vnl,vsl : list (list bool)
x,g,h : BC
n,s : nat
*****
eq (app (firstn n vnl) (repeat (Init.Nat.sub n (length vnl)) nil)) vnl
+++++
subst n.
-----
Lemma rec3_correct n s x g h vnl vsl : length vnl = n -> length vsl = s -> sem (rec3 n s x g h) vnl vsl = sem_rec1 g h (sem x vnl nil) vnl vsl.
Proof.
intros Hn Hs.
unfold rec3.
rewrite sem_comp.
rewrite rec1_correct.
simpl.
f_equal.
rewrite map_proj_seq_normal.
subst n.

*****
Hs : eq (length vsl) s
vnl,vsl : list (list bool)
x,g,h : BC
s : nat
*****
eq (app (firstn (length vnl) vnl) (repeat (Init.Nat.sub (length vnl) (length vnl)) nil)) vnl
+++++
rewrite minus_diag.
-----
Lemma rec3_correct n s x g h vnl vsl : length vnl = n -> length vsl = s -> sem (rec3 n s x g h) vnl vsl = sem_rec1 g h (sem x vnl nil) vnl vsl.
Proof.
intros Hn Hs.
unfold rec3.
rewrite sem_comp.
rewrite rec1_correct.
simpl.
f_equal.
rewrite map_proj_seq_normal.
subst n.
rewrite minus_diag.

*****
Hs : eq (length vsl) s
vnl,vsl : list (list bool)
x,g,h : BC
s : nat
*****
eq (app (firstn (length vnl) vnl) (repeat O nil)) vnl
+++++
simpl.
-----
Lemma rec3_correct n s x g h vnl vsl : length vnl = n -> length vsl = s -> sem (rec3 n s x g h) vnl vsl = sem_rec1 g h (sem x vnl nil) vnl vsl.
Proof.
intros Hn Hs.
unfold rec3.
rewrite sem_comp.
rewrite rec1_correct.
simpl.
f_equal.
rewrite map_proj_seq_normal.
subst n.
rewrite minus_diag.
simpl.

*****
Hs : eq (length vsl) s
vnl,vsl : list (list bool)
x,g,h : BC
s : nat
*****
eq (app (firstn (length vnl) vnl) nil) vnl
+++++
rewrite app_nil_r.
-----
Lemma rec3_correct n s x g h vnl vsl : length vnl = n -> length vsl = s -> sem (rec3 n s x g h) vnl vsl = sem_rec1 g h (sem x vnl nil) vnl vsl.
Proof.
intros Hn Hs.
unfold rec3.
rewrite sem_comp.
rewrite rec1_correct.
simpl.
f_equal.
rewrite map_proj_seq_normal.
subst n.
rewrite minus_diag.
simpl.
rewrite app_nil_r.

*****
Hs : eq (length vsl) s
vnl,vsl : list (list bool)
x,g,h : BC
s : nat
*****
eq (firstn (length vnl) vnl) vnl
+++++
rewrite <- (app_nil_r vnl) at 2.
-----
Lemma rec3_correct n s x g h vnl vsl : length vnl = n -> length vsl = s -> sem (rec3 n s x g h) vnl vsl = sem_rec1 g h (sem x vnl nil) vnl vsl.
Proof.
intros Hn Hs.
unfold rec3.
rewrite sem_comp.
rewrite rec1_correct.
simpl.
f_equal.
rewrite map_proj_seq_normal.
subst n.
rewrite minus_diag.
simpl.
rewrite app_nil_r.
rewrite <- (app_nil_r vnl) at 2.

*****
Hs : eq (length vsl) s
vnl,vsl : list (list bool)
x,g,h : BC
s : nat
*****
eq (firstn (length vnl) (app vnl nil)) vnl
+++++
apply firstn_app.
-----
Lemma rec3_correct n s x g h vnl vsl : length vnl = n -> length vsl = s -> sem (rec3 n s x g h) vnl vsl = sem_rec1 g h (sem x vnl nil) vnl vsl.
Proof.
intros Hn Hs.
unfold rec3.
rewrite sem_comp.
rewrite rec1_correct.
simpl.
f_equal.

*****
Hs : eq (length vsl) s
Hn : eq (length vnl) n
vnl,vsl : list (list bool)
x,g,h : BC
n,s : nat
*****
eq (map (fun se : BC => sem se vnl vsl) (map (proj n s) (seq n s))) vsl
+++++
rewrite map_proj_seq_safe.
-----
Lemma rec3_correct n s x g h vnl vsl : length vnl = n -> length vsl = s -> sem (rec3 n s x g h) vnl vsl = sem_rec1 g h (sem x vnl nil) vnl vsl.
Proof.
intros Hn Hs.
unfold rec3.
rewrite sem_comp.
rewrite rec1_correct.
simpl.
f_equal.
rewrite map_proj_seq_safe.

*****
Hs : eq (length vsl) s
Hn : eq (length vnl) n
vnl,vsl : list (list bool)
x,g,h : BC
n,s : nat
*****
eq (app (firstn s vsl) (repeat (Init.Nat.sub s (length vsl)) nil)) vsl
+++++
subst s.
-----
Lemma rec3_correct n s x g h vnl vsl : length vnl = n -> length vsl = s -> sem (rec3 n s x g h) vnl vsl = sem_rec1 g h (sem x vnl nil) vnl vsl.
Proof.
intros Hn Hs.
unfold rec3.
rewrite sem_comp.
rewrite rec1_correct.
simpl.
f_equal.
rewrite map_proj_seq_safe.
subst s.

*****
Hn : eq (length vnl) n
vnl,vsl : list (list bool)
x,g,h : BC
n : nat
*****
eq (app (firstn (length vsl) vsl) (repeat (Init.Nat.sub (length vsl) (length vsl)) nil)) vsl
+++++
rewrite minus_diag.
-----
Lemma rec3_correct n s x g h vnl vsl : length vnl = n -> length vsl = s -> sem (rec3 n s x g h) vnl vsl = sem_rec1 g h (sem x vnl nil) vnl vsl.
Proof.
intros Hn Hs.
unfold rec3.
rewrite sem_comp.
rewrite rec1_correct.
simpl.
f_equal.
rewrite map_proj_seq_safe.
subst s.
rewrite minus_diag.

*****
Hn : eq (length vnl) n
vnl,vsl : list (list bool)
x,g,h : BC
n : nat
*****
eq (app (firstn (length vsl) vsl) (repeat O nil)) vsl
+++++
simpl.
-----
Lemma rec3_correct n s x g h vnl vsl : length vnl = n -> length vsl = s -> sem (rec3 n s x g h) vnl vsl = sem_rec1 g h (sem x vnl nil) vnl vsl.
Proof.
intros Hn Hs.
unfold rec3.
rewrite sem_comp.
rewrite rec1_correct.
simpl.
f_equal.
rewrite map_proj_seq_safe.
subst s.
rewrite minus_diag.
simpl.

*****
Hn : eq (length vnl) n
vnl,vsl : list (list bool)
x,g,h : BC
n : nat
*****
eq (app (firstn (length vsl) vsl) nil) vsl
+++++
rewrite app_nil_r.
-----
Lemma rec3_correct n s x g h vnl vsl : length vnl = n -> length vsl = s -> sem (rec3 n s x g h) vnl vsl = sem_rec1 g h (sem x vnl nil) vnl vsl.
Proof.
intros Hn Hs.
unfold rec3.
rewrite sem_comp.
rewrite rec1_correct.
simpl.
f_equal.
rewrite map_proj_seq_safe.
subst s.
rewrite minus_diag.
simpl.
rewrite app_nil_r.

*****
Hn : eq (length vnl) n
vnl,vsl : list (list bool)
x,g,h : BC
n : nat
*****
eq (firstn (length vsl) vsl) vsl
+++++
rewrite <- (app_nil_r vsl) at 2.
-----
Lemma rec3_correct n s x g h vnl vsl : length vnl = n -> length vsl = s -> sem (rec3 n s x g h) vnl vsl = sem_rec1 g h (sem x vnl nil) vnl vsl.
Proof.
intros Hn Hs.
unfold rec3.
rewrite sem_comp.
rewrite rec1_correct.
simpl.
f_equal.
rewrite map_proj_seq_safe.
subst s.
rewrite minus_diag.
simpl.
rewrite app_nil_r.
rewrite <- (app_nil_r vsl) at 2.

*****
Hn : eq (length vnl) n
vnl,vsl : list (list bool)
x,g,h : BC
n : nat
*****
eq (firstn (length vsl) (app vsl nil)) vsl
+++++
apply firstn_app.
-----
Lemma rec3_correct n s x g h vnl vsl : length vnl = n -> length vsl = s -> sem (rec3 n s x g h) vnl vsl = sem_rec1 g h (sem x vnl nil) vnl vsl.
Proof.
intros Hn Hs.
unfold rec3.
rewrite sem_comp.
rewrite rec1_correct.

*****
Hs : eq (length vsl) s
Hn : eq (length vnl) n
vnl,vsl : list (list bool)
x,g,h : BC
n,s : nat
*****
eq (length (map (fun ne : BC => sem ne vnl nil) (cons x (map (proj n O) (seq O n))))) (S n)
+++++
simpl.
-----
Lemma rec3_correct n s x g h vnl vsl : length vnl = n -> length vsl = s -> sem (rec3 n s x g h) vnl vsl = sem_rec1 g h (sem x vnl nil) vnl vsl.
Proof.
intros Hn Hs.
unfold rec3.
rewrite sem_comp.
rewrite rec1_correct.
simpl.

*****
Hs : eq (length vsl) s
Hn : eq (length vnl) n
vnl,vsl : list (list bool)
x,g,h : BC
n,s : nat
*****
eq (S (length (map (fun ne : BC => sem ne vnl nil) (map (proj n O) (seq O n))))) (S n)
+++++
rewrite map_length.
-----
Lemma rec3_correct n s x g h vnl vsl : length vnl = n -> length vsl = s -> sem (rec3 n s x g h) vnl vsl = sem_rec1 g h (sem x vnl nil) vnl vsl.
Proof.
intros Hn Hs.
unfold rec3.
rewrite sem_comp.
rewrite rec1_correct.
simpl.
rewrite map_length.

*****
Hs : eq (length vsl) s
Hn : eq (length vnl) n
vnl,vsl : list (list bool)
x,g,h : BC
n,s : nat
*****
eq (S (length (map (proj n O) (seq O n)))) (S n)
+++++
rewrite map_length.
-----
Lemma rec3_correct n s x g h vnl vsl : length vnl = n -> length vsl = s -> sem (rec3 n s x g h) vnl vsl = sem_rec1 g h (sem x vnl nil) vnl vsl.
Proof.
intros Hn Hs.
unfold rec3.
rewrite sem_comp.
rewrite rec1_correct.
simpl.
rewrite map_length.
rewrite map_length.

*****
Hs : eq (length vsl) s
Hn : eq (length vnl) n
vnl,vsl : list (list bool)
x,g,h : BC
n,s : nat
*****
eq (S (length (seq O n))) (S n)
+++++
rewrite seq_length.
-----
Lemma rec3_correct n s x g h vnl vsl : length vnl = n -> length vsl = s -> sem (rec3 n s x g h) vnl vsl = sem_rec1 g h (sem x vnl nil) vnl vsl.
Proof.
intros Hn Hs.
unfold rec3.
rewrite sem_comp.
rewrite rec1_correct.
simpl.
rewrite map_length.
rewrite map_length.
rewrite seq_length.

*****
Hs : eq (length vsl) s
Hn : eq (length vnl) n
vnl,vsl : list (list bool)
x,g,h : BC
n,s : nat
*****
eq (S n) (S n)
+++++
reflexivity.
-----
Lemma rec3_correct n s x g h vnl vsl : length vnl = n -> length vsl = s -> sem (rec3 n s x g h) vnl vsl = sem_rec1 g h (sem x vnl nil) vnl vsl.
Proof.
intros Hn Hs.
unfold rec3.
rewrite sem_comp.
rewrite rec1_correct.

*****
Hs : eq (length vsl) s
Hn : eq (length vnl) n
vnl,vsl : list (list bool)
x,g,h : BC
n,s : nat
*****
eq (length (map (fun se : BC => sem se vnl vsl) (map (proj n s) (seq n s)))) s
+++++
simpl.
-----
Lemma rec3_correct n s x g h vnl vsl : length vnl = n -> length vsl = s -> sem (rec3 n s x g h) vnl vsl = sem_rec1 g h (sem x vnl nil) vnl vsl.
Proof.
intros Hn Hs.
unfold rec3.
rewrite sem_comp.
rewrite rec1_correct.
simpl.

*****
Hs : eq (length vsl) s
Hn : eq (length vnl) n
vnl,vsl : list (list bool)
x,g,h : BC
n,s : nat
*****
eq (length (map (fun se : BC => sem se vnl vsl) (map (proj n s) (seq n s)))) s
+++++
rewrite map_length.
-----
Lemma rec3_correct n s x g h vnl vsl : length vnl = n -> length vsl = s -> sem (rec3 n s x g h) vnl vsl = sem_rec1 g h (sem x vnl nil) vnl vsl.
Proof.
intros Hn Hs.
unfold rec3.
rewrite sem_comp.
rewrite rec1_correct.
simpl.
rewrite map_length.

*****
Hs : eq (length vsl) s
Hn : eq (length vnl) n
vnl,vsl : list (list bool)
x,g,h : BC
n,s : nat
*****
eq (length (map (proj n s) (seq n s))) s
+++++
rewrite map_length.
-----
Lemma rec3_correct n s x g h vnl vsl : length vnl = n -> length vsl = s -> sem (rec3 n s x g h) vnl vsl = sem_rec1 g h (sem x vnl nil) vnl vsl.
Proof.
intros Hn Hs.
unfold rec3.
rewrite sem_comp.
rewrite rec1_correct.
simpl.
rewrite map_length.
rewrite map_length.

*****
Hs : eq (length vsl) s
Hn : eq (length vnl) n
vnl,vsl : list (list bool)
x,g,h : BC
n,s : nat
*****
eq (length (seq n s)) s
+++++
rewrite seq_length.
-----
Lemma rec3_correct n s x g h vnl vsl : length vnl = n -> length vsl = s -> sem (rec3 n s x g h) vnl vsl = sem_rec1 g h (sem x vnl nil) vnl vsl.
Proof.
intros Hn Hs.
unfold rec3.
rewrite sem_comp.
rewrite rec1_correct.
simpl.
rewrite map_length.
rewrite map_length.
rewrite seq_length.

*****
Hs : eq (length vsl) s
Hn : eq (length vnl) n
vnl,vsl : list (list bool)
x,g,h : BC
n,s : nat
*****
eq s s
+++++
reflexivity.
-----
Lemma rec3_correct n s x g h vnl vsl : length vnl = n -> length vsl = s -> sem (rec3 n s x g h) vnl vsl = sem_rec1 g h (sem x vnl nil) vnl vsl.
Proof.
intros Hn Hs.
unfold rec3.
rewrite sem_comp.
rewrite rec1_correct.

*****

*****

+++++
Qed.
-----
Definition true_e (n s:nat) : BC :=\n  comp n s (comp 0 0 (succ true) nil (zero :: nil)) nil nil.
-----
Lemma true_correct n s l1 l2: \n bs2bool (sem (true_e n s) l1 l2) = true.
-----
Lemma true_correct n s l1 l2: bs2bool (sem (true_e n s) l1 l2) = true.

*****
l1,l2 : list (list bool)
n,s : nat
*****
eq (bs2bool (sem (true_e n s) l1 l2)) true
+++++
Proof.
-----
Lemma true_correct n s l1 l2: bs2bool (sem (true_e n s) l1 l2) = true.
Proof.

*****
l1,l2 : list (list bool)
n,s : nat
*****
eq (bs2bool (sem (true_e n s) l1 l2)) true
+++++
intros.
-----
Lemma true_correct n s l1 l2: bs2bool (sem (true_e n s) l1 l2) = true.
Proof.
intros.

*****
l1,l2 : list (list bool)
n,s : nat
*****
eq (bs2bool (sem (true_e n s) l1 l2)) true
+++++
simpl.
-----
Lemma true_correct n s l1 l2: bs2bool (sem (true_e n s) l1 l2) = true.
Proof.
intros.
simpl.

*****
l1,l2 : list (list bool)
n,s : nat
*****
eq true true
+++++
trivial.
-----
Lemma true_correct n s l1 l2: bs2bool (sem (true_e n s) l1 l2) = true.
Proof.
intros.
simpl.
trivial.

*****

*****

+++++
Qed.
-----
Lemma true_correct_nat n s l1 l2: \n bs2nat (sem (true_e n s) l1 l2) = 1.
-----
Lemma true_correct_nat n s l1 l2: bs2nat (sem (true_e n s) l1 l2) = 1.

*****
l1,l2 : list (list bool)
n,s : nat
*****
eq (bs2nat (sem (true_e n s) l1 l2)) (S O)
+++++
Proof.
-----
Lemma true_correct_nat n s l1 l2: bs2nat (sem (true_e n s) l1 l2) = 1.
Proof.

*****
l1,l2 : list (list bool)
n,s : nat
*****
eq (bs2nat (sem (true_e n s) l1 l2)) (S O)
+++++
intros.
-----
Lemma true_correct_nat n s l1 l2: bs2nat (sem (true_e n s) l1 l2) = 1.
Proof.
intros.

*****
l1,l2 : list (list bool)
n,s : nat
*****
eq (bs2nat (sem (true_e n s) l1 l2)) (S O)
+++++
simpl.
-----
Lemma true_correct_nat n s l1 l2: bs2nat (sem (true_e n s) l1 l2) = 1.
Proof.
intros.
simpl.

*****
l1,l2 : list (list bool)
n,s : nat
*****
eq (S O) (S O)
+++++
trivial.
-----
Lemma true_correct_nat n s l1 l2: bs2nat (sem (true_e n s) l1 l2) = 1.
Proof.
intros.
simpl.
trivial.

*****

*****

+++++
Qed.
-----
Definition false_e (n s:nat) : BC :=\n  comp n s (comp 0 0 (succ false) nil (zero :: nil)) nil nil.
-----
Lemma false_correct n s l1 l2: \n bs2bool (sem (false_e n s) l1 l2) = false.
-----
Lemma false_correct n s l1 l2: bs2bool (sem (false_e n s) l1 l2) = false.

*****
l1,l2 : list (list bool)
n,s : nat
*****
eq (bs2bool (sem (false_e n s) l1 l2)) false
+++++
Proof.
-----
Lemma false_correct n s l1 l2: bs2bool (sem (false_e n s) l1 l2) = false.
Proof.

*****
l1,l2 : list (list bool)
n,s : nat
*****
eq (bs2bool (sem (false_e n s) l1 l2)) false
+++++
intros.
-----
Lemma false_correct n s l1 l2: bs2bool (sem (false_e n s) l1 l2) = false.
Proof.
intros.

*****
l1,l2 : list (list bool)
n,s : nat
*****
eq (bs2bool (sem (false_e n s) l1 l2)) false
+++++
simpl.
-----
Lemma false_correct n s l1 l2: bs2bool (sem (false_e n s) l1 l2) = false.
Proof.
intros.
simpl.

*****
l1,l2 : list (list bool)
n,s : nat
*****
eq false false
+++++
trivial.
-----
Lemma false_correct n s l1 l2: bs2bool (sem (false_e n s) l1 l2) = false.
Proof.
intros.
simpl.
trivial.

*****

*****

+++++
Qed.
-----
Lemma false_correct_nat n s l1 l2: \n bs2nat (sem (false_e n s) l1 l2) = 0.
-----
Lemma false_correct_nat n s l1 l2: bs2nat (sem (false_e n s) l1 l2) = 0.

*****
l1,l2 : list (list bool)
n,s : nat
*****
eq (bs2nat (sem (false_e n s) l1 l2)) O
+++++
Proof.
-----
Lemma false_correct_nat n s l1 l2: bs2nat (sem (false_e n s) l1 l2) = 0.
Proof.

*****
l1,l2 : list (list bool)
n,s : nat
*****
eq (bs2nat (sem (false_e n s) l1 l2)) O
+++++
intros.
-----
Lemma false_correct_nat n s l1 l2: bs2nat (sem (false_e n s) l1 l2) = 0.
Proof.
intros.

*****
l1,l2 : list (list bool)
n,s : nat
*****
eq (bs2nat (sem (false_e n s) l1 l2)) O
+++++
simpl.
-----
Lemma false_correct_nat n s l1 l2: bs2nat (sem (false_e n s) l1 l2) = 0.
Proof.
intros.
simpl.

*****
l1,l2 : list (list bool)
n,s : nat
*****
eq O O
+++++
trivial.
-----
Lemma false_correct_nat n s l1 l2: bs2nat (sem (false_e n s) l1 l2) = 0.
Proof.
intros.
simpl.
trivial.

*****

*****

+++++
Qed.
-----
Definition parity_e : BC := \n  comp 0 1 cond nil [proj 0 1 0; false_e 0 1; true_e 0 1; false_e 0 1].
-----
Lemma parity_correct_even v :\n  bs2bool (sem parity_e nil [v]) = false ->\n  even (bs2nat v).
-----
Lemma parity_correct_even v : bs2bool (sem parity_e nil [v]) = false -> even (bs2nat v).

*****
v : list bool
*****
forall _ : eq (bs2bool (sem parity_e nil (cons v nil))) false, even (bs2nat v)
+++++
Proof.
-----
Lemma parity_correct_even v : bs2bool (sem parity_e nil [v]) = false -> even (bs2nat v).
Proof.

*****
v : list bool
*****
forall _ : eq (bs2bool (sem parity_e nil (cons v nil))) false, even (bs2nat v)
+++++
destruct v.
-----
Lemma parity_correct_even v : bs2bool (sem parity_e nil [v]) = false -> even (bs2nat v).
Proof.
destruct v.

*****

*****
forall _ : eq (bs2bool (sem parity_e nil (cons nil nil))) false, even (bs2nat nil)
+++++
simpl.
-----
Lemma parity_correct_even v : bs2bool (sem parity_e nil [v]) = false -> even (bs2nat v).
Proof.
destruct v.
simpl.

*****

*****
forall _ : eq false false, even O
+++++
intros.
-----
Lemma parity_correct_even v : bs2bool (sem parity_e nil [v]) = false -> even (bs2nat v).
Proof.
destruct v.
simpl.
intros.

*****
H : eq false false
*****
even O
+++++
apply even_O.
-----
Lemma parity_correct_even v : bs2bool (sem parity_e nil [v]) = false -> even (bs2nat v).
Proof.
destruct v.

*****
v : list bool
b : bool
*****
forall _ : eq (bs2bool (sem parity_e nil (cons (cons b v) nil))) false, even (bs2nat (cons b v))
+++++
simpl.
-----
Lemma parity_correct_even v : bs2bool (sem parity_e nil [v]) = false -> even (bs2nat v).
Proof.
destruct v.
simpl.

*****
v : list bool
b : bool
*****
forall _ : eq (bs2bool (if b then cons true nil else cons false nil)) false, even (if b then S (Init.Nat.add (bs2nat v) (Init.Nat.add (bs2nat v) O)) else Init.Nat.add (bs2nat v) (Init.Nat.add (bs2nat v) O))
+++++
intros.
-----
Lemma parity_correct_even v : bs2bool (sem parity_e nil [v]) = false -> even (bs2nat v).
Proof.
destruct v.
simpl.
intros.

*****
H : eq (bs2bool (if b then cons true nil else cons false nil)) false
v : list bool
b : bool
*****
even (if b then S (Init.Nat.add (bs2nat v) (Init.Nat.add (bs2nat v) O)) else Init.Nat.add (bs2nat v) (Init.Nat.add (bs2nat v) O))
+++++
destruct b.
-----
Lemma parity_correct_even v : bs2bool (sem parity_e nil [v]) = false -> even (bs2nat v).
Proof.
destruct v.
simpl.
intros.
destruct b.

*****
H : eq (bs2bool (cons true nil)) false
v : list bool
*****
even (S (Init.Nat.add (bs2nat v) (Init.Nat.add (bs2nat v) O)))
+++++
simpl in *.
-----
Lemma parity_correct_even v : bs2bool (sem parity_e nil [v]) = false -> even (bs2nat v).
Proof.
destruct v.
simpl.
intros.
destruct b.
simpl in *.

*****
H : eq true false
v : list bool
*****
even (S (Init.Nat.add (bs2nat v) (Init.Nat.add (bs2nat v) O)))
+++++
discriminate.
-----
Lemma parity_correct_even v : bs2bool (sem parity_e nil [v]) = false -> even (bs2nat v).
Proof.
destruct v.
simpl.
intros.
destruct b.

*****
H : eq (bs2bool (cons false nil)) false
v : list bool
*****
even (Init.Nat.add (bs2nat v) (Init.Nat.add (bs2nat v) O))
+++++
simpl in *.
-----
Lemma parity_correct_even v : bs2bool (sem parity_e nil [v]) = false -> even (bs2nat v).
Proof.
destruct v.
simpl.
intros.
destruct b.
simpl in *.

*****
H : eq false false
v : list bool
*****
even (Init.Nat.add (bs2nat v) (Init.Nat.add (bs2nat v) O))
+++++
cutrewrite (bs2nat v + (bs2nat v + 0) = 2 * (bs2nat v)).
-----
Lemma parity_correct_even v : bs2bool (sem parity_e nil [v]) = false -> even (bs2nat v).
Proof.
destruct v.
simpl.
intros.
destruct b.
simpl in *.
cutrewrite (bs2nat v + (bs2nat v + 0) = 2 * (bs2nat v)).

*****
H : eq false false
v : list bool
*****
even (Init.Nat.mul (S (S O)) (bs2nat v))
+++++
auto with arith.
-----
Lemma parity_correct_even v : bs2bool (sem parity_e nil [v]) = false -> even (bs2nat v).
Proof.
destruct v.
simpl.
intros.
destruct b.
simpl in *.
cutrewrite (bs2nat v + (bs2nat v + 0) = 2 * (bs2nat v)).

*****
H : eq false false
v : list bool
*****
eq (Init.Nat.add (bs2nat v) (Init.Nat.add (bs2nat v) O)) (Init.Nat.mul (S (S O)) (bs2nat v))
+++++
ring.
-----
Lemma parity_correct_even v : bs2bool (sem parity_e nil [v]) = false -> even (bs2nat v).
Proof.
destruct v.

*****

*****

+++++
Qed.
-----
Lemma parity_correct_odd v :\n  bs2bool (sem parity_e nil [v]) = true ->\n  odd (bs2nat v).
-----
Lemma parity_correct_odd v : bs2bool (sem parity_e nil [v]) = true -> odd (bs2nat v).

*****
v : list bool
*****
forall _ : eq (bs2bool (sem parity_e nil (cons v nil))) true, odd (bs2nat v)
+++++
Proof.
-----
Lemma parity_correct_odd v : bs2bool (sem parity_e nil [v]) = true -> odd (bs2nat v).
Proof.

*****
v : list bool
*****
forall _ : eq (bs2bool (sem parity_e nil (cons v nil))) true, odd (bs2nat v)
+++++
destruct v.
-----
Lemma parity_correct_odd v : bs2bool (sem parity_e nil [v]) = true -> odd (bs2nat v).
Proof.
destruct v.

*****

*****
forall _ : eq (bs2bool (sem parity_e nil (cons nil nil))) true, odd (bs2nat nil)
+++++
simpl.
-----
Lemma parity_correct_odd v : bs2bool (sem parity_e nil [v]) = true -> odd (bs2nat v).
Proof.
destruct v.
simpl.

*****

*****
forall _ : eq false true, odd O
+++++
intros.
-----
Lemma parity_correct_odd v : bs2bool (sem parity_e nil [v]) = true -> odd (bs2nat v).
Proof.
destruct v.
simpl.
intros.

*****
H : eq false true
*****
odd O
+++++
discriminate.
-----
Lemma parity_correct_odd v : bs2bool (sem parity_e nil [v]) = true -> odd (bs2nat v).
Proof.
destruct v.

*****
v : list bool
b : bool
*****
forall _ : eq (bs2bool (sem parity_e nil (cons (cons b v) nil))) true, odd (bs2nat (cons b v))
+++++
simpl.
-----
Lemma parity_correct_odd v : bs2bool (sem parity_e nil [v]) = true -> odd (bs2nat v).
Proof.
destruct v.
simpl.

*****
v : list bool
b : bool
*****
forall _ : eq (bs2bool (if b then cons true nil else cons false nil)) true, odd (if b then S (Init.Nat.add (bs2nat v) (Init.Nat.add (bs2nat v) O)) else Init.Nat.add (bs2nat v) (Init.Nat.add (bs2nat v) O))
+++++
intros.
-----
Lemma parity_correct_odd v : bs2bool (sem parity_e nil [v]) = true -> odd (bs2nat v).
Proof.
destruct v.
simpl.
intros.

*****
H : eq (bs2bool (if b then cons true nil else cons false nil)) true
v : list bool
b : bool
*****
odd (if b then S (Init.Nat.add (bs2nat v) (Init.Nat.add (bs2nat v) O)) else Init.Nat.add (bs2nat v) (Init.Nat.add (bs2nat v) O))
+++++
cutrewrite (bs2nat v + (bs2nat v + 0) = (2 * (bs2nat v))).
-----
Lemma parity_correct_odd v : bs2bool (sem parity_e nil [v]) = true -> odd (bs2nat v).
Proof.
destruct v.
simpl.
intros.
cutrewrite (bs2nat v + (bs2nat v + 0) = (2 * (bs2nat v))).

*****
H : eq (bs2bool (if b then cons true nil else cons false nil)) true
v : list bool
b : bool
*****
odd (if b then S (Init.Nat.mul (S (S O)) (bs2nat v)) else Init.Nat.mul (S (S O)) (bs2nat v))
+++++
destruct b.
-----
Lemma parity_correct_odd v : bs2bool (sem parity_e nil [v]) = true -> odd (bs2nat v).
Proof.
destruct v.
simpl.
intros.
cutrewrite (bs2nat v + (bs2nat v + 0) = (2 * (bs2nat v))).
destruct b.

*****
H : eq (bs2bool (cons true nil)) true
v : list bool
*****
odd (S (Init.Nat.mul (S (S O)) (bs2nat v)))
+++++
apply odd_S.
-----
Lemma parity_correct_odd v : bs2bool (sem parity_e nil [v]) = true -> odd (bs2nat v).
Proof.
destruct v.
simpl.
intros.
cutrewrite (bs2nat v + (bs2nat v + 0) = (2 * (bs2nat v))).
destruct b.
apply odd_S.

*****
H : eq (bs2bool (cons true nil)) true
v : list bool
*****
even (Init.Nat.mul (S (S O)) (bs2nat v))
+++++
auto with arith.
-----
Lemma parity_correct_odd v : bs2bool (sem parity_e nil [v]) = true -> odd (bs2nat v).
Proof.
destruct v.
simpl.
intros.
cutrewrite (bs2nat v + (bs2nat v + 0) = (2 * (bs2nat v))).
destruct b.

*****
H : eq (bs2bool (cons false nil)) true
v : list bool
*****
odd (Init.Nat.mul (S (S O)) (bs2nat v))
+++++
simpl in H.
-----
Lemma parity_correct_odd v : bs2bool (sem parity_e nil [v]) = true -> odd (bs2nat v).
Proof.
destruct v.
simpl.
intros.
cutrewrite (bs2nat v + (bs2nat v + 0) = (2 * (bs2nat v))).
destruct b.
simpl in H.

*****
H : eq false true
v : list bool
*****
odd (Init.Nat.mul (S (S O)) (bs2nat v))
+++++
discriminate.
-----
Lemma parity_correct_odd v : bs2bool (sem parity_e nil [v]) = true -> odd (bs2nat v).
Proof.
destruct v.
simpl.
intros.
cutrewrite (bs2nat v + (bs2nat v + 0) = (2 * (bs2nat v))).

*****
H : eq (bs2bool (if b then cons true nil else cons false nil)) true
v : list bool
b : bool
*****
eq (Init.Nat.add (bs2nat v) (Init.Nat.add (bs2nat v) O)) (Init.Nat.mul (S (S O)) (bs2nat v))
+++++
omega.
-----
Lemma parity_correct_odd v : bs2bool (sem parity_e nil [v]) = true -> odd (bs2nat v).
Proof.
destruct v.

*****

*****

+++++
Qed.
-----
Definition P (x:bs)(y:bs) : bs := skipn (length x) y.
-----
Lemma P_nil : forall x, P x nil = nil.
-----
Lemma P_nil : forall x, P x nil = nil.

*****

*****
forall x : list bool, eq (P x nil) nil
+++++
Proof.
-----
Lemma P_nil : forall x, P x nil = nil.
Proof.

*****

*****
forall x : list bool, eq (P x nil) nil
+++++
intro x.
-----
Lemma P_nil : forall x, P x nil = nil.
Proof.
intro x.

*****
x : list bool
*****
eq (P x nil) nil
+++++
case x.
-----
Lemma P_nil : forall x, P x nil = nil.
Proof.
intro x.
case x.

*****
x : list bool
*****
eq (P nil nil) nil
+++++
trivial.
-----
Lemma P_nil : forall x, P x nil = nil.
Proof.
intro x.
case x.

*****
x : list bool
*****
forall (b : bool) (l : list bool), eq (P (cons b l) nil) nil
+++++
trivial.
-----
Lemma P_nil : forall x, P x nil = nil.
Proof.
intro x.
case x.

*****

*****

+++++
Qed.
-----
Definition P_e : BC :=\n  rec (proj 0 1 0)\n      (comp 1 2 pred nil [proj 1 2 1])\n      (comp 1 2 pred nil [proj 1 2 1]).
-----
Lemma P_correct x y :\n  sem P_e [x] [y] = P x y.
-----
Lemma P_correct x y : sem P_e [x] [y] = P x y.

*****
x,y : list bool
*****
eq (sem P_e (cons x nil) (cons y nil)) (P x y)
+++++
Proof.
-----
Lemma P_correct x y : sem P_e [x] [y] = P x y.
Proof.

*****
x,y : list bool
*****
eq (sem P_e (cons x nil) (cons y nil)) (P x y)
+++++
unfold P.
-----
Lemma P_correct x y : sem P_e [x] [y] = P x y.
Proof.
unfold P.

*****
x,y : list bool
*****
eq (sem P_e (cons x nil) (cons y nil)) (skipn (length x) y)
+++++
induction x.
-----
Lemma P_correct x y : sem P_e [x] [y] = P x y.
Proof.
unfold P.
induction x.

*****
y : list bool
*****
eq (sem P_e (cons nil nil) (cons y nil)) (skipn (length nil) y)
+++++
simpl in *.
-----
Lemma P_correct x y : sem P_e [x] [y] = P x y.
Proof.
unfold P.
induction x.
simpl in *.

*****
y : list bool
*****
eq y y
+++++
trivial.
-----
Lemma P_correct x y : sem P_e [x] [y] = P x y.
Proof.
unfold P.
induction x.

*****
IHx : eq (sem P_e (cons x nil) (cons y nil)) (skipn (length x) y)
x,y : list bool
a : bool
*****
eq (sem P_e (cons (cons a x) nil) (cons y nil)) (skipn (length (cons a x)) y)
+++++
simpl in *.
-----
Lemma P_correct x y : sem P_e [x] [y] = P x y.
Proof.
unfold P.
induction x.
simpl in *.

*****
IHx : eq\n (sem_rec (fun _ vsl : list (list bool) => nth O vsl nil)\n (fun _ vsl : list (list bool) => tl (nth O vsl nil))\n (fun _ vsl : list (list bool) => tl (nth O vsl nil)) x nil\n (cons y nil)) (skipn (length x) y)
x,y : list bool
a : bool
*****
eq (if a then tl (sem_rec (fun _ vsl : list (list bool) => nth O vsl nil) (fun _ vsl : list (list bool) => tl (nth O vsl nil)) (fun _ vsl : list (list bool) => tl (nth O vsl nil)) x nil (cons y nil)) else tl (sem_rec (fun _ vsl : list (list bool) => nth O vsl nil) (fun _ vsl : list (list bool) => tl (nth O vsl nil)) (fun _ vsl : list (list bool) => tl (nth O vsl nil)) x nil (cons y nil))) match y with | nil => nil | cons _ l => skipn (length x) l end
+++++
trivial.
-----
Lemma P_correct x y : sem P_e [x] [y] = P x y.
Proof.
unfold P.
induction x.
simpl in *.
trivial.

*****
IHx : eq\n (sem_rec (fun _ vsl : list (list bool) => nth O vsl nil)\n (fun _ vsl : list (list bool) => tl (nth O vsl nil))\n (fun _ vsl : list (list bool) => tl (nth O vsl nil)) x nil\n (cons y nil)) (skipn (length x) y)
x,y : list bool
a : bool
*****
eq (if a then tl (sem_rec (fun _ vsl : list (list bool) => nth O vsl nil) (fun _ vsl : list (list bool) => tl (nth O vsl nil)) (fun _ vsl : list (list bool) => tl (nth O vsl nil)) x nil (cons y nil)) else tl (sem_rec (fun _ vsl : list (list bool) => nth O vsl nil) (fun _ vsl : list (list bool) => tl (nth O vsl nil)) (fun _ vsl : list (list bool) => tl (nth O vsl nil)) x nil (cons y nil))) match y with | nil => nil | cons _ l => skipn (length x) l end
+++++
intros.
-----
Lemma P_correct x y : sem P_e [x] [y] = P x y.
Proof.
unfold P.
induction x.
simpl in *.
trivial.
intros.

*****
IHx : eq\n (sem_rec (fun _ vsl : list (list bool) => nth O vsl nil)\n (fun _ vsl : list (list bool) => tl (nth O vsl nil))\n (fun _ vsl : list (list bool) => tl (nth O vsl nil)) x nil\n (cons y nil)) (skipn (length x) y)
x,y : list bool
a : bool
*****
eq (if a then tl (sem_rec (fun _ vsl : list (list bool) => nth O vsl nil) (fun _ vsl : list (list bool) => tl (nth O vsl nil)) (fun _ vsl : list (list bool) => tl (nth O vsl nil)) x nil (cons y nil)) else tl (sem_rec (fun _ vsl : list (list bool) => nth O vsl nil) (fun _ vsl : list (list bool) => tl (nth O vsl nil)) (fun _ vsl : list (list bool) => tl (nth O vsl nil)) x nil (cons y nil))) match y with | nil => nil | cons _ l => skipn (length x) l end
+++++
case a.
-----
Lemma P_correct x y : sem P_e [x] [y] = P x y.
Proof.
unfold P.
induction x.
simpl in *.
trivial.
intros.
case a.

*****
IHx : eq\n (sem_rec (fun _ vsl : list (list bool) => nth O vsl nil)\n (fun _ vsl : list (list bool) => tl (nth O vsl nil))\n (fun _ vsl : list (list bool) => tl (nth O vsl nil)) x nil\n (cons y nil)) (skipn (length x) y)
x,y : list bool
a : bool
*****
eq (tl (sem_rec (fun _ vsl : list (list bool) => nth O vsl nil) (fun _ vsl : list (list bool) => tl (nth O vsl nil)) (fun _ vsl : list (list bool) => tl (nth O vsl nil)) x nil (cons y nil))) match y with | nil => nil | cons _ l => skipn (length x) l end
+++++
rewrite IHx.
-----
Lemma P_correct x y : sem P_e [x] [y] = P x y.
Proof.
unfold P.
induction x.
simpl in *.
trivial.
intros.
case a.
rewrite IHx.

*****
IHx : eq\n (sem_rec (fun _ vsl : list (list bool) => nth O vsl nil)\n (fun _ vsl : list (list bool) => tl (nth O vsl nil))\n (fun _ vsl : list (list bool) => tl (nth O vsl nil)) x nil\n (cons y nil)) (skipn (length x) y)
x,y : list bool
a : bool
*****
eq (tl (skipn (length x) y)) match y with | nil => nil | cons _ l => skipn (length x) l end
+++++
clear IHx.
-----
Lemma P_correct x y : sem P_e [x] [y] = P x y.
Proof.
unfold P.
induction x.
simpl in *.
trivial.
intros.
case a.
rewrite IHx.
clear IHx.

*****
x,y : list bool
a : bool
*****
eq (tl (skipn (length x) y)) match y with | nil => nil | cons _ l => skipn (length x) l end
+++++
induction (length x).
-----
Lemma P_correct x y : sem P_e [x] [y] = P x y.
Proof.
unfold P.
induction x.
simpl in *.
trivial.
intros.
case a.
rewrite IHx.
clear IHx.
induction (length x).

*****
x,y : list bool
a : bool
*****
eq (tl (skipn O y)) match y with | nil => nil | cons _ l => skipn O l end
+++++
simpl.
-----
Lemma P_correct x y : sem P_e [x] [y] = P x y.
Proof.
unfold P.
induction x.
simpl in *.
trivial.
intros.
case a.
rewrite IHx.
clear IHx.
induction (length x).
simpl.

*****
x,y : list bool
a : bool
*****
eq (tl y) match y with | nil => nil | cons _ l => l end
+++++
trivial.
-----
Lemma P_correct x y : sem P_e [x] [y] = P x y.
Proof.
unfold P.
induction x.
simpl in *.
trivial.
intros.
case a.
rewrite IHx.
clear IHx.
induction (length x).

*****
IHn : eq (tl (skipn n y))\n match y with\n | nil => nil\n | cons _ l => skipn n l\n end
n : nat
x,y : list bool
a : bool
*****
eq (tl (skipn (S n) y)) match y with | nil => nil | cons _ l => skipn (S n) l end
+++++
simpl.
-----
Lemma P_correct x y : sem P_e [x] [y] = P x y.
Proof.
unfold P.
induction x.
simpl in *.
trivial.
intros.
case a.
rewrite IHx.
clear IHx.
induction (length x).
simpl.

*****
IHn : eq (tl (skipn n y))\n match y with\n | nil => nil\n | cons _ l => skipn n l\n end
n : nat
x,y : list bool
a : bool
*****
eq (tl match y with | nil => nil | cons _ l => skipn n l end) match y with | cons _ (cons _ l0) => skipn n l0 | _ => nil end
+++++
trivial.
-----
Lemma P_correct x y : sem P_e [x] [y] = P x y.
Proof.
unfold P.
induction x.
simpl in *.
trivial.
intros.
case a.
rewrite IHx.
clear IHx.
induction (length x).
simpl.
trivial.

*****
IHn : eq (tl (skipn n y))\n match y with\n | nil => nil\n | cons _ l => skipn n l\n end
n : nat
x,y : list bool
a : bool
*****
eq (tl match y with | nil => nil | cons _ l => skipn n l end) match y with | cons _ (cons _ l0) => skipn n l0 | _ => nil end
+++++
rewrite <- IHn.
-----
Lemma P_correct x y : sem P_e [x] [y] = P x y.
Proof.
unfold P.
induction x.
simpl in *.
trivial.
intros.
case a.
rewrite IHx.
clear IHx.
induction (length x).
simpl.
trivial.
rewrite <- IHn.

*****
IHn : eq (tl (skipn n y))\n match y with\n | nil => nil\n | cons _ l => skipn n l\n end
n : nat
x,y : list bool
a : bool
*****
eq (tl (tl (skipn n y))) match y with | cons _ (cons _ l0) => skipn n l0 | _ => nil end
+++++
clear IHn.
-----
Lemma P_correct x y : sem P_e [x] [y] = P x y.
Proof.
unfold P.
induction x.
simpl in *.
trivial.
intros.
case a.
rewrite IHx.
clear IHx.
induction (length x).
simpl.
trivial.
rewrite <- IHn.
clear IHn.

*****
n : nat
x,y : list bool
a : bool
*****
eq (tl (tl (skipn n y))) match y with | cons _ (cons _ l0) => skipn n l0 | _ => nil end
+++++
revert y.
-----
Lemma P_correct x y : sem P_e [x] [y] = P x y.
Proof.
unfold P.
induction x.
simpl in *.
trivial.
intros.
case a.
rewrite IHx.
clear IHx.
induction (length x).
simpl.
trivial.
rewrite <- IHn.
clear IHn.
revert y.

*****
n : nat
x : list bool
a : bool
*****
forall y : list bool, eq (tl (tl (skipn n y))) match y with | cons _ (cons _ l0) => skipn n l0 | _ => nil end
+++++
induction n.
-----
Lemma P_correct x y : sem P_e [x] [y] = P x y.
Proof.
unfold P.
induction x.
simpl in *.
trivial.
intros.
case a.
rewrite IHx.
clear IHx.
induction (length x).
simpl.
trivial.
rewrite <- IHn.
clear IHn.
revert y.
induction n.

*****
x : list bool
a : bool
*****
forall y : list bool, eq (tl (tl (skipn O y))) match y with | cons _ (cons _ l0) => skipn O l0 | _ => nil end
+++++
simpl.
-----
Lemma P_correct x y : sem P_e [x] [y] = P x y.
Proof.
unfold P.
induction x.
simpl in *.
trivial.
intros.
case a.
rewrite IHx.
clear IHx.
induction (length x).
simpl.
trivial.
rewrite <- IHn.
clear IHn.
revert y.
induction n.
simpl.

*****
x : list bool
a : bool
*****
forall y : list bool, eq (tl (tl y)) match y with | cons _ (cons _ l0) => l0 | _ => nil end
+++++
trivial.
-----
Lemma P_correct x y : sem P_e [x] [y] = P x y.
Proof.
unfold P.
induction x.
simpl in *.
trivial.
intros.
case a.
rewrite IHx.
clear IHx.
induction (length x).
simpl.
trivial.
rewrite <- IHn.
clear IHn.
revert y.
induction n.
simpl.
trivial.

*****
x : list bool
a : bool
*****
forall y : list bool, eq (tl (tl y)) match y with | cons _ (cons _ l0) => l0 | _ => nil end
+++++
intros.
-----
Lemma P_correct x y : sem P_e [x] [y] = P x y.
Proof.
unfold P.
induction x.
simpl in *.
trivial.
intros.
case a.
rewrite IHx.
clear IHx.
induction (length x).
simpl.
trivial.
rewrite <- IHn.
clear IHn.
revert y.
induction n.
simpl.
trivial.
intros.

*****
x,y : list bool
a : bool
*****
eq (tl (tl y)) match y with | cons _ (cons _ l0) => l0 | _ => nil end
+++++
case y.
-----
Lemma P_correct x y : sem P_e [x] [y] = P x y.
Proof.
unfold P.
induction x.
simpl in *.
trivial.
intros.
case a.
rewrite IHx.
clear IHx.
induction (length x).
simpl.
trivial.
rewrite <- IHn.
clear IHn.
revert y.
induction n.
simpl.
trivial.
intros.
case y.

*****
x,y : list bool
a : bool
*****
eq (tl (tl nil)) nil
+++++
simpl.
-----
Lemma P_correct x y : sem P_e [x] [y] = P x y.
Proof.
unfold P.
induction x.
simpl in *.
trivial.
intros.
case a.
rewrite IHx.
clear IHx.
induction (length x).
simpl.
trivial.
rewrite <- IHn.
clear IHn.
revert y.
induction n.
simpl.
trivial.
intros.
case y.
simpl.

*****
x,y : list bool
a : bool
*****
eq nil nil
+++++
trivial.
-----
Lemma P_correct x y : sem P_e [x] [y] = P x y.
Proof.
unfold P.
induction x.
simpl in *.
trivial.
intros.
case a.
rewrite IHx.
clear IHx.
induction (length x).
simpl.
trivial.
rewrite <- IHn.
clear IHn.
revert y.
induction n.
simpl.
trivial.
intros.
case y.

*****
x,y : list bool
a : bool
*****
forall (b : bool) (l : list bool), eq (tl (tl (cons b l))) match l with | nil => nil | cons _ l0 => l0 end
+++++
simpl.
-----
Lemma P_correct x y : sem P_e [x] [y] = P x y.
Proof.
unfold P.
induction x.
simpl in *.
trivial.
intros.
case a.
rewrite IHx.
clear IHx.
induction (length x).
simpl.
trivial.
rewrite <- IHn.
clear IHn.
revert y.
induction n.
simpl.
trivial.
intros.
case y.
simpl.

*****
x,y : list bool
a : bool
*****
forall (_ : bool) (l : list bool), eq (tl l) match l with | nil => nil | cons _ l0 => l0 end
+++++
trivial.
-----
Lemma P_correct x y : sem P_e [x] [y] = P x y.
Proof.
unfold P.
induction x.
simpl in *.
trivial.
intros.
case a.
rewrite IHx.
clear IHx.
induction (length x).
simpl.
trivial.
rewrite <- IHn.
clear IHn.
revert y.
induction n.

*****
IHn : forall y : list bool,\neq (tl (tl (skipn n y)))\n match y with\n | cons _ (cons _ l0) => skipn n l0\n | _ => nil\n end
n : nat
x : list bool
a : bool
*****
forall y : list bool, eq (tl (tl (skipn (S n) y))) match y with | cons _ (cons _ l0) => skipn (S n) l0 | _ => nil end
+++++
simpl.
-----
Lemma P_correct x y : sem P_e [x] [y] = P x y.
Proof.
unfold P.
induction x.
simpl in *.
trivial.
intros.
case a.
rewrite IHx.
clear IHx.
induction (length x).
simpl.
trivial.
rewrite <- IHn.
clear IHn.
revert y.
induction n.
simpl.

*****
IHn : forall y : list bool,\neq (tl (tl (skipn n y)))\n match y with\n | cons _ (cons _ l0) => skipn n l0\n | _ => nil\n end
n : nat
x : list bool
a : bool
*****
forall y : list bool, eq (tl (tl match y with | nil => nil | cons _ l => skipn n l end)) match y with | cons _ (cons _ (cons _ l1)) => skipn n l1 | _ => nil end
+++++
trivial.
-----
Lemma P_correct x y : sem P_e [x] [y] = P x y.
Proof.
unfold P.
induction x.
simpl in *.
trivial.
intros.
case a.
rewrite IHx.
clear IHx.
induction (length x).
simpl.
trivial.
rewrite <- IHn.
clear IHn.
revert y.
induction n.
simpl.
trivial.

*****
IHn : forall y : list bool,\neq (tl (tl (skipn n y)))\n match y with\n | cons _ (cons _ l0) => skipn n l0\n | _ => nil\n end
n : nat
x : list bool
a : bool
*****
forall y : list bool, eq (tl (tl match y with | nil => nil | cons _ l => skipn n l end)) match y with | cons _ (cons _ (cons _ l1)) => skipn n l1 | _ => nil end
+++++
intros.
-----
Lemma P_correct x y : sem P_e [x] [y] = P x y.
Proof.
unfold P.
induction x.
simpl in *.
trivial.
intros.
case a.
rewrite IHx.
clear IHx.
induction (length x).
simpl.
trivial.
rewrite <- IHn.
clear IHn.
revert y.
induction n.
simpl.
trivial.
intros.

*****
y : list bool
IHn : forall y : list bool,\neq (tl (tl (skipn n y)))\n match y with\n | cons _ (cons _ l0) => skipn n l0\n | _ => nil\n end
n : nat
x : list bool
a : bool
*****
eq (tl (tl match y with | nil => nil | cons _ l => skipn n l end)) match y with | cons _ (cons _ (cons _ l1)) => skipn n l1 | _ => nil end
+++++
case y.
-----
Lemma P_correct x y : sem P_e [x] [y] = P x y.
Proof.
unfold P.
induction x.
simpl in *.
trivial.
intros.
case a.
rewrite IHx.
clear IHx.
induction (length x).
simpl.
trivial.
rewrite <- IHn.
clear IHn.
revert y.
induction n.
simpl.
trivial.
intros.
case y.

*****
y : list bool
IHn : forall y : list bool,\neq (tl (tl (skipn n y)))\n match y with\n | cons _ (cons _ l0) => skipn n l0\n | _ => nil\n end
n : nat
x : list bool
a : bool
*****
eq (tl (tl nil)) nil
+++++
simpl.
-----
Lemma P_correct x y : sem P_e [x] [y] = P x y.
Proof.
unfold P.
induction x.
simpl in *.
trivial.
intros.
case a.
rewrite IHx.
clear IHx.
induction (length x).
simpl.
trivial.
rewrite <- IHn.
clear IHn.
revert y.
induction n.
simpl.
trivial.
intros.
case y.
simpl.

*****
y : list bool
IHn : forall y : list bool,\neq (tl (tl (skipn n y)))\n match y with\n | cons _ (cons _ l0) => skipn n l0\n | _ => nil\n end
n : nat
x : list bool
a : bool
*****
eq nil nil
+++++
trivial.
-----
Lemma P_correct x y : sem P_e [x] [y] = P x y.
Proof.
unfold P.
induction x.
simpl in *.
trivial.
intros.
case a.
rewrite IHx.
clear IHx.
induction (length x).
simpl.
trivial.
rewrite <- IHn.
clear IHn.
revert y.
induction n.
simpl.
trivial.
intros.
case y.

*****
y : list bool
IHn : forall y : list bool,\neq (tl (tl (skipn n y)))\n match y with\n | cons _ (cons _ l0) => skipn n l0\n | _ => nil\n end
n : nat
x : list bool
a : bool
*****
forall (_ : bool) (l : list bool), eq (tl (tl (skipn n l))) match l with | cons _ (cons _ l1) => skipn n l1 | _ => nil end
+++++
simpl.
-----
Lemma P_correct x y : sem P_e [x] [y] = P x y.
Proof.
unfold P.
induction x.
simpl in *.
trivial.
intros.
case a.
rewrite IHx.
clear IHx.
induction (length x).
simpl.
trivial.
rewrite <- IHn.
clear IHn.
revert y.
induction n.
simpl.
trivial.
intros.
case y.
simpl.

*****
y : list bool
IHn : forall y : list bool,\neq (tl (tl (skipn n y)))\n match y with\n | cons _ (cons _ l0) => skipn n l0\n | _ => nil\n end
n : nat
x : list bool
a : bool
*****
forall (_ : bool) (l : list bool), eq (tl (tl (skipn n l))) match l with | cons _ (cons _ l1) => skipn n l1 | _ => nil end
+++++
trivial.
-----
Lemma P_correct x y : sem P_e [x] [y] = P x y.
Proof.
unfold P.
induction x.
simpl in *.
trivial.
intros.
case a.

*****
IHx : eq\n (sem_rec (fun _ vsl : list (list bool) => nth O vsl nil)\n (fun _ vsl : list (list bool) => tl (nth O vsl nil))\n (fun _ vsl : list (list bool) => tl (nth O vsl nil)) x nil\n (cons y nil)) (skipn (length x) y)
x,y : list bool
a : bool
*****
eq (tl (sem_rec (fun _ vsl : list (list bool) => nth O vsl nil) (fun _ vsl : list (list bool) => tl (nth O vsl nil)) (fun _ vsl : list (list bool) => tl (nth O vsl nil)) x nil (cons y nil))) match y with | nil => nil | cons _ l => skipn (length x) l end
+++++
rewrite IHx.
-----
Lemma P_correct x y : sem P_e [x] [y] = P x y.
Proof.
unfold P.
induction x.
simpl in *.
trivial.
intros.
case a.
rewrite IHx.

*****
IHx : eq\n (sem_rec (fun _ vsl : list (list bool) => nth O vsl nil)\n (fun _ vsl : list (list bool) => tl (nth O vsl nil))\n (fun _ vsl : list (list bool) => tl (nth O vsl nil)) x nil\n (cons y nil)) (skipn (length x) y)
x,y : list bool
a : bool
*****
eq (tl (skipn (length x) y)) match y with | nil => nil | cons _ l => skipn (length x) l end
+++++
clear IHx.
-----
Lemma P_correct x y : sem P_e [x] [y] = P x y.
Proof.
unfold P.
induction x.
simpl in *.
trivial.
intros.
case a.
rewrite IHx.
clear IHx.

*****
x,y : list bool
a : bool
*****
eq (tl (skipn (length x) y)) match y with | nil => nil | cons _ l => skipn (length x) l end
+++++
induction (length x).
-----
Lemma P_correct x y : sem P_e [x] [y] = P x y.
Proof.
unfold P.
induction x.
simpl in *.
trivial.
intros.
case a.
rewrite IHx.
clear IHx.
induction (length x).

*****
x,y : list bool
a : bool
*****
eq (tl (skipn O y)) match y with | nil => nil | cons _ l => skipn O l end
+++++
simpl.
-----
Lemma P_correct x y : sem P_e [x] [y] = P x y.
Proof.
unfold P.
induction x.
simpl in *.
trivial.
intros.
case a.
rewrite IHx.
clear IHx.
induction (length x).
simpl.

*****
x,y : list bool
a : bool
*****
eq (tl y) match y with | nil => nil | cons _ l => l end
+++++
trivial.
-----
Lemma P_correct x y : sem P_e [x] [y] = P x y.
Proof.
unfold P.
induction x.
simpl in *.
trivial.
intros.
case a.
rewrite IHx.
clear IHx.
induction (length x).

*****
IHn : eq (tl (skipn n y))\n match y with\n | nil => nil\n | cons _ l => skipn n l\n end
n : nat
x,y : list bool
a : bool
*****
eq (tl (skipn (S n) y)) match y with | nil => nil | cons _ l => skipn (S n) l end
+++++
simpl.
-----
Lemma P_correct x y : sem P_e [x] [y] = P x y.
Proof.
unfold P.
induction x.
simpl in *.
trivial.
intros.
case a.
rewrite IHx.
clear IHx.
induction (length x).
simpl.

*****
IHn : eq (tl (skipn n y))\n match y with\n | nil => nil\n | cons _ l => skipn n l\n end
n : nat
x,y : list bool
a : bool
*****
eq (tl match y with | nil => nil | cons _ l => skipn n l end) match y with | cons _ (cons _ l0) => skipn n l0 | _ => nil end
+++++
trivial.
-----
Lemma P_correct x y : sem P_e [x] [y] = P x y.
Proof.
unfold P.
induction x.
simpl in *.
trivial.
intros.
case a.
rewrite IHx.
clear IHx.
induction (length x).
simpl.
trivial.

*****
IHn : eq (tl (skipn n y))\n match y with\n | nil => nil\n | cons _ l => skipn n l\n end
n : nat
x,y : list bool
a : bool
*****
eq (tl match y with | nil => nil | cons _ l => skipn n l end) match y with | cons _ (cons _ l0) => skipn n l0 | _ => nil end
+++++
rewrite <- IHn.
-----
Lemma P_correct x y : sem P_e [x] [y] = P x y.
Proof.
unfold P.
induction x.
simpl in *.
trivial.
intros.
case a.
rewrite IHx.
clear IHx.
induction (length x).
simpl.
trivial.
rewrite <- IHn.

*****
IHn : eq (tl (skipn n y))\n match y with\n | nil => nil\n | cons _ l => skipn n l\n end
n : nat
x,y : list bool
a : bool
*****
eq (tl (tl (skipn n y))) match y with | cons _ (cons _ l0) => skipn n l0 | _ => nil end
+++++
clear IHn.
-----
Lemma P_correct x y : sem P_e [x] [y] = P x y.
Proof.
unfold P.
induction x.
simpl in *.
trivial.
intros.
case a.
rewrite IHx.
clear IHx.
induction (length x).
simpl.
trivial.
rewrite <- IHn.
clear IHn.

*****
n : nat
x,y : list bool
a : bool
*****
eq (tl (tl (skipn n y))) match y with | cons _ (cons _ l0) => skipn n l0 | _ => nil end
+++++
revert y.
-----
Lemma P_correct x y : sem P_e [x] [y] = P x y.
Proof.
unfold P.
induction x.
simpl in *.
trivial.
intros.
case a.
rewrite IHx.
clear IHx.
induction (length x).
simpl.
trivial.
rewrite <- IHn.
clear IHn.
revert y.

*****
n : nat
x : list bool
a : bool
*****
forall y : list bool, eq (tl (tl (skipn n y))) match y with | cons _ (cons _ l0) => skipn n l0 | _ => nil end
+++++
induction n.
-----
Lemma P_correct x y : sem P_e [x] [y] = P x y.
Proof.
unfold P.
induction x.
simpl in *.
trivial.
intros.
case a.
rewrite IHx.
clear IHx.
induction (length x).
simpl.
trivial.
rewrite <- IHn.
clear IHn.
revert y.
induction n.

*****
x : list bool
a : bool
*****
forall y : list bool, eq (tl (tl (skipn O y))) match y with | cons _ (cons _ l0) => skipn O l0 | _ => nil end
+++++
simpl.
-----
Lemma P_correct x y : sem P_e [x] [y] = P x y.
Proof.
unfold P.
induction x.
simpl in *.
trivial.
intros.
case a.
rewrite IHx.
clear IHx.
induction (length x).
simpl.
trivial.
rewrite <- IHn.
clear IHn.
revert y.
induction n.
simpl.

*****
x : list bool
a : bool
*****
forall y : list bool, eq (tl (tl y)) match y with | cons _ (cons _ l0) => l0 | _ => nil end
+++++
trivial.
-----
Lemma P_correct x y : sem P_e [x] [y] = P x y.
Proof.
unfold P.
induction x.
simpl in *.
trivial.
intros.
case a.
rewrite IHx.
clear IHx.
induction (length x).
simpl.
trivial.
rewrite <- IHn.
clear IHn.
revert y.
induction n.
simpl.
trivial.

*****
x : list bool
a : bool
*****
forall y : list bool, eq (tl (tl y)) match y with | cons _ (cons _ l0) => l0 | _ => nil end
+++++
intros.
-----
Lemma P_correct x y : sem P_e [x] [y] = P x y.
Proof.
unfold P.
induction x.
simpl in *.
trivial.
intros.
case a.
rewrite IHx.
clear IHx.
induction (length x).
simpl.
trivial.
rewrite <- IHn.
clear IHn.
revert y.
induction n.
simpl.
trivial.
intros.

*****
x,y : list bool
a : bool
*****
eq (tl (tl y)) match y with | cons _ (cons _ l0) => l0 | _ => nil end
+++++
case y.
-----
Lemma P_correct x y : sem P_e [x] [y] = P x y.
Proof.
unfold P.
induction x.
simpl in *.
trivial.
intros.
case a.
rewrite IHx.
clear IHx.
induction (length x).
simpl.
trivial.
rewrite <- IHn.
clear IHn.
revert y.
induction n.
simpl.
trivial.
intros.
case y.

*****
x,y : list bool
a : bool
*****
eq (tl (tl nil)) nil
+++++
simpl.
-----
Lemma P_correct x y : sem P_e [x] [y] = P x y.
Proof.
unfold P.
induction x.
simpl in *.
trivial.
intros.
case a.
rewrite IHx.
clear IHx.
induction (length x).
simpl.
trivial.
rewrite <- IHn.
clear IHn.
revert y.
induction n.
simpl.
trivial.
intros.
case y.
simpl.

*****
x,y : list bool
a : bool
*****
eq nil nil
+++++
trivial.
-----
Lemma P_correct x y : sem P_e [x] [y] = P x y.
Proof.
unfold P.
induction x.
simpl in *.
trivial.
intros.
case a.
rewrite IHx.
clear IHx.
induction (length x).
simpl.
trivial.
rewrite <- IHn.
clear IHn.
revert y.
induction n.
simpl.
trivial.
intros.
case y.

*****
x,y : list bool
a : bool
*****
forall (b : bool) (l : list bool), eq (tl (tl (cons b l))) match l with | nil => nil | cons _ l0 => l0 end
+++++
simpl.
-----
Lemma P_correct x y : sem P_e [x] [y] = P x y.
Proof.
unfold P.
induction x.
simpl in *.
trivial.
intros.
case a.
rewrite IHx.
clear IHx.
induction (length x).
simpl.
trivial.
rewrite <- IHn.
clear IHn.
revert y.
induction n.
simpl.
trivial.
intros.
case y.
simpl.

*****
x,y : list bool
a : bool
*****
forall (_ : bool) (l : list bool), eq (tl l) match l with | nil => nil | cons _ l0 => l0 end
+++++
trivial.
-----
Lemma P_correct x y : sem P_e [x] [y] = P x y.
Proof.
unfold P.
induction x.
simpl in *.
trivial.
intros.
case a.
rewrite IHx.
clear IHx.
induction (length x).
simpl.
trivial.
rewrite <- IHn.
clear IHn.
revert y.
induction n.

*****
IHn : forall y : list bool,\neq (tl (tl (skipn n y)))\n match y with\n | cons _ (cons _ l0) => skipn n l0\n | _ => nil\n end
n : nat
x : list bool
a : bool
*****
forall y : list bool, eq (tl (tl (skipn (S n) y))) match y with | cons _ (cons _ l0) => skipn (S n) l0 | _ => nil end
+++++
simpl.
-----
Lemma P_correct x y : sem P_e [x] [y] = P x y.
Proof.
unfold P.
induction x.
simpl in *.
trivial.
intros.
case a.
rewrite IHx.
clear IHx.
induction (length x).
simpl.
trivial.
rewrite <- IHn.
clear IHn.
revert y.
induction n.
simpl.

*****
IHn : forall y : list bool,\neq (tl (tl (skipn n y)))\n match y with\n | cons _ (cons _ l0) => skipn n l0\n | _ => nil\n end
n : nat
x : list bool
a : bool
*****
forall y : list bool, eq (tl (tl match y with | nil => nil | cons _ l => skipn n l end)) match y with | cons _ (cons _ (cons _ l1)) => skipn n l1 | _ => nil end
+++++
trivial.
-----
Lemma P_correct x y : sem P_e [x] [y] = P x y.
Proof.
unfold P.
induction x.
simpl in *.
trivial.
intros.
case a.
rewrite IHx.
clear IHx.
induction (length x).
simpl.
trivial.
rewrite <- IHn.
clear IHn.
revert y.
induction n.
simpl.
trivial.

*****
IHn : forall y : list bool,\neq (tl (tl (skipn n y)))\n match y with\n | cons _ (cons _ l0) => skipn n l0\n | _ => nil\n end
n : nat
x : list bool
a : bool
*****
forall y : list bool, eq (tl (tl match y with | nil => nil | cons _ l => skipn n l end)) match y with | cons _ (cons _ (cons _ l1)) => skipn n l1 | _ => nil end
+++++
intros.
-----
Lemma P_correct x y : sem P_e [x] [y] = P x y.
Proof.
unfold P.
induction x.
simpl in *.
trivial.
intros.
case a.
rewrite IHx.
clear IHx.
induction (length x).
simpl.
trivial.
rewrite <- IHn.
clear IHn.
revert y.
induction n.
simpl.
trivial.
intros.

*****
y : list bool
IHn : forall y : list bool,\neq (tl (tl (skipn n y)))\n match y with\n | cons _ (cons _ l0) => skipn n l0\n | _ => nil\n end
n : nat
x : list bool
a : bool
*****
eq (tl (tl match y with | nil => nil | cons _ l => skipn n l end)) match y with | cons _ (cons _ (cons _ l1)) => skipn n l1 | _ => nil end
+++++
case y.
-----
Lemma P_correct x y : sem P_e [x] [y] = P x y.
Proof.
unfold P.
induction x.
simpl in *.
trivial.
intros.
case a.
rewrite IHx.
clear IHx.
induction (length x).
simpl.
trivial.
rewrite <- IHn.
clear IHn.
revert y.
induction n.
simpl.
trivial.
intros.
case y.

*****
y : list bool
IHn : forall y : list bool,\neq (tl (tl (skipn n y)))\n match y with\n | cons _ (cons _ l0) => skipn n l0\n | _ => nil\n end
n : nat
x : list bool
a : bool
*****
eq (tl (tl nil)) nil
+++++
simpl.
-----
Lemma P_correct x y : sem P_e [x] [y] = P x y.
Proof.
unfold P.
induction x.
simpl in *.
trivial.
intros.
case a.
rewrite IHx.
clear IHx.
induction (length x).
simpl.
trivial.
rewrite <- IHn.
clear IHn.
revert y.
induction n.
simpl.
trivial.
intros.
case y.
simpl.

*****
y : list bool
IHn : forall y : list bool,\neq (tl (tl (skipn n y)))\n match y with\n | cons _ (cons _ l0) => skipn n l0\n | _ => nil\n end
n : nat
x : list bool
a : bool
*****
eq nil nil
+++++
trivial.
-----
Lemma P_correct x y : sem P_e [x] [y] = P x y.
Proof.
unfold P.
induction x.
simpl in *.
trivial.
intros.
case a.
rewrite IHx.
clear IHx.
induction (length x).
simpl.
trivial.
rewrite <- IHn.
clear IHn.
revert y.
induction n.
simpl.
trivial.
intros.
case y.

*****
y : list bool
IHn : forall y : list bool,\neq (tl (tl (skipn n y)))\n match y with\n | cons _ (cons _ l0) => skipn n l0\n | _ => nil\n end
n : nat
x : list bool
a : bool
*****
forall (_ : bool) (l : list bool), eq (tl (tl (skipn n l))) match l with | cons _ (cons _ l1) => skipn n l1 | _ => nil end
+++++
simpl.
-----
Lemma P_correct x y : sem P_e [x] [y] = P x y.
Proof.
unfold P.
induction x.
simpl in *.
trivial.
intros.
case a.
rewrite IHx.
clear IHx.
induction (length x).
simpl.
trivial.
rewrite <- IHn.
clear IHn.
revert y.
induction n.
simpl.
trivial.
intros.
case y.
simpl.

*****
y : list bool
IHn : forall y : list bool,\neq (tl (tl (skipn n y)))\n match y with\n | cons _ (cons _ l0) => skipn n l0\n | _ => nil\n end
n : nat
x : list bool
a : bool
*****
forall (_ : bool) (l : list bool), eq (tl (tl (skipn n l))) match l with | cons _ (cons _ l1) => skipn n l1 | _ => nil end
+++++
trivial.
-----
Lemma P_correct x y : sem P_e [x] [y] = P x y.
Proof.
unfold P.
induction x.

*****

*****

+++++
Qed.
-----
Global Opaque P_e.
-----
Definition P'_e := from_11_to_20 P_e.
-----
Definition Y (z w y:bs) : bs :=\n  P (P z w) y.
-----
Definition Y_e : BC :=\n  comp 2 1 P_e \n  [comp 2 0 P'_e [proj 2 0 0; proj 2 0 1] nil] \n  [proj 2 1 2].
-----
Lemma Y_correct z w y :\n  sem Y_e [z;w] [y] = Y z w y.
-----
Lemma Y_correct z w y : sem Y_e [z;w] [y] = Y z w y.

*****
z,w,y : list bool
*****
eq (sem Y_e (cons z (cons w nil)) (cons y nil)) (Y z w y)
+++++
Proof.
-----
Lemma Y_correct z w y : sem Y_e [z;w] [y] = Y z w y.
Proof.

*****
z,w,y : list bool
*****
eq (sem Y_e (cons z (cons w nil)) (cons y nil)) (Y z w y)
+++++
intros.
-----
Lemma Y_correct z w y : sem Y_e [z;w] [y] = Y z w y.
Proof.
intros.

*****
z,w,y : list bool
*****
eq (sem Y_e (cons z (cons w nil)) (cons y nil)) (Y z w y)
+++++
simpl.
-----
Lemma Y_correct z w y : sem Y_e [z;w] [y] = Y z w y.
Proof.
intros.
simpl.

*****
z,w,y : list bool
*****
eq (sem P_e (cons (sem P_e (cons z nil) (cons w nil)) nil) (cons y nil)) (Y z w y)
+++++
rewrite P_correct.
-----
Lemma Y_correct z w y : sem Y_e [z;w] [y] = Y z w y.
Proof.
intros.
simpl.
rewrite P_correct.

*****
z,w,y : list bool
*****
eq (P (sem P_e (cons z nil) (cons w nil)) y) (Y z w y)
+++++
rewrite P_correct.
-----
Lemma Y_correct z w y : sem Y_e [z;w] [y] = Y z w y.
Proof.
intros.
simpl.
rewrite P_correct.
rewrite P_correct.

*****
z,w,y : list bool
*****
eq (P (P z w) y) (Y z w y)
+++++
trivial.
-----
Lemma Y_correct z w y : sem Y_e [z;w] [y] = Y z w y.
Proof.
intros.
simpl.
rewrite P_correct.
rewrite P_correct.
trivial.

*****

*****

+++++
Qed.
-----
Lemma Y_skipn z w y :\n  Y z w y = skipn (length w - length z) y.
-----
Lemma Y_skipn z w y : Y z w y = skipn (length w - length z) y.

*****
z,w,y : list bool
*****
eq (Y z w y) (skipn (Init.Nat.sub (length w) (length z)) y)
+++++
Proof.
-----
Lemma Y_skipn z w y : Y z w y = skipn (length w - length z) y.
Proof.

*****
z,w,y : list bool
*****
eq (Y z w y) (skipn (Init.Nat.sub (length w) (length z)) y)
+++++
unfold Y.
-----
Lemma Y_skipn z w y : Y z w y = skipn (length w - length z) y.
Proof.
unfold Y.

*****
z,w,y : list bool
*****
eq (P (P z w) y) (skipn (Init.Nat.sub (length w) (length z)) y)
+++++
unfold P.
-----
Lemma Y_skipn z w y : Y z w y = skipn (length w - length z) y.
Proof.
unfold Y.
unfold P.

*****
z,w,y : list bool
*****
eq (skipn (length (skipn (length z) w)) y) (skipn (Init.Nat.sub (length w) (length z)) y)
+++++
intros.
-----
Lemma Y_skipn z w y : Y z w y = skipn (length w - length z) y.
Proof.
unfold Y.
unfold P.
intros.

*****
z,w,y : list bool
*****
eq (skipn (length (skipn (length z) w)) y) (skipn (Init.Nat.sub (length w) (length z)) y)
+++++
rewrite length_skipn.
-----
Lemma Y_skipn z w y : Y z w y = skipn (length w - length z) y.
Proof.
unfold Y.
unfold P.
intros.
rewrite length_skipn.

*****
z,w,y : list bool
*****
eq (skipn (Init.Nat.sub (length w) (length z)) y) (skipn (Init.Nat.sub (length w) (length z)) y)
+++++
trivial.
-----
Lemma Y_skipn z w y : Y z w y = skipn (length w - length z) y.
Proof.
unfold Y.
unfold P.
intros.
rewrite length_skipn.
trivial.

*****

*****

+++++
Qed.
-----
Global Opaque Y_e.
-----
Lemma Y_nth x y z :\n hd false (Y x y z) = nth (length y - length x) z false.
-----
Lemma Y_nth x y z : hd false (Y x y z) = nth (length y - length x) z false.

*****
x,y,z : list bool
*****
eq (hd false (Y x y z)) (nth (Init.Nat.sub (length y) (length x)) z false)
+++++
Proof.
-----
Lemma Y_nth x y z : hd false (Y x y z) = nth (length y - length x) z false.
Proof.

*****
x,y,z : list bool
*****
eq (hd false (Y x y z)) (nth (Init.Nat.sub (length y) (length x)) z false)
+++++
unfold Y.
-----
Lemma Y_nth x y z : hd false (Y x y z) = nth (length y - length x) z false.
Proof.
unfold Y.

*****
x,y,z : list bool
*****
eq (hd false (P (P x y) z)) (nth (Init.Nat.sub (length y) (length x)) z false)
+++++
unfold P.
-----
Lemma Y_nth x y z : hd false (Y x y z) = nth (length y - length x) z false.
Proof.
unfold Y.
unfold P.

*****
x,y,z : list bool
*****
eq (hd false (skipn (length (skipn (length x) y)) z)) (nth (Init.Nat.sub (length y) (length x)) z false)
+++++
intros.
-----
Lemma Y_nth x y z : hd false (Y x y z) = nth (length y - length x) z false.
Proof.
unfold Y.
unfold P.
intros.

*****
x,y,z : list bool
*****
eq (hd false (skipn (length (skipn (length x) y)) z)) (nth (Init.Nat.sub (length y) (length x)) z false)
+++++
rewrite length_skipn.
-----
Lemma Y_nth x y z : hd false (Y x y z) = nth (length y - length x) z false.
Proof.
unfold Y.
unfold P.
intros.
rewrite length_skipn.

*****
x,y,z : list bool
*****
eq (hd false (skipn (Init.Nat.sub (length y) (length x)) z)) (nth (Init.Nat.sub (length y) (length x)) z false)
+++++
remember (length y - length x) as n.
-----
Lemma Y_nth x y z : hd false (Y x y z) = nth (length y - length x) z false.
Proof.
unfold Y.
unfold P.
intros.
rewrite length_skipn.
remember (length y - length x) as n.

*****
Heqn : eq n (Init.Nat.sub (length y) (length x))
n : nat
x,y,z : list bool
*****
eq (hd false (skipn n z)) (nth n z false)
+++++
revert x y z Heqn.
-----
Lemma Y_nth x y z : hd false (Y x y z) = nth (length y - length x) z false.
Proof.
unfold Y.
unfold P.
intros.
rewrite length_skipn.
remember (length y - length x) as n.
revert x y z Heqn.

*****
n : nat
*****
forall (x y z : list bool) (_ : eq n (Init.Nat.sub (length y) (length x))), eq (hd false (skipn n z)) (nth n z false)
+++++
induction n.
-----
Lemma Y_nth x y z : hd false (Y x y z) = nth (length y - length x) z false.
Proof.
unfold Y.
unfold P.
intros.
rewrite length_skipn.
remember (length y - length x) as n.
revert x y z Heqn.
induction n.

*****

*****
forall (x y z : list bool) (_ : eq O (Init.Nat.sub (length y) (length x))), eq (hd false (skipn O z)) (nth O z false)
+++++
simpl.
-----
Lemma Y_nth x y z : hd false (Y x y z) = nth (length y - length x) z false.
Proof.
unfold Y.
unfold P.
intros.
rewrite length_skipn.
remember (length y - length x) as n.
revert x y z Heqn.
induction n.
simpl.

*****

*****
forall (x y z : list bool) (_ : eq O (Init.Nat.sub (length y) (length x))), eq (hd false z) (nth O z false)
+++++
intros.
-----
Lemma Y_nth x y z : hd false (Y x y z) = nth (length y - length x) z false.
Proof.
unfold Y.
unfold P.
intros.
rewrite length_skipn.
remember (length y - length x) as n.
revert x y z Heqn.
induction n.
simpl.
intros.

*****
Heqn : eq O (Init.Nat.sub (length y) (length x))
x,y,z : list bool
*****
eq (hd false z) (nth O z false)
+++++
case z.
-----
Lemma Y_nth x y z : hd false (Y x y z) = nth (length y - length x) z false.
Proof.
unfold Y.
unfold P.
intros.
rewrite length_skipn.
remember (length y - length x) as n.
revert x y z Heqn.
induction n.
simpl.
intros.
case z.

*****
Heqn : eq O (Init.Nat.sub (length y) (length x))
x,y,z : list bool
*****
eq (hd false nil) (nth O nil false)
+++++
trivial.
-----
Lemma Y_nth x y z : hd false (Y x y z) = nth (length y - length x) z false.
Proof.
unfold Y.
unfold P.
intros.
rewrite length_skipn.
remember (length y - length x) as n.
revert x y z Heqn.
induction n.
simpl.
intros.
case z.

*****
Heqn : eq O (Init.Nat.sub (length y) (length x))
x,y,z : list bool
*****
forall (b : bool) (l : list bool), eq (hd false (cons b l)) (nth O (cons b l) false)
+++++
trivial.
-----
Lemma Y_nth x y z : hd false (Y x y z) = nth (length y - length x) z false.
Proof.
unfold Y.
unfold P.
intros.
rewrite length_skipn.
remember (length y - length x) as n.
revert x y z Heqn.
induction n.

*****
IHn : forall (x y z : list bool)\n (_ : eq n (Init.Nat.sub (length y) (length x))),\neq (hd false (skipn n z)) (nth n z false)
n : nat
*****
forall (x y z : list bool) (_ : eq (S n) (Init.Nat.sub (length y) (length x))), eq (hd false (skipn (S n) z)) (nth (S n) z false)
+++++
simpl.
-----
Lemma Y_nth x y z : hd false (Y x y z) = nth (length y - length x) z false.
Proof.
unfold Y.
unfold P.
intros.
rewrite length_skipn.
remember (length y - length x) as n.
revert x y z Heqn.
induction n.
simpl.

*****
IHn : forall (x y z : list bool)\n (_ : eq n (Init.Nat.sub (length y) (length x))),\neq (hd false (skipn n z)) (nth n z false)
n : nat
*****
forall (x y z : list bool) (_ : eq (S n) (Init.Nat.sub (length y) (length x))), eq (hd false match z with | nil => nil | cons _ l => skipn n l end) (nth (S n) z false)
+++++
intros.
-----
Lemma Y_nth x y z : hd false (Y x y z) = nth (length y - length x) z false.
Proof.
unfold Y.
unfold P.
intros.
rewrite length_skipn.
remember (length y - length x) as n.
revert x y z Heqn.
induction n.
simpl.
intros.

*****
Heqn : eq (S n) (Init.Nat.sub (length y) (length x))
x,y,z : list bool
IHn : forall (x y z : list bool)\n (_ : eq n (Init.Nat.sub (length y) (length x))),\neq (hd false (skipn n z)) (nth n z false)
n : nat
*****
eq (hd false match z with | nil => nil | cons _ l => skipn n l end) (nth (S n) z false)
+++++
destruct z.
-----
Lemma Y_nth x y z : hd false (Y x y z) = nth (length y - length x) z false.
Proof.
unfold Y.
unfold P.
intros.
rewrite length_skipn.
remember (length y - length x) as n.
revert x y z Heqn.
induction n.
simpl.
intros.
destruct z.

*****
Heqn : eq (S n) (Init.Nat.sub (length y) (length x))
x,y : list bool
IHn : forall (x y z : list bool)\n (_ : eq n (Init.Nat.sub (length y) (length x))),\neq (hd false (skipn n z)) (nth n z false)
n : nat
*****
eq (hd false nil) (nth (S n) nil false)
+++++
simpl in *.
-----
Lemma Y_nth x y z : hd false (Y x y z) = nth (length y - length x) z false.
Proof.
unfold Y.
unfold P.
intros.
rewrite length_skipn.
remember (length y - length x) as n.
revert x y z Heqn.
induction n.
simpl.
intros.
destruct z.
simpl in *.

*****
Heqn : eq (S n) (Init.Nat.sub (length y) (length x))
x,y : list bool
IHn : forall (x y z : list bool)\n (_ : eq n (Init.Nat.sub (length y) (length x))),\neq (hd false (skipn n z)) (nth n z false)
n : nat
*****
eq false false
+++++
trivial.
-----
Lemma Y_nth x y z : hd false (Y x y z) = nth (length y - length x) z false.
Proof.
unfold Y.
unfold P.
intros.
rewrite length_skipn.
remember (length y - length x) as n.
revert x y z Heqn.
induction n.
simpl.
intros.
destruct z.

*****
Heqn : eq (S n) (Init.Nat.sub (length y) (length x))
z : list bool
b : bool
x,y : list bool
IHn : forall (x y z : list bool)\n (_ : eq n (Init.Nat.sub (length y) (length x))),\neq (hd false (skipn n z)) (nth n z false)
n : nat
*****
eq (hd false (skipn n z)) (nth (S n) (cons b z) false)
+++++
simpl in *.
-----
Lemma Y_nth x y z : hd false (Y x y z) = nth (length y - length x) z false.
Proof.
unfold Y.
unfold P.
intros.
rewrite length_skipn.
remember (length y - length x) as n.
revert x y z Heqn.
induction n.
simpl.
intros.
destruct z.
simpl in *.

*****
Heqn : eq (S n) (Init.Nat.sub (length y) (length x))
z : list bool
b : bool
x,y : list bool
IHn : forall (x y z : list bool)\n (_ : eq n (Init.Nat.sub (length y) (length x))),\neq (hd false (skipn n z)) (nth n z false)
n : nat
*****
eq (hd false (skipn n z)) (nth n z false)
+++++
trivial.
-----
Lemma Y_nth x y z : hd false (Y x y z) = nth (length y - length x) z false.
Proof.
unfold Y.
unfold P.
intros.
rewrite length_skipn.
remember (length y - length x) as n.
revert x y z Heqn.
induction n.
simpl.
intros.
destruct z.
simpl in *.
trivial.

*****
Heqn : eq (S n) (Init.Nat.sub (length y) (length x))
z : list bool
b : bool
x,y : list bool
IHn : forall (x y z : list bool)\n (_ : eq n (Init.Nat.sub (length y) (length x))),\neq (hd false (skipn n z)) (nth n z false)
n : nat
*****
eq (hd false (skipn n z)) (nth n z false)
+++++
apply IHn with (x:=true::x) (y:=y).
-----
Lemma Y_nth x y z : hd false (Y x y z) = nth (length y - length x) z false.
Proof.
unfold Y.
unfold P.
intros.
rewrite length_skipn.
remember (length y - length x) as n.
revert x y z Heqn.
induction n.
simpl.
intros.
destruct z.
simpl in *.
trivial.
apply IHn with (x:=true::x) (y:=y).

*****
Heqn : eq (S n) (Init.Nat.sub (length y) (length x))
z : list bool
b : bool
x,y : list bool
IHn : forall (x y z : list bool)\n (_ : eq n (Init.Nat.sub (length y) (length x))),\neq (hd false (skipn n z)) (nth n z false)
n : nat
*****
eq n (Init.Nat.sub (length y) (length (cons true x)))
+++++
simpl.
-----
Lemma Y_nth x y z : hd false (Y x y z) = nth (length y - length x) z false.
Proof.
unfold Y.
unfold P.
intros.
rewrite length_skipn.
remember (length y - length x) as n.
revert x y z Heqn.
induction n.
simpl.
intros.
destruct z.
simpl in *.
trivial.
apply IHn with (x:=true::x) (y:=y).
simpl.

*****
Heqn : eq (S n) (Init.Nat.sub (length y) (length x))
z : list bool
b : bool
x,y : list bool
IHn : forall (x y z : list bool)\n (_ : eq n (Init.Nat.sub (length y) (length x))),\neq (hd false (skipn n z)) (nth n z false)
n : nat
*****
eq n (Init.Nat.sub (length y) (S (length x)))
+++++
omega.
-----
Lemma Y_nth x y z : hd false (Y x y z) = nth (length y - length x) z false.
Proof.
unfold Y.
unfold P.
intros.
rewrite length_skipn.
remember (length y - length x) as n.
revert x y z Heqn.
induction n.

*****

*****

+++++
Qed.
-----
Lemma Y_nil x y : Y x y nil = nil.
-----
Lemma Y_nil x y : Y x y nil = nil.

*****
x,y : list bool
*****
eq (Y x y nil) nil
+++++
Proof.
-----
Lemma Y_nil x y : Y x y nil = nil.
Proof.

*****
x,y : list bool
*****
eq (Y x y nil) nil
+++++
intros.
-----
Lemma Y_nil x y : Y x y nil = nil.
Proof.
intros.

*****
x,y : list bool
*****
eq (Y x y nil) nil
+++++
unfold Y.
-----
Lemma Y_nil x y : Y x y nil = nil.
Proof.
intros.
unfold Y.

*****
x,y : list bool
*****
eq (P (P x y) nil) nil
+++++
unfold P.
-----
Lemma Y_nil x y : Y x y nil = nil.
Proof.
intros.
unfold Y.
unfold P.

*****
x,y : list bool
*****
eq (skipn (length (skipn (length x) y)) nil) nil
+++++
case (length (skipn (length x) y)).
-----
Lemma Y_nil x y : Y x y nil = nil.
Proof.
intros.
unfold Y.
unfold P.
case (length (skipn (length x) y)).

*****
x,y : list bool
*****
eq (skipn O nil) nil
+++++
simpl.
-----
Lemma Y_nil x y : Y x y nil = nil.
Proof.
intros.
unfold Y.
unfold P.
case (length (skipn (length x) y)).
simpl.

*****
x,y : list bool
*****
eq nil nil
+++++
trivial.
-----
Lemma Y_nil x y : Y x y nil = nil.
Proof.
intros.
unfold Y.
unfold P.
case (length (skipn (length x) y)).

*****
x,y : list bool
*****
forall n : nat, eq (skipn (S n) nil) nil
+++++
simpl.
-----
Lemma Y_nil x y : Y x y nil = nil.
Proof.
intros.
unfold Y.
unfold P.
case (length (skipn (length x) y)).
simpl.

*****
x,y : list bool
*****
forall _ : nat, eq nil nil
+++++
trivial.
-----
Lemma Y_nil x y : Y x y nil = nil.
Proof.
intros.
unfold Y.
unfold P.
case (length (skipn (length x) y)).

*****

*****

+++++
Qed.
-----
Lemma Y_refl x y : Y x x y = y.
-----
Lemma Y_refl x y : Y x x y = y.

*****
x,y : list bool
*****
eq (Y x x y) y
+++++
Proof.
-----
Lemma Y_refl x y : Y x x y = y.
Proof.

*****
x,y : list bool
*****
eq (Y x x y) y
+++++
intros.
-----
Lemma Y_refl x y : Y x x y = y.
Proof.
intros.

*****
x,y : list bool
*****
eq (Y x x y) y
+++++
unfold Y.
-----
Lemma Y_refl x y : Y x x y = y.
Proof.
intros.
unfold Y.

*****
x,y : list bool
*****
eq (P (P x x) y) y
+++++
unfold P.
-----
Lemma Y_refl x y : Y x x y = y.
Proof.
intros.
unfold Y.
unfold P.

*****
x,y : list bool
*****
eq (skipn (length (skipn (length x) x)) y) y
+++++
rewrite length_skipn.
-----
Lemma Y_refl x y : Y x x y = y.
Proof.
intros.
unfold Y.
unfold P.
rewrite length_skipn.

*****
x,y : list bool
*****
eq (skipn (Init.Nat.sub (length x) (length x)) y) y
+++++
rewrite minus_diag.
-----
Lemma Y_refl x y : Y x x y = y.
Proof.
intros.
unfold Y.
unfold P.
rewrite length_skipn.
rewrite minus_diag.

*****
x,y : list bool
*****
eq (skipn O y) y
+++++
simpl.
-----
Lemma Y_refl x y : Y x x y = y.
Proof.
intros.
unfold Y.
unfold P.
rewrite length_skipn.
rewrite minus_diag.
simpl.

*****
x,y : list bool
*****
eq y y
+++++
trivial.
-----
Lemma Y_refl x y : Y x x y = y.
Proof.
intros.
unfold Y.
unfold P.
rewrite length_skipn.
rewrite minus_diag.
simpl.
trivial.

*****

*****

+++++
Qed.
-----
Lemma Y_nil_length x y z :\n  Y x y z = nil ->\n  length z <= length y - length x.
-----
Lemma Y_nil_length x y z : Y x y z = nil -> length z <= length y - length x.

*****
x,y,z : list bool
*****
forall _ : eq (Y x y z) nil, le (length z) (Init.Nat.sub (length y) (length x))
+++++
Proof.
-----
Lemma Y_nil_length x y z : Y x y z = nil -> length z <= length y - length x.
Proof.

*****
x,y,z : list bool
*****
forall _ : eq (Y x y z) nil, le (length z) (Init.Nat.sub (length y) (length x))
+++++
intros.
-----
Lemma Y_nil_length x y z : Y x y z = nil -> length z <= length y - length x.
Proof.
intros.

*****
H : eq (Y x y z) nil
x,y,z : list bool
*****
le (length z) (Init.Nat.sub (length y) (length x))
+++++
unfold Y in H.
-----
Lemma Y_nil_length x y z : Y x y z = nil -> length z <= length y - length x.
Proof.
intros.
unfold Y in H.

*****
H : eq (P (P x y) z) nil
x,y,z : list bool
*****
le (length z) (Init.Nat.sub (length y) (length x))
+++++
unfold P in H.
-----
Lemma Y_nil_length x y z : Y x y z = nil -> length z <= length y - length x.
Proof.
intros.
unfold Y in H.
unfold P in H.

*****
H : eq (skipn (length (skipn (length x) y)) z) nil
x,y,z : list bool
*****
le (length z) (Init.Nat.sub (length y) (length x))
+++++
rewrite length_skipn in H.
-----
Lemma Y_nil_length x y z : Y x y z = nil -> length z <= length y - length x.
Proof.
intros.
unfold Y in H.
unfold P in H.
rewrite length_skipn in H.

*****
H : eq (skipn (Init.Nat.sub (length y) (length x)) z) nil
x,y,z : list bool
*****
le (length z) (Init.Nat.sub (length y) (length x))
+++++
apply skipn_nil_length.
-----
Lemma Y_nil_length x y z : Y x y z = nil -> length z <= length y - length x.
Proof.
intros.
unfold Y in H.
unfold P in H.
rewrite length_skipn in H.
apply skipn_nil_length.

*****
H : eq (skipn (Init.Nat.sub (length y) (length x)) z) nil
x,y,z : list bool
*****
eq (skipn (Init.Nat.sub (length y) (length x)) z) nil
+++++
trivial.
-----
Lemma Y_nil_length x y z : Y x y z = nil -> length z <= length y - length x.
Proof.
intros.
unfold Y in H.
unfold P in H.
rewrite length_skipn in H.
apply skipn_nil_length.
trivial.

*****

*****

+++++
Qed.
-----
Lemma Y_hd_same x y z i1 i2: Y (i1 :: x) y z = Y (i2 :: x) y z.
-----
Lemma Y_hd_same x y z i1 i2: Y (i1 :: x) y z = Y (i2 :: x) y z.

*****
i1,i2 : bool
x,y,z : list bool
*****
eq (Y (cons i1 x) y z) (Y (cons i2 x) y z)
+++++
Proof.
-----
Lemma Y_hd_same x y z i1 i2: Y (i1 :: x) y z = Y (i2 :: x) y z.
Proof.

*****
i1,i2 : bool
x,y,z : list bool
*****
eq (Y (cons i1 x) y z) (Y (cons i2 x) y z)
+++++
intros.
-----
Lemma Y_hd_same x y z i1 i2: Y (i1 :: x) y z = Y (i2 :: x) y z.
Proof.
intros.

*****
i1,i2 : bool
x,y,z : list bool
*****
eq (Y (cons i1 x) y z) (Y (cons i2 x) y z)
+++++
unfold Y.
-----
Lemma Y_hd_same x y z i1 i2: Y (i1 :: x) y z = Y (i2 :: x) y z.
Proof.
intros.
unfold Y.

*****
i1,i2 : bool
x,y,z : list bool
*****
eq (P (P (cons i1 x) y) z) (P (P (cons i2 x) y) z)
+++++
unfold P.
-----
Lemma Y_hd_same x y z i1 i2: Y (i1 :: x) y z = Y (i2 :: x) y z.
Proof.
intros.
unfold Y.
unfold P.

*****
i1,i2 : bool
x,y,z : list bool
*****
eq (skipn (length (skipn (length (cons i1 x)) y)) z) (skipn (length (skipn (length (cons i2 x)) y)) z)
+++++
simpl.
-----
Lemma Y_hd_same x y z i1 i2: Y (i1 :: x) y z = Y (i2 :: x) y z.
Proof.
intros.
unfold Y.
unfold P.
simpl.

*****
i1,i2 : bool
x,y,z : list bool
*****
eq (skipn (length match y with | nil => nil | cons _ l => skipn (length x) l end) z) (skipn (length match y with | nil => nil | cons _ l => skipn (length x) l end) z)
+++++
trivial.
-----
Lemma Y_hd_same x y z i1 i2: Y (i1 :: x) y z = Y (i2 :: x) y z.
Proof.
intros.
unfold Y.
unfold P.
simpl.
trivial.

*****

*****

+++++
Qed.
-----
Lemma Y_le : forall u w y , length u <= length w ->\n   length (Y u w y) <= length (Y w w y).
-----
Lemma Y_le : forall u w y , length u <= length w -> length (Y u w y) <= length (Y w w y).

*****

*****
forall (u w y : list bool) (_ : le (length u) (length w)), le (length (Y u w y)) (length (Y w w y))
+++++
intros.
-----
Lemma Y_le : forall u w y , length u <= length w -> length (Y u w y) <= length (Y w w y).
intros.

*****
H : le (length u) (length w)
u,w,y : list bool
*****
le (length (Y u w y)) (length (Y w w y))
+++++
repeat rewrite Y_skipn.
-----
Lemma Y_le : forall u w y , length u <= length w -> length (Y u w y) <= length (Y w w y).
intros.
repeat rewrite Y_skipn.

*****
H : le (length u) (length w)
u,w,y : list bool
*****
le (length (skipn (Init.Nat.sub (length w) (length u)) y)) (length (skipn (Init.Nat.sub (length w) (length w)) y))
+++++
repeat rewrite skipn_length.
-----
Lemma Y_le : forall u w y , length u <= length w -> length (Y u w y) <= length (Y w w y).
intros.
repeat rewrite Y_skipn.
repeat rewrite skipn_length.

*****
H : le (length u) (length w)
u,w,y : list bool
*****
le (Init.Nat.sub (length y) (Init.Nat.sub (length w) (length u))) (Init.Nat.sub (length y) (Init.Nat.sub (length w) (length w)))
+++++
omega.
-----
Lemma Y_le : forall u w y , length u <= length w -> length (Y u w y) <= length (Y w w y).
intros.
repeat rewrite Y_skipn.
repeat rewrite skipn_length.
omega.

*****

*****

+++++
Qed.
-----
Definition I_e : BC :=\n  comp 2 1 parity_e nil \n  [comp 2 1 Y_e \n    [comp 2 0 (succ true) nil [proj 2 0 0]; proj 2 0 1] \n    [proj 2 1 2] ].
-----
Lemma I_correct (z w y : bs) :\n  sem I_e [z;w] [y] = [nth (length w - S (length z)) y false].
-----
Lemma I_correct (z w y : bs) : sem I_e [z;w] [y] = [nth (length w - S (length z)) y false].

*****
z,w,y : list bool
*****
eq (sem I_e (cons z (cons w nil)) (cons y nil)) (cons (nth (Init.Nat.sub (length w) (S (length z))) y false) nil)
+++++
Proof.
-----
Lemma I_correct (z w y : bs) : sem I_e [z;w] [y] = [nth (length w - S (length z)) y false].
Proof.

*****
z,w,y : list bool
*****
eq (sem I_e (cons z (cons w nil)) (cons y nil)) (cons (nth (Init.Nat.sub (length w) (S (length z))) y false) nil)
+++++
simpl.
-----
Lemma I_correct (z w y : bs) : sem I_e [z;w] [y] = [nth (length w - S (length z)) y false].
Proof.
simpl.

*****
z,w,y : list bool
*****
eq match sem Y_e (cons (cons true z) (cons w nil)) (cons y nil) with | cons true _ => cons true nil | _ => cons false nil end (cons (nth (Init.Nat.sub (length w) (S (length z))) y false) nil)
+++++
intros.
-----
Lemma I_correct (z w y : bs) : sem I_e [z;w] [y] = [nth (length w - S (length z)) y false].
Proof.
simpl.
intros.

*****
z,w,y : list bool
*****
eq match sem Y_e (cons (cons true z) (cons w nil)) (cons y nil) with | cons true _ => cons true nil | _ => cons false nil end (cons (nth (Init.Nat.sub (length w) (S (length z))) y false) nil)
+++++
rewrite Y_correct.
-----
Lemma I_correct (z w y : bs) : sem I_e [z;w] [y] = [nth (length w - S (length z)) y false].
Proof.
simpl.
intros.
rewrite Y_correct.

*****
z,w,y : list bool
*****
eq match Y (cons true z) w y with | cons true _ => cons true nil | _ => cons false nil end (cons (nth (Init.Nat.sub (length w) (S (length z))) y false) nil)
+++++
case_eq (Y (true :: z) w y).
-----
Lemma I_correct (z w y : bs) : sem I_e [z;w] [y] = [nth (length w - S (length z)) y false].
Proof.
simpl.
intros.
rewrite Y_correct.
case_eq (Y (true :: z) w y).

*****
z,w,y : list bool
*****
forall _ : eq (Y (cons true z) w y) nil, eq (cons false nil) (cons (nth (Init.Nat.sub (length w) (S (length z))) y false) nil)
+++++
intros.
-----
Lemma I_correct (z w y : bs) : sem I_e [z;w] [y] = [nth (length w - S (length z)) y false].
Proof.
simpl.
intros.
rewrite Y_correct.
case_eq (Y (true :: z) w y).
intros.

*****
H : eq (Y (cons true z) w y) nil
z,w,y : list bool
*****
eq (cons false nil) (cons (nth (Init.Nat.sub (length w) (S (length z))) y false) nil)
+++++
apply Y_nil_length in H.
-----
Lemma I_correct (z w y : bs) : sem I_e [z;w] [y] = [nth (length w - S (length z)) y false].
Proof.
simpl.
intros.
rewrite Y_correct.
case_eq (Y (true :: z) w y).
intros.
apply Y_nil_length in H.

*****
H : le (length y) (Init.Nat.sub (length w) (length (cons true z)))
z,w,y : list bool
*****
eq (cons false nil) (cons (nth (Init.Nat.sub (length w) (S (length z))) y false) nil)
+++++
simpl in H.
-----
Lemma I_correct (z w y : bs) : sem I_e [z;w] [y] = [nth (length w - S (length z)) y false].
Proof.
simpl.
intros.
rewrite Y_correct.
case_eq (Y (true :: z) w y).
intros.
apply Y_nil_length in H.
simpl in H.

*****
H : le (length y) (Init.Nat.sub (length w) (S (length z)))
z,w,y : list bool
*****
eq (cons false nil) (cons (nth (Init.Nat.sub (length w) (S (length z))) y false) nil)
+++++
rewrite nth_overflow.
-----
Lemma I_correct (z w y : bs) : sem I_e [z;w] [y] = [nth (length w - S (length z)) y false].
Proof.
simpl.
intros.
rewrite Y_correct.
case_eq (Y (true :: z) w y).
intros.
apply Y_nil_length in H.
simpl in H.
rewrite nth_overflow.

*****
H : le (length y) (Init.Nat.sub (length w) (S (length z)))
z,w,y : list bool
*****
eq (cons false nil) (cons false nil)
+++++
trivial.
-----
Lemma I_correct (z w y : bs) : sem I_e [z;w] [y] = [nth (length w - S (length z)) y false].
Proof.
simpl.
intros.
rewrite Y_correct.
case_eq (Y (true :: z) w y).
intros.
apply Y_nil_length in H.
simpl in H.
rewrite nth_overflow.

*****
H : le (length y) (Init.Nat.sub (length w) (S (length z)))
z,w,y : list bool
*****
le (length y) (Init.Nat.sub (length w) (S (length z)))
+++++
trivial.
-----
Lemma I_correct (z w y : bs) : sem I_e [z;w] [y] = [nth (length w - S (length z)) y false].
Proof.
simpl.
intros.
rewrite Y_correct.
case_eq (Y (true :: z) w y).

*****
z,w,y : list bool
*****
forall (b : bool) (l : list bool) (_ : eq (Y (cons true z) w y) (cons b l)), eq (if b then cons true nil else cons false nil) (cons (nth (Init.Nat.sub (length w) (S (length z))) y false) nil)
+++++
intros.
-----
Lemma I_correct (z w y : bs) : sem I_e [z;w] [y] = [nth (length w - S (length z)) y false].
Proof.
simpl.
intros.
rewrite Y_correct.
case_eq (Y (true :: z) w y).
intros.

*****
H : eq (Y (cons true z) w y) (cons b l)
l : list bool
b : bool
z,w,y : list bool
*****
eq (if b then cons true nil else cons false nil) (cons (nth (Init.Nat.sub (length w) (S (length z))) y false) nil)
+++++
replace (S (length z)) with (length (true :: z)).
-----
Lemma I_correct (z w y : bs) : sem I_e [z;w] [y] = [nth (length w - S (length z)) y false].
Proof.
simpl.
intros.
rewrite Y_correct.
case_eq (Y (true :: z) w y).
intros.
replace (S (length z)) with (length (true :: z)).

*****
H : eq (Y (cons true z) w y) (cons b l)
l : list bool
b : bool
z,w,y : list bool
*****
eq (if b then cons true nil else cons false nil) (cons (nth (Init.Nat.sub (length w) (length (cons true z))) y false) nil)
+++++
rewrite <- Y_nth.
-----
Lemma I_correct (z w y : bs) : sem I_e [z;w] [y] = [nth (length w - S (length z)) y false].
Proof.
simpl.
intros.
rewrite Y_correct.
case_eq (Y (true :: z) w y).
intros.
replace (S (length z)) with (length (true :: z)).
rewrite <- Y_nth.

*****
H : eq (Y (cons true z) w y) (cons b l)
l : list bool
b : bool
z,w,y : list bool
*****
eq (if b then cons true nil else cons false nil) (cons (hd false (Y (cons true z) w y)) nil)
+++++
rewrite H.
-----
Lemma I_correct (z w y : bs) : sem I_e [z;w] [y] = [nth (length w - S (length z)) y false].
Proof.
simpl.
intros.
rewrite Y_correct.
case_eq (Y (true :: z) w y).
intros.
replace (S (length z)) with (length (true :: z)).
rewrite <- Y_nth.
rewrite H.

*****
H : eq (Y (cons true z) w y) (cons b l)
l : list bool
b : bool
z,w,y : list bool
*****
eq (if b then cons true nil else cons false nil) (cons (hd false (cons b l)) nil)
+++++
simpl.
-----
Lemma I_correct (z w y : bs) : sem I_e [z;w] [y] = [nth (length w - S (length z)) y false].
Proof.
simpl.
intros.
rewrite Y_correct.
case_eq (Y (true :: z) w y).
intros.
replace (S (length z)) with (length (true :: z)).
rewrite <- Y_nth.
rewrite H.
simpl.

*****
H : eq (Y (cons true z) w y) (cons b l)
l : list bool
b : bool
z,w,y : list bool
*****
eq (if b then cons true nil else cons false nil) (cons b nil)
+++++
trivial.
-----
Lemma I_correct (z w y : bs) : sem I_e [z;w] [y] = [nth (length w - S (length z)) y false].
Proof.
simpl.
intros.
rewrite Y_correct.
case_eq (Y (true :: z) w y).
intros.
replace (S (length z)) with (length (true :: z)).
rewrite <- Y_nth.
rewrite H.
simpl.
trivial.

*****
H : eq (Y (cons true z) w y) (cons b l)
l : list bool
b : bool
z,w,y : list bool
*****
eq (if b then cons true nil else cons false nil) (cons b nil)
+++++
destruct b.
-----
Lemma I_correct (z w y : bs) : sem I_e [z;w] [y] = [nth (length w - S (length z)) y false].
Proof.
simpl.
intros.
rewrite Y_correct.
case_eq (Y (true :: z) w y).
intros.
replace (S (length z)) with (length (true :: z)).
rewrite <- Y_nth.
rewrite H.
simpl.
trivial.
destruct b.

*****
H : eq (Y (cons true z) w y) (cons true l)
z,w,y,l : list bool
*****
eq (cons true nil) (cons true nil)
+++++
trivial.
-----
Lemma I_correct (z w y : bs) : sem I_e [z;w] [y] = [nth (length w - S (length z)) y false].
Proof.
simpl.
intros.
rewrite Y_correct.
case_eq (Y (true :: z) w y).
intros.
replace (S (length z)) with (length (true :: z)).
rewrite <- Y_nth.
rewrite H.
simpl.
trivial.
destruct b.

*****
H : eq (Y (cons true z) w y) (cons false l)
z,w,y,l : list bool
*****
eq (cons false nil) (cons false nil)
+++++
trivial.
-----
Lemma I_correct (z w y : bs) : sem I_e [z;w] [y] = [nth (length w - S (length z)) y false].
Proof.
simpl.
intros.
rewrite Y_correct.
case_eq (Y (true :: z) w y).
intros.
replace (S (length z)) with (length (true :: z)).

*****
H : eq (Y (cons true z) w y) (cons b l)
l : list bool
b : bool
z,w,y : list bool
*****
eq (length (cons true z)) (S (length z))
+++++
simpl.
-----
Lemma I_correct (z w y : bs) : sem I_e [z;w] [y] = [nth (length w - S (length z)) y false].
Proof.
simpl.
intros.
rewrite Y_correct.
case_eq (Y (true :: z) w y).
intros.
replace (S (length z)) with (length (true :: z)).
simpl.

*****
H : eq (Y (cons true z) w y) (cons b l)
l : list bool
b : bool
z,w,y : list bool
*****
eq (S (length z)) (S (length z))
+++++
trivial.
-----
Lemma I_correct (z w y : bs) : sem I_e [z;w] [y] = [nth (length w - S (length z)) y false].
Proof.
simpl.
intros.
rewrite Y_correct.
case_eq (Y (true :: z) w y).

*****

*****

+++++
Qed.
-----
Lemma I_Y_property j z w y :\n  length z < length w ->\n  length w - S (length z) < length y ->  \n  Y (j :: z) w y = [nth (length w - S (length z)) y false] ++ Y z w y.
-----
Lemma I_Y_property j z w y : length z < length w -> length w - S (length z) < length y -> Y (j :: z) w y = [nth (length w - S (length z)) y false] ++ Y z w y.

*****
z,w,y : list bool
j : bool
*****
forall (_ : lt (length z) (length w)) (_ : lt (Init.Nat.sub (length w) (S (length z))) (length y)), eq (Y (cons j z) w y) (app (cons (nth (Init.Nat.sub (length w) (S (length z))) y false) nil) (Y z w y))
+++++
Proof.
-----
Lemma I_Y_property j z w y : length z < length w -> length w - S (length z) < length y -> Y (j :: z) w y = [nth (length w - S (length z)) y false] ++ Y z w y.
Proof.

*****
z,w,y : list bool
j : bool
*****
forall (_ : lt (length z) (length w)) (_ : lt (Init.Nat.sub (length w) (S (length z))) (length y)), eq (Y (cons j z) w y) (app (cons (nth (Init.Nat.sub (length w) (S (length z))) y false) nil) (Y z w y))
+++++
intros.
-----
Lemma I_Y_property j z w y : length z < length w -> length w - S (length z) < length y -> Y (j :: z) w y = [nth (length w - S (length z)) y false] ++ Y z w y.
Proof.
intros.

*****
H0 : lt (Init.Nat.sub (length w) (S (length z))) (length y)
H : lt (length z) (length w)
z,w,y : list bool
j : bool
*****
eq (Y (cons j z) w y) (app (cons (nth (Init.Nat.sub (length w) (S (length z))) y false) nil) (Y z w y))
+++++
simpl.
-----
Lemma I_Y_property j z w y : length z < length w -> length w - S (length z) < length y -> Y (j :: z) w y = [nth (length w - S (length z)) y false] ++ Y z w y.
Proof.
intros.
simpl.

*****
H0 : lt (Init.Nat.sub (length w) (S (length z))) (length y)
H : lt (length z) (length w)
z,w,y : list bool
j : bool
*****
eq (Y (cons j z) w y) (cons (nth (Init.Nat.sub (length w) (S (length z))) y false) (Y z w y))
+++++
rewrite Y_skipn.
-----
Lemma I_Y_property j z w y : length z < length w -> length w - S (length z) < length y -> Y (j :: z) w y = [nth (length w - S (length z)) y false] ++ Y z w y.
Proof.
intros.
simpl.
rewrite Y_skipn.

*****
H0 : lt (Init.Nat.sub (length w) (S (length z))) (length y)
H : lt (length z) (length w)
z,w,y : list bool
j : bool
*****
eq (skipn (Init.Nat.sub (length w) (length (cons j z))) y) (cons (nth (Init.Nat.sub (length w) (S (length z))) y false) (Y z w y))
+++++
rewrite Y_skipn.
-----
Lemma I_Y_property j z w y : length z < length w -> length w - S (length z) < length y -> Y (j :: z) w y = [nth (length w - S (length z)) y false] ++ Y z w y.
Proof.
intros.
simpl.
rewrite Y_skipn.
rewrite Y_skipn.

*****
H0 : lt (Init.Nat.sub (length w) (S (length z))) (length y)
H : lt (length z) (length w)
z,w,y : list bool
j : bool
*****
eq (skipn (Init.Nat.sub (length w) (length (cons j z))) y) (cons (nth (Init.Nat.sub (length w) (S (length z))) y false) (skipn (Init.Nat.sub (length w) (length z)) y))
+++++
simpl.
-----
Lemma I_Y_property j z w y : length z < length w -> length w - S (length z) < length y -> Y (j :: z) w y = [nth (length w - S (length z)) y false] ++ Y z w y.
Proof.
intros.
simpl.
rewrite Y_skipn.
rewrite Y_skipn.
simpl.

*****
H0 : lt (Init.Nat.sub (length w) (S (length z))) (length y)
H : lt (length z) (length w)
z,w,y : list bool
j : bool
*****
eq (skipn (Init.Nat.sub (length w) (S (length z))) y) (cons (nth (Init.Nat.sub (length w) (S (length z))) y false) (skipn (Init.Nat.sub (length w) (length z)) y))
+++++
rewrite skipn_hd with (d := false).
-----
Lemma I_Y_property j z w y : length z < length w -> length w - S (length z) < length y -> Y (j :: z) w y = [nth (length w - S (length z)) y false] ++ Y z w y.
Proof.
intros.
simpl.
rewrite Y_skipn.
rewrite Y_skipn.
simpl.
rewrite skipn_hd with (d := false).

*****
H0 : lt (Init.Nat.sub (length w) (S (length z))) (length y)
H : lt (length z) (length w)
z,w,y : list bool
j : bool
*****
eq (cons (nth (Init.Nat.sub (length w) (S (length z))) y false) (skipn (S (Init.Nat.sub (length w) (S (length z)))) y)) (cons (nth (Init.Nat.sub (length w) (S (length z))) y false) (skipn (Init.Nat.sub (length w) (length z)) y))
+++++
f_equal.
-----
Lemma I_Y_property j z w y : length z < length w -> length w - S (length z) < length y -> Y (j :: z) w y = [nth (length w - S (length z)) y false] ++ Y z w y.
Proof.
intros.
simpl.
rewrite Y_skipn.
rewrite Y_skipn.
simpl.
rewrite skipn_hd with (d := false).
f_equal.

*****
H0 : lt (Init.Nat.sub (length w) (S (length z))) (length y)
H : lt (length z) (length w)
z,w,y : list bool
j : bool
*****
eq (skipn (S (Init.Nat.sub (length w) (S (length z)))) y) (skipn (Init.Nat.sub (length w) (length z)) y)
+++++
f_equal.
-----
Lemma I_Y_property j z w y : length z < length w -> length w - S (length z) < length y -> Y (j :: z) w y = [nth (length w - S (length z)) y false] ++ Y z w y.
Proof.
intros.
simpl.
rewrite Y_skipn.
rewrite Y_skipn.
simpl.
rewrite skipn_hd with (d := false).
f_equal.
f_equal.

*****
H0 : lt (Init.Nat.sub (length w) (S (length z))) (length y)
H : lt (length z) (length w)
z,w,y : list bool
j : bool
*****
eq (S (Init.Nat.sub (length w) (S (length z)))) (Init.Nat.sub (length w) (length z))
+++++
omega.
-----
Lemma I_Y_property j z w y : length z < length w -> length w - S (length z) < length y -> Y (j :: z) w y = [nth (length w - S (length z)) y false] ++ Y z w y.
Proof.
intros.
simpl.
rewrite Y_skipn.
rewrite Y_skipn.
simpl.
rewrite skipn_hd with (d := false).

*****
H0 : lt (Init.Nat.sub (length w) (S (length z))) (length y)
H : lt (length z) (length w)
z,w,y : list bool
j : bool
*****
lt (Init.Nat.sub (length w) (S (length z))) (length y)
+++++
trivial.
-----
Lemma I_Y_property j z w y : length z < length w -> length w - S (length z) < length y -> Y (j :: z) w y = [nth (length w - S (length z)) y false] ++ Y z w y.
Proof.
intros.
simpl.
rewrite Y_skipn.
rewrite Y_skipn.
simpl.
rewrite skipn_hd with (d := false).

*****

*****

+++++
Qed.
-----
Global Opaque I_e.
-----
