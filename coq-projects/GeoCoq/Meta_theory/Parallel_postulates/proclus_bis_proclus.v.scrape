Require Import GeoCoq.Axioms.parallel_postulates.
-----
Require Import GeoCoq.Tarski_dev.Ch12_parallel.
-----
Section proclus_bis_proclus.
-----
Context `{TnEQD:Tarski_neutral_dimensionless_with_decidable_point_equality}.
-----
Lemma proclus_bis__proclus : alternative_proclus_postulate -> proclus_postulate.
-----
Lemma proclus_bis__proclus : alternative_proclus_postulate -> proclus_postulate.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : alternative_proclus_postulate, proclus_postulate
+++++
Proof.
-----
Lemma proclus_bis__proclus : alternative_proclus_postulate -> proclus_postulate.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : alternative_proclus_postulate, proclus_postulate
+++++
intros proclus_bis A B C D P Q HPar HInter HNCol HCop.
-----
Lemma proclus_bis__proclus : alternative_proclus_postulate -> proclus_postulate.
Proof.
intros proclus_bis A B C D P Q HPar HInter HNCol HCop.

*****
HCop : Coplanar C D P Q
HNCol : not (Col A B Q)
HInter : Col A B P
HPar : Par A B C D
A,B,C,D,P,Q : Tpoint
proclus_bis : alternative_proclus_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Y : Tpoint => and (Col P Q Y) (Col C D Y))
+++++
elim(col_dec C D P).
-----
Lemma proclus_bis__proclus : alternative_proclus_postulate -> proclus_postulate.
Proof.
intros proclus_bis A B C D P Q HPar HInter HNCol HCop.
elim(col_dec C D P).

*****
HCop : Coplanar C D P Q
HNCol : not (Col A B Q)
HInter : Col A B P
HPar : Par A B C D
A,B,C,D,P,Q : Tpoint
proclus_bis : alternative_proclus_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : Col C D P, ex (fun Y : Tpoint => and (Col P Q Y) (Col C D Y))
+++++
intro; exists P; Col.
-----
Lemma proclus_bis__proclus : alternative_proclus_postulate -> proclus_postulate.
Proof.
intros proclus_bis A B C D P Q HPar HInter HNCol HCop.
elim(col_dec C D P).
intro; exists P; Col.

*****
HCop : Coplanar C D P Q
HNCol : not (Col A B Q)
HInter : Col A B P
HPar : Par A B C D
A,B,C,D,P,Q : Tpoint
proclus_bis : alternative_proclus_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : not (Col C D P), ex (fun Y : Tpoint => and (Col P Q Y) (Col C D Y))
+++++
intro HNCol1.
-----
Lemma proclus_bis__proclus : alternative_proclus_postulate -> proclus_postulate.
Proof.
intros proclus_bis A B C D P Q HPar HInter HNCol HCop.
elim(col_dec C D P).
intro; exists P; Col.
intro HNCol1.

*****
HNCol1 : not (Col C D P)
HCop : Coplanar C D P Q
HNCol : not (Col A B Q)
HInter : Col A B P
HPar : Par A B C D
A,B,C,D,P,Q : Tpoint
proclus_bis : alternative_proclus_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Y : Tpoint => and (Col P Q Y) (Col C D Y))
+++++
apply par_symmetry in HPar.
-----
Lemma proclus_bis__proclus : alternative_proclus_postulate -> proclus_postulate.
Proof.
intros proclus_bis A B C D P Q HPar HInter HNCol HCop.
elim(col_dec C D P).
intro; exists P; Col.
intro HNCol1.
apply par_symmetry in HPar.

*****
HNCol1 : not (Col C D P)
HCop : Coplanar C D P Q
HNCol : not (Col A B Q)
HInter : Col A B P
HPar : Par C D A B
A,B,C,D,P,Q : Tpoint
proclus_bis : alternative_proclus_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Y : Tpoint => and (Col P Q Y) (Col C D Y))
+++++
apply (par_not_col_strict _ _ _ _ P) in HPar; auto.
-----
Lemma proclus_bis__proclus : alternative_proclus_postulate -> proclus_postulate.
Proof.
intros proclus_bis A B C D P Q HPar HInter HNCol HCop.
elim(col_dec C D P).
intro; exists P; Col.
intro HNCol1.
apply par_symmetry in HPar.
apply (par_not_col_strict _ _ _ _ P) in HPar; auto.

*****
HNCol1 : not (Col C D P)
HCop : Coplanar C D P Q
HNCol : not (Col A B Q)
HInter : Col A B P
HPar : Par_strict C D A B
A,B,C,D,P,Q : Tpoint
proclus_bis : alternative_proclus_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Y : Tpoint => and (Col P Q Y) (Col C D Y))
+++++
assert(HC0 := l8_18_existence C D P).
-----
Lemma proclus_bis__proclus : alternative_proclus_postulate -> proclus_postulate.
Proof.
intros proclus_bis A B C D P Q HPar HInter HNCol HCop.
elim(col_dec C D P).
intro; exists P; Col.
intro HNCol1.
apply par_symmetry in HPar.
apply (par_not_col_strict _ _ _ _ P) in HPar; auto.
assert(HC0 := l8_18_existence C D P).

*****
HC0 : forall _ : not (Col C D P),\nex (fun X : Tpoint => and (Col C D X) (Perp C D P X))
HNCol1 : not (Col C D P)
HCop : Coplanar C D P Q
HNCol : not (Col A B Q)
HInter : Col A B P
HPar : Par_strict C D A B
A,B,C,D,P,Q : Tpoint
proclus_bis : alternative_proclus_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Y : Tpoint => and (Col P Q Y) (Col C D Y))
+++++
destruct HC0 as [C0 []]; auto.
-----
Lemma proclus_bis__proclus : alternative_proclus_postulate -> proclus_postulate.
Proof.
intros proclus_bis A B C D P Q HPar HInter HNCol HCop.
elim(col_dec C D P).
intro; exists P; Col.
intro HNCol1.
apply par_symmetry in HPar.
apply (par_not_col_strict _ _ _ _ P) in HPar; auto.
assert(HC0 := l8_18_existence C D P).
destruct HC0 as [C0 []]; auto.

*****
H0 : Perp C D P C0
H : Col C D C0
C0 : Tpoint
HNCol1 : not (Col C D P)
HCop : Coplanar C D P Q
HNCol : not (Col A B Q)
HInter : Col A B P
HPar : Par_strict C D A B
A,B,C,D,P,Q : Tpoint
proclus_bis : alternative_proclus_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Y : Tpoint => and (Col P Q Y) (Col C D Y))
+++++
assert(HNCol2 : ~ Col C0 A B) by (apply (par_not_col C D); Col).
-----
Lemma proclus_bis__proclus : alternative_proclus_postulate -> proclus_postulate.
Proof.
intros proclus_bis A B C D P Q HPar HInter HNCol HCop.
elim(col_dec C D P).
intro; exists P; Col.
intro HNCol1.
apply par_symmetry in HPar.
apply (par_not_col_strict _ _ _ _ P) in HPar; auto.
assert(HC0 := l8_18_existence C D P).
destruct HC0 as [C0 []]; auto.
assert(HNCol2 : ~ Col C0 A B) by (apply (par_not_col C D); Col).

*****
HNCol2 : not (Col C0 A B)
H0 : Perp C D P C0
H : Col C D C0
C0 : Tpoint
HNCol1 : not (Col C D P)
HCop : Coplanar C D P Q
HNCol : not (Col A B Q)
HInter : Col A B P
HPar : Par_strict C D A B
A,B,C,D,P,Q : Tpoint
proclus_bis : alternative_proclus_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Y : Tpoint => and (Col P Q Y) (Col C D Y))
+++++
assert_diffs.
-----
Lemma proclus_bis__proclus : alternative_proclus_postulate -> proclus_postulate.
Proof.
intros proclus_bis A B C D P Q HPar HInter HNCol HCop.
elim(col_dec C D P).
intro; exists P; Col.
intro HNCol1.
apply par_symmetry in HPar.
apply (par_not_col_strict _ _ _ _ P) in HPar; auto.
assert(HC0 := l8_18_existence C D P).
destruct HC0 as [C0 []]; auto.
assert(HNCol2 : ~ Col C0 A B) by (apply (par_not_col C D); Col).
assert_diffs.

*****
H10 : not (eq P C0)
H12 : not (eq A Q)
H8 : not (eq B Q)
H9 : not (eq C P)
H5 : not (eq D P)
H7 : not (eq C D)
H6 : not (eq C0 B)
H3 : not (eq A B)
H4 : not (eq C0 A)
HNCol2 : not (Col C0 A B)
H0 : Perp C D P C0
H : Col C D C0
C0 : Tpoint
HNCol1 : not (Col C D P)
HCop : Coplanar C D P Q
HNCol : not (Col A B Q)
HInter : Col A B P
HPar : Par_strict C D A B
A,B,C,D,P,Q : Tpoint
proclus_bis : alternative_proclus_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Y : Tpoint => and (Col P Q Y) (Col C D Y))
+++++
assert(HA0 : exists A0, Col A B A0 /\ ~ Col C0 P A0).
-----
Lemma proclus_bis__proclus : alternative_proclus_postulate -> proclus_postulate.
Proof.
intros proclus_bis A B C D P Q HPar HInter HNCol HCop.
elim(col_dec C D P).
intro; exists P; Col.
intro HNCol1.
apply par_symmetry in HPar.
apply (par_not_col_strict _ _ _ _ P) in HPar; auto.
assert(HC0 := l8_18_existence C D P).
destruct HC0 as [C0 []]; auto.
assert(HNCol2 : ~ Col C0 A B) by (apply (par_not_col C D); Col).
assert_diffs.
assert(HA0 : exists A0, Col A B A0 /\\ ~ Col C0 P A0).

*****
H10 : not (eq P C0)
H12 : not (eq A Q)
H8 : not (eq B Q)
H9 : not (eq C P)
H5 : not (eq D P)
H7 : not (eq C D)
H6 : not (eq C0 B)
H3 : not (eq A B)
H4 : not (eq C0 A)
HNCol2 : not (Col C0 A B)
H0 : Perp C D P C0
H : Col C D C0
C0 : Tpoint
HNCol1 : not (Col C D P)
HCop : Coplanar C D P Q
HNCol : not (Col A B Q)
HInter : Col A B P
HPar : Par_strict C D A B
A,B,C,D,P,Q : Tpoint
proclus_bis : alternative_proclus_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun A0 : Tpoint => and (Col A B A0) (not (Col C0 P A0)))
+++++
elim(col_dec C0 P A).
-----
Lemma proclus_bis__proclus : alternative_proclus_postulate -> proclus_postulate.
Proof.
intros proclus_bis A B C D P Q HPar HInter HNCol HCop.
elim(col_dec C D P).
intro; exists P; Col.
intro HNCol1.
apply par_symmetry in HPar.
apply (par_not_col_strict _ _ _ _ P) in HPar; auto.
assert(HC0 := l8_18_existence C D P).
destruct HC0 as [C0 []]; auto.
assert(HNCol2 : ~ Col C0 A B) by (apply (par_not_col C D); Col).
assert_diffs.
assert(HA0 : exists A0, Col A B A0 /\\ ~ Col C0 P A0).
elim(col_dec C0 P A).

*****
H10 : not (eq P C0)
H12 : not (eq A Q)
H8 : not (eq B Q)
H9 : not (eq C P)
H5 : not (eq D P)
H7 : not (eq C D)
H6 : not (eq C0 B)
H3 : not (eq A B)
H4 : not (eq C0 A)
HNCol2 : not (Col C0 A B)
H0 : Perp C D P C0
H : Col C D C0
C0 : Tpoint
HNCol1 : not (Col C D P)
HCop : Coplanar C D P Q
HNCol : not (Col A B Q)
HInter : Col A B P
HPar : Par_strict C D A B
A,B,C,D,P,Q : Tpoint
proclus_bis : alternative_proclus_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : Col C0 P A, ex (fun A0 : Tpoint => and (Col A B A0) (not (Col C0 P A0)))
+++++
-
-----
Lemma proclus_bis__proclus : alternative_proclus_postulate -> proclus_postulate.
Proof.
intros proclus_bis A B C D P Q HPar HInter HNCol HCop.
elim(col_dec C D P).
intro; exists P; Col.
intro HNCol1.
apply par_symmetry in HPar.
apply (par_not_col_strict _ _ _ _ P) in HPar; auto.
assert(HC0 := l8_18_existence C D P).
destruct HC0 as [C0 []]; auto.
assert(HNCol2 : ~ Col C0 A B) by (apply (par_not_col C D); Col).
assert_diffs.
assert(HA0 : exists A0, Col A B A0 /\\ ~ Col C0 P A0).
elim(col_dec C0 P A).
-

*****
H10 : not (eq P C0)
H12 : not (eq A Q)
H8 : not (eq B Q)
H9 : not (eq C P)
H5 : not (eq D P)
H7 : not (eq C D)
H6 : not (eq C0 B)
H3 : not (eq A B)
H4 : not (eq C0 A)
HNCol2 : not (Col C0 A B)
H0 : Perp C D P C0
H : Col C D C0
C0 : Tpoint
HNCol1 : not (Col C D P)
HCop : Coplanar C D P Q
HNCol : not (Col A B Q)
HInter : Col A B P
HPar : Par_strict C D A B
A,B,C,D,P,Q : Tpoint
proclus_bis : alternative_proclus_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : Col C0 P A, ex (fun A0 : Tpoint => and (Col A B A0) (not (Col C0 P A0)))
+++++
intro.
-----
Lemma proclus_bis__proclus : alternative_proclus_postulate -> proclus_postulate.
Proof.
intros proclus_bis A B C D P Q HPar HInter HNCol HCop.
elim(col_dec C D P).
intro; exists P; Col.
intro HNCol1.
apply par_symmetry in HPar.
apply (par_not_col_strict _ _ _ _ P) in HPar; auto.
assert(HC0 := l8_18_existence C D P).
destruct HC0 as [C0 []]; auto.
assert(HNCol2 : ~ Col C0 A B) by (apply (par_not_col C D); Col).
assert_diffs.
assert(HA0 : exists A0, Col A B A0 /\\ ~ Col C0 P A0).
elim(col_dec C0 P A).
-
intro.

*****
H1 : Col C0 P A
H10 : not (eq P C0)
H12 : not (eq A Q)
H8 : not (eq B Q)
H9 : not (eq C P)
H5 : not (eq D P)
H7 : not (eq C D)
H6 : not (eq C0 B)
H3 : not (eq A B)
H4 : not (eq C0 A)
HNCol2 : not (Col C0 A B)
H0 : Perp C D P C0
H : Col C D C0
C0 : Tpoint
HNCol1 : not (Col C D P)
HCop : Coplanar C D P Q
HNCol : not (Col A B Q)
HInter : Col A B P
HPar : Par_strict C D A B
A,B,C,D,P,Q : Tpoint
proclus_bis : alternative_proclus_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun A0 : Tpoint => and (Col A B A0) (not (Col C0 P A0)))
+++++
assert(~ Col C0 P B) by (intro; apply HNCol2; ColR).
-----
Lemma proclus_bis__proclus : alternative_proclus_postulate -> proclus_postulate.
Proof.
intros proclus_bis A B C D P Q HPar HInter HNCol HCop.
elim(col_dec C D P).
intro; exists P; Col.
intro HNCol1.
apply par_symmetry in HPar.
apply (par_not_col_strict _ _ _ _ P) in HPar; auto.
assert(HC0 := l8_18_existence C D P).
destruct HC0 as [C0 []]; auto.
assert(HNCol2 : ~ Col C0 A B) by (apply (par_not_col C D); Col).
assert_diffs.
assert(HA0 : exists A0, Col A B A0 /\\ ~ Col C0 P A0).
elim(col_dec C0 P A).
-
intro.
assert(~ Col C0 P B) by (intro; apply HNCol2; ColR).

*****
H2 : not (Col C0 P B)
H1 : Col C0 P A
H10 : not (eq P C0)
H12 : not (eq A Q)
H8 : not (eq B Q)
H9 : not (eq C P)
H5 : not (eq D P)
H7 : not (eq C D)
H6 : not (eq C0 B)
H3 : not (eq A B)
H4 : not (eq C0 A)
HNCol2 : not (Col C0 A B)
H0 : Perp C D P C0
H : Col C D C0
C0 : Tpoint
HNCol1 : not (Col C D P)
HCop : Coplanar C D P Q
HNCol : not (Col A B Q)
HInter : Col A B P
HPar : Par_strict C D A B
A,B,C,D,P,Q : Tpoint
proclus_bis : alternative_proclus_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun A0 : Tpoint => and (Col A B A0) (not (Col C0 P A0)))
+++++
exists B.
-----
Lemma proclus_bis__proclus : alternative_proclus_postulate -> proclus_postulate.
Proof.
intros proclus_bis A B C D P Q HPar HInter HNCol HCop.
elim(col_dec C D P).
intro; exists P; Col.
intro HNCol1.
apply par_symmetry in HPar.
apply (par_not_col_strict _ _ _ _ P) in HPar; auto.
assert(HC0 := l8_18_existence C D P).
destruct HC0 as [C0 []]; auto.
assert(HNCol2 : ~ Col C0 A B) by (apply (par_not_col C D); Col).
assert_diffs.
assert(HA0 : exists A0, Col A B A0 /\\ ~ Col C0 P A0).
elim(col_dec C0 P A).
-
intro.
assert(~ Col C0 P B) by (intro; apply HNCol2; ColR).
exists B.

*****
H2 : not (Col C0 P B)
H1 : Col C0 P A
H10 : not (eq P C0)
H12 : not (eq A Q)
H8 : not (eq B Q)
H9 : not (eq C P)
H5 : not (eq D P)
H7 : not (eq C D)
H6 : not (eq C0 B)
H3 : not (eq A B)
H4 : not (eq C0 A)
HNCol2 : not (Col C0 A B)
H0 : Perp C D P C0
H : Col C D C0
C0 : Tpoint
HNCol1 : not (Col C D P)
HCop : Coplanar C D P Q
HNCol : not (Col A B Q)
HInter : Col A B P
HPar : Par_strict C D A B
A,B,C,D,P,Q : Tpoint
proclus_bis : alternative_proclus_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Col A B B) (not (Col C0 P B))
+++++
split; Col.
-----
Lemma proclus_bis__proclus : alternative_proclus_postulate -> proclus_postulate.
Proof.
intros proclus_bis A B C D P Q HPar HInter HNCol HCop.
elim(col_dec C D P).
intro; exists P; Col.
intro HNCol1.
apply par_symmetry in HPar.
apply (par_not_col_strict _ _ _ _ P) in HPar; auto.
assert(HC0 := l8_18_existence C D P).
destruct HC0 as [C0 []]; auto.
assert(HNCol2 : ~ Col C0 A B) by (apply (par_not_col C D); Col).
assert_diffs.
assert(HA0 : exists A0, Col A B A0 /\\ ~ Col C0 P A0).
elim(col_dec C0 P A).
-
intro.
assert(~ Col C0 P B) by (intro; apply HNCol2; ColR).
exists B.
split; Col.

*****

*****

+++++
-
-----
Lemma proclus_bis__proclus : alternative_proclus_postulate -> proclus_postulate.
Proof.
intros proclus_bis A B C D P Q HPar HInter HNCol HCop.
elim(col_dec C D P).
intro; exists P; Col.
intro HNCol1.
apply par_symmetry in HPar.
apply (par_not_col_strict _ _ _ _ P) in HPar; auto.
assert(HC0 := l8_18_existence C D P).
destruct HC0 as [C0 []]; auto.
assert(HNCol2 : ~ Col C0 A B) by (apply (par_not_col C D); Col).
assert_diffs.
assert(HA0 : exists A0, Col A B A0 /\\ ~ Col C0 P A0).
elim(col_dec C0 P A).
-
intro.
assert(~ Col C0 P B) by (intro; apply HNCol2; ColR).
exists B.
split; Col.
-

*****
H10 : not (eq P C0)
H12 : not (eq A Q)
H8 : not (eq B Q)
H9 : not (eq C P)
H5 : not (eq D P)
H7 : not (eq C D)
H6 : not (eq C0 B)
H3 : not (eq A B)
H4 : not (eq C0 A)
HNCol2 : not (Col C0 A B)
H0 : Perp C D P C0
H : Col C D C0
C0 : Tpoint
HNCol1 : not (Col C D P)
HCop : Coplanar C D P Q
HNCol : not (Col A B Q)
HInter : Col A B P
HPar : Par_strict C D A B
A,B,C,D,P,Q : Tpoint
proclus_bis : alternative_proclus_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : not (Col C0 P A), ex (fun A0 : Tpoint => and (Col A B A0) (not (Col C0 P A0)))
+++++
intro.
-----
Lemma proclus_bis__proclus : alternative_proclus_postulate -> proclus_postulate.
Proof.
intros proclus_bis A B C D P Q HPar HInter HNCol HCop.
elim(col_dec C D P).
intro; exists P; Col.
intro HNCol1.
apply par_symmetry in HPar.
apply (par_not_col_strict _ _ _ _ P) in HPar; auto.
assert(HC0 := l8_18_existence C D P).
destruct HC0 as [C0 []]; auto.
assert(HNCol2 : ~ Col C0 A B) by (apply (par_not_col C D); Col).
assert_diffs.
assert(HA0 : exists A0, Col A B A0 /\\ ~ Col C0 P A0).
elim(col_dec C0 P A).
-
intro.
assert(~ Col C0 P B) by (intro; apply HNCol2; ColR).
exists B.
split; Col.
-
intro.

*****
H1 : not (Col C0 P A)
H10 : not (eq P C0)
H12 : not (eq A Q)
H8 : not (eq B Q)
H9 : not (eq C P)
H5 : not (eq D P)
H7 : not (eq C D)
H6 : not (eq C0 B)
H3 : not (eq A B)
H4 : not (eq C0 A)
HNCol2 : not (Col C0 A B)
H0 : Perp C D P C0
H : Col C D C0
C0 : Tpoint
HNCol1 : not (Col C D P)
HCop : Coplanar C D P Q
HNCol : not (Col A B Q)
HInter : Col A B P
HPar : Par_strict C D A B
A,B,C,D,P,Q : Tpoint
proclus_bis : alternative_proclus_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun A0 : Tpoint => and (Col A B A0) (not (Col C0 P A0)))
+++++
exists A.
-----
Lemma proclus_bis__proclus : alternative_proclus_postulate -> proclus_postulate.
Proof.
intros proclus_bis A B C D P Q HPar HInter HNCol HCop.
elim(col_dec C D P).
intro; exists P; Col.
intro HNCol1.
apply par_symmetry in HPar.
apply (par_not_col_strict _ _ _ _ P) in HPar; auto.
assert(HC0 := l8_18_existence C D P).
destruct HC0 as [C0 []]; auto.
assert(HNCol2 : ~ Col C0 A B) by (apply (par_not_col C D); Col).
assert_diffs.
assert(HA0 : exists A0, Col A B A0 /\\ ~ Col C0 P A0).
elim(col_dec C0 P A).
-
intro.
assert(~ Col C0 P B) by (intro; apply HNCol2; ColR).
exists B.
split; Col.
-
intro.
exists A.

*****
H1 : not (Col C0 P A)
H10 : not (eq P C0)
H12 : not (eq A Q)
H8 : not (eq B Q)
H9 : not (eq C P)
H5 : not (eq D P)
H7 : not (eq C D)
H6 : not (eq C0 B)
H3 : not (eq A B)
H4 : not (eq C0 A)
HNCol2 : not (Col C0 A B)
H0 : Perp C D P C0
H : Col C D C0
C0 : Tpoint
HNCol1 : not (Col C D P)
HCop : Coplanar C D P Q
HNCol : not (Col A B Q)
HInter : Col A B P
HPar : Par_strict C D A B
A,B,C,D,P,Q : Tpoint
proclus_bis : alternative_proclus_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Col A B A) (not (Col C0 P A))
+++++
split; Col.
-----
Lemma proclus_bis__proclus : alternative_proclus_postulate -> proclus_postulate.
Proof.
intros proclus_bis A B C D P Q HPar HInter HNCol HCop.
elim(col_dec C D P).
intro; exists P; Col.
intro HNCol1.
apply par_symmetry in HPar.
apply (par_not_col_strict _ _ _ _ P) in HPar; auto.
assert(HC0 := l8_18_existence C D P).
destruct HC0 as [C0 []]; auto.
assert(HNCol2 : ~ Col C0 A B) by (apply (par_not_col C D); Col).
assert_diffs.
assert(HA0 : exists A0, Col A B A0 /\\ ~ Col C0 P A0).

*****
HA0 : ex (fun A0 : Tpoint => and (Col A B A0) (not (Col C0 P A0)))
H10 : not (eq P C0)
H12 : not (eq A Q)
H8 : not (eq B Q)
H9 : not (eq C P)
H5 : not (eq D P)
H7 : not (eq C D)
H6 : not (eq C0 B)
H3 : not (eq A B)
H4 : not (eq C0 A)
HNCol2 : not (Col C0 A B)
H0 : Perp C D P C0
H : Col C D C0
C0 : Tpoint
HNCol1 : not (Col C D P)
HCop : Coplanar C D P Q
HNCol : not (Col A B Q)
HInter : Col A B P
HPar : Par_strict C D A B
A,B,C,D,P,Q : Tpoint
proclus_bis : alternative_proclus_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Y : Tpoint => and (Col P Q Y) (Col C D Y))
+++++
destruct HA0 as [A0 []].
-----
Lemma proclus_bis__proclus : alternative_proclus_postulate -> proclus_postulate.
Proof.
intros proclus_bis A B C D P Q HPar HInter HNCol HCop.
elim(col_dec C D P).
intro; exists P; Col.
intro HNCol1.
apply par_symmetry in HPar.
apply (par_not_col_strict _ _ _ _ P) in HPar; auto.
assert(HC0 := l8_18_existence C D P).
destruct HC0 as [C0 []]; auto.
assert(HNCol2 : ~ Col C0 A B) by (apply (par_not_col C D); Col).
assert_diffs.
assert(HA0 : exists A0, Col A B A0 /\\ ~ Col C0 P A0).
destruct HA0 as [A0 []].

*****
H2 : not (Col C0 P A0)
H1 : Col A B A0
A0 : Tpoint
H10 : not (eq P C0)
H12 : not (eq A Q)
H8 : not (eq B Q)
H9 : not (eq C P)
H5 : not (eq D P)
H7 : not (eq C D)
H6 : not (eq C0 B)
H3 : not (eq A B)
H4 : not (eq C0 A)
HNCol2 : not (Col C0 A B)
H0 : Perp C D P C0
H : Col C D C0
C0 : Tpoint
HNCol1 : not (Col C D P)
HCop : Coplanar C D P Q
HNCol : not (Col A B Q)
HInter : Col A B P
HPar : Par_strict C D A B
A,B,C,D,P,Q : Tpoint
proclus_bis : alternative_proclus_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Y : Tpoint => and (Col P Q Y) (Col C D Y))
+++++
assert(HA' := l10_15 C0 P P A0).
-----
Lemma proclus_bis__proclus : alternative_proclus_postulate -> proclus_postulate.
Proof.
intros proclus_bis A B C D P Q HPar HInter HNCol HCop.
elim(col_dec C D P).
intro; exists P; Col.
intro HNCol1.
apply par_symmetry in HPar.
apply (par_not_col_strict _ _ _ _ P) in HPar; auto.
assert(HC0 := l8_18_existence C D P).
destruct HC0 as [C0 []]; auto.
assert(HNCol2 : ~ Col C0 A B) by (apply (par_not_col C D); Col).
assert_diffs.
assert(HA0 : exists A0, Col A B A0 /\\ ~ Col C0 P A0).
destruct HA0 as [A0 []].
assert(HA' := l10_15 C0 P P A0).

*****
HA' : forall (_ : Col C0 P P) (_ : not (Col C0 P A0)),\nex (fun Q : Tpoint => and (Perp C0 P Q P) (OS C0 P A0 Q))
H2 : not (Col C0 P A0)
H1 : Col A B A0
A0 : Tpoint
H10 : not (eq P C0)
H12 : not (eq A Q)
H8 : not (eq B Q)
H9 : not (eq C P)
H5 : not (eq D P)
H7 : not (eq C D)
H6 : not (eq C0 B)
H3 : not (eq A B)
H4 : not (eq C0 A)
HNCol2 : not (Col C0 A B)
H0 : Perp C D P C0
H : Col C D C0
C0 : Tpoint
HNCol1 : not (Col C D P)
HCop : Coplanar C D P Q
HNCol : not (Col A B Q)
HInter : Col A B P
HPar : Par_strict C D A B
A,B,C,D,P,Q : Tpoint
proclus_bis : alternative_proclus_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Y : Tpoint => and (Col P Q Y) (Col C D Y))
+++++
destruct HA' as [A' []]; Col.
-----
Lemma proclus_bis__proclus : alternative_proclus_postulate -> proclus_postulate.
Proof.
intros proclus_bis A B C D P Q HPar HInter HNCol HCop.
elim(col_dec C D P).
intro; exists P; Col.
intro HNCol1.
apply par_symmetry in HPar.
apply (par_not_col_strict _ _ _ _ P) in HPar; auto.
assert(HC0 := l8_18_existence C D P).
destruct HC0 as [C0 []]; auto.
assert(HNCol2 : ~ Col C0 A B) by (apply (par_not_col C D); Col).
assert_diffs.
assert(HA0 : exists A0, Col A B A0 /\\ ~ Col C0 P A0).
destruct HA0 as [A0 []].
assert(HA' := l10_15 C0 P P A0).
destruct HA' as [A' []]; Col.

*****
H13 : OS C0 P A0 A'
H11 : Perp C0 P A' P
A' : Tpoint
H2 : not (Col C0 P A0)
H1 : Col A B A0
A0 : Tpoint
H10 : not (eq P C0)
H12 : not (eq A Q)
H8 : not (eq B Q)
H9 : not (eq C P)
H5 : not (eq D P)
H7 : not (eq C D)
H6 : not (eq C0 B)
H3 : not (eq A B)
H4 : not (eq C0 A)
HNCol2 : not (Col C0 A B)
H0 : Perp C D P C0
H : Col C D C0
C0 : Tpoint
HNCol1 : not (Col C D P)
HCop : Coplanar C D P Q
HNCol : not (Col A B Q)
HInter : Col A B P
HPar : Par_strict C D A B
A,B,C,D,P,Q : Tpoint
proclus_bis : alternative_proclus_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Y : Tpoint => and (Col P Q Y) (Col C D Y))
+++++
assert_diffs.
-----
Lemma proclus_bis__proclus : alternative_proclus_postulate -> proclus_postulate.
Proof.
intros proclus_bis A B C D P Q HPar HInter HNCol HCop.
elim(col_dec C D P).
intro; exists P; Col.
intro HNCol1.
apply par_symmetry in HPar.
apply (par_not_col_strict _ _ _ _ P) in HPar; auto.
assert(HC0 := l8_18_existence C D P).
destruct HC0 as [C0 []]; auto.
assert(HNCol2 : ~ Col C0 A B) by (apply (par_not_col C D); Col).
assert_diffs.
assert(HA0 : exists A0, Col A B A0 /\\ ~ Col C0 P A0).
destruct HA0 as [A0 []].
assert(HA' := l10_15 C0 P P A0).
destruct HA' as [A' []]; Col.
assert_diffs.

*****
H18 : not (eq C0 A')
H17 : not (eq A' P)
H19 : not (eq C0 A0)
H16 : not (eq P A0)
H13 : OS C0 P A0 A'
H11 : Perp C0 P A' P
A' : Tpoint
H2 : not (Col C0 P A0)
H1 : Col A B A0
A0 : Tpoint
H10 : not (eq P C0)
H12 : not (eq A Q)
H8 : not (eq B Q)
H9 : not (eq C P)
H5 : not (eq D P)
H7 : not (eq C D)
H6 : not (eq C0 B)
H3 : not (eq A B)
H4 : not (eq C0 A)
HNCol2 : not (Col C0 A B)
H0 : Perp C D P C0
H : Col C D C0
C0 : Tpoint
HNCol1 : not (Col C D P)
HCop : Coplanar C D P Q
HNCol : not (Col A B Q)
HInter : Col A B P
HPar : Par_strict C D A B
A,B,C,D,P,Q : Tpoint
proclus_bis : alternative_proclus_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Y : Tpoint => and (Col P Q Y) (Col C D Y))
+++++
elim(col_dec A0 P A').
-----
Lemma proclus_bis__proclus : alternative_proclus_postulate -> proclus_postulate.
Proof.
intros proclus_bis A B C D P Q HPar HInter HNCol HCop.
elim(col_dec C D P).
intro; exists P; Col.
intro HNCol1.
apply par_symmetry in HPar.
apply (par_not_col_strict _ _ _ _ P) in HPar; auto.
assert(HC0 := l8_18_existence C D P).
destruct HC0 as [C0 []]; auto.
assert(HNCol2 : ~ Col C0 A B) by (apply (par_not_col C D); Col).
assert_diffs.
assert(HA0 : exists A0, Col A B A0 /\\ ~ Col C0 P A0).
destruct HA0 as [A0 []].
assert(HA' := l10_15 C0 P P A0).
destruct HA' as [A' []]; Col.
assert_diffs.
elim(col_dec A0 P A').

*****
H18 : not (eq C0 A')
H17 : not (eq A' P)
H19 : not (eq C0 A0)
H16 : not (eq P A0)
H13 : OS C0 P A0 A'
H11 : Perp C0 P A' P
A' : Tpoint
H2 : not (Col C0 P A0)
H1 : Col A B A0
A0 : Tpoint
H10 : not (eq P C0)
H12 : not (eq A Q)
H8 : not (eq B Q)
H9 : not (eq C P)
H5 : not (eq D P)
H7 : not (eq C D)
H6 : not (eq C0 B)
H3 : not (eq A B)
H4 : not (eq C0 A)
HNCol2 : not (Col C0 A B)
H0 : Perp C D P C0
H : Col C D C0
C0 : Tpoint
HNCol1 : not (Col C D P)
HCop : Coplanar C D P Q
HNCol : not (Col A B Q)
HInter : Col A B P
HPar : Par_strict C D A B
A,B,C,D,P,Q : Tpoint
proclus_bis : alternative_proclus_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : Col A0 P A', ex (fun Y : Tpoint => and (Col P Q Y) (Col C D Y))
+++++
-
-----
Lemma proclus_bis__proclus : alternative_proclus_postulate -> proclus_postulate.
Proof.
intros proclus_bis A B C D P Q HPar HInter HNCol HCop.
elim(col_dec C D P).
intro; exists P; Col.
intro HNCol1.
apply par_symmetry in HPar.
apply (par_not_col_strict _ _ _ _ P) in HPar; auto.
assert(HC0 := l8_18_existence C D P).
destruct HC0 as [C0 []]; auto.
assert(HNCol2 : ~ Col C0 A B) by (apply (par_not_col C D); Col).
assert_diffs.
assert(HA0 : exists A0, Col A B A0 /\\ ~ Col C0 P A0).
destruct HA0 as [A0 []].
assert(HA' := l10_15 C0 P P A0).
destruct HA' as [A' []]; Col.
assert_diffs.
elim(col_dec A0 P A').
-

*****
H18 : not (eq C0 A')
H17 : not (eq A' P)
H19 : not (eq C0 A0)
H16 : not (eq P A0)
H13 : OS C0 P A0 A'
H11 : Perp C0 P A' P
A' : Tpoint
H2 : not (Col C0 P A0)
H1 : Col A B A0
A0 : Tpoint
H10 : not (eq P C0)
H12 : not (eq A Q)
H8 : not (eq B Q)
H9 : not (eq C P)
H5 : not (eq D P)
H7 : not (eq C D)
H6 : not (eq C0 B)
H3 : not (eq A B)
H4 : not (eq C0 A)
HNCol2 : not (Col C0 A B)
H0 : Perp C D P C0
H : Col C D C0
C0 : Tpoint
HNCol1 : not (Col C D P)
HCop : Coplanar C D P Q
HNCol : not (Col A B Q)
HInter : Col A B P
HPar : Par_strict C D A B
A,B,C,D,P,Q : Tpoint
proclus_bis : alternative_proclus_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : Col A0 P A', ex (fun Y : Tpoint => and (Col P Q Y) (Col C D Y))
+++++
intro.
-----
Lemma proclus_bis__proclus : alternative_proclus_postulate -> proclus_postulate.
Proof.
intros proclus_bis A B C D P Q HPar HInter HNCol HCop.
elim(col_dec C D P).
intro; exists P; Col.
intro HNCol1.
apply par_symmetry in HPar.
apply (par_not_col_strict _ _ _ _ P) in HPar; auto.
assert(HC0 := l8_18_existence C D P).
destruct HC0 as [C0 []]; auto.
assert(HNCol2 : ~ Col C0 A B) by (apply (par_not_col C D); Col).
assert_diffs.
assert(HA0 : exists A0, Col A B A0 /\\ ~ Col C0 P A0).
destruct HA0 as [A0 []].
assert(HA' := l10_15 C0 P P A0).
destruct HA' as [A' []]; Col.
assert_diffs.
elim(col_dec A0 P A').
-
intro.

*****
H14 : Col A0 P A'
H18 : not (eq C0 A')
H17 : not (eq A' P)
H19 : not (eq C0 A0)
H16 : not (eq P A0)
H13 : OS C0 P A0 A'
H11 : Perp C0 P A' P
A' : Tpoint
H2 : not (Col C0 P A0)
H1 : Col A B A0
A0 : Tpoint
H10 : not (eq P C0)
H12 : not (eq A Q)
H8 : not (eq B Q)
H9 : not (eq C P)
H5 : not (eq D P)
H7 : not (eq C D)
H6 : not (eq C0 B)
H3 : not (eq A B)
H4 : not (eq C0 A)
HNCol2 : not (Col C0 A B)
H0 : Perp C D P C0
H : Col C D C0
C0 : Tpoint
HNCol1 : not (Col C D P)
HCop : Coplanar C D P Q
HNCol : not (Col A B Q)
HInter : Col A B P
HPar : Par_strict C D A B
A,B,C,D,P,Q : Tpoint
proclus_bis : alternative_proclus_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Y : Tpoint => and (Col P Q Y) (Col C D Y))
+++++
apply (proclus_bis A0 P); Col; [| |intro; apply HNCol; ColR].
-----
Lemma proclus_bis__proclus : alternative_proclus_postulate -> proclus_postulate.
Proof.
intros proclus_bis A B C D P Q HPar HInter HNCol HCop.
elim(col_dec C D P).
intro; exists P; Col.
intro HNCol1.
apply par_symmetry in HPar.
apply (par_not_col_strict _ _ _ _ P) in HPar; auto.
assert(HC0 := l8_18_existence C D P).
destruct HC0 as [C0 []]; auto.
assert(HNCol2 : ~ Col C0 A B) by (apply (par_not_col C D); Col).
assert_diffs.
assert(HA0 : exists A0, Col A B A0 /\\ ~ Col C0 P A0).
destruct HA0 as [A0 []].
assert(HA' := l10_15 C0 P P A0).
destruct HA' as [A' []]; Col.
assert_diffs.
elim(col_dec A0 P A').
-
intro.
apply (proclus_bis A0 P); Col; [| |intro; apply HNCol; ColR].

*****
H14 : Col A0 P A'
H18 : not (eq C0 A')
H17 : not (eq A' P)
H19 : not (eq C0 A0)
H16 : not (eq P A0)
H13 : OS C0 P A0 A'
H11 : Perp C0 P A' P
A' : Tpoint
H2 : not (Col C0 P A0)
H1 : Col A B A0
A0 : Tpoint
H10 : not (eq P C0)
H12 : not (eq A Q)
H8 : not (eq B Q)
H9 : not (eq C P)
H5 : not (eq D P)
H7 : not (eq C D)
H6 : not (eq C0 B)
H3 : not (eq A B)
H4 : not (eq C0 A)
HNCol2 : not (Col C0 A B)
H0 : Perp C D P C0
H : Col C D C0
C0 : Tpoint
HNCol1 : not (Col C D P)
HCop : Coplanar C D P Q
HNCol : not (Col A B Q)
HInter : Col A B P
HPar : Par_strict C D A B
A,B,C,D,P,Q : Tpoint
proclus_bis : alternative_proclus_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Perp2 A0 P C D P
+++++
exists C0.
-----
Lemma proclus_bis__proclus : alternative_proclus_postulate -> proclus_postulate.
Proof.
intros proclus_bis A B C D P Q HPar HInter HNCol HCop.
elim(col_dec C D P).
intro; exists P; Col.
intro HNCol1.
apply par_symmetry in HPar.
apply (par_not_col_strict _ _ _ _ P) in HPar; auto.
assert(HC0 := l8_18_existence C D P).
destruct HC0 as [C0 []]; auto.
assert(HNCol2 : ~ Col C0 A B) by (apply (par_not_col C D); Col).
assert_diffs.
assert(HA0 : exists A0, Col A B A0 /\\ ~ Col C0 P A0).
destruct HA0 as [A0 []].
assert(HA' := l10_15 C0 P P A0).
destruct HA' as [A' []]; Col.
assert_diffs.
elim(col_dec A0 P A').
-
intro.
apply (proclus_bis A0 P); Col; [| |intro; apply HNCol; ColR].
exists C0.

*****
H14 : Col A0 P A'
H18 : not (eq C0 A')
H17 : not (eq A' P)
H19 : not (eq C0 A0)
H16 : not (eq P A0)
H13 : OS C0 P A0 A'
H11 : Perp C0 P A' P
A' : Tpoint
H2 : not (Col C0 P A0)
H1 : Col A B A0
A0 : Tpoint
H10 : not (eq P C0)
H12 : not (eq A Q)
H8 : not (eq B Q)
H9 : not (eq C P)
H5 : not (eq D P)
H7 : not (eq C D)
H6 : not (eq C0 B)
H3 : not (eq A B)
H4 : not (eq C0 A)
HNCol2 : not (Col C0 A B)
H0 : Perp C D P C0
H : Col C D C0
C0 : Tpoint
HNCol1 : not (Col C D P)
HCop : Coplanar C D P Q
HNCol : not (Col A B Q)
HInter : Col A B P
HPar : Par_strict C D A B
A,B,C,D,P,Q : Tpoint
proclus_bis : alternative_proclus_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Y : Tpoint => and (Col P C0 Y) (and (Perp C0 Y A0 P) (Perp C0 Y C D)))
+++++
exists P.
-----
Lemma proclus_bis__proclus : alternative_proclus_postulate -> proclus_postulate.
Proof.
intros proclus_bis A B C D P Q HPar HInter HNCol HCop.
elim(col_dec C D P).
intro; exists P; Col.
intro HNCol1.
apply par_symmetry in HPar.
apply (par_not_col_strict _ _ _ _ P) in HPar; auto.
assert(HC0 := l8_18_existence C D P).
destruct HC0 as [C0 []]; auto.
assert(HNCol2 : ~ Col C0 A B) by (apply (par_not_col C D); Col).
assert_diffs.
assert(HA0 : exists A0, Col A B A0 /\\ ~ Col C0 P A0).
destruct HA0 as [A0 []].
assert(HA' := l10_15 C0 P P A0).
destruct HA' as [A' []]; Col.
assert_diffs.
elim(col_dec A0 P A').
-
intro.
apply (proclus_bis A0 P); Col; [| |intro; apply HNCol; ColR].
exists C0.
exists P.

*****
H14 : Col A0 P A'
H18 : not (eq C0 A')
H17 : not (eq A' P)
H19 : not (eq C0 A0)
H16 : not (eq P A0)
H13 : OS C0 P A0 A'
H11 : Perp C0 P A' P
A' : Tpoint
H2 : not (Col C0 P A0)
H1 : Col A B A0
A0 : Tpoint
H10 : not (eq P C0)
H12 : not (eq A Q)
H8 : not (eq B Q)
H9 : not (eq C P)
H5 : not (eq D P)
H7 : not (eq C D)
H6 : not (eq C0 B)
H3 : not (eq A B)
H4 : not (eq C0 A)
HNCol2 : not (Col C0 A B)
H0 : Perp C D P C0
H : Col C D C0
C0 : Tpoint
HNCol1 : not (Col C D P)
HCop : Coplanar C D P Q
HNCol : not (Col A B Q)
HInter : Col A B P
HPar : Par_strict C D A B
A,B,C,D,P,Q : Tpoint
proclus_bis : alternative_proclus_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Col P C0 P) (and (Perp C0 P A0 P) (Perp C0 P C D))
+++++
split; Col.
-----
Lemma proclus_bis__proclus : alternative_proclus_postulate -> proclus_postulate.
Proof.
intros proclus_bis A B C D P Q HPar HInter HNCol HCop.
elim(col_dec C D P).
intro; exists P; Col.
intro HNCol1.
apply par_symmetry in HPar.
apply (par_not_col_strict _ _ _ _ P) in HPar; auto.
assert(HC0 := l8_18_existence C D P).
destruct HC0 as [C0 []]; auto.
assert(HNCol2 : ~ Col C0 A B) by (apply (par_not_col C D); Col).
assert_diffs.
assert(HA0 : exists A0, Col A B A0 /\\ ~ Col C0 P A0).
destruct HA0 as [A0 []].
assert(HA' := l10_15 C0 P P A0).
destruct HA' as [A' []]; Col.
assert_diffs.
elim(col_dec A0 P A').
-
intro.
apply (proclus_bis A0 P); Col; [| |intro; apply HNCol; ColR].
exists C0.
exists P.
split; Col.

*****
H14 : Col A0 P A'
H18 : not (eq C0 A')
H17 : not (eq A' P)
H19 : not (eq C0 A0)
H16 : not (eq P A0)
H13 : OS C0 P A0 A'
H11 : Perp C0 P A' P
A' : Tpoint
H2 : not (Col C0 P A0)
H1 : Col A B A0
A0 : Tpoint
H10 : not (eq P C0)
H12 : not (eq A Q)
H8 : not (eq B Q)
H9 : not (eq C P)
H5 : not (eq D P)
H7 : not (eq C D)
H6 : not (eq C0 B)
H3 : not (eq A B)
H4 : not (eq C0 A)
HNCol2 : not (Col C0 A B)
H0 : Perp C D P C0
H : Col C D C0
C0 : Tpoint
HNCol1 : not (Col C D P)
HCop : Coplanar C D P Q
HNCol : not (Col A B Q)
HInter : Col A B P
HPar : Par_strict C D A B
A,B,C,D,P,Q : Tpoint
proclus_bis : alternative_proclus_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Perp C0 P A0 P) (Perp C0 P C D)
+++++
split; [|Perp].
-----
Lemma proclus_bis__proclus : alternative_proclus_postulate -> proclus_postulate.
Proof.
intros proclus_bis A B C D P Q HPar HInter HNCol HCop.
elim(col_dec C D P).
intro; exists P; Col.
intro HNCol1.
apply par_symmetry in HPar.
apply (par_not_col_strict _ _ _ _ P) in HPar; auto.
assert(HC0 := l8_18_existence C D P).
destruct HC0 as [C0 []]; auto.
assert(HNCol2 : ~ Col C0 A B) by (apply (par_not_col C D); Col).
assert_diffs.
assert(HA0 : exists A0, Col A B A0 /\\ ~ Col C0 P A0).
destruct HA0 as [A0 []].
assert(HA' := l10_15 C0 P P A0).
destruct HA' as [A' []]; Col.
assert_diffs.
elim(col_dec A0 P A').
-
intro.
apply (proclus_bis A0 P); Col; [| |intro; apply HNCol; ColR].
exists C0.
exists P.
split; Col.
split; [|Perp].

*****
H14 : Col A0 P A'
H18 : not (eq C0 A')
H17 : not (eq A' P)
H19 : not (eq C0 A0)
H16 : not (eq P A0)
H13 : OS C0 P A0 A'
H11 : Perp C0 P A' P
A' : Tpoint
H2 : not (Col C0 P A0)
H1 : Col A B A0
A0 : Tpoint
H10 : not (eq P C0)
H12 : not (eq A Q)
H8 : not (eq B Q)
H9 : not (eq C P)
H5 : not (eq D P)
H7 : not (eq C D)
H6 : not (eq C0 B)
H3 : not (eq A B)
H4 : not (eq C0 A)
HNCol2 : not (Col C0 A B)
H0 : Perp C D P C0
H : Col C D C0
C0 : Tpoint
HNCol1 : not (Col C D P)
HCop : Coplanar C D P Q
HNCol : not (Col A B Q)
HInter : Col A B P
HPar : Par_strict C D A B
A,B,C,D,P,Q : Tpoint
proclus_bis : alternative_proclus_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Perp C0 P A0 P
+++++
apply perp_right_comm.
-----
Lemma proclus_bis__proclus : alternative_proclus_postulate -> proclus_postulate.
Proof.
intros proclus_bis A B C D P Q HPar HInter HNCol HCop.
elim(col_dec C D P).
intro; exists P; Col.
intro HNCol1.
apply par_symmetry in HPar.
apply (par_not_col_strict _ _ _ _ P) in HPar; auto.
assert(HC0 := l8_18_existence C D P).
destruct HC0 as [C0 []]; auto.
assert(HNCol2 : ~ Col C0 A B) by (apply (par_not_col C D); Col).
assert_diffs.
assert(HA0 : exists A0, Col A B A0 /\\ ~ Col C0 P A0).
destruct HA0 as [A0 []].
assert(HA' := l10_15 C0 P P A0).
destruct HA' as [A' []]; Col.
assert_diffs.
elim(col_dec A0 P A').
-
intro.
apply (proclus_bis A0 P); Col; [| |intro; apply HNCol; ColR].
exists C0.
exists P.
split; Col.
split; [|Perp].
apply perp_right_comm.

*****
H14 : Col A0 P A'
H18 : not (eq C0 A')
H17 : not (eq A' P)
H19 : not (eq C0 A0)
H16 : not (eq P A0)
H13 : OS C0 P A0 A'
H11 : Perp C0 P A' P
A' : Tpoint
H2 : not (Col C0 P A0)
H1 : Col A B A0
A0 : Tpoint
H10 : not (eq P C0)
H12 : not (eq A Q)
H8 : not (eq B Q)
H9 : not (eq C P)
H5 : not (eq D P)
H7 : not (eq C D)
H6 : not (eq C0 B)
H3 : not (eq A B)
H4 : not (eq C0 A)
HNCol2 : not (Col C0 A B)
H0 : Perp C D P C0
H : Col C D C0
C0 : Tpoint
HNCol1 : not (Col C D P)
HCop : Coplanar C D P Q
HNCol : not (Col A B Q)
HInter : Col A B P
HPar : Par_strict C D A B
A,B,C,D,P,Q : Tpoint
proclus_bis : alternative_proclus_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Perp C0 P P A0
+++++
apply (perp_col1 _ _ _ A'); Perp; Col.
-----
Lemma proclus_bis__proclus : alternative_proclus_postulate -> proclus_postulate.
Proof.
intros proclus_bis A B C D P Q HPar HInter HNCol HCop.
elim(col_dec C D P).
intro; exists P; Col.
intro HNCol1.
apply par_symmetry in HPar.
apply (par_not_col_strict _ _ _ _ P) in HPar; auto.
assert(HC0 := l8_18_existence C D P).
destruct HC0 as [C0 []]; auto.
assert(HNCol2 : ~ Col C0 A B) by (apply (par_not_col C D); Col).
assert_diffs.
assert(HA0 : exists A0, Col A B A0 /\\ ~ Col C0 P A0).
destruct HA0 as [A0 []].
assert(HA' := l10_15 C0 P P A0).
destruct HA' as [A' []]; Col.
assert_diffs.
elim(col_dec A0 P A').
-
intro.
apply (proclus_bis A0 P); Col; [| |intro; apply HNCol; ColR].

*****
H14 : Col A0 P A'
H18 : not (eq C0 A')
H17 : not (eq A' P)
H19 : not (eq C0 A0)
H16 : not (eq P A0)
H13 : OS C0 P A0 A'
H11 : Perp C0 P A' P
A' : Tpoint
H2 : not (Col C0 P A0)
H1 : Col A B A0
A0 : Tpoint
H10 : not (eq P C0)
H12 : not (eq A Q)
H8 : not (eq B Q)
H9 : not (eq C P)
H5 : not (eq D P)
H7 : not (eq C D)
H6 : not (eq C0 B)
H3 : not (eq A B)
H4 : not (eq C0 A)
HNCol2 : not (Col C0 A B)
H0 : Perp C D P C0
H : Col C D C0
C0 : Tpoint
HNCol1 : not (Col C D P)
HCop : Coplanar C D P Q
HNCol : not (Col A B Q)
HInter : Col A B P
HPar : Par_strict C D A B
A,B,C,D,P,Q : Tpoint
proclus_bis : alternative_proclus_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar A0 P C D
+++++
apply pars__coplanar in HPar.
-----
Lemma proclus_bis__proclus : alternative_proclus_postulate -> proclus_postulate.
Proof.
intros proclus_bis A B C D P Q HPar HInter HNCol HCop.
elim(col_dec C D P).
intro; exists P; Col.
intro HNCol1.
apply par_symmetry in HPar.
apply (par_not_col_strict _ _ _ _ P) in HPar; auto.
assert(HC0 := l8_18_existence C D P).
destruct HC0 as [C0 []]; auto.
assert(HNCol2 : ~ Col C0 A B) by (apply (par_not_col C D); Col).
assert_diffs.
assert(HA0 : exists A0, Col A B A0 /\\ ~ Col C0 P A0).
destruct HA0 as [A0 []].
assert(HA' := l10_15 C0 P P A0).
destruct HA' as [A' []]; Col.
assert_diffs.
elim(col_dec A0 P A').
-
intro.
apply (proclus_bis A0 P); Col; [| |intro; apply HNCol; ColR].
apply pars__coplanar in HPar.

*****
H14 : Col A0 P A'
H18 : not (eq C0 A')
H17 : not (eq A' P)
H19 : not (eq C0 A0)
H16 : not (eq P A0)
H13 : OS C0 P A0 A'
H11 : Perp C0 P A' P
A' : Tpoint
H2 : not (Col C0 P A0)
H1 : Col A B A0
A0 : Tpoint
H10 : not (eq P C0)
H12 : not (eq A Q)
H8 : not (eq B Q)
H9 : not (eq C P)
H5 : not (eq D P)
H7 : not (eq C D)
H6 : not (eq C0 B)
H3 : not (eq A B)
H4 : not (eq C0 A)
HNCol2 : not (Col C0 A B)
H0 : Perp C D P C0
H : Col C D C0
C0 : Tpoint
HNCol1 : not (Col C D P)
HCop : Coplanar C D P Q
HNCol : not (Col A B Q)
HInter : Col A B P
HPar : Coplanar C D A B
A,B,C,D,P,Q : Tpoint
proclus_bis : alternative_proclus_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar A0 P C D
+++++
assert (Coplanar C D P A0) by (apply col2_cop__cop with A B; Col; Cop).
-----
Lemma proclus_bis__proclus : alternative_proclus_postulate -> proclus_postulate.
Proof.
intros proclus_bis A B C D P Q HPar HInter HNCol HCop.
elim(col_dec C D P).
intro; exists P; Col.
intro HNCol1.
apply par_symmetry in HPar.
apply (par_not_col_strict _ _ _ _ P) in HPar; auto.
assert(HC0 := l8_18_existence C D P).
destruct HC0 as [C0 []]; auto.
assert(HNCol2 : ~ Col C0 A B) by (apply (par_not_col C D); Col).
assert_diffs.
assert(HA0 : exists A0, Col A B A0 /\\ ~ Col C0 P A0).
destruct HA0 as [A0 []].
assert(HA' := l10_15 C0 P P A0).
destruct HA' as [A' []]; Col.
assert_diffs.
elim(col_dec A0 P A').
-
intro.
apply (proclus_bis A0 P); Col; [| |intro; apply HNCol; ColR].
apply pars__coplanar in HPar.
assert (Coplanar C D P A0) by (apply col2_cop__cop with A B; Col; Cop).

*****
H15 : Coplanar C D P A0
H14 : Col A0 P A'
H18 : not (eq C0 A')
H17 : not (eq A' P)
H19 : not (eq C0 A0)
H16 : not (eq P A0)
H13 : OS C0 P A0 A'
H11 : Perp C0 P A' P
A' : Tpoint
H2 : not (Col C0 P A0)
H1 : Col A B A0
A0 : Tpoint
H10 : not (eq P C0)
H12 : not (eq A Q)
H8 : not (eq B Q)
H9 : not (eq C P)
H5 : not (eq D P)
H7 : not (eq C D)
H6 : not (eq C0 B)
H3 : not (eq A B)
H4 : not (eq C0 A)
HNCol2 : not (Col C0 A B)
H0 : Perp C D P C0
H : Col C D C0
C0 : Tpoint
HNCol1 : not (Col C D P)
HCop : Coplanar C D P Q
HNCol : not (Col A B Q)
HInter : Col A B P
HPar : Coplanar C D A B
A,B,C,D,P,Q : Tpoint
proclus_bis : alternative_proclus_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar A0 P C D
+++++
CopR.
-----
Lemma proclus_bis__proclus : alternative_proclus_postulate -> proclus_postulate.
Proof.
intros proclus_bis A B C D P Q HPar HInter HNCol HCop.
elim(col_dec C D P).
intro; exists P; Col.
intro HNCol1.
apply par_symmetry in HPar.
apply (par_not_col_strict _ _ _ _ P) in HPar; auto.
assert(HC0 := l8_18_existence C D P).
destruct HC0 as [C0 []]; auto.
assert(HNCol2 : ~ Col C0 A B) by (apply (par_not_col C D); Col).
assert_diffs.
assert(HA0 : exists A0, Col A B A0 /\\ ~ Col C0 P A0).
destruct HA0 as [A0 []].
assert(HA' := l10_15 C0 P P A0).
destruct HA' as [A' []]; Col.
assert_diffs.
elim(col_dec A0 P A').
-
intro.
apply (proclus_bis A0 P); Col; [| |intro; apply HNCol; ColR].

*****

*****

+++++
-
-----
Lemma proclus_bis__proclus : alternative_proclus_postulate -> proclus_postulate.
Proof.
intros proclus_bis A B C D P Q HPar HInter HNCol HCop.
elim(col_dec C D P).
intro; exists P; Col.
intro HNCol1.
apply par_symmetry in HPar.
apply (par_not_col_strict _ _ _ _ P) in HPar; auto.
assert(HC0 := l8_18_existence C D P).
destruct HC0 as [C0 []]; auto.
assert(HNCol2 : ~ Col C0 A B) by (apply (par_not_col C D); Col).
assert_diffs.
assert(HA0 : exists A0, Col A B A0 /\\ ~ Col C0 P A0).
destruct HA0 as [A0 []].
assert(HA' := l10_15 C0 P P A0).
destruct HA' as [A' []]; Col.
assert_diffs.
elim(col_dec A0 P A').
-
intro.
apply (proclus_bis A0 P); Col; [| |intro; apply HNCol; ColR].
-

*****
H18 : not (eq C0 A')
H17 : not (eq A' P)
H19 : not (eq C0 A0)
H16 : not (eq P A0)
H13 : OS C0 P A0 A'
H11 : Perp C0 P A' P
A' : Tpoint
H2 : not (Col C0 P A0)
H1 : Col A B A0
A0 : Tpoint
H10 : not (eq P C0)
H12 : not (eq A Q)
H8 : not (eq B Q)
H9 : not (eq C P)
H5 : not (eq D P)
H7 : not (eq C D)
H6 : not (eq C0 B)
H3 : not (eq A B)
H4 : not (eq C0 A)
HNCol2 : not (Col C0 A B)
H0 : Perp C D P C0
H : Col C D C0
C0 : Tpoint
HNCol1 : not (Col C D P)
HCop : Coplanar C D P Q
HNCol : not (Col A B Q)
HInter : Col A B P
HPar : Par_strict C D A B
A,B,C,D,P,Q : Tpoint
proclus_bis : alternative_proclus_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : not (Col A0 P A'), ex (fun Y : Tpoint => and (Col P Q Y) (Col C D Y))
+++++
intro.
-----
Lemma proclus_bis__proclus : alternative_proclus_postulate -> proclus_postulate.
Proof.
intros proclus_bis A B C D P Q HPar HInter HNCol HCop.
elim(col_dec C D P).
intro; exists P; Col.
intro HNCol1.
apply par_symmetry in HPar.
apply (par_not_col_strict _ _ _ _ P) in HPar; auto.
assert(HC0 := l8_18_existence C D P).
destruct HC0 as [C0 []]; auto.
assert(HNCol2 : ~ Col C0 A B) by (apply (par_not_col C D); Col).
assert_diffs.
assert(HA0 : exists A0, Col A B A0 /\\ ~ Col C0 P A0).
destruct HA0 as [A0 []].
assert(HA' := l10_15 C0 P P A0).
destruct HA' as [A' []]; Col.
assert_diffs.
elim(col_dec A0 P A').
-
intro.
apply (proclus_bis A0 P); Col; [| |intro; apply HNCol; ColR].
-
intro.

*****
H14 : not (Col A0 P A')
H18 : not (eq C0 A')
H17 : not (eq A' P)
H19 : not (eq C0 A0)
H16 : not (eq P A0)
H13 : OS C0 P A0 A'
H11 : Perp C0 P A' P
A' : Tpoint
H2 : not (Col C0 P A0)
H1 : Col A B A0
A0 : Tpoint
H10 : not (eq P C0)
H12 : not (eq A Q)
H8 : not (eq B Q)
H9 : not (eq C P)
H5 : not (eq D P)
H7 : not (eq C D)
H6 : not (eq C0 B)
H3 : not (eq A B)
H4 : not (eq C0 A)
HNCol2 : not (Col C0 A B)
H0 : Perp C D P C0
H : Col C D C0
C0 : Tpoint
HNCol1 : not (Col C D P)
HCop : Coplanar C D P Q
HNCol : not (Col A B Q)
HInter : Col A B P
HPar : Par_strict C D A B
A,B,C,D,P,Q : Tpoint
proclus_bis : alternative_proclus_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Y : Tpoint => and (Col P Q Y) (Col C D Y))
+++++
exfalso.
-----
Lemma proclus_bis__proclus : alternative_proclus_postulate -> proclus_postulate.
Proof.
intros proclus_bis A B C D P Q HPar HInter HNCol HCop.
elim(col_dec C D P).
intro; exists P; Col.
intro HNCol1.
apply par_symmetry in HPar.
apply (par_not_col_strict _ _ _ _ P) in HPar; auto.
assert(HC0 := l8_18_existence C D P).
destruct HC0 as [C0 []]; auto.
assert(HNCol2 : ~ Col C0 A B) by (apply (par_not_col C D); Col).
assert_diffs.
assert(HA0 : exists A0, Col A B A0 /\\ ~ Col C0 P A0).
destruct HA0 as [A0 []].
assert(HA' := l10_15 C0 P P A0).
destruct HA' as [A' []]; Col.
assert_diffs.
elim(col_dec A0 P A').
-
intro.
apply (proclus_bis A0 P); Col; [| |intro; apply HNCol; ColR].
-
intro.
exfalso.

*****
H14 : not (Col A0 P A')
H18 : not (eq C0 A')
H17 : not (eq A' P)
H19 : not (eq C0 A0)
H16 : not (eq P A0)
H13 : OS C0 P A0 A'
H11 : Perp C0 P A' P
A' : Tpoint
H2 : not (Col C0 P A0)
H1 : Col A B A0
A0 : Tpoint
H10 : not (eq P C0)
H12 : not (eq A Q)
H8 : not (eq B Q)
H9 : not (eq C P)
H5 : not (eq D P)
H7 : not (eq C D)
H6 : not (eq C0 B)
H3 : not (eq A B)
H4 : not (eq C0 A)
HNCol2 : not (Col C0 A B)
H0 : Perp C D P C0
H : Col C D C0
C0 : Tpoint
HNCol1 : not (Col C D P)
HCop : Coplanar C D P Q
HNCol : not (Col A B Q)
HInter : Col A B P
HPar : Par_strict C D A B
A,B,C,D,P,Q : Tpoint
proclus_bis : alternative_proclus_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
assert(HY := proclus_bis A' P C D P A0).
-----
Lemma proclus_bis__proclus : alternative_proclus_postulate -> proclus_postulate.
Proof.
intros proclus_bis A B C D P Q HPar HInter HNCol HCop.
elim(col_dec C D P).
intro; exists P; Col.
intro HNCol1.
apply par_symmetry in HPar.
apply (par_not_col_strict _ _ _ _ P) in HPar; auto.
assert(HC0 := l8_18_existence C D P).
destruct HC0 as [C0 []]; auto.
assert(HNCol2 : ~ Col C0 A B) by (apply (par_not_col C D); Col).
assert_diffs.
assert(HA0 : exists A0, Col A B A0 /\\ ~ Col C0 P A0).
destruct HA0 as [A0 []].
assert(HA' := l10_15 C0 P P A0).
destruct HA' as [A' []]; Col.
assert_diffs.
elim(col_dec A0 P A').
-
intro.
apply (proclus_bis A0 P); Col; [| |intro; apply HNCol; ColR].
-
intro.
exfalso.
assert(HY := proclus_bis A' P C D P A0).

*****
HY : forall (_ : Perp2 A' P C D P) (_ : not (Col C D P))\n (_ : Coplanar A' P C D) (_ : Col A' P P) (_ : not (Col A' P A0))\n (_ : Coplanar C D P A0),\nex (fun Y : Tpoint => and (Col P A0 Y) (Col C D Y))
H14 : not (Col A0 P A')
H18 : not (eq C0 A')
H17 : not (eq A' P)
H19 : not (eq C0 A0)
H16 : not (eq P A0)
H13 : OS C0 P A0 A'
H11 : Perp C0 P A' P
A' : Tpoint
H2 : not (Col C0 P A0)
H1 : Col A B A0
A0 : Tpoint
H10 : not (eq P C0)
H12 : not (eq A Q)
H8 : not (eq B Q)
H9 : not (eq C P)
H5 : not (eq D P)
H7 : not (eq C D)
H6 : not (eq C0 B)
H3 : not (eq A B)
H4 : not (eq C0 A)
HNCol2 : not (Col C0 A B)
H0 : Perp C D P C0
H : Col C D C0
C0 : Tpoint
HNCol1 : not (Col C D P)
HCop : Coplanar C D P Q
HNCol : not (Col A B Q)
HInter : Col A B P
HPar : Par_strict C D A B
A,B,C,D,P,Q : Tpoint
proclus_bis : alternative_proclus_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
assert (Coplanar C D P A0).
-----
Lemma proclus_bis__proclus : alternative_proclus_postulate -> proclus_postulate.
Proof.
intros proclus_bis A B C D P Q HPar HInter HNCol HCop.
elim(col_dec C D P).
intro; exists P; Col.
intro HNCol1.
apply par_symmetry in HPar.
apply (par_not_col_strict _ _ _ _ P) in HPar; auto.
assert(HC0 := l8_18_existence C D P).
destruct HC0 as [C0 []]; auto.
assert(HNCol2 : ~ Col C0 A B) by (apply (par_not_col C D); Col).
assert_diffs.
assert(HA0 : exists A0, Col A B A0 /\\ ~ Col C0 P A0).
destruct HA0 as [A0 []].
assert(HA' := l10_15 C0 P P A0).
destruct HA' as [A' []]; Col.
assert_diffs.
elim(col_dec A0 P A').
-
intro.
apply (proclus_bis A0 P); Col; [| |intro; apply HNCol; ColR].
-
intro.
exfalso.
assert(HY := proclus_bis A' P C D P A0).
assert (Coplanar C D P A0).

*****
HY : forall (_ : Perp2 A' P C D P) (_ : not (Col C D P))\n (_ : Coplanar A' P C D) (_ : Col A' P P) (_ : not (Col A' P A0))\n (_ : Coplanar C D P A0),\nex (fun Y : Tpoint => and (Col P A0 Y) (Col C D Y))
H14 : not (Col A0 P A')
H18 : not (eq C0 A')
H17 : not (eq A' P)
H19 : not (eq C0 A0)
H16 : not (eq P A0)
H13 : OS C0 P A0 A'
H11 : Perp C0 P A' P
A' : Tpoint
H2 : not (Col C0 P A0)
H1 : Col A B A0
A0 : Tpoint
H10 : not (eq P C0)
H12 : not (eq A Q)
H8 : not (eq B Q)
H9 : not (eq C P)
H5 : not (eq D P)
H7 : not (eq C D)
H6 : not (eq C0 B)
H3 : not (eq A B)
H4 : not (eq C0 A)
HNCol2 : not (Col C0 A B)
H0 : Perp C D P C0
H : Col C D C0
C0 : Tpoint
HNCol1 : not (Col C D P)
HCop : Coplanar C D P Q
HNCol : not (Col A B Q)
HInter : Col A B P
HPar : Par_strict C D A B
A,B,C,D,P,Q : Tpoint
proclus_bis : alternative_proclus_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar C D P A0
+++++
apply pars__coplanar in HPar.
-----
Lemma proclus_bis__proclus : alternative_proclus_postulate -> proclus_postulate.
Proof.
intros proclus_bis A B C D P Q HPar HInter HNCol HCop.
elim(col_dec C D P).
intro; exists P; Col.
intro HNCol1.
apply par_symmetry in HPar.
apply (par_not_col_strict _ _ _ _ P) in HPar; auto.
assert(HC0 := l8_18_existence C D P).
destruct HC0 as [C0 []]; auto.
assert(HNCol2 : ~ Col C0 A B) by (apply (par_not_col C D); Col).
assert_diffs.
assert(HA0 : exists A0, Col A B A0 /\\ ~ Col C0 P A0).
destruct HA0 as [A0 []].
assert(HA' := l10_15 C0 P P A0).
destruct HA' as [A' []]; Col.
assert_diffs.
elim(col_dec A0 P A').
-
intro.
apply (proclus_bis A0 P); Col; [| |intro; apply HNCol; ColR].
-
intro.
exfalso.
assert(HY := proclus_bis A' P C D P A0).
assert (Coplanar C D P A0).
apply pars__coplanar in HPar.

*****
HY : forall (_ : Perp2 A' P C D P) (_ : not (Col C D P))\n (_ : Coplanar A' P C D) (_ : Col A' P P) (_ : not (Col A' P A0))\n (_ : Coplanar C D P A0),\nex (fun Y : Tpoint => and (Col P A0 Y) (Col C D Y))
H14 : not (Col A0 P A')
H18 : not (eq C0 A')
H17 : not (eq A' P)
H19 : not (eq C0 A0)
H16 : not (eq P A0)
H13 : OS C0 P A0 A'
H11 : Perp C0 P A' P
A' : Tpoint
H2 : not (Col C0 P A0)
H1 : Col A B A0
A0 : Tpoint
H10 : not (eq P C0)
H12 : not (eq A Q)
H8 : not (eq B Q)
H9 : not (eq C P)
H5 : not (eq D P)
H7 : not (eq C D)
H6 : not (eq C0 B)
H3 : not (eq A B)
H4 : not (eq C0 A)
HNCol2 : not (Col C0 A B)
H0 : Perp C D P C0
H : Col C D C0
C0 : Tpoint
HNCol1 : not (Col C D P)
HCop : Coplanar C D P Q
HNCol : not (Col A B Q)
HInter : Col A B P
HPar : Coplanar C D A B
A,B,C,D,P,Q : Tpoint
proclus_bis : alternative_proclus_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar C D P A0
+++++
assert (Coplanar C D P A0) by (apply col2_cop__cop with A B; Col; Cop).
-----
Lemma proclus_bis__proclus : alternative_proclus_postulate -> proclus_postulate.
Proof.
intros proclus_bis A B C D P Q HPar HInter HNCol HCop.
elim(col_dec C D P).
intro; exists P; Col.
intro HNCol1.
apply par_symmetry in HPar.
apply (par_not_col_strict _ _ _ _ P) in HPar; auto.
assert(HC0 := l8_18_existence C D P).
destruct HC0 as [C0 []]; auto.
assert(HNCol2 : ~ Col C0 A B) by (apply (par_not_col C D); Col).
assert_diffs.
assert(HA0 : exists A0, Col A B A0 /\\ ~ Col C0 P A0).
destruct HA0 as [A0 []].
assert(HA' := l10_15 C0 P P A0).
destruct HA' as [A' []]; Col.
assert_diffs.
elim(col_dec A0 P A').
-
intro.
apply (proclus_bis A0 P); Col; [| |intro; apply HNCol; ColR].
-
intro.
exfalso.
assert(HY := proclus_bis A' P C D P A0).
assert (Coplanar C D P A0).
apply pars__coplanar in HPar.
assert (Coplanar C D P A0) by (apply col2_cop__cop with A B; Col; Cop).

*****
H15 : Coplanar C D P A0
HY : forall (_ : Perp2 A' P C D P) (_ : not (Col C D P))\n (_ : Coplanar A' P C D) (_ : Col A' P P) (_ : not (Col A' P A0))\n (_ : Coplanar C D P A0),\nex (fun Y : Tpoint => and (Col P A0 Y) (Col C D Y))
H14 : not (Col A0 P A')
H18 : not (eq C0 A')
H17 : not (eq A' P)
H19 : not (eq C0 A0)
H16 : not (eq P A0)
H13 : OS C0 P A0 A'
H11 : Perp C0 P A' P
A' : Tpoint
H2 : not (Col C0 P A0)
H1 : Col A B A0
A0 : Tpoint
H10 : not (eq P C0)
H12 : not (eq A Q)
H8 : not (eq B Q)
H9 : not (eq C P)
H5 : not (eq D P)
H7 : not (eq C D)
H6 : not (eq C0 B)
H3 : not (eq A B)
H4 : not (eq C0 A)
HNCol2 : not (Col C0 A B)
H0 : Perp C D P C0
H : Col C D C0
C0 : Tpoint
HNCol1 : not (Col C D P)
HCop : Coplanar C D P Q
HNCol : not (Col A B Q)
HInter : Col A B P
HPar : Coplanar C D A B
A,B,C,D,P,Q : Tpoint
proclus_bis : alternative_proclus_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar C D P A0
+++++
CopR.
-----
Lemma proclus_bis__proclus : alternative_proclus_postulate -> proclus_postulate.
Proof.
intros proclus_bis A B C D P Q HPar HInter HNCol HCop.
elim(col_dec C D P).
intro; exists P; Col.
intro HNCol1.
apply par_symmetry in HPar.
apply (par_not_col_strict _ _ _ _ P) in HPar; auto.
assert(HC0 := l8_18_existence C D P).
destruct HC0 as [C0 []]; auto.
assert(HNCol2 : ~ Col C0 A B) by (apply (par_not_col C D); Col).
assert_diffs.
assert(HA0 : exists A0, Col A B A0 /\\ ~ Col C0 P A0).
destruct HA0 as [A0 []].
assert(HA' := l10_15 C0 P P A0).
destruct HA' as [A' []]; Col.
assert_diffs.
elim(col_dec A0 P A').
-
intro.
apply (proclus_bis A0 P); Col; [| |intro; apply HNCol; ColR].
-
intro.
exfalso.
assert(HY := proclus_bis A' P C D P A0).
assert (Coplanar C D P A0).

*****
H15 : Coplanar C D P A0
HY : forall (_ : Perp2 A' P C D P) (_ : not (Col C D P))\n (_ : Coplanar A' P C D) (_ : Col A' P P) (_ : not (Col A' P A0))\n (_ : Coplanar C D P A0),\nex (fun Y : Tpoint => and (Col P A0 Y) (Col C D Y))
H14 : not (Col A0 P A')
H18 : not (eq C0 A')
H17 : not (eq A' P)
H19 : not (eq C0 A0)
H16 : not (eq P A0)
H13 : OS C0 P A0 A'
H11 : Perp C0 P A' P
A' : Tpoint
H2 : not (Col C0 P A0)
H1 : Col A B A0
A0 : Tpoint
H10 : not (eq P C0)
H12 : not (eq A Q)
H8 : not (eq B Q)
H9 : not (eq C P)
H5 : not (eq D P)
H7 : not (eq C D)
H6 : not (eq C0 B)
H3 : not (eq A B)
H4 : not (eq C0 A)
HNCol2 : not (Col C0 A B)
H0 : Perp C D P C0
H : Col C D C0
C0 : Tpoint
HNCol1 : not (Col C D P)
HCop : Coplanar C D P Q
HNCol : not (Col A B Q)
HInter : Col A B P
HPar : Par_strict C D A B
A,B,C,D,P,Q : Tpoint
proclus_bis : alternative_proclus_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
destruct HY as [Y []]; Col.
-----
Lemma proclus_bis__proclus : alternative_proclus_postulate -> proclus_postulate.
Proof.
intros proclus_bis A B C D P Q HPar HInter HNCol HCop.
elim(col_dec C D P).
intro; exists P; Col.
intro HNCol1.
apply par_symmetry in HPar.
apply (par_not_col_strict _ _ _ _ P) in HPar; auto.
assert(HC0 := l8_18_existence C D P).
destruct HC0 as [C0 []]; auto.
assert(HNCol2 : ~ Col C0 A B) by (apply (par_not_col C D); Col).
assert_diffs.
assert(HA0 : exists A0, Col A B A0 /\\ ~ Col C0 P A0).
destruct HA0 as [A0 []].
assert(HA' := l10_15 C0 P P A0).
destruct HA' as [A' []]; Col.
assert_diffs.
elim(col_dec A0 P A').
-
intro.
apply (proclus_bis A0 P); Col; [| |intro; apply HNCol; ColR].
-
intro.
exfalso.
assert(HY := proclus_bis A' P C D P A0).
assert (Coplanar C D P A0).
destruct HY as [Y []]; Col.

*****
H15 : Coplanar C D P A0
H14 : not (Col A0 P A')
H18 : not (eq C0 A')
H17 : not (eq A' P)
H19 : not (eq C0 A0)
H16 : not (eq P A0)
H13 : OS C0 P A0 A'
H11 : Perp C0 P A' P
A' : Tpoint
H2 : not (Col C0 P A0)
H1 : Col A B A0
A0 : Tpoint
H10 : not (eq P C0)
H12 : not (eq A Q)
H8 : not (eq B Q)
H9 : not (eq C P)
H5 : not (eq D P)
H7 : not (eq C D)
H6 : not (eq C0 B)
H3 : not (eq A B)
H4 : not (eq C0 A)
HNCol2 : not (Col C0 A B)
H0 : Perp C D P C0
H : Col C D C0
C0 : Tpoint
HNCol1 : not (Col C D P)
HCop : Coplanar C D P Q
HNCol : not (Col A B Q)
HInter : Col A B P
HPar : Par_strict C D A B
A,B,C,D,P,Q : Tpoint
proclus_bis : alternative_proclus_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Perp2 A' P C D P
+++++
exists C0; exists P; repeat split; Col; Perp.
-----
Lemma proclus_bis__proclus : alternative_proclus_postulate -> proclus_postulate.
Proof.
intros proclus_bis A B C D P Q HPar HInter HNCol HCop.
elim(col_dec C D P).
intro; exists P; Col.
intro HNCol1.
apply par_symmetry in HPar.
apply (par_not_col_strict _ _ _ _ P) in HPar; auto.
assert(HC0 := l8_18_existence C D P).
destruct HC0 as [C0 []]; auto.
assert(HNCol2 : ~ Col C0 A B) by (apply (par_not_col C D); Col).
assert_diffs.
assert(HA0 : exists A0, Col A B A0 /\\ ~ Col C0 P A0).
destruct HA0 as [A0 []].
assert(HA' := l10_15 C0 P P A0).
destruct HA' as [A' []]; Col.
assert_diffs.
elim(col_dec A0 P A').
-
intro.
apply (proclus_bis A0 P); Col; [| |intro; apply HNCol; ColR].
-
intro.
exfalso.
assert(HY := proclus_bis A' P C D P A0).
assert (Coplanar C D P A0).
destruct HY as [Y []]; Col.

*****
H15 : Coplanar C D P A0
H14 : not (Col A0 P A')
H18 : not (eq C0 A')
H17 : not (eq A' P)
H19 : not (eq C0 A0)
H16 : not (eq P A0)
H13 : OS C0 P A0 A'
H11 : Perp C0 P A' P
A' : Tpoint
H2 : not (Col C0 P A0)
H1 : Col A B A0
A0 : Tpoint
H10 : not (eq P C0)
H12 : not (eq A Q)
H8 : not (eq B Q)
H9 : not (eq C P)
H5 : not (eq D P)
H7 : not (eq C D)
H6 : not (eq C0 B)
H3 : not (eq A B)
H4 : not (eq C0 A)
HNCol2 : not (Col C0 A B)
H0 : Perp C D P C0
H : Col C D C0
C0 : Tpoint
HNCol1 : not (Col C D P)
HCop : Coplanar C D P Q
HNCol : not (Col A B Q)
HInter : Col A B P
HPar : Par_strict C D A B
A,B,C,D,P,Q : Tpoint
proclus_bis : alternative_proclus_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar A' P C D
+++++
assert (Coplanar P A0 A' C0) by Cop.
-----
Lemma proclus_bis__proclus : alternative_proclus_postulate -> proclus_postulate.
Proof.
intros proclus_bis A B C D P Q HPar HInter HNCol HCop.
elim(col_dec C D P).
intro; exists P; Col.
intro HNCol1.
apply par_symmetry in HPar.
apply (par_not_col_strict _ _ _ _ P) in HPar; auto.
assert(HC0 := l8_18_existence C D P).
destruct HC0 as [C0 []]; auto.
assert(HNCol2 : ~ Col C0 A B) by (apply (par_not_col C D); Col).
assert_diffs.
assert(HA0 : exists A0, Col A B A0 /\\ ~ Col C0 P A0).
destruct HA0 as [A0 []].
assert(HA' := l10_15 C0 P P A0).
destruct HA' as [A' []]; Col.
assert_diffs.
elim(col_dec A0 P A').
-
intro.
apply (proclus_bis A0 P); Col; [| |intro; apply HNCol; ColR].
-
intro.
exfalso.
assert(HY := proclus_bis A' P C D P A0).
assert (Coplanar C D P A0).
destruct HY as [Y []]; Col.
assert (Coplanar P A0 A' C0) by Cop.

*****
H20 : Coplanar P A0 A' C0
H15 : Coplanar C D P A0
H14 : not (Col A0 P A')
H18 : not (eq C0 A')
H17 : not (eq A' P)
H19 : not (eq C0 A0)
H16 : not (eq P A0)
H13 : OS C0 P A0 A'
H11 : Perp C0 P A' P
A' : Tpoint
H2 : not (Col C0 P A0)
H1 : Col A B A0
A0 : Tpoint
H10 : not (eq P C0)
H12 : not (eq A Q)
H8 : not (eq B Q)
H9 : not (eq C P)
H5 : not (eq D P)
H7 : not (eq C D)
H6 : not (eq C0 B)
H3 : not (eq A B)
H4 : not (eq C0 A)
HNCol2 : not (Col C0 A B)
H0 : Perp C D P C0
H : Col C D C0
C0 : Tpoint
HNCol1 : not (Col C D P)
HCop : Coplanar C D P Q
HNCol : not (Col A B Q)
HInter : Col A B P
HPar : Par_strict C D A B
A,B,C,D,P,Q : Tpoint
proclus_bis : alternative_proclus_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar A' P C D
+++++
elim (eq_dec_points C0 C); intro; treat_equalities; elim (eq_dec_points C0 D); intro; treat_equalities; auto; try CopR.
-----
Lemma proclus_bis__proclus : alternative_proclus_postulate -> proclus_postulate.
Proof.
intros proclus_bis A B C D P Q HPar HInter HNCol HCop.
elim(col_dec C D P).
intro; exists P; Col.
intro HNCol1.
apply par_symmetry in HPar.
apply (par_not_col_strict _ _ _ _ P) in HPar; auto.
assert(HC0 := l8_18_existence C D P).
destruct HC0 as [C0 []]; auto.
assert(HNCol2 : ~ Col C0 A B) by (apply (par_not_col C D); Col).
assert_diffs.
assert(HA0 : exists A0, Col A B A0 /\\ ~ Col C0 P A0).
destruct HA0 as [A0 []].
assert(HA' := l10_15 C0 P P A0).
destruct HA' as [A' []]; Col.
assert_diffs.
elim(col_dec A0 P A').
-
intro.
apply (proclus_bis A0 P); Col; [| |intro; apply HNCol; ColR].
-
intro.
exfalso.
assert(HY := proclus_bis A' P C D P A0).
assert (Coplanar C D P A0).
destruct HY as [Y []]; Col.
assert (Coplanar P A0 A' C0) by Cop.
elim (eq_dec_points C0 C); intro; treat_equalities; elim (eq_dec_points C0 D); intro; treat_equalities; auto; try CopR.

*****
H22 : not (eq C0 D)
H21 : not (eq C0 C)
H20 : Coplanar P A0 A' C0
H15 : Coplanar C D P A0
H14 : not (Col A0 P A')
H18 : not (eq C0 A')
H17 : not (eq A' P)
H19 : not (eq C0 A0)
H16 : not (eq P A0)
H13 : OS C0 P A0 A'
H11 : Perp C0 P A' P
A' : Tpoint
H2 : not (Col C0 P A0)
H1 : Col A B A0
A0 : Tpoint
H10 : not (eq P C0)
H12 : not (eq A Q)
H8 : not (eq B Q)
H9 : not (eq C P)
H5 : not (eq D P)
H7 : not (eq C D)
H6 : not (eq C0 B)
H3 : not (eq A B)
H4 : not (eq C0 A)
HNCol2 : not (Col C0 A B)
H0 : Perp C D P C0
H : Col C D C0
C0 : Tpoint
HNCol1 : not (Col C D P)
HCop : Coplanar C D P Q
HNCol : not (Col A B Q)
HInter : Col A B P
HPar : Par_strict C D A B
A,B,C,D,P,Q : Tpoint
proclus_bis : alternative_proclus_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar A' P C D
+++++
assert (Coplanar P A0 C C0) by (apply col2_cop__cop with C D; Col; Cop).
-----
Lemma proclus_bis__proclus : alternative_proclus_postulate -> proclus_postulate.
Proof.
intros proclus_bis A B C D P Q HPar HInter HNCol HCop.
elim(col_dec C D P).
intro; exists P; Col.
intro HNCol1.
apply par_symmetry in HPar.
apply (par_not_col_strict _ _ _ _ P) in HPar; auto.
assert(HC0 := l8_18_existence C D P).
destruct HC0 as [C0 []]; auto.
assert(HNCol2 : ~ Col C0 A B) by (apply (par_not_col C D); Col).
assert_diffs.
assert(HA0 : exists A0, Col A B A0 /\\ ~ Col C0 P A0).
destruct HA0 as [A0 []].
assert(HA' := l10_15 C0 P P A0).
destruct HA' as [A' []]; Col.
assert_diffs.
elim(col_dec A0 P A').
-
intro.
apply (proclus_bis A0 P); Col; [| |intro; apply HNCol; ColR].
-
intro.
exfalso.
assert(HY := proclus_bis A' P C D P A0).
assert (Coplanar C D P A0).
destruct HY as [Y []]; Col.
assert (Coplanar P A0 A' C0) by Cop.
elim (eq_dec_points C0 C); intro; treat_equalities; elim (eq_dec_points C0 D); intro; treat_equalities; auto; try CopR.
assert (Coplanar P A0 C C0) by (apply col2_cop__cop with C D; Col; Cop).

*****
H23 : Coplanar P A0 C C0
H22 : not (eq C0 D)
H21 : not (eq C0 C)
H20 : Coplanar P A0 A' C0
H15 : Coplanar C D P A0
H14 : not (Col A0 P A')
H18 : not (eq C0 A')
H17 : not (eq A' P)
H19 : not (eq C0 A0)
H16 : not (eq P A0)
H13 : OS C0 P A0 A'
H11 : Perp C0 P A' P
A' : Tpoint
H2 : not (Col C0 P A0)
H1 : Col A B A0
A0 : Tpoint
H10 : not (eq P C0)
H12 : not (eq A Q)
H8 : not (eq B Q)
H9 : not (eq C P)
H5 : not (eq D P)
H7 : not (eq C D)
H6 : not (eq C0 B)
H3 : not (eq A B)
H4 : not (eq C0 A)
HNCol2 : not (Col C0 A B)
H0 : Perp C D P C0
H : Col C D C0
C0 : Tpoint
HNCol1 : not (Col C D P)
HCop : Coplanar C D P Q
HNCol : not (Col A B Q)
HInter : Col A B P
HPar : Par_strict C D A B
A,B,C,D,P,Q : Tpoint
proclus_bis : alternative_proclus_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar A' P C D
+++++
assert (Coplanar P A0 D C0); [|CopR].
-----
Lemma proclus_bis__proclus : alternative_proclus_postulate -> proclus_postulate.
Proof.
intros proclus_bis A B C D P Q HPar HInter HNCol HCop.
elim(col_dec C D P).
intro; exists P; Col.
intro HNCol1.
apply par_symmetry in HPar.
apply (par_not_col_strict _ _ _ _ P) in HPar; auto.
assert(HC0 := l8_18_existence C D P).
destruct HC0 as [C0 []]; auto.
assert(HNCol2 : ~ Col C0 A B) by (apply (par_not_col C D); Col).
assert_diffs.
assert(HA0 : exists A0, Col A B A0 /\\ ~ Col C0 P A0).
destruct HA0 as [A0 []].
assert(HA' := l10_15 C0 P P A0).
destruct HA' as [A' []]; Col.
assert_diffs.
elim(col_dec A0 P A').
-
intro.
apply (proclus_bis A0 P); Col; [| |intro; apply HNCol; ColR].
-
intro.
exfalso.
assert(HY := proclus_bis A' P C D P A0).
assert (Coplanar C D P A0).
destruct HY as [Y []]; Col.
assert (Coplanar P A0 A' C0) by Cop.
elim (eq_dec_points C0 C); intro; treat_equalities; elim (eq_dec_points C0 D); intro; treat_equalities; auto; try CopR.
assert (Coplanar P A0 C C0) by (apply col2_cop__cop with C D; Col; Cop).
assert (Coplanar P A0 D C0); [|CopR].

*****
H23 : Coplanar P A0 C C0
H22 : not (eq C0 D)
H21 : not (eq C0 C)
H20 : Coplanar P A0 A' C0
H15 : Coplanar C D P A0
H14 : not (Col A0 P A')
H18 : not (eq C0 A')
H17 : not (eq A' P)
H19 : not (eq C0 A0)
H16 : not (eq P A0)
H13 : OS C0 P A0 A'
H11 : Perp C0 P A' P
A' : Tpoint
H2 : not (Col C0 P A0)
H1 : Col A B A0
A0 : Tpoint
H10 : not (eq P C0)
H12 : not (eq A Q)
H8 : not (eq B Q)
H9 : not (eq C P)
H5 : not (eq D P)
H7 : not (eq C D)
H6 : not (eq C0 B)
H3 : not (eq A B)
H4 : not (eq C0 A)
HNCol2 : not (Col C0 A B)
H0 : Perp C D P C0
H : Col C D C0
C0 : Tpoint
HNCol1 : not (Col C D P)
HCop : Coplanar C D P Q
HNCol : not (Col A B Q)
HInter : Col A B P
HPar : Par_strict C D A B
A,B,C,D,P,Q : Tpoint
proclus_bis : alternative_proclus_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar P A0 D C0
+++++
apply col2_cop__cop with C D; Col; Cop.
-----
Lemma proclus_bis__proclus : alternative_proclus_postulate -> proclus_postulate.
Proof.
intros proclus_bis A B C D P Q HPar HInter HNCol HCop.
elim(col_dec C D P).
intro; exists P; Col.
intro HNCol1.
apply par_symmetry in HPar.
apply (par_not_col_strict _ _ _ _ P) in HPar; auto.
assert(HC0 := l8_18_existence C D P).
destruct HC0 as [C0 []]; auto.
assert(HNCol2 : ~ Col C0 A B) by (apply (par_not_col C D); Col).
assert_diffs.
assert(HA0 : exists A0, Col A B A0 /\\ ~ Col C0 P A0).
destruct HA0 as [A0 []].
assert(HA' := l10_15 C0 P P A0).
destruct HA' as [A' []]; Col.
assert_diffs.
elim(col_dec A0 P A').
-
intro.
apply (proclus_bis A0 P); Col; [| |intro; apply HNCol; ColR].
-
intro.
exfalso.
assert(HY := proclus_bis A' P C D P A0).
assert (Coplanar C D P A0).
destruct HY as [Y []]; Col.

*****
H21 : Col C D Y
H20 : Col P A0 Y
Y : Tpoint
H15 : Coplanar C D P A0
H14 : not (Col A0 P A')
H18 : not (eq C0 A')
H17 : not (eq A' P)
H19 : not (eq C0 A0)
H16 : not (eq P A0)
H13 : OS C0 P A0 A'
H11 : Perp C0 P A' P
A' : Tpoint
H2 : not (Col C0 P A0)
H1 : Col A B A0
A0 : Tpoint
H10 : not (eq P C0)
H12 : not (eq A Q)
H8 : not (eq B Q)
H9 : not (eq C P)
H5 : not (eq D P)
H7 : not (eq C D)
H6 : not (eq C0 B)
H3 : not (eq A B)
H4 : not (eq C0 A)
HNCol2 : not (Col C0 A B)
H0 : Perp C D P C0
H : Col C D C0
C0 : Tpoint
HNCol1 : not (Col C D P)
HCop : Coplanar C D P Q
HNCol : not (Col A B Q)
HInter : Col A B P
HPar : Par_strict C D A B
A,B,C,D,P,Q : Tpoint
proclus_bis : alternative_proclus_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
assert(Habs : ~ Col Y A B) by (apply (par_not_col C D); Col).
-----
Lemma proclus_bis__proclus : alternative_proclus_postulate -> proclus_postulate.
Proof.
intros proclus_bis A B C D P Q HPar HInter HNCol HCop.
elim(col_dec C D P).
intro; exists P; Col.
intro HNCol1.
apply par_symmetry in HPar.
apply (par_not_col_strict _ _ _ _ P) in HPar; auto.
assert(HC0 := l8_18_existence C D P).
destruct HC0 as [C0 []]; auto.
assert(HNCol2 : ~ Col C0 A B) by (apply (par_not_col C D); Col).
assert_diffs.
assert(HA0 : exists A0, Col A B A0 /\\ ~ Col C0 P A0).
destruct HA0 as [A0 []].
assert(HA' := l10_15 C0 P P A0).
destruct HA' as [A' []]; Col.
assert_diffs.
elim(col_dec A0 P A').
-
intro.
apply (proclus_bis A0 P); Col; [| |intro; apply HNCol; ColR].
-
intro.
exfalso.
assert(HY := proclus_bis A' P C D P A0).
assert (Coplanar C D P A0).
destruct HY as [Y []]; Col.
assert(Habs : ~ Col Y A B) by (apply (par_not_col C D); Col).

*****
Habs : not (Col Y A B)
H21 : Col C D Y
H20 : Col P A0 Y
Y : Tpoint
H15 : Coplanar C D P A0
H14 : not (Col A0 P A')
H18 : not (eq C0 A')
H17 : not (eq A' P)
H19 : not (eq C0 A0)
H16 : not (eq P A0)
H13 : OS C0 P A0 A'
H11 : Perp C0 P A' P
A' : Tpoint
H2 : not (Col C0 P A0)
H1 : Col A B A0
A0 : Tpoint
H10 : not (eq P C0)
H12 : not (eq A Q)
H8 : not (eq B Q)
H9 : not (eq C P)
H5 : not (eq D P)
H7 : not (eq C D)
H6 : not (eq C0 B)
H3 : not (eq A B)
H4 : not (eq C0 A)
HNCol2 : not (Col C0 A B)
H0 : Perp C D P C0
H : Col C D C0
C0 : Tpoint
HNCol1 : not (Col C D P)
HCop : Coplanar C D P Q
HNCol : not (Col A B Q)
HInter : Col A B P
HPar : Par_strict C D A B
A,B,C,D,P,Q : Tpoint
proclus_bis : alternative_proclus_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
apply Habs; ColR.
-----
Lemma proclus_bis__proclus : alternative_proclus_postulate -> proclus_postulate.
Proof.
intros proclus_bis A B C D P Q HPar HInter HNCol HCop.
elim(col_dec C D P).
intro; exists P; Col.
intro HNCol1.
apply par_symmetry in HPar.
apply (par_not_col_strict _ _ _ _ P) in HPar; auto.
assert(HC0 := l8_18_existence C D P).
destruct HC0 as [C0 []]; auto.
assert(HNCol2 : ~ Col C0 A B) by (apply (par_not_col C D); Col).
assert_diffs.
assert(HA0 : exists A0, Col A B A0 /\\ ~ Col C0 P A0).
destruct HA0 as [A0 []].
assert(HA' := l10_15 C0 P P A0).
destruct HA' as [A' []]; Col.
assert_diffs.
elim(col_dec A0 P A').
-
intro.
apply (proclus_bis A0 P); Col; [| |intro; apply HNCol; ColR].
-
intro.
exfalso.
assert(HY := proclus_bis A' P C D P A0).
assert (Coplanar C D P A0).
destruct HY as [Y []]; Col.

*****

*****

+++++
Qed.
-----
End proclus_bis_proclus.
-----
