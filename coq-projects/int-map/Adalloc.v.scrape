From Coq Require Import Bool.
-----
Require Import Coq.Bool.Sumbool.
-----
From Coq Require Import Arith.
-----
Require Import Coq.NArith.NArith.
-----
Require Import Coq.NArith.Ndigits.
-----
Require Import Coq.NArith.Ndec.
-----
Require Import Coq.NArith.Nnat.
-----
Require Import Map.
-----
Require Import Fset.
-----
Section AdAlloc.
-----
Variable A : Set.
-----
Fixpoint ad_alloc_opt (m:Map A) : ad :=\n    match m with\n    | M0 => N0\n    | M1 a _ => if Neqb a N0 then Npos 1 else N0\n    | M2 m1 m2 =>\n        Nmin (Ndouble (ad_alloc_opt m1))\n          (Ndouble_plus_one (ad_alloc_opt m2))\n    end.
-----
Lemma ad_alloc_opt_allocates_1 :\n   forall m:Map A, MapGet A m (ad_alloc_opt m) = None.
-----
Lemma ad_alloc_opt_allocates_1 : forall m:Map A, MapGet A m (ad_alloc_opt m) = None.

*****
A : Set
*****
forall m : Map A, eq (MapGet A m (ad_alloc_opt m)) None
+++++
Proof.
-----
Lemma ad_alloc_opt_allocates_1 : forall m:Map A, MapGet A m (ad_alloc_opt m) = None.
Proof.

*****
A : Set
*****
forall m : Map A, eq (MapGet A m (ad_alloc_opt m)) None
+++++
induction m as [| a| m0 H m1 H0].
-----
Lemma ad_alloc_opt_allocates_1 : forall m:Map A, MapGet A m (ad_alloc_opt m) = None.
Proof.
induction m as [| a| m0 H m1 H0].

*****
A : Set
*****
eq (MapGet A (M0 A) (ad_alloc_opt (M0 A))) None
+++++
reflexivity.
-----
Lemma ad_alloc_opt_allocates_1 : forall m:Map A, MapGet A m (ad_alloc_opt m) = None.
Proof.
induction m as [| a| m0 H m1 H0].

*****
a0 : A
a : ad
A : Set
*****
eq (MapGet A (M1 A a a0) (ad_alloc_opt (M1 A a a0))) None
+++++
simpl in |- *.
-----
Lemma ad_alloc_opt_allocates_1 : forall m:Map A, MapGet A m (ad_alloc_opt m) = None.
Proof.
induction m as [| a| m0 H m1 H0].
simpl in |- *.

*****
a0 : A
a : ad
A : Set
*****
eq (if N.eqb a (if N.eqb a N0 then Npos xH else N0) then Some a0 else None) None
+++++
elim (sumbool_of_bool (Neqb a N0)).
-----
Lemma ad_alloc_opt_allocates_1 : forall m:Map A, MapGet A m (ad_alloc_opt m) = None.
Proof.
induction m as [| a| m0 H m1 H0].
simpl in |- *.
elim (sumbool_of_bool (Neqb a N0)).

*****
a0 : A
a : ad
A : Set
*****
forall _ : eq (N.eqb a N0) true, eq (if N.eqb a (if N.eqb a N0 then Npos xH else N0) then Some a0 else None) None
+++++
intro H.
-----
Lemma ad_alloc_opt_allocates_1 : forall m:Map A, MapGet A m (ad_alloc_opt m) = None.
Proof.
induction m as [| a| m0 H m1 H0].
simpl in |- *.
elim (sumbool_of_bool (Neqb a N0)).
intro H.

*****
H : eq (N.eqb a N0) true
a0 : A
a : ad
A : Set
*****
eq (if N.eqb a (if N.eqb a N0 then Npos xH else N0) then Some a0 else None) None
+++++
rewrite H.
-----
Lemma ad_alloc_opt_allocates_1 : forall m:Map A, MapGet A m (ad_alloc_opt m) = None.
Proof.
induction m as [| a| m0 H m1 H0].
simpl in |- *.
elim (sumbool_of_bool (Neqb a N0)).
intro H.
rewrite H.

*****
H : eq (N.eqb a N0) true
a0 : A
a : ad
A : Set
*****
eq (if N.eqb a (Npos xH) then Some a0 else None) None
+++++
rewrite (Neqb_complete _ _ H).
-----
Lemma ad_alloc_opt_allocates_1 : forall m:Map A, MapGet A m (ad_alloc_opt m) = None.
Proof.
induction m as [| a| m0 H m1 H0].
simpl in |- *.
elim (sumbool_of_bool (Neqb a N0)).
intro H.
rewrite H.
rewrite (Neqb_complete _ _ H).

*****
H : eq (N.eqb a N0) true
a0 : A
a : ad
A : Set
*****
eq (if N.eqb N0 (Npos xH) then Some a0 else None) None
+++++
reflexivity.
-----
Lemma ad_alloc_opt_allocates_1 : forall m:Map A, MapGet A m (ad_alloc_opt m) = None.
Proof.
induction m as [| a| m0 H m1 H0].
simpl in |- *.
elim (sumbool_of_bool (Neqb a N0)).

*****
a0 : A
a : ad
A : Set
*****
forall _ : eq (N.eqb a N0) false, eq (if N.eqb a (if N.eqb a N0 then Npos xH else N0) then Some a0 else None) None
+++++
intro H.
-----
Lemma ad_alloc_opt_allocates_1 : forall m:Map A, MapGet A m (ad_alloc_opt m) = None.
Proof.
induction m as [| a| m0 H m1 H0].
simpl in |- *.
elim (sumbool_of_bool (Neqb a N0)).
intro H.

*****
H : eq (N.eqb a N0) false
a0 : A
a : ad
A : Set
*****
eq (if N.eqb a (if N.eqb a N0 then Npos xH else N0) then Some a0 else None) None
+++++
rewrite H.
-----
Lemma ad_alloc_opt_allocates_1 : forall m:Map A, MapGet A m (ad_alloc_opt m) = None.
Proof.
induction m as [| a| m0 H m1 H0].
simpl in |- *.
elim (sumbool_of_bool (Neqb a N0)).
intro H.
rewrite H.

*****
H : eq (N.eqb a N0) false
a0 : A
a : ad
A : Set
*****
eq (if N.eqb a N0 then Some a0 else None) None
+++++
rewrite H.
-----
Lemma ad_alloc_opt_allocates_1 : forall m:Map A, MapGet A m (ad_alloc_opt m) = None.
Proof.
induction m as [| a| m0 H m1 H0].
simpl in |- *.
elim (sumbool_of_bool (Neqb a N0)).
intro H.
rewrite H.
rewrite H.

*****
H : eq (N.eqb a N0) false
a0 : A
a : ad
A : Set
*****
eq None None
+++++
reflexivity.
-----
Lemma ad_alloc_opt_allocates_1 : forall m:Map A, MapGet A m (ad_alloc_opt m) = None.
Proof.
induction m as [| a| m0 H m1 H0].

*****
H0 : eq (MapGet A m1 (ad_alloc_opt m1)) None
H : eq (MapGet A m0 (ad_alloc_opt m0)) None
m0,m1 : Map A
A : Set
*****
eq (MapGet A (M2 A m0 m1) (ad_alloc_opt (M2 A m0 m1))) None
+++++
intros.
-----
Lemma ad_alloc_opt_allocates_1 : forall m:Map A, MapGet A m (ad_alloc_opt m) = None.
Proof.
induction m as [| a| m0 H m1 H0].
intros.

*****
H0 : eq (MapGet A m1 (ad_alloc_opt m1)) None
H : eq (MapGet A m0 (ad_alloc_opt m0)) None
m0,m1 : Map A
A : Set
*****
eq (MapGet A (M2 A m0 m1) (ad_alloc_opt (M2 A m0 m1))) None
+++++
change (ad_alloc_opt (M2 A m0 m1)) with (Nmin (Ndouble (ad_alloc_opt m0)) (Ndouble_plus_one (ad_alloc_opt m1))) in |- *.
-----
Lemma ad_alloc_opt_allocates_1 : forall m:Map A, MapGet A m (ad_alloc_opt m) = None.
Proof.
induction m as [| a| m0 H m1 H0].
intros.
change (ad_alloc_opt (M2 A m0 m1)) with (Nmin (Ndouble (ad_alloc_opt m0)) (Ndouble_plus_one (ad_alloc_opt m1))) in |- *.

*****
H0 : eq (MapGet A m1 (ad_alloc_opt m1)) None
H : eq (MapGet A m0 (ad_alloc_opt m0)) None
m0,m1 : Map A
A : Set
*****
eq (MapGet A (M2 A m0 m1) (N.min (N.double (ad_alloc_opt m0)) (N.succ_double (ad_alloc_opt m1)))) None
+++++
elim (Nmin_choice (Ndouble (ad_alloc_opt m0)) (Ndouble_plus_one (ad_alloc_opt m1))).
-----
Lemma ad_alloc_opt_allocates_1 : forall m:Map A, MapGet A m (ad_alloc_opt m) = None.
Proof.
induction m as [| a| m0 H m1 H0].
intros.
change (ad_alloc_opt (M2 A m0 m1)) with (Nmin (Ndouble (ad_alloc_opt m0)) (Ndouble_plus_one (ad_alloc_opt m1))) in |- *.
elim (Nmin_choice (Ndouble (ad_alloc_opt m0)) (Ndouble_plus_one (ad_alloc_opt m1))).

*****
H0 : eq (MapGet A m1 (ad_alloc_opt m1)) None
H : eq (MapGet A m0 (ad_alloc_opt m0)) None
m0,m1 : Map A
A : Set
*****
forall _ : eq (N.min (N.double (ad_alloc_opt m0)) (N.succ_double (ad_alloc_opt m1))) (N.double (ad_alloc_opt m0)), eq (MapGet A (M2 A m0 m1) (N.min (N.double (ad_alloc_opt m0)) (N.succ_double (ad_alloc_opt m1)))) None
+++++
intro H1.
-----
Lemma ad_alloc_opt_allocates_1 : forall m:Map A, MapGet A m (ad_alloc_opt m) = None.
Proof.
induction m as [| a| m0 H m1 H0].
intros.
change (ad_alloc_opt (M2 A m0 m1)) with (Nmin (Ndouble (ad_alloc_opt m0)) (Ndouble_plus_one (ad_alloc_opt m1))) in |- *.
elim (Nmin_choice (Ndouble (ad_alloc_opt m0)) (Ndouble_plus_one (ad_alloc_opt m1))).
intro H1.

*****
H1 : eq\n (N.min (N.double (ad_alloc_opt m0)) (N.succ_double (ad_alloc_opt m1)))\n (N.double (ad_alloc_opt m0))
H0 : eq (MapGet A m1 (ad_alloc_opt m1)) None
H : eq (MapGet A m0 (ad_alloc_opt m0)) None
m0,m1 : Map A
A : Set
*****
eq (MapGet A (M2 A m0 m1) (N.min (N.double (ad_alloc_opt m0)) (N.succ_double (ad_alloc_opt m1)))) None
+++++
rewrite H1.
-----
Lemma ad_alloc_opt_allocates_1 : forall m:Map A, MapGet A m (ad_alloc_opt m) = None.
Proof.
induction m as [| a| m0 H m1 H0].
intros.
change (ad_alloc_opt (M2 A m0 m1)) with (Nmin (Ndouble (ad_alloc_opt m0)) (Ndouble_plus_one (ad_alloc_opt m1))) in |- *.
elim (Nmin_choice (Ndouble (ad_alloc_opt m0)) (Ndouble_plus_one (ad_alloc_opt m1))).
intro H1.
rewrite H1.

*****
H1 : eq\n (N.min (N.double (ad_alloc_opt m0)) (N.succ_double (ad_alloc_opt m1)))\n (N.double (ad_alloc_opt m0))
H0 : eq (MapGet A m1 (ad_alloc_opt m1)) None
H : eq (MapGet A m0 (ad_alloc_opt m0)) None
m0,m1 : Map A
A : Set
*****
eq (MapGet A (M2 A m0 m1) (N.double (ad_alloc_opt m0))) None
+++++
rewrite MapGet_M2_bit_0_0.
-----
Lemma ad_alloc_opt_allocates_1 : forall m:Map A, MapGet A m (ad_alloc_opt m) = None.
Proof.
induction m as [| a| m0 H m1 H0].
intros.
change (ad_alloc_opt (M2 A m0 m1)) with (Nmin (Ndouble (ad_alloc_opt m0)) (Ndouble_plus_one (ad_alloc_opt m1))) in |- *.
elim (Nmin_choice (Ndouble (ad_alloc_opt m0)) (Ndouble_plus_one (ad_alloc_opt m1))).
intro H1.
rewrite H1.
rewrite MapGet_M2_bit_0_0.

*****
H1 : eq\n (N.min (N.double (ad_alloc_opt m0)) (N.succ_double (ad_alloc_opt m1)))\n (N.double (ad_alloc_opt m0))
H0 : eq (MapGet A m1 (ad_alloc_opt m1)) None
H : eq (MapGet A m0 (ad_alloc_opt m0)) None
m0,m1 : Map A
A : Set
*****
eq (MapGet A m0 (N.div2 (N.double (ad_alloc_opt m0)))) None
+++++
rewrite Ndouble_div2.
-----
Lemma ad_alloc_opt_allocates_1 : forall m:Map A, MapGet A m (ad_alloc_opt m) = None.
Proof.
induction m as [| a| m0 H m1 H0].
intros.
change (ad_alloc_opt (M2 A m0 m1)) with (Nmin (Ndouble (ad_alloc_opt m0)) (Ndouble_plus_one (ad_alloc_opt m1))) in |- *.
elim (Nmin_choice (Ndouble (ad_alloc_opt m0)) (Ndouble_plus_one (ad_alloc_opt m1))).
intro H1.
rewrite H1.
rewrite MapGet_M2_bit_0_0.
rewrite Ndouble_div2.

*****
H1 : eq\n (N.min (N.double (ad_alloc_opt m0)) (N.succ_double (ad_alloc_opt m1)))\n (N.double (ad_alloc_opt m0))
H0 : eq (MapGet A m1 (ad_alloc_opt m1)) None
H : eq (MapGet A m0 (ad_alloc_opt m0)) None
m0,m1 : Map A
A : Set
*****
eq (MapGet A m0 (ad_alloc_opt m0)) None
+++++
assumption.
-----
Lemma ad_alloc_opt_allocates_1 : forall m:Map A, MapGet A m (ad_alloc_opt m) = None.
Proof.
induction m as [| a| m0 H m1 H0].
intros.
change (ad_alloc_opt (M2 A m0 m1)) with (Nmin (Ndouble (ad_alloc_opt m0)) (Ndouble_plus_one (ad_alloc_opt m1))) in |- *.
elim (Nmin_choice (Ndouble (ad_alloc_opt m0)) (Ndouble_plus_one (ad_alloc_opt m1))).
intro H1.
rewrite H1.
rewrite MapGet_M2_bit_0_0.

*****
H1 : eq\n (N.min (N.double (ad_alloc_opt m0)) (N.succ_double (ad_alloc_opt m1)))\n (N.double (ad_alloc_opt m0))
H0 : eq (MapGet A m1 (ad_alloc_opt m1)) None
H : eq (MapGet A m0 (ad_alloc_opt m0)) None
m0,m1 : Map A
A : Set
*****
eq (N.odd (N.double (ad_alloc_opt m0))) false
+++++
apply Ndouble_bit0.
-----
Lemma ad_alloc_opt_allocates_1 : forall m:Map A, MapGet A m (ad_alloc_opt m) = None.
Proof.
induction m as [| a| m0 H m1 H0].
intros.
change (ad_alloc_opt (M2 A m0 m1)) with (Nmin (Ndouble (ad_alloc_opt m0)) (Ndouble_plus_one (ad_alloc_opt m1))) in |- *.
elim (Nmin_choice (Ndouble (ad_alloc_opt m0)) (Ndouble_plus_one (ad_alloc_opt m1))).

*****
H0 : eq (MapGet A m1 (ad_alloc_opt m1)) None
H : eq (MapGet A m0 (ad_alloc_opt m0)) None
m0,m1 : Map A
A : Set
*****
forall _ : eq (N.min (N.double (ad_alloc_opt m0)) (N.succ_double (ad_alloc_opt m1))) (N.succ_double (ad_alloc_opt m1)), eq (MapGet A (M2 A m0 m1) (N.min (N.double (ad_alloc_opt m0)) (N.succ_double (ad_alloc_opt m1)))) None
+++++
intro H1.
-----
Lemma ad_alloc_opt_allocates_1 : forall m:Map A, MapGet A m (ad_alloc_opt m) = None.
Proof.
induction m as [| a| m0 H m1 H0].
intros.
change (ad_alloc_opt (M2 A m0 m1)) with (Nmin (Ndouble (ad_alloc_opt m0)) (Ndouble_plus_one (ad_alloc_opt m1))) in |- *.
elim (Nmin_choice (Ndouble (ad_alloc_opt m0)) (Ndouble_plus_one (ad_alloc_opt m1))).
intro H1.

*****
H1 : eq\n (N.min (N.double (ad_alloc_opt m0)) (N.succ_double (ad_alloc_opt m1)))\n (N.succ_double (ad_alloc_opt m1))
H0 : eq (MapGet A m1 (ad_alloc_opt m1)) None
H : eq (MapGet A m0 (ad_alloc_opt m0)) None
m0,m1 : Map A
A : Set
*****
eq (MapGet A (M2 A m0 m1) (N.min (N.double (ad_alloc_opt m0)) (N.succ_double (ad_alloc_opt m1)))) None
+++++
rewrite H1.
-----
Lemma ad_alloc_opt_allocates_1 : forall m:Map A, MapGet A m (ad_alloc_opt m) = None.
Proof.
induction m as [| a| m0 H m1 H0].
intros.
change (ad_alloc_opt (M2 A m0 m1)) with (Nmin (Ndouble (ad_alloc_opt m0)) (Ndouble_plus_one (ad_alloc_opt m1))) in |- *.
elim (Nmin_choice (Ndouble (ad_alloc_opt m0)) (Ndouble_plus_one (ad_alloc_opt m1))).
intro H1.
rewrite H1.

*****
H1 : eq\n (N.min (N.double (ad_alloc_opt m0)) (N.succ_double (ad_alloc_opt m1)))\n (N.succ_double (ad_alloc_opt m1))
H0 : eq (MapGet A m1 (ad_alloc_opt m1)) None
H : eq (MapGet A m0 (ad_alloc_opt m0)) None
m0,m1 : Map A
A : Set
*****
eq (MapGet A (M2 A m0 m1) (N.succ_double (ad_alloc_opt m1))) None
+++++
rewrite MapGet_M2_bit_0_1.
-----
Lemma ad_alloc_opt_allocates_1 : forall m:Map A, MapGet A m (ad_alloc_opt m) = None.
Proof.
induction m as [| a| m0 H m1 H0].
intros.
change (ad_alloc_opt (M2 A m0 m1)) with (Nmin (Ndouble (ad_alloc_opt m0)) (Ndouble_plus_one (ad_alloc_opt m1))) in |- *.
elim (Nmin_choice (Ndouble (ad_alloc_opt m0)) (Ndouble_plus_one (ad_alloc_opt m1))).
intro H1.
rewrite H1.
rewrite MapGet_M2_bit_0_1.

*****
H1 : eq\n (N.min (N.double (ad_alloc_opt m0)) (N.succ_double (ad_alloc_opt m1)))\n (N.succ_double (ad_alloc_opt m1))
H0 : eq (MapGet A m1 (ad_alloc_opt m1)) None
H : eq (MapGet A m0 (ad_alloc_opt m0)) None
m0,m1 : Map A
A : Set
*****
eq (MapGet A m1 (N.div2 (N.succ_double (ad_alloc_opt m1)))) None
+++++
rewrite Ndouble_plus_one_div2.
-----
Lemma ad_alloc_opt_allocates_1 : forall m:Map A, MapGet A m (ad_alloc_opt m) = None.
Proof.
induction m as [| a| m0 H m1 H0].
intros.
change (ad_alloc_opt (M2 A m0 m1)) with (Nmin (Ndouble (ad_alloc_opt m0)) (Ndouble_plus_one (ad_alloc_opt m1))) in |- *.
elim (Nmin_choice (Ndouble (ad_alloc_opt m0)) (Ndouble_plus_one (ad_alloc_opt m1))).
intro H1.
rewrite H1.
rewrite MapGet_M2_bit_0_1.
rewrite Ndouble_plus_one_div2.

*****
H1 : eq\n (N.min (N.double (ad_alloc_opt m0)) (N.succ_double (ad_alloc_opt m1)))\n (N.succ_double (ad_alloc_opt m1))
H0 : eq (MapGet A m1 (ad_alloc_opt m1)) None
H : eq (MapGet A m0 (ad_alloc_opt m0)) None
m0,m1 : Map A
A : Set
*****
eq (MapGet A m1 (ad_alloc_opt m1)) None
+++++
assumption.
-----
Lemma ad_alloc_opt_allocates_1 : forall m:Map A, MapGet A m (ad_alloc_opt m) = None.
Proof.
induction m as [| a| m0 H m1 H0].
intros.
change (ad_alloc_opt (M2 A m0 m1)) with (Nmin (Ndouble (ad_alloc_opt m0)) (Ndouble_plus_one (ad_alloc_opt m1))) in |- *.
elim (Nmin_choice (Ndouble (ad_alloc_opt m0)) (Ndouble_plus_one (ad_alloc_opt m1))).
intro H1.
rewrite H1.
rewrite MapGet_M2_bit_0_1.

*****
H1 : eq\n (N.min (N.double (ad_alloc_opt m0)) (N.succ_double (ad_alloc_opt m1)))\n (N.succ_double (ad_alloc_opt m1))
H0 : eq (MapGet A m1 (ad_alloc_opt m1)) None
H : eq (MapGet A m0 (ad_alloc_opt m0)) None
m0,m1 : Map A
A : Set
*****
eq (N.odd (N.succ_double (ad_alloc_opt m1))) true
+++++
apply Ndouble_plus_one_bit0.
-----
Lemma ad_alloc_opt_allocates_1 : forall m:Map A, MapGet A m (ad_alloc_opt m) = None.
Proof.
induction m as [| a| m0 H m1 H0].

*****

*****

+++++
Qed.
-----
Lemma ad_alloc_opt_allocates :\n   forall m:Map A, in_dom A (ad_alloc_opt m) m = false.
-----
Lemma ad_alloc_opt_allocates : forall m:Map A, in_dom A (ad_alloc_opt m) m = false.

*****
A : Set
*****
forall m : Map A, eq (in_dom A (ad_alloc_opt m) m) false
+++++
Proof.
-----
Lemma ad_alloc_opt_allocates : forall m:Map A, in_dom A (ad_alloc_opt m) m = false.
Proof.

*****
A : Set
*****
forall m : Map A, eq (in_dom A (ad_alloc_opt m) m) false
+++++
unfold in_dom in |- *.
-----
Lemma ad_alloc_opt_allocates : forall m:Map A, in_dom A (ad_alloc_opt m) m = false.
Proof.
unfold in_dom in |- *.

*****
A : Set
*****
forall m : Map A, eq match MapGet A m (ad_alloc_opt m) with | Some _ => true | None => false end false
+++++
intro.
-----
Lemma ad_alloc_opt_allocates : forall m:Map A, in_dom A (ad_alloc_opt m) m = false.
Proof.
unfold in_dom in |- *.
intro.

*****
m : Map A
A : Set
*****
eq match MapGet A m (ad_alloc_opt m) with | Some _ => true | None => false end false
+++++
rewrite (ad_alloc_opt_allocates_1 m).
-----
Lemma ad_alloc_opt_allocates : forall m:Map A, in_dom A (ad_alloc_opt m) m = false.
Proof.
unfold in_dom in |- *.
intro.
rewrite (ad_alloc_opt_allocates_1 m).

*****
m : Map A
A : Set
*****
eq false false
+++++
reflexivity.
-----
Lemma ad_alloc_opt_allocates : forall m:Map A, in_dom A (ad_alloc_opt m) m = false.
Proof.
unfold in_dom in |- *.
intro.
rewrite (ad_alloc_opt_allocates_1 m).
reflexivity.

*****

*****

+++++
Qed.
-----
Lemma ad_alloc_opt_optimal_1 :\n   forall (m:Map A) (a:ad),\n     Nleb (ad_alloc_opt m) a = false -> {y : A | MapGet A m a = Some y}.
-----
Lemma ad_alloc_opt_optimal_1 : forall (m:Map A) (a:ad), Nleb (ad_alloc_opt m) a = false -> {y : A | MapGet A m a = Some y}.

*****
A : Set
*****
forall (m : Map A) (a : ad) (_ : eq (Nleb (ad_alloc_opt m) a) false), sig (fun y : A => eq (MapGet A m a) (Some y))
+++++
Proof.
-----
Lemma ad_alloc_opt_optimal_1 : forall (m:Map A) (a:ad), Nleb (ad_alloc_opt m) a = false -> {y : A | MapGet A m a = Some y}.
Proof.

*****
A : Set
*****
forall (m : Map A) (a : ad) (_ : eq (Nleb (ad_alloc_opt m) a) false), sig (fun y : A => eq (MapGet A m a) (Some y))
+++++
induction m as [| a y| m0 H m1 H0].
-----
Lemma ad_alloc_opt_optimal_1 : forall (m:Map A) (a:ad), Nleb (ad_alloc_opt m) a = false -> {y : A | MapGet A m a = Some y}.
Proof.
induction m as [| a y| m0 H m1 H0].

*****
A : Set
*****
forall (a : ad) (_ : eq (Nleb (ad_alloc_opt (M0 A)) a) false), sig (fun y : A => eq (MapGet A (M0 A) a) (Some y))
+++++
simpl in |- *.
-----
Lemma ad_alloc_opt_optimal_1 : forall (m:Map A) (a:ad), Nleb (ad_alloc_opt m) a = false -> {y : A | MapGet A m a = Some y}.
Proof.
induction m as [| a y| m0 H m1 H0].
simpl in |- *.

*****
A : Set
*****
forall (a : ad) (_ : eq (Nleb N0 a) false), sig (fun y : A => eq None (Some y))
+++++
unfold Nle in |- *.
-----
Lemma ad_alloc_opt_optimal_1 : forall (m:Map A) (a:ad), Nleb (ad_alloc_opt m) a = false -> {y : A | MapGet A m a = Some y}.
Proof.
induction m as [| a y| m0 H m1 H0].
simpl in |- *.
unfold Nle in |- *.

*****
A : Set
*****
forall (a : ad) (_ : eq (Nleb N0 a) false), sig (fun y : A => eq None (Some y))
+++++
simpl in |- *.
-----
Lemma ad_alloc_opt_optimal_1 : forall (m:Map A) (a:ad), Nleb (ad_alloc_opt m) a = false -> {y : A | MapGet A m a = Some y}.
Proof.
induction m as [| a y| m0 H m1 H0].
simpl in |- *.
unfold Nle in |- *.
simpl in |- *.

*****
A : Set
*****
forall (a : ad) (_ : eq (Nleb N0 a) false), sig (fun y : A => eq None (Some y))
+++++
intros.
-----
Lemma ad_alloc_opt_optimal_1 : forall (m:Map A) (a:ad), Nleb (ad_alloc_opt m) a = false -> {y : A | MapGet A m a = Some y}.
Proof.
induction m as [| a y| m0 H m1 H0].
simpl in |- *.
unfold Nle in |- *.
simpl in |- *.
intros.

*****
H : eq (Nleb N0 a) false
a : ad
A : Set
*****
sig (fun y : A => eq None (Some y))
+++++
discriminate H.
-----
Lemma ad_alloc_opt_optimal_1 : forall (m:Map A) (a:ad), Nleb (ad_alloc_opt m) a = false -> {y : A | MapGet A m a = Some y}.
Proof.
induction m as [| a y| m0 H m1 H0].

*****
y : A
a : ad
A : Set
*****
forall (a0 : ad) (_ : eq (Nleb (ad_alloc_opt (M1 A a y)) a0) false), sig (fun y0 : A => eq (MapGet A (M1 A a y) a0) (Some y0))
+++++
simpl in |- *.
-----
Lemma ad_alloc_opt_optimal_1 : forall (m:Map A) (a:ad), Nleb (ad_alloc_opt m) a = false -> {y : A | MapGet A m a = Some y}.
Proof.
induction m as [| a y| m0 H m1 H0].
simpl in |- *.

*****
y : A
a : ad
A : Set
*****
forall (a0 : ad) (_ : eq (Nleb (if N.eqb a N0 then Npos xH else N0) a0) false), sig (fun y0 : A => eq (if N.eqb a a0 then Some y else None) (Some y0))
+++++
intros b H.
-----
Lemma ad_alloc_opt_optimal_1 : forall (m:Map A) (a:ad), Nleb (ad_alloc_opt m) a = false -> {y : A | MapGet A m a = Some y}.
Proof.
induction m as [| a y| m0 H m1 H0].
simpl in |- *.
intros b H.

*****
H : eq (Nleb (if N.eqb a N0 then Npos xH else N0) b) false
b : ad
y : A
a : ad
A : Set
*****
sig (fun y0 : A => eq (if N.eqb a b then Some y else None) (Some y0))
+++++
elim (sumbool_of_bool (Neqb a N0)).
-----
Lemma ad_alloc_opt_optimal_1 : forall (m:Map A) (a:ad), Nleb (ad_alloc_opt m) a = false -> {y : A | MapGet A m a = Some y}.
Proof.
induction m as [| a y| m0 H m1 H0].
simpl in |- *.
intros b H.
elim (sumbool_of_bool (Neqb a N0)).

*****
H : eq (Nleb (if N.eqb a N0 then Npos xH else N0) b) false
b : ad
y : A
a : ad
A : Set
*****
forall _ : eq (N.eqb a N0) true, sig (fun y0 : A => eq (if N.eqb a b then Some y else None) (Some y0))
+++++
intro H0.
-----
Lemma ad_alloc_opt_optimal_1 : forall (m:Map A) (a:ad), Nleb (ad_alloc_opt m) a = false -> {y : A | MapGet A m a = Some y}.
Proof.
induction m as [| a y| m0 H m1 H0].
simpl in |- *.
intros b H.
elim (sumbool_of_bool (Neqb a N0)).
intro H0.

*****
H0 : eq (N.eqb a N0) true
H : eq (Nleb (if N.eqb a N0 then Npos xH else N0) b) false
b : ad
y : A
a : ad
A : Set
*****
sig (fun y0 : A => eq (if N.eqb a b then Some y else None) (Some y0))
+++++
rewrite H0 in H.
-----
Lemma ad_alloc_opt_optimal_1 : forall (m:Map A) (a:ad), Nleb (ad_alloc_opt m) a = false -> {y : A | MapGet A m a = Some y}.
Proof.
induction m as [| a y| m0 H m1 H0].
simpl in |- *.
intros b H.
elim (sumbool_of_bool (Neqb a N0)).
intro H0.
rewrite H0 in H.

*****
H0 : eq (N.eqb a N0) true
H : eq (Nleb (Npos xH) b) false
b : ad
y : A
a : ad
A : Set
*****
sig (fun y0 : A => eq (if N.eqb a b then Some y else None) (Some y0))
+++++
unfold Nleb in H.
-----
Lemma ad_alloc_opt_optimal_1 : forall (m:Map A) (a:ad), Nleb (ad_alloc_opt m) a = false -> {y : A | MapGet A m a = Some y}.
Proof.
induction m as [| a y| m0 H m1 H0].
simpl in |- *.
intros b H.
elim (sumbool_of_bool (Neqb a N0)).
intro H0.
rewrite H0 in H.
unfold Nleb in H.

*****
H0 : eq (N.eqb a N0) true
H : eq (Nat.leb (N.to_nat (Npos xH)) (N.to_nat b)) false
b : ad
y : A
a : ad
A : Set
*****
sig (fun y0 : A => eq (if N.eqb a b then Some y else None) (Some y0))
+++++
cut (N0 = b).
-----
Lemma ad_alloc_opt_optimal_1 : forall (m:Map A) (a:ad), Nleb (ad_alloc_opt m) a = false -> {y : A | MapGet A m a = Some y}.
Proof.
induction m as [| a y| m0 H m1 H0].
simpl in |- *.
intros b H.
elim (sumbool_of_bool (Neqb a N0)).
intro H0.
rewrite H0 in H.
unfold Nleb in H.
cut (N0 = b).

*****
H0 : eq (N.eqb a N0) true
H : eq (Nat.leb (N.to_nat (Npos xH)) (N.to_nat b)) false
b : ad
y : A
a : ad
A : Set
*****
forall _ : eq N0 b, sig (fun y0 : A => eq (if N.eqb a b then Some y else None) (Some y0))
+++++
intro.
-----
Lemma ad_alloc_opt_optimal_1 : forall (m:Map A) (a:ad), Nleb (ad_alloc_opt m) a = false -> {y : A | MapGet A m a = Some y}.
Proof.
induction m as [| a y| m0 H m1 H0].
simpl in |- *.
intros b H.
elim (sumbool_of_bool (Neqb a N0)).
intro H0.
rewrite H0 in H.
unfold Nleb in H.
cut (N0 = b).
intro.

*****
H1 : eq N0 b
H0 : eq (N.eqb a N0) true
H : eq (Nat.leb (N.to_nat (Npos xH)) (N.to_nat b)) false
b : ad
y : A
a : ad
A : Set
*****
sig (fun y0 : A => eq (if N.eqb a b then Some y else None) (Some y0))
+++++
split with y.
-----
Lemma ad_alloc_opt_optimal_1 : forall (m:Map A) (a:ad), Nleb (ad_alloc_opt m) a = false -> {y : A | MapGet A m a = Some y}.
Proof.
induction m as [| a y| m0 H m1 H0].
simpl in |- *.
intros b H.
elim (sumbool_of_bool (Neqb a N0)).
intro H0.
rewrite H0 in H.
unfold Nleb in H.
cut (N0 = b).
intro.
split with y.

*****
H1 : eq N0 b
H0 : eq (N.eqb a N0) true
H : eq (Nat.leb (N.to_nat (Npos xH)) (N.to_nat b)) false
b : ad
y : A
a : ad
A : Set
*****
eq (if N.eqb a b then Some y else None) (Some y)
+++++
rewrite <- H1.
-----
Lemma ad_alloc_opt_optimal_1 : forall (m:Map A) (a:ad), Nleb (ad_alloc_opt m) a = false -> {y : A | MapGet A m a = Some y}.
Proof.
induction m as [| a y| m0 H m1 H0].
simpl in |- *.
intros b H.
elim (sumbool_of_bool (Neqb a N0)).
intro H0.
rewrite H0 in H.
unfold Nleb in H.
cut (N0 = b).
intro.
split with y.
rewrite <- H1.

*****
H1 : eq N0 b
H0 : eq (N.eqb a N0) true
H : eq (Nat.leb (N.to_nat (Npos xH)) (N.to_nat b)) false
b : ad
y : A
a : ad
A : Set
*****
eq (if N.eqb a N0 then Some y else None) (Some y)
+++++
rewrite H0.
-----
Lemma ad_alloc_opt_optimal_1 : forall (m:Map A) (a:ad), Nleb (ad_alloc_opt m) a = false -> {y : A | MapGet A m a = Some y}.
Proof.
induction m as [| a y| m0 H m1 H0].
simpl in |- *.
intros b H.
elim (sumbool_of_bool (Neqb a N0)).
intro H0.
rewrite H0 in H.
unfold Nleb in H.
cut (N0 = b).
intro.
split with y.
rewrite <- H1.
rewrite H0.

*****
H1 : eq N0 b
H0 : eq (N.eqb a N0) true
H : eq (Nat.leb (N.to_nat (Npos xH)) (N.to_nat b)) false
b : ad
y : A
a : ad
A : Set
*****
eq (Some y) (Some y)
+++++
reflexivity.
-----
Lemma ad_alloc_opt_optimal_1 : forall (m:Map A) (a:ad), Nleb (ad_alloc_opt m) a = false -> {y : A | MapGet A m a = Some y}.
Proof.
induction m as [| a y| m0 H m1 H0].
simpl in |- *.
intros b H.
elim (sumbool_of_bool (Neqb a N0)).
intro H0.
rewrite H0 in H.
unfold Nleb in H.
cut (N0 = b).

*****
H0 : eq (N.eqb a N0) true
H : eq (Nat.leb (N.to_nat (Npos xH)) (N.to_nat b)) false
b : ad
y : A
a : ad
A : Set
*****
eq N0 b
+++++
rewrite <- (N_of_nat_of_N b).
-----
Lemma ad_alloc_opt_optimal_1 : forall (m:Map A) (a:ad), Nleb (ad_alloc_opt m) a = false -> {y : A | MapGet A m a = Some y}.
Proof.
induction m as [| a y| m0 H m1 H0].
simpl in |- *.
intros b H.
elim (sumbool_of_bool (Neqb a N0)).
intro H0.
rewrite H0 in H.
unfold Nleb in H.
cut (N0 = b).
rewrite <- (N_of_nat_of_N b).

*****
H0 : eq (N.eqb a N0) true
H : eq (Nat.leb (N.to_nat (Npos xH)) (N.to_nat b)) false
b : ad
y : A
a : ad
A : Set
*****
eq N0 (N.of_nat (N.to_nat b))
+++++
rewrite <- (le_n_O_eq _ (le_S_n _ _ (leb_complete_conv _ _ H))).
-----
Lemma ad_alloc_opt_optimal_1 : forall (m:Map A) (a:ad), Nleb (ad_alloc_opt m) a = false -> {y : A | MapGet A m a = Some y}.
Proof.
induction m as [| a y| m0 H m1 H0].
simpl in |- *.
intros b H.
elim (sumbool_of_bool (Neqb a N0)).
intro H0.
rewrite H0 in H.
unfold Nleb in H.
cut (N0 = b).
rewrite <- (N_of_nat_of_N b).
rewrite <- (le_n_O_eq _ (le_S_n _ _ (leb_complete_conv _ _ H))).

*****
H0 : eq (N.eqb a N0) true
H : eq (Nat.leb (N.to_nat (Npos xH)) (N.to_nat b)) false
b : ad
y : A
a : ad
A : Set
*****
eq N0 (N.of_nat O)
+++++
reflexivity.
-----
Lemma ad_alloc_opt_optimal_1 : forall (m:Map A) (a:ad), Nleb (ad_alloc_opt m) a = false -> {y : A | MapGet A m a = Some y}.
Proof.
induction m as [| a y| m0 H m1 H0].
simpl in |- *.
intros b H.
elim (sumbool_of_bool (Neqb a N0)).

*****
H : eq (Nleb (if N.eqb a N0 then Npos xH else N0) b) false
b : ad
y : A
a : ad
A : Set
*****
forall _ : eq (N.eqb a N0) false, sig (fun y0 : A => eq (if N.eqb a b then Some y else None) (Some y0))
+++++
intro H0.
-----
Lemma ad_alloc_opt_optimal_1 : forall (m:Map A) (a:ad), Nleb (ad_alloc_opt m) a = false -> {y : A | MapGet A m a = Some y}.
Proof.
induction m as [| a y| m0 H m1 H0].
simpl in |- *.
intros b H.
elim (sumbool_of_bool (Neqb a N0)).
intro H0.

*****
H0 : eq (N.eqb a N0) false
H : eq (Nleb (if N.eqb a N0 then Npos xH else N0) b) false
b : ad
y : A
a : ad
A : Set
*****
sig (fun y0 : A => eq (if N.eqb a b then Some y else None) (Some y0))
+++++
rewrite H0 in H.
-----
Lemma ad_alloc_opt_optimal_1 : forall (m:Map A) (a:ad), Nleb (ad_alloc_opt m) a = false -> {y : A | MapGet A m a = Some y}.
Proof.
induction m as [| a y| m0 H m1 H0].
simpl in |- *.
intros b H.
elim (sumbool_of_bool (Neqb a N0)).
intro H0.
rewrite H0 in H.

*****
H0 : eq (N.eqb a N0) false
H : eq (Nleb N0 b) false
b : ad
y : A
a : ad
A : Set
*****
sig (fun y0 : A => eq (if N.eqb a b then Some y else None) (Some y0))
+++++
discriminate H.
-----
Lemma ad_alloc_opt_optimal_1 : forall (m:Map A) (a:ad), Nleb (ad_alloc_opt m) a = false -> {y : A | MapGet A m a = Some y}.
Proof.
induction m as [| a y| m0 H m1 H0].

*****
H0 : forall (a : ad) (_ : eq (Nleb (ad_alloc_opt m1) a) false),\nsig (fun y : A => eq (MapGet A m1 a) (Some y))
H : forall (a : ad) (_ : eq (Nleb (ad_alloc_opt m0) a) false),\nsig (fun y : A => eq (MapGet A m0 a) (Some y))
m0,m1 : Map A
A : Set
*****
forall (a : ad) (_ : eq (Nleb (ad_alloc_opt (M2 A m0 m1)) a) false), sig (fun y : A => eq (MapGet A (M2 A m0 m1) a) (Some y))
+++++
intros.
-----
Lemma ad_alloc_opt_optimal_1 : forall (m:Map A) (a:ad), Nleb (ad_alloc_opt m) a = false -> {y : A | MapGet A m a = Some y}.
Proof.
induction m as [| a y| m0 H m1 H0].
intros.

*****
H1 : eq (Nleb (ad_alloc_opt (M2 A m0 m1)) a) false
a : ad
H0 : forall (a : ad) (_ : eq (Nleb (ad_alloc_opt m1) a) false),\nsig (fun y : A => eq (MapGet A m1 a) (Some y))
H : forall (a : ad) (_ : eq (Nleb (ad_alloc_opt m0) a) false),\nsig (fun y : A => eq (MapGet A m0 a) (Some y))
m0,m1 : Map A
A : Set
*****
sig (fun y : A => eq (MapGet A (M2 A m0 m1) a) (Some y))
+++++
simpl in H1.
-----
Lemma ad_alloc_opt_optimal_1 : forall (m:Map A) (a:ad), Nleb (ad_alloc_opt m) a = false -> {y : A | MapGet A m a = Some y}.
Proof.
induction m as [| a y| m0 H m1 H0].
intros.
simpl in H1.

*****
H1 : eq\n (Nleb\n (N.min (N.double (ad_alloc_opt m0))\n (N.succ_double (ad_alloc_opt m1))) a) false
a : ad
H0 : forall (a : ad) (_ : eq (Nleb (ad_alloc_opt m1) a) false),\nsig (fun y : A => eq (MapGet A m1 a) (Some y))
H : forall (a : ad) (_ : eq (Nleb (ad_alloc_opt m0) a) false),\nsig (fun y : A => eq (MapGet A m0 a) (Some y))
m0,m1 : Map A
A : Set
*****
sig (fun y : A => eq (MapGet A (M2 A m0 m1) a) (Some y))
+++++
elim (Ndouble_or_double_plus_un a).
-----
Lemma ad_alloc_opt_optimal_1 : forall (m:Map A) (a:ad), Nleb (ad_alloc_opt m) a = false -> {y : A | MapGet A m a = Some y}.
Proof.
induction m as [| a y| m0 H m1 H0].
intros.
simpl in H1.
elim (Ndouble_or_double_plus_un a).

*****
H1 : eq\n (Nleb\n (N.min (N.double (ad_alloc_opt m0))\n (N.succ_double (ad_alloc_opt m1))) a) false
a : ad
H0 : forall (a : ad) (_ : eq (Nleb (ad_alloc_opt m1) a) false),\nsig (fun y : A => eq (MapGet A m1 a) (Some y))
H : forall (a : ad) (_ : eq (Nleb (ad_alloc_opt m0) a) false),\nsig (fun y : A => eq (MapGet A m0 a) (Some y))
m0,m1 : Map A
A : Set
*****
forall _ : sig (fun a0 : N => eq a (N.double a0)), sig (fun y : A => eq (MapGet A (M2 A m0 m1) a) (Some y))
+++++
intro H2.
-----
Lemma ad_alloc_opt_optimal_1 : forall (m:Map A) (a:ad), Nleb (ad_alloc_opt m) a = false -> {y : A | MapGet A m a = Some y}.
Proof.
induction m as [| a y| m0 H m1 H0].
intros.
simpl in H1.
elim (Ndouble_or_double_plus_un a).
intro H2.

*****
H2 : sig (fun a0 : N => eq a (N.double a0))
H1 : eq\n (Nleb\n (N.min (N.double (ad_alloc_opt m0))\n (N.succ_double (ad_alloc_opt m1))) a) false
a : ad
H0 : forall (a : ad) (_ : eq (Nleb (ad_alloc_opt m1) a) false),\nsig (fun y : A => eq (MapGet A m1 a) (Some y))
H : forall (a : ad) (_ : eq (Nleb (ad_alloc_opt m0) a) false),\nsig (fun y : A => eq (MapGet A m0 a) (Some y))
m0,m1 : Map A
A : Set
*****
sig (fun y : A => eq (MapGet A (M2 A m0 m1) a) (Some y))
+++++
elim H2.
-----
Lemma ad_alloc_opt_optimal_1 : forall (m:Map A) (a:ad), Nleb (ad_alloc_opt m) a = false -> {y : A | MapGet A m a = Some y}.
Proof.
induction m as [| a y| m0 H m1 H0].
intros.
simpl in H1.
elim (Ndouble_or_double_plus_un a).
intro H2.
elim H2.

*****
H2 : sig (fun a0 : N => eq a (N.double a0))
H1 : eq\n (Nleb\n (N.min (N.double (ad_alloc_opt m0))\n (N.succ_double (ad_alloc_opt m1))) a) false
a : ad
H0 : forall (a : ad) (_ : eq (Nleb (ad_alloc_opt m1) a) false),\nsig (fun y : A => eq (MapGet A m1 a) (Some y))
H : forall (a : ad) (_ : eq (Nleb (ad_alloc_opt m0) a) false),\nsig (fun y : A => eq (MapGet A m0 a) (Some y))
m0,m1 : Map A
A : Set
*****
forall (x : N) (_ : eq a (N.double x)), sig (fun y : A => eq (MapGet A (M2 A m0 m1) a) (Some y))
+++++
intros a0 H3.
-----
Lemma ad_alloc_opt_optimal_1 : forall (m:Map A) (a:ad), Nleb (ad_alloc_opt m) a = false -> {y : A | MapGet A m a = Some y}.
Proof.
induction m as [| a y| m0 H m1 H0].
intros.
simpl in H1.
elim (Ndouble_or_double_plus_un a).
intro H2.
elim H2.
intros a0 H3.

*****
H3 : eq a (N.double a0)
a0 : N
H2 : sig (fun a0 : N => eq a (N.double a0))
H1 : eq\n (Nleb\n (N.min (N.double (ad_alloc_opt m0))\n (N.succ_double (ad_alloc_opt m1))) a) false
a : ad
H0 : forall (a : ad) (_ : eq (Nleb (ad_alloc_opt m1) a) false),\nsig (fun y : A => eq (MapGet A m1 a) (Some y))
H : forall (a : ad) (_ : eq (Nleb (ad_alloc_opt m0) a) false),\nsig (fun y : A => eq (MapGet A m0 a) (Some y))
m0,m1 : Map A
A : Set
*****
sig (fun y : A => eq (MapGet A (M2 A m0 m1) a) (Some y))
+++++
rewrite H3 in H1.
-----
Lemma ad_alloc_opt_optimal_1 : forall (m:Map A) (a:ad), Nleb (ad_alloc_opt m) a = false -> {y : A | MapGet A m a = Some y}.
Proof.
induction m as [| a y| m0 H m1 H0].
intros.
simpl in H1.
elim (Ndouble_or_double_plus_un a).
intro H2.
elim H2.
intros a0 H3.
rewrite H3 in H1.

*****
H3 : eq a (N.double a0)
H2 : sig (fun a0 : N => eq a (N.double a0))
H1 : eq\n (Nleb\n (N.min (N.double (ad_alloc_opt m0))\n (N.succ_double (ad_alloc_opt m1))) (N.double a0)) false
a0 : N
a : ad
H0 : forall (a : ad) (_ : eq (Nleb (ad_alloc_opt m1) a) false),\nsig (fun y : A => eq (MapGet A m1 a) (Some y))
H : forall (a : ad) (_ : eq (Nleb (ad_alloc_opt m0) a) false),\nsig (fun y : A => eq (MapGet A m0 a) (Some y))
m0,m1 : Map A
A : Set
*****
sig (fun y : A => eq (MapGet A (M2 A m0 m1) a) (Some y))
+++++
elim (H _ (Nltb_double_mono_conv _ _ (Nmin_lt_3 _ _ _ H1))).
-----
Lemma ad_alloc_opt_optimal_1 : forall (m:Map A) (a:ad), Nleb (ad_alloc_opt m) a = false -> {y : A | MapGet A m a = Some y}.
Proof.
induction m as [| a y| m0 H m1 H0].
intros.
simpl in H1.
elim (Ndouble_or_double_plus_un a).
intro H2.
elim H2.
intros a0 H3.
rewrite H3 in H1.
elim (H _ (Nltb_double_mono_conv _ _ (Nmin_lt_3 _ _ _ H1))).

*****
H3 : eq a (N.double a0)
H2 : sig (fun a0 : N => eq a (N.double a0))
H1 : eq\n (Nleb\n (N.min (N.double (ad_alloc_opt m0))\n (N.succ_double (ad_alloc_opt m1))) (N.double a0)) false
a0 : N
a : ad
H0 : forall (a : ad) (_ : eq (Nleb (ad_alloc_opt m1) a) false),\nsig (fun y : A => eq (MapGet A m1 a) (Some y))
H : forall (a : ad) (_ : eq (Nleb (ad_alloc_opt m0) a) false),\nsig (fun y : A => eq (MapGet A m0 a) (Some y))
m0,m1 : Map A
A : Set
*****
forall (x : A) (_ : eq (MapGet A m0 a0) (Some x)), sig (fun y : A => eq (MapGet A (M2 A m0 m1) a) (Some y))
+++++
intros y H4.
-----
Lemma ad_alloc_opt_optimal_1 : forall (m:Map A) (a:ad), Nleb (ad_alloc_opt m) a = false -> {y : A | MapGet A m a = Some y}.
Proof.
induction m as [| a y| m0 H m1 H0].
intros.
simpl in H1.
elim (Ndouble_or_double_plus_un a).
intro H2.
elim H2.
intros a0 H3.
rewrite H3 in H1.
elim (H _ (Nltb_double_mono_conv _ _ (Nmin_lt_3 _ _ _ H1))).
intros y H4.

*****
H4 : eq (MapGet A m0 a0) (Some y)
y : A
H3 : eq a (N.double a0)
H2 : sig (fun a0 : N => eq a (N.double a0))
H1 : eq\n (Nleb\n (N.min (N.double (ad_alloc_opt m0))\n (N.succ_double (ad_alloc_opt m1))) (N.double a0)) false
a0 : N
a : ad
H0 : forall (a : ad) (_ : eq (Nleb (ad_alloc_opt m1) a) false),\nsig (fun y : A => eq (MapGet A m1 a) (Some y))
H : forall (a : ad) (_ : eq (Nleb (ad_alloc_opt m0) a) false),\nsig (fun y : A => eq (MapGet A m0 a) (Some y))
m0,m1 : Map A
A : Set
*****
sig (fun y : A => eq (MapGet A (M2 A m0 m1) a) (Some y))
+++++
split with y.
-----
Lemma ad_alloc_opt_optimal_1 : forall (m:Map A) (a:ad), Nleb (ad_alloc_opt m) a = false -> {y : A | MapGet A m a = Some y}.
Proof.
induction m as [| a y| m0 H m1 H0].
intros.
simpl in H1.
elim (Ndouble_or_double_plus_un a).
intro H2.
elim H2.
intros a0 H3.
rewrite H3 in H1.
elim (H _ (Nltb_double_mono_conv _ _ (Nmin_lt_3 _ _ _ H1))).
intros y H4.
split with y.

*****
H4 : eq (MapGet A m0 a0) (Some y)
y : A
H3 : eq a (N.double a0)
H2 : sig (fun a0 : N => eq a (N.double a0))
H1 : eq\n (Nleb\n (N.min (N.double (ad_alloc_opt m0))\n (N.succ_double (ad_alloc_opt m1))) (N.double a0)) false
a0 : N
a : ad
H0 : forall (a : ad) (_ : eq (Nleb (ad_alloc_opt m1) a) false),\nsig (fun y : A => eq (MapGet A m1 a) (Some y))
H : forall (a : ad) (_ : eq (Nleb (ad_alloc_opt m0) a) false),\nsig (fun y : A => eq (MapGet A m0 a) (Some y))
m0,m1 : Map A
A : Set
*****
eq (MapGet A (M2 A m0 m1) a) (Some y)
+++++
rewrite H3.
-----
Lemma ad_alloc_opt_optimal_1 : forall (m:Map A) (a:ad), Nleb (ad_alloc_opt m) a = false -> {y : A | MapGet A m a = Some y}.
Proof.
induction m as [| a y| m0 H m1 H0].
intros.
simpl in H1.
elim (Ndouble_or_double_plus_un a).
intro H2.
elim H2.
intros a0 H3.
rewrite H3 in H1.
elim (H _ (Nltb_double_mono_conv _ _ (Nmin_lt_3 _ _ _ H1))).
intros y H4.
split with y.
rewrite H3.

*****
H4 : eq (MapGet A m0 a0) (Some y)
y : A
H3 : eq a (N.double a0)
H2 : sig (fun a0 : N => eq a (N.double a0))
H1 : eq\n (Nleb\n (N.min (N.double (ad_alloc_opt m0))\n (N.succ_double (ad_alloc_opt m1))) (N.double a0)) false
a0 : N
a : ad
H0 : forall (a : ad) (_ : eq (Nleb (ad_alloc_opt m1) a) false),\nsig (fun y : A => eq (MapGet A m1 a) (Some y))
H : forall (a : ad) (_ : eq (Nleb (ad_alloc_opt m0) a) false),\nsig (fun y : A => eq (MapGet A m0 a) (Some y))
m0,m1 : Map A
A : Set
*****
eq (MapGet A (M2 A m0 m1) (N.double a0)) (Some y)
+++++
rewrite MapGet_M2_bit_0_0.
-----
Lemma ad_alloc_opt_optimal_1 : forall (m:Map A) (a:ad), Nleb (ad_alloc_opt m) a = false -> {y : A | MapGet A m a = Some y}.
Proof.
induction m as [| a y| m0 H m1 H0].
intros.
simpl in H1.
elim (Ndouble_or_double_plus_un a).
intro H2.
elim H2.
intros a0 H3.
rewrite H3 in H1.
elim (H _ (Nltb_double_mono_conv _ _ (Nmin_lt_3 _ _ _ H1))).
intros y H4.
split with y.
rewrite H3.
rewrite MapGet_M2_bit_0_0.

*****
H4 : eq (MapGet A m0 a0) (Some y)
y : A
H3 : eq a (N.double a0)
H2 : sig (fun a0 : N => eq a (N.double a0))
H1 : eq\n (Nleb\n (N.min (N.double (ad_alloc_opt m0))\n (N.succ_double (ad_alloc_opt m1))) (N.double a0)) false
a0 : N
a : ad
H0 : forall (a : ad) (_ : eq (Nleb (ad_alloc_opt m1) a) false),\nsig (fun y : A => eq (MapGet A m1 a) (Some y))
H : forall (a : ad) (_ : eq (Nleb (ad_alloc_opt m0) a) false),\nsig (fun y : A => eq (MapGet A m0 a) (Some y))
m0,m1 : Map A
A : Set
*****
eq (MapGet A m0 (N.div2 (N.double a0))) (Some y)
+++++
rewrite Ndouble_div2.
-----
Lemma ad_alloc_opt_optimal_1 : forall (m:Map A) (a:ad), Nleb (ad_alloc_opt m) a = false -> {y : A | MapGet A m a = Some y}.
Proof.
induction m as [| a y| m0 H m1 H0].
intros.
simpl in H1.
elim (Ndouble_or_double_plus_un a).
intro H2.
elim H2.
intros a0 H3.
rewrite H3 in H1.
elim (H _ (Nltb_double_mono_conv _ _ (Nmin_lt_3 _ _ _ H1))).
intros y H4.
split with y.
rewrite H3.
rewrite MapGet_M2_bit_0_0.
rewrite Ndouble_div2.

*****
H4 : eq (MapGet A m0 a0) (Some y)
y : A
H3 : eq a (N.double a0)
H2 : sig (fun a0 : N => eq a (N.double a0))
H1 : eq\n (Nleb\n (N.min (N.double (ad_alloc_opt m0))\n (N.succ_double (ad_alloc_opt m1))) (N.double a0)) false
a0 : N
a : ad
H0 : forall (a : ad) (_ : eq (Nleb (ad_alloc_opt m1) a) false),\nsig (fun y : A => eq (MapGet A m1 a) (Some y))
H : forall (a : ad) (_ : eq (Nleb (ad_alloc_opt m0) a) false),\nsig (fun y : A => eq (MapGet A m0 a) (Some y))
m0,m1 : Map A
A : Set
*****
eq (MapGet A m0 a0) (Some y)
+++++
assumption.
-----
Lemma ad_alloc_opt_optimal_1 : forall (m:Map A) (a:ad), Nleb (ad_alloc_opt m) a = false -> {y : A | MapGet A m a = Some y}.
Proof.
induction m as [| a y| m0 H m1 H0].
intros.
simpl in H1.
elim (Ndouble_or_double_plus_un a).
intro H2.
elim H2.
intros a0 H3.
rewrite H3 in H1.
elim (H _ (Nltb_double_mono_conv _ _ (Nmin_lt_3 _ _ _ H1))).
intros y H4.
split with y.
rewrite H3.
rewrite MapGet_M2_bit_0_0.

*****
H4 : eq (MapGet A m0 a0) (Some y)
y : A
H3 : eq a (N.double a0)
H2 : sig (fun a0 : N => eq a (N.double a0))
H1 : eq\n (Nleb\n (N.min (N.double (ad_alloc_opt m0))\n (N.succ_double (ad_alloc_opt m1))) (N.double a0)) false
a0 : N
a : ad
H0 : forall (a : ad) (_ : eq (Nleb (ad_alloc_opt m1) a) false),\nsig (fun y : A => eq (MapGet A m1 a) (Some y))
H : forall (a : ad) (_ : eq (Nleb (ad_alloc_opt m0) a) false),\nsig (fun y : A => eq (MapGet A m0 a) (Some y))
m0,m1 : Map A
A : Set
*****
eq (N.odd (N.double a0)) false
+++++
apply Ndouble_bit0.
-----
Lemma ad_alloc_opt_optimal_1 : forall (m:Map A) (a:ad), Nleb (ad_alloc_opt m) a = false -> {y : A | MapGet A m a = Some y}.
Proof.
induction m as [| a y| m0 H m1 H0].
intros.
simpl in H1.
elim (Ndouble_or_double_plus_un a).

*****
H1 : eq\n (Nleb\n (N.min (N.double (ad_alloc_opt m0))\n (N.succ_double (ad_alloc_opt m1))) a) false
a : ad
H0 : forall (a : ad) (_ : eq (Nleb (ad_alloc_opt m1) a) false),\nsig (fun y : A => eq (MapGet A m1 a) (Some y))
H : forall (a : ad) (_ : eq (Nleb (ad_alloc_opt m0) a) false),\nsig (fun y : A => eq (MapGet A m0 a) (Some y))
m0,m1 : Map A
A : Set
*****
forall _ : sig (fun a1 : N => eq a (N.succ_double a1)), sig (fun y : A => eq (MapGet A (M2 A m0 m1) a) (Some y))
+++++
intro H2.
-----
Lemma ad_alloc_opt_optimal_1 : forall (m:Map A) (a:ad), Nleb (ad_alloc_opt m) a = false -> {y : A | MapGet A m a = Some y}.
Proof.
induction m as [| a y| m0 H m1 H0].
intros.
simpl in H1.
elim (Ndouble_or_double_plus_un a).
intro H2.

*****
H2 : sig (fun a1 : N => eq a (N.succ_double a1))
H1 : eq\n (Nleb\n (N.min (N.double (ad_alloc_opt m0))\n (N.succ_double (ad_alloc_opt m1))) a) false
a : ad
H0 : forall (a : ad) (_ : eq (Nleb (ad_alloc_opt m1) a) false),\nsig (fun y : A => eq (MapGet A m1 a) (Some y))
H : forall (a : ad) (_ : eq (Nleb (ad_alloc_opt m0) a) false),\nsig (fun y : A => eq (MapGet A m0 a) (Some y))
m0,m1 : Map A
A : Set
*****
sig (fun y : A => eq (MapGet A (M2 A m0 m1) a) (Some y))
+++++
elim H2.
-----
Lemma ad_alloc_opt_optimal_1 : forall (m:Map A) (a:ad), Nleb (ad_alloc_opt m) a = false -> {y : A | MapGet A m a = Some y}.
Proof.
induction m as [| a y| m0 H m1 H0].
intros.
simpl in H1.
elim (Ndouble_or_double_plus_un a).
intro H2.
elim H2.

*****
H2 : sig (fun a1 : N => eq a (N.succ_double a1))
H1 : eq\n (Nleb\n (N.min (N.double (ad_alloc_opt m0))\n (N.succ_double (ad_alloc_opt m1))) a) false
a : ad
H0 : forall (a : ad) (_ : eq (Nleb (ad_alloc_opt m1) a) false),\nsig (fun y : A => eq (MapGet A m1 a) (Some y))
H : forall (a : ad) (_ : eq (Nleb (ad_alloc_opt m0) a) false),\nsig (fun y : A => eq (MapGet A m0 a) (Some y))
m0,m1 : Map A
A : Set
*****
forall (x : N) (_ : eq a (N.succ_double x)), sig (fun y : A => eq (MapGet A (M2 A m0 m1) a) (Some y))
+++++
intros a0 H3.
-----
Lemma ad_alloc_opt_optimal_1 : forall (m:Map A) (a:ad), Nleb (ad_alloc_opt m) a = false -> {y : A | MapGet A m a = Some y}.
Proof.
induction m as [| a y| m0 H m1 H0].
intros.
simpl in H1.
elim (Ndouble_or_double_plus_un a).
intro H2.
elim H2.
intros a0 H3.

*****
H3 : eq a (N.succ_double a0)
a0 : N
H2 : sig (fun a1 : N => eq a (N.succ_double a1))
H1 : eq\n (Nleb\n (N.min (N.double (ad_alloc_opt m0))\n (N.succ_double (ad_alloc_opt m1))) a) false
a : ad
H0 : forall (a : ad) (_ : eq (Nleb (ad_alloc_opt m1) a) false),\nsig (fun y : A => eq (MapGet A m1 a) (Some y))
H : forall (a : ad) (_ : eq (Nleb (ad_alloc_opt m0) a) false),\nsig (fun y : A => eq (MapGet A m0 a) (Some y))
m0,m1 : Map A
A : Set
*****
sig (fun y : A => eq (MapGet A (M2 A m0 m1) a) (Some y))
+++++
rewrite H3 in H1.
-----
Lemma ad_alloc_opt_optimal_1 : forall (m:Map A) (a:ad), Nleb (ad_alloc_opt m) a = false -> {y : A | MapGet A m a = Some y}.
Proof.
induction m as [| a y| m0 H m1 H0].
intros.
simpl in H1.
elim (Ndouble_or_double_plus_un a).
intro H2.
elim H2.
intros a0 H3.
rewrite H3 in H1.

*****
H3 : eq a (N.succ_double a0)
H2 : sig (fun a1 : N => eq a (N.succ_double a1))
H1 : eq\n (Nleb\n (N.min (N.double (ad_alloc_opt m0))\n (N.succ_double (ad_alloc_opt m1))) (N.succ_double a0)) false
a0 : N
a : ad
H0 : forall (a : ad) (_ : eq (Nleb (ad_alloc_opt m1) a) false),\nsig (fun y : A => eq (MapGet A m1 a) (Some y))
H : forall (a : ad) (_ : eq (Nleb (ad_alloc_opt m0) a) false),\nsig (fun y : A => eq (MapGet A m0 a) (Some y))
m0,m1 : Map A
A : Set
*****
sig (fun y : A => eq (MapGet A (M2 A m0 m1) a) (Some y))
+++++
elim (H0 _ (Nltb_double_plus_one_mono_conv _ _ (Nmin_lt_4 _ _ _ H1))).
-----
Lemma ad_alloc_opt_optimal_1 : forall (m:Map A) (a:ad), Nleb (ad_alloc_opt m) a = false -> {y : A | MapGet A m a = Some y}.
Proof.
induction m as [| a y| m0 H m1 H0].
intros.
simpl in H1.
elim (Ndouble_or_double_plus_un a).
intro H2.
elim H2.
intros a0 H3.
rewrite H3 in H1.
elim (H0 _ (Nltb_double_plus_one_mono_conv _ _ (Nmin_lt_4 _ _ _ H1))).

*****
H3 : eq a (N.succ_double a0)
H2 : sig (fun a1 : N => eq a (N.succ_double a1))
H1 : eq\n (Nleb\n (N.min (N.double (ad_alloc_opt m0))\n (N.succ_double (ad_alloc_opt m1))) (N.succ_double a0)) false
a0 : N
a : ad
H0 : forall (a : ad) (_ : eq (Nleb (ad_alloc_opt m1) a) false),\nsig (fun y : A => eq (MapGet A m1 a) (Some y))
H : forall (a : ad) (_ : eq (Nleb (ad_alloc_opt m0) a) false),\nsig (fun y : A => eq (MapGet A m0 a) (Some y))
m0,m1 : Map A
A : Set
*****
forall (x : A) (_ : eq (MapGet A m1 a0) (Some x)), sig (fun y : A => eq (MapGet A (M2 A m0 m1) a) (Some y))
+++++
intros y H4.
-----
Lemma ad_alloc_opt_optimal_1 : forall (m:Map A) (a:ad), Nleb (ad_alloc_opt m) a = false -> {y : A | MapGet A m a = Some y}.
Proof.
induction m as [| a y| m0 H m1 H0].
intros.
simpl in H1.
elim (Ndouble_or_double_plus_un a).
intro H2.
elim H2.
intros a0 H3.
rewrite H3 in H1.
elim (H0 _ (Nltb_double_plus_one_mono_conv _ _ (Nmin_lt_4 _ _ _ H1))).
intros y H4.

*****
H4 : eq (MapGet A m1 a0) (Some y)
y : A
H3 : eq a (N.succ_double a0)
H2 : sig (fun a1 : N => eq a (N.succ_double a1))
H1 : eq\n (Nleb\n (N.min (N.double (ad_alloc_opt m0))\n (N.succ_double (ad_alloc_opt m1))) (N.succ_double a0)) false
a0 : N
a : ad
H0 : forall (a : ad) (_ : eq (Nleb (ad_alloc_opt m1) a) false),\nsig (fun y : A => eq (MapGet A m1 a) (Some y))
H : forall (a : ad) (_ : eq (Nleb (ad_alloc_opt m0) a) false),\nsig (fun y : A => eq (MapGet A m0 a) (Some y))
m0,m1 : Map A
A : Set
*****
sig (fun y : A => eq (MapGet A (M2 A m0 m1) a) (Some y))
+++++
split with y.
-----
Lemma ad_alloc_opt_optimal_1 : forall (m:Map A) (a:ad), Nleb (ad_alloc_opt m) a = false -> {y : A | MapGet A m a = Some y}.
Proof.
induction m as [| a y| m0 H m1 H0].
intros.
simpl in H1.
elim (Ndouble_or_double_plus_un a).
intro H2.
elim H2.
intros a0 H3.
rewrite H3 in H1.
elim (H0 _ (Nltb_double_plus_one_mono_conv _ _ (Nmin_lt_4 _ _ _ H1))).
intros y H4.
split with y.

*****
H4 : eq (MapGet A m1 a0) (Some y)
y : A
H3 : eq a (N.succ_double a0)
H2 : sig (fun a1 : N => eq a (N.succ_double a1))
H1 : eq\n (Nleb\n (N.min (N.double (ad_alloc_opt m0))\n (N.succ_double (ad_alloc_opt m1))) (N.succ_double a0)) false
a0 : N
a : ad
H0 : forall (a : ad) (_ : eq (Nleb (ad_alloc_opt m1) a) false),\nsig (fun y : A => eq (MapGet A m1 a) (Some y))
H : forall (a : ad) (_ : eq (Nleb (ad_alloc_opt m0) a) false),\nsig (fun y : A => eq (MapGet A m0 a) (Some y))
m0,m1 : Map A
A : Set
*****
eq (MapGet A (M2 A m0 m1) a) (Some y)
+++++
rewrite H3.
-----
Lemma ad_alloc_opt_optimal_1 : forall (m:Map A) (a:ad), Nleb (ad_alloc_opt m) a = false -> {y : A | MapGet A m a = Some y}.
Proof.
induction m as [| a y| m0 H m1 H0].
intros.
simpl in H1.
elim (Ndouble_or_double_plus_un a).
intro H2.
elim H2.
intros a0 H3.
rewrite H3 in H1.
elim (H0 _ (Nltb_double_plus_one_mono_conv _ _ (Nmin_lt_4 _ _ _ H1))).
intros y H4.
split with y.
rewrite H3.

*****
H4 : eq (MapGet A m1 a0) (Some y)
y : A
H3 : eq a (N.succ_double a0)
H2 : sig (fun a1 : N => eq a (N.succ_double a1))
H1 : eq\n (Nleb\n (N.min (N.double (ad_alloc_opt m0))\n (N.succ_double (ad_alloc_opt m1))) (N.succ_double a0)) false
a0 : N
a : ad
H0 : forall (a : ad) (_ : eq (Nleb (ad_alloc_opt m1) a) false),\nsig (fun y : A => eq (MapGet A m1 a) (Some y))
H : forall (a : ad) (_ : eq (Nleb (ad_alloc_opt m0) a) false),\nsig (fun y : A => eq (MapGet A m0 a) (Some y))
m0,m1 : Map A
A : Set
*****
eq (MapGet A (M2 A m0 m1) (N.succ_double a0)) (Some y)
+++++
rewrite MapGet_M2_bit_0_1.
-----
Lemma ad_alloc_opt_optimal_1 : forall (m:Map A) (a:ad), Nleb (ad_alloc_opt m) a = false -> {y : A | MapGet A m a = Some y}.
Proof.
induction m as [| a y| m0 H m1 H0].
intros.
simpl in H1.
elim (Ndouble_or_double_plus_un a).
intro H2.
elim H2.
intros a0 H3.
rewrite H3 in H1.
elim (H0 _ (Nltb_double_plus_one_mono_conv _ _ (Nmin_lt_4 _ _ _ H1))).
intros y H4.
split with y.
rewrite H3.
rewrite MapGet_M2_bit_0_1.

*****
H4 : eq (MapGet A m1 a0) (Some y)
y : A
H3 : eq a (N.succ_double a0)
H2 : sig (fun a1 : N => eq a (N.succ_double a1))
H1 : eq\n (Nleb\n (N.min (N.double (ad_alloc_opt m0))\n (N.succ_double (ad_alloc_opt m1))) (N.succ_double a0)) false
a0 : N
a : ad
H0 : forall (a : ad) (_ : eq (Nleb (ad_alloc_opt m1) a) false),\nsig (fun y : A => eq (MapGet A m1 a) (Some y))
H : forall (a : ad) (_ : eq (Nleb (ad_alloc_opt m0) a) false),\nsig (fun y : A => eq (MapGet A m0 a) (Some y))
m0,m1 : Map A
A : Set
*****
eq (MapGet A m1 (N.div2 (N.succ_double a0))) (Some y)
+++++
rewrite Ndouble_plus_one_div2.
-----
Lemma ad_alloc_opt_optimal_1 : forall (m:Map A) (a:ad), Nleb (ad_alloc_opt m) a = false -> {y : A | MapGet A m a = Some y}.
Proof.
induction m as [| a y| m0 H m1 H0].
intros.
simpl in H1.
elim (Ndouble_or_double_plus_un a).
intro H2.
elim H2.
intros a0 H3.
rewrite H3 in H1.
elim (H0 _ (Nltb_double_plus_one_mono_conv _ _ (Nmin_lt_4 _ _ _ H1))).
intros y H4.
split with y.
rewrite H3.
rewrite MapGet_M2_bit_0_1.
rewrite Ndouble_plus_one_div2.

*****
H4 : eq (MapGet A m1 a0) (Some y)
y : A
H3 : eq a (N.succ_double a0)
H2 : sig (fun a1 : N => eq a (N.succ_double a1))
H1 : eq\n (Nleb\n (N.min (N.double (ad_alloc_opt m0))\n (N.succ_double (ad_alloc_opt m1))) (N.succ_double a0)) false
a0 : N
a : ad
H0 : forall (a : ad) (_ : eq (Nleb (ad_alloc_opt m1) a) false),\nsig (fun y : A => eq (MapGet A m1 a) (Some y))
H : forall (a : ad) (_ : eq (Nleb (ad_alloc_opt m0) a) false),\nsig (fun y : A => eq (MapGet A m0 a) (Some y))
m0,m1 : Map A
A : Set
*****
eq (MapGet A m1 a0) (Some y)
+++++
assumption.
-----
Lemma ad_alloc_opt_optimal_1 : forall (m:Map A) (a:ad), Nleb (ad_alloc_opt m) a = false -> {y : A | MapGet A m a = Some y}.
Proof.
induction m as [| a y| m0 H m1 H0].
intros.
simpl in H1.
elim (Ndouble_or_double_plus_un a).
intro H2.
elim H2.
intros a0 H3.
rewrite H3 in H1.
elim (H0 _ (Nltb_double_plus_one_mono_conv _ _ (Nmin_lt_4 _ _ _ H1))).
intros y H4.
split with y.
rewrite H3.
rewrite MapGet_M2_bit_0_1.

*****
H4 : eq (MapGet A m1 a0) (Some y)
y : A
H3 : eq a (N.succ_double a0)
H2 : sig (fun a1 : N => eq a (N.succ_double a1))
H1 : eq\n (Nleb\n (N.min (N.double (ad_alloc_opt m0))\n (N.succ_double (ad_alloc_opt m1))) (N.succ_double a0)) false
a0 : N
a : ad
H0 : forall (a : ad) (_ : eq (Nleb (ad_alloc_opt m1) a) false),\nsig (fun y : A => eq (MapGet A m1 a) (Some y))
H : forall (a : ad) (_ : eq (Nleb (ad_alloc_opt m0) a) false),\nsig (fun y : A => eq (MapGet A m0 a) (Some y))
m0,m1 : Map A
A : Set
*****
eq (N.odd (N.succ_double a0)) true
+++++
apply Ndouble_plus_one_bit0.
-----
Lemma ad_alloc_opt_optimal_1 : forall (m:Map A) (a:ad), Nleb (ad_alloc_opt m) a = false -> {y : A | MapGet A m a = Some y}.
Proof.
induction m as [| a y| m0 H m1 H0].

*****

*****

+++++
Qed.
-----
Lemma ad_alloc_opt_optimal :\n   forall (m:Map A) (a:ad),\n     Nleb (ad_alloc_opt m) a = false -> in_dom A a m = true.
-----
Lemma ad_alloc_opt_optimal : forall (m:Map A) (a:ad), Nleb (ad_alloc_opt m) a = false -> in_dom A a m = true.

*****
A : Set
*****
forall (m : Map A) (a : ad) (_ : eq (Nleb (ad_alloc_opt m) a) false), eq (in_dom A a m) true
+++++
Proof.
-----
Lemma ad_alloc_opt_optimal : forall (m:Map A) (a:ad), Nleb (ad_alloc_opt m) a = false -> in_dom A a m = true.
Proof.

*****
A : Set
*****
forall (m : Map A) (a : ad) (_ : eq (Nleb (ad_alloc_opt m) a) false), eq (in_dom A a m) true
+++++
intros.
-----
Lemma ad_alloc_opt_optimal : forall (m:Map A) (a:ad), Nleb (ad_alloc_opt m) a = false -> in_dom A a m = true.
Proof.
intros.

*****
H : eq (Nleb (ad_alloc_opt m) a) false
a : ad
m : Map A
A : Set
*****
eq (in_dom A a m) true
+++++
unfold in_dom in |- *.
-----
Lemma ad_alloc_opt_optimal : forall (m:Map A) (a:ad), Nleb (ad_alloc_opt m) a = false -> in_dom A a m = true.
Proof.
intros.
unfold in_dom in |- *.

*****
H : eq (Nleb (ad_alloc_opt m) a) false
a : ad
m : Map A
A : Set
*****
eq match MapGet A m a with | Some _ => true | None => false end true
+++++
elim (ad_alloc_opt_optimal_1 m a H).
-----
Lemma ad_alloc_opt_optimal : forall (m:Map A) (a:ad), Nleb (ad_alloc_opt m) a = false -> in_dom A a m = true.
Proof.
intros.
unfold in_dom in |- *.
elim (ad_alloc_opt_optimal_1 m a H).

*****
H : eq (Nleb (ad_alloc_opt m) a) false
a : ad
m : Map A
A : Set
*****
forall (x : A) (_ : eq (MapGet A m a) (Some x)), eq match MapGet A m a with | Some _ => true | None => false end true
+++++
intros y H0.
-----
Lemma ad_alloc_opt_optimal : forall (m:Map A) (a:ad), Nleb (ad_alloc_opt m) a = false -> in_dom A a m = true.
Proof.
intros.
unfold in_dom in |- *.
elim (ad_alloc_opt_optimal_1 m a H).
intros y H0.

*****
H0 : eq (MapGet A m a) (Some y)
y : A
H : eq (Nleb (ad_alloc_opt m) a) false
a : ad
m : Map A
A : Set
*****
eq match MapGet A m a with | Some _ => true | None => false end true
+++++
rewrite H0.
-----
Lemma ad_alloc_opt_optimal : forall (m:Map A) (a:ad), Nleb (ad_alloc_opt m) a = false -> in_dom A a m = true.
Proof.
intros.
unfold in_dom in |- *.
elim (ad_alloc_opt_optimal_1 m a H).
intros y H0.
rewrite H0.

*****
H0 : eq (MapGet A m a) (Some y)
y : A
H : eq (Nleb (ad_alloc_opt m) a) false
a : ad
m : Map A
A : Set
*****
eq true true
+++++
reflexivity.
-----
Lemma ad_alloc_opt_optimal : forall (m:Map A) (a:ad), Nleb (ad_alloc_opt m) a = false -> in_dom A a m = true.
Proof.
intros.
unfold in_dom in |- *.
elim (ad_alloc_opt_optimal_1 m a H).
intros y H0.
rewrite H0.
reflexivity.

*****

*****

+++++
Qed.
-----
End AdAlloc.
-----
