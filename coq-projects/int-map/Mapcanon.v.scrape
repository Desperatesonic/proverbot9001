From Coq Require Import Bool.
-----
Require Import Coq.Bool.Sumbool.
-----
From Coq Require Import Arith.
-----
Require Import Coq.NArith.NArith.
-----
Require Import Coq.NArith.Ndigits.
-----
Require Import Coq.NArith.Ndec.
-----
Require Import Map.
-----
Require Import Mapaxioms.
-----
Require Import Mapiter.
-----
Require Import Fset.
-----
From Coq Require Import List.
-----
Require Import Lsort.
-----
Require Import Mapsubset.
-----
Require Import Mapcard.
-----
Section MapCanon.
-----
Variable A : Type.
-----
Inductive mapcanon : Map A -> Prop :=\n    | M0_canon : mapcanon (M0 A)\n    | M1_canon : forall (a:ad) (y:A), mapcanon (M1 A a y)\n    | M2_canon :\n        forall m1 m2:Map A,\n          mapcanon m1 ->\n          mapcanon m2 -> 2 <= MapCard A (M2 A m1 m2) -> mapcanon (M2 A m1 m2).
-----
Lemma mapcanon_M2 :\n   forall m1 m2:Map A, mapcanon (M2 A m1 m2) -> 2 <= MapCard A (M2 A m1 m2).
-----
Lemma mapcanon_M2 : forall m1 m2:Map A, mapcanon (M2 A m1 m2) -> 2 <= MapCard A (M2 A m1 m2).

*****
A : Type
*****
forall (m1 m2 : Map A) (_ : mapcanon (M2 A m1 m2)), le (S (S O)) (MapCard A (M2 A m1 m2))
+++++
Proof.
-----
Lemma mapcanon_M2 : forall m1 m2:Map A, mapcanon (M2 A m1 m2) -> 2 <= MapCard A (M2 A m1 m2).
Proof.

*****
A : Type
*****
forall (m1 m2 : Map A) (_ : mapcanon (M2 A m1 m2)), le (S (S O)) (MapCard A (M2 A m1 m2))
+++++
intros.
-----
Lemma mapcanon_M2 : forall m1 m2:Map A, mapcanon (M2 A m1 m2) -> 2 <= MapCard A (M2 A m1 m2).
Proof.
intros.

*****
H : mapcanon (M2 A m1 m2)
m1,m2 : Map A
A : Type
*****
le (S (S O)) (MapCard A (M2 A m1 m2))
+++++
inversion H.
-----
Lemma mapcanon_M2 : forall m1 m2:Map A, mapcanon (M2 A m1 m2) -> 2 <= MapCard A (M2 A m1 m2).
Proof.
intros.
inversion H.

*****
H1 : eq m3 m2
H0 : eq m0 m1
H4 : le (S (S O)) (MapCard A (M2 A m1 m2))
H3 : mapcanon m2
H2 : mapcanon m1
m0,m3 : Map A
H : mapcanon (M2 A m1 m2)
m1,m2 : Map A
A : Type
*****
le (S (S O)) (MapCard A (M2 A m1 m2))
+++++
assumption.
-----
Lemma mapcanon_M2 : forall m1 m2:Map A, mapcanon (M2 A m1 m2) -> 2 <= MapCard A (M2 A m1 m2).
Proof.
intros.
inversion H.
assumption.

*****

*****

+++++
Qed.
-----
Lemma mapcanon_M2_1 :\n   forall m1 m2:Map A, mapcanon (M2 A m1 m2) -> mapcanon m1.
-----
Lemma mapcanon_M2_1 : forall m1 m2:Map A, mapcanon (M2 A m1 m2) -> mapcanon m1.

*****
A : Type
*****
forall (m1 m2 : Map A) (_ : mapcanon (M2 A m1 m2)), mapcanon m1
+++++
Proof.
-----
Lemma mapcanon_M2_1 : forall m1 m2:Map A, mapcanon (M2 A m1 m2) -> mapcanon m1.
Proof.

*****
A : Type
*****
forall (m1 m2 : Map A) (_ : mapcanon (M2 A m1 m2)), mapcanon m1
+++++
intros.
-----
Lemma mapcanon_M2_1 : forall m1 m2:Map A, mapcanon (M2 A m1 m2) -> mapcanon m1.
Proof.
intros.

*****
H : mapcanon (M2 A m1 m2)
m1,m2 : Map A
A : Type
*****
mapcanon m1
+++++
inversion H.
-----
Lemma mapcanon_M2_1 : forall m1 m2:Map A, mapcanon (M2 A m1 m2) -> mapcanon m1.
Proof.
intros.
inversion H.

*****
H1 : eq m3 m2
H0 : eq m0 m1
H4 : le (S (S O)) (MapCard A (M2 A m1 m2))
H3 : mapcanon m2
H2 : mapcanon m1
m0,m3 : Map A
H : mapcanon (M2 A m1 m2)
m1,m2 : Map A
A : Type
*****
mapcanon m1
+++++
assumption.
-----
Lemma mapcanon_M2_1 : forall m1 m2:Map A, mapcanon (M2 A m1 m2) -> mapcanon m1.
Proof.
intros.
inversion H.
assumption.

*****

*****

+++++
Qed.
-----
Lemma mapcanon_M2_2 :\n   forall m1 m2:Map A, mapcanon (M2 A m1 m2) -> mapcanon m2.
-----
Lemma mapcanon_M2_2 : forall m1 m2:Map A, mapcanon (M2 A m1 m2) -> mapcanon m2.

*****
A : Type
*****
forall (m1 m2 : Map A) (_ : mapcanon (M2 A m1 m2)), mapcanon m2
+++++
Proof.
-----
Lemma mapcanon_M2_2 : forall m1 m2:Map A, mapcanon (M2 A m1 m2) -> mapcanon m2.
Proof.

*****
A : Type
*****
forall (m1 m2 : Map A) (_ : mapcanon (M2 A m1 m2)), mapcanon m2
+++++
intros.
-----
Lemma mapcanon_M2_2 : forall m1 m2:Map A, mapcanon (M2 A m1 m2) -> mapcanon m2.
Proof.
intros.

*****
H : mapcanon (M2 A m1 m2)
m1,m2 : Map A
A : Type
*****
mapcanon m2
+++++
inversion H.
-----
Lemma mapcanon_M2_2 : forall m1 m2:Map A, mapcanon (M2 A m1 m2) -> mapcanon m2.
Proof.
intros.
inversion H.

*****
H1 : eq m3 m2
H0 : eq m0 m1
H4 : le (S (S O)) (MapCard A (M2 A m1 m2))
H3 : mapcanon m2
H2 : mapcanon m1
m0,m3 : Map A
H : mapcanon (M2 A m1 m2)
m1,m2 : Map A
A : Type
*****
mapcanon m2
+++++
assumption.
-----
Lemma mapcanon_M2_2 : forall m1 m2:Map A, mapcanon (M2 A m1 m2) -> mapcanon m2.
Proof.
intros.
inversion H.
assumption.

*****

*****

+++++
Qed.
-----
Lemma M2_eqmap_1 :\n   forall m0 m1 m2 m3:Map A,\n     eqmap A (M2 A m0 m1) (M2 A m2 m3) -> eqmap A m0 m2.
-----
Lemma M2_eqmap_1 : forall m0 m1 m2 m3:Map A, eqmap A (M2 A m0 m1) (M2 A m2 m3) -> eqmap A m0 m2.

*****
A : Type
*****
forall (m0 m1 m2 m3 : Map A) (_ : eqmap A (M2 A m0 m1) (M2 A m2 m3)), eqmap A m0 m2
+++++
Proof.
-----
Lemma M2_eqmap_1 : forall m0 m1 m2 m3:Map A, eqmap A (M2 A m0 m1) (M2 A m2 m3) -> eqmap A m0 m2.
Proof.

*****
A : Type
*****
forall (m0 m1 m2 m3 : Map A) (_ : eqmap A (M2 A m0 m1) (M2 A m2 m3)), eqmap A m0 m2
+++++
unfold eqmap in |- *.
-----
Lemma M2_eqmap_1 : forall m0 m1 m2 m3:Map A, eqmap A (M2 A m0 m1) (M2 A m2 m3) -> eqmap A m0 m2.
Proof.
unfold eqmap in |- *.

*****
A : Type
*****
forall (m0 m1 m2 m3 : Map A) (_ : eqm A (MapGet A (M2 A m0 m1)) (MapGet A (M2 A m2 m3))), eqm A (MapGet A m0) (MapGet A m2)
+++++
unfold eqm in |- *.
-----
Lemma M2_eqmap_1 : forall m0 m1 m2 m3:Map A, eqmap A (M2 A m0 m1) (M2 A m2 m3) -> eqmap A m0 m2.
Proof.
unfold eqmap in |- *.
unfold eqm in |- *.

*****
A : Type
*****
forall (m0 m1 m2 m3 : Map A) (_ : forall a : ad, eq (MapGet A (M2 A m0 m1) a) (MapGet A (M2 A m2 m3) a)) (a : ad), eq (MapGet A m0 a) (MapGet A m2 a)
+++++
intros.
-----
Lemma M2_eqmap_1 : forall m0 m1 m2 m3:Map A, eqmap A (M2 A m0 m1) (M2 A m2 m3) -> eqmap A m0 m2.
Proof.
unfold eqmap in |- *.
unfold eqm in |- *.
intros.

*****
a : ad
H : forall a : ad, eq (MapGet A (M2 A m0 m1) a) (MapGet A (M2 A m2 m3) a)
m0,m1,m2,m3 : Map A
A : Type
*****
eq (MapGet A m0 a) (MapGet A m2 a)
+++++
rewrite <- (Ndouble_div2 a).
-----
Lemma M2_eqmap_1 : forall m0 m1 m2 m3:Map A, eqmap A (M2 A m0 m1) (M2 A m2 m3) -> eqmap A m0 m2.
Proof.
unfold eqmap in |- *.
unfold eqm in |- *.
intros.
rewrite <- (Ndouble_div2 a).

*****
a : ad
H : forall a : ad, eq (MapGet A (M2 A m0 m1) a) (MapGet A (M2 A m2 m3) a)
m0,m1,m2,m3 : Map A
A : Type
*****
eq (MapGet A m0 (N.div2 (N.double a))) (MapGet A m2 (N.div2 (N.double a)))
+++++
rewrite <- (MapGet_M2_bit_0_0 A _ (Ndouble_bit0 a) m0 m1).
-----
Lemma M2_eqmap_1 : forall m0 m1 m2 m3:Map A, eqmap A (M2 A m0 m1) (M2 A m2 m3) -> eqmap A m0 m2.
Proof.
unfold eqmap in |- *.
unfold eqm in |- *.
intros.
rewrite <- (Ndouble_div2 a).
rewrite <- (MapGet_M2_bit_0_0 A _ (Ndouble_bit0 a) m0 m1).

*****
a : ad
H : forall a : ad, eq (MapGet A (M2 A m0 m1) a) (MapGet A (M2 A m2 m3) a)
m0,m1,m2,m3 : Map A
A : Type
*****
eq (MapGet A (M2 A m0 m1) (N.double a)) (MapGet A m2 (N.div2 (N.double a)))
+++++
rewrite <- (MapGet_M2_bit_0_0 A _ (Ndouble_bit0 a) m2 m3).
-----
Lemma M2_eqmap_1 : forall m0 m1 m2 m3:Map A, eqmap A (M2 A m0 m1) (M2 A m2 m3) -> eqmap A m0 m2.
Proof.
unfold eqmap in |- *.
unfold eqm in |- *.
intros.
rewrite <- (Ndouble_div2 a).
rewrite <- (MapGet_M2_bit_0_0 A _ (Ndouble_bit0 a) m0 m1).
rewrite <- (MapGet_M2_bit_0_0 A _ (Ndouble_bit0 a) m2 m3).

*****
a : ad
H : forall a : ad, eq (MapGet A (M2 A m0 m1) a) (MapGet A (M2 A m2 m3) a)
m0,m1,m2,m3 : Map A
A : Type
*****
eq (MapGet A (M2 A m0 m1) (N.double a)) (MapGet A (M2 A m2 m3) (N.double a))
+++++
exact (H (Ndouble a)).
-----
Lemma M2_eqmap_1 : forall m0 m1 m2 m3:Map A, eqmap A (M2 A m0 m1) (M2 A m2 m3) -> eqmap A m0 m2.
Proof.
unfold eqmap in |- *.
unfold eqm in |- *.
intros.
rewrite <- (Ndouble_div2 a).
rewrite <- (MapGet_M2_bit_0_0 A _ (Ndouble_bit0 a) m0 m1).
rewrite <- (MapGet_M2_bit_0_0 A _ (Ndouble_bit0 a) m2 m3).
exact (H (Ndouble a)).

*****

*****

+++++
Qed.
-----
Lemma M2_eqmap_2 :\n   forall m0 m1 m2 m3:Map A,\n     eqmap A (M2 A m0 m1) (M2 A m2 m3) -> eqmap A m1 m3.
-----
Lemma M2_eqmap_2 : forall m0 m1 m2 m3:Map A, eqmap A (M2 A m0 m1) (M2 A m2 m3) -> eqmap A m1 m3.

*****
A : Type
*****
forall (m0 m1 m2 m3 : Map A) (_ : eqmap A (M2 A m0 m1) (M2 A m2 m3)), eqmap A m1 m3
+++++
Proof.
-----
Lemma M2_eqmap_2 : forall m0 m1 m2 m3:Map A, eqmap A (M2 A m0 m1) (M2 A m2 m3) -> eqmap A m1 m3.
Proof.

*****
A : Type
*****
forall (m0 m1 m2 m3 : Map A) (_ : eqmap A (M2 A m0 m1) (M2 A m2 m3)), eqmap A m1 m3
+++++
unfold eqmap in |- *.
-----
Lemma M2_eqmap_2 : forall m0 m1 m2 m3:Map A, eqmap A (M2 A m0 m1) (M2 A m2 m3) -> eqmap A m1 m3.
Proof.
unfold eqmap in |- *.

*****
A : Type
*****
forall (m0 m1 m2 m3 : Map A) (_ : eqm A (MapGet A (M2 A m0 m1)) (MapGet A (M2 A m2 m3))), eqm A (MapGet A m1) (MapGet A m3)
+++++
unfold eqm in |- *.
-----
Lemma M2_eqmap_2 : forall m0 m1 m2 m3:Map A, eqmap A (M2 A m0 m1) (M2 A m2 m3) -> eqmap A m1 m3.
Proof.
unfold eqmap in |- *.
unfold eqm in |- *.

*****
A : Type
*****
forall (m0 m1 m2 m3 : Map A) (_ : forall a : ad, eq (MapGet A (M2 A m0 m1) a) (MapGet A (M2 A m2 m3) a)) (a : ad), eq (MapGet A m1 a) (MapGet A m3 a)
+++++
intros.
-----
Lemma M2_eqmap_2 : forall m0 m1 m2 m3:Map A, eqmap A (M2 A m0 m1) (M2 A m2 m3) -> eqmap A m1 m3.
Proof.
unfold eqmap in |- *.
unfold eqm in |- *.
intros.

*****
a : ad
H : forall a : ad, eq (MapGet A (M2 A m0 m1) a) (MapGet A (M2 A m2 m3) a)
m0,m1,m2,m3 : Map A
A : Type
*****
eq (MapGet A m1 a) (MapGet A m3 a)
+++++
rewrite <- (Ndouble_plus_one_div2 a).
-----
Lemma M2_eqmap_2 : forall m0 m1 m2 m3:Map A, eqmap A (M2 A m0 m1) (M2 A m2 m3) -> eqmap A m1 m3.
Proof.
unfold eqmap in |- *.
unfold eqm in |- *.
intros.
rewrite <- (Ndouble_plus_one_div2 a).

*****
a : ad
H : forall a : ad, eq (MapGet A (M2 A m0 m1) a) (MapGet A (M2 A m2 m3) a)
m0,m1,m2,m3 : Map A
A : Type
*****
eq (MapGet A m1 (N.div2 (N.succ_double a))) (MapGet A m3 (N.div2 (N.succ_double a)))
+++++
rewrite <- (MapGet_M2_bit_0_1 A _ (Ndouble_plus_one_bit0 a) m0 m1).
-----
Lemma M2_eqmap_2 : forall m0 m1 m2 m3:Map A, eqmap A (M2 A m0 m1) (M2 A m2 m3) -> eqmap A m1 m3.
Proof.
unfold eqmap in |- *.
unfold eqm in |- *.
intros.
rewrite <- (Ndouble_plus_one_div2 a).
rewrite <- (MapGet_M2_bit_0_1 A _ (Ndouble_plus_one_bit0 a) m0 m1).

*****
a : ad
H : forall a : ad, eq (MapGet A (M2 A m0 m1) a) (MapGet A (M2 A m2 m3) a)
m0,m1,m2,m3 : Map A
A : Type
*****
eq (MapGet A (M2 A m0 m1) (N.succ_double a)) (MapGet A m3 (N.div2 (N.succ_double a)))
+++++
rewrite <- (MapGet_M2_bit_0_1 A _ (Ndouble_plus_one_bit0 a) m2 m3).
-----
Lemma M2_eqmap_2 : forall m0 m1 m2 m3:Map A, eqmap A (M2 A m0 m1) (M2 A m2 m3) -> eqmap A m1 m3.
Proof.
unfold eqmap in |- *.
unfold eqm in |- *.
intros.
rewrite <- (Ndouble_plus_one_div2 a).
rewrite <- (MapGet_M2_bit_0_1 A _ (Ndouble_plus_one_bit0 a) m0 m1).
rewrite <- (MapGet_M2_bit_0_1 A _ (Ndouble_plus_one_bit0 a) m2 m3).

*****
a : ad
H : forall a : ad, eq (MapGet A (M2 A m0 m1) a) (MapGet A (M2 A m2 m3) a)
m0,m1,m2,m3 : Map A
A : Type
*****
eq (MapGet A (M2 A m0 m1) (N.succ_double a)) (MapGet A (M2 A m2 m3) (N.succ_double a))
+++++
exact (H (Ndouble_plus_one a)).
-----
Lemma M2_eqmap_2 : forall m0 m1 m2 m3:Map A, eqmap A (M2 A m0 m1) (M2 A m2 m3) -> eqmap A m1 m3.
Proof.
unfold eqmap in |- *.
unfold eqm in |- *.
intros.
rewrite <- (Ndouble_plus_one_div2 a).
rewrite <- (MapGet_M2_bit_0_1 A _ (Ndouble_plus_one_bit0 a) m0 m1).
rewrite <- (MapGet_M2_bit_0_1 A _ (Ndouble_plus_one_bit0 a) m2 m3).
exact (H (Ndouble_plus_one a)).

*****

*****

+++++
Qed.
-----
Lemma mapcanon_unique :\n   forall m m':Map A, mapcanon m -> mapcanon m' -> eqmap A m m' -> m = m'.
-----
Lemma mapcanon_unique : forall m m':Map A, mapcanon m -> mapcanon m' -> eqmap A m m' -> m = m'.

*****
A : Type
*****
forall (m m' : Map A) (_ : mapcanon m) (_ : mapcanon m') (_ : eqmap A m m'), eq m m'
+++++
Proof.
-----
Lemma mapcanon_unique : forall m m':Map A, mapcanon m -> mapcanon m' -> eqmap A m m' -> m = m'.
Proof.

*****
A : Type
*****
forall (m m' : Map A) (_ : mapcanon m) (_ : mapcanon m') (_ : eqmap A m m'), eq m m'
+++++
simple induction m.
-----
Lemma mapcanon_unique : forall m m':Map A, mapcanon m -> mapcanon m' -> eqmap A m m' -> m = m'.
Proof.
simple induction m.

*****
m : Map A
A : Type
*****
forall (m' : Map A) (_ : mapcanon (M0 A)) (_ : mapcanon m') (_ : eqmap A (M0 A) m'), eq (M0 A) m'
+++++
simple induction m'.
-----
Lemma mapcanon_unique : forall m m':Map A, mapcanon m -> mapcanon m' -> eqmap A m m' -> m = m'.
Proof.
simple induction m.
simple induction m'.

*****
m,m' : Map A
A : Type
*****
forall (_ : mapcanon (M0 A)) (_ : mapcanon (M0 A)) (_ : eqmap A (M0 A) (M0 A)), eq (M0 A) (M0 A)
+++++
trivial.
-----
Lemma mapcanon_unique : forall m m':Map A, mapcanon m -> mapcanon m' -> eqmap A m m' -> m = m'.
Proof.
simple induction m.
simple induction m'.

*****
m,m' : Map A
A : Type
*****
forall (a : ad) (a0 : A) (_ : mapcanon (M0 A)) (_ : mapcanon (M1 A a a0)) (_ : eqmap A (M0 A) (M1 A a a0)), eq (M0 A) (M1 A a a0)
+++++
intros a y H H0 H1.
-----
Lemma mapcanon_unique : forall m m':Map A, mapcanon m -> mapcanon m' -> eqmap A m m' -> m = m'.
Proof.
simple induction m.
simple induction m'.
intros a y H H0 H1.

*****
H1 : eqmap A (M0 A) (M1 A a y)
H0 : mapcanon (M1 A a y)
H : mapcanon (M0 A)
y : A
a : ad
m,m' : Map A
A : Type
*****
eq (M0 A) (M1 A a y)
+++++
cut (None = MapGet A (M1 A a y) a).
-----
Lemma mapcanon_unique : forall m m':Map A, mapcanon m -> mapcanon m' -> eqmap A m m' -> m = m'.
Proof.
simple induction m.
simple induction m'.
intros a y H H0 H1.
cut (None = MapGet A (M1 A a y) a).

*****
H1 : eqmap A (M0 A) (M1 A a y)
H0 : mapcanon (M1 A a y)
H : mapcanon (M0 A)
y : A
a : ad
m,m' : Map A
A : Type
*****
forall _ : eq None (MapGet A (M1 A a y) a), eq (M0 A) (M1 A a y)
+++++
simpl in |- *.
-----
Lemma mapcanon_unique : forall m m':Map A, mapcanon m -> mapcanon m' -> eqmap A m m' -> m = m'.
Proof.
simple induction m.
simple induction m'.
intros a y H H0 H1.
cut (None = MapGet A (M1 A a y) a).
simpl in |- *.

*****
H1 : eqmap A (M0 A) (M1 A a y)
H0 : mapcanon (M1 A a y)
H : mapcanon (M0 A)
y : A
a : ad
m,m' : Map A
A : Type
*****
forall _ : eq None (if N.eqb a a then Some y else None), eq (M0 A) (M1 A a y)
+++++
rewrite (Neqb_correct a).
-----
Lemma mapcanon_unique : forall m m':Map A, mapcanon m -> mapcanon m' -> eqmap A m m' -> m = m'.
Proof.
simple induction m.
simple induction m'.
intros a y H H0 H1.
cut (None = MapGet A (M1 A a y) a).
simpl in |- *.
rewrite (Neqb_correct a).

*****
H1 : eqmap A (M0 A) (M1 A a y)
H0 : mapcanon (M1 A a y)
H : mapcanon (M0 A)
y : A
a : ad
m,m' : Map A
A : Type
*****
forall _ : eq None (Some y), eq (M0 A) (M1 A a y)
+++++
intro.
-----
Lemma mapcanon_unique : forall m m':Map A, mapcanon m -> mapcanon m' -> eqmap A m m' -> m = m'.
Proof.
simple induction m.
simple induction m'.
intros a y H H0 H1.
cut (None = MapGet A (M1 A a y) a).
simpl in |- *.
rewrite (Neqb_correct a).
intro.

*****
H2 : eq None (Some y)
H1 : eqmap A (M0 A) (M1 A a y)
H0 : mapcanon (M1 A a y)
H : mapcanon (M0 A)
y : A
a : ad
m,m' : Map A
A : Type
*****
eq (M0 A) (M1 A a y)
+++++
discriminate H2.
-----
Lemma mapcanon_unique : forall m m':Map A, mapcanon m -> mapcanon m' -> eqmap A m m' -> m = m'.
Proof.
simple induction m.
simple induction m'.
intros a y H H0 H1.
cut (None = MapGet A (M1 A a y) a).

*****
H1 : eqmap A (M0 A) (M1 A a y)
H0 : mapcanon (M1 A a y)
H : mapcanon (M0 A)
y : A
a : ad
m,m' : Map A
A : Type
*****
eq None (MapGet A (M1 A a y) a)
+++++
exact (H1 a).
-----
Lemma mapcanon_unique : forall m m':Map A, mapcanon m -> mapcanon m' -> eqmap A m m' -> m = m'.
Proof.
simple induction m.
simple induction m'.

*****
m,m' : Map A
A : Type
*****
forall (m : Map A) (_ : forall (_ : mapcanon (M0 A)) (_ : mapcanon m) (_ : eqmap A (M0 A) m), eq (M0 A) m) (m0 : Map A) (_ : forall (_ : mapcanon (M0 A)) (_ : mapcanon m0) (_ : eqmap A (M0 A) m0), eq (M0 A) m0) (_ : mapcanon (M0 A)) (_ : mapcanon (M2 A m m0)) (_ : eqmap A (M0 A) (M2 A m m0)), eq (M0 A) (M2 A m m0)
+++++
intros.
-----
Lemma mapcanon_unique : forall m m':Map A, mapcanon m -> mapcanon m' -> eqmap A m m' -> m = m'.
Proof.
simple induction m.
simple induction m'.
intros.

*****
H3 : eqmap A (M0 A) (M2 A m0 m1)
H2 : mapcanon (M2 A m0 m1)
H1 : mapcanon (M0 A)
H0 : forall (_ : mapcanon (M0 A)) (_ : mapcanon m1) (_ : eqmap A (M0 A) m1),\neq (M0 A) m1
m1 : Map A
H : forall (_ : mapcanon (M0 A)) (_ : mapcanon m0) (_ : eqmap A (M0 A) m0),\neq (M0 A) m0
m,m',m0 : Map A
A : Type
*****
eq (M0 A) (M2 A m0 m1)
+++++
cut (2 <= MapCard A (M0 A)).
-----
Lemma mapcanon_unique : forall m m':Map A, mapcanon m -> mapcanon m' -> eqmap A m m' -> m = m'.
Proof.
simple induction m.
simple induction m'.
intros.
cut (2 <= MapCard A (M0 A)).

*****
H3 : eqmap A (M0 A) (M2 A m0 m1)
H2 : mapcanon (M2 A m0 m1)
H1 : mapcanon (M0 A)
H0 : forall (_ : mapcanon (M0 A)) (_ : mapcanon m1) (_ : eqmap A (M0 A) m1),\neq (M0 A) m1
m1 : Map A
H : forall (_ : mapcanon (M0 A)) (_ : mapcanon m0) (_ : eqmap A (M0 A) m0),\neq (M0 A) m0
m,m',m0 : Map A
A : Type
*****
forall _ : le (S (S O)) (MapCard A (M0 A)), eq (M0 A) (M2 A m0 m1)
+++++
intro.
-----
Lemma mapcanon_unique : forall m m':Map A, mapcanon m -> mapcanon m' -> eqmap A m m' -> m = m'.
Proof.
simple induction m.
simple induction m'.
intros.
cut (2 <= MapCard A (M0 A)).
intro.

*****
H4 : le (S (S O)) (MapCard A (M0 A))
H3 : eqmap A (M0 A) (M2 A m0 m1)
H2 : mapcanon (M2 A m0 m1)
H1 : mapcanon (M0 A)
H0 : forall (_ : mapcanon (M0 A)) (_ : mapcanon m1) (_ : eqmap A (M0 A) m1),\neq (M0 A) m1
m1 : Map A
H : forall (_ : mapcanon (M0 A)) (_ : mapcanon m0) (_ : eqmap A (M0 A) m0),\neq (M0 A) m0
m,m',m0 : Map A
A : Type
*****
eq (M0 A) (M2 A m0 m1)
+++++
elim (le_Sn_O _ H4).
-----
Lemma mapcanon_unique : forall m m':Map A, mapcanon m -> mapcanon m' -> eqmap A m m' -> m = m'.
Proof.
simple induction m.
simple induction m'.
intros.
cut (2 <= MapCard A (M0 A)).

*****
H3 : eqmap A (M0 A) (M2 A m0 m1)
H2 : mapcanon (M2 A m0 m1)
H1 : mapcanon (M0 A)
H0 : forall (_ : mapcanon (M0 A)) (_ : mapcanon m1) (_ : eqmap A (M0 A) m1),\neq (M0 A) m1
m1 : Map A
H : forall (_ : mapcanon (M0 A)) (_ : mapcanon m0) (_ : eqmap A (M0 A) m0),\neq (M0 A) m0
m,m',m0 : Map A
A : Type
*****
le (S (S O)) (MapCard A (M0 A))
+++++
rewrite (MapCard_ext A _ _ H3).
-----
Lemma mapcanon_unique : forall m m':Map A, mapcanon m -> mapcanon m' -> eqmap A m m' -> m = m'.
Proof.
simple induction m.
simple induction m'.
intros.
cut (2 <= MapCard A (M0 A)).
rewrite (MapCard_ext A _ _ H3).

*****
H3 : eqmap A (M0 A) (M2 A m0 m1)
H2 : mapcanon (M2 A m0 m1)
H1 : mapcanon (M0 A)
H0 : forall (_ : mapcanon (M0 A)) (_ : mapcanon m1) (_ : eqmap A (M0 A) m1),\neq (M0 A) m1
m1 : Map A
H : forall (_ : mapcanon (M0 A)) (_ : mapcanon m0) (_ : eqmap A (M0 A) m0),\neq (M0 A) m0
m,m',m0 : Map A
A : Type
*****
le (S (S O)) (MapCard A (M2 A m0 m1))
+++++
exact (mapcanon_M2 _ _ H2).
-----
Lemma mapcanon_unique : forall m m':Map A, mapcanon m -> mapcanon m' -> eqmap A m m' -> m = m'.
Proof.
simple induction m.

*****
m : Map A
A : Type
*****
forall (a : ad) (a0 : A) (m' : Map A) (_ : mapcanon (M1 A a a0)) (_ : mapcanon m') (_ : eqmap A (M1 A a a0) m'), eq (M1 A a a0) m'
+++++
intros a y.
-----
Lemma mapcanon_unique : forall m m':Map A, mapcanon m -> mapcanon m' -> eqmap A m m' -> m = m'.
Proof.
simple induction m.
intros a y.

*****
y : A
a : ad
m : Map A
A : Type
*****
forall (m' : Map A) (_ : mapcanon (M1 A a y)) (_ : mapcanon m') (_ : eqmap A (M1 A a y) m'), eq (M1 A a y) m'
+++++
simple induction m'.
-----
Lemma mapcanon_unique : forall m m':Map A, mapcanon m -> mapcanon m' -> eqmap A m m' -> m = m'.
Proof.
simple induction m.
intros a y.
simple induction m'.

*****
m' : Map A
y : A
a : ad
m : Map A
A : Type
*****
forall (_ : mapcanon (M1 A a y)) (_ : mapcanon (M0 A)) (_ : eqmap A (M1 A a y) (M0 A)), eq (M1 A a y) (M0 A)
+++++
intros.
-----
Lemma mapcanon_unique : forall m m':Map A, mapcanon m -> mapcanon m' -> eqmap A m m' -> m = m'.
Proof.
simple induction m.
intros a y.
simple induction m'.
intros.

*****
H1 : eqmap A (M1 A a y) (M0 A)
H0 : mapcanon (M0 A)
H : mapcanon (M1 A a y)
m' : Map A
y : A
a : ad
m : Map A
A : Type
*****
eq (M1 A a y) (M0 A)
+++++
cut (MapGet A (M1 A a y) a = None).
-----
Lemma mapcanon_unique : forall m m':Map A, mapcanon m -> mapcanon m' -> eqmap A m m' -> m = m'.
Proof.
simple induction m.
intros a y.
simple induction m'.
intros.
cut (MapGet A (M1 A a y) a = None).

*****
H1 : eqmap A (M1 A a y) (M0 A)
H0 : mapcanon (M0 A)
H : mapcanon (M1 A a y)
m' : Map A
y : A
a : ad
m : Map A
A : Type
*****
forall _ : eq (MapGet A (M1 A a y) a) None, eq (M1 A a y) (M0 A)
+++++
simpl in |- *.
-----
Lemma mapcanon_unique : forall m m':Map A, mapcanon m -> mapcanon m' -> eqmap A m m' -> m = m'.
Proof.
simple induction m.
intros a y.
simple induction m'.
intros.
cut (MapGet A (M1 A a y) a = None).
simpl in |- *.

*****
H1 : eqmap A (M1 A a y) (M0 A)
H0 : mapcanon (M0 A)
H : mapcanon (M1 A a y)
m' : Map A
y : A
a : ad
m : Map A
A : Type
*****
forall _ : eq (if N.eqb a a then Some y else None) None, eq (M1 A a y) (M0 A)
+++++
rewrite (Neqb_correct a).
-----
Lemma mapcanon_unique : forall m m':Map A, mapcanon m -> mapcanon m' -> eqmap A m m' -> m = m'.
Proof.
simple induction m.
intros a y.
simple induction m'.
intros.
cut (MapGet A (M1 A a y) a = None).
simpl in |- *.
rewrite (Neqb_correct a).

*****
H1 : eqmap A (M1 A a y) (M0 A)
H0 : mapcanon (M0 A)
H : mapcanon (M1 A a y)
m' : Map A
y : A
a : ad
m : Map A
A : Type
*****
forall _ : eq (Some y) None, eq (M1 A a y) (M0 A)
+++++
intro.
-----
Lemma mapcanon_unique : forall m m':Map A, mapcanon m -> mapcanon m' -> eqmap A m m' -> m = m'.
Proof.
simple induction m.
intros a y.
simple induction m'.
intros.
cut (MapGet A (M1 A a y) a = None).
simpl in |- *.
rewrite (Neqb_correct a).
intro.

*****
H2 : eq (Some y) None
H1 : eqmap A (M1 A a y) (M0 A)
H0 : mapcanon (M0 A)
H : mapcanon (M1 A a y)
m' : Map A
y : A
a : ad
m : Map A
A : Type
*****
eq (M1 A a y) (M0 A)
+++++
discriminate H2.
-----
Lemma mapcanon_unique : forall m m':Map A, mapcanon m -> mapcanon m' -> eqmap A m m' -> m = m'.
Proof.
simple induction m.
intros a y.
simple induction m'.
intros.
cut (MapGet A (M1 A a y) a = None).

*****
H1 : eqmap A (M1 A a y) (M0 A)
H0 : mapcanon (M0 A)
H : mapcanon (M1 A a y)
m' : Map A
y : A
a : ad
m : Map A
A : Type
*****
eq (MapGet A (M1 A a y) a) None
+++++
exact (H1 a).
-----
Lemma mapcanon_unique : forall m m':Map A, mapcanon m -> mapcanon m' -> eqmap A m m' -> m = m'.
Proof.
simple induction m.
intros a y.
simple induction m'.

*****
m' : Map A
y : A
a : ad
m : Map A
A : Type
*****
forall (a0 : ad) (a1 : A) (_ : mapcanon (M1 A a y)) (_ : mapcanon (M1 A a0 a1)) (_ : eqmap A (M1 A a y) (M1 A a0 a1)), eq (M1 A a y) (M1 A a0 a1)
+++++
intros a0 y0 H H0 H1.
-----
Lemma mapcanon_unique : forall m m':Map A, mapcanon m -> mapcanon m' -> eqmap A m m' -> m = m'.
Proof.
simple induction m.
intros a y.
simple induction m'.
intros a0 y0 H H0 H1.

*****
H1 : eqmap A (M1 A a y) (M1 A a0 y0)
H0 : mapcanon (M1 A a0 y0)
H : mapcanon (M1 A a y)
y0 : A
a0 : ad
m' : Map A
y : A
a : ad
m : Map A
A : Type
*****
eq (M1 A a y) (M1 A a0 y0)
+++++
cut (MapGet A (M1 A a y) a = MapGet A (M1 A a0 y0) a).
-----
Lemma mapcanon_unique : forall m m':Map A, mapcanon m -> mapcanon m' -> eqmap A m m' -> m = m'.
Proof.
simple induction m.
intros a y.
simple induction m'.
intros a0 y0 H H0 H1.
cut (MapGet A (M1 A a y) a = MapGet A (M1 A a0 y0) a).

*****
H1 : eqmap A (M1 A a y) (M1 A a0 y0)
H0 : mapcanon (M1 A a0 y0)
H : mapcanon (M1 A a y)
y0 : A
a0 : ad
m' : Map A
y : A
a : ad
m : Map A
A : Type
*****
forall _ : eq (MapGet A (M1 A a y) a) (MapGet A (M1 A a0 y0) a), eq (M1 A a y) (M1 A a0 y0)
+++++
simpl in |- *.
-----
Lemma mapcanon_unique : forall m m':Map A, mapcanon m -> mapcanon m' -> eqmap A m m' -> m = m'.
Proof.
simple induction m.
intros a y.
simple induction m'.
intros a0 y0 H H0 H1.
cut (MapGet A (M1 A a y) a = MapGet A (M1 A a0 y0) a).
simpl in |- *.

*****
H1 : eqmap A (M1 A a y) (M1 A a0 y0)
H0 : mapcanon (M1 A a0 y0)
H : mapcanon (M1 A a y)
y0 : A
a0 : ad
m' : Map A
y : A
a : ad
m : Map A
A : Type
*****
forall _ : eq (if N.eqb a a then Some y else None) (if N.eqb a0 a then Some y0 else None), eq (M1 A a y) (M1 A a0 y0)
+++++
rewrite (Neqb_correct a).
-----
Lemma mapcanon_unique : forall m m':Map A, mapcanon m -> mapcanon m' -> eqmap A m m' -> m = m'.
Proof.
simple induction m.
intros a y.
simple induction m'.
intros a0 y0 H H0 H1.
cut (MapGet A (M1 A a y) a = MapGet A (M1 A a0 y0) a).
simpl in |- *.
rewrite (Neqb_correct a).

*****
H1 : eqmap A (M1 A a y) (M1 A a0 y0)
H0 : mapcanon (M1 A a0 y0)
H : mapcanon (M1 A a y)
y0 : A
a0 : ad
m' : Map A
y : A
a : ad
m : Map A
A : Type
*****
forall _ : eq (Some y) (if N.eqb a0 a then Some y0 else None), eq (M1 A a y) (M1 A a0 y0)
+++++
intro.
-----
Lemma mapcanon_unique : forall m m':Map A, mapcanon m -> mapcanon m' -> eqmap A m m' -> m = m'.
Proof.
simple induction m.
intros a y.
simple induction m'.
intros a0 y0 H H0 H1.
cut (MapGet A (M1 A a y) a = MapGet A (M1 A a0 y0) a).
simpl in |- *.
rewrite (Neqb_correct a).
intro.

*****
H2 : eq (Some y) (if N.eqb a0 a then Some y0 else None)
H1 : eqmap A (M1 A a y) (M1 A a0 y0)
H0 : mapcanon (M1 A a0 y0)
H : mapcanon (M1 A a y)
y0 : A
a0 : ad
m' : Map A
y : A
a : ad
m : Map A
A : Type
*****
eq (M1 A a y) (M1 A a0 y0)
+++++
elim (sumbool_of_bool (Neqb a0 a)).
-----
Lemma mapcanon_unique : forall m m':Map A, mapcanon m -> mapcanon m' -> eqmap A m m' -> m = m'.
Proof.
simple induction m.
intros a y.
simple induction m'.
intros a0 y0 H H0 H1.
cut (MapGet A (M1 A a y) a = MapGet A (M1 A a0 y0) a).
simpl in |- *.
rewrite (Neqb_correct a).
intro.
elim (sumbool_of_bool (Neqb a0 a)).

*****
H2 : eq (Some y) (if N.eqb a0 a then Some y0 else None)
H1 : eqmap A (M1 A a y) (M1 A a0 y0)
H0 : mapcanon (M1 A a0 y0)
H : mapcanon (M1 A a y)
y0 : A
a0 : ad
m' : Map A
y : A
a : ad
m : Map A
A : Type
*****
forall _ : eq (N.eqb a0 a) true, eq (M1 A a y) (M1 A a0 y0)
+++++
intro H3.
-----
Lemma mapcanon_unique : forall m m':Map A, mapcanon m -> mapcanon m' -> eqmap A m m' -> m = m'.
Proof.
simple induction m.
intros a y.
simple induction m'.
intros a0 y0 H H0 H1.
cut (MapGet A (M1 A a y) a = MapGet A (M1 A a0 y0) a).
simpl in |- *.
rewrite (Neqb_correct a).
intro.
elim (sumbool_of_bool (Neqb a0 a)).
intro H3.

*****
H3 : eq (N.eqb a0 a) true
H2 : eq (Some y) (if N.eqb a0 a then Some y0 else None)
H1 : eqmap A (M1 A a y) (M1 A a0 y0)
H0 : mapcanon (M1 A a0 y0)
H : mapcanon (M1 A a y)
y0 : A
a0 : ad
m' : Map A
y : A
a : ad
m : Map A
A : Type
*****
eq (M1 A a y) (M1 A a0 y0)
+++++
rewrite H3 in H2.
-----
Lemma mapcanon_unique : forall m m':Map A, mapcanon m -> mapcanon m' -> eqmap A m m' -> m = m'.
Proof.
simple induction m.
intros a y.
simple induction m'.
intros a0 y0 H H0 H1.
cut (MapGet A (M1 A a y) a = MapGet A (M1 A a0 y0) a).
simpl in |- *.
rewrite (Neqb_correct a).
intro.
elim (sumbool_of_bool (Neqb a0 a)).
intro H3.
rewrite H3 in H2.

*****
H3 : eq (N.eqb a0 a) true
H2 : eq (Some y) (Some y0)
H1 : eqmap A (M1 A a y) (M1 A a0 y0)
H0 : mapcanon (M1 A a0 y0)
H : mapcanon (M1 A a y)
y0 : A
a0 : ad
m' : Map A
y : A
a : ad
m : Map A
A : Type
*****
eq (M1 A a y) (M1 A a0 y0)
+++++
inversion H2.
-----
Lemma mapcanon_unique : forall m m':Map A, mapcanon m -> mapcanon m' -> eqmap A m m' -> m = m'.
Proof.
simple induction m.
intros a y.
simple induction m'.
intros a0 y0 H H0 H1.
cut (MapGet A (M1 A a y) a = MapGet A (M1 A a0 y0) a).
simpl in |- *.
rewrite (Neqb_correct a).
intro.
elim (sumbool_of_bool (Neqb a0 a)).
intro H3.
rewrite H3 in H2.
inversion H2.

*****
H5 : eq y y0
H3 : eq (N.eqb a0 a) true
H2 : eq (Some y) (Some y0)
H1 : eqmap A (M1 A a y) (M1 A a0 y0)
H0 : mapcanon (M1 A a0 y0)
H : mapcanon (M1 A a y)
y0 : A
a0 : ad
m' : Map A
y : A
a : ad
m : Map A
A : Type
*****
eq (M1 A a y0) (M1 A a0 y0)
+++++
rewrite (Neqb_complete _ _ H3).
-----
Lemma mapcanon_unique : forall m m':Map A, mapcanon m -> mapcanon m' -> eqmap A m m' -> m = m'.
Proof.
simple induction m.
intros a y.
simple induction m'.
intros a0 y0 H H0 H1.
cut (MapGet A (M1 A a y) a = MapGet A (M1 A a0 y0) a).
simpl in |- *.
rewrite (Neqb_correct a).
intro.
elim (sumbool_of_bool (Neqb a0 a)).
intro H3.
rewrite H3 in H2.
inversion H2.
rewrite (Neqb_complete _ _ H3).

*****
H5 : eq y y0
H3 : eq (N.eqb a0 a) true
H2 : eq (Some y) (Some y0)
H1 : eqmap A (M1 A a y) (M1 A a0 y0)
H0 : mapcanon (M1 A a0 y0)
H : mapcanon (M1 A a y)
y0 : A
a0 : ad
m' : Map A
y : A
a : ad
m : Map A
A : Type
*****
eq (M1 A a y0) (M1 A a y0)
+++++
reflexivity.
-----
Lemma mapcanon_unique : forall m m':Map A, mapcanon m -> mapcanon m' -> eqmap A m m' -> m = m'.
Proof.
simple induction m.
intros a y.
simple induction m'.
intros a0 y0 H H0 H1.
cut (MapGet A (M1 A a y) a = MapGet A (M1 A a0 y0) a).
simpl in |- *.
rewrite (Neqb_correct a).
intro.
elim (sumbool_of_bool (Neqb a0 a)).

*****
H2 : eq (Some y) (if N.eqb a0 a then Some y0 else None)
H1 : eqmap A (M1 A a y) (M1 A a0 y0)
H0 : mapcanon (M1 A a0 y0)
H : mapcanon (M1 A a y)
y0 : A
a0 : ad
m' : Map A
y : A
a : ad
m : Map A
A : Type
*****
forall _ : eq (N.eqb a0 a) false, eq (M1 A a y) (M1 A a0 y0)
+++++
intro H3.
-----
Lemma mapcanon_unique : forall m m':Map A, mapcanon m -> mapcanon m' -> eqmap A m m' -> m = m'.
Proof.
simple induction m.
intros a y.
simple induction m'.
intros a0 y0 H H0 H1.
cut (MapGet A (M1 A a y) a = MapGet A (M1 A a0 y0) a).
simpl in |- *.
rewrite (Neqb_correct a).
intro.
elim (sumbool_of_bool (Neqb a0 a)).
intro H3.

*****
H3 : eq (N.eqb a0 a) false
H2 : eq (Some y) (if N.eqb a0 a then Some y0 else None)
H1 : eqmap A (M1 A a y) (M1 A a0 y0)
H0 : mapcanon (M1 A a0 y0)
H : mapcanon (M1 A a y)
y0 : A
a0 : ad
m' : Map A
y : A
a : ad
m : Map A
A : Type
*****
eq (M1 A a y) (M1 A a0 y0)
+++++
rewrite H3 in H2.
-----
Lemma mapcanon_unique : forall m m':Map A, mapcanon m -> mapcanon m' -> eqmap A m m' -> m = m'.
Proof.
simple induction m.
intros a y.
simple induction m'.
intros a0 y0 H H0 H1.
cut (MapGet A (M1 A a y) a = MapGet A (M1 A a0 y0) a).
simpl in |- *.
rewrite (Neqb_correct a).
intro.
elim (sumbool_of_bool (Neqb a0 a)).
intro H3.
rewrite H3 in H2.

*****
H3 : eq (N.eqb a0 a) false
H2 : eq (Some y) None
H1 : eqmap A (M1 A a y) (M1 A a0 y0)
H0 : mapcanon (M1 A a0 y0)
H : mapcanon (M1 A a y)
y0 : A
a0 : ad
m' : Map A
y : A
a : ad
m : Map A
A : Type
*****
eq (M1 A a y) (M1 A a0 y0)
+++++
discriminate H2.
-----
Lemma mapcanon_unique : forall m m':Map A, mapcanon m -> mapcanon m' -> eqmap A m m' -> m = m'.
Proof.
simple induction m.
intros a y.
simple induction m'.
intros a0 y0 H H0 H1.
cut (MapGet A (M1 A a y) a = MapGet A (M1 A a0 y0) a).

*****
H1 : eqmap A (M1 A a y) (M1 A a0 y0)
H0 : mapcanon (M1 A a0 y0)
H : mapcanon (M1 A a y)
y0 : A
a0 : ad
m' : Map A
y : A
a : ad
m : Map A
A : Type
*****
eq (MapGet A (M1 A a y) a) (MapGet A (M1 A a0 y0) a)
+++++
exact (H1 a).
-----
Lemma mapcanon_unique : forall m m':Map A, mapcanon m -> mapcanon m' -> eqmap A m m' -> m = m'.
Proof.
simple induction m.
intros a y.
simple induction m'.

*****
m' : Map A
y : A
a : ad
m : Map A
A : Type
*****
forall (m : Map A) (_ : forall (_ : mapcanon (M1 A a y)) (_ : mapcanon m) (_ : eqmap A (M1 A a y) m), eq (M1 A a y) m) (m0 : Map A) (_ : forall (_ : mapcanon (M1 A a y)) (_ : mapcanon m0) (_ : eqmap A (M1 A a y) m0), eq (M1 A a y) m0) (_ : mapcanon (M1 A a y)) (_ : mapcanon (M2 A m m0)) (_ : eqmap A (M1 A a y) (M2 A m m0)), eq (M1 A a y) (M2 A m m0)
+++++
intros.
-----
Lemma mapcanon_unique : forall m m':Map A, mapcanon m -> mapcanon m' -> eqmap A m m' -> m = m'.
Proof.
simple induction m.
intros a y.
simple induction m'.
intros.

*****
H3 : eqmap A (M1 A a y) (M2 A m0 m1)
H2 : mapcanon (M2 A m0 m1)
H1 : mapcanon (M1 A a y)
H0 : forall (_ : mapcanon (M1 A a y)) (_ : mapcanon m1)\n (_ : eqmap A (M1 A a y) m1), eq (M1 A a y) m1
m1 : Map A
H : forall (_ : mapcanon (M1 A a y)) (_ : mapcanon m0)\n (_ : eqmap A (M1 A a y) m0), eq (M1 A a y) m0
m',m0 : Map A
y : A
a : ad
m : Map A
A : Type
*****
eq (M1 A a y) (M2 A m0 m1)
+++++
cut (2 <= MapCard A (M1 A a y)).
-----
Lemma mapcanon_unique : forall m m':Map A, mapcanon m -> mapcanon m' -> eqmap A m m' -> m = m'.
Proof.
simple induction m.
intros a y.
simple induction m'.
intros.
cut (2 <= MapCard A (M1 A a y)).

*****
H3 : eqmap A (M1 A a y) (M2 A m0 m1)
H2 : mapcanon (M2 A m0 m1)
H1 : mapcanon (M1 A a y)
H0 : forall (_ : mapcanon (M1 A a y)) (_ : mapcanon m1)\n (_ : eqmap A (M1 A a y) m1), eq (M1 A a y) m1
m1 : Map A
H : forall (_ : mapcanon (M1 A a y)) (_ : mapcanon m0)\n (_ : eqmap A (M1 A a y) m0), eq (M1 A a y) m0
m',m0 : Map A
y : A
a : ad
m : Map A
A : Type
*****
forall _ : le (S (S O)) (MapCard A (M1 A a y)), eq (M1 A a y) (M2 A m0 m1)
+++++
intro.
-----
Lemma mapcanon_unique : forall m m':Map A, mapcanon m -> mapcanon m' -> eqmap A m m' -> m = m'.
Proof.
simple induction m.
intros a y.
simple induction m'.
intros.
cut (2 <= MapCard A (M1 A a y)).
intro.

*****
H4 : le (S (S O)) (MapCard A (M1 A a y))
H3 : eqmap A (M1 A a y) (M2 A m0 m1)
H2 : mapcanon (M2 A m0 m1)
H1 : mapcanon (M1 A a y)
H0 : forall (_ : mapcanon (M1 A a y)) (_ : mapcanon m1)\n (_ : eqmap A (M1 A a y) m1), eq (M1 A a y) m1
m1 : Map A
H : forall (_ : mapcanon (M1 A a y)) (_ : mapcanon m0)\n (_ : eqmap A (M1 A a y) m0), eq (M1 A a y) m0
m',m0 : Map A
y : A
a : ad
m : Map A
A : Type
*****
eq (M1 A a y) (M2 A m0 m1)
+++++
elim (le_Sn_O _ (le_S_n _ _ H4)).
-----
Lemma mapcanon_unique : forall m m':Map A, mapcanon m -> mapcanon m' -> eqmap A m m' -> m = m'.
Proof.
simple induction m.
intros a y.
simple induction m'.
intros.
cut (2 <= MapCard A (M1 A a y)).

*****
H3 : eqmap A (M1 A a y) (M2 A m0 m1)
H2 : mapcanon (M2 A m0 m1)
H1 : mapcanon (M1 A a y)
H0 : forall (_ : mapcanon (M1 A a y)) (_ : mapcanon m1)\n (_ : eqmap A (M1 A a y) m1), eq (M1 A a y) m1
m1 : Map A
H : forall (_ : mapcanon (M1 A a y)) (_ : mapcanon m0)\n (_ : eqmap A (M1 A a y) m0), eq (M1 A a y) m0
m',m0 : Map A
y : A
a : ad
m : Map A
A : Type
*****
le (S (S O)) (MapCard A (M1 A a y))
+++++
rewrite (MapCard_ext A _ _ H3).
-----
Lemma mapcanon_unique : forall m m':Map A, mapcanon m -> mapcanon m' -> eqmap A m m' -> m = m'.
Proof.
simple induction m.
intros a y.
simple induction m'.
intros.
cut (2 <= MapCard A (M1 A a y)).
rewrite (MapCard_ext A _ _ H3).

*****
H3 : eqmap A (M1 A a y) (M2 A m0 m1)
H2 : mapcanon (M2 A m0 m1)
H1 : mapcanon (M1 A a y)
H0 : forall (_ : mapcanon (M1 A a y)) (_ : mapcanon m1)\n (_ : eqmap A (M1 A a y) m1), eq (M1 A a y) m1
m1 : Map A
H : forall (_ : mapcanon (M1 A a y)) (_ : mapcanon m0)\n (_ : eqmap A (M1 A a y) m0), eq (M1 A a y) m0
m',m0 : Map A
y : A
a : ad
m : Map A
A : Type
*****
le (S (S O)) (MapCard A (M2 A m0 m1))
+++++
exact (mapcanon_M2 _ _ H2).
-----
Lemma mapcanon_unique : forall m m':Map A, mapcanon m -> mapcanon m' -> eqmap A m m' -> m = m'.
Proof.
simple induction m.

*****
m : Map A
A : Type
*****
forall (m : Map A) (_ : forall (m' : Map A) (_ : mapcanon m) (_ : mapcanon m') (_ : eqmap A m m'), eq m m') (m0 : Map A) (_ : forall (m' : Map A) (_ : mapcanon m0) (_ : mapcanon m') (_ : eqmap A m0 m'), eq m0 m') (m' : Map A) (_ : mapcanon (M2 A m m0)) (_ : mapcanon m') (_ : eqmap A (M2 A m m0) m'), eq (M2 A m m0) m'
+++++
simple induction m'.
-----
Lemma mapcanon_unique : forall m m':Map A, mapcanon m -> mapcanon m' -> eqmap A m m' -> m = m'.
Proof.
simple induction m.
simple induction m'.

*****
m' : Map A
H0 : forall (m' : Map A) (_ : mapcanon m1) (_ : mapcanon m')\n (_ : eqmap A m1 m'), eq m1 m'
m1 : Map A
H : forall (m' : Map A) (_ : mapcanon m0) (_ : mapcanon m')\n (_ : eqmap A m0 m'), eq m0 m'
m,m0 : Map A
A : Type
*****
forall (_ : mapcanon (M2 A m0 m1)) (_ : mapcanon (M0 A)) (_ : eqmap A (M2 A m0 m1) (M0 A)), eq (M2 A m0 m1) (M0 A)
+++++
intros.
-----
Lemma mapcanon_unique : forall m m':Map A, mapcanon m -> mapcanon m' -> eqmap A m m' -> m = m'.
Proof.
simple induction m.
simple induction m'.
intros.

*****
H3 : eqmap A (M2 A m0 m1) (M0 A)
H2 : mapcanon (M0 A)
H1 : mapcanon (M2 A m0 m1)
m' : Map A
H0 : forall (m' : Map A) (_ : mapcanon m1) (_ : mapcanon m')\n (_ : eqmap A m1 m'), eq m1 m'
m1 : Map A
H : forall (m' : Map A) (_ : mapcanon m0) (_ : mapcanon m')\n (_ : eqmap A m0 m'), eq m0 m'
m,m0 : Map A
A : Type
*****
eq (M2 A m0 m1) (M0 A)
+++++
cut (2 <= MapCard A (M0 A)).
-----
Lemma mapcanon_unique : forall m m':Map A, mapcanon m -> mapcanon m' -> eqmap A m m' -> m = m'.
Proof.
simple induction m.
simple induction m'.
intros.
cut (2 <= MapCard A (M0 A)).

*****
H3 : eqmap A (M2 A m0 m1) (M0 A)
H2 : mapcanon (M0 A)
H1 : mapcanon (M2 A m0 m1)
m' : Map A
H0 : forall (m' : Map A) (_ : mapcanon m1) (_ : mapcanon m')\n (_ : eqmap A m1 m'), eq m1 m'
m1 : Map A
H : forall (m' : Map A) (_ : mapcanon m0) (_ : mapcanon m')\n (_ : eqmap A m0 m'), eq m0 m'
m,m0 : Map A
A : Type
*****
forall _ : le (S (S O)) (MapCard A (M0 A)), eq (M2 A m0 m1) (M0 A)
+++++
intro.
-----
Lemma mapcanon_unique : forall m m':Map A, mapcanon m -> mapcanon m' -> eqmap A m m' -> m = m'.
Proof.
simple induction m.
simple induction m'.
intros.
cut (2 <= MapCard A (M0 A)).
intro.

*****
H4 : le (S (S O)) (MapCard A (M0 A))
H3 : eqmap A (M2 A m0 m1) (M0 A)
H2 : mapcanon (M0 A)
H1 : mapcanon (M2 A m0 m1)
m' : Map A
H0 : forall (m' : Map A) (_ : mapcanon m1) (_ : mapcanon m')\n (_ : eqmap A m1 m'), eq m1 m'
m1 : Map A
H : forall (m' : Map A) (_ : mapcanon m0) (_ : mapcanon m')\n (_ : eqmap A m0 m'), eq m0 m'
m,m0 : Map A
A : Type
*****
eq (M2 A m0 m1) (M0 A)
+++++
elim (le_Sn_O _ H4).
-----
Lemma mapcanon_unique : forall m m':Map A, mapcanon m -> mapcanon m' -> eqmap A m m' -> m = m'.
Proof.
simple induction m.
simple induction m'.
intros.
cut (2 <= MapCard A (M0 A)).

*****
H3 : eqmap A (M2 A m0 m1) (M0 A)
H2 : mapcanon (M0 A)
H1 : mapcanon (M2 A m0 m1)
m' : Map A
H0 : forall (m' : Map A) (_ : mapcanon m1) (_ : mapcanon m')\n (_ : eqmap A m1 m'), eq m1 m'
m1 : Map A
H : forall (m' : Map A) (_ : mapcanon m0) (_ : mapcanon m')\n (_ : eqmap A m0 m'), eq m0 m'
m,m0 : Map A
A : Type
*****
le (S (S O)) (MapCard A (M0 A))
+++++
rewrite <- (MapCard_ext A _ _ H3).
-----
Lemma mapcanon_unique : forall m m':Map A, mapcanon m -> mapcanon m' -> eqmap A m m' -> m = m'.
Proof.
simple induction m.
simple induction m'.
intros.
cut (2 <= MapCard A (M0 A)).
rewrite <- (MapCard_ext A _ _ H3).

*****
H3 : eqmap A (M2 A m0 m1) (M0 A)
H2 : mapcanon (M0 A)
H1 : mapcanon (M2 A m0 m1)
m' : Map A
H0 : forall (m' : Map A) (_ : mapcanon m1) (_ : mapcanon m')\n (_ : eqmap A m1 m'), eq m1 m'
m1 : Map A
H : forall (m' : Map A) (_ : mapcanon m0) (_ : mapcanon m')\n (_ : eqmap A m0 m'), eq m0 m'
m,m0 : Map A
A : Type
*****
le (S (S O)) (MapCard A (M2 A m0 m1))
+++++
exact (mapcanon_M2 _ _ H1).
-----
Lemma mapcanon_unique : forall m m':Map A, mapcanon m -> mapcanon m' -> eqmap A m m' -> m = m'.
Proof.
simple induction m.
simple induction m'.

*****
m' : Map A
H0 : forall (m' : Map A) (_ : mapcanon m1) (_ : mapcanon m')\n (_ : eqmap A m1 m'), eq m1 m'
m1 : Map A
H : forall (m' : Map A) (_ : mapcanon m0) (_ : mapcanon m')\n (_ : eqmap A m0 m'), eq m0 m'
m,m0 : Map A
A : Type
*****
forall (a : ad) (a0 : A) (_ : mapcanon (M2 A m0 m1)) (_ : mapcanon (M1 A a a0)) (_ : eqmap A (M2 A m0 m1) (M1 A a a0)), eq (M2 A m0 m1) (M1 A a a0)
+++++
intros a y H1 H2 H3.
-----
Lemma mapcanon_unique : forall m m':Map A, mapcanon m -> mapcanon m' -> eqmap A m m' -> m = m'.
Proof.
simple induction m.
simple induction m'.
intros a y H1 H2 H3.

*****
H3 : eqmap A (M2 A m0 m1) (M1 A a y)
H2 : mapcanon (M1 A a y)
H1 : mapcanon (M2 A m0 m1)
y : A
a : ad
m' : Map A
H0 : forall (m' : Map A) (_ : mapcanon m1) (_ : mapcanon m')\n (_ : eqmap A m1 m'), eq m1 m'
m1 : Map A
H : forall (m' : Map A) (_ : mapcanon m0) (_ : mapcanon m')\n (_ : eqmap A m0 m'), eq m0 m'
m,m0 : Map A
A : Type
*****
eq (M2 A m0 m1) (M1 A a y)
+++++
cut (2 <= MapCard A (M1 A a y)).
-----
Lemma mapcanon_unique : forall m m':Map A, mapcanon m -> mapcanon m' -> eqmap A m m' -> m = m'.
Proof.
simple induction m.
simple induction m'.
intros a y H1 H2 H3.
cut (2 <= MapCard A (M1 A a y)).

*****
H3 : eqmap A (M2 A m0 m1) (M1 A a y)
H2 : mapcanon (M1 A a y)
H1 : mapcanon (M2 A m0 m1)
y : A
a : ad
m' : Map A
H0 : forall (m' : Map A) (_ : mapcanon m1) (_ : mapcanon m')\n (_ : eqmap A m1 m'), eq m1 m'
m1 : Map A
H : forall (m' : Map A) (_ : mapcanon m0) (_ : mapcanon m')\n (_ : eqmap A m0 m'), eq m0 m'
m,m0 : Map A
A : Type
*****
forall _ : le (S (S O)) (MapCard A (M1 A a y)), eq (M2 A m0 m1) (M1 A a y)
+++++
intro.
-----
Lemma mapcanon_unique : forall m m':Map A, mapcanon m -> mapcanon m' -> eqmap A m m' -> m = m'.
Proof.
simple induction m.
simple induction m'.
intros a y H1 H2 H3.
cut (2 <= MapCard A (M1 A a y)).
intro.

*****
H4 : le (S (S O)) (MapCard A (M1 A a y))
H3 : eqmap A (M2 A m0 m1) (M1 A a y)
H2 : mapcanon (M1 A a y)
H1 : mapcanon (M2 A m0 m1)
y : A
a : ad
m' : Map A
H0 : forall (m' : Map A) (_ : mapcanon m1) (_ : mapcanon m')\n (_ : eqmap A m1 m'), eq m1 m'
m1 : Map A
H : forall (m' : Map A) (_ : mapcanon m0) (_ : mapcanon m')\n (_ : eqmap A m0 m'), eq m0 m'
m,m0 : Map A
A : Type
*****
eq (M2 A m0 m1) (M1 A a y)
+++++
elim (le_Sn_O _ (le_S_n _ _ H4)).
-----
Lemma mapcanon_unique : forall m m':Map A, mapcanon m -> mapcanon m' -> eqmap A m m' -> m = m'.
Proof.
simple induction m.
simple induction m'.
intros a y H1 H2 H3.
cut (2 <= MapCard A (M1 A a y)).

*****
H3 : eqmap A (M2 A m0 m1) (M1 A a y)
H2 : mapcanon (M1 A a y)
H1 : mapcanon (M2 A m0 m1)
y : A
a : ad
m' : Map A
H0 : forall (m' : Map A) (_ : mapcanon m1) (_ : mapcanon m')\n (_ : eqmap A m1 m'), eq m1 m'
m1 : Map A
H : forall (m' : Map A) (_ : mapcanon m0) (_ : mapcanon m')\n (_ : eqmap A m0 m'), eq m0 m'
m,m0 : Map A
A : Type
*****
le (S (S O)) (MapCard A (M1 A a y))
+++++
rewrite <- (MapCard_ext A _ _ H3).
-----
Lemma mapcanon_unique : forall m m':Map A, mapcanon m -> mapcanon m' -> eqmap A m m' -> m = m'.
Proof.
simple induction m.
simple induction m'.
intros a y H1 H2 H3.
cut (2 <= MapCard A (M1 A a y)).
rewrite <- (MapCard_ext A _ _ H3).

*****
H3 : eqmap A (M2 A m0 m1) (M1 A a y)
H2 : mapcanon (M1 A a y)
H1 : mapcanon (M2 A m0 m1)
y : A
a : ad
m' : Map A
H0 : forall (m' : Map A) (_ : mapcanon m1) (_ : mapcanon m')\n (_ : eqmap A m1 m'), eq m1 m'
m1 : Map A
H : forall (m' : Map A) (_ : mapcanon m0) (_ : mapcanon m')\n (_ : eqmap A m0 m'), eq m0 m'
m,m0 : Map A
A : Type
*****
le (S (S O)) (MapCard A (M2 A m0 m1))
+++++
exact (mapcanon_M2 _ _ H1).
-----
Lemma mapcanon_unique : forall m m':Map A, mapcanon m -> mapcanon m' -> eqmap A m m' -> m = m'.
Proof.
simple induction m.
simple induction m'.

*****
m' : Map A
H0 : forall (m' : Map A) (_ : mapcanon m1) (_ : mapcanon m')\n (_ : eqmap A m1 m'), eq m1 m'
m1 : Map A
H : forall (m' : Map A) (_ : mapcanon m0) (_ : mapcanon m')\n (_ : eqmap A m0 m'), eq m0 m'
m,m0 : Map A
A : Type
*****
forall (m : Map A) (_ : forall (_ : mapcanon (M2 A m0 m1)) (_ : mapcanon m) (_ : eqmap A (M2 A m0 m1) m), eq (M2 A m0 m1) m) (m2 : Map A) (_ : forall (_ : mapcanon (M2 A m0 m1)) (_ : mapcanon m2) (_ : eqmap A (M2 A m0 m1) m2), eq (M2 A m0 m1) m2) (_ : mapcanon (M2 A m0 m1)) (_ : mapcanon (M2 A m m2)) (_ : eqmap A (M2 A m0 m1) (M2 A m m2)), eq (M2 A m0 m1) (M2 A m m2)
+++++
intros.
-----
Lemma mapcanon_unique : forall m m':Map A, mapcanon m -> mapcanon m' -> eqmap A m m' -> m = m'.
Proof.
simple induction m.
simple induction m'.
intros.

*****
H5 : eqmap A (M2 A m0 m1) (M2 A m2 m3)
H4 : mapcanon (M2 A m2 m3)
H3 : mapcanon (M2 A m0 m1)
H2 : forall (_ : mapcanon (M2 A m0 m1)) (_ : mapcanon m3)\n (_ : eqmap A (M2 A m0 m1) m3), eq (M2 A m0 m1) m3
m3 : Map A
H1 : forall (_ : mapcanon (M2 A m0 m1)) (_ : mapcanon m2)\n (_ : eqmap A (M2 A m0 m1) m2), eq (M2 A m0 m1) m2
m',m2 : Map A
H0 : forall (m' : Map A) (_ : mapcanon m1) (_ : mapcanon m')\n (_ : eqmap A m1 m'), eq m1 m'
m1 : Map A
H : forall (m' : Map A) (_ : mapcanon m0) (_ : mapcanon m')\n (_ : eqmap A m0 m'), eq m0 m'
m,m0 : Map A
A : Type
*****
eq (M2 A m0 m1) (M2 A m2 m3)
+++++
rewrite (H m2).
-----
Lemma mapcanon_unique : forall m m':Map A, mapcanon m -> mapcanon m' -> eqmap A m m' -> m = m'.
Proof.
simple induction m.
simple induction m'.
intros.
rewrite (H m2).

*****
H5 : eqmap A (M2 A m0 m1) (M2 A m2 m3)
H4 : mapcanon (M2 A m2 m3)
H3 : mapcanon (M2 A m0 m1)
H2 : forall (_ : mapcanon (M2 A m0 m1)) (_ : mapcanon m3)\n (_ : eqmap A (M2 A m0 m1) m3), eq (M2 A m0 m1) m3
m3 : Map A
H1 : forall (_ : mapcanon (M2 A m0 m1)) (_ : mapcanon m2)\n (_ : eqmap A (M2 A m0 m1) m2), eq (M2 A m0 m1) m2
m',m2 : Map A
H0 : forall (m' : Map A) (_ : mapcanon m1) (_ : mapcanon m')\n (_ : eqmap A m1 m'), eq m1 m'
m1 : Map A
H : forall (m' : Map A) (_ : mapcanon m0) (_ : mapcanon m')\n (_ : eqmap A m0 m'), eq m0 m'
m,m0 : Map A
A : Type
*****
eq (M2 A m2 m1) (M2 A m2 m3)
+++++
rewrite (H0 m3).
-----
Lemma mapcanon_unique : forall m m':Map A, mapcanon m -> mapcanon m' -> eqmap A m m' -> m = m'.
Proof.
simple induction m.
simple induction m'.
intros.
rewrite (H m2).
rewrite (H0 m3).

*****
H5 : eqmap A (M2 A m0 m1) (M2 A m2 m3)
H4 : mapcanon (M2 A m2 m3)
H3 : mapcanon (M2 A m0 m1)
H2 : forall (_ : mapcanon (M2 A m0 m1)) (_ : mapcanon m3)\n (_ : eqmap A (M2 A m0 m1) m3), eq (M2 A m0 m1) m3
m3 : Map A
H1 : forall (_ : mapcanon (M2 A m0 m1)) (_ : mapcanon m2)\n (_ : eqmap A (M2 A m0 m1) m2), eq (M2 A m0 m1) m2
m',m2 : Map A
H0 : forall (m' : Map A) (_ : mapcanon m1) (_ : mapcanon m')\n (_ : eqmap A m1 m'), eq m1 m'
m1 : Map A
H : forall (m' : Map A) (_ : mapcanon m0) (_ : mapcanon m')\n (_ : eqmap A m0 m'), eq m0 m'
m,m0 : Map A
A : Type
*****
eq (M2 A m2 m3) (M2 A m2 m3)
+++++
reflexivity.
-----
Lemma mapcanon_unique : forall m m':Map A, mapcanon m -> mapcanon m' -> eqmap A m m' -> m = m'.
Proof.
simple induction m.
simple induction m'.
intros.
rewrite (H m2).
rewrite (H0 m3).

*****
H5 : eqmap A (M2 A m0 m1) (M2 A m2 m3)
H4 : mapcanon (M2 A m2 m3)
H3 : mapcanon (M2 A m0 m1)
H2 : forall (_ : mapcanon (M2 A m0 m1)) (_ : mapcanon m3)\n (_ : eqmap A (M2 A m0 m1) m3), eq (M2 A m0 m1) m3
m3 : Map A
H1 : forall (_ : mapcanon (M2 A m0 m1)) (_ : mapcanon m2)\n (_ : eqmap A (M2 A m0 m1) m2), eq (M2 A m0 m1) m2
m',m2 : Map A
H0 : forall (m' : Map A) (_ : mapcanon m1) (_ : mapcanon m')\n (_ : eqmap A m1 m'), eq m1 m'
m1 : Map A
H : forall (m' : Map A) (_ : mapcanon m0) (_ : mapcanon m')\n (_ : eqmap A m0 m'), eq m0 m'
m,m0 : Map A
A : Type
*****
mapcanon m1
+++++
exact (mapcanon_M2_2 _ _ H3).
-----
Lemma mapcanon_unique : forall m m':Map A, mapcanon m -> mapcanon m' -> eqmap A m m' -> m = m'.
Proof.
simple induction m.
simple induction m'.
intros.
rewrite (H m2).
rewrite (H0 m3).

*****
H5 : eqmap A (M2 A m0 m1) (M2 A m2 m3)
H4 : mapcanon (M2 A m2 m3)
H3 : mapcanon (M2 A m0 m1)
H2 : forall (_ : mapcanon (M2 A m0 m1)) (_ : mapcanon m3)\n (_ : eqmap A (M2 A m0 m1) m3), eq (M2 A m0 m1) m3
m3 : Map A
H1 : forall (_ : mapcanon (M2 A m0 m1)) (_ : mapcanon m2)\n (_ : eqmap A (M2 A m0 m1) m2), eq (M2 A m0 m1) m2
m',m2 : Map A
H0 : forall (m' : Map A) (_ : mapcanon m1) (_ : mapcanon m')\n (_ : eqmap A m1 m'), eq m1 m'
m1 : Map A
H : forall (m' : Map A) (_ : mapcanon m0) (_ : mapcanon m')\n (_ : eqmap A m0 m'), eq m0 m'
m,m0 : Map A
A : Type
*****
mapcanon m3
+++++
exact (mapcanon_M2_2 _ _ H4).
-----
Lemma mapcanon_unique : forall m m':Map A, mapcanon m -> mapcanon m' -> eqmap A m m' -> m = m'.
Proof.
simple induction m.
simple induction m'.
intros.
rewrite (H m2).
rewrite (H0 m3).

*****
H5 : eqmap A (M2 A m0 m1) (M2 A m2 m3)
H4 : mapcanon (M2 A m2 m3)
H3 : mapcanon (M2 A m0 m1)
H2 : forall (_ : mapcanon (M2 A m0 m1)) (_ : mapcanon m3)\n (_ : eqmap A (M2 A m0 m1) m3), eq (M2 A m0 m1) m3
m3 : Map A
H1 : forall (_ : mapcanon (M2 A m0 m1)) (_ : mapcanon m2)\n (_ : eqmap A (M2 A m0 m1) m2), eq (M2 A m0 m1) m2
m',m2 : Map A
H0 : forall (m' : Map A) (_ : mapcanon m1) (_ : mapcanon m')\n (_ : eqmap A m1 m'), eq m1 m'
m1 : Map A
H : forall (m' : Map A) (_ : mapcanon m0) (_ : mapcanon m')\n (_ : eqmap A m0 m'), eq m0 m'
m,m0 : Map A
A : Type
*****
eqmap A m1 m3
+++++
exact (M2_eqmap_2 _ _ _ _ H5).
-----
Lemma mapcanon_unique : forall m m':Map A, mapcanon m -> mapcanon m' -> eqmap A m m' -> m = m'.
Proof.
simple induction m.
simple induction m'.
intros.
rewrite (H m2).

*****
H5 : eqmap A (M2 A m0 m1) (M2 A m2 m3)
H4 : mapcanon (M2 A m2 m3)
H3 : mapcanon (M2 A m0 m1)
H2 : forall (_ : mapcanon (M2 A m0 m1)) (_ : mapcanon m3)\n (_ : eqmap A (M2 A m0 m1) m3), eq (M2 A m0 m1) m3
m3 : Map A
H1 : forall (_ : mapcanon (M2 A m0 m1)) (_ : mapcanon m2)\n (_ : eqmap A (M2 A m0 m1) m2), eq (M2 A m0 m1) m2
m',m2 : Map A
H0 : forall (m' : Map A) (_ : mapcanon m1) (_ : mapcanon m')\n (_ : eqmap A m1 m'), eq m1 m'
m1 : Map A
H : forall (m' : Map A) (_ : mapcanon m0) (_ : mapcanon m')\n (_ : eqmap A m0 m'), eq m0 m'
m,m0 : Map A
A : Type
*****
mapcanon m0
+++++
exact (mapcanon_M2_1 _ _ H3).
-----
Lemma mapcanon_unique : forall m m':Map A, mapcanon m -> mapcanon m' -> eqmap A m m' -> m = m'.
Proof.
simple induction m.
simple induction m'.
intros.
rewrite (H m2).

*****
H5 : eqmap A (M2 A m0 m1) (M2 A m2 m3)
H4 : mapcanon (M2 A m2 m3)
H3 : mapcanon (M2 A m0 m1)
H2 : forall (_ : mapcanon (M2 A m0 m1)) (_ : mapcanon m3)\n (_ : eqmap A (M2 A m0 m1) m3), eq (M2 A m0 m1) m3
m3 : Map A
H1 : forall (_ : mapcanon (M2 A m0 m1)) (_ : mapcanon m2)\n (_ : eqmap A (M2 A m0 m1) m2), eq (M2 A m0 m1) m2
m',m2 : Map A
H0 : forall (m' : Map A) (_ : mapcanon m1) (_ : mapcanon m')\n (_ : eqmap A m1 m'), eq m1 m'
m1 : Map A
H : forall (m' : Map A) (_ : mapcanon m0) (_ : mapcanon m')\n (_ : eqmap A m0 m'), eq m0 m'
m,m0 : Map A
A : Type
*****
mapcanon m2
+++++
exact (mapcanon_M2_1 _ _ H4).
-----
Lemma mapcanon_unique : forall m m':Map A, mapcanon m -> mapcanon m' -> eqmap A m m' -> m = m'.
Proof.
simple induction m.
simple induction m'.
intros.
rewrite (H m2).

*****
H5 : eqmap A (M2 A m0 m1) (M2 A m2 m3)
H4 : mapcanon (M2 A m2 m3)
H3 : mapcanon (M2 A m0 m1)
H2 : forall (_ : mapcanon (M2 A m0 m1)) (_ : mapcanon m3)\n (_ : eqmap A (M2 A m0 m1) m3), eq (M2 A m0 m1) m3
m3 : Map A
H1 : forall (_ : mapcanon (M2 A m0 m1)) (_ : mapcanon m2)\n (_ : eqmap A (M2 A m0 m1) m2), eq (M2 A m0 m1) m2
m',m2 : Map A
H0 : forall (m' : Map A) (_ : mapcanon m1) (_ : mapcanon m')\n (_ : eqmap A m1 m'), eq m1 m'
m1 : Map A
H : forall (m' : Map A) (_ : mapcanon m0) (_ : mapcanon m')\n (_ : eqmap A m0 m'), eq m0 m'
m,m0 : Map A
A : Type
*****
eqmap A m0 m2
+++++
exact (M2_eqmap_1 _ _ _ _ H5).
-----
Lemma mapcanon_unique : forall m m':Map A, mapcanon m -> mapcanon m' -> eqmap A m m' -> m = m'.
Proof.
simple induction m.

*****

*****

+++++
Qed.
-----
Lemma MapPut1_canon :\n   forall (p:positive) (a a':ad) (y y':A), mapcanon (MapPut1 A a y a' y' p).
-----
Lemma MapPut1_canon : forall (p:positive) (a a':ad) (y y':A), mapcanon (MapPut1 A a y a' y' p).

*****
A : Type
*****
forall (p : positive) (a a' : ad) (y y' : A), mapcanon (MapPut1 A a y a' y' p)
+++++
Proof.
-----
Lemma MapPut1_canon : forall (p:positive) (a a':ad) (y y':A), mapcanon (MapPut1 A a y a' y' p).
Proof.

*****
A : Type
*****
forall (p : positive) (a a' : ad) (y y' : A), mapcanon (MapPut1 A a y a' y' p)
+++++
simple induction p.
-----
Lemma MapPut1_canon : forall (p:positive) (a a':ad) (y y':A), mapcanon (MapPut1 A a y a' y' p).
Proof.
simple induction p.

*****
p : positive
A : Type
*****
forall (p : positive) (_ : forall (a a' : ad) (y y' : A), mapcanon (MapPut1 A a y a' y' p)) (a a' : ad) (y y' : A), mapcanon (MapPut1 A a y a' y' (xI p))
+++++
simpl in |- *.
-----
Lemma MapPut1_canon : forall (p:positive) (a a':ad) (y y':A), mapcanon (MapPut1 A a y a' y' p).
Proof.
simple induction p.
simpl in |- *.

*****
p : positive
A : Type
*****
forall (p : positive) (_ : forall (a a' : ad) (y y' : A), mapcanon (MapPut1 A a y a' y' p)) (a a' : ad) (y y' : A), mapcanon (if N.odd a then M2 A (M1 A (N.div2 a') y') (M1 A (N.div2 a) y) else M2 A (M1 A (N.div2 a) y) (M1 A (N.div2 a') y'))
+++++
intros.
-----
Lemma MapPut1_canon : forall (p:positive) (a a':ad) (y y':A), mapcanon (MapPut1 A a y a' y' p).
Proof.
simple induction p.
simpl in |- *.
intros.

*****
y,y' : A
a,a' : ad
H : forall (a a' : ad) (y y' : A), mapcanon (MapPut1 A a y a' y' p0)
p,p0 : positive
A : Type
*****
mapcanon (if N.odd a then M2 A (M1 A (N.div2 a') y') (M1 A (N.div2 a) y) else M2 A (M1 A (N.div2 a) y) (M1 A (N.div2 a') y'))
+++++
case (Nbit0 a).
-----
Lemma MapPut1_canon : forall (p:positive) (a a':ad) (y y':A), mapcanon (MapPut1 A a y a' y' p).
Proof.
simple induction p.
simpl in |- *.
intros.
case (Nbit0 a).

*****
y,y' : A
a,a' : ad
H : forall (a a' : ad) (y y' : A), mapcanon (MapPut1 A a y a' y' p0)
p,p0 : positive
A : Type
*****
mapcanon (M2 A (M1 A (N.div2 a') y') (M1 A (N.div2 a) y))
+++++
apply M2_canon.
-----
Lemma MapPut1_canon : forall (p:positive) (a a':ad) (y y':A), mapcanon (MapPut1 A a y a' y' p).
Proof.
simple induction p.
simpl in |- *.
intros.
case (Nbit0 a).
apply M2_canon.

*****
y,y' : A
a,a' : ad
H : forall (a a' : ad) (y y' : A), mapcanon (MapPut1 A a y a' y' p0)
p,p0 : positive
A : Type
*****
mapcanon (M1 A (N.div2 a') y')
+++++
apply M1_canon.
-----
Lemma MapPut1_canon : forall (p:positive) (a a':ad) (y y':A), mapcanon (MapPut1 A a y a' y' p).
Proof.
simple induction p.
simpl in |- *.
intros.
case (Nbit0 a).
apply M2_canon.

*****
y,y' : A
a,a' : ad
H : forall (a a' : ad) (y y' : A), mapcanon (MapPut1 A a y a' y' p0)
p,p0 : positive
A : Type
*****
mapcanon (M1 A (N.div2 a) y)
+++++
apply M1_canon.
-----
Lemma MapPut1_canon : forall (p:positive) (a a':ad) (y y':A), mapcanon (MapPut1 A a y a' y' p).
Proof.
simple induction p.
simpl in |- *.
intros.
case (Nbit0 a).
apply M2_canon.

*****
y,y' : A
a,a' : ad
H : forall (a a' : ad) (y y' : A), mapcanon (MapPut1 A a y a' y' p0)
p,p0 : positive
A : Type
*****
le (S (S O)) (MapCard A (M2 A (M1 A (N.div2 a') y') (M1 A (N.div2 a) y)))
+++++
apply le_n.
-----
Lemma MapPut1_canon : forall (p:positive) (a a':ad) (y y':A), mapcanon (MapPut1 A a y a' y' p).
Proof.
simple induction p.
simpl in |- *.
intros.
case (Nbit0 a).

*****
y,y' : A
a,a' : ad
H : forall (a a' : ad) (y y' : A), mapcanon (MapPut1 A a y a' y' p0)
p,p0 : positive
A : Type
*****
mapcanon (M2 A (M1 A (N.div2 a) y) (M1 A (N.div2 a') y'))
+++++
apply M2_canon.
-----
Lemma MapPut1_canon : forall (p:positive) (a a':ad) (y y':A), mapcanon (MapPut1 A a y a' y' p).
Proof.
simple induction p.
simpl in |- *.
intros.
case (Nbit0 a).
apply M2_canon.

*****
y,y' : A
a,a' : ad
H : forall (a a' : ad) (y y' : A), mapcanon (MapPut1 A a y a' y' p0)
p,p0 : positive
A : Type
*****
mapcanon (M1 A (N.div2 a) y)
+++++
apply M1_canon.
-----
Lemma MapPut1_canon : forall (p:positive) (a a':ad) (y y':A), mapcanon (MapPut1 A a y a' y' p).
Proof.
simple induction p.
simpl in |- *.
intros.
case (Nbit0 a).
apply M2_canon.

*****
y,y' : A
a,a' : ad
H : forall (a a' : ad) (y y' : A), mapcanon (MapPut1 A a y a' y' p0)
p,p0 : positive
A : Type
*****
mapcanon (M1 A (N.div2 a') y')
+++++
apply M1_canon.
-----
Lemma MapPut1_canon : forall (p:positive) (a a':ad) (y y':A), mapcanon (MapPut1 A a y a' y' p).
Proof.
simple induction p.
simpl in |- *.
intros.
case (Nbit0 a).
apply M2_canon.

*****
y,y' : A
a,a' : ad
H : forall (a a' : ad) (y y' : A), mapcanon (MapPut1 A a y a' y' p0)
p,p0 : positive
A : Type
*****
le (S (S O)) (MapCard A (M2 A (M1 A (N.div2 a) y) (M1 A (N.div2 a') y')))
+++++
apply le_n.
-----
Lemma MapPut1_canon : forall (p:positive) (a a':ad) (y y':A), mapcanon (MapPut1 A a y a' y' p).
Proof.
simple induction p.

*****
p : positive
A : Type
*****
forall (p : positive) (_ : forall (a a' : ad) (y y' : A), mapcanon (MapPut1 A a y a' y' p)) (a a' : ad) (y y' : A), mapcanon (MapPut1 A a y a' y' (xO p))
+++++
simpl in |- *.
-----
Lemma MapPut1_canon : forall (p:positive) (a a':ad) (y y':A), mapcanon (MapPut1 A a y a' y' p).
Proof.
simple induction p.
simpl in |- *.

*****
p : positive
A : Type
*****
forall (p : positive) (_ : forall (a a' : ad) (y y' : A), mapcanon (MapPut1 A a y a' y' p)) (a a' : ad) (y y' : A), mapcanon (if N.odd a then M2 A (M0 A) (MapPut1 A (N.div2 a) y (N.div2 a') y' p) else M2 A (MapPut1 A (N.div2 a) y (N.div2 a') y' p) (M0 A))
+++++
intros.
-----
Lemma MapPut1_canon : forall (p:positive) (a a':ad) (y y':A), mapcanon (MapPut1 A a y a' y' p).
Proof.
simple induction p.
simpl in |- *.
intros.

*****
y,y' : A
a,a' : ad
H : forall (a a' : ad) (y y' : A), mapcanon (MapPut1 A a y a' y' p0)
p,p0 : positive
A : Type
*****
mapcanon (if N.odd a then M2 A (M0 A) (MapPut1 A (N.div2 a) y (N.div2 a') y' p0) else M2 A (MapPut1 A (N.div2 a) y (N.div2 a') y' p0) (M0 A))
+++++
case (Nbit0 a).
-----
Lemma MapPut1_canon : forall (p:positive) (a a':ad) (y y':A), mapcanon (MapPut1 A a y a' y' p).
Proof.
simple induction p.
simpl in |- *.
intros.
case (Nbit0 a).

*****
y,y' : A
a,a' : ad
H : forall (a a' : ad) (y y' : A), mapcanon (MapPut1 A a y a' y' p0)
p,p0 : positive
A : Type
*****
mapcanon (M2 A (M0 A) (MapPut1 A (N.div2 a) y (N.div2 a') y' p0))
+++++
apply M2_canon.
-----
Lemma MapPut1_canon : forall (p:positive) (a a':ad) (y y':A), mapcanon (MapPut1 A a y a' y' p).
Proof.
simple induction p.
simpl in |- *.
intros.
case (Nbit0 a).
apply M2_canon.

*****
y,y' : A
a,a' : ad
H : forall (a a' : ad) (y y' : A), mapcanon (MapPut1 A a y a' y' p0)
p,p0 : positive
A : Type
*****
mapcanon (M0 A)
+++++
apply M0_canon.
-----
Lemma MapPut1_canon : forall (p:positive) (a a':ad) (y y':A), mapcanon (MapPut1 A a y a' y' p).
Proof.
simple induction p.
simpl in |- *.
intros.
case (Nbit0 a).
apply M2_canon.

*****
y,y' : A
a,a' : ad
H : forall (a a' : ad) (y y' : A), mapcanon (MapPut1 A a y a' y' p0)
p,p0 : positive
A : Type
*****
mapcanon (MapPut1 A (N.div2 a) y (N.div2 a') y' p0)
+++++
apply H.
-----
Lemma MapPut1_canon : forall (p:positive) (a a':ad) (y y':A), mapcanon (MapPut1 A a y a' y' p).
Proof.
simple induction p.
simpl in |- *.
intros.
case (Nbit0 a).
apply M2_canon.

*****
y,y' : A
a,a' : ad
H : forall (a a' : ad) (y y' : A), mapcanon (MapPut1 A a y a' y' p0)
p,p0 : positive
A : Type
*****
le (S (S O)) (MapCard A (M2 A (M0 A) (MapPut1 A (N.div2 a) y (N.div2 a') y' p0)))
+++++
simpl in |- *.
-----
Lemma MapPut1_canon : forall (p:positive) (a a':ad) (y y':A), mapcanon (MapPut1 A a y a' y' p).
Proof.
simple induction p.
simpl in |- *.
intros.
case (Nbit0 a).
apply M2_canon.
simpl in |- *.

*****
y,y' : A
a,a' : ad
H : forall (a a' : ad) (y y' : A), mapcanon (MapPut1 A a y a' y' p0)
p,p0 : positive
A : Type
*****
le (S (S O)) (MapCard A (MapPut1 A (N.div2 a) y (N.div2 a') y' p0))
+++++
rewrite MapCard_Put1_equals_2.
-----
Lemma MapPut1_canon : forall (p:positive) (a a':ad) (y y':A), mapcanon (MapPut1 A a y a' y' p).
Proof.
simple induction p.
simpl in |- *.
intros.
case (Nbit0 a).
apply M2_canon.
simpl in |- *.
rewrite MapCard_Put1_equals_2.

*****
y,y' : A
a,a' : ad
H : forall (a a' : ad) (y y' : A), mapcanon (MapPut1 A a y a' y' p0)
p,p0 : positive
A : Type
*****
le (S (S O)) (S (S O))
+++++
apply le_n.
-----
Lemma MapPut1_canon : forall (p:positive) (a a':ad) (y y':A), mapcanon (MapPut1 A a y a' y' p).
Proof.
simple induction p.
simpl in |- *.
intros.
case (Nbit0 a).

*****
y,y' : A
a,a' : ad
H : forall (a a' : ad) (y y' : A), mapcanon (MapPut1 A a y a' y' p0)
p,p0 : positive
A : Type
*****
mapcanon (M2 A (MapPut1 A (N.div2 a) y (N.div2 a') y' p0) (M0 A))
+++++
apply M2_canon.
-----
Lemma MapPut1_canon : forall (p:positive) (a a':ad) (y y':A), mapcanon (MapPut1 A a y a' y' p).
Proof.
simple induction p.
simpl in |- *.
intros.
case (Nbit0 a).
apply M2_canon.

*****
y,y' : A
a,a' : ad
H : forall (a a' : ad) (y y' : A), mapcanon (MapPut1 A a y a' y' p0)
p,p0 : positive
A : Type
*****
mapcanon (MapPut1 A (N.div2 a) y (N.div2 a') y' p0)
+++++
apply H.
-----
Lemma MapPut1_canon : forall (p:positive) (a a':ad) (y y':A), mapcanon (MapPut1 A a y a' y' p).
Proof.
simple induction p.
simpl in |- *.
intros.
case (Nbit0 a).
apply M2_canon.

*****
y,y' : A
a,a' : ad
H : forall (a a' : ad) (y y' : A), mapcanon (MapPut1 A a y a' y' p0)
p,p0 : positive
A : Type
*****
mapcanon (M0 A)
+++++
apply M0_canon.
-----
Lemma MapPut1_canon : forall (p:positive) (a a':ad) (y y':A), mapcanon (MapPut1 A a y a' y' p).
Proof.
simple induction p.
simpl in |- *.
intros.
case (Nbit0 a).
apply M2_canon.

*****
y,y' : A
a,a' : ad
H : forall (a a' : ad) (y y' : A), mapcanon (MapPut1 A a y a' y' p0)
p,p0 : positive
A : Type
*****
le (S (S O)) (MapCard A (M2 A (MapPut1 A (N.div2 a) y (N.div2 a') y' p0) (M0 A)))
+++++
simpl in |- *.
-----
Lemma MapPut1_canon : forall (p:positive) (a a':ad) (y y':A), mapcanon (MapPut1 A a y a' y' p).
Proof.
simple induction p.
simpl in |- *.
intros.
case (Nbit0 a).
apply M2_canon.
simpl in |- *.

*****
y,y' : A
a,a' : ad
H : forall (a a' : ad) (y y' : A), mapcanon (MapPut1 A a y a' y' p0)
p,p0 : positive
A : Type
*****
le (S (S O)) (Init.Nat.add (MapCard A (MapPut1 A (N.div2 a) y (N.div2 a') y' p0)) O)
+++++
rewrite MapCard_Put1_equals_2.
-----
Lemma MapPut1_canon : forall (p:positive) (a a':ad) (y y':A), mapcanon (MapPut1 A a y a' y' p).
Proof.
simple induction p.
simpl in |- *.
intros.
case (Nbit0 a).
apply M2_canon.
simpl in |- *.
rewrite MapCard_Put1_equals_2.

*****
y,y' : A
a,a' : ad
H : forall (a a' : ad) (y y' : A), mapcanon (MapPut1 A a y a' y' p0)
p,p0 : positive
A : Type
*****
le (S (S O)) (Init.Nat.add (S (S O)) O)
+++++
apply le_n.
-----
Lemma MapPut1_canon : forall (p:positive) (a a':ad) (y y':A), mapcanon (MapPut1 A a y a' y' p).
Proof.
simple induction p.

*****
p : positive
A : Type
*****
forall (a a' : ad) (y y' : A), mapcanon (MapPut1 A a y a' y' xH)
+++++
simpl in |- *.
-----
Lemma MapPut1_canon : forall (p:positive) (a a':ad) (y y':A), mapcanon (MapPut1 A a y a' y' p).
Proof.
simple induction p.
simpl in |- *.

*****
p : positive
A : Type
*****
forall (a a' : ad) (y y' : A), mapcanon (if N.odd a then M2 A (M1 A (N.div2 a') y') (M1 A (N.div2 a) y) else M2 A (M1 A (N.div2 a) y) (M1 A (N.div2 a') y'))
+++++
simpl in |- *.
-----
Lemma MapPut1_canon : forall (p:positive) (a a':ad) (y y':A), mapcanon (MapPut1 A a y a' y' p).
Proof.
simple induction p.
simpl in |- *.
simpl in |- *.

*****
p : positive
A : Type
*****
forall (a a' : ad) (y y' : A), mapcanon (if N.odd a then M2 A (M1 A (N.div2 a') y') (M1 A (N.div2 a) y) else M2 A (M1 A (N.div2 a) y) (M1 A (N.div2 a') y'))
+++++
intros.
-----
Lemma MapPut1_canon : forall (p:positive) (a a':ad) (y y':A), mapcanon (MapPut1 A a y a' y' p).
Proof.
simple induction p.
simpl in |- *.
simpl in |- *.
intros.

*****
y,y' : A
a,a' : ad
p : positive
A : Type
*****
mapcanon (if N.odd a then M2 A (M1 A (N.div2 a') y') (M1 A (N.div2 a) y) else M2 A (M1 A (N.div2 a) y) (M1 A (N.div2 a') y'))
+++++
case (Nbit0 a).
-----
Lemma MapPut1_canon : forall (p:positive) (a a':ad) (y y':A), mapcanon (MapPut1 A a y a' y' p).
Proof.
simple induction p.
simpl in |- *.
simpl in |- *.
intros.
case (Nbit0 a).

*****
y,y' : A
a,a' : ad
p : positive
A : Type
*****
mapcanon (M2 A (M1 A (N.div2 a') y') (M1 A (N.div2 a) y))
+++++
apply M2_canon.
-----
Lemma MapPut1_canon : forall (p:positive) (a a':ad) (y y':A), mapcanon (MapPut1 A a y a' y' p).
Proof.
simple induction p.
simpl in |- *.
simpl in |- *.
intros.
case (Nbit0 a).
apply M2_canon.

*****
y,y' : A
a,a' : ad
p : positive
A : Type
*****
mapcanon (M1 A (N.div2 a') y')
+++++
apply M1_canon.
-----
Lemma MapPut1_canon : forall (p:positive) (a a':ad) (y y':A), mapcanon (MapPut1 A a y a' y' p).
Proof.
simple induction p.
simpl in |- *.
simpl in |- *.
intros.
case (Nbit0 a).
apply M2_canon.

*****
y,y' : A
a,a' : ad
p : positive
A : Type
*****
mapcanon (M1 A (N.div2 a) y)
+++++
apply M1_canon.
-----
Lemma MapPut1_canon : forall (p:positive) (a a':ad) (y y':A), mapcanon (MapPut1 A a y a' y' p).
Proof.
simple induction p.
simpl in |- *.
simpl in |- *.
intros.
case (Nbit0 a).
apply M2_canon.

*****
y,y' : A
a,a' : ad
p : positive
A : Type
*****
le (S (S O)) (MapCard A (M2 A (M1 A (N.div2 a') y') (M1 A (N.div2 a) y)))
+++++
simpl in |- *.
-----
Lemma MapPut1_canon : forall (p:positive) (a a':ad) (y y':A), mapcanon (MapPut1 A a y a' y' p).
Proof.
simple induction p.
simpl in |- *.
simpl in |- *.
intros.
case (Nbit0 a).
apply M2_canon.
simpl in |- *.

*****
y,y' : A
a,a' : ad
p : positive
A : Type
*****
le (S (S O)) (S (S O))
+++++
apply le_n.
-----
Lemma MapPut1_canon : forall (p:positive) (a a':ad) (y y':A), mapcanon (MapPut1 A a y a' y' p).
Proof.
simple induction p.
simpl in |- *.
simpl in |- *.
intros.
case (Nbit0 a).

*****
y,y' : A
a,a' : ad
p : positive
A : Type
*****
mapcanon (M2 A (M1 A (N.div2 a) y) (M1 A (N.div2 a') y'))
+++++
apply M2_canon.
-----
Lemma MapPut1_canon : forall (p:positive) (a a':ad) (y y':A), mapcanon (MapPut1 A a y a' y' p).
Proof.
simple induction p.
simpl in |- *.
simpl in |- *.
intros.
case (Nbit0 a).
apply M2_canon.

*****
y,y' : A
a,a' : ad
p : positive
A : Type
*****
mapcanon (M1 A (N.div2 a) y)
+++++
apply M1_canon.
-----
Lemma MapPut1_canon : forall (p:positive) (a a':ad) (y y':A), mapcanon (MapPut1 A a y a' y' p).
Proof.
simple induction p.
simpl in |- *.
simpl in |- *.
intros.
case (Nbit0 a).
apply M2_canon.

*****
y,y' : A
a,a' : ad
p : positive
A : Type
*****
mapcanon (M1 A (N.div2 a') y')
+++++
apply M1_canon.
-----
Lemma MapPut1_canon : forall (p:positive) (a a':ad) (y y':A), mapcanon (MapPut1 A a y a' y' p).
Proof.
simple induction p.
simpl in |- *.
simpl in |- *.
intros.
case (Nbit0 a).
apply M2_canon.

*****
y,y' : A
a,a' : ad
p : positive
A : Type
*****
le (S (S O)) (MapCard A (M2 A (M1 A (N.div2 a) y) (M1 A (N.div2 a') y')))
+++++
simpl in |- *.
-----
Lemma MapPut1_canon : forall (p:positive) (a a':ad) (y y':A), mapcanon (MapPut1 A a y a' y' p).
Proof.
simple induction p.
simpl in |- *.
simpl in |- *.
intros.
case (Nbit0 a).
apply M2_canon.
simpl in |- *.

*****
y,y' : A
a,a' : ad
p : positive
A : Type
*****
le (S (S O)) (S (S O))
+++++
apply le_n.
-----
Lemma MapPut1_canon : forall (p:positive) (a a':ad) (y y':A), mapcanon (MapPut1 A a y a' y' p).
Proof.
simple induction p.

*****

*****

+++++
Qed.
-----
Lemma MapPut_canon :\n   forall m:Map A,\n     mapcanon m -> forall (a:ad) (y:A), mapcanon (MapPut A m a y).
-----
Lemma MapPut_canon : forall m:Map A, mapcanon m -> forall (a:ad) (y:A), mapcanon (MapPut A m a y).

*****
A : Type
*****
forall (m : Map A) (_ : mapcanon m) (a : ad) (y : A), mapcanon (MapPut A m a y)
+++++
Proof.
-----
Lemma MapPut_canon : forall m:Map A, mapcanon m -> forall (a:ad) (y:A), mapcanon (MapPut A m a y).
Proof.

*****
A : Type
*****
forall (m : Map A) (_ : mapcanon m) (a : ad) (y : A), mapcanon (MapPut A m a y)
+++++
simple induction m.
-----
Lemma MapPut_canon : forall m:Map A, mapcanon m -> forall (a:ad) (y:A), mapcanon (MapPut A m a y).
Proof.
simple induction m.

*****
m : Map A
A : Type
*****
forall (_ : mapcanon (M0 A)) (a : ad) (y : A), mapcanon (MapPut A (M0 A) a y)
+++++
intros.
-----
Lemma MapPut_canon : forall m:Map A, mapcanon m -> forall (a:ad) (y:A), mapcanon (MapPut A m a y).
Proof.
simple induction m.
intros.

*****
y : A
a : ad
H : mapcanon (M0 A)
m : Map A
A : Type
*****
mapcanon (MapPut A (M0 A) a y)
+++++
simpl in |- *.
-----
Lemma MapPut_canon : forall m:Map A, mapcanon m -> forall (a:ad) (y:A), mapcanon (MapPut A m a y).
Proof.
simple induction m.
intros.
simpl in |- *.

*****
y : A
a : ad
H : mapcanon (M0 A)
m : Map A
A : Type
*****
mapcanon (M1 A a y)
+++++
apply M1_canon.
-----
Lemma MapPut_canon : forall m:Map A, mapcanon m -> forall (a:ad) (y:A), mapcanon (MapPut A m a y).
Proof.
simple induction m.

*****
m : Map A
A : Type
*****
forall (a : ad) (a0 : A) (_ : mapcanon (M1 A a a0)) (a1 : ad) (y : A), mapcanon (MapPut A (M1 A a a0) a1 y)
+++++
intros a0 y0 H a y.
-----
Lemma MapPut_canon : forall m:Map A, mapcanon m -> forall (a:ad) (y:A), mapcanon (MapPut A m a y).
Proof.
simple induction m.
intros a0 y0 H a y.

*****
y : A
a : ad
H : mapcanon (M1 A a0 y0)
y0 : A
a0 : ad
m : Map A
A : Type
*****
mapcanon (MapPut A (M1 A a0 y0) a y)
+++++
simpl in |- *.
-----
Lemma MapPut_canon : forall m:Map A, mapcanon m -> forall (a:ad) (y:A), mapcanon (MapPut A m a y).
Proof.
simple induction m.
intros a0 y0 H a y.
simpl in |- *.

*****
y : A
a : ad
H : mapcanon (M1 A a0 y0)
y0 : A
a0 : ad
m : Map A
A : Type
*****
mapcanon match N.lxor a0 a with | N0 => M1 A a y | Npos p => MapPut1 A a0 y0 a y p end
+++++
case (Nxor a0 a).
-----
Lemma MapPut_canon : forall m:Map A, mapcanon m -> forall (a:ad) (y:A), mapcanon (MapPut A m a y).
Proof.
simple induction m.
intros a0 y0 H a y.
simpl in |- *.
case (Nxor a0 a).

*****
y : A
a : ad
H : mapcanon (M1 A a0 y0)
y0 : A
a0 : ad
m : Map A
A : Type
*****
mapcanon (M1 A a y)
+++++
apply M1_canon.
-----
Lemma MapPut_canon : forall m:Map A, mapcanon m -> forall (a:ad) (y:A), mapcanon (MapPut A m a y).
Proof.
simple induction m.
intros a0 y0 H a y.
simpl in |- *.
case (Nxor a0 a).

*****
y : A
a : ad
H : mapcanon (M1 A a0 y0)
y0 : A
a0 : ad
m : Map A
A : Type
*****
forall p : positive, mapcanon (MapPut1 A a0 y0 a y p)
+++++
intro.
-----
Lemma MapPut_canon : forall m:Map A, mapcanon m -> forall (a:ad) (y:A), mapcanon (MapPut A m a y).
Proof.
simple induction m.
intros a0 y0 H a y.
simpl in |- *.
case (Nxor a0 a).
intro.

*****
p : positive
y : A
a : ad
H : mapcanon (M1 A a0 y0)
y0 : A
a0 : ad
m : Map A
A : Type
*****
mapcanon (MapPut1 A a0 y0 a y p)
+++++
apply MapPut1_canon.
-----
Lemma MapPut_canon : forall m:Map A, mapcanon m -> forall (a:ad) (y:A), mapcanon (MapPut A m a y).
Proof.
simple induction m.

*****
m : Map A
A : Type
*****
forall (m : Map A) (_ : forall (_ : mapcanon m) (a : ad) (y : A), mapcanon (MapPut A m a y)) (m0 : Map A) (_ : forall (_ : mapcanon m0) (a : ad) (y : A), mapcanon (MapPut A m0 a y)) (_ : mapcanon (M2 A m m0)) (a : ad) (y : A), mapcanon (MapPut A (M2 A m m0) a y)
+++++
intros.
-----
Lemma MapPut_canon : forall m:Map A, mapcanon m -> forall (a:ad) (y:A), mapcanon (MapPut A m a y).
Proof.
simple induction m.
intros.

*****
y : A
a : ad
H1 : mapcanon (M2 A m0 m1)
H0 : forall (_ : mapcanon m1) (a : ad) (y : A), mapcanon (MapPut A m1 a y)
m1 : Map A
H : forall (_ : mapcanon m0) (a : ad) (y : A), mapcanon (MapPut A m0 a y)
m,m0 : Map A
A : Type
*****
mapcanon (MapPut A (M2 A m0 m1) a y)
+++++
simpl in |- *.
-----
Lemma MapPut_canon : forall m:Map A, mapcanon m -> forall (a:ad) (y:A), mapcanon (MapPut A m a y).
Proof.
simple induction m.
intros.
simpl in |- *.

*****
y : A
a : ad
H1 : mapcanon (M2 A m0 m1)
H0 : forall (_ : mapcanon m1) (a : ad) (y : A), mapcanon (MapPut A m1 a y)
m1 : Map A
H : forall (_ : mapcanon m0) (a : ad) (y : A), mapcanon (MapPut A m0 a y)
m,m0 : Map A
A : Type
*****
mapcanon match a with | N0 => M2 A (MapPut A m0 N0 y) m1 | Npos (xI p) => M2 A m0 (MapPut A m1 (Npos p) y) | Npos (xO p) => M2 A (MapPut A m0 (Npos p) y) m1 | Npos xH => M2 A m0 (MapPut A m1 N0 y) end
+++++
elim a.
-----
Lemma MapPut_canon : forall m:Map A, mapcanon m -> forall (a:ad) (y:A), mapcanon (MapPut A m a y).
Proof.
simple induction m.
intros.
simpl in |- *.
elim a.

*****
y : A
a : ad
H1 : mapcanon (M2 A m0 m1)
H0 : forall (_ : mapcanon m1) (a : ad) (y : A), mapcanon (MapPut A m1 a y)
m1 : Map A
H : forall (_ : mapcanon m0) (a : ad) (y : A), mapcanon (MapPut A m0 a y)
m,m0 : Map A
A : Type
*****
mapcanon (M2 A (MapPut A m0 N0 y) m1)
+++++
apply M2_canon.
-----
Lemma MapPut_canon : forall m:Map A, mapcanon m -> forall (a:ad) (y:A), mapcanon (MapPut A m a y).
Proof.
simple induction m.
intros.
simpl in |- *.
elim a.
apply M2_canon.

*****
y : A
a : ad
H1 : mapcanon (M2 A m0 m1)
H0 : forall (_ : mapcanon m1) (a : ad) (y : A), mapcanon (MapPut A m1 a y)
m1 : Map A
H : forall (_ : mapcanon m0) (a : ad) (y : A), mapcanon (MapPut A m0 a y)
m,m0 : Map A
A : Type
*****
mapcanon (MapPut A m0 N0 y)
+++++
apply H.
-----
Lemma MapPut_canon : forall m:Map A, mapcanon m -> forall (a:ad) (y:A), mapcanon (MapPut A m a y).
Proof.
simple induction m.
intros.
simpl in |- *.
elim a.
apply M2_canon.
apply H.

*****
y : A
a : ad
H1 : mapcanon (M2 A m0 m1)
H0 : forall (_ : mapcanon m1) (a : ad) (y : A), mapcanon (MapPut A m1 a y)
m1 : Map A
H : forall (_ : mapcanon m0) (a : ad) (y : A), mapcanon (MapPut A m0 a y)
m,m0 : Map A
A : Type
*****
mapcanon m0
+++++
exact (mapcanon_M2_1 m0 m1 H1).
-----
Lemma MapPut_canon : forall m:Map A, mapcanon m -> forall (a:ad) (y:A), mapcanon (MapPut A m a y).
Proof.
simple induction m.
intros.
simpl in |- *.
elim a.
apply M2_canon.

*****
y : A
a : ad
H1 : mapcanon (M2 A m0 m1)
H0 : forall (_ : mapcanon m1) (a : ad) (y : A), mapcanon (MapPut A m1 a y)
m1 : Map A
H : forall (_ : mapcanon m0) (a : ad) (y : A), mapcanon (MapPut A m0 a y)
m,m0 : Map A
A : Type
*****
mapcanon m1
+++++
exact (mapcanon_M2_2 m0 m1 H1).
-----
Lemma MapPut_canon : forall m:Map A, mapcanon m -> forall (a:ad) (y:A), mapcanon (MapPut A m a y).
Proof.
simple induction m.
intros.
simpl in |- *.
elim a.
apply M2_canon.

*****
y : A
a : ad
H1 : mapcanon (M2 A m0 m1)
H0 : forall (_ : mapcanon m1) (a : ad) (y : A), mapcanon (MapPut A m1 a y)
m1 : Map A
H : forall (_ : mapcanon m0) (a : ad) (y : A), mapcanon (MapPut A m0 a y)
m,m0 : Map A
A : Type
*****
le (S (S O)) (MapCard A (M2 A (MapPut A m0 N0 y) m1))
+++++
simpl in |- *.
-----
Lemma MapPut_canon : forall m:Map A, mapcanon m -> forall (a:ad) (y:A), mapcanon (MapPut A m a y).
Proof.
simple induction m.
intros.
simpl in |- *.
elim a.
apply M2_canon.
simpl in |- *.

*****
y : A
a : ad
H1 : mapcanon (M2 A m0 m1)
H0 : forall (_ : mapcanon m1) (a : ad) (y : A), mapcanon (MapPut A m1 a y)
m1 : Map A
H : forall (_ : mapcanon m0) (a : ad) (y : A), mapcanon (MapPut A m0 a y)
m,m0 : Map A
A : Type
*****
le (S (S O)) (Init.Nat.add (MapCard A (MapPut A m0 N0 y)) (MapCard A m1))
+++++
apply le_trans with (m := MapCard A m0 + MapCard A m1).
-----
Lemma MapPut_canon : forall m:Map A, mapcanon m -> forall (a:ad) (y:A), mapcanon (MapPut A m a y).
Proof.
simple induction m.
intros.
simpl in |- *.
elim a.
apply M2_canon.
simpl in |- *.
apply le_trans with (m := MapCard A m0 + MapCard A m1).

*****
y : A
a : ad
H1 : mapcanon (M2 A m0 m1)
H0 : forall (_ : mapcanon m1) (a : ad) (y : A), mapcanon (MapPut A m1 a y)
m1 : Map A
H : forall (_ : mapcanon m0) (a : ad) (y : A), mapcanon (MapPut A m0 a y)
m,m0 : Map A
A : Type
*****
le (S (S O)) (Init.Nat.add (MapCard A m0) (MapCard A m1))
+++++
exact (mapcanon_M2 _ _ H1).
-----
Lemma MapPut_canon : forall m:Map A, mapcanon m -> forall (a:ad) (y:A), mapcanon (MapPut A m a y).
Proof.
simple induction m.
intros.
simpl in |- *.
elim a.
apply M2_canon.
simpl in |- *.
apply le_trans with (m := MapCard A m0 + MapCard A m1).

*****
y : A
a : ad
H1 : mapcanon (M2 A m0 m1)
H0 : forall (_ : mapcanon m1) (a : ad) (y : A), mapcanon (MapPut A m1 a y)
m1 : Map A
H : forall (_ : mapcanon m0) (a : ad) (y : A), mapcanon (MapPut A m0 a y)
m,m0 : Map A
A : Type
*****
le (Init.Nat.add (MapCard A m0) (MapCard A m1)) (Init.Nat.add (MapCard A (MapPut A m0 N0 y)) (MapCard A m1))
+++++
apply plus_le_compat.
-----
Lemma MapPut_canon : forall m:Map A, mapcanon m -> forall (a:ad) (y:A), mapcanon (MapPut A m a y).
Proof.
simple induction m.
intros.
simpl in |- *.
elim a.
apply M2_canon.
simpl in |- *.
apply le_trans with (m := MapCard A m0 + MapCard A m1).
apply plus_le_compat.

*****
y : A
a : ad
H1 : mapcanon (M2 A m0 m1)
H0 : forall (_ : mapcanon m1) (a : ad) (y : A), mapcanon (MapPut A m1 a y)
m1 : Map A
H : forall (_ : mapcanon m0) (a : ad) (y : A), mapcanon (MapPut A m0 a y)
m,m0 : Map A
A : Type
*****
le (MapCard A m0) (MapCard A (MapPut A m0 N0 y))
+++++
exact (MapCard_Put_lb A m0 N0 y).
-----
Lemma MapPut_canon : forall m:Map A, mapcanon m -> forall (a:ad) (y:A), mapcanon (MapPut A m a y).
Proof.
simple induction m.
intros.
simpl in |- *.
elim a.
apply M2_canon.
simpl in |- *.
apply le_trans with (m := MapCard A m0 + MapCard A m1).
apply plus_le_compat.

*****
y : A
a : ad
H1 : mapcanon (M2 A m0 m1)
H0 : forall (_ : mapcanon m1) (a : ad) (y : A), mapcanon (MapPut A m1 a y)
m1 : Map A
H : forall (_ : mapcanon m0) (a : ad) (y : A), mapcanon (MapPut A m0 a y)
m,m0 : Map A
A : Type
*****
le (MapCard A m1) (MapCard A m1)
+++++
apply le_n.
-----
Lemma MapPut_canon : forall m:Map A, mapcanon m -> forall (a:ad) (y:A), mapcanon (MapPut A m a y).
Proof.
simple induction m.
intros.
simpl in |- *.
elim a.

*****
y : A
a : ad
H1 : mapcanon (M2 A m0 m1)
H0 : forall (_ : mapcanon m1) (a : ad) (y : A), mapcanon (MapPut A m1 a y)
m1 : Map A
H : forall (_ : mapcanon m0) (a : ad) (y : A), mapcanon (MapPut A m0 a y)
m,m0 : Map A
A : Type
*****
forall p : positive, mapcanon match p with | xI p0 => M2 A m0 (MapPut A m1 (Npos p0) y) | xO p0 => M2 A (MapPut A m0 (Npos p0) y) m1 | xH => M2 A m0 (MapPut A m1 N0 y) end
+++++
intro.
-----
Lemma MapPut_canon : forall m:Map A, mapcanon m -> forall (a:ad) (y:A), mapcanon (MapPut A m a y).
Proof.
simple induction m.
intros.
simpl in |- *.
elim a.
intro.

*****
p : positive
y : A
a : ad
H1 : mapcanon (M2 A m0 m1)
H0 : forall (_ : mapcanon m1) (a : ad) (y : A), mapcanon (MapPut A m1 a y)
m1 : Map A
H : forall (_ : mapcanon m0) (a : ad) (y : A), mapcanon (MapPut A m0 a y)
m,m0 : Map A
A : Type
*****
mapcanon match p with | xI p => M2 A m0 (MapPut A m1 (Npos p) y) | xO p => M2 A (MapPut A m0 (Npos p) y) m1 | xH => M2 A m0 (MapPut A m1 N0 y) end
+++++
case p.
-----
Lemma MapPut_canon : forall m:Map A, mapcanon m -> forall (a:ad) (y:A), mapcanon (MapPut A m a y).
Proof.
simple induction m.
intros.
simpl in |- *.
elim a.
intro.
case p.

*****
p : positive
y : A
a : ad
H1 : mapcanon (M2 A m0 m1)
H0 : forall (_ : mapcanon m1) (a : ad) (y : A), mapcanon (MapPut A m1 a y)
m1 : Map A
H : forall (_ : mapcanon m0) (a : ad) (y : A), mapcanon (MapPut A m0 a y)
m,m0 : Map A
A : Type
*****
forall p : positive, mapcanon (M2 A m0 (MapPut A m1 (Npos p) y))
+++++
intro.
-----
Lemma MapPut_canon : forall m:Map A, mapcanon m -> forall (a:ad) (y:A), mapcanon (MapPut A m a y).
Proof.
simple induction m.
intros.
simpl in |- *.
elim a.
intro.
case p.
intro.

*****
p,p0 : positive
y : A
a : ad
H1 : mapcanon (M2 A m0 m1)
H0 : forall (_ : mapcanon m1) (a : ad) (y : A), mapcanon (MapPut A m1 a y)
m1 : Map A
H : forall (_ : mapcanon m0) (a : ad) (y : A), mapcanon (MapPut A m0 a y)
m,m0 : Map A
A : Type
*****
mapcanon (M2 A m0 (MapPut A m1 (Npos p0) y))
+++++
apply M2_canon.
-----
Lemma MapPut_canon : forall m:Map A, mapcanon m -> forall (a:ad) (y:A), mapcanon (MapPut A m a y).
Proof.
simple induction m.
intros.
simpl in |- *.
elim a.
intro.
case p.
intro.
apply M2_canon.

*****
p,p0 : positive
y : A
a : ad
H1 : mapcanon (M2 A m0 m1)
H0 : forall (_ : mapcanon m1) (a : ad) (y : A), mapcanon (MapPut A m1 a y)
m1 : Map A
H : forall (_ : mapcanon m0) (a : ad) (y : A), mapcanon (MapPut A m0 a y)
m,m0 : Map A
A : Type
*****
mapcanon m0
+++++
exact (mapcanon_M2_1 m0 m1 H1).
-----
Lemma MapPut_canon : forall m:Map A, mapcanon m -> forall (a:ad) (y:A), mapcanon (MapPut A m a y).
Proof.
simple induction m.
intros.
simpl in |- *.
elim a.
intro.
case p.
intro.
apply M2_canon.

*****
p,p0 : positive
y : A
a : ad
H1 : mapcanon (M2 A m0 m1)
H0 : forall (_ : mapcanon m1) (a : ad) (y : A), mapcanon (MapPut A m1 a y)
m1 : Map A
H : forall (_ : mapcanon m0) (a : ad) (y : A), mapcanon (MapPut A m0 a y)
m,m0 : Map A
A : Type
*****
mapcanon (MapPut A m1 (Npos p0) y)
+++++
apply H0.
-----
Lemma MapPut_canon : forall m:Map A, mapcanon m -> forall (a:ad) (y:A), mapcanon (MapPut A m a y).
Proof.
simple induction m.
intros.
simpl in |- *.
elim a.
intro.
case p.
intro.
apply M2_canon.
apply H0.

*****
p,p0 : positive
y : A
a : ad
H1 : mapcanon (M2 A m0 m1)
H0 : forall (_ : mapcanon m1) (a : ad) (y : A), mapcanon (MapPut A m1 a y)
m1 : Map A
H : forall (_ : mapcanon m0) (a : ad) (y : A), mapcanon (MapPut A m0 a y)
m,m0 : Map A
A : Type
*****
mapcanon m1
+++++
exact (mapcanon_M2_2 m0 m1 H1).
-----
Lemma MapPut_canon : forall m:Map A, mapcanon m -> forall (a:ad) (y:A), mapcanon (MapPut A m a y).
Proof.
simple induction m.
intros.
simpl in |- *.
elim a.
intro.
case p.
intro.
apply M2_canon.

*****
p,p0 : positive
y : A
a : ad
H1 : mapcanon (M2 A m0 m1)
H0 : forall (_ : mapcanon m1) (a : ad) (y : A), mapcanon (MapPut A m1 a y)
m1 : Map A
H : forall (_ : mapcanon m0) (a : ad) (y : A), mapcanon (MapPut A m0 a y)
m,m0 : Map A
A : Type
*****
le (S (S O)) (MapCard A (M2 A m0 (MapPut A m1 (Npos p0) y)))
+++++
simpl in |- *.
-----
Lemma MapPut_canon : forall m:Map A, mapcanon m -> forall (a:ad) (y:A), mapcanon (MapPut A m a y).
Proof.
simple induction m.
intros.
simpl in |- *.
elim a.
intro.
case p.
intro.
apply M2_canon.
simpl in |- *.

*****
p,p0 : positive
y : A
a : ad
H1 : mapcanon (M2 A m0 m1)
H0 : forall (_ : mapcanon m1) (a : ad) (y : A), mapcanon (MapPut A m1 a y)
m1 : Map A
H : forall (_ : mapcanon m0) (a : ad) (y : A), mapcanon (MapPut A m0 a y)
m,m0 : Map A
A : Type
*****
le (S (S O)) (Init.Nat.add (MapCard A m0) (MapCard A (MapPut A m1 (Npos p0) y)))
+++++
apply le_trans with (m := MapCard A m0 + MapCard A m1).
-----
Lemma MapPut_canon : forall m:Map A, mapcanon m -> forall (a:ad) (y:A), mapcanon (MapPut A m a y).
Proof.
simple induction m.
intros.
simpl in |- *.
elim a.
intro.
case p.
intro.
apply M2_canon.
simpl in |- *.
apply le_trans with (m := MapCard A m0 + MapCard A m1).

*****
p,p0 : positive
y : A
a : ad
H1 : mapcanon (M2 A m0 m1)
H0 : forall (_ : mapcanon m1) (a : ad) (y : A), mapcanon (MapPut A m1 a y)
m1 : Map A
H : forall (_ : mapcanon m0) (a : ad) (y : A), mapcanon (MapPut A m0 a y)
m,m0 : Map A
A : Type
*****
le (S (S O)) (Init.Nat.add (MapCard A m0) (MapCard A m1))
+++++
exact (mapcanon_M2 m0 m1 H1).
-----
Lemma MapPut_canon : forall m:Map A, mapcanon m -> forall (a:ad) (y:A), mapcanon (MapPut A m a y).
Proof.
simple induction m.
intros.
simpl in |- *.
elim a.
intro.
case p.
intro.
apply M2_canon.
simpl in |- *.
apply le_trans with (m := MapCard A m0 + MapCard A m1).

*****
p,p0 : positive
y : A
a : ad
H1 : mapcanon (M2 A m0 m1)
H0 : forall (_ : mapcanon m1) (a : ad) (y : A), mapcanon (MapPut A m1 a y)
m1 : Map A
H : forall (_ : mapcanon m0) (a : ad) (y : A), mapcanon (MapPut A m0 a y)
m,m0 : Map A
A : Type
*****
le (Init.Nat.add (MapCard A m0) (MapCard A m1)) (Init.Nat.add (MapCard A m0) (MapCard A (MapPut A m1 (Npos p0) y)))
+++++
apply plus_le_compat_l.
-----
Lemma MapPut_canon : forall m:Map A, mapcanon m -> forall (a:ad) (y:A), mapcanon (MapPut A m a y).
Proof.
simple induction m.
intros.
simpl in |- *.
elim a.
intro.
case p.
intro.
apply M2_canon.
simpl in |- *.
apply le_trans with (m := MapCard A m0 + MapCard A m1).
apply plus_le_compat_l.

*****
p,p0 : positive
y : A
a : ad
H1 : mapcanon (M2 A m0 m1)
H0 : forall (_ : mapcanon m1) (a : ad) (y : A), mapcanon (MapPut A m1 a y)
m1 : Map A
H : forall (_ : mapcanon m0) (a : ad) (y : A), mapcanon (MapPut A m0 a y)
m,m0 : Map A
A : Type
*****
le (MapCard A m1) (MapCard A (MapPut A m1 (Npos p0) y))
+++++
exact (MapCard_Put_lb A m1 (Npos p0) y).
-----
Lemma MapPut_canon : forall m:Map A, mapcanon m -> forall (a:ad) (y:A), mapcanon (MapPut A m a y).
Proof.
simple induction m.
intros.
simpl in |- *.
elim a.
intro.
case p.

*****
p : positive
y : A
a : ad
H1 : mapcanon (M2 A m0 m1)
H0 : forall (_ : mapcanon m1) (a : ad) (y : A), mapcanon (MapPut A m1 a y)
m1 : Map A
H : forall (_ : mapcanon m0) (a : ad) (y : A), mapcanon (MapPut A m0 a y)
m,m0 : Map A
A : Type
*****
forall p : positive, mapcanon (M2 A (MapPut A m0 (Npos p) y) m1)
+++++
intro.
-----
Lemma MapPut_canon : forall m:Map A, mapcanon m -> forall (a:ad) (y:A), mapcanon (MapPut A m a y).
Proof.
simple induction m.
intros.
simpl in |- *.
elim a.
intro.
case p.
intro.

*****
p,p0 : positive
y : A
a : ad
H1 : mapcanon (M2 A m0 m1)
H0 : forall (_ : mapcanon m1) (a : ad) (y : A), mapcanon (MapPut A m1 a y)
m1 : Map A
H : forall (_ : mapcanon m0) (a : ad) (y : A), mapcanon (MapPut A m0 a y)
m,m0 : Map A
A : Type
*****
mapcanon (M2 A (MapPut A m0 (Npos p0) y) m1)
+++++
apply M2_canon.
-----
Lemma MapPut_canon : forall m:Map A, mapcanon m -> forall (a:ad) (y:A), mapcanon (MapPut A m a y).
Proof.
simple induction m.
intros.
simpl in |- *.
elim a.
intro.
case p.
intro.
apply M2_canon.

*****
p,p0 : positive
y : A
a : ad
H1 : mapcanon (M2 A m0 m1)
H0 : forall (_ : mapcanon m1) (a : ad) (y : A), mapcanon (MapPut A m1 a y)
m1 : Map A
H : forall (_ : mapcanon m0) (a : ad) (y : A), mapcanon (MapPut A m0 a y)
m,m0 : Map A
A : Type
*****
mapcanon (MapPut A m0 (Npos p0) y)
+++++
apply H.
-----
Lemma MapPut_canon : forall m:Map A, mapcanon m -> forall (a:ad) (y:A), mapcanon (MapPut A m a y).
Proof.
simple induction m.
intros.
simpl in |- *.
elim a.
intro.
case p.
intro.
apply M2_canon.
apply H.

*****
p,p0 : positive
y : A
a : ad
H1 : mapcanon (M2 A m0 m1)
H0 : forall (_ : mapcanon m1) (a : ad) (y : A), mapcanon (MapPut A m1 a y)
m1 : Map A
H : forall (_ : mapcanon m0) (a : ad) (y : A), mapcanon (MapPut A m0 a y)
m,m0 : Map A
A : Type
*****
mapcanon m0
+++++
exact (mapcanon_M2_1 m0 m1 H1).
-----
Lemma MapPut_canon : forall m:Map A, mapcanon m -> forall (a:ad) (y:A), mapcanon (MapPut A m a y).
Proof.
simple induction m.
intros.
simpl in |- *.
elim a.
intro.
case p.
intro.
apply M2_canon.

*****
p,p0 : positive
y : A
a : ad
H1 : mapcanon (M2 A m0 m1)
H0 : forall (_ : mapcanon m1) (a : ad) (y : A), mapcanon (MapPut A m1 a y)
m1 : Map A
H : forall (_ : mapcanon m0) (a : ad) (y : A), mapcanon (MapPut A m0 a y)
m,m0 : Map A
A : Type
*****
mapcanon m1
+++++
exact (mapcanon_M2_2 m0 m1 H1).
-----
Lemma MapPut_canon : forall m:Map A, mapcanon m -> forall (a:ad) (y:A), mapcanon (MapPut A m a y).
Proof.
simple induction m.
intros.
simpl in |- *.
elim a.
intro.
case p.
intro.
apply M2_canon.

*****
p,p0 : positive
y : A
a : ad
H1 : mapcanon (M2 A m0 m1)
H0 : forall (_ : mapcanon m1) (a : ad) (y : A), mapcanon (MapPut A m1 a y)
m1 : Map A
H : forall (_ : mapcanon m0) (a : ad) (y : A), mapcanon (MapPut A m0 a y)
m,m0 : Map A
A : Type
*****
le (S (S O)) (MapCard A (M2 A (MapPut A m0 (Npos p0) y) m1))
+++++
simpl in |- *.
-----
Lemma MapPut_canon : forall m:Map A, mapcanon m -> forall (a:ad) (y:A), mapcanon (MapPut A m a y).
Proof.
simple induction m.
intros.
simpl in |- *.
elim a.
intro.
case p.
intro.
apply M2_canon.
simpl in |- *.

*****
p,p0 : positive
y : A
a : ad
H1 : mapcanon (M2 A m0 m1)
H0 : forall (_ : mapcanon m1) (a : ad) (y : A), mapcanon (MapPut A m1 a y)
m1 : Map A
H : forall (_ : mapcanon m0) (a : ad) (y : A), mapcanon (MapPut A m0 a y)
m,m0 : Map A
A : Type
*****
le (S (S O)) (Init.Nat.add (MapCard A (MapPut A m0 (Npos p0) y)) (MapCard A m1))
+++++
apply le_trans with (m := MapCard A m0 + MapCard A m1).
-----
Lemma MapPut_canon : forall m:Map A, mapcanon m -> forall (a:ad) (y:A), mapcanon (MapPut A m a y).
Proof.
simple induction m.
intros.
simpl in |- *.
elim a.
intro.
case p.
intro.
apply M2_canon.
simpl in |- *.
apply le_trans with (m := MapCard A m0 + MapCard A m1).

*****
p,p0 : positive
y : A
a : ad
H1 : mapcanon (M2 A m0 m1)
H0 : forall (_ : mapcanon m1) (a : ad) (y : A), mapcanon (MapPut A m1 a y)
m1 : Map A
H : forall (_ : mapcanon m0) (a : ad) (y : A), mapcanon (MapPut A m0 a y)
m,m0 : Map A
A : Type
*****
le (S (S O)) (Init.Nat.add (MapCard A m0) (MapCard A m1))
+++++
exact (mapcanon_M2 m0 m1 H1).
-----
Lemma MapPut_canon : forall m:Map A, mapcanon m -> forall (a:ad) (y:A), mapcanon (MapPut A m a y).
Proof.
simple induction m.
intros.
simpl in |- *.
elim a.
intro.
case p.
intro.
apply M2_canon.
simpl in |- *.
apply le_trans with (m := MapCard A m0 + MapCard A m1).

*****
p,p0 : positive
y : A
a : ad
H1 : mapcanon (M2 A m0 m1)
H0 : forall (_ : mapcanon m1) (a : ad) (y : A), mapcanon (MapPut A m1 a y)
m1 : Map A
H : forall (_ : mapcanon m0) (a : ad) (y : A), mapcanon (MapPut A m0 a y)
m,m0 : Map A
A : Type
*****
le (Init.Nat.add (MapCard A m0) (MapCard A m1)) (Init.Nat.add (MapCard A (MapPut A m0 (Npos p0) y)) (MapCard A m1))
+++++
apply plus_le_compat_r.
-----
Lemma MapPut_canon : forall m:Map A, mapcanon m -> forall (a:ad) (y:A), mapcanon (MapPut A m a y).
Proof.
simple induction m.
intros.
simpl in |- *.
elim a.
intro.
case p.
intro.
apply M2_canon.
simpl in |- *.
apply le_trans with (m := MapCard A m0 + MapCard A m1).
apply plus_le_compat_r.

*****
p,p0 : positive
y : A
a : ad
H1 : mapcanon (M2 A m0 m1)
H0 : forall (_ : mapcanon m1) (a : ad) (y : A), mapcanon (MapPut A m1 a y)
m1 : Map A
H : forall (_ : mapcanon m0) (a : ad) (y : A), mapcanon (MapPut A m0 a y)
m,m0 : Map A
A : Type
*****
le (MapCard A m0) (MapCard A (MapPut A m0 (Npos p0) y))
+++++
exact (MapCard_Put_lb A m0 (Npos p0) y).
-----
Lemma MapPut_canon : forall m:Map A, mapcanon m -> forall (a:ad) (y:A), mapcanon (MapPut A m a y).
Proof.
simple induction m.
intros.
simpl in |- *.
elim a.
intro.
case p.

*****
p : positive
y : A
a : ad
H1 : mapcanon (M2 A m0 m1)
H0 : forall (_ : mapcanon m1) (a : ad) (y : A), mapcanon (MapPut A m1 a y)
m1 : Map A
H : forall (_ : mapcanon m0) (a : ad) (y : A), mapcanon (MapPut A m0 a y)
m,m0 : Map A
A : Type
*****
mapcanon (M2 A m0 (MapPut A m1 N0 y))
+++++
apply M2_canon.
-----
Lemma MapPut_canon : forall m:Map A, mapcanon m -> forall (a:ad) (y:A), mapcanon (MapPut A m a y).
Proof.
simple induction m.
intros.
simpl in |- *.
elim a.
intro.
case p.
apply M2_canon.

*****
p : positive
y : A
a : ad
H1 : mapcanon (M2 A m0 m1)
H0 : forall (_ : mapcanon m1) (a : ad) (y : A), mapcanon (MapPut A m1 a y)
m1 : Map A
H : forall (_ : mapcanon m0) (a : ad) (y : A), mapcanon (MapPut A m0 a y)
m,m0 : Map A
A : Type
*****
mapcanon m0
+++++
apply (mapcanon_M2_1 m0 m1 H1).
-----
Lemma MapPut_canon : forall m:Map A, mapcanon m -> forall (a:ad) (y:A), mapcanon (MapPut A m a y).
Proof.
simple induction m.
intros.
simpl in |- *.
elim a.
intro.
case p.
apply M2_canon.

*****
p : positive
y : A
a : ad
H1 : mapcanon (M2 A m0 m1)
H0 : forall (_ : mapcanon m1) (a : ad) (y : A), mapcanon (MapPut A m1 a y)
m1 : Map A
H : forall (_ : mapcanon m0) (a : ad) (y : A), mapcanon (MapPut A m0 a y)
m,m0 : Map A
A : Type
*****
mapcanon (MapPut A m1 N0 y)
+++++
apply H0.
-----
Lemma MapPut_canon : forall m:Map A, mapcanon m -> forall (a:ad) (y:A), mapcanon (MapPut A m a y).
Proof.
simple induction m.
intros.
simpl in |- *.
elim a.
intro.
case p.
apply M2_canon.
apply H0.

*****
p : positive
y : A
a : ad
H1 : mapcanon (M2 A m0 m1)
H0 : forall (_ : mapcanon m1) (a : ad) (y : A), mapcanon (MapPut A m1 a y)
m1 : Map A
H : forall (_ : mapcanon m0) (a : ad) (y : A), mapcanon (MapPut A m0 a y)
m,m0 : Map A
A : Type
*****
mapcanon m1
+++++
apply (mapcanon_M2_2 m0 m1 H1).
-----
Lemma MapPut_canon : forall m:Map A, mapcanon m -> forall (a:ad) (y:A), mapcanon (MapPut A m a y).
Proof.
simple induction m.
intros.
simpl in |- *.
elim a.
intro.
case p.
apply M2_canon.

*****
p : positive
y : A
a : ad
H1 : mapcanon (M2 A m0 m1)
H0 : forall (_ : mapcanon m1) (a : ad) (y : A), mapcanon (MapPut A m1 a y)
m1 : Map A
H : forall (_ : mapcanon m0) (a : ad) (y : A), mapcanon (MapPut A m0 a y)
m,m0 : Map A
A : Type
*****
le (S (S O)) (MapCard A (M2 A m0 (MapPut A m1 N0 y)))
+++++
simpl in |- *.
-----
Lemma MapPut_canon : forall m:Map A, mapcanon m -> forall (a:ad) (y:A), mapcanon (MapPut A m a y).
Proof.
simple induction m.
intros.
simpl in |- *.
elim a.
intro.
case p.
apply M2_canon.
simpl in |- *.

*****
p : positive
y : A
a : ad
H1 : mapcanon (M2 A m0 m1)
H0 : forall (_ : mapcanon m1) (a : ad) (y : A), mapcanon (MapPut A m1 a y)
m1 : Map A
H : forall (_ : mapcanon m0) (a : ad) (y : A), mapcanon (MapPut A m0 a y)
m,m0 : Map A
A : Type
*****
le (S (S O)) (Init.Nat.add (MapCard A m0) (MapCard A (MapPut A m1 N0 y)))
+++++
apply le_trans with (m := MapCard A m0 + MapCard A m1).
-----
Lemma MapPut_canon : forall m:Map A, mapcanon m -> forall (a:ad) (y:A), mapcanon (MapPut A m a y).
Proof.
simple induction m.
intros.
simpl in |- *.
elim a.
intro.
case p.
apply M2_canon.
simpl in |- *.
apply le_trans with (m := MapCard A m0 + MapCard A m1).

*****
p : positive
y : A
a : ad
H1 : mapcanon (M2 A m0 m1)
H0 : forall (_ : mapcanon m1) (a : ad) (y : A), mapcanon (MapPut A m1 a y)
m1 : Map A
H : forall (_ : mapcanon m0) (a : ad) (y : A), mapcanon (MapPut A m0 a y)
m,m0 : Map A
A : Type
*****
le (S (S O)) (Init.Nat.add (MapCard A m0) (MapCard A m1))
+++++
exact (mapcanon_M2 m0 m1 H1).
-----
Lemma MapPut_canon : forall m:Map A, mapcanon m -> forall (a:ad) (y:A), mapcanon (MapPut A m a y).
Proof.
simple induction m.
intros.
simpl in |- *.
elim a.
intro.
case p.
apply M2_canon.
simpl in |- *.
apply le_trans with (m := MapCard A m0 + MapCard A m1).

*****
p : positive
y : A
a : ad
H1 : mapcanon (M2 A m0 m1)
H0 : forall (_ : mapcanon m1) (a : ad) (y : A), mapcanon (MapPut A m1 a y)
m1 : Map A
H : forall (_ : mapcanon m0) (a : ad) (y : A), mapcanon (MapPut A m0 a y)
m,m0 : Map A
A : Type
*****
le (Init.Nat.add (MapCard A m0) (MapCard A m1)) (Init.Nat.add (MapCard A m0) (MapCard A (MapPut A m1 N0 y)))
+++++
apply plus_le_compat_l.
-----
Lemma MapPut_canon : forall m:Map A, mapcanon m -> forall (a:ad) (y:A), mapcanon (MapPut A m a y).
Proof.
simple induction m.
intros.
simpl in |- *.
elim a.
intro.
case p.
apply M2_canon.
simpl in |- *.
apply le_trans with (m := MapCard A m0 + MapCard A m1).
apply plus_le_compat_l.

*****
p : positive
y : A
a : ad
H1 : mapcanon (M2 A m0 m1)
H0 : forall (_ : mapcanon m1) (a : ad) (y : A), mapcanon (MapPut A m1 a y)
m1 : Map A
H : forall (_ : mapcanon m0) (a : ad) (y : A), mapcanon (MapPut A m0 a y)
m,m0 : Map A
A : Type
*****
le (MapCard A m1) (MapCard A (MapPut A m1 N0 y))
+++++
exact (MapCard_Put_lb A m1 N0 y).
-----
Lemma MapPut_canon : forall m:Map A, mapcanon m -> forall (a:ad) (y:A), mapcanon (MapPut A m a y).
Proof.
simple induction m.

*****

*****

+++++
Qed.
-----
Lemma MapPut_behind_canon :\n   forall m:Map A,\n     mapcanon m -> forall (a:ad) (y:A), mapcanon (MapPut_behind A m a y).
-----
Lemma MapPut_behind_canon : forall m:Map A, mapcanon m -> forall (a:ad) (y:A), mapcanon (MapPut_behind A m a y).

*****
A : Type
*****
forall (m : Map A) (_ : mapcanon m) (a : ad) (y : A), mapcanon (MapPut_behind A m a y)
+++++
Proof.
-----
Lemma MapPut_behind_canon : forall m:Map A, mapcanon m -> forall (a:ad) (y:A), mapcanon (MapPut_behind A m a y).
Proof.

*****
A : Type
*****
forall (m : Map A) (_ : mapcanon m) (a : ad) (y : A), mapcanon (MapPut_behind A m a y)
+++++
simple induction m.
-----
Lemma MapPut_behind_canon : forall m:Map A, mapcanon m -> forall (a:ad) (y:A), mapcanon (MapPut_behind A m a y).
Proof.
simple induction m.

*****
m : Map A
A : Type
*****
forall (_ : mapcanon (M0 A)) (a : ad) (y : A), mapcanon (MapPut_behind A (M0 A) a y)
+++++
intros.
-----
Lemma MapPut_behind_canon : forall m:Map A, mapcanon m -> forall (a:ad) (y:A), mapcanon (MapPut_behind A m a y).
Proof.
simple induction m.
intros.

*****
y : A
a : ad
H : mapcanon (M0 A)
m : Map A
A : Type
*****
mapcanon (MapPut_behind A (M0 A) a y)
+++++
simpl in |- *.
-----
Lemma MapPut_behind_canon : forall m:Map A, mapcanon m -> forall (a:ad) (y:A), mapcanon (MapPut_behind A m a y).
Proof.
simple induction m.
intros.
simpl in |- *.

*****
y : A
a : ad
H : mapcanon (M0 A)
m : Map A
A : Type
*****
mapcanon (M1 A a y)
+++++
apply M1_canon.
-----
Lemma MapPut_behind_canon : forall m:Map A, mapcanon m -> forall (a:ad) (y:A), mapcanon (MapPut_behind A m a y).
Proof.
simple induction m.

*****
m : Map A
A : Type
*****
forall (a : ad) (a0 : A) (_ : mapcanon (M1 A a a0)) (a1 : ad) (y : A), mapcanon (MapPut_behind A (M1 A a a0) a1 y)
+++++
intros a0 y0 H a y.
-----
Lemma MapPut_behind_canon : forall m:Map A, mapcanon m -> forall (a:ad) (y:A), mapcanon (MapPut_behind A m a y).
Proof.
simple induction m.
intros a0 y0 H a y.

*****
y : A
a : ad
H : mapcanon (M1 A a0 y0)
y0 : A
a0 : ad
m : Map A
A : Type
*****
mapcanon (MapPut_behind A (M1 A a0 y0) a y)
+++++
simpl in |- *.
-----
Lemma MapPut_behind_canon : forall m:Map A, mapcanon m -> forall (a:ad) (y:A), mapcanon (MapPut_behind A m a y).
Proof.
simple induction m.
intros a0 y0 H a y.
simpl in |- *.

*****
y : A
a : ad
H : mapcanon (M1 A a0 y0)
y0 : A
a0 : ad
m : Map A
A : Type
*****
mapcanon match N.lxor a0 a with | N0 => M1 A a0 y0 | Npos p => MapPut1 A a0 y0 a y p end
+++++
case (Nxor a0 a).
-----
Lemma MapPut_behind_canon : forall m:Map A, mapcanon m -> forall (a:ad) (y:A), mapcanon (MapPut_behind A m a y).
Proof.
simple induction m.
intros a0 y0 H a y.
simpl in |- *.
case (Nxor a0 a).

*****
y : A
a : ad
H : mapcanon (M1 A a0 y0)
y0 : A
a0 : ad
m : Map A
A : Type
*****
mapcanon (M1 A a0 y0)
+++++
apply M1_canon.
-----
Lemma MapPut_behind_canon : forall m:Map A, mapcanon m -> forall (a:ad) (y:A), mapcanon (MapPut_behind A m a y).
Proof.
simple induction m.
intros a0 y0 H a y.
simpl in |- *.
case (Nxor a0 a).

*****
y : A
a : ad
H : mapcanon (M1 A a0 y0)
y0 : A
a0 : ad
m : Map A
A : Type
*****
forall p : positive, mapcanon (MapPut1 A a0 y0 a y p)
+++++
intro.
-----
Lemma MapPut_behind_canon : forall m:Map A, mapcanon m -> forall (a:ad) (y:A), mapcanon (MapPut_behind A m a y).
Proof.
simple induction m.
intros a0 y0 H a y.
simpl in |- *.
case (Nxor a0 a).
intro.

*****
p : positive
y : A
a : ad
H : mapcanon (M1 A a0 y0)
y0 : A
a0 : ad
m : Map A
A : Type
*****
mapcanon (MapPut1 A a0 y0 a y p)
+++++
apply MapPut1_canon.
-----
Lemma MapPut_behind_canon : forall m:Map A, mapcanon m -> forall (a:ad) (y:A), mapcanon (MapPut_behind A m a y).
Proof.
simple induction m.

*****
m : Map A
A : Type
*****
forall (m : Map A) (_ : forall (_ : mapcanon m) (a : ad) (y : A), mapcanon (MapPut_behind A m a y)) (m0 : Map A) (_ : forall (_ : mapcanon m0) (a : ad) (y : A), mapcanon (MapPut_behind A m0 a y)) (_ : mapcanon (M2 A m m0)) (a : ad) (y : A), mapcanon (MapPut_behind A (M2 A m m0) a y)
+++++
intros.
-----
Lemma MapPut_behind_canon : forall m:Map A, mapcanon m -> forall (a:ad) (y:A), mapcanon (MapPut_behind A m a y).
Proof.
simple induction m.
intros.

*****
y : A
a : ad
H1 : mapcanon (M2 A m0 m1)
H0 : forall (_ : mapcanon m1) (a : ad) (y : A),\nmapcanon (MapPut_behind A m1 a y)
m1 : Map A
H : forall (_ : mapcanon m0) (a : ad) (y : A),\nmapcanon (MapPut_behind A m0 a y)
m,m0 : Map A
A : Type
*****
mapcanon (MapPut_behind A (M2 A m0 m1) a y)
+++++
simpl in |- *.
-----
Lemma MapPut_behind_canon : forall m:Map A, mapcanon m -> forall (a:ad) (y:A), mapcanon (MapPut_behind A m a y).
Proof.
simple induction m.
intros.
simpl in |- *.

*****
y : A
a : ad
H1 : mapcanon (M2 A m0 m1)
H0 : forall (_ : mapcanon m1) (a : ad) (y : A),\nmapcanon (MapPut_behind A m1 a y)
m1 : Map A
H : forall (_ : mapcanon m0) (a : ad) (y : A),\nmapcanon (MapPut_behind A m0 a y)
m,m0 : Map A
A : Type
*****
mapcanon match a with | N0 => M2 A (MapPut_behind A m0 N0 y) m1 | Npos (xI p) => M2 A m0 (MapPut_behind A m1 (Npos p) y) | Npos (xO p) => M2 A (MapPut_behind A m0 (Npos p) y) m1 | Npos xH => M2 A m0 (MapPut_behind A m1 N0 y) end
+++++
elim a.
-----
Lemma MapPut_behind_canon : forall m:Map A, mapcanon m -> forall (a:ad) (y:A), mapcanon (MapPut_behind A m a y).
Proof.
simple induction m.
intros.
simpl in |- *.
elim a.

*****
y : A
a : ad
H1 : mapcanon (M2 A m0 m1)
H0 : forall (_ : mapcanon m1) (a : ad) (y : A),\nmapcanon (MapPut_behind A m1 a y)
m1 : Map A
H : forall (_ : mapcanon m0) (a : ad) (y : A),\nmapcanon (MapPut_behind A m0 a y)
m,m0 : Map A
A : Type
*****
mapcanon (M2 A (MapPut_behind A m0 N0 y) m1)
+++++
apply M2_canon.
-----
Lemma MapPut_behind_canon : forall m:Map A, mapcanon m -> forall (a:ad) (y:A), mapcanon (MapPut_behind A m a y).
Proof.
simple induction m.
intros.
simpl in |- *.
elim a.
apply M2_canon.

*****
y : A
a : ad
H1 : mapcanon (M2 A m0 m1)
H0 : forall (_ : mapcanon m1) (a : ad) (y : A),\nmapcanon (MapPut_behind A m1 a y)
m1 : Map A
H : forall (_ : mapcanon m0) (a : ad) (y : A),\nmapcanon (MapPut_behind A m0 a y)
m,m0 : Map A
A : Type
*****
mapcanon (MapPut_behind A m0 N0 y)
+++++
apply H.
-----
Lemma MapPut_behind_canon : forall m:Map A, mapcanon m -> forall (a:ad) (y:A), mapcanon (MapPut_behind A m a y).
Proof.
simple induction m.
intros.
simpl in |- *.
elim a.
apply M2_canon.
apply H.

*****
y : A
a : ad
H1 : mapcanon (M2 A m0 m1)
H0 : forall (_ : mapcanon m1) (a : ad) (y : A),\nmapcanon (MapPut_behind A m1 a y)
m1 : Map A
H : forall (_ : mapcanon m0) (a : ad) (y : A),\nmapcanon (MapPut_behind A m0 a y)
m,m0 : Map A
A : Type
*****
mapcanon m0
+++++
exact (mapcanon_M2_1 m0 m1 H1).
-----
Lemma MapPut_behind_canon : forall m:Map A, mapcanon m -> forall (a:ad) (y:A), mapcanon (MapPut_behind A m a y).
Proof.
simple induction m.
intros.
simpl in |- *.
elim a.
apply M2_canon.

*****
y : A
a : ad
H1 : mapcanon (M2 A m0 m1)
H0 : forall (_ : mapcanon m1) (a : ad) (y : A),\nmapcanon (MapPut_behind A m1 a y)
m1 : Map A
H : forall (_ : mapcanon m0) (a : ad) (y : A),\nmapcanon (MapPut_behind A m0 a y)
m,m0 : Map A
A : Type
*****
mapcanon m1
+++++
exact (mapcanon_M2_2 m0 m1 H1).
-----
Lemma MapPut_behind_canon : forall m:Map A, mapcanon m -> forall (a:ad) (y:A), mapcanon (MapPut_behind A m a y).
Proof.
simple induction m.
intros.
simpl in |- *.
elim a.
apply M2_canon.

*****
y : A
a : ad
H1 : mapcanon (M2 A m0 m1)
H0 : forall (_ : mapcanon m1) (a : ad) (y : A),\nmapcanon (MapPut_behind A m1 a y)
m1 : Map A
H : forall (_ : mapcanon m0) (a : ad) (y : A),\nmapcanon (MapPut_behind A m0 a y)
m,m0 : Map A
A : Type
*****
le (S (S O)) (MapCard A (M2 A (MapPut_behind A m0 N0 y) m1))
+++++
simpl in |- *.
-----
Lemma MapPut_behind_canon : forall m:Map A, mapcanon m -> forall (a:ad) (y:A), mapcanon (MapPut_behind A m a y).
Proof.
simple induction m.
intros.
simpl in |- *.
elim a.
apply M2_canon.
simpl in |- *.

*****
y : A
a : ad
H1 : mapcanon (M2 A m0 m1)
H0 : forall (_ : mapcanon m1) (a : ad) (y : A),\nmapcanon (MapPut_behind A m1 a y)
m1 : Map A
H : forall (_ : mapcanon m0) (a : ad) (y : A),\nmapcanon (MapPut_behind A m0 a y)
m,m0 : Map A
A : Type
*****
le (S (S O)) (Init.Nat.add (MapCard A (MapPut_behind A m0 N0 y)) (MapCard A m1))
+++++
apply le_trans with (m := MapCard A m0 + MapCard A m1).
-----
Lemma MapPut_behind_canon : forall m:Map A, mapcanon m -> forall (a:ad) (y:A), mapcanon (MapPut_behind A m a y).
Proof.
simple induction m.
intros.
simpl in |- *.
elim a.
apply M2_canon.
simpl in |- *.
apply le_trans with (m := MapCard A m0 + MapCard A m1).

*****
y : A
a : ad
H1 : mapcanon (M2 A m0 m1)
H0 : forall (_ : mapcanon m1) (a : ad) (y : A),\nmapcanon (MapPut_behind A m1 a y)
m1 : Map A
H : forall (_ : mapcanon m0) (a : ad) (y : A),\nmapcanon (MapPut_behind A m0 a y)
m,m0 : Map A
A : Type
*****
le (S (S O)) (Init.Nat.add (MapCard A m0) (MapCard A m1))
+++++
exact (mapcanon_M2 _ _ H1).
-----
Lemma MapPut_behind_canon : forall m:Map A, mapcanon m -> forall (a:ad) (y:A), mapcanon (MapPut_behind A m a y).
Proof.
simple induction m.
intros.
simpl in |- *.
elim a.
apply M2_canon.
simpl in |- *.
apply le_trans with (m := MapCard A m0 + MapCard A m1).

*****
y : A
a : ad
H1 : mapcanon (M2 A m0 m1)
H0 : forall (_ : mapcanon m1) (a : ad) (y : A),\nmapcanon (MapPut_behind A m1 a y)
m1 : Map A
H : forall (_ : mapcanon m0) (a : ad) (y : A),\nmapcanon (MapPut_behind A m0 a y)
m,m0 : Map A
A : Type
*****
le (Init.Nat.add (MapCard A m0) (MapCard A m1)) (Init.Nat.add (MapCard A (MapPut_behind A m0 N0 y)) (MapCard A m1))
+++++
apply plus_le_compat.
-----
Lemma MapPut_behind_canon : forall m:Map A, mapcanon m -> forall (a:ad) (y:A), mapcanon (MapPut_behind A m a y).
Proof.
simple induction m.
intros.
simpl in |- *.
elim a.
apply M2_canon.
simpl in |- *.
apply le_trans with (m := MapCard A m0 + MapCard A m1).
apply plus_le_compat.

*****
y : A
a : ad
H1 : mapcanon (M2 A m0 m1)
H0 : forall (_ : mapcanon m1) (a : ad) (y : A),\nmapcanon (MapPut_behind A m1 a y)
m1 : Map A
H : forall (_ : mapcanon m0) (a : ad) (y : A),\nmapcanon (MapPut_behind A m0 a y)
m,m0 : Map A
A : Type
*****
le (MapCard A m0) (MapCard A (MapPut_behind A m0 N0 y))
+++++
rewrite MapCard_Put_behind_Put.
-----
Lemma MapPut_behind_canon : forall m:Map A, mapcanon m -> forall (a:ad) (y:A), mapcanon (MapPut_behind A m a y).
Proof.
simple induction m.
intros.
simpl in |- *.
elim a.
apply M2_canon.
simpl in |- *.
apply le_trans with (m := MapCard A m0 + MapCard A m1).
apply plus_le_compat.
rewrite MapCard_Put_behind_Put.

*****
y : A
a : ad
H1 : mapcanon (M2 A m0 m1)
H0 : forall (_ : mapcanon m1) (a : ad) (y : A),\nmapcanon (MapPut_behind A m1 a y)
m1 : Map A
H : forall (_ : mapcanon m0) (a : ad) (y : A),\nmapcanon (MapPut_behind A m0 a y)
m,m0 : Map A
A : Type
*****
le (MapCard A m0) (MapCard A (MapPut A m0 N0 y))
+++++
exact (MapCard_Put_lb A m0 N0 y).
-----
Lemma MapPut_behind_canon : forall m:Map A, mapcanon m -> forall (a:ad) (y:A), mapcanon (MapPut_behind A m a y).
Proof.
simple induction m.
intros.
simpl in |- *.
elim a.
apply M2_canon.
simpl in |- *.
apply le_trans with (m := MapCard A m0 + MapCard A m1).
apply plus_le_compat.

*****
y : A
a : ad
H1 : mapcanon (M2 A m0 m1)
H0 : forall (_ : mapcanon m1) (a : ad) (y : A),\nmapcanon (MapPut_behind A m1 a y)
m1 : Map A
H : forall (_ : mapcanon m0) (a : ad) (y : A),\nmapcanon (MapPut_behind A m0 a y)
m,m0 : Map A
A : Type
*****
le (MapCard A m1) (MapCard A m1)
+++++
apply le_n.
-----
Lemma MapPut_behind_canon : forall m:Map A, mapcanon m -> forall (a:ad) (y:A), mapcanon (MapPut_behind A m a y).
Proof.
simple induction m.
intros.
simpl in |- *.
elim a.

*****
y : A
a : ad
H1 : mapcanon (M2 A m0 m1)
H0 : forall (_ : mapcanon m1) (a : ad) (y : A),\nmapcanon (MapPut_behind A m1 a y)
m1 : Map A
H : forall (_ : mapcanon m0) (a : ad) (y : A),\nmapcanon (MapPut_behind A m0 a y)
m,m0 : Map A
A : Type
*****
forall p : positive, mapcanon match p with | xI p0 => M2 A m0 (MapPut_behind A m1 (Npos p0) y) | xO p0 => M2 A (MapPut_behind A m0 (Npos p0) y) m1 | xH => M2 A m0 (MapPut_behind A m1 N0 y) end
+++++
intro.
-----
Lemma MapPut_behind_canon : forall m:Map A, mapcanon m -> forall (a:ad) (y:A), mapcanon (MapPut_behind A m a y).
Proof.
simple induction m.
intros.
simpl in |- *.
elim a.
intro.

*****
p : positive
y : A
a : ad
H1 : mapcanon (M2 A m0 m1)
H0 : forall (_ : mapcanon m1) (a : ad) (y : A),\nmapcanon (MapPut_behind A m1 a y)
m1 : Map A
H : forall (_ : mapcanon m0) (a : ad) (y : A),\nmapcanon (MapPut_behind A m0 a y)
m,m0 : Map A
A : Type
*****
mapcanon match p with | xI p => M2 A m0 (MapPut_behind A m1 (Npos p) y) | xO p => M2 A (MapPut_behind A m0 (Npos p) y) m1 | xH => M2 A m0 (MapPut_behind A m1 N0 y) end
+++++
case p.
-----
Lemma MapPut_behind_canon : forall m:Map A, mapcanon m -> forall (a:ad) (y:A), mapcanon (MapPut_behind A m a y).
Proof.
simple induction m.
intros.
simpl in |- *.
elim a.
intro.
case p.

*****
p : positive
y : A
a : ad
H1 : mapcanon (M2 A m0 m1)
H0 : forall (_ : mapcanon m1) (a : ad) (y : A),\nmapcanon (MapPut_behind A m1 a y)
m1 : Map A
H : forall (_ : mapcanon m0) (a : ad) (y : A),\nmapcanon (MapPut_behind A m0 a y)
m,m0 : Map A
A : Type
*****
forall p : positive, mapcanon (M2 A m0 (MapPut_behind A m1 (Npos p) y))
+++++
intro.
-----
Lemma MapPut_behind_canon : forall m:Map A, mapcanon m -> forall (a:ad) (y:A), mapcanon (MapPut_behind A m a y).
Proof.
simple induction m.
intros.
simpl in |- *.
elim a.
intro.
case p.
intro.

*****
p,p0 : positive
y : A
a : ad
H1 : mapcanon (M2 A m0 m1)
H0 : forall (_ : mapcanon m1) (a : ad) (y : A),\nmapcanon (MapPut_behind A m1 a y)
m1 : Map A
H : forall (_ : mapcanon m0) (a : ad) (y : A),\nmapcanon (MapPut_behind A m0 a y)
m,m0 : Map A
A : Type
*****
mapcanon (M2 A m0 (MapPut_behind A m1 (Npos p0) y))
+++++
apply M2_canon.
-----
Lemma MapPut_behind_canon : forall m:Map A, mapcanon m -> forall (a:ad) (y:A), mapcanon (MapPut_behind A m a y).
Proof.
simple induction m.
intros.
simpl in |- *.
elim a.
intro.
case p.
intro.
apply M2_canon.

*****
p,p0 : positive
y : A
a : ad
H1 : mapcanon (M2 A m0 m1)
H0 : forall (_ : mapcanon m1) (a : ad) (y : A),\nmapcanon (MapPut_behind A m1 a y)
m1 : Map A
H : forall (_ : mapcanon m0) (a : ad) (y : A),\nmapcanon (MapPut_behind A m0 a y)
m,m0 : Map A
A : Type
*****
mapcanon m0
+++++
exact (mapcanon_M2_1 m0 m1 H1).
-----
Lemma MapPut_behind_canon : forall m:Map A, mapcanon m -> forall (a:ad) (y:A), mapcanon (MapPut_behind A m a y).
Proof.
simple induction m.
intros.
simpl in |- *.
elim a.
intro.
case p.
intro.
apply M2_canon.

*****
p,p0 : positive
y : A
a : ad
H1 : mapcanon (M2 A m0 m1)
H0 : forall (_ : mapcanon m1) (a : ad) (y : A),\nmapcanon (MapPut_behind A m1 a y)
m1 : Map A
H : forall (_ : mapcanon m0) (a : ad) (y : A),\nmapcanon (MapPut_behind A m0 a y)
m,m0 : Map A
A : Type
*****
mapcanon (MapPut_behind A m1 (Npos p0) y)
+++++
apply H0.
-----
Lemma MapPut_behind_canon : forall m:Map A, mapcanon m -> forall (a:ad) (y:A), mapcanon (MapPut_behind A m a y).
Proof.
simple induction m.
intros.
simpl in |- *.
elim a.
intro.
case p.
intro.
apply M2_canon.
apply H0.

*****
p,p0 : positive
y : A
a : ad
H1 : mapcanon (M2 A m0 m1)
H0 : forall (_ : mapcanon m1) (a : ad) (y : A),\nmapcanon (MapPut_behind A m1 a y)
m1 : Map A
H : forall (_ : mapcanon m0) (a : ad) (y : A),\nmapcanon (MapPut_behind A m0 a y)
m,m0 : Map A
A : Type
*****
mapcanon m1
+++++
exact (mapcanon_M2_2 m0 m1 H1).
-----
Lemma MapPut_behind_canon : forall m:Map A, mapcanon m -> forall (a:ad) (y:A), mapcanon (MapPut_behind A m a y).
Proof.
simple induction m.
intros.
simpl in |- *.
elim a.
intro.
case p.
intro.
apply M2_canon.

*****
p,p0 : positive
y : A
a : ad
H1 : mapcanon (M2 A m0 m1)
H0 : forall (_ : mapcanon m1) (a : ad) (y : A),\nmapcanon (MapPut_behind A m1 a y)
m1 : Map A
H : forall (_ : mapcanon m0) (a : ad) (y : A),\nmapcanon (MapPut_behind A m0 a y)
m,m0 : Map A
A : Type
*****
le (S (S O)) (MapCard A (M2 A m0 (MapPut_behind A m1 (Npos p0) y)))
+++++
simpl in |- *.
-----
Lemma MapPut_behind_canon : forall m:Map A, mapcanon m -> forall (a:ad) (y:A), mapcanon (MapPut_behind A m a y).
Proof.
simple induction m.
intros.
simpl in |- *.
elim a.
intro.
case p.
intro.
apply M2_canon.
simpl in |- *.

*****
p,p0 : positive
y : A
a : ad
H1 : mapcanon (M2 A m0 m1)
H0 : forall (_ : mapcanon m1) (a : ad) (y : A),\nmapcanon (MapPut_behind A m1 a y)
m1 : Map A
H : forall (_ : mapcanon m0) (a : ad) (y : A),\nmapcanon (MapPut_behind A m0 a y)
m,m0 : Map A
A : Type
*****
le (S (S O)) (Init.Nat.add (MapCard A m0) (MapCard A (MapPut_behind A m1 (Npos p0) y)))
+++++
apply le_trans with (m := MapCard A m0 + MapCard A m1).
-----
Lemma MapPut_behind_canon : forall m:Map A, mapcanon m -> forall (a:ad) (y:A), mapcanon (MapPut_behind A m a y).
Proof.
simple induction m.
intros.
simpl in |- *.
elim a.
intro.
case p.
intro.
apply M2_canon.
simpl in |- *.
apply le_trans with (m := MapCard A m0 + MapCard A m1).

*****
p,p0 : positive
y : A
a : ad
H1 : mapcanon (M2 A m0 m1)
H0 : forall (_ : mapcanon m1) (a : ad) (y : A),\nmapcanon (MapPut_behind A m1 a y)
m1 : Map A
H : forall (_ : mapcanon m0) (a : ad) (y : A),\nmapcanon (MapPut_behind A m0 a y)
m,m0 : Map A
A : Type
*****
le (S (S O)) (Init.Nat.add (MapCard A m0) (MapCard A m1))
+++++
exact (mapcanon_M2 m0 m1 H1).
-----
Lemma MapPut_behind_canon : forall m:Map A, mapcanon m -> forall (a:ad) (y:A), mapcanon (MapPut_behind A m a y).
Proof.
simple induction m.
intros.
simpl in |- *.
elim a.
intro.
case p.
intro.
apply M2_canon.
simpl in |- *.
apply le_trans with (m := MapCard A m0 + MapCard A m1).

*****
p,p0 : positive
y : A
a : ad
H1 : mapcanon (M2 A m0 m1)
H0 : forall (_ : mapcanon m1) (a : ad) (y : A),\nmapcanon (MapPut_behind A m1 a y)
m1 : Map A
H : forall (_ : mapcanon m0) (a : ad) (y : A),\nmapcanon (MapPut_behind A m0 a y)
m,m0 : Map A
A : Type
*****
le (Init.Nat.add (MapCard A m0) (MapCard A m1)) (Init.Nat.add (MapCard A m0) (MapCard A (MapPut_behind A m1 (Npos p0) y)))
+++++
apply plus_le_compat_l.
-----
Lemma MapPut_behind_canon : forall m:Map A, mapcanon m -> forall (a:ad) (y:A), mapcanon (MapPut_behind A m a y).
Proof.
simple induction m.
intros.
simpl in |- *.
elim a.
intro.
case p.
intro.
apply M2_canon.
simpl in |- *.
apply le_trans with (m := MapCard A m0 + MapCard A m1).
apply plus_le_compat_l.

*****
p,p0 : positive
y : A
a : ad
H1 : mapcanon (M2 A m0 m1)
H0 : forall (_ : mapcanon m1) (a : ad) (y : A),\nmapcanon (MapPut_behind A m1 a y)
m1 : Map A
H : forall (_ : mapcanon m0) (a : ad) (y : A),\nmapcanon (MapPut_behind A m0 a y)
m,m0 : Map A
A : Type
*****
le (MapCard A m1) (MapCard A (MapPut_behind A m1 (Npos p0) y))
+++++
rewrite MapCard_Put_behind_Put.
-----
Lemma MapPut_behind_canon : forall m:Map A, mapcanon m -> forall (a:ad) (y:A), mapcanon (MapPut_behind A m a y).
Proof.
simple induction m.
intros.
simpl in |- *.
elim a.
intro.
case p.
intro.
apply M2_canon.
simpl in |- *.
apply le_trans with (m := MapCard A m0 + MapCard A m1).
apply plus_le_compat_l.
rewrite MapCard_Put_behind_Put.

*****
p,p0 : positive
y : A
a : ad
H1 : mapcanon (M2 A m0 m1)
H0 : forall (_ : mapcanon m1) (a : ad) (y : A),\nmapcanon (MapPut_behind A m1 a y)
m1 : Map A
H : forall (_ : mapcanon m0) (a : ad) (y : A),\nmapcanon (MapPut_behind A m0 a y)
m,m0 : Map A
A : Type
*****
le (MapCard A m1) (MapCard A (MapPut A m1 (Npos p0) y))
+++++
exact (MapCard_Put_lb A m1 (Npos p0) y).
-----
Lemma MapPut_behind_canon : forall m:Map A, mapcanon m -> forall (a:ad) (y:A), mapcanon (MapPut_behind A m a y).
Proof.
simple induction m.
intros.
simpl in |- *.
elim a.
intro.
case p.

*****
p : positive
y : A
a : ad
H1 : mapcanon (M2 A m0 m1)
H0 : forall (_ : mapcanon m1) (a : ad) (y : A),\nmapcanon (MapPut_behind A m1 a y)
m1 : Map A
H : forall (_ : mapcanon m0) (a : ad) (y : A),\nmapcanon (MapPut_behind A m0 a y)
m,m0 : Map A
A : Type
*****
forall p : positive, mapcanon (M2 A (MapPut_behind A m0 (Npos p) y) m1)
+++++
intro.
-----
Lemma MapPut_behind_canon : forall m:Map A, mapcanon m -> forall (a:ad) (y:A), mapcanon (MapPut_behind A m a y).
Proof.
simple induction m.
intros.
simpl in |- *.
elim a.
intro.
case p.
intro.

*****
p,p0 : positive
y : A
a : ad
H1 : mapcanon (M2 A m0 m1)
H0 : forall (_ : mapcanon m1) (a : ad) (y : A),\nmapcanon (MapPut_behind A m1 a y)
m1 : Map A
H : forall (_ : mapcanon m0) (a : ad) (y : A),\nmapcanon (MapPut_behind A m0 a y)
m,m0 : Map A
A : Type
*****
mapcanon (M2 A (MapPut_behind A m0 (Npos p0) y) m1)
+++++
apply M2_canon.
-----
Lemma MapPut_behind_canon : forall m:Map A, mapcanon m -> forall (a:ad) (y:A), mapcanon (MapPut_behind A m a y).
Proof.
simple induction m.
intros.
simpl in |- *.
elim a.
intro.
case p.
intro.
apply M2_canon.

*****
p,p0 : positive
y : A
a : ad
H1 : mapcanon (M2 A m0 m1)
H0 : forall (_ : mapcanon m1) (a : ad) (y : A),\nmapcanon (MapPut_behind A m1 a y)
m1 : Map A
H : forall (_ : mapcanon m0) (a : ad) (y : A),\nmapcanon (MapPut_behind A m0 a y)
m,m0 : Map A
A : Type
*****
mapcanon (MapPut_behind A m0 (Npos p0) y)
+++++
apply H.
-----
Lemma MapPut_behind_canon : forall m:Map A, mapcanon m -> forall (a:ad) (y:A), mapcanon (MapPut_behind A m a y).
Proof.
simple induction m.
intros.
simpl in |- *.
elim a.
intro.
case p.
intro.
apply M2_canon.
apply H.

*****
p,p0 : positive
y : A
a : ad
H1 : mapcanon (M2 A m0 m1)
H0 : forall (_ : mapcanon m1) (a : ad) (y : A),\nmapcanon (MapPut_behind A m1 a y)
m1 : Map A
H : forall (_ : mapcanon m0) (a : ad) (y : A),\nmapcanon (MapPut_behind A m0 a y)
m,m0 : Map A
A : Type
*****
mapcanon m0
+++++
exact (mapcanon_M2_1 m0 m1 H1).
-----
Lemma MapPut_behind_canon : forall m:Map A, mapcanon m -> forall (a:ad) (y:A), mapcanon (MapPut_behind A m a y).
Proof.
simple induction m.
intros.
simpl in |- *.
elim a.
intro.
case p.
intro.
apply M2_canon.

*****
p,p0 : positive
y : A
a : ad
H1 : mapcanon (M2 A m0 m1)
H0 : forall (_ : mapcanon m1) (a : ad) (y : A),\nmapcanon (MapPut_behind A m1 a y)
m1 : Map A
H : forall (_ : mapcanon m0) (a : ad) (y : A),\nmapcanon (MapPut_behind A m0 a y)
m,m0 : Map A
A : Type
*****
mapcanon m1
+++++
exact (mapcanon_M2_2 m0 m1 H1).
-----
Lemma MapPut_behind_canon : forall m:Map A, mapcanon m -> forall (a:ad) (y:A), mapcanon (MapPut_behind A m a y).
Proof.
simple induction m.
intros.
simpl in |- *.
elim a.
intro.
case p.
intro.
apply M2_canon.

*****
p,p0 : positive
y : A
a : ad
H1 : mapcanon (M2 A m0 m1)
H0 : forall (_ : mapcanon m1) (a : ad) (y : A),\nmapcanon (MapPut_behind A m1 a y)
m1 : Map A
H : forall (_ : mapcanon m0) (a : ad) (y : A),\nmapcanon (MapPut_behind A m0 a y)
m,m0 : Map A
A : Type
*****
le (S (S O)) (MapCard A (M2 A (MapPut_behind A m0 (Npos p0) y) m1))
+++++
simpl in |- *.
-----
Lemma MapPut_behind_canon : forall m:Map A, mapcanon m -> forall (a:ad) (y:A), mapcanon (MapPut_behind A m a y).
Proof.
simple induction m.
intros.
simpl in |- *.
elim a.
intro.
case p.
intro.
apply M2_canon.
simpl in |- *.

*****
p,p0 : positive
y : A
a : ad
H1 : mapcanon (M2 A m0 m1)
H0 : forall (_ : mapcanon m1) (a : ad) (y : A),\nmapcanon (MapPut_behind A m1 a y)
m1 : Map A
H : forall (_ : mapcanon m0) (a : ad) (y : A),\nmapcanon (MapPut_behind A m0 a y)
m,m0 : Map A
A : Type
*****
le (S (S O)) (Init.Nat.add (MapCard A (MapPut_behind A m0 (Npos p0) y)) (MapCard A m1))
+++++
apply le_trans with (m := MapCard A m0 + MapCard A m1).
-----
Lemma MapPut_behind_canon : forall m:Map A, mapcanon m -> forall (a:ad) (y:A), mapcanon (MapPut_behind A m a y).
Proof.
simple induction m.
intros.
simpl in |- *.
elim a.
intro.
case p.
intro.
apply M2_canon.
simpl in |- *.
apply le_trans with (m := MapCard A m0 + MapCard A m1).

*****
p,p0 : positive
y : A
a : ad
H1 : mapcanon (M2 A m0 m1)
H0 : forall (_ : mapcanon m1) (a : ad) (y : A),\nmapcanon (MapPut_behind A m1 a y)
m1 : Map A
H : forall (_ : mapcanon m0) (a : ad) (y : A),\nmapcanon (MapPut_behind A m0 a y)
m,m0 : Map A
A : Type
*****
le (S (S O)) (Init.Nat.add (MapCard A m0) (MapCard A m1))
+++++
exact (mapcanon_M2 m0 m1 H1).
-----
Lemma MapPut_behind_canon : forall m:Map A, mapcanon m -> forall (a:ad) (y:A), mapcanon (MapPut_behind A m a y).
Proof.
simple induction m.
intros.
simpl in |- *.
elim a.
intro.
case p.
intro.
apply M2_canon.
simpl in |- *.
apply le_trans with (m := MapCard A m0 + MapCard A m1).

*****
p,p0 : positive
y : A
a : ad
H1 : mapcanon (M2 A m0 m1)
H0 : forall (_ : mapcanon m1) (a : ad) (y : A),\nmapcanon (MapPut_behind A m1 a y)
m1 : Map A
H : forall (_ : mapcanon m0) (a : ad) (y : A),\nmapcanon (MapPut_behind A m0 a y)
m,m0 : Map A
A : Type
*****
le (Init.Nat.add (MapCard A m0) (MapCard A m1)) (Init.Nat.add (MapCard A (MapPut_behind A m0 (Npos p0) y)) (MapCard A m1))
+++++
apply plus_le_compat_r.
-----
Lemma MapPut_behind_canon : forall m:Map A, mapcanon m -> forall (a:ad) (y:A), mapcanon (MapPut_behind A m a y).
Proof.
simple induction m.
intros.
simpl in |- *.
elim a.
intro.
case p.
intro.
apply M2_canon.
simpl in |- *.
apply le_trans with (m := MapCard A m0 + MapCard A m1).
apply plus_le_compat_r.

*****
p,p0 : positive
y : A
a : ad
H1 : mapcanon (M2 A m0 m1)
H0 : forall (_ : mapcanon m1) (a : ad) (y : A),\nmapcanon (MapPut_behind A m1 a y)
m1 : Map A
H : forall (_ : mapcanon m0) (a : ad) (y : A),\nmapcanon (MapPut_behind A m0 a y)
m,m0 : Map A
A : Type
*****
le (MapCard A m0) (MapCard A (MapPut_behind A m0 (Npos p0) y))
+++++
rewrite MapCard_Put_behind_Put.
-----
Lemma MapPut_behind_canon : forall m:Map A, mapcanon m -> forall (a:ad) (y:A), mapcanon (MapPut_behind A m a y).
Proof.
simple induction m.
intros.
simpl in |- *.
elim a.
intro.
case p.
intro.
apply M2_canon.
simpl in |- *.
apply le_trans with (m := MapCard A m0 + MapCard A m1).
apply plus_le_compat_r.
rewrite MapCard_Put_behind_Put.

*****
p,p0 : positive
y : A
a : ad
H1 : mapcanon (M2 A m0 m1)
H0 : forall (_ : mapcanon m1) (a : ad) (y : A),\nmapcanon (MapPut_behind A m1 a y)
m1 : Map A
H : forall (_ : mapcanon m0) (a : ad) (y : A),\nmapcanon (MapPut_behind A m0 a y)
m,m0 : Map A
A : Type
*****
le (MapCard A m0) (MapCard A (MapPut A m0 (Npos p0) y))
+++++
exact (MapCard_Put_lb A m0 (Npos p0) y).
-----
Lemma MapPut_behind_canon : forall m:Map A, mapcanon m -> forall (a:ad) (y:A), mapcanon (MapPut_behind A m a y).
Proof.
simple induction m.
intros.
simpl in |- *.
elim a.
intro.
case p.

*****
p : positive
y : A
a : ad
H1 : mapcanon (M2 A m0 m1)
H0 : forall (_ : mapcanon m1) (a : ad) (y : A),\nmapcanon (MapPut_behind A m1 a y)
m1 : Map A
H : forall (_ : mapcanon m0) (a : ad) (y : A),\nmapcanon (MapPut_behind A m0 a y)
m,m0 : Map A
A : Type
*****
mapcanon (M2 A m0 (MapPut_behind A m1 N0 y))
+++++
apply M2_canon.
-----
Lemma MapPut_behind_canon : forall m:Map A, mapcanon m -> forall (a:ad) (y:A), mapcanon (MapPut_behind A m a y).
Proof.
simple induction m.
intros.
simpl in |- *.
elim a.
intro.
case p.
apply M2_canon.

*****
p : positive
y : A
a : ad
H1 : mapcanon (M2 A m0 m1)
H0 : forall (_ : mapcanon m1) (a : ad) (y : A),\nmapcanon (MapPut_behind A m1 a y)
m1 : Map A
H : forall (_ : mapcanon m0) (a : ad) (y : A),\nmapcanon (MapPut_behind A m0 a y)
m,m0 : Map A
A : Type
*****
mapcanon m0
+++++
apply (mapcanon_M2_1 m0 m1 H1).
-----
Lemma MapPut_behind_canon : forall m:Map A, mapcanon m -> forall (a:ad) (y:A), mapcanon (MapPut_behind A m a y).
Proof.
simple induction m.
intros.
simpl in |- *.
elim a.
intro.
case p.
apply M2_canon.

*****
p : positive
y : A
a : ad
H1 : mapcanon (M2 A m0 m1)
H0 : forall (_ : mapcanon m1) (a : ad) (y : A),\nmapcanon (MapPut_behind A m1 a y)
m1 : Map A
H : forall (_ : mapcanon m0) (a : ad) (y : A),\nmapcanon (MapPut_behind A m0 a y)
m,m0 : Map A
A : Type
*****
mapcanon (MapPut_behind A m1 N0 y)
+++++
apply H0.
-----
Lemma MapPut_behind_canon : forall m:Map A, mapcanon m -> forall (a:ad) (y:A), mapcanon (MapPut_behind A m a y).
Proof.
simple induction m.
intros.
simpl in |- *.
elim a.
intro.
case p.
apply M2_canon.
apply H0.

*****
p : positive
y : A
a : ad
H1 : mapcanon (M2 A m0 m1)
H0 : forall (_ : mapcanon m1) (a : ad) (y : A),\nmapcanon (MapPut_behind A m1 a y)
m1 : Map A
H : forall (_ : mapcanon m0) (a : ad) (y : A),\nmapcanon (MapPut_behind A m0 a y)
m,m0 : Map A
A : Type
*****
mapcanon m1
+++++
apply (mapcanon_M2_2 m0 m1 H1).
-----
Lemma MapPut_behind_canon : forall m:Map A, mapcanon m -> forall (a:ad) (y:A), mapcanon (MapPut_behind A m a y).
Proof.
simple induction m.
intros.
simpl in |- *.
elim a.
intro.
case p.
apply M2_canon.

*****
p : positive
y : A
a : ad
H1 : mapcanon (M2 A m0 m1)
H0 : forall (_ : mapcanon m1) (a : ad) (y : A),\nmapcanon (MapPut_behind A m1 a y)
m1 : Map A
H : forall (_ : mapcanon m0) (a : ad) (y : A),\nmapcanon (MapPut_behind A m0 a y)
m,m0 : Map A
A : Type
*****
le (S (S O)) (MapCard A (M2 A m0 (MapPut_behind A m1 N0 y)))
+++++
simpl in |- *.
-----
Lemma MapPut_behind_canon : forall m:Map A, mapcanon m -> forall (a:ad) (y:A), mapcanon (MapPut_behind A m a y).
Proof.
simple induction m.
intros.
simpl in |- *.
elim a.
intro.
case p.
apply M2_canon.
simpl in |- *.

*****
p : positive
y : A
a : ad
H1 : mapcanon (M2 A m0 m1)
H0 : forall (_ : mapcanon m1) (a : ad) (y : A),\nmapcanon (MapPut_behind A m1 a y)
m1 : Map A
H : forall (_ : mapcanon m0) (a : ad) (y : A),\nmapcanon (MapPut_behind A m0 a y)
m,m0 : Map A
A : Type
*****
le (S (S O)) (Init.Nat.add (MapCard A m0) (MapCard A (MapPut_behind A m1 N0 y)))
+++++
apply le_trans with (m := MapCard A m0 + MapCard A m1).
-----
Lemma MapPut_behind_canon : forall m:Map A, mapcanon m -> forall (a:ad) (y:A), mapcanon (MapPut_behind A m a y).
Proof.
simple induction m.
intros.
simpl in |- *.
elim a.
intro.
case p.
apply M2_canon.
simpl in |- *.
apply le_trans with (m := MapCard A m0 + MapCard A m1).

*****
p : positive
y : A
a : ad
H1 : mapcanon (M2 A m0 m1)
H0 : forall (_ : mapcanon m1) (a : ad) (y : A),\nmapcanon (MapPut_behind A m1 a y)
m1 : Map A
H : forall (_ : mapcanon m0) (a : ad) (y : A),\nmapcanon (MapPut_behind A m0 a y)
m,m0 : Map A
A : Type
*****
le (S (S O)) (Init.Nat.add (MapCard A m0) (MapCard A m1))
+++++
exact (mapcanon_M2 m0 m1 H1).
-----
Lemma MapPut_behind_canon : forall m:Map A, mapcanon m -> forall (a:ad) (y:A), mapcanon (MapPut_behind A m a y).
Proof.
simple induction m.
intros.
simpl in |- *.
elim a.
intro.
case p.
apply M2_canon.
simpl in |- *.
apply le_trans with (m := MapCard A m0 + MapCard A m1).

*****
p : positive
y : A
a : ad
H1 : mapcanon (M2 A m0 m1)
H0 : forall (_ : mapcanon m1) (a : ad) (y : A),\nmapcanon (MapPut_behind A m1 a y)
m1 : Map A
H : forall (_ : mapcanon m0) (a : ad) (y : A),\nmapcanon (MapPut_behind A m0 a y)
m,m0 : Map A
A : Type
*****
le (Init.Nat.add (MapCard A m0) (MapCard A m1)) (Init.Nat.add (MapCard A m0) (MapCard A (MapPut_behind A m1 N0 y)))
+++++
apply plus_le_compat_l.
-----
Lemma MapPut_behind_canon : forall m:Map A, mapcanon m -> forall (a:ad) (y:A), mapcanon (MapPut_behind A m a y).
Proof.
simple induction m.
intros.
simpl in |- *.
elim a.
intro.
case p.
apply M2_canon.
simpl in |- *.
apply le_trans with (m := MapCard A m0 + MapCard A m1).
apply plus_le_compat_l.

*****
p : positive
y : A
a : ad
H1 : mapcanon (M2 A m0 m1)
H0 : forall (_ : mapcanon m1) (a : ad) (y : A),\nmapcanon (MapPut_behind A m1 a y)
m1 : Map A
H : forall (_ : mapcanon m0) (a : ad) (y : A),\nmapcanon (MapPut_behind A m0 a y)
m,m0 : Map A
A : Type
*****
le (MapCard A m1) (MapCard A (MapPut_behind A m1 N0 y))
+++++
rewrite MapCard_Put_behind_Put.
-----
Lemma MapPut_behind_canon : forall m:Map A, mapcanon m -> forall (a:ad) (y:A), mapcanon (MapPut_behind A m a y).
Proof.
simple induction m.
intros.
simpl in |- *.
elim a.
intro.
case p.
apply M2_canon.
simpl in |- *.
apply le_trans with (m := MapCard A m0 + MapCard A m1).
apply plus_le_compat_l.
rewrite MapCard_Put_behind_Put.

*****
p : positive
y : A
a : ad
H1 : mapcanon (M2 A m0 m1)
H0 : forall (_ : mapcanon m1) (a : ad) (y : A),\nmapcanon (MapPut_behind A m1 a y)
m1 : Map A
H : forall (_ : mapcanon m0) (a : ad) (y : A),\nmapcanon (MapPut_behind A m0 a y)
m,m0 : Map A
A : Type
*****
le (MapCard A m1) (MapCard A (MapPut A m1 N0 y))
+++++
exact (MapCard_Put_lb A m1 N0 y).
-----
Lemma MapPut_behind_canon : forall m:Map A, mapcanon m -> forall (a:ad) (y:A), mapcanon (MapPut_behind A m a y).
Proof.
simple induction m.

*****

*****

+++++
Qed.
-----
Lemma makeM2_canon :\n   forall m m':Map A, mapcanon m -> mapcanon m' -> mapcanon (makeM2 A m m').
-----
Lemma makeM2_canon : forall m m':Map A, mapcanon m -> mapcanon m' -> mapcanon (makeM2 A m m').

*****
A : Type
*****
forall (m m' : Map A) (_ : mapcanon m) (_ : mapcanon m'), mapcanon (makeM2 A m m')
+++++
Proof.
-----
Lemma makeM2_canon : forall m m':Map A, mapcanon m -> mapcanon m' -> mapcanon (makeM2 A m m').
Proof.

*****
A : Type
*****
forall (m m' : Map A) (_ : mapcanon m) (_ : mapcanon m'), mapcanon (makeM2 A m m')
+++++
intro.
-----
Lemma makeM2_canon : forall m m':Map A, mapcanon m -> mapcanon m' -> mapcanon (makeM2 A m m').
Proof.
intro.

*****
m : Map A
A : Type
*****
forall (m' : Map A) (_ : mapcanon m) (_ : mapcanon m'), mapcanon (makeM2 A m m')
+++++
case m.
-----
Lemma makeM2_canon : forall m m':Map A, mapcanon m -> mapcanon m' -> mapcanon (makeM2 A m m').
Proof.
intro.
case m.

*****
m : Map A
A : Type
*****
forall (m' : Map A) (_ : mapcanon (M0 A)) (_ : mapcanon m'), mapcanon (makeM2 A (M0 A) m')
+++++
intro.
-----
Lemma makeM2_canon : forall m m':Map A, mapcanon m -> mapcanon m' -> mapcanon (makeM2 A m m').
Proof.
intro.
case m.
intro.

*****
m,m' : Map A
A : Type
*****
forall (_ : mapcanon (M0 A)) (_ : mapcanon m'), mapcanon (makeM2 A (M0 A) m')
+++++
case m'.
-----
Lemma makeM2_canon : forall m m':Map A, mapcanon m -> mapcanon m' -> mapcanon (makeM2 A m m').
Proof.
intro.
case m.
intro.
case m'.

*****
m,m' : Map A
A : Type
*****
forall (_ : mapcanon (M0 A)) (_ : mapcanon (M0 A)), mapcanon (makeM2 A (M0 A) (M0 A))
+++++
intros.
-----
Lemma makeM2_canon : forall m m':Map A, mapcanon m -> mapcanon m' -> mapcanon (makeM2 A m m').
Proof.
intro.
case m.
intro.
case m'.
intros.

*****
H,H0 : mapcanon (M0 A)
m,m' : Map A
A : Type
*****
mapcanon (makeM2 A (M0 A) (M0 A))
+++++
exact M0_canon.
-----
Lemma makeM2_canon : forall m m':Map A, mapcanon m -> mapcanon m' -> mapcanon (makeM2 A m m').
Proof.
intro.
case m.
intro.
case m'.

*****
m,m' : Map A
A : Type
*****
forall (a : ad) (a0 : A) (_ : mapcanon (M0 A)) (_ : mapcanon (M1 A a a0)), mapcanon (makeM2 A (M0 A) (M1 A a a0))
+++++
intros a y H H0.
-----
Lemma makeM2_canon : forall m m':Map A, mapcanon m -> mapcanon m' -> mapcanon (makeM2 A m m').
Proof.
intro.
case m.
intro.
case m'.
intros a y H H0.

*****
H0 : mapcanon (M1 A a y)
H : mapcanon (M0 A)
y : A
a : ad
m,m' : Map A
A : Type
*****
mapcanon (makeM2 A (M0 A) (M1 A a y))
+++++
exact (M1_canon (Ndouble_plus_one a) y).
-----
Lemma makeM2_canon : forall m m':Map A, mapcanon m -> mapcanon m' -> mapcanon (makeM2 A m m').
Proof.
intro.
case m.
intro.
case m'.

*****
m,m' : Map A
A : Type
*****
forall (m m0 : Map A) (_ : mapcanon (M0 A)) (_ : mapcanon (M2 A m m0)), mapcanon (makeM2 A (M0 A) (M2 A m m0))
+++++
intros.
-----
Lemma makeM2_canon : forall m m':Map A, mapcanon m -> mapcanon m' -> mapcanon (makeM2 A m m').
Proof.
intro.
case m.
intro.
case m'.
intros.

*****
H0 : mapcanon (M2 A m0 m1)
H : mapcanon (M0 A)
m,m',m0,m1 : Map A
A : Type
*****
mapcanon (makeM2 A (M0 A) (M2 A m0 m1))
+++++
simpl in |- *.
-----
Lemma makeM2_canon : forall m m':Map A, mapcanon m -> mapcanon m' -> mapcanon (makeM2 A m m').
Proof.
intro.
case m.
intro.
case m'.
intros.
simpl in |- *.

*****
H0 : mapcanon (M2 A m0 m1)
H : mapcanon (M0 A)
m,m',m0,m1 : Map A
A : Type
*****
mapcanon (M2 A (M0 A) (M2 A m0 m1))
+++++
apply M2_canon.
-----
Lemma makeM2_canon : forall m m':Map A, mapcanon m -> mapcanon m' -> mapcanon (makeM2 A m m').
Proof.
intro.
case m.
intro.
case m'.
intros.
simpl in |- *.
apply M2_canon.

*****
H0 : mapcanon (M2 A m0 m1)
H : mapcanon (M0 A)
m,m',m0,m1 : Map A
A : Type
*****
mapcanon (M0 A)
+++++
try assumption.
-----
Lemma makeM2_canon : forall m m':Map A, mapcanon m -> mapcanon m' -> mapcanon (makeM2 A m m').
Proof.
intro.
case m.
intro.
case m'.
intros.
simpl in |- *.
apply M2_canon.

*****
H0 : mapcanon (M2 A m0 m1)
H : mapcanon (M0 A)
m,m',m0,m1 : Map A
A : Type
*****
mapcanon (M2 A m0 m1)
+++++
try assumption.
-----
Lemma makeM2_canon : forall m m':Map A, mapcanon m -> mapcanon m' -> mapcanon (makeM2 A m m').
Proof.
intro.
case m.
intro.
case m'.
intros.
simpl in |- *.
apply M2_canon.

*****
H0 : mapcanon (M2 A m0 m1)
H : mapcanon (M0 A)
m,m',m0,m1 : Map A
A : Type
*****
le (S (S O)) (MapCard A (M2 A (M0 A) (M2 A m0 m1)))
+++++
try assumption.
-----
Lemma makeM2_canon : forall m m':Map A, mapcanon m -> mapcanon m' -> mapcanon (makeM2 A m m').
Proof.
intro.
case m.
intro.
case m'.
intros.
simpl in |- *.
apply M2_canon.
try assumption.

*****
H0 : mapcanon (M2 A m0 m1)
H : mapcanon (M0 A)
m,m',m0,m1 : Map A
A : Type
*****
le (S (S O)) (MapCard A (M2 A (M0 A) (M2 A m0 m1)))
+++++
exact (mapcanon_M2 m0 m1 H0).
-----
Lemma makeM2_canon : forall m m':Map A, mapcanon m -> mapcanon m' -> mapcanon (makeM2 A m m').
Proof.
intro.
case m.

*****
m : Map A
A : Type
*****
forall (a : ad) (a0 : A) (m' : Map A) (_ : mapcanon (M1 A a a0)) (_ : mapcanon m'), mapcanon (makeM2 A (M1 A a a0) m')
+++++
intros a y m'.
-----
Lemma makeM2_canon : forall m m':Map A, mapcanon m -> mapcanon m' -> mapcanon (makeM2 A m m').
Proof.
intro.
case m.
intros a y m'.

*****
m' : Map A
y : A
a : ad
m : Map A
A : Type
*****
forall (_ : mapcanon (M1 A a y)) (_ : mapcanon m'), mapcanon (makeM2 A (M1 A a y) m')
+++++
case m'.
-----
Lemma makeM2_canon : forall m m':Map A, mapcanon m -> mapcanon m' -> mapcanon (makeM2 A m m').
Proof.
intro.
case m.
intros a y m'.
case m'.

*****
m' : Map A
y : A
a : ad
m : Map A
A : Type
*****
forall (_ : mapcanon (M1 A a y)) (_ : mapcanon (M0 A)), mapcanon (makeM2 A (M1 A a y) (M0 A))
+++++
intros.
-----
Lemma makeM2_canon : forall m m':Map A, mapcanon m -> mapcanon m' -> mapcanon (makeM2 A m m').
Proof.
intro.
case m.
intros a y m'.
case m'.
intros.

*****
H0 : mapcanon (M0 A)
H : mapcanon (M1 A a y)
m' : Map A
y : A
a : ad
m : Map A
A : Type
*****
mapcanon (makeM2 A (M1 A a y) (M0 A))
+++++
exact (M1_canon (Ndouble a) y).
-----
Lemma makeM2_canon : forall m m':Map A, mapcanon m -> mapcanon m' -> mapcanon (makeM2 A m m').
Proof.
intro.
case m.
intros a y m'.
case m'.

*****
m' : Map A
y : A
a : ad
m : Map A
A : Type
*****
forall (a0 : ad) (a1 : A) (_ : mapcanon (M1 A a y)) (_ : mapcanon (M1 A a0 a1)), mapcanon (makeM2 A (M1 A a y) (M1 A a0 a1))
+++++
intros a0 y0 H H0.
-----
Lemma makeM2_canon : forall m m':Map A, mapcanon m -> mapcanon m' -> mapcanon (makeM2 A m m').
Proof.
intro.
case m.
intros a y m'.
case m'.
intros a0 y0 H H0.

*****
H0 : mapcanon (M1 A a0 y0)
H : mapcanon (M1 A a y)
y0 : A
a0 : ad
m' : Map A
y : A
a : ad
m : Map A
A : Type
*****
mapcanon (makeM2 A (M1 A a y) (M1 A a0 y0))
+++++
simpl in |- *.
-----
Lemma makeM2_canon : forall m m':Map A, mapcanon m -> mapcanon m' -> mapcanon (makeM2 A m m').
Proof.
intro.
case m.
intros a y m'.
case m'.
intros a0 y0 H H0.
simpl in |- *.

*****
H0 : mapcanon (M1 A a0 y0)
H : mapcanon (M1 A a y)
y0 : A
a0 : ad
m' : Map A
y : A
a : ad
m : Map A
A : Type
*****
mapcanon (M2 A (M1 A a y) (M1 A a0 y0))
+++++
apply M2_canon.
-----
Lemma makeM2_canon : forall m m':Map A, mapcanon m -> mapcanon m' -> mapcanon (makeM2 A m m').
Proof.
intro.
case m.
intros a y m'.
case m'.
intros a0 y0 H H0.
simpl in |- *.
apply M2_canon.

*****
H0 : mapcanon (M1 A a0 y0)
H : mapcanon (M1 A a y)
y0 : A
a0 : ad
m' : Map A
y : A
a : ad
m : Map A
A : Type
*****
mapcanon (M1 A a y)
+++++
try assumption.
-----
Lemma makeM2_canon : forall m m':Map A, mapcanon m -> mapcanon m' -> mapcanon (makeM2 A m m').
Proof.
intro.
case m.
intros a y m'.
case m'.
intros a0 y0 H H0.
simpl in |- *.
apply M2_canon.

*****
H0 : mapcanon (M1 A a0 y0)
H : mapcanon (M1 A a y)
y0 : A
a0 : ad
m' : Map A
y : A
a : ad
m : Map A
A : Type
*****
mapcanon (M1 A a0 y0)
+++++
try assumption.
-----
Lemma makeM2_canon : forall m m':Map A, mapcanon m -> mapcanon m' -> mapcanon (makeM2 A m m').
Proof.
intro.
case m.
intros a y m'.
case m'.
intros a0 y0 H H0.
simpl in |- *.
apply M2_canon.

*****
H0 : mapcanon (M1 A a0 y0)
H : mapcanon (M1 A a y)
y0 : A
a0 : ad
m' : Map A
y : A
a : ad
m : Map A
A : Type
*****
le (S (S O)) (MapCard A (M2 A (M1 A a y) (M1 A a0 y0)))
+++++
try assumption.
-----
Lemma makeM2_canon : forall m m':Map A, mapcanon m -> mapcanon m' -> mapcanon (makeM2 A m m').
Proof.
intro.
case m.
intros a y m'.
case m'.
intros a0 y0 H H0.
simpl in |- *.
apply M2_canon.
try assumption.

*****
H0 : mapcanon (M1 A a0 y0)
H : mapcanon (M1 A a y)
y0 : A
a0 : ad
m' : Map A
y : A
a : ad
m : Map A
A : Type
*****
le (S (S O)) (MapCard A (M2 A (M1 A a y) (M1 A a0 y0)))
+++++
apply le_n.
-----
Lemma makeM2_canon : forall m m':Map A, mapcanon m -> mapcanon m' -> mapcanon (makeM2 A m m').
Proof.
intro.
case m.
intros a y m'.
case m'.

*****
m' : Map A
y : A
a : ad
m : Map A
A : Type
*****
forall (m m0 : Map A) (_ : mapcanon (M1 A a y)) (_ : mapcanon (M2 A m m0)), mapcanon (makeM2 A (M1 A a y) (M2 A m m0))
+++++
intros.
-----
Lemma makeM2_canon : forall m m':Map A, mapcanon m -> mapcanon m' -> mapcanon (makeM2 A m m').
Proof.
intro.
case m.
intros a y m'.
case m'.
intros.

*****
H0 : mapcanon (M2 A m0 m1)
H : mapcanon (M1 A a y)
m',m0,m1 : Map A
y : A
a : ad
m : Map A
A : Type
*****
mapcanon (makeM2 A (M1 A a y) (M2 A m0 m1))
+++++
simpl in |- *.
-----
Lemma makeM2_canon : forall m m':Map A, mapcanon m -> mapcanon m' -> mapcanon (makeM2 A m m').
Proof.
intro.
case m.
intros a y m'.
case m'.
intros.
simpl in |- *.

*****
H0 : mapcanon (M2 A m0 m1)
H : mapcanon (M1 A a y)
m',m0,m1 : Map A
y : A
a : ad
m : Map A
A : Type
*****
mapcanon (M2 A (M1 A a y) (M2 A m0 m1))
+++++
apply M2_canon.
-----
Lemma makeM2_canon : forall m m':Map A, mapcanon m -> mapcanon m' -> mapcanon (makeM2 A m m').
Proof.
intro.
case m.
intros a y m'.
case m'.
intros.
simpl in |- *.
apply M2_canon.

*****
H0 : mapcanon (M2 A m0 m1)
H : mapcanon (M1 A a y)
m',m0,m1 : Map A
y : A
a : ad
m : Map A
A : Type
*****
mapcanon (M1 A a y)
+++++
try assumption.
-----
Lemma makeM2_canon : forall m m':Map A, mapcanon m -> mapcanon m' -> mapcanon (makeM2 A m m').
Proof.
intro.
case m.
intros a y m'.
case m'.
intros.
simpl in |- *.
apply M2_canon.

*****
H0 : mapcanon (M2 A m0 m1)
H : mapcanon (M1 A a y)
m',m0,m1 : Map A
y : A
a : ad
m : Map A
A : Type
*****
mapcanon (M2 A m0 m1)
+++++
try assumption.
-----
Lemma makeM2_canon : forall m m':Map A, mapcanon m -> mapcanon m' -> mapcanon (makeM2 A m m').
Proof.
intro.
case m.
intros a y m'.
case m'.
intros.
simpl in |- *.
apply M2_canon.

*****
H0 : mapcanon (M2 A m0 m1)
H : mapcanon (M1 A a y)
m',m0,m1 : Map A
y : A
a : ad
m : Map A
A : Type
*****
le (S (S O)) (MapCard A (M2 A (M1 A a y) (M2 A m0 m1)))
+++++
try assumption.
-----
Lemma makeM2_canon : forall m m':Map A, mapcanon m -> mapcanon m' -> mapcanon (makeM2 A m m').
Proof.
intro.
case m.
intros a y m'.
case m'.
intros.
simpl in |- *.
apply M2_canon.
try assumption.

*****
H0 : mapcanon (M2 A m0 m1)
H : mapcanon (M1 A a y)
m',m0,m1 : Map A
y : A
a : ad
m : Map A
A : Type
*****
le (S (S O)) (MapCard A (M2 A (M1 A a y) (M2 A m0 m1)))
+++++
apply le_trans with (m := MapCard A (M2 A m0 m1)).
-----
Lemma makeM2_canon : forall m m':Map A, mapcanon m -> mapcanon m' -> mapcanon (makeM2 A m m').
Proof.
intro.
case m.
intros a y m'.
case m'.
intros.
simpl in |- *.
apply M2_canon.
try assumption.
apply le_trans with (m := MapCard A (M2 A m0 m1)).

*****
H0 : mapcanon (M2 A m0 m1)
H : mapcanon (M1 A a y)
m',m0,m1 : Map A
y : A
a : ad
m : Map A
A : Type
*****
le (S (S O)) (MapCard A (M2 A m0 m1))
+++++
exact (mapcanon_M2 _ _ H0).
-----
Lemma makeM2_canon : forall m m':Map A, mapcanon m -> mapcanon m' -> mapcanon (makeM2 A m m').
Proof.
intro.
case m.
intros a y m'.
case m'.
intros.
simpl in |- *.
apply M2_canon.
try assumption.
apply le_trans with (m := MapCard A (M2 A m0 m1)).

*****
H0 : mapcanon (M2 A m0 m1)
H : mapcanon (M1 A a y)
m',m0,m1 : Map A
y : A
a : ad
m : Map A
A : Type
*****
le (MapCard A (M2 A m0 m1)) (MapCard A (M2 A (M1 A a y) (M2 A m0 m1)))
+++++
exact (le_plus_r (MapCard A (M1 A a y)) (MapCard A (M2 A m0 m1))).
-----
Lemma makeM2_canon : forall m m':Map A, mapcanon m -> mapcanon m' -> mapcanon (makeM2 A m m').
Proof.
intro.
case m.

*****
m : Map A
A : Type
*****
forall (m m0 m' : Map A) (_ : mapcanon (M2 A m m0)) (_ : mapcanon m'), mapcanon (makeM2 A (M2 A m m0) m')
+++++
simpl in |- *.
-----
Lemma makeM2_canon : forall m m':Map A, mapcanon m -> mapcanon m' -> mapcanon (makeM2 A m m').
Proof.
intro.
case m.
simpl in |- *.

*****
m : Map A
A : Type
*****
forall (m m0 m' : Map A) (_ : mapcanon (M2 A m m0)) (_ : mapcanon m'), mapcanon (M2 A (M2 A m m0) m')
+++++
intros.
-----
Lemma makeM2_canon : forall m m':Map A, mapcanon m -> mapcanon m' -> mapcanon (makeM2 A m m').
Proof.
intro.
case m.
simpl in |- *.
intros.

*****
H0 : mapcanon m'
H : mapcanon (M2 A m0 m1)
m,m0,m1,m' : Map A
A : Type
*****
mapcanon (M2 A (M2 A m0 m1) m')
+++++
apply M2_canon.
-----
Lemma makeM2_canon : forall m m':Map A, mapcanon m -> mapcanon m' -> mapcanon (makeM2 A m m').
Proof.
intro.
case m.
simpl in |- *.
intros.
apply M2_canon.

*****
H0 : mapcanon m'
H : mapcanon (M2 A m0 m1)
m,m0,m1,m' : Map A
A : Type
*****
mapcanon (M2 A m0 m1)
+++++
try assumption.
-----
Lemma makeM2_canon : forall m m':Map A, mapcanon m -> mapcanon m' -> mapcanon (makeM2 A m m').
Proof.
intro.
case m.
simpl in |- *.
intros.
apply M2_canon.

*****
H0 : mapcanon m'
H : mapcanon (M2 A m0 m1)
m,m0,m1,m' : Map A
A : Type
*****
mapcanon m'
+++++
try assumption.
-----
Lemma makeM2_canon : forall m m':Map A, mapcanon m -> mapcanon m' -> mapcanon (makeM2 A m m').
Proof.
intro.
case m.
simpl in |- *.
intros.
apply M2_canon.

*****
H0 : mapcanon m'
H : mapcanon (M2 A m0 m1)
m,m0,m1,m' : Map A
A : Type
*****
le (S (S O)) (MapCard A (M2 A (M2 A m0 m1) m'))
+++++
try assumption.
-----
Lemma makeM2_canon : forall m m':Map A, mapcanon m -> mapcanon m' -> mapcanon (makeM2 A m m').
Proof.
intro.
case m.
simpl in |- *.
intros.
apply M2_canon.
try assumption.

*****
H0 : mapcanon m'
H : mapcanon (M2 A m0 m1)
m,m0,m1,m' : Map A
A : Type
*****
le (S (S O)) (MapCard A (M2 A (M2 A m0 m1) m'))
+++++
apply le_trans with (m := MapCard A (M2 A m0 m1)).
-----
Lemma makeM2_canon : forall m m':Map A, mapcanon m -> mapcanon m' -> mapcanon (makeM2 A m m').
Proof.
intro.
case m.
simpl in |- *.
intros.
apply M2_canon.
try assumption.
apply le_trans with (m := MapCard A (M2 A m0 m1)).

*****
H0 : mapcanon m'
H : mapcanon (M2 A m0 m1)
m,m0,m1,m' : Map A
A : Type
*****
le (S (S O)) (MapCard A (M2 A m0 m1))
+++++
exact (mapcanon_M2 _ _ H).
-----
Lemma makeM2_canon : forall m m':Map A, mapcanon m -> mapcanon m' -> mapcanon (makeM2 A m m').
Proof.
intro.
case m.
simpl in |- *.
intros.
apply M2_canon.
try assumption.
apply le_trans with (m := MapCard A (M2 A m0 m1)).

*****
H0 : mapcanon m'
H : mapcanon (M2 A m0 m1)
m,m0,m1,m' : Map A
A : Type
*****
le (MapCard A (M2 A m0 m1)) (MapCard A (M2 A (M2 A m0 m1) m'))
+++++
exact (le_plus_l (MapCard A (M2 A m0 m1)) (MapCard A m')).
-----
Lemma makeM2_canon : forall m m':Map A, mapcanon m -> mapcanon m' -> mapcanon (makeM2 A m m').
Proof.
intro.
case m.

*****

*****

+++++
Qed.
-----
Fixpoint MapCanonicalize (m:Map A) : Map A :=\n    match m with\n    | M2 m0 m1 => makeM2 A (MapCanonicalize m0) (MapCanonicalize m1)\n    | _ => m\n    end.
-----
Lemma mapcanon_exists_1 : forall m:Map A, eqmap A m (MapCanonicalize m).
-----
Lemma mapcanon_exists_1 : forall m:Map A, eqmap A m (MapCanonicalize m).

*****
A : Type
*****
forall m : Map A, eqmap A m (MapCanonicalize m)
+++++
Proof.
-----
Lemma mapcanon_exists_1 : forall m:Map A, eqmap A m (MapCanonicalize m).
Proof.

*****
A : Type
*****
forall m : Map A, eqmap A m (MapCanonicalize m)
+++++
simple induction m.
-----
Lemma mapcanon_exists_1 : forall m:Map A, eqmap A m (MapCanonicalize m).
Proof.
simple induction m.

*****
m : Map A
A : Type
*****
eqmap A (M0 A) (MapCanonicalize (M0 A))
+++++
apply eqmap_refl.
-----
Lemma mapcanon_exists_1 : forall m:Map A, eqmap A m (MapCanonicalize m).
Proof.
simple induction m.

*****
m : Map A
A : Type
*****
forall (a : ad) (a0 : A), eqmap A (M1 A a a0) (MapCanonicalize (M1 A a a0))
+++++
intros.
-----
Lemma mapcanon_exists_1 : forall m:Map A, eqmap A m (MapCanonicalize m).
Proof.
simple induction m.
intros.

*****
a0 : A
a : ad
m : Map A
A : Type
*****
eqmap A (M1 A a a0) (MapCanonicalize (M1 A a a0))
+++++
apply eqmap_refl.
-----
Lemma mapcanon_exists_1 : forall m:Map A, eqmap A m (MapCanonicalize m).
Proof.
simple induction m.

*****
m : Map A
A : Type
*****
forall (m : Map A) (_ : eqmap A m (MapCanonicalize m)) (m0 : Map A) (_ : eqmap A m0 (MapCanonicalize m0)), eqmap A (M2 A m m0) (MapCanonicalize (M2 A m m0))
+++++
intros.
-----
Lemma mapcanon_exists_1 : forall m:Map A, eqmap A m (MapCanonicalize m).
Proof.
simple induction m.
intros.

*****
H0 : eqmap A m1 (MapCanonicalize m1)
m1 : Map A
H : eqmap A m0 (MapCanonicalize m0)
m,m0 : Map A
A : Type
*****
eqmap A (M2 A m0 m1) (MapCanonicalize (M2 A m0 m1))
+++++
simpl in |- *.
-----
Lemma mapcanon_exists_1 : forall m:Map A, eqmap A m (MapCanonicalize m).
Proof.
simple induction m.
intros.
simpl in |- *.

*****
H0 : eqmap A m1 (MapCanonicalize m1)
m1 : Map A
H : eqmap A m0 (MapCanonicalize m0)
m,m0 : Map A
A : Type
*****
eqmap A (M2 A m0 m1) (makeM2 A (MapCanonicalize m0) (MapCanonicalize m1))
+++++
unfold eqmap in |- *.
-----
Lemma mapcanon_exists_1 : forall m:Map A, eqmap A m (MapCanonicalize m).
Proof.
simple induction m.
intros.
simpl in |- *.
unfold eqmap in |- *.

*****
H0 : eqmap A m1 (MapCanonicalize m1)
m1 : Map A
H : eqmap A m0 (MapCanonicalize m0)
m,m0 : Map A
A : Type
*****
eqm A (MapGet A (M2 A m0 m1)) (MapGet A (makeM2 A (MapCanonicalize m0) (MapCanonicalize m1)))
+++++
unfold eqm in |- *.
-----
Lemma mapcanon_exists_1 : forall m:Map A, eqmap A m (MapCanonicalize m).
Proof.
simple induction m.
intros.
simpl in |- *.
unfold eqmap in |- *.
unfold eqm in |- *.

*****
H0 : eqmap A m1 (MapCanonicalize m1)
m1 : Map A
H : eqmap A m0 (MapCanonicalize m0)
m,m0 : Map A
A : Type
*****
forall a : ad, eq (MapGet A (M2 A m0 m1) a) (MapGet A (makeM2 A (MapCanonicalize m0) (MapCanonicalize m1)) a)
+++++
intro.
-----
Lemma mapcanon_exists_1 : forall m:Map A, eqmap A m (MapCanonicalize m).
Proof.
simple induction m.
intros.
simpl in |- *.
unfold eqmap in |- *.
unfold eqm in |- *.
intro.

*****
a : ad
H0 : eqmap A m1 (MapCanonicalize m1)
m1 : Map A
H : eqmap A m0 (MapCanonicalize m0)
m,m0 : Map A
A : Type
*****
eq (MapGet A (M2 A m0 m1) a) (MapGet A (makeM2 A (MapCanonicalize m0) (MapCanonicalize m1)) a)
+++++
rewrite (makeM2_M2 A (MapCanonicalize m0) (MapCanonicalize m1) a).
-----
Lemma mapcanon_exists_1 : forall m:Map A, eqmap A m (MapCanonicalize m).
Proof.
simple induction m.
intros.
simpl in |- *.
unfold eqmap in |- *.
unfold eqm in |- *.
intro.
rewrite (makeM2_M2 A (MapCanonicalize m0) (MapCanonicalize m1) a).

*****
a : ad
H0 : eqmap A m1 (MapCanonicalize m1)
m1 : Map A
H : eqmap A m0 (MapCanonicalize m0)
m,m0 : Map A
A : Type
*****
eq (MapGet A (M2 A m0 m1) a) (MapGet A (M2 A (MapCanonicalize m0) (MapCanonicalize m1)) a)
+++++
rewrite MapGet_M2_bit_0_if.
-----
Lemma mapcanon_exists_1 : forall m:Map A, eqmap A m (MapCanonicalize m).
Proof.
simple induction m.
intros.
simpl in |- *.
unfold eqmap in |- *.
unfold eqm in |- *.
intro.
rewrite (makeM2_M2 A (MapCanonicalize m0) (MapCanonicalize m1) a).
rewrite MapGet_M2_bit_0_if.

*****
a : ad
H0 : eqmap A m1 (MapCanonicalize m1)
m1 : Map A
H : eqmap A m0 (MapCanonicalize m0)
m,m0 : Map A
A : Type
*****
eq (if N.odd a then MapGet A m1 (N.div2 a) else MapGet A m0 (N.div2 a)) (MapGet A (M2 A (MapCanonicalize m0) (MapCanonicalize m1)) a)
+++++
rewrite MapGet_M2_bit_0_if.
-----
Lemma mapcanon_exists_1 : forall m:Map A, eqmap A m (MapCanonicalize m).
Proof.
simple induction m.
intros.
simpl in |- *.
unfold eqmap in |- *.
unfold eqm in |- *.
intro.
rewrite (makeM2_M2 A (MapCanonicalize m0) (MapCanonicalize m1) a).
rewrite MapGet_M2_bit_0_if.
rewrite MapGet_M2_bit_0_if.

*****
a : ad
H0 : eqmap A m1 (MapCanonicalize m1)
m1 : Map A
H : eqmap A m0 (MapCanonicalize m0)
m,m0 : Map A
A : Type
*****
eq (if N.odd a then MapGet A m1 (N.div2 a) else MapGet A m0 (N.div2 a)) (if N.odd a then MapGet A (MapCanonicalize m1) (N.div2 a) else MapGet A (MapCanonicalize m0) (N.div2 a))
+++++
rewrite <- (H (Ndiv2 a)).
-----
Lemma mapcanon_exists_1 : forall m:Map A, eqmap A m (MapCanonicalize m).
Proof.
simple induction m.
intros.
simpl in |- *.
unfold eqmap in |- *.
unfold eqm in |- *.
intro.
rewrite (makeM2_M2 A (MapCanonicalize m0) (MapCanonicalize m1) a).
rewrite MapGet_M2_bit_0_if.
rewrite MapGet_M2_bit_0_if.
rewrite <- (H (Ndiv2 a)).

*****
a : ad
H0 : eqmap A m1 (MapCanonicalize m1)
m1 : Map A
H : eqmap A m0 (MapCanonicalize m0)
m,m0 : Map A
A : Type
*****
eq (if N.odd a then MapGet A m1 (N.div2 a) else MapGet A m0 (N.div2 a)) (if N.odd a then MapGet A (MapCanonicalize m1) (N.div2 a) else MapGet A m0 (N.div2 a))
+++++
rewrite <- (H0 (Ndiv2 a)).
-----
Lemma mapcanon_exists_1 : forall m:Map A, eqmap A m (MapCanonicalize m).
Proof.
simple induction m.
intros.
simpl in |- *.
unfold eqmap in |- *.
unfold eqm in |- *.
intro.
rewrite (makeM2_M2 A (MapCanonicalize m0) (MapCanonicalize m1) a).
rewrite MapGet_M2_bit_0_if.
rewrite MapGet_M2_bit_0_if.
rewrite <- (H (Ndiv2 a)).
rewrite <- (H0 (Ndiv2 a)).

*****
a : ad
H0 : eqmap A m1 (MapCanonicalize m1)
m1 : Map A
H : eqmap A m0 (MapCanonicalize m0)
m,m0 : Map A
A : Type
*****
eq (if N.odd a then MapGet A m1 (N.div2 a) else MapGet A m0 (N.div2 a)) (if N.odd a then MapGet A m1 (N.div2 a) else MapGet A m0 (N.div2 a))
+++++
reflexivity.
-----
Lemma mapcanon_exists_1 : forall m:Map A, eqmap A m (MapCanonicalize m).
Proof.
simple induction m.

*****

*****

+++++
Qed.
-----
Lemma mapcanon_exists_2 : forall m:Map A, mapcanon (MapCanonicalize m).
-----
Lemma mapcanon_exists_2 : forall m:Map A, mapcanon (MapCanonicalize m).

*****
A : Type
*****
forall m : Map A, mapcanon (MapCanonicalize m)
+++++
Proof.
-----
Lemma mapcanon_exists_2 : forall m:Map A, mapcanon (MapCanonicalize m).
Proof.

*****
A : Type
*****
forall m : Map A, mapcanon (MapCanonicalize m)
+++++
simple induction m.
-----
Lemma mapcanon_exists_2 : forall m:Map A, mapcanon (MapCanonicalize m).
Proof.
simple induction m.

*****
m : Map A
A : Type
*****
mapcanon (MapCanonicalize (M0 A))
+++++
apply M0_canon.
-----
Lemma mapcanon_exists_2 : forall m:Map A, mapcanon (MapCanonicalize m).
Proof.
simple induction m.

*****
m : Map A
A : Type
*****
forall (a : ad) (a0 : A), mapcanon (MapCanonicalize (M1 A a a0))
+++++
intros.
-----
Lemma mapcanon_exists_2 : forall m:Map A, mapcanon (MapCanonicalize m).
Proof.
simple induction m.
intros.

*****
a0 : A
a : ad
m : Map A
A : Type
*****
mapcanon (MapCanonicalize (M1 A a a0))
+++++
simpl in |- *.
-----
Lemma mapcanon_exists_2 : forall m:Map A, mapcanon (MapCanonicalize m).
Proof.
simple induction m.
intros.
simpl in |- *.

*****
a0 : A
a : ad
m : Map A
A : Type
*****
mapcanon (M1 A a a0)
+++++
apply M1_canon.
-----
Lemma mapcanon_exists_2 : forall m:Map A, mapcanon (MapCanonicalize m).
Proof.
simple induction m.

*****
m : Map A
A : Type
*****
forall (m : Map A) (_ : mapcanon (MapCanonicalize m)) (m0 : Map A) (_ : mapcanon (MapCanonicalize m0)), mapcanon (MapCanonicalize (M2 A m m0))
+++++
intros.
-----
Lemma mapcanon_exists_2 : forall m:Map A, mapcanon (MapCanonicalize m).
Proof.
simple induction m.
intros.

*****
H0 : mapcanon (MapCanonicalize m1)
m1 : Map A
H : mapcanon (MapCanonicalize m0)
m,m0 : Map A
A : Type
*****
mapcanon (MapCanonicalize (M2 A m0 m1))
+++++
simpl in |- *.
-----
Lemma mapcanon_exists_2 : forall m:Map A, mapcanon (MapCanonicalize m).
Proof.
simple induction m.
intros.
simpl in |- *.

*****
H0 : mapcanon (MapCanonicalize m1)
m1 : Map A
H : mapcanon (MapCanonicalize m0)
m,m0 : Map A
A : Type
*****
mapcanon (makeM2 A (MapCanonicalize m0) (MapCanonicalize m1))
+++++
apply makeM2_canon.
-----
Lemma mapcanon_exists_2 : forall m:Map A, mapcanon (MapCanonicalize m).
Proof.
simple induction m.
intros.
simpl in |- *.
apply makeM2_canon.

*****
H0 : mapcanon (MapCanonicalize m1)
m1 : Map A
H : mapcanon (MapCanonicalize m0)
m,m0 : Map A
A : Type
*****
mapcanon (MapCanonicalize m0)
+++++
assumption.
-----
Lemma mapcanon_exists_2 : forall m:Map A, mapcanon (MapCanonicalize m).
Proof.
simple induction m.
intros.
simpl in |- *.
apply makeM2_canon.

*****
H0 : mapcanon (MapCanonicalize m1)
m1 : Map A
H : mapcanon (MapCanonicalize m0)
m,m0 : Map A
A : Type
*****
mapcanon (MapCanonicalize m1)
+++++
assumption.
-----
Lemma mapcanon_exists_2 : forall m:Map A, mapcanon (MapCanonicalize m).
Proof.
simple induction m.

*****

*****

+++++
Qed.
-----
Lemma mapcanon_exists :\n   forall m:Map A, {m' : Map A | eqmap A m m' /\ mapcanon m'}.
-----
Lemma mapcanon_exists : forall m:Map A, {m' : Map A | eqmap A m m' /\\ mapcanon m'}.

*****
A : Type
*****
forall m : Map A, sig (fun m' : Map A => and (eqmap A m m') (mapcanon m'))
+++++
Proof.
-----
Lemma mapcanon_exists : forall m:Map A, {m' : Map A | eqmap A m m' /\\ mapcanon m'}.
Proof.

*****
A : Type
*****
forall m : Map A, sig (fun m' : Map A => and (eqmap A m m') (mapcanon m'))
+++++
intro.
-----
Lemma mapcanon_exists : forall m:Map A, {m' : Map A | eqmap A m m' /\\ mapcanon m'}.
Proof.
intro.

*****
m : Map A
A : Type
*****
sig (fun m' : Map A => and (eqmap A m m') (mapcanon m'))
+++++
split with (MapCanonicalize m).
-----
Lemma mapcanon_exists : forall m:Map A, {m' : Map A | eqmap A m m' /\\ mapcanon m'}.
Proof.
intro.
split with (MapCanonicalize m).

*****
m : Map A
A : Type
*****
and (eqmap A m (MapCanonicalize m)) (mapcanon (MapCanonicalize m))
+++++
split.
-----
Lemma mapcanon_exists : forall m:Map A, {m' : Map A | eqmap A m m' /\\ mapcanon m'}.
Proof.
intro.
split with (MapCanonicalize m).
split.

*****
m : Map A
A : Type
*****
eqmap A m (MapCanonicalize m)
+++++
apply mapcanon_exists_1.
-----
Lemma mapcanon_exists : forall m:Map A, {m' : Map A | eqmap A m m' /\\ mapcanon m'}.
Proof.
intro.
split with (MapCanonicalize m).
split.

*****
m : Map A
A : Type
*****
mapcanon (MapCanonicalize m)
+++++
apply mapcanon_exists_2.
-----
Lemma mapcanon_exists : forall m:Map A, {m' : Map A | eqmap A m m' /\\ mapcanon m'}.
Proof.
intro.
split with (MapCanonicalize m).
split.

*****

*****

+++++
Qed.
-----
Lemma MapRemove_canon :\n   forall m:Map A, mapcanon m -> forall a:ad, mapcanon (MapRemove A m a).
-----
Lemma MapRemove_canon : forall m:Map A, mapcanon m -> forall a:ad, mapcanon (MapRemove A m a).

*****
A : Type
*****
forall (m : Map A) (_ : mapcanon m) (a : ad), mapcanon (MapRemove A m a)
+++++
Proof.
-----
Lemma MapRemove_canon : forall m:Map A, mapcanon m -> forall a:ad, mapcanon (MapRemove A m a).
Proof.

*****
A : Type
*****
forall (m : Map A) (_ : mapcanon m) (a : ad), mapcanon (MapRemove A m a)
+++++
simple induction m.
-----
Lemma MapRemove_canon : forall m:Map A, mapcanon m -> forall a:ad, mapcanon (MapRemove A m a).
Proof.
simple induction m.

*****
m : Map A
A : Type
*****
forall (_ : mapcanon (M0 A)) (a : ad), mapcanon (MapRemove A (M0 A) a)
+++++
intros.
-----
Lemma MapRemove_canon : forall m:Map A, mapcanon m -> forall a:ad, mapcanon (MapRemove A m a).
Proof.
simple induction m.
intros.

*****
a : ad
H : mapcanon (M0 A)
m : Map A
A : Type
*****
mapcanon (MapRemove A (M0 A) a)
+++++
exact M0_canon.
-----
Lemma MapRemove_canon : forall m:Map A, mapcanon m -> forall a:ad, mapcanon (MapRemove A m a).
Proof.
simple induction m.

*****
m : Map A
A : Type
*****
forall (a : ad) (a0 : A) (_ : mapcanon (M1 A a a0)) (a1 : ad), mapcanon (MapRemove A (M1 A a a0) a1)
+++++
intros a y H a0.
-----
Lemma MapRemove_canon : forall m:Map A, mapcanon m -> forall a:ad, mapcanon (MapRemove A m a).
Proof.
simple induction m.
intros a y H a0.

*****
a0 : ad
H : mapcanon (M1 A a y)
y : A
a : ad
m : Map A
A : Type
*****
mapcanon (MapRemove A (M1 A a y) a0)
+++++
simpl in |- *.
-----
Lemma MapRemove_canon : forall m:Map A, mapcanon m -> forall a:ad, mapcanon (MapRemove A m a).
Proof.
simple induction m.
intros a y H a0.
simpl in |- *.

*****
a0 : ad
H : mapcanon (M1 A a y)
y : A
a : ad
m : Map A
A : Type
*****
mapcanon (if N.eqb a a0 then M0 A else M1 A a y)
+++++
case (Neqb a a0).
-----
Lemma MapRemove_canon : forall m:Map A, mapcanon m -> forall a:ad, mapcanon (MapRemove A m a).
Proof.
simple induction m.
intros a y H a0.
simpl in |- *.
case (Neqb a a0).

*****
a0 : ad
H : mapcanon (M1 A a y)
y : A
a : ad
m : Map A
A : Type
*****
mapcanon (M0 A)
+++++
exact M0_canon.
-----
Lemma MapRemove_canon : forall m:Map A, mapcanon m -> forall a:ad, mapcanon (MapRemove A m a).
Proof.
simple induction m.
intros a y H a0.
simpl in |- *.
case (Neqb a a0).

*****
a0 : ad
H : mapcanon (M1 A a y)
y : A
a : ad
m : Map A
A : Type
*****
mapcanon (M1 A a y)
+++++
assumption.
-----
Lemma MapRemove_canon : forall m:Map A, mapcanon m -> forall a:ad, mapcanon (MapRemove A m a).
Proof.
simple induction m.

*****
m : Map A
A : Type
*****
forall (m : Map A) (_ : forall (_ : mapcanon m) (a : ad), mapcanon (MapRemove A m a)) (m0 : Map A) (_ : forall (_ : mapcanon m0) (a : ad), mapcanon (MapRemove A m0 a)) (_ : mapcanon (M2 A m m0)) (a : ad), mapcanon (MapRemove A (M2 A m m0) a)
+++++
intros.
-----
Lemma MapRemove_canon : forall m:Map A, mapcanon m -> forall a:ad, mapcanon (MapRemove A m a).
Proof.
simple induction m.
intros.

*****
a : ad
H1 : mapcanon (M2 A m0 m1)
H0 : forall (_ : mapcanon m1) (a : ad), mapcanon (MapRemove A m1 a)
m1 : Map A
H : forall (_ : mapcanon m0) (a : ad), mapcanon (MapRemove A m0 a)
m,m0 : Map A
A : Type
*****
mapcanon (MapRemove A (M2 A m0 m1) a)
+++++
simpl in |- *.
-----
Lemma MapRemove_canon : forall m:Map A, mapcanon m -> forall a:ad, mapcanon (MapRemove A m a).
Proof.
simple induction m.
intros.
simpl in |- *.

*****
a : ad
H1 : mapcanon (M2 A m0 m1)
H0 : forall (_ : mapcanon m1) (a : ad), mapcanon (MapRemove A m1 a)
m1 : Map A
H : forall (_ : mapcanon m0) (a : ad), mapcanon (MapRemove A m0 a)
m,m0 : Map A
A : Type
*****
mapcanon (if N.odd a then makeM2 A m0 (MapRemove A m1 (N.div2 a)) else makeM2 A (MapRemove A m0 (N.div2 a)) m1)
+++++
case (Nbit0 a).
-----
Lemma MapRemove_canon : forall m:Map A, mapcanon m -> forall a:ad, mapcanon (MapRemove A m a).
Proof.
simple induction m.
intros.
simpl in |- *.
case (Nbit0 a).

*****
a : ad
H1 : mapcanon (M2 A m0 m1)
H0 : forall (_ : mapcanon m1) (a : ad), mapcanon (MapRemove A m1 a)
m1 : Map A
H : forall (_ : mapcanon m0) (a : ad), mapcanon (MapRemove A m0 a)
m,m0 : Map A
A : Type
*****
mapcanon (makeM2 A m0 (MapRemove A m1 (N.div2 a)))
+++++
apply makeM2_canon.
-----
Lemma MapRemove_canon : forall m:Map A, mapcanon m -> forall a:ad, mapcanon (MapRemove A m a).
Proof.
simple induction m.
intros.
simpl in |- *.
case (Nbit0 a).
apply makeM2_canon.

*****
a : ad
H1 : mapcanon (M2 A m0 m1)
H0 : forall (_ : mapcanon m1) (a : ad), mapcanon (MapRemove A m1 a)
m1 : Map A
H : forall (_ : mapcanon m0) (a : ad), mapcanon (MapRemove A m0 a)
m,m0 : Map A
A : Type
*****
mapcanon m0
+++++
exact (mapcanon_M2_1 _ _ H1).
-----
Lemma MapRemove_canon : forall m:Map A, mapcanon m -> forall a:ad, mapcanon (MapRemove A m a).
Proof.
simple induction m.
intros.
simpl in |- *.
case (Nbit0 a).
apply makeM2_canon.

*****
a : ad
H1 : mapcanon (M2 A m0 m1)
H0 : forall (_ : mapcanon m1) (a : ad), mapcanon (MapRemove A m1 a)
m1 : Map A
H : forall (_ : mapcanon m0) (a : ad), mapcanon (MapRemove A m0 a)
m,m0 : Map A
A : Type
*****
mapcanon (MapRemove A m1 (N.div2 a))
+++++
apply H0.
-----
Lemma MapRemove_canon : forall m:Map A, mapcanon m -> forall a:ad, mapcanon (MapRemove A m a).
Proof.
simple induction m.
intros.
simpl in |- *.
case (Nbit0 a).
apply makeM2_canon.
apply H0.

*****
a : ad
H1 : mapcanon (M2 A m0 m1)
H0 : forall (_ : mapcanon m1) (a : ad), mapcanon (MapRemove A m1 a)
m1 : Map A
H : forall (_ : mapcanon m0) (a : ad), mapcanon (MapRemove A m0 a)
m,m0 : Map A
A : Type
*****
mapcanon m1
+++++
exact (mapcanon_M2_2 _ _ H1).
-----
Lemma MapRemove_canon : forall m:Map A, mapcanon m -> forall a:ad, mapcanon (MapRemove A m a).
Proof.
simple induction m.
intros.
simpl in |- *.
case (Nbit0 a).

*****
a : ad
H1 : mapcanon (M2 A m0 m1)
H0 : forall (_ : mapcanon m1) (a : ad), mapcanon (MapRemove A m1 a)
m1 : Map A
H : forall (_ : mapcanon m0) (a : ad), mapcanon (MapRemove A m0 a)
m,m0 : Map A
A : Type
*****
mapcanon (makeM2 A (MapRemove A m0 (N.div2 a)) m1)
+++++
apply makeM2_canon.
-----
Lemma MapRemove_canon : forall m:Map A, mapcanon m -> forall a:ad, mapcanon (MapRemove A m a).
Proof.
simple induction m.
intros.
simpl in |- *.
case (Nbit0 a).
apply makeM2_canon.

*****
a : ad
H1 : mapcanon (M2 A m0 m1)
H0 : forall (_ : mapcanon m1) (a : ad), mapcanon (MapRemove A m1 a)
m1 : Map A
H : forall (_ : mapcanon m0) (a : ad), mapcanon (MapRemove A m0 a)
m,m0 : Map A
A : Type
*****
mapcanon (MapRemove A m0 (N.div2 a))
+++++
apply H.
-----
Lemma MapRemove_canon : forall m:Map A, mapcanon m -> forall a:ad, mapcanon (MapRemove A m a).
Proof.
simple induction m.
intros.
simpl in |- *.
case (Nbit0 a).
apply makeM2_canon.
apply H.

*****
a : ad
H1 : mapcanon (M2 A m0 m1)
H0 : forall (_ : mapcanon m1) (a : ad), mapcanon (MapRemove A m1 a)
m1 : Map A
H : forall (_ : mapcanon m0) (a : ad), mapcanon (MapRemove A m0 a)
m,m0 : Map A
A : Type
*****
mapcanon m0
+++++
exact (mapcanon_M2_1 _ _ H1).
-----
Lemma MapRemove_canon : forall m:Map A, mapcanon m -> forall a:ad, mapcanon (MapRemove A m a).
Proof.
simple induction m.
intros.
simpl in |- *.
case (Nbit0 a).
apply makeM2_canon.

*****
a : ad
H1 : mapcanon (M2 A m0 m1)
H0 : forall (_ : mapcanon m1) (a : ad), mapcanon (MapRemove A m1 a)
m1 : Map A
H : forall (_ : mapcanon m0) (a : ad), mapcanon (MapRemove A m0 a)
m,m0 : Map A
A : Type
*****
mapcanon m1
+++++
exact (mapcanon_M2_2 _ _ H1).
-----
Lemma MapRemove_canon : forall m:Map A, mapcanon m -> forall a:ad, mapcanon (MapRemove A m a).
Proof.
simple induction m.

*****

*****

+++++
Qed.
-----
Lemma MapMerge_canon :\n   forall m m':Map A, mapcanon m -> mapcanon m' -> mapcanon (MapMerge A m m').
-----
Lemma MapMerge_canon : forall m m':Map A, mapcanon m -> mapcanon m' -> mapcanon (MapMerge A m m').

*****
A : Type
*****
forall (m m' : Map A) (_ : mapcanon m) (_ : mapcanon m'), mapcanon (MapMerge A m m')
+++++
Proof.
-----
Lemma MapMerge_canon : forall m m':Map A, mapcanon m -> mapcanon m' -> mapcanon (MapMerge A m m').
Proof.

*****
A : Type
*****
forall (m m' : Map A) (_ : mapcanon m) (_ : mapcanon m'), mapcanon (MapMerge A m m')
+++++
simple induction m.
-----
Lemma MapMerge_canon : forall m m':Map A, mapcanon m -> mapcanon m' -> mapcanon (MapMerge A m m').
Proof.
simple induction m.

*****
m : Map A
A : Type
*****
forall (m' : Map A) (_ : mapcanon (M0 A)) (_ : mapcanon m'), mapcanon (MapMerge A (M0 A) m')
+++++
intros.
-----
Lemma MapMerge_canon : forall m m':Map A, mapcanon m -> mapcanon m' -> mapcanon (MapMerge A m m').
Proof.
simple induction m.
intros.

*****
H0 : mapcanon m'
H : mapcanon (M0 A)
m,m' : Map A
A : Type
*****
mapcanon (MapMerge A (M0 A) m')
+++++
exact H0.
-----
Lemma MapMerge_canon : forall m m':Map A, mapcanon m -> mapcanon m' -> mapcanon (MapMerge A m m').
Proof.
simple induction m.

*****
m : Map A
A : Type
*****
forall (a : ad) (a0 : A) (m' : Map A) (_ : mapcanon (M1 A a a0)) (_ : mapcanon m'), mapcanon (MapMerge A (M1 A a a0) m')
+++++
simpl in |- *.
-----
Lemma MapMerge_canon : forall m m':Map A, mapcanon m -> mapcanon m' -> mapcanon (MapMerge A m m').
Proof.
simple induction m.
simpl in |- *.

*****
m : Map A
A : Type
*****
forall (a : ad) (a0 : A) (m' : Map A) (_ : mapcanon (M1 A a a0)) (_ : mapcanon m'), mapcanon (MapPut_behind A m' a a0)
+++++
intros a y m' H H0.
-----
Lemma MapMerge_canon : forall m m':Map A, mapcanon m -> mapcanon m' -> mapcanon (MapMerge A m m').
Proof.
simple induction m.
simpl in |- *.
intros a y m' H H0.

*****
H0 : mapcanon m'
H : mapcanon (M1 A a y)
m' : Map A
y : A
a : ad
m : Map A
A : Type
*****
mapcanon (MapPut_behind A m' a y)
+++++
exact (MapPut_behind_canon m' H0 a y).
-----
Lemma MapMerge_canon : forall m m':Map A, mapcanon m -> mapcanon m' -> mapcanon (MapMerge A m m').
Proof.
simple induction m.

*****
m : Map A
A : Type
*****
forall (m : Map A) (_ : forall (m' : Map A) (_ : mapcanon m) (_ : mapcanon m'), mapcanon (MapMerge A m m')) (m0 : Map A) (_ : forall (m' : Map A) (_ : mapcanon m0) (_ : mapcanon m'), mapcanon (MapMerge A m0 m')) (m' : Map A) (_ : mapcanon (M2 A m m0)) (_ : mapcanon m'), mapcanon (MapMerge A (M2 A m m0) m')
+++++
simple induction m'.
-----
Lemma MapMerge_canon : forall m m':Map A, mapcanon m -> mapcanon m' -> mapcanon (MapMerge A m m').
Proof.
simple induction m.
simple induction m'.

*****
m' : Map A
H0 : forall (m' : Map A) (_ : mapcanon m1) (_ : mapcanon m'),\nmapcanon (MapMerge A m1 m')
m1 : Map A
H : forall (m' : Map A) (_ : mapcanon m0) (_ : mapcanon m'),\nmapcanon (MapMerge A m0 m')
m,m0 : Map A
A : Type
*****
forall (_ : mapcanon (M2 A m0 m1)) (_ : mapcanon (M0 A)), mapcanon (MapMerge A (M2 A m0 m1) (M0 A))
+++++
intros.
-----
Lemma MapMerge_canon : forall m m':Map A, mapcanon m -> mapcanon m' -> mapcanon (MapMerge A m m').
Proof.
simple induction m.
simple induction m'.
intros.

*****
H2 : mapcanon (M0 A)
H1 : mapcanon (M2 A m0 m1)
m' : Map A
H0 : forall (m' : Map A) (_ : mapcanon m1) (_ : mapcanon m'),\nmapcanon (MapMerge A m1 m')
m1 : Map A
H : forall (m' : Map A) (_ : mapcanon m0) (_ : mapcanon m'),\nmapcanon (MapMerge A m0 m')
m,m0 : Map A
A : Type
*****
mapcanon (MapMerge A (M2 A m0 m1) (M0 A))
+++++
exact H1.
-----
Lemma MapMerge_canon : forall m m':Map A, mapcanon m -> mapcanon m' -> mapcanon (MapMerge A m m').
Proof.
simple induction m.
simple induction m'.

*****
m' : Map A
H0 : forall (m' : Map A) (_ : mapcanon m1) (_ : mapcanon m'),\nmapcanon (MapMerge A m1 m')
m1 : Map A
H : forall (m' : Map A) (_ : mapcanon m0) (_ : mapcanon m'),\nmapcanon (MapMerge A m0 m')
m,m0 : Map A
A : Type
*****
forall (a : ad) (a0 : A) (_ : mapcanon (M2 A m0 m1)) (_ : mapcanon (M1 A a a0)), mapcanon (MapMerge A (M2 A m0 m1) (M1 A a a0))
+++++
intros a y H1 H2.
-----
Lemma MapMerge_canon : forall m m':Map A, mapcanon m -> mapcanon m' -> mapcanon (MapMerge A m m').
Proof.
simple induction m.
simple induction m'.
intros a y H1 H2.

*****
H2 : mapcanon (M1 A a y)
H1 : mapcanon (M2 A m0 m1)
y : A
a : ad
m' : Map A
H0 : forall (m' : Map A) (_ : mapcanon m1) (_ : mapcanon m'),\nmapcanon (MapMerge A m1 m')
m1 : Map A
H : forall (m' : Map A) (_ : mapcanon m0) (_ : mapcanon m'),\nmapcanon (MapMerge A m0 m')
m,m0 : Map A
A : Type
*****
mapcanon (MapMerge A (M2 A m0 m1) (M1 A a y))
+++++
unfold MapMerge in |- *.
-----
Lemma MapMerge_canon : forall m m':Map A, mapcanon m -> mapcanon m' -> mapcanon (MapMerge A m m').
Proof.
simple induction m.
simple induction m'.
intros a y H1 H2.
unfold MapMerge in |- *.

*****
H2 : mapcanon (M1 A a y)
H1 : mapcanon (M2 A m0 m1)
y : A
a : ad
m' : Map A
H0 : forall (m' : Map A) (_ : mapcanon m1) (_ : mapcanon m'),\nmapcanon (MapMerge A m1 m')
m1 : Map A
H : forall (m' : Map A) (_ : mapcanon m0) (_ : mapcanon m'),\nmapcanon (MapMerge A m0 m')
m,m0 : Map A
A : Type
*****
mapcanon (MapPut A (M2 A m0 m1) a y)
+++++
exact (MapPut_canon _ H1 a y).
-----
Lemma MapMerge_canon : forall m m':Map A, mapcanon m -> mapcanon m' -> mapcanon (MapMerge A m m').
Proof.
simple induction m.
simple induction m'.

*****
m' : Map A
H0 : forall (m' : Map A) (_ : mapcanon m1) (_ : mapcanon m'),\nmapcanon (MapMerge A m1 m')
m1 : Map A
H : forall (m' : Map A) (_ : mapcanon m0) (_ : mapcanon m'),\nmapcanon (MapMerge A m0 m')
m,m0 : Map A
A : Type
*****
forall (m : Map A) (_ : forall (_ : mapcanon (M2 A m0 m1)) (_ : mapcanon m), mapcanon (MapMerge A (M2 A m0 m1) m)) (m2 : Map A) (_ : forall (_ : mapcanon (M2 A m0 m1)) (_ : mapcanon m2), mapcanon (MapMerge A (M2 A m0 m1) m2)) (_ : mapcanon (M2 A m0 m1)) (_ : mapcanon (M2 A m m2)), mapcanon (MapMerge A (M2 A m0 m1) (M2 A m m2))
+++++
intros.
-----
Lemma MapMerge_canon : forall m m':Map A, mapcanon m -> mapcanon m' -> mapcanon (MapMerge A m m').
Proof.
simple induction m.
simple induction m'.
intros.

*****
H4 : mapcanon (M2 A m2 m3)
H3 : mapcanon (M2 A m0 m1)
H2 : forall (_ : mapcanon (M2 A m0 m1)) (_ : mapcanon m3),\nmapcanon (MapMerge A (M2 A m0 m1) m3)
m3 : Map A
H1 : forall (_ : mapcanon (M2 A m0 m1)) (_ : mapcanon m2),\nmapcanon (MapMerge A (M2 A m0 m1) m2)
m',m2 : Map A
H0 : forall (m' : Map A) (_ : mapcanon m1) (_ : mapcanon m'),\nmapcanon (MapMerge A m1 m')
m1 : Map A
H : forall (m' : Map A) (_ : mapcanon m0) (_ : mapcanon m'),\nmapcanon (MapMerge A m0 m')
m,m0 : Map A
A : Type
*****
mapcanon (MapMerge A (M2 A m0 m1) (M2 A m2 m3))
+++++
simpl in |- *.
-----
Lemma MapMerge_canon : forall m m':Map A, mapcanon m -> mapcanon m' -> mapcanon (MapMerge A m m').
Proof.
simple induction m.
simple induction m'.
intros.
simpl in |- *.

*****
H4 : mapcanon (M2 A m2 m3)
H3 : mapcanon (M2 A m0 m1)
H2 : forall (_ : mapcanon (M2 A m0 m1)) (_ : mapcanon m3),\nmapcanon (MapMerge A (M2 A m0 m1) m3)
m3 : Map A
H1 : forall (_ : mapcanon (M2 A m0 m1)) (_ : mapcanon m2),\nmapcanon (MapMerge A (M2 A m0 m1) m2)
m',m2 : Map A
H0 : forall (m' : Map A) (_ : mapcanon m1) (_ : mapcanon m'),\nmapcanon (MapMerge A m1 m')
m1 : Map A
H : forall (m' : Map A) (_ : mapcanon m0) (_ : mapcanon m'),\nmapcanon (MapMerge A m0 m')
m,m0 : Map A
A : Type
*****
mapcanon (M2 A (MapMerge A m0 m2) (MapMerge A m1 m3))
+++++
apply M2_canon.
-----
Lemma MapMerge_canon : forall m m':Map A, mapcanon m -> mapcanon m' -> mapcanon (MapMerge A m m').
Proof.
simple induction m.
simple induction m'.
intros.
simpl in |- *.
apply M2_canon.

*****
H4 : mapcanon (M2 A m2 m3)
H3 : mapcanon (M2 A m0 m1)
H2 : forall (_ : mapcanon (M2 A m0 m1)) (_ : mapcanon m3),\nmapcanon (MapMerge A (M2 A m0 m1) m3)
m3 : Map A
H1 : forall (_ : mapcanon (M2 A m0 m1)) (_ : mapcanon m2),\nmapcanon (MapMerge A (M2 A m0 m1) m2)
m',m2 : Map A
H0 : forall (m' : Map A) (_ : mapcanon m1) (_ : mapcanon m'),\nmapcanon (MapMerge A m1 m')
m1 : Map A
H : forall (m' : Map A) (_ : mapcanon m0) (_ : mapcanon m'),\nmapcanon (MapMerge A m0 m')
m,m0 : Map A
A : Type
*****
mapcanon (MapMerge A m0 m2)
+++++
apply H.
-----
Lemma MapMerge_canon : forall m m':Map A, mapcanon m -> mapcanon m' -> mapcanon (MapMerge A m m').
Proof.
simple induction m.
simple induction m'.
intros.
simpl in |- *.
apply M2_canon.
apply H.

*****
H4 : mapcanon (M2 A m2 m3)
H3 : mapcanon (M2 A m0 m1)
H2 : forall (_ : mapcanon (M2 A m0 m1)) (_ : mapcanon m3),\nmapcanon (MapMerge A (M2 A m0 m1) m3)
m3 : Map A
H1 : forall (_ : mapcanon (M2 A m0 m1)) (_ : mapcanon m2),\nmapcanon (MapMerge A (M2 A m0 m1) m2)
m',m2 : Map A
H0 : forall (m' : Map A) (_ : mapcanon m1) (_ : mapcanon m'),\nmapcanon (MapMerge A m1 m')
m1 : Map A
H : forall (m' : Map A) (_ : mapcanon m0) (_ : mapcanon m'),\nmapcanon (MapMerge A m0 m')
m,m0 : Map A
A : Type
*****
mapcanon m0
+++++
exact (mapcanon_M2_1 _ _ H3).
-----
Lemma MapMerge_canon : forall m m':Map A, mapcanon m -> mapcanon m' -> mapcanon (MapMerge A m m').
Proof.
simple induction m.
simple induction m'.
intros.
simpl in |- *.
apply M2_canon.
apply H.

*****
H4 : mapcanon (M2 A m2 m3)
H3 : mapcanon (M2 A m0 m1)
H2 : forall (_ : mapcanon (M2 A m0 m1)) (_ : mapcanon m3),\nmapcanon (MapMerge A (M2 A m0 m1) m3)
m3 : Map A
H1 : forall (_ : mapcanon (M2 A m0 m1)) (_ : mapcanon m2),\nmapcanon (MapMerge A (M2 A m0 m1) m2)
m',m2 : Map A
H0 : forall (m' : Map A) (_ : mapcanon m1) (_ : mapcanon m'),\nmapcanon (MapMerge A m1 m')
m1 : Map A
H : forall (m' : Map A) (_ : mapcanon m0) (_ : mapcanon m'),\nmapcanon (MapMerge A m0 m')
m,m0 : Map A
A : Type
*****
mapcanon m2
+++++
exact (mapcanon_M2_1 _ _ H4).
-----
Lemma MapMerge_canon : forall m m':Map A, mapcanon m -> mapcanon m' -> mapcanon (MapMerge A m m').
Proof.
simple induction m.
simple induction m'.
intros.
simpl in |- *.
apply M2_canon.

*****
H4 : mapcanon (M2 A m2 m3)
H3 : mapcanon (M2 A m0 m1)
H2 : forall (_ : mapcanon (M2 A m0 m1)) (_ : mapcanon m3),\nmapcanon (MapMerge A (M2 A m0 m1) m3)
m3 : Map A
H1 : forall (_ : mapcanon (M2 A m0 m1)) (_ : mapcanon m2),\nmapcanon (MapMerge A (M2 A m0 m1) m2)
m',m2 : Map A
H0 : forall (m' : Map A) (_ : mapcanon m1) (_ : mapcanon m'),\nmapcanon (MapMerge A m1 m')
m1 : Map A
H : forall (m' : Map A) (_ : mapcanon m0) (_ : mapcanon m'),\nmapcanon (MapMerge A m0 m')
m,m0 : Map A
A : Type
*****
mapcanon (MapMerge A m1 m3)
+++++
apply H0.
-----
Lemma MapMerge_canon : forall m m':Map A, mapcanon m -> mapcanon m' -> mapcanon (MapMerge A m m').
Proof.
simple induction m.
simple induction m'.
intros.
simpl in |- *.
apply M2_canon.
apply H0.

*****
H4 : mapcanon (M2 A m2 m3)
H3 : mapcanon (M2 A m0 m1)
H2 : forall (_ : mapcanon (M2 A m0 m1)) (_ : mapcanon m3),\nmapcanon (MapMerge A (M2 A m0 m1) m3)
m3 : Map A
H1 : forall (_ : mapcanon (M2 A m0 m1)) (_ : mapcanon m2),\nmapcanon (MapMerge A (M2 A m0 m1) m2)
m',m2 : Map A
H0 : forall (m' : Map A) (_ : mapcanon m1) (_ : mapcanon m'),\nmapcanon (MapMerge A m1 m')
m1 : Map A
H : forall (m' : Map A) (_ : mapcanon m0) (_ : mapcanon m'),\nmapcanon (MapMerge A m0 m')
m,m0 : Map A
A : Type
*****
mapcanon m1
+++++
exact (mapcanon_M2_2 _ _ H3).
-----
Lemma MapMerge_canon : forall m m':Map A, mapcanon m -> mapcanon m' -> mapcanon (MapMerge A m m').
Proof.
simple induction m.
simple induction m'.
intros.
simpl in |- *.
apply M2_canon.
apply H0.

*****
H4 : mapcanon (M2 A m2 m3)
H3 : mapcanon (M2 A m0 m1)
H2 : forall (_ : mapcanon (M2 A m0 m1)) (_ : mapcanon m3),\nmapcanon (MapMerge A (M2 A m0 m1) m3)
m3 : Map A
H1 : forall (_ : mapcanon (M2 A m0 m1)) (_ : mapcanon m2),\nmapcanon (MapMerge A (M2 A m0 m1) m2)
m',m2 : Map A
H0 : forall (m' : Map A) (_ : mapcanon m1) (_ : mapcanon m'),\nmapcanon (MapMerge A m1 m')
m1 : Map A
H : forall (m' : Map A) (_ : mapcanon m0) (_ : mapcanon m'),\nmapcanon (MapMerge A m0 m')
m,m0 : Map A
A : Type
*****
mapcanon m3
+++++
exact (mapcanon_M2_2 _ _ H4).
-----
Lemma MapMerge_canon : forall m m':Map A, mapcanon m -> mapcanon m' -> mapcanon (MapMerge A m m').
Proof.
simple induction m.
simple induction m'.
intros.
simpl in |- *.
apply M2_canon.

*****
H4 : mapcanon (M2 A m2 m3)
H3 : mapcanon (M2 A m0 m1)
H2 : forall (_ : mapcanon (M2 A m0 m1)) (_ : mapcanon m3),\nmapcanon (MapMerge A (M2 A m0 m1) m3)
m3 : Map A
H1 : forall (_ : mapcanon (M2 A m0 m1)) (_ : mapcanon m2),\nmapcanon (MapMerge A (M2 A m0 m1) m2)
m',m2 : Map A
H0 : forall (m' : Map A) (_ : mapcanon m1) (_ : mapcanon m'),\nmapcanon (MapMerge A m1 m')
m1 : Map A
H : forall (m' : Map A) (_ : mapcanon m0) (_ : mapcanon m'),\nmapcanon (MapMerge A m0 m')
m,m0 : Map A
A : Type
*****
le (S (S O)) (MapCard A (M2 A (MapMerge A m0 m2) (MapMerge A m1 m3)))
+++++
change (2 <= MapCard A (MapMerge A (M2 A m0 m1) (M2 A m2 m3))) in |- *.
-----
Lemma MapMerge_canon : forall m m':Map A, mapcanon m -> mapcanon m' -> mapcanon (MapMerge A m m').
Proof.
simple induction m.
simple induction m'.
intros.
simpl in |- *.
apply M2_canon.
change (2 <= MapCard A (MapMerge A (M2 A m0 m1) (M2 A m2 m3))) in |- *.

*****
H4 : mapcanon (M2 A m2 m3)
H3 : mapcanon (M2 A m0 m1)
H2 : forall (_ : mapcanon (M2 A m0 m1)) (_ : mapcanon m3),\nmapcanon (MapMerge A (M2 A m0 m1) m3)
m3 : Map A
H1 : forall (_ : mapcanon (M2 A m0 m1)) (_ : mapcanon m2),\nmapcanon (MapMerge A (M2 A m0 m1) m2)
m',m2 : Map A
H0 : forall (m' : Map A) (_ : mapcanon m1) (_ : mapcanon m'),\nmapcanon (MapMerge A m1 m')
m1 : Map A
H : forall (m' : Map A) (_ : mapcanon m0) (_ : mapcanon m'),\nmapcanon (MapMerge A m0 m')
m,m0 : Map A
A : Type
*****
le (S (S O)) (MapCard A (MapMerge A (M2 A m0 m1) (M2 A m2 m3)))
+++++
apply le_trans with (m := MapCard A (M2 A m0 m1)).
-----
Lemma MapMerge_canon : forall m m':Map A, mapcanon m -> mapcanon m' -> mapcanon (MapMerge A m m').
Proof.
simple induction m.
simple induction m'.
intros.
simpl in |- *.
apply M2_canon.
change (2 <= MapCard A (MapMerge A (M2 A m0 m1) (M2 A m2 m3))) in |- *.
apply le_trans with (m := MapCard A (M2 A m0 m1)).

*****
H4 : mapcanon (M2 A m2 m3)
H3 : mapcanon (M2 A m0 m1)
H2 : forall (_ : mapcanon (M2 A m0 m1)) (_ : mapcanon m3),\nmapcanon (MapMerge A (M2 A m0 m1) m3)
m3 : Map A
H1 : forall (_ : mapcanon (M2 A m0 m1)) (_ : mapcanon m2),\nmapcanon (MapMerge A (M2 A m0 m1) m2)
m',m2 : Map A
H0 : forall (m' : Map A) (_ : mapcanon m1) (_ : mapcanon m'),\nmapcanon (MapMerge A m1 m')
m1 : Map A
H : forall (m' : Map A) (_ : mapcanon m0) (_ : mapcanon m'),\nmapcanon (MapMerge A m0 m')
m,m0 : Map A
A : Type
*****
le (S (S O)) (MapCard A (M2 A m0 m1))
+++++
exact (mapcanon_M2 _ _ H3).
-----
Lemma MapMerge_canon : forall m m':Map A, mapcanon m -> mapcanon m' -> mapcanon (MapMerge A m m').
Proof.
simple induction m.
simple induction m'.
intros.
simpl in |- *.
apply M2_canon.
change (2 <= MapCard A (MapMerge A (M2 A m0 m1) (M2 A m2 m3))) in |- *.
apply le_trans with (m := MapCard A (M2 A m0 m1)).

*****
H4 : mapcanon (M2 A m2 m3)
H3 : mapcanon (M2 A m0 m1)
H2 : forall (_ : mapcanon (M2 A m0 m1)) (_ : mapcanon m3),\nmapcanon (MapMerge A (M2 A m0 m1) m3)
m3 : Map A
H1 : forall (_ : mapcanon (M2 A m0 m1)) (_ : mapcanon m2),\nmapcanon (MapMerge A (M2 A m0 m1) m2)
m',m2 : Map A
H0 : forall (m' : Map A) (_ : mapcanon m1) (_ : mapcanon m'),\nmapcanon (MapMerge A m1 m')
m1 : Map A
H : forall (m' : Map A) (_ : mapcanon m0) (_ : mapcanon m'),\nmapcanon (MapMerge A m0 m')
m,m0 : Map A
A : Type
*****
le (MapCard A (M2 A m0 m1)) (MapCard A (MapMerge A (M2 A m0 m1) (M2 A m2 m3)))
+++++
exact (MapMerge_Card_lb_l A (M2 A m0 m1) (M2 A m2 m3)).
-----
Lemma MapMerge_canon : forall m m':Map A, mapcanon m -> mapcanon m' -> mapcanon (MapMerge A m m').
Proof.
simple induction m.

*****

*****

+++++
Qed.
-----
Lemma MapDelta_canon :\n   forall m m':Map A, mapcanon m -> mapcanon m' -> mapcanon (MapDelta A m m').
-----
Lemma MapDelta_canon : forall m m':Map A, mapcanon m -> mapcanon m' -> mapcanon (MapDelta A m m').

*****
A : Type
*****
forall (m m' : Map A) (_ : mapcanon m) (_ : mapcanon m'), mapcanon (MapDelta A m m')
+++++
Proof.
-----
Lemma MapDelta_canon : forall m m':Map A, mapcanon m -> mapcanon m' -> mapcanon (MapDelta A m m').
Proof.

*****
A : Type
*****
forall (m m' : Map A) (_ : mapcanon m) (_ : mapcanon m'), mapcanon (MapDelta A m m')
+++++
simple induction m.
-----
Lemma MapDelta_canon : forall m m':Map A, mapcanon m -> mapcanon m' -> mapcanon (MapDelta A m m').
Proof.
simple induction m.

*****
m : Map A
A : Type
*****
forall (m' : Map A) (_ : mapcanon (M0 A)) (_ : mapcanon m'), mapcanon (MapDelta A (M0 A) m')
+++++
intros.
-----
Lemma MapDelta_canon : forall m m':Map A, mapcanon m -> mapcanon m' -> mapcanon (MapDelta A m m').
Proof.
simple induction m.
intros.

*****
H0 : mapcanon m'
H : mapcanon (M0 A)
m,m' : Map A
A : Type
*****
mapcanon (MapDelta A (M0 A) m')
+++++
exact H0.
-----
Lemma MapDelta_canon : forall m m':Map A, mapcanon m -> mapcanon m' -> mapcanon (MapDelta A m m').
Proof.
simple induction m.

*****
m : Map A
A : Type
*****
forall (a : ad) (a0 : A) (m' : Map A) (_ : mapcanon (M1 A a a0)) (_ : mapcanon m'), mapcanon (MapDelta A (M1 A a a0) m')
+++++
simpl in |- *.
-----
Lemma MapDelta_canon : forall m m':Map A, mapcanon m -> mapcanon m' -> mapcanon (MapDelta A m m').
Proof.
simple induction m.
simpl in |- *.

*****
m : Map A
A : Type
*****
forall (a : ad) (a0 : A) (m' : Map A) (_ : mapcanon (M1 A a a0)) (_ : mapcanon m'), mapcanon match MapGet A m' a with | Some _ => MapRemove A m' a | None => MapPut A m' a a0 end
+++++
intros a y m' H H0.
-----
Lemma MapDelta_canon : forall m m':Map A, mapcanon m -> mapcanon m' -> mapcanon (MapDelta A m m').
Proof.
simple induction m.
simpl in |- *.
intros a y m' H H0.

*****
H0 : mapcanon m'
H : mapcanon (M1 A a y)
m' : Map A
y : A
a : ad
m : Map A
A : Type
*****
mapcanon match MapGet A m' a with | Some _ => MapRemove A m' a | None => MapPut A m' a y end
+++++
case (MapGet A m' a).
-----
Lemma MapDelta_canon : forall m m':Map A, mapcanon m -> mapcanon m' -> mapcanon (MapDelta A m m').
Proof.
simple induction m.
simpl in |- *.
intros a y m' H H0.
case (MapGet A m' a).

*****
H0 : mapcanon m'
H : mapcanon (M1 A a y)
m' : Map A
y : A
a : ad
m : Map A
A : Type
*****
forall _ : A, mapcanon (MapRemove A m' a)
+++++
intro.
-----
Lemma MapDelta_canon : forall m m':Map A, mapcanon m -> mapcanon m' -> mapcanon (MapDelta A m m').
Proof.
simple induction m.
simpl in |- *.
intros a y m' H H0.
case (MapGet A m' a).
intro.

*****
a0 : A
H0 : mapcanon m'
H : mapcanon (M1 A a y)
m' : Map A
y : A
a : ad
m : Map A
A : Type
*****
mapcanon (MapRemove A m' a)
+++++
exact (MapRemove_canon m' H0 a).
-----
Lemma MapDelta_canon : forall m m':Map A, mapcanon m -> mapcanon m' -> mapcanon (MapDelta A m m').
Proof.
simple induction m.
simpl in |- *.
intros a y m' H H0.
case (MapGet A m' a).

*****
H0 : mapcanon m'
H : mapcanon (M1 A a y)
m' : Map A
y : A
a : ad
m : Map A
A : Type
*****
mapcanon (MapPut A m' a y)
+++++
exact (MapPut_canon m' H0 a y).
-----
Lemma MapDelta_canon : forall m m':Map A, mapcanon m -> mapcanon m' -> mapcanon (MapDelta A m m').
Proof.
simple induction m.

*****
m : Map A
A : Type
*****
forall (m : Map A) (_ : forall (m' : Map A) (_ : mapcanon m) (_ : mapcanon m'), mapcanon (MapDelta A m m')) (m0 : Map A) (_ : forall (m' : Map A) (_ : mapcanon m0) (_ : mapcanon m'), mapcanon (MapDelta A m0 m')) (m' : Map A) (_ : mapcanon (M2 A m m0)) (_ : mapcanon m'), mapcanon (MapDelta A (M2 A m m0) m')
+++++
simple induction m'.
-----
Lemma MapDelta_canon : forall m m':Map A, mapcanon m -> mapcanon m' -> mapcanon (MapDelta A m m').
Proof.
simple induction m.
simple induction m'.

*****
m' : Map A
H0 : forall (m' : Map A) (_ : mapcanon m1) (_ : mapcanon m'),\nmapcanon (MapDelta A m1 m')
m1 : Map A
H : forall (m' : Map A) (_ : mapcanon m0) (_ : mapcanon m'),\nmapcanon (MapDelta A m0 m')
m,m0 : Map A
A : Type
*****
forall (_ : mapcanon (M2 A m0 m1)) (_ : mapcanon (M0 A)), mapcanon (MapDelta A (M2 A m0 m1) (M0 A))
+++++
intros.
-----
Lemma MapDelta_canon : forall m m':Map A, mapcanon m -> mapcanon m' -> mapcanon (MapDelta A m m').
Proof.
simple induction m.
simple induction m'.
intros.

*****
H2 : mapcanon (M0 A)
H1 : mapcanon (M2 A m0 m1)
m' : Map A
H0 : forall (m' : Map A) (_ : mapcanon m1) (_ : mapcanon m'),\nmapcanon (MapDelta A m1 m')
m1 : Map A
H : forall (m' : Map A) (_ : mapcanon m0) (_ : mapcanon m'),\nmapcanon (MapDelta A m0 m')
m,m0 : Map A
A : Type
*****
mapcanon (MapDelta A (M2 A m0 m1) (M0 A))
+++++
exact H1.
-----
Lemma MapDelta_canon : forall m m':Map A, mapcanon m -> mapcanon m' -> mapcanon (MapDelta A m m').
Proof.
simple induction m.
simple induction m'.

*****
m' : Map A
H0 : forall (m' : Map A) (_ : mapcanon m1) (_ : mapcanon m'),\nmapcanon (MapDelta A m1 m')
m1 : Map A
H : forall (m' : Map A) (_ : mapcanon m0) (_ : mapcanon m'),\nmapcanon (MapDelta A m0 m')
m,m0 : Map A
A : Type
*****
forall (a : ad) (a0 : A) (_ : mapcanon (M2 A m0 m1)) (_ : mapcanon (M1 A a a0)), mapcanon (MapDelta A (M2 A m0 m1) (M1 A a a0))
+++++
unfold MapDelta in |- *.
-----
Lemma MapDelta_canon : forall m m':Map A, mapcanon m -> mapcanon m' -> mapcanon (MapDelta A m m').
Proof.
simple induction m.
simple induction m'.
unfold MapDelta in |- *.

*****
m' : Map A
H0 : forall (m' : Map A) (_ : mapcanon m1) (_ : mapcanon m'),\nmapcanon (MapDelta A m1 m')
m1 : Map A
H : forall (m' : Map A) (_ : mapcanon m0) (_ : mapcanon m'),\nmapcanon (MapDelta A m0 m')
m,m0 : Map A
A : Type
*****
forall (a : ad) (a0 : A) (_ : mapcanon (M2 A m0 m1)) (_ : mapcanon (M1 A a a0)), mapcanon match MapGet A (M2 A m0 m1) a with | Some _ => MapRemove A (M2 A m0 m1) a | None => MapPut A (M2 A m0 m1) a a0 end
+++++
intros a y H1 H2.
-----
Lemma MapDelta_canon : forall m m':Map A, mapcanon m -> mapcanon m' -> mapcanon (MapDelta A m m').
Proof.
simple induction m.
simple induction m'.
unfold MapDelta in |- *.
intros a y H1 H2.

*****
H2 : mapcanon (M1 A a y)
H1 : mapcanon (M2 A m0 m1)
y : A
a : ad
m' : Map A
H0 : forall (m' : Map A) (_ : mapcanon m1) (_ : mapcanon m'),\nmapcanon (MapDelta A m1 m')
m1 : Map A
H : forall (m' : Map A) (_ : mapcanon m0) (_ : mapcanon m'),\nmapcanon (MapDelta A m0 m')
m,m0 : Map A
A : Type
*****
mapcanon match MapGet A (M2 A m0 m1) a with | Some _ => MapRemove A (M2 A m0 m1) a | None => MapPut A (M2 A m0 m1) a y end
+++++
case (MapGet A (M2 A m0 m1) a).
-----
Lemma MapDelta_canon : forall m m':Map A, mapcanon m -> mapcanon m' -> mapcanon (MapDelta A m m').
Proof.
simple induction m.
simple induction m'.
unfold MapDelta in |- *.
intros a y H1 H2.
case (MapGet A (M2 A m0 m1) a).

*****
H2 : mapcanon (M1 A a y)
H1 : mapcanon (M2 A m0 m1)
y : A
a : ad
m' : Map A
H0 : forall (m' : Map A) (_ : mapcanon m1) (_ : mapcanon m'),\nmapcanon (MapDelta A m1 m')
m1 : Map A
H : forall (m' : Map A) (_ : mapcanon m0) (_ : mapcanon m'),\nmapcanon (MapDelta A m0 m')
m,m0 : Map A
A : Type
*****
forall _ : A, mapcanon (MapRemove A (M2 A m0 m1) a)
+++++
intro.
-----
Lemma MapDelta_canon : forall m m':Map A, mapcanon m -> mapcanon m' -> mapcanon (MapDelta A m m').
Proof.
simple induction m.
simple induction m'.
unfold MapDelta in |- *.
intros a y H1 H2.
case (MapGet A (M2 A m0 m1) a).
intro.

*****
a0 : A
H2 : mapcanon (M1 A a y)
H1 : mapcanon (M2 A m0 m1)
y : A
a : ad
m' : Map A
H0 : forall (m' : Map A) (_ : mapcanon m1) (_ : mapcanon m'),\nmapcanon (MapDelta A m1 m')
m1 : Map A
H : forall (m' : Map A) (_ : mapcanon m0) (_ : mapcanon m'),\nmapcanon (MapDelta A m0 m')
m,m0 : Map A
A : Type
*****
mapcanon (MapRemove A (M2 A m0 m1) a)
+++++
exact (MapRemove_canon _ H1 a).
-----
Lemma MapDelta_canon : forall m m':Map A, mapcanon m -> mapcanon m' -> mapcanon (MapDelta A m m').
Proof.
simple induction m.
simple induction m'.
unfold MapDelta in |- *.
intros a y H1 H2.
case (MapGet A (M2 A m0 m1) a).

*****
H2 : mapcanon (M1 A a y)
H1 : mapcanon (M2 A m0 m1)
y : A
a : ad
m' : Map A
H0 : forall (m' : Map A) (_ : mapcanon m1) (_ : mapcanon m'),\nmapcanon (MapDelta A m1 m')
m1 : Map A
H : forall (m' : Map A) (_ : mapcanon m0) (_ : mapcanon m'),\nmapcanon (MapDelta A m0 m')
m,m0 : Map A
A : Type
*****
mapcanon (MapPut A (M2 A m0 m1) a y)
+++++
exact (MapPut_canon _ H1 a y).
-----
Lemma MapDelta_canon : forall m m':Map A, mapcanon m -> mapcanon m' -> mapcanon (MapDelta A m m').
Proof.
simple induction m.
simple induction m'.

*****
m' : Map A
H0 : forall (m' : Map A) (_ : mapcanon m1) (_ : mapcanon m'),\nmapcanon (MapDelta A m1 m')
m1 : Map A
H : forall (m' : Map A) (_ : mapcanon m0) (_ : mapcanon m'),\nmapcanon (MapDelta A m0 m')
m,m0 : Map A
A : Type
*****
forall (m : Map A) (_ : forall (_ : mapcanon (M2 A m0 m1)) (_ : mapcanon m), mapcanon (MapDelta A (M2 A m0 m1) m)) (m2 : Map A) (_ : forall (_ : mapcanon (M2 A m0 m1)) (_ : mapcanon m2), mapcanon (MapDelta A (M2 A m0 m1) m2)) (_ : mapcanon (M2 A m0 m1)) (_ : mapcanon (M2 A m m2)), mapcanon (MapDelta A (M2 A m0 m1) (M2 A m m2))
+++++
intros.
-----
Lemma MapDelta_canon : forall m m':Map A, mapcanon m -> mapcanon m' -> mapcanon (MapDelta A m m').
Proof.
simple induction m.
simple induction m'.
intros.

*****
H4 : mapcanon (M2 A m2 m3)
H3 : mapcanon (M2 A m0 m1)
H2 : forall (_ : mapcanon (M2 A m0 m1)) (_ : mapcanon m3),\nmapcanon (MapDelta A (M2 A m0 m1) m3)
m3 : Map A
H1 : forall (_ : mapcanon (M2 A m0 m1)) (_ : mapcanon m2),\nmapcanon (MapDelta A (M2 A m0 m1) m2)
m',m2 : Map A
H0 : forall (m' : Map A) (_ : mapcanon m1) (_ : mapcanon m'),\nmapcanon (MapDelta A m1 m')
m1 : Map A
H : forall (m' : Map A) (_ : mapcanon m0) (_ : mapcanon m'),\nmapcanon (MapDelta A m0 m')
m,m0 : Map A
A : Type
*****
mapcanon (MapDelta A (M2 A m0 m1) (M2 A m2 m3))
+++++
simpl in |- *.
-----
Lemma MapDelta_canon : forall m m':Map A, mapcanon m -> mapcanon m' -> mapcanon (MapDelta A m m').
Proof.
simple induction m.
simple induction m'.
intros.
simpl in |- *.

*****
H4 : mapcanon (M2 A m2 m3)
H3 : mapcanon (M2 A m0 m1)
H2 : forall (_ : mapcanon (M2 A m0 m1)) (_ : mapcanon m3),\nmapcanon (MapDelta A (M2 A m0 m1) m3)
m3 : Map A
H1 : forall (_ : mapcanon (M2 A m0 m1)) (_ : mapcanon m2),\nmapcanon (MapDelta A (M2 A m0 m1) m2)
m',m2 : Map A
H0 : forall (m' : Map A) (_ : mapcanon m1) (_ : mapcanon m'),\nmapcanon (MapDelta A m1 m')
m1 : Map A
H : forall (m' : Map A) (_ : mapcanon m0) (_ : mapcanon m'),\nmapcanon (MapDelta A m0 m')
m,m0 : Map A
A : Type
*****
mapcanon (makeM2 A (MapDelta A m0 m2) (MapDelta A m1 m3))
+++++
apply makeM2_canon.
-----
Lemma MapDelta_canon : forall m m':Map A, mapcanon m -> mapcanon m' -> mapcanon (MapDelta A m m').
Proof.
simple induction m.
simple induction m'.
intros.
simpl in |- *.
apply makeM2_canon.

*****
H4 : mapcanon (M2 A m2 m3)
H3 : mapcanon (M2 A m0 m1)
H2 : forall (_ : mapcanon (M2 A m0 m1)) (_ : mapcanon m3),\nmapcanon (MapDelta A (M2 A m0 m1) m3)
m3 : Map A
H1 : forall (_ : mapcanon (M2 A m0 m1)) (_ : mapcanon m2),\nmapcanon (MapDelta A (M2 A m0 m1) m2)
m',m2 : Map A
H0 : forall (m' : Map A) (_ : mapcanon m1) (_ : mapcanon m'),\nmapcanon (MapDelta A m1 m')
m1 : Map A
H : forall (m' : Map A) (_ : mapcanon m0) (_ : mapcanon m'),\nmapcanon (MapDelta A m0 m')
m,m0 : Map A
A : Type
*****
mapcanon (MapDelta A m0 m2)
+++++
apply H.
-----
Lemma MapDelta_canon : forall m m':Map A, mapcanon m -> mapcanon m' -> mapcanon (MapDelta A m m').
Proof.
simple induction m.
simple induction m'.
intros.
simpl in |- *.
apply makeM2_canon.
apply H.

*****
H4 : mapcanon (M2 A m2 m3)
H3 : mapcanon (M2 A m0 m1)
H2 : forall (_ : mapcanon (M2 A m0 m1)) (_ : mapcanon m3),\nmapcanon (MapDelta A (M2 A m0 m1) m3)
m3 : Map A
H1 : forall (_ : mapcanon (M2 A m0 m1)) (_ : mapcanon m2),\nmapcanon (MapDelta A (M2 A m0 m1) m2)
m',m2 : Map A
H0 : forall (m' : Map A) (_ : mapcanon m1) (_ : mapcanon m'),\nmapcanon (MapDelta A m1 m')
m1 : Map A
H : forall (m' : Map A) (_ : mapcanon m0) (_ : mapcanon m'),\nmapcanon (MapDelta A m0 m')
m,m0 : Map A
A : Type
*****
mapcanon m0
+++++
exact (mapcanon_M2_1 _ _ H3).
-----
Lemma MapDelta_canon : forall m m':Map A, mapcanon m -> mapcanon m' -> mapcanon (MapDelta A m m').
Proof.
simple induction m.
simple induction m'.
intros.
simpl in |- *.
apply makeM2_canon.
apply H.

*****
H4 : mapcanon (M2 A m2 m3)
H3 : mapcanon (M2 A m0 m1)
H2 : forall (_ : mapcanon (M2 A m0 m1)) (_ : mapcanon m3),\nmapcanon (MapDelta A (M2 A m0 m1) m3)
m3 : Map A
H1 : forall (_ : mapcanon (M2 A m0 m1)) (_ : mapcanon m2),\nmapcanon (MapDelta A (M2 A m0 m1) m2)
m',m2 : Map A
H0 : forall (m' : Map A) (_ : mapcanon m1) (_ : mapcanon m'),\nmapcanon (MapDelta A m1 m')
m1 : Map A
H : forall (m' : Map A) (_ : mapcanon m0) (_ : mapcanon m'),\nmapcanon (MapDelta A m0 m')
m,m0 : Map A
A : Type
*****
mapcanon m2
+++++
exact (mapcanon_M2_1 _ _ H4).
-----
Lemma MapDelta_canon : forall m m':Map A, mapcanon m -> mapcanon m' -> mapcanon (MapDelta A m m').
Proof.
simple induction m.
simple induction m'.
intros.
simpl in |- *.
apply makeM2_canon.

*****
H4 : mapcanon (M2 A m2 m3)
H3 : mapcanon (M2 A m0 m1)
H2 : forall (_ : mapcanon (M2 A m0 m1)) (_ : mapcanon m3),\nmapcanon (MapDelta A (M2 A m0 m1) m3)
m3 : Map A
H1 : forall (_ : mapcanon (M2 A m0 m1)) (_ : mapcanon m2),\nmapcanon (MapDelta A (M2 A m0 m1) m2)
m',m2 : Map A
H0 : forall (m' : Map A) (_ : mapcanon m1) (_ : mapcanon m'),\nmapcanon (MapDelta A m1 m')
m1 : Map A
H : forall (m' : Map A) (_ : mapcanon m0) (_ : mapcanon m'),\nmapcanon (MapDelta A m0 m')
m,m0 : Map A
A : Type
*****
mapcanon (MapDelta A m1 m3)
+++++
apply H0.
-----
Lemma MapDelta_canon : forall m m':Map A, mapcanon m -> mapcanon m' -> mapcanon (MapDelta A m m').
Proof.
simple induction m.
simple induction m'.
intros.
simpl in |- *.
apply makeM2_canon.
apply H0.

*****
H4 : mapcanon (M2 A m2 m3)
H3 : mapcanon (M2 A m0 m1)
H2 : forall (_ : mapcanon (M2 A m0 m1)) (_ : mapcanon m3),\nmapcanon (MapDelta A (M2 A m0 m1) m3)
m3 : Map A
H1 : forall (_ : mapcanon (M2 A m0 m1)) (_ : mapcanon m2),\nmapcanon (MapDelta A (M2 A m0 m1) m2)
m',m2 : Map A
H0 : forall (m' : Map A) (_ : mapcanon m1) (_ : mapcanon m'),\nmapcanon (MapDelta A m1 m')
m1 : Map A
H : forall (m' : Map A) (_ : mapcanon m0) (_ : mapcanon m'),\nmapcanon (MapDelta A m0 m')
m,m0 : Map A
A : Type
*****
mapcanon m1
+++++
exact (mapcanon_M2_2 _ _ H3).
-----
Lemma MapDelta_canon : forall m m':Map A, mapcanon m -> mapcanon m' -> mapcanon (MapDelta A m m').
Proof.
simple induction m.
simple induction m'.
intros.
simpl in |- *.
apply makeM2_canon.
apply H0.

*****
H4 : mapcanon (M2 A m2 m3)
H3 : mapcanon (M2 A m0 m1)
H2 : forall (_ : mapcanon (M2 A m0 m1)) (_ : mapcanon m3),\nmapcanon (MapDelta A (M2 A m0 m1) m3)
m3 : Map A
H1 : forall (_ : mapcanon (M2 A m0 m1)) (_ : mapcanon m2),\nmapcanon (MapDelta A (M2 A m0 m1) m2)
m',m2 : Map A
H0 : forall (m' : Map A) (_ : mapcanon m1) (_ : mapcanon m'),\nmapcanon (MapDelta A m1 m')
m1 : Map A
H : forall (m' : Map A) (_ : mapcanon m0) (_ : mapcanon m'),\nmapcanon (MapDelta A m0 m')
m,m0 : Map A
A : Type
*****
mapcanon m3
+++++
exact (mapcanon_M2_2 _ _ H4).
-----
Lemma MapDelta_canon : forall m m':Map A, mapcanon m -> mapcanon m' -> mapcanon (MapDelta A m m').
Proof.
simple induction m.

*****

*****

+++++
Qed.
-----
Variable B : Type.
-----
Lemma MapDomRestrTo_canon :\n   forall m:Map A,\n     mapcanon m -> forall m':Map B, mapcanon (MapDomRestrTo A B m m').
-----
Lemma MapDomRestrTo_canon : forall m:Map A, mapcanon m -> forall m':Map B, mapcanon (MapDomRestrTo A B m m').

*****
B : Type
A : Type
*****
forall (m : Map A) (_ : mapcanon m) (m' : Map B), mapcanon (MapDomRestrTo A B m m')
+++++
Proof.
-----
Lemma MapDomRestrTo_canon : forall m:Map A, mapcanon m -> forall m':Map B, mapcanon (MapDomRestrTo A B m m').
Proof.

*****
B : Type
A : Type
*****
forall (m : Map A) (_ : mapcanon m) (m' : Map B), mapcanon (MapDomRestrTo A B m m')
+++++
simple induction m.
-----
Lemma MapDomRestrTo_canon : forall m:Map A, mapcanon m -> forall m':Map B, mapcanon (MapDomRestrTo A B m m').
Proof.
simple induction m.

*****
m : Map A
B : Type
A : Type
*****
forall (_ : mapcanon (M0 A)) (m' : Map B), mapcanon (MapDomRestrTo A B (M0 A) m')
+++++
intros.
-----
Lemma MapDomRestrTo_canon : forall m:Map A, mapcanon m -> forall m':Map B, mapcanon (MapDomRestrTo A B m m').
Proof.
simple induction m.
intros.

*****
m' : Map B
H : mapcanon (M0 A)
m : Map A
B : Type
A : Type
*****
mapcanon (MapDomRestrTo A B (M0 A) m')
+++++
exact M0_canon.
-----
Lemma MapDomRestrTo_canon : forall m:Map A, mapcanon m -> forall m':Map B, mapcanon (MapDomRestrTo A B m m').
Proof.
simple induction m.

*****
m : Map A
B : Type
A : Type
*****
forall (a : ad) (a0 : A) (_ : mapcanon (M1 A a a0)) (m' : Map B), mapcanon (MapDomRestrTo A B (M1 A a a0) m')
+++++
simpl in |- *.
-----
Lemma MapDomRestrTo_canon : forall m:Map A, mapcanon m -> forall m':Map B, mapcanon (MapDomRestrTo A B m m').
Proof.
simple induction m.
simpl in |- *.

*****
m : Map A
B : Type
A : Type
*****
forall (a : ad) (a0 : A) (_ : mapcanon (M1 A a a0)) (m' : Map B), mapcanon match MapGet B m' a with | Some _ => M1 A a a0 | None => M0 A end
+++++
intros a y H m'.
-----
Lemma MapDomRestrTo_canon : forall m:Map A, mapcanon m -> forall m':Map B, mapcanon (MapDomRestrTo A B m m').
Proof.
simple induction m.
simpl in |- *.
intros a y H m'.

*****
m' : Map B
H : mapcanon (M1 A a y)
y : A
a : ad
m : Map A
B : Type
A : Type
*****
mapcanon match MapGet B m' a with | Some _ => M1 A a y | None => M0 A end
+++++
case (MapGet B m' a).
-----
Lemma MapDomRestrTo_canon : forall m:Map A, mapcanon m -> forall m':Map B, mapcanon (MapDomRestrTo A B m m').
Proof.
simple induction m.
simpl in |- *.
intros a y H m'.
case (MapGet B m' a).

*****
m' : Map B
H : mapcanon (M1 A a y)
y : A
a : ad
m : Map A
B : Type
A : Type
*****
forall _ : B, mapcanon (M1 A a y)
+++++
intro.
-----
Lemma MapDomRestrTo_canon : forall m:Map A, mapcanon m -> forall m':Map B, mapcanon (MapDomRestrTo A B m m').
Proof.
simple induction m.
simpl in |- *.
intros a y H m'.
case (MapGet B m' a).
intro.

*****
b : B
m' : Map B
H : mapcanon (M1 A a y)
y : A
a : ad
m : Map A
B : Type
A : Type
*****
mapcanon (M1 A a y)
+++++
apply M1_canon.
-----
Lemma MapDomRestrTo_canon : forall m:Map A, mapcanon m -> forall m':Map B, mapcanon (MapDomRestrTo A B m m').
Proof.
simple induction m.
simpl in |- *.
intros a y H m'.
case (MapGet B m' a).

*****
m' : Map B
H : mapcanon (M1 A a y)
y : A
a : ad
m : Map A
B : Type
A : Type
*****
mapcanon (M0 A)
+++++
exact M0_canon.
-----
Lemma MapDomRestrTo_canon : forall m:Map A, mapcanon m -> forall m':Map B, mapcanon (MapDomRestrTo A B m m').
Proof.
simple induction m.

*****
m : Map A
B : Type
A : Type
*****
forall (m : Map A) (_ : forall (_ : mapcanon m) (m' : Map B), mapcanon (MapDomRestrTo A B m m')) (m0 : Map A) (_ : forall (_ : mapcanon m0) (m' : Map B), mapcanon (MapDomRestrTo A B m0 m')) (_ : mapcanon (M2 A m m0)) (m' : Map B), mapcanon (MapDomRestrTo A B (M2 A m m0) m')
+++++
simple induction m'.
-----
Lemma MapDomRestrTo_canon : forall m:Map A, mapcanon m -> forall m':Map B, mapcanon (MapDomRestrTo A B m m').
Proof.
simple induction m.
simple induction m'.

*****
m' : Map B
H1 : mapcanon (M2 A m0 m1)
H0 : forall (_ : mapcanon m1) (m' : Map B),\nmapcanon (MapDomRestrTo A B m1 m')
m1 : Map A
H : forall (_ : mapcanon m0) (m' : Map B),\nmapcanon (MapDomRestrTo A B m0 m')
m,m0 : Map A
B : Type
A : Type
*****
mapcanon (MapDomRestrTo A B (M2 A m0 m1) (M0 B))
+++++
exact M0_canon.
-----
Lemma MapDomRestrTo_canon : forall m:Map A, mapcanon m -> forall m':Map B, mapcanon (MapDomRestrTo A B m m').
Proof.
simple induction m.
simple induction m'.

*****
m' : Map B
H1 : mapcanon (M2 A m0 m1)
H0 : forall (_ : mapcanon m1) (m' : Map B),\nmapcanon (MapDomRestrTo A B m1 m')
m1 : Map A
H : forall (_ : mapcanon m0) (m' : Map B),\nmapcanon (MapDomRestrTo A B m0 m')
m,m0 : Map A
B : Type
A : Type
*****
forall (a : ad) (a0 : B), mapcanon (MapDomRestrTo A B (M2 A m0 m1) (M1 B a a0))
+++++
unfold MapDomRestrTo in |- *.
-----
Lemma MapDomRestrTo_canon : forall m:Map A, mapcanon m -> forall m':Map B, mapcanon (MapDomRestrTo A B m m').
Proof.
simple induction m.
simple induction m'.
unfold MapDomRestrTo in |- *.

*****
m' : Map B
H1 : mapcanon (M2 A m0 m1)
H0 : forall (_ : mapcanon m1) (m' : Map B),\nmapcanon (MapDomRestrTo A B m1 m')
m1 : Map A
H : forall (_ : mapcanon m0) (m' : Map B),\nmapcanon (MapDomRestrTo A B m0 m')
m,m0 : Map A
B : Type
A : Type
*****
forall (a : ad) (_ : B), mapcanon match MapGet A (M2 A m0 m1) a with | Some y => M1 A a y | None => M0 A end
+++++
intros a y.
-----
Lemma MapDomRestrTo_canon : forall m:Map A, mapcanon m -> forall m':Map B, mapcanon (MapDomRestrTo A B m m').
Proof.
simple induction m.
simple induction m'.
unfold MapDomRestrTo in |- *.
intros a y.

*****
y : B
a : ad
m' : Map B
H1 : mapcanon (M2 A m0 m1)
H0 : forall (_ : mapcanon m1) (m' : Map B),\nmapcanon (MapDomRestrTo A B m1 m')
m1 : Map A
H : forall (_ : mapcanon m0) (m' : Map B),\nmapcanon (MapDomRestrTo A B m0 m')
m,m0 : Map A
B : Type
A : Type
*****
mapcanon match MapGet A (M2 A m0 m1) a with | Some y => M1 A a y | None => M0 A end
+++++
case (MapGet A (M2 A m0 m1) a).
-----
Lemma MapDomRestrTo_canon : forall m:Map A, mapcanon m -> forall m':Map B, mapcanon (MapDomRestrTo A B m m').
Proof.
simple induction m.
simple induction m'.
unfold MapDomRestrTo in |- *.
intros a y.
case (MapGet A (M2 A m0 m1) a).

*****
y : B
a : ad
m' : Map B
H1 : mapcanon (M2 A m0 m1)
H0 : forall (_ : mapcanon m1) (m' : Map B),\nmapcanon (MapDomRestrTo A B m1 m')
m1 : Map A
H : forall (_ : mapcanon m0) (m' : Map B),\nmapcanon (MapDomRestrTo A B m0 m')
m,m0 : Map A
B : Type
A : Type
*****
forall a0 : A, mapcanon (M1 A a a0)
+++++
intro.
-----
Lemma MapDomRestrTo_canon : forall m:Map A, mapcanon m -> forall m':Map B, mapcanon (MapDomRestrTo A B m m').
Proof.
simple induction m.
simple induction m'.
unfold MapDomRestrTo in |- *.
intros a y.
case (MapGet A (M2 A m0 m1) a).
intro.

*****
a0 : A
y : B
a : ad
m' : Map B
H1 : mapcanon (M2 A m0 m1)
H0 : forall (_ : mapcanon m1) (m' : Map B),\nmapcanon (MapDomRestrTo A B m1 m')
m1 : Map A
H : forall (_ : mapcanon m0) (m' : Map B),\nmapcanon (MapDomRestrTo A B m0 m')
m,m0 : Map A
B : Type
A : Type
*****
mapcanon (M1 A a a0)
+++++
apply M1_canon.
-----
Lemma MapDomRestrTo_canon : forall m:Map A, mapcanon m -> forall m':Map B, mapcanon (MapDomRestrTo A B m m').
Proof.
simple induction m.
simple induction m'.
unfold MapDomRestrTo in |- *.
intros a y.
case (MapGet A (M2 A m0 m1) a).

*****
y : B
a : ad
m' : Map B
H1 : mapcanon (M2 A m0 m1)
H0 : forall (_ : mapcanon m1) (m' : Map B),\nmapcanon (MapDomRestrTo A B m1 m')
m1 : Map A
H : forall (_ : mapcanon m0) (m' : Map B),\nmapcanon (MapDomRestrTo A B m0 m')
m,m0 : Map A
B : Type
A : Type
*****
mapcanon (M0 A)
+++++
exact M0_canon.
-----
Lemma MapDomRestrTo_canon : forall m:Map A, mapcanon m -> forall m':Map B, mapcanon (MapDomRestrTo A B m m').
Proof.
simple induction m.
simple induction m'.

*****
m' : Map B
H1 : mapcanon (M2 A m0 m1)
H0 : forall (_ : mapcanon m1) (m' : Map B),\nmapcanon (MapDomRestrTo A B m1 m')
m1 : Map A
H : forall (_ : mapcanon m0) (m' : Map B),\nmapcanon (MapDomRestrTo A B m0 m')
m,m0 : Map A
B : Type
A : Type
*****
forall (m : Map B) (_ : mapcanon (MapDomRestrTo A B (M2 A m0 m1) m)) (m2 : Map B) (_ : mapcanon (MapDomRestrTo A B (M2 A m0 m1) m2)), mapcanon (MapDomRestrTo A B (M2 A m0 m1) (M2 B m m2))
+++++
intros.
-----
Lemma MapDomRestrTo_canon : forall m:Map A, mapcanon m -> forall m':Map B, mapcanon (MapDomRestrTo A B m m').
Proof.
simple induction m.
simple induction m'.
intros.

*****
H3 : mapcanon (MapDomRestrTo A B (M2 A m0 m1) m3)
m3 : Map B
H2 : mapcanon (MapDomRestrTo A B (M2 A m0 m1) m2)
m',m2 : Map B
H1 : mapcanon (M2 A m0 m1)
H0 : forall (_ : mapcanon m1) (m' : Map B),\nmapcanon (MapDomRestrTo A B m1 m')
m1 : Map A
H : forall (_ : mapcanon m0) (m' : Map B),\nmapcanon (MapDomRestrTo A B m0 m')
m,m0 : Map A
B : Type
A : Type
*****
mapcanon (MapDomRestrTo A B (M2 A m0 m1) (M2 B m2 m3))
+++++
simpl in |- *.
-----
Lemma MapDomRestrTo_canon : forall m:Map A, mapcanon m -> forall m':Map B, mapcanon (MapDomRestrTo A B m m').
Proof.
simple induction m.
simple induction m'.
intros.
simpl in |- *.

*****
H3 : mapcanon (MapDomRestrTo A B (M2 A m0 m1) m3)
m3 : Map B
H2 : mapcanon (MapDomRestrTo A B (M2 A m0 m1) m2)
m',m2 : Map B
H1 : mapcanon (M2 A m0 m1)
H0 : forall (_ : mapcanon m1) (m' : Map B),\nmapcanon (MapDomRestrTo A B m1 m')
m1 : Map A
H : forall (_ : mapcanon m0) (m' : Map B),\nmapcanon (MapDomRestrTo A B m0 m')
m,m0 : Map A
B : Type
A : Type
*****
mapcanon (makeM2 A (MapDomRestrTo A B m0 m2) (MapDomRestrTo A B m1 m3))
+++++
apply makeM2_canon.
-----
Lemma MapDomRestrTo_canon : forall m:Map A, mapcanon m -> forall m':Map B, mapcanon (MapDomRestrTo A B m m').
Proof.
simple induction m.
simple induction m'.
intros.
simpl in |- *.
apply makeM2_canon.

*****
H3 : mapcanon (MapDomRestrTo A B (M2 A m0 m1) m3)
m3 : Map B
H2 : mapcanon (MapDomRestrTo A B (M2 A m0 m1) m2)
m',m2 : Map B
H1 : mapcanon (M2 A m0 m1)
H0 : forall (_ : mapcanon m1) (m' : Map B),\nmapcanon (MapDomRestrTo A B m1 m')
m1 : Map A
H : forall (_ : mapcanon m0) (m' : Map B),\nmapcanon (MapDomRestrTo A B m0 m')
m,m0 : Map A
B : Type
A : Type
*****
mapcanon (MapDomRestrTo A B m0 m2)
+++++
apply H.
-----
Lemma MapDomRestrTo_canon : forall m:Map A, mapcanon m -> forall m':Map B, mapcanon (MapDomRestrTo A B m m').
Proof.
simple induction m.
simple induction m'.
intros.
simpl in |- *.
apply makeM2_canon.
apply H.

*****
H3 : mapcanon (MapDomRestrTo A B (M2 A m0 m1) m3)
m3 : Map B
H2 : mapcanon (MapDomRestrTo A B (M2 A m0 m1) m2)
m',m2 : Map B
H1 : mapcanon (M2 A m0 m1)
H0 : forall (_ : mapcanon m1) (m' : Map B),\nmapcanon (MapDomRestrTo A B m1 m')
m1 : Map A
H : forall (_ : mapcanon m0) (m' : Map B),\nmapcanon (MapDomRestrTo A B m0 m')
m,m0 : Map A
B : Type
A : Type
*****
mapcanon m0
+++++
exact (mapcanon_M2_1 m0 m1 H1).
-----
Lemma MapDomRestrTo_canon : forall m:Map A, mapcanon m -> forall m':Map B, mapcanon (MapDomRestrTo A B m m').
Proof.
simple induction m.
simple induction m'.
intros.
simpl in |- *.
apply makeM2_canon.

*****
H3 : mapcanon (MapDomRestrTo A B (M2 A m0 m1) m3)
m3 : Map B
H2 : mapcanon (MapDomRestrTo A B (M2 A m0 m1) m2)
m',m2 : Map B
H1 : mapcanon (M2 A m0 m1)
H0 : forall (_ : mapcanon m1) (m' : Map B),\nmapcanon (MapDomRestrTo A B m1 m')
m1 : Map A
H : forall (_ : mapcanon m0) (m' : Map B),\nmapcanon (MapDomRestrTo A B m0 m')
m,m0 : Map A
B : Type
A : Type
*****
mapcanon (MapDomRestrTo A B m1 m3)
+++++
apply H0.
-----
Lemma MapDomRestrTo_canon : forall m:Map A, mapcanon m -> forall m':Map B, mapcanon (MapDomRestrTo A B m m').
Proof.
simple induction m.
simple induction m'.
intros.
simpl in |- *.
apply makeM2_canon.
apply H0.

*****
H3 : mapcanon (MapDomRestrTo A B (M2 A m0 m1) m3)
m3 : Map B
H2 : mapcanon (MapDomRestrTo A B (M2 A m0 m1) m2)
m',m2 : Map B
H1 : mapcanon (M2 A m0 m1)
H0 : forall (_ : mapcanon m1) (m' : Map B),\nmapcanon (MapDomRestrTo A B m1 m')
m1 : Map A
H : forall (_ : mapcanon m0) (m' : Map B),\nmapcanon (MapDomRestrTo A B m0 m')
m,m0 : Map A
B : Type
A : Type
*****
mapcanon m1
+++++
exact (mapcanon_M2_2 m0 m1 H1).
-----
Lemma MapDomRestrTo_canon : forall m:Map A, mapcanon m -> forall m':Map B, mapcanon (MapDomRestrTo A B m m').
Proof.
simple induction m.

*****

*****

+++++
Qed.
-----
Lemma MapDomRestrBy_canon :\n   forall m:Map A,\n     mapcanon m -> forall m':Map B, mapcanon (MapDomRestrBy A B m m').
-----
Lemma MapDomRestrBy_canon : forall m:Map A, mapcanon m -> forall m':Map B, mapcanon (MapDomRestrBy A B m m').

*****
B : Type
A : Type
*****
forall (m : Map A) (_ : mapcanon m) (m' : Map B), mapcanon (MapDomRestrBy A B m m')
+++++
Proof.
-----
Lemma MapDomRestrBy_canon : forall m:Map A, mapcanon m -> forall m':Map B, mapcanon (MapDomRestrBy A B m m').
Proof.

*****
B : Type
A : Type
*****
forall (m : Map A) (_ : mapcanon m) (m' : Map B), mapcanon (MapDomRestrBy A B m m')
+++++
simple induction m.
-----
Lemma MapDomRestrBy_canon : forall m:Map A, mapcanon m -> forall m':Map B, mapcanon (MapDomRestrBy A B m m').
Proof.
simple induction m.

*****
m : Map A
B : Type
A : Type
*****
forall (_ : mapcanon (M0 A)) (m' : Map B), mapcanon (MapDomRestrBy A B (M0 A) m')
+++++
intros.
-----
Lemma MapDomRestrBy_canon : forall m:Map A, mapcanon m -> forall m':Map B, mapcanon (MapDomRestrBy A B m m').
Proof.
simple induction m.
intros.

*****
m' : Map B
H : mapcanon (M0 A)
m : Map A
B : Type
A : Type
*****
mapcanon (MapDomRestrBy A B (M0 A) m')
+++++
exact M0_canon.
-----
Lemma MapDomRestrBy_canon : forall m:Map A, mapcanon m -> forall m':Map B, mapcanon (MapDomRestrBy A B m m').
Proof.
simple induction m.

*****
m : Map A
B : Type
A : Type
*****
forall (a : ad) (a0 : A) (_ : mapcanon (M1 A a a0)) (m' : Map B), mapcanon (MapDomRestrBy A B (M1 A a a0) m')
+++++
simpl in |- *.
-----
Lemma MapDomRestrBy_canon : forall m:Map A, mapcanon m -> forall m':Map B, mapcanon (MapDomRestrBy A B m m').
Proof.
simple induction m.
simpl in |- *.

*****
m : Map A
B : Type
A : Type
*****
forall (a : ad) (a0 : A) (_ : mapcanon (M1 A a a0)) (m' : Map B), mapcanon match MapGet B m' a with | Some _ => M0 A | None => M1 A a a0 end
+++++
intros a y H m'.
-----
Lemma MapDomRestrBy_canon : forall m:Map A, mapcanon m -> forall m':Map B, mapcanon (MapDomRestrBy A B m m').
Proof.
simple induction m.
simpl in |- *.
intros a y H m'.

*****
m' : Map B
H : mapcanon (M1 A a y)
y : A
a : ad
m : Map A
B : Type
A : Type
*****
mapcanon match MapGet B m' a with | Some _ => M0 A | None => M1 A a y end
+++++
case (MapGet B m' a).
-----
Lemma MapDomRestrBy_canon : forall m:Map A, mapcanon m -> forall m':Map B, mapcanon (MapDomRestrBy A B m m').
Proof.
simple induction m.
simpl in |- *.
intros a y H m'.
case (MapGet B m' a).

*****
m' : Map B
H : mapcanon (M1 A a y)
y : A
a : ad
m : Map A
B : Type
A : Type
*****
forall _ : B, mapcanon (M0 A)
+++++
try assumption.
-----
Lemma MapDomRestrBy_canon : forall m:Map A, mapcanon m -> forall m':Map B, mapcanon (MapDomRestrBy A B m m').
Proof.
simple induction m.
simpl in |- *.
intros a y H m'.
case (MapGet B m' a).
try assumption.

*****
m' : Map B
H : mapcanon (M1 A a y)
y : A
a : ad
m : Map A
B : Type
A : Type
*****
forall _ : B, mapcanon (M0 A)
+++++
intro.
-----
Lemma MapDomRestrBy_canon : forall m:Map A, mapcanon m -> forall m':Map B, mapcanon (MapDomRestrBy A B m m').
Proof.
simple induction m.
simpl in |- *.
intros a y H m'.
case (MapGet B m' a).
try assumption.
intro.

*****
b : B
m' : Map B
H : mapcanon (M1 A a y)
y : A
a : ad
m : Map A
B : Type
A : Type
*****
mapcanon (M0 A)
+++++
exact M0_canon.
-----
Lemma MapDomRestrBy_canon : forall m:Map A, mapcanon m -> forall m':Map B, mapcanon (MapDomRestrBy A B m m').
Proof.
simple induction m.
simpl in |- *.
intros a y H m'.
case (MapGet B m' a).

*****
m' : Map B
H : mapcanon (M1 A a y)
y : A
a : ad
m : Map A
B : Type
A : Type
*****
mapcanon (M1 A a y)
+++++
try assumption.
-----
Lemma MapDomRestrBy_canon : forall m:Map A, mapcanon m -> forall m':Map B, mapcanon (MapDomRestrBy A B m m').
Proof.
simple induction m.

*****
m : Map A
B : Type
A : Type
*****
forall (m : Map A) (_ : forall (_ : mapcanon m) (m' : Map B), mapcanon (MapDomRestrBy A B m m')) (m0 : Map A) (_ : forall (_ : mapcanon m0) (m' : Map B), mapcanon (MapDomRestrBy A B m0 m')) (_ : mapcanon (M2 A m m0)) (m' : Map B), mapcanon (MapDomRestrBy A B (M2 A m m0) m')
+++++
simple induction m'.
-----
Lemma MapDomRestrBy_canon : forall m:Map A, mapcanon m -> forall m':Map B, mapcanon (MapDomRestrBy A B m m').
Proof.
simple induction m.
simple induction m'.

*****
m' : Map B
H1 : mapcanon (M2 A m0 m1)
H0 : forall (_ : mapcanon m1) (m' : Map B),\nmapcanon (MapDomRestrBy A B m1 m')
m1 : Map A
H : forall (_ : mapcanon m0) (m' : Map B),\nmapcanon (MapDomRestrBy A B m0 m')
m,m0 : Map A
B : Type
A : Type
*****
mapcanon (MapDomRestrBy A B (M2 A m0 m1) (M0 B))
+++++
exact H1.
-----
Lemma MapDomRestrBy_canon : forall m:Map A, mapcanon m -> forall m':Map B, mapcanon (MapDomRestrBy A B m m').
Proof.
simple induction m.
simple induction m'.

*****
m' : Map B
H1 : mapcanon (M2 A m0 m1)
H0 : forall (_ : mapcanon m1) (m' : Map B),\nmapcanon (MapDomRestrBy A B m1 m')
m1 : Map A
H : forall (_ : mapcanon m0) (m' : Map B),\nmapcanon (MapDomRestrBy A B m0 m')
m,m0 : Map A
B : Type
A : Type
*****
forall (a : ad) (a0 : B), mapcanon (MapDomRestrBy A B (M2 A m0 m1) (M1 B a a0))
+++++
intros a y.
-----
Lemma MapDomRestrBy_canon : forall m:Map A, mapcanon m -> forall m':Map B, mapcanon (MapDomRestrBy A B m m').
Proof.
simple induction m.
simple induction m'.
intros a y.

*****
y : B
a : ad
m' : Map B
H1 : mapcanon (M2 A m0 m1)
H0 : forall (_ : mapcanon m1) (m' : Map B),\nmapcanon (MapDomRestrBy A B m1 m')
m1 : Map A
H : forall (_ : mapcanon m0) (m' : Map B),\nmapcanon (MapDomRestrBy A B m0 m')
m,m0 : Map A
B : Type
A : Type
*****
mapcanon (MapDomRestrBy A B (M2 A m0 m1) (M1 B a y))
+++++
simpl in |- *.
-----
Lemma MapDomRestrBy_canon : forall m:Map A, mapcanon m -> forall m':Map B, mapcanon (MapDomRestrBy A B m m').
Proof.
simple induction m.
simple induction m'.
intros a y.
simpl in |- *.

*****
y : B
a : ad
m' : Map B
H1 : mapcanon (M2 A m0 m1)
H0 : forall (_ : mapcanon m1) (m' : Map B),\nmapcanon (MapDomRestrBy A B m1 m')
m1 : Map A
H : forall (_ : mapcanon m0) (m' : Map B),\nmapcanon (MapDomRestrBy A B m0 m')
m,m0 : Map A
B : Type
A : Type
*****
mapcanon (if N.odd a then makeM2 A m0 (MapRemove A m1 (N.div2 a)) else makeM2 A (MapRemove A m0 (N.div2 a)) m1)
+++++
case (Nbit0 a).
-----
Lemma MapDomRestrBy_canon : forall m:Map A, mapcanon m -> forall m':Map B, mapcanon (MapDomRestrBy A B m m').
Proof.
simple induction m.
simple induction m'.
intros a y.
simpl in |- *.
case (Nbit0 a).

*****
y : B
a : ad
m' : Map B
H1 : mapcanon (M2 A m0 m1)
H0 : forall (_ : mapcanon m1) (m' : Map B),\nmapcanon (MapDomRestrBy A B m1 m')
m1 : Map A
H : forall (_ : mapcanon m0) (m' : Map B),\nmapcanon (MapDomRestrBy A B m0 m')
m,m0 : Map A
B : Type
A : Type
*****
mapcanon (makeM2 A m0 (MapRemove A m1 (N.div2 a)))
+++++
apply makeM2_canon.
-----
Lemma MapDomRestrBy_canon : forall m:Map A, mapcanon m -> forall m':Map B, mapcanon (MapDomRestrBy A B m m').
Proof.
simple induction m.
simple induction m'.
intros a y.
simpl in |- *.
case (Nbit0 a).
apply makeM2_canon.

*****
y : B
a : ad
m' : Map B
H1 : mapcanon (M2 A m0 m1)
H0 : forall (_ : mapcanon m1) (m' : Map B),\nmapcanon (MapDomRestrBy A B m1 m')
m1 : Map A
H : forall (_ : mapcanon m0) (m' : Map B),\nmapcanon (MapDomRestrBy A B m0 m')
m,m0 : Map A
B : Type
A : Type
*****
mapcanon m0
+++++
exact (mapcanon_M2_1 _ _ H1).
-----
Lemma MapDomRestrBy_canon : forall m:Map A, mapcanon m -> forall m':Map B, mapcanon (MapDomRestrBy A B m m').
Proof.
simple induction m.
simple induction m'.
intros a y.
simpl in |- *.
case (Nbit0 a).
apply makeM2_canon.

*****
y : B
a : ad
m' : Map B
H1 : mapcanon (M2 A m0 m1)
H0 : forall (_ : mapcanon m1) (m' : Map B),\nmapcanon (MapDomRestrBy A B m1 m')
m1 : Map A
H : forall (_ : mapcanon m0) (m' : Map B),\nmapcanon (MapDomRestrBy A B m0 m')
m,m0 : Map A
B : Type
A : Type
*****
mapcanon (MapRemove A m1 (N.div2 a))
+++++
apply MapRemove_canon.
-----
Lemma MapDomRestrBy_canon : forall m:Map A, mapcanon m -> forall m':Map B, mapcanon (MapDomRestrBy A B m m').
Proof.
simple induction m.
simple induction m'.
intros a y.
simpl in |- *.
case (Nbit0 a).
apply makeM2_canon.
apply MapRemove_canon.

*****
y : B
a : ad
m' : Map B
H1 : mapcanon (M2 A m0 m1)
H0 : forall (_ : mapcanon m1) (m' : Map B),\nmapcanon (MapDomRestrBy A B m1 m')
m1 : Map A
H : forall (_ : mapcanon m0) (m' : Map B),\nmapcanon (MapDomRestrBy A B m0 m')
m,m0 : Map A
B : Type
A : Type
*****
mapcanon m1
+++++
exact (mapcanon_M2_2 _ _ H1).
-----
Lemma MapDomRestrBy_canon : forall m:Map A, mapcanon m -> forall m':Map B, mapcanon (MapDomRestrBy A B m m').
Proof.
simple induction m.
simple induction m'.
intros a y.
simpl in |- *.
case (Nbit0 a).

*****
y : B
a : ad
m' : Map B
H1 : mapcanon (M2 A m0 m1)
H0 : forall (_ : mapcanon m1) (m' : Map B),\nmapcanon (MapDomRestrBy A B m1 m')
m1 : Map A
H : forall (_ : mapcanon m0) (m' : Map B),\nmapcanon (MapDomRestrBy A B m0 m')
m,m0 : Map A
B : Type
A : Type
*****
mapcanon (makeM2 A (MapRemove A m0 (N.div2 a)) m1)
+++++
apply makeM2_canon.
-----
Lemma MapDomRestrBy_canon : forall m:Map A, mapcanon m -> forall m':Map B, mapcanon (MapDomRestrBy A B m m').
Proof.
simple induction m.
simple induction m'.
intros a y.
simpl in |- *.
case (Nbit0 a).
apply makeM2_canon.

*****
y : B
a : ad
m' : Map B
H1 : mapcanon (M2 A m0 m1)
H0 : forall (_ : mapcanon m1) (m' : Map B),\nmapcanon (MapDomRestrBy A B m1 m')
m1 : Map A
H : forall (_ : mapcanon m0) (m' : Map B),\nmapcanon (MapDomRestrBy A B m0 m')
m,m0 : Map A
B : Type
A : Type
*****
mapcanon (MapRemove A m0 (N.div2 a))
+++++
apply MapRemove_canon.
-----
Lemma MapDomRestrBy_canon : forall m:Map A, mapcanon m -> forall m':Map B, mapcanon (MapDomRestrBy A B m m').
Proof.
simple induction m.
simple induction m'.
intros a y.
simpl in |- *.
case (Nbit0 a).
apply makeM2_canon.
apply MapRemove_canon.

*****
y : B
a : ad
m' : Map B
H1 : mapcanon (M2 A m0 m1)
H0 : forall (_ : mapcanon m1) (m' : Map B),\nmapcanon (MapDomRestrBy A B m1 m')
m1 : Map A
H : forall (_ : mapcanon m0) (m' : Map B),\nmapcanon (MapDomRestrBy A B m0 m')
m,m0 : Map A
B : Type
A : Type
*****
mapcanon m0
+++++
exact (mapcanon_M2_1 _ _ H1).
-----
Lemma MapDomRestrBy_canon : forall m:Map A, mapcanon m -> forall m':Map B, mapcanon (MapDomRestrBy A B m m').
Proof.
simple induction m.
simple induction m'.
intros a y.
simpl in |- *.
case (Nbit0 a).
apply makeM2_canon.

*****
y : B
a : ad
m' : Map B
H1 : mapcanon (M2 A m0 m1)
H0 : forall (_ : mapcanon m1) (m' : Map B),\nmapcanon (MapDomRestrBy A B m1 m')
m1 : Map A
H : forall (_ : mapcanon m0) (m' : Map B),\nmapcanon (MapDomRestrBy A B m0 m')
m,m0 : Map A
B : Type
A : Type
*****
mapcanon m1
+++++
exact (mapcanon_M2_2 _ _ H1).
-----
Lemma MapDomRestrBy_canon : forall m:Map A, mapcanon m -> forall m':Map B, mapcanon (MapDomRestrBy A B m m').
Proof.
simple induction m.
simple induction m'.

*****
m' : Map B
H1 : mapcanon (M2 A m0 m1)
H0 : forall (_ : mapcanon m1) (m' : Map B),\nmapcanon (MapDomRestrBy A B m1 m')
m1 : Map A
H : forall (_ : mapcanon m0) (m' : Map B),\nmapcanon (MapDomRestrBy A B m0 m')
m,m0 : Map A
B : Type
A : Type
*****
forall (m : Map B) (_ : mapcanon (MapDomRestrBy A B (M2 A m0 m1) m)) (m2 : Map B) (_ : mapcanon (MapDomRestrBy A B (M2 A m0 m1) m2)), mapcanon (MapDomRestrBy A B (M2 A m0 m1) (M2 B m m2))
+++++
intros.
-----
Lemma MapDomRestrBy_canon : forall m:Map A, mapcanon m -> forall m':Map B, mapcanon (MapDomRestrBy A B m m').
Proof.
simple induction m.
simple induction m'.
intros.

*****
H3 : mapcanon (MapDomRestrBy A B (M2 A m0 m1) m3)
m3 : Map B
H2 : mapcanon (MapDomRestrBy A B (M2 A m0 m1) m2)
m',m2 : Map B
H1 : mapcanon (M2 A m0 m1)
H0 : forall (_ : mapcanon m1) (m' : Map B),\nmapcanon (MapDomRestrBy A B m1 m')
m1 : Map A
H : forall (_ : mapcanon m0) (m' : Map B),\nmapcanon (MapDomRestrBy A B m0 m')
m,m0 : Map A
B : Type
A : Type
*****
mapcanon (MapDomRestrBy A B (M2 A m0 m1) (M2 B m2 m3))
+++++
simpl in |- *.
-----
Lemma MapDomRestrBy_canon : forall m:Map A, mapcanon m -> forall m':Map B, mapcanon (MapDomRestrBy A B m m').
Proof.
simple induction m.
simple induction m'.
intros.
simpl in |- *.

*****
H3 : mapcanon (MapDomRestrBy A B (M2 A m0 m1) m3)
m3 : Map B
H2 : mapcanon (MapDomRestrBy A B (M2 A m0 m1) m2)
m',m2 : Map B
H1 : mapcanon (M2 A m0 m1)
H0 : forall (_ : mapcanon m1) (m' : Map B),\nmapcanon (MapDomRestrBy A B m1 m')
m1 : Map A
H : forall (_ : mapcanon m0) (m' : Map B),\nmapcanon (MapDomRestrBy A B m0 m')
m,m0 : Map A
B : Type
A : Type
*****
mapcanon (makeM2 A (MapDomRestrBy A B m0 m2) (MapDomRestrBy A B m1 m3))
+++++
apply makeM2_canon.
-----
Lemma MapDomRestrBy_canon : forall m:Map A, mapcanon m -> forall m':Map B, mapcanon (MapDomRestrBy A B m m').
Proof.
simple induction m.
simple induction m'.
intros.
simpl in |- *.
apply makeM2_canon.

*****
H3 : mapcanon (MapDomRestrBy A B (M2 A m0 m1) m3)
m3 : Map B
H2 : mapcanon (MapDomRestrBy A B (M2 A m0 m1) m2)
m',m2 : Map B
H1 : mapcanon (M2 A m0 m1)
H0 : forall (_ : mapcanon m1) (m' : Map B),\nmapcanon (MapDomRestrBy A B m1 m')
m1 : Map A
H : forall (_ : mapcanon m0) (m' : Map B),\nmapcanon (MapDomRestrBy A B m0 m')
m,m0 : Map A
B : Type
A : Type
*****
mapcanon (MapDomRestrBy A B m0 m2)
+++++
apply H.
-----
Lemma MapDomRestrBy_canon : forall m:Map A, mapcanon m -> forall m':Map B, mapcanon (MapDomRestrBy A B m m').
Proof.
simple induction m.
simple induction m'.
intros.
simpl in |- *.
apply makeM2_canon.
apply H.

*****
H3 : mapcanon (MapDomRestrBy A B (M2 A m0 m1) m3)
m3 : Map B
H2 : mapcanon (MapDomRestrBy A B (M2 A m0 m1) m2)
m',m2 : Map B
H1 : mapcanon (M2 A m0 m1)
H0 : forall (_ : mapcanon m1) (m' : Map B),\nmapcanon (MapDomRestrBy A B m1 m')
m1 : Map A
H : forall (_ : mapcanon m0) (m' : Map B),\nmapcanon (MapDomRestrBy A B m0 m')
m,m0 : Map A
B : Type
A : Type
*****
mapcanon m0
+++++
exact (mapcanon_M2_1 _ _ H1).
-----
Lemma MapDomRestrBy_canon : forall m:Map A, mapcanon m -> forall m':Map B, mapcanon (MapDomRestrBy A B m m').
Proof.
simple induction m.
simple induction m'.
intros.
simpl in |- *.
apply makeM2_canon.

*****
H3 : mapcanon (MapDomRestrBy A B (M2 A m0 m1) m3)
m3 : Map B
H2 : mapcanon (MapDomRestrBy A B (M2 A m0 m1) m2)
m',m2 : Map B
H1 : mapcanon (M2 A m0 m1)
H0 : forall (_ : mapcanon m1) (m' : Map B),\nmapcanon (MapDomRestrBy A B m1 m')
m1 : Map A
H : forall (_ : mapcanon m0) (m' : Map B),\nmapcanon (MapDomRestrBy A B m0 m')
m,m0 : Map A
B : Type
A : Type
*****
mapcanon (MapDomRestrBy A B m1 m3)
+++++
apply H0.
-----
Lemma MapDomRestrBy_canon : forall m:Map A, mapcanon m -> forall m':Map B, mapcanon (MapDomRestrBy A B m m').
Proof.
simple induction m.
simple induction m'.
intros.
simpl in |- *.
apply makeM2_canon.
apply H0.

*****
H3 : mapcanon (MapDomRestrBy A B (M2 A m0 m1) m3)
m3 : Map B
H2 : mapcanon (MapDomRestrBy A B (M2 A m0 m1) m2)
m',m2 : Map B
H1 : mapcanon (M2 A m0 m1)
H0 : forall (_ : mapcanon m1) (m' : Map B),\nmapcanon (MapDomRestrBy A B m1 m')
m1 : Map A
H : forall (_ : mapcanon m0) (m' : Map B),\nmapcanon (MapDomRestrBy A B m0 m')
m,m0 : Map A
B : Type
A : Type
*****
mapcanon m1
+++++
exact (mapcanon_M2_2 _ _ H1).
-----
Lemma MapDomRestrBy_canon : forall m:Map A, mapcanon m -> forall m':Map B, mapcanon (MapDomRestrBy A B m m').
Proof.
simple induction m.

*****

*****

+++++
Qed.
-----
Lemma Map_of_alist_canon : forall l:alist A, mapcanon (Map_of_alist A l).
-----
Lemma Map_of_alist_canon : forall l:alist A, mapcanon (Map_of_alist A l).

*****
B : Type
A : Type
*****
forall l : alist A, mapcanon (Map_of_alist A l)
+++++
Proof.
-----
Lemma Map_of_alist_canon : forall l:alist A, mapcanon (Map_of_alist A l).
Proof.

*****
B : Type
A : Type
*****
forall l : alist A, mapcanon (Map_of_alist A l)
+++++
simple induction l.
-----
Lemma Map_of_alist_canon : forall l:alist A, mapcanon (Map_of_alist A l).
Proof.
simple induction l.

*****
l : alist A
B : Type
A : Type
*****
mapcanon (Map_of_alist A nil)
+++++
exact M0_canon.
-----
Lemma Map_of_alist_canon : forall l:alist A, mapcanon (Map_of_alist A l).
Proof.
simple induction l.

*****
l : alist A
B : Type
A : Type
*****
forall (a : prod ad A) (l : list (prod ad A)) (_ : mapcanon (Map_of_alist A l)), mapcanon (Map_of_alist A (cons a l))
+++++
intro r.
-----
Lemma Map_of_alist_canon : forall l:alist A, mapcanon (Map_of_alist A l).
Proof.
simple induction l.
intro r.

*****
r : prod ad A
l : alist A
B : Type
A : Type
*****
forall (l : list (prod ad A)) (_ : mapcanon (Map_of_alist A l)), mapcanon (Map_of_alist A (cons r l))
+++++
elim r.
-----
Lemma Map_of_alist_canon : forall l:alist A, mapcanon (Map_of_alist A l).
Proof.
simple induction l.
intro r.
elim r.

*****
r : prod ad A
l : alist A
B : Type
A : Type
*****
forall (a : ad) (b : A) (l : list (prod ad A)) (_ : mapcanon (Map_of_alist A l)), mapcanon (Map_of_alist A (cons (pair a b) l))
+++++
intros a y l0 H.
-----
Lemma Map_of_alist_canon : forall l:alist A, mapcanon (Map_of_alist A l).
Proof.
simple induction l.
intro r.
elim r.
intros a y l0 H.

*****
H : mapcanon (Map_of_alist A l0)
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
B : Type
A : Type
*****
mapcanon (Map_of_alist A (cons (pair a y) l0))
+++++
simpl in |- *.
-----
Lemma Map_of_alist_canon : forall l:alist A, mapcanon (Map_of_alist A l).
Proof.
simple induction l.
intro r.
elim r.
intros a y l0 H.
simpl in |- *.

*****
H : mapcanon (Map_of_alist A l0)
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
B : Type
A : Type
*****
mapcanon (MapPut A (Map_of_alist A l0) a y)
+++++
apply MapPut_canon.
-----
Lemma Map_of_alist_canon : forall l:alist A, mapcanon (Map_of_alist A l).
Proof.
simple induction l.
intro r.
elim r.
intros a y l0 H.
simpl in |- *.
apply MapPut_canon.

*****
H : mapcanon (Map_of_alist A l0)
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
B : Type
A : Type
*****
mapcanon (Map_of_alist A l0)
+++++
assumption.
-----
Lemma Map_of_alist_canon : forall l:alist A, mapcanon (Map_of_alist A l).
Proof.
simple induction l.

*****

*****

+++++
Qed.
-----
Lemma MapSubset_c_1 :\n   forall (m:Map A) (m':Map B),\n     mapcanon m -> MapSubset A B m m' -> MapDomRestrBy A B m m' = M0 A.
-----
Lemma MapSubset_c_1 : forall (m:Map A) (m':Map B), mapcanon m -> MapSubset A B m m' -> MapDomRestrBy A B m m' = M0 A.

*****
B : Type
A : Type
*****
forall (m : Map A) (m' : Map B) (_ : mapcanon m) (_ : MapSubset A B m m'), eq (MapDomRestrBy A B m m') (M0 A)
+++++
Proof.
-----
Lemma MapSubset_c_1 : forall (m:Map A) (m':Map B), mapcanon m -> MapSubset A B m m' -> MapDomRestrBy A B m m' = M0 A.
Proof.

*****
B : Type
A : Type
*****
forall (m : Map A) (m' : Map B) (_ : mapcanon m) (_ : MapSubset A B m m'), eq (MapDomRestrBy A B m m') (M0 A)
+++++
intros.
-----
Lemma MapSubset_c_1 : forall (m:Map A) (m':Map B), mapcanon m -> MapSubset A B m m' -> MapDomRestrBy A B m m' = M0 A.
Proof.
intros.

*****
H0 : MapSubset A B m m'
H : mapcanon m
m' : Map B
m : Map A
B : Type
A : Type
*****
eq (MapDomRestrBy A B m m') (M0 A)
+++++
apply mapcanon_unique.
-----
Lemma MapSubset_c_1 : forall (m:Map A) (m':Map B), mapcanon m -> MapSubset A B m m' -> MapDomRestrBy A B m m' = M0 A.
Proof.
intros.
apply mapcanon_unique.

*****
H0 : MapSubset A B m m'
H : mapcanon m
m' : Map B
m : Map A
B : Type
A : Type
*****
mapcanon (MapDomRestrBy A B m m')
+++++
apply MapDomRestrBy_canon.
-----
Lemma MapSubset_c_1 : forall (m:Map A) (m':Map B), mapcanon m -> MapSubset A B m m' -> MapDomRestrBy A B m m' = M0 A.
Proof.
intros.
apply mapcanon_unique.
apply MapDomRestrBy_canon.

*****
H0 : MapSubset A B m m'
H : mapcanon m
m' : Map B
m : Map A
B : Type
A : Type
*****
mapcanon m
+++++
assumption.
-----
Lemma MapSubset_c_1 : forall (m:Map A) (m':Map B), mapcanon m -> MapSubset A B m m' -> MapDomRestrBy A B m m' = M0 A.
Proof.
intros.
apply mapcanon_unique.

*****
H0 : MapSubset A B m m'
H : mapcanon m
m' : Map B
m : Map A
B : Type
A : Type
*****
mapcanon (M0 A)
+++++
apply M0_canon.
-----
Lemma MapSubset_c_1 : forall (m:Map A) (m':Map B), mapcanon m -> MapSubset A B m m' -> MapDomRestrBy A B m m' = M0 A.
Proof.
intros.
apply mapcanon_unique.

*****
H0 : MapSubset A B m m'
H : mapcanon m
m' : Map B
m : Map A
B : Type
A : Type
*****
eqmap A (MapDomRestrBy A B m m') (M0 A)
+++++
exact (MapSubset_imp_2 _ _ m m' H0).
-----
Lemma MapSubset_c_1 : forall (m:Map A) (m':Map B), mapcanon m -> MapSubset A B m m' -> MapDomRestrBy A B m m' = M0 A.
Proof.
intros.
apply mapcanon_unique.

*****

*****

+++++
Qed.
-----
Lemma MapSubset_c_2 :\n   forall (m:Map A) (m':Map B),\n     MapDomRestrBy A B m m' = M0 A -> MapSubset A B m m'.
-----
Lemma MapSubset_c_2 : forall (m:Map A) (m':Map B), MapDomRestrBy A B m m' = M0 A -> MapSubset A B m m'.

*****
B : Type
A : Type
*****
forall (m : Map A) (m' : Map B) (_ : eq (MapDomRestrBy A B m m') (M0 A)), MapSubset A B m m'
+++++
Proof.
-----
Lemma MapSubset_c_2 : forall (m:Map A) (m':Map B), MapDomRestrBy A B m m' = M0 A -> MapSubset A B m m'.
Proof.

*****
B : Type
A : Type
*****
forall (m : Map A) (m' : Map B) (_ : eq (MapDomRestrBy A B m m') (M0 A)), MapSubset A B m m'
+++++
intros.
-----
Lemma MapSubset_c_2 : forall (m:Map A) (m':Map B), MapDomRestrBy A B m m' = M0 A -> MapSubset A B m m'.
Proof.
intros.

*****
H : eq (MapDomRestrBy A B m m') (M0 A)
m' : Map B
m : Map A
B : Type
A : Type
*****
MapSubset A B m m'
+++++
apply MapSubset_2_imp.
-----
Lemma MapSubset_c_2 : forall (m:Map A) (m':Map B), MapDomRestrBy A B m m' = M0 A -> MapSubset A B m m'.
Proof.
intros.
apply MapSubset_2_imp.

*****
H : eq (MapDomRestrBy A B m m') (M0 A)
m' : Map B
m : Map A
B : Type
A : Type
*****
MapSubset_2 A B m m'
+++++
unfold MapSubset_2 in |- *.
-----
Lemma MapSubset_c_2 : forall (m:Map A) (m':Map B), MapDomRestrBy A B m m' = M0 A -> MapSubset A B m m'.
Proof.
intros.
apply MapSubset_2_imp.
unfold MapSubset_2 in |- *.

*****
H : eq (MapDomRestrBy A B m m') (M0 A)
m' : Map B
m : Map A
B : Type
A : Type
*****
eqmap A (MapDomRestrBy A B m m') (M0 A)
+++++
rewrite H.
-----
Lemma MapSubset_c_2 : forall (m:Map A) (m':Map B), MapDomRestrBy A B m m' = M0 A -> MapSubset A B m m'.
Proof.
intros.
apply MapSubset_2_imp.
unfold MapSubset_2 in |- *.
rewrite H.

*****
H : eq (MapDomRestrBy A B m m') (M0 A)
m' : Map B
m : Map A
B : Type
A : Type
*****
eqmap A (M0 A) (M0 A)
+++++
apply eqmap_refl.
-----
Lemma MapSubset_c_2 : forall (m:Map A) (m':Map B), MapDomRestrBy A B m m' = M0 A -> MapSubset A B m m'.
Proof.
intros.
apply MapSubset_2_imp.
unfold MapSubset_2 in |- *.
rewrite H.
apply eqmap_refl.

*****

*****

+++++
Qed.
-----
End MapCanon.
-----
Section FSetCanon.
-----
Variable A : Type.
-----
Lemma MapDom_canon :\n   forall m:Map A, mapcanon A m -> mapcanon unit (MapDom A m).
-----
Lemma MapDom_canon : forall m:Map A, mapcanon A m -> mapcanon unit (MapDom A m).

*****
A : Type
*****
forall (m : Map A) (_ : mapcanon A m), mapcanon unit (MapDom A m)
+++++
Proof.
-----
Lemma MapDom_canon : forall m:Map A, mapcanon A m -> mapcanon unit (MapDom A m).
Proof.

*****
A : Type
*****
forall (m : Map A) (_ : mapcanon A m), mapcanon unit (MapDom A m)
+++++
simple induction m.
-----
Lemma MapDom_canon : forall m:Map A, mapcanon A m -> mapcanon unit (MapDom A m).
Proof.
simple induction m.

*****
m : Map A
A : Type
*****
forall _ : mapcanon A (M0 A), mapcanon unit (MapDom A (M0 A))
+++++
intro.
-----
Lemma MapDom_canon : forall m:Map A, mapcanon A m -> mapcanon unit (MapDom A m).
Proof.
simple induction m.
intro.

*****
H : mapcanon A (M0 A)
m : Map A
A : Type
*****
mapcanon unit (MapDom A (M0 A))
+++++
exact (M0_canon unit).
-----
Lemma MapDom_canon : forall m:Map A, mapcanon A m -> mapcanon unit (MapDom A m).
Proof.
simple induction m.

*****
m : Map A
A : Type
*****
forall (a : ad) (a0 : A) (_ : mapcanon A (M1 A a a0)), mapcanon unit (MapDom A (M1 A a a0))
+++++
intros a y H.
-----
Lemma MapDom_canon : forall m:Map A, mapcanon A m -> mapcanon unit (MapDom A m).
Proof.
simple induction m.
intros a y H.

*****
H : mapcanon A (M1 A a y)
y : A
a : ad
m : Map A
A : Type
*****
mapcanon unit (MapDom A (M1 A a y))
+++++
exact (M1_canon unit a _).
-----
Lemma MapDom_canon : forall m:Map A, mapcanon A m -> mapcanon unit (MapDom A m).
Proof.
simple induction m.

*****
m : Map A
A : Type
*****
forall (m : Map A) (_ : forall _ : mapcanon A m, mapcanon unit (MapDom A m)) (m0 : Map A) (_ : forall _ : mapcanon A m0, mapcanon unit (MapDom A m0)) (_ : mapcanon A (M2 A m m0)), mapcanon unit (MapDom A (M2 A m m0))
+++++
intros.
-----
Lemma MapDom_canon : forall m:Map A, mapcanon A m -> mapcanon unit (MapDom A m).
Proof.
simple induction m.
intros.

*****
H1 : mapcanon A (M2 A m0 m1)
H0 : forall _ : mapcanon A m1, mapcanon unit (MapDom A m1)
m1 : Map A
H : forall _ : mapcanon A m0, mapcanon unit (MapDom A m0)
m,m0 : Map A
A : Type
*****
mapcanon unit (MapDom A (M2 A m0 m1))
+++++
simpl in |- *.
-----
Lemma MapDom_canon : forall m:Map A, mapcanon A m -> mapcanon unit (MapDom A m).
Proof.
simple induction m.
intros.
simpl in |- *.

*****
H1 : mapcanon A (M2 A m0 m1)
H0 : forall _ : mapcanon A m1, mapcanon unit (MapDom A m1)
m1 : Map A
H : forall _ : mapcanon A m0, mapcanon unit (MapDom A m0)
m,m0 : Map A
A : Type
*****
mapcanon unit (M2 unit (MapDom A m0) (MapDom A m1))
+++++
apply M2_canon.
-----
Lemma MapDom_canon : forall m:Map A, mapcanon A m -> mapcanon unit (MapDom A m).
Proof.
simple induction m.
intros.
simpl in |- *.
apply M2_canon.

*****
H1 : mapcanon A (M2 A m0 m1)
H0 : forall _ : mapcanon A m1, mapcanon unit (MapDom A m1)
m1 : Map A
H : forall _ : mapcanon A m0, mapcanon unit (MapDom A m0)
m,m0 : Map A
A : Type
*****
mapcanon unit (MapDom A m0)
+++++
apply H.
-----
Lemma MapDom_canon : forall m:Map A, mapcanon A m -> mapcanon unit (MapDom A m).
Proof.
simple induction m.
intros.
simpl in |- *.
apply M2_canon.
apply H.

*****
H1 : mapcanon A (M2 A m0 m1)
H0 : forall _ : mapcanon A m1, mapcanon unit (MapDom A m1)
m1 : Map A
H : forall _ : mapcanon A m0, mapcanon unit (MapDom A m0)
m,m0 : Map A
A : Type
*****
mapcanon A m0
+++++
exact (mapcanon_M2_1 A _ _ H1).
-----
Lemma MapDom_canon : forall m:Map A, mapcanon A m -> mapcanon unit (MapDom A m).
Proof.
simple induction m.
intros.
simpl in |- *.
apply M2_canon.

*****
H1 : mapcanon A (M2 A m0 m1)
H0 : forall _ : mapcanon A m1, mapcanon unit (MapDom A m1)
m1 : Map A
H : forall _ : mapcanon A m0, mapcanon unit (MapDom A m0)
m,m0 : Map A
A : Type
*****
mapcanon unit (MapDom A m1)
+++++
apply H0.
-----
Lemma MapDom_canon : forall m:Map A, mapcanon A m -> mapcanon unit (MapDom A m).
Proof.
simple induction m.
intros.
simpl in |- *.
apply M2_canon.
apply H0.

*****
H1 : mapcanon A (M2 A m0 m1)
H0 : forall _ : mapcanon A m1, mapcanon unit (MapDom A m1)
m1 : Map A
H : forall _ : mapcanon A m0, mapcanon unit (MapDom A m0)
m,m0 : Map A
A : Type
*****
mapcanon A m1
+++++
exact (mapcanon_M2_2 A _ _ H1).
-----
Lemma MapDom_canon : forall m:Map A, mapcanon A m -> mapcanon unit (MapDom A m).
Proof.
simple induction m.
intros.
simpl in |- *.
apply M2_canon.

*****
H1 : mapcanon A (M2 A m0 m1)
H0 : forall _ : mapcanon A m1, mapcanon unit (MapDom A m1)
m1 : Map A
H : forall _ : mapcanon A m0, mapcanon unit (MapDom A m0)
m,m0 : Map A
A : Type
*****
le (S (S O)) (MapCard unit (M2 unit (MapDom A m0) (MapDom A m1)))
+++++
change (2 <= MapCard unit (MapDom A (M2 A m0 m1))) in |- *.
-----
Lemma MapDom_canon : forall m:Map A, mapcanon A m -> mapcanon unit (MapDom A m).
Proof.
simple induction m.
intros.
simpl in |- *.
apply M2_canon.
change (2 <= MapCard unit (MapDom A (M2 A m0 m1))) in |- *.

*****
H1 : mapcanon A (M2 A m0 m1)
H0 : forall _ : mapcanon A m1, mapcanon unit (MapDom A m1)
m1 : Map A
H : forall _ : mapcanon A m0, mapcanon unit (MapDom A m0)
m,m0 : Map A
A : Type
*****
le (S (S O)) (MapCard unit (MapDom A (M2 A m0 m1)))
+++++
rewrite <- MapCard_Dom.
-----
Lemma MapDom_canon : forall m:Map A, mapcanon A m -> mapcanon unit (MapDom A m).
Proof.
simple induction m.
intros.
simpl in |- *.
apply M2_canon.
change (2 <= MapCard unit (MapDom A (M2 A m0 m1))) in |- *.
rewrite <- MapCard_Dom.

*****
H1 : mapcanon A (M2 A m0 m1)
H0 : forall _ : mapcanon A m1, mapcanon unit (MapDom A m1)
m1 : Map A
H : forall _ : mapcanon A m0, mapcanon unit (MapDom A m0)
m,m0 : Map A
A : Type
*****
le (S (S O)) (MapCard A (M2 A m0 m1))
+++++
exact (mapcanon_M2 A _ _ H1).
-----
Lemma MapDom_canon : forall m:Map A, mapcanon A m -> mapcanon unit (MapDom A m).
Proof.
simple induction m.

*****

*****

+++++
Qed.
-----
End FSetCanon.
-----
Section MapFoldCanon.
-----
Variables A B : Type.
-----
Lemma MapFold_canon_1 :\n   forall m0:Map B,\n     mapcanon B m0 ->\n     forall op:Map B -> Map B -> Map B,\n       (forall m1:Map B,\n          mapcanon B m1 ->\n          forall m2:Map B, mapcanon B m2 -> mapcanon B (op m1 m2)) ->\n       forall f:ad -> A -> Map B,\n         (forall (a:ad) (y:A), mapcanon B (f a y)) ->\n         forall (m:Map A) (pf:ad -> ad),\n           mapcanon B (MapFold1 A (Map B) m0 op f pf m).
-----
Lemma MapFold_canon_1 : forall m0:Map B, mapcanon B m0 -> forall op:Map B -> Map B -> Map B, (forall m1:Map B, mapcanon B m1 -> forall m2:Map B, mapcanon B m2 -> mapcanon B (op m1 m2)) -> forall f:ad -> A -> Map B, (forall (a:ad) (y:A), mapcanon B (f a y)) -> forall (m:Map A) (pf:ad -> ad), mapcanon B (MapFold1 A (Map B) m0 op f pf m).

*****
A,B : Type
*****
forall (m0 : Map B) (_ : mapcanon B m0) (op : forall (_ : Map B) (_ : Map B), Map B) (_ : forall (m1 : Map B) (_ : mapcanon B m1) (m2 : Map B) (_ : mapcanon B m2), mapcanon B (op m1 m2)) (f : forall (_ : ad) (_ : A), Map B) (_ : forall (a : ad) (y : A), mapcanon B (f a y)) (m : Map A) (pf : forall _ : ad, ad), mapcanon B (MapFold1 A (Map B) m0 op f pf m)
+++++
Proof.
-----
Lemma MapFold_canon_1 : forall m0:Map B, mapcanon B m0 -> forall op:Map B -> Map B -> Map B, (forall m1:Map B, mapcanon B m1 -> forall m2:Map B, mapcanon B m2 -> mapcanon B (op m1 m2)) -> forall f:ad -> A -> Map B, (forall (a:ad) (y:A), mapcanon B (f a y)) -> forall (m:Map A) (pf:ad -> ad), mapcanon B (MapFold1 A (Map B) m0 op f pf m).
Proof.

*****
A,B : Type
*****
forall (m0 : Map B) (_ : mapcanon B m0) (op : forall (_ : Map B) (_ : Map B), Map B) (_ : forall (m1 : Map B) (_ : mapcanon B m1) (m2 : Map B) (_ : mapcanon B m2), mapcanon B (op m1 m2)) (f : forall (_ : ad) (_ : A), Map B) (_ : forall (a : ad) (y : A), mapcanon B (f a y)) (m : Map A) (pf : forall _ : ad, ad), mapcanon B (MapFold1 A (Map B) m0 op f pf m)
+++++
simple induction m.
-----
Lemma MapFold_canon_1 : forall m0:Map B, mapcanon B m0 -> forall op:Map B -> Map B -> Map B, (forall m1:Map B, mapcanon B m1 -> forall m2:Map B, mapcanon B m2 -> mapcanon B (op m1 m2)) -> forall f:ad -> A -> Map B, (forall (a:ad) (y:A), mapcanon B (f a y)) -> forall (m:Map A) (pf:ad -> ad), mapcanon B (MapFold1 A (Map B) m0 op f pf m).
Proof.
simple induction m.

*****
m : Map A
H1 : forall (a : ad) (y : A), mapcanon B (f a y)
f : forall (_ : ad) (_ : A), Map B
H0 : forall (m1 : Map B) (_ : mapcanon B m1) (m2 : Map B)\n (_ : mapcanon B m2), mapcanon B (op m1 m2)
op : forall (_ : Map B) (_ : Map B), Map B
H : mapcanon B m0
m0 : Map B
A,B : Type
*****
forall pf : forall _ : ad, ad, mapcanon B (MapFold1 A (Map B) m0 op f pf (M0 A))
+++++
intro.
-----
Lemma MapFold_canon_1 : forall m0:Map B, mapcanon B m0 -> forall op:Map B -> Map B -> Map B, (forall m1:Map B, mapcanon B m1 -> forall m2:Map B, mapcanon B m2 -> mapcanon B (op m1 m2)) -> forall f:ad -> A -> Map B, (forall (a:ad) (y:A), mapcanon B (f a y)) -> forall (m:Map A) (pf:ad -> ad), mapcanon B (MapFold1 A (Map B) m0 op f pf m).
Proof.
simple induction m.
intro.

*****
pf : forall _ : ad, ad
m : Map A
H1 : forall (a : ad) (y : A), mapcanon B (f a y)
f : forall (_ : ad) (_ : A), Map B
H0 : forall (m1 : Map B) (_ : mapcanon B m1) (m2 : Map B)\n (_ : mapcanon B m2), mapcanon B (op m1 m2)
op : forall (_ : Map B) (_ : Map B), Map B
H : mapcanon B m0
m0 : Map B
A,B : Type
*****
mapcanon B (MapFold1 A (Map B) m0 op f pf (M0 A))
+++++
exact H.
-----
Lemma MapFold_canon_1 : forall m0:Map B, mapcanon B m0 -> forall op:Map B -> Map B -> Map B, (forall m1:Map B, mapcanon B m1 -> forall m2:Map B, mapcanon B m2 -> mapcanon B (op m1 m2)) -> forall f:ad -> A -> Map B, (forall (a:ad) (y:A), mapcanon B (f a y)) -> forall (m:Map A) (pf:ad -> ad), mapcanon B (MapFold1 A (Map B) m0 op f pf m).
Proof.
simple induction m.

*****
m : Map A
H1 : forall (a : ad) (y : A), mapcanon B (f a y)
f : forall (_ : ad) (_ : A), Map B
H0 : forall (m1 : Map B) (_ : mapcanon B m1) (m2 : Map B)\n (_ : mapcanon B m2), mapcanon B (op m1 m2)
op : forall (_ : Map B) (_ : Map B), Map B
H : mapcanon B m0
m0 : Map B
A,B : Type
*****
forall (a : ad) (a0 : A) (pf : forall _ : ad, ad), mapcanon B (MapFold1 A (Map B) m0 op f pf (M1 A a a0))
+++++
intros a y pf.
-----
Lemma MapFold_canon_1 : forall m0:Map B, mapcanon B m0 -> forall op:Map B -> Map B -> Map B, (forall m1:Map B, mapcanon B m1 -> forall m2:Map B, mapcanon B m2 -> mapcanon B (op m1 m2)) -> forall f:ad -> A -> Map B, (forall (a:ad) (y:A), mapcanon B (f a y)) -> forall (m:Map A) (pf:ad -> ad), mapcanon B (MapFold1 A (Map B) m0 op f pf m).
Proof.
simple induction m.
intros a y pf.

*****
pf : forall _ : ad, ad
y : A
a : ad
m : Map A
H1 : forall (a : ad) (y : A), mapcanon B (f a y)
f : forall (_ : ad) (_ : A), Map B
H0 : forall (m1 : Map B) (_ : mapcanon B m1) (m2 : Map B)\n (_ : mapcanon B m2), mapcanon B (op m1 m2)
op : forall (_ : Map B) (_ : Map B), Map B
H : mapcanon B m0
m0 : Map B
A,B : Type
*****
mapcanon B (MapFold1 A (Map B) m0 op f pf (M1 A a y))
+++++
simpl in |- *.
-----
Lemma MapFold_canon_1 : forall m0:Map B, mapcanon B m0 -> forall op:Map B -> Map B -> Map B, (forall m1:Map B, mapcanon B m1 -> forall m2:Map B, mapcanon B m2 -> mapcanon B (op m1 m2)) -> forall f:ad -> A -> Map B, (forall (a:ad) (y:A), mapcanon B (f a y)) -> forall (m:Map A) (pf:ad -> ad), mapcanon B (MapFold1 A (Map B) m0 op f pf m).
Proof.
simple induction m.
intros a y pf.
simpl in |- *.

*****
pf : forall _ : ad, ad
y : A
a : ad
m : Map A
H1 : forall (a : ad) (y : A), mapcanon B (f a y)
f : forall (_ : ad) (_ : A), Map B
H0 : forall (m1 : Map B) (_ : mapcanon B m1) (m2 : Map B)\n (_ : mapcanon B m2), mapcanon B (op m1 m2)
op : forall (_ : Map B) (_ : Map B), Map B
H : mapcanon B m0
m0 : Map B
A,B : Type
*****
mapcanon B (f (pf a) y)
+++++
apply H1.
-----
Lemma MapFold_canon_1 : forall m0:Map B, mapcanon B m0 -> forall op:Map B -> Map B -> Map B, (forall m1:Map B, mapcanon B m1 -> forall m2:Map B, mapcanon B m2 -> mapcanon B (op m1 m2)) -> forall f:ad -> A -> Map B, (forall (a:ad) (y:A), mapcanon B (f a y)) -> forall (m:Map A) (pf:ad -> ad), mapcanon B (MapFold1 A (Map B) m0 op f pf m).
Proof.
simple induction m.

*****
m : Map A
H1 : forall (a : ad) (y : A), mapcanon B (f a y)
f : forall (_ : ad) (_ : A), Map B
H0 : forall (m1 : Map B) (_ : mapcanon B m1) (m2 : Map B)\n (_ : mapcanon B m2), mapcanon B (op m1 m2)
op : forall (_ : Map B) (_ : Map B), Map B
H : mapcanon B m0
m0 : Map B
A,B : Type
*****
forall (m : Map A) (_ : forall pf : forall _ : ad, ad, mapcanon B (MapFold1 A (Map B) m0 op f pf m)) (m1 : Map A) (_ : forall pf : forall _ : ad, ad, mapcanon B (MapFold1 A (Map B) m0 op f pf m1)) (pf : forall _ : ad, ad), mapcanon B (MapFold1 A (Map B) m0 op f pf (M2 A m m1))
+++++
intros.
-----
Lemma MapFold_canon_1 : forall m0:Map B, mapcanon B m0 -> forall op:Map B -> Map B -> Map B, (forall m1:Map B, mapcanon B m1 -> forall m2:Map B, mapcanon B m2 -> mapcanon B (op m1 m2)) -> forall f:ad -> A -> Map B, (forall (a:ad) (y:A), mapcanon B (f a y)) -> forall (m:Map A) (pf:ad -> ad), mapcanon B (MapFold1 A (Map B) m0 op f pf m).
Proof.
simple induction m.
intros.

*****
pf : forall _ : ad, ad
H3 : forall pf : forall _ : ad, ad,\nmapcanon B (MapFold1 A (Map B) m0 op f pf m2)
m2 : Map A
H2 : forall pf : forall _ : ad, ad,\nmapcanon B (MapFold1 A (Map B) m0 op f pf m1)
m,m1 : Map A
H1 : forall (a : ad) (y : A), mapcanon B (f a y)
f : forall (_ : ad) (_ : A), Map B
H0 : forall (m1 : Map B) (_ : mapcanon B m1) (m2 : Map B)\n (_ : mapcanon B m2), mapcanon B (op m1 m2)
op : forall (_ : Map B) (_ : Map B), Map B
H : mapcanon B m0
m0 : Map B
A,B : Type
*****
mapcanon B (MapFold1 A (Map B) m0 op f pf (M2 A m1 m2))
+++++
simpl in |- *.
-----
Lemma MapFold_canon_1 : forall m0:Map B, mapcanon B m0 -> forall op:Map B -> Map B -> Map B, (forall m1:Map B, mapcanon B m1 -> forall m2:Map B, mapcanon B m2 -> mapcanon B (op m1 m2)) -> forall f:ad -> A -> Map B, (forall (a:ad) (y:A), mapcanon B (f a y)) -> forall (m:Map A) (pf:ad -> ad), mapcanon B (MapFold1 A (Map B) m0 op f pf m).
Proof.
simple induction m.
intros.
simpl in |- *.

*****
pf : forall _ : ad, ad
H3 : forall pf : forall _ : ad, ad,\nmapcanon B (MapFold1 A (Map B) m0 op f pf m2)
m2 : Map A
H2 : forall pf : forall _ : ad, ad,\nmapcanon B (MapFold1 A (Map B) m0 op f pf m1)
m,m1 : Map A
H1 : forall (a : ad) (y : A), mapcanon B (f a y)
f : forall (_ : ad) (_ : A), Map B
H0 : forall (m1 : Map B) (_ : mapcanon B m1) (m2 : Map B)\n (_ : mapcanon B m2), mapcanon B (op m1 m2)
op : forall (_ : Map B) (_ : Map B), Map B
H : mapcanon B m0
m0 : Map B
A,B : Type
*****
mapcanon B (op (MapFold1 A (Map B) m0 op f (fun a0 : ad => pf (N.double a0)) m1) (MapFold1 A (Map B) m0 op f (fun a0 : ad => pf (N.succ_double a0)) m2))
+++++
apply H0.
-----
Lemma MapFold_canon_1 : forall m0:Map B, mapcanon B m0 -> forall op:Map B -> Map B -> Map B, (forall m1:Map B, mapcanon B m1 -> forall m2:Map B, mapcanon B m2 -> mapcanon B (op m1 m2)) -> forall f:ad -> A -> Map B, (forall (a:ad) (y:A), mapcanon B (f a y)) -> forall (m:Map A) (pf:ad -> ad), mapcanon B (MapFold1 A (Map B) m0 op f pf m).
Proof.
simple induction m.
intros.
simpl in |- *.
apply H0.

*****
pf : forall _ : ad, ad
H3 : forall pf : forall _ : ad, ad,\nmapcanon B (MapFold1 A (Map B) m0 op f pf m2)
m2 : Map A
H2 : forall pf : forall _ : ad, ad,\nmapcanon B (MapFold1 A (Map B) m0 op f pf m1)
m,m1 : Map A
H1 : forall (a : ad) (y : A), mapcanon B (f a y)
f : forall (_ : ad) (_ : A), Map B
H0 : forall (m1 : Map B) (_ : mapcanon B m1) (m2 : Map B)\n (_ : mapcanon B m2), mapcanon B (op m1 m2)
op : forall (_ : Map B) (_ : Map B), Map B
H : mapcanon B m0
m0 : Map B
A,B : Type
*****
mapcanon B (MapFold1 A (Map B) m0 op f (fun a0 : ad => pf (N.double a0)) m1)
+++++
apply H2.
-----
Lemma MapFold_canon_1 : forall m0:Map B, mapcanon B m0 -> forall op:Map B -> Map B -> Map B, (forall m1:Map B, mapcanon B m1 -> forall m2:Map B, mapcanon B m2 -> mapcanon B (op m1 m2)) -> forall f:ad -> A -> Map B, (forall (a:ad) (y:A), mapcanon B (f a y)) -> forall (m:Map A) (pf:ad -> ad), mapcanon B (MapFold1 A (Map B) m0 op f pf m).
Proof.
simple induction m.
intros.
simpl in |- *.
apply H0.

*****
pf : forall _ : ad, ad
H3 : forall pf : forall _ : ad, ad,\nmapcanon B (MapFold1 A (Map B) m0 op f pf m2)
m2 : Map A
H2 : forall pf : forall _ : ad, ad,\nmapcanon B (MapFold1 A (Map B) m0 op f pf m1)
m,m1 : Map A
H1 : forall (a : ad) (y : A), mapcanon B (f a y)
f : forall (_ : ad) (_ : A), Map B
H0 : forall (m1 : Map B) (_ : mapcanon B m1) (m2 : Map B)\n (_ : mapcanon B m2), mapcanon B (op m1 m2)
op : forall (_ : Map B) (_ : Map B), Map B
H : mapcanon B m0
m0 : Map B
A,B : Type
*****
mapcanon B (MapFold1 A (Map B) m0 op f (fun a0 : ad => pf (N.succ_double a0)) m2)
+++++
apply H3.
-----
Lemma MapFold_canon_1 : forall m0:Map B, mapcanon B m0 -> forall op:Map B -> Map B -> Map B, (forall m1:Map B, mapcanon B m1 -> forall m2:Map B, mapcanon B m2 -> mapcanon B (op m1 m2)) -> forall f:ad -> A -> Map B, (forall (a:ad) (y:A), mapcanon B (f a y)) -> forall (m:Map A) (pf:ad -> ad), mapcanon B (MapFold1 A (Map B) m0 op f pf m).
Proof.
simple induction m.

*****

*****

+++++
Qed.
-----
Lemma MapFold_canon :\n   forall m0:Map B,\n     mapcanon B m0 ->\n     forall op:Map B -> Map B -> Map B,\n       (forall m1:Map B,\n          mapcanon B m1 ->\n          forall m2:Map B, mapcanon B m2 -> mapcanon B (op m1 m2)) ->\n       forall f:ad -> A -> Map B,\n         (forall (a:ad) (y:A), mapcanon B (f a y)) ->\n         forall m:Map A, mapcanon B (MapFold A (Map B) m0 op f m).
-----
Lemma MapFold_canon : forall m0:Map B, mapcanon B m0 -> forall op:Map B -> Map B -> Map B, (forall m1:Map B, mapcanon B m1 -> forall m2:Map B, mapcanon B m2 -> mapcanon B (op m1 m2)) -> forall f:ad -> A -> Map B, (forall (a:ad) (y:A), mapcanon B (f a y)) -> forall m:Map A, mapcanon B (MapFold A (Map B) m0 op f m).

*****
A,B : Type
*****
forall (m0 : Map B) (_ : mapcanon B m0) (op : forall (_ : Map B) (_ : Map B), Map B) (_ : forall (m1 : Map B) (_ : mapcanon B m1) (m2 : Map B) (_ : mapcanon B m2), mapcanon B (op m1 m2)) (f : forall (_ : ad) (_ : A), Map B) (_ : forall (a : ad) (y : A), mapcanon B (f a y)) (m : Map A), mapcanon B (MapFold A (Map B) m0 op f m)
+++++
Proof.
-----
Lemma MapFold_canon : forall m0:Map B, mapcanon B m0 -> forall op:Map B -> Map B -> Map B, (forall m1:Map B, mapcanon B m1 -> forall m2:Map B, mapcanon B m2 -> mapcanon B (op m1 m2)) -> forall f:ad -> A -> Map B, (forall (a:ad) (y:A), mapcanon B (f a y)) -> forall m:Map A, mapcanon B (MapFold A (Map B) m0 op f m).
Proof.

*****
A,B : Type
*****
forall (m0 : Map B) (_ : mapcanon B m0) (op : forall (_ : Map B) (_ : Map B), Map B) (_ : forall (m1 : Map B) (_ : mapcanon B m1) (m2 : Map B) (_ : mapcanon B m2), mapcanon B (op m1 m2)) (f : forall (_ : ad) (_ : A), Map B) (_ : forall (a : ad) (y : A), mapcanon B (f a y)) (m : Map A), mapcanon B (MapFold A (Map B) m0 op f m)
+++++
intros.
-----
Lemma MapFold_canon : forall m0:Map B, mapcanon B m0 -> forall op:Map B -> Map B -> Map B, (forall m1:Map B, mapcanon B m1 -> forall m2:Map B, mapcanon B m2 -> mapcanon B (op m1 m2)) -> forall f:ad -> A -> Map B, (forall (a:ad) (y:A), mapcanon B (f a y)) -> forall m:Map A, mapcanon B (MapFold A (Map B) m0 op f m).
Proof.
intros.

*****
m : Map A
H1 : forall (a : ad) (y : A), mapcanon B (f a y)
f : forall (_ : ad) (_ : A), Map B
H0 : forall (m1 : Map B) (_ : mapcanon B m1) (m2 : Map B)\n (_ : mapcanon B m2), mapcanon B (op m1 m2)
op : forall (_ : Map B) (_ : Map B), Map B
H : mapcanon B m0
m0 : Map B
A,B : Type
*****
mapcanon B (MapFold A (Map B) m0 op f m)
+++++
exact (MapFold_canon_1 m0 H op H0 f H1 m (fun a:ad => a)).
-----
Lemma MapFold_canon : forall m0:Map B, mapcanon B m0 -> forall op:Map B -> Map B -> Map B, (forall m1:Map B, mapcanon B m1 -> forall m2:Map B, mapcanon B m2 -> mapcanon B (op m1 m2)) -> forall f:ad -> A -> Map B, (forall (a:ad) (y:A), mapcanon B (f a y)) -> forall m:Map A, mapcanon B (MapFold A (Map B) m0 op f m).
Proof.
intros.
exact (MapFold_canon_1 m0 H op H0 f H1 m (fun a:ad => a)).

*****

*****

+++++
Qed.
-----
Lemma MapCollect_canon :\n   forall f:ad -> A -> Map B,\n     (forall (a:ad) (y:A), mapcanon B (f a y)) ->\n     forall m:Map A, mapcanon B (MapCollect A B f m).
-----
Lemma MapCollect_canon : forall f:ad -> A -> Map B, (forall (a:ad) (y:A), mapcanon B (f a y)) -> forall m:Map A, mapcanon B (MapCollect A B f m).

*****
A,B : Type
*****
forall (f : forall (_ : ad) (_ : A), Map B) (_ : forall (a : ad) (y : A), mapcanon B (f a y)) (m : Map A), mapcanon B (MapCollect A B f m)
+++++
Proof.
-----
Lemma MapCollect_canon : forall f:ad -> A -> Map B, (forall (a:ad) (y:A), mapcanon B (f a y)) -> forall m:Map A, mapcanon B (MapCollect A B f m).
Proof.

*****
A,B : Type
*****
forall (f : forall (_ : ad) (_ : A), Map B) (_ : forall (a : ad) (y : A), mapcanon B (f a y)) (m : Map A), mapcanon B (MapCollect A B f m)
+++++
intros.
-----
Lemma MapCollect_canon : forall f:ad -> A -> Map B, (forall (a:ad) (y:A), mapcanon B (f a y)) -> forall m:Map A, mapcanon B (MapCollect A B f m).
Proof.
intros.

*****
m : Map A
H : forall (a : ad) (y : A), mapcanon B (f a y)
f : forall (_ : ad) (_ : A), Map B
A,B : Type
*****
mapcanon B (MapCollect A B f m)
+++++
rewrite MapCollect_as_Fold.
-----
Lemma MapCollect_canon : forall f:ad -> A -> Map B, (forall (a:ad) (y:A), mapcanon B (f a y)) -> forall m:Map A, mapcanon B (MapCollect A B f m).
Proof.
intros.
rewrite MapCollect_as_Fold.

*****
m : Map A
H : forall (a : ad) (y : A), mapcanon B (f a y)
f : forall (_ : ad) (_ : A), Map B
A,B : Type
*****
mapcanon B (MapFold A (Map B) (M0 B) (MapMerge B) f m)
+++++
apply MapFold_canon.
-----
Lemma MapCollect_canon : forall f:ad -> A -> Map B, (forall (a:ad) (y:A), mapcanon B (f a y)) -> forall m:Map A, mapcanon B (MapCollect A B f m).
Proof.
intros.
rewrite MapCollect_as_Fold.
apply MapFold_canon.

*****
m : Map A
H : forall (a : ad) (y : A), mapcanon B (f a y)
f : forall (_ : ad) (_ : A), Map B
A,B : Type
*****
mapcanon B (M0 B)
+++++
apply M0_canon.
-----
Lemma MapCollect_canon : forall f:ad -> A -> Map B, (forall (a:ad) (y:A), mapcanon B (f a y)) -> forall m:Map A, mapcanon B (MapCollect A B f m).
Proof.
intros.
rewrite MapCollect_as_Fold.
apply MapFold_canon.

*****
m : Map A
H : forall (a : ad) (y : A), mapcanon B (f a y)
f : forall (_ : ad) (_ : A), Map B
A,B : Type
*****
forall (m1 : Map B) (_ : mapcanon B m1) (m2 : Map B) (_ : mapcanon B m2), mapcanon B (MapMerge B m1 m2)
+++++
intros.
-----
Lemma MapCollect_canon : forall f:ad -> A -> Map B, (forall (a:ad) (y:A), mapcanon B (f a y)) -> forall m:Map A, mapcanon B (MapCollect A B f m).
Proof.
intros.
rewrite MapCollect_as_Fold.
apply MapFold_canon.
intros.

*****
H1 : mapcanon B m2
m2 : Map B
H0 : mapcanon B m1
m1 : Map B
m : Map A
H : forall (a : ad) (y : A), mapcanon B (f a y)
f : forall (_ : ad) (_ : A), Map B
A,B : Type
*****
mapcanon B (MapMerge B m1 m2)
+++++
exact (MapMerge_canon B m1 m2 H0 H1).
-----
Lemma MapCollect_canon : forall f:ad -> A -> Map B, (forall (a:ad) (y:A), mapcanon B (f a y)) -> forall m:Map A, mapcanon B (MapCollect A B f m).
Proof.
intros.
rewrite MapCollect_as_Fold.
apply MapFold_canon.

*****
m : Map A
H : forall (a : ad) (y : A), mapcanon B (f a y)
f : forall (_ : ad) (_ : A), Map B
A,B : Type
*****
forall (a : ad) (y : A), mapcanon B (f a y)
+++++
assumption.
-----
Lemma MapCollect_canon : forall f:ad -> A -> Map B, (forall (a:ad) (y:A), mapcanon B (f a y)) -> forall m:Map A, mapcanon B (MapCollect A B f m).
Proof.
intros.
rewrite MapCollect_as_Fold.
apply MapFold_canon.

*****

*****

+++++
Qed.
-----
End MapFoldCanon.
-----
