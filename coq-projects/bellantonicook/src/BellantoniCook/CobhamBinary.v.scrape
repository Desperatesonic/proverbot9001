From Coq Require Import List.
-----
From Coq Require Import Arith.
-----
Require Import   Coq.Arith.Div2 .
-----
Require Import BellantoniCook.Lib BellantoniCook.Bitstring BellantoniCook.Cobham BellantoniCook.CobhamLib.
-----
Opaque bs2nat.
-----
Opaque Cond.
-----
Lemma bs2nat_smash' : forall u v n,\n  bs2nat v = power 2 n ->\n  bs2nat (smash' u v) = power 2 (length u + n).
-----
Lemma bs2nat_smash' : forall u v n, bs2nat v = power 2 n -> bs2nat (smash' u v) = power 2 (length u + n).

*****

*****
forall (u v : list bool) (n : nat) (_ : eq (bs2nat v) (power (S (S O)) n)), eq (bs2nat (smash' u v)) (power (S (S O)) (Init.Nat.add (length u) n))
+++++
Proof.
-----
Lemma bs2nat_smash' : forall u v n, bs2nat v = power 2 n -> bs2nat (smash' u v) = power 2 (length u + n).
Proof.

*****

*****
forall (u v : list bool) (n : nat) (_ : eq (bs2nat v) (power (S (S O)) n)), eq (bs2nat (smash' u v)) (power (S (S O)) (Init.Nat.add (length u) n))
+++++
induction u.
-----
Lemma bs2nat_smash' : forall u v n, bs2nat v = power 2 n -> bs2nat (smash' u v) = power 2 (length u + n).
Proof.
induction u.

*****

*****
forall (v : list bool) (n : nat) (_ : eq (bs2nat v) (power (S (S O)) n)), eq (bs2nat (smash' nil v)) (power (S (S O)) (Init.Nat.add (length nil) n))
+++++
simpl.
-----
Lemma bs2nat_smash' : forall u v n, bs2nat v = power 2 n -> bs2nat (smash' u v) = power 2 (length u + n).
Proof.
induction u.
simpl.

*****

*****
forall (v : list bool) (n : nat) (_ : eq (bs2nat v) (power (S (S O)) n)), eq (bs2nat v) (power (S (S O)) n)
+++++
intros.
-----
Lemma bs2nat_smash' : forall u v n, bs2nat v = power 2 n -> bs2nat (smash' u v) = power 2 (length u + n).
Proof.
induction u.
simpl.
intros.

*****
H : eq (bs2nat v) (power (S (S O)) n)
n : nat
v : list bool
*****
eq (bs2nat v) (power (S (S O)) n)
+++++
auto.
-----
Lemma bs2nat_smash' : forall u v n, bs2nat v = power 2 n -> bs2nat (smash' u v) = power 2 (length u + n).
Proof.
induction u.

*****
IHu : forall (v : list bool) (n : nat)\n (_ : eq (bs2nat v) (power (S (S O)) n)),\neq (bs2nat (smash' u v)) (power (S (S O)) (Init.Nat.add (length u) n))
u : list bool
a : bool
*****
forall (v : list bool) (n : nat) (_ : eq (bs2nat v) (power (S (S O)) n)), eq (bs2nat (smash' (cons a u) v)) (power (S (S O)) (Init.Nat.add (length (cons a u)) n))
+++++
simpl.
-----
Lemma bs2nat_smash' : forall u v n, bs2nat v = power 2 n -> bs2nat (smash' u v) = power 2 (length u + n).
Proof.
induction u.
simpl.

*****
IHu : forall (v : list bool) (n : nat)\n (_ : eq (bs2nat v) (power (S (S O)) n)),\neq (bs2nat (smash' u v)) (power (S (S O)) (Init.Nat.add (length u) n))
u : list bool
a : bool
*****
forall (v : list bool) (n : nat) (_ : eq (bs2nat v) (power (S (S O)) n)), eq (bs2nat (cons false (smash' u v))) (Init.Nat.add (power (S (S O)) (Init.Nat.add (length u) n)) (Init.Nat.add (power (S (S O)) (Init.Nat.add (length u) n)) O))
+++++
intros.
-----
Lemma bs2nat_smash' : forall u v n, bs2nat v = power 2 n -> bs2nat (smash' u v) = power 2 (length u + n).
Proof.
induction u.
simpl.
intros.

*****
H : eq (bs2nat v) (power (S (S O)) n)
n : nat
v : list bool
IHu : forall (v : list bool) (n : nat)\n (_ : eq (bs2nat v) (power (S (S O)) n)),\neq (bs2nat (smash' u v)) (power (S (S O)) (Init.Nat.add (length u) n))
u : list bool
a : bool
*****
eq (bs2nat (cons false (smash' u v))) (Init.Nat.add (power (S (S O)) (Init.Nat.add (length u) n)) (Init.Nat.add (power (S (S O)) (Init.Nat.add (length u) n)) O))
+++++
auto.
-----
Lemma bs2nat_smash' : forall u v n, bs2nat v = power 2 n -> bs2nat (smash' u v) = power 2 (length u + n).
Proof.
induction u.
simpl.
intros.
auto.

*****
H : eq (bs2nat v) (power (S (S O)) n)
n : nat
v : list bool
IHu : forall (v : list bool) (n : nat)\n (_ : eq (bs2nat v) (power (S (S O)) n)),\neq (bs2nat (smash' u v)) (power (S (S O)) (Init.Nat.add (length u) n))
u : list bool
a : bool
*****
eq (bs2nat (cons false (smash' u v))) (Init.Nat.add (power (S (S O)) (Init.Nat.add (length u) n)) (Init.Nat.add (power (S (S O)) (Init.Nat.add (length u) n)) O))
+++++
rewrite bs2nat_false.
-----
Lemma bs2nat_smash' : forall u v n, bs2nat v = power 2 n -> bs2nat (smash' u v) = power 2 (length u + n).
Proof.
induction u.
simpl.
intros.
auto.
rewrite bs2nat_false.

*****
H : eq (bs2nat v) (power (S (S O)) n)
n : nat
v : list bool
IHu : forall (v : list bool) (n : nat)\n (_ : eq (bs2nat v) (power (S (S O)) n)),\neq (bs2nat (smash' u v)) (power (S (S O)) (Init.Nat.add (length u) n))
u : list bool
a : bool
*****
eq (Init.Nat.mul (S (S O)) (bs2nat (smash' u v))) (Init.Nat.add (power (S (S O)) (Init.Nat.add (length u) n)) (Init.Nat.add (power (S (S O)) (Init.Nat.add (length u) n)) O))
+++++
rewrite (IHu v n).
-----
Lemma bs2nat_smash' : forall u v n, bs2nat v = power 2 n -> bs2nat (smash' u v) = power 2 (length u + n).
Proof.
induction u.
simpl.
intros.
auto.
rewrite bs2nat_false.
rewrite (IHu v n).

*****
H : eq (bs2nat v) (power (S (S O)) n)
n : nat
v : list bool
IHu : forall (v : list bool) (n : nat)\n (_ : eq (bs2nat v) (power (S (S O)) n)),\neq (bs2nat (smash' u v)) (power (S (S O)) (Init.Nat.add (length u) n))
u : list bool
a : bool
*****
eq (Init.Nat.mul (S (S O)) (power (S (S O)) (Init.Nat.add (length u) n))) (Init.Nat.add (power (S (S O)) (Init.Nat.add (length u) n)) (Init.Nat.add (power (S (S O)) (Init.Nat.add (length u) n)) O))
+++++
trivial.
-----
Lemma bs2nat_smash' : forall u v n, bs2nat v = power 2 n -> bs2nat (smash' u v) = power 2 (length u + n).
Proof.
induction u.
simpl.
intros.
auto.
rewrite bs2nat_false.
rewrite (IHu v n).

*****
H : eq (bs2nat v) (power (S (S O)) n)
n : nat
v : list bool
IHu : forall (v : list bool) (n : nat)\n (_ : eq (bs2nat v) (power (S (S O)) n)),\neq (bs2nat (smash' u v)) (power (S (S O)) (Init.Nat.add (length u) n))
u : list bool
a : bool
*****
eq (bs2nat v) (power (S (S O)) n)
+++++
trivial.
-----
Lemma bs2nat_smash' : forall u v n, bs2nat v = power 2 n -> bs2nat (smash' u v) = power 2 (length u + n).
Proof.
induction u.

*****

*****

+++++
Qed.
-----
Lemma bs2nat_smash_bs : forall u v,\n  bs2nat (smash_bs u v) = power 2 (length u * length v).
-----
Lemma bs2nat_smash_bs : forall u v, bs2nat (smash_bs u v) = power 2 (length u * length v).

*****

*****
forall u v : list bool, eq (bs2nat (smash_bs u v)) (power (S (S O)) (Init.Nat.mul (length u) (length v)))
+++++
Proof.
-----
Lemma bs2nat_smash_bs : forall u v, bs2nat (smash_bs u v) = power 2 (length u * length v).
Proof.

*****

*****
forall u v : list bool, eq (bs2nat (smash_bs u v)) (power (S (S O)) (Init.Nat.mul (length u) (length v)))
+++++
induction u.
-----
Lemma bs2nat_smash_bs : forall u v, bs2nat (smash_bs u v) = power 2 (length u * length v).
Proof.
induction u.

*****

*****
forall v : list bool, eq (bs2nat (smash_bs nil v)) (power (S (S O)) (Init.Nat.mul (length nil) (length v)))
+++++
simpl.
-----
Lemma bs2nat_smash_bs : forall u v, bs2nat (smash_bs u v) = power 2 (length u * length v).
Proof.
induction u.
simpl.

*****

*****
forall _ : list bool, eq (bs2nat (cons true nil)) (S O)
+++++
intros.
-----
Lemma bs2nat_smash_bs : forall u v, bs2nat (smash_bs u v) = power 2 (length u * length v).
Proof.
induction u.
simpl.
intros.

*****
v : list bool
*****
eq (bs2nat (cons true nil)) (S O)
+++++
auto.
-----
Lemma bs2nat_smash_bs : forall u v, bs2nat (smash_bs u v) = power 2 (length u * length v).
Proof.
induction u.

*****
IHu : forall v : list bool,\neq (bs2nat (smash_bs u v))\n (power (S (S O)) (Init.Nat.mul (length u) (length v)))
u : list bool
a : bool
*****
forall v : list bool, eq (bs2nat (smash_bs (cons a u) v)) (power (S (S O)) (Init.Nat.mul (length (cons a u)) (length v)))
+++++
simpl.
-----
Lemma bs2nat_smash_bs : forall u v, bs2nat (smash_bs u v) = power 2 (length u * length v).
Proof.
induction u.
simpl.

*****
IHu : forall v : list bool,\neq (bs2nat (smash_bs u v))\n (power (S (S O)) (Init.Nat.mul (length u) (length v)))
u : list bool
a : bool
*****
forall v : list bool, eq (bs2nat (smash' v (smash_bs u v))) (power (S (S O)) (Init.Nat.add (length v) (Init.Nat.mul (length u) (length v))))
+++++
intros.
-----
Lemma bs2nat_smash_bs : forall u v, bs2nat (smash_bs u v) = power 2 (length u * length v).
Proof.
induction u.
simpl.
intros.

*****
v : list bool
IHu : forall v : list bool,\neq (bs2nat (smash_bs u v))\n (power (S (S O)) (Init.Nat.mul (length u) (length v)))
u : list bool
a : bool
*****
eq (bs2nat (smash' v (smash_bs u v))) (power (S (S O)) (Init.Nat.add (length v) (Init.Nat.mul (length u) (length v))))
+++++
auto.
-----
Lemma bs2nat_smash_bs : forall u v, bs2nat (smash_bs u v) = power 2 (length u * length v).
Proof.
induction u.
simpl.
intros.
auto.

*****
v : list bool
IHu : forall v : list bool,\neq (bs2nat (smash_bs u v))\n (power (S (S O)) (Init.Nat.mul (length u) (length v)))
u : list bool
a : bool
*****
eq (bs2nat (smash' v (smash_bs u v))) (power (S (S O)) (Init.Nat.add (length v) (Init.Nat.mul (length u) (length v))))
+++++
rewrite bs2nat_smash' with (n := length u * length v).
-----
Lemma bs2nat_smash_bs : forall u v, bs2nat (smash_bs u v) = power 2 (length u * length v).
Proof.
induction u.
simpl.
intros.
auto.
rewrite bs2nat_smash' with (n := length u * length v).

*****
v : list bool
IHu : forall v : list bool,\neq (bs2nat (smash_bs u v))\n (power (S (S O)) (Init.Nat.mul (length u) (length v)))
u : list bool
a : bool
*****
eq (power (S (S O)) (Init.Nat.add (length v) (Init.Nat.mul (length u) (length v)))) (power (S (S O)) (Init.Nat.add (length v) (Init.Nat.mul (length u) (length v))))
+++++
trivial.
-----
Lemma bs2nat_smash_bs : forall u v, bs2nat (smash_bs u v) = power 2 (length u * length v).
Proof.
induction u.
simpl.
intros.
auto.
rewrite bs2nat_smash' with (n := length u * length v).

*****
v : list bool
IHu : forall v : list bool,\neq (bs2nat (smash_bs u v))\n (power (S (S O)) (Init.Nat.mul (length u) (length v)))
u : list bool
a : bool
*****
eq (bs2nat (smash_bs u v)) (power (S (S O)) (Init.Nat.mul (length u) (length v)))
+++++
trivial.
-----
Lemma bs2nat_smash_bs : forall u v, bs2nat (smash_bs u v) = power 2 (length u * length v).
Proof.
induction u.

*****

*****

+++++
Qed.
-----
Lemma Smash_correct : forall l,\n  bs2nat (Sem Smash l) = power 2 (length (hd nil l) * length (hd nil (tl l))).
-----
Lemma Smash_correct : forall l, bs2nat (Sem Smash l) = power 2 (length (hd nil l) * length (hd nil (tl l))).

*****

*****
forall l : list (list bool), eq (bs2nat (Sem Smash l)) (power (S (S O)) (Init.Nat.mul (length (hd nil l)) (length (hd nil (tl l)))))
+++++
Proof.
-----
Lemma Smash_correct : forall l, bs2nat (Sem Smash l) = power 2 (length (hd nil l) * length (hd nil (tl l))).
Proof.

*****

*****
forall l : list (list bool), eq (bs2nat (Sem Smash l)) (power (S (S O)) (Init.Nat.mul (length (hd nil l)) (length (hd nil (tl l)))))
+++++
intros [ | u [ | v l] ].
-----
Lemma Smash_correct : forall l, bs2nat (Sem Smash l) = power 2 (length (hd nil l) * length (hd nil (tl l))).
Proof.
intros [ | u [ | v l] ].

*****

*****
eq (bs2nat (Sem Smash nil)) (power (S (S O)) (Init.Nat.mul (length (hd nil nil)) (length (hd nil (tl nil)))))
+++++
trivial.
-----
Lemma Smash_correct : forall l, bs2nat (Sem Smash l) = power 2 (length (hd nil l) * length (hd nil (tl l))).
Proof.
intros [ | u [ | v l] ].

*****
u : list bool
*****
eq (bs2nat (Sem Smash (cons u nil))) (power (S (S O)) (Init.Nat.mul (length (hd nil (cons u nil))) (length (hd nil (tl (cons u nil))))))
+++++
trivial.
-----
Lemma Smash_correct : forall l, bs2nat (Sem Smash l) = power 2 (length (hd nil l) * length (hd nil (tl l))).
Proof.
intros [ | u [ | v l] ].
trivial.

*****
u : list bool
*****
eq (bs2nat (Sem Smash (cons u nil))) (power (S (S O)) (Init.Nat.mul (length (hd nil (cons u nil))) (length (hd nil (tl (cons u nil))))))
+++++
simpl.
-----
Lemma Smash_correct : forall l, bs2nat (Sem Smash l) = power 2 (length (hd nil l) * length (hd nil (tl l))).
Proof.
intros [ | u [ | v l] ].
trivial.
simpl.

*****
u : list bool
*****
eq (bs2nat (smash_bs u nil)) (power (S (S O)) (Init.Nat.mul (length u) O))
+++++
rewrite mult_0_r.
-----
Lemma Smash_correct : forall l, bs2nat (Sem Smash l) = power 2 (length (hd nil l) * length (hd nil (tl l))).
Proof.
intros [ | u [ | v l] ].
trivial.
simpl.
rewrite mult_0_r.

*****
u : list bool
*****
eq (bs2nat (smash_bs u nil)) (power (S (S O)) O)
+++++
simpl.
-----
Lemma Smash_correct : forall l, bs2nat (Sem Smash l) = power 2 (length (hd nil l) * length (hd nil (tl l))).
Proof.
intros [ | u [ | v l] ].
trivial.
simpl.
rewrite mult_0_r.
simpl.

*****
u : list bool
*****
eq (bs2nat (smash_bs u nil)) (S O)
+++++
induction u as [ | [ | ] u IH].
-----
Lemma Smash_correct : forall l, bs2nat (Sem Smash l) = power 2 (length (hd nil l) * length (hd nil (tl l))).
Proof.
intros [ | u [ | v l] ].
trivial.
simpl.
rewrite mult_0_r.
simpl.
induction u as [ | [ | ] u IH].

*****

*****
eq (bs2nat (smash_bs nil nil)) (S O)
+++++
trivial.
-----
Lemma Smash_correct : forall l, bs2nat (Sem Smash l) = power 2 (length (hd nil l) * length (hd nil (tl l))).
Proof.
intros [ | u [ | v l] ].
trivial.
simpl.
rewrite mult_0_r.
simpl.
induction u as [ | [ | ] u IH].

*****
IH : eq (bs2nat (smash_bs u nil)) (S O)
u : list bool
*****
eq (bs2nat (smash_bs (cons true u) nil)) (S O)
+++++
trivial.
-----
Lemma Smash_correct : forall l, bs2nat (Sem Smash l) = power 2 (length (hd nil l) * length (hd nil (tl l))).
Proof.
intros [ | u [ | v l] ].
trivial.
simpl.
rewrite mult_0_r.
simpl.
induction u as [ | [ | ] u IH].

*****
IH : eq (bs2nat (smash_bs u nil)) (S O)
u : list bool
*****
eq (bs2nat (smash_bs (cons false u) nil)) (S O)
+++++
trivial.
-----
Lemma Smash_correct : forall l, bs2nat (Sem Smash l) = power 2 (length (hd nil l) * length (hd nil (tl l))).
Proof.
intros [ | u [ | v l] ].

*****
l : list (list bool)
u,v : list bool
*****
eq (bs2nat (Sem Smash (cons u (cons v l)))) (power (S (S O)) (Init.Nat.mul (length (hd nil (cons u (cons v l)))) (length (hd nil (tl (cons u (cons v l)))))))
+++++
trivial.
-----
Lemma Smash_correct : forall l, bs2nat (Sem Smash l) = power 2 (length (hd nil l) * length (hd nil (tl l))).
Proof.
intros [ | u [ | v l] ].
trivial.

*****
l : list (list bool)
u,v : list bool
*****
eq (bs2nat (Sem Smash (cons u (cons v l)))) (power (S (S O)) (Init.Nat.mul (length (hd nil (cons u (cons v l)))) (length (hd nil (tl (cons u (cons v l)))))))
+++++
simpl.
-----
Lemma Smash_correct : forall l, bs2nat (Sem Smash l) = power 2 (length (hd nil l) * length (hd nil (tl l))).
Proof.
intros [ | u [ | v l] ].
trivial.
simpl.

*****
l : list (list bool)
u,v : list bool
*****
eq (bs2nat (smash_bs u v)) (power (S (S O)) (Init.Nat.mul (length u) (length v)))
+++++
apply bs2nat_smash_bs.
-----
Lemma Smash_correct : forall l, bs2nat (Sem Smash l) = power 2 (length (hd nil l) * length (hd nil (tl l))).
Proof.
intros [ | u [ | v l] ].

*****

*****

+++++
Qed.
-----
Lemma Zero_correct_bs n l: \n  Sem (Zero_e n) l = nil.
-----
Lemma Zero_correct_bs n l: Sem (Zero_e n) l = nil.

*****
l : list (list bool)
n : nat
*****
eq (Sem (Zero_e n) l) nil
+++++
Proof.
-----
Lemma Zero_correct_bs n l: Sem (Zero_e n) l = nil.
Proof.

*****
l : list (list bool)
n : nat
*****
eq (Sem (Zero_e n) l) nil
+++++
trivial.
-----
Lemma Zero_correct_bs n l: Sem (Zero_e n) l = nil.
Proof.
trivial.

*****

*****

+++++
Qed.
-----
Lemma Zero_correct n l: \n  bs2nat (Sem (Zero_e n) l) = 0.
-----
Lemma Zero_correct n l: bs2nat (Sem (Zero_e n) l) = 0.

*****
l : list (list bool)
n : nat
*****
eq (bs2nat (Sem (Zero_e n) l)) O
+++++
Proof.
-----
Lemma Zero_correct n l: bs2nat (Sem (Zero_e n) l) = 0.
Proof.

*****
l : list (list bool)
n : nat
*****
eq (bs2nat (Sem (Zero_e n) l)) O
+++++
trivial.
-----
Lemma Zero_correct n l: bs2nat (Sem (Zero_e n) l) = 0.
Proof.
trivial.

*****

*****

+++++
Qed.
-----
Definition False_e n :=\n  Comp n (Succ false) [Zero_e n].
-----
Lemma arity_False: forall n : nat, arity (False_e n) = ok_arity n.
-----
Lemma arity_False: forall n : nat, arity (False_e n) = ok_arity n.

*****

*****
forall n : nat, eq (arity (False_e n)) (ok_arity n)
+++++
Proof.
-----
Lemma arity_False: forall n : nat, arity (False_e n) = ok_arity n.
Proof.

*****

*****
forall n : nat, eq (arity (False_e n)) (ok_arity n)
+++++
simpl.
-----
Lemma arity_False: forall n : nat, arity (False_e n) = ok_arity n.
Proof.
simpl.

*****

*****
forall n : nat, eq (if andb (Nat.eqb n n) true then ok_arity n else error_Comp (ok_arity (S O)) (cons (ok_arity n) nil)) (ok_arity n)
+++++
simpl.
-----
Lemma arity_False: forall n : nat, arity (False_e n) = ok_arity n.
Proof.
simpl.
simpl.

*****

*****
forall n : nat, eq (if andb (Nat.eqb n n) true then ok_arity n else error_Comp (ok_arity (S O)) (cons (ok_arity n) nil)) (ok_arity n)
+++++
intros.
-----
Lemma arity_False: forall n : nat, arity (False_e n) = ok_arity n.
Proof.
simpl.
simpl.
intros.

*****
n : nat
*****
eq (if andb (Nat.eqb n n) true then ok_arity n else error_Comp (ok_arity (S O)) (cons (ok_arity n) nil)) (ok_arity n)
+++++
rewrite <- beq_nat_refl.
-----
Lemma arity_False: forall n : nat, arity (False_e n) = ok_arity n.
Proof.
simpl.
simpl.
intros.
rewrite <- beq_nat_refl.

*****
n : nat
*****
eq (if andb true true then ok_arity n else error_Comp (ok_arity (S O)) (cons (ok_arity n) nil)) (ok_arity n)
+++++
simpl.
-----
Lemma arity_False: forall n : nat, arity (False_e n) = ok_arity n.
Proof.
simpl.
simpl.
intros.
rewrite <- beq_nat_refl.
simpl.

*****
n : nat
*****
eq (ok_arity n) (ok_arity n)
+++++
trivial.
-----
Lemma arity_False: forall n : nat, arity (False_e n) = ok_arity n.
Proof.
simpl.
simpl.
intros.
rewrite <- beq_nat_refl.
simpl.
trivial.

*****

*****

+++++
Qed.
-----
Lemma rec_bounded_False: forall n : nat, rec_bounded (False_e n).
-----
Lemma rec_bounded_False: forall n : nat, rec_bounded (False_e n).

*****

*****
forall n : nat, rec_bounded (False_e n)
+++++
Proof.
-----
Lemma rec_bounded_False: forall n : nat, rec_bounded (False_e n).
Proof.

*****

*****
forall n : nat, rec_bounded (False_e n)
+++++
intros.
-----
Lemma rec_bounded_False: forall n : nat, rec_bounded (False_e n).
Proof.
intros.

*****
n : nat
*****
rec_bounded (False_e n)
+++++
simpl.
-----
Lemma rec_bounded_False: forall n : nat, rec_bounded (False_e n).
Proof.
intros.
simpl.

*****
n : nat
*****
and True (and (and True True) True)
+++++
intuition.
-----
Lemma rec_bounded_False: forall n : nat, rec_bounded (False_e n).
Proof.
intros.
simpl.
intuition.

*****

*****

+++++
Qed.
-----
Lemma False_correct: forall (n : nat) (l : list bs), bs2nat (Sem (False_e n) l) = 0.
-----
Lemma False_correct: forall (n : nat) (l : list bs), bs2nat (Sem (False_e n) l) = 0.

*****

*****
forall (n : nat) (l : list (list bool)), eq (bs2nat (Sem (False_e n) l)) O
+++++
Proof.
-----
Lemma False_correct: forall (n : nat) (l : list bs), bs2nat (Sem (False_e n) l) = 0.
Proof.

*****

*****
forall (n : nat) (l : list (list bool)), eq (bs2nat (Sem (False_e n) l)) O
+++++
intros.
-----
Lemma False_correct: forall (n : nat) (l : list bs), bs2nat (Sem (False_e n) l) = 0.
Proof.
intros.

*****
l : list (list bool)
n : nat
*****
eq (bs2nat (Sem (False_e n) l)) O
+++++
simpl.
-----
Lemma False_correct: forall (n : nat) (l : list bs), bs2nat (Sem (False_e n) l) = 0.
Proof.
intros.
simpl.

*****
l : list (list bool)
n : nat
*****
eq (bs2nat (cons false nil)) O
+++++
auto.
-----
Lemma False_correct: forall (n : nat) (l : list bs), bs2nat (Sem (False_e n) l) = 0.
Proof.
intros.
simpl.
auto.

*****

*****

+++++
Qed.
-----
Lemma False_correct_bs: forall (n : nat) (l : list bs), Sem (False_e n) l = [false].
-----
Lemma False_correct_bs: forall (n : nat) (l : list bs), Sem (False_e n) l = [false].

*****

*****
forall (n : nat) (l : list (list bool)), eq (Sem (False_e n) l) (cons false nil)
+++++
Proof.
-----
Lemma False_correct_bs: forall (n : nat) (l : list bs), Sem (False_e n) l = [false].
Proof.

*****

*****
forall (n : nat) (l : list (list bool)), eq (Sem (False_e n) l) (cons false nil)
+++++
intros.
-----
Lemma False_correct_bs: forall (n : nat) (l : list bs), Sem (False_e n) l = [false].
Proof.
intros.

*****
l : list (list bool)
n : nat
*****
eq (Sem (False_e n) l) (cons false nil)
+++++
simpl.
-----
Lemma False_correct_bs: forall (n : nat) (l : list bs), Sem (False_e n) l = [false].
Proof.
intros.
simpl.

*****
l : list (list bool)
n : nat
*****
eq (cons false nil) (cons false nil)
+++++
auto.
-----
Lemma False_correct_bs: forall (n : nat) (l : list bs), Sem (False_e n) l = [false].
Proof.
intros.
simpl.
auto.

*****

*****

+++++
Qed.
-----
Lemma One_correct n l: \n  bs2nat (Sem (One_e n) l) = 1.
-----
Lemma One_correct n l: bs2nat (Sem (One_e n) l) = 1.

*****
l : list (list bool)
n : nat
*****
eq (bs2nat (Sem (One_e n) l)) (S O)
+++++
Proof.
-----
Lemma One_correct n l: bs2nat (Sem (One_e n) l) = 1.
Proof.

*****
l : list (list bool)
n : nat
*****
eq (bs2nat (Sem (One_e n) l)) (S O)
+++++
trivial.
-----
Lemma One_correct n l: bs2nat (Sem (One_e n) l) = 1.
Proof.
trivial.

*****

*****

+++++
Qed.
-----
Lemma One_correct_bs n l:\n  Sem (One_e n) l = [true].
-----
Lemma One_correct_bs n l: Sem (One_e n) l = [true].

*****
l : list (list bool)
n : nat
*****
eq (Sem (One_e n) l) (cons true nil)
+++++
Proof.
-----
Lemma One_correct_bs n l: Sem (One_e n) l = [true].
Proof.

*****
l : list (list bool)
n : nat
*****
eq (Sem (One_e n) l) (cons true nil)
+++++
trivial.
-----
Lemma One_correct_bs n l: Sem (One_e n) l = [true].
Proof.
trivial.

*****

*****

+++++
Qed.
-----
Opaque Zero_e One_e False_e Rev_e RemoveLSZ_e.
-----
Definition Normalize_e : Cobham :=\n  Comp 1 Rev_e [Comp 1 RemoveLSZ_e [Rev_e]].
-----
Lemma arity_Normalize :\n  arity Normalize_e = ok_arity 1.
-----
Lemma arity_Normalize : arity Normalize_e = ok_arity 1.

*****

*****
eq (arity Normalize_e) (ok_arity (S O))
+++++
Proof.
-----
Lemma arity_Normalize : arity Normalize_e = ok_arity 1.
Proof.

*****

*****
eq (arity Normalize_e) (ok_arity (S O))
+++++
trivial.
-----
Lemma arity_Normalize : arity Normalize_e = ok_arity 1.
Proof.
trivial.

*****

*****

+++++
Qed.
-----
Lemma rec_bounded_Normalize :\n  rec_bounded Normalize_e.
-----
Lemma rec_bounded_Normalize : rec_bounded Normalize_e.

*****

*****
rec_bounded Normalize_e
+++++
Proof.
-----
Lemma rec_bounded_Normalize : rec_bounded Normalize_e.
Proof.

*****

*****
rec_bounded Normalize_e
+++++
simpl.
-----
Lemma rec_bounded_Normalize : rec_bounded Normalize_e.
Proof.
simpl.

*****

*****
and (rec_bounded Rev_e) (and (and (rec_bounded RemoveLSZ_e) (and (rec_bounded Rev_e) True)) True)
+++++
intuition.
-----
Lemma rec_bounded_Normalize : rec_bounded Normalize_e.
Proof.
simpl.
intuition.

*****

*****
rec_bounded Rev_e
+++++
apply rec_bounded_Rev.
-----
Lemma rec_bounded_Normalize : rec_bounded Normalize_e.
Proof.
simpl.
intuition.

*****

*****
rec_bounded RemoveLSZ_e
+++++
apply rec_bounded_RemoveLSZ.
-----
Lemma rec_bounded_Normalize : rec_bounded Normalize_e.
Proof.
simpl.
intuition.

*****

*****
rec_bounded Rev_e
+++++
apply rec_bounded_Rev.
-----
Lemma rec_bounded_Normalize : rec_bounded Normalize_e.
Proof.
simpl.
intuition.

*****

*****

+++++
Qed.
-----
Lemma Normalize_correct : forall l,\n  bs2nat (Sem Normalize_e l) = bs2nat (Sem (Proj 1 0) l).
-----
Lemma Normalize_correct : forall l, bs2nat (Sem Normalize_e l) = bs2nat (Sem (Proj 1 0) l).

*****

*****
forall l : list (list bool), eq (bs2nat (Sem Normalize_e l)) (bs2nat (Sem (Proj (S O) O) l))
+++++
Proof.
-----
Lemma Normalize_correct : forall l, bs2nat (Sem Normalize_e l) = bs2nat (Sem (Proj 1 0) l).
Proof.

*****

*****
forall l : list (list bool), eq (bs2nat (Sem Normalize_e l)) (bs2nat (Sem (Proj (S O) O) l))
+++++
destruct l as [ | v l].
-----
Lemma Normalize_correct : forall l, bs2nat (Sem Normalize_e l) = bs2nat (Sem (Proj 1 0) l).
Proof.
destruct l as [ | v l].

*****

*****
eq (bs2nat (Sem Normalize_e nil)) (bs2nat (Sem (Proj (S O) O) nil))
+++++
trivial.
-----
Lemma Normalize_correct : forall l, bs2nat (Sem Normalize_e l) = bs2nat (Sem (Proj 1 0) l).
Proof.
destruct l as [ | v l].

*****
l : list (list bool)
v : list bool
*****
eq (bs2nat (Sem Normalize_e (cons v l))) (bs2nat (Sem (Proj (S O) O) (cons v l)))
+++++
trivial.
-----
Lemma Normalize_correct : forall l, bs2nat (Sem Normalize_e l) = bs2nat (Sem (Proj 1 0) l).
Proof.
destruct l as [ | v l].
trivial.

*****
l : list (list bool)
v : list bool
*****
eq (bs2nat (Sem Normalize_e (cons v l))) (bs2nat (Sem (Proj (S O) O) (cons v l)))
+++++
simpl.
-----
Lemma Normalize_correct : forall l, bs2nat (Sem Normalize_e l) = bs2nat (Sem (Proj 1 0) l).
Proof.
destruct l as [ | v l].
trivial.
simpl.

*****
l : list (list bool)
v : list bool
*****
eq (bs2nat (Sem Rev_e (cons (Sem RemoveLSZ_e (cons (Sem Rev_e (cons v l)) nil)) nil))) (bs2nat v)
+++++
induction v as [ | [ | ] v IH].
-----
Lemma Normalize_correct : forall l, bs2nat (Sem Normalize_e l) = bs2nat (Sem (Proj 1 0) l).
Proof.
destruct l as [ | v l].
trivial.
simpl.
induction v as [ | [ | ] v IH].

*****
l : list (list bool)
*****
eq (bs2nat (Sem Rev_e (cons (Sem RemoveLSZ_e (cons (Sem Rev_e (cons nil l)) nil)) nil))) (bs2nat nil)
+++++
trivial.
-----
Lemma Normalize_correct : forall l, bs2nat (Sem Normalize_e l) = bs2nat (Sem (Proj 1 0) l).
Proof.
destruct l as [ | v l].
trivial.
simpl.
induction v as [ | [ | ] v IH].

*****
IH : eq\n (bs2nat\n (Sem Rev_e\n (cons (Sem RemoveLSZ_e (cons (Sem Rev_e (cons v l)) nil)) nil)))\n (bs2nat v)
l : list (list bool)
v : list bool
*****
eq (bs2nat (Sem Rev_e (cons (Sem RemoveLSZ_e (cons (Sem Rev_e (cons (cons true v) l)) nil)) nil))) (bs2nat (cons true v))
+++++
trivial.
-----
Lemma Normalize_correct : forall l, bs2nat (Sem Normalize_e l) = bs2nat (Sem (Proj 1 0) l).
Proof.
destruct l as [ | v l].
trivial.
simpl.
induction v as [ | [ | ] v IH].
trivial.

*****
IH : eq\n (bs2nat\n (Sem Rev_e\n (cons (Sem RemoveLSZ_e (cons (Sem Rev_e (cons v l)) nil)) nil)))\n (bs2nat v)
l : list (list bool)
v : list bool
*****
eq (bs2nat (Sem Rev_e (cons (Sem RemoveLSZ_e (cons (Sem Rev_e (cons (cons true v) l)) nil)) nil))) (bs2nat (cons true v))
+++++
rewrite bs2nat_true.
-----
Lemma Normalize_correct : forall l, bs2nat (Sem Normalize_e l) = bs2nat (Sem (Proj 1 0) l).
Proof.
destruct l as [ | v l].
trivial.
simpl.
induction v as [ | [ | ] v IH].
trivial.
rewrite bs2nat_true.

*****
IH : eq\n (bs2nat\n (Sem Rev_e\n (cons (Sem RemoveLSZ_e (cons (Sem Rev_e (cons v l)) nil)) nil)))\n (bs2nat v)
l : list (list bool)
v : list bool
*****
eq (bs2nat (Sem Rev_e (cons (Sem RemoveLSZ_e (cons (Sem Rev_e (cons (cons true v) l)) nil)) nil))) (Init.Nat.add (S O) (Init.Nat.mul (S (S O)) (bs2nat v)))
+++++
do 2 rewrite Rev_correct in *.
-----
Lemma Normalize_correct : forall l, bs2nat (Sem Normalize_e l) = bs2nat (Sem (Proj 1 0) l).
Proof.
destruct l as [ | v l].
trivial.
simpl.
induction v as [ | [ | ] v IH].
trivial.
rewrite bs2nat_true.
do 2 rewrite Rev_correct in *.

*****
IH : eq\n (bs2nat\n (rev\n (hd nil\n (cons (Sem RemoveLSZ_e (cons (rev (hd nil (cons v l))) nil))\n nil)))) (bs2nat v)
l : list (list bool)
v : list bool
*****
eq (bs2nat (rev (hd nil (cons (Sem RemoveLSZ_e (cons (rev (hd nil (cons (cons true v) l))) nil)) nil)))) (Init.Nat.add (S O) (Init.Nat.mul (S (S O)) (bs2nat v)))
+++++
simpl in *.
-----
Lemma Normalize_correct : forall l, bs2nat (Sem Normalize_e l) = bs2nat (Sem (Proj 1 0) l).
Proof.
destruct l as [ | v l].
trivial.
simpl.
induction v as [ | [ | ] v IH].
trivial.
rewrite bs2nat_true.
do 2 rewrite Rev_correct in *.
simpl in *.

*****
IH : eq (bs2nat (rev (Sem RemoveLSZ_e (cons (rev v) nil)))) (bs2nat v)
l : list (list bool)
v : list bool
*****
eq (bs2nat (rev (Sem RemoveLSZ_e (cons (app (rev v) (cons true nil)) nil)))) (S (Init.Nat.add (bs2nat v) (Init.Nat.add (bs2nat v) O)))
+++++
rewrite RemoveLSZ_app.
-----
Lemma Normalize_correct : forall l, bs2nat (Sem Normalize_e l) = bs2nat (Sem (Proj 1 0) l).
Proof.
destruct l as [ | v l].
trivial.
simpl.
induction v as [ | [ | ] v IH].
trivial.
rewrite bs2nat_true.
do 2 rewrite Rev_correct in *.
simpl in *.
rewrite RemoveLSZ_app.

*****
IH : eq (bs2nat (rev (Sem RemoveLSZ_e (cons (rev v) nil)))) (bs2nat v)
l : list (list bool)
v : list bool
*****
eq (bs2nat (rev match Sem RemoveLSZ_e (cons (rev v) nil) with | nil => Sem RemoveLSZ_e (cons (cons true nil) nil) | cons b l => app (cons b l) (cons true nil) end)) (S (Init.Nat.add (bs2nat v) (Init.Nat.add (bs2nat v) O)))
+++++
rewrite <- IH.
-----
Lemma Normalize_correct : forall l, bs2nat (Sem Normalize_e l) = bs2nat (Sem (Proj 1 0) l).
Proof.
destruct l as [ | v l].
trivial.
simpl.
induction v as [ | [ | ] v IH].
trivial.
rewrite bs2nat_true.
do 2 rewrite Rev_correct in *.
simpl in *.
rewrite RemoveLSZ_app.
rewrite <- IH.

*****
IH : eq (bs2nat (rev (Sem RemoveLSZ_e (cons (rev v) nil)))) (bs2nat v)
l : list (list bool)
v : list bool
*****
eq (bs2nat (rev match Sem RemoveLSZ_e (cons (rev v) nil) with | nil => Sem RemoveLSZ_e (cons (cons true nil) nil) | cons b l => app (cons b l) (cons true nil) end)) (S (Init.Nat.add (bs2nat (rev (Sem RemoveLSZ_e (cons (rev v) nil)))) (Init.Nat.add (bs2nat (rev (Sem RemoveLSZ_e (cons (rev v) nil)))) O)))
+++++
destruct (Sem RemoveLSZ_e [rev v]).
-----
Lemma Normalize_correct : forall l, bs2nat (Sem Normalize_e l) = bs2nat (Sem (Proj 1 0) l).
Proof.
destruct l as [ | v l].
trivial.
simpl.
induction v as [ | [ | ] v IH].
trivial.
rewrite bs2nat_true.
do 2 rewrite Rev_correct in *.
simpl in *.
rewrite RemoveLSZ_app.
rewrite <- IH.
destruct (Sem RemoveLSZ_e [rev v]).

*****
IH : eq (bs2nat (rev nil)) (bs2nat v)
l : list (list bool)
v : list bool
*****
eq (bs2nat (rev (Sem RemoveLSZ_e (cons (cons true nil) nil)))) (S (Init.Nat.add (bs2nat (rev nil)) (Init.Nat.add (bs2nat (rev nil)) O)))
+++++
trivial.
-----
Lemma Normalize_correct : forall l, bs2nat (Sem Normalize_e l) = bs2nat (Sem (Proj 1 0) l).
Proof.
destruct l as [ | v l].
trivial.
simpl.
induction v as [ | [ | ] v IH].
trivial.
rewrite bs2nat_true.
do 2 rewrite Rev_correct in *.
simpl in *.
rewrite RemoveLSZ_app.
rewrite <- IH.
destruct (Sem RemoveLSZ_e [rev v]).

*****
IH : eq (bs2nat (rev (cons b l0))) (bs2nat v)
l0 : list bool
b : bool
l : list (list bool)
v : list bool
*****
eq (bs2nat (rev (app (cons b l0) (cons true nil)))) (S (Init.Nat.add (bs2nat (rev (cons b l0))) (Init.Nat.add (bs2nat (rev (cons b l0))) O)))
+++++
trivial.
-----
Lemma Normalize_correct : forall l, bs2nat (Sem Normalize_e l) = bs2nat (Sem (Proj 1 0) l).
Proof.
destruct l as [ | v l].
trivial.
simpl.
induction v as [ | [ | ] v IH].
trivial.
rewrite bs2nat_true.
do 2 rewrite Rev_correct in *.
simpl in *.
rewrite RemoveLSZ_app.
rewrite <- IH.
destruct (Sem RemoveLSZ_e [rev v]).
trivial.

*****
IH : eq (bs2nat (rev (cons b l0))) (bs2nat v)
l0 : list bool
b : bool
l : list (list bool)
v : list bool
*****
eq (bs2nat (rev (app (cons b l0) (cons true nil)))) (S (Init.Nat.add (bs2nat (rev (cons b l0))) (Init.Nat.add (bs2nat (rev (cons b l0))) O)))
+++++
simpl.
-----
Lemma Normalize_correct : forall l, bs2nat (Sem Normalize_e l) = bs2nat (Sem (Proj 1 0) l).
Proof.
destruct l as [ | v l].
trivial.
simpl.
induction v as [ | [ | ] v IH].
trivial.
rewrite bs2nat_true.
do 2 rewrite Rev_correct in *.
simpl in *.
rewrite RemoveLSZ_app.
rewrite <- IH.
destruct (Sem RemoveLSZ_e [rev v]).
trivial.
simpl.

*****
IH : eq (bs2nat (rev (cons b l0))) (bs2nat v)
l0 : list bool
b : bool
l : list (list bool)
v : list bool
*****
eq (bs2nat (app (rev (app l0 (cons true nil))) (cons b nil))) (S (Init.Nat.add (bs2nat (app (rev l0) (cons b nil))) (Init.Nat.add (bs2nat (app (rev l0) (cons b nil))) O)))
+++++
rewrite rev_unit.
-----
Lemma Normalize_correct : forall l, bs2nat (Sem Normalize_e l) = bs2nat (Sem (Proj 1 0) l).
Proof.
destruct l as [ | v l].
trivial.
simpl.
induction v as [ | [ | ] v IH].
trivial.
rewrite bs2nat_true.
do 2 rewrite Rev_correct in *.
simpl in *.
rewrite RemoveLSZ_app.
rewrite <- IH.
destruct (Sem RemoveLSZ_e [rev v]).
trivial.
simpl.
rewrite rev_unit.

*****
IH : eq (bs2nat (rev (cons b l0))) (bs2nat v)
l0 : list bool
b : bool
l : list (list bool)
v : list bool
*****
eq (bs2nat (app (cons true (rev l0)) (cons b nil))) (S (Init.Nat.add (bs2nat (app (rev l0) (cons b nil))) (Init.Nat.add (bs2nat (app (rev l0) (cons b nil))) O)))
+++++
trivial.
-----
Lemma Normalize_correct : forall l, bs2nat (Sem Normalize_e l) = bs2nat (Sem (Proj 1 0) l).
Proof.
destruct l as [ | v l].
trivial.
simpl.
induction v as [ | [ | ] v IH].

*****
IH : eq\n (bs2nat\n (Sem Rev_e\n (cons (Sem RemoveLSZ_e (cons (Sem Rev_e (cons v l)) nil)) nil)))\n (bs2nat v)
l : list (list bool)
v : list bool
*****
eq (bs2nat (Sem Rev_e (cons (Sem RemoveLSZ_e (cons (Sem Rev_e (cons (cons false v) l)) nil)) nil))) (bs2nat (cons false v))
+++++
trivial.
-----
Lemma Normalize_correct : forall l, bs2nat (Sem Normalize_e l) = bs2nat (Sem (Proj 1 0) l).
Proof.
destruct l as [ | v l].
trivial.
simpl.
induction v as [ | [ | ] v IH].
trivial.

*****
IH : eq\n (bs2nat\n (Sem Rev_e\n (cons (Sem RemoveLSZ_e (cons (Sem Rev_e (cons v l)) nil)) nil)))\n (bs2nat v)
l : list (list bool)
v : list bool
*****
eq (bs2nat (Sem Rev_e (cons (Sem RemoveLSZ_e (cons (Sem Rev_e (cons (cons false v) l)) nil)) nil))) (bs2nat (cons false v))
+++++
rewrite bs2nat_false.
-----
Lemma Normalize_correct : forall l, bs2nat (Sem Normalize_e l) = bs2nat (Sem (Proj 1 0) l).
Proof.
destruct l as [ | v l].
trivial.
simpl.
induction v as [ | [ | ] v IH].
trivial.
rewrite bs2nat_false.

*****
IH : eq\n (bs2nat\n (Sem Rev_e\n (cons (Sem RemoveLSZ_e (cons (Sem Rev_e (cons v l)) nil)) nil)))\n (bs2nat v)
l : list (list bool)
v : list bool
*****
eq (bs2nat (Sem Rev_e (cons (Sem RemoveLSZ_e (cons (Sem Rev_e (cons (cons false v) l)) nil)) nil))) (Init.Nat.mul (S (S O)) (bs2nat v))
+++++
do 2 rewrite Rev_correct in *.
-----
Lemma Normalize_correct : forall l, bs2nat (Sem Normalize_e l) = bs2nat (Sem (Proj 1 0) l).
Proof.
destruct l as [ | v l].
trivial.
simpl.
induction v as [ | [ | ] v IH].
trivial.
rewrite bs2nat_false.
do 2 rewrite Rev_correct in *.

*****
IH : eq\n (bs2nat\n (rev\n (hd nil\n (cons (Sem RemoveLSZ_e (cons (rev (hd nil (cons v l))) nil))\n nil)))) (bs2nat v)
l : list (list bool)
v : list bool
*****
eq (bs2nat (rev (hd nil (cons (Sem RemoveLSZ_e (cons (rev (hd nil (cons (cons false v) l))) nil)) nil)))) (Init.Nat.mul (S (S O)) (bs2nat v))
+++++
simpl in *.
-----
Lemma Normalize_correct : forall l, bs2nat (Sem Normalize_e l) = bs2nat (Sem (Proj 1 0) l).
Proof.
destruct l as [ | v l].
trivial.
simpl.
induction v as [ | [ | ] v IH].
trivial.
rewrite bs2nat_false.
do 2 rewrite Rev_correct in *.
simpl in *.

*****
IH : eq (bs2nat (rev (Sem RemoveLSZ_e (cons (rev v) nil)))) (bs2nat v)
l : list (list bool)
v : list bool
*****
eq (bs2nat (rev (Sem RemoveLSZ_e (cons (app (rev v) (cons false nil)) nil)))) (Init.Nat.add (bs2nat v) (Init.Nat.add (bs2nat v) O))
+++++
rewrite RemoveLSZ_app.
-----
Lemma Normalize_correct : forall l, bs2nat (Sem Normalize_e l) = bs2nat (Sem (Proj 1 0) l).
Proof.
destruct l as [ | v l].
trivial.
simpl.
induction v as [ | [ | ] v IH].
trivial.
rewrite bs2nat_false.
do 2 rewrite Rev_correct in *.
simpl in *.
rewrite RemoveLSZ_app.

*****
IH : eq (bs2nat (rev (Sem RemoveLSZ_e (cons (rev v) nil)))) (bs2nat v)
l : list (list bool)
v : list bool
*****
eq (bs2nat (rev match Sem RemoveLSZ_e (cons (rev v) nil) with | nil => Sem RemoveLSZ_e (cons (cons false nil) nil) | cons b l => app (cons b l) (cons false nil) end)) (Init.Nat.add (bs2nat v) (Init.Nat.add (bs2nat v) O))
+++++
rewrite <- IH.
-----
Lemma Normalize_correct : forall l, bs2nat (Sem Normalize_e l) = bs2nat (Sem (Proj 1 0) l).
Proof.
destruct l as [ | v l].
trivial.
simpl.
induction v as [ | [ | ] v IH].
trivial.
rewrite bs2nat_false.
do 2 rewrite Rev_correct in *.
simpl in *.
rewrite RemoveLSZ_app.
rewrite <- IH.

*****
IH : eq (bs2nat (rev (Sem RemoveLSZ_e (cons (rev v) nil)))) (bs2nat v)
l : list (list bool)
v : list bool
*****
eq (bs2nat (rev match Sem RemoveLSZ_e (cons (rev v) nil) with | nil => Sem RemoveLSZ_e (cons (cons false nil) nil) | cons b l => app (cons b l) (cons false nil) end)) (Init.Nat.add (bs2nat (rev (Sem RemoveLSZ_e (cons (rev v) nil)))) (Init.Nat.add (bs2nat (rev (Sem RemoveLSZ_e (cons (rev v) nil)))) O))
+++++
destruct (Sem RemoveLSZ_e [rev v]).
-----
Lemma Normalize_correct : forall l, bs2nat (Sem Normalize_e l) = bs2nat (Sem (Proj 1 0) l).
Proof.
destruct l as [ | v l].
trivial.
simpl.
induction v as [ | [ | ] v IH].
trivial.
rewrite bs2nat_false.
do 2 rewrite Rev_correct in *.
simpl in *.
rewrite RemoveLSZ_app.
rewrite <- IH.
destruct (Sem RemoveLSZ_e [rev v]).

*****
IH : eq (bs2nat (rev nil)) (bs2nat v)
l : list (list bool)
v : list bool
*****
eq (bs2nat (rev (Sem RemoveLSZ_e (cons (cons false nil) nil)))) (Init.Nat.add (bs2nat (rev nil)) (Init.Nat.add (bs2nat (rev nil)) O))
+++++
trivial.
-----
Lemma Normalize_correct : forall l, bs2nat (Sem Normalize_e l) = bs2nat (Sem (Proj 1 0) l).
Proof.
destruct l as [ | v l].
trivial.
simpl.
induction v as [ | [ | ] v IH].
trivial.
rewrite bs2nat_false.
do 2 rewrite Rev_correct in *.
simpl in *.
rewrite RemoveLSZ_app.
rewrite <- IH.
destruct (Sem RemoveLSZ_e [rev v]).

*****
IH : eq (bs2nat (rev (cons b l0))) (bs2nat v)
l0 : list bool
b : bool
l : list (list bool)
v : list bool
*****
eq (bs2nat (rev (app (cons b l0) (cons false nil)))) (Init.Nat.add (bs2nat (rev (cons b l0))) (Init.Nat.add (bs2nat (rev (cons b l0))) O))
+++++
trivial.
-----
Lemma Normalize_correct : forall l, bs2nat (Sem Normalize_e l) = bs2nat (Sem (Proj 1 0) l).
Proof.
destruct l as [ | v l].
trivial.
simpl.
induction v as [ | [ | ] v IH].
trivial.
rewrite bs2nat_false.
do 2 rewrite Rev_correct in *.
simpl in *.
rewrite RemoveLSZ_app.
rewrite <- IH.
destruct (Sem RemoveLSZ_e [rev v]).
trivial.

*****
IH : eq (bs2nat (rev (cons b l0))) (bs2nat v)
l0 : list bool
b : bool
l : list (list bool)
v : list bool
*****
eq (bs2nat (rev (app (cons b l0) (cons false nil)))) (Init.Nat.add (bs2nat (rev (cons b l0))) (Init.Nat.add (bs2nat (rev (cons b l0))) O))
+++++
simpl.
-----
Lemma Normalize_correct : forall l, bs2nat (Sem Normalize_e l) = bs2nat (Sem (Proj 1 0) l).
Proof.
destruct l as [ | v l].
trivial.
simpl.
induction v as [ | [ | ] v IH].
trivial.
rewrite bs2nat_false.
do 2 rewrite Rev_correct in *.
simpl in *.
rewrite RemoveLSZ_app.
rewrite <- IH.
destruct (Sem RemoveLSZ_e [rev v]).
trivial.
simpl.

*****
IH : eq (bs2nat (rev (cons b l0))) (bs2nat v)
l0 : list bool
b : bool
l : list (list bool)
v : list bool
*****
eq (bs2nat (app (rev (app l0 (cons false nil))) (cons b nil))) (Init.Nat.add (bs2nat (app (rev l0) (cons b nil))) (Init.Nat.add (bs2nat (app (rev l0) (cons b nil))) O))
+++++
rewrite rev_unit.
-----
Lemma Normalize_correct : forall l, bs2nat (Sem Normalize_e l) = bs2nat (Sem (Proj 1 0) l).
Proof.
destruct l as [ | v l].
trivial.
simpl.
induction v as [ | [ | ] v IH].
trivial.
rewrite bs2nat_false.
do 2 rewrite Rev_correct in *.
simpl in *.
rewrite RemoveLSZ_app.
rewrite <- IH.
destruct (Sem RemoveLSZ_e [rev v]).
trivial.
simpl.
rewrite rev_unit.

*****
IH : eq (bs2nat (rev (cons b l0))) (bs2nat v)
l0 : list bool
b : bool
l : list (list bool)
v : list bool
*****
eq (bs2nat (app (cons false (rev l0)) (cons b nil))) (Init.Nat.add (bs2nat (app (rev l0) (cons b nil))) (Init.Nat.add (bs2nat (app (rev l0) (cons b nil))) O))
+++++
trivial.
-----
Lemma Normalize_correct : forall l, bs2nat (Sem Normalize_e l) = bs2nat (Sem (Proj 1 0) l).
Proof.
destruct l as [ | v l].

*****

*****

+++++
Qed.
-----
Lemma Normalize_normal : forall l,\n  Sem Normalize_e l = nil \/ bs2nat (Sem Normalize_e l) <> 0.
-----
Lemma Normalize_normal : forall l, Sem Normalize_e l = nil \\/ bs2nat (Sem Normalize_e l) <> 0.

*****

*****
forall l : list (list bool), or (eq (Sem Normalize_e l) nil) (not (eq (bs2nat (Sem Normalize_e l)) O))
+++++
Proof.
-----
Lemma Normalize_normal : forall l, Sem Normalize_e l = nil \\/ bs2nat (Sem Normalize_e l) <> 0.
Proof.

*****

*****
forall l : list (list bool), or (eq (Sem Normalize_e l) nil) (not (eq (bs2nat (Sem Normalize_e l)) O))
+++++
destruct l as [ | v l].
-----
Lemma Normalize_normal : forall l, Sem Normalize_e l = nil \\/ bs2nat (Sem Normalize_e l) <> 0.
Proof.
destruct l as [ | v l].

*****

*****
or (eq (Sem Normalize_e nil) nil) (not (eq (bs2nat (Sem Normalize_e nil)) O))
+++++
tauto.
-----
Lemma Normalize_normal : forall l, Sem Normalize_e l = nil \\/ bs2nat (Sem Normalize_e l) <> 0.
Proof.
destruct l as [ | v l].

*****
l : list (list bool)
v : list bool
*****
or (eq (Sem Normalize_e (cons v l)) nil) (not (eq (bs2nat (Sem Normalize_e (cons v l))) O))
+++++
simpl.
-----
Lemma Normalize_normal : forall l, Sem Normalize_e l = nil \\/ bs2nat (Sem Normalize_e l) <> 0.
Proof.
destruct l as [ | v l].
simpl.

*****
l : list (list bool)
v : list bool
*****
or (eq (Sem Rev_e (cons (Sem RemoveLSZ_e (cons (Sem Rev_e (cons v l)) nil)) nil)) nil) (not (eq (bs2nat (Sem Rev_e (cons (Sem RemoveLSZ_e (cons (Sem Rev_e (cons v l)) nil)) nil))) O))
+++++
induction v as [ | [ | ] v IH].
-----
Lemma Normalize_normal : forall l, Sem Normalize_e l = nil \\/ bs2nat (Sem Normalize_e l) <> 0.
Proof.
destruct l as [ | v l].
simpl.
induction v as [ | [ | ] v IH].

*****
l : list (list bool)
*****
or (eq (Sem Rev_e (cons (Sem RemoveLSZ_e (cons (Sem Rev_e (cons nil l)) nil)) nil)) nil) (not (eq (bs2nat (Sem Rev_e (cons (Sem RemoveLSZ_e (cons (Sem Rev_e (cons nil l)) nil)) nil))) O))
+++++
tauto.
-----
Lemma Normalize_normal : forall l, Sem Normalize_e l = nil \\/ bs2nat (Sem Normalize_e l) <> 0.
Proof.
destruct l as [ | v l].
simpl.
induction v as [ | [ | ] v IH].

*****
IH : or\n (eq\n (Sem Rev_e\n (cons (Sem RemoveLSZ_e (cons (Sem Rev_e (cons v l)) nil)) nil))\n nil)\n (not\n (eq\n (bs2nat\n (Sem Rev_e\n (cons (Sem RemoveLSZ_e (cons (Sem Rev_e (cons v l)) nil))\n nil))) O))
l : list (list bool)
v : list bool
*****
or (eq (Sem Rev_e (cons (Sem RemoveLSZ_e (cons (Sem Rev_e (cons (cons true v) l)) nil)) nil)) nil) (not (eq (bs2nat (Sem Rev_e (cons (Sem RemoveLSZ_e (cons (Sem Rev_e (cons (cons true v) l)) nil)) nil))) O))
+++++
do 2 rewrite Rev_correct in *.
-----
Lemma Normalize_normal : forall l, Sem Normalize_e l = nil \\/ bs2nat (Sem Normalize_e l) <> 0.
Proof.
destruct l as [ | v l].
simpl.
induction v as [ | [ | ] v IH].
do 2 rewrite Rev_correct in *.

*****
IH : or\n (eq\n (rev\n (hd nil\n (cons (Sem RemoveLSZ_e (cons (rev (hd nil (cons v l))) nil))\n nil))) nil)\n (not\n (eq\n (bs2nat\n (rev\n (hd nil\n (cons\n (Sem RemoveLSZ_e\n (cons (rev (hd nil (cons v l))) nil)) nil)))) O))
l : list (list bool)
v : list bool
*****
or (eq (rev (hd nil (cons (Sem RemoveLSZ_e (cons (rev (hd nil (cons (cons true v) l))) nil)) nil))) nil) (not (eq (bs2nat (rev (hd nil (cons (Sem RemoveLSZ_e (cons (rev (hd nil (cons (cons true v) l))) nil)) nil)))) O))
+++++
simpl in *.
-----
Lemma Normalize_normal : forall l, Sem Normalize_e l = nil \\/ bs2nat (Sem Normalize_e l) <> 0.
Proof.
destruct l as [ | v l].
simpl.
induction v as [ | [ | ] v IH].
do 2 rewrite Rev_correct in *.
simpl in *.

*****
IH : or (eq (rev (Sem RemoveLSZ_e (cons (rev v) nil))) nil)\n (not (eq (bs2nat (rev (Sem RemoveLSZ_e (cons (rev v) nil)))) O))
l : list (list bool)
v : list bool
*****
or (eq (rev (Sem RemoveLSZ_e (cons (app (rev v) (cons true nil)) nil))) nil) (not (eq (bs2nat (rev (Sem RemoveLSZ_e (cons (app (rev v) (cons true nil)) nil)))) O))
+++++
rewrite RemoveLSZ_app.
-----
Lemma Normalize_normal : forall l, Sem Normalize_e l = nil \\/ bs2nat (Sem Normalize_e l) <> 0.
Proof.
destruct l as [ | v l].
simpl.
induction v as [ | [ | ] v IH].
do 2 rewrite Rev_correct in *.
simpl in *.
rewrite RemoveLSZ_app.

*****
IH : or (eq (rev (Sem RemoveLSZ_e (cons (rev v) nil))) nil)\n (not (eq (bs2nat (rev (Sem RemoveLSZ_e (cons (rev v) nil)))) O))
l : list (list bool)
v : list bool
*****
or (eq (rev match Sem RemoveLSZ_e (cons (rev v) nil) with | nil => Sem RemoveLSZ_e (cons (cons true nil) nil) | cons b l => app (cons b l) (cons true nil) end) nil) (not (eq (bs2nat (rev match Sem RemoveLSZ_e (cons (rev v) nil) with | nil => Sem RemoveLSZ_e (cons (cons true nil) nil) | cons b l => app (cons b l) (cons true nil) end)) O))
+++++
destruct (Sem RemoveLSZ_e [rev v]).
-----
Lemma Normalize_normal : forall l, Sem Normalize_e l = nil \\/ bs2nat (Sem Normalize_e l) <> 0.
Proof.
destruct l as [ | v l].
simpl.
induction v as [ | [ | ] v IH].
do 2 rewrite Rev_correct in *.
simpl in *.
rewrite RemoveLSZ_app.
destruct (Sem RemoveLSZ_e [rev v]).

*****
IH : or (eq (rev nil) nil) (not (eq (bs2nat (rev nil)) O))
l : list (list bool)
v : list bool
*****
or (eq (rev (Sem RemoveLSZ_e (cons (cons true nil) nil))) nil) (not (eq (bs2nat (rev (Sem RemoveLSZ_e (cons (cons true nil) nil)))) O))
+++++
right.
-----
Lemma Normalize_normal : forall l, Sem Normalize_e l = nil \\/ bs2nat (Sem Normalize_e l) <> 0.
Proof.
destruct l as [ | v l].
simpl.
induction v as [ | [ | ] v IH].
do 2 rewrite Rev_correct in *.
simpl in *.
rewrite RemoveLSZ_app.
destruct (Sem RemoveLSZ_e [rev v]).
right.

*****
IH : or (eq (rev nil) nil) (not (eq (bs2nat (rev nil)) O))
l : list (list bool)
v : list bool
*****
not (eq (bs2nat (rev (Sem RemoveLSZ_e (cons (cons true nil) nil)))) O)
+++++
discriminate.
-----
Lemma Normalize_normal : forall l, Sem Normalize_e l = nil \\/ bs2nat (Sem Normalize_e l) <> 0.
Proof.
destruct l as [ | v l].
simpl.
induction v as [ | [ | ] v IH].
do 2 rewrite Rev_correct in *.
simpl in *.
rewrite RemoveLSZ_app.
destruct (Sem RemoveLSZ_e [rev v]).

*****
IH : or (eq (rev (cons b l0)) nil) (not (eq (bs2nat (rev (cons b l0))) O))
l0 : list bool
b : bool
l : list (list bool)
v : list bool
*****
or (eq (rev (app (cons b l0) (cons true nil))) nil) (not (eq (bs2nat (rev (app (cons b l0) (cons true nil)))) O))
+++++
right.
-----
Lemma Normalize_normal : forall l, Sem Normalize_e l = nil \\/ bs2nat (Sem Normalize_e l) <> 0.
Proof.
destruct l as [ | v l].
simpl.
induction v as [ | [ | ] v IH].
do 2 rewrite Rev_correct in *.
simpl in *.
rewrite RemoveLSZ_app.
destruct (Sem RemoveLSZ_e [rev v]).
right.

*****
IH : or (eq (rev (cons b l0)) nil) (not (eq (bs2nat (rev (cons b l0))) O))
l0 : list bool
b : bool
l : list (list bool)
v : list bool
*****
not (eq (bs2nat (rev (app (cons b l0) (cons true nil)))) O)
+++++
simpl.
-----
Lemma Normalize_normal : forall l, Sem Normalize_e l = nil \\/ bs2nat (Sem Normalize_e l) <> 0.
Proof.
destruct l as [ | v l].
simpl.
induction v as [ | [ | ] v IH].
do 2 rewrite Rev_correct in *.
simpl in *.
rewrite RemoveLSZ_app.
destruct (Sem RemoveLSZ_e [rev v]).
right.
simpl.

*****
IH : or (eq (rev (cons b l0)) nil) (not (eq (bs2nat (rev (cons b l0))) O))
l0 : list bool
b : bool
l : list (list bool)
v : list bool
*****
not (eq (bs2nat (app (rev (app l0 (cons true nil))) (cons b nil))) O)
+++++
rewrite rev_unit.
-----
Lemma Normalize_normal : forall l, Sem Normalize_e l = nil \\/ bs2nat (Sem Normalize_e l) <> 0.
Proof.
destruct l as [ | v l].
simpl.
induction v as [ | [ | ] v IH].
do 2 rewrite Rev_correct in *.
simpl in *.
rewrite RemoveLSZ_app.
destruct (Sem RemoveLSZ_e [rev v]).
right.
simpl.
rewrite rev_unit.

*****
IH : or (eq (rev (cons b l0)) nil) (not (eq (bs2nat (rev (cons b l0))) O))
l0 : list bool
b : bool
l : list (list bool)
v : list bool
*****
not (eq (bs2nat (app (cons true (rev l0)) (cons b nil))) O)
+++++
discriminate.
-----
Lemma Normalize_normal : forall l, Sem Normalize_e l = nil \\/ bs2nat (Sem Normalize_e l) <> 0.
Proof.
destruct l as [ | v l].
simpl.
induction v as [ | [ | ] v IH].

*****
IH : or\n (eq\n (Sem Rev_e\n (cons (Sem RemoveLSZ_e (cons (Sem Rev_e (cons v l)) nil)) nil))\n nil)\n (not\n (eq\n (bs2nat\n (Sem Rev_e\n (cons (Sem RemoveLSZ_e (cons (Sem Rev_e (cons v l)) nil))\n nil))) O))
l : list (list bool)
v : list bool
*****
or (eq (Sem Rev_e (cons (Sem RemoveLSZ_e (cons (Sem Rev_e (cons (cons false v) l)) nil)) nil)) nil) (not (eq (bs2nat (Sem Rev_e (cons (Sem RemoveLSZ_e (cons (Sem Rev_e (cons (cons false v) l)) nil)) nil))) O))
+++++
do 2 rewrite Rev_correct in *.
-----
Lemma Normalize_normal : forall l, Sem Normalize_e l = nil \\/ bs2nat (Sem Normalize_e l) <> 0.
Proof.
destruct l as [ | v l].
simpl.
induction v as [ | [ | ] v IH].
do 2 rewrite Rev_correct in *.

*****
IH : or\n (eq\n (rev\n (hd nil\n (cons (Sem RemoveLSZ_e (cons (rev (hd nil (cons v l))) nil))\n nil))) nil)\n (not\n (eq\n (bs2nat\n (rev\n (hd nil\n (cons\n (Sem RemoveLSZ_e\n (cons (rev (hd nil (cons v l))) nil)) nil)))) O))
l : list (list bool)
v : list bool
*****
or (eq (rev (hd nil (cons (Sem RemoveLSZ_e (cons (rev (hd nil (cons (cons false v) l))) nil)) nil))) nil) (not (eq (bs2nat (rev (hd nil (cons (Sem RemoveLSZ_e (cons (rev (hd nil (cons (cons false v) l))) nil)) nil)))) O))
+++++
simpl in *.
-----
Lemma Normalize_normal : forall l, Sem Normalize_e l = nil \\/ bs2nat (Sem Normalize_e l) <> 0.
Proof.
destruct l as [ | v l].
simpl.
induction v as [ | [ | ] v IH].
do 2 rewrite Rev_correct in *.
simpl in *.

*****
IH : or (eq (rev (Sem RemoveLSZ_e (cons (rev v) nil))) nil)\n (not (eq (bs2nat (rev (Sem RemoveLSZ_e (cons (rev v) nil)))) O))
l : list (list bool)
v : list bool
*****
or (eq (rev (Sem RemoveLSZ_e (cons (app (rev v) (cons false nil)) nil))) nil) (not (eq (bs2nat (rev (Sem RemoveLSZ_e (cons (app (rev v) (cons false nil)) nil)))) O))
+++++
rewrite RemoveLSZ_app.
-----
Lemma Normalize_normal : forall l, Sem Normalize_e l = nil \\/ bs2nat (Sem Normalize_e l) <> 0.
Proof.
destruct l as [ | v l].
simpl.
induction v as [ | [ | ] v IH].
do 2 rewrite Rev_correct in *.
simpl in *.
rewrite RemoveLSZ_app.

*****
IH : or (eq (rev (Sem RemoveLSZ_e (cons (rev v) nil))) nil)\n (not (eq (bs2nat (rev (Sem RemoveLSZ_e (cons (rev v) nil)))) O))
l : list (list bool)
v : list bool
*****
or (eq (rev match Sem RemoveLSZ_e (cons (rev v) nil) with | nil => Sem RemoveLSZ_e (cons (cons false nil) nil) | cons b l => app (cons b l) (cons false nil) end) nil) (not (eq (bs2nat (rev match Sem RemoveLSZ_e (cons (rev v) nil) with | nil => Sem RemoveLSZ_e (cons (cons false nil) nil) | cons b l => app (cons b l) (cons false nil) end)) O))
+++++
destruct (Sem RemoveLSZ_e [rev v]).
-----
Lemma Normalize_normal : forall l, Sem Normalize_e l = nil \\/ bs2nat (Sem Normalize_e l) <> 0.
Proof.
destruct l as [ | v l].
simpl.
induction v as [ | [ | ] v IH].
do 2 rewrite Rev_correct in *.
simpl in *.
rewrite RemoveLSZ_app.
destruct (Sem RemoveLSZ_e [rev v]).

*****
IH : or (eq (rev nil) nil) (not (eq (bs2nat (rev nil)) O))
l : list (list bool)
v : list bool
*****
or (eq (rev (Sem RemoveLSZ_e (cons (cons false nil) nil))) nil) (not (eq (bs2nat (rev (Sem RemoveLSZ_e (cons (cons false nil) nil)))) O))
+++++
trivial.
-----
Lemma Normalize_normal : forall l, Sem Normalize_e l = nil \\/ bs2nat (Sem Normalize_e l) <> 0.
Proof.
destruct l as [ | v l].
simpl.
induction v as [ | [ | ] v IH].
do 2 rewrite Rev_correct in *.
simpl in *.
rewrite RemoveLSZ_app.
destruct (Sem RemoveLSZ_e [rev v]).

*****
IH : or (eq (rev (cons b l0)) nil) (not (eq (bs2nat (rev (cons b l0))) O))
l0 : list bool
b : bool
l : list (list bool)
v : list bool
*****
or (eq (rev (app (cons b l0) (cons false nil))) nil) (not (eq (bs2nat (rev (app (cons b l0) (cons false nil)))) O))
+++++
simpl in *.
-----
Lemma Normalize_normal : forall l, Sem Normalize_e l = nil \\/ bs2nat (Sem Normalize_e l) <> 0.
Proof.
destruct l as [ | v l].
simpl.
induction v as [ | [ | ] v IH].
do 2 rewrite Rev_correct in *.
simpl in *.
rewrite RemoveLSZ_app.
destruct (Sem RemoveLSZ_e [rev v]).
simpl in *.

*****
IH : or (eq (app (rev l0) (cons b nil)) nil)\n (not (eq (bs2nat (app (rev l0) (cons b nil))) O))
l0 : list bool
b : bool
l : list (list bool)
v : list bool
*****
or (eq (app (rev (app l0 (cons false nil))) (cons b nil)) nil) (not (eq (bs2nat (app (rev (app l0 (cons false nil))) (cons b nil))) O))
+++++
rewrite rev_unit.
-----
Lemma Normalize_normal : forall l, Sem Normalize_e l = nil \\/ bs2nat (Sem Normalize_e l) <> 0.
Proof.
destruct l as [ | v l].
simpl.
induction v as [ | [ | ] v IH].
do 2 rewrite Rev_correct in *.
simpl in *.
rewrite RemoveLSZ_app.
destruct (Sem RemoveLSZ_e [rev v]).
simpl in *.
rewrite rev_unit.

*****
IH : or (eq (app (rev l0) (cons b nil)) nil)\n (not (eq (bs2nat (app (rev l0) (cons b nil))) O))
l0 : list bool
b : bool
l : list (list bool)
v : list bool
*****
or (eq (app (cons false (rev l0)) (cons b nil)) nil) (not (eq (bs2nat (app (cons false (rev l0)) (cons b nil))) O))
+++++
simpl.
-----
Lemma Normalize_normal : forall l, Sem Normalize_e l = nil \\/ bs2nat (Sem Normalize_e l) <> 0.
Proof.
destruct l as [ | v l].
simpl.
induction v as [ | [ | ] v IH].
do 2 rewrite Rev_correct in *.
simpl in *.
rewrite RemoveLSZ_app.
destruct (Sem RemoveLSZ_e [rev v]).
simpl in *.
rewrite rev_unit.
simpl.

*****
IH : or (eq (app (rev l0) (cons b nil)) nil)\n (not (eq (bs2nat (app (rev l0) (cons b nil))) O))
l0 : list bool
b : bool
l : list (list bool)
v : list bool
*****
or (eq (cons false (app (rev l0) (cons b nil))) nil) (not (eq (bs2nat (cons false (app (rev l0) (cons b nil)))) O))
+++++
right.
-----
Lemma Normalize_normal : forall l, Sem Normalize_e l = nil \\/ bs2nat (Sem Normalize_e l) <> 0.
Proof.
destruct l as [ | v l].
simpl.
induction v as [ | [ | ] v IH].
do 2 rewrite Rev_correct in *.
simpl in *.
rewrite RemoveLSZ_app.
destruct (Sem RemoveLSZ_e [rev v]).
simpl in *.
rewrite rev_unit.
simpl.
right.

*****
IH : or (eq (app (rev l0) (cons b nil)) nil)\n (not (eq (bs2nat (app (rev l0) (cons b nil))) O))
l0 : list bool
b : bool
l : list (list bool)
v : list bool
*****
not (eq (bs2nat (cons false (app (rev l0) (cons b nil)))) O)
+++++
rewrite bs2nat_false.
-----
Lemma Normalize_normal : forall l, Sem Normalize_e l = nil \\/ bs2nat (Sem Normalize_e l) <> 0.
Proof.
destruct l as [ | v l].
simpl.
induction v as [ | [ | ] v IH].
do 2 rewrite Rev_correct in *.
simpl in *.
rewrite RemoveLSZ_app.
destruct (Sem RemoveLSZ_e [rev v]).
simpl in *.
rewrite rev_unit.
simpl.
right.
rewrite bs2nat_false.

*****
IH : or (eq (app (rev l0) (cons b nil)) nil)\n (not (eq (bs2nat (app (rev l0) (cons b nil))) O))
l0 : list bool
b : bool
l : list (list bool)
v : list bool
*****
not (eq (Init.Nat.mul (S (S O)) (bs2nat (app (rev l0) (cons b nil)))) O)
+++++
destruct IH as [IH | IH].
-----
Lemma Normalize_normal : forall l, Sem Normalize_e l = nil \\/ bs2nat (Sem Normalize_e l) <> 0.
Proof.
destruct l as [ | v l].
simpl.
induction v as [ | [ | ] v IH].
do 2 rewrite Rev_correct in *.
simpl in *.
rewrite RemoveLSZ_app.
destruct (Sem RemoveLSZ_e [rev v]).
simpl in *.
rewrite rev_unit.
simpl.
right.
rewrite bs2nat_false.
destruct IH as [IH | IH].

*****
IH : eq (app (rev l0) (cons b nil)) nil
l0 : list bool
b : bool
l : list (list bool)
v : list bool
*****
not (eq (Init.Nat.mul (S (S O)) (bs2nat (app (rev l0) (cons b nil)))) O)
+++++
apply app_eq_nil in IH.
-----
Lemma Normalize_normal : forall l, Sem Normalize_e l = nil \\/ bs2nat (Sem Normalize_e l) <> 0.
Proof.
destruct l as [ | v l].
simpl.
induction v as [ | [ | ] v IH].
do 2 rewrite Rev_correct in *.
simpl in *.
rewrite RemoveLSZ_app.
destruct (Sem RemoveLSZ_e [rev v]).
simpl in *.
rewrite rev_unit.
simpl.
right.
rewrite bs2nat_false.
destruct IH as [IH | IH].
apply app_eq_nil in IH.

*****
IH : and (eq (rev l0) nil) (eq (cons b nil) nil)
l0 : list bool
b : bool
l : list (list bool)
v : list bool
*****
not (eq (Init.Nat.mul (S (S O)) (bs2nat (app (rev l0) (cons b nil)))) O)
+++++
destruct IH as [_ IH].
-----
Lemma Normalize_normal : forall l, Sem Normalize_e l = nil \\/ bs2nat (Sem Normalize_e l) <> 0.
Proof.
destruct l as [ | v l].
simpl.
induction v as [ | [ | ] v IH].
do 2 rewrite Rev_correct in *.
simpl in *.
rewrite RemoveLSZ_app.
destruct (Sem RemoveLSZ_e [rev v]).
simpl in *.
rewrite rev_unit.
simpl.
right.
rewrite bs2nat_false.
destruct IH as [IH | IH].
apply app_eq_nil in IH.
destruct IH as [_ IH].

*****
IH : eq (cons b nil) nil
l0 : list bool
b : bool
l : list (list bool)
v : list bool
*****
not (eq (Init.Nat.mul (S (S O)) (bs2nat (app (rev l0) (cons b nil)))) O)
+++++
congruence.
-----
Lemma Normalize_normal : forall l, Sem Normalize_e l = nil \\/ bs2nat (Sem Normalize_e l) <> 0.
Proof.
destruct l as [ | v l].
simpl.
induction v as [ | [ | ] v IH].
do 2 rewrite Rev_correct in *.
simpl in *.
rewrite RemoveLSZ_app.
destruct (Sem RemoveLSZ_e [rev v]).
simpl in *.
rewrite rev_unit.
simpl.
right.
rewrite bs2nat_false.
destruct IH as [IH | IH].

*****
IH : not (eq (bs2nat (app (rev l0) (cons b nil))) O)
l0 : list bool
b : bool
l : list (list bool)
v : list bool
*****
not (eq (Init.Nat.mul (S (S O)) (bs2nat (app (rev l0) (cons b nil)))) O)
+++++
omega.
-----
Lemma Normalize_normal : forall l, Sem Normalize_e l = nil \\/ bs2nat (Sem Normalize_e l) <> 0.
Proof.
destruct l as [ | v l].

*****

*****

+++++
Qed.
-----
Opaque Normalize_e.
-----
Definition Succ_e : Cobham :=\n  Rec\n    (Comp 0 (Succ true) [Zero])\n    (Comp 2 (Succ true) [Proj 2 0])\n    (Comp 2 (Succ false) [Proj 2 1])\n    (Comp 1 (Succ true) [Proj 1 0]).
-----
Lemma arity_Succ : arity Succ_e = ok_arity 1.
-----
Lemma arity_Succ : arity Succ_e = ok_arity 1.

*****

*****
eq (arity Succ_e) (ok_arity (S O))
+++++
Proof.
-----
Lemma arity_Succ : arity Succ_e = ok_arity 1.
Proof.

*****

*****
eq (arity Succ_e) (ok_arity (S O))
+++++
trivial.
-----
Lemma arity_Succ : arity Succ_e = ok_arity 1.
Proof.
trivial.

*****

*****

+++++
Qed.
-----
Lemma length_Succ : forall l,\n  length (Sem Succ_e l) <= length (Sem (Comp 1 (Succ true) [Proj 1 0]) l).
-----
Lemma length_Succ : forall l, length (Sem Succ_e l) <= length (Sem (Comp 1 (Succ true) [Proj 1 0]) l).

*****

*****
forall l : list (list bool), le (length (Sem Succ_e l)) (length (Sem (Comp (S O) (Succ true) (cons (Proj (S O) O) nil)) l))
+++++
Proof.
-----
Lemma length_Succ : forall l, length (Sem Succ_e l) <= length (Sem (Comp 1 (Succ true) [Proj 1 0]) l).
Proof.

*****

*****
forall l : list (list bool), le (length (Sem Succ_e l)) (length (Sem (Comp (S O) (Succ true) (cons (Proj (S O) O) nil)) l))
+++++
destruct l as [ | v l].
-----
Lemma length_Succ : forall l, length (Sem Succ_e l) <= length (Sem (Comp 1 (Succ true) [Proj 1 0]) l).
Proof.
destruct l as [ | v l].

*****

*****
le (length (Sem Succ_e nil)) (length (Sem (Comp (S O) (Succ true) (cons (Proj (S O) O) nil)) nil))
+++++
trivial.
-----
Lemma length_Succ : forall l, length (Sem Succ_e l) <= length (Sem (Comp 1 (Succ true) [Proj 1 0]) l).
Proof.
destruct l as [ | v l].

*****
l : list (list bool)
v : list bool
*****
le (length (Sem Succ_e (cons v l))) (length (Sem (Comp (S O) (Succ true) (cons (Proj (S O) O) nil)) (cons v l)))
+++++
trivial.
-----
Lemma length_Succ : forall l, length (Sem Succ_e l) <= length (Sem (Comp 1 (Succ true) [Proj 1 0]) l).
Proof.
destruct l as [ | v l].
trivial.

*****
l : list (list bool)
v : list bool
*****
le (length (Sem Succ_e (cons v l))) (length (Sem (Comp (S O) (Succ true) (cons (Proj (S O) O) nil)) (cons v l)))
+++++
simpl.
-----
Lemma length_Succ : forall l, length (Sem Succ_e l) <= length (Sem (Comp 1 (Succ true) [Proj 1 0]) l).
Proof.
destruct l as [ | v l].
trivial.
simpl.

*****
l : list (list bool)
v : list bool
*****
le (length (sem_Rec (fun _ : list (list bool) => cons true nil) (fun vl : list (list bool) => cons true (nth O vl nil)) (fun vl : list (list bool) => cons false (nth (S O) vl nil)) v l)) (S (length v))
+++++
induction v as [ | [ | ] v IH].
-----
Lemma length_Succ : forall l, length (Sem Succ_e l) <= length (Sem (Comp 1 (Succ true) [Proj 1 0]) l).
Proof.
destruct l as [ | v l].
trivial.
simpl.
induction v as [ | [ | ] v IH].

*****
l : list (list bool)
*****
le (length (sem_Rec (fun _ : list (list bool) => cons true nil) (fun vl : list (list bool) => cons true (nth O vl nil)) (fun vl : list (list bool) => cons false (nth (S O) vl nil)) nil l)) (S (length nil))
+++++
trivial.
-----
Lemma length_Succ : forall l, length (Sem Succ_e l) <= length (Sem (Comp 1 (Succ true) [Proj 1 0]) l).
Proof.
destruct l as [ | v l].
trivial.
simpl.
induction v as [ | [ | ] v IH].

*****
IH : le\n (length\n (sem_Rec (fun _ : list (list bool) => cons true nil)\n (fun vl : list (list bool) => cons true (nth O vl nil))\n (fun vl : list (list bool) => cons false (nth (S O) vl nil)) v\n l)) (S (length v))
l : list (list bool)
v : list bool
*****
le (length (sem_Rec (fun _ : list (list bool) => cons true nil) (fun vl : list (list bool) => cons true (nth O vl nil)) (fun vl : list (list bool) => cons false (nth (S O) vl nil)) (cons true v) l)) (S (length (cons true v)))
+++++
trivial.
-----
Lemma length_Succ : forall l, length (Sem Succ_e l) <= length (Sem (Comp 1 (Succ true) [Proj 1 0]) l).
Proof.
destruct l as [ | v l].
trivial.
simpl.
induction v as [ | [ | ] v IH].
trivial.

*****
IH : le\n (length\n (sem_Rec (fun _ : list (list bool) => cons true nil)\n (fun vl : list (list bool) => cons true (nth O vl nil))\n (fun vl : list (list bool) => cons false (nth (S O) vl nil)) v\n l)) (S (length v))
l : list (list bool)
v : list bool
*****
le (length (sem_Rec (fun _ : list (list bool) => cons true nil) (fun vl : list (list bool) => cons true (nth O vl nil)) (fun vl : list (list bool) => cons false (nth (S O) vl nil)) (cons true v) l)) (S (length (cons true v)))
+++++
simpl.
-----
Lemma length_Succ : forall l, length (Sem Succ_e l) <= length (Sem (Comp 1 (Succ true) [Proj 1 0]) l).
Proof.
destruct l as [ | v l].
trivial.
simpl.
induction v as [ | [ | ] v IH].
trivial.
simpl.

*****
IH : le\n (length\n (sem_Rec (fun _ : list (list bool) => cons true nil)\n (fun vl : list (list bool) => cons true (nth O vl nil))\n (fun vl : list (list bool) => cons false (nth (S O) vl nil)) v\n l)) (S (length v))
l : list (list bool)
v : list bool
*****
le (S (length (sem_Rec (fun _ : list (list bool) => cons true nil) (fun vl : list (list bool) => cons true (nth O vl nil)) (fun vl : list (list bool) => cons false (nth (S O) vl nil)) v l))) (S (S (length v)))
+++++
omega.
-----
Lemma length_Succ : forall l, length (Sem Succ_e l) <= length (Sem (Comp 1 (Succ true) [Proj 1 0]) l).
Proof.
destruct l as [ | v l].
trivial.
simpl.
induction v as [ | [ | ] v IH].

*****
IH : le\n (length\n (sem_Rec (fun _ : list (list bool) => cons true nil)\n (fun vl : list (list bool) => cons true (nth O vl nil))\n (fun vl : list (list bool) => cons false (nth (S O) vl nil)) v\n l)) (S (length v))
l : list (list bool)
v : list bool
*****
le (length (sem_Rec (fun _ : list (list bool) => cons true nil) (fun vl : list (list bool) => cons true (nth O vl nil)) (fun vl : list (list bool) => cons false (nth (S O) vl nil)) (cons false v) l)) (S (length (cons false v)))
+++++
trivial.
-----
Lemma length_Succ : forall l, length (Sem Succ_e l) <= length (Sem (Comp 1 (Succ true) [Proj 1 0]) l).
Proof.
destruct l as [ | v l].
trivial.
simpl.
induction v as [ | [ | ] v IH].
trivial.

*****
IH : le\n (length\n (sem_Rec (fun _ : list (list bool) => cons true nil)\n (fun vl : list (list bool) => cons true (nth O vl nil))\n (fun vl : list (list bool) => cons false (nth (S O) vl nil)) v\n l)) (S (length v))
l : list (list bool)
v : list bool
*****
le (length (sem_Rec (fun _ : list (list bool) => cons true nil) (fun vl : list (list bool) => cons true (nth O vl nil)) (fun vl : list (list bool) => cons false (nth (S O) vl nil)) (cons false v) l)) (S (length (cons false v)))
+++++
simpl.
-----
Lemma length_Succ : forall l, length (Sem Succ_e l) <= length (Sem (Comp 1 (Succ true) [Proj 1 0]) l).
Proof.
destruct l as [ | v l].
trivial.
simpl.
induction v as [ | [ | ] v IH].
trivial.
simpl.

*****
IH : le\n (length\n (sem_Rec (fun _ : list (list bool) => cons true nil)\n (fun vl : list (list bool) => cons true (nth O vl nil))\n (fun vl : list (list bool) => cons false (nth (S O) vl nil)) v\n l)) (S (length v))
l : list (list bool)
v : list bool
*****
le (S (length v)) (S (S (length v)))
+++++
omega.
-----
Lemma length_Succ : forall l, length (Sem Succ_e l) <= length (Sem (Comp 1 (Succ true) [Proj 1 0]) l).
Proof.
destruct l as [ | v l].

*****

*****

+++++
Qed.
-----
Lemma le_1_length_Succ v : \n  1 <= length (Sem Succ_e [v]).
-----
Lemma le_1_length_Succ v : 1 <= length (Sem Succ_e [v]).

*****
v : list bool
*****
le (S O) (length (Sem Succ_e (cons v nil)))
+++++
Proof.
-----
Lemma le_1_length_Succ v : 1 <= length (Sem Succ_e [v]).
Proof.

*****
v : list bool
*****
le (S O) (length (Sem Succ_e (cons v nil)))
+++++
destruct v as [ | [ | ] v].
-----
Lemma le_1_length_Succ v : 1 <= length (Sem Succ_e [v]).
Proof.
destruct v as [ | [ | ] v].

*****

*****
le (S O) (length (Sem Succ_e (cons nil nil)))
+++++
trivial.
-----
Lemma le_1_length_Succ v : 1 <= length (Sem Succ_e [v]).
Proof.
destruct v as [ | [ | ] v].

*****
v : list bool
*****
le (S O) (length (Sem Succ_e (cons (cons true v) nil)))
+++++
trivial.
-----
Lemma le_1_length_Succ v : 1 <= length (Sem Succ_e [v]).
Proof.
destruct v as [ | [ | ] v].
trivial.

*****
v : list bool
*****
le (S O) (length (Sem Succ_e (cons (cons true v) nil)))
+++++
simpl.
-----
Lemma le_1_length_Succ v : 1 <= length (Sem Succ_e [v]).
Proof.
destruct v as [ | [ | ] v].
trivial.
simpl.

*****
v : list bool
*****
le (S O) (S (length (sem_Rec (fun _ : list (list bool) => cons true nil) (fun vl : list (list bool) => cons true (nth O vl nil)) (fun vl : list (list bool) => cons false (nth (S O) vl nil)) v nil)))
+++++
omega.
-----
Lemma le_1_length_Succ v : 1 <= length (Sem Succ_e [v]).
Proof.
destruct v as [ | [ | ] v].

*****
v : list bool
*****
le (S O) (length (Sem Succ_e (cons (cons false v) nil)))
+++++
trivial.
-----
Lemma le_1_length_Succ v : 1 <= length (Sem Succ_e [v]).
Proof.
destruct v as [ | [ | ] v].
trivial.

*****
v : list bool
*****
le (S O) (length (Sem Succ_e (cons (cons false v) nil)))
+++++
simpl.
-----
Lemma le_1_length_Succ v : 1 <= length (Sem Succ_e [v]).
Proof.
destruct v as [ | [ | ] v].
trivial.
simpl.

*****
v : list bool
*****
le (S O) (S (length v))
+++++
omega.
-----
Lemma le_1_length_Succ v : 1 <= length (Sem Succ_e [v]).
Proof.
destruct v as [ | [ | ] v].

*****

*****

+++++
Qed.
-----
Lemma le_length_Succ v :\n  length v <= length (Sem Succ_e [v]).
-----
Lemma le_length_Succ v : length v <= length (Sem Succ_e [v]).

*****
v : list bool
*****
le (length v) (length (Sem Succ_e (cons v nil)))
+++++
Proof.
-----
Lemma le_length_Succ v : length v <= length (Sem Succ_e [v]).
Proof.

*****
v : list bool
*****
le (length v) (length (Sem Succ_e (cons v nil)))
+++++
induction v as [ | [ | ] v IH].
-----
Lemma le_length_Succ v : length v <= length (Sem Succ_e [v]).
Proof.
induction v as [ | [ | ] v IH].

*****

*****
le (length nil) (length (Sem Succ_e (cons nil nil)))
+++++
simpl.
-----
Lemma le_length_Succ v : length v <= length (Sem Succ_e [v]).
Proof.
induction v as [ | [ | ] v IH].
simpl.

*****

*****
le O (S O)
+++++
omega.
-----
Lemma le_length_Succ v : length v <= length (Sem Succ_e [v]).
Proof.
induction v as [ | [ | ] v IH].

*****
IH : le (length v) (length (Sem Succ_e (cons v nil)))
v : list bool
*****
le (length (cons true v)) (length (Sem Succ_e (cons (cons true v) nil)))
+++++
simpl in *.
-----
Lemma le_length_Succ v : length v <= length (Sem Succ_e [v]).
Proof.
induction v as [ | [ | ] v IH].
simpl in *.

*****
IH : le (length v)\n (length\n (sem_Rec (fun _ : list (list bool) => cons true nil)\n (fun vl : list (list bool) => cons true (nth O vl nil))\n (fun vl : list (list bool) => cons false (nth (S O) vl nil)) v\n nil))
v : list bool
*****
le (S (length v)) (S (length (sem_Rec (fun _ : list (list bool) => cons true nil) (fun vl : list (list bool) => cons true (nth O vl nil)) (fun vl : list (list bool) => cons false (nth (S O) vl nil)) v nil)))
+++++
omega.
-----
Lemma le_length_Succ v : length v <= length (Sem Succ_e [v]).
Proof.
induction v as [ | [ | ] v IH].

*****
IH : le (length v) (length (Sem Succ_e (cons v nil)))
v : list bool
*****
le (length (cons false v)) (length (Sem Succ_e (cons (cons false v) nil)))
+++++
trivial.
-----
Lemma le_length_Succ v : length v <= length (Sem Succ_e [v]).
Proof.
induction v as [ | [ | ] v IH].

*****

*****

+++++
Qed.
-----
Lemma Succ_length v :\n  length (Sem Succ_e v) <= S (length (hd nil v)).
-----
Lemma Succ_length v : length (Sem Succ_e v) <= S (length (hd nil v)).

*****
v : list (list bool)
*****
le (length (Sem Succ_e v)) (S (length (hd nil v)))
+++++
Proof.
-----
Lemma Succ_length v : length (Sem Succ_e v) <= S (length (hd nil v)).
Proof.

*****
v : list (list bool)
*****
le (length (Sem Succ_e v)) (S (length (hd nil v)))
+++++
intros.
-----
Lemma Succ_length v : length (Sem Succ_e v) <= S (length (hd nil v)).
Proof.
intros.

*****
v : list (list bool)
*****
le (length (Sem Succ_e v)) (S (length (hd nil v)))
+++++
simpl.
-----
Lemma Succ_length v : length (Sem Succ_e v) <= S (length (hd nil v)).
Proof.
intros.
simpl.

*****
v : list (list bool)
*****
le (length (sem_Rec (fun _ : list (list bool) => cons true nil) (fun vl : list (list bool) => cons true (nth O vl nil)) (fun vl : list (list bool) => cons false (nth (S O) vl nil)) (hd nil v) (tl v))) (S (length (hd nil v)))
+++++
induction (hd nil v).
-----
Lemma Succ_length v : length (Sem Succ_e v) <= S (length (hd nil v)).
Proof.
intros.
simpl.
induction (hd nil v).

*****
v : list (list bool)
*****
le (length (sem_Rec (fun _ : list (list bool) => cons true nil) (fun vl : list (list bool) => cons true (nth O vl nil)) (fun vl : list (list bool) => cons false (nth (S O) vl nil)) nil (tl v))) (S (length nil))
+++++
simpl.
-----
Lemma Succ_length v : length (Sem Succ_e v) <= S (length (hd nil v)).
Proof.
intros.
simpl.
induction (hd nil v).
simpl.

*****
v : list (list bool)
*****
le (S O) (S O)
+++++
auto.
-----
Lemma Succ_length v : length (Sem Succ_e v) <= S (length (hd nil v)).
Proof.
intros.
simpl.
induction (hd nil v).

*****
IHl : le\n (length\n (sem_Rec (fun _ : list (list bool) => cons true nil)\n (fun vl : list (list bool) => cons true (nth O vl nil))\n (fun vl : list (list bool) => cons false (nth (S O) vl nil)) l\n (tl v))) (S (length l))
l : list bool
a : bool
v : list (list bool)
*****
le (length (sem_Rec (fun _ : list (list bool) => cons true nil) (fun vl : list (list bool) => cons true (nth O vl nil)) (fun vl : list (list bool) => cons false (nth (S O) vl nil)) (cons a l) (tl v))) (S (length (cons a l)))
+++++
simpl.
-----
Lemma Succ_length v : length (Sem Succ_e v) <= S (length (hd nil v)).
Proof.
intros.
simpl.
induction (hd nil v).
simpl.

*****
IHl : le\n (length\n (sem_Rec (fun _ : list (list bool) => cons true nil)\n (fun vl : list (list bool) => cons true (nth O vl nil))\n (fun vl : list (list bool) => cons false (nth (S O) vl nil)) l\n (tl v))) (S (length l))
l : list bool
a : bool
v : list (list bool)
*****
le (length (if a then cons false (sem_Rec (fun _ : list (list bool) => cons true nil) (fun vl : list (list bool) => cons true (nth O vl nil)) (fun vl : list (list bool) => cons false (nth (S O) vl nil)) l (tl v)) else cons true l)) (S (S (length l)))
+++++
auto.
-----
Lemma Succ_length v : length (Sem Succ_e v) <= S (length (hd nil v)).
Proof.
intros.
simpl.
induction (hd nil v).
simpl.
auto.

*****
IHl : le\n (length\n (sem_Rec (fun _ : list (list bool) => cons true nil)\n (fun vl : list (list bool) => cons true (nth O vl nil))\n (fun vl : list (list bool) => cons false (nth (S O) vl nil)) l\n (tl v))) (S (length l))
l : list bool
a : bool
v : list (list bool)
*****
le (length (if a then cons false (sem_Rec (fun _ : list (list bool) => cons true nil) (fun vl : list (list bool) => cons true (nth O vl nil)) (fun vl : list (list bool) => cons false (nth (S O) vl nil)) l (tl v)) else cons true l)) (S (S (length l)))
+++++
case a.
-----
Lemma Succ_length v : length (Sem Succ_e v) <= S (length (hd nil v)).
Proof.
intros.
simpl.
induction (hd nil v).
simpl.
auto.
case a.

*****
IHl : le\n (length\n (sem_Rec (fun _ : list (list bool) => cons true nil)\n (fun vl : list (list bool) => cons true (nth O vl nil))\n (fun vl : list (list bool) => cons false (nth (S O) vl nil)) l\n (tl v))) (S (length l))
l : list bool
a : bool
v : list (list bool)
*****
le (length (cons false (sem_Rec (fun _ : list (list bool) => cons true nil) (fun vl : list (list bool) => cons true (nth O vl nil)) (fun vl : list (list bool) => cons false (nth (S O) vl nil)) l (tl v)))) (S (S (length l)))
+++++
simpl.
-----
Lemma Succ_length v : length (Sem Succ_e v) <= S (length (hd nil v)).
Proof.
intros.
simpl.
induction (hd nil v).
simpl.
auto.
case a.
simpl.

*****
IHl : le\n (length\n (sem_Rec (fun _ : list (list bool) => cons true nil)\n (fun vl : list (list bool) => cons true (nth O vl nil))\n (fun vl : list (list bool) => cons false (nth (S O) vl nil)) l\n (tl v))) (S (length l))
l : list bool
a : bool
v : list (list bool)
*****
le (S (length (sem_Rec (fun _ : list (list bool) => cons true nil) (fun vl : list (list bool) => cons true (nth O vl nil)) (fun vl : list (list bool) => cons false (nth (S O) vl nil)) l (tl v)))) (S (S (length l)))
+++++
omega.
-----
Lemma Succ_length v : length (Sem Succ_e v) <= S (length (hd nil v)).
Proof.
intros.
simpl.
induction (hd nil v).
simpl.
auto.
case a.

*****
IHl : le\n (length\n (sem_Rec (fun _ : list (list bool) => cons true nil)\n (fun vl : list (list bool) => cons true (nth O vl nil))\n (fun vl : list (list bool) => cons false (nth (S O) vl nil)) l\n (tl v))) (S (length l))
l : list bool
a : bool
v : list (list bool)
*****
le (length (cons true l)) (S (S (length l)))
+++++
simpl.
-----
Lemma Succ_length v : length (Sem Succ_e v) <= S (length (hd nil v)).
Proof.
intros.
simpl.
induction (hd nil v).
simpl.
auto.
case a.
simpl.

*****
IHl : le\n (length\n (sem_Rec (fun _ : list (list bool) => cons true nil)\n (fun vl : list (list bool) => cons true (nth O vl nil))\n (fun vl : list (list bool) => cons false (nth (S O) vl nil)) l\n (tl v))) (S (length l))
l : list bool
a : bool
v : list (list bool)
*****
le (S (length l)) (S (S (length l)))
+++++
omega.
-----
Lemma Succ_length v : length (Sem Succ_e v) <= S (length (hd nil v)).
Proof.
intros.
simpl.
induction (hd nil v).

*****

*****

+++++
Qed.
-----
Lemma rec_bounded_Succ :\n  rec_bounded Succ_e.
-----
Lemma rec_bounded_Succ : rec_bounded Succ_e.

*****

*****
rec_bounded Succ_e
+++++
Proof.
-----
Lemma rec_bounded_Succ : rec_bounded Succ_e.
Proof.

*****

*****
rec_bounded Succ_e
+++++
simpl.
-----
Lemma rec_bounded_Succ : rec_bounded Succ_e.
Proof.
simpl.

*****

*****
and (and True (and True True)) (and (and True (and True True)) (and (and True (and True True)) (and (and True (and True True)) (forall l : list (list bool), le (length (sem_Rec (fun _ : list (list bool) => cons true nil) (fun vl : list (list bool) => cons true (nth O vl nil)) (fun vl : list (list bool) => cons false (nth (S O) vl nil)) (hd nil l) (tl l))) (S (length (nth O l nil)))))))
+++++
intuition.
-----
Lemma rec_bounded_Succ : rec_bounded Succ_e.
Proof.
simpl.
intuition.

*****
l : list (list bool)
*****
le (length (sem_Rec (fun _ : list (list bool) => cons true nil) (fun vl : list (list bool) => cons true (nth O vl nil)) (fun vl : list (list bool) => cons false (nth (S O) vl nil)) (hd nil l) (tl l))) (S (length (nth O l nil)))
+++++
eapply le_trans.
-----
Lemma rec_bounded_Succ : rec_bounded Succ_e.
Proof.
simpl.
intuition.
eapply le_trans.

*****
l : list (list bool)
*****
le (length (sem_Rec (fun _ : list (list bool) => cons true nil) (fun vl : list (list bool) => cons true (nth O vl nil)) (fun vl : list (list bool) => cons false (nth (S O) vl nil)) (hd nil l) (tl l))) ?m
+++++
eapply le_trans.
-----
Lemma rec_bounded_Succ : rec_bounded Succ_e.
Proof.
simpl.
intuition.
eapply le_trans.
eapply le_trans.

*****
l : list (list bool)
*****
le (length (sem_Rec (fun _ : list (list bool) => cons true nil) (fun vl : list (list bool) => cons true (nth O vl nil)) (fun vl : list (list bool) => cons false (nth (S O) vl nil)) (hd nil l) (tl l))) ?m0
+++++
simpl.
-----
Lemma rec_bounded_Succ : rec_bounded Succ_e.
Proof.
simpl.
intuition.
eapply le_trans.
eapply le_trans.
simpl.

*****
l : list (list bool)
*****
le (length (sem_Rec (fun _ : list (list bool) => cons true nil) (fun vl : list (list bool) => cons true (nth O vl nil)) (fun vl : list (list bool) => cons false (nth (S O) vl nil)) (hd nil l) (tl l))) ?m0
+++++
trivial.
-----
Lemma rec_bounded_Succ : rec_bounded Succ_e.
Proof.
simpl.
intuition.
eapply le_trans.
eapply le_trans.

*****
l : list (list bool)
*****
le (length (sem_Rec (fun _ : list (list bool) => cons true nil) (fun vl : list (list bool) => cons true (nth O vl nil)) (fun vl : list (list bool) => cons false (nth (S O) vl nil)) (hd nil l) (tl l))) ?m
+++++
apply length_Succ.
-----
Lemma rec_bounded_Succ : rec_bounded Succ_e.
Proof.
simpl.
intuition.
eapply le_trans.

*****
l : list (list bool)
*****
le (length (Sem (Comp (S O) (Succ true) (cons (Proj (S O) O) nil)) l)) (S (length (nth O l nil)))
+++++
trivial.
-----
Lemma rec_bounded_Succ : rec_bounded Succ_e.
Proof.
simpl.
intuition.
eapply le_trans.

*****

*****

+++++
Qed.
-----
Lemma Succ_correct : forall l,\n  bs2nat (Sem Succ_e l) = 1 + bs2nat (hd nil l).
-----
Lemma Succ_correct : forall l, bs2nat (Sem Succ_e l) = 1 + bs2nat (hd nil l).

*****

*****
forall l : list (list bool), eq (bs2nat (Sem Succ_e l)) (Init.Nat.add (S O) (bs2nat (hd nil l)))
+++++
Proof.
-----
Lemma Succ_correct : forall l, bs2nat (Sem Succ_e l) = 1 + bs2nat (hd nil l).
Proof.

*****

*****
forall l : list (list bool), eq (bs2nat (Sem Succ_e l)) (Init.Nat.add (S O) (bs2nat (hd nil l)))
+++++
destruct l as [ | v l].
-----
Lemma Succ_correct : forall l, bs2nat (Sem Succ_e l) = 1 + bs2nat (hd nil l).
Proof.
destruct l as [ | v l].

*****

*****
eq (bs2nat (Sem Succ_e nil)) (Init.Nat.add (S O) (bs2nat (hd nil nil)))
+++++
trivial.
-----
Lemma Succ_correct : forall l, bs2nat (Sem Succ_e l) = 1 + bs2nat (hd nil l).
Proof.
destruct l as [ | v l].

*****
l : list (list bool)
v : list bool
*****
eq (bs2nat (Sem Succ_e (cons v l))) (Init.Nat.add (S O) (bs2nat (hd nil (cons v l))))
+++++
trivial.
-----
Lemma Succ_correct : forall l, bs2nat (Sem Succ_e l) = 1 + bs2nat (hd nil l).
Proof.
destruct l as [ | v l].
trivial.

*****
l : list (list bool)
v : list bool
*****
eq (bs2nat (Sem Succ_e (cons v l))) (Init.Nat.add (S O) (bs2nat (hd nil (cons v l))))
+++++
simpl hd.
-----
Lemma Succ_correct : forall l, bs2nat (Sem Succ_e l) = 1 + bs2nat (hd nil l).
Proof.
destruct l as [ | v l].
trivial.
simpl hd.

*****
l : list (list bool)
v : list bool
*****
eq (bs2nat (Sem Succ_e (cons v l))) (Init.Nat.add (S O) (bs2nat v))
+++++
induction v as [ | [ | ] v IH].
-----
Lemma Succ_correct : forall l, bs2nat (Sem Succ_e l) = 1 + bs2nat (hd nil l).
Proof.
destruct l as [ | v l].
trivial.
simpl hd.
induction v as [ | [ | ] v IH].

*****
l : list (list bool)
*****
eq (bs2nat (Sem Succ_e (cons nil l))) (Init.Nat.add (S O) (bs2nat nil))
+++++
trivial.
-----
Lemma Succ_correct : forall l, bs2nat (Sem Succ_e l) = 1 + bs2nat (hd nil l).
Proof.
destruct l as [ | v l].
trivial.
simpl hd.
induction v as [ | [ | ] v IH].

*****
IH : eq (bs2nat (Sem Succ_e (cons v l))) (Init.Nat.add (S O) (bs2nat v))
l : list (list bool)
v : list bool
*****
eq (bs2nat (Sem Succ_e (cons (cons true v) l))) (Init.Nat.add (S O) (bs2nat (cons true v)))
+++++
trivial.
-----
Lemma Succ_correct : forall l, bs2nat (Sem Succ_e l) = 1 + bs2nat (hd nil l).
Proof.
destruct l as [ | v l].
trivial.
simpl hd.
induction v as [ | [ | ] v IH].
trivial.

*****
IH : eq (bs2nat (Sem Succ_e (cons v l))) (Init.Nat.add (S O) (bs2nat v))
l : list (list bool)
v : list bool
*****
eq (bs2nat (Sem Succ_e (cons (cons true v) l))) (Init.Nat.add (S O) (bs2nat (cons true v)))
+++++
simpl Sem in *.
-----
Lemma Succ_correct : forall l, bs2nat (Sem Succ_e l) = 1 + bs2nat (hd nil l).
Proof.
destruct l as [ | v l].
trivial.
simpl hd.
induction v as [ | [ | ] v IH].
trivial.
simpl Sem in *.

*****
IH : eq\n (bs2nat\n (sem_Rec (fun _ : list (list bool) => cons true nil)\n (fun vl : list (list bool) => cons true (nth O vl nil))\n (fun vl : list (list bool) => cons false (nth (S O) vl nil)) v\n l)) (Init.Nat.add (S O) (bs2nat v))
l : list (list bool)
v : list bool
*****
eq (bs2nat (cons false (sem_Rec (fun _ : list (list bool) => cons true nil) (fun vl : list (list bool) => cons true (nth O vl nil)) (fun vl : list (list bool) => cons false (nth (S O) vl nil)) v l))) (Init.Nat.add (S O) (bs2nat (cons true v)))
+++++
rewrite bs2nat_false.
-----
Lemma Succ_correct : forall l, bs2nat (Sem Succ_e l) = 1 + bs2nat (hd nil l).
Proof.
destruct l as [ | v l].
trivial.
simpl hd.
induction v as [ | [ | ] v IH].
trivial.
simpl Sem in *.
rewrite bs2nat_false.

*****
IH : eq\n (bs2nat\n (sem_Rec (fun _ : list (list bool) => cons true nil)\n (fun vl : list (list bool) => cons true (nth O vl nil))\n (fun vl : list (list bool) => cons false (nth (S O) vl nil)) v\n l)) (Init.Nat.add (S O) (bs2nat v))
l : list (list bool)
v : list bool
*****
eq (Init.Nat.mul (S (S O)) (bs2nat (sem_Rec (fun _ : list (list bool) => cons true nil) (fun vl : list (list bool) => cons true (nth O vl nil)) (fun vl : list (list bool) => cons false (nth (S O) vl nil)) v l))) (Init.Nat.add (S O) (bs2nat (cons true v)))
+++++
rewrite bs2nat_true.
-----
Lemma Succ_correct : forall l, bs2nat (Sem Succ_e l) = 1 + bs2nat (hd nil l).
Proof.
destruct l as [ | v l].
trivial.
simpl hd.
induction v as [ | [ | ] v IH].
trivial.
simpl Sem in *.
rewrite bs2nat_false.
rewrite bs2nat_true.

*****
IH : eq\n (bs2nat\n (sem_Rec (fun _ : list (list bool) => cons true nil)\n (fun vl : list (list bool) => cons true (nth O vl nil))\n (fun vl : list (list bool) => cons false (nth (S O) vl nil)) v\n l)) (Init.Nat.add (S O) (bs2nat v))
l : list (list bool)
v : list bool
*****
eq (Init.Nat.mul (S (S O)) (bs2nat (sem_Rec (fun _ : list (list bool) => cons true nil) (fun vl : list (list bool) => cons true (nth O vl nil)) (fun vl : list (list bool) => cons false (nth (S O) vl nil)) v l))) (Init.Nat.add (S O) (Init.Nat.add (S O) (Init.Nat.mul (S (S O)) (bs2nat v))))
+++++
rewrite IH.
-----
Lemma Succ_correct : forall l, bs2nat (Sem Succ_e l) = 1 + bs2nat (hd nil l).
Proof.
destruct l as [ | v l].
trivial.
simpl hd.
induction v as [ | [ | ] v IH].
trivial.
simpl Sem in *.
rewrite bs2nat_false.
rewrite bs2nat_true.
rewrite IH.

*****
IH : eq\n (bs2nat\n (sem_Rec (fun _ : list (list bool) => cons true nil)\n (fun vl : list (list bool) => cons true (nth O vl nil))\n (fun vl : list (list bool) => cons false (nth (S O) vl nil)) v\n l)) (Init.Nat.add (S O) (bs2nat v))
l : list (list bool)
v : list bool
*****
eq (Init.Nat.mul (S (S O)) (Init.Nat.add (S O) (bs2nat v))) (Init.Nat.add (S O) (Init.Nat.add (S O) (Init.Nat.mul (S (S O)) (bs2nat v))))
+++++
ring.
-----
Lemma Succ_correct : forall l, bs2nat (Sem Succ_e l) = 1 + bs2nat (hd nil l).
Proof.
destruct l as [ | v l].
trivial.
simpl hd.
induction v as [ | [ | ] v IH].

*****
IH : eq (bs2nat (Sem Succ_e (cons v l))) (Init.Nat.add (S O) (bs2nat v))
l : list (list bool)
v : list bool
*****
eq (bs2nat (Sem Succ_e (cons (cons false v) l))) (Init.Nat.add (S O) (bs2nat (cons false v)))
+++++
trivial.
-----
Lemma Succ_correct : forall l, bs2nat (Sem Succ_e l) = 1 + bs2nat (hd nil l).
Proof.
destruct l as [ | v l].

*****

*****

+++++
Qed.
-----
Opaque Succ_e.
-----
Definition Pred'_e : Cobham :=\n  Rec\n    Zero\n    (Comp 2 (Succ true) [Proj 2 1])\n    (Comp 2 (Succ false) [Proj 2 0])\n    (Proj 1 0).
-----
Lemma arity_Pred' : arity Pred'_e = ok_arity 1.
-----
Lemma arity_Pred' : arity Pred'_e = ok_arity 1.

*****

*****
eq (arity Pred'_e) (ok_arity (S O))
+++++
Proof.
-----
Lemma arity_Pred' : arity Pred'_e = ok_arity 1.
Proof.

*****

*****
eq (arity Pred'_e) (ok_arity (S O))
+++++
trivial.
-----
Lemma arity_Pred' : arity Pred'_e = ok_arity 1.
Proof.
trivial.

*****

*****

+++++
Qed.
-----
Lemma rec_bounded_Pred' :\n  rec_bounded Pred'_e.
-----
Lemma rec_bounded_Pred' : rec_bounded Pred'_e.

*****

*****
rec_bounded Pred'_e
+++++
Proof.
-----
Lemma rec_bounded_Pred' : rec_bounded Pred'_e.
Proof.

*****

*****
rec_bounded Pred'_e
+++++
simpl.
-----
Lemma rec_bounded_Pred' : rec_bounded Pred'_e.
Proof.
simpl.

*****

*****
and True (and True (and (and True (and True True)) (and (and True (and True True)) (forall l : list (list bool), le (length (sem_Rec (fun _ : list (list bool) => nil) (fun vl : list (list bool) => cons true (nth (S O) vl nil)) (fun vl : list (list bool) => cons false (nth O vl nil)) (hd nil l) (tl l))) (length (nth O l nil))))))
+++++
intuition.
-----
Lemma rec_bounded_Pred' : rec_bounded Pred'_e.
Proof.
simpl.
intuition.

*****
l : list (list bool)
*****
le (length (sem_Rec (fun _ : list (list bool) => nil) (fun vl : list (list bool) => cons true (nth (S O) vl nil)) (fun vl : list (list bool) => cons false (nth O vl nil)) (hd nil l) (tl l))) (length (nth O l nil))
+++++
destruct l as [ | v l].
-----
Lemma rec_bounded_Pred' : rec_bounded Pred'_e.
Proof.
simpl.
intuition.
destruct l as [ | v l].

*****

*****
le (length (sem_Rec (fun _ : list (list bool) => nil) (fun vl : list (list bool) => cons true (nth (S O) vl nil)) (fun vl : list (list bool) => cons false (nth O vl nil)) (hd nil nil) (tl nil))) (length (nth O nil nil))
+++++
trivial.
-----
Lemma rec_bounded_Pred' : rec_bounded Pred'_e.
Proof.
simpl.
intuition.
destruct l as [ | v l].

*****
l : list (list bool)
v : list bool
*****
le (length (sem_Rec (fun _ : list (list bool) => nil) (fun vl : list (list bool) => cons true (nth (S O) vl nil)) (fun vl : list (list bool) => cons false (nth O vl nil)) (hd nil (cons v l)) (tl (cons v l)))) (length (nth O (cons v l) nil))
+++++
simpl.
-----
Lemma rec_bounded_Pred' : rec_bounded Pred'_e.
Proof.
simpl.
intuition.
destruct l as [ | v l].
simpl.

*****
l : list (list bool)
v : list bool
*****
le (length (sem_Rec (fun _ : list (list bool) => nil) (fun vl : list (list bool) => cons true (nth (S O) vl nil)) (fun vl : list (list bool) => cons false (nth O vl nil)) v l)) (length v)
+++++
induction v as [ | [ | ] v IH].
-----
Lemma rec_bounded_Pred' : rec_bounded Pred'_e.
Proof.
simpl.
intuition.
destruct l as [ | v l].
simpl.
induction v as [ | [ | ] v IH].

*****
l : list (list bool)
*****
le (length (sem_Rec (fun _ : list (list bool) => nil) (fun vl : list (list bool) => cons true (nth (S O) vl nil)) (fun vl : list (list bool) => cons false (nth O vl nil)) nil l)) (length nil)
+++++
trivial.
-----
Lemma rec_bounded_Pred' : rec_bounded Pred'_e.
Proof.
simpl.
intuition.
destruct l as [ | v l].
simpl.
induction v as [ | [ | ] v IH].

*****
IH : le\n (length\n (sem_Rec (fun _ : list (list bool) => nil)\n (fun vl : list (list bool) => cons true (nth (S O) vl nil))\n (fun vl : list (list bool) => cons false (nth O vl nil)) v l))\n (length v)
l : list (list bool)
v : list bool
*****
le (length (sem_Rec (fun _ : list (list bool) => nil) (fun vl : list (list bool) => cons true (nth (S O) vl nil)) (fun vl : list (list bool) => cons false (nth O vl nil)) (cons true v) l)) (length (cons true v))
+++++
trivial.
-----
Lemma rec_bounded_Pred' : rec_bounded Pred'_e.
Proof.
simpl.
intuition.
destruct l as [ | v l].
simpl.
induction v as [ | [ | ] v IH].

*****
IH : le\n (length\n (sem_Rec (fun _ : list (list bool) => nil)\n (fun vl : list (list bool) => cons true (nth (S O) vl nil))\n (fun vl : list (list bool) => cons false (nth O vl nil)) v l))\n (length v)
l : list (list bool)
v : list bool
*****
le (length (sem_Rec (fun _ : list (list bool) => nil) (fun vl : list (list bool) => cons true (nth (S O) vl nil)) (fun vl : list (list bool) => cons false (nth O vl nil)) (cons false v) l)) (length (cons false v))
+++++
simpl.
-----
Lemma rec_bounded_Pred' : rec_bounded Pred'_e.
Proof.
simpl.
intuition.
destruct l as [ | v l].
simpl.
induction v as [ | [ | ] v IH].
simpl.

*****
IH : le\n (length\n (sem_Rec (fun _ : list (list bool) => nil)\n (fun vl : list (list bool) => cons true (nth (S O) vl nil))\n (fun vl : list (list bool) => cons false (nth O vl nil)) v l))\n (length v)
l : list (list bool)
v : list bool
*****
le (S (length (sem_Rec (fun _ : list (list bool) => nil) (fun vl : list (list bool) => cons true (nth (S O) vl nil)) (fun vl : list (list bool) => cons false (nth O vl nil)) v l))) (S (length v))
+++++
omega.
-----
Lemma rec_bounded_Pred' : rec_bounded Pred'_e.
Proof.
simpl.
intuition.
destruct l as [ | v l].

*****

*****

+++++
Qed.
-----
Lemma Pred'_correct : forall l,\n  hd nil l = nil \/ bs2nat (hd nil l) <> 0 ->\n  bs2nat (Sem Pred'_e l) =  bs2nat (hd nil l) - 1.
-----
Lemma Pred'_correct : forall l, hd nil l = nil \\/ bs2nat (hd nil l) <> 0 -> bs2nat (Sem Pred'_e l) = bs2nat (hd nil l) - 1.

*****

*****
forall (l : list (list bool)) (_ : or (eq (hd nil l) nil) (not (eq (bs2nat (hd nil l)) O))), eq (bs2nat (Sem Pred'_e l)) (Init.Nat.sub (bs2nat (hd nil l)) (S O))
+++++
Proof.
-----
Lemma Pred'_correct : forall l, hd nil l = nil \\/ bs2nat (hd nil l) <> 0 -> bs2nat (Sem Pred'_e l) = bs2nat (hd nil l) - 1.
Proof.

*****

*****
forall (l : list (list bool)) (_ : or (eq (hd nil l) nil) (not (eq (bs2nat (hd nil l)) O))), eq (bs2nat (Sem Pred'_e l)) (Init.Nat.sub (bs2nat (hd nil l)) (S O))
+++++
intros l H.
-----
Lemma Pred'_correct : forall l, hd nil l = nil \\/ bs2nat (hd nil l) <> 0 -> bs2nat (Sem Pred'_e l) = bs2nat (hd nil l) - 1.
Proof.
intros l H.

*****
H : or (eq (hd nil l) nil) (not (eq (bs2nat (hd nil l)) O))
l : list (list bool)
*****
eq (bs2nat (Sem Pred'_e l)) (Init.Nat.sub (bs2nat (hd nil l)) (S O))
+++++
destruct l as [ | v l].
-----
Lemma Pred'_correct : forall l, hd nil l = nil \\/ bs2nat (hd nil l) <> 0 -> bs2nat (Sem Pred'_e l) = bs2nat (hd nil l) - 1.
Proof.
intros l H.
destruct l as [ | v l].

*****
H : or (eq (hd nil nil) nil) (not (eq (bs2nat (hd nil nil)) O))
*****
eq (bs2nat (Sem Pred'_e nil)) (Init.Nat.sub (bs2nat (hd nil nil)) (S O))
+++++
simpl.
-----
Lemma Pred'_correct : forall l, hd nil l = nil \\/ bs2nat (hd nil l) <> 0 -> bs2nat (Sem Pred'_e l) = bs2nat (hd nil l) - 1.
Proof.
intros l H.
destruct l as [ | v l].
simpl.

*****
H : or (eq (hd nil nil) nil) (not (eq (bs2nat (hd nil nil)) O))
*****
eq (bs2nat nil) (Init.Nat.sub (bs2nat nil) (S O))
+++++
trivial.
-----
Lemma Pred'_correct : forall l, hd nil l = nil \\/ bs2nat (hd nil l) <> 0 -> bs2nat (Sem Pred'_e l) = bs2nat (hd nil l) - 1.
Proof.
intros l H.
destruct l as [ | v l].

*****
H : or (eq (hd nil (cons v l)) nil)\n (not (eq (bs2nat (hd nil (cons v l))) O))
l : list (list bool)
v : list bool
*****
eq (bs2nat (Sem Pred'_e (cons v l))) (Init.Nat.sub (bs2nat (hd nil (cons v l))) (S O))
+++++
simpl hd.
-----
Lemma Pred'_correct : forall l, hd nil l = nil \\/ bs2nat (hd nil l) <> 0 -> bs2nat (Sem Pred'_e l) = bs2nat (hd nil l) - 1.
Proof.
intros l H.
destruct l as [ | v l].
simpl hd.

*****
H : or (eq (hd nil (cons v l)) nil)\n (not (eq (bs2nat (hd nil (cons v l))) O))
l : list (list bool)
v : list bool
*****
eq (bs2nat (Sem Pred'_e (cons v l))) (Init.Nat.sub (bs2nat v) (S O))
+++++
induction v as [ | [ | ] v IH].
-----
Lemma Pred'_correct : forall l, hd nil l = nil \\/ bs2nat (hd nil l) <> 0 -> bs2nat (Sem Pred'_e l) = bs2nat (hd nil l) - 1.
Proof.
intros l H.
destruct l as [ | v l].
simpl hd.
induction v as [ | [ | ] v IH].

*****
H : or (eq (hd nil (cons nil l)) nil)\n (not (eq (bs2nat (hd nil (cons nil l))) O))
l : list (list bool)
*****
eq (bs2nat (Sem Pred'_e (cons nil l))) (Init.Nat.sub (bs2nat nil) (S O))
+++++
trivial.
-----
Lemma Pred'_correct : forall l, hd nil l = nil \\/ bs2nat (hd nil l) <> 0 -> bs2nat (Sem Pred'_e l) = bs2nat (hd nil l) - 1.
Proof.
intros l H.
destruct l as [ | v l].
simpl hd.
induction v as [ | [ | ] v IH].

*****
IH : forall\n _ : or (eq (hd nil (cons v l)) nil)\n (not (eq (bs2nat (hd nil (cons v l))) O)),\neq (bs2nat (Sem Pred'_e (cons v l))) (Init.Nat.sub (bs2nat v) (S O))
H : or (eq (hd nil (cons (cons true v) l)) nil)\n (not (eq (bs2nat (hd nil (cons (cons true v) l))) O))
l : list (list bool)
v : list bool
*****
eq (bs2nat (Sem Pred'_e (cons (cons true v) l))) (Init.Nat.sub (bs2nat (cons true v)) (S O))
+++++
simpl Sem in *.
-----
Lemma Pred'_correct : forall l, hd nil l = nil \\/ bs2nat (hd nil l) <> 0 -> bs2nat (Sem Pred'_e l) = bs2nat (hd nil l) - 1.
Proof.
intros l H.
destruct l as [ | v l].
simpl hd.
induction v as [ | [ | ] v IH].
simpl Sem in *.

*****
IH : forall\n _ : or (eq (hd nil (cons v l)) nil)\n (not (eq (bs2nat (hd nil (cons v l))) O)),\neq\n (bs2nat\n (sem_Rec (fun _ : list (list bool) => nil)\n (fun vl : list (list bool) => cons true (nth (S O) vl nil))\n (fun vl : list (list bool) => cons false (nth O vl nil)) v l))\n (Init.Nat.sub (bs2nat v) (S O))
H : or (eq (hd nil (cons (cons true v) l)) nil)\n (not (eq (bs2nat (hd nil (cons (cons true v) l))) O))
l : list (list bool)
v : list bool
*****
eq (bs2nat (cons false v)) (Init.Nat.sub (bs2nat (cons true v)) (S O))
+++++
rewrite bs2nat_false.
-----
Lemma Pred'_correct : forall l, hd nil l = nil \\/ bs2nat (hd nil l) <> 0 -> bs2nat (Sem Pred'_e l) = bs2nat (hd nil l) - 1.
Proof.
intros l H.
destruct l as [ | v l].
simpl hd.
induction v as [ | [ | ] v IH].
simpl Sem in *.
rewrite bs2nat_false.

*****
IH : forall\n _ : or (eq (hd nil (cons v l)) nil)\n (not (eq (bs2nat (hd nil (cons v l))) O)),\neq\n (bs2nat\n (sem_Rec (fun _ : list (list bool) => nil)\n (fun vl : list (list bool) => cons true (nth (S O) vl nil))\n (fun vl : list (list bool) => cons false (nth O vl nil)) v l))\n (Init.Nat.sub (bs2nat v) (S O))
H : or (eq (hd nil (cons (cons true v) l)) nil)\n (not (eq (bs2nat (hd nil (cons (cons true v) l))) O))
l : list (list bool)
v : list bool
*****
eq (Init.Nat.mul (S (S O)) (bs2nat v)) (Init.Nat.sub (bs2nat (cons true v)) (S O))
+++++
rewrite bs2nat_true.
-----
Lemma Pred'_correct : forall l, hd nil l = nil \\/ bs2nat (hd nil l) <> 0 -> bs2nat (Sem Pred'_e l) = bs2nat (hd nil l) - 1.
Proof.
intros l H.
destruct l as [ | v l].
simpl hd.
induction v as [ | [ | ] v IH].
simpl Sem in *.
rewrite bs2nat_false.
rewrite bs2nat_true.

*****
IH : forall\n _ : or (eq (hd nil (cons v l)) nil)\n (not (eq (bs2nat (hd nil (cons v l))) O)),\neq\n (bs2nat\n (sem_Rec (fun _ : list (list bool) => nil)\n (fun vl : list (list bool) => cons true (nth (S O) vl nil))\n (fun vl : list (list bool) => cons false (nth O vl nil)) v l))\n (Init.Nat.sub (bs2nat v) (S O))
H : or (eq (hd nil (cons (cons true v) l)) nil)\n (not (eq (bs2nat (hd nil (cons (cons true v) l))) O))
l : list (list bool)
v : list bool
*****
eq (Init.Nat.mul (S (S O)) (bs2nat v)) (Init.Nat.sub (Init.Nat.add (S O) (Init.Nat.mul (S (S O)) (bs2nat v))) (S O))
+++++
omega.
-----
Lemma Pred'_correct : forall l, hd nil l = nil \\/ bs2nat (hd nil l) <> 0 -> bs2nat (Sem Pred'_e l) = bs2nat (hd nil l) - 1.
Proof.
intros l H.
destruct l as [ | v l].
simpl hd.
induction v as [ | [ | ] v IH].

*****
IH : forall\n _ : or (eq (hd nil (cons v l)) nil)\n (not (eq (bs2nat (hd nil (cons v l))) O)),\neq (bs2nat (Sem Pred'_e (cons v l))) (Init.Nat.sub (bs2nat v) (S O))
H : or (eq (hd nil (cons (cons false v) l)) nil)\n (not (eq (bs2nat (hd nil (cons (cons false v) l))) O))
l : list (list bool)
v : list bool
*****
eq (bs2nat (Sem Pred'_e (cons (cons false v) l))) (Init.Nat.sub (bs2nat (cons false v)) (S O))
+++++
simpl Sem in *.
-----
Lemma Pred'_correct : forall l, hd nil l = nil \\/ bs2nat (hd nil l) <> 0 -> bs2nat (Sem Pred'_e l) = bs2nat (hd nil l) - 1.
Proof.
intros l H.
destruct l as [ | v l].
simpl hd.
induction v as [ | [ | ] v IH].
simpl Sem in *.

*****
IH : forall\n _ : or (eq (hd nil (cons v l)) nil)\n (not (eq (bs2nat (hd nil (cons v l))) O)),\neq\n (bs2nat\n (sem_Rec (fun _ : list (list bool) => nil)\n (fun vl : list (list bool) => cons true (nth (S O) vl nil))\n (fun vl : list (list bool) => cons false (nth O vl nil)) v l))\n (Init.Nat.sub (bs2nat v) (S O))
H : or (eq (hd nil (cons (cons false v) l)) nil)\n (not (eq (bs2nat (hd nil (cons (cons false v) l))) O))
l : list (list bool)
v : list bool
*****
eq (bs2nat (cons true (sem_Rec (fun _ : list (list bool) => nil) (fun vl : list (list bool) => cons true (nth (S O) vl nil)) (fun vl : list (list bool) => cons false (nth O vl nil)) v l))) (Init.Nat.sub (bs2nat (cons false v)) (S O))
+++++
rewrite bs2nat_false.
-----
Lemma Pred'_correct : forall l, hd nil l = nil \\/ bs2nat (hd nil l) <> 0 -> bs2nat (Sem Pred'_e l) = bs2nat (hd nil l) - 1.
Proof.
intros l H.
destruct l as [ | v l].
simpl hd.
induction v as [ | [ | ] v IH].
simpl Sem in *.
rewrite bs2nat_false.

*****
IH : forall\n _ : or (eq (hd nil (cons v l)) nil)\n (not (eq (bs2nat (hd nil (cons v l))) O)),\neq\n (bs2nat\n (sem_Rec (fun _ : list (list bool) => nil)\n (fun vl : list (list bool) => cons true (nth (S O) vl nil))\n (fun vl : list (list bool) => cons false (nth O vl nil)) v l))\n (Init.Nat.sub (bs2nat v) (S O))
H : or (eq (hd nil (cons (cons false v) l)) nil)\n (not (eq (bs2nat (hd nil (cons (cons false v) l))) O))
l : list (list bool)
v : list bool
*****
eq (bs2nat (cons true (sem_Rec (fun _ : list (list bool) => nil) (fun vl : list (list bool) => cons true (nth (S O) vl nil)) (fun vl : list (list bool) => cons false (nth O vl nil)) v l))) (Init.Nat.sub (Init.Nat.mul (S (S O)) (bs2nat v)) (S O))
+++++
rewrite bs2nat_true.
-----
Lemma Pred'_correct : forall l, hd nil l = nil \\/ bs2nat (hd nil l) <> 0 -> bs2nat (Sem Pred'_e l) = bs2nat (hd nil l) - 1.
Proof.
intros l H.
destruct l as [ | v l].
simpl hd.
induction v as [ | [ | ] v IH].
simpl Sem in *.
rewrite bs2nat_false.
rewrite bs2nat_true.

*****
IH : forall\n _ : or (eq (hd nil (cons v l)) nil)\n (not (eq (bs2nat (hd nil (cons v l))) O)),\neq\n (bs2nat\n (sem_Rec (fun _ : list (list bool) => nil)\n (fun vl : list (list bool) => cons true (nth (S O) vl nil))\n (fun vl : list (list bool) => cons false (nth O vl nil)) v l))\n (Init.Nat.sub (bs2nat v) (S O))
H : or (eq (hd nil (cons (cons false v) l)) nil)\n (not (eq (bs2nat (hd nil (cons (cons false v) l))) O))
l : list (list bool)
v : list bool
*****
eq (Init.Nat.add (S O) (Init.Nat.mul (S (S O)) (bs2nat (sem_Rec (fun _ : list (list bool) => nil) (fun vl : list (list bool) => cons true (nth (S O) vl nil)) (fun vl : list (list bool) => cons false (nth O vl nil)) v l)))) (Init.Nat.sub (Init.Nat.mul (S (S O)) (bs2nat v)) (S O))
+++++
rewrite IH.
-----
Lemma Pred'_correct : forall l, hd nil l = nil \\/ bs2nat (hd nil l) <> 0 -> bs2nat (Sem Pred'_e l) = bs2nat (hd nil l) - 1.
Proof.
intros l H.
destruct l as [ | v l].
simpl hd.
induction v as [ | [ | ] v IH].
simpl Sem in *.
rewrite bs2nat_false.
rewrite bs2nat_true.
rewrite IH.

*****
IH : forall\n _ : or (eq (hd nil (cons v l)) nil)\n (not (eq (bs2nat (hd nil (cons v l))) O)),\neq\n (bs2nat\n (sem_Rec (fun _ : list (list bool) => nil)\n (fun vl : list (list bool) => cons true (nth (S O) vl nil))\n (fun vl : list (list bool) => cons false (nth O vl nil)) v l))\n (Init.Nat.sub (bs2nat v) (S O))
H : or (eq (hd nil (cons (cons false v) l)) nil)\n (not (eq (bs2nat (hd nil (cons (cons false v) l))) O))
l : list (list bool)
v : list bool
*****
eq (Init.Nat.add (S O) (Init.Nat.mul (S (S O)) (Init.Nat.sub (bs2nat v) (S O)))) (Init.Nat.sub (Init.Nat.mul (S (S O)) (bs2nat v)) (S O))
+++++
simpl in H.
-----
Lemma Pred'_correct : forall l, hd nil l = nil \\/ bs2nat (hd nil l) <> 0 -> bs2nat (Sem Pred'_e l) = bs2nat (hd nil l) - 1.
Proof.
intros l H.
destruct l as [ | v l].
simpl hd.
induction v as [ | [ | ] v IH].
simpl Sem in *.
rewrite bs2nat_false.
rewrite bs2nat_true.
rewrite IH.
simpl in H.

*****
IH : forall\n _ : or (eq (hd nil (cons v l)) nil)\n (not (eq (bs2nat (hd nil (cons v l))) O)),\neq\n (bs2nat\n (sem_Rec (fun _ : list (list bool) => nil)\n (fun vl : list (list bool) => cons true (nth (S O) vl nil))\n (fun vl : list (list bool) => cons false (nth O vl nil)) v l))\n (Init.Nat.sub (bs2nat v) (S O))
H : or (eq (cons false v) nil) (not (eq (bs2nat (cons false v)) O))
l : list (list bool)
v : list bool
*****
eq (Init.Nat.add (S O) (Init.Nat.mul (S (S O)) (Init.Nat.sub (bs2nat v) (S O)))) (Init.Nat.sub (Init.Nat.mul (S (S O)) (bs2nat v)) (S O))
+++++
destruct H as [H | H].
-----
Lemma Pred'_correct : forall l, hd nil l = nil \\/ bs2nat (hd nil l) <> 0 -> bs2nat (Sem Pred'_e l) = bs2nat (hd nil l) - 1.
Proof.
intros l H.
destruct l as [ | v l].
simpl hd.
induction v as [ | [ | ] v IH].
simpl Sem in *.
rewrite bs2nat_false.
rewrite bs2nat_true.
rewrite IH.
simpl in H.
destruct H as [H | H].

*****
IH : forall\n _ : or (eq (hd nil (cons v l)) nil)\n (not (eq (bs2nat (hd nil (cons v l))) O)),\neq\n (bs2nat\n (sem_Rec (fun _ : list (list bool) => nil)\n (fun vl : list (list bool) => cons true (nth (S O) vl nil))\n (fun vl : list (list bool) => cons false (nth O vl nil)) v l))\n (Init.Nat.sub (bs2nat v) (S O))
H : eq (cons false v) nil
l : list (list bool)
v : list bool
*****
eq (Init.Nat.add (S O) (Init.Nat.mul (S (S O)) (Init.Nat.sub (bs2nat v) (S O)))) (Init.Nat.sub (Init.Nat.mul (S (S O)) (bs2nat v)) (S O))
+++++
congruence.
-----
Lemma Pred'_correct : forall l, hd nil l = nil \\/ bs2nat (hd nil l) <> 0 -> bs2nat (Sem Pred'_e l) = bs2nat (hd nil l) - 1.
Proof.
intros l H.
destruct l as [ | v l].
simpl hd.
induction v as [ | [ | ] v IH].
simpl Sem in *.
rewrite bs2nat_false.
rewrite bs2nat_true.
rewrite IH.
simpl in H.
destruct H as [H | H].

*****
IH : forall\n _ : or (eq (hd nil (cons v l)) nil)\n (not (eq (bs2nat (hd nil (cons v l))) O)),\neq\n (bs2nat\n (sem_Rec (fun _ : list (list bool) => nil)\n (fun vl : list (list bool) => cons true (nth (S O) vl nil))\n (fun vl : list (list bool) => cons false (nth O vl nil)) v l))\n (Init.Nat.sub (bs2nat v) (S O))
H : not (eq (bs2nat (cons false v)) O)
l : list (list bool)
v : list bool
*****
eq (Init.Nat.add (S O) (Init.Nat.mul (S (S O)) (Init.Nat.sub (bs2nat v) (S O)))) (Init.Nat.sub (Init.Nat.mul (S (S O)) (bs2nat v)) (S O))
+++++
rewrite bs2nat_false in H.
-----
Lemma Pred'_correct : forall l, hd nil l = nil \\/ bs2nat (hd nil l) <> 0 -> bs2nat (Sem Pred'_e l) = bs2nat (hd nil l) - 1.
Proof.
intros l H.
destruct l as [ | v l].
simpl hd.
induction v as [ | [ | ] v IH].
simpl Sem in *.
rewrite bs2nat_false.
rewrite bs2nat_true.
rewrite IH.
simpl in H.
destruct H as [H | H].
rewrite bs2nat_false in H.

*****
IH : forall\n _ : or (eq (hd nil (cons v l)) nil)\n (not (eq (bs2nat (hd nil (cons v l))) O)),\neq\n (bs2nat\n (sem_Rec (fun _ : list (list bool) => nil)\n (fun vl : list (list bool) => cons true (nth (S O) vl nil))\n (fun vl : list (list bool) => cons false (nth O vl nil)) v l))\n (Init.Nat.sub (bs2nat v) (S O))
H : not (eq (Init.Nat.mul (S (S O)) (bs2nat v)) O)
l : list (list bool)
v : list bool
*****
eq (Init.Nat.add (S O) (Init.Nat.mul (S (S O)) (Init.Nat.sub (bs2nat v) (S O)))) (Init.Nat.sub (Init.Nat.mul (S (S O)) (bs2nat v)) (S O))
+++++
omega.
-----
Lemma Pred'_correct : forall l, hd nil l = nil \\/ bs2nat (hd nil l) <> 0 -> bs2nat (Sem Pred'_e l) = bs2nat (hd nil l) - 1.
Proof.
intros l H.
destruct l as [ | v l].
simpl hd.
induction v as [ | [ | ] v IH].
simpl Sem in *.
rewrite bs2nat_false.
rewrite bs2nat_true.
rewrite IH.

*****
IH : forall\n _ : or (eq (hd nil (cons v l)) nil)\n (not (eq (bs2nat (hd nil (cons v l))) O)),\neq\n (bs2nat\n (sem_Rec (fun _ : list (list bool) => nil)\n (fun vl : list (list bool) => cons true (nth (S O) vl nil))\n (fun vl : list (list bool) => cons false (nth O vl nil)) v l))\n (Init.Nat.sub (bs2nat v) (S O))
H : or (eq (hd nil (cons (cons false v) l)) nil)\n (not (eq (bs2nat (hd nil (cons (cons false v) l))) O))
l : list (list bool)
v : list bool
*****
or (eq (hd nil (cons v l)) nil) (not (eq (bs2nat (hd nil (cons v l))) O))
+++++
simpl in *.
-----
Lemma Pred'_correct : forall l, hd nil l = nil \\/ bs2nat (hd nil l) <> 0 -> bs2nat (Sem Pred'_e l) = bs2nat (hd nil l) - 1.
Proof.
intros l H.
destruct l as [ | v l].
simpl hd.
induction v as [ | [ | ] v IH].
simpl Sem in *.
rewrite bs2nat_false.
rewrite bs2nat_true.
rewrite IH.
simpl in *.

*****
IH : forall _ : or (eq v nil) (not (eq (bs2nat v) O)),\neq\n (bs2nat\n (sem_Rec (fun _ : list (list bool) => nil)\n (fun vl : list (list bool) => cons true (nth (S O) vl nil))\n (fun vl : list (list bool) => cons false (nth O vl nil)) v l))\n (Init.Nat.sub (bs2nat v) (S O))
H : or (eq (cons false v) nil) (not (eq (bs2nat (cons false v)) O))
l : list (list bool)
v : list bool
*****
or (eq v nil) (not (eq (bs2nat v) O))
+++++
destruct H as [H | H].
-----
Lemma Pred'_correct : forall l, hd nil l = nil \\/ bs2nat (hd nil l) <> 0 -> bs2nat (Sem Pred'_e l) = bs2nat (hd nil l) - 1.
Proof.
intros l H.
destruct l as [ | v l].
simpl hd.
induction v as [ | [ | ] v IH].
simpl Sem in *.
rewrite bs2nat_false.
rewrite bs2nat_true.
rewrite IH.
simpl in *.
destruct H as [H | H].

*****
IH : forall _ : or (eq v nil) (not (eq (bs2nat v) O)),\neq\n (bs2nat\n (sem_Rec (fun _ : list (list bool) => nil)\n (fun vl : list (list bool) => cons true (nth (S O) vl nil))\n (fun vl : list (list bool) => cons false (nth O vl nil)) v l))\n (Init.Nat.sub (bs2nat v) (S O))
H : eq (cons false v) nil
l : list (list bool)
v : list bool
*****
or (eq v nil) (not (eq (bs2nat v) O))
+++++
congruence.
-----
Lemma Pred'_correct : forall l, hd nil l = nil \\/ bs2nat (hd nil l) <> 0 -> bs2nat (Sem Pred'_e l) = bs2nat (hd nil l) - 1.
Proof.
intros l H.
destruct l as [ | v l].
simpl hd.
induction v as [ | [ | ] v IH].
simpl Sem in *.
rewrite bs2nat_false.
rewrite bs2nat_true.
rewrite IH.
simpl in *.
destruct H as [H | H].

*****
IH : forall _ : or (eq v nil) (not (eq (bs2nat v) O)),\neq\n (bs2nat\n (sem_Rec (fun _ : list (list bool) => nil)\n (fun vl : list (list bool) => cons true (nth (S O) vl nil))\n (fun vl : list (list bool) => cons false (nth O vl nil)) v l))\n (Init.Nat.sub (bs2nat v) (S O))
H : not (eq (bs2nat (cons false v)) O)
l : list (list bool)
v : list bool
*****
or (eq v nil) (not (eq (bs2nat v) O))
+++++
rewrite bs2nat_false in H.
-----
Lemma Pred'_correct : forall l, hd nil l = nil \\/ bs2nat (hd nil l) <> 0 -> bs2nat (Sem Pred'_e l) = bs2nat (hd nil l) - 1.
Proof.
intros l H.
destruct l as [ | v l].
simpl hd.
induction v as [ | [ | ] v IH].
simpl Sem in *.
rewrite bs2nat_false.
rewrite bs2nat_true.
rewrite IH.
simpl in *.
destruct H as [H | H].
rewrite bs2nat_false in H.

*****
IH : forall _ : or (eq v nil) (not (eq (bs2nat v) O)),\neq\n (bs2nat\n (sem_Rec (fun _ : list (list bool) => nil)\n (fun vl : list (list bool) => cons true (nth (S O) vl nil))\n (fun vl : list (list bool) => cons false (nth O vl nil)) v l))\n (Init.Nat.sub (bs2nat v) (S O))
H : not (eq (Init.Nat.mul (S (S O)) (bs2nat v)) O)
l : list (list bool)
v : list bool
*****
or (eq v nil) (not (eq (bs2nat v) O))
+++++
simpl in H.
-----
Lemma Pred'_correct : forall l, hd nil l = nil \\/ bs2nat (hd nil l) <> 0 -> bs2nat (Sem Pred'_e l) = bs2nat (hd nil l) - 1.
Proof.
intros l H.
destruct l as [ | v l].
simpl hd.
induction v as [ | [ | ] v IH].
simpl Sem in *.
rewrite bs2nat_false.
rewrite bs2nat_true.
rewrite IH.
simpl in *.
destruct H as [H | H].
rewrite bs2nat_false in H.
simpl in H.

*****
IH : forall _ : or (eq v nil) (not (eq (bs2nat v) O)),\neq\n (bs2nat\n (sem_Rec (fun _ : list (list bool) => nil)\n (fun vl : list (list bool) => cons true (nth (S O) vl nil))\n (fun vl : list (list bool) => cons false (nth O vl nil)) v l))\n (Init.Nat.sub (bs2nat v) (S O))
H : not (eq (Init.Nat.add (bs2nat v) (Init.Nat.add (bs2nat v) O)) O)
l : list (list bool)
v : list bool
*****
or (eq v nil) (not (eq (bs2nat v) O))
+++++
right.
-----
Lemma Pred'_correct : forall l, hd nil l = nil \\/ bs2nat (hd nil l) <> 0 -> bs2nat (Sem Pred'_e l) = bs2nat (hd nil l) - 1.
Proof.
intros l H.
destruct l as [ | v l].
simpl hd.
induction v as [ | [ | ] v IH].
simpl Sem in *.
rewrite bs2nat_false.
rewrite bs2nat_true.
rewrite IH.
simpl in *.
destruct H as [H | H].
rewrite bs2nat_false in H.
simpl in H.
right.

*****
IH : forall _ : or (eq v nil) (not (eq (bs2nat v) O)),\neq\n (bs2nat\n (sem_Rec (fun _ : list (list bool) => nil)\n (fun vl : list (list bool) => cons true (nth (S O) vl nil))\n (fun vl : list (list bool) => cons false (nth O vl nil)) v l))\n (Init.Nat.sub (bs2nat v) (S O))
H : not (eq (Init.Nat.add (bs2nat v) (Init.Nat.add (bs2nat v) O)) O)
l : list (list bool)
v : list bool
*****
not (eq (bs2nat v) O)
+++++
omega.
-----
Lemma Pred'_correct : forall l, hd nil l = nil \\/ bs2nat (hd nil l) <> 0 -> bs2nat (Sem Pred'_e l) = bs2nat (hd nil l) - 1.
Proof.
intros l H.
destruct l as [ | v l].

*****

*****

+++++
Qed.
-----
Opaque Pred'_e.
-----
Definition Pred_e : Cobham :=\n  Comp 1 Pred'_e [Normalize_e].
-----
Lemma arity_Pred : arity Pred_e = ok_arity 1.
-----
Lemma arity_Pred : arity Pred_e = ok_arity 1.

*****

*****
eq (arity Pred_e) (ok_arity (S O))
+++++
Proof.
-----
Lemma arity_Pred : arity Pred_e = ok_arity 1.
Proof.

*****

*****
eq (arity Pred_e) (ok_arity (S O))
+++++
trivial.
-----
Lemma arity_Pred : arity Pred_e = ok_arity 1.
Proof.
trivial.

*****

*****

+++++
Qed.
-----
Lemma rec_bounded_Pred :\n  rec_bounded Pred_e.
-----
Lemma rec_bounded_Pred : rec_bounded Pred_e.

*****

*****
rec_bounded Pred_e
+++++
Proof.
-----
Lemma rec_bounded_Pred : rec_bounded Pred_e.
Proof.

*****

*****
rec_bounded Pred_e
+++++
simpl.
-----
Lemma rec_bounded_Pred : rec_bounded Pred_e.
Proof.
simpl.

*****

*****
and (rec_bounded Pred'_e) (and (rec_bounded Normalize_e) True)
+++++
intuition.
-----
Lemma rec_bounded_Pred : rec_bounded Pred_e.
Proof.
simpl.
intuition.

*****

*****
rec_bounded Pred'_e
+++++
apply rec_bounded_Pred'.
-----
Lemma rec_bounded_Pred : rec_bounded Pred_e.
Proof.
simpl.
intuition.

*****

*****
rec_bounded Normalize_e
+++++
apply rec_bounded_Normalize.
-----
Lemma rec_bounded_Pred : rec_bounded Pred_e.
Proof.
simpl.
intuition.

*****

*****

+++++
Qed.
-----
Lemma Pred_correct : forall l,\n  bs2nat (Sem Pred_e l) =  bs2nat (hd nil l) - 1.
-----
Lemma Pred_correct : forall l, bs2nat (Sem Pred_e l) = bs2nat (hd nil l) - 1.

*****

*****
forall l : list (list bool), eq (bs2nat (Sem Pred_e l)) (Init.Nat.sub (bs2nat (hd nil l)) (S O))
+++++
Proof.
-----
Lemma Pred_correct : forall l, bs2nat (Sem Pred_e l) = bs2nat (hd nil l) - 1.
Proof.

*****

*****
forall l : list (list bool), eq (bs2nat (Sem Pred_e l)) (Init.Nat.sub (bs2nat (hd nil l)) (S O))
+++++
intro l.
-----
Lemma Pred_correct : forall l, bs2nat (Sem Pred_e l) = bs2nat (hd nil l) - 1.
Proof.
intro l.

*****
l : list (list bool)
*****
eq (bs2nat (Sem Pred_e l)) (Init.Nat.sub (bs2nat (hd nil l)) (S O))
+++++
simpl.
-----
Lemma Pred_correct : forall l, bs2nat (Sem Pred_e l) = bs2nat (hd nil l) - 1.
Proof.
intro l.
simpl.

*****
l : list (list bool)
*****
eq (bs2nat (Sem Pred'_e (cons (Sem Normalize_e l) nil))) (Init.Nat.sub (bs2nat (hd nil l)) (S O))
+++++
rewrite Pred'_correct.
-----
Lemma Pred_correct : forall l, bs2nat (Sem Pred_e l) = bs2nat (hd nil l) - 1.
Proof.
intro l.
simpl.
rewrite Pred'_correct.

*****
l : list (list bool)
*****
eq (Init.Nat.sub (bs2nat (hd nil (cons (Sem Normalize_e l) nil))) (S O)) (Init.Nat.sub (bs2nat (hd nil l)) (S O))
+++++
simpl.
-----
Lemma Pred_correct : forall l, bs2nat (Sem Pred_e l) = bs2nat (hd nil l) - 1.
Proof.
intro l.
simpl.
rewrite Pred'_correct.
simpl.

*****
l : list (list bool)
*****
eq (Init.Nat.sub (bs2nat (Sem Normalize_e l)) (S O)) (Init.Nat.sub (bs2nat (hd nil l)) (S O))
+++++
rewrite Normalize_correct.
-----
Lemma Pred_correct : forall l, bs2nat (Sem Pred_e l) = bs2nat (hd nil l) - 1.
Proof.
intro l.
simpl.
rewrite Pred'_correct.
simpl.
rewrite Normalize_correct.

*****
l : list (list bool)
*****
eq (Init.Nat.sub (bs2nat (Sem (Proj (S O) O) l)) (S O)) (Init.Nat.sub (bs2nat (hd nil l)) (S O))
+++++
simpl.
-----
Lemma Pred_correct : forall l, bs2nat (Sem Pred_e l) = bs2nat (hd nil l) - 1.
Proof.
intro l.
simpl.
rewrite Pred'_correct.
simpl.
rewrite Normalize_correct.
simpl.

*****
l : list (list bool)
*****
eq (Init.Nat.sub (bs2nat (nth O l nil)) (S O)) (Init.Nat.sub (bs2nat (hd nil l)) (S O))
+++++
rewrite hd_nth_0.
-----
Lemma Pred_correct : forall l, bs2nat (Sem Pred_e l) = bs2nat (hd nil l) - 1.
Proof.
intro l.
simpl.
rewrite Pred'_correct.
simpl.
rewrite Normalize_correct.
simpl.
rewrite hd_nth_0.

*****
l : list (list bool)
*****
eq (Init.Nat.sub (bs2nat (nth O l nil)) (S O)) (Init.Nat.sub (bs2nat (nth O l nil)) (S O))
+++++
trivial.
-----
Lemma Pred_correct : forall l, bs2nat (Sem Pred_e l) = bs2nat (hd nil l) - 1.
Proof.
intro l.
simpl.
rewrite Pred'_correct.

*****
l : list (list bool)
*****
or (eq (hd nil (cons (Sem Normalize_e l) nil)) nil) (not (eq (bs2nat (hd nil (cons (Sem Normalize_e l) nil))) O))
+++++
apply Normalize_normal.
-----
Lemma Pred_correct : forall l, bs2nat (Sem Pred_e l) = bs2nat (hd nil l) - 1.
Proof.
intro l.
simpl.
rewrite Pred'_correct.

*****

*****

+++++
Qed.
-----
Opaque Pred_e.
-----
Definition OneMinus'_e : Cobham :=\n  Rec2\n    (One_e 0)\n    (Zero_e 2)\n    (One_e 1).
-----
Lemma arity_OneMinus' : arity OneMinus'_e = ok_arity 1.
-----
Lemma arity_OneMinus' : arity OneMinus'_e = ok_arity 1.

*****

*****
eq (arity OneMinus'_e) (ok_arity (S O))
+++++
Proof.
-----
Lemma arity_OneMinus' : arity OneMinus'_e = ok_arity 1.
Proof.

*****

*****
eq (arity OneMinus'_e) (ok_arity (S O))
+++++
trivial.
-----
Lemma arity_OneMinus' : arity OneMinus'_e = ok_arity 1.
Proof.
trivial.

*****

*****

+++++
Qed.
-----
Lemma rec_bounded_OneMinus' :\n  rec_bounded OneMinus'_e.
-----
Lemma rec_bounded_OneMinus' : rec_bounded OneMinus'_e.

*****

*****
rec_bounded OneMinus'_e
+++++
Proof.
-----
Lemma rec_bounded_OneMinus' : rec_bounded OneMinus'_e.
Proof.

*****

*****
rec_bounded OneMinus'_e
+++++
simpl.
-----
Lemma rec_bounded_OneMinus' : rec_bounded OneMinus'_e.
Proof.
simpl.

*****

*****
and (rec_bounded (One_e (S O))) (and (rec_bounded (One_e O)) (and (rec_bounded (Zero_e (S (S O)))) (and (rec_bounded (Zero_e (S (S O)))) (forall l : list (list bool), le (length (sem_Rec (Sem (One_e O)) (Sem (Zero_e (S (S O)))) (Sem (Zero_e (S (S O)))) (hd nil l) (tl l))) (length (Sem (One_e (S O)) l))))))
+++++
intuition.
-----
Lemma rec_bounded_OneMinus' : rec_bounded OneMinus'_e.
Proof.
simpl.
intuition.

*****

*****
rec_bounded (One_e (S O))
+++++
apply rec_bounded_One.
-----
Lemma rec_bounded_OneMinus' : rec_bounded OneMinus'_e.
Proof.
simpl.
intuition.

*****

*****
rec_bounded (One_e O)
+++++
apply rec_bounded_One.
-----
Lemma rec_bounded_OneMinus' : rec_bounded OneMinus'_e.
Proof.
simpl.
intuition.

*****

*****
rec_bounded (Zero_e (S (S O)))
+++++
apply rec_bounded_Zero.
-----
Lemma rec_bounded_OneMinus' : rec_bounded OneMinus'_e.
Proof.
simpl.
intuition.

*****

*****
rec_bounded (Zero_e (S (S O)))
+++++
apply rec_bounded_Zero.
-----
Lemma rec_bounded_OneMinus' : rec_bounded OneMinus'_e.
Proof.
simpl.
intuition.

*****
l : list (list bool)
*****
le (length (sem_Rec (Sem (One_e O)) (Sem (Zero_e (S (S O)))) (Sem (Zero_e (S (S O)))) (hd nil l) (tl l))) (length (Sem (One_e (S O)) l))
+++++
destruct l as [ | v l].
-----
Lemma rec_bounded_OneMinus' : rec_bounded OneMinus'_e.
Proof.
simpl.
intuition.
destruct l as [ | v l].

*****

*****
le (length (sem_Rec (Sem (One_e O)) (Sem (Zero_e (S (S O)))) (Sem (Zero_e (S (S O)))) (hd nil nil) (tl nil))) (length (Sem (One_e (S O)) nil))
+++++
trivial.
-----
Lemma rec_bounded_OneMinus' : rec_bounded OneMinus'_e.
Proof.
simpl.
intuition.
destruct l as [ | v l].

*****
l : list (list bool)
v : list bool
*****
le (length (sem_Rec (Sem (One_e O)) (Sem (Zero_e (S (S O)))) (Sem (Zero_e (S (S O)))) (hd nil (cons v l)) (tl (cons v l)))) (length (Sem (One_e (S O)) (cons v l)))
+++++
simpl.
-----
Lemma rec_bounded_OneMinus' : rec_bounded OneMinus'_e.
Proof.
simpl.
intuition.
destruct l as [ | v l].
simpl.

*****
l : list (list bool)
v : list bool
*****
le (length (sem_Rec (Sem (One_e O)) (Sem (Zero_e (S (S O)))) (Sem (Zero_e (S (S O)))) v l)) (length (Sem (One_e (S O)) (cons v l)))
+++++
induction v as [ | [ | ] v IH].
-----
Lemma rec_bounded_OneMinus' : rec_bounded OneMinus'_e.
Proof.
simpl.
intuition.
destruct l as [ | v l].
simpl.
induction v as [ | [ | ] v IH].

*****
l : list (list bool)
*****
le (length (sem_Rec (Sem (One_e O)) (Sem (Zero_e (S (S O)))) (Sem (Zero_e (S (S O)))) nil l)) (length (Sem (One_e (S O)) (cons nil l)))
+++++
trivial.
-----
Lemma rec_bounded_OneMinus' : rec_bounded OneMinus'_e.
Proof.
simpl.
intuition.
destruct l as [ | v l].
simpl.
induction v as [ | [ | ] v IH].

*****
IH : le\n (length\n (sem_Rec (Sem (One_e O)) (Sem (Zero_e (S (S O))))\n (Sem (Zero_e (S (S O)))) v l))\n (length (Sem (One_e (S O)) (cons v l)))
l : list (list bool)
v : list bool
*****
le (length (sem_Rec (Sem (One_e O)) (Sem (Zero_e (S (S O)))) (Sem (Zero_e (S (S O)))) (cons true v) l)) (length (Sem (One_e (S O)) (cons (cons true v) l)))
+++++
auto with arith.
-----
Lemma rec_bounded_OneMinus' : rec_bounded OneMinus'_e.
Proof.
simpl.
intuition.
destruct l as [ | v l].
simpl.
induction v as [ | [ | ] v IH].

*****
IH : le\n (length\n (sem_Rec (Sem (One_e O)) (Sem (Zero_e (S (S O))))\n (Sem (Zero_e (S (S O)))) v l))\n (length (Sem (One_e (S O)) (cons v l)))
l : list (list bool)
v : list bool
*****
le (length (sem_Rec (Sem (One_e O)) (Sem (Zero_e (S (S O)))) (Sem (Zero_e (S (S O)))) (cons false v) l)) (length (Sem (One_e (S O)) (cons (cons false v) l)))
+++++
auto with arith.
-----
Lemma rec_bounded_OneMinus' : rec_bounded OneMinus'_e.
Proof.
simpl.
intuition.

*****

*****

+++++
Qed.
-----
Lemma OneMinus'_correct : forall l,\n  hd nil l = nil \/ bs2nat (hd nil l) <> 0 ->\n  bs2nat (Sem OneMinus'_e l) = 1 - bs2nat (hd nil l).
-----
Lemma OneMinus'_correct : forall l, hd nil l = nil \\/ bs2nat (hd nil l) <> 0 -> bs2nat (Sem OneMinus'_e l) = 1 - bs2nat (hd nil l).

*****

*****
forall (l : list (list bool)) (_ : or (eq (hd nil l) nil) (not (eq (bs2nat (hd nil l)) O))), eq (bs2nat (Sem OneMinus'_e l)) (Init.Nat.sub (S O) (bs2nat (hd nil l)))
+++++
Proof.
-----
Lemma OneMinus'_correct : forall l, hd nil l = nil \\/ bs2nat (hd nil l) <> 0 -> bs2nat (Sem OneMinus'_e l) = 1 - bs2nat (hd nil l).
Proof.

*****

*****
forall (l : list (list bool)) (_ : or (eq (hd nil l) nil) (not (eq (bs2nat (hd nil l)) O))), eq (bs2nat (Sem OneMinus'_e l)) (Init.Nat.sub (S O) (bs2nat (hd nil l)))
+++++
intros [ | v l] H.
-----
Lemma OneMinus'_correct : forall l, hd nil l = nil \\/ bs2nat (hd nil l) <> 0 -> bs2nat (Sem OneMinus'_e l) = 1 - bs2nat (hd nil l).
Proof.
intros [ | v l] H.

*****
H : or (eq (hd nil nil) nil) (not (eq (bs2nat (hd nil nil)) O))
*****
eq (bs2nat (Sem OneMinus'_e nil)) (Init.Nat.sub (S O) (bs2nat (hd nil nil)))
+++++
trivial.
-----
Lemma OneMinus'_correct : forall l, hd nil l = nil \\/ bs2nat (hd nil l) <> 0 -> bs2nat (Sem OneMinus'_e l) = 1 - bs2nat (hd nil l).
Proof.
intros [ | v l] H.

*****
H : or (eq (hd nil (cons v l)) nil)\n (not (eq (bs2nat (hd nil (cons v l))) O))
l : list (list bool)
v : list bool
*****
eq (bs2nat (Sem OneMinus'_e (cons v l))) (Init.Nat.sub (S O) (bs2nat (hd nil (cons v l))))
+++++
simpl hd.
-----
Lemma OneMinus'_correct : forall l, hd nil l = nil \\/ bs2nat (hd nil l) <> 0 -> bs2nat (Sem OneMinus'_e l) = 1 - bs2nat (hd nil l).
Proof.
intros [ | v l] H.
simpl hd.

*****
H : or (eq (hd nil (cons v l)) nil)\n (not (eq (bs2nat (hd nil (cons v l))) O))
l : list (list bool)
v : list bool
*****
eq (bs2nat (Sem OneMinus'_e (cons v l))) (Init.Nat.sub (S O) (bs2nat v))
+++++
destruct v as [ | [ | ] v].
-----
Lemma OneMinus'_correct : forall l, hd nil l = nil \\/ bs2nat (hd nil l) <> 0 -> bs2nat (Sem OneMinus'_e l) = 1 - bs2nat (hd nil l).
Proof.
intros [ | v l] H.
simpl hd.
destruct v as [ | [ | ] v].

*****
H : or (eq (hd nil (cons nil l)) nil)\n (not (eq (bs2nat (hd nil (cons nil l))) O))
l : list (list bool)
*****
eq (bs2nat (Sem OneMinus'_e (cons nil l))) (Init.Nat.sub (S O) (bs2nat nil))
+++++
trivial.
-----
Lemma OneMinus'_correct : forall l, hd nil l = nil \\/ bs2nat (hd nil l) <> 0 -> bs2nat (Sem OneMinus'_e l) = 1 - bs2nat (hd nil l).
Proof.
intros [ | v l] H.
simpl hd.
destruct v as [ | [ | ] v].

*****
H : or (eq (hd nil (cons (cons true v) l)) nil)\n (not (eq (bs2nat (hd nil (cons (cons true v) l))) O))
l : list (list bool)
v : list bool
*****
eq (bs2nat (Sem OneMinus'_e (cons (cons true v) l))) (Init.Nat.sub (S O) (bs2nat (cons true v)))
+++++
trivial.
-----
Lemma OneMinus'_correct : forall l, hd nil l = nil \\/ bs2nat (hd nil l) <> 0 -> bs2nat (Sem OneMinus'_e l) = 1 - bs2nat (hd nil l).
Proof.
intros [ | v l] H.
simpl hd.
destruct v as [ | [ | ] v].

*****
H : or (eq (hd nil (cons (cons false v) l)) nil)\n (not (eq (bs2nat (hd nil (cons (cons false v) l))) O))
l : list (list bool)
v : list bool
*****
eq (bs2nat (Sem OneMinus'_e (cons (cons false v) l))) (Init.Nat.sub (S O) (bs2nat (cons false v)))
+++++
simpl Sem in *.
-----
Lemma OneMinus'_correct : forall l, hd nil l = nil \\/ bs2nat (hd nil l) <> 0 -> bs2nat (Sem OneMinus'_e l) = 1 - bs2nat (hd nil l).
Proof.
intros [ | v l] H.
simpl hd.
destruct v as [ | [ | ] v].
simpl Sem in *.

*****
H : or (eq (hd nil (cons (cons false v) l)) nil)\n (not (eq (bs2nat (hd nil (cons (cons false v) l))) O))
l : list (list bool)
v : list bool
*****
eq (bs2nat (Sem (Zero_e (S (S O))) (cons v (cons (sem_Rec (Sem (One_e O)) (Sem (Zero_e (S (S O)))) (Sem (Zero_e (S (S O)))) v l) l)))) (Init.Nat.sub (S O) (bs2nat (cons false v)))
+++++
simpl in *.
-----
Lemma OneMinus'_correct : forall l, hd nil l = nil \\/ bs2nat (hd nil l) <> 0 -> bs2nat (Sem OneMinus'_e l) = 1 - bs2nat (hd nil l).
Proof.
intros [ | v l] H.
simpl hd.
destruct v as [ | [ | ] v].
simpl Sem in *.
simpl in *.

*****
H : or (eq (cons false v) nil) (not (eq (bs2nat (cons false v)) O))
l : list (list bool)
v : list bool
*****
eq (bs2nat (Sem (Zero_e (S (S O))) (cons v (cons (sem_Rec (Sem (One_e O)) (Sem (Zero_e (S (S O)))) (Sem (Zero_e (S (S O)))) v l) l)))) match bs2nat (cons false v) with | O => S O | S _ => O end
+++++
rewrite Zero_correct.
-----
Lemma OneMinus'_correct : forall l, hd nil l = nil \\/ bs2nat (hd nil l) <> 0 -> bs2nat (Sem OneMinus'_e l) = 1 - bs2nat (hd nil l).
Proof.
intros [ | v l] H.
simpl hd.
destruct v as [ | [ | ] v].
simpl Sem in *.
simpl in *.
rewrite Zero_correct.

*****
H : or (eq (cons false v) nil) (not (eq (bs2nat (cons false v)) O))
l : list (list bool)
v : list bool
*****
eq O match bs2nat (cons false v) with | O => S O | S _ => O end
+++++
rewrite bs2nat_false in *.
-----
Lemma OneMinus'_correct : forall l, hd nil l = nil \\/ bs2nat (hd nil l) <> 0 -> bs2nat (Sem OneMinus'_e l) = 1 - bs2nat (hd nil l).
Proof.
intros [ | v l] H.
simpl hd.
destruct v as [ | [ | ] v].
simpl Sem in *.
simpl in *.
rewrite Zero_correct.
rewrite bs2nat_false in *.

*****
H : or (eq (cons false v) nil)\n (not (eq (Init.Nat.mul (S (S O)) (bs2nat v)) O))
l : list (list bool)
v : list bool
*****
eq O match Init.Nat.mul (S (S O)) (bs2nat v) with | O => S O | S _ => O end
+++++
destruct H as [H | H].
-----
Lemma OneMinus'_correct : forall l, hd nil l = nil \\/ bs2nat (hd nil l) <> 0 -> bs2nat (Sem OneMinus'_e l) = 1 - bs2nat (hd nil l).
Proof.
intros [ | v l] H.
simpl hd.
destruct v as [ | [ | ] v].
simpl Sem in *.
simpl in *.
rewrite Zero_correct.
rewrite bs2nat_false in *.
destruct H as [H | H].

*****
H : eq (cons false v) nil
l : list (list bool)
v : list bool
*****
eq O match Init.Nat.mul (S (S O)) (bs2nat v) with | O => S O | S _ => O end
+++++
congruence.
-----
Lemma OneMinus'_correct : forall l, hd nil l = nil \\/ bs2nat (hd nil l) <> 0 -> bs2nat (Sem OneMinus'_e l) = 1 - bs2nat (hd nil l).
Proof.
intros [ | v l] H.
simpl hd.
destruct v as [ | [ | ] v].
simpl Sem in *.
simpl in *.
rewrite Zero_correct.
rewrite bs2nat_false in *.
destruct H as [H | H].

*****
H : not (eq (Init.Nat.mul (S (S O)) (bs2nat v)) O)
l : list (list bool)
v : list bool
*****
eq O match Init.Nat.mul (S (S O)) (bs2nat v) with | O => S O | S _ => O end
+++++
destruct (2 * bs2nat v).
-----
Lemma OneMinus'_correct : forall l, hd nil l = nil \\/ bs2nat (hd nil l) <> 0 -> bs2nat (Sem OneMinus'_e l) = 1 - bs2nat (hd nil l).
Proof.
intros [ | v l] H.
simpl hd.
destruct v as [ | [ | ] v].
simpl Sem in *.
simpl in *.
rewrite Zero_correct.
rewrite bs2nat_false in *.
destruct H as [H | H].
destruct (2 * bs2nat v).

*****
H : not (eq O O)
l : list (list bool)
v : list bool
*****
eq O (S O)
+++++
tauto.
-----
Lemma OneMinus'_correct : forall l, hd nil l = nil \\/ bs2nat (hd nil l) <> 0 -> bs2nat (Sem OneMinus'_e l) = 1 - bs2nat (hd nil l).
Proof.
intros [ | v l] H.
simpl hd.
destruct v as [ | [ | ] v].
simpl Sem in *.
simpl in *.
rewrite Zero_correct.
rewrite bs2nat_false in *.
destruct H as [H | H].
destruct (2 * bs2nat v).

*****
H : not (eq (S n) O)
n : nat
l : list (list bool)
v : list bool
*****
eq O O
+++++
trivial.
-----
Lemma OneMinus'_correct : forall l, hd nil l = nil \\/ bs2nat (hd nil l) <> 0 -> bs2nat (Sem OneMinus'_e l) = 1 - bs2nat (hd nil l).
Proof.
intros [ | v l] H.

*****

*****

+++++
Qed.
-----
Opaque OneMinus'_e.
-----
Definition OneMinus_e : Cobham :=\n  Comp 1 OneMinus'_e [Normalize_e].
-----
Lemma arity_OneMinus : arity OneMinus_e = ok_arity 1.
-----
Lemma arity_OneMinus : arity OneMinus_e = ok_arity 1.

*****

*****
eq (arity OneMinus_e) (ok_arity (S O))
+++++
Proof.
-----
Lemma arity_OneMinus : arity OneMinus_e = ok_arity 1.
Proof.

*****

*****
eq (arity OneMinus_e) (ok_arity (S O))
+++++
trivial.
-----
Lemma arity_OneMinus : arity OneMinus_e = ok_arity 1.
Proof.
trivial.

*****

*****

+++++
Qed.
-----
Lemma rec_bounded_OneMinus :\n  rec_bounded OneMinus_e.
-----
Lemma rec_bounded_OneMinus : rec_bounded OneMinus_e.

*****

*****
rec_bounded OneMinus_e
+++++
Proof.
-----
Lemma rec_bounded_OneMinus : rec_bounded OneMinus_e.
Proof.

*****

*****
rec_bounded OneMinus_e
+++++
simpl.
-----
Lemma rec_bounded_OneMinus : rec_bounded OneMinus_e.
Proof.
simpl.

*****

*****
and (rec_bounded OneMinus'_e) (and (rec_bounded Normalize_e) True)
+++++
intuition.
-----
Lemma rec_bounded_OneMinus : rec_bounded OneMinus_e.
Proof.
simpl.
intuition.

*****

*****
rec_bounded OneMinus'_e
+++++
apply rec_bounded_OneMinus'.
-----
Lemma rec_bounded_OneMinus : rec_bounded OneMinus_e.
Proof.
simpl.
intuition.

*****

*****
rec_bounded Normalize_e
+++++
apply rec_bounded_Normalize.
-----
Lemma rec_bounded_OneMinus : rec_bounded OneMinus_e.
Proof.
simpl.
intuition.

*****

*****

+++++
Qed.
-----
Lemma OneMinus_correct : forall l,\n  bs2nat (Sem OneMinus_e l) = 1 - bs2nat (hd nil l).
-----
Lemma OneMinus_correct : forall l, bs2nat (Sem OneMinus_e l) = 1 - bs2nat (hd nil l).

*****

*****
forall l : list (list bool), eq (bs2nat (Sem OneMinus_e l)) (Init.Nat.sub (S O) (bs2nat (hd nil l)))
+++++
Proof.
-----
Lemma OneMinus_correct : forall l, bs2nat (Sem OneMinus_e l) = 1 - bs2nat (hd nil l).
Proof.

*****

*****
forall l : list (list bool), eq (bs2nat (Sem OneMinus_e l)) (Init.Nat.sub (S O) (bs2nat (hd nil l)))
+++++
intro l.
-----
Lemma OneMinus_correct : forall l, bs2nat (Sem OneMinus_e l) = 1 - bs2nat (hd nil l).
Proof.
intro l.

*****
l : list (list bool)
*****
eq (bs2nat (Sem OneMinus_e l)) (Init.Nat.sub (S O) (bs2nat (hd nil l)))
+++++
simpl.
-----
Lemma OneMinus_correct : forall l, bs2nat (Sem OneMinus_e l) = 1 - bs2nat (hd nil l).
Proof.
intro l.
simpl.

*****
l : list (list bool)
*****
eq (bs2nat (Sem OneMinus'_e (cons (Sem Normalize_e l) nil))) match bs2nat (hd nil l) with | O => S O | S _ => O end
+++++
rewrite OneMinus'_correct.
-----
Lemma OneMinus_correct : forall l, bs2nat (Sem OneMinus_e l) = 1 - bs2nat (hd nil l).
Proof.
intro l.
simpl.
rewrite OneMinus'_correct.

*****
l : list (list bool)
*****
eq (Init.Nat.sub (S O) (bs2nat (hd nil (cons (Sem Normalize_e l) nil)))) match bs2nat (hd nil l) with | O => S O | S _ => O end
+++++
simpl.
-----
Lemma OneMinus_correct : forall l, bs2nat (Sem OneMinus_e l) = 1 - bs2nat (hd nil l).
Proof.
intro l.
simpl.
rewrite OneMinus'_correct.
simpl.

*****
l : list (list bool)
*****
eq match bs2nat (Sem Normalize_e l) with | O => S O | S _ => O end match bs2nat (hd nil l) with | O => S O | S _ => O end
+++++
rewrite Normalize_correct.
-----
Lemma OneMinus_correct : forall l, bs2nat (Sem OneMinus_e l) = 1 - bs2nat (hd nil l).
Proof.
intro l.
simpl.
rewrite OneMinus'_correct.
simpl.
rewrite Normalize_correct.

*****
l : list (list bool)
*****
eq match bs2nat (Sem (Proj (S O) O) l) with | O => S O | S _ => O end match bs2nat (hd nil l) with | O => S O | S _ => O end
+++++
simpl.
-----
Lemma OneMinus_correct : forall l, bs2nat (Sem OneMinus_e l) = 1 - bs2nat (hd nil l).
Proof.
intro l.
simpl.
rewrite OneMinus'_correct.
simpl.
rewrite Normalize_correct.
simpl.

*****
l : list (list bool)
*****
eq match bs2nat (nth O l nil) with | O => S O | S _ => O end match bs2nat (hd nil l) with | O => S O | S _ => O end
+++++
rewrite hd_nth_0.
-----
Lemma OneMinus_correct : forall l, bs2nat (Sem OneMinus_e l) = 1 - bs2nat (hd nil l).
Proof.
intro l.
simpl.
rewrite OneMinus'_correct.
simpl.
rewrite Normalize_correct.
simpl.
rewrite hd_nth_0.

*****
l : list (list bool)
*****
eq match bs2nat (nth O l nil) with | O => S O | S _ => O end match bs2nat (nth O l nil) with | O => S O | S _ => O end
+++++
trivial.
-----
Lemma OneMinus_correct : forall l, bs2nat (Sem OneMinus_e l) = 1 - bs2nat (hd nil l).
Proof.
intro l.
simpl.
rewrite OneMinus'_correct.

*****
l : list (list bool)
*****
or (eq (hd nil (cons (Sem Normalize_e l) nil)) nil) (not (eq (bs2nat (hd nil (cons (Sem Normalize_e l) nil))) O))
+++++
apply Normalize_normal.
-----
Lemma OneMinus_correct : forall l, bs2nat (Sem OneMinus_e l) = 1 - bs2nat (hd nil l).
Proof.
intro l.
simpl.
rewrite OneMinus'_correct.

*****

*****

+++++
Qed.
-----
Opaque OneMinus_e.
-----
Definition Div2_e : Cobham :=\n  Rec2\n    Zero\n    (Proj 2 0)\n    (Proj 1 0).
-----
Lemma arity_Div2 : arity Div2_e = ok_arity 1.
-----
Lemma arity_Div2 : arity Div2_e = ok_arity 1.

*****

*****
eq (arity Div2_e) (ok_arity (S O))
+++++
Proof.
-----
Lemma arity_Div2 : arity Div2_e = ok_arity 1.
Proof.

*****

*****
eq (arity Div2_e) (ok_arity (S O))
+++++
trivial.
-----
Lemma arity_Div2 : arity Div2_e = ok_arity 1.
Proof.
trivial.

*****

*****

+++++
Qed.
-----
Lemma length_Div2 : forall l,\n  length (Sem Div2_e l) = length (hd nil l) - 1.
-----
Lemma length_Div2 : forall l, length (Sem Div2_e l) = length (hd nil l) - 1.

*****

*****
forall l : list (list bool), eq (length (Sem Div2_e l)) (Init.Nat.sub (length (hd nil l)) (S O))
+++++
Proof.
-----
Lemma length_Div2 : forall l, length (Sem Div2_e l) = length (hd nil l) - 1.
Proof.

*****

*****
forall l : list (list bool), eq (length (Sem Div2_e l)) (Init.Nat.sub (length (hd nil l)) (S O))
+++++
destruct l as [ | v l].
-----
Lemma length_Div2 : forall l, length (Sem Div2_e l) = length (hd nil l) - 1.
Proof.
destruct l as [ | v l].

*****

*****
eq (length (Sem Div2_e nil)) (Init.Nat.sub (length (hd nil nil)) (S O))
+++++
trivial.
-----
Lemma length_Div2 : forall l, length (Sem Div2_e l) = length (hd nil l) - 1.
Proof.
destruct l as [ | v l].

*****
l : list (list bool)
v : list bool
*****
eq (length (Sem Div2_e (cons v l))) (Init.Nat.sub (length (hd nil (cons v l))) (S O))
+++++
simpl.
-----
Lemma length_Div2 : forall l, length (Sem Div2_e l) = length (hd nil l) - 1.
Proof.
destruct l as [ | v l].
simpl.

*****
l : list (list bool)
v : list bool
*****
eq (length (sem_Rec (fun _ : list (list bool) => nil) (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => nth O vl nil) v l)) (Init.Nat.sub (length v) (S O))
+++++
induction v as [ | [ | ] v IH].
-----
Lemma length_Div2 : forall l, length (Sem Div2_e l) = length (hd nil l) - 1.
Proof.
destruct l as [ | v l].
simpl.
induction v as [ | [ | ] v IH].

*****
l : list (list bool)
*****
eq (length (sem_Rec (fun _ : list (list bool) => nil) (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => nth O vl nil) nil l)) (Init.Nat.sub (length nil) (S O))
+++++
trivial.
-----
Lemma length_Div2 : forall l, length (Sem Div2_e l) = length (hd nil l) - 1.
Proof.
destruct l as [ | v l].
simpl.
induction v as [ | [ | ] v IH].

*****
IH : eq\n (length\n (sem_Rec (fun _ : list (list bool) => nil)\n (fun vl : list (list bool) => nth O vl nil)\n (fun vl : list (list bool) => nth O vl nil) v l))\n (Init.Nat.sub (length v) (S O))
l : list (list bool)
v : list bool
*****
eq (length (sem_Rec (fun _ : list (list bool) => nil) (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => nth O vl nil) (cons true v) l)) (Init.Nat.sub (length (cons true v)) (S O))
+++++
simpl.
-----
Lemma length_Div2 : forall l, length (Sem Div2_e l) = length (hd nil l) - 1.
Proof.
destruct l as [ | v l].
simpl.
induction v as [ | [ | ] v IH].
simpl.

*****
IH : eq\n (length\n (sem_Rec (fun _ : list (list bool) => nil)\n (fun vl : list (list bool) => nth O vl nil)\n (fun vl : list (list bool) => nth O vl nil) v l))\n (Init.Nat.sub (length v) (S O))
l : list (list bool)
v : list bool
*****
eq (length v) (Init.Nat.sub (length v) O)
+++++
omega.
-----
Lemma length_Div2 : forall l, length (Sem Div2_e l) = length (hd nil l) - 1.
Proof.
destruct l as [ | v l].
simpl.
induction v as [ | [ | ] v IH].

*****
IH : eq\n (length\n (sem_Rec (fun _ : list (list bool) => nil)\n (fun vl : list (list bool) => nth O vl nil)\n (fun vl : list (list bool) => nth O vl nil) v l))\n (Init.Nat.sub (length v) (S O))
l : list (list bool)
v : list bool
*****
eq (length (sem_Rec (fun _ : list (list bool) => nil) (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => nth O vl nil) (cons false v) l)) (Init.Nat.sub (length (cons false v)) (S O))
+++++
simpl.
-----
Lemma length_Div2 : forall l, length (Sem Div2_e l) = length (hd nil l) - 1.
Proof.
destruct l as [ | v l].
simpl.
induction v as [ | [ | ] v IH].
simpl.

*****
IH : eq\n (length\n (sem_Rec (fun _ : list (list bool) => nil)\n (fun vl : list (list bool) => nth O vl nil)\n (fun vl : list (list bool) => nth O vl nil) v l))\n (Init.Nat.sub (length v) (S O))
l : list (list bool)
v : list bool
*****
eq (length v) (Init.Nat.sub (length v) O)
+++++
omega.
-----
Lemma length_Div2 : forall l, length (Sem Div2_e l) = length (hd nil l) - 1.
Proof.
destruct l as [ | v l].

*****

*****

+++++
Qed.
-----
Lemma rec_bounded_Div2 :\n  rec_bounded Div2_e.
-----
Lemma rec_bounded_Div2 : rec_bounded Div2_e.

*****

*****
rec_bounded Div2_e
+++++
Proof.
-----
Lemma rec_bounded_Div2 : rec_bounded Div2_e.
Proof.

*****

*****
rec_bounded Div2_e
+++++
simpl.
-----
Lemma rec_bounded_Div2 : rec_bounded Div2_e.
Proof.
simpl.

*****

*****
and True (and True (and True (and True (forall l : list (list bool), le (length (sem_Rec (fun _ : list (list bool) => nil) (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => nth O vl nil) (hd nil l) (tl l))) (length (nth O l nil))))))
+++++
intuition.
-----
Lemma rec_bounded_Div2 : rec_bounded Div2_e.
Proof.
simpl.
intuition.

*****
l : list (list bool)
*****
le (length (sem_Rec (fun _ : list (list bool) => nil) (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => nth O vl nil) (hd nil l) (tl l))) (length (nth O l nil))
+++++
destruct l as [ | v l].
-----
Lemma rec_bounded_Div2 : rec_bounded Div2_e.
Proof.
simpl.
intuition.
destruct l as [ | v l].

*****

*****
le (length (sem_Rec (fun _ : list (list bool) => nil) (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => nth O vl nil) (hd nil nil) (tl nil))) (length (nth O nil nil))
+++++
trivial.
-----
Lemma rec_bounded_Div2 : rec_bounded Div2_e.
Proof.
simpl.
intuition.
destruct l as [ | v l].

*****
l : list (list bool)
v : list bool
*****
le (length (sem_Rec (fun _ : list (list bool) => nil) (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => nth O vl nil) (hd nil (cons v l)) (tl (cons v l)))) (length (nth O (cons v l) nil))
+++++
simpl.
-----
Lemma rec_bounded_Div2 : rec_bounded Div2_e.
Proof.
simpl.
intuition.
destruct l as [ | v l].
simpl.

*****
l : list (list bool)
v : list bool
*****
le (length (sem_Rec (fun _ : list (list bool) => nil) (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => nth O vl nil) v l)) (length v)
+++++
destruct v as [ | [ | ] v].
-----
Lemma rec_bounded_Div2 : rec_bounded Div2_e.
Proof.
simpl.
intuition.
destruct l as [ | v l].
simpl.
destruct v as [ | [ | ] v].

*****
l : list (list bool)
*****
le (length (sem_Rec (fun _ : list (list bool) => nil) (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => nth O vl nil) nil l)) (length nil)
+++++
trivial.
-----
Lemma rec_bounded_Div2 : rec_bounded Div2_e.
Proof.
simpl.
intuition.
destruct l as [ | v l].
simpl.
destruct v as [ | [ | ] v].

*****
l : list (list bool)
v : list bool
*****
le (length (sem_Rec (fun _ : list (list bool) => nil) (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => nth O vl nil) (cons true v) l)) (length (cons true v))
+++++
simpl.
-----
Lemma rec_bounded_Div2 : rec_bounded Div2_e.
Proof.
simpl.
intuition.
destruct l as [ | v l].
simpl.
destruct v as [ | [ | ] v].
simpl.

*****
l : list (list bool)
v : list bool
*****
le (length v) (S (length v))
+++++
omega.
-----
Lemma rec_bounded_Div2 : rec_bounded Div2_e.
Proof.
simpl.
intuition.
destruct l as [ | v l].
simpl.
destruct v as [ | [ | ] v].

*****
l : list (list bool)
v : list bool
*****
le (length (sem_Rec (fun _ : list (list bool) => nil) (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => nth O vl nil) (cons false v) l)) (length (cons false v))
+++++
simpl.
-----
Lemma rec_bounded_Div2 : rec_bounded Div2_e.
Proof.
simpl.
intuition.
destruct l as [ | v l].
simpl.
destruct v as [ | [ | ] v].
simpl.

*****
l : list (list bool)
v : list bool
*****
le (length v) (S (length v))
+++++
omega.
-----
Lemma rec_bounded_Div2 : rec_bounded Div2_e.
Proof.
simpl.
intuition.
destruct l as [ | v l].

*****

*****

+++++
Qed.
-----
Lemma Div2_correct_bs : forall l,\n  Sem Div2_e l =\n  tl (hd nil l).
-----
Lemma Div2_correct_bs : forall l, Sem Div2_e l = tl (hd nil l).

*****

*****
forall l : list (list bool), eq (Sem Div2_e l) (tl (hd nil l))
+++++
Proof.
-----
Lemma Div2_correct_bs : forall l, Sem Div2_e l = tl (hd nil l).
Proof.

*****

*****
forall l : list (list bool), eq (Sem Div2_e l) (tl (hd nil l))
+++++
destruct l as [ | v l].
-----
Lemma Div2_correct_bs : forall l, Sem Div2_e l = tl (hd nil l).
Proof.
destruct l as [ | v l].

*****

*****
eq (Sem Div2_e nil) (tl (hd nil nil))
+++++
trivial.
-----
Lemma Div2_correct_bs : forall l, Sem Div2_e l = tl (hd nil l).
Proof.
destruct l as [ | v l].

*****
l : list (list bool)
v : list bool
*****
eq (Sem Div2_e (cons v l)) (tl (hd nil (cons v l)))
+++++
simpl.
-----
Lemma Div2_correct_bs : forall l, Sem Div2_e l = tl (hd nil l).
Proof.
destruct l as [ | v l].
simpl.

*****
l : list (list bool)
v : list bool
*****
eq (sem_Rec (fun _ : list (list bool) => nil) (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => nth O vl nil) v l) (tl v)
+++++
destruct v as [ | [ | ] v].
-----
Lemma Div2_correct_bs : forall l, Sem Div2_e l = tl (hd nil l).
Proof.
destruct l as [ | v l].
simpl.
destruct v as [ | [ | ] v].

*****
l : list (list bool)
*****
eq (sem_Rec (fun _ : list (list bool) => nil) (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => nth O vl nil) nil l) (tl nil)
+++++
trivial.
-----
Lemma Div2_correct_bs : forall l, Sem Div2_e l = tl (hd nil l).
Proof.
destruct l as [ | v l].
simpl.
destruct v as [ | [ | ] v].

*****
l : list (list bool)
v : list bool
*****
eq (sem_Rec (fun _ : list (list bool) => nil) (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => nth O vl nil) (cons true v) l) (tl (cons true v))
+++++
trivial.
-----
Lemma Div2_correct_bs : forall l, Sem Div2_e l = tl (hd nil l).
Proof.
destruct l as [ | v l].
simpl.
destruct v as [ | [ | ] v].

*****
l : list (list bool)
v : list bool
*****
eq (sem_Rec (fun _ : list (list bool) => nil) (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => nth O vl nil) (cons false v) l) (tl (cons false v))
+++++
trivial.
-----
Lemma Div2_correct_bs : forall l, Sem Div2_e l = tl (hd nil l).
Proof.
destruct l as [ | v l].

*****

*****

+++++
Qed.
-----
Lemma Div2_correct : forall l,\n  bs2nat (Sem Div2_e l) = div2 (bs2nat (hd nil l)).
-----
Lemma Div2_correct : forall l, bs2nat (Sem Div2_e l) = div2 (bs2nat (hd nil l)).

*****

*****
forall l : list (list bool), eq (bs2nat (Sem Div2_e l)) (Nat.div2 (bs2nat (hd nil l)))
+++++
Proof.
-----
Lemma Div2_correct : forall l, bs2nat (Sem Div2_e l) = div2 (bs2nat (hd nil l)).
Proof.

*****

*****
forall l : list (list bool), eq (bs2nat (Sem Div2_e l)) (Nat.div2 (bs2nat (hd nil l)))
+++++
intros [ | v l].
-----
Lemma Div2_correct : forall l, bs2nat (Sem Div2_e l) = div2 (bs2nat (hd nil l)).
Proof.
intros [ | v l].

*****

*****
eq (bs2nat (Sem Div2_e nil)) (Nat.div2 (bs2nat (hd nil nil)))
+++++
trivial.
-----
Lemma Div2_correct : forall l, bs2nat (Sem Div2_e l) = div2 (bs2nat (hd nil l)).
Proof.
intros [ | v l].

*****
l : list (list bool)
v : list bool
*****
eq (bs2nat (Sem Div2_e (cons v l))) (Nat.div2 (bs2nat (hd nil (cons v l))))
+++++
rewrite Div2_correct_bs.
-----
Lemma Div2_correct : forall l, bs2nat (Sem Div2_e l) = div2 (bs2nat (hd nil l)).
Proof.
intros [ | v l].
rewrite Div2_correct_bs.

*****
l : list (list bool)
v : list bool
*****
eq (bs2nat (tl (hd nil (cons v l)))) (Nat.div2 (bs2nat (hd nil (cons v l))))
+++++
simpl.
-----
Lemma Div2_correct : forall l, bs2nat (Sem Div2_e l) = div2 (bs2nat (hd nil l)).
Proof.
intros [ | v l].
rewrite Div2_correct_bs.
simpl.

*****
l : list (list bool)
v : list bool
*****
eq (bs2nat (tl v)) (Nat.div2 (bs2nat v))
+++++
apply bs2nat_tl.
-----
Lemma Div2_correct : forall l, bs2nat (Sem Div2_e l) = div2 (bs2nat (hd nil l)).
Proof.
intros [ | v l].

*****

*****

+++++
Qed.
-----
Opaque Div2_e.
-----
Definition Mod2_e : Cobham :=\n  Rec\n    Zero\n    (False_e 2)\n    (One_e 2)\n    (One_e 1).
-----
Lemma arity_Mod2 : arity Mod2_e = ok_arity 1.
-----
Lemma arity_Mod2 : arity Mod2_e = ok_arity 1.

*****

*****
eq (arity Mod2_e) (ok_arity (S O))
+++++
Proof.
-----
Lemma arity_Mod2 : arity Mod2_e = ok_arity 1.
Proof.

*****

*****
eq (arity Mod2_e) (ok_arity (S O))
+++++
simpl.
-----
Lemma arity_Mod2 : arity Mod2_e = ok_arity 1.
Proof.
simpl.

*****

*****
eq match arity (False_e (S (S O))) with | error_Rec a a0 a1 a2 => error_Rec (ok_arity O) (error_Rec a a0 a1 a2) (arity (One_e (S (S O)))) (arity (One_e (S O))) | error_Comp a l => error_Rec (ok_arity O) (error_Comp a l) (arity (One_e (S (S O)))) (arity (One_e (S O))) | error_Proj n n0 => error_Rec (ok_arity O) (error_Proj n n0) (arity (One_e (S (S O)))) (arity (One_e (S O))) | ok_arity h0n => match arity (One_e (S (S O))) with | error_Rec a a0 a1 a2 => error_Rec (ok_arity O) (ok_arity h0n) (error_Rec a a0 a1 a2) (arity (One_e (S O))) | error_Comp a l => error_Rec (ok_arity O) (ok_arity h0n) (error_Comp a l) (arity (One_e (S O))) | error_Proj n n0 => error_Rec (ok_arity O) (ok_arity h0n) (error_Proj n n0) (arity (One_e (S O))) | ok_arity h1n => match arity (One_e (S O)) with | error_Rec a a0 a1 a2 => error_Rec (ok_arity O) (ok_arity h0n) (ok_arity h1n) (error_Rec a a0 a1 a2) | error_Comp a l => error_Rec (ok_arity O) (ok_arity h0n) (ok_arity h1n) (error_Comp a l) | error_Proj n n0 => error_Rec (ok_arity O) (ok_arity h0n) (ok_arity h1n) (error_Proj n n0) | ok_arity jn => if andb (andb match h0n with | S (S O) => true | _ => false end (Nat.eqb h1n h0n)) match h1n with | O => false | S m' => Nat.eqb jn m' end then ok_arity jn else error_Rec (ok_arity O) (ok_arity h0n) (ok_arity h1n) (ok_arity jn) end end end (ok_arity (S O))
+++++
trivial.
-----
Lemma arity_Mod2 : arity Mod2_e = ok_arity 1.
Proof.
simpl.
trivial.

*****

*****

+++++
Qed.
-----
Lemma rec_bounded_Mod2 :\n  rec_bounded Mod2_e.
-----
Lemma rec_bounded_Mod2 : rec_bounded Mod2_e.

*****

*****
rec_bounded Mod2_e
+++++
Proof.
-----
Lemma rec_bounded_Mod2 : rec_bounded Mod2_e.
Proof.

*****

*****
rec_bounded Mod2_e
+++++
simpl.
-----
Lemma rec_bounded_Mod2 : rec_bounded Mod2_e.
Proof.
simpl.

*****

*****
and (rec_bounded (One_e (S O))) (and True (and (rec_bounded (False_e (S (S O)))) (and (rec_bounded (One_e (S (S O)))) (forall l : list (list bool), le (length (sem_Rec (fun _ : list (list bool) => nil) (Sem (False_e (S (S O)))) (Sem (One_e (S (S O)))) (hd nil l) (tl l))) (length (Sem (One_e (S O)) l))))))
+++++
intuition.
-----
Lemma rec_bounded_Mod2 : rec_bounded Mod2_e.
Proof.
simpl.
intuition.

*****

*****
rec_bounded (One_e (S O))
+++++
apply rec_bounded_One.
-----
Lemma rec_bounded_Mod2 : rec_bounded Mod2_e.
Proof.
simpl.
intuition.

*****

*****
rec_bounded (False_e (S (S O)))
+++++
apply rec_bounded_False.
-----
Lemma rec_bounded_Mod2 : rec_bounded Mod2_e.
Proof.
simpl.
intuition.

*****

*****
rec_bounded (One_e (S (S O)))
+++++
apply rec_bounded_One.
-----
Lemma rec_bounded_Mod2 : rec_bounded Mod2_e.
Proof.
simpl.
intuition.

*****
l : list (list bool)
*****
le (length (sem_Rec (fun _ : list (list bool) => nil) (Sem (False_e (S (S O)))) (Sem (One_e (S (S O)))) (hd nil l) (tl l))) (length (Sem (One_e (S O)) l))
+++++
destruct l as [ | v l].
-----
Lemma rec_bounded_Mod2 : rec_bounded Mod2_e.
Proof.
simpl.
intuition.
destruct l as [ | v l].

*****

*****
le (length (sem_Rec (fun _ : list (list bool) => nil) (Sem (False_e (S (S O)))) (Sem (One_e (S (S O)))) (hd nil nil) (tl nil))) (length (Sem (One_e (S O)) nil))
+++++
simpl.
-----
Lemma rec_bounded_Mod2 : rec_bounded Mod2_e.
Proof.
simpl.
intuition.
destruct l as [ | v l].
simpl.

*****

*****
le O (length (Sem (One_e (S O)) nil))
+++++
omega.
-----
Lemma rec_bounded_Mod2 : rec_bounded Mod2_e.
Proof.
simpl.
intuition.
destruct l as [ | v l].

*****
l : list (list bool)
v : list bool
*****
le (length (sem_Rec (fun _ : list (list bool) => nil) (Sem (False_e (S (S O)))) (Sem (One_e (S (S O)))) (hd nil (cons v l)) (tl (cons v l)))) (length (Sem (One_e (S O)) (cons v l)))
+++++
simpl.
-----
Lemma rec_bounded_Mod2 : rec_bounded Mod2_e.
Proof.
simpl.
intuition.
destruct l as [ | v l].
simpl.

*****
l : list (list bool)
v : list bool
*****
le (length (sem_Rec (fun _ : list (list bool) => nil) (Sem (False_e (S (S O)))) (Sem (One_e (S (S O)))) v l)) (length (Sem (One_e (S O)) (cons v l)))
+++++
induction v as [ | [ | ] v IH].
-----
Lemma rec_bounded_Mod2 : rec_bounded Mod2_e.
Proof.
simpl.
intuition.
destruct l as [ | v l].
simpl.
induction v as [ | [ | ] v IH].

*****
l : list (list bool)
*****
le (length (sem_Rec (fun _ : list (list bool) => nil) (Sem (False_e (S (S O)))) (Sem (One_e (S (S O)))) nil l)) (length (Sem (One_e (S O)) (cons nil l)))
+++++
simpl.
-----
Lemma rec_bounded_Mod2 : rec_bounded Mod2_e.
Proof.
simpl.
intuition.
destruct l as [ | v l].
simpl.
induction v as [ | [ | ] v IH].
simpl.

*****
l : list (list bool)
*****
le O (length (Sem (One_e (S O)) (cons nil l)))
+++++
omega.
-----
Lemma rec_bounded_Mod2 : rec_bounded Mod2_e.
Proof.
simpl.
intuition.
destruct l as [ | v l].
simpl.
induction v as [ | [ | ] v IH].

*****
IH : le\n (length\n (sem_Rec (fun _ : list (list bool) => nil)\n (Sem (False_e (S (S O)))) (Sem (One_e (S (S O)))) v l))\n (length (Sem (One_e (S O)) (cons v l)))
l : list (list bool)
v : list bool
*****
le (length (sem_Rec (fun _ : list (list bool) => nil) (Sem (False_e (S (S O)))) (Sem (One_e (S (S O)))) (cons true v) l)) (length (Sem (One_e (S O)) (cons (cons true v) l)))
+++++
auto with arith.
-----
Lemma rec_bounded_Mod2 : rec_bounded Mod2_e.
Proof.
simpl.
intuition.
destruct l as [ | v l].
simpl.
induction v as [ | [ | ] v IH].

*****
IH : le\n (length\n (sem_Rec (fun _ : list (list bool) => nil)\n (Sem (False_e (S (S O)))) (Sem (One_e (S (S O)))) v l))\n (length (Sem (One_e (S O)) (cons v l)))
l : list (list bool)
v : list bool
*****
le (length (sem_Rec (fun _ : list (list bool) => nil) (Sem (False_e (S (S O)))) (Sem (One_e (S (S O)))) (cons false v) l)) (length (Sem (One_e (S O)) (cons (cons false v) l)))
+++++
auto with arith.
-----
Lemma rec_bounded_Mod2 : rec_bounded Mod2_e.
Proof.
simpl.
intuition.

*****

*****

+++++
Qed.
-----
Lemma Mod2_correct_bs : forall l, \n  (hd nil l) <> nil ->\n  Sem Mod2_e l = [hd true (hd nil l)].
-----
Lemma Mod2_correct_bs : forall l, (hd nil l) <> nil -> Sem Mod2_e l = [hd true (hd nil l)].

*****

*****
forall (l : list (list bool)) (_ : not (eq (hd nil l) nil)), eq (Sem Mod2_e l) (cons (hd true (hd nil l)) nil)
+++++
Proof.
-----
Lemma Mod2_correct_bs : forall l, (hd nil l) <> nil -> Sem Mod2_e l = [hd true (hd nil l)].
Proof.

*****

*****
forall (l : list (list bool)) (_ : not (eq (hd nil l) nil)), eq (Sem Mod2_e l) (cons (hd true (hd nil l)) nil)
+++++
intros.
-----
Lemma Mod2_correct_bs : forall l, (hd nil l) <> nil -> Sem Mod2_e l = [hd true (hd nil l)].
Proof.
intros.

*****
H : not (eq (hd nil l) nil)
l : list (list bool)
*****
eq (Sem Mod2_e l) (cons (hd true (hd nil l)) nil)
+++++
simpl.
-----
Lemma Mod2_correct_bs : forall l, (hd nil l) <> nil -> Sem Mod2_e l = [hd true (hd nil l)].
Proof.
intros.
simpl.

*****
H : not (eq (hd nil l) nil)
l : list (list bool)
*****
eq (sem_Rec (fun _ : list (list bool) => nil) (Sem (False_e (S (S O)))) (Sem (One_e (S (S O)))) (hd nil l) (tl l)) (cons (hd true (hd nil l)) nil)
+++++
destruct (hd nil l).
-----
Lemma Mod2_correct_bs : forall l, (hd nil l) <> nil -> Sem Mod2_e l = [hd true (hd nil l)].
Proof.
intros.
simpl.
destruct (hd nil l).

*****
H : not (eq nil nil)
l : list (list bool)
*****
eq (sem_Rec (fun _ : list (list bool) => nil) (Sem (False_e (S (S O)))) (Sem (One_e (S (S O)))) nil (tl l)) (cons (hd true nil) nil)
+++++
simpl.
-----
Lemma Mod2_correct_bs : forall l, (hd nil l) <> nil -> Sem Mod2_e l = [hd true (hd nil l)].
Proof.
intros.
simpl.
destruct (hd nil l).
simpl.

*****
H : not (eq nil nil)
l : list (list bool)
*****
eq nil (cons true nil)
+++++
trivial.
-----
Lemma Mod2_correct_bs : forall l, (hd nil l) <> nil -> Sem Mod2_e l = [hd true (hd nil l)].
Proof.
intros.
simpl.
destruct (hd nil l).
simpl.
trivial.

*****
H : not (eq nil nil)
l : list (list bool)
*****
eq nil (cons true nil)
+++++
elim H.
-----
Lemma Mod2_correct_bs : forall l, (hd nil l) <> nil -> Sem Mod2_e l = [hd true (hd nil l)].
Proof.
intros.
simpl.
destruct (hd nil l).
simpl.
trivial.
elim H.

*****
H : not (eq nil nil)
l : list (list bool)
*****
eq nil nil
+++++
trivial.
-----
Lemma Mod2_correct_bs : forall l, (hd nil l) <> nil -> Sem Mod2_e l = [hd true (hd nil l)].
Proof.
intros.
simpl.
destruct (hd nil l).

*****
H : not (eq (cons b l0) nil)
l0 : list bool
b : bool
l : list (list bool)
*****
eq (sem_Rec (fun _ : list (list bool) => nil) (Sem (False_e (S (S O)))) (Sem (One_e (S (S O)))) (cons b l0) (tl l)) (cons (hd true (cons b l0)) nil)
+++++
simpl.
-----
Lemma Mod2_correct_bs : forall l, (hd nil l) <> nil -> Sem Mod2_e l = [hd true (hd nil l)].
Proof.
intros.
simpl.
destruct (hd nil l).
simpl.

*****
H : not (eq (cons b l0) nil)
l0 : list bool
b : bool
l : list (list bool)
*****
eq (if b then Sem (One_e (S (S O))) (cons l0 (cons (sem_Rec (fun _ : list (list bool) => nil) (Sem (False_e (S (S O)))) (Sem (One_e (S (S O)))) l0 (tl l)) (tl l))) else Sem (False_e (S (S O))) (cons l0 (cons (sem_Rec (fun _ : list (list bool) => nil) (Sem (False_e (S (S O)))) (Sem (One_e (S (S O)))) l0 (tl l)) (tl l)))) (cons b nil)
+++++
trivial.
-----
Lemma Mod2_correct_bs : forall l, (hd nil l) <> nil -> Sem Mod2_e l = [hd true (hd nil l)].
Proof.
intros.
simpl.
destruct (hd nil l).
simpl.
trivial.

*****
H : not (eq (cons b l0) nil)
l0 : list bool
b : bool
l : list (list bool)
*****
eq (if b then Sem (One_e (S (S O))) (cons l0 (cons (sem_Rec (fun _ : list (list bool) => nil) (Sem (False_e (S (S O)))) (Sem (One_e (S (S O)))) l0 (tl l)) (tl l))) else Sem (False_e (S (S O))) (cons l0 (cons (sem_Rec (fun _ : list (list bool) => nil) (Sem (False_e (S (S O)))) (Sem (One_e (S (S O)))) l0 (tl l)) (tl l)))) (cons b nil)
+++++
case b.
-----
Lemma Mod2_correct_bs : forall l, (hd nil l) <> nil -> Sem Mod2_e l = [hd true (hd nil l)].
Proof.
intros.
simpl.
destruct (hd nil l).
simpl.
trivial.
case b.

*****
H : not (eq (cons b l0) nil)
l0 : list bool
b : bool
l : list (list bool)
*****
eq (Sem (One_e (S (S O))) (cons l0 (cons (sem_Rec (fun _ : list (list bool) => nil) (Sem (False_e (S (S O)))) (Sem (One_e (S (S O)))) l0 (tl l)) (tl l)))) (cons true nil)
+++++
rewrite One_correct_bs.
-----
Lemma Mod2_correct_bs : forall l, (hd nil l) <> nil -> Sem Mod2_e l = [hd true (hd nil l)].
Proof.
intros.
simpl.
destruct (hd nil l).
simpl.
trivial.
case b.
rewrite One_correct_bs.

*****
H : not (eq (cons b l0) nil)
l0 : list bool
b : bool
l : list (list bool)
*****
eq (cons true nil) (cons true nil)
+++++
trivial.
-----
Lemma Mod2_correct_bs : forall l, (hd nil l) <> nil -> Sem Mod2_e l = [hd true (hd nil l)].
Proof.
intros.
simpl.
destruct (hd nil l).
simpl.
trivial.
case b.

*****
H : not (eq (cons b l0) nil)
l0 : list bool
b : bool
l : list (list bool)
*****
eq (Sem (False_e (S (S O))) (cons l0 (cons (sem_Rec (fun _ : list (list bool) => nil) (Sem (False_e (S (S O)))) (Sem (One_e (S (S O)))) l0 (tl l)) (tl l)))) (cons false nil)
+++++
rewrite False_correct_bs.
-----
Lemma Mod2_correct_bs : forall l, (hd nil l) <> nil -> Sem Mod2_e l = [hd true (hd nil l)].
Proof.
intros.
simpl.
destruct (hd nil l).
simpl.
trivial.
case b.
rewrite False_correct_bs.

*****
H : not (eq (cons b l0) nil)
l0 : list bool
b : bool
l : list (list bool)
*****
eq (cons false nil) (cons false nil)
+++++
trivial.
-----
Lemma Mod2_correct_bs : forall l, (hd nil l) <> nil -> Sem Mod2_e l = [hd true (hd nil l)].
Proof.
intros.
simpl.
destruct (hd nil l).

*****

*****

+++++
Qed.
-----
Lemma Mod2_correct : forall l,\n  bs2nat (Sem Mod2_e l) = mod2 (bs2nat (hd nil l)).
-----
Lemma Mod2_correct : forall l, bs2nat (Sem Mod2_e l) = mod2 (bs2nat (hd nil l)).

*****

*****
forall l : list (list bool), eq (bs2nat (Sem Mod2_e l)) (mod2 (bs2nat (hd nil l)))
+++++
Proof.
-----
Lemma Mod2_correct : forall l, bs2nat (Sem Mod2_e l) = mod2 (bs2nat (hd nil l)).
Proof.

*****

*****
forall l : list (list bool), eq (bs2nat (Sem Mod2_e l)) (mod2 (bs2nat (hd nil l)))
+++++
unfold mod2.
-----
Lemma Mod2_correct : forall l, bs2nat (Sem Mod2_e l) = mod2 (bs2nat (hd nil l)).
Proof.
unfold mod2.

*****

*****
forall l : list (list bool), eq (bs2nat (Sem Mod2_e l)) (Init.Nat.sub (bs2nat (hd nil l)) (Init.Nat.mul (S (S O)) (Nat.div2 (bs2nat (hd nil l)))))
+++++
destruct l as [ | v l].
-----
Lemma Mod2_correct : forall l, bs2nat (Sem Mod2_e l) = mod2 (bs2nat (hd nil l)).
Proof.
unfold mod2.
destruct l as [ | v l].

*****

*****
eq (bs2nat (Sem Mod2_e nil)) (Init.Nat.sub (bs2nat (hd nil nil)) (Init.Nat.mul (S (S O)) (Nat.div2 (bs2nat (hd nil nil)))))
+++++
trivial.
-----
Lemma Mod2_correct : forall l, bs2nat (Sem Mod2_e l) = mod2 (bs2nat (hd nil l)).
Proof.
unfold mod2.
destruct l as [ | v l].

*****
l : list (list bool)
v : list bool
*****
eq (bs2nat (Sem Mod2_e (cons v l))) (Init.Nat.sub (bs2nat (hd nil (cons v l))) (Init.Nat.mul (S (S O)) (Nat.div2 (bs2nat (hd nil (cons v l))))))
+++++
simpl hd.
-----
Lemma Mod2_correct : forall l, bs2nat (Sem Mod2_e l) = mod2 (bs2nat (hd nil l)).
Proof.
unfold mod2.
destruct l as [ | v l].
simpl hd.

*****
l : list (list bool)
v : list bool
*****
eq (bs2nat (Sem Mod2_e (cons v l))) (Init.Nat.sub (bs2nat v) (Init.Nat.mul (S (S O)) (Nat.div2 (bs2nat v))))
+++++
destruct v as [ | [ | ] v].
-----
Lemma Mod2_correct : forall l, bs2nat (Sem Mod2_e l) = mod2 (bs2nat (hd nil l)).
Proof.
unfold mod2.
destruct l as [ | v l].
simpl hd.
destruct v as [ | [ | ] v].

*****
l : list (list bool)
*****
eq (bs2nat (Sem Mod2_e (cons nil l))) (Init.Nat.sub (bs2nat nil) (Init.Nat.mul (S (S O)) (Nat.div2 (bs2nat nil))))
+++++
trivial.
-----
Lemma Mod2_correct : forall l, bs2nat (Sem Mod2_e l) = mod2 (bs2nat (hd nil l)).
Proof.
unfold mod2.
destruct l as [ | v l].
simpl hd.
destruct v as [ | [ | ] v].

*****
l : list (list bool)
v : list bool
*****
eq (bs2nat (Sem Mod2_e (cons (cons true v) l))) (Init.Nat.sub (bs2nat (cons true v)) (Init.Nat.mul (S (S O)) (Nat.div2 (bs2nat (cons true v)))))
+++++
simpl Sem in *.
-----
Lemma Mod2_correct : forall l, bs2nat (Sem Mod2_e l) = mod2 (bs2nat (hd nil l)).
Proof.
unfold mod2.
destruct l as [ | v l].
simpl hd.
destruct v as [ | [ | ] v].
simpl Sem in *.

*****
l : list (list bool)
v : list bool
*****
eq (bs2nat (Sem (One_e (S (S O))) (cons v (cons (sem_Rec (fun _ : list (list bool) => nil) (Sem (False_e (S (S O)))) (Sem (One_e (S (S O)))) v l) l)))) (Init.Nat.sub (bs2nat (cons true v)) (Init.Nat.mul (S (S O)) (Nat.div2 (bs2nat (cons true v)))))
+++++
rewrite One_correct.
-----
Lemma Mod2_correct : forall l, bs2nat (Sem Mod2_e l) = mod2 (bs2nat (hd nil l)).
Proof.
unfold mod2.
destruct l as [ | v l].
simpl hd.
destruct v as [ | [ | ] v].
simpl Sem in *.
rewrite One_correct.

*****
l : list (list bool)
v : list bool
*****
eq (S O) (Init.Nat.sub (bs2nat (cons true v)) (Init.Nat.mul (S (S O)) (Nat.div2 (bs2nat (cons true v)))))
+++++
rewrite bs2nat_true.
-----
Lemma Mod2_correct : forall l, bs2nat (Sem Mod2_e l) = mod2 (bs2nat (hd nil l)).
Proof.
unfold mod2.
destruct l as [ | v l].
simpl hd.
destruct v as [ | [ | ] v].
simpl Sem in *.
rewrite One_correct.
rewrite bs2nat_true.

*****
l : list (list bool)
v : list bool
*****
eq (S O) (Init.Nat.sub (Init.Nat.add (S O) (Init.Nat.mul (S (S O)) (bs2nat v))) (Init.Nat.mul (S (S O)) (Nat.div2 (Init.Nat.add (S O) (Init.Nat.mul (S (S O)) (bs2nat v))))))
+++++
change (1 + 2 * bs2nat v) with (S (2 * bs2nat v)).
-----
Lemma Mod2_correct : forall l, bs2nat (Sem Mod2_e l) = mod2 (bs2nat (hd nil l)).
Proof.
unfold mod2.
destruct l as [ | v l].
simpl hd.
destruct v as [ | [ | ] v].
simpl Sem in *.
rewrite One_correct.
rewrite bs2nat_true.
change (1 + 2 * bs2nat v) with (S (2 * bs2nat v)).

*****
l : list (list bool)
v : list bool
*****
eq (S O) (Init.Nat.sub (S (Init.Nat.mul (S (S O)) (bs2nat v))) (Init.Nat.mul (S (S O)) (Nat.div2 (S (Init.Nat.mul (S (S O)) (bs2nat v))))))
+++++
rewrite div2_double_plus_one.
-----
Lemma Mod2_correct : forall l, bs2nat (Sem Mod2_e l) = mod2 (bs2nat (hd nil l)).
Proof.
unfold mod2.
destruct l as [ | v l].
simpl hd.
destruct v as [ | [ | ] v].
simpl Sem in *.
rewrite One_correct.
rewrite bs2nat_true.
change (1 + 2 * bs2nat v) with (S (2 * bs2nat v)).
rewrite div2_double_plus_one.

*****
l : list (list bool)
v : list bool
*****
eq (S O) (Init.Nat.sub (S (Init.Nat.mul (S (S O)) (bs2nat v))) (Init.Nat.mul (S (S O)) (bs2nat v)))
+++++
omega.
-----
Lemma Mod2_correct : forall l, bs2nat (Sem Mod2_e l) = mod2 (bs2nat (hd nil l)).
Proof.
unfold mod2.
destruct l as [ | v l].
simpl hd.
destruct v as [ | [ | ] v].

*****
l : list (list bool)
v : list bool
*****
eq (bs2nat (Sem Mod2_e (cons (cons false v) l))) (Init.Nat.sub (bs2nat (cons false v)) (Init.Nat.mul (S (S O)) (Nat.div2 (bs2nat (cons false v)))))
+++++
simpl Sem in *.
-----
Lemma Mod2_correct : forall l, bs2nat (Sem Mod2_e l) = mod2 (bs2nat (hd nil l)).
Proof.
unfold mod2.
destruct l as [ | v l].
simpl hd.
destruct v as [ | [ | ] v].
simpl Sem in *.

*****
l : list (list bool)
v : list bool
*****
eq (bs2nat (Sem (False_e (S (S O))) (cons v (cons (sem_Rec (fun _ : list (list bool) => nil) (Sem (False_e (S (S O)))) (Sem (One_e (S (S O)))) v l) l)))) (Init.Nat.sub (bs2nat (cons false v)) (Init.Nat.mul (S (S O)) (Nat.div2 (bs2nat (cons false v)))))
+++++
rewrite bs2nat_false.
-----
Lemma Mod2_correct : forall l, bs2nat (Sem Mod2_e l) = mod2 (bs2nat (hd nil l)).
Proof.
unfold mod2.
destruct l as [ | v l].
simpl hd.
destruct v as [ | [ | ] v].
simpl Sem in *.
rewrite bs2nat_false.

*****
l : list (list bool)
v : list bool
*****
eq (bs2nat (Sem (False_e (S (S O))) (cons v (cons (sem_Rec (fun _ : list (list bool) => nil) (Sem (False_e (S (S O)))) (Sem (One_e (S (S O)))) v l) l)))) (Init.Nat.sub (Init.Nat.mul (S (S O)) (bs2nat v)) (Init.Nat.mul (S (S O)) (Nat.div2 (Init.Nat.mul (S (S O)) (bs2nat v)))))
+++++
rewrite div2_double.
-----
Lemma Mod2_correct : forall l, bs2nat (Sem Mod2_e l) = mod2 (bs2nat (hd nil l)).
Proof.
unfold mod2.
destruct l as [ | v l].
simpl hd.
destruct v as [ | [ | ] v].
simpl Sem in *.
rewrite bs2nat_false.
rewrite div2_double.

*****
l : list (list bool)
v : list bool
*****
eq (bs2nat (Sem (False_e (S (S O))) (cons v (cons (sem_Rec (fun _ : list (list bool) => nil) (Sem (False_e (S (S O)))) (Sem (One_e (S (S O)))) v l) l)))) (Init.Nat.sub (Init.Nat.mul (S (S O)) (bs2nat v)) (Init.Nat.mul (S (S O)) (bs2nat v)))
+++++
auto with arith.
-----
Lemma Mod2_correct : forall l, bs2nat (Sem Mod2_e l) = mod2 (bs2nat (hd nil l)).
Proof.
unfold mod2.
destruct l as [ | v l].

*****

*****

+++++
Qed.
-----
Opaque Mod2_e.
-----
Definition Length_e : Cobham :=\n  Rec2\n    Zero\n    (Comp 2 Succ_e [Proj 2 1])\n    (Proj 1 0).
-----
Lemma arity_Length : arity Length_e = ok_arity 1.
-----
Lemma arity_Length : arity Length_e = ok_arity 1.

*****

*****
eq (arity Length_e) (ok_arity (S O))
+++++
Proof.
-----
Lemma arity_Length : arity Length_e = ok_arity 1.
Proof.

*****

*****
eq (arity Length_e) (ok_arity (S O))
+++++
trivial.
-----
Lemma arity_Length : arity Length_e = ok_arity 1.
Proof.
trivial.

*****

*****

+++++
Qed.
-----
Lemma rec_bounded_Length :\n  rec_bounded Length_e.
-----
Lemma rec_bounded_Length : rec_bounded Length_e.

*****

*****
rec_bounded Length_e
+++++
Proof.
-----
Lemma rec_bounded_Length : rec_bounded Length_e.
Proof.

*****

*****
rec_bounded Length_e
+++++
simpl.
-----
Lemma rec_bounded_Length : rec_bounded Length_e.
Proof.
simpl.

*****

*****
and True (and True (and (and (rec_bounded Succ_e) (and True True)) (and (and (rec_bounded Succ_e) (and True True)) (forall l : list (list bool), le (length (sem_Rec (fun _ : list (list bool) => nil) (fun vl : list (list bool) => Sem Succ_e (cons (nth (S O) vl nil) nil)) (fun vl : list (list bool) => Sem Succ_e (cons (nth (S O) vl nil) nil)) (hd nil l) (tl l))) (length (nth O l nil))))))
+++++
intuition.
-----
Lemma rec_bounded_Length : rec_bounded Length_e.
Proof.
simpl.
intuition.

*****

*****
rec_bounded Succ_e
+++++
apply rec_bounded_Succ.
-----
Lemma rec_bounded_Length : rec_bounded Length_e.
Proof.
simpl.
intuition.

*****

*****
rec_bounded Succ_e
+++++
apply rec_bounded_Succ.
-----
Lemma rec_bounded_Length : rec_bounded Length_e.
Proof.
simpl.
intuition.

*****
l : list (list bool)
*****
le (length (sem_Rec (fun _ : list (list bool) => nil) (fun vl : list (list bool) => Sem Succ_e (cons (nth (S O) vl nil) nil)) (fun vl : list (list bool) => Sem Succ_e (cons (nth (S O) vl nil) nil)) (hd nil l) (tl l))) (length (nth O l nil))
+++++
destruct l as [ | v l].
-----
Lemma rec_bounded_Length : rec_bounded Length_e.
Proof.
simpl.
intuition.
destruct l as [ | v l].

*****

*****
le (length (sem_Rec (fun _ : list (list bool) => nil) (fun vl : list (list bool) => Sem Succ_e (cons (nth (S O) vl nil) nil)) (fun vl : list (list bool) => Sem Succ_e (cons (nth (S O) vl nil) nil)) (hd nil nil) (tl nil))) (length (nth O nil nil))
+++++
trivial.
-----
Lemma rec_bounded_Length : rec_bounded Length_e.
Proof.
simpl.
intuition.
destruct l as [ | v l].

*****
l : list (list bool)
v : list bool
*****
le (length (sem_Rec (fun _ : list (list bool) => nil) (fun vl : list (list bool) => Sem Succ_e (cons (nth (S O) vl nil) nil)) (fun vl : list (list bool) => Sem Succ_e (cons (nth (S O) vl nil) nil)) (hd nil (cons v l)) (tl (cons v l)))) (length (nth O (cons v l) nil))
+++++
simpl.
-----
Lemma rec_bounded_Length : rec_bounded Length_e.
Proof.
simpl.
intuition.
destruct l as [ | v l].
simpl.

*****
l : list (list bool)
v : list bool
*****
le (length (sem_Rec (fun _ : list (list bool) => nil) (fun vl : list (list bool) => Sem Succ_e (cons (nth (S O) vl nil) nil)) (fun vl : list (list bool) => Sem Succ_e (cons (nth (S O) vl nil) nil)) v l)) (length v)
+++++
induction v as [ | [ | ] v IH].
-----
Lemma rec_bounded_Length : rec_bounded Length_e.
Proof.
simpl.
intuition.
destruct l as [ | v l].
simpl.
induction v as [ | [ | ] v IH].

*****
l : list (list bool)
*****
le (length (sem_Rec (fun _ : list (list bool) => nil) (fun vl : list (list bool) => Sem Succ_e (cons (nth (S O) vl nil) nil)) (fun vl : list (list bool) => Sem Succ_e (cons (nth (S O) vl nil) nil)) nil l)) (length nil)
+++++
trivial.
-----
Lemma rec_bounded_Length : rec_bounded Length_e.
Proof.
simpl.
intuition.
destruct l as [ | v l].
simpl.
induction v as [ | [ | ] v IH].

*****
IH : le\n (length\n (sem_Rec (fun _ : list (list bool) => nil)\n (fun vl : list (list bool) =>\n Sem Succ_e (cons (nth (S O) vl nil) nil))\n (fun vl : list (list bool) =>\n Sem Succ_e (cons (nth (S O) vl nil) nil)) v l)) \n (length v)
l : list (list bool)
v : list bool
*****
le (length (sem_Rec (fun _ : list (list bool) => nil) (fun vl : list (list bool) => Sem Succ_e (cons (nth (S O) vl nil) nil)) (fun vl : list (list bool) => Sem Succ_e (cons (nth (S O) vl nil) nil)) (cons true v) l)) (length (cons true v))
+++++
simpl.
-----
Lemma rec_bounded_Length : rec_bounded Length_e.
Proof.
simpl.
intuition.
destruct l as [ | v l].
simpl.
induction v as [ | [ | ] v IH].
simpl.

*****
IH : le\n (length\n (sem_Rec (fun _ : list (list bool) => nil)\n (fun vl : list (list bool) =>\n Sem Succ_e (cons (nth (S O) vl nil) nil))\n (fun vl : list (list bool) =>\n Sem Succ_e (cons (nth (S O) vl nil) nil)) v l)) \n (length v)
l : list (list bool)
v : list bool
*****
le (length (Sem Succ_e (cons (sem_Rec (fun _ : list (list bool) => nil) (fun vl : list (list bool) => Sem Succ_e (cons (nth (S O) vl nil) nil)) (fun vl : list (list bool) => Sem Succ_e (cons (nth (S O) vl nil) nil)) v l) nil))) (S (length v))
+++++
eapply le_trans.
-----
Lemma rec_bounded_Length : rec_bounded Length_e.
Proof.
simpl.
intuition.
destruct l as [ | v l].
simpl.
induction v as [ | [ | ] v IH].
simpl.
eapply le_trans.

*****
IH : le\n (length\n (sem_Rec (fun _ : list (list bool) => nil)\n (fun vl : list (list bool) =>\n Sem Succ_e (cons (nth (S O) vl nil) nil))\n (fun vl : list (list bool) =>\n Sem Succ_e (cons (nth (S O) vl nil) nil)) v l)) \n (length v)
l : list (list bool)
v : list bool
*****
le (length (Sem Succ_e (cons (sem_Rec (fun _ : list (list bool) => nil) (fun vl : list (list bool) => Sem Succ_e (cons (nth (S O) vl nil) nil)) (fun vl : list (list bool) => Sem Succ_e (cons (nth (S O) vl nil) nil)) v l) nil))) ?m
+++++
apply length_Succ.
-----
Lemma rec_bounded_Length : rec_bounded Length_e.
Proof.
simpl.
intuition.
destruct l as [ | v l].
simpl.
induction v as [ | [ | ] v IH].
simpl.
eapply le_trans.

*****
IH : le\n (length\n (sem_Rec (fun _ : list (list bool) => nil)\n (fun vl : list (list bool) =>\n Sem Succ_e (cons (nth (S O) vl nil) nil))\n (fun vl : list (list bool) =>\n Sem Succ_e (cons (nth (S O) vl nil) nil)) v l)) \n (length v)
l : list (list bool)
v : list bool
*****
le (length (Sem (Comp (S O) (Succ true) (cons (Proj (S O) O) nil)) (cons (sem_Rec (fun _ : list (list bool) => nil) (fun vl : list (list bool) => Sem Succ_e (cons (nth (S O) vl nil) nil)) (fun vl : list (list bool) => Sem Succ_e (cons (nth (S O) vl nil) nil)) v l) nil))) (S (length v))
+++++
simpl.
-----
Lemma rec_bounded_Length : rec_bounded Length_e.
Proof.
simpl.
intuition.
destruct l as [ | v l].
simpl.
induction v as [ | [ | ] v IH].
simpl.
eapply le_trans.
simpl.

*****
IH : le\n (length\n (sem_Rec (fun _ : list (list bool) => nil)\n (fun vl : list (list bool) =>\n Sem Succ_e (cons (nth (S O) vl nil) nil))\n (fun vl : list (list bool) =>\n Sem Succ_e (cons (nth (S O) vl nil) nil)) v l)) \n (length v)
l : list (list bool)
v : list bool
*****
le (S (length (sem_Rec (fun _ : list (list bool) => nil) (fun vl : list (list bool) => Sem Succ_e (cons (nth (S O) vl nil) nil)) (fun vl : list (list bool) => Sem Succ_e (cons (nth (S O) vl nil) nil)) v l))) (S (length v))
+++++
omega.
-----
Lemma rec_bounded_Length : rec_bounded Length_e.
Proof.
simpl.
intuition.
destruct l as [ | v l].
simpl.
induction v as [ | [ | ] v IH].

*****
IH : le\n (length\n (sem_Rec (fun _ : list (list bool) => nil)\n (fun vl : list (list bool) =>\n Sem Succ_e (cons (nth (S O) vl nil) nil))\n (fun vl : list (list bool) =>\n Sem Succ_e (cons (nth (S O) vl nil) nil)) v l)) \n (length v)
l : list (list bool)
v : list bool
*****
le (length (sem_Rec (fun _ : list (list bool) => nil) (fun vl : list (list bool) => Sem Succ_e (cons (nth (S O) vl nil) nil)) (fun vl : list (list bool) => Sem Succ_e (cons (nth (S O) vl nil) nil)) (cons false v) l)) (length (cons false v))
+++++
simpl.
-----
Lemma rec_bounded_Length : rec_bounded Length_e.
Proof.
simpl.
intuition.
destruct l as [ | v l].
simpl.
induction v as [ | [ | ] v IH].
simpl.

*****
IH : le\n (length\n (sem_Rec (fun _ : list (list bool) => nil)\n (fun vl : list (list bool) =>\n Sem Succ_e (cons (nth (S O) vl nil) nil))\n (fun vl : list (list bool) =>\n Sem Succ_e (cons (nth (S O) vl nil) nil)) v l)) \n (length v)
l : list (list bool)
v : list bool
*****
le (length (Sem Succ_e (cons (sem_Rec (fun _ : list (list bool) => nil) (fun vl : list (list bool) => Sem Succ_e (cons (nth (S O) vl nil) nil)) (fun vl : list (list bool) => Sem Succ_e (cons (nth (S O) vl nil) nil)) v l) nil))) (S (length v))
+++++
eapply le_trans.
-----
Lemma rec_bounded_Length : rec_bounded Length_e.
Proof.
simpl.
intuition.
destruct l as [ | v l].
simpl.
induction v as [ | [ | ] v IH].
simpl.
eapply le_trans.

*****
IH : le\n (length\n (sem_Rec (fun _ : list (list bool) => nil)\n (fun vl : list (list bool) =>\n Sem Succ_e (cons (nth (S O) vl nil) nil))\n (fun vl : list (list bool) =>\n Sem Succ_e (cons (nth (S O) vl nil) nil)) v l)) \n (length v)
l : list (list bool)
v : list bool
*****
le (length (Sem Succ_e (cons (sem_Rec (fun _ : list (list bool) => nil) (fun vl : list (list bool) => Sem Succ_e (cons (nth (S O) vl nil) nil)) (fun vl : list (list bool) => Sem Succ_e (cons (nth (S O) vl nil) nil)) v l) nil))) ?m
+++++
apply length_Succ.
-----
Lemma rec_bounded_Length : rec_bounded Length_e.
Proof.
simpl.
intuition.
destruct l as [ | v l].
simpl.
induction v as [ | [ | ] v IH].
simpl.
eapply le_trans.

*****
IH : le\n (length\n (sem_Rec (fun _ : list (list bool) => nil)\n (fun vl : list (list bool) =>\n Sem Succ_e (cons (nth (S O) vl nil) nil))\n (fun vl : list (list bool) =>\n Sem Succ_e (cons (nth (S O) vl nil) nil)) v l)) \n (length v)
l : list (list bool)
v : list bool
*****
le (length (Sem (Comp (S O) (Succ true) (cons (Proj (S O) O) nil)) (cons (sem_Rec (fun _ : list (list bool) => nil) (fun vl : list (list bool) => Sem Succ_e (cons (nth (S O) vl nil) nil)) (fun vl : list (list bool) => Sem Succ_e (cons (nth (S O) vl nil) nil)) v l) nil))) (S (length v))
+++++
simpl.
-----
Lemma rec_bounded_Length : rec_bounded Length_e.
Proof.
simpl.
intuition.
destruct l as [ | v l].
simpl.
induction v as [ | [ | ] v IH].
simpl.
eapply le_trans.
simpl.

*****
IH : le\n (length\n (sem_Rec (fun _ : list (list bool) => nil)\n (fun vl : list (list bool) =>\n Sem Succ_e (cons (nth (S O) vl nil) nil))\n (fun vl : list (list bool) =>\n Sem Succ_e (cons (nth (S O) vl nil) nil)) v l)) \n (length v)
l : list (list bool)
v : list bool
*****
le (S (length (sem_Rec (fun _ : list (list bool) => nil) (fun vl : list (list bool) => Sem Succ_e (cons (nth (S O) vl nil) nil)) (fun vl : list (list bool) => Sem Succ_e (cons (nth (S O) vl nil) nil)) v l))) (S (length v))
+++++
omega.
-----
Lemma rec_bounded_Length : rec_bounded Length_e.
Proof.
simpl.
intuition.

*****

*****

+++++
Qed.
-----
Lemma Length_correct : forall l,\n  bs2nat (Sem Length_e l) = length (hd nil l).
-----
Lemma Length_correct : forall l, bs2nat (Sem Length_e l) = length (hd nil l).

*****

*****
forall l : list (list bool), eq (bs2nat (Sem Length_e l)) (length (hd nil l))
+++++
Proof.
-----
Lemma Length_correct : forall l, bs2nat (Sem Length_e l) = length (hd nil l).
Proof.

*****

*****
forall l : list (list bool), eq (bs2nat (Sem Length_e l)) (length (hd nil l))
+++++
destruct l as [ | v l].
-----
Lemma Length_correct : forall l, bs2nat (Sem Length_e l) = length (hd nil l).
Proof.
destruct l as [ | v l].

*****

*****
eq (bs2nat (Sem Length_e nil)) (length (hd nil nil))
+++++
trivial.
-----
Lemma Length_correct : forall l, bs2nat (Sem Length_e l) = length (hd nil l).
Proof.
destruct l as [ | v l].

*****
l : list (list bool)
v : list bool
*****
eq (bs2nat (Sem Length_e (cons v l))) (length (hd nil (cons v l)))
+++++
simpl hd.
-----
Lemma Length_correct : forall l, bs2nat (Sem Length_e l) = length (hd nil l).
Proof.
destruct l as [ | v l].
simpl hd.

*****
l : list (list bool)
v : list bool
*****
eq (bs2nat (Sem Length_e (cons v l))) (length v)
+++++
induction v as [ | [ | ] v IH].
-----
Lemma Length_correct : forall l, bs2nat (Sem Length_e l) = length (hd nil l).
Proof.
destruct l as [ | v l].
simpl hd.
induction v as [ | [ | ] v IH].

*****
l : list (list bool)
*****
eq (bs2nat (Sem Length_e (cons nil l))) (length nil)
+++++
trivial.
-----
Lemma Length_correct : forall l, bs2nat (Sem Length_e l) = length (hd nil l).
Proof.
destruct l as [ | v l].
simpl hd.
induction v as [ | [ | ] v IH].

*****
IH : eq (bs2nat (Sem Length_e (cons v l))) (length v)
l : list (list bool)
v : list bool
*****
eq (bs2nat (Sem Length_e (cons (cons true v) l))) (length (cons true v))
+++++
simpl.
-----
Lemma Length_correct : forall l, bs2nat (Sem Length_e l) = length (hd nil l).
Proof.
destruct l as [ | v l].
simpl hd.
induction v as [ | [ | ] v IH].
simpl.

*****
IH : eq (bs2nat (Sem Length_e (cons v l))) (length v)
l : list (list bool)
v : list bool
*****
eq (bs2nat (Sem Succ_e (cons (sem_Rec (fun _ : list (list bool) => nil) (fun vl : list (list bool) => Sem Succ_e (cons (nth (S O) vl nil) nil)) (fun vl : list (list bool) => Sem Succ_e (cons (nth (S O) vl nil) nil)) v l) nil))) (S (length v))
+++++
rewrite Succ_correct.
-----
Lemma Length_correct : forall l, bs2nat (Sem Length_e l) = length (hd nil l).
Proof.
destruct l as [ | v l].
simpl hd.
induction v as [ | [ | ] v IH].
simpl.
rewrite Succ_correct.

*****
IH : eq (bs2nat (Sem Length_e (cons v l))) (length v)
l : list (list bool)
v : list bool
*****
eq (Init.Nat.add (S O) (bs2nat (hd nil (cons (sem_Rec (fun _ : list (list bool) => nil) (fun vl : list (list bool) => Sem Succ_e (cons (nth (S O) vl nil) nil)) (fun vl : list (list bool) => Sem Succ_e (cons (nth (S O) vl nil) nil)) v l) nil)))) (S (length v))
+++++
simpl.
-----
Lemma Length_correct : forall l, bs2nat (Sem Length_e l) = length (hd nil l).
Proof.
destruct l as [ | v l].
simpl hd.
induction v as [ | [ | ] v IH].
simpl.
rewrite Succ_correct.
simpl.

*****
IH : eq (bs2nat (Sem Length_e (cons v l))) (length v)
l : list (list bool)
v : list bool
*****
eq (S (bs2nat (sem_Rec (fun _ : list (list bool) => nil) (fun vl : list (list bool) => Sem Succ_e (cons (nth (S O) vl nil) nil)) (fun vl : list (list bool) => Sem Succ_e (cons (nth (S O) vl nil) nil)) v l))) (S (length v))
+++++
f_equal.
-----
Lemma Length_correct : forall l, bs2nat (Sem Length_e l) = length (hd nil l).
Proof.
destruct l as [ | v l].
simpl hd.
induction v as [ | [ | ] v IH].
simpl.
rewrite Succ_correct.
simpl.
f_equal.

*****
IH : eq (bs2nat (Sem Length_e (cons v l))) (length v)
l : list (list bool)
v : list bool
*****
eq (bs2nat (sem_Rec (fun _ : list (list bool) => nil) (fun vl : list (list bool) => Sem Succ_e (cons (nth (S O) vl nil) nil)) (fun vl : list (list bool) => Sem Succ_e (cons (nth (S O) vl nil) nil)) v l)) (length v)
+++++
trivial.
-----
Lemma Length_correct : forall l, bs2nat (Sem Length_e l) = length (hd nil l).
Proof.
destruct l as [ | v l].
simpl hd.
induction v as [ | [ | ] v IH].

*****
IH : eq (bs2nat (Sem Length_e (cons v l))) (length v)
l : list (list bool)
v : list bool
*****
eq (bs2nat (Sem Length_e (cons (cons false v) l))) (length (cons false v))
+++++
simpl.
-----
Lemma Length_correct : forall l, bs2nat (Sem Length_e l) = length (hd nil l).
Proof.
destruct l as [ | v l].
simpl hd.
induction v as [ | [ | ] v IH].
simpl.

*****
IH : eq (bs2nat (Sem Length_e (cons v l))) (length v)
l : list (list bool)
v : list bool
*****
eq (bs2nat (Sem Succ_e (cons (sem_Rec (fun _ : list (list bool) => nil) (fun vl : list (list bool) => Sem Succ_e (cons (nth (S O) vl nil) nil)) (fun vl : list (list bool) => Sem Succ_e (cons (nth (S O) vl nil) nil)) v l) nil))) (S (length v))
+++++
rewrite Succ_correct.
-----
Lemma Length_correct : forall l, bs2nat (Sem Length_e l) = length (hd nil l).
Proof.
destruct l as [ | v l].
simpl hd.
induction v as [ | [ | ] v IH].
simpl.
rewrite Succ_correct.

*****
IH : eq (bs2nat (Sem Length_e (cons v l))) (length v)
l : list (list bool)
v : list bool
*****
eq (Init.Nat.add (S O) (bs2nat (hd nil (cons (sem_Rec (fun _ : list (list bool) => nil) (fun vl : list (list bool) => Sem Succ_e (cons (nth (S O) vl nil) nil)) (fun vl : list (list bool) => Sem Succ_e (cons (nth (S O) vl nil) nil)) v l) nil)))) (S (length v))
+++++
simpl.
-----
Lemma Length_correct : forall l, bs2nat (Sem Length_e l) = length (hd nil l).
Proof.
destruct l as [ | v l].
simpl hd.
induction v as [ | [ | ] v IH].
simpl.
rewrite Succ_correct.
simpl.

*****
IH : eq (bs2nat (Sem Length_e (cons v l))) (length v)
l : list (list bool)
v : list bool
*****
eq (S (bs2nat (sem_Rec (fun _ : list (list bool) => nil) (fun vl : list (list bool) => Sem Succ_e (cons (nth (S O) vl nil) nil)) (fun vl : list (list bool) => Sem Succ_e (cons (nth (S O) vl nil) nil)) v l))) (S (length v))
+++++
f_equal.
-----
Lemma Length_correct : forall l, bs2nat (Sem Length_e l) = length (hd nil l).
Proof.
destruct l as [ | v l].
simpl hd.
induction v as [ | [ | ] v IH].
simpl.
rewrite Succ_correct.
simpl.
f_equal.

*****
IH : eq (bs2nat (Sem Length_e (cons v l))) (length v)
l : list (list bool)
v : list bool
*****
eq (bs2nat (sem_Rec (fun _ : list (list bool) => nil) (fun vl : list (list bool) => Sem Succ_e (cons (nth (S O) vl nil) nil)) (fun vl : list (list bool) => Sem Succ_e (cons (nth (S O) vl nil) nil)) v l)) (length v)
+++++
trivial.
-----
Lemma Length_correct : forall l, bs2nat (Sem Length_e l) = length (hd nil l).
Proof.
destruct l as [ | v l].

*****

*****

+++++
Qed.
-----
Opaque Length_e.
-----
Definition MultOneMinus'_e : Cobham :=\n  Comp 2 Cond [\n    Proj 2 1;\n    Proj 2 0;\n    Zero_e 2;\n    Zero_e 2\n  ].
-----
Lemma arity_MultOneMinus' : arity MultOneMinus'_e = ok_arity 2.
-----
Lemma arity_MultOneMinus' : arity MultOneMinus'_e = ok_arity 2.

*****

*****
eq (arity MultOneMinus'_e) (ok_arity (S (S O)))
+++++
Proof.
-----
Lemma arity_MultOneMinus' : arity MultOneMinus'_e = ok_arity 2.
Proof.

*****

*****
eq (arity MultOneMinus'_e) (ok_arity (S (S O)))
+++++
trivial.
-----
Lemma arity_MultOneMinus' : arity MultOneMinus'_e = ok_arity 2.
Proof.
trivial.

*****

*****

+++++
Qed.
-----
Lemma rec_bounded_MultOneMinus' :\n  rec_bounded MultOneMinus'_e.
-----
Lemma rec_bounded_MultOneMinus' : rec_bounded MultOneMinus'_e.

*****

*****
rec_bounded MultOneMinus'_e
+++++
Proof.
-----
Lemma rec_bounded_MultOneMinus' : rec_bounded MultOneMinus'_e.
Proof.

*****

*****
rec_bounded MultOneMinus'_e
+++++
simpl.
-----
Lemma rec_bounded_MultOneMinus' : rec_bounded MultOneMinus'_e.
Proof.
simpl.

*****

*****
and (rec_bounded Cond) (and True (and True (and (rec_bounded (Zero_e (S (S O)))) (and (rec_bounded (Zero_e (S (S O)))) True))))
+++++
intuition.
-----
Lemma rec_bounded_MultOneMinus' : rec_bounded MultOneMinus'_e.
Proof.
simpl.
intuition.

*****

*****
rec_bounded Cond
+++++
apply rec_bounded'_spec with 4.
-----
Lemma rec_bounded_MultOneMinus' : rec_bounded MultOneMinus'_e.
Proof.
simpl.
intuition.
apply rec_bounded'_spec with 4.

*****

*****
eq (arity Cond) (ok_arity (S (S (S (S O)))))
+++++
apply arity_Cond.
-----
Lemma rec_bounded_MultOneMinus' : rec_bounded MultOneMinus'_e.
Proof.
simpl.
intuition.
apply rec_bounded'_spec with 4.

*****

*****
rec_bounded' Cond
+++++
apply rec_bounded_Cond.
-----
Lemma rec_bounded_MultOneMinus' : rec_bounded MultOneMinus'_e.
Proof.
simpl.
intuition.

*****

*****
rec_bounded (Zero_e (S (S O)))
+++++
apply rec_bounded_Zero.
-----
Lemma rec_bounded_MultOneMinus' : rec_bounded MultOneMinus'_e.
Proof.
simpl.
intuition.

*****

*****
rec_bounded (Zero_e (S (S O)))
+++++
apply rec_bounded_Zero.
-----
Lemma rec_bounded_MultOneMinus' : rec_bounded MultOneMinus'_e.
Proof.
simpl.
intuition.

*****

*****

+++++
Qed.
-----
Lemma MultOneMinus'_correct : forall l,\n  hd nil (tl l) = nil \/ bs2nat (hd nil (tl l)) <> 0 ->\n  bs2nat (Sem MultOneMinus'_e l) = bs2nat (hd nil l) * (1 - bs2nat (hd nil (tl l))).
-----
Lemma MultOneMinus'_correct : forall l, hd nil (tl l) = nil \\/ bs2nat (hd nil (tl l)) <> 0 -> bs2nat (Sem MultOneMinus'_e l) = bs2nat (hd nil l) * (1 - bs2nat (hd nil (tl l))).

*****

*****
forall (l : list (list bool)) (_ : or (eq (hd nil (tl l)) nil) (not (eq (bs2nat (hd nil (tl l))) O))), eq (bs2nat (Sem MultOneMinus'_e l)) (Init.Nat.mul (bs2nat (hd nil l)) (Init.Nat.sub (S O) (bs2nat (hd nil (tl l)))))
+++++
Proof.
-----
Lemma MultOneMinus'_correct : forall l, hd nil (tl l) = nil \\/ bs2nat (hd nil (tl l)) <> 0 -> bs2nat (Sem MultOneMinus'_e l) = bs2nat (hd nil l) * (1 - bs2nat (hd nil (tl l))).
Proof.

*****

*****
forall (l : list (list bool)) (_ : or (eq (hd nil (tl l)) nil) (not (eq (bs2nat (hd nil (tl l))) O))), eq (bs2nat (Sem MultOneMinus'_e l)) (Init.Nat.mul (bs2nat (hd nil l)) (Init.Nat.sub (S O) (bs2nat (hd nil (tl l)))))
+++++
intros [ | u [ | v l] ] H.
-----
Lemma MultOneMinus'_correct : forall l, hd nil (tl l) = nil \\/ bs2nat (hd nil (tl l)) <> 0 -> bs2nat (Sem MultOneMinus'_e l) = bs2nat (hd nil l) * (1 - bs2nat (hd nil (tl l))).
Proof.
intros [ | u [ | v l] ] H.

*****
H : or (eq (hd nil (tl nil)) nil) (not (eq (bs2nat (hd nil (tl nil))) O))
*****
eq (bs2nat (Sem MultOneMinus'_e nil)) (Init.Nat.mul (bs2nat (hd nil nil)) (Init.Nat.sub (S O) (bs2nat (hd nil (tl nil)))))
+++++
trivial.
-----
Lemma MultOneMinus'_correct : forall l, hd nil (tl l) = nil \\/ bs2nat (hd nil (tl l)) <> 0 -> bs2nat (Sem MultOneMinus'_e l) = bs2nat (hd nil l) * (1 - bs2nat (hd nil (tl l))).
Proof.
intros [ | u [ | v l] ] H.

*****
H : or (eq (hd nil (tl (cons u nil))) nil)\n (not (eq (bs2nat (hd nil (tl (cons u nil)))) O))
u : list bool
*****
eq (bs2nat (Sem MultOneMinus'_e (cons u nil))) (Init.Nat.mul (bs2nat (hd nil (cons u nil))) (Init.Nat.sub (S O) (bs2nat (hd nil (tl (cons u nil))))))
+++++
auto with arith.
-----
Lemma MultOneMinus'_correct : forall l, hd nil (tl l) = nil \\/ bs2nat (hd nil (tl l)) <> 0 -> bs2nat (Sem MultOneMinus'_e l) = bs2nat (hd nil l) * (1 - bs2nat (hd nil (tl l))).
Proof.
intros [ | u [ | v l] ] H.

*****
H : or (eq (hd nil (tl (cons u (cons v l)))) nil)\n (not (eq (bs2nat (hd nil (tl (cons u (cons v l))))) O))
l : list (list bool)
u,v : list bool
*****
eq (bs2nat (Sem MultOneMinus'_e (cons u (cons v l)))) (Init.Nat.mul (bs2nat (hd nil (cons u (cons v l)))) (Init.Nat.sub (S O) (bs2nat (hd nil (tl (cons u (cons v l)))))))
+++++
simpl.
-----
Lemma MultOneMinus'_correct : forall l, hd nil (tl l) = nil \\/ bs2nat (hd nil (tl l)) <> 0 -> bs2nat (Sem MultOneMinus'_e l) = bs2nat (hd nil l) * (1 - bs2nat (hd nil (tl l))).
Proof.
intros [ | u [ | v l] ] H.
simpl.

*****
H : or (eq (hd nil (tl (cons u (cons v l)))) nil)\n (not (eq (bs2nat (hd nil (tl (cons u (cons v l))))) O))
l : list (list bool)
u,v : list bool
*****
eq (bs2nat (Sem Cond (cons v (cons u (cons (Sem (Zero_e (S (S O))) (cons u (cons v l))) (cons (Sem (Zero_e (S (S O))) (cons u (cons v l))) nil)))))) (Init.Nat.mul (bs2nat u) match bs2nat v with | O => S O | S _ => O end)
+++++
rewrite Cond_correct.
-----
Lemma MultOneMinus'_correct : forall l, hd nil (tl l) = nil \\/ bs2nat (hd nil (tl l)) <> 0 -> bs2nat (Sem MultOneMinus'_e l) = bs2nat (hd nil l) * (1 - bs2nat (hd nil (tl l))).
Proof.
intros [ | u [ | v l] ] H.
simpl.
rewrite Cond_correct.

*****
H : or (eq (hd nil (tl (cons u (cons v l)))) nil)\n (not (eq (bs2nat (hd nil (tl (cons u (cons v l))))) O))
l : list (list bool)
u,v : list bool
*****
eq (bs2nat match hd nil (cons v (cons u (cons (Sem (Zero_e (S (S O))) (cons u (cons v l))) (cons (Sem (Zero_e (S (S O))) (cons u (cons v l))) nil)))) with | nil => hd nil (tl (cons v (cons u (cons (Sem (Zero_e (S (S O))) (cons u (cons v l))) (cons (Sem (Zero_e (S (S O))) (cons u (cons v l))) nil))))) | cons true _ => hd nil (tl (tl (cons v (cons u (cons (Sem (Zero_e (S (S O))) (cons u (cons v l))) (cons (Sem (Zero_e (S (S O))) (cons u (cons v l))) nil)))))) | cons false _ => hd nil (tl (tl (tl (cons v (cons u (cons (Sem (Zero_e (S (S O))) (cons u (cons v l))) (cons (Sem (Zero_e (S (S O))) (cons u (cons v l))) nil))))))) end) (Init.Nat.mul (bs2nat u) match bs2nat v with | O => S O | S _ => O end)
+++++
simpl in *.
-----
Lemma MultOneMinus'_correct : forall l, hd nil (tl l) = nil \\/ bs2nat (hd nil (tl l)) <> 0 -> bs2nat (Sem MultOneMinus'_e l) = bs2nat (hd nil l) * (1 - bs2nat (hd nil (tl l))).
Proof.
intros [ | u [ | v l] ] H.
simpl.
rewrite Cond_correct.
simpl in *.

*****
H : or (eq v nil) (not (eq (bs2nat v) O))
l : list (list bool)
u,v : list bool
*****
eq (bs2nat match v with | nil => u | _ => Sem (Zero_e (S (S O))) (cons u (cons v l)) end) (Init.Nat.mul (bs2nat u) match bs2nat v with | O => S O | S _ => O end)
+++++
destruct v as [ | [ | ] v].
-----
Lemma MultOneMinus'_correct : forall l, hd nil (tl l) = nil \\/ bs2nat (hd nil (tl l)) <> 0 -> bs2nat (Sem MultOneMinus'_e l) = bs2nat (hd nil l) * (1 - bs2nat (hd nil (tl l))).
Proof.
intros [ | u [ | v l] ] H.
simpl.
rewrite Cond_correct.
simpl in *.
destruct v as [ | [ | ] v].

*****
H : or (eq nil nil) (not (eq (bs2nat nil) O))
l : list (list bool)
u : list bool
*****
eq (bs2nat u) (Init.Nat.mul (bs2nat u) match bs2nat nil with | O => S O | S _ => O end)
+++++
auto with arith.
-----
Lemma MultOneMinus'_correct : forall l, hd nil (tl l) = nil \\/ bs2nat (hd nil (tl l)) <> 0 -> bs2nat (Sem MultOneMinus'_e l) = bs2nat (hd nil l) * (1 - bs2nat (hd nil (tl l))).
Proof.
intros [ | u [ | v l] ] H.
simpl.
rewrite Cond_correct.
simpl in *.
destruct v as [ | [ | ] v].

*****
H : or (eq (cons true v) nil) (not (eq (bs2nat (cons true v)) O))
l : list (list bool)
u,v : list bool
*****
eq (bs2nat (Sem (Zero_e (S (S O))) (cons u (cons (cons true v) l)))) (Init.Nat.mul (bs2nat u) match bs2nat (cons true v) with | O => S O | S _ => O end)
+++++
trivial.
-----
Lemma MultOneMinus'_correct : forall l, hd nil (tl l) = nil \\/ bs2nat (hd nil (tl l)) <> 0 -> bs2nat (Sem MultOneMinus'_e l) = bs2nat (hd nil l) * (1 - bs2nat (hd nil (tl l))).
Proof.
intros [ | u [ | v l] ] H.
simpl.
rewrite Cond_correct.
simpl in *.
destruct v as [ | [ | ] v].

*****
H : or (eq (cons false v) nil) (not (eq (bs2nat (cons false v)) O))
l : list (list bool)
u,v : list bool
*****
eq (bs2nat (Sem (Zero_e (S (S O))) (cons u (cons (cons false v) l)))) (Init.Nat.mul (bs2nat u) match bs2nat (cons false v) with | O => S O | S _ => O end)
+++++
rewrite Zero_correct.
-----
Lemma MultOneMinus'_correct : forall l, hd nil (tl l) = nil \\/ bs2nat (hd nil (tl l)) <> 0 -> bs2nat (Sem MultOneMinus'_e l) = bs2nat (hd nil l) * (1 - bs2nat (hd nil (tl l))).
Proof.
intros [ | u [ | v l] ] H.
simpl.
rewrite Cond_correct.
simpl in *.
destruct v as [ | [ | ] v].
rewrite Zero_correct.

*****
H : or (eq (cons false v) nil) (not (eq (bs2nat (cons false v)) O))
l : list (list bool)
u,v : list bool
*****
eq O (Init.Nat.mul (bs2nat u) match bs2nat (cons false v) with | O => S O | S _ => O end)
+++++
rewrite bs2nat_false in *.
-----
Lemma MultOneMinus'_correct : forall l, hd nil (tl l) = nil \\/ bs2nat (hd nil (tl l)) <> 0 -> bs2nat (Sem MultOneMinus'_e l) = bs2nat (hd nil l) * (1 - bs2nat (hd nil (tl l))).
Proof.
intros [ | u [ | v l] ] H.
simpl.
rewrite Cond_correct.
simpl in *.
destruct v as [ | [ | ] v].
rewrite Zero_correct.
rewrite bs2nat_false in *.

*****
H : or (eq (cons false v) nil)\n (not (eq (Init.Nat.mul (S (S O)) (bs2nat v)) O))
l : list (list bool)
u,v : list bool
*****
eq O (Init.Nat.mul (bs2nat u) match Init.Nat.mul (S (S O)) (bs2nat v) with | O => S O | S _ => O end)
+++++
destruct (2 * bs2nat v).
-----
Lemma MultOneMinus'_correct : forall l, hd nil (tl l) = nil \\/ bs2nat (hd nil (tl l)) <> 0 -> bs2nat (Sem MultOneMinus'_e l) = bs2nat (hd nil l) * (1 - bs2nat (hd nil (tl l))).
Proof.
intros [ | u [ | v l] ] H.
simpl.
rewrite Cond_correct.
simpl in *.
destruct v as [ | [ | ] v].
rewrite Zero_correct.
rewrite bs2nat_false in *.
destruct (2 * bs2nat v).

*****
H : or (eq (cons false v) nil) (not (eq O O))
l : list (list bool)
u,v : list bool
*****
eq O (Init.Nat.mul (bs2nat u) (S O))
+++++
destruct H.
-----
Lemma MultOneMinus'_correct : forall l, hd nil (tl l) = nil \\/ bs2nat (hd nil (tl l)) <> 0 -> bs2nat (Sem MultOneMinus'_e l) = bs2nat (hd nil l) * (1 - bs2nat (hd nil (tl l))).
Proof.
intros [ | u [ | v l] ] H.
simpl.
rewrite Cond_correct.
simpl in *.
destruct v as [ | [ | ] v].
rewrite Zero_correct.
rewrite bs2nat_false in *.
destruct (2 * bs2nat v).
destruct H.

*****
H : eq (cons false v) nil
l : list (list bool)
u,v : list bool
*****
eq O (Init.Nat.mul (bs2nat u) (S O))
+++++
congruence.
-----
Lemma MultOneMinus'_correct : forall l, hd nil (tl l) = nil \\/ bs2nat (hd nil (tl l)) <> 0 -> bs2nat (Sem MultOneMinus'_e l) = bs2nat (hd nil l) * (1 - bs2nat (hd nil (tl l))).
Proof.
intros [ | u [ | v l] ] H.
simpl.
rewrite Cond_correct.
simpl in *.
destruct v as [ | [ | ] v].
rewrite Zero_correct.
rewrite bs2nat_false in *.
destruct (2 * bs2nat v).
destruct H.

*****
H : not (eq O O)
l : list (list bool)
u,v : list bool
*****
eq O (Init.Nat.mul (bs2nat u) (S O))
+++++
tauto.
-----
Lemma MultOneMinus'_correct : forall l, hd nil (tl l) = nil \\/ bs2nat (hd nil (tl l)) <> 0 -> bs2nat (Sem MultOneMinus'_e l) = bs2nat (hd nil l) * (1 - bs2nat (hd nil (tl l))).
Proof.
intros [ | u [ | v l] ] H.
simpl.
rewrite Cond_correct.
simpl in *.
destruct v as [ | [ | ] v].
rewrite Zero_correct.
rewrite bs2nat_false in *.
destruct (2 * bs2nat v).

*****
H : or (eq (cons false v) nil) (not (eq (S n) O))
n : nat
l : list (list bool)
u,v : list bool
*****
eq O (Init.Nat.mul (bs2nat u) O)
+++++
trivial.
-----
Lemma MultOneMinus'_correct : forall l, hd nil (tl l) = nil \\/ bs2nat (hd nil (tl l)) <> 0 -> bs2nat (Sem MultOneMinus'_e l) = bs2nat (hd nil l) * (1 - bs2nat (hd nil (tl l))).
Proof.
intros [ | u [ | v l] ] H.

*****

*****

+++++
Qed.
-----
Opaque MultOneMinus'_e.
-----
Definition MultOneMinus_e : Cobham :=\n  Comp 2 MultOneMinus'_e [Proj 2 0; Comp 2 Normalize_e [Proj 2 1]].
-----
Lemma arity_MultOneMinus : arity MultOneMinus_e = ok_arity 2.
-----
Lemma arity_MultOneMinus : arity MultOneMinus_e = ok_arity 2.

*****

*****
eq (arity MultOneMinus_e) (ok_arity (S (S O)))
+++++
Proof.
-----
Lemma arity_MultOneMinus : arity MultOneMinus_e = ok_arity 2.
Proof.

*****

*****
eq (arity MultOneMinus_e) (ok_arity (S (S O)))
+++++
trivial.
-----
Lemma arity_MultOneMinus : arity MultOneMinus_e = ok_arity 2.
Proof.
trivial.

*****

*****

+++++
Qed.
-----
Lemma rec_bounded_MultOneMinus :\n  rec_bounded MultOneMinus_e.
-----
Lemma rec_bounded_MultOneMinus : rec_bounded MultOneMinus_e.

*****

*****
rec_bounded MultOneMinus_e
+++++
Proof.
-----
Lemma rec_bounded_MultOneMinus : rec_bounded MultOneMinus_e.
Proof.

*****

*****
rec_bounded MultOneMinus_e
+++++
simpl.
-----
Lemma rec_bounded_MultOneMinus : rec_bounded MultOneMinus_e.
Proof.
simpl.

*****

*****
and (rec_bounded MultOneMinus'_e) (and True (and (and (rec_bounded Normalize_e) (and True True)) True))
+++++
intuition.
-----
Lemma rec_bounded_MultOneMinus : rec_bounded MultOneMinus_e.
Proof.
simpl.
intuition.

*****

*****
rec_bounded MultOneMinus'_e
+++++
apply rec_bounded_MultOneMinus'.
-----
Lemma rec_bounded_MultOneMinus : rec_bounded MultOneMinus_e.
Proof.
simpl.
intuition.

*****

*****
rec_bounded Normalize_e
+++++
apply rec_bounded_Normalize.
-----
Lemma rec_bounded_MultOneMinus : rec_bounded MultOneMinus_e.
Proof.
simpl.
intuition.

*****

*****

+++++
Qed.
-----
Lemma MultOneMinus_correct : forall l,\n  bs2nat (Sem MultOneMinus_e l) = bs2nat (hd nil l) * (1 - bs2nat (hd nil (tl l))).
-----
Lemma MultOneMinus_correct : forall l, bs2nat (Sem MultOneMinus_e l) = bs2nat (hd nil l) * (1 - bs2nat (hd nil (tl l))).

*****

*****
forall l : list (list bool), eq (bs2nat (Sem MultOneMinus_e l)) (Init.Nat.mul (bs2nat (hd nil l)) (Init.Nat.sub (S O) (bs2nat (hd nil (tl l)))))
+++++
Proof.
-----
Lemma MultOneMinus_correct : forall l, bs2nat (Sem MultOneMinus_e l) = bs2nat (hd nil l) * (1 - bs2nat (hd nil (tl l))).
Proof.

*****

*****
forall l : list (list bool), eq (bs2nat (Sem MultOneMinus_e l)) (Init.Nat.mul (bs2nat (hd nil l)) (Init.Nat.sub (S O) (bs2nat (hd nil (tl l)))))
+++++
intro l.
-----
Lemma MultOneMinus_correct : forall l, bs2nat (Sem MultOneMinus_e l) = bs2nat (hd nil l) * (1 - bs2nat (hd nil (tl l))).
Proof.
intro l.

*****
l : list (list bool)
*****
eq (bs2nat (Sem MultOneMinus_e l)) (Init.Nat.mul (bs2nat (hd nil l)) (Init.Nat.sub (S O) (bs2nat (hd nil (tl l)))))
+++++
simpl.
-----
Lemma MultOneMinus_correct : forall l, bs2nat (Sem MultOneMinus_e l) = bs2nat (hd nil l) * (1 - bs2nat (hd nil (tl l))).
Proof.
intro l.
simpl.

*****
l : list (list bool)
*****
eq (bs2nat (Sem MultOneMinus'_e (cons (nth O l nil) (cons (Sem Normalize_e (cons (nth (S O) l nil) nil)) nil)))) (Init.Nat.mul (bs2nat (hd nil l)) match bs2nat (hd nil (tl l)) with | O => S O | S _ => O end)
+++++
rewrite MultOneMinus'_correct.
-----
Lemma MultOneMinus_correct : forall l, bs2nat (Sem MultOneMinus_e l) = bs2nat (hd nil l) * (1 - bs2nat (hd nil (tl l))).
Proof.
intro l.
simpl.
rewrite MultOneMinus'_correct.

*****
l : list (list bool)
*****
eq (Init.Nat.mul (bs2nat (hd nil (cons (nth O l nil) (cons (Sem Normalize_e (cons (nth (S O) l nil) nil)) nil)))) (Init.Nat.sub (S O) (bs2nat (hd nil (tl (cons (nth O l nil) (cons (Sem Normalize_e (cons (nth (S O) l nil) nil)) nil))))))) (Init.Nat.mul (bs2nat (hd nil l)) match bs2nat (hd nil (tl l)) with | O => S O | S _ => O end)
+++++
simpl.
-----
Lemma MultOneMinus_correct : forall l, bs2nat (Sem MultOneMinus_e l) = bs2nat (hd nil l) * (1 - bs2nat (hd nil (tl l))).
Proof.
intro l.
simpl.
rewrite MultOneMinus'_correct.
simpl.

*****
l : list (list bool)
*****
eq (Init.Nat.mul (bs2nat (nth O l nil)) match bs2nat (Sem Normalize_e (cons (nth (S O) l nil) nil)) with | O => S O | S _ => O end) (Init.Nat.mul (bs2nat (hd nil l)) match bs2nat (hd nil (tl l)) with | O => S O | S _ => O end)
+++++
rewrite Normalize_correct.
-----
Lemma MultOneMinus_correct : forall l, bs2nat (Sem MultOneMinus_e l) = bs2nat (hd nil l) * (1 - bs2nat (hd nil (tl l))).
Proof.
intro l.
simpl.
rewrite MultOneMinus'_correct.
simpl.
rewrite Normalize_correct.

*****
l : list (list bool)
*****
eq (Init.Nat.mul (bs2nat (nth O l nil)) match bs2nat (Sem (Proj (S O) O) (cons (nth (S O) l nil) nil)) with | O => S O | S _ => O end) (Init.Nat.mul (bs2nat (hd nil l)) match bs2nat (hd nil (tl l)) with | O => S O | S _ => O end)
+++++
simpl.
-----
Lemma MultOneMinus_correct : forall l, bs2nat (Sem MultOneMinus_e l) = bs2nat (hd nil l) * (1 - bs2nat (hd nil (tl l))).
Proof.
intro l.
simpl.
rewrite MultOneMinus'_correct.
simpl.
rewrite Normalize_correct.
simpl.

*****
l : list (list bool)
*****
eq (Init.Nat.mul (bs2nat (nth O l nil)) match bs2nat (nth (S O) l nil) with | O => S O | S _ => O end) (Init.Nat.mul (bs2nat (hd nil l)) match bs2nat (hd nil (tl l)) with | O => S O | S _ => O end)
+++++
rewrite hd_nth_1.
-----
Lemma MultOneMinus_correct : forall l, bs2nat (Sem MultOneMinus_e l) = bs2nat (hd nil l) * (1 - bs2nat (hd nil (tl l))).
Proof.
intro l.
simpl.
rewrite MultOneMinus'_correct.
simpl.
rewrite Normalize_correct.
simpl.
rewrite hd_nth_1.

*****
l : list (list bool)
*****
eq (Init.Nat.mul (bs2nat (nth O l nil)) match bs2nat (nth (S O) l nil) with | O => S O | S _ => O end) (Init.Nat.mul (bs2nat (hd nil l)) match bs2nat (nth (S O) l nil) with | O => S O | S _ => O end)
+++++
rewrite hd_nth_0.
-----
Lemma MultOneMinus_correct : forall l, bs2nat (Sem MultOneMinus_e l) = bs2nat (hd nil l) * (1 - bs2nat (hd nil (tl l))).
Proof.
intro l.
simpl.
rewrite MultOneMinus'_correct.
simpl.
rewrite Normalize_correct.
simpl.
rewrite hd_nth_1.
rewrite hd_nth_0.

*****
l : list (list bool)
*****
eq (Init.Nat.mul (bs2nat (nth O l nil)) match bs2nat (nth (S O) l nil) with | O => S O | S _ => O end) (Init.Nat.mul (bs2nat (nth O l nil)) match bs2nat (nth (S O) l nil) with | O => S O | S _ => O end)
+++++
trivial.
-----
Lemma MultOneMinus_correct : forall l, bs2nat (Sem MultOneMinus_e l) = bs2nat (hd nil l) * (1 - bs2nat (hd nil (tl l))).
Proof.
intro l.
simpl.
rewrite MultOneMinus'_correct.

*****
l : list (list bool)
*****
or (eq (hd nil (tl (cons (nth O l nil) (cons (Sem Normalize_e (cons (nth (S O) l nil) nil)) nil)))) nil) (not (eq (bs2nat (hd nil (tl (cons (nth O l nil) (cons (Sem Normalize_e (cons (nth (S O) l nil) nil)) nil))))) O))
+++++
simpl.
-----
Lemma MultOneMinus_correct : forall l, bs2nat (Sem MultOneMinus_e l) = bs2nat (hd nil l) * (1 - bs2nat (hd nil (tl l))).
Proof.
intro l.
simpl.
rewrite MultOneMinus'_correct.
simpl.

*****
l : list (list bool)
*****
or (eq (Sem Normalize_e (cons (nth (S O) l nil) nil)) nil) (not (eq (bs2nat (Sem Normalize_e (cons (nth (S O) l nil) nil))) O))
+++++
apply Normalize_normal.
-----
Lemma MultOneMinus_correct : forall l, bs2nat (Sem MultOneMinus_e l) = bs2nat (hd nil l) * (1 - bs2nat (hd nil (tl l))).
Proof.
intro l.
simpl.
rewrite MultOneMinus'_correct.

*****

*****

+++++
Qed.
-----
Opaque MultOneMinus_e.
-----
Definition PlusOneMinus'_e : Cobham :=\n  Comp 2 Cond [\n    Proj 2 1;\n    Comp 2 Succ_e [Proj 2 0];\n    Proj 2 0;\n    Proj 2 0\n  ].
-----
Lemma arity_PlusOneMinus' : arity PlusOneMinus'_e = ok_arity 2.
-----
Lemma arity_PlusOneMinus' : arity PlusOneMinus'_e = ok_arity 2.

*****

*****
eq (arity PlusOneMinus'_e) (ok_arity (S (S O)))
+++++
Proof.
-----
Lemma arity_PlusOneMinus' : arity PlusOneMinus'_e = ok_arity 2.
Proof.

*****

*****
eq (arity PlusOneMinus'_e) (ok_arity (S (S O)))
+++++
trivial.
-----
Lemma arity_PlusOneMinus' : arity PlusOneMinus'_e = ok_arity 2.
Proof.
trivial.

*****

*****

+++++
Qed.
-----
Lemma rec_bounded_PlusOneMinus' :\n  rec_bounded PlusOneMinus'_e.
-----
Lemma rec_bounded_PlusOneMinus' : rec_bounded PlusOneMinus'_e.

*****

*****
rec_bounded PlusOneMinus'_e
+++++
Proof.
-----
Lemma rec_bounded_PlusOneMinus' : rec_bounded PlusOneMinus'_e.
Proof.

*****

*****
rec_bounded PlusOneMinus'_e
+++++
simpl.
-----
Lemma rec_bounded_PlusOneMinus' : rec_bounded PlusOneMinus'_e.
Proof.
simpl.

*****

*****
and (rec_bounded Cond) (and True (and (and (rec_bounded Succ_e) (and True True)) (and True (and True True))))
+++++
intuition.
-----
Lemma rec_bounded_PlusOneMinus' : rec_bounded PlusOneMinus'_e.
Proof.
simpl.
intuition.

*****

*****
rec_bounded Cond
+++++
apply rec_bounded'_spec with 4.
-----
Lemma rec_bounded_PlusOneMinus' : rec_bounded PlusOneMinus'_e.
Proof.
simpl.
intuition.
apply rec_bounded'_spec with 4.

*****

*****
eq (arity Cond) (ok_arity (S (S (S (S O)))))
+++++
apply arity_Cond.
-----
Lemma rec_bounded_PlusOneMinus' : rec_bounded PlusOneMinus'_e.
Proof.
simpl.
intuition.
apply rec_bounded'_spec with 4.

*****

*****
rec_bounded' Cond
+++++
apply rec_bounded_Cond.
-----
Lemma rec_bounded_PlusOneMinus' : rec_bounded PlusOneMinus'_e.
Proof.
simpl.
intuition.

*****

*****
rec_bounded Succ_e
+++++
apply rec_bounded_Succ.
-----
Lemma rec_bounded_PlusOneMinus' : rec_bounded PlusOneMinus'_e.
Proof.
simpl.
intuition.

*****

*****

+++++
Qed.
-----
Lemma PlusOneMinus'_correct : forall l,\n  hd nil (tl l) = nil \/ bs2nat (hd nil (tl l)) <> 0 ->\n  bs2nat (Sem PlusOneMinus'_e l) = bs2nat (hd nil l) + (1 - bs2nat (hd nil (tl l))).
-----
Lemma PlusOneMinus'_correct : forall l, hd nil (tl l) = nil \\/ bs2nat (hd nil (tl l)) <> 0 -> bs2nat (Sem PlusOneMinus'_e l) = bs2nat (hd nil l) + (1 - bs2nat (hd nil (tl l))).

*****

*****
forall (l : list (list bool)) (_ : or (eq (hd nil (tl l)) nil) (not (eq (bs2nat (hd nil (tl l))) O))), eq (bs2nat (Sem PlusOneMinus'_e l)) (Init.Nat.add (bs2nat (hd nil l)) (Init.Nat.sub (S O) (bs2nat (hd nil (tl l)))))
+++++
Proof.
-----
Lemma PlusOneMinus'_correct : forall l, hd nil (tl l) = nil \\/ bs2nat (hd nil (tl l)) <> 0 -> bs2nat (Sem PlusOneMinus'_e l) = bs2nat (hd nil l) + (1 - bs2nat (hd nil (tl l))).
Proof.

*****

*****
forall (l : list (list bool)) (_ : or (eq (hd nil (tl l)) nil) (not (eq (bs2nat (hd nil (tl l))) O))), eq (bs2nat (Sem PlusOneMinus'_e l)) (Init.Nat.add (bs2nat (hd nil l)) (Init.Nat.sub (S O) (bs2nat (hd nil (tl l)))))
+++++
intros [ | u [ | v l] ] H.
-----
Lemma PlusOneMinus'_correct : forall l, hd nil (tl l) = nil \\/ bs2nat (hd nil (tl l)) <> 0 -> bs2nat (Sem PlusOneMinus'_e l) = bs2nat (hd nil l) + (1 - bs2nat (hd nil (tl l))).
Proof.
intros [ | u [ | v l] ] H.

*****
H : or (eq (hd nil (tl nil)) nil) (not (eq (bs2nat (hd nil (tl nil))) O))
*****
eq (bs2nat (Sem PlusOneMinus'_e nil)) (Init.Nat.add (bs2nat (hd nil nil)) (Init.Nat.sub (S O) (bs2nat (hd nil (tl nil)))))
+++++
trivial.
-----
Lemma PlusOneMinus'_correct : forall l, hd nil (tl l) = nil \\/ bs2nat (hd nil (tl l)) <> 0 -> bs2nat (Sem PlusOneMinus'_e l) = bs2nat (hd nil l) + (1 - bs2nat (hd nil (tl l))).
Proof.
intros [ | u [ | v l] ] H.

*****
H : or (eq (hd nil (tl (cons u nil))) nil)\n (not (eq (bs2nat (hd nil (tl (cons u nil)))) O))
u : list bool
*****
eq (bs2nat (Sem PlusOneMinus'_e (cons u nil))) (Init.Nat.add (bs2nat (hd nil (cons u nil))) (Init.Nat.sub (S O) (bs2nat (hd nil (tl (cons u nil))))))
+++++
simpl.
-----
Lemma PlusOneMinus'_correct : forall l, hd nil (tl l) = nil \\/ bs2nat (hd nil (tl l)) <> 0 -> bs2nat (Sem PlusOneMinus'_e l) = bs2nat (hd nil l) + (1 - bs2nat (hd nil (tl l))).
Proof.
intros [ | u [ | v l] ] H.
simpl.

*****
H : or (eq (hd nil (tl (cons u nil))) nil)\n (not (eq (bs2nat (hd nil (tl (cons u nil)))) O))
u : list bool
*****
eq (bs2nat (Sem Cond (cons nil (cons (Sem Succ_e (cons u nil)) (cons u (cons u nil)))))) (Init.Nat.add (bs2nat u) match bs2nat nil with | O => S O | S _ => O end)
+++++
rewrite Cond_correct.
-----
Lemma PlusOneMinus'_correct : forall l, hd nil (tl l) = nil \\/ bs2nat (hd nil (tl l)) <> 0 -> bs2nat (Sem PlusOneMinus'_e l) = bs2nat (hd nil l) + (1 - bs2nat (hd nil (tl l))).
Proof.
intros [ | u [ | v l] ] H.
simpl.
rewrite Cond_correct.

*****
H : or (eq (hd nil (tl (cons u nil))) nil)\n (not (eq (bs2nat (hd nil (tl (cons u nil)))) O))
u : list bool
*****
eq (bs2nat match hd nil (cons nil (cons (Sem Succ_e (cons u nil)) (cons u (cons u nil)))) with | nil => hd nil (tl (cons nil (cons (Sem Succ_e (cons u nil)) (cons u (cons u nil))))) | cons true _ => hd nil (tl (tl (cons nil (cons (Sem Succ_e (cons u nil)) (cons u (cons u nil)))))) | cons false _ => hd nil (tl (tl (tl (cons nil (cons (Sem Succ_e (cons u nil)) (cons u (cons u nil))))))) end) (Init.Nat.add (bs2nat u) match bs2nat nil with | O => S O | S _ => O end)
+++++
simpl.
-----
Lemma PlusOneMinus'_correct : forall l, hd nil (tl l) = nil \\/ bs2nat (hd nil (tl l)) <> 0 -> bs2nat (Sem PlusOneMinus'_e l) = bs2nat (hd nil l) + (1 - bs2nat (hd nil (tl l))).
Proof.
intros [ | u [ | v l] ] H.
simpl.
rewrite Cond_correct.
simpl.

*****
H : or (eq (hd nil (tl (cons u nil))) nil)\n (not (eq (bs2nat (hd nil (tl (cons u nil)))) O))
u : list bool
*****
eq (bs2nat (Sem Succ_e (cons u nil))) (Init.Nat.add (bs2nat u) match bs2nat nil with | O => S O | S _ => O end)
+++++
rewrite Succ_correct.
-----
Lemma PlusOneMinus'_correct : forall l, hd nil (tl l) = nil \\/ bs2nat (hd nil (tl l)) <> 0 -> bs2nat (Sem PlusOneMinus'_e l) = bs2nat (hd nil l) + (1 - bs2nat (hd nil (tl l))).
Proof.
intros [ | u [ | v l] ] H.
simpl.
rewrite Cond_correct.
simpl.
rewrite Succ_correct.

*****
H : or (eq (hd nil (tl (cons u nil))) nil)\n (not (eq (bs2nat (hd nil (tl (cons u nil)))) O))
u : list bool
*****
eq (Init.Nat.add (S O) (bs2nat (hd nil (cons u nil)))) (Init.Nat.add (bs2nat u) match bs2nat nil with | O => S O | S _ => O end)
+++++
rewrite bs2nat_nil.
-----
Lemma PlusOneMinus'_correct : forall l, hd nil (tl l) = nil \\/ bs2nat (hd nil (tl l)) <> 0 -> bs2nat (Sem PlusOneMinus'_e l) = bs2nat (hd nil l) + (1 - bs2nat (hd nil (tl l))).
Proof.
intros [ | u [ | v l] ] H.
simpl.
rewrite Cond_correct.
simpl.
rewrite Succ_correct.
rewrite bs2nat_nil.

*****
H : or (eq (hd nil (tl (cons u nil))) nil)\n (not (eq (bs2nat (hd nil (tl (cons u nil)))) O))
u : list bool
*****
eq (Init.Nat.add (S O) (bs2nat (hd nil (cons u nil)))) (Init.Nat.add (bs2nat u) (S O))
+++++
simpl.
-----
Lemma PlusOneMinus'_correct : forall l, hd nil (tl l) = nil \\/ bs2nat (hd nil (tl l)) <> 0 -> bs2nat (Sem PlusOneMinus'_e l) = bs2nat (hd nil l) + (1 - bs2nat (hd nil (tl l))).
Proof.
intros [ | u [ | v l] ] H.
simpl.
rewrite Cond_correct.
simpl.
rewrite Succ_correct.
rewrite bs2nat_nil.
simpl.

*****
H : or (eq (hd nil (tl (cons u nil))) nil)\n (not (eq (bs2nat (hd nil (tl (cons u nil)))) O))
u : list bool
*****
eq (S (bs2nat u)) (Init.Nat.add (bs2nat u) (S O))
+++++
ring.
-----
Lemma PlusOneMinus'_correct : forall l, hd nil (tl l) = nil \\/ bs2nat (hd nil (tl l)) <> 0 -> bs2nat (Sem PlusOneMinus'_e l) = bs2nat (hd nil l) + (1 - bs2nat (hd nil (tl l))).
Proof.
intros [ | u [ | v l] ] H.

*****
H : or (eq (hd nil (tl (cons u (cons v l)))) nil)\n (not (eq (bs2nat (hd nil (tl (cons u (cons v l))))) O))
l : list (list bool)
u,v : list bool
*****
eq (bs2nat (Sem PlusOneMinus'_e (cons u (cons v l)))) (Init.Nat.add (bs2nat (hd nil (cons u (cons v l)))) (Init.Nat.sub (S O) (bs2nat (hd nil (tl (cons u (cons v l)))))))
+++++
simpl.
-----
Lemma PlusOneMinus'_correct : forall l, hd nil (tl l) = nil \\/ bs2nat (hd nil (tl l)) <> 0 -> bs2nat (Sem PlusOneMinus'_e l) = bs2nat (hd nil l) + (1 - bs2nat (hd nil (tl l))).
Proof.
intros [ | u [ | v l] ] H.
simpl.

*****
H : or (eq (hd nil (tl (cons u (cons v l)))) nil)\n (not (eq (bs2nat (hd nil (tl (cons u (cons v l))))) O))
l : list (list bool)
u,v : list bool
*****
eq (bs2nat (Sem Cond (cons v (cons (Sem Succ_e (cons u nil)) (cons u (cons u nil)))))) (Init.Nat.add (bs2nat u) match bs2nat v with | O => S O | S _ => O end)
+++++
rewrite Cond_correct.
-----
Lemma PlusOneMinus'_correct : forall l, hd nil (tl l) = nil \\/ bs2nat (hd nil (tl l)) <> 0 -> bs2nat (Sem PlusOneMinus'_e l) = bs2nat (hd nil l) + (1 - bs2nat (hd nil (tl l))).
Proof.
intros [ | u [ | v l] ] H.
simpl.
rewrite Cond_correct.

*****
H : or (eq (hd nil (tl (cons u (cons v l)))) nil)\n (not (eq (bs2nat (hd nil (tl (cons u (cons v l))))) O))
l : list (list bool)
u,v : list bool
*****
eq (bs2nat match hd nil (cons v (cons (Sem Succ_e (cons u nil)) (cons u (cons u nil)))) with | nil => hd nil (tl (cons v (cons (Sem Succ_e (cons u nil)) (cons u (cons u nil))))) | cons true _ => hd nil (tl (tl (cons v (cons (Sem Succ_e (cons u nil)) (cons u (cons u nil)))))) | cons false _ => hd nil (tl (tl (tl (cons v (cons (Sem Succ_e (cons u nil)) (cons u (cons u nil))))))) end) (Init.Nat.add (bs2nat u) match bs2nat v with | O => S O | S _ => O end)
+++++
simpl.
-----
Lemma PlusOneMinus'_correct : forall l, hd nil (tl l) = nil \\/ bs2nat (hd nil (tl l)) <> 0 -> bs2nat (Sem PlusOneMinus'_e l) = bs2nat (hd nil l) + (1 - bs2nat (hd nil (tl l))).
Proof.
intros [ | u [ | v l] ] H.
simpl.
rewrite Cond_correct.
simpl.

*****
H : or (eq (hd nil (tl (cons u (cons v l)))) nil)\n (not (eq (bs2nat (hd nil (tl (cons u (cons v l))))) O))
l : list (list bool)
u,v : list bool
*****
eq (bs2nat match v with | nil => Sem Succ_e (cons u nil) | _ => u end) (Init.Nat.add (bs2nat u) match bs2nat v with | O => S O | S _ => O end)
+++++
destruct v as [ | [ | ] v].
-----
Lemma PlusOneMinus'_correct : forall l, hd nil (tl l) = nil \\/ bs2nat (hd nil (tl l)) <> 0 -> bs2nat (Sem PlusOneMinus'_e l) = bs2nat (hd nil l) + (1 - bs2nat (hd nil (tl l))).
Proof.
intros [ | u [ | v l] ] H.
simpl.
rewrite Cond_correct.
simpl.
destruct v as [ | [ | ] v].

*****
H : or (eq (hd nil (tl (cons u (cons nil l)))) nil)\n (not (eq (bs2nat (hd nil (tl (cons u (cons nil l))))) O))
l : list (list bool)
u : list bool
*****
eq (bs2nat (Sem Succ_e (cons u nil))) (Init.Nat.add (bs2nat u) match bs2nat nil with | O => S O | S _ => O end)
+++++
rewrite Succ_correct.
-----
Lemma PlusOneMinus'_correct : forall l, hd nil (tl l) = nil \\/ bs2nat (hd nil (tl l)) <> 0 -> bs2nat (Sem PlusOneMinus'_e l) = bs2nat (hd nil l) + (1 - bs2nat (hd nil (tl l))).
Proof.
intros [ | u [ | v l] ] H.
simpl.
rewrite Cond_correct.
simpl.
destruct v as [ | [ | ] v].
rewrite Succ_correct.

*****
H : or (eq (hd nil (tl (cons u (cons nil l)))) nil)\n (not (eq (bs2nat (hd nil (tl (cons u (cons nil l))))) O))
l : list (list bool)
u : list bool
*****
eq (Init.Nat.add (S O) (bs2nat (hd nil (cons u nil)))) (Init.Nat.add (bs2nat u) match bs2nat nil with | O => S O | S _ => O end)
+++++
rewrite bs2nat_nil.
-----
Lemma PlusOneMinus'_correct : forall l, hd nil (tl l) = nil \\/ bs2nat (hd nil (tl l)) <> 0 -> bs2nat (Sem PlusOneMinus'_e l) = bs2nat (hd nil l) + (1 - bs2nat (hd nil (tl l))).
Proof.
intros [ | u [ | v l] ] H.
simpl.
rewrite Cond_correct.
simpl.
destruct v as [ | [ | ] v].
rewrite Succ_correct.
rewrite bs2nat_nil.

*****
H : or (eq (hd nil (tl (cons u (cons nil l)))) nil)\n (not (eq (bs2nat (hd nil (tl (cons u (cons nil l))))) O))
l : list (list bool)
u : list bool
*****
eq (Init.Nat.add (S O) (bs2nat (hd nil (cons u nil)))) (Init.Nat.add (bs2nat u) (S O))
+++++
simpl.
-----
Lemma PlusOneMinus'_correct : forall l, hd nil (tl l) = nil \\/ bs2nat (hd nil (tl l)) <> 0 -> bs2nat (Sem PlusOneMinus'_e l) = bs2nat (hd nil l) + (1 - bs2nat (hd nil (tl l))).
Proof.
intros [ | u [ | v l] ] H.
simpl.
rewrite Cond_correct.
simpl.
destruct v as [ | [ | ] v].
rewrite Succ_correct.
rewrite bs2nat_nil.
simpl.

*****
H : or (eq (hd nil (tl (cons u (cons nil l)))) nil)\n (not (eq (bs2nat (hd nil (tl (cons u (cons nil l))))) O))
l : list (list bool)
u : list bool
*****
eq (S (bs2nat u)) (Init.Nat.add (bs2nat u) (S O))
+++++
ring.
-----
Lemma PlusOneMinus'_correct : forall l, hd nil (tl l) = nil \\/ bs2nat (hd nil (tl l)) <> 0 -> bs2nat (Sem PlusOneMinus'_e l) = bs2nat (hd nil l) + (1 - bs2nat (hd nil (tl l))).
Proof.
intros [ | u [ | v l] ] H.
simpl.
rewrite Cond_correct.
simpl.
destruct v as [ | [ | ] v].

*****
H : or (eq (hd nil (tl (cons u (cons (cons true v) l)))) nil)\n (not (eq (bs2nat (hd nil (tl (cons u (cons (cons true v) l))))) O))
l : list (list bool)
u,v : list bool
*****
eq (bs2nat u) (Init.Nat.add (bs2nat u) match bs2nat (cons true v) with | O => S O | S _ => O end)
+++++
trivial.
-----
Lemma PlusOneMinus'_correct : forall l, hd nil (tl l) = nil \\/ bs2nat (hd nil (tl l)) <> 0 -> bs2nat (Sem PlusOneMinus'_e l) = bs2nat (hd nil l) + (1 - bs2nat (hd nil (tl l))).
Proof.
intros [ | u [ | v l] ] H.
simpl.
rewrite Cond_correct.
simpl.
destruct v as [ | [ | ] v].

*****
H : or (eq (hd nil (tl (cons u (cons (cons false v) l)))) nil)\n (not (eq (bs2nat (hd nil (tl (cons u (cons (cons false v) l))))) O))
l : list (list bool)
u,v : list bool
*****
eq (bs2nat u) (Init.Nat.add (bs2nat u) match bs2nat (cons false v) with | O => S O | S _ => O end)
+++++
simpl in H.
-----
Lemma PlusOneMinus'_correct : forall l, hd nil (tl l) = nil \\/ bs2nat (hd nil (tl l)) <> 0 -> bs2nat (Sem PlusOneMinus'_e l) = bs2nat (hd nil l) + (1 - bs2nat (hd nil (tl l))).
Proof.
intros [ | u [ | v l] ] H.
simpl.
rewrite Cond_correct.
simpl.
destruct v as [ | [ | ] v].
simpl in H.

*****
H : or (eq (cons false v) nil) (not (eq (bs2nat (cons false v)) O))
l : list (list bool)
u,v : list bool
*****
eq (bs2nat u) (Init.Nat.add (bs2nat u) match bs2nat (cons false v) with | O => S O | S _ => O end)
+++++
rewrite bs2nat_false in *.
-----
Lemma PlusOneMinus'_correct : forall l, hd nil (tl l) = nil \\/ bs2nat (hd nil (tl l)) <> 0 -> bs2nat (Sem PlusOneMinus'_e l) = bs2nat (hd nil l) + (1 - bs2nat (hd nil (tl l))).
Proof.
intros [ | u [ | v l] ] H.
simpl.
rewrite Cond_correct.
simpl.
destruct v as [ | [ | ] v].
simpl in H.
rewrite bs2nat_false in *.

*****
H : or (eq (cons false v) nil)\n (not (eq (Init.Nat.mul (S (S O)) (bs2nat v)) O))
l : list (list bool)
u,v : list bool
*****
eq (bs2nat u) (Init.Nat.add (bs2nat u) match Init.Nat.mul (S (S O)) (bs2nat v) with | O => S O | S _ => O end)
+++++
destruct (2 * bs2nat v).
-----
Lemma PlusOneMinus'_correct : forall l, hd nil (tl l) = nil \\/ bs2nat (hd nil (tl l)) <> 0 -> bs2nat (Sem PlusOneMinus'_e l) = bs2nat (hd nil l) + (1 - bs2nat (hd nil (tl l))).
Proof.
intros [ | u [ | v l] ] H.
simpl.
rewrite Cond_correct.
simpl.
destruct v as [ | [ | ] v].
simpl in H.
rewrite bs2nat_false in *.
destruct (2 * bs2nat v).

*****
H : or (eq (cons false v) nil) (not (eq O O))
l : list (list bool)
u,v : list bool
*****
eq (bs2nat u) (Init.Nat.add (bs2nat u) (S O))
+++++
destruct H.
-----
Lemma PlusOneMinus'_correct : forall l, hd nil (tl l) = nil \\/ bs2nat (hd nil (tl l)) <> 0 -> bs2nat (Sem PlusOneMinus'_e l) = bs2nat (hd nil l) + (1 - bs2nat (hd nil (tl l))).
Proof.
intros [ | u [ | v l] ] H.
simpl.
rewrite Cond_correct.
simpl.
destruct v as [ | [ | ] v].
simpl in H.
rewrite bs2nat_false in *.
destruct (2 * bs2nat v).
destruct H.

*****
H : eq (cons false v) nil
l : list (list bool)
u,v : list bool
*****
eq (bs2nat u) (Init.Nat.add (bs2nat u) (S O))
+++++
congruence.
-----
Lemma PlusOneMinus'_correct : forall l, hd nil (tl l) = nil \\/ bs2nat (hd nil (tl l)) <> 0 -> bs2nat (Sem PlusOneMinus'_e l) = bs2nat (hd nil l) + (1 - bs2nat (hd nil (tl l))).
Proof.
intros [ | u [ | v l] ] H.
simpl.
rewrite Cond_correct.
simpl.
destruct v as [ | [ | ] v].
simpl in H.
rewrite bs2nat_false in *.
destruct (2 * bs2nat v).
destruct H.

*****
H : not (eq O O)
l : list (list bool)
u,v : list bool
*****
eq (bs2nat u) (Init.Nat.add (bs2nat u) (S O))
+++++
tauto.
-----
Lemma PlusOneMinus'_correct : forall l, hd nil (tl l) = nil \\/ bs2nat (hd nil (tl l)) <> 0 -> bs2nat (Sem PlusOneMinus'_e l) = bs2nat (hd nil l) + (1 - bs2nat (hd nil (tl l))).
Proof.
intros [ | u [ | v l] ] H.
simpl.
rewrite Cond_correct.
simpl.
destruct v as [ | [ | ] v].
simpl in H.
rewrite bs2nat_false in *.
destruct (2 * bs2nat v).

*****
H : or (eq (cons false v) nil) (not (eq (S n) O))
n : nat
l : list (list bool)
u,v : list bool
*****
eq (bs2nat u) (Init.Nat.add (bs2nat u) O)
+++++
trivial.
-----
Lemma PlusOneMinus'_correct : forall l, hd nil (tl l) = nil \\/ bs2nat (hd nil (tl l)) <> 0 -> bs2nat (Sem PlusOneMinus'_e l) = bs2nat (hd nil l) + (1 - bs2nat (hd nil (tl l))).
Proof.
intros [ | u [ | v l] ] H.

*****

*****

+++++
Qed.
-----
Lemma PlusOneMinus'_length : forall l,\n  length (Sem PlusOneMinus'_e [nth 0 l nil; Sem Normalize_e [nth 1 l nil]])\n  <= S (length (hd nil l)).
-----
Lemma PlusOneMinus'_length : forall l, length (Sem PlusOneMinus'_e [nth 0 l nil; Sem Normalize_e [nth 1 l nil]]) <= S (length (hd nil l)).

*****

*****
forall l : list (list bool), le (length (Sem PlusOneMinus'_e (cons (nth O l nil) (cons (Sem Normalize_e (cons (nth (S O) l nil) nil)) nil)))) (S (length (hd nil l)))
+++++
Proof.
-----
Lemma PlusOneMinus'_length : forall l, length (Sem PlusOneMinus'_e [nth 0 l nil; Sem Normalize_e [nth 1 l nil]]) <= S (length (hd nil l)).
Proof.

*****

*****
forall l : list (list bool), le (length (Sem PlusOneMinus'_e (cons (nth O l nil) (cons (Sem Normalize_e (cons (nth (S O) l nil) nil)) nil)))) (S (length (hd nil l)))
+++++
intros.
-----
Lemma PlusOneMinus'_length : forall l, length (Sem PlusOneMinus'_e [nth 0 l nil; Sem Normalize_e [nth 1 l nil]]) <= S (length (hd nil l)).
Proof.
intros.

*****
l : list (list bool)
*****
le (length (Sem PlusOneMinus'_e (cons (nth O l nil) (cons (Sem Normalize_e (cons (nth (S O) l nil) nil)) nil)))) (S (length (hd nil l)))
+++++
simpl.
-----
Lemma PlusOneMinus'_length : forall l, length (Sem PlusOneMinus'_e [nth 0 l nil; Sem Normalize_e [nth 1 l nil]]) <= S (length (hd nil l)).
Proof.
intros.
simpl.

*****
l : list (list bool)
*****
le (length (Sem Cond (cons (Sem Normalize_e (cons (nth (S O) l nil) nil)) (cons (Sem Succ_e (cons (nth O l nil) nil)) (cons (nth O l nil) (cons (nth O l nil) nil)))))) (S (length (hd nil l)))
+++++
rewrite Cond_correct.
-----
Lemma PlusOneMinus'_length : forall l, length (Sem PlusOneMinus'_e [nth 0 l nil; Sem Normalize_e [nth 1 l nil]]) <= S (length (hd nil l)).
Proof.
intros.
simpl.
rewrite Cond_correct.

*****
l : list (list bool)
*****
le (length match hd nil (cons (Sem Normalize_e (cons (nth (S O) l nil) nil)) (cons (Sem Succ_e (cons (nth O l nil) nil)) (cons (nth O l nil) (cons (nth O l nil) nil)))) with | nil => hd nil (tl (cons (Sem Normalize_e (cons (nth (S O) l nil) nil)) (cons (Sem Succ_e (cons (nth O l nil) nil)) (cons (nth O l nil) (cons (nth O l nil) nil))))) | cons true _ => hd nil (tl (tl (cons (Sem Normalize_e (cons (nth (S O) l nil) nil)) (cons (Sem Succ_e (cons (nth O l nil) nil)) (cons (nth O l nil) (cons (nth O l nil) nil)))))) | cons false _ => hd nil (tl (tl (tl (cons (Sem Normalize_e (cons (nth (S O) l nil) nil)) (cons (Sem Succ_e (cons (nth O l nil) nil)) (cons (nth O l nil) (cons (nth O l nil) nil))))))) end) (S (length (hd nil l)))
+++++
simpl.
-----
Lemma PlusOneMinus'_length : forall l, length (Sem PlusOneMinus'_e [nth 0 l nil; Sem Normalize_e [nth 1 l nil]]) <= S (length (hd nil l)).
Proof.
intros.
simpl.
rewrite Cond_correct.
simpl.

*****
l : list (list bool)
*****
le (length match Sem Normalize_e (cons (nth (S O) l nil) nil) with | nil => Sem Succ_e (cons (nth O l nil) nil) | _ => nth O l nil end) (S (length (hd nil l)))
+++++
rewrite hd_nth_0.
-----
Lemma PlusOneMinus'_length : forall l, length (Sem PlusOneMinus'_e [nth 0 l nil; Sem Normalize_e [nth 1 l nil]]) <= S (length (hd nil l)).
Proof.
intros.
simpl.
rewrite Cond_correct.
simpl.
rewrite hd_nth_0.

*****
l : list (list bool)
*****
le (length match Sem Normalize_e (cons (nth (S O) l nil) nil) with | nil => Sem Succ_e (cons (nth O l nil) nil) | _ => nth O l nil end) (S (length (nth O l nil)))
+++++
destruct (Sem Normalize_e [nth 1 l nil]).
-----
Lemma PlusOneMinus'_length : forall l, length (Sem PlusOneMinus'_e [nth 0 l nil; Sem Normalize_e [nth 1 l nil]]) <= S (length (hd nil l)).
Proof.
intros.
simpl.
rewrite Cond_correct.
simpl.
rewrite hd_nth_0.
destruct (Sem Normalize_e [nth 1 l nil]).

*****
l : list (list bool)
*****
le (length (Sem Succ_e (cons (nth O l nil) nil))) (S (length (nth O l nil)))
+++++
auto.
-----
Lemma PlusOneMinus'_length : forall l, length (Sem PlusOneMinus'_e [nth 0 l nil; Sem Normalize_e [nth 1 l nil]]) <= S (length (hd nil l)).
Proof.
intros.
simpl.
rewrite Cond_correct.
simpl.
rewrite hd_nth_0.
destruct (Sem Normalize_e [nth 1 l nil]).
auto.

*****
l : list (list bool)
*****
le (length (Sem Succ_e (cons (nth O l nil) nil))) (S (length (nth O l nil)))
+++++
apply Succ_length.
-----
Lemma PlusOneMinus'_length : forall l, length (Sem PlusOneMinus'_e [nth 0 l nil; Sem Normalize_e [nth 1 l nil]]) <= S (length (hd nil l)).
Proof.
intros.
simpl.
rewrite Cond_correct.
simpl.
rewrite hd_nth_0.
destruct (Sem Normalize_e [nth 1 l nil]).

*****
l0 : list bool
b : bool
l : list (list bool)
*****
le (length (if b then nth O l nil else nth O l nil)) (S (length (nth O l nil)))
+++++
auto.
-----
Lemma PlusOneMinus'_length : forall l, length (Sem PlusOneMinus'_e [nth 0 l nil; Sem Normalize_e [nth 1 l nil]]) <= S (length (hd nil l)).
Proof.
intros.
simpl.
rewrite Cond_correct.
simpl.
rewrite hd_nth_0.
destruct (Sem Normalize_e [nth 1 l nil]).
auto.

*****
l0 : list bool
b : bool
l : list (list bool)
*****
le (length (if b then nth O l nil else nth O l nil)) (S (length (nth O l nil)))
+++++
case b.
-----
Lemma PlusOneMinus'_length : forall l, length (Sem PlusOneMinus'_e [nth 0 l nil; Sem Normalize_e [nth 1 l nil]]) <= S (length (hd nil l)).
Proof.
intros.
simpl.
rewrite Cond_correct.
simpl.
rewrite hd_nth_0.
destruct (Sem Normalize_e [nth 1 l nil]).
auto.
case b.

*****
l0 : list bool
b : bool
l : list (list bool)
*****
le (length (nth O l nil)) (S (length (nth O l nil)))
+++++
auto.
-----
Lemma PlusOneMinus'_length : forall l, length (Sem PlusOneMinus'_e [nth 0 l nil; Sem Normalize_e [nth 1 l nil]]) <= S (length (hd nil l)).
Proof.
intros.
simpl.
rewrite Cond_correct.
simpl.
rewrite hd_nth_0.
destruct (Sem Normalize_e [nth 1 l nil]).
auto.
case b.

*****
l0 : list bool
b : bool
l : list (list bool)
*****
le (length (nth O l nil)) (S (length (nth O l nil)))
+++++
auto.
-----
Lemma PlusOneMinus'_length : forall l, length (Sem PlusOneMinus'_e [nth 0 l nil; Sem Normalize_e [nth 1 l nil]]) <= S (length (hd nil l)).
Proof.
intros.
simpl.
rewrite Cond_correct.
simpl.
rewrite hd_nth_0.
destruct (Sem Normalize_e [nth 1 l nil]).

*****

*****

+++++
Qed.
-----
Opaque PlusOneMinus'_e.
-----
Definition PlusOneMinus_e : Cobham :=\n  Comp 2 PlusOneMinus'_e [Proj 2 0; Comp 2 Normalize_e [Proj 2 1] ].
-----
Lemma arity_PlusOneMinus : arity PlusOneMinus_e = ok_arity 2.
-----
Lemma arity_PlusOneMinus : arity PlusOneMinus_e = ok_arity 2.

*****

*****
eq (arity PlusOneMinus_e) (ok_arity (S (S O)))
+++++
Proof.
-----
Lemma arity_PlusOneMinus : arity PlusOneMinus_e = ok_arity 2.
Proof.

*****

*****
eq (arity PlusOneMinus_e) (ok_arity (S (S O)))
+++++
trivial.
-----
Lemma arity_PlusOneMinus : arity PlusOneMinus_e = ok_arity 2.
Proof.
trivial.

*****

*****

+++++
Qed.
-----
Lemma rec_bounded_PlusOneMinus :\n  rec_bounded PlusOneMinus_e.
-----
Lemma rec_bounded_PlusOneMinus : rec_bounded PlusOneMinus_e.

*****

*****
rec_bounded PlusOneMinus_e
+++++
Proof.
-----
Lemma rec_bounded_PlusOneMinus : rec_bounded PlusOneMinus_e.
Proof.

*****

*****
rec_bounded PlusOneMinus_e
+++++
simpl.
-----
Lemma rec_bounded_PlusOneMinus : rec_bounded PlusOneMinus_e.
Proof.
simpl.

*****

*****
and (rec_bounded PlusOneMinus'_e) (and True (and (and (rec_bounded Normalize_e) (and True True)) True))
+++++
intuition.
-----
Lemma rec_bounded_PlusOneMinus : rec_bounded PlusOneMinus_e.
Proof.
simpl.
intuition.

*****

*****
rec_bounded PlusOneMinus'_e
+++++
apply rec_bounded_PlusOneMinus'.
-----
Lemma rec_bounded_PlusOneMinus : rec_bounded PlusOneMinus_e.
Proof.
simpl.
intuition.

*****

*****
rec_bounded Normalize_e
+++++
apply rec_bounded_Normalize.
-----
Lemma rec_bounded_PlusOneMinus : rec_bounded PlusOneMinus_e.
Proof.
simpl.
intuition.

*****

*****

+++++
Qed.
-----
Lemma PlusOneMinus_correct : forall l,\n  bs2nat (Sem PlusOneMinus_e l) = bs2nat (hd nil l) + (1 - bs2nat (hd nil (tl l))).
-----
Lemma PlusOneMinus_correct : forall l, bs2nat (Sem PlusOneMinus_e l) = bs2nat (hd nil l) + (1 - bs2nat (hd nil (tl l))).

*****

*****
forall l : list (list bool), eq (bs2nat (Sem PlusOneMinus_e l)) (Init.Nat.add (bs2nat (hd nil l)) (Init.Nat.sub (S O) (bs2nat (hd nil (tl l)))))
+++++
Proof.
-----
Lemma PlusOneMinus_correct : forall l, bs2nat (Sem PlusOneMinus_e l) = bs2nat (hd nil l) + (1 - bs2nat (hd nil (tl l))).
Proof.

*****

*****
forall l : list (list bool), eq (bs2nat (Sem PlusOneMinus_e l)) (Init.Nat.add (bs2nat (hd nil l)) (Init.Nat.sub (S O) (bs2nat (hd nil (tl l)))))
+++++
intro l.
-----
Lemma PlusOneMinus_correct : forall l, bs2nat (Sem PlusOneMinus_e l) = bs2nat (hd nil l) + (1 - bs2nat (hd nil (tl l))).
Proof.
intro l.

*****
l : list (list bool)
*****
eq (bs2nat (Sem PlusOneMinus_e l)) (Init.Nat.add (bs2nat (hd nil l)) (Init.Nat.sub (S O) (bs2nat (hd nil (tl l)))))
+++++
simpl.
-----
Lemma PlusOneMinus_correct : forall l, bs2nat (Sem PlusOneMinus_e l) = bs2nat (hd nil l) + (1 - bs2nat (hd nil (tl l))).
Proof.
intro l.
simpl.

*****
l : list (list bool)
*****
eq (bs2nat (Sem PlusOneMinus'_e (cons (nth O l nil) (cons (Sem Normalize_e (cons (nth (S O) l nil) nil)) nil)))) (Init.Nat.add (bs2nat (hd nil l)) match bs2nat (hd nil (tl l)) with | O => S O | S _ => O end)
+++++
rewrite PlusOneMinus'_correct.
-----
Lemma PlusOneMinus_correct : forall l, bs2nat (Sem PlusOneMinus_e l) = bs2nat (hd nil l) + (1 - bs2nat (hd nil (tl l))).
Proof.
intro l.
simpl.
rewrite PlusOneMinus'_correct.

*****
l : list (list bool)
*****
eq (Init.Nat.add (bs2nat (hd nil (cons (nth O l nil) (cons (Sem Normalize_e (cons (nth (S O) l nil) nil)) nil)))) (Init.Nat.sub (S O) (bs2nat (hd nil (tl (cons (nth O l nil) (cons (Sem Normalize_e (cons (nth (S O) l nil) nil)) nil))))))) (Init.Nat.add (bs2nat (hd nil l)) match bs2nat (hd nil (tl l)) with | O => S O | S _ => O end)
+++++
simpl.
-----
Lemma PlusOneMinus_correct : forall l, bs2nat (Sem PlusOneMinus_e l) = bs2nat (hd nil l) + (1 - bs2nat (hd nil (tl l))).
Proof.
intro l.
simpl.
rewrite PlusOneMinus'_correct.
simpl.

*****
l : list (list bool)
*****
eq (Init.Nat.add (bs2nat (nth O l nil)) match bs2nat (Sem Normalize_e (cons (nth (S O) l nil) nil)) with | O => S O | S _ => O end) (Init.Nat.add (bs2nat (hd nil l)) match bs2nat (hd nil (tl l)) with | O => S O | S _ => O end)
+++++
rewrite Normalize_correct.
-----
Lemma PlusOneMinus_correct : forall l, bs2nat (Sem PlusOneMinus_e l) = bs2nat (hd nil l) + (1 - bs2nat (hd nil (tl l))).
Proof.
intro l.
simpl.
rewrite PlusOneMinus'_correct.
simpl.
rewrite Normalize_correct.

*****
l : list (list bool)
*****
eq (Init.Nat.add (bs2nat (nth O l nil)) match bs2nat (Sem (Proj (S O) O) (cons (nth (S O) l nil) nil)) with | O => S O | S _ => O end) (Init.Nat.add (bs2nat (hd nil l)) match bs2nat (hd nil (tl l)) with | O => S O | S _ => O end)
+++++
simpl.
-----
Lemma PlusOneMinus_correct : forall l, bs2nat (Sem PlusOneMinus_e l) = bs2nat (hd nil l) + (1 - bs2nat (hd nil (tl l))).
Proof.
intro l.
simpl.
rewrite PlusOneMinus'_correct.
simpl.
rewrite Normalize_correct.
simpl.

*****
l : list (list bool)
*****
eq (Init.Nat.add (bs2nat (nth O l nil)) match bs2nat (nth (S O) l nil) with | O => S O | S _ => O end) (Init.Nat.add (bs2nat (hd nil l)) match bs2nat (hd nil (tl l)) with | O => S O | S _ => O end)
+++++
rewrite hd_nth_1.
-----
Lemma PlusOneMinus_correct : forall l, bs2nat (Sem PlusOneMinus_e l) = bs2nat (hd nil l) + (1 - bs2nat (hd nil (tl l))).
Proof.
intro l.
simpl.
rewrite PlusOneMinus'_correct.
simpl.
rewrite Normalize_correct.
simpl.
rewrite hd_nth_1.

*****
l : list (list bool)
*****
eq (Init.Nat.add (bs2nat (nth O l nil)) match bs2nat (nth (S O) l nil) with | O => S O | S _ => O end) (Init.Nat.add (bs2nat (hd nil l)) match bs2nat (nth (S O) l nil) with | O => S O | S _ => O end)
+++++
rewrite hd_nth_0.
-----
Lemma PlusOneMinus_correct : forall l, bs2nat (Sem PlusOneMinus_e l) = bs2nat (hd nil l) + (1 - bs2nat (hd nil (tl l))).
Proof.
intro l.
simpl.
rewrite PlusOneMinus'_correct.
simpl.
rewrite Normalize_correct.
simpl.
rewrite hd_nth_1.
rewrite hd_nth_0.

*****
l : list (list bool)
*****
eq (Init.Nat.add (bs2nat (nth O l nil)) match bs2nat (nth (S O) l nil) with | O => S O | S _ => O end) (Init.Nat.add (bs2nat (nth O l nil)) match bs2nat (nth (S O) l nil) with | O => S O | S _ => O end)
+++++
trivial.
-----
Lemma PlusOneMinus_correct : forall l, bs2nat (Sem PlusOneMinus_e l) = bs2nat (hd nil l) + (1 - bs2nat (hd nil (tl l))).
Proof.
intro l.
simpl.
rewrite PlusOneMinus'_correct.

*****
l : list (list bool)
*****
or (eq (hd nil (tl (cons (nth O l nil) (cons (Sem Normalize_e (cons (nth (S O) l nil) nil)) nil)))) nil) (not (eq (bs2nat (hd nil (tl (cons (nth O l nil) (cons (Sem Normalize_e (cons (nth (S O) l nil) nil)) nil))))) O))
+++++
simpl.
-----
Lemma PlusOneMinus_correct : forall l, bs2nat (Sem PlusOneMinus_e l) = bs2nat (hd nil l) + (1 - bs2nat (hd nil (tl l))).
Proof.
intro l.
simpl.
rewrite PlusOneMinus'_correct.
simpl.

*****
l : list (list bool)
*****
or (eq (Sem Normalize_e (cons (nth (S O) l nil) nil)) nil) (not (eq (bs2nat (Sem Normalize_e (cons (nth (S O) l nil) nil))) O))
+++++
apply Normalize_normal.
-----
Lemma PlusOneMinus_correct : forall l, bs2nat (Sem PlusOneMinus_e l) = bs2nat (hd nil l) + (1 - bs2nat (hd nil (tl l))).
Proof.
intro l.
simpl.
rewrite PlusOneMinus'_correct.

*****

*****

+++++
Qed.
-----
Lemma PlusOneMinus_length : forall l,\n  length (Sem PlusOneMinus_e [nth 0 l nil; nth 1 l nil]) <= S (length (nth 0 l nil)).
-----
Lemma PlusOneMinus_length : forall l, length (Sem PlusOneMinus_e [nth 0 l nil; nth 1 l nil]) <= S (length (nth 0 l nil)).

*****

*****
forall l : list (list bool), le (length (Sem PlusOneMinus_e (cons (nth O l nil) (cons (nth (S O) l nil) nil)))) (S (length (nth O l nil)))
+++++
Proof.
-----
Lemma PlusOneMinus_length : forall l, length (Sem PlusOneMinus_e [nth 0 l nil; nth 1 l nil]) <= S (length (nth 0 l nil)).
Proof.

*****

*****
forall l : list (list bool), le (length (Sem PlusOneMinus_e (cons (nth O l nil) (cons (nth (S O) l nil) nil)))) (S (length (nth O l nil)))
+++++
intros.
-----
Lemma PlusOneMinus_length : forall l, length (Sem PlusOneMinus_e [nth 0 l nil; nth 1 l nil]) <= S (length (nth 0 l nil)).
Proof.
intros.

*****
l : list (list bool)
*****
le (length (Sem PlusOneMinus_e (cons (nth O l nil) (cons (nth (S O) l nil) nil)))) (S (length (nth O l nil)))
+++++
simpl.
-----
Lemma PlusOneMinus_length : forall l, length (Sem PlusOneMinus_e [nth 0 l nil; nth 1 l nil]) <= S (length (nth 0 l nil)).
Proof.
intros.
simpl.

*****
l : list (list bool)
*****
le (length (Sem PlusOneMinus'_e (cons (nth O l nil) (cons (Sem Normalize_e (cons (nth (S O) l nil) nil)) nil)))) (S (length (nth O l nil)))
+++++
rewrite <- hd_nth_0 at 2.
-----
Lemma PlusOneMinus_length : forall l, length (Sem PlusOneMinus_e [nth 0 l nil; nth 1 l nil]) <= S (length (nth 0 l nil)).
Proof.
intros.
simpl.
rewrite <- hd_nth_0 at 2.

*****
l : list (list bool)
*****
le (length (Sem PlusOneMinus'_e (cons (nth O l nil) (cons (Sem Normalize_e (cons (nth (S O) l nil) nil)) nil)))) (S (length (hd nil l)))
+++++
apply PlusOneMinus'_length.
-----
Lemma PlusOneMinus_length : forall l, length (Sem PlusOneMinus_e [nth 0 l nil; nth 1 l nil]) <= S (length (nth 0 l nil)).
Proof.
intros.
simpl.
rewrite <- hd_nth_0 at 2.
apply PlusOneMinus'_length.

*****

*****

+++++
Qed.
-----
Opaque PlusOneMinus_e.
-----
Definition OneMinusMultPlus'_e : Cobham :=\n  Rec\n    (Proj 1 0)\n    (Comp 3 (Succ false) [Proj 3 0])\n    (Comp 3 (Succ true) [Proj 3 0])\n    (Comp 2 Smash [Comp 2 Succ_e [Proj 2 1]; Comp 2 (Succ true) [Proj 2 0]]).
-----
Lemma arity_OneMinusMultPlus' : arity OneMinusMultPlus'_e = ok_arity 2.
-----
Lemma arity_OneMinusMultPlus' : arity OneMinusMultPlus'_e = ok_arity 2.

*****

*****
eq (arity OneMinusMultPlus'_e) (ok_arity (S (S O)))
+++++
Proof.
-----
Lemma arity_OneMinusMultPlus' : arity OneMinusMultPlus'_e = ok_arity 2.
Proof.

*****

*****
eq (arity OneMinusMultPlus'_e) (ok_arity (S (S O)))
+++++
trivial.
-----
Lemma arity_OneMinusMultPlus' : arity OneMinusMultPlus'_e = ok_arity 2.
Proof.
trivial.

*****

*****

+++++
Qed.
-----
Lemma rec_bounded_OneMinusMultPlus' :\n  rec_bounded OneMinusMultPlus'_e.
-----
Lemma rec_bounded_OneMinusMultPlus' : rec_bounded OneMinusMultPlus'_e.

*****

*****
rec_bounded OneMinusMultPlus'_e
+++++
Proof.
-----
Lemma rec_bounded_OneMinusMultPlus' : rec_bounded OneMinusMultPlus'_e.
Proof.

*****

*****
rec_bounded OneMinusMultPlus'_e
+++++
simpl.
-----
Lemma rec_bounded_OneMinusMultPlus' : rec_bounded OneMinusMultPlus'_e.
Proof.
simpl.

*****

*****
and (and True (and (and (rec_bounded Succ_e) (and True True)) (and (and True (and True True)) True))) (and True (and (and True (and True True)) (and (and True (and True True)) (forall l : list (list bool), le (length (sem_Rec (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => cons false (nth O vl nil)) (fun vl : list (list bool) => cons true (nth O vl nil)) (hd nil l) (tl l))) (length (smash_bs (Sem Succ_e (cons (nth (S O) l nil) nil)) (cons true (nth O l nil))))))))
+++++
intuition.
-----
Lemma rec_bounded_OneMinusMultPlus' : rec_bounded OneMinusMultPlus'_e.
Proof.
simpl.
intuition.

*****

*****
rec_bounded Succ_e
+++++
apply rec_bounded_Succ.
-----
Lemma rec_bounded_OneMinusMultPlus' : rec_bounded OneMinusMultPlus'_e.
Proof.
simpl.
intuition.
apply rec_bounded_Succ.

*****
l : list (list bool)
*****
le (length (sem_Rec (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => cons false (nth O vl nil)) (fun vl : list (list bool) => cons true (nth O vl nil)) (hd nil l) (tl l))) (length (smash_bs (Sem Succ_e (cons (nth (S O) l nil) nil)) (cons true (nth O l nil))))
+++++
destruct l as [ | v l].
-----
Lemma rec_bounded_OneMinusMultPlus' : rec_bounded OneMinusMultPlus'_e.
Proof.
simpl.
intuition.
apply rec_bounded_Succ.
destruct l as [ | v l].

*****

*****
le (length (sem_Rec (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => cons false (nth O vl nil)) (fun vl : list (list bool) => cons true (nth O vl nil)) (hd nil nil) (tl nil))) (length (smash_bs (Sem Succ_e (cons (nth (S O) nil nil) nil)) (cons true (nth O nil nil))))
+++++
simpl; omega.
-----
Lemma rec_bounded_OneMinusMultPlus' : rec_bounded OneMinusMultPlus'_e.
Proof.
simpl.
intuition.
apply rec_bounded_Succ.
destruct l as [ | v l].
simpl; omega.

*****
l : list (list bool)
v : list bool
*****
le (length (sem_Rec (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => cons false (nth O vl nil)) (fun vl : list (list bool) => cons true (nth O vl nil)) (hd nil (cons v l)) (tl (cons v l)))) (length (smash_bs (Sem Succ_e (cons (nth (S O) (cons v l) nil) nil)) (cons true (nth O (cons v l) nil))))
+++++
simpl.
-----
Lemma rec_bounded_OneMinusMultPlus' : rec_bounded OneMinusMultPlus'_e.
Proof.
simpl.
intuition.
apply rec_bounded_Succ.
destruct l as [ | v l].
simpl; omega.
simpl.

*****
l : list (list bool)
v : list bool
*****
le (length (sem_Rec (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => cons false (nth O vl nil)) (fun vl : list (list bool) => cons true (nth O vl nil)) v l)) (length (smash_bs (Sem Succ_e (cons (nth O l nil) nil)) (cons true v)))
+++++
induction v as [ | [ | ] v IH]; simpl.
-----
Lemma rec_bounded_OneMinusMultPlus' : rec_bounded OneMinusMultPlus'_e.
Proof.
simpl.
intuition.
apply rec_bounded_Succ.
destruct l as [ | v l].
simpl; omega.
simpl.
induction v as [ | [ | ] v IH]; simpl.

*****
l : list (list bool)
*****
le (length (nth O l nil)) (length (smash_bs (Sem Succ_e (cons (nth O l nil) nil)) (cons true nil)))
+++++
rewrite length_smash.
-----
Lemma rec_bounded_OneMinusMultPlus' : rec_bounded OneMinusMultPlus'_e.
Proof.
simpl.
intuition.
apply rec_bounded_Succ.
destruct l as [ | v l].
simpl; omega.
simpl.
induction v as [ | [ | ] v IH]; simpl.
rewrite length_smash.

*****
l : list (list bool)
*****
le (length (nth O l nil)) (Init.Nat.add (S O) (Init.Nat.mul (length (Sem Succ_e (cons (nth O l nil) nil))) (length (cons true nil))))
+++++
simpl.
-----
Lemma rec_bounded_OneMinusMultPlus' : rec_bounded OneMinusMultPlus'_e.
Proof.
simpl.
intuition.
apply rec_bounded_Succ.
destruct l as [ | v l].
simpl; omega.
simpl.
induction v as [ | [ | ] v IH]; simpl.
rewrite length_smash.
simpl.

*****
l : list (list bool)
*****
le (length (nth O l nil)) (S (Init.Nat.mul (length (Sem Succ_e (cons (nth O l nil) nil))) (S O)))
+++++
rewrite mult_1_r.
-----
Lemma rec_bounded_OneMinusMultPlus' : rec_bounded OneMinusMultPlus'_e.
Proof.
simpl.
intuition.
apply rec_bounded_Succ.
destruct l as [ | v l].
simpl; omega.
simpl.
induction v as [ | [ | ] v IH]; simpl.
rewrite length_smash.
simpl.
rewrite mult_1_r.

*****
l : list (list bool)
*****
le (length (nth O l nil)) (S (length (Sem Succ_e (cons (nth O l nil) nil))))
+++++
eapply le_trans; [idtac | apply le_n_S; apply le_length_Succ].
-----
Lemma rec_bounded_OneMinusMultPlus' : rec_bounded OneMinusMultPlus'_e.
Proof.
simpl.
intuition.
apply rec_bounded_Succ.
destruct l as [ | v l].
simpl; omega.
simpl.
induction v as [ | [ | ] v IH]; simpl.
rewrite length_smash.
simpl.
rewrite mult_1_r.
eapply le_trans; [idtac | apply le_n_S; apply le_length_Succ].

*****
l : list (list bool)
*****
le (length (nth O l nil)) (S (length (nth O l nil)))
+++++
omega.
-----
Lemma rec_bounded_OneMinusMultPlus' : rec_bounded OneMinusMultPlus'_e.
Proof.
simpl.
intuition.
apply rec_bounded_Succ.
destruct l as [ | v l].
simpl; omega.
simpl.
induction v as [ | [ | ] v IH]; simpl.
rewrite length_smash.
simpl.
rewrite mult_1_r.
eapply le_trans; [idtac | apply le_n_S; apply le_length_Succ].
omega.

*****
IH : le\n (length\n (sem_Rec (fun vl : list (list bool) => nth O vl nil)\n (fun vl : list (list bool) => cons false (nth O vl nil))\n (fun vl : list (list bool) => cons true (nth O vl nil)) v l))\n (length\n (smash_bs (Sem Succ_e (cons (nth O l nil) nil)) (cons true v)))
l : list (list bool)
v : list bool
*****
le (S (length v)) (length (smash_bs (Sem Succ_e (cons (nth O l nil) nil)) (cons true (cons true v))))
+++++
rewrite length_smash.
-----
Lemma rec_bounded_OneMinusMultPlus' : rec_bounded OneMinusMultPlus'_e.
Proof.
simpl.
intuition.
apply rec_bounded_Succ.
destruct l as [ | v l].
simpl; omega.
simpl.
induction v as [ | [ | ] v IH]; simpl.
rewrite length_smash.
simpl.
rewrite mult_1_r.
eapply le_trans; [idtac | apply le_n_S; apply le_length_Succ].
omega.
rewrite length_smash.

*****
IH : le\n (length\n (sem_Rec (fun vl : list (list bool) => nth O vl nil)\n (fun vl : list (list bool) => cons false (nth O vl nil))\n (fun vl : list (list bool) => cons true (nth O vl nil)) v l))\n (length\n (smash_bs (Sem Succ_e (cons (nth O l nil) nil)) (cons true v)))
l : list (list bool)
v : list bool
*****
le (S (length v)) (Init.Nat.add (S O) (Init.Nat.mul (length (Sem Succ_e (cons (nth O l nil) nil))) (length (cons true (cons true v)))))
+++++
simpl.
-----
Lemma rec_bounded_OneMinusMultPlus' : rec_bounded OneMinusMultPlus'_e.
Proof.
simpl.
intuition.
apply rec_bounded_Succ.
destruct l as [ | v l].
simpl; omega.
simpl.
induction v as [ | [ | ] v IH]; simpl.
rewrite length_smash.
simpl.
rewrite mult_1_r.
eapply le_trans; [idtac | apply le_n_S; apply le_length_Succ].
omega.
rewrite length_smash.
simpl.

*****
IH : le\n (length\n (sem_Rec (fun vl : list (list bool) => nth O vl nil)\n (fun vl : list (list bool) => cons false (nth O vl nil))\n (fun vl : list (list bool) => cons true (nth O vl nil)) v l))\n (length\n (smash_bs (Sem Succ_e (cons (nth O l nil) nil)) (cons true v)))
l : list (list bool)
v : list bool
*****
le (S (length v)) (S (Init.Nat.mul (length (Sem Succ_e (cons (nth O l nil) nil))) (S (S (length v)))))
+++++
apply le_n_S.
-----
Lemma rec_bounded_OneMinusMultPlus' : rec_bounded OneMinusMultPlus'_e.
Proof.
simpl.
intuition.
apply rec_bounded_Succ.
destruct l as [ | v l].
simpl; omega.
simpl.
induction v as [ | [ | ] v IH]; simpl.
rewrite length_smash.
simpl.
rewrite mult_1_r.
eapply le_trans; [idtac | apply le_n_S; apply le_length_Succ].
omega.
rewrite length_smash.
simpl.
apply le_n_S.

*****
IH : le\n (length\n (sem_Rec (fun vl : list (list bool) => nth O vl nil)\n (fun vl : list (list bool) => cons false (nth O vl nil))\n (fun vl : list (list bool) => cons true (nth O vl nil)) v l))\n (length\n (smash_bs (Sem Succ_e (cons (nth O l nil) nil)) (cons true v)))
l : list (list bool)
v : list bool
*****
le (length v) (Init.Nat.mul (length (Sem Succ_e (cons (nth O l nil) nil))) (S (S (length v))))
+++++
rewrite <- (mult_1_l (length v)).
-----
Lemma rec_bounded_OneMinusMultPlus' : rec_bounded OneMinusMultPlus'_e.
Proof.
simpl.
intuition.
apply rec_bounded_Succ.
destruct l as [ | v l].
simpl; omega.
simpl.
induction v as [ | [ | ] v IH]; simpl.
rewrite length_smash.
simpl.
rewrite mult_1_r.
eapply le_trans; [idtac | apply le_n_S; apply le_length_Succ].
omega.
rewrite length_smash.
simpl.
apply le_n_S.
rewrite <- (mult_1_l (length v)).

*****
IH : le\n (length\n (sem_Rec (fun vl : list (list bool) => nth O vl nil)\n (fun vl : list (list bool) => cons false (nth O vl nil))\n (fun vl : list (list bool) => cons true (nth O vl nil)) v l))\n (length\n (smash_bs (Sem Succ_e (cons (nth O l nil) nil)) (cons true v)))
l : list (list bool)
v : list bool
*****
le (Nat.mul (S O) (length v)) (Init.Nat.mul (length (Sem Succ_e (cons (nth O l nil) nil))) (S (S (Nat.mul (S O) (length v)))))
+++++
apply mult_le_compat.
-----
Lemma rec_bounded_OneMinusMultPlus' : rec_bounded OneMinusMultPlus'_e.
Proof.
simpl.
intuition.
apply rec_bounded_Succ.
destruct l as [ | v l].
simpl; omega.
simpl.
induction v as [ | [ | ] v IH]; simpl.
rewrite length_smash.
simpl.
rewrite mult_1_r.
eapply le_trans; [idtac | apply le_n_S; apply le_length_Succ].
omega.
rewrite length_smash.
simpl.
apply le_n_S.
rewrite <- (mult_1_l (length v)).
apply mult_le_compat.

*****
IH : le\n (length\n (sem_Rec (fun vl : list (list bool) => nth O vl nil)\n (fun vl : list (list bool) => cons false (nth O vl nil))\n (fun vl : list (list bool) => cons true (nth O vl nil)) v l))\n (length\n (smash_bs (Sem Succ_e (cons (nth O l nil) nil)) (cons true v)))
l : list (list bool)
v : list bool
*****
le (S O) (length (Sem Succ_e (cons (nth O l nil) nil)))
+++++
apply le_1_length_Succ.
-----
Lemma rec_bounded_OneMinusMultPlus' : rec_bounded OneMinusMultPlus'_e.
Proof.
simpl.
intuition.
apply rec_bounded_Succ.
destruct l as [ | v l].
simpl; omega.
simpl.
induction v as [ | [ | ] v IH]; simpl.
rewrite length_smash.
simpl.
rewrite mult_1_r.
eapply le_trans; [idtac | apply le_n_S; apply le_length_Succ].
omega.
rewrite length_smash.
simpl.
apply le_n_S.
rewrite <- (mult_1_l (length v)).
apply mult_le_compat.
apply le_1_length_Succ.

*****
IH : le\n (length\n (sem_Rec (fun vl : list (list bool) => nth O vl nil)\n (fun vl : list (list bool) => cons false (nth O vl nil))\n (fun vl : list (list bool) => cons true (nth O vl nil)) v l))\n (length\n (smash_bs (Sem Succ_e (cons (nth O l nil) nil)) (cons true v)))
l : list (list bool)
v : list bool
*****
le (length v) (S (S (Nat.mul (S O) (length v))))
+++++
omega.
-----
Lemma rec_bounded_OneMinusMultPlus' : rec_bounded OneMinusMultPlus'_e.
Proof.
simpl.
intuition.
apply rec_bounded_Succ.
destruct l as [ | v l].
simpl; omega.
simpl.
induction v as [ | [ | ] v IH]; simpl.
rewrite length_smash.
simpl.
rewrite mult_1_r.
eapply le_trans; [idtac | apply le_n_S; apply le_length_Succ].
omega.
rewrite length_smash.
simpl.
apply le_n_S.
rewrite <- (mult_1_l (length v)).
apply mult_le_compat.
apply le_1_length_Succ.
omega.

*****
IH : le\n (length\n (sem_Rec (fun vl : list (list bool) => nth O vl nil)\n (fun vl : list (list bool) => cons false (nth O vl nil))\n (fun vl : list (list bool) => cons true (nth O vl nil)) v l))\n (length\n (smash_bs (Sem Succ_e (cons (nth O l nil) nil)) (cons true v)))
l : list (list bool)
v : list bool
*****
le (S (length v)) (length (smash_bs (Sem Succ_e (cons (nth O l nil) nil)) (cons true (cons false v))))
+++++
rewrite length_smash.
-----
Lemma rec_bounded_OneMinusMultPlus' : rec_bounded OneMinusMultPlus'_e.
Proof.
simpl.
intuition.
apply rec_bounded_Succ.
destruct l as [ | v l].
simpl; omega.
simpl.
induction v as [ | [ | ] v IH]; simpl.
rewrite length_smash.
simpl.
rewrite mult_1_r.
eapply le_trans; [idtac | apply le_n_S; apply le_length_Succ].
omega.
rewrite length_smash.
simpl.
apply le_n_S.
rewrite <- (mult_1_l (length v)).
apply mult_le_compat.
apply le_1_length_Succ.
omega.
rewrite length_smash.

*****
IH : le\n (length\n (sem_Rec (fun vl : list (list bool) => nth O vl nil)\n (fun vl : list (list bool) => cons false (nth O vl nil))\n (fun vl : list (list bool) => cons true (nth O vl nil)) v l))\n (length\n (smash_bs (Sem Succ_e (cons (nth O l nil) nil)) (cons true v)))
l : list (list bool)
v : list bool
*****
le (S (length v)) (Init.Nat.add (S O) (Init.Nat.mul (length (Sem Succ_e (cons (nth O l nil) nil))) (length (cons true (cons false v)))))
+++++
simpl.
-----
Lemma rec_bounded_OneMinusMultPlus' : rec_bounded OneMinusMultPlus'_e.
Proof.
simpl.
intuition.
apply rec_bounded_Succ.
destruct l as [ | v l].
simpl; omega.
simpl.
induction v as [ | [ | ] v IH]; simpl.
rewrite length_smash.
simpl.
rewrite mult_1_r.
eapply le_trans; [idtac | apply le_n_S; apply le_length_Succ].
omega.
rewrite length_smash.
simpl.
apply le_n_S.
rewrite <- (mult_1_l (length v)).
apply mult_le_compat.
apply le_1_length_Succ.
omega.
rewrite length_smash.
simpl.

*****
IH : le\n (length\n (sem_Rec (fun vl : list (list bool) => nth O vl nil)\n (fun vl : list (list bool) => cons false (nth O vl nil))\n (fun vl : list (list bool) => cons true (nth O vl nil)) v l))\n (length\n (smash_bs (Sem Succ_e (cons (nth O l nil) nil)) (cons true v)))
l : list (list bool)
v : list bool
*****
le (S (length v)) (S (Init.Nat.mul (length (Sem Succ_e (cons (nth O l nil) nil))) (S (S (length v)))))
+++++
apply le_n_S.
-----
Lemma rec_bounded_OneMinusMultPlus' : rec_bounded OneMinusMultPlus'_e.
Proof.
simpl.
intuition.
apply rec_bounded_Succ.
destruct l as [ | v l].
simpl; omega.
simpl.
induction v as [ | [ | ] v IH]; simpl.
rewrite length_smash.
simpl.
rewrite mult_1_r.
eapply le_trans; [idtac | apply le_n_S; apply le_length_Succ].
omega.
rewrite length_smash.
simpl.
apply le_n_S.
rewrite <- (mult_1_l (length v)).
apply mult_le_compat.
apply le_1_length_Succ.
omega.
rewrite length_smash.
simpl.
apply le_n_S.

*****
IH : le\n (length\n (sem_Rec (fun vl : list (list bool) => nth O vl nil)\n (fun vl : list (list bool) => cons false (nth O vl nil))\n (fun vl : list (list bool) => cons true (nth O vl nil)) v l))\n (length\n (smash_bs (Sem Succ_e (cons (nth O l nil) nil)) (cons true v)))
l : list (list bool)
v : list bool
*****
le (length v) (Init.Nat.mul (length (Sem Succ_e (cons (nth O l nil) nil))) (S (S (length v))))
+++++
rewrite <- (mult_1_l (length v)).
-----
Lemma rec_bounded_OneMinusMultPlus' : rec_bounded OneMinusMultPlus'_e.
Proof.
simpl.
intuition.
apply rec_bounded_Succ.
destruct l as [ | v l].
simpl; omega.
simpl.
induction v as [ | [ | ] v IH]; simpl.
rewrite length_smash.
simpl.
rewrite mult_1_r.
eapply le_trans; [idtac | apply le_n_S; apply le_length_Succ].
omega.
rewrite length_smash.
simpl.
apply le_n_S.
rewrite <- (mult_1_l (length v)).
apply mult_le_compat.
apply le_1_length_Succ.
omega.
rewrite length_smash.
simpl.
apply le_n_S.
rewrite <- (mult_1_l (length v)).

*****
IH : le\n (length\n (sem_Rec (fun vl : list (list bool) => nth O vl nil)\n (fun vl : list (list bool) => cons false (nth O vl nil))\n (fun vl : list (list bool) => cons true (nth O vl nil)) v l))\n (length\n (smash_bs (Sem Succ_e (cons (nth O l nil) nil)) (cons true v)))
l : list (list bool)
v : list bool
*****
le (Nat.mul (S O) (length v)) (Init.Nat.mul (length (Sem Succ_e (cons (nth O l nil) nil))) (S (S (Nat.mul (S O) (length v)))))
+++++
apply mult_le_compat.
-----
Lemma rec_bounded_OneMinusMultPlus' : rec_bounded OneMinusMultPlus'_e.
Proof.
simpl.
intuition.
apply rec_bounded_Succ.
destruct l as [ | v l].
simpl; omega.
simpl.
induction v as [ | [ | ] v IH]; simpl.
rewrite length_smash.
simpl.
rewrite mult_1_r.
eapply le_trans; [idtac | apply le_n_S; apply le_length_Succ].
omega.
rewrite length_smash.
simpl.
apply le_n_S.
rewrite <- (mult_1_l (length v)).
apply mult_le_compat.
apply le_1_length_Succ.
omega.
rewrite length_smash.
simpl.
apply le_n_S.
rewrite <- (mult_1_l (length v)).
apply mult_le_compat.

*****
IH : le\n (length\n (sem_Rec (fun vl : list (list bool) => nth O vl nil)\n (fun vl : list (list bool) => cons false (nth O vl nil))\n (fun vl : list (list bool) => cons true (nth O vl nil)) v l))\n (length\n (smash_bs (Sem Succ_e (cons (nth O l nil) nil)) (cons true v)))
l : list (list bool)
v : list bool
*****
le (S O) (length (Sem Succ_e (cons (nth O l nil) nil)))
+++++
apply le_1_length_Succ.
-----
Lemma rec_bounded_OneMinusMultPlus' : rec_bounded OneMinusMultPlus'_e.
Proof.
simpl.
intuition.
apply rec_bounded_Succ.
destruct l as [ | v l].
simpl; omega.
simpl.
induction v as [ | [ | ] v IH]; simpl.
rewrite length_smash.
simpl.
rewrite mult_1_r.
eapply le_trans; [idtac | apply le_n_S; apply le_length_Succ].
omega.
rewrite length_smash.
simpl.
apply le_n_S.
rewrite <- (mult_1_l (length v)).
apply mult_le_compat.
apply le_1_length_Succ.
omega.
rewrite length_smash.
simpl.
apply le_n_S.
rewrite <- (mult_1_l (length v)).
apply mult_le_compat.
apply le_1_length_Succ.

*****
IH : le\n (length\n (sem_Rec (fun vl : list (list bool) => nth O vl nil)\n (fun vl : list (list bool) => cons false (nth O vl nil))\n (fun vl : list (list bool) => cons true (nth O vl nil)) v l))\n (length\n (smash_bs (Sem Succ_e (cons (nth O l nil) nil)) (cons true v)))
l : list (list bool)
v : list bool
*****
le (length v) (S (S (Nat.mul (S O) (length v))))
+++++
omega.
-----
Lemma rec_bounded_OneMinusMultPlus' : rec_bounded OneMinusMultPlus'_e.
Proof.
simpl.
intuition.
apply rec_bounded_Succ.
destruct l as [ | v l].
simpl; omega.
simpl.
induction v as [ | [ | ] v IH]; simpl.
rewrite length_smash.
simpl.
rewrite mult_1_r.
eapply le_trans; [idtac | apply le_n_S; apply le_length_Succ].
omega.
rewrite length_smash.
simpl.
apply le_n_S.
rewrite <- (mult_1_l (length v)).
apply mult_le_compat.
apply le_1_length_Succ.
omega.
rewrite length_smash.
simpl.
apply le_n_S.
rewrite <- (mult_1_l (length v)).
apply mult_le_compat.
apply le_1_length_Succ.
omega.

*****

*****

+++++
Qed.
-----
Lemma OneMinusMultPlus'_correct : forall l,\n  hd nil l = nil \/ bs2nat (hd nil l) <> 0 ->\n  bs2nat (Sem OneMinusMultPlus'_e l) =\n  (1 - bs2nat (hd nil l)) * bs2nat (hd nil (tl l)) +\n  bs2nat (hd nil l) * (1 - (1 - bs2nat (hd nil l))).
-----
Lemma OneMinusMultPlus'_correct : forall l, hd nil l = nil \\/ bs2nat (hd nil l) <> 0 -> bs2nat (Sem OneMinusMultPlus'_e l) = (1 - bs2nat (hd nil l)) * bs2nat (hd nil (tl l)) + bs2nat (hd nil l) * (1 - (1 - bs2nat (hd nil l))).

*****

*****
forall (l : list (list bool)) (_ : or (eq (hd nil l) nil) (not (eq (bs2nat (hd nil l)) O))), eq (bs2nat (Sem OneMinusMultPlus'_e l)) (Init.Nat.add (Init.Nat.mul (Init.Nat.sub (S O) (bs2nat (hd nil l))) (bs2nat (hd nil (tl l)))) (Init.Nat.mul (bs2nat (hd nil l)) (Init.Nat.sub (S O) (Init.Nat.sub (S O) (bs2nat (hd nil l))))))
+++++
Proof.
-----
Lemma OneMinusMultPlus'_correct : forall l, hd nil l = nil \\/ bs2nat (hd nil l) <> 0 -> bs2nat (Sem OneMinusMultPlus'_e l) = (1 - bs2nat (hd nil l)) * bs2nat (hd nil (tl l)) + bs2nat (hd nil l) * (1 - (1 - bs2nat (hd nil l))).
Proof.

*****

*****
forall (l : list (list bool)) (_ : or (eq (hd nil l) nil) (not (eq (bs2nat (hd nil l)) O))), eq (bs2nat (Sem OneMinusMultPlus'_e l)) (Init.Nat.add (Init.Nat.mul (Init.Nat.sub (S O) (bs2nat (hd nil l))) (bs2nat (hd nil (tl l)))) (Init.Nat.mul (bs2nat (hd nil l)) (Init.Nat.sub (S O) (Init.Nat.sub (S O) (bs2nat (hd nil l))))))
+++++
intros [ | v l] H.
-----
Lemma OneMinusMultPlus'_correct : forall l, hd nil l = nil \\/ bs2nat (hd nil l) <> 0 -> bs2nat (Sem OneMinusMultPlus'_e l) = (1 - bs2nat (hd nil l)) * bs2nat (hd nil (tl l)) + bs2nat (hd nil l) * (1 - (1 - bs2nat (hd nil l))).
Proof.
intros [ | v l] H.

*****
H : or (eq (hd nil nil) nil) (not (eq (bs2nat (hd nil nil)) O))
*****
eq (bs2nat (Sem OneMinusMultPlus'_e nil)) (Init.Nat.add (Init.Nat.mul (Init.Nat.sub (S O) (bs2nat (hd nil nil))) (bs2nat (hd nil (tl nil)))) (Init.Nat.mul (bs2nat (hd nil nil)) (Init.Nat.sub (S O) (Init.Nat.sub (S O) (bs2nat (hd nil nil))))))
+++++
trivial.
-----
Lemma OneMinusMultPlus'_correct : forall l, hd nil l = nil \\/ bs2nat (hd nil l) <> 0 -> bs2nat (Sem OneMinusMultPlus'_e l) = (1 - bs2nat (hd nil l)) * bs2nat (hd nil (tl l)) + bs2nat (hd nil l) * (1 - (1 - bs2nat (hd nil l))).
Proof.
intros [ | v l] H.

*****
H : or (eq (hd nil (cons v l)) nil)\n (not (eq (bs2nat (hd nil (cons v l))) O))
l : list (list bool)
v : list bool
*****
eq (bs2nat (Sem OneMinusMultPlus'_e (cons v l))) (Init.Nat.add (Init.Nat.mul (Init.Nat.sub (S O) (bs2nat (hd nil (cons v l)))) (bs2nat (hd nil (tl (cons v l))))) (Init.Nat.mul (bs2nat (hd nil (cons v l))) (Init.Nat.sub (S O) (Init.Nat.sub (S O) (bs2nat (hd nil (cons v l)))))))
+++++
simpl.
-----
Lemma OneMinusMultPlus'_correct : forall l, hd nil l = nil \\/ bs2nat (hd nil l) <> 0 -> bs2nat (Sem OneMinusMultPlus'_e l) = (1 - bs2nat (hd nil l)) * bs2nat (hd nil (tl l)) + bs2nat (hd nil l) * (1 - (1 - bs2nat (hd nil l))).
Proof.
intros [ | v l] H.
simpl.

*****
H : or (eq (hd nil (cons v l)) nil)\n (not (eq (bs2nat (hd nil (cons v l))) O))
l : list (list bool)
v : list bool
*****
eq (bs2nat (sem_Rec (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => cons false (nth O vl nil)) (fun vl : list (list bool) => cons true (nth O vl nil)) v l)) (Init.Nat.add (Init.Nat.mul match bs2nat v with | O => S O | S _ => O end (bs2nat (hd nil l))) (Init.Nat.mul (bs2nat v) match match bs2nat v with | O => S O | S _ => O end with | O => S O | S _ => O end))
+++++
destruct v as [ | [ | ] v].
-----
Lemma OneMinusMultPlus'_correct : forall l, hd nil l = nil \\/ bs2nat (hd nil l) <> 0 -> bs2nat (Sem OneMinusMultPlus'_e l) = (1 - bs2nat (hd nil l)) * bs2nat (hd nil (tl l)) + bs2nat (hd nil l) * (1 - (1 - bs2nat (hd nil l))).
Proof.
intros [ | v l] H.
simpl.
destruct v as [ | [ | ] v].

*****
H : or (eq (hd nil (cons nil l)) nil)\n (not (eq (bs2nat (hd nil (cons nil l))) O))
l : list (list bool)
*****
eq (bs2nat (sem_Rec (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => cons false (nth O vl nil)) (fun vl : list (list bool) => cons true (nth O vl nil)) nil l)) (Init.Nat.add (Init.Nat.mul match bs2nat nil with | O => S O | S _ => O end (bs2nat (hd nil l))) (Init.Nat.mul (bs2nat nil) match match bs2nat nil with | O => S O | S _ => O end with | O => S O | S _ => O end))
+++++
simpl.
-----
Lemma OneMinusMultPlus'_correct : forall l, hd nil l = nil \\/ bs2nat (hd nil l) <> 0 -> bs2nat (Sem OneMinusMultPlus'_e l) = (1 - bs2nat (hd nil l)) * bs2nat (hd nil (tl l)) + bs2nat (hd nil l) * (1 - (1 - bs2nat (hd nil l))).
Proof.
intros [ | v l] H.
simpl.
destruct v as [ | [ | ] v].
simpl.

*****
H : or (eq (hd nil (cons nil l)) nil)\n (not (eq (bs2nat (hd nil (cons nil l))) O))
l : list (list bool)
*****
eq (bs2nat (nth O l nil)) (Init.Nat.add (Init.Nat.mul match bs2nat nil with | O => S O | S _ => O end (bs2nat (hd nil l))) (Init.Nat.mul (bs2nat nil) match match bs2nat nil with | O => S O | S _ => O end with | O => S O | S _ => O end))
+++++
rewrite bs2nat_nil.
-----
Lemma OneMinusMultPlus'_correct : forall l, hd nil l = nil \\/ bs2nat (hd nil l) <> 0 -> bs2nat (Sem OneMinusMultPlus'_e l) = (1 - bs2nat (hd nil l)) * bs2nat (hd nil (tl l)) + bs2nat (hd nil l) * (1 - (1 - bs2nat (hd nil l))).
Proof.
intros [ | v l] H.
simpl.
destruct v as [ | [ | ] v].
simpl.
rewrite bs2nat_nil.

*****
H : or (eq (hd nil (cons nil l)) nil)\n (not (eq (bs2nat (hd nil (cons nil l))) O))
l : list (list bool)
*****
eq (bs2nat (nth O l nil)) (Init.Nat.add (Init.Nat.mul (S O) (bs2nat (hd nil l))) (Init.Nat.mul O O))
+++++
rewrite hd_nth_0.
-----
Lemma OneMinusMultPlus'_correct : forall l, hd nil l = nil \\/ bs2nat (hd nil l) <> 0 -> bs2nat (Sem OneMinusMultPlus'_e l) = (1 - bs2nat (hd nil l)) * bs2nat (hd nil (tl l)) + bs2nat (hd nil l) * (1 - (1 - bs2nat (hd nil l))).
Proof.
intros [ | v l] H.
simpl.
destruct v as [ | [ | ] v].
simpl.
rewrite bs2nat_nil.
rewrite hd_nth_0.

*****
H : or (eq (hd nil (cons nil l)) nil)\n (not (eq (bs2nat (hd nil (cons nil l))) O))
l : list (list bool)
*****
eq (bs2nat (nth O l nil)) (Init.Nat.add (Init.Nat.mul (S O) (bs2nat (nth O l nil))) (Init.Nat.mul O O))
+++++
ring.
-----
Lemma OneMinusMultPlus'_correct : forall l, hd nil l = nil \\/ bs2nat (hd nil l) <> 0 -> bs2nat (Sem OneMinusMultPlus'_e l) = (1 - bs2nat (hd nil l)) * bs2nat (hd nil (tl l)) + bs2nat (hd nil l) * (1 - (1 - bs2nat (hd nil l))).
Proof.
intros [ | v l] H.
simpl.
destruct v as [ | [ | ] v].

*****
H : or (eq (hd nil (cons (cons true v) l)) nil)\n (not (eq (bs2nat (hd nil (cons (cons true v) l))) O))
l : list (list bool)
v : list bool
*****
eq (bs2nat (sem_Rec (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => cons false (nth O vl nil)) (fun vl : list (list bool) => cons true (nth O vl nil)) (cons true v) l)) (Init.Nat.add (Init.Nat.mul match bs2nat (cons true v) with | O => S O | S _ => O end (bs2nat (hd nil l))) (Init.Nat.mul (bs2nat (cons true v)) match match bs2nat (cons true v) with | O => S O | S _ => O end with | O => S O | S _ => O end))
+++++
simpl.
-----
Lemma OneMinusMultPlus'_correct : forall l, hd nil l = nil \\/ bs2nat (hd nil l) <> 0 -> bs2nat (Sem OneMinusMultPlus'_e l) = (1 - bs2nat (hd nil l)) * bs2nat (hd nil (tl l)) + bs2nat (hd nil l) * (1 - (1 - bs2nat (hd nil l))).
Proof.
intros [ | v l] H.
simpl.
destruct v as [ | [ | ] v].
simpl.

*****
H : or (eq (hd nil (cons (cons true v) l)) nil)\n (not (eq (bs2nat (hd nil (cons (cons true v) l))) O))
l : list (list bool)
v : list bool
*****
eq (bs2nat (cons true v)) (Init.Nat.add (Init.Nat.mul match bs2nat (cons true v) with | O => S O | S _ => O end (bs2nat (hd nil l))) (Init.Nat.mul (bs2nat (cons true v)) match match bs2nat (cons true v) with | O => S O | S _ => O end with | O => S O | S _ => O end))
+++++
rewrite bs2nat_true.
-----
Lemma OneMinusMultPlus'_correct : forall l, hd nil l = nil \\/ bs2nat (hd nil l) <> 0 -> bs2nat (Sem OneMinusMultPlus'_e l) = (1 - bs2nat (hd nil l)) * bs2nat (hd nil (tl l)) + bs2nat (hd nil l) * (1 - (1 - bs2nat (hd nil l))).
Proof.
intros [ | v l] H.
simpl.
destruct v as [ | [ | ] v].
simpl.
rewrite bs2nat_true.

*****
H : or (eq (hd nil (cons (cons true v) l)) nil)\n (not (eq (bs2nat (hd nil (cons (cons true v) l))) O))
l : list (list bool)
v : list bool
*****
eq (Init.Nat.add (S O) (Init.Nat.mul (S (S O)) (bs2nat v))) (Init.Nat.add (Init.Nat.mul match Init.Nat.add (S O) (Init.Nat.mul (S (S O)) (bs2nat v)) with | O => S O | S _ => O end (bs2nat (hd nil l))) (Init.Nat.mul (Init.Nat.add (S O) (Init.Nat.mul (S (S O)) (bs2nat v))) match match Init.Nat.add (S O) (Init.Nat.mul (S (S O)) (bs2nat v)) with | O => S O | S _ => O end with | O => S O | S _ => O end))
+++++
simpl.
-----
Lemma OneMinusMultPlus'_correct : forall l, hd nil l = nil \\/ bs2nat (hd nil l) <> 0 -> bs2nat (Sem OneMinusMultPlus'_e l) = (1 - bs2nat (hd nil l)) * bs2nat (hd nil (tl l)) + bs2nat (hd nil l) * (1 - (1 - bs2nat (hd nil l))).
Proof.
intros [ | v l] H.
simpl.
destruct v as [ | [ | ] v].
simpl.
rewrite bs2nat_true.
simpl.

*****
H : or (eq (hd nil (cons (cons true v) l)) nil)\n (not (eq (bs2nat (hd nil (cons (cons true v) l))) O))
l : list (list bool)
v : list bool
*****
eq (S (Init.Nat.add (bs2nat v) (Init.Nat.add (bs2nat v) O))) (S (Init.Nat.mul (Init.Nat.add (bs2nat v) (Init.Nat.add (bs2nat v) O)) (S O)))
+++++
ring.
-----
Lemma OneMinusMultPlus'_correct : forall l, hd nil l = nil \\/ bs2nat (hd nil l) <> 0 -> bs2nat (Sem OneMinusMultPlus'_e l) = (1 - bs2nat (hd nil l)) * bs2nat (hd nil (tl l)) + bs2nat (hd nil l) * (1 - (1 - bs2nat (hd nil l))).
Proof.
intros [ | v l] H.
simpl.
destruct v as [ | [ | ] v].

*****
H : or (eq (hd nil (cons (cons false v) l)) nil)\n (not (eq (bs2nat (hd nil (cons (cons false v) l))) O))
l : list (list bool)
v : list bool
*****
eq (bs2nat (sem_Rec (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => cons false (nth O vl nil)) (fun vl : list (list bool) => cons true (nth O vl nil)) (cons false v) l)) (Init.Nat.add (Init.Nat.mul match bs2nat (cons false v) with | O => S O | S _ => O end (bs2nat (hd nil l))) (Init.Nat.mul (bs2nat (cons false v)) match match bs2nat (cons false v) with | O => S O | S _ => O end with | O => S O | S _ => O end))
+++++
simpl.
-----
Lemma OneMinusMultPlus'_correct : forall l, hd nil l = nil \\/ bs2nat (hd nil l) <> 0 -> bs2nat (Sem OneMinusMultPlus'_e l) = (1 - bs2nat (hd nil l)) * bs2nat (hd nil (tl l)) + bs2nat (hd nil l) * (1 - (1 - bs2nat (hd nil l))).
Proof.
intros [ | v l] H.
simpl.
destruct v as [ | [ | ] v].
simpl.

*****
H : or (eq (hd nil (cons (cons false v) l)) nil)\n (not (eq (bs2nat (hd nil (cons (cons false v) l))) O))
l : list (list bool)
v : list bool
*****
eq (bs2nat (cons false v)) (Init.Nat.add (Init.Nat.mul match bs2nat (cons false v) with | O => S O | S _ => O end (bs2nat (hd nil l))) (Init.Nat.mul (bs2nat (cons false v)) match match bs2nat (cons false v) with | O => S O | S _ => O end with | O => S O | S _ => O end))
+++++
simpl in *.
-----
Lemma OneMinusMultPlus'_correct : forall l, hd nil l = nil \\/ bs2nat (hd nil l) <> 0 -> bs2nat (Sem OneMinusMultPlus'_e l) = (1 - bs2nat (hd nil l)) * bs2nat (hd nil (tl l)) + bs2nat (hd nil l) * (1 - (1 - bs2nat (hd nil l))).
Proof.
intros [ | v l] H.
simpl.
destruct v as [ | [ | ] v].
simpl.
simpl in *.

*****
H : or (eq (cons false v) nil) (not (eq (bs2nat (cons false v)) O))
l : list (list bool)
v : list bool
*****
eq (bs2nat (cons false v)) (Init.Nat.add (Init.Nat.mul match bs2nat (cons false v) with | O => S O | S _ => O end (bs2nat (hd nil l))) (Init.Nat.mul (bs2nat (cons false v)) match match bs2nat (cons false v) with | O => S O | S _ => O end with | O => S O | S _ => O end))
+++++
rewrite bs2nat_false in *.
-----
Lemma OneMinusMultPlus'_correct : forall l, hd nil l = nil \\/ bs2nat (hd nil l) <> 0 -> bs2nat (Sem OneMinusMultPlus'_e l) = (1 - bs2nat (hd nil l)) * bs2nat (hd nil (tl l)) + bs2nat (hd nil l) * (1 - (1 - bs2nat (hd nil l))).
Proof.
intros [ | v l] H.
simpl.
destruct v as [ | [ | ] v].
simpl.
simpl in *.
rewrite bs2nat_false in *.

*****
H : or (eq (cons false v) nil)\n (not (eq (Init.Nat.mul (S (S O)) (bs2nat v)) O))
l : list (list bool)
v : list bool
*****
eq (Init.Nat.mul (S (S O)) (bs2nat v)) (Init.Nat.add (Init.Nat.mul match Init.Nat.mul (S (S O)) (bs2nat v) with | O => S O | S _ => O end (bs2nat (hd nil l))) (Init.Nat.mul (Init.Nat.mul (S (S O)) (bs2nat v)) match match Init.Nat.mul (S (S O)) (bs2nat v) with | O => S O | S _ => O end with | O => S O | S _ => O end))
+++++
destruct (2 * bs2nat v).
-----
Lemma OneMinusMultPlus'_correct : forall l, hd nil l = nil \\/ bs2nat (hd nil l) <> 0 -> bs2nat (Sem OneMinusMultPlus'_e l) = (1 - bs2nat (hd nil l)) * bs2nat (hd nil (tl l)) + bs2nat (hd nil l) * (1 - (1 - bs2nat (hd nil l))).
Proof.
intros [ | v l] H.
simpl.
destruct v as [ | [ | ] v].
simpl.
simpl in *.
rewrite bs2nat_false in *.
destruct (2 * bs2nat v).

*****
H : or (eq (cons false v) nil) (not (eq O O))
l : list (list bool)
v : list bool
*****
eq O (Init.Nat.add (Init.Nat.mul (S O) (bs2nat (hd nil l))) (Init.Nat.mul O O))
+++++
destruct H.
-----
Lemma OneMinusMultPlus'_correct : forall l, hd nil l = nil \\/ bs2nat (hd nil l) <> 0 -> bs2nat (Sem OneMinusMultPlus'_e l) = (1 - bs2nat (hd nil l)) * bs2nat (hd nil (tl l)) + bs2nat (hd nil l) * (1 - (1 - bs2nat (hd nil l))).
Proof.
intros [ | v l] H.
simpl.
destruct v as [ | [ | ] v].
simpl.
simpl in *.
rewrite bs2nat_false in *.
destruct (2 * bs2nat v).
destruct H.

*****
H : eq (cons false v) nil
l : list (list bool)
v : list bool
*****
eq O (Init.Nat.add (Init.Nat.mul (S O) (bs2nat (hd nil l))) (Init.Nat.mul O O))
+++++
congruence.
-----
Lemma OneMinusMultPlus'_correct : forall l, hd nil l = nil \\/ bs2nat (hd nil l) <> 0 -> bs2nat (Sem OneMinusMultPlus'_e l) = (1 - bs2nat (hd nil l)) * bs2nat (hd nil (tl l)) + bs2nat (hd nil l) * (1 - (1 - bs2nat (hd nil l))).
Proof.
intros [ | v l] H.
simpl.
destruct v as [ | [ | ] v].
simpl.
simpl in *.
rewrite bs2nat_false in *.
destruct (2 * bs2nat v).
destruct H.

*****
H : not (eq O O)
l : list (list bool)
v : list bool
*****
eq O (Init.Nat.add (Init.Nat.mul (S O) (bs2nat (hd nil l))) (Init.Nat.mul O O))
+++++
tauto.
-----
Lemma OneMinusMultPlus'_correct : forall l, hd nil l = nil \\/ bs2nat (hd nil l) <> 0 -> bs2nat (Sem OneMinusMultPlus'_e l) = (1 - bs2nat (hd nil l)) * bs2nat (hd nil (tl l)) + bs2nat (hd nil l) * (1 - (1 - bs2nat (hd nil l))).
Proof.
intros [ | v l] H.
simpl.
destruct v as [ | [ | ] v].
simpl.
simpl in *.
rewrite bs2nat_false in *.
destruct (2 * bs2nat v).

*****
H : or (eq (cons false v) nil) (not (eq (S n) O))
n : nat
l : list (list bool)
v : list bool
*****
eq (S n) (Init.Nat.add (Init.Nat.mul O (bs2nat (hd nil l))) (Init.Nat.mul (S n) (S O)))
+++++
ring.
-----
Lemma OneMinusMultPlus'_correct : forall l, hd nil l = nil \\/ bs2nat (hd nil l) <> 0 -> bs2nat (Sem OneMinusMultPlus'_e l) = (1 - bs2nat (hd nil l)) * bs2nat (hd nil (tl l)) + bs2nat (hd nil l) * (1 - (1 - bs2nat (hd nil l))).
Proof.
intros [ | v l] H.

*****

*****

+++++
Qed.
-----
Opaque OneMinusMultPlus'_e.
-----
Definition OneMinusMultPlus_e : Cobham :=\n  Comp 2 OneMinusMultPlus'_e [Comp 2 Normalize_e [Proj 2 0]; Proj 2 1].
-----
Lemma arity_OneMinusMultPlus : arity OneMinusMultPlus_e = ok_arity 2.
-----
Lemma arity_OneMinusMultPlus : arity OneMinusMultPlus_e = ok_arity 2.

*****

*****
eq (arity OneMinusMultPlus_e) (ok_arity (S (S O)))
+++++
Proof.
-----
Lemma arity_OneMinusMultPlus : arity OneMinusMultPlus_e = ok_arity 2.
Proof.

*****

*****
eq (arity OneMinusMultPlus_e) (ok_arity (S (S O)))
+++++
trivial.
-----
Lemma arity_OneMinusMultPlus : arity OneMinusMultPlus_e = ok_arity 2.
Proof.
trivial.

*****

*****

+++++
Qed.
-----
Lemma rec_bounded_OneMinusMultPlus :\n  rec_bounded OneMinusMultPlus_e.
-----
Lemma rec_bounded_OneMinusMultPlus : rec_bounded OneMinusMultPlus_e.

*****

*****
rec_bounded OneMinusMultPlus_e
+++++
Proof.
-----
Lemma rec_bounded_OneMinusMultPlus : rec_bounded OneMinusMultPlus_e.
Proof.

*****

*****
rec_bounded OneMinusMultPlus_e
+++++
simpl.
-----
Lemma rec_bounded_OneMinusMultPlus : rec_bounded OneMinusMultPlus_e.
Proof.
simpl.

*****

*****
and (rec_bounded OneMinusMultPlus'_e) (and (and (rec_bounded Normalize_e) (and True True)) (and True True))
+++++
intuition.
-----
Lemma rec_bounded_OneMinusMultPlus : rec_bounded OneMinusMultPlus_e.
Proof.
simpl.
intuition.

*****

*****
rec_bounded OneMinusMultPlus'_e
+++++
apply rec_bounded_OneMinusMultPlus'.
-----
Lemma rec_bounded_OneMinusMultPlus : rec_bounded OneMinusMultPlus_e.
Proof.
simpl.
intuition.

*****

*****
rec_bounded Normalize_e
+++++
apply rec_bounded_Normalize.
-----
Lemma rec_bounded_OneMinusMultPlus : rec_bounded OneMinusMultPlus_e.
Proof.
simpl.
intuition.

*****

*****

+++++
Qed.
-----
Lemma OneMinusMultPlus_correct : forall l,\n  bs2nat (Sem OneMinusMultPlus_e l) =\n  (1 - bs2nat (hd nil l)) * bs2nat (hd nil (tl l)) +\n  bs2nat (hd nil l) * (1 - (1 - bs2nat (hd nil l))).
-----
Lemma OneMinusMultPlus_correct : forall l, bs2nat (Sem OneMinusMultPlus_e l) = (1 - bs2nat (hd nil l)) * bs2nat (hd nil (tl l)) + bs2nat (hd nil l) * (1 - (1 - bs2nat (hd nil l))).

*****

*****
forall l : list (list bool), eq (bs2nat (Sem OneMinusMultPlus_e l)) (Init.Nat.add (Init.Nat.mul (Init.Nat.sub (S O) (bs2nat (hd nil l))) (bs2nat (hd nil (tl l)))) (Init.Nat.mul (bs2nat (hd nil l)) (Init.Nat.sub (S O) (Init.Nat.sub (S O) (bs2nat (hd nil l))))))
+++++
Proof.
-----
Lemma OneMinusMultPlus_correct : forall l, bs2nat (Sem OneMinusMultPlus_e l) = (1 - bs2nat (hd nil l)) * bs2nat (hd nil (tl l)) + bs2nat (hd nil l) * (1 - (1 - bs2nat (hd nil l))).
Proof.

*****

*****
forall l : list (list bool), eq (bs2nat (Sem OneMinusMultPlus_e l)) (Init.Nat.add (Init.Nat.mul (Init.Nat.sub (S O) (bs2nat (hd nil l))) (bs2nat (hd nil (tl l)))) (Init.Nat.mul (bs2nat (hd nil l)) (Init.Nat.sub (S O) (Init.Nat.sub (S O) (bs2nat (hd nil l))))))
+++++
intro l.
-----
Lemma OneMinusMultPlus_correct : forall l, bs2nat (Sem OneMinusMultPlus_e l) = (1 - bs2nat (hd nil l)) * bs2nat (hd nil (tl l)) + bs2nat (hd nil l) * (1 - (1 - bs2nat (hd nil l))).
Proof.
intro l.

*****
l : list (list bool)
*****
eq (bs2nat (Sem OneMinusMultPlus_e l)) (Init.Nat.add (Init.Nat.mul (Init.Nat.sub (S O) (bs2nat (hd nil l))) (bs2nat (hd nil (tl l)))) (Init.Nat.mul (bs2nat (hd nil l)) (Init.Nat.sub (S O) (Init.Nat.sub (S O) (bs2nat (hd nil l))))))
+++++
simpl.
-----
Lemma OneMinusMultPlus_correct : forall l, bs2nat (Sem OneMinusMultPlus_e l) = (1 - bs2nat (hd nil l)) * bs2nat (hd nil (tl l)) + bs2nat (hd nil l) * (1 - (1 - bs2nat (hd nil l))).
Proof.
intro l.
simpl.

*****
l : list (list bool)
*****
eq (bs2nat (Sem OneMinusMultPlus'_e (cons (Sem Normalize_e (cons (nth O l nil) nil)) (cons (nth (S O) l nil) nil)))) (Init.Nat.add (Init.Nat.mul match bs2nat (hd nil l) with | O => S O | S _ => O end (bs2nat (hd nil (tl l)))) (Init.Nat.mul (bs2nat (hd nil l)) match match bs2nat (hd nil l) with | O => S O | S _ => O end with | O => S O | S _ => O end))
+++++
rewrite OneMinusMultPlus'_correct.
-----
Lemma OneMinusMultPlus_correct : forall l, bs2nat (Sem OneMinusMultPlus_e l) = (1 - bs2nat (hd nil l)) * bs2nat (hd nil (tl l)) + bs2nat (hd nil l) * (1 - (1 - bs2nat (hd nil l))).
Proof.
intro l.
simpl.
rewrite OneMinusMultPlus'_correct.

*****
l : list (list bool)
*****
eq (Init.Nat.add (Init.Nat.mul (Init.Nat.sub (S O) (bs2nat (hd nil (cons (Sem Normalize_e (cons (nth O l nil) nil)) (cons (nth (S O) l nil) nil))))) (bs2nat (hd nil (tl (cons (Sem Normalize_e (cons (nth O l nil) nil)) (cons (nth (S O) l nil) nil)))))) (Init.Nat.mul (bs2nat (hd nil (cons (Sem Normalize_e (cons (nth O l nil) nil)) (cons (nth (S O) l nil) nil)))) (Init.Nat.sub (S O) (Init.Nat.sub (S O) (bs2nat (hd nil (cons (Sem Normalize_e (cons (nth O l nil) nil)) (cons (nth (S O) l nil) nil)))))))) (Init.Nat.add (Init.Nat.mul match bs2nat (hd nil l) with | O => S O | S _ => O end (bs2nat (hd nil (tl l)))) (Init.Nat.mul (bs2nat (hd nil l)) match match bs2nat (hd nil l) with | O => S O | S _ => O end with | O => S O | S _ => O end))
+++++
simpl.
-----
Lemma OneMinusMultPlus_correct : forall l, bs2nat (Sem OneMinusMultPlus_e l) = (1 - bs2nat (hd nil l)) * bs2nat (hd nil (tl l)) + bs2nat (hd nil l) * (1 - (1 - bs2nat (hd nil l))).
Proof.
intro l.
simpl.
rewrite OneMinusMultPlus'_correct.
simpl.

*****
l : list (list bool)
*****
eq (Init.Nat.add (Init.Nat.mul match bs2nat (Sem Normalize_e (cons (nth O l nil) nil)) with | O => S O | S _ => O end (bs2nat (nth (S O) l nil))) (Init.Nat.mul (bs2nat (Sem Normalize_e (cons (nth O l nil) nil))) match match bs2nat (Sem Normalize_e (cons (nth O l nil) nil)) with | O => S O | S _ => O end with | O => S O | S _ => O end)) (Init.Nat.add (Init.Nat.mul match bs2nat (hd nil l) with | O => S O | S _ => O end (bs2nat (hd nil (tl l)))) (Init.Nat.mul (bs2nat (hd nil l)) match match bs2nat (hd nil l) with | O => S O | S _ => O end with | O => S O | S _ => O end))
+++++
rewrite Normalize_correct.
-----
Lemma OneMinusMultPlus_correct : forall l, bs2nat (Sem OneMinusMultPlus_e l) = (1 - bs2nat (hd nil l)) * bs2nat (hd nil (tl l)) + bs2nat (hd nil l) * (1 - (1 - bs2nat (hd nil l))).
Proof.
intro l.
simpl.
rewrite OneMinusMultPlus'_correct.
simpl.
rewrite Normalize_correct.

*****
l : list (list bool)
*****
eq (Init.Nat.add (Init.Nat.mul match bs2nat (Sem (Proj (S O) O) (cons (nth O l nil) nil)) with | O => S O | S _ => O end (bs2nat (nth (S O) l nil))) (Init.Nat.mul (bs2nat (Sem (Proj (S O) O) (cons (nth O l nil) nil))) match match bs2nat (Sem (Proj (S O) O) (cons (nth O l nil) nil)) with | O => S O | S _ => O end with | O => S O | S _ => O end)) (Init.Nat.add (Init.Nat.mul match bs2nat (hd nil l) with | O => S O | S _ => O end (bs2nat (hd nil (tl l)))) (Init.Nat.mul (bs2nat (hd nil l)) match match bs2nat (hd nil l) with | O => S O | S _ => O end with | O => S O | S _ => O end))
+++++
simpl.
-----
Lemma OneMinusMultPlus_correct : forall l, bs2nat (Sem OneMinusMultPlus_e l) = (1 - bs2nat (hd nil l)) * bs2nat (hd nil (tl l)) + bs2nat (hd nil l) * (1 - (1 - bs2nat (hd nil l))).
Proof.
intro l.
simpl.
rewrite OneMinusMultPlus'_correct.
simpl.
rewrite Normalize_correct.
simpl.

*****
l : list (list bool)
*****
eq (Init.Nat.add (Init.Nat.mul match bs2nat (nth O l nil) with | O => S O | S _ => O end (bs2nat (nth (S O) l nil))) (Init.Nat.mul (bs2nat (nth O l nil)) match match bs2nat (nth O l nil) with | O => S O | S _ => O end with | O => S O | S _ => O end)) (Init.Nat.add (Init.Nat.mul match bs2nat (hd nil l) with | O => S O | S _ => O end (bs2nat (hd nil (tl l)))) (Init.Nat.mul (bs2nat (hd nil l)) match match bs2nat (hd nil l) with | O => S O | S _ => O end with | O => S O | S _ => O end))
+++++
rewrite hd_nth_1.
-----
Lemma OneMinusMultPlus_correct : forall l, bs2nat (Sem OneMinusMultPlus_e l) = (1 - bs2nat (hd nil l)) * bs2nat (hd nil (tl l)) + bs2nat (hd nil l) * (1 - (1 - bs2nat (hd nil l))).
Proof.
intro l.
simpl.
rewrite OneMinusMultPlus'_correct.
simpl.
rewrite Normalize_correct.
simpl.
rewrite hd_nth_1.

*****
l : list (list bool)
*****
eq (Init.Nat.add (Init.Nat.mul match bs2nat (nth O l nil) with | O => S O | S _ => O end (bs2nat (nth (S O) l nil))) (Init.Nat.mul (bs2nat (nth O l nil)) match match bs2nat (nth O l nil) with | O => S O | S _ => O end with | O => S O | S _ => O end)) (Init.Nat.add (Init.Nat.mul match bs2nat (hd nil l) with | O => S O | S _ => O end (bs2nat (nth (S O) l nil))) (Init.Nat.mul (bs2nat (hd nil l)) match match bs2nat (hd nil l) with | O => S O | S _ => O end with | O => S O | S _ => O end))
+++++
rewrite hd_nth_0.
-----
Lemma OneMinusMultPlus_correct : forall l, bs2nat (Sem OneMinusMultPlus_e l) = (1 - bs2nat (hd nil l)) * bs2nat (hd nil (tl l)) + bs2nat (hd nil l) * (1 - (1 - bs2nat (hd nil l))).
Proof.
intro l.
simpl.
rewrite OneMinusMultPlus'_correct.
simpl.
rewrite Normalize_correct.
simpl.
rewrite hd_nth_1.
rewrite hd_nth_0.

*****
l : list (list bool)
*****
eq (Init.Nat.add (Init.Nat.mul match bs2nat (nth O l nil) with | O => S O | S _ => O end (bs2nat (nth (S O) l nil))) (Init.Nat.mul (bs2nat (nth O l nil)) match match bs2nat (nth O l nil) with | O => S O | S _ => O end with | O => S O | S _ => O end)) (Init.Nat.add (Init.Nat.mul match bs2nat (nth O l nil) with | O => S O | S _ => O end (bs2nat (nth (S O) l nil))) (Init.Nat.mul (bs2nat (nth O l nil)) match match bs2nat (nth O l nil) with | O => S O | S _ => O end with | O => S O | S _ => O end))
+++++
trivial.
-----
Lemma OneMinusMultPlus_correct : forall l, bs2nat (Sem OneMinusMultPlus_e l) = (1 - bs2nat (hd nil l)) * bs2nat (hd nil (tl l)) + bs2nat (hd nil l) * (1 - (1 - bs2nat (hd nil l))).
Proof.
intro l.
simpl.
rewrite OneMinusMultPlus'_correct.

*****
l : list (list bool)
*****
or (eq (hd nil (cons (Sem Normalize_e (cons (nth O l nil) nil)) (cons (nth (S O) l nil) nil))) nil) (not (eq (bs2nat (hd nil (cons (Sem Normalize_e (cons (nth O l nil) nil)) (cons (nth (S O) l nil) nil)))) O))
+++++
apply Normalize_normal.
-----
Lemma OneMinusMultPlus_correct : forall l, bs2nat (Sem OneMinusMultPlus_e l) = (1 - bs2nat (hd nil l)) * bs2nat (hd nil (tl l)) + bs2nat (hd nil l) * (1 - (1 - bs2nat (hd nil l))).
Proof.
intro l.
simpl.
rewrite OneMinusMultPlus'_correct.

*****

*****

+++++
Qed.
-----
Opaque OneMinusMultPlus_e.
-----
Definition PlusMod2_e : Cobham :=\n  Comp 2 Cond [\n     Proj 2 1;\n     Proj 2 0;\n     Comp 2 Succ_e [Proj 2 0];\n     Proj 2 0\n  ].
-----
Lemma arity_PlusMod2 :\n  arity PlusMod2_e = ok_arity 2.
-----
Lemma arity_PlusMod2 : arity PlusMod2_e = ok_arity 2.

*****

*****
eq (arity PlusMod2_e) (ok_arity (S (S O)))
+++++
Proof.
-----
Lemma arity_PlusMod2 : arity PlusMod2_e = ok_arity 2.
Proof.

*****

*****
eq (arity PlusMod2_e) (ok_arity (S (S O)))
+++++
trivial.
-----
Lemma arity_PlusMod2 : arity PlusMod2_e = ok_arity 2.
Proof.
trivial.

*****

*****

+++++
Qed.
-----
Lemma rec_bounded_PlusMod2 :\n  rec_bounded PlusMod2_e.
-----
Lemma rec_bounded_PlusMod2 : rec_bounded PlusMod2_e.

*****

*****
rec_bounded PlusMod2_e
+++++
Proof.
-----
Lemma rec_bounded_PlusMod2 : rec_bounded PlusMod2_e.
Proof.

*****

*****
rec_bounded PlusMod2_e
+++++
simpl.
-----
Lemma rec_bounded_PlusMod2 : rec_bounded PlusMod2_e.
Proof.
simpl.

*****

*****
and (rec_bounded Cond) (and True (and True (and (and (rec_bounded Succ_e) (and True True)) (and True True))))
+++++
intuition.
-----
Lemma rec_bounded_PlusMod2 : rec_bounded PlusMod2_e.
Proof.
simpl.
intuition.

*****

*****
rec_bounded Cond
+++++
apply rec_bounded'_spec with 4.
-----
Lemma rec_bounded_PlusMod2 : rec_bounded PlusMod2_e.
Proof.
simpl.
intuition.
apply rec_bounded'_spec with 4.

*****

*****
eq (arity Cond) (ok_arity (S (S (S (S O)))))
+++++
apply arity_Cond.
-----
Lemma rec_bounded_PlusMod2 : rec_bounded PlusMod2_e.
Proof.
simpl.
intuition.
apply rec_bounded'_spec with 4.

*****

*****
rec_bounded' Cond
+++++
apply rec_bounded_Cond.
-----
Lemma rec_bounded_PlusMod2 : rec_bounded PlusMod2_e.
Proof.
simpl.
intuition.

*****

*****
rec_bounded Succ_e
+++++
apply rec_bounded_Succ.
-----
Lemma rec_bounded_PlusMod2 : rec_bounded PlusMod2_e.
Proof.
simpl.
intuition.

*****

*****

+++++
Qed.
-----
Lemma PlusMod2_correct : forall l,\n  bs2nat (Sem PlusMod2_e l) =\n  bs2nat (hd nil l) + mod2 (bs2nat (hd nil (tl l))).
-----
Lemma PlusMod2_correct : forall l, bs2nat (Sem PlusMod2_e l) = bs2nat (hd nil l) + mod2 (bs2nat (hd nil (tl l))).

*****

*****
forall l : list (list bool), eq (bs2nat (Sem PlusMod2_e l)) (Init.Nat.add (bs2nat (hd nil l)) (mod2 (bs2nat (hd nil (tl l)))))
+++++
Proof.
-----
Lemma PlusMod2_correct : forall l, bs2nat (Sem PlusMod2_e l) = bs2nat (hd nil l) + mod2 (bs2nat (hd nil (tl l))).
Proof.

*****

*****
forall l : list (list bool), eq (bs2nat (Sem PlusMod2_e l)) (Init.Nat.add (bs2nat (hd nil l)) (mod2 (bs2nat (hd nil (tl l)))))
+++++
unfold mod2.
-----
Lemma PlusMod2_correct : forall l, bs2nat (Sem PlusMod2_e l) = bs2nat (hd nil l) + mod2 (bs2nat (hd nil (tl l))).
Proof.
unfold mod2.

*****

*****
forall l : list (list bool), eq (bs2nat (Sem PlusMod2_e l)) (Init.Nat.add (bs2nat (hd nil l)) (Init.Nat.sub (bs2nat (hd nil (tl l))) (Init.Nat.mul (S (S O)) (Nat.div2 (bs2nat (hd nil (tl l)))))))
+++++
intros [ | u [ | v l] ].
-----
Lemma PlusMod2_correct : forall l, bs2nat (Sem PlusMod2_e l) = bs2nat (hd nil l) + mod2 (bs2nat (hd nil (tl l))).
Proof.
unfold mod2.
intros [ | u [ | v l] ].

*****

*****
eq (bs2nat (Sem PlusMod2_e nil)) (Init.Nat.add (bs2nat (hd nil nil)) (Init.Nat.sub (bs2nat (hd nil (tl nil))) (Init.Nat.mul (S (S O)) (Nat.div2 (bs2nat (hd nil (tl nil)))))))
+++++
simpl.
-----
Lemma PlusMod2_correct : forall l, bs2nat (Sem PlusMod2_e l) = bs2nat (hd nil l) + mod2 (bs2nat (hd nil (tl l))).
Proof.
unfold mod2.
intros [ | u [ | v l] ].
simpl.

*****

*****
eq (bs2nat (Sem Cond (cons nil (cons nil (cons (Sem Succ_e (cons nil nil)) (cons nil nil)))))) (Init.Nat.add (bs2nat nil) (Init.Nat.sub (bs2nat nil) (Init.Nat.add (Nat.div2 (bs2nat nil)) (Init.Nat.add (Nat.div2 (bs2nat nil)) O))))
+++++
trivial.
-----
Lemma PlusMod2_correct : forall l, bs2nat (Sem PlusMod2_e l) = bs2nat (hd nil l) + mod2 (bs2nat (hd nil (tl l))).
Proof.
unfold mod2.
intros [ | u [ | v l] ].

*****
u : list bool
*****
eq (bs2nat (Sem PlusMod2_e (cons u nil))) (Init.Nat.add (bs2nat (hd nil (cons u nil))) (Init.Nat.sub (bs2nat (hd nil (tl (cons u nil)))) (Init.Nat.mul (S (S O)) (Nat.div2 (bs2nat (hd nil (tl (cons u nil))))))))
+++++
simpl.
-----
Lemma PlusMod2_correct : forall l, bs2nat (Sem PlusMod2_e l) = bs2nat (hd nil l) + mod2 (bs2nat (hd nil (tl l))).
Proof.
unfold mod2.
intros [ | u [ | v l] ].
simpl.

*****
u : list bool
*****
eq (bs2nat (Sem Cond (cons nil (cons u (cons (Sem Succ_e (cons u nil)) (cons u nil)))))) (Init.Nat.add (bs2nat u) (Init.Nat.sub (bs2nat nil) (Init.Nat.add (Nat.div2 (bs2nat nil)) (Init.Nat.add (Nat.div2 (bs2nat nil)) O))))
+++++
rewrite Cond_correct.
-----
Lemma PlusMod2_correct : forall l, bs2nat (Sem PlusMod2_e l) = bs2nat (hd nil l) + mod2 (bs2nat (hd nil (tl l))).
Proof.
unfold mod2.
intros [ | u [ | v l] ].
simpl.
rewrite Cond_correct.

*****
u : list bool
*****
eq (bs2nat match hd nil (cons nil (cons u (cons (Sem Succ_e (cons u nil)) (cons u nil)))) with | nil => hd nil (tl (cons nil (cons u (cons (Sem Succ_e (cons u nil)) (cons u nil))))) | cons true _ => hd nil (tl (tl (cons nil (cons u (cons (Sem Succ_e (cons u nil)) (cons u nil)))))) | cons false _ => hd nil (tl (tl (tl (cons nil (cons u (cons (Sem Succ_e (cons u nil)) (cons u nil))))))) end) (Init.Nat.add (bs2nat u) (Init.Nat.sub (bs2nat nil) (Init.Nat.add (Nat.div2 (bs2nat nil)) (Init.Nat.add (Nat.div2 (bs2nat nil)) O))))
+++++
rewrite bs2nat_nil.
-----
Lemma PlusMod2_correct : forall l, bs2nat (Sem PlusMod2_e l) = bs2nat (hd nil l) + mod2 (bs2nat (hd nil (tl l))).
Proof.
unfold mod2.
intros [ | u [ | v l] ].
simpl.
rewrite Cond_correct.
rewrite bs2nat_nil.

*****
u : list bool
*****
eq (bs2nat match hd nil (cons nil (cons u (cons (Sem Succ_e (cons u nil)) (cons u nil)))) with | nil => hd nil (tl (cons nil (cons u (cons (Sem Succ_e (cons u nil)) (cons u nil))))) | cons true _ => hd nil (tl (tl (cons nil (cons u (cons (Sem Succ_e (cons u nil)) (cons u nil)))))) | cons false _ => hd nil (tl (tl (tl (cons nil (cons u (cons (Sem Succ_e (cons u nil)) (cons u nil))))))) end) (Init.Nat.add (bs2nat u) (Init.Nat.sub O (Init.Nat.add (Nat.div2 O) (Init.Nat.add (Nat.div2 O) O))))
+++++
simpl.
-----
Lemma PlusMod2_correct : forall l, bs2nat (Sem PlusMod2_e l) = bs2nat (hd nil l) + mod2 (bs2nat (hd nil (tl l))).
Proof.
unfold mod2.
intros [ | u [ | v l] ].
simpl.
rewrite Cond_correct.
rewrite bs2nat_nil.
simpl.

*****
u : list bool
*****
eq (bs2nat u) (Init.Nat.add (bs2nat u) O)
+++++
omega.
-----
Lemma PlusMod2_correct : forall l, bs2nat (Sem PlusMod2_e l) = bs2nat (hd nil l) + mod2 (bs2nat (hd nil (tl l))).
Proof.
unfold mod2.
intros [ | u [ | v l] ].

*****
l : list (list bool)
u,v : list bool
*****
eq (bs2nat (Sem PlusMod2_e (cons u (cons v l)))) (Init.Nat.add (bs2nat (hd nil (cons u (cons v l)))) (Init.Nat.sub (bs2nat (hd nil (tl (cons u (cons v l))))) (Init.Nat.mul (S (S O)) (Nat.div2 (bs2nat (hd nil (tl (cons u (cons v l)))))))))
+++++
simpl.
-----
Lemma PlusMod2_correct : forall l, bs2nat (Sem PlusMod2_e l) = bs2nat (hd nil l) + mod2 (bs2nat (hd nil (tl l))).
Proof.
unfold mod2.
intros [ | u [ | v l] ].
simpl.

*****
l : list (list bool)
u,v : list bool
*****
eq (bs2nat (Sem Cond (cons v (cons u (cons (Sem Succ_e (cons u nil)) (cons u nil)))))) (Init.Nat.add (bs2nat u) (Init.Nat.sub (bs2nat v) (Init.Nat.add (Nat.div2 (bs2nat v)) (Init.Nat.add (Nat.div2 (bs2nat v)) O))))
+++++
rewrite Cond_correct.
-----
Lemma PlusMod2_correct : forall l, bs2nat (Sem PlusMod2_e l) = bs2nat (hd nil l) + mod2 (bs2nat (hd nil (tl l))).
Proof.
unfold mod2.
intros [ | u [ | v l] ].
simpl.
rewrite Cond_correct.

*****
l : list (list bool)
u,v : list bool
*****
eq (bs2nat match hd nil (cons v (cons u (cons (Sem Succ_e (cons u nil)) (cons u nil)))) with | nil => hd nil (tl (cons v (cons u (cons (Sem Succ_e (cons u nil)) (cons u nil))))) | cons true _ => hd nil (tl (tl (cons v (cons u (cons (Sem Succ_e (cons u nil)) (cons u nil)))))) | cons false _ => hd nil (tl (tl (tl (cons v (cons u (cons (Sem Succ_e (cons u nil)) (cons u nil))))))) end) (Init.Nat.add (bs2nat u) (Init.Nat.sub (bs2nat v) (Init.Nat.add (Nat.div2 (bs2nat v)) (Init.Nat.add (Nat.div2 (bs2nat v)) O))))
+++++
simpl.
-----
Lemma PlusMod2_correct : forall l, bs2nat (Sem PlusMod2_e l) = bs2nat (hd nil l) + mod2 (bs2nat (hd nil (tl l))).
Proof.
unfold mod2.
intros [ | u [ | v l] ].
simpl.
rewrite Cond_correct.
simpl.

*****
l : list (list bool)
u,v : list bool
*****
eq (bs2nat match v with | cons true _ => Sem Succ_e (cons u nil) | _ => u end) (Init.Nat.add (bs2nat u) (Init.Nat.sub (bs2nat v) (Init.Nat.add (Nat.div2 (bs2nat v)) (Init.Nat.add (Nat.div2 (bs2nat v)) O))))
+++++
destruct v as [ | [ | ] v].
-----
Lemma PlusMod2_correct : forall l, bs2nat (Sem PlusMod2_e l) = bs2nat (hd nil l) + mod2 (bs2nat (hd nil (tl l))).
Proof.
unfold mod2.
intros [ | u [ | v l] ].
simpl.
rewrite Cond_correct.
simpl.
destruct v as [ | [ | ] v].

*****
l : list (list bool)
u : list bool
*****
eq (bs2nat u) (Init.Nat.add (bs2nat u) (Init.Nat.sub (bs2nat nil) (Init.Nat.add (Nat.div2 (bs2nat nil)) (Init.Nat.add (Nat.div2 (bs2nat nil)) O))))
+++++
rewrite bs2nat_nil.
-----
Lemma PlusMod2_correct : forall l, bs2nat (Sem PlusMod2_e l) = bs2nat (hd nil l) + mod2 (bs2nat (hd nil (tl l))).
Proof.
unfold mod2.
intros [ | u [ | v l] ].
simpl.
rewrite Cond_correct.
simpl.
destruct v as [ | [ | ] v].
rewrite bs2nat_nil.

*****
l : list (list bool)
u : list bool
*****
eq (bs2nat u) (Init.Nat.add (bs2nat u) (Init.Nat.sub O (Init.Nat.add (Nat.div2 O) (Init.Nat.add (Nat.div2 O) O))))
+++++
simpl.
-----
Lemma PlusMod2_correct : forall l, bs2nat (Sem PlusMod2_e l) = bs2nat (hd nil l) + mod2 (bs2nat (hd nil (tl l))).
Proof.
unfold mod2.
intros [ | u [ | v l] ].
simpl.
rewrite Cond_correct.
simpl.
destruct v as [ | [ | ] v].
rewrite bs2nat_nil.
simpl.

*****
l : list (list bool)
u : list bool
*****
eq (bs2nat u) (Init.Nat.add (bs2nat u) O)
+++++
omega.
-----
Lemma PlusMod2_correct : forall l, bs2nat (Sem PlusMod2_e l) = bs2nat (hd nil l) + mod2 (bs2nat (hd nil (tl l))).
Proof.
unfold mod2.
intros [ | u [ | v l] ].
simpl.
rewrite Cond_correct.
simpl.
destruct v as [ | [ | ] v].

*****
l : list (list bool)
u,v : list bool
*****
eq (bs2nat (Sem Succ_e (cons u nil))) (Init.Nat.add (bs2nat u) (Init.Nat.sub (bs2nat (cons true v)) (Init.Nat.add (Nat.div2 (bs2nat (cons true v))) (Init.Nat.add (Nat.div2 (bs2nat (cons true v))) O))))
+++++
rewrite bs2nat_true.
-----
Lemma PlusMod2_correct : forall l, bs2nat (Sem PlusMod2_e l) = bs2nat (hd nil l) + mod2 (bs2nat (hd nil (tl l))).
Proof.
unfold mod2.
intros [ | u [ | v l] ].
simpl.
rewrite Cond_correct.
simpl.
destruct v as [ | [ | ] v].
rewrite bs2nat_true.

*****
l : list (list bool)
u,v : list bool
*****
eq (bs2nat (Sem Succ_e (cons u nil))) (Init.Nat.add (bs2nat u) (Init.Nat.sub (Init.Nat.add (S O) (Init.Nat.mul (S (S O)) (bs2nat v))) (Init.Nat.add (Nat.div2 (Init.Nat.add (S O) (Init.Nat.mul (S (S O)) (bs2nat v)))) (Init.Nat.add (Nat.div2 (Init.Nat.add (S O) (Init.Nat.mul (S (S O)) (bs2nat v)))) O))))
+++++
rewrite Succ_correct.
-----
Lemma PlusMod2_correct : forall l, bs2nat (Sem PlusMod2_e l) = bs2nat (hd nil l) + mod2 (bs2nat (hd nil (tl l))).
Proof.
unfold mod2.
intros [ | u [ | v l] ].
simpl.
rewrite Cond_correct.
simpl.
destruct v as [ | [ | ] v].
rewrite bs2nat_true.
rewrite Succ_correct.

*****
l : list (list bool)
u,v : list bool
*****
eq (Init.Nat.add (S O) (bs2nat (hd nil (cons u nil)))) (Init.Nat.add (bs2nat u) (Init.Nat.sub (Init.Nat.add (S O) (Init.Nat.mul (S (S O)) (bs2nat v))) (Init.Nat.add (Nat.div2 (Init.Nat.add (S O) (Init.Nat.mul (S (S O)) (bs2nat v)))) (Init.Nat.add (Nat.div2 (Init.Nat.add (S O) (Init.Nat.mul (S (S O)) (bs2nat v)))) O))))
+++++
change (1 + 2 * bs2nat v) with (S (2 * bs2nat v)).
-----
Lemma PlusMod2_correct : forall l, bs2nat (Sem PlusMod2_e l) = bs2nat (hd nil l) + mod2 (bs2nat (hd nil (tl l))).
Proof.
unfold mod2.
intros [ | u [ | v l] ].
simpl.
rewrite Cond_correct.
simpl.
destruct v as [ | [ | ] v].
rewrite bs2nat_true.
rewrite Succ_correct.
change (1 + 2 * bs2nat v) with (S (2 * bs2nat v)).

*****
l : list (list bool)
u,v : list bool
*****
eq (Init.Nat.add (S O) (bs2nat (hd nil (cons u nil)))) (Init.Nat.add (bs2nat u) (Init.Nat.sub (S (Init.Nat.mul (S (S O)) (bs2nat v))) (Init.Nat.add (Nat.div2 (S (Init.Nat.mul (S (S O)) (bs2nat v)))) (Init.Nat.add (Nat.div2 (S (Init.Nat.mul (S (S O)) (bs2nat v)))) O))))
+++++
rewrite div2_double_plus_one.
-----
Lemma PlusMod2_correct : forall l, bs2nat (Sem PlusMod2_e l) = bs2nat (hd nil l) + mod2 (bs2nat (hd nil (tl l))).
Proof.
unfold mod2.
intros [ | u [ | v l] ].
simpl.
rewrite Cond_correct.
simpl.
destruct v as [ | [ | ] v].
rewrite bs2nat_true.
rewrite Succ_correct.
change (1 + 2 * bs2nat v) with (S (2 * bs2nat v)).
rewrite div2_double_plus_one.

*****
l : list (list bool)
u,v : list bool
*****
eq (Init.Nat.add (S O) (bs2nat (hd nil (cons u nil)))) (Init.Nat.add (bs2nat u) (Init.Nat.sub (S (Init.Nat.mul (S (S O)) (bs2nat v))) (Init.Nat.add (bs2nat v) (Init.Nat.add (bs2nat v) O))))
+++++
simpl hd.
-----
Lemma PlusMod2_correct : forall l, bs2nat (Sem PlusMod2_e l) = bs2nat (hd nil l) + mod2 (bs2nat (hd nil (tl l))).
Proof.
unfold mod2.
intros [ | u [ | v l] ].
simpl.
rewrite Cond_correct.
simpl.
destruct v as [ | [ | ] v].
rewrite bs2nat_true.
rewrite Succ_correct.
change (1 + 2 * bs2nat v) with (S (2 * bs2nat v)).
rewrite div2_double_plus_one.
simpl hd.

*****
l : list (list bool)
u,v : list bool
*****
eq (Init.Nat.add (S O) (bs2nat u)) (Init.Nat.add (bs2nat u) (Init.Nat.sub (S (Init.Nat.mul (S (S O)) (bs2nat v))) (Init.Nat.add (bs2nat v) (Init.Nat.add (bs2nat v) O))))
+++++
omega.
-----
Lemma PlusMod2_correct : forall l, bs2nat (Sem PlusMod2_e l) = bs2nat (hd nil l) + mod2 (bs2nat (hd nil (tl l))).
Proof.
unfold mod2.
intros [ | u [ | v l] ].
simpl.
rewrite Cond_correct.
simpl.
destruct v as [ | [ | ] v].

*****
l : list (list bool)
u,v : list bool
*****
eq (bs2nat u) (Init.Nat.add (bs2nat u) (Init.Nat.sub (bs2nat (cons false v)) (Init.Nat.add (Nat.div2 (bs2nat (cons false v))) (Init.Nat.add (Nat.div2 (bs2nat (cons false v))) O))))
+++++
rewrite bs2nat_false.
-----
Lemma PlusMod2_correct : forall l, bs2nat (Sem PlusMod2_e l) = bs2nat (hd nil l) + mod2 (bs2nat (hd nil (tl l))).
Proof.
unfold mod2.
intros [ | u [ | v l] ].
simpl.
rewrite Cond_correct.
simpl.
destruct v as [ | [ | ] v].
rewrite bs2nat_false.

*****
l : list (list bool)
u,v : list bool
*****
eq (bs2nat u) (Init.Nat.add (bs2nat u) (Init.Nat.sub (Init.Nat.mul (S (S O)) (bs2nat v)) (Init.Nat.add (Nat.div2 (Init.Nat.mul (S (S O)) (bs2nat v))) (Init.Nat.add (Nat.div2 (Init.Nat.mul (S (S O)) (bs2nat v))) O))))
+++++
rewrite div2_double.
-----
Lemma PlusMod2_correct : forall l, bs2nat (Sem PlusMod2_e l) = bs2nat (hd nil l) + mod2 (bs2nat (hd nil (tl l))).
Proof.
unfold mod2.
intros [ | u [ | v l] ].
simpl.
rewrite Cond_correct.
simpl.
destruct v as [ | [ | ] v].
rewrite bs2nat_false.
rewrite div2_double.

*****
l : list (list bool)
u,v : list bool
*****
eq (bs2nat u) (Init.Nat.add (bs2nat u) (Init.Nat.sub (Init.Nat.mul (S (S O)) (bs2nat v)) (Init.Nat.add (bs2nat v) (Init.Nat.add (bs2nat v) O))))
+++++
omega.
-----
Lemma PlusMod2_correct : forall l, bs2nat (Sem PlusMod2_e l) = bs2nat (hd nil l) + mod2 (bs2nat (hd nil (tl l))).
Proof.
unfold mod2.
intros [ | u [ | v l] ].

*****

*****

+++++
Qed.
-----
Opaque PlusMod2_e.
-----
Definition PlusOneMinusMod2_e : Cobham :=\n  Comp 3 Cond [\n    Proj 3 2;\n    Proj 3 0;\n    Comp 3 PlusOneMinus_e [Proj 3 0; Proj 3 1];\n    Proj 3 0\n  ].
-----
Lemma arity_PlusOneMinusMod2 :\n  arity PlusOneMinusMod2_e = ok_arity 3.
-----
Lemma arity_PlusOneMinusMod2 : arity PlusOneMinusMod2_e = ok_arity 3.

*****

*****
eq (arity PlusOneMinusMod2_e) (ok_arity (S (S (S O))))
+++++
Proof.
-----
Lemma arity_PlusOneMinusMod2 : arity PlusOneMinusMod2_e = ok_arity 3.
Proof.

*****

*****
eq (arity PlusOneMinusMod2_e) (ok_arity (S (S (S O))))
+++++
trivial.
-----
Lemma arity_PlusOneMinusMod2 : arity PlusOneMinusMod2_e = ok_arity 3.
Proof.
trivial.

*****

*****

+++++
Qed.
-----
Lemma rec_bounded_PlusOneMinusMod2 :\n  rec_bounded PlusOneMinusMod2_e.
-----
Lemma rec_bounded_PlusOneMinusMod2 : rec_bounded PlusOneMinusMod2_e.

*****

*****
rec_bounded PlusOneMinusMod2_e
+++++
Proof.
-----
Lemma rec_bounded_PlusOneMinusMod2 : rec_bounded PlusOneMinusMod2_e.
Proof.

*****

*****
rec_bounded PlusOneMinusMod2_e
+++++
simpl.
-----
Lemma rec_bounded_PlusOneMinusMod2 : rec_bounded PlusOneMinusMod2_e.
Proof.
simpl.

*****

*****
and (rec_bounded Cond) (and True (and True (and (and (rec_bounded PlusOneMinus_e) (and True (and True True))) (and True True))))
+++++
intuition.
-----
Lemma rec_bounded_PlusOneMinusMod2 : rec_bounded PlusOneMinusMod2_e.
Proof.
simpl.
intuition.

*****

*****
rec_bounded Cond
+++++
apply rec_bounded'_spec with 4.
-----
Lemma rec_bounded_PlusOneMinusMod2 : rec_bounded PlusOneMinusMod2_e.
Proof.
simpl.
intuition.
apply rec_bounded'_spec with 4.

*****

*****
eq (arity Cond) (ok_arity (S (S (S (S O)))))
+++++
apply arity_Cond.
-----
Lemma rec_bounded_PlusOneMinusMod2 : rec_bounded PlusOneMinusMod2_e.
Proof.
simpl.
intuition.
apply rec_bounded'_spec with 4.

*****

*****
rec_bounded' Cond
+++++
apply rec_bounded_Cond.
-----
Lemma rec_bounded_PlusOneMinusMod2 : rec_bounded PlusOneMinusMod2_e.
Proof.
simpl.
intuition.

*****

*****
rec_bounded PlusOneMinus_e
+++++
apply rec_bounded_PlusOneMinus.
-----
Lemma rec_bounded_PlusOneMinusMod2 : rec_bounded PlusOneMinusMod2_e.
Proof.
simpl.
intuition.

*****

*****

+++++
Qed.
-----
Lemma PlusOneMinusMod2_correct : forall l,\n  bs2nat (Sem PlusOneMinusMod2_e l) =\n  bs2nat (hd nil l) +\n  (1 - bs2nat (hd nil (tl l))) *\n  mod2 (bs2nat (hd nil (tl (tl l)))).
-----
Lemma PlusOneMinusMod2_correct : forall l, bs2nat (Sem PlusOneMinusMod2_e l) = bs2nat (hd nil l) + (1 - bs2nat (hd nil (tl l))) * mod2 (bs2nat (hd nil (tl (tl l)))).

*****

*****
forall l : list (list bool), eq (bs2nat (Sem PlusOneMinusMod2_e l)) (Init.Nat.add (bs2nat (hd nil l)) (Init.Nat.mul (Init.Nat.sub (S O) (bs2nat (hd nil (tl l)))) (mod2 (bs2nat (hd nil (tl (tl l)))))))
+++++
Proof.
-----
Lemma PlusOneMinusMod2_correct : forall l, bs2nat (Sem PlusOneMinusMod2_e l) = bs2nat (hd nil l) + (1 - bs2nat (hd nil (tl l))) * mod2 (bs2nat (hd nil (tl (tl l)))).
Proof.

*****

*****
forall l : list (list bool), eq (bs2nat (Sem PlusOneMinusMod2_e l)) (Init.Nat.add (bs2nat (hd nil l)) (Init.Nat.mul (Init.Nat.sub (S O) (bs2nat (hd nil (tl l)))) (mod2 (bs2nat (hd nil (tl (tl l)))))))
+++++
unfold mod2.
-----
Lemma PlusOneMinusMod2_correct : forall l, bs2nat (Sem PlusOneMinusMod2_e l) = bs2nat (hd nil l) + (1 - bs2nat (hd nil (tl l))) * mod2 (bs2nat (hd nil (tl (tl l)))).
Proof.
unfold mod2.

*****

*****
forall l : list (list bool), eq (bs2nat (Sem PlusOneMinusMod2_e l)) (Init.Nat.add (bs2nat (hd nil l)) (Init.Nat.mul (Init.Nat.sub (S O) (bs2nat (hd nil (tl l)))) (Init.Nat.sub (bs2nat (hd nil (tl (tl l)))) (Init.Nat.mul (S (S O)) (Nat.div2 (bs2nat (hd nil (tl (tl l)))))))))
+++++
intros [ | u [ | v [ | w l] ] ].
-----
Lemma PlusOneMinusMod2_correct : forall l, bs2nat (Sem PlusOneMinusMod2_e l) = bs2nat (hd nil l) + (1 - bs2nat (hd nil (tl l))) * mod2 (bs2nat (hd nil (tl (tl l)))).
Proof.
unfold mod2.
intros [ | u [ | v [ | w l] ] ].

*****

*****
eq (bs2nat (Sem PlusOneMinusMod2_e nil)) (Init.Nat.add (bs2nat (hd nil nil)) (Init.Nat.mul (Init.Nat.sub (S O) (bs2nat (hd nil (tl nil)))) (Init.Nat.sub (bs2nat (hd nil (tl (tl nil)))) (Init.Nat.mul (S (S O)) (Nat.div2 (bs2nat (hd nil (tl (tl nil)))))))))
+++++
simpl.
-----
Lemma PlusOneMinusMod2_correct : forall l, bs2nat (Sem PlusOneMinusMod2_e l) = bs2nat (hd nil l) + (1 - bs2nat (hd nil (tl l))) * mod2 (bs2nat (hd nil (tl (tl l)))).
Proof.
unfold mod2.
intros [ | u [ | v [ | w l] ] ].
simpl.

*****

*****
eq (bs2nat (Sem Cond (cons nil (cons nil (cons (Sem PlusOneMinus_e (cons nil (cons nil nil))) (cons nil nil)))))) (Init.Nat.add (bs2nat nil) (Init.Nat.mul match bs2nat nil with | O => S O | S _ => O end (Init.Nat.sub (bs2nat nil) (Init.Nat.add (Nat.div2 (bs2nat nil)) (Init.Nat.add (Nat.div2 (bs2nat nil)) O)))))
+++++
trivial.
-----
Lemma PlusOneMinusMod2_correct : forall l, bs2nat (Sem PlusOneMinusMod2_e l) = bs2nat (hd nil l) + (1 - bs2nat (hd nil (tl l))) * mod2 (bs2nat (hd nil (tl (tl l)))).
Proof.
unfold mod2.
intros [ | u [ | v [ | w l] ] ].

*****
u : list bool
*****
eq (bs2nat (Sem PlusOneMinusMod2_e (cons u nil))) (Init.Nat.add (bs2nat (hd nil (cons u nil))) (Init.Nat.mul (Init.Nat.sub (S O) (bs2nat (hd nil (tl (cons u nil))))) (Init.Nat.sub (bs2nat (hd nil (tl (tl (cons u nil))))) (Init.Nat.mul (S (S O)) (Nat.div2 (bs2nat (hd nil (tl (tl (cons u nil))))))))))
+++++
simpl.
-----
Lemma PlusOneMinusMod2_correct : forall l, bs2nat (Sem PlusOneMinusMod2_e l) = bs2nat (hd nil l) + (1 - bs2nat (hd nil (tl l))) * mod2 (bs2nat (hd nil (tl (tl l)))).
Proof.
unfold mod2.
intros [ | u [ | v [ | w l] ] ].
simpl.

*****
u : list bool
*****
eq (bs2nat (Sem Cond (cons nil (cons u (cons (Sem PlusOneMinus_e (cons u (cons nil nil))) (cons u nil)))))) (Init.Nat.add (bs2nat u) (Init.Nat.mul match bs2nat nil with | O => S O | S _ => O end (Init.Nat.sub (bs2nat nil) (Init.Nat.add (Nat.div2 (bs2nat nil)) (Init.Nat.add (Nat.div2 (bs2nat nil)) O)))))
+++++
trivial.
-----
Lemma PlusOneMinusMod2_correct : forall l, bs2nat (Sem PlusOneMinusMod2_e l) = bs2nat (hd nil l) + (1 - bs2nat (hd nil (tl l))) * mod2 (bs2nat (hd nil (tl (tl l)))).
Proof.
unfold mod2.
intros [ | u [ | v [ | w l] ] ].

*****
u,v : list bool
*****
eq (bs2nat (Sem PlusOneMinusMod2_e (cons u (cons v nil)))) (Init.Nat.add (bs2nat (hd nil (cons u (cons v nil)))) (Init.Nat.mul (Init.Nat.sub (S O) (bs2nat (hd nil (tl (cons u (cons v nil)))))) (Init.Nat.sub (bs2nat (hd nil (tl (tl (cons u (cons v nil)))))) (Init.Nat.mul (S (S O)) (Nat.div2 (bs2nat (hd nil (tl (tl (cons u (cons v nil)))))))))))
+++++
simpl.
-----
Lemma PlusOneMinusMod2_correct : forall l, bs2nat (Sem PlusOneMinusMod2_e l) = bs2nat (hd nil l) + (1 - bs2nat (hd nil (tl l))) * mod2 (bs2nat (hd nil (tl (tl l)))).
Proof.
unfold mod2.
intros [ | u [ | v [ | w l] ] ].
simpl.

*****
u,v : list bool
*****
eq (bs2nat (Sem Cond (cons nil (cons u (cons (Sem PlusOneMinus_e (cons u (cons v nil))) (cons u nil)))))) (Init.Nat.add (bs2nat u) (Init.Nat.mul match bs2nat v with | O => S O | S _ => O end (Init.Nat.sub (bs2nat nil) (Init.Nat.add (Nat.div2 (bs2nat nil)) (Init.Nat.add (Nat.div2 (bs2nat nil)) O)))))
+++++
rewrite Cond_correct.
-----
Lemma PlusOneMinusMod2_correct : forall l, bs2nat (Sem PlusOneMinusMod2_e l) = bs2nat (hd nil l) + (1 - bs2nat (hd nil (tl l))) * mod2 (bs2nat (hd nil (tl (tl l)))).
Proof.
unfold mod2.
intros [ | u [ | v [ | w l] ] ].
simpl.
rewrite Cond_correct.

*****
u,v : list bool
*****
eq (bs2nat match hd nil (cons nil (cons u (cons (Sem PlusOneMinus_e (cons u (cons v nil))) (cons u nil)))) with | nil => hd nil (tl (cons nil (cons u (cons (Sem PlusOneMinus_e (cons u (cons v nil))) (cons u nil))))) | cons true _ => hd nil (tl (tl (cons nil (cons u (cons (Sem PlusOneMinus_e (cons u (cons v nil))) (cons u nil)))))) | cons false _ => hd nil (tl (tl (tl (cons nil (cons u (cons (Sem PlusOneMinus_e (cons u (cons v nil))) (cons u nil))))))) end) (Init.Nat.add (bs2nat u) (Init.Nat.mul match bs2nat v with | O => S O | S _ => O end (Init.Nat.sub (bs2nat nil) (Init.Nat.add (Nat.div2 (bs2nat nil)) (Init.Nat.add (Nat.div2 (bs2nat nil)) O)))))
+++++
simpl.
-----
Lemma PlusOneMinusMod2_correct : forall l, bs2nat (Sem PlusOneMinusMod2_e l) = bs2nat (hd nil l) + (1 - bs2nat (hd nil (tl l))) * mod2 (bs2nat (hd nil (tl (tl l)))).
Proof.
unfold mod2.
intros [ | u [ | v [ | w l] ] ].
simpl.
rewrite Cond_correct.
simpl.

*****
u,v : list bool
*****
eq (bs2nat u) (Init.Nat.add (bs2nat u) (Init.Nat.mul match bs2nat v with | O => S O | S _ => O end (Init.Nat.sub (bs2nat nil) (Init.Nat.add (Nat.div2 (bs2nat nil)) (Init.Nat.add (Nat.div2 (bs2nat nil)) O)))))
+++++
rewrite bs2nat_nil.
-----
Lemma PlusOneMinusMod2_correct : forall l, bs2nat (Sem PlusOneMinusMod2_e l) = bs2nat (hd nil l) + (1 - bs2nat (hd nil (tl l))) * mod2 (bs2nat (hd nil (tl (tl l)))).
Proof.
unfold mod2.
intros [ | u [ | v [ | w l] ] ].
simpl.
rewrite Cond_correct.
simpl.
rewrite bs2nat_nil.

*****
u,v : list bool
*****
eq (bs2nat u) (Init.Nat.add (bs2nat u) (Init.Nat.mul match bs2nat v with | O => S O | S _ => O end (Init.Nat.sub O (Init.Nat.add (Nat.div2 O) (Init.Nat.add (Nat.div2 O) O)))))
+++++
simpl.
-----
Lemma PlusOneMinusMod2_correct : forall l, bs2nat (Sem PlusOneMinusMod2_e l) = bs2nat (hd nil l) + (1 - bs2nat (hd nil (tl l))) * mod2 (bs2nat (hd nil (tl (tl l)))).
Proof.
unfold mod2.
intros [ | u [ | v [ | w l] ] ].
simpl.
rewrite Cond_correct.
simpl.
rewrite bs2nat_nil.
simpl.

*****
u,v : list bool
*****
eq (bs2nat u) (Init.Nat.add (bs2nat u) (Init.Nat.mul match bs2nat v with | O => S O | S _ => O end O))
+++++
ring.
-----
Lemma PlusOneMinusMod2_correct : forall l, bs2nat (Sem PlusOneMinusMod2_e l) = bs2nat (hd nil l) + (1 - bs2nat (hd nil (tl l))) * mod2 (bs2nat (hd nil (tl (tl l)))).
Proof.
unfold mod2.
intros [ | u [ | v [ | w l] ] ].

*****
l : list (list bool)
u,v,w : list bool
*****
eq (bs2nat (Sem PlusOneMinusMod2_e (cons u (cons v (cons w l))))) (Init.Nat.add (bs2nat (hd nil (cons u (cons v (cons w l))))) (Init.Nat.mul (Init.Nat.sub (S O) (bs2nat (hd nil (tl (cons u (cons v (cons w l))))))) (Init.Nat.sub (bs2nat (hd nil (tl (tl (cons u (cons v (cons w l))))))) (Init.Nat.mul (S (S O)) (Nat.div2 (bs2nat (hd nil (tl (tl (cons u (cons v (cons w l))))))))))))
+++++
simpl.
-----
Lemma PlusOneMinusMod2_correct : forall l, bs2nat (Sem PlusOneMinusMod2_e l) = bs2nat (hd nil l) + (1 - bs2nat (hd nil (tl l))) * mod2 (bs2nat (hd nil (tl (tl l)))).
Proof.
unfold mod2.
intros [ | u [ | v [ | w l] ] ].
simpl.

*****
l : list (list bool)
u,v,w : list bool
*****
eq (bs2nat (Sem Cond (cons w (cons u (cons (Sem PlusOneMinus_e (cons u (cons v nil))) (cons u nil)))))) (Init.Nat.add (bs2nat u) (Init.Nat.mul match bs2nat v with | O => S O | S _ => O end (Init.Nat.sub (bs2nat w) (Init.Nat.add (Nat.div2 (bs2nat w)) (Init.Nat.add (Nat.div2 (bs2nat w)) O)))))
+++++
rewrite Cond_correct.
-----
Lemma PlusOneMinusMod2_correct : forall l, bs2nat (Sem PlusOneMinusMod2_e l) = bs2nat (hd nil l) + (1 - bs2nat (hd nil (tl l))) * mod2 (bs2nat (hd nil (tl (tl l)))).
Proof.
unfold mod2.
intros [ | u [ | v [ | w l] ] ].
simpl.
rewrite Cond_correct.

*****
l : list (list bool)
u,v,w : list bool
*****
eq (bs2nat match hd nil (cons w (cons u (cons (Sem PlusOneMinus_e (cons u (cons v nil))) (cons u nil)))) with | nil => hd nil (tl (cons w (cons u (cons (Sem PlusOneMinus_e (cons u (cons v nil))) (cons u nil))))) | cons true _ => hd nil (tl (tl (cons w (cons u (cons (Sem PlusOneMinus_e (cons u (cons v nil))) (cons u nil)))))) | cons false _ => hd nil (tl (tl (tl (cons w (cons u (cons (Sem PlusOneMinus_e (cons u (cons v nil))) (cons u nil))))))) end) (Init.Nat.add (bs2nat u) (Init.Nat.mul match bs2nat v with | O => S O | S _ => O end (Init.Nat.sub (bs2nat w) (Init.Nat.add (Nat.div2 (bs2nat w)) (Init.Nat.add (Nat.div2 (bs2nat w)) O)))))
+++++
simpl.
-----
Lemma PlusOneMinusMod2_correct : forall l, bs2nat (Sem PlusOneMinusMod2_e l) = bs2nat (hd nil l) + (1 - bs2nat (hd nil (tl l))) * mod2 (bs2nat (hd nil (tl (tl l)))).
Proof.
unfold mod2.
intros [ | u [ | v [ | w l] ] ].
simpl.
rewrite Cond_correct.
simpl.

*****
l : list (list bool)
u,v,w : list bool
*****
eq (bs2nat match w with | cons true _ => Sem PlusOneMinus_e (cons u (cons v nil)) | _ => u end) (Init.Nat.add (bs2nat u) (Init.Nat.mul match bs2nat v with | O => S O | S _ => O end (Init.Nat.sub (bs2nat w) (Init.Nat.add (Nat.div2 (bs2nat w)) (Init.Nat.add (Nat.div2 (bs2nat w)) O)))))
+++++
destruct w as [ | [ | ] w].
-----
Lemma PlusOneMinusMod2_correct : forall l, bs2nat (Sem PlusOneMinusMod2_e l) = bs2nat (hd nil l) + (1 - bs2nat (hd nil (tl l))) * mod2 (bs2nat (hd nil (tl (tl l)))).
Proof.
unfold mod2.
intros [ | u [ | v [ | w l] ] ].
simpl.
rewrite Cond_correct.
simpl.
destruct w as [ | [ | ] w].

*****
l : list (list bool)
u,v : list bool
*****
eq (bs2nat u) (Init.Nat.add (bs2nat u) (Init.Nat.mul match bs2nat v with | O => S O | S _ => O end (Init.Nat.sub (bs2nat nil) (Init.Nat.add (Nat.div2 (bs2nat nil)) (Init.Nat.add (Nat.div2 (bs2nat nil)) O)))))
+++++
rewrite bs2nat_nil.
-----
Lemma PlusOneMinusMod2_correct : forall l, bs2nat (Sem PlusOneMinusMod2_e l) = bs2nat (hd nil l) + (1 - bs2nat (hd nil (tl l))) * mod2 (bs2nat (hd nil (tl (tl l)))).
Proof.
unfold mod2.
intros [ | u [ | v [ | w l] ] ].
simpl.
rewrite Cond_correct.
simpl.
destruct w as [ | [ | ] w].
rewrite bs2nat_nil.

*****
l : list (list bool)
u,v : list bool
*****
eq (bs2nat u) (Init.Nat.add (bs2nat u) (Init.Nat.mul match bs2nat v with | O => S O | S _ => O end (Init.Nat.sub O (Init.Nat.add (Nat.div2 O) (Init.Nat.add (Nat.div2 O) O)))))
+++++
simpl.
-----
Lemma PlusOneMinusMod2_correct : forall l, bs2nat (Sem PlusOneMinusMod2_e l) = bs2nat (hd nil l) + (1 - bs2nat (hd nil (tl l))) * mod2 (bs2nat (hd nil (tl (tl l)))).
Proof.
unfold mod2.
intros [ | u [ | v [ | w l] ] ].
simpl.
rewrite Cond_correct.
simpl.
destruct w as [ | [ | ] w].
rewrite bs2nat_nil.
simpl.

*****
l : list (list bool)
u,v : list bool
*****
eq (bs2nat u) (Init.Nat.add (bs2nat u) (Init.Nat.mul match bs2nat v with | O => S O | S _ => O end O))
+++++
ring.
-----
Lemma PlusOneMinusMod2_correct : forall l, bs2nat (Sem PlusOneMinusMod2_e l) = bs2nat (hd nil l) + (1 - bs2nat (hd nil (tl l))) * mod2 (bs2nat (hd nil (tl (tl l)))).
Proof.
unfold mod2.
intros [ | u [ | v [ | w l] ] ].
simpl.
rewrite Cond_correct.
simpl.
destruct w as [ | [ | ] w].

*****
l : list (list bool)
u,v,w : list bool
*****
eq (bs2nat (Sem PlusOneMinus_e (cons u (cons v nil)))) (Init.Nat.add (bs2nat u) (Init.Nat.mul match bs2nat v with | O => S O | S _ => O end (Init.Nat.sub (bs2nat (cons true w)) (Init.Nat.add (Nat.div2 (bs2nat (cons true w))) (Init.Nat.add (Nat.div2 (bs2nat (cons true w))) O)))))
+++++
rewrite PlusOneMinus_correct.
-----
Lemma PlusOneMinusMod2_correct : forall l, bs2nat (Sem PlusOneMinusMod2_e l) = bs2nat (hd nil l) + (1 - bs2nat (hd nil (tl l))) * mod2 (bs2nat (hd nil (tl (tl l)))).
Proof.
unfold mod2.
intros [ | u [ | v [ | w l] ] ].
simpl.
rewrite Cond_correct.
simpl.
destruct w as [ | [ | ] w].
rewrite PlusOneMinus_correct.

*****
l : list (list bool)
u,v,w : list bool
*****
eq (Init.Nat.add (bs2nat (hd nil (cons u (cons v nil)))) (Init.Nat.sub (S O) (bs2nat (hd nil (tl (cons u (cons v nil))))))) (Init.Nat.add (bs2nat u) (Init.Nat.mul match bs2nat v with | O => S O | S _ => O end (Init.Nat.sub (bs2nat (cons true w)) (Init.Nat.add (Nat.div2 (bs2nat (cons true w))) (Init.Nat.add (Nat.div2 (bs2nat (cons true w))) O)))))
+++++
simpl.
-----
Lemma PlusOneMinusMod2_correct : forall l, bs2nat (Sem PlusOneMinusMod2_e l) = bs2nat (hd nil l) + (1 - bs2nat (hd nil (tl l))) * mod2 (bs2nat (hd nil (tl (tl l)))).
Proof.
unfold mod2.
intros [ | u [ | v [ | w l] ] ].
simpl.
rewrite Cond_correct.
simpl.
destruct w as [ | [ | ] w].
rewrite PlusOneMinus_correct.
simpl.

*****
l : list (list bool)
u,v,w : list bool
*****
eq (Init.Nat.add (bs2nat u) match bs2nat v with | O => S O | S _ => O end) (Init.Nat.add (bs2nat u) (Init.Nat.mul match bs2nat v with | O => S O | S _ => O end (Init.Nat.sub (bs2nat (cons true w)) (Init.Nat.add (Nat.div2 (bs2nat (cons true w))) (Init.Nat.add (Nat.div2 (bs2nat (cons true w))) O)))))
+++++
rewrite bs2nat_true.
-----
Lemma PlusOneMinusMod2_correct : forall l, bs2nat (Sem PlusOneMinusMod2_e l) = bs2nat (hd nil l) + (1 - bs2nat (hd nil (tl l))) * mod2 (bs2nat (hd nil (tl (tl l)))).
Proof.
unfold mod2.
intros [ | u [ | v [ | w l] ] ].
simpl.
rewrite Cond_correct.
simpl.
destruct w as [ | [ | ] w].
rewrite PlusOneMinus_correct.
simpl.
rewrite bs2nat_true.

*****
l : list (list bool)
u,v,w : list bool
*****
eq (Init.Nat.add (bs2nat u) match bs2nat v with | O => S O | S _ => O end) (Init.Nat.add (bs2nat u) (Init.Nat.mul match bs2nat v with | O => S O | S _ => O end (Init.Nat.sub (Init.Nat.add (S O) (Init.Nat.mul (S (S O)) (bs2nat w))) (Init.Nat.add (Nat.div2 (Init.Nat.add (S O) (Init.Nat.mul (S (S O)) (bs2nat w)))) (Init.Nat.add (Nat.div2 (Init.Nat.add (S O) (Init.Nat.mul (S (S O)) (bs2nat w)))) O)))))
+++++
change (1 + 2 * bs2nat w) with (S (2 * bs2nat w)).
-----
Lemma PlusOneMinusMod2_correct : forall l, bs2nat (Sem PlusOneMinusMod2_e l) = bs2nat (hd nil l) + (1 - bs2nat (hd nil (tl l))) * mod2 (bs2nat (hd nil (tl (tl l)))).
Proof.
unfold mod2.
intros [ | u [ | v [ | w l] ] ].
simpl.
rewrite Cond_correct.
simpl.
destruct w as [ | [ | ] w].
rewrite PlusOneMinus_correct.
simpl.
rewrite bs2nat_true.
change (1 + 2 * bs2nat w) with (S (2 * bs2nat w)).

*****
l : list (list bool)
u,v,w : list bool
*****
eq (Init.Nat.add (bs2nat u) match bs2nat v with | O => S O | S _ => O end) (Init.Nat.add (bs2nat u) (Init.Nat.mul match bs2nat v with | O => S O | S _ => O end (Init.Nat.sub (S (Init.Nat.mul (S (S O)) (bs2nat w))) (Init.Nat.add (Nat.div2 (S (Init.Nat.mul (S (S O)) (bs2nat w)))) (Init.Nat.add (Nat.div2 (S (Init.Nat.mul (S (S O)) (bs2nat w)))) O)))))
+++++
rewrite div2_double_plus_one.
-----
Lemma PlusOneMinusMod2_correct : forall l, bs2nat (Sem PlusOneMinusMod2_e l) = bs2nat (hd nil l) + (1 - bs2nat (hd nil (tl l))) * mod2 (bs2nat (hd nil (tl (tl l)))).
Proof.
unfold mod2.
intros [ | u [ | v [ | w l] ] ].
simpl.
rewrite Cond_correct.
simpl.
destruct w as [ | [ | ] w].
rewrite PlusOneMinus_correct.
simpl.
rewrite bs2nat_true.
change (1 + 2 * bs2nat w) with (S (2 * bs2nat w)).
rewrite div2_double_plus_one.

*****
l : list (list bool)
u,v,w : list bool
*****
eq (Init.Nat.add (bs2nat u) match bs2nat v with | O => S O | S _ => O end) (Init.Nat.add (bs2nat u) (Init.Nat.mul match bs2nat v with | O => S O | S _ => O end (Init.Nat.sub (S (Init.Nat.mul (S (S O)) (bs2nat w))) (Init.Nat.add (bs2nat w) (Init.Nat.add (bs2nat w) O)))))
+++++
case (bs2nat v).
-----
Lemma PlusOneMinusMod2_correct : forall l, bs2nat (Sem PlusOneMinusMod2_e l) = bs2nat (hd nil l) + (1 - bs2nat (hd nil (tl l))) * mod2 (bs2nat (hd nil (tl (tl l)))).
Proof.
unfold mod2.
intros [ | u [ | v [ | w l] ] ].
simpl.
rewrite Cond_correct.
simpl.
destruct w as [ | [ | ] w].
rewrite PlusOneMinus_correct.
simpl.
rewrite bs2nat_true.
change (1 + 2 * bs2nat w) with (S (2 * bs2nat w)).
rewrite div2_double_plus_one.
case (bs2nat v).

*****
l : list (list bool)
u,v,w : list bool
*****
eq (Init.Nat.add (bs2nat u) (S O)) (Init.Nat.add (bs2nat u) (Init.Nat.mul (S O) (Init.Nat.sub (S (Init.Nat.mul (S (S O)) (bs2nat w))) (Init.Nat.add (bs2nat w) (Init.Nat.add (bs2nat w) O)))))
+++++
omega.
-----
Lemma PlusOneMinusMod2_correct : forall l, bs2nat (Sem PlusOneMinusMod2_e l) = bs2nat (hd nil l) + (1 - bs2nat (hd nil (tl l))) * mod2 (bs2nat (hd nil (tl (tl l)))).
Proof.
unfold mod2.
intros [ | u [ | v [ | w l] ] ].
simpl.
rewrite Cond_correct.
simpl.
destruct w as [ | [ | ] w].
rewrite PlusOneMinus_correct.
simpl.
rewrite bs2nat_true.
change (1 + 2 * bs2nat w) with (S (2 * bs2nat w)).
rewrite div2_double_plus_one.
case (bs2nat v).

*****
l : list (list bool)
u,v,w : list bool
*****
forall _ : nat, eq (Init.Nat.add (bs2nat u) O) (Init.Nat.add (bs2nat u) (Init.Nat.mul O (Init.Nat.sub (S (Init.Nat.mul (S (S O)) (bs2nat w))) (Init.Nat.add (bs2nat w) (Init.Nat.add (bs2nat w) O)))))
+++++
trivial.
-----
Lemma PlusOneMinusMod2_correct : forall l, bs2nat (Sem PlusOneMinusMod2_e l) = bs2nat (hd nil l) + (1 - bs2nat (hd nil (tl l))) * mod2 (bs2nat (hd nil (tl (tl l)))).
Proof.
unfold mod2.
intros [ | u [ | v [ | w l] ] ].
simpl.
rewrite Cond_correct.
simpl.
destruct w as [ | [ | ] w].

*****
l : list (list bool)
u,v,w : list bool
*****
eq (bs2nat u) (Init.Nat.add (bs2nat u) (Init.Nat.mul match bs2nat v with | O => S O | S _ => O end (Init.Nat.sub (bs2nat (cons false w)) (Init.Nat.add (Nat.div2 (bs2nat (cons false w))) (Init.Nat.add (Nat.div2 (bs2nat (cons false w))) O)))))
+++++
rewrite bs2nat_false.
-----
Lemma PlusOneMinusMod2_correct : forall l, bs2nat (Sem PlusOneMinusMod2_e l) = bs2nat (hd nil l) + (1 - bs2nat (hd nil (tl l))) * mod2 (bs2nat (hd nil (tl (tl l)))).
Proof.
unfold mod2.
intros [ | u [ | v [ | w l] ] ].
simpl.
rewrite Cond_correct.
simpl.
destruct w as [ | [ | ] w].
rewrite bs2nat_false.

*****
l : list (list bool)
u,v,w : list bool
*****
eq (bs2nat u) (Init.Nat.add (bs2nat u) (Init.Nat.mul match bs2nat v with | O => S O | S _ => O end (Init.Nat.sub (Init.Nat.mul (S (S O)) (bs2nat w)) (Init.Nat.add (Nat.div2 (Init.Nat.mul (S (S O)) (bs2nat w))) (Init.Nat.add (Nat.div2 (Init.Nat.mul (S (S O)) (bs2nat w))) O)))))
+++++
rewrite div2_double.
-----
Lemma PlusOneMinusMod2_correct : forall l, bs2nat (Sem PlusOneMinusMod2_e l) = bs2nat (hd nil l) + (1 - bs2nat (hd nil (tl l))) * mod2 (bs2nat (hd nil (tl (tl l)))).
Proof.
unfold mod2.
intros [ | u [ | v [ | w l] ] ].
simpl.
rewrite Cond_correct.
simpl.
destruct w as [ | [ | ] w].
rewrite bs2nat_false.
rewrite div2_double.

*****
l : list (list bool)
u,v,w : list bool
*****
eq (bs2nat u) (Init.Nat.add (bs2nat u) (Init.Nat.mul match bs2nat v with | O => S O | S _ => O end (Init.Nat.sub (Init.Nat.mul (S (S O)) (bs2nat w)) (Init.Nat.add (bs2nat w) (Init.Nat.add (bs2nat w) O)))))
+++++
case (bs2nat v).
-----
Lemma PlusOneMinusMod2_correct : forall l, bs2nat (Sem PlusOneMinusMod2_e l) = bs2nat (hd nil l) + (1 - bs2nat (hd nil (tl l))) * mod2 (bs2nat (hd nil (tl (tl l)))).
Proof.
unfold mod2.
intros [ | u [ | v [ | w l] ] ].
simpl.
rewrite Cond_correct.
simpl.
destruct w as [ | [ | ] w].
rewrite bs2nat_false.
rewrite div2_double.
case (bs2nat v).

*****
l : list (list bool)
u,v,w : list bool
*****
eq (bs2nat u) (Init.Nat.add (bs2nat u) (Init.Nat.mul (S O) (Init.Nat.sub (Init.Nat.mul (S (S O)) (bs2nat w)) (Init.Nat.add (bs2nat w) (Init.Nat.add (bs2nat w) O)))))
+++++
omega.
-----
Lemma PlusOneMinusMod2_correct : forall l, bs2nat (Sem PlusOneMinusMod2_e l) = bs2nat (hd nil l) + (1 - bs2nat (hd nil (tl l))) * mod2 (bs2nat (hd nil (tl (tl l)))).
Proof.
unfold mod2.
intros [ | u [ | v [ | w l] ] ].
simpl.
rewrite Cond_correct.
simpl.
destruct w as [ | [ | ] w].
rewrite bs2nat_false.
rewrite div2_double.
case (bs2nat v).

*****
l : list (list bool)
u,v,w : list bool
*****
forall _ : nat, eq (bs2nat u) (Init.Nat.add (bs2nat u) (Init.Nat.mul O (Init.Nat.sub (Init.Nat.mul (S (S O)) (bs2nat w)) (Init.Nat.add (bs2nat w) (Init.Nat.add (bs2nat w) O)))))
+++++
trivial.
-----
Lemma PlusOneMinusMod2_correct : forall l, bs2nat (Sem PlusOneMinusMod2_e l) = bs2nat (hd nil l) + (1 - bs2nat (hd nil (tl l))) * mod2 (bs2nat (hd nil (tl (tl l)))).
Proof.
unfold mod2.
intros [ | u [ | v [ | w l] ] ].

*****

*****

+++++
Qed.
-----
Lemma PlusOneMinusMod2_length : forall l,\n  length (Sem PlusOneMinusMod2_e l) <= S (length (hd nil l)).
-----
Lemma PlusOneMinusMod2_length : forall l, length (Sem PlusOneMinusMod2_e l) <= S (length (hd nil l)).

*****

*****
forall l : list (list bool), le (length (Sem PlusOneMinusMod2_e l)) (S (length (hd nil l)))
+++++
Proof.
-----
Lemma PlusOneMinusMod2_length : forall l, length (Sem PlusOneMinusMod2_e l) <= S (length (hd nil l)).
Proof.

*****

*****
forall l : list (list bool), le (length (Sem PlusOneMinusMod2_e l)) (S (length (hd nil l)))
+++++
intros.
-----
Lemma PlusOneMinusMod2_length : forall l, length (Sem PlusOneMinusMod2_e l) <= S (length (hd nil l)).
Proof.
intros.

*****
l : list (list bool)
*****
le (length (Sem PlusOneMinusMod2_e l)) (S (length (hd nil l)))
+++++
simpl.
-----
Lemma PlusOneMinusMod2_length : forall l, length (Sem PlusOneMinusMod2_e l) <= S (length (hd nil l)).
Proof.
intros.
simpl.

*****
l : list (list bool)
*****
le (length (Sem Cond (cons (nth (S (S O)) l nil) (cons (nth O l nil) (cons (Sem PlusOneMinus_e (cons (nth O l nil) (cons (nth (S O) l nil) nil))) (cons (nth O l nil) nil)))))) (S (length (hd nil l)))
+++++
rewrite Cond_correct.
-----
Lemma PlusOneMinusMod2_length : forall l, length (Sem PlusOneMinusMod2_e l) <= S (length (hd nil l)).
Proof.
intros.
simpl.
rewrite Cond_correct.

*****
l : list (list bool)
*****
le (length match hd nil (cons (nth (S (S O)) l nil) (cons (nth O l nil) (cons (Sem PlusOneMinus_e (cons (nth O l nil) (cons (nth (S O) l nil) nil))) (cons (nth O l nil) nil)))) with | nil => hd nil (tl (cons (nth (S (S O)) l nil) (cons (nth O l nil) (cons (Sem PlusOneMinus_e (cons (nth O l nil) (cons (nth (S O) l nil) nil))) (cons (nth O l nil) nil))))) | cons true _ => hd nil (tl (tl (cons (nth (S (S O)) l nil) (cons (nth O l nil) (cons (Sem PlusOneMinus_e (cons (nth O l nil) (cons (nth (S O) l nil) nil))) (cons (nth O l nil) nil)))))) | cons false _ => hd nil (tl (tl (tl (cons (nth (S (S O)) l nil) (cons (nth O l nil) (cons (Sem PlusOneMinus_e (cons (nth O l nil) (cons (nth (S O) l nil) nil))) (cons (nth O l nil) nil))))))) end) (S (length (hd nil l)))
+++++
simpl.
-----
Lemma PlusOneMinusMod2_length : forall l, length (Sem PlusOneMinusMod2_e l) <= S (length (hd nil l)).
Proof.
intros.
simpl.
rewrite Cond_correct.
simpl.

*****
l : list (list bool)
*****
le (length match nth (S (S O)) l nil with | cons true _ => Sem PlusOneMinus_e (cons (nth O l nil) (cons (nth (S O) l nil) nil)) | _ => nth O l nil end) (S (length (hd nil l)))
+++++
rewrite hd_nth_0.
-----
Lemma PlusOneMinusMod2_length : forall l, length (Sem PlusOneMinusMod2_e l) <= S (length (hd nil l)).
Proof.
intros.
simpl.
rewrite Cond_correct.
simpl.
rewrite hd_nth_0.

*****
l : list (list bool)
*****
le (length match nth (S (S O)) l nil with | cons true _ => Sem PlusOneMinus_e (cons (nth O l nil) (cons (nth (S O) l nil) nil)) | _ => nth O l nil end) (S (length (nth O l nil)))
+++++
destruct (nth 2 l nil).
-----
Lemma PlusOneMinusMod2_length : forall l, length (Sem PlusOneMinusMod2_e l) <= S (length (hd nil l)).
Proof.
intros.
simpl.
rewrite Cond_correct.
simpl.
rewrite hd_nth_0.
destruct (nth 2 l nil).

*****
l : list (list bool)
*****
le (length (nth O l nil)) (S (length (nth O l nil)))
+++++
auto.
-----
Lemma PlusOneMinusMod2_length : forall l, length (Sem PlusOneMinusMod2_e l) <= S (length (hd nil l)).
Proof.
intros.
simpl.
rewrite Cond_correct.
simpl.
rewrite hd_nth_0.
destruct (nth 2 l nil).

*****
l0 : list bool
b : bool
l : list (list bool)
*****
le (length (if b then Sem PlusOneMinus_e (cons (nth O l nil) (cons (nth (S O) l nil) nil)) else nth O l nil)) (S (length (nth O l nil)))
+++++
auto.
-----
Lemma PlusOneMinusMod2_length : forall l, length (Sem PlusOneMinusMod2_e l) <= S (length (hd nil l)).
Proof.
intros.
simpl.
rewrite Cond_correct.
simpl.
rewrite hd_nth_0.
destruct (nth 2 l nil).
auto.

*****
l0 : list bool
b : bool
l : list (list bool)
*****
le (length (if b then Sem PlusOneMinus_e (cons (nth O l nil) (cons (nth (S O) l nil) nil)) else nth O l nil)) (S (length (nth O l nil)))
+++++
case b.
-----
Lemma PlusOneMinusMod2_length : forall l, length (Sem PlusOneMinusMod2_e l) <= S (length (hd nil l)).
Proof.
intros.
simpl.
rewrite Cond_correct.
simpl.
rewrite hd_nth_0.
destruct (nth 2 l nil).
auto.
case b.

*****
l0 : list bool
b : bool
l : list (list bool)
*****
le (length (Sem PlusOneMinus_e (cons (nth O l nil) (cons (nth (S O) l nil) nil)))) (S (length (nth O l nil)))
+++++
auto.
-----
Lemma PlusOneMinusMod2_length : forall l, length (Sem PlusOneMinusMod2_e l) <= S (length (hd nil l)).
Proof.
intros.
simpl.
rewrite Cond_correct.
simpl.
rewrite hd_nth_0.
destruct (nth 2 l nil).
auto.
case b.
auto.

*****
l0 : list bool
b : bool
l : list (list bool)
*****
le (length (Sem PlusOneMinus_e (cons (nth O l nil) (cons (nth (S O) l nil) nil)))) (S (length (nth O l nil)))
+++++
apply PlusOneMinus_length.
-----
Lemma PlusOneMinusMod2_length : forall l, length (Sem PlusOneMinusMod2_e l) <= S (length (hd nil l)).
Proof.
intros.
simpl.
rewrite Cond_correct.
simpl.
rewrite hd_nth_0.
destruct (nth 2 l nil).
auto.
case b.

*****
l0 : list bool
b : bool
l : list (list bool)
*****
le (length (nth O l nil)) (S (length (nth O l nil)))
+++++
auto.
-----
Lemma PlusOneMinusMod2_length : forall l, length (Sem PlusOneMinusMod2_e l) <= S (length (hd nil l)).
Proof.
intros.
simpl.
rewrite Cond_correct.
simpl.
rewrite hd_nth_0.
destruct (nth 2 l nil).

*****

*****

+++++
Qed.
-----
Opaque PlusOneMinusMod2_e.
-----
Definition MultTwoPowerLength'_e : Cobham :=\n  Rec2\n    (Proj 1 0)\n    (Comp 3 (Succ false) [Proj 3 1])\n    (Comp 2 Smash [Comp 2 (Succ true) [Proj 2 0]; Comp 2 (Succ true) [Proj 2 1] ] ).
-----
Lemma arity_MultTwoPowerLength' :\n  arity MultTwoPowerLength'_e = ok_arity 2.
-----
Lemma arity_MultTwoPowerLength' : arity MultTwoPowerLength'_e = ok_arity 2.

*****

*****
eq (arity MultTwoPowerLength'_e) (ok_arity (S (S O)))
+++++
Proof.
-----
Lemma arity_MultTwoPowerLength' : arity MultTwoPowerLength'_e = ok_arity 2.
Proof.

*****

*****
eq (arity MultTwoPowerLength'_e) (ok_arity (S (S O)))
+++++
trivial.
-----
Lemma arity_MultTwoPowerLength' : arity MultTwoPowerLength'_e = ok_arity 2.
Proof.
trivial.

*****

*****

+++++
Qed.
-----
Lemma rec_bounded_MultTwoPowerLength' :\n  rec_bounded MultTwoPowerLength'_e.
-----
Lemma rec_bounded_MultTwoPowerLength' : rec_bounded MultTwoPowerLength'_e.

*****

*****
rec_bounded MultTwoPowerLength'_e
+++++
Proof.
-----
Lemma rec_bounded_MultTwoPowerLength' : rec_bounded MultTwoPowerLength'_e.
Proof.

*****

*****
rec_bounded MultTwoPowerLength'_e
+++++
simpl.
-----
Lemma rec_bounded_MultTwoPowerLength' : rec_bounded MultTwoPowerLength'_e.
Proof.
simpl.

*****

*****
and (and True (and (and True (and True True)) (and (and True (and True True)) True))) (and True (and (and True (and True True)) (and (and True (and True True)) (forall l : list (list bool), le (length (sem_Rec (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => cons false (nth (S O) vl nil)) (fun vl : list (list bool) => cons false (nth (S O) vl nil)) (hd nil l) (tl l))) (S (length (smash' (nth (S O) l nil) (smash_bs (nth O l nil) (cons true (nth (S O) l nil))))))))))
+++++
intuition.
-----
Lemma rec_bounded_MultTwoPowerLength' : rec_bounded MultTwoPowerLength'_e.
Proof.
simpl.
intuition.

*****
l : list (list bool)
*****
le (length (sem_Rec (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => cons false (nth (S O) vl nil)) (fun vl : list (list bool) => cons false (nth (S O) vl nil)) (hd nil l) (tl l))) (S (length (smash' (nth (S O) l nil) (smash_bs (nth O l nil) (cons true (nth (S O) l nil))))))
+++++
destruct l as [ | u [ | v l] ].
-----
Lemma rec_bounded_MultTwoPowerLength' : rec_bounded MultTwoPowerLength'_e.
Proof.
simpl.
intuition.
destruct l as [ | u [ | v l] ].

*****

*****
le (length (sem_Rec (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => cons false (nth (S O) vl nil)) (fun vl : list (list bool) => cons false (nth (S O) vl nil)) (hd nil nil) (tl nil))) (S (length (smash' (nth (S O) nil nil) (smash_bs (nth O nil nil) (cons true (nth (S O) nil nil))))))
+++++
simpl.
-----
Lemma rec_bounded_MultTwoPowerLength' : rec_bounded MultTwoPowerLength'_e.
Proof.
simpl.
intuition.
destruct l as [ | u [ | v l] ].
simpl.

*****

*****
le O (S (S O))
+++++
omega.
-----
Lemma rec_bounded_MultTwoPowerLength' : rec_bounded MultTwoPowerLength'_e.
Proof.
simpl.
intuition.
destruct l as [ | u [ | v l] ].

*****
u : list bool
*****
le (length (sem_Rec (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => cons false (nth (S O) vl nil)) (fun vl : list (list bool) => cons false (nth (S O) vl nil)) (hd nil (cons u nil)) (tl (cons u nil)))) (S (length (smash' (nth (S O) (cons u nil) nil) (smash_bs (nth O (cons u nil) nil) (cons true (nth (S O) (cons u nil) nil))))))
+++++
simpl.
-----
Lemma rec_bounded_MultTwoPowerLength' : rec_bounded MultTwoPowerLength'_e.
Proof.
simpl.
intuition.
destruct l as [ | u [ | v l] ].
simpl.

*****
u : list bool
*****
le (length (sem_Rec (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => cons false (nth (S O) vl nil)) (fun vl : list (list bool) => cons false (nth (S O) vl nil)) u nil)) (S (length (smash_bs u (cons true nil))))
+++++
rewrite length_smash.
-----
Lemma rec_bounded_MultTwoPowerLength' : rec_bounded MultTwoPowerLength'_e.
Proof.
simpl.
intuition.
destruct l as [ | u [ | v l] ].
simpl.
rewrite length_smash.

*****
u : list bool
*****
le (length (sem_Rec (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => cons false (nth (S O) vl nil)) (fun vl : list (list bool) => cons false (nth (S O) vl nil)) u nil)) (S (Init.Nat.add (S O) (Init.Nat.mul (length u) (length (cons true nil)))))
+++++
simpl.
-----
Lemma rec_bounded_MultTwoPowerLength' : rec_bounded MultTwoPowerLength'_e.
Proof.
simpl.
intuition.
destruct l as [ | u [ | v l] ].
simpl.
rewrite length_smash.
simpl.

*****
u : list bool
*****
le (length (sem_Rec (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => cons false (nth (S O) vl nil)) (fun vl : list (list bool) => cons false (nth (S O) vl nil)) u nil)) (S (S (Init.Nat.mul (length u) (S O))))
+++++
rewrite mult_1_r.
-----
Lemma rec_bounded_MultTwoPowerLength' : rec_bounded MultTwoPowerLength'_e.
Proof.
simpl.
intuition.
destruct l as [ | u [ | v l] ].
simpl.
rewrite length_smash.
simpl.
rewrite mult_1_r.

*****
u : list bool
*****
le (length (sem_Rec (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => cons false (nth (S O) vl nil)) (fun vl : list (list bool) => cons false (nth (S O) vl nil)) u nil)) (S (S (length u)))
+++++
induction u as [ | [ | ] u IH].
-----
Lemma rec_bounded_MultTwoPowerLength' : rec_bounded MultTwoPowerLength'_e.
Proof.
simpl.
intuition.
destruct l as [ | u [ | v l] ].
simpl.
rewrite length_smash.
simpl.
rewrite mult_1_r.
induction u as [ | [ | ] u IH].

*****

*****
le (length (sem_Rec (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => cons false (nth (S O) vl nil)) (fun vl : list (list bool) => cons false (nth (S O) vl nil)) nil nil)) (S (S (length nil)))
+++++
simpl.
-----
Lemma rec_bounded_MultTwoPowerLength' : rec_bounded MultTwoPowerLength'_e.
Proof.
simpl.
intuition.
destruct l as [ | u [ | v l] ].
simpl.
rewrite length_smash.
simpl.
rewrite mult_1_r.
induction u as [ | [ | ] u IH].
simpl.

*****

*****
le O (S (S O))
+++++
omega.
-----
Lemma rec_bounded_MultTwoPowerLength' : rec_bounded MultTwoPowerLength'_e.
Proof.
simpl.
intuition.
destruct l as [ | u [ | v l] ].
simpl.
rewrite length_smash.
simpl.
rewrite mult_1_r.
induction u as [ | [ | ] u IH].

*****
IH : le\n (length\n (sem_Rec (fun vl : list (list bool) => nth O vl nil)\n (fun vl : list (list bool) => cons false (nth (S O) vl nil))\n (fun vl : list (list bool) => cons false (nth (S O) vl nil)) u\n nil)) (S (S (length u)))
u : list bool
*****
le (length (sem_Rec (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => cons false (nth (S O) vl nil)) (fun vl : list (list bool) => cons false (nth (S O) vl nil)) (cons true u) nil)) (S (S (length (cons true u))))
+++++
simpl.
-----
Lemma rec_bounded_MultTwoPowerLength' : rec_bounded MultTwoPowerLength'_e.
Proof.
simpl.
intuition.
destruct l as [ | u [ | v l] ].
simpl.
rewrite length_smash.
simpl.
rewrite mult_1_r.
induction u as [ | [ | ] u IH].
simpl.

*****
IH : le\n (length\n (sem_Rec (fun vl : list (list bool) => nth O vl nil)\n (fun vl : list (list bool) => cons false (nth (S O) vl nil))\n (fun vl : list (list bool) => cons false (nth (S O) vl nil)) u\n nil)) (S (S (length u)))
u : list bool
*****
le (S (length (sem_Rec (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => cons false (nth (S O) vl nil)) (fun vl : list (list bool) => cons false (nth (S O) vl nil)) u nil))) (S (S (S (length u))))
+++++
omega.
-----
Lemma rec_bounded_MultTwoPowerLength' : rec_bounded MultTwoPowerLength'_e.
Proof.
simpl.
intuition.
destruct l as [ | u [ | v l] ].
simpl.
rewrite length_smash.
simpl.
rewrite mult_1_r.
induction u as [ | [ | ] u IH].

*****
IH : le\n (length\n (sem_Rec (fun vl : list (list bool) => nth O vl nil)\n (fun vl : list (list bool) => cons false (nth (S O) vl nil))\n (fun vl : list (list bool) => cons false (nth (S O) vl nil)) u\n nil)) (S (S (length u)))
u : list bool
*****
le (length (sem_Rec (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => cons false (nth (S O) vl nil)) (fun vl : list (list bool) => cons false (nth (S O) vl nil)) (cons false u) nil)) (S (S (length (cons false u))))
+++++
simpl.
-----
Lemma rec_bounded_MultTwoPowerLength' : rec_bounded MultTwoPowerLength'_e.
Proof.
simpl.
intuition.
destruct l as [ | u [ | v l] ].
simpl.
rewrite length_smash.
simpl.
rewrite mult_1_r.
induction u as [ | [ | ] u IH].
simpl.

*****
IH : le\n (length\n (sem_Rec (fun vl : list (list bool) => nth O vl nil)\n (fun vl : list (list bool) => cons false (nth (S O) vl nil))\n (fun vl : list (list bool) => cons false (nth (S O) vl nil)) u\n nil)) (S (S (length u)))
u : list bool
*****
le (S (length (sem_Rec (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => cons false (nth (S O) vl nil)) (fun vl : list (list bool) => cons false (nth (S O) vl nil)) u nil))) (S (S (S (length u))))
+++++
omega.
-----
Lemma rec_bounded_MultTwoPowerLength' : rec_bounded MultTwoPowerLength'_e.
Proof.
simpl.
intuition.
destruct l as [ | u [ | v l] ].

*****
l : list (list bool)
u,v : list bool
*****
le (length (sem_Rec (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => cons false (nth (S O) vl nil)) (fun vl : list (list bool) => cons false (nth (S O) vl nil)) (hd nil (cons u (cons v l))) (tl (cons u (cons v l))))) (S (length (smash' (nth (S O) (cons u (cons v l)) nil) (smash_bs (nth O (cons u (cons v l)) nil) (cons true (nth (S O) (cons u (cons v l)) nil))))))
+++++
simpl.
-----
Lemma rec_bounded_MultTwoPowerLength' : rec_bounded MultTwoPowerLength'_e.
Proof.
simpl.
intuition.
destruct l as [ | u [ | v l] ].
simpl.

*****
l : list (list bool)
u,v : list bool
*****
le (length (sem_Rec (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => cons false (nth (S O) vl nil)) (fun vl : list (list bool) => cons false (nth (S O) vl nil)) u (cons v l))) (S (length (smash' v (smash_bs u (cons true v)))))
+++++
rewrite length_smash'.
-----
Lemma rec_bounded_MultTwoPowerLength' : rec_bounded MultTwoPowerLength'_e.
Proof.
simpl.
intuition.
destruct l as [ | u [ | v l] ].
simpl.
rewrite length_smash'.

*****
l : list (list bool)
u,v : list bool
*****
le (length (sem_Rec (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => cons false (nth (S O) vl nil)) (fun vl : list (list bool) => cons false (nth (S O) vl nil)) u (cons v l))) (S (Init.Nat.add (length v) (length (smash_bs u (cons true v)))))
+++++
rewrite length_smash.
-----
Lemma rec_bounded_MultTwoPowerLength' : rec_bounded MultTwoPowerLength'_e.
Proof.
simpl.
intuition.
destruct l as [ | u [ | v l] ].
simpl.
rewrite length_smash'.
rewrite length_smash.

*****
l : list (list bool)
u,v : list bool
*****
le (length (sem_Rec (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => cons false (nth (S O) vl nil)) (fun vl : list (list bool) => cons false (nth (S O) vl nil)) u (cons v l))) (S (Init.Nat.add (length v) (Init.Nat.add (S O) (Init.Nat.mul (length u) (length (cons true v))))))
+++++
simpl.
-----
Lemma rec_bounded_MultTwoPowerLength' : rec_bounded MultTwoPowerLength'_e.
Proof.
simpl.
intuition.
destruct l as [ | u [ | v l] ].
simpl.
rewrite length_smash'.
rewrite length_smash.
simpl.

*****
l : list (list bool)
u,v : list bool
*****
le (length (sem_Rec (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => cons false (nth (S O) vl nil)) (fun vl : list (list bool) => cons false (nth (S O) vl nil)) u (cons v l))) (S (Init.Nat.add (length v) (S (Init.Nat.mul (length u) (S (length v))))))
+++++
induction u as [ | [ | ] u IH].
-----
Lemma rec_bounded_MultTwoPowerLength' : rec_bounded MultTwoPowerLength'_e.
Proof.
simpl.
intuition.
destruct l as [ | u [ | v l] ].
simpl.
rewrite length_smash'.
rewrite length_smash.
simpl.
induction u as [ | [ | ] u IH].

*****
l : list (list bool)
v : list bool
*****
le (length (sem_Rec (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => cons false (nth (S O) vl nil)) (fun vl : list (list bool) => cons false (nth (S O) vl nil)) nil (cons v l))) (S (Init.Nat.add (length v) (S (Init.Nat.mul (length nil) (S (length v))))))
+++++
simpl.
-----
Lemma rec_bounded_MultTwoPowerLength' : rec_bounded MultTwoPowerLength'_e.
Proof.
simpl.
intuition.
destruct l as [ | u [ | v l] ].
simpl.
rewrite length_smash'.
rewrite length_smash.
simpl.
induction u as [ | [ | ] u IH].
simpl.

*****
l : list (list bool)
v : list bool
*****
le (length v) (S (Init.Nat.add (length v) (S O)))
+++++
omega.
-----
Lemma rec_bounded_MultTwoPowerLength' : rec_bounded MultTwoPowerLength'_e.
Proof.
simpl.
intuition.
destruct l as [ | u [ | v l] ].
simpl.
rewrite length_smash'.
rewrite length_smash.
simpl.
induction u as [ | [ | ] u IH].

*****
IH : le\n (length\n (sem_Rec (fun vl : list (list bool) => nth O vl nil)\n (fun vl : list (list bool) => cons false (nth (S O) vl nil))\n (fun vl : list (list bool) => cons false (nth (S O) vl nil)) u\n (cons v l)))\n (S\n (Init.Nat.add (length v)\n (S (Init.Nat.mul (length u) (S (length v))))))
l : list (list bool)
u,v : list bool
*****
le (length (sem_Rec (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => cons false (nth (S O) vl nil)) (fun vl : list (list bool) => cons false (nth (S O) vl nil)) (cons true u) (cons v l))) (S (Init.Nat.add (length v) (S (Init.Nat.mul (length (cons true u)) (S (length v))))))
+++++
simpl.
-----
Lemma rec_bounded_MultTwoPowerLength' : rec_bounded MultTwoPowerLength'_e.
Proof.
simpl.
intuition.
destruct l as [ | u [ | v l] ].
simpl.
rewrite length_smash'.
rewrite length_smash.
simpl.
induction u as [ | [ | ] u IH].
simpl.

*****
IH : le\n (length\n (sem_Rec (fun vl : list (list bool) => nth O vl nil)\n (fun vl : list (list bool) => cons false (nth (S O) vl nil))\n (fun vl : list (list bool) => cons false (nth (S O) vl nil)) u\n (cons v l)))\n (S\n (Init.Nat.add (length v)\n (S (Init.Nat.mul (length u) (S (length v))))))
l : list (list bool)
u,v : list bool
*****
le (S (length (sem_Rec (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => cons false (nth (S O) vl nil)) (fun vl : list (list bool) => cons false (nth (S O) vl nil)) u (cons v l)))) (S (Init.Nat.add (length v) (S (S (Init.Nat.add (length v) (Init.Nat.mul (length u) (S (length v))))))))
+++++
omega.
-----
Lemma rec_bounded_MultTwoPowerLength' : rec_bounded MultTwoPowerLength'_e.
Proof.
simpl.
intuition.
destruct l as [ | u [ | v l] ].
simpl.
rewrite length_smash'.
rewrite length_smash.
simpl.
induction u as [ | [ | ] u IH].

*****
IH : le\n (length\n (sem_Rec (fun vl : list (list bool) => nth O vl nil)\n (fun vl : list (list bool) => cons false (nth (S O) vl nil))\n (fun vl : list (list bool) => cons false (nth (S O) vl nil)) u\n (cons v l)))\n (S\n (Init.Nat.add (length v)\n (S (Init.Nat.mul (length u) (S (length v))))))
l : list (list bool)
u,v : list bool
*****
le (length (sem_Rec (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => cons false (nth (S O) vl nil)) (fun vl : list (list bool) => cons false (nth (S O) vl nil)) (cons false u) (cons v l))) (S (Init.Nat.add (length v) (S (Init.Nat.mul (length (cons false u)) (S (length v))))))
+++++
simpl.
-----
Lemma rec_bounded_MultTwoPowerLength' : rec_bounded MultTwoPowerLength'_e.
Proof.
simpl.
intuition.
destruct l as [ | u [ | v l] ].
simpl.
rewrite length_smash'.
rewrite length_smash.
simpl.
induction u as [ | [ | ] u IH].
simpl.

*****
IH : le\n (length\n (sem_Rec (fun vl : list (list bool) => nth O vl nil)\n (fun vl : list (list bool) => cons false (nth (S O) vl nil))\n (fun vl : list (list bool) => cons false (nth (S O) vl nil)) u\n (cons v l)))\n (S\n (Init.Nat.add (length v)\n (S (Init.Nat.mul (length u) (S (length v))))))
l : list (list bool)
u,v : list bool
*****
le (S (length (sem_Rec (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => cons false (nth (S O) vl nil)) (fun vl : list (list bool) => cons false (nth (S O) vl nil)) u (cons v l)))) (S (Init.Nat.add (length v) (S (S (Init.Nat.add (length v) (Init.Nat.mul (length u) (S (length v))))))))
+++++
omega.
-----
Lemma rec_bounded_MultTwoPowerLength' : rec_bounded MultTwoPowerLength'_e.
Proof.
simpl.
intuition.
destruct l as [ | u [ | v l] ].

*****

*****

+++++
Qed.
-----
Lemma MultTwoPowerLength'_correct : forall l,\n  bs2nat (Sem MultTwoPowerLength'_e l) =\n  power 2 (length (hd nil l)) * bs2nat (hd nil (tl l)).
-----
Lemma MultTwoPowerLength'_correct : forall l, bs2nat (Sem MultTwoPowerLength'_e l) = power 2 (length (hd nil l)) * bs2nat (hd nil (tl l)).

*****

*****
forall l : list (list bool), eq (bs2nat (Sem MultTwoPowerLength'_e l)) (Init.Nat.mul (power (S (S O)) (length (hd nil l))) (bs2nat (hd nil (tl l))))
+++++
Proof.
-----
Lemma MultTwoPowerLength'_correct : forall l, bs2nat (Sem MultTwoPowerLength'_e l) = power 2 (length (hd nil l)) * bs2nat (hd nil (tl l)).
Proof.

*****

*****
forall l : list (list bool), eq (bs2nat (Sem MultTwoPowerLength'_e l)) (Init.Nat.mul (power (S (S O)) (length (hd nil l))) (bs2nat (hd nil (tl l))))
+++++
destruct l as [ | u [ | v l] ].
-----
Lemma MultTwoPowerLength'_correct : forall l, bs2nat (Sem MultTwoPowerLength'_e l) = power 2 (length (hd nil l)) * bs2nat (hd nil (tl l)).
Proof.
destruct l as [ | u [ | v l] ].

*****

*****
eq (bs2nat (Sem MultTwoPowerLength'_e nil)) (Init.Nat.mul (power (S (S O)) (length (hd nil nil))) (bs2nat (hd nil (tl nil))))
+++++
trivial.
-----
Lemma MultTwoPowerLength'_correct : forall l, bs2nat (Sem MultTwoPowerLength'_e l) = power 2 (length (hd nil l)) * bs2nat (hd nil (tl l)).
Proof.
destruct l as [ | u [ | v l] ].

*****
u : list bool
*****
eq (bs2nat (Sem MultTwoPowerLength'_e (cons u nil))) (Init.Nat.mul (power (S (S O)) (length (hd nil (cons u nil)))) (bs2nat (hd nil (tl (cons u nil)))))
+++++
simpl.
-----
Lemma MultTwoPowerLength'_correct : forall l, bs2nat (Sem MultTwoPowerLength'_e l) = power 2 (length (hd nil l)) * bs2nat (hd nil (tl l)).
Proof.
destruct l as [ | u [ | v l] ].
simpl.

*****
u : list bool
*****
eq (bs2nat (sem_Rec (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => cons false (nth (S O) vl nil)) (fun vl : list (list bool) => cons false (nth (S O) vl nil)) u nil)) (Init.Nat.mul (power (S (S O)) (length u)) (bs2nat nil))
+++++
rewrite bs2nat_nil.
-----
Lemma MultTwoPowerLength'_correct : forall l, bs2nat (Sem MultTwoPowerLength'_e l) = power 2 (length (hd nil l)) * bs2nat (hd nil (tl l)).
Proof.
destruct l as [ | u [ | v l] ].
simpl.
rewrite bs2nat_nil.

*****
u : list bool
*****
eq (bs2nat (sem_Rec (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => cons false (nth (S O) vl nil)) (fun vl : list (list bool) => cons false (nth (S O) vl nil)) u nil)) (Init.Nat.mul (power (S (S O)) (length u)) O)
+++++
rewrite mult_0_r.
-----
Lemma MultTwoPowerLength'_correct : forall l, bs2nat (Sem MultTwoPowerLength'_e l) = power 2 (length (hd nil l)) * bs2nat (hd nil (tl l)).
Proof.
destruct l as [ | u [ | v l] ].
simpl.
rewrite bs2nat_nil.
rewrite mult_0_r.

*****
u : list bool
*****
eq (bs2nat (sem_Rec (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => cons false (nth (S O) vl nil)) (fun vl : list (list bool) => cons false (nth (S O) vl nil)) u nil)) O
+++++
induction u as [ | [ | ] u IH].
-----
Lemma MultTwoPowerLength'_correct : forall l, bs2nat (Sem MultTwoPowerLength'_e l) = power 2 (length (hd nil l)) * bs2nat (hd nil (tl l)).
Proof.
destruct l as [ | u [ | v l] ].
simpl.
rewrite bs2nat_nil.
rewrite mult_0_r.
induction u as [ | [ | ] u IH].

*****

*****
eq (bs2nat (sem_Rec (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => cons false (nth (S O) vl nil)) (fun vl : list (list bool) => cons false (nth (S O) vl nil)) nil nil)) O
+++++
trivial.
-----
Lemma MultTwoPowerLength'_correct : forall l, bs2nat (Sem MultTwoPowerLength'_e l) = power 2 (length (hd nil l)) * bs2nat (hd nil (tl l)).
Proof.
destruct l as [ | u [ | v l] ].
simpl.
rewrite bs2nat_nil.
rewrite mult_0_r.
induction u as [ | [ | ] u IH].

*****
IH : eq\n (bs2nat\n (sem_Rec (fun vl : list (list bool) => nth O vl nil)\n (fun vl : list (list bool) => cons false (nth (S O) vl nil))\n (fun vl : list (list bool) => cons false (nth (S O) vl nil)) u\n nil)) O
u : list bool
*****
eq (bs2nat (sem_Rec (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => cons false (nth (S O) vl nil)) (fun vl : list (list bool) => cons false (nth (S O) vl nil)) (cons true u) nil)) O
+++++
simpl.
-----
Lemma MultTwoPowerLength'_correct : forall l, bs2nat (Sem MultTwoPowerLength'_e l) = power 2 (length (hd nil l)) * bs2nat (hd nil (tl l)).
Proof.
destruct l as [ | u [ | v l] ].
simpl.
rewrite bs2nat_nil.
rewrite mult_0_r.
induction u as [ | [ | ] u IH].
simpl.

*****
IH : eq\n (bs2nat\n (sem_Rec (fun vl : list (list bool) => nth O vl nil)\n (fun vl : list (list bool) => cons false (nth (S O) vl nil))\n (fun vl : list (list bool) => cons false (nth (S O) vl nil)) u\n nil)) O
u : list bool
*****
eq (bs2nat (cons false (sem_Rec (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => cons false (nth (S O) vl nil)) (fun vl : list (list bool) => cons false (nth (S O) vl nil)) u nil))) O
+++++
rewrite bs2nat_false.
-----
Lemma MultTwoPowerLength'_correct : forall l, bs2nat (Sem MultTwoPowerLength'_e l) = power 2 (length (hd nil l)) * bs2nat (hd nil (tl l)).
Proof.
destruct l as [ | u [ | v l] ].
simpl.
rewrite bs2nat_nil.
rewrite mult_0_r.
induction u as [ | [ | ] u IH].
simpl.
rewrite bs2nat_false.

*****
IH : eq\n (bs2nat\n (sem_Rec (fun vl : list (list bool) => nth O vl nil)\n (fun vl : list (list bool) => cons false (nth (S O) vl nil))\n (fun vl : list (list bool) => cons false (nth (S O) vl nil)) u\n nil)) O
u : list bool
*****
eq (Init.Nat.mul (S (S O)) (bs2nat (sem_Rec (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => cons false (nth (S O) vl nil)) (fun vl : list (list bool) => cons false (nth (S O) vl nil)) u nil))) O
+++++
omega.
-----
Lemma MultTwoPowerLength'_correct : forall l, bs2nat (Sem MultTwoPowerLength'_e l) = power 2 (length (hd nil l)) * bs2nat (hd nil (tl l)).
Proof.
destruct l as [ | u [ | v l] ].
simpl.
rewrite bs2nat_nil.
rewrite mult_0_r.
induction u as [ | [ | ] u IH].

*****
IH : eq\n (bs2nat\n (sem_Rec (fun vl : list (list bool) => nth O vl nil)\n (fun vl : list (list bool) => cons false (nth (S O) vl nil))\n (fun vl : list (list bool) => cons false (nth (S O) vl nil)) u\n nil)) O
u : list bool
*****
eq (bs2nat (sem_Rec (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => cons false (nth (S O) vl nil)) (fun vl : list (list bool) => cons false (nth (S O) vl nil)) (cons false u) nil)) O
+++++
simpl.
-----
Lemma MultTwoPowerLength'_correct : forall l, bs2nat (Sem MultTwoPowerLength'_e l) = power 2 (length (hd nil l)) * bs2nat (hd nil (tl l)).
Proof.
destruct l as [ | u [ | v l] ].
simpl.
rewrite bs2nat_nil.
rewrite mult_0_r.
induction u as [ | [ | ] u IH].
simpl.

*****
IH : eq\n (bs2nat\n (sem_Rec (fun vl : list (list bool) => nth O vl nil)\n (fun vl : list (list bool) => cons false (nth (S O) vl nil))\n (fun vl : list (list bool) => cons false (nth (S O) vl nil)) u\n nil)) O
u : list bool
*****
eq (bs2nat (cons false (sem_Rec (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => cons false (nth (S O) vl nil)) (fun vl : list (list bool) => cons false (nth (S O) vl nil)) u nil))) O
+++++
rewrite bs2nat_false.
-----
Lemma MultTwoPowerLength'_correct : forall l, bs2nat (Sem MultTwoPowerLength'_e l) = power 2 (length (hd nil l)) * bs2nat (hd nil (tl l)).
Proof.
destruct l as [ | u [ | v l] ].
simpl.
rewrite bs2nat_nil.
rewrite mult_0_r.
induction u as [ | [ | ] u IH].
simpl.
rewrite bs2nat_false.

*****
IH : eq\n (bs2nat\n (sem_Rec (fun vl : list (list bool) => nth O vl nil)\n (fun vl : list (list bool) => cons false (nth (S O) vl nil))\n (fun vl : list (list bool) => cons false (nth (S O) vl nil)) u\n nil)) O
u : list bool
*****
eq (Init.Nat.mul (S (S O)) (bs2nat (sem_Rec (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => cons false (nth (S O) vl nil)) (fun vl : list (list bool) => cons false (nth (S O) vl nil)) u nil))) O
+++++
omega.
-----
Lemma MultTwoPowerLength'_correct : forall l, bs2nat (Sem MultTwoPowerLength'_e l) = power 2 (length (hd nil l)) * bs2nat (hd nil (tl l)).
Proof.
destruct l as [ | u [ | v l] ].

*****
l : list (list bool)
u,v : list bool
*****
eq (bs2nat (Sem MultTwoPowerLength'_e (cons u (cons v l)))) (Init.Nat.mul (power (S (S O)) (length (hd nil (cons u (cons v l))))) (bs2nat (hd nil (tl (cons u (cons v l))))))
+++++
induction u as [ | [ | ] u IH].
-----
Lemma MultTwoPowerLength'_correct : forall l, bs2nat (Sem MultTwoPowerLength'_e l) = power 2 (length (hd nil l)) * bs2nat (hd nil (tl l)).
Proof.
destruct l as [ | u [ | v l] ].
induction u as [ | [ | ] u IH].

*****
l : list (list bool)
v : list bool
*****
eq (bs2nat (Sem MultTwoPowerLength'_e (cons nil (cons v l)))) (Init.Nat.mul (power (S (S O)) (length (hd nil (cons nil (cons v l))))) (bs2nat (hd nil (tl (cons nil (cons v l))))))
+++++
simpl in *.
-----
Lemma MultTwoPowerLength'_correct : forall l, bs2nat (Sem MultTwoPowerLength'_e l) = power 2 (length (hd nil l)) * bs2nat (hd nil (tl l)).
Proof.
destruct l as [ | u [ | v l] ].
induction u as [ | [ | ] u IH].
simpl in *.

*****
l : list (list bool)
v : list bool
*****
eq (bs2nat v) (Init.Nat.add (bs2nat v) O)
+++++
trivial.
-----
Lemma MultTwoPowerLength'_correct : forall l, bs2nat (Sem MultTwoPowerLength'_e l) = power 2 (length (hd nil l)) * bs2nat (hd nil (tl l)).
Proof.
destruct l as [ | u [ | v l] ].
induction u as [ | [ | ] u IH].

*****
IH : eq (bs2nat (Sem MultTwoPowerLength'_e (cons u (cons v l))))\n (Init.Nat.mul (power (S (S O)) (length (hd nil (cons u (cons v l)))))\n (bs2nat (hd nil (tl (cons u (cons v l))))))
l : list (list bool)
u,v : list bool
*****
eq (bs2nat (Sem MultTwoPowerLength'_e (cons (cons true u) (cons v l)))) (Init.Nat.mul (power (S (S O)) (length (hd nil (cons (cons true u) (cons v l))))) (bs2nat (hd nil (tl (cons (cons true u) (cons v l))))))
+++++
simpl in *.
-----
Lemma MultTwoPowerLength'_correct : forall l, bs2nat (Sem MultTwoPowerLength'_e l) = power 2 (length (hd nil l)) * bs2nat (hd nil (tl l)).
Proof.
destruct l as [ | u [ | v l] ].
induction u as [ | [ | ] u IH].
simpl in *.

*****
IH : eq\n (bs2nat\n (sem_Rec (fun vl : list (list bool) => nth O vl nil)\n (fun vl : list (list bool) => cons false (nth (S O) vl nil))\n (fun vl : list (list bool) => cons false (nth (S O) vl nil)) u\n (cons v l)))\n (Init.Nat.mul (power (S (S O)) (length u)) (bs2nat v))
l : list (list bool)
u,v : list bool
*****
eq (bs2nat (cons false (sem_Rec (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => cons false (nth (S O) vl nil)) (fun vl : list (list bool) => cons false (nth (S O) vl nil)) u (cons v l)))) (Init.Nat.mul (Init.Nat.add (power (S (S O)) (length u)) (Init.Nat.add (power (S (S O)) (length u)) O)) (bs2nat v))
+++++
rewrite bs2nat_false.
-----
Lemma MultTwoPowerLength'_correct : forall l, bs2nat (Sem MultTwoPowerLength'_e l) = power 2 (length (hd nil l)) * bs2nat (hd nil (tl l)).
Proof.
destruct l as [ | u [ | v l] ].
induction u as [ | [ | ] u IH].
simpl in *.
rewrite bs2nat_false.

*****
IH : eq\n (bs2nat\n (sem_Rec (fun vl : list (list bool) => nth O vl nil)\n (fun vl : list (list bool) => cons false (nth (S O) vl nil))\n (fun vl : list (list bool) => cons false (nth (S O) vl nil)) u\n (cons v l)))\n (Init.Nat.mul (power (S (S O)) (length u)) (bs2nat v))
l : list (list bool)
u,v : list bool
*****
eq (Init.Nat.mul (S (S O)) (bs2nat (sem_Rec (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => cons false (nth (S O) vl nil)) (fun vl : list (list bool) => cons false (nth (S O) vl nil)) u (cons v l)))) (Init.Nat.mul (Init.Nat.add (power (S (S O)) (length u)) (Init.Nat.add (power (S (S O)) (length u)) O)) (bs2nat v))
+++++
rewrite plus_0_r.
-----
Lemma MultTwoPowerLength'_correct : forall l, bs2nat (Sem MultTwoPowerLength'_e l) = power 2 (length (hd nil l)) * bs2nat (hd nil (tl l)).
Proof.
destruct l as [ | u [ | v l] ].
induction u as [ | [ | ] u IH].
simpl in *.
rewrite bs2nat_false.
rewrite plus_0_r.

*****
IH : eq\n (bs2nat\n (sem_Rec (fun vl : list (list bool) => nth O vl nil)\n (fun vl : list (list bool) => cons false (nth (S O) vl nil))\n (fun vl : list (list bool) => cons false (nth (S O) vl nil)) u\n (cons v l)))\n (Init.Nat.mul (power (S (S O)) (length u)) (bs2nat v))
l : list (list bool)
u,v : list bool
*****
eq (Init.Nat.mul (S (S O)) (bs2nat (sem_Rec (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => cons false (nth (S O) vl nil)) (fun vl : list (list bool) => cons false (nth (S O) vl nil)) u (cons v l)))) (Init.Nat.mul (Init.Nat.add (power (S (S O)) (length u)) (power (S (S O)) (length u))) (bs2nat v))
+++++
rewrite IH.
-----
Lemma MultTwoPowerLength'_correct : forall l, bs2nat (Sem MultTwoPowerLength'_e l) = power 2 (length (hd nil l)) * bs2nat (hd nil (tl l)).
Proof.
destruct l as [ | u [ | v l] ].
induction u as [ | [ | ] u IH].
simpl in *.
rewrite bs2nat_false.
rewrite plus_0_r.
rewrite IH.

*****
IH : eq\n (bs2nat\n (sem_Rec (fun vl : list (list bool) => nth O vl nil)\n (fun vl : list (list bool) => cons false (nth (S O) vl nil))\n (fun vl : list (list bool) => cons false (nth (S O) vl nil)) u\n (cons v l)))\n (Init.Nat.mul (power (S (S O)) (length u)) (bs2nat v))
l : list (list bool)
u,v : list bool
*****
eq (Init.Nat.mul (S (S O)) (Init.Nat.mul (power (S (S O)) (length u)) (bs2nat v))) (Init.Nat.mul (Init.Nat.add (power (S (S O)) (length u)) (power (S (S O)) (length u))) (bs2nat v))
+++++
ring.
-----
Lemma MultTwoPowerLength'_correct : forall l, bs2nat (Sem MultTwoPowerLength'_e l) = power 2 (length (hd nil l)) * bs2nat (hd nil (tl l)).
Proof.
destruct l as [ | u [ | v l] ].
induction u as [ | [ | ] u IH].

*****
IH : eq (bs2nat (Sem MultTwoPowerLength'_e (cons u (cons v l))))\n (Init.Nat.mul (power (S (S O)) (length (hd nil (cons u (cons v l)))))\n (bs2nat (hd nil (tl (cons u (cons v l))))))
l : list (list bool)
u,v : list bool
*****
eq (bs2nat (Sem MultTwoPowerLength'_e (cons (cons false u) (cons v l)))) (Init.Nat.mul (power (S (S O)) (length (hd nil (cons (cons false u) (cons v l))))) (bs2nat (hd nil (tl (cons (cons false u) (cons v l))))))
+++++
simpl in *.
-----
Lemma MultTwoPowerLength'_correct : forall l, bs2nat (Sem MultTwoPowerLength'_e l) = power 2 (length (hd nil l)) * bs2nat (hd nil (tl l)).
Proof.
destruct l as [ | u [ | v l] ].
induction u as [ | [ | ] u IH].
simpl in *.

*****
IH : eq\n (bs2nat\n (sem_Rec (fun vl : list (list bool) => nth O vl nil)\n (fun vl : list (list bool) => cons false (nth (S O) vl nil))\n (fun vl : list (list bool) => cons false (nth (S O) vl nil)) u\n (cons v l)))\n (Init.Nat.mul (power (S (S O)) (length u)) (bs2nat v))
l : list (list bool)
u,v : list bool
*****
eq (bs2nat (cons false (sem_Rec (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => cons false (nth (S O) vl nil)) (fun vl : list (list bool) => cons false (nth (S O) vl nil)) u (cons v l)))) (Init.Nat.mul (Init.Nat.add (power (S (S O)) (length u)) (Init.Nat.add (power (S (S O)) (length u)) O)) (bs2nat v))
+++++
rewrite bs2nat_false.
-----
Lemma MultTwoPowerLength'_correct : forall l, bs2nat (Sem MultTwoPowerLength'_e l) = power 2 (length (hd nil l)) * bs2nat (hd nil (tl l)).
Proof.
destruct l as [ | u [ | v l] ].
induction u as [ | [ | ] u IH].
simpl in *.
rewrite bs2nat_false.

*****
IH : eq\n (bs2nat\n (sem_Rec (fun vl : list (list bool) => nth O vl nil)\n (fun vl : list (list bool) => cons false (nth (S O) vl nil))\n (fun vl : list (list bool) => cons false (nth (S O) vl nil)) u\n (cons v l)))\n (Init.Nat.mul (power (S (S O)) (length u)) (bs2nat v))
l : list (list bool)
u,v : list bool
*****
eq (Init.Nat.mul (S (S O)) (bs2nat (sem_Rec (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => cons false (nth (S O) vl nil)) (fun vl : list (list bool) => cons false (nth (S O) vl nil)) u (cons v l)))) (Init.Nat.mul (Init.Nat.add (power (S (S O)) (length u)) (Init.Nat.add (power (S (S O)) (length u)) O)) (bs2nat v))
+++++
rewrite plus_0_r.
-----
Lemma MultTwoPowerLength'_correct : forall l, bs2nat (Sem MultTwoPowerLength'_e l) = power 2 (length (hd nil l)) * bs2nat (hd nil (tl l)).
Proof.
destruct l as [ | u [ | v l] ].
induction u as [ | [ | ] u IH].
simpl in *.
rewrite bs2nat_false.
rewrite plus_0_r.

*****
IH : eq\n (bs2nat\n (sem_Rec (fun vl : list (list bool) => nth O vl nil)\n (fun vl : list (list bool) => cons false (nth (S O) vl nil))\n (fun vl : list (list bool) => cons false (nth (S O) vl nil)) u\n (cons v l)))\n (Init.Nat.mul (power (S (S O)) (length u)) (bs2nat v))
l : list (list bool)
u,v : list bool
*****
eq (Init.Nat.mul (S (S O)) (bs2nat (sem_Rec (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => cons false (nth (S O) vl nil)) (fun vl : list (list bool) => cons false (nth (S O) vl nil)) u (cons v l)))) (Init.Nat.mul (Init.Nat.add (power (S (S O)) (length u)) (power (S (S O)) (length u))) (bs2nat v))
+++++
rewrite IH.
-----
Lemma MultTwoPowerLength'_correct : forall l, bs2nat (Sem MultTwoPowerLength'_e l) = power 2 (length (hd nil l)) * bs2nat (hd nil (tl l)).
Proof.
destruct l as [ | u [ | v l] ].
induction u as [ | [ | ] u IH].
simpl in *.
rewrite bs2nat_false.
rewrite plus_0_r.
rewrite IH.

*****
IH : eq\n (bs2nat\n (sem_Rec (fun vl : list (list bool) => nth O vl nil)\n (fun vl : list (list bool) => cons false (nth (S O) vl nil))\n (fun vl : list (list bool) => cons false (nth (S O) vl nil)) u\n (cons v l)))\n (Init.Nat.mul (power (S (S O)) (length u)) (bs2nat v))
l : list (list bool)
u,v : list bool
*****
eq (Init.Nat.mul (S (S O)) (Init.Nat.mul (power (S (S O)) (length u)) (bs2nat v))) (Init.Nat.mul (Init.Nat.add (power (S (S O)) (length u)) (power (S (S O)) (length u))) (bs2nat v))
+++++
ring.
-----
Lemma MultTwoPowerLength'_correct : forall l, bs2nat (Sem MultTwoPowerLength'_e l) = power 2 (length (hd nil l)) * bs2nat (hd nil (tl l)).
Proof.
destruct l as [ | u [ | v l] ].

*****

*****

+++++
Qed.
-----
Opaque MultTwoPowerLength'_e.
-----
Definition MultTwoPowerLength_e : Cobham :=\n  Comp 2 MultTwoPowerLength'_e [Proj 2 1; Proj 2 0].
-----
Lemma arity_MultTwoPowerLength :\n  arity MultTwoPowerLength_e = ok_arity 2.
-----
Lemma arity_MultTwoPowerLength : arity MultTwoPowerLength_e = ok_arity 2.

*****

*****
eq (arity MultTwoPowerLength_e) (ok_arity (S (S O)))
+++++
Proof.
-----
Lemma arity_MultTwoPowerLength : arity MultTwoPowerLength_e = ok_arity 2.
Proof.

*****

*****
eq (arity MultTwoPowerLength_e) (ok_arity (S (S O)))
+++++
trivial.
-----
Lemma arity_MultTwoPowerLength : arity MultTwoPowerLength_e = ok_arity 2.
Proof.
trivial.

*****

*****

+++++
Qed.
-----
Lemma rec_bounded_MultTwoPowerLength :\n  rec_bounded MultTwoPowerLength_e.
-----
Lemma rec_bounded_MultTwoPowerLength : rec_bounded MultTwoPowerLength_e.

*****

*****
rec_bounded MultTwoPowerLength_e
+++++
Proof.
-----
Lemma rec_bounded_MultTwoPowerLength : rec_bounded MultTwoPowerLength_e.
Proof.

*****

*****
rec_bounded MultTwoPowerLength_e
+++++
simpl.
-----
Lemma rec_bounded_MultTwoPowerLength : rec_bounded MultTwoPowerLength_e.
Proof.
simpl.

*****

*****
and (rec_bounded MultTwoPowerLength'_e) (and True (and True True))
+++++
intuition.
-----
Lemma rec_bounded_MultTwoPowerLength : rec_bounded MultTwoPowerLength_e.
Proof.
simpl.
intuition.

*****

*****
rec_bounded MultTwoPowerLength'_e
+++++
apply rec_bounded_MultTwoPowerLength'.
-----
Lemma rec_bounded_MultTwoPowerLength : rec_bounded MultTwoPowerLength_e.
Proof.
simpl.
intuition.
apply rec_bounded_MultTwoPowerLength'.

*****

*****

+++++
Qed.
-----
Lemma MultTwoPowerLength_correct : forall l,\n  bs2nat (Sem MultTwoPowerLength_e l) =\n  bs2nat (hd nil l) * power 2 (length (hd nil (tl l))).
-----
Lemma MultTwoPowerLength_correct : forall l, bs2nat (Sem MultTwoPowerLength_e l) = bs2nat (hd nil l) * power 2 (length (hd nil (tl l))).

*****

*****
forall l : list (list bool), eq (bs2nat (Sem MultTwoPowerLength_e l)) (Init.Nat.mul (bs2nat (hd nil l)) (power (S (S O)) (length (hd nil (tl l)))))
+++++
Proof.
-----
Lemma MultTwoPowerLength_correct : forall l, bs2nat (Sem MultTwoPowerLength_e l) = bs2nat (hd nil l) * power 2 (length (hd nil (tl l))).
Proof.

*****

*****
forall l : list (list bool), eq (bs2nat (Sem MultTwoPowerLength_e l)) (Init.Nat.mul (bs2nat (hd nil l)) (power (S (S O)) (length (hd nil (tl l)))))
+++++
intro l.
-----
Lemma MultTwoPowerLength_correct : forall l, bs2nat (Sem MultTwoPowerLength_e l) = bs2nat (hd nil l) * power 2 (length (hd nil (tl l))).
Proof.
intro l.

*****
l : list (list bool)
*****
eq (bs2nat (Sem MultTwoPowerLength_e l)) (Init.Nat.mul (bs2nat (hd nil l)) (power (S (S O)) (length (hd nil (tl l)))))
+++++
simpl.
-----
Lemma MultTwoPowerLength_correct : forall l, bs2nat (Sem MultTwoPowerLength_e l) = bs2nat (hd nil l) * power 2 (length (hd nil (tl l))).
Proof.
intro l.
simpl.

*****
l : list (list bool)
*****
eq (bs2nat (Sem MultTwoPowerLength'_e (cons (nth (S O) l nil) (cons (nth O l nil) nil)))) (Init.Nat.mul (bs2nat (hd nil l)) (power (S (S O)) (length (hd nil (tl l)))))
+++++
rewrite MultTwoPowerLength'_correct.
-----
Lemma MultTwoPowerLength_correct : forall l, bs2nat (Sem MultTwoPowerLength_e l) = bs2nat (hd nil l) * power 2 (length (hd nil (tl l))).
Proof.
intro l.
simpl.
rewrite MultTwoPowerLength'_correct.

*****
l : list (list bool)
*****
eq (Init.Nat.mul (power (S (S O)) (length (hd nil (cons (nth (S O) l nil) (cons (nth O l nil) nil))))) (bs2nat (hd nil (tl (cons (nth (S O) l nil) (cons (nth O l nil) nil)))))) (Init.Nat.mul (bs2nat (hd nil l)) (power (S (S O)) (length (hd nil (tl l)))))
+++++
simpl.
-----
Lemma MultTwoPowerLength_correct : forall l, bs2nat (Sem MultTwoPowerLength_e l) = bs2nat (hd nil l) * power 2 (length (hd nil (tl l))).
Proof.
intro l.
simpl.
rewrite MultTwoPowerLength'_correct.
simpl.

*****
l : list (list bool)
*****
eq (Init.Nat.mul (power (S (S O)) (length (nth (S O) l nil))) (bs2nat (nth O l nil))) (Init.Nat.mul (bs2nat (hd nil l)) (power (S (S O)) (length (hd nil (tl l)))))
+++++
rewrite hd_nth_0.
-----
Lemma MultTwoPowerLength_correct : forall l, bs2nat (Sem MultTwoPowerLength_e l) = bs2nat (hd nil l) * power 2 (length (hd nil (tl l))).
Proof.
intro l.
simpl.
rewrite MultTwoPowerLength'_correct.
simpl.
rewrite hd_nth_0.

*****
l : list (list bool)
*****
eq (Init.Nat.mul (power (S (S O)) (length (nth (S O) l nil))) (bs2nat (nth O l nil))) (Init.Nat.mul (bs2nat (nth O l nil)) (power (S (S O)) (length (hd nil (tl l)))))
+++++
rewrite hd_nth_1.
-----
Lemma MultTwoPowerLength_correct : forall l, bs2nat (Sem MultTwoPowerLength_e l) = bs2nat (hd nil l) * power 2 (length (hd nil (tl l))).
Proof.
intro l.
simpl.
rewrite MultTwoPowerLength'_correct.
simpl.
rewrite hd_nth_0.
rewrite hd_nth_1.

*****
l : list (list bool)
*****
eq (Init.Nat.mul (power (S (S O)) (length (nth (S O) l nil))) (bs2nat (nth O l nil))) (Init.Nat.mul (bs2nat (nth O l nil)) (power (S (S O)) (length (nth (S O) l nil))))
+++++
ring.
-----
Lemma MultTwoPowerLength_correct : forall l, bs2nat (Sem MultTwoPowerLength_e l) = bs2nat (hd nil l) * power 2 (length (hd nil (tl l))).
Proof.
intro l.
simpl.
rewrite MultTwoPowerLength'_correct.
simpl.
rewrite hd_nth_0.
rewrite hd_nth_1.
ring.

*****

*****

+++++
Qed.
-----
Opaque MultTwoPowerLength_e.
-----
Definition DivTwoPower'_e : Cobham :=\n  Rec2\n    (Proj 1 0)\n    (Comp 3 Div2_e [Proj 3 1])\n    (Proj 2 1).
-----
Lemma arity_DivTwoPower' :\n  arity DivTwoPower'_e = ok_arity 2.
-----
Lemma arity_DivTwoPower' : arity DivTwoPower'_e = ok_arity 2.

*****

*****
eq (arity DivTwoPower'_e) (ok_arity (S (S O)))
+++++
Proof.
-----
Lemma arity_DivTwoPower' : arity DivTwoPower'_e = ok_arity 2.
Proof.

*****

*****
eq (arity DivTwoPower'_e) (ok_arity (S (S O)))
+++++
trivial.
-----
Lemma arity_DivTwoPower' : arity DivTwoPower'_e = ok_arity 2.
Proof.
trivial.

*****

*****

+++++
Qed.
-----
Lemma length_DivTwoPower' : forall l,\n  length (Sem DivTwoPower'_e l) = length (hd nil (tl l)) - length (hd nil l).
-----
Lemma length_DivTwoPower' : forall l, length (Sem DivTwoPower'_e l) = length (hd nil (tl l)) - length (hd nil l).

*****

*****
forall l : list (list bool), eq (length (Sem DivTwoPower'_e l)) (Init.Nat.sub (length (hd nil (tl l))) (length (hd nil l)))
+++++
Proof.
-----
Lemma length_DivTwoPower' : forall l, length (Sem DivTwoPower'_e l) = length (hd nil (tl l)) - length (hd nil l).
Proof.

*****

*****
forall l : list (list bool), eq (length (Sem DivTwoPower'_e l)) (Init.Nat.sub (length (hd nil (tl l))) (length (hd nil l)))
+++++
intros [ | u [ | v l] ].
-----
Lemma length_DivTwoPower' : forall l, length (Sem DivTwoPower'_e l) = length (hd nil (tl l)) - length (hd nil l).
Proof.
intros [ | u [ | v l] ].

*****

*****
eq (length (Sem DivTwoPower'_e nil)) (Init.Nat.sub (length (hd nil (tl nil))) (length (hd nil nil)))
+++++
trivial.
-----
Lemma length_DivTwoPower' : forall l, length (Sem DivTwoPower'_e l) = length (hd nil (tl l)) - length (hd nil l).
Proof.
intros [ | u [ | v l] ].

*****
u : list bool
*****
eq (length (Sem DivTwoPower'_e (cons u nil))) (Init.Nat.sub (length (hd nil (tl (cons u nil)))) (length (hd nil (cons u nil))))
+++++
simpl.
-----
Lemma length_DivTwoPower' : forall l, length (Sem DivTwoPower'_e l) = length (hd nil (tl l)) - length (hd nil l).
Proof.
intros [ | u [ | v l] ].
simpl.

*****
u : list bool
*****
eq (length (sem_Rec (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => Sem Div2_e (cons (nth (S O) vl nil) nil)) (fun vl : list (list bool) => Sem Div2_e (cons (nth (S O) vl nil) nil)) u nil)) O
+++++
induction u as [ | [ | ] u IH].
-----
Lemma length_DivTwoPower' : forall l, length (Sem DivTwoPower'_e l) = length (hd nil (tl l)) - length (hd nil l).
Proof.
intros [ | u [ | v l] ].
simpl.
induction u as [ | [ | ] u IH].

*****

*****
eq (length (sem_Rec (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => Sem Div2_e (cons (nth (S O) vl nil) nil)) (fun vl : list (list bool) => Sem Div2_e (cons (nth (S O) vl nil) nil)) nil nil)) O
+++++
trivial.
-----
Lemma length_DivTwoPower' : forall l, length (Sem DivTwoPower'_e l) = length (hd nil (tl l)) - length (hd nil l).
Proof.
intros [ | u [ | v l] ].
simpl.
induction u as [ | [ | ] u IH].

*****
IH : eq\n (length\n (sem_Rec (fun vl : list (list bool) => nth O vl nil)\n (fun vl : list (list bool) =>\n Sem Div2_e (cons (nth (S O) vl nil) nil))\n (fun vl : list (list bool) =>\n Sem Div2_e (cons (nth (S O) vl nil) nil)) u nil)) O
u : list bool
*****
eq (length (sem_Rec (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => Sem Div2_e (cons (nth (S O) vl nil) nil)) (fun vl : list (list bool) => Sem Div2_e (cons (nth (S O) vl nil) nil)) (cons true u) nil)) O
+++++
simpl.
-----
Lemma length_DivTwoPower' : forall l, length (Sem DivTwoPower'_e l) = length (hd nil (tl l)) - length (hd nil l).
Proof.
intros [ | u [ | v l] ].
simpl.
induction u as [ | [ | ] u IH].
simpl.

*****
IH : eq\n (length\n (sem_Rec (fun vl : list (list bool) => nth O vl nil)\n (fun vl : list (list bool) =>\n Sem Div2_e (cons (nth (S O) vl nil) nil))\n (fun vl : list (list bool) =>\n Sem Div2_e (cons (nth (S O) vl nil) nil)) u nil)) O
u : list bool
*****
eq (length (Sem Div2_e (cons (sem_Rec (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => Sem Div2_e (cons (nth (S O) vl nil) nil)) (fun vl : list (list bool) => Sem Div2_e (cons (nth (S O) vl nil) nil)) u nil) nil))) O
+++++
rewrite length_Div2.
-----
Lemma length_DivTwoPower' : forall l, length (Sem DivTwoPower'_e l) = length (hd nil (tl l)) - length (hd nil l).
Proof.
intros [ | u [ | v l] ].
simpl.
induction u as [ | [ | ] u IH].
simpl.
rewrite length_Div2.

*****
IH : eq\n (length\n (sem_Rec (fun vl : list (list bool) => nth O vl nil)\n (fun vl : list (list bool) =>\n Sem Div2_e (cons (nth (S O) vl nil) nil))\n (fun vl : list (list bool) =>\n Sem Div2_e (cons (nth (S O) vl nil) nil)) u nil)) O
u : list bool
*****
eq (Init.Nat.sub (length (hd nil (cons (sem_Rec (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => Sem Div2_e (cons (nth (S O) vl nil) nil)) (fun vl : list (list bool) => Sem Div2_e (cons (nth (S O) vl nil) nil)) u nil) nil))) (S O)) O
+++++
simpl.
-----
Lemma length_DivTwoPower' : forall l, length (Sem DivTwoPower'_e l) = length (hd nil (tl l)) - length (hd nil l).
Proof.
intros [ | u [ | v l] ].
simpl.
induction u as [ | [ | ] u IH].
simpl.
rewrite length_Div2.
simpl.

*****
IH : eq\n (length\n (sem_Rec (fun vl : list (list bool) => nth O vl nil)\n (fun vl : list (list bool) =>\n Sem Div2_e (cons (nth (S O) vl nil) nil))\n (fun vl : list (list bool) =>\n Sem Div2_e (cons (nth (S O) vl nil) nil)) u nil)) O
u : list bool
*****
eq (Init.Nat.sub (length (sem_Rec (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => Sem Div2_e (cons (nth (S O) vl nil) nil)) (fun vl : list (list bool) => Sem Div2_e (cons (nth (S O) vl nil) nil)) u nil)) (S O)) O
+++++
omega.
-----
Lemma length_DivTwoPower' : forall l, length (Sem DivTwoPower'_e l) = length (hd nil (tl l)) - length (hd nil l).
Proof.
intros [ | u [ | v l] ].
simpl.
induction u as [ | [ | ] u IH].

*****
IH : eq\n (length\n (sem_Rec (fun vl : list (list bool) => nth O vl nil)\n (fun vl : list (list bool) =>\n Sem Div2_e (cons (nth (S O) vl nil) nil))\n (fun vl : list (list bool) =>\n Sem Div2_e (cons (nth (S O) vl nil) nil)) u nil)) O
u : list bool
*****
eq (length (sem_Rec (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => Sem Div2_e (cons (nth (S O) vl nil) nil)) (fun vl : list (list bool) => Sem Div2_e (cons (nth (S O) vl nil) nil)) (cons false u) nil)) O
+++++
simpl.
-----
Lemma length_DivTwoPower' : forall l, length (Sem DivTwoPower'_e l) = length (hd nil (tl l)) - length (hd nil l).
Proof.
intros [ | u [ | v l] ].
simpl.
induction u as [ | [ | ] u IH].
simpl.

*****
IH : eq\n (length\n (sem_Rec (fun vl : list (list bool) => nth O vl nil)\n (fun vl : list (list bool) =>\n Sem Div2_e (cons (nth (S O) vl nil) nil))\n (fun vl : list (list bool) =>\n Sem Div2_e (cons (nth (S O) vl nil) nil)) u nil)) O
u : list bool
*****
eq (length (Sem Div2_e (cons (sem_Rec (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => Sem Div2_e (cons (nth (S O) vl nil) nil)) (fun vl : list (list bool) => Sem Div2_e (cons (nth (S O) vl nil) nil)) u nil) nil))) O
+++++
rewrite length_Div2.
-----
Lemma length_DivTwoPower' : forall l, length (Sem DivTwoPower'_e l) = length (hd nil (tl l)) - length (hd nil l).
Proof.
intros [ | u [ | v l] ].
simpl.
induction u as [ | [ | ] u IH].
simpl.
rewrite length_Div2.

*****
IH : eq\n (length\n (sem_Rec (fun vl : list (list bool) => nth O vl nil)\n (fun vl : list (list bool) =>\n Sem Div2_e (cons (nth (S O) vl nil) nil))\n (fun vl : list (list bool) =>\n Sem Div2_e (cons (nth (S O) vl nil) nil)) u nil)) O
u : list bool
*****
eq (Init.Nat.sub (length (hd nil (cons (sem_Rec (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => Sem Div2_e (cons (nth (S O) vl nil) nil)) (fun vl : list (list bool) => Sem Div2_e (cons (nth (S O) vl nil) nil)) u nil) nil))) (S O)) O
+++++
simpl.
-----
Lemma length_DivTwoPower' : forall l, length (Sem DivTwoPower'_e l) = length (hd nil (tl l)) - length (hd nil l).
Proof.
intros [ | u [ | v l] ].
simpl.
induction u as [ | [ | ] u IH].
simpl.
rewrite length_Div2.
simpl.

*****
IH : eq\n (length\n (sem_Rec (fun vl : list (list bool) => nth O vl nil)\n (fun vl : list (list bool) =>\n Sem Div2_e (cons (nth (S O) vl nil) nil))\n (fun vl : list (list bool) =>\n Sem Div2_e (cons (nth (S O) vl nil) nil)) u nil)) O
u : list bool
*****
eq (Init.Nat.sub (length (sem_Rec (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => Sem Div2_e (cons (nth (S O) vl nil) nil)) (fun vl : list (list bool) => Sem Div2_e (cons (nth (S O) vl nil) nil)) u nil)) (S O)) O
+++++
omega.
-----
Lemma length_DivTwoPower' : forall l, length (Sem DivTwoPower'_e l) = length (hd nil (tl l)) - length (hd nil l).
Proof.
intros [ | u [ | v l] ].

*****
l : list (list bool)
u,v : list bool
*****
eq (length (Sem DivTwoPower'_e (cons u (cons v l)))) (Init.Nat.sub (length (hd nil (tl (cons u (cons v l))))) (length (hd nil (cons u (cons v l)))))
+++++
induction u as [ | [ | ] u IH].
-----
Lemma length_DivTwoPower' : forall l, length (Sem DivTwoPower'_e l) = length (hd nil (tl l)) - length (hd nil l).
Proof.
intros [ | u [ | v l] ].
induction u as [ | [ | ] u IH].

*****
l : list (list bool)
v : list bool
*****
eq (length (Sem DivTwoPower'_e (cons nil (cons v l)))) (Init.Nat.sub (length (hd nil (tl (cons nil (cons v l))))) (length (hd nil (cons nil (cons v l)))))
+++++
simpl.
-----
Lemma length_DivTwoPower' : forall l, length (Sem DivTwoPower'_e l) = length (hd nil (tl l)) - length (hd nil l).
Proof.
intros [ | u [ | v l] ].
induction u as [ | [ | ] u IH].
simpl.

*****
l : list (list bool)
v : list bool
*****
eq (length v) (Init.Nat.sub (length v) O)
+++++
omega.
-----
Lemma length_DivTwoPower' : forall l, length (Sem DivTwoPower'_e l) = length (hd nil (tl l)) - length (hd nil l).
Proof.
intros [ | u [ | v l] ].
induction u as [ | [ | ] u IH].

*****
IH : eq (length (Sem DivTwoPower'_e (cons u (cons v l))))\n (Init.Nat.sub (length (hd nil (tl (cons u (cons v l)))))\n (length (hd nil (cons u (cons v l)))))
l : list (list bool)
u,v : list bool
*****
eq (length (Sem DivTwoPower'_e (cons (cons true u) (cons v l)))) (Init.Nat.sub (length (hd nil (tl (cons (cons true u) (cons v l))))) (length (hd nil (cons (cons true u) (cons v l)))))
+++++
simpl in *.
-----
Lemma length_DivTwoPower' : forall l, length (Sem DivTwoPower'_e l) = length (hd nil (tl l)) - length (hd nil l).
Proof.
intros [ | u [ | v l] ].
induction u as [ | [ | ] u IH].
simpl in *.

*****
IH : eq\n (length\n (sem_Rec (fun vl : list (list bool) => nth O vl nil)\n (fun vl : list (list bool) =>\n Sem Div2_e (cons (nth (S O) vl nil) nil))\n (fun vl : list (list bool) =>\n Sem Div2_e (cons (nth (S O) vl nil) nil)) u \n (cons v l))) (Init.Nat.sub (length v) (length u))
l : list (list bool)
u,v : list bool
*****
eq (length (Sem Div2_e (cons (sem_Rec (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => Sem Div2_e (cons (nth (S O) vl nil) nil)) (fun vl : list (list bool) => Sem Div2_e (cons (nth (S O) vl nil) nil)) u (cons v l)) nil))) (Init.Nat.sub (length v) (S (length u)))
+++++
rewrite length_Div2.
-----
Lemma length_DivTwoPower' : forall l, length (Sem DivTwoPower'_e l) = length (hd nil (tl l)) - length (hd nil l).
Proof.
intros [ | u [ | v l] ].
induction u as [ | [ | ] u IH].
simpl in *.
rewrite length_Div2.

*****
IH : eq\n (length\n (sem_Rec (fun vl : list (list bool) => nth O vl nil)\n (fun vl : list (list bool) =>\n Sem Div2_e (cons (nth (S O) vl nil) nil))\n (fun vl : list (list bool) =>\n Sem Div2_e (cons (nth (S O) vl nil) nil)) u \n (cons v l))) (Init.Nat.sub (length v) (length u))
l : list (list bool)
u,v : list bool
*****
eq (Init.Nat.sub (length (hd nil (cons (sem_Rec (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => Sem Div2_e (cons (nth (S O) vl nil) nil)) (fun vl : list (list bool) => Sem Div2_e (cons (nth (S O) vl nil) nil)) u (cons v l)) nil))) (S O)) (Init.Nat.sub (length v) (S (length u)))
+++++
simpl.
-----
Lemma length_DivTwoPower' : forall l, length (Sem DivTwoPower'_e l) = length (hd nil (tl l)) - length (hd nil l).
Proof.
intros [ | u [ | v l] ].
induction u as [ | [ | ] u IH].
simpl in *.
rewrite length_Div2.
simpl.

*****
IH : eq\n (length\n (sem_Rec (fun vl : list (list bool) => nth O vl nil)\n (fun vl : list (list bool) =>\n Sem Div2_e (cons (nth (S O) vl nil) nil))\n (fun vl : list (list bool) =>\n Sem Div2_e (cons (nth (S O) vl nil) nil)) u \n (cons v l))) (Init.Nat.sub (length v) (length u))
l : list (list bool)
u,v : list bool
*****
eq (Init.Nat.sub (length (sem_Rec (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => Sem Div2_e (cons (nth (S O) vl nil) nil)) (fun vl : list (list bool) => Sem Div2_e (cons (nth (S O) vl nil) nil)) u (cons v l))) (S O)) (Init.Nat.sub (length v) (S (length u)))
+++++
omega.
-----
Lemma length_DivTwoPower' : forall l, length (Sem DivTwoPower'_e l) = length (hd nil (tl l)) - length (hd nil l).
Proof.
intros [ | u [ | v l] ].
induction u as [ | [ | ] u IH].

*****
IH : eq (length (Sem DivTwoPower'_e (cons u (cons v l))))\n (Init.Nat.sub (length (hd nil (tl (cons u (cons v l)))))\n (length (hd nil (cons u (cons v l)))))
l : list (list bool)
u,v : list bool
*****
eq (length (Sem DivTwoPower'_e (cons (cons false u) (cons v l)))) (Init.Nat.sub (length (hd nil (tl (cons (cons false u) (cons v l))))) (length (hd nil (cons (cons false u) (cons v l)))))
+++++
simpl in *.
-----
Lemma length_DivTwoPower' : forall l, length (Sem DivTwoPower'_e l) = length (hd nil (tl l)) - length (hd nil l).
Proof.
intros [ | u [ | v l] ].
induction u as [ | [ | ] u IH].
simpl in *.

*****
IH : eq\n (length\n (sem_Rec (fun vl : list (list bool) => nth O vl nil)\n (fun vl : list (list bool) =>\n Sem Div2_e (cons (nth (S O) vl nil) nil))\n (fun vl : list (list bool) =>\n Sem Div2_e (cons (nth (S O) vl nil) nil)) u \n (cons v l))) (Init.Nat.sub (length v) (length u))
l : list (list bool)
u,v : list bool
*****
eq (length (Sem Div2_e (cons (sem_Rec (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => Sem Div2_e (cons (nth (S O) vl nil) nil)) (fun vl : list (list bool) => Sem Div2_e (cons (nth (S O) vl nil) nil)) u (cons v l)) nil))) (Init.Nat.sub (length v) (S (length u)))
+++++
rewrite length_Div2.
-----
Lemma length_DivTwoPower' : forall l, length (Sem DivTwoPower'_e l) = length (hd nil (tl l)) - length (hd nil l).
Proof.
intros [ | u [ | v l] ].
induction u as [ | [ | ] u IH].
simpl in *.
rewrite length_Div2.

*****
IH : eq\n (length\n (sem_Rec (fun vl : list (list bool) => nth O vl nil)\n (fun vl : list (list bool) =>\n Sem Div2_e (cons (nth (S O) vl nil) nil))\n (fun vl : list (list bool) =>\n Sem Div2_e (cons (nth (S O) vl nil) nil)) u \n (cons v l))) (Init.Nat.sub (length v) (length u))
l : list (list bool)
u,v : list bool
*****
eq (Init.Nat.sub (length (hd nil (cons (sem_Rec (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => Sem Div2_e (cons (nth (S O) vl nil) nil)) (fun vl : list (list bool) => Sem Div2_e (cons (nth (S O) vl nil) nil)) u (cons v l)) nil))) (S O)) (Init.Nat.sub (length v) (S (length u)))
+++++
simpl.
-----
Lemma length_DivTwoPower' : forall l, length (Sem DivTwoPower'_e l) = length (hd nil (tl l)) - length (hd nil l).
Proof.
intros [ | u [ | v l] ].
induction u as [ | [ | ] u IH].
simpl in *.
rewrite length_Div2.
simpl.

*****
IH : eq\n (length\n (sem_Rec (fun vl : list (list bool) => nth O vl nil)\n (fun vl : list (list bool) =>\n Sem Div2_e (cons (nth (S O) vl nil) nil))\n (fun vl : list (list bool) =>\n Sem Div2_e (cons (nth (S O) vl nil) nil)) u \n (cons v l))) (Init.Nat.sub (length v) (length u))
l : list (list bool)
u,v : list bool
*****
eq (Init.Nat.sub (length (sem_Rec (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => Sem Div2_e (cons (nth (S O) vl nil) nil)) (fun vl : list (list bool) => Sem Div2_e (cons (nth (S O) vl nil) nil)) u (cons v l))) (S O)) (Init.Nat.sub (length v) (S (length u)))
+++++
omega.
-----
Lemma length_DivTwoPower' : forall l, length (Sem DivTwoPower'_e l) = length (hd nil (tl l)) - length (hd nil l).
Proof.
intros [ | u [ | v l] ].

*****

*****

+++++
Qed.
-----
Lemma rec_bounded_DivTwoPower' :\n  rec_bounded DivTwoPower'_e.
-----
Lemma rec_bounded_DivTwoPower' : rec_bounded DivTwoPower'_e.

*****

*****
rec_bounded DivTwoPower'_e
+++++
Proof.
-----
Lemma rec_bounded_DivTwoPower' : rec_bounded DivTwoPower'_e.
Proof.

*****

*****
rec_bounded DivTwoPower'_e
+++++
simpl.
-----
Lemma rec_bounded_DivTwoPower' : rec_bounded DivTwoPower'_e.
Proof.
simpl.

*****

*****
and True (and True (and (and (rec_bounded Div2_e) (and True True)) (and (and (rec_bounded Div2_e) (and True True)) (forall l : list (list bool), le (length (sem_Rec (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => Sem Div2_e (cons (nth (S O) vl nil) nil)) (fun vl : list (list bool) => Sem Div2_e (cons (nth (S O) vl nil) nil)) (hd nil l) (tl l))) (length (nth (S O) l nil))))))
+++++
intuition.
-----
Lemma rec_bounded_DivTwoPower' : rec_bounded DivTwoPower'_e.
Proof.
simpl.
intuition.

*****

*****
rec_bounded Div2_e
+++++
apply rec_bounded_Div2.
-----
Lemma rec_bounded_DivTwoPower' : rec_bounded DivTwoPower'_e.
Proof.
simpl.
intuition.

*****

*****
rec_bounded Div2_e
+++++
apply rec_bounded_Div2.
-----
Lemma rec_bounded_DivTwoPower' : rec_bounded DivTwoPower'_e.
Proof.
simpl.
intuition.

*****
l : list (list bool)
*****
le (length (sem_Rec (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => Sem Div2_e (cons (nth (S O) vl nil) nil)) (fun vl : list (list bool) => Sem Div2_e (cons (nth (S O) vl nil) nil)) (hd nil l) (tl l))) (length (nth (S O) l nil))
+++++
destruct l as [ | u [ | v l] ].
-----
Lemma rec_bounded_DivTwoPower' : rec_bounded DivTwoPower'_e.
Proof.
simpl.
intuition.
destruct l as [ | u [ | v l] ].

*****

*****
le (length (sem_Rec (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => Sem Div2_e (cons (nth (S O) vl nil) nil)) (fun vl : list (list bool) => Sem Div2_e (cons (nth (S O) vl nil) nil)) (hd nil nil) (tl nil))) (length (nth (S O) nil nil))
+++++
trivial.
-----
Lemma rec_bounded_DivTwoPower' : rec_bounded DivTwoPower'_e.
Proof.
simpl.
intuition.
destruct l as [ | u [ | v l] ].

*****
u : list bool
*****
le (length (sem_Rec (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => Sem Div2_e (cons (nth (S O) vl nil) nil)) (fun vl : list (list bool) => Sem Div2_e (cons (nth (S O) vl nil) nil)) (hd nil (cons u nil)) (tl (cons u nil)))) (length (nth (S O) (cons u nil) nil))
+++++
simpl.
-----
Lemma rec_bounded_DivTwoPower' : rec_bounded DivTwoPower'_e.
Proof.
simpl.
intuition.
destruct l as [ | u [ | v l] ].
simpl.

*****
u : list bool
*****
le (length (sem_Rec (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => Sem Div2_e (cons (nth (S O) vl nil) nil)) (fun vl : list (list bool) => Sem Div2_e (cons (nth (S O) vl nil) nil)) u nil)) O
+++++
induction u as [ | [ | ] u IH].
-----
Lemma rec_bounded_DivTwoPower' : rec_bounded DivTwoPower'_e.
Proof.
simpl.
intuition.
destruct l as [ | u [ | v l] ].
simpl.
induction u as [ | [ | ] u IH].

*****

*****
le (length (sem_Rec (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => Sem Div2_e (cons (nth (S O) vl nil) nil)) (fun vl : list (list bool) => Sem Div2_e (cons (nth (S O) vl nil) nil)) nil nil)) O
+++++
trivial.
-----
Lemma rec_bounded_DivTwoPower' : rec_bounded DivTwoPower'_e.
Proof.
simpl.
intuition.
destruct l as [ | u [ | v l] ].
simpl.
induction u as [ | [ | ] u IH].

*****
IH : le\n (length\n (sem_Rec (fun vl : list (list bool) => nth O vl nil)\n (fun vl : list (list bool) =>\n Sem Div2_e (cons (nth (S O) vl nil) nil))\n (fun vl : list (list bool) =>\n Sem Div2_e (cons (nth (S O) vl nil) nil)) u nil)) O
u : list bool
*****
le (length (sem_Rec (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => Sem Div2_e (cons (nth (S O) vl nil) nil)) (fun vl : list (list bool) => Sem Div2_e (cons (nth (S O) vl nil) nil)) (cons true u) nil)) O
+++++
simpl.
-----
Lemma rec_bounded_DivTwoPower' : rec_bounded DivTwoPower'_e.
Proof.
simpl.
intuition.
destruct l as [ | u [ | v l] ].
simpl.
induction u as [ | [ | ] u IH].
simpl.

*****
IH : le\n (length\n (sem_Rec (fun vl : list (list bool) => nth O vl nil)\n (fun vl : list (list bool) =>\n Sem Div2_e (cons (nth (S O) vl nil) nil))\n (fun vl : list (list bool) =>\n Sem Div2_e (cons (nth (S O) vl nil) nil)) u nil)) O
u : list bool
*****
le (length (Sem Div2_e (cons (sem_Rec (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => Sem Div2_e (cons (nth (S O) vl nil) nil)) (fun vl : list (list bool) => Sem Div2_e (cons (nth (S O) vl nil) nil)) u nil) nil))) O
+++++
rewrite length_Div2.
-----
Lemma rec_bounded_DivTwoPower' : rec_bounded DivTwoPower'_e.
Proof.
simpl.
intuition.
destruct l as [ | u [ | v l] ].
simpl.
induction u as [ | [ | ] u IH].
simpl.
rewrite length_Div2.

*****
IH : le\n (length\n (sem_Rec (fun vl : list (list bool) => nth O vl nil)\n (fun vl : list (list bool) =>\n Sem Div2_e (cons (nth (S O) vl nil) nil))\n (fun vl : list (list bool) =>\n Sem Div2_e (cons (nth (S O) vl nil) nil)) u nil)) O
u : list bool
*****
le (Init.Nat.sub (length (hd nil (cons (sem_Rec (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => Sem Div2_e (cons (nth (S O) vl nil) nil)) (fun vl : list (list bool) => Sem Div2_e (cons (nth (S O) vl nil) nil)) u nil) nil))) (S O)) O
+++++
simpl.
-----
Lemma rec_bounded_DivTwoPower' : rec_bounded DivTwoPower'_e.
Proof.
simpl.
intuition.
destruct l as [ | u [ | v l] ].
simpl.
induction u as [ | [ | ] u IH].
simpl.
rewrite length_Div2.
simpl.

*****
IH : le\n (length\n (sem_Rec (fun vl : list (list bool) => nth O vl nil)\n (fun vl : list (list bool) =>\n Sem Div2_e (cons (nth (S O) vl nil) nil))\n (fun vl : list (list bool) =>\n Sem Div2_e (cons (nth (S O) vl nil) nil)) u nil)) O
u : list bool
*****
le (Init.Nat.sub (length (sem_Rec (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => Sem Div2_e (cons (nth (S O) vl nil) nil)) (fun vl : list (list bool) => Sem Div2_e (cons (nth (S O) vl nil) nil)) u nil)) (S O)) O
+++++
omega.
-----
Lemma rec_bounded_DivTwoPower' : rec_bounded DivTwoPower'_e.
Proof.
simpl.
intuition.
destruct l as [ | u [ | v l] ].
simpl.
induction u as [ | [ | ] u IH].

*****
IH : le\n (length\n (sem_Rec (fun vl : list (list bool) => nth O vl nil)\n (fun vl : list (list bool) =>\n Sem Div2_e (cons (nth (S O) vl nil) nil))\n (fun vl : list (list bool) =>\n Sem Div2_e (cons (nth (S O) vl nil) nil)) u nil)) O
u : list bool
*****
le (length (sem_Rec (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => Sem Div2_e (cons (nth (S O) vl nil) nil)) (fun vl : list (list bool) => Sem Div2_e (cons (nth (S O) vl nil) nil)) (cons false u) nil)) O
+++++
simpl.
-----
Lemma rec_bounded_DivTwoPower' : rec_bounded DivTwoPower'_e.
Proof.
simpl.
intuition.
destruct l as [ | u [ | v l] ].
simpl.
induction u as [ | [ | ] u IH].
simpl.

*****
IH : le\n (length\n (sem_Rec (fun vl : list (list bool) => nth O vl nil)\n (fun vl : list (list bool) =>\n Sem Div2_e (cons (nth (S O) vl nil) nil))\n (fun vl : list (list bool) =>\n Sem Div2_e (cons (nth (S O) vl nil) nil)) u nil)) O
u : list bool
*****
le (length (Sem Div2_e (cons (sem_Rec (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => Sem Div2_e (cons (nth (S O) vl nil) nil)) (fun vl : list (list bool) => Sem Div2_e (cons (nth (S O) vl nil) nil)) u nil) nil))) O
+++++
rewrite length_Div2.
-----
Lemma rec_bounded_DivTwoPower' : rec_bounded DivTwoPower'_e.
Proof.
simpl.
intuition.
destruct l as [ | u [ | v l] ].
simpl.
induction u as [ | [ | ] u IH].
simpl.
rewrite length_Div2.

*****
IH : le\n (length\n (sem_Rec (fun vl : list (list bool) => nth O vl nil)\n (fun vl : list (list bool) =>\n Sem Div2_e (cons (nth (S O) vl nil) nil))\n (fun vl : list (list bool) =>\n Sem Div2_e (cons (nth (S O) vl nil) nil)) u nil)) O
u : list bool
*****
le (Init.Nat.sub (length (hd nil (cons (sem_Rec (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => Sem Div2_e (cons (nth (S O) vl nil) nil)) (fun vl : list (list bool) => Sem Div2_e (cons (nth (S O) vl nil) nil)) u nil) nil))) (S O)) O
+++++
simpl.
-----
Lemma rec_bounded_DivTwoPower' : rec_bounded DivTwoPower'_e.
Proof.
simpl.
intuition.
destruct l as [ | u [ | v l] ].
simpl.
induction u as [ | [ | ] u IH].
simpl.
rewrite length_Div2.
simpl.

*****
IH : le\n (length\n (sem_Rec (fun vl : list (list bool) => nth O vl nil)\n (fun vl : list (list bool) =>\n Sem Div2_e (cons (nth (S O) vl nil) nil))\n (fun vl : list (list bool) =>\n Sem Div2_e (cons (nth (S O) vl nil) nil)) u nil)) O
u : list bool
*****
le (Init.Nat.sub (length (sem_Rec (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => Sem Div2_e (cons (nth (S O) vl nil) nil)) (fun vl : list (list bool) => Sem Div2_e (cons (nth (S O) vl nil) nil)) u nil)) (S O)) O
+++++
omega.
-----
Lemma rec_bounded_DivTwoPower' : rec_bounded DivTwoPower'_e.
Proof.
simpl.
intuition.
destruct l as [ | u [ | v l] ].

*****
l : list (list bool)
u,v : list bool
*****
le (length (sem_Rec (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => Sem Div2_e (cons (nth (S O) vl nil) nil)) (fun vl : list (list bool) => Sem Div2_e (cons (nth (S O) vl nil) nil)) (hd nil (cons u (cons v l))) (tl (cons u (cons v l))))) (length (nth (S O) (cons u (cons v l)) nil))
+++++
induction u as [ | [ | ] u IH].
-----
Lemma rec_bounded_DivTwoPower' : rec_bounded DivTwoPower'_e.
Proof.
simpl.
intuition.
destruct l as [ | u [ | v l] ].
induction u as [ | [ | ] u IH].

*****
l : list (list bool)
v : list bool
*****
le (length (sem_Rec (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => Sem Div2_e (cons (nth (S O) vl nil) nil)) (fun vl : list (list bool) => Sem Div2_e (cons (nth (S O) vl nil) nil)) (hd nil (cons nil (cons v l))) (tl (cons nil (cons v l))))) (length (nth (S O) (cons nil (cons v l)) nil))
+++++
trivial.
-----
Lemma rec_bounded_DivTwoPower' : rec_bounded DivTwoPower'_e.
Proof.
simpl.
intuition.
destruct l as [ | u [ | v l] ].
induction u as [ | [ | ] u IH].

*****
IH : le\n (length\n (sem_Rec (fun vl : list (list bool) => nth O vl nil)\n (fun vl : list (list bool) =>\n Sem Div2_e (cons (nth (S O) vl nil) nil))\n (fun vl : list (list bool) =>\n Sem Div2_e (cons (nth (S O) vl nil) nil))\n (hd nil (cons u (cons v l))) (tl (cons u (cons v l)))))\n (length (nth (S O) (cons u (cons v l)) nil))
l : list (list bool)
u,v : list bool
*****
le (length (sem_Rec (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => Sem Div2_e (cons (nth (S O) vl nil) nil)) (fun vl : list (list bool) => Sem Div2_e (cons (nth (S O) vl nil) nil)) (hd nil (cons (cons true u) (cons v l))) (tl (cons (cons true u) (cons v l))))) (length (nth (S O) (cons (cons true u) (cons v l)) nil))
+++++
simpl in *.
-----
Lemma rec_bounded_DivTwoPower' : rec_bounded DivTwoPower'_e.
Proof.
simpl.
intuition.
destruct l as [ | u [ | v l] ].
induction u as [ | [ | ] u IH].
simpl in *.

*****
IH : le\n (length\n (sem_Rec (fun vl : list (list bool) => nth O vl nil)\n (fun vl : list (list bool) =>\n Sem Div2_e (cons (nth (S O) vl nil) nil))\n (fun vl : list (list bool) =>\n Sem Div2_e (cons (nth (S O) vl nil) nil)) u \n (cons v l))) (length v)
l : list (list bool)
u,v : list bool
*****
le (length (Sem Div2_e (cons (sem_Rec (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => Sem Div2_e (cons (nth (S O) vl nil) nil)) (fun vl : list (list bool) => Sem Div2_e (cons (nth (S O) vl nil) nil)) u (cons v l)) nil))) (length v)
+++++
rewrite length_Div2.
-----
Lemma rec_bounded_DivTwoPower' : rec_bounded DivTwoPower'_e.
Proof.
simpl.
intuition.
destruct l as [ | u [ | v l] ].
induction u as [ | [ | ] u IH].
simpl in *.
rewrite length_Div2.

*****
IH : le\n (length\n (sem_Rec (fun vl : list (list bool) => nth O vl nil)\n (fun vl : list (list bool) =>\n Sem Div2_e (cons (nth (S O) vl nil) nil))\n (fun vl : list (list bool) =>\n Sem Div2_e (cons (nth (S O) vl nil) nil)) u \n (cons v l))) (length v)
l : list (list bool)
u,v : list bool
*****
le (Init.Nat.sub (length (hd nil (cons (sem_Rec (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => Sem Div2_e (cons (nth (S O) vl nil) nil)) (fun vl : list (list bool) => Sem Div2_e (cons (nth (S O) vl nil) nil)) u (cons v l)) nil))) (S O)) (length v)
+++++
simpl.
-----
Lemma rec_bounded_DivTwoPower' : rec_bounded DivTwoPower'_e.
Proof.
simpl.
intuition.
destruct l as [ | u [ | v l] ].
induction u as [ | [ | ] u IH].
simpl in *.
rewrite length_Div2.
simpl.

*****
IH : le\n (length\n (sem_Rec (fun vl : list (list bool) => nth O vl nil)\n (fun vl : list (list bool) =>\n Sem Div2_e (cons (nth (S O) vl nil) nil))\n (fun vl : list (list bool) =>\n Sem Div2_e (cons (nth (S O) vl nil) nil)) u \n (cons v l))) (length v)
l : list (list bool)
u,v : list bool
*****
le (Init.Nat.sub (length (sem_Rec (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => Sem Div2_e (cons (nth (S O) vl nil) nil)) (fun vl : list (list bool) => Sem Div2_e (cons (nth (S O) vl nil) nil)) u (cons v l))) (S O)) (length v)
+++++
omega.
-----
Lemma rec_bounded_DivTwoPower' : rec_bounded DivTwoPower'_e.
Proof.
simpl.
intuition.
destruct l as [ | u [ | v l] ].
induction u as [ | [ | ] u IH].

*****
IH : le\n (length\n (sem_Rec (fun vl : list (list bool) => nth O vl nil)\n (fun vl : list (list bool) =>\n Sem Div2_e (cons (nth (S O) vl nil) nil))\n (fun vl : list (list bool) =>\n Sem Div2_e (cons (nth (S O) vl nil) nil))\n (hd nil (cons u (cons v l))) (tl (cons u (cons v l)))))\n (length (nth (S O) (cons u (cons v l)) nil))
l : list (list bool)
u,v : list bool
*****
le (length (sem_Rec (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => Sem Div2_e (cons (nth (S O) vl nil) nil)) (fun vl : list (list bool) => Sem Div2_e (cons (nth (S O) vl nil) nil)) (hd nil (cons (cons false u) (cons v l))) (tl (cons (cons false u) (cons v l))))) (length (nth (S O) (cons (cons false u) (cons v l)) nil))
+++++
simpl in *.
-----
Lemma rec_bounded_DivTwoPower' : rec_bounded DivTwoPower'_e.
Proof.
simpl.
intuition.
destruct l as [ | u [ | v l] ].
induction u as [ | [ | ] u IH].
simpl in *.

*****
IH : le\n (length\n (sem_Rec (fun vl : list (list bool) => nth O vl nil)\n (fun vl : list (list bool) =>\n Sem Div2_e (cons (nth (S O) vl nil) nil))\n (fun vl : list (list bool) =>\n Sem Div2_e (cons (nth (S O) vl nil) nil)) u \n (cons v l))) (length v)
l : list (list bool)
u,v : list bool
*****
le (length (Sem Div2_e (cons (sem_Rec (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => Sem Div2_e (cons (nth (S O) vl nil) nil)) (fun vl : list (list bool) => Sem Div2_e (cons (nth (S O) vl nil) nil)) u (cons v l)) nil))) (length v)
+++++
rewrite length_Div2.
-----
Lemma rec_bounded_DivTwoPower' : rec_bounded DivTwoPower'_e.
Proof.
simpl.
intuition.
destruct l as [ | u [ | v l] ].
induction u as [ | [ | ] u IH].
simpl in *.
rewrite length_Div2.

*****
IH : le\n (length\n (sem_Rec (fun vl : list (list bool) => nth O vl nil)\n (fun vl : list (list bool) =>\n Sem Div2_e (cons (nth (S O) vl nil) nil))\n (fun vl : list (list bool) =>\n Sem Div2_e (cons (nth (S O) vl nil) nil)) u \n (cons v l))) (length v)
l : list (list bool)
u,v : list bool
*****
le (Init.Nat.sub (length (hd nil (cons (sem_Rec (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => Sem Div2_e (cons (nth (S O) vl nil) nil)) (fun vl : list (list bool) => Sem Div2_e (cons (nth (S O) vl nil) nil)) u (cons v l)) nil))) (S O)) (length v)
+++++
simpl.
-----
Lemma rec_bounded_DivTwoPower' : rec_bounded DivTwoPower'_e.
Proof.
simpl.
intuition.
destruct l as [ | u [ | v l] ].
induction u as [ | [ | ] u IH].
simpl in *.
rewrite length_Div2.
simpl.

*****
IH : le\n (length\n (sem_Rec (fun vl : list (list bool) => nth O vl nil)\n (fun vl : list (list bool) =>\n Sem Div2_e (cons (nth (S O) vl nil) nil))\n (fun vl : list (list bool) =>\n Sem Div2_e (cons (nth (S O) vl nil) nil)) u \n (cons v l))) (length v)
l : list (list bool)
u,v : list bool
*****
le (Init.Nat.sub (length (sem_Rec (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => Sem Div2_e (cons (nth (S O) vl nil) nil)) (fun vl : list (list bool) => Sem Div2_e (cons (nth (S O) vl nil) nil)) u (cons v l))) (S O)) (length v)
+++++
omega.
-----
Lemma rec_bounded_DivTwoPower' : rec_bounded DivTwoPower'_e.
Proof.
simpl.
intuition.

*****

*****

+++++
Qed.
-----
Lemma DivTwoPower'_correct_bs : forall l,\n  Sem DivTwoPower'_e l =\n  fun_power (length (hd nil l)) (@tl _) (hd nil (tl l)).
-----
Lemma DivTwoPower'_correct_bs : forall l, Sem DivTwoPower'_e l = fun_power (length (hd nil l)) (@tl _) (hd nil (tl l)).

*****

*****
forall l : list (list bool), eq (Sem DivTwoPower'_e l) (fun_power (length (hd nil l)) (tl (A:=bool)) (hd nil (tl l)))
+++++
Proof.
-----
Lemma DivTwoPower'_correct_bs : forall l, Sem DivTwoPower'_e l = fun_power (length (hd nil l)) (@tl _) (hd nil (tl l)).
Proof.

*****

*****
forall l : list (list bool), eq (Sem DivTwoPower'_e l) (fun_power (length (hd nil l)) (tl (A:=bool)) (hd nil (tl l)))
+++++
intros [ | u [ | v l] ].
-----
Lemma DivTwoPower'_correct_bs : forall l, Sem DivTwoPower'_e l = fun_power (length (hd nil l)) (@tl _) (hd nil (tl l)).
Proof.
intros [ | u [ | v l] ].

*****

*****
eq (Sem DivTwoPower'_e nil) (fun_power (length (hd nil nil)) (tl (A:=bool)) (hd nil (tl nil)))
+++++
trivial.
-----
Lemma DivTwoPower'_correct_bs : forall l, Sem DivTwoPower'_e l = fun_power (length (hd nil l)) (@tl _) (hd nil (tl l)).
Proof.
intros [ | u [ | v l] ].

*****
u : list bool
*****
eq (Sem DivTwoPower'_e (cons u nil)) (fun_power (length (hd nil (cons u nil))) (tl (A:=bool)) (hd nil (tl (cons u nil))))
+++++
simpl.
-----
Lemma DivTwoPower'_correct_bs : forall l, Sem DivTwoPower'_e l = fun_power (length (hd nil l)) (@tl _) (hd nil (tl l)).
Proof.
intros [ | u [ | v l] ].
simpl.

*****
u : list bool
*****
eq (sem_Rec (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => Sem Div2_e (cons (nth (S O) vl nil) nil)) (fun vl : list (list bool) => Sem Div2_e (cons (nth (S O) vl nil) nil)) u nil) (fun_power (length u) (tl (A:=bool)) nil)
+++++
induction u as [ | [ | ] u IH].
-----
Lemma DivTwoPower'_correct_bs : forall l, Sem DivTwoPower'_e l = fun_power (length (hd nil l)) (@tl _) (hd nil (tl l)).
Proof.
intros [ | u [ | v l] ].
simpl.
induction u as [ | [ | ] u IH].

*****

*****
eq (sem_Rec (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => Sem Div2_e (cons (nth (S O) vl nil) nil)) (fun vl : list (list bool) => Sem Div2_e (cons (nth (S O) vl nil) nil)) nil nil) (fun_power (length nil) (tl (A:=bool)) nil)
+++++
trivial.
-----
Lemma DivTwoPower'_correct_bs : forall l, Sem DivTwoPower'_e l = fun_power (length (hd nil l)) (@tl _) (hd nil (tl l)).
Proof.
intros [ | u [ | v l] ].
simpl.
induction u as [ | [ | ] u IH].

*****
IH : eq\n (sem_Rec (fun vl : list (list bool) => nth O vl nil)\n (fun vl : list (list bool) =>\n Sem Div2_e (cons (nth (S O) vl nil) nil))\n (fun vl : list (list bool) =>\n Sem Div2_e (cons (nth (S O) vl nil) nil)) u nil)\n (fun_power (length u) (tl (A:=bool)) nil)
u : list bool
*****
eq (sem_Rec (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => Sem Div2_e (cons (nth (S O) vl nil) nil)) (fun vl : list (list bool) => Sem Div2_e (cons (nth (S O) vl nil) nil)) (cons true u) nil) (fun_power (length (cons true u)) (tl (A:=bool)) nil)
+++++
simpl.
-----
Lemma DivTwoPower'_correct_bs : forall l, Sem DivTwoPower'_e l = fun_power (length (hd nil l)) (@tl _) (hd nil (tl l)).
Proof.
intros [ | u [ | v l] ].
simpl.
induction u as [ | [ | ] u IH].
simpl.

*****
IH : eq\n (sem_Rec (fun vl : list (list bool) => nth O vl nil)\n (fun vl : list (list bool) =>\n Sem Div2_e (cons (nth (S O) vl nil) nil))\n (fun vl : list (list bool) =>\n Sem Div2_e (cons (nth (S O) vl nil) nil)) u nil)\n (fun_power (length u) (tl (A:=bool)) nil)
u : list bool
*****
eq (Sem Div2_e (cons (sem_Rec (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => Sem Div2_e (cons (nth (S O) vl nil) nil)) (fun vl : list (list bool) => Sem Div2_e (cons (nth (S O) vl nil) nil)) u nil) nil)) (tl (fun_power (length u) (tl (A:=bool)) nil))
+++++
rewrite Div2_correct_bs.
-----
Lemma DivTwoPower'_correct_bs : forall l, Sem DivTwoPower'_e l = fun_power (length (hd nil l)) (@tl _) (hd nil (tl l)).
Proof.
intros [ | u [ | v l] ].
simpl.
induction u as [ | [ | ] u IH].
simpl.
rewrite Div2_correct_bs.

*****
IH : eq\n (sem_Rec (fun vl : list (list bool) => nth O vl nil)\n (fun vl : list (list bool) =>\n Sem Div2_e (cons (nth (S O) vl nil) nil))\n (fun vl : list (list bool) =>\n Sem Div2_e (cons (nth (S O) vl nil) nil)) u nil)\n (fun_power (length u) (tl (A:=bool)) nil)
u : list bool
*****
eq (tl (hd nil (cons (sem_Rec (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => Sem Div2_e (cons (nth (S O) vl nil) nil)) (fun vl : list (list bool) => Sem Div2_e (cons (nth (S O) vl nil) nil)) u nil) nil))) (tl (fun_power (length u) (tl (A:=bool)) nil))
+++++
simpl.
-----
Lemma DivTwoPower'_correct_bs : forall l, Sem DivTwoPower'_e l = fun_power (length (hd nil l)) (@tl _) (hd nil (tl l)).
Proof.
intros [ | u [ | v l] ].
simpl.
induction u as [ | [ | ] u IH].
simpl.
rewrite Div2_correct_bs.
simpl.

*****
IH : eq\n (sem_Rec (fun vl : list (list bool) => nth O vl nil)\n (fun vl : list (list bool) =>\n Sem Div2_e (cons (nth (S O) vl nil) nil))\n (fun vl : list (list bool) =>\n Sem Div2_e (cons (nth (S O) vl nil) nil)) u nil)\n (fun_power (length u) (tl (A:=bool)) nil)
u : list bool
*****
eq (tl (sem_Rec (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => Sem Div2_e (cons (nth (S O) vl nil) nil)) (fun vl : list (list bool) => Sem Div2_e (cons (nth (S O) vl nil) nil)) u nil)) (tl (fun_power (length u) (tl (A:=bool)) nil))
+++++
congruence.
-----
Lemma DivTwoPower'_correct_bs : forall l, Sem DivTwoPower'_e l = fun_power (length (hd nil l)) (@tl _) (hd nil (tl l)).
Proof.
intros [ | u [ | v l] ].
simpl.
induction u as [ | [ | ] u IH].

*****
IH : eq\n (sem_Rec (fun vl : list (list bool) => nth O vl nil)\n (fun vl : list (list bool) =>\n Sem Div2_e (cons (nth (S O) vl nil) nil))\n (fun vl : list (list bool) =>\n Sem Div2_e (cons (nth (S O) vl nil) nil)) u nil)\n (fun_power (length u) (tl (A:=bool)) nil)
u : list bool
*****
eq (sem_Rec (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => Sem Div2_e (cons (nth (S O) vl nil) nil)) (fun vl : list (list bool) => Sem Div2_e (cons (nth (S O) vl nil) nil)) (cons false u) nil) (fun_power (length (cons false u)) (tl (A:=bool)) nil)
+++++
simpl.
-----
Lemma DivTwoPower'_correct_bs : forall l, Sem DivTwoPower'_e l = fun_power (length (hd nil l)) (@tl _) (hd nil (tl l)).
Proof.
intros [ | u [ | v l] ].
simpl.
induction u as [ | [ | ] u IH].
simpl.

*****
IH : eq\n (sem_Rec (fun vl : list (list bool) => nth O vl nil)\n (fun vl : list (list bool) =>\n Sem Div2_e (cons (nth (S O) vl nil) nil))\n (fun vl : list (list bool) =>\n Sem Div2_e (cons (nth (S O) vl nil) nil)) u nil)\n (fun_power (length u) (tl (A:=bool)) nil)
u : list bool
*****
eq (Sem Div2_e (cons (sem_Rec (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => Sem Div2_e (cons (nth (S O) vl nil) nil)) (fun vl : list (list bool) => Sem Div2_e (cons (nth (S O) vl nil) nil)) u nil) nil)) (tl (fun_power (length u) (tl (A:=bool)) nil))
+++++
rewrite Div2_correct_bs.
-----
Lemma DivTwoPower'_correct_bs : forall l, Sem DivTwoPower'_e l = fun_power (length (hd nil l)) (@tl _) (hd nil (tl l)).
Proof.
intros [ | u [ | v l] ].
simpl.
induction u as [ | [ | ] u IH].
simpl.
rewrite Div2_correct_bs.

*****
IH : eq\n (sem_Rec (fun vl : list (list bool) => nth O vl nil)\n (fun vl : list (list bool) =>\n Sem Div2_e (cons (nth (S O) vl nil) nil))\n (fun vl : list (list bool) =>\n Sem Div2_e (cons (nth (S O) vl nil) nil)) u nil)\n (fun_power (length u) (tl (A:=bool)) nil)
u : list bool
*****
eq (tl (hd nil (cons (sem_Rec (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => Sem Div2_e (cons (nth (S O) vl nil) nil)) (fun vl : list (list bool) => Sem Div2_e (cons (nth (S O) vl nil) nil)) u nil) nil))) (tl (fun_power (length u) (tl (A:=bool)) nil))
+++++
simpl.
-----
Lemma DivTwoPower'_correct_bs : forall l, Sem DivTwoPower'_e l = fun_power (length (hd nil l)) (@tl _) (hd nil (tl l)).
Proof.
intros [ | u [ | v l] ].
simpl.
induction u as [ | [ | ] u IH].
simpl.
rewrite Div2_correct_bs.
simpl.

*****
IH : eq\n (sem_Rec (fun vl : list (list bool) => nth O vl nil)\n (fun vl : list (list bool) =>\n Sem Div2_e (cons (nth (S O) vl nil) nil))\n (fun vl : list (list bool) =>\n Sem Div2_e (cons (nth (S O) vl nil) nil)) u nil)\n (fun_power (length u) (tl (A:=bool)) nil)
u : list bool
*****
eq (tl (sem_Rec (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => Sem Div2_e (cons (nth (S O) vl nil) nil)) (fun vl : list (list bool) => Sem Div2_e (cons (nth (S O) vl nil) nil)) u nil)) (tl (fun_power (length u) (tl (A:=bool)) nil))
+++++
congruence.
-----
Lemma DivTwoPower'_correct_bs : forall l, Sem DivTwoPower'_e l = fun_power (length (hd nil l)) (@tl _) (hd nil (tl l)).
Proof.
intros [ | u [ | v l] ].

*****
l : list (list bool)
u,v : list bool
*****
eq (Sem DivTwoPower'_e (cons u (cons v l))) (fun_power (length (hd nil (cons u (cons v l)))) (tl (A:=bool)) (hd nil (tl (cons u (cons v l)))))
+++++
simpl.
-----
Lemma DivTwoPower'_correct_bs : forall l, Sem DivTwoPower'_e l = fun_power (length (hd nil l)) (@tl _) (hd nil (tl l)).
Proof.
intros [ | u [ | v l] ].
simpl.

*****
l : list (list bool)
u,v : list bool
*****
eq (sem_Rec (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => Sem Div2_e (cons (nth (S O) vl nil) nil)) (fun vl : list (list bool) => Sem Div2_e (cons (nth (S O) vl nil) nil)) u (cons v l)) (fun_power (length u) (tl (A:=bool)) v)
+++++
induction u as [ | [ | ] u IH].
-----
Lemma DivTwoPower'_correct_bs : forall l, Sem DivTwoPower'_e l = fun_power (length (hd nil l)) (@tl _) (hd nil (tl l)).
Proof.
intros [ | u [ | v l] ].
simpl.
induction u as [ | [ | ] u IH].

*****
l : list (list bool)
v : list bool
*****
eq (sem_Rec (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => Sem Div2_e (cons (nth (S O) vl nil) nil)) (fun vl : list (list bool) => Sem Div2_e (cons (nth (S O) vl nil) nil)) nil (cons v l)) (fun_power (length nil) (tl (A:=bool)) v)
+++++
trivial.
-----
Lemma DivTwoPower'_correct_bs : forall l, Sem DivTwoPower'_e l = fun_power (length (hd nil l)) (@tl _) (hd nil (tl l)).
Proof.
intros [ | u [ | v l] ].
simpl.
induction u as [ | [ | ] u IH].

*****
IH : eq\n (sem_Rec (fun vl : list (list bool) => nth O vl nil)\n (fun vl : list (list bool) =>\n Sem Div2_e (cons (nth (S O) vl nil) nil))\n (fun vl : list (list bool) =>\n Sem Div2_e (cons (nth (S O) vl nil) nil)) u \n (cons v l)) (fun_power (length u) (tl (A:=bool)) v)
l : list (list bool)
u,v : list bool
*****
eq (sem_Rec (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => Sem Div2_e (cons (nth (S O) vl nil) nil)) (fun vl : list (list bool) => Sem Div2_e (cons (nth (S O) vl nil) nil)) (cons true u) (cons v l)) (fun_power (length (cons true u)) (tl (A:=bool)) v)
+++++
simpl.
-----
Lemma DivTwoPower'_correct_bs : forall l, Sem DivTwoPower'_e l = fun_power (length (hd nil l)) (@tl _) (hd nil (tl l)).
Proof.
intros [ | u [ | v l] ].
simpl.
induction u as [ | [ | ] u IH].
simpl.

*****
IH : eq\n (sem_Rec (fun vl : list (list bool) => nth O vl nil)\n (fun vl : list (list bool) =>\n Sem Div2_e (cons (nth (S O) vl nil) nil))\n (fun vl : list (list bool) =>\n Sem Div2_e (cons (nth (S O) vl nil) nil)) u \n (cons v l)) (fun_power (length u) (tl (A:=bool)) v)
l : list (list bool)
u,v : list bool
*****
eq (Sem Div2_e (cons (sem_Rec (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => Sem Div2_e (cons (nth (S O) vl nil) nil)) (fun vl : list (list bool) => Sem Div2_e (cons (nth (S O) vl nil) nil)) u (cons v l)) nil)) (tl (fun_power (length u) (tl (A:=bool)) v))
+++++
rewrite Div2_correct_bs.
-----
Lemma DivTwoPower'_correct_bs : forall l, Sem DivTwoPower'_e l = fun_power (length (hd nil l)) (@tl _) (hd nil (tl l)).
Proof.
intros [ | u [ | v l] ].
simpl.
induction u as [ | [ | ] u IH].
simpl.
rewrite Div2_correct_bs.

*****
IH : eq\n (sem_Rec (fun vl : list (list bool) => nth O vl nil)\n (fun vl : list (list bool) =>\n Sem Div2_e (cons (nth (S O) vl nil) nil))\n (fun vl : list (list bool) =>\n Sem Div2_e (cons (nth (S O) vl nil) nil)) u \n (cons v l)) (fun_power (length u) (tl (A:=bool)) v)
l : list (list bool)
u,v : list bool
*****
eq (tl (hd nil (cons (sem_Rec (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => Sem Div2_e (cons (nth (S O) vl nil) nil)) (fun vl : list (list bool) => Sem Div2_e (cons (nth (S O) vl nil) nil)) u (cons v l)) nil))) (tl (fun_power (length u) (tl (A:=bool)) v))
+++++
simpl.
-----
Lemma DivTwoPower'_correct_bs : forall l, Sem DivTwoPower'_e l = fun_power (length (hd nil l)) (@tl _) (hd nil (tl l)).
Proof.
intros [ | u [ | v l] ].
simpl.
induction u as [ | [ | ] u IH].
simpl.
rewrite Div2_correct_bs.
simpl.

*****
IH : eq\n (sem_Rec (fun vl : list (list bool) => nth O vl nil)\n (fun vl : list (list bool) =>\n Sem Div2_e (cons (nth (S O) vl nil) nil))\n (fun vl : list (list bool) =>\n Sem Div2_e (cons (nth (S O) vl nil) nil)) u \n (cons v l)) (fun_power (length u) (tl (A:=bool)) v)
l : list (list bool)
u,v : list bool
*****
eq (tl (sem_Rec (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => Sem Div2_e (cons (nth (S O) vl nil) nil)) (fun vl : list (list bool) => Sem Div2_e (cons (nth (S O) vl nil) nil)) u (cons v l))) (tl (fun_power (length u) (tl (A:=bool)) v))
+++++
congruence.
-----
Lemma DivTwoPower'_correct_bs : forall l, Sem DivTwoPower'_e l = fun_power (length (hd nil l)) (@tl _) (hd nil (tl l)).
Proof.
intros [ | u [ | v l] ].
simpl.
induction u as [ | [ | ] u IH].

*****
IH : eq\n (sem_Rec (fun vl : list (list bool) => nth O vl nil)\n (fun vl : list (list bool) =>\n Sem Div2_e (cons (nth (S O) vl nil) nil))\n (fun vl : list (list bool) =>\n Sem Div2_e (cons (nth (S O) vl nil) nil)) u \n (cons v l)) (fun_power (length u) (tl (A:=bool)) v)
l : list (list bool)
u,v : list bool
*****
eq (sem_Rec (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => Sem Div2_e (cons (nth (S O) vl nil) nil)) (fun vl : list (list bool) => Sem Div2_e (cons (nth (S O) vl nil) nil)) (cons false u) (cons v l)) (fun_power (length (cons false u)) (tl (A:=bool)) v)
+++++
simpl.
-----
Lemma DivTwoPower'_correct_bs : forall l, Sem DivTwoPower'_e l = fun_power (length (hd nil l)) (@tl _) (hd nil (tl l)).
Proof.
intros [ | u [ | v l] ].
simpl.
induction u as [ | [ | ] u IH].
simpl.

*****
IH : eq\n (sem_Rec (fun vl : list (list bool) => nth O vl nil)\n (fun vl : list (list bool) =>\n Sem Div2_e (cons (nth (S O) vl nil) nil))\n (fun vl : list (list bool) =>\n Sem Div2_e (cons (nth (S O) vl nil) nil)) u \n (cons v l)) (fun_power (length u) (tl (A:=bool)) v)
l : list (list bool)
u,v : list bool
*****
eq (Sem Div2_e (cons (sem_Rec (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => Sem Div2_e (cons (nth (S O) vl nil) nil)) (fun vl : list (list bool) => Sem Div2_e (cons (nth (S O) vl nil) nil)) u (cons v l)) nil)) (tl (fun_power (length u) (tl (A:=bool)) v))
+++++
rewrite Div2_correct_bs.
-----
Lemma DivTwoPower'_correct_bs : forall l, Sem DivTwoPower'_e l = fun_power (length (hd nil l)) (@tl _) (hd nil (tl l)).
Proof.
intros [ | u [ | v l] ].
simpl.
induction u as [ | [ | ] u IH].
simpl.
rewrite Div2_correct_bs.

*****
IH : eq\n (sem_Rec (fun vl : list (list bool) => nth O vl nil)\n (fun vl : list (list bool) =>\n Sem Div2_e (cons (nth (S O) vl nil) nil))\n (fun vl : list (list bool) =>\n Sem Div2_e (cons (nth (S O) vl nil) nil)) u \n (cons v l)) (fun_power (length u) (tl (A:=bool)) v)
l : list (list bool)
u,v : list bool
*****
eq (tl (hd nil (cons (sem_Rec (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => Sem Div2_e (cons (nth (S O) vl nil) nil)) (fun vl : list (list bool) => Sem Div2_e (cons (nth (S O) vl nil) nil)) u (cons v l)) nil))) (tl (fun_power (length u) (tl (A:=bool)) v))
+++++
simpl.
-----
Lemma DivTwoPower'_correct_bs : forall l, Sem DivTwoPower'_e l = fun_power (length (hd nil l)) (@tl _) (hd nil (tl l)).
Proof.
intros [ | u [ | v l] ].
simpl.
induction u as [ | [ | ] u IH].
simpl.
rewrite Div2_correct_bs.
simpl.

*****
IH : eq\n (sem_Rec (fun vl : list (list bool) => nth O vl nil)\n (fun vl : list (list bool) =>\n Sem Div2_e (cons (nth (S O) vl nil) nil))\n (fun vl : list (list bool) =>\n Sem Div2_e (cons (nth (S O) vl nil) nil)) u \n (cons v l)) (fun_power (length u) (tl (A:=bool)) v)
l : list (list bool)
u,v : list bool
*****
eq (tl (sem_Rec (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => Sem Div2_e (cons (nth (S O) vl nil) nil)) (fun vl : list (list bool) => Sem Div2_e (cons (nth (S O) vl nil) nil)) u (cons v l))) (tl (fun_power (length u) (tl (A:=bool)) v))
+++++
congruence.
-----
Lemma DivTwoPower'_correct_bs : forall l, Sem DivTwoPower'_e l = fun_power (length (hd nil l)) (@tl _) (hd nil (tl l)).
Proof.
intros [ | u [ | v l] ].

*****

*****

+++++
Qed.
-----
Lemma DivTwoPower'_correct : forall l,\n  bs2nat (Sem DivTwoPower'_e l) =\n  fun_power (length (hd nil l)) div2 (bs2nat (hd nil (tl l))).
-----
Lemma DivTwoPower'_correct : forall l, bs2nat (Sem DivTwoPower'_e l) = fun_power (length (hd nil l)) div2 (bs2nat (hd nil (tl l))).

*****

*****
forall l : list (list bool), eq (bs2nat (Sem DivTwoPower'_e l)) (fun_power (length (hd nil l)) Nat.div2 (bs2nat (hd nil (tl l))))
+++++
Proof.
-----
Lemma DivTwoPower'_correct : forall l, bs2nat (Sem DivTwoPower'_e l) = fun_power (length (hd nil l)) div2 (bs2nat (hd nil (tl l))).
Proof.

*****

*****
forall l : list (list bool), eq (bs2nat (Sem DivTwoPower'_e l)) (fun_power (length (hd nil l)) Nat.div2 (bs2nat (hd nil (tl l))))
+++++
intro l.
-----
Lemma DivTwoPower'_correct : forall l, bs2nat (Sem DivTwoPower'_e l) = fun_power (length (hd nil l)) div2 (bs2nat (hd nil (tl l))).
Proof.
intro l.

*****
l : list (list bool)
*****
eq (bs2nat (Sem DivTwoPower'_e l)) (fun_power (length (hd nil l)) Nat.div2 (bs2nat (hd nil (tl l))))
+++++
rewrite DivTwoPower'_correct_bs.
-----
Lemma DivTwoPower'_correct : forall l, bs2nat (Sem DivTwoPower'_e l) = fun_power (length (hd nil l)) div2 (bs2nat (hd nil (tl l))).
Proof.
intro l.
rewrite DivTwoPower'_correct_bs.

*****
l : list (list bool)
*****
eq (bs2nat (fun_power (length (hd nil l)) (tl (A:=bool)) (hd nil (tl l)))) (fun_power (length (hd nil l)) Nat.div2 (bs2nat (hd nil (tl l))))
+++++
induction (length (hd nil l)).
-----
Lemma DivTwoPower'_correct : forall l, bs2nat (Sem DivTwoPower'_e l) = fun_power (length (hd nil l)) div2 (bs2nat (hd nil (tl l))).
Proof.
intro l.
rewrite DivTwoPower'_correct_bs.
induction (length (hd nil l)).

*****
l : list (list bool)
*****
eq (bs2nat (fun_power O (tl (A:=bool)) (hd nil (tl l)))) (fun_power O Nat.div2 (bs2nat (hd nil (tl l))))
+++++
trivial.
-----
Lemma DivTwoPower'_correct : forall l, bs2nat (Sem DivTwoPower'_e l) = fun_power (length (hd nil l)) div2 (bs2nat (hd nil (tl l))).
Proof.
intro l.
rewrite DivTwoPower'_correct_bs.
induction (length (hd nil l)).

*****
IHn : eq (bs2nat (fun_power n (tl (A:=bool)) (hd nil (tl l))))\n (fun_power n Nat.div2 (bs2nat (hd nil (tl l))))
n : nat
l : list (list bool)
*****
eq (bs2nat (fun_power (S n) (tl (A:=bool)) (hd nil (tl l)))) (fun_power (S n) Nat.div2 (bs2nat (hd nil (tl l))))
+++++
simpl.
-----
Lemma DivTwoPower'_correct : forall l, bs2nat (Sem DivTwoPower'_e l) = fun_power (length (hd nil l)) div2 (bs2nat (hd nil (tl l))).
Proof.
intro l.
rewrite DivTwoPower'_correct_bs.
induction (length (hd nil l)).
simpl.

*****
IHn : eq (bs2nat (fun_power n (tl (A:=bool)) (hd nil (tl l))))\n (fun_power n Nat.div2 (bs2nat (hd nil (tl l))))
n : nat
l : list (list bool)
*****
eq (bs2nat (tl (fun_power n (tl (A:=bool)) (hd nil (tl l))))) (Nat.div2 (fun_power n Nat.div2 (bs2nat (hd nil (tl l)))))
+++++
rewrite bs2nat_tl.
-----
Lemma DivTwoPower'_correct : forall l, bs2nat (Sem DivTwoPower'_e l) = fun_power (length (hd nil l)) div2 (bs2nat (hd nil (tl l))).
Proof.
intro l.
rewrite DivTwoPower'_correct_bs.
induction (length (hd nil l)).
simpl.
rewrite bs2nat_tl.

*****
IHn : eq (bs2nat (fun_power n (tl (A:=bool)) (hd nil (tl l))))\n (fun_power n Nat.div2 (bs2nat (hd nil (tl l))))
n : nat
l : list (list bool)
*****
eq (Nat.div2 (bs2nat (fun_power n (tl (A:=bool)) (hd nil (tl l))))) (Nat.div2 (fun_power n Nat.div2 (bs2nat (hd nil (tl l)))))
+++++
congruence.
-----
Lemma DivTwoPower'_correct : forall l, bs2nat (Sem DivTwoPower'_e l) = fun_power (length (hd nil l)) div2 (bs2nat (hd nil (tl l))).
Proof.
intro l.
rewrite DivTwoPower'_correct_bs.
induction (length (hd nil l)).

*****

*****

+++++
Qed.
-----
Opaque DivTwoPower'_e.
-----
Definition DivTwoPower_e : Cobham :=\n  Comp 2 DivTwoPower'_e [Proj 2 1; Proj 2 0].
-----
Lemma arity_DivTwoPower :\n  arity DivTwoPower_e = ok_arity 2.
-----
Lemma arity_DivTwoPower : arity DivTwoPower_e = ok_arity 2.

*****

*****
eq (arity DivTwoPower_e) (ok_arity (S (S O)))
+++++
Proof.
-----
Lemma arity_DivTwoPower : arity DivTwoPower_e = ok_arity 2.
Proof.

*****

*****
eq (arity DivTwoPower_e) (ok_arity (S (S O)))
+++++
trivial.
-----
Lemma arity_DivTwoPower : arity DivTwoPower_e = ok_arity 2.
Proof.
trivial.

*****

*****

+++++
Qed.
-----
Lemma rec_bounded_DivTwoPower :\n  rec_bounded DivTwoPower_e.
-----
Lemma rec_bounded_DivTwoPower : rec_bounded DivTwoPower_e.

*****

*****
rec_bounded DivTwoPower_e
+++++
Proof.
-----
Lemma rec_bounded_DivTwoPower : rec_bounded DivTwoPower_e.
Proof.

*****

*****
rec_bounded DivTwoPower_e
+++++
simpl.
-----
Lemma rec_bounded_DivTwoPower : rec_bounded DivTwoPower_e.
Proof.
simpl.

*****

*****
and (rec_bounded DivTwoPower'_e) (and True (and True True))
+++++
intuition.
-----
Lemma rec_bounded_DivTwoPower : rec_bounded DivTwoPower_e.
Proof.
simpl.
intuition.

*****

*****
rec_bounded DivTwoPower'_e
+++++
apply rec_bounded_DivTwoPower'.
-----
Lemma rec_bounded_DivTwoPower : rec_bounded DivTwoPower_e.
Proof.
simpl.
intuition.
apply rec_bounded_DivTwoPower'.

*****

*****

+++++
Qed.
-----
Lemma DivTwoPower_correct_bs : forall l,\n  Sem DivTwoPower_e l =\n  fun_power (length (hd nil (tl l))) (@tl _) (hd nil l).
-----
Lemma DivTwoPower_correct_bs : forall l, Sem DivTwoPower_e l = fun_power (length (hd nil (tl l))) (@tl _) (hd nil l).

*****

*****
forall l : list (list bool), eq (Sem DivTwoPower_e l) (fun_power (length (hd nil (tl l))) (tl (A:=bool)) (hd nil l))
+++++
Proof.
-----
Lemma DivTwoPower_correct_bs : forall l, Sem DivTwoPower_e l = fun_power (length (hd nil (tl l))) (@tl _) (hd nil l).
Proof.

*****

*****
forall l : list (list bool), eq (Sem DivTwoPower_e l) (fun_power (length (hd nil (tl l))) (tl (A:=bool)) (hd nil l))
+++++
intro l.
-----
Lemma DivTwoPower_correct_bs : forall l, Sem DivTwoPower_e l = fun_power (length (hd nil (tl l))) (@tl _) (hd nil l).
Proof.
intro l.

*****
l : list (list bool)
*****
eq (Sem DivTwoPower_e l) (fun_power (length (hd nil (tl l))) (tl (A:=bool)) (hd nil l))
+++++
simpl.
-----
Lemma DivTwoPower_correct_bs : forall l, Sem DivTwoPower_e l = fun_power (length (hd nil (tl l))) (@tl _) (hd nil l).
Proof.
intro l.
simpl.

*****
l : list (list bool)
*****
eq (Sem DivTwoPower'_e (cons (nth (S O) l nil) (cons (nth O l nil) nil))) (fun_power (length (hd nil (tl l))) (tl (A:=bool)) (hd nil l))
+++++
rewrite DivTwoPower'_correct_bs.
-----
Lemma DivTwoPower_correct_bs : forall l, Sem DivTwoPower_e l = fun_power (length (hd nil (tl l))) (@tl _) (hd nil l).
Proof.
intro l.
simpl.
rewrite DivTwoPower'_correct_bs.

*****
l : list (list bool)
*****
eq (fun_power (length (hd nil (cons (nth (S O) l nil) (cons (nth O l nil) nil)))) (tl (A:=bool)) (hd nil (tl (cons (nth (S O) l nil) (cons (nth O l nil) nil))))) (fun_power (length (hd nil (tl l))) (tl (A:=bool)) (hd nil l))
+++++
simpl.
-----
Lemma DivTwoPower_correct_bs : forall l, Sem DivTwoPower_e l = fun_power (length (hd nil (tl l))) (@tl _) (hd nil l).
Proof.
intro l.
simpl.
rewrite DivTwoPower'_correct_bs.
simpl.

*****
l : list (list bool)
*****
eq (fun_power (length (nth (S O) l nil)) (tl (A:=bool)) (nth O l nil)) (fun_power (length (hd nil (tl l))) (tl (A:=bool)) (hd nil l))
+++++
rewrite <- hd_nth_0.
-----
Lemma DivTwoPower_correct_bs : forall l, Sem DivTwoPower_e l = fun_power (length (hd nil (tl l))) (@tl _) (hd nil l).
Proof.
intro l.
simpl.
rewrite DivTwoPower'_correct_bs.
simpl.
rewrite <- hd_nth_0.

*****
l : list (list bool)
*****
eq (fun_power (length (nth (S O) l nil)) (tl (A:=bool)) (hd nil l)) (fun_power (length (hd nil (tl l))) (tl (A:=bool)) (hd nil l))
+++++
rewrite <- hd_nth_1.
-----
Lemma DivTwoPower_correct_bs : forall l, Sem DivTwoPower_e l = fun_power (length (hd nil (tl l))) (@tl _) (hd nil l).
Proof.
intro l.
simpl.
rewrite DivTwoPower'_correct_bs.
simpl.
rewrite <- hd_nth_0.
rewrite <- hd_nth_1.

*****
l : list (list bool)
*****
eq (fun_power (length (hd nil (tl l))) (tl (A:=bool)) (hd nil l)) (fun_power (length (hd nil (tl l))) (tl (A:=bool)) (hd nil l))
+++++
trivial.
-----
Lemma DivTwoPower_correct_bs : forall l, Sem DivTwoPower_e l = fun_power (length (hd nil (tl l))) (@tl _) (hd nil l).
Proof.
intro l.
simpl.
rewrite DivTwoPower'_correct_bs.
simpl.
rewrite <- hd_nth_0.
rewrite <- hd_nth_1.
trivial.

*****

*****

+++++
Qed.
-----
Lemma length_DivTwoPower : forall l,\n  length (Sem DivTwoPower_e l) = length (hd nil l) - length (hd nil (tl l)).
-----
Lemma length_DivTwoPower : forall l, length (Sem DivTwoPower_e l) = length (hd nil l) - length (hd nil (tl l)).

*****

*****
forall l : list (list bool), eq (length (Sem DivTwoPower_e l)) (Init.Nat.sub (length (hd nil l)) (length (hd nil (tl l))))
+++++
Proof.
-----
Lemma length_DivTwoPower : forall l, length (Sem DivTwoPower_e l) = length (hd nil l) - length (hd nil (tl l)).
Proof.

*****

*****
forall l : list (list bool), eq (length (Sem DivTwoPower_e l)) (Init.Nat.sub (length (hd nil l)) (length (hd nil (tl l))))
+++++
intro l.
-----
Lemma length_DivTwoPower : forall l, length (Sem DivTwoPower_e l) = length (hd nil l) - length (hd nil (tl l)).
Proof.
intro l.

*****
l : list (list bool)
*****
eq (length (Sem DivTwoPower_e l)) (Init.Nat.sub (length (hd nil l)) (length (hd nil (tl l))))
+++++
simpl.
-----
Lemma length_DivTwoPower : forall l, length (Sem DivTwoPower_e l) = length (hd nil l) - length (hd nil (tl l)).
Proof.
intro l.
simpl.

*****
l : list (list bool)
*****
eq (length (Sem DivTwoPower'_e (cons (nth (S O) l nil) (cons (nth O l nil) nil)))) (Init.Nat.sub (length (hd nil l)) (length (hd nil (tl l))))
+++++
rewrite length_DivTwoPower'.
-----
Lemma length_DivTwoPower : forall l, length (Sem DivTwoPower_e l) = length (hd nil l) - length (hd nil (tl l)).
Proof.
intro l.
simpl.
rewrite length_DivTwoPower'.

*****
l : list (list bool)
*****
eq (Init.Nat.sub (length (hd nil (tl (cons (nth (S O) l nil) (cons (nth O l nil) nil))))) (length (hd nil (cons (nth (S O) l nil) (cons (nth O l nil) nil))))) (Init.Nat.sub (length (hd nil l)) (length (hd nil (tl l))))
+++++
simpl.
-----
Lemma length_DivTwoPower : forall l, length (Sem DivTwoPower_e l) = length (hd nil l) - length (hd nil (tl l)).
Proof.
intro l.
simpl.
rewrite length_DivTwoPower'.
simpl.

*****
l : list (list bool)
*****
eq (Init.Nat.sub (length (nth O l nil)) (length (nth (S O) l nil))) (Init.Nat.sub (length (hd nil l)) (length (hd nil (tl l))))
+++++
rewrite <- hd_nth_0.
-----
Lemma length_DivTwoPower : forall l, length (Sem DivTwoPower_e l) = length (hd nil l) - length (hd nil (tl l)).
Proof.
intro l.
simpl.
rewrite length_DivTwoPower'.
simpl.
rewrite <- hd_nth_0.

*****
l : list (list bool)
*****
eq (Init.Nat.sub (length (hd nil l)) (length (nth (S O) l nil))) (Init.Nat.sub (length (hd nil l)) (length (hd nil (tl l))))
+++++
rewrite <- hd_nth_1.
-----
Lemma length_DivTwoPower : forall l, length (Sem DivTwoPower_e l) = length (hd nil l) - length (hd nil (tl l)).
Proof.
intro l.
simpl.
rewrite length_DivTwoPower'.
simpl.
rewrite <- hd_nth_0.
rewrite <- hd_nth_1.

*****
l : list (list bool)
*****
eq (Init.Nat.sub (length (hd nil l)) (length (hd nil (tl l)))) (Init.Nat.sub (length (hd nil l)) (length (hd nil (tl l))))
+++++
trivial.
-----
Lemma length_DivTwoPower : forall l, length (Sem DivTwoPower_e l) = length (hd nil l) - length (hd nil (tl l)).
Proof.
intro l.
simpl.
rewrite length_DivTwoPower'.
simpl.
rewrite <- hd_nth_0.
rewrite <- hd_nth_1.
trivial.

*****

*****

+++++
Qed.
-----
Lemma skipn_tl : forall n (l : bs),\n  skipn (S n) l = tl (skipn n l).
-----
Lemma skipn_tl : forall n (l : bs), skipn (S n) l = tl (skipn n l).

*****

*****
forall (n : nat) (l : list bool), eq (skipn (S n) l) (tl (skipn n l))
+++++
Proof.
-----
Lemma skipn_tl : forall n (l : bs), skipn (S n) l = tl (skipn n l).
Proof.

*****

*****
forall (n : nat) (l : list bool), eq (skipn (S n) l) (tl (skipn n l))
+++++
intros.
-----
Lemma skipn_tl : forall n (l : bs), skipn (S n) l = tl (skipn n l).
Proof.
intros.

*****
l : list bool
n : nat
*****
eq (skipn (S n) l) (tl (skipn n l))
+++++
destruct (le_lt_dec (length l) n).
-----
Lemma skipn_tl : forall n (l : bs), skipn (S n) l = tl (skipn n l).
Proof.
intros.
destruct (le_lt_dec (length l) n).

*****
l0 : le (length l) n
l : list bool
n : nat
*****
eq (skipn (S n) l) (tl (skipn n l))
+++++
rewrite skipn_nil.
-----
Lemma skipn_tl : forall n (l : bs), skipn (S n) l = tl (skipn n l).
Proof.
intros.
destruct (le_lt_dec (length l) n).
rewrite skipn_nil.

*****
l0 : le (length l) n
l : list bool
n : nat
*****
eq nil (tl (skipn n l))
+++++
simpl.
-----
Lemma skipn_tl : forall n (l : bs), skipn (S n) l = tl (skipn n l).
Proof.
intros.
destruct (le_lt_dec (length l) n).
rewrite skipn_nil.
simpl.

*****
l0 : le (length l) n
l : list bool
n : nat
*****
eq nil (tl (skipn n l))
+++++
rewrite skipn_nil.
-----
Lemma skipn_tl : forall n (l : bs), skipn (S n) l = tl (skipn n l).
Proof.
intros.
destruct (le_lt_dec (length l) n).
rewrite skipn_nil.
simpl.
rewrite skipn_nil.

*****
l0 : le (length l) n
l : list bool
n : nat
*****
eq nil (tl nil)
+++++
simpl.
-----
Lemma skipn_tl : forall n (l : bs), skipn (S n) l = tl (skipn n l).
Proof.
intros.
destruct (le_lt_dec (length l) n).
rewrite skipn_nil.
simpl.
rewrite skipn_nil.
simpl.

*****
l0 : le (length l) n
l : list bool
n : nat
*****
eq nil nil
+++++
auto.
-----
Lemma skipn_tl : forall n (l : bs), skipn (S n) l = tl (skipn n l).
Proof.
intros.
destruct (le_lt_dec (length l) n).
rewrite skipn_nil.
simpl.
rewrite skipn_nil.

*****
l0 : le (length l) n
l : list bool
n : nat
*****
le (length l) n
+++++
simpl.
-----
Lemma skipn_tl : forall n (l : bs), skipn (S n) l = tl (skipn n l).
Proof.
intros.
destruct (le_lt_dec (length l) n).
rewrite skipn_nil.
simpl.
rewrite skipn_nil.
simpl.

*****
l0 : le (length l) n
l : list bool
n : nat
*****
le (length l) n
+++++
auto.
-----
Lemma skipn_tl : forall n (l : bs), skipn (S n) l = tl (skipn n l).
Proof.
intros.
destruct (le_lt_dec (length l) n).
rewrite skipn_nil.

*****
l0 : le (length l) n
l : list bool
n : nat
*****
le (length l) (S n)
+++++
simpl.
-----
Lemma skipn_tl : forall n (l : bs), skipn (S n) l = tl (skipn n l).
Proof.
intros.
destruct (le_lt_dec (length l) n).
rewrite skipn_nil.
simpl.

*****
l0 : le (length l) n
l : list bool
n : nat
*****
le (length l) (S n)
+++++
omega.
-----
Lemma skipn_tl : forall n (l : bs), skipn (S n) l = tl (skipn n l).
Proof.
intros.
destruct (le_lt_dec (length l) n).

*****
l0 : lt n (length l)
l : list bool
n : nat
*****
eq (skipn (S n) l) (tl (skipn n l))
+++++
rewrite (skipn_hd n l true).
-----
Lemma skipn_tl : forall n (l : bs), skipn (S n) l = tl (skipn n l).
Proof.
intros.
destruct (le_lt_dec (length l) n).
rewrite (skipn_hd n l true).

*****
l0 : lt n (length l)
l : list bool
n : nat
*****
eq (skipn (S n) l) (tl (cons (nth n l true) (skipn (S n) l)))
+++++
reflexivity.
-----
Lemma skipn_tl : forall n (l : bs), skipn (S n) l = tl (skipn n l).
Proof.
intros.
destruct (le_lt_dec (length l) n).
rewrite (skipn_hd n l true).

*****
l0 : lt n (length l)
l : list bool
n : nat
*****
lt n (length l)
+++++
trivial.
-----
Lemma skipn_tl : forall n (l : bs), skipn (S n) l = tl (skipn n l).
Proof.
intros.
destruct (le_lt_dec (length l) n).

*****

*****

+++++
Qed.
-----
Lemma DivTwoPower_correct : forall l,\n  Sem DivTwoPower_e l =\n  skipn (length (nth 1 l nil)) (nth 0 l nil).
-----
Lemma DivTwoPower_correct : forall l, Sem DivTwoPower_e l = skipn (length (nth 1 l nil)) (nth 0 l nil).

*****

*****
forall l : list (list bool), eq (Sem DivTwoPower_e l) (skipn (length (nth (S O) l nil)) (nth O l nil))
+++++
Proof.
-----
Lemma DivTwoPower_correct : forall l, Sem DivTwoPower_e l = skipn (length (nth 1 l nil)) (nth 0 l nil).
Proof.

*****

*****
forall l : list (list bool), eq (Sem DivTwoPower_e l) (skipn (length (nth (S O) l nil)) (nth O l nil))
+++++
intros l.
-----
Lemma DivTwoPower_correct : forall l, Sem DivTwoPower_e l = skipn (length (nth 1 l nil)) (nth 0 l nil).
Proof.
intros l.

*****
l : list (list bool)
*****
eq (Sem DivTwoPower_e l) (skipn (length (nth (S O) l nil)) (nth O l nil))
+++++
simpl.
-----
Lemma DivTwoPower_correct : forall l, Sem DivTwoPower_e l = skipn (length (nth 1 l nil)) (nth 0 l nil).
Proof.
intros l.
simpl.

*****
l : list (list bool)
*****
eq (Sem DivTwoPower'_e (cons (nth (S O) l nil) (cons (nth O l nil) nil))) (skipn (length (nth (S O) l nil)) (nth O l nil))
+++++
rewrite DivTwoPower'_correct_bs.
-----
Lemma DivTwoPower_correct : forall l, Sem DivTwoPower_e l = skipn (length (nth 1 l nil)) (nth 0 l nil).
Proof.
intros l.
simpl.
rewrite DivTwoPower'_correct_bs.

*****
l : list (list bool)
*****
eq (fun_power (length (hd nil (cons (nth (S O) l nil) (cons (nth O l nil) nil)))) (tl (A:=bool)) (hd nil (tl (cons (nth (S O) l nil) (cons (nth O l nil) nil))))) (skipn (length (nth (S O) l nil)) (nth O l nil))
+++++
simpl.
-----
Lemma DivTwoPower_correct : forall l, Sem DivTwoPower_e l = skipn (length (nth 1 l nil)) (nth 0 l nil).
Proof.
intros l.
simpl.
rewrite DivTwoPower'_correct_bs.
simpl.

*****
l : list (list bool)
*****
eq (fun_power (length (nth (S O) l nil)) (tl (A:=bool)) (nth O l nil)) (skipn (length (nth (S O) l nil)) (nth O l nil))
+++++
induction (nth 1 l nil).
-----
Lemma DivTwoPower_correct : forall l, Sem DivTwoPower_e l = skipn (length (nth 1 l nil)) (nth 0 l nil).
Proof.
intros l.
simpl.
rewrite DivTwoPower'_correct_bs.
simpl.
induction (nth 1 l nil).

*****
l : list (list bool)
*****
eq (fun_power (length nil) (tl (A:=bool)) (nth O l nil)) (skipn (length nil) (nth O l nil))
+++++
simpl.
-----
Lemma DivTwoPower_correct : forall l, Sem DivTwoPower_e l = skipn (length (nth 1 l nil)) (nth 0 l nil).
Proof.
intros l.
simpl.
rewrite DivTwoPower'_correct_bs.
simpl.
induction (nth 1 l nil).
simpl.

*****
l : list (list bool)
*****
eq (nth O l nil) (nth O l nil)
+++++
auto.
-----
Lemma DivTwoPower_correct : forall l, Sem DivTwoPower_e l = skipn (length (nth 1 l nil)) (nth 0 l nil).
Proof.
intros l.
simpl.
rewrite DivTwoPower'_correct_bs.
simpl.
induction (nth 1 l nil).

*****
IHl0 : eq (fun_power (length l0) (tl (A:=bool)) (nth O l nil))\n (skipn (length l0) (nth O l nil))
l0 : list bool
a : bool
l : list (list bool)
*****
eq (fun_power (length (cons a l0)) (tl (A:=bool)) (nth O l nil)) (skipn (length (cons a l0)) (nth O l nil))
+++++
simpl.
-----
Lemma DivTwoPower_correct : forall l, Sem DivTwoPower_e l = skipn (length (nth 1 l nil)) (nth 0 l nil).
Proof.
intros l.
simpl.
rewrite DivTwoPower'_correct_bs.
simpl.
induction (nth 1 l nil).
simpl.

*****
IHl0 : eq (fun_power (length l0) (tl (A:=bool)) (nth O l nil))\n (skipn (length l0) (nth O l nil))
l0 : list bool
a : bool
l : list (list bool)
*****
eq (tl (fun_power (length l0) (tl (A:=bool)) (nth O l nil))) match nth O l nil with | nil => nil | cons _ l => skipn (length l0) l end
+++++
auto.
-----
Lemma DivTwoPower_correct : forall l, Sem DivTwoPower_e l = skipn (length (nth 1 l nil)) (nth 0 l nil).
Proof.
intros l.
simpl.
rewrite DivTwoPower'_correct_bs.
simpl.
induction (nth 1 l nil).
simpl.
auto.

*****
IHl0 : eq (fun_power (length l0) (tl (A:=bool)) (nth O l nil))\n (skipn (length l0) (nth O l nil))
l0 : list bool
a : bool
l : list (list bool)
*****
eq (tl (fun_power (length l0) (tl (A:=bool)) (nth O l nil))) match nth O l nil with | nil => nil | cons _ l => skipn (length l0) l end
+++++
rewrite IHl0.
-----
Lemma DivTwoPower_correct : forall l, Sem DivTwoPower_e l = skipn (length (nth 1 l nil)) (nth 0 l nil).
Proof.
intros l.
simpl.
rewrite DivTwoPower'_correct_bs.
simpl.
induction (nth 1 l nil).
simpl.
auto.
rewrite IHl0.

*****
IHl0 : eq (fun_power (length l0) (tl (A:=bool)) (nth O l nil))\n (skipn (length l0) (nth O l nil))
l0 : list bool
a : bool
l : list (list bool)
*****
eq (tl (skipn (length l0) (nth O l nil))) match nth O l nil with | nil => nil | cons _ l => skipn (length l0) l end
+++++
destruct (nth 0 l nil).
-----
Lemma DivTwoPower_correct : forall l, Sem DivTwoPower_e l = skipn (length (nth 1 l nil)) (nth 0 l nil).
Proof.
intros l.
simpl.
rewrite DivTwoPower'_correct_bs.
simpl.
induction (nth 1 l nil).
simpl.
auto.
rewrite IHl0.
destruct (nth 0 l nil).

*****
IHl0 : eq (fun_power (length l0) (tl (A:=bool)) nil) (skipn (length l0) nil)
l0 : list bool
a : bool
l : list (list bool)
*****
eq (tl (skipn (length l0) nil)) nil
+++++
simpl.
-----
Lemma DivTwoPower_correct : forall l, Sem DivTwoPower_e l = skipn (length (nth 1 l nil)) (nth 0 l nil).
Proof.
intros l.
simpl.
rewrite DivTwoPower'_correct_bs.
simpl.
induction (nth 1 l nil).
simpl.
auto.
rewrite IHl0.
destruct (nth 0 l nil).
simpl.

*****
IHl0 : eq (fun_power (length l0) (tl (A:=bool)) nil) (skipn (length l0) nil)
l0 : list bool
a : bool
l : list (list bool)
*****
eq (tl (skipn (length l0) nil)) nil
+++++
rewrite skipn_nil.
-----
Lemma DivTwoPower_correct : forall l, Sem DivTwoPower_e l = skipn (length (nth 1 l nil)) (nth 0 l nil).
Proof.
intros l.
simpl.
rewrite DivTwoPower'_correct_bs.
simpl.
induction (nth 1 l nil).
simpl.
auto.
rewrite IHl0.
destruct (nth 0 l nil).
simpl.
rewrite skipn_nil.

*****
IHl0 : eq (fun_power (length l0) (tl (A:=bool)) nil) (skipn (length l0) nil)
l0 : list bool
a : bool
l : list (list bool)
*****
eq (tl nil) nil
+++++
simpl.
-----
Lemma DivTwoPower_correct : forall l, Sem DivTwoPower_e l = skipn (length (nth 1 l nil)) (nth 0 l nil).
Proof.
intros l.
simpl.
rewrite DivTwoPower'_correct_bs.
simpl.
induction (nth 1 l nil).
simpl.
auto.
rewrite IHl0.
destruct (nth 0 l nil).
simpl.
rewrite skipn_nil.
simpl.

*****
IHl0 : eq (fun_power (length l0) (tl (A:=bool)) nil) (skipn (length l0) nil)
l0 : list bool
a : bool
l : list (list bool)
*****
eq nil nil
+++++
auto.
-----
Lemma DivTwoPower_correct : forall l, Sem DivTwoPower_e l = skipn (length (nth 1 l nil)) (nth 0 l nil).
Proof.
intros l.
simpl.
rewrite DivTwoPower'_correct_bs.
simpl.
induction (nth 1 l nil).
simpl.
auto.
rewrite IHl0.
destruct (nth 0 l nil).
simpl.
rewrite skipn_nil.

*****
IHl0 : eq (fun_power (length l0) (tl (A:=bool)) nil) (skipn (length l0) nil)
l0 : list bool
a : bool
l : list (list bool)
*****
le (length nil) (length l0)
+++++
simpl.
-----
Lemma DivTwoPower_correct : forall l, Sem DivTwoPower_e l = skipn (length (nth 1 l nil)) (nth 0 l nil).
Proof.
intros l.
simpl.
rewrite DivTwoPower'_correct_bs.
simpl.
induction (nth 1 l nil).
simpl.
auto.
rewrite IHl0.
destruct (nth 0 l nil).
simpl.
rewrite skipn_nil.
simpl.

*****
IHl0 : eq (fun_power (length l0) (tl (A:=bool)) nil) (skipn (length l0) nil)
l0 : list bool
a : bool
l : list (list bool)
*****
le O (length l0)
+++++
auto.
-----
Lemma DivTwoPower_correct : forall l, Sem DivTwoPower_e l = skipn (length (nth 1 l nil)) (nth 0 l nil).
Proof.
intros l.
simpl.
rewrite DivTwoPower'_correct_bs.
simpl.
induction (nth 1 l nil).
simpl.
auto.
rewrite IHl0.
destruct (nth 0 l nil).
simpl.
rewrite skipn_nil.
simpl.
auto.

*****
IHl0 : eq (fun_power (length l0) (tl (A:=bool)) nil) (skipn (length l0) nil)
l0 : list bool
a : bool
l : list (list bool)
*****
le O (length l0)
+++++
omega.
-----
Lemma DivTwoPower_correct : forall l, Sem DivTwoPower_e l = skipn (length (nth 1 l nil)) (nth 0 l nil).
Proof.
intros l.
simpl.
rewrite DivTwoPower'_correct_bs.
simpl.
induction (nth 1 l nil).
simpl.
auto.
rewrite IHl0.
destruct (nth 0 l nil).

*****
IHl0 : eq (fun_power (length l0) (tl (A:=bool)) (cons b l1))\n (skipn (length l0) (cons b l1))
l1 : list bool
b : bool
l0 : list bool
a : bool
l : list (list bool)
*****
eq (tl (skipn (length l0) (cons b l1))) (skipn (length l0) l1)
+++++
simpl.
-----
Lemma DivTwoPower_correct : forall l, Sem DivTwoPower_e l = skipn (length (nth 1 l nil)) (nth 0 l nil).
Proof.
intros l.
simpl.
rewrite DivTwoPower'_correct_bs.
simpl.
induction (nth 1 l nil).
simpl.
auto.
rewrite IHl0.
destruct (nth 0 l nil).
simpl.

*****
IHl0 : eq (fun_power (length l0) (tl (A:=bool)) (cons b l1))\n (skipn (length l0) (cons b l1))
l1 : list bool
b : bool
l0 : list bool
a : bool
l : list (list bool)
*****
eq (tl (skipn (length l0) (cons b l1))) (skipn (length l0) l1)
+++++
rewrite <- skipn_tl.
-----
Lemma DivTwoPower_correct : forall l, Sem DivTwoPower_e l = skipn (length (nth 1 l nil)) (nth 0 l nil).
Proof.
intros l.
simpl.
rewrite DivTwoPower'_correct_bs.
simpl.
induction (nth 1 l nil).
simpl.
auto.
rewrite IHl0.
destruct (nth 0 l nil).
simpl.
rewrite <- skipn_tl.

*****
IHl0 : eq (fun_power (length l0) (tl (A:=bool)) (cons b l1))\n (skipn (length l0) (cons b l1))
l1 : list bool
b : bool
l0 : list bool
a : bool
l : list (list bool)
*****
eq (skipn (S (length l0)) (cons b l1)) (skipn (length l0) l1)
+++++
simpl.
-----
Lemma DivTwoPower_correct : forall l, Sem DivTwoPower_e l = skipn (length (nth 1 l nil)) (nth 0 l nil).
Proof.
intros l.
simpl.
rewrite DivTwoPower'_correct_bs.
simpl.
induction (nth 1 l nil).
simpl.
auto.
rewrite IHl0.
destruct (nth 0 l nil).
simpl.
rewrite <- skipn_tl.
simpl.

*****
IHl0 : eq (fun_power (length l0) (tl (A:=bool)) (cons b l1))\n (skipn (length l0) (cons b l1))
l1 : list bool
b : bool
l0 : list bool
a : bool
l : list (list bool)
*****
eq (skipn (length l0) l1) (skipn (length l0) l1)
+++++
trivial.
-----
Lemma DivTwoPower_correct : forall l, Sem DivTwoPower_e l = skipn (length (nth 1 l nil)) (nth 0 l nil).
Proof.
intros l.
simpl.
rewrite DivTwoPower'_correct_bs.
simpl.
induction (nth 1 l nil).

*****

*****

+++++
Qed.
-----
Opaque DivTwoPower_e.
-----
Definition DivDivTwoPower_e : Cobham :=\n  Comp 3 DivTwoPower_e [Proj 3 0; Comp 3 DivTwoPower_e [Proj 3 1; Proj 3 2] ].
-----
Lemma arity_DivDivTwoPower :\n  arity DivDivTwoPower_e = ok_arity 3.
-----
Lemma arity_DivDivTwoPower : arity DivDivTwoPower_e = ok_arity 3.

*****

*****
eq (arity DivDivTwoPower_e) (ok_arity (S (S (S O))))
+++++
Proof.
-----
Lemma arity_DivDivTwoPower : arity DivDivTwoPower_e = ok_arity 3.
Proof.

*****

*****
eq (arity DivDivTwoPower_e) (ok_arity (S (S (S O))))
+++++
trivial.
-----
Lemma arity_DivDivTwoPower : arity DivDivTwoPower_e = ok_arity 3.
Proof.
trivial.

*****

*****

+++++
Qed.
-----
Lemma rec_bounded_DivDivTwoPower :\n  rec_bounded DivDivTwoPower_e.
-----
Lemma rec_bounded_DivDivTwoPower : rec_bounded DivDivTwoPower_e.

*****

*****
rec_bounded DivDivTwoPower_e
+++++
Proof.
-----
Lemma rec_bounded_DivDivTwoPower : rec_bounded DivDivTwoPower_e.
Proof.

*****

*****
rec_bounded DivDivTwoPower_e
+++++
simpl.
-----
Lemma rec_bounded_DivDivTwoPower : rec_bounded DivDivTwoPower_e.
Proof.
simpl.

*****

*****
and (rec_bounded DivTwoPower_e) (and True (and (and (rec_bounded DivTwoPower_e) (and True (and True True))) True))
+++++
intuition.
-----
Lemma rec_bounded_DivDivTwoPower : rec_bounded DivDivTwoPower_e.
Proof.
simpl.
intuition.

*****

*****
rec_bounded DivTwoPower_e
+++++
apply rec_bounded_DivTwoPower.
-----
Lemma rec_bounded_DivDivTwoPower : rec_bounded DivDivTwoPower_e.
Proof.
simpl.
intuition.

*****

*****
rec_bounded DivTwoPower_e
+++++
apply rec_bounded_DivTwoPower.
-----
Lemma rec_bounded_DivDivTwoPower : rec_bounded DivDivTwoPower_e.
Proof.
simpl.
intuition.

*****

*****

+++++
Qed.
-----
Lemma DivDivTwoPower_correct : forall l,\n  Sem DivDivTwoPower_e l =\n  skipn (length (nth 1 l nil) - length (nth 2 l nil)) (nth 0 l nil).
-----
Lemma DivDivTwoPower_correct : forall l, Sem DivDivTwoPower_e l = skipn (length (nth 1 l nil) - length (nth 2 l nil)) (nth 0 l nil).

*****

*****
forall l : list (list bool), eq (Sem DivDivTwoPower_e l) (skipn (Init.Nat.sub (length (nth (S O) l nil)) (length (nth (S (S O)) l nil))) (nth O l nil))
+++++
Proof.
-----
Lemma DivDivTwoPower_correct : forall l, Sem DivDivTwoPower_e l = skipn (length (nth 1 l nil) - length (nth 2 l nil)) (nth 0 l nil).
Proof.

*****

*****
forall l : list (list bool), eq (Sem DivDivTwoPower_e l) (skipn (Init.Nat.sub (length (nth (S O) l nil)) (length (nth (S (S O)) l nil))) (nth O l nil))
+++++
intros l.
-----
Lemma DivDivTwoPower_correct : forall l, Sem DivDivTwoPower_e l = skipn (length (nth 1 l nil) - length (nth 2 l nil)) (nth 0 l nil).
Proof.
intros l.

*****
l : list (list bool)
*****
eq (Sem DivDivTwoPower_e l) (skipn (Init.Nat.sub (length (nth (S O) l nil)) (length (nth (S (S O)) l nil))) (nth O l nil))
+++++
simpl.
-----
Lemma DivDivTwoPower_correct : forall l, Sem DivDivTwoPower_e l = skipn (length (nth 1 l nil) - length (nth 2 l nil)) (nth 0 l nil).
Proof.
intros l.
simpl.

*****
l : list (list bool)
*****
eq (Sem DivTwoPower_e (cons (nth O l nil) (cons (Sem DivTwoPower_e (cons (nth (S O) l nil) (cons (nth (S (S O)) l nil) nil))) nil))) (skipn (Init.Nat.sub (length (nth (S O) l nil)) (length (nth (S (S O)) l nil))) (nth O l nil))
+++++
rewrite DivTwoPower_correct.
-----
Lemma DivDivTwoPower_correct : forall l, Sem DivDivTwoPower_e l = skipn (length (nth 1 l nil) - length (nth 2 l nil)) (nth 0 l nil).
Proof.
intros l.
simpl.
rewrite DivTwoPower_correct.

*****
l : list (list bool)
*****
eq (skipn (length (nth (S O) (cons (nth O l nil) (cons (Sem DivTwoPower_e (cons (nth (S O) l nil) (cons (nth (S (S O)) l nil) nil))) nil)) nil)) (nth O (cons (nth O l nil) (cons (Sem DivTwoPower_e (cons (nth (S O) l nil) (cons (nth (S (S O)) l nil) nil))) nil)) nil)) (skipn (Init.Nat.sub (length (nth (S O) l nil)) (length (nth (S (S O)) l nil))) (nth O l nil))
+++++
simpl.
-----
Lemma DivDivTwoPower_correct : forall l, Sem DivDivTwoPower_e l = skipn (length (nth 1 l nil) - length (nth 2 l nil)) (nth 0 l nil).
Proof.
intros l.
simpl.
rewrite DivTwoPower_correct.
simpl.

*****
l : list (list bool)
*****
eq (skipn (length (Sem DivTwoPower_e (cons (nth (S O) l nil) (cons (nth (S (S O)) l nil) nil)))) (nth O l nil)) (skipn (Init.Nat.sub (length (nth (S O) l nil)) (length (nth (S (S O)) l nil))) (nth O l nil))
+++++
rewrite DivTwoPower_correct.
-----
Lemma DivDivTwoPower_correct : forall l, Sem DivDivTwoPower_e l = skipn (length (nth 1 l nil) - length (nth 2 l nil)) (nth 0 l nil).
Proof.
intros l.
simpl.
rewrite DivTwoPower_correct.
simpl.
rewrite DivTwoPower_correct.

*****
l : list (list bool)
*****
eq (skipn (length (skipn (length (nth (S O) (cons (nth (S O) l nil) (cons (nth (S (S O)) l nil) nil)) nil)) (nth O (cons (nth (S O) l nil) (cons (nth (S (S O)) l nil) nil)) nil))) (nth O l nil)) (skipn (Init.Nat.sub (length (nth (S O) l nil)) (length (nth (S (S O)) l nil))) (nth O l nil))
+++++
simpl.
-----
Lemma DivDivTwoPower_correct : forall l, Sem DivDivTwoPower_e l = skipn (length (nth 1 l nil) - length (nth 2 l nil)) (nth 0 l nil).
Proof.
intros l.
simpl.
rewrite DivTwoPower_correct.
simpl.
rewrite DivTwoPower_correct.
simpl.

*****
l : list (list bool)
*****
eq (skipn (length (skipn (length (nth (S (S O)) l nil)) (nth (S O) l nil))) (nth O l nil)) (skipn (Init.Nat.sub (length (nth (S O) l nil)) (length (nth (S (S O)) l nil))) (nth O l nil))
+++++
f_equal.
-----
Lemma DivDivTwoPower_correct : forall l, Sem DivDivTwoPower_e l = skipn (length (nth 1 l nil) - length (nth 2 l nil)) (nth 0 l nil).
Proof.
intros l.
simpl.
rewrite DivTwoPower_correct.
simpl.
rewrite DivTwoPower_correct.
simpl.
f_equal.

*****
l : list (list bool)
*****
eq (length (skipn (length (nth (S (S O)) l nil)) (nth (S O) l nil))) (Init.Nat.sub (length (nth (S O) l nil)) (length (nth (S (S O)) l nil)))
+++++
rewrite length_skipn.
-----
Lemma DivDivTwoPower_correct : forall l, Sem DivDivTwoPower_e l = skipn (length (nth 1 l nil) - length (nth 2 l nil)) (nth 0 l nil).
Proof.
intros l.
simpl.
rewrite DivTwoPower_correct.
simpl.
rewrite DivTwoPower_correct.
simpl.
f_equal.
rewrite length_skipn.

*****
l : list (list bool)
*****
eq (Init.Nat.sub (length (nth (S O) l nil)) (length (nth (S (S O)) l nil))) (Init.Nat.sub (length (nth (S O) l nil)) (length (nth (S (S O)) l nil)))
+++++
trivial.
-----
Lemma DivDivTwoPower_correct : forall l, Sem DivDivTwoPower_e l = skipn (length (nth 1 l nil) - length (nth 2 l nil)) (nth 0 l nil).
Proof.
intros l.
simpl.
rewrite DivTwoPower_correct.
simpl.
rewrite DivTwoPower_correct.
simpl.
f_equal.
rewrite length_skipn.
trivial.

*****

*****

+++++
Qed.
-----
Opaque DivDivTwoPower_e.
-----
Fixpoint Repeat_e (n l : nat) (b : bool) : Cobham :=\n  match l with\n    | 0 => Zero_e n\n    | S l' => Comp n (Succ b) [Repeat_e n l' b]\n  end.
-----
Lemma arity_Repeat : forall n len b,\n  arity (Repeat_e n len b) = ok_arity n.
-----
Lemma arity_Repeat : forall n len b, arity (Repeat_e n len b) = ok_arity n.

*****

*****
forall (n len : nat) (b : bool), eq (arity (Repeat_e n len b)) (ok_arity n)
+++++
Proof.
-----
Lemma arity_Repeat : forall n len b, arity (Repeat_e n len b) = ok_arity n.
Proof.

*****

*****
forall (n len : nat) (b : bool), eq (arity (Repeat_e n len b)) (ok_arity n)
+++++
induction len as [ | len' IH].
-----
Lemma arity_Repeat : forall n len b, arity (Repeat_e n len b) = ok_arity n.
Proof.
induction len as [ | len' IH].

*****
n : nat
*****
forall b : bool, eq (arity (Repeat_e n O b)) (ok_arity n)
+++++
simpl.
-----
Lemma arity_Repeat : forall n len b, arity (Repeat_e n len b) = ok_arity n.
Proof.
induction len as [ | len' IH].
simpl.

*****
n : nat
*****
forall _ : bool, eq (arity (Zero_e n)) (ok_arity n)
+++++
trivial.
-----
Lemma arity_Repeat : forall n len b, arity (Repeat_e n len b) = ok_arity n.
Proof.
induction len as [ | len' IH].

*****
IH : forall b : bool, eq (arity (Repeat_e n len' b)) (ok_arity n)
n,len' : nat
*****
forall b : bool, eq (arity (Repeat_e n (S len') b)) (ok_arity n)
+++++
simpl.
-----
Lemma arity_Repeat : forall n len b, arity (Repeat_e n len b) = ok_arity n.
Proof.
induction len as [ | len' IH].
simpl.

*****
IH : forall b : bool, eq (arity (Repeat_e n len' b)) (ok_arity n)
n,len' : nat
*****
forall b : bool, eq (if andb (arity_eq (arity (Repeat_e n len' b)) (ok_arity n)) true then ok_arity n else error_Comp (ok_arity (S O)) (cons (arity (Repeat_e n len' b)) nil)) (ok_arity n)
+++++
trivial.
-----
Lemma arity_Repeat : forall n len b, arity (Repeat_e n len b) = ok_arity n.
Proof.
induction len as [ | len' IH].
simpl.
trivial.

*****
IH : forall b : bool, eq (arity (Repeat_e n len' b)) (ok_arity n)
n,len' : nat
*****
forall b : bool, eq (if andb (arity_eq (arity (Repeat_e n len' b)) (ok_arity n)) true then ok_arity n else error_Comp (ok_arity (S O)) (cons (arity (Repeat_e n len' b)) nil)) (ok_arity n)
+++++
intros [ | ].
-----
Lemma arity_Repeat : forall n len b, arity (Repeat_e n len b) = ok_arity n.
Proof.
induction len as [ | len' IH].
simpl.
trivial.
intros [ | ].

*****
IH : forall b : bool, eq (arity (Repeat_e n len' b)) (ok_arity n)
n,len' : nat
*****
eq (if andb (arity_eq (arity (Repeat_e n len' true)) (ok_arity n)) true then ok_arity n else error_Comp (ok_arity (S O)) (cons (arity (Repeat_e n len' true)) nil)) (ok_arity n)
+++++
rewrite IH.
-----
Lemma arity_Repeat : forall n len b, arity (Repeat_e n len b) = ok_arity n.
Proof.
induction len as [ | len' IH].
simpl.
trivial.
intros [ | ].
rewrite IH.

*****
IH : forall b : bool, eq (arity (Repeat_e n len' b)) (ok_arity n)
n,len' : nat
*****
eq (if andb (arity_eq (ok_arity n) (ok_arity n)) true then ok_arity n else error_Comp (ok_arity (S O)) (cons (ok_arity n) nil)) (ok_arity n)
+++++
simpl.
-----
Lemma arity_Repeat : forall n len b, arity (Repeat_e n len b) = ok_arity n.
Proof.
induction len as [ | len' IH].
simpl.
trivial.
intros [ | ].
rewrite IH.
simpl.

*****
IH : forall b : bool, eq (arity (Repeat_e n len' b)) (ok_arity n)
n,len' : nat
*****
eq (if andb (Nat.eqb n n) true then ok_arity n else error_Comp (ok_arity (S O)) (cons (ok_arity n) nil)) (ok_arity n)
+++++
rewrite <- beq_nat_refl.
-----
Lemma arity_Repeat : forall n len b, arity (Repeat_e n len b) = ok_arity n.
Proof.
induction len as [ | len' IH].
simpl.
trivial.
intros [ | ].
rewrite IH.
simpl.
rewrite <- beq_nat_refl.

*****
IH : forall b : bool, eq (arity (Repeat_e n len' b)) (ok_arity n)
n,len' : nat
*****
eq (if andb true true then ok_arity n else error_Comp (ok_arity (S O)) (cons (ok_arity n) nil)) (ok_arity n)
+++++
trivial.
-----
Lemma arity_Repeat : forall n len b, arity (Repeat_e n len b) = ok_arity n.
Proof.
induction len as [ | len' IH].
simpl.
trivial.
intros [ | ].

*****
IH : forall b : bool, eq (arity (Repeat_e n len' b)) (ok_arity n)
n,len' : nat
*****
eq (if andb (arity_eq (arity (Repeat_e n len' false)) (ok_arity n)) true then ok_arity n else error_Comp (ok_arity (S O)) (cons (arity (Repeat_e n len' false)) nil)) (ok_arity n)
+++++
rewrite IH.
-----
Lemma arity_Repeat : forall n len b, arity (Repeat_e n len b) = ok_arity n.
Proof.
induction len as [ | len' IH].
simpl.
trivial.
intros [ | ].
rewrite IH.

*****
IH : forall b : bool, eq (arity (Repeat_e n len' b)) (ok_arity n)
n,len' : nat
*****
eq (if andb (arity_eq (ok_arity n) (ok_arity n)) true then ok_arity n else error_Comp (ok_arity (S O)) (cons (ok_arity n) nil)) (ok_arity n)
+++++
simpl.
-----
Lemma arity_Repeat : forall n len b, arity (Repeat_e n len b) = ok_arity n.
Proof.
induction len as [ | len' IH].
simpl.
trivial.
intros [ | ].
rewrite IH.
simpl.

*****
IH : forall b : bool, eq (arity (Repeat_e n len' b)) (ok_arity n)
n,len' : nat
*****
eq (if andb (Nat.eqb n n) true then ok_arity n else error_Comp (ok_arity (S O)) (cons (ok_arity n) nil)) (ok_arity n)
+++++
rewrite <- beq_nat_refl.
-----
Lemma arity_Repeat : forall n len b, arity (Repeat_e n len b) = ok_arity n.
Proof.
induction len as [ | len' IH].
simpl.
trivial.
intros [ | ].
rewrite IH.
simpl.
rewrite <- beq_nat_refl.

*****
IH : forall b : bool, eq (arity (Repeat_e n len' b)) (ok_arity n)
n,len' : nat
*****
eq (if andb true true then ok_arity n else error_Comp (ok_arity (S O)) (cons (ok_arity n) nil)) (ok_arity n)
+++++
trivial.
-----
Lemma arity_Repeat : forall n len b, arity (Repeat_e n len b) = ok_arity n.
Proof.
induction len as [ | len' IH].

*****

*****

+++++
Qed.
-----
Lemma rec_bounded_Repeat : forall n len b,\n  rec_bounded (Repeat_e n len b).
-----
Lemma rec_bounded_Repeat : forall n len b, rec_bounded (Repeat_e n len b).

*****

*****
forall (n len : nat) (b : bool), rec_bounded (Repeat_e n len b)
+++++
Proof.
-----
Lemma rec_bounded_Repeat : forall n len b, rec_bounded (Repeat_e n len b).
Proof.

*****

*****
forall (n len : nat) (b : bool), rec_bounded (Repeat_e n len b)
+++++
intros n len b.
-----
Lemma rec_bounded_Repeat : forall n len b, rec_bounded (Repeat_e n len b).
Proof.
intros n len b.

*****
b : bool
n,len : nat
*****
rec_bounded (Repeat_e n len b)
+++++
induction len as [ | len' IH].
-----
Lemma rec_bounded_Repeat : forall n len b, rec_bounded (Repeat_e n len b).
Proof.
intros n len b.
induction len as [ | len' IH].

*****
b : bool
n : nat
*****
rec_bounded (Repeat_e n O b)
+++++
simpl.
-----
Lemma rec_bounded_Repeat : forall n len b, rec_bounded (Repeat_e n len b).
Proof.
intros n len b.
induction len as [ | len' IH].
simpl.

*****
b : bool
n : nat
*****
rec_bounded (Zero_e n)
+++++
apply rec_bounded_Zero.
-----
Lemma rec_bounded_Repeat : forall n len b, rec_bounded (Repeat_e n len b).
Proof.
intros n len b.
induction len as [ | len' IH].

*****
IH : rec_bounded (Repeat_e n len' b)
b : bool
n,len' : nat
*****
rec_bounded (Repeat_e n (S len') b)
+++++
simpl.
-----
Lemma rec_bounded_Repeat : forall n len b, rec_bounded (Repeat_e n len b).
Proof.
intros n len b.
induction len as [ | len' IH].
simpl.

*****
IH : rec_bounded (Repeat_e n len' b)
b : bool
n,len' : nat
*****
and True (and (rec_bounded (Repeat_e n len' b)) True)
+++++
intuition.
-----
Lemma rec_bounded_Repeat : forall n len b, rec_bounded (Repeat_e n len b).
Proof.
intros n len b.
induction len as [ | len' IH].

*****

*****

+++++
Qed.
-----
Lemma length_Repeat : forall n l b l',\n  length (Sem (Repeat_e n l b) l') = l.
-----
Lemma length_Repeat : forall n l b l', length (Sem (Repeat_e n l b) l') = l.

*****

*****
forall (n l : nat) (b : bool) (l' : list (list bool)), eq (length (Sem (Repeat_e n l b) l')) l
+++++
Proof.
-----
Lemma length_Repeat : forall n l b l', length (Sem (Repeat_e n l b) l') = l.
Proof.

*****

*****
forall (n l : nat) (b : bool) (l' : list (list bool)), eq (length (Sem (Repeat_e n l b) l')) l
+++++
induction l.
-----
Lemma length_Repeat : forall n l b l', length (Sem (Repeat_e n l b) l') = l.
Proof.
induction l.

*****
n : nat
*****
forall (b : bool) (l' : list (list bool)), eq (length (Sem (Repeat_e n O b) l')) O
+++++
simpl.
-----
Lemma length_Repeat : forall n l b l', length (Sem (Repeat_e n l b) l') = l.
Proof.
induction l.
simpl.

*****
n : nat
*****
forall (_ : bool) (l' : list (list bool)), eq (length (Sem (Zero_e n) l')) O
+++++
auto.
-----
Lemma length_Repeat : forall n l b l', length (Sem (Repeat_e n l b) l') = l.
Proof.
induction l.

*****
IHl : forall (b : bool) (l' : list (list bool)),\neq (length (Sem (Repeat_e n l b) l')) l
n,l : nat
*****
forall (b : bool) (l' : list (list bool)), eq (length (Sem (Repeat_e n (S l) b) l')) (S l)
+++++
simpl.
-----
Lemma length_Repeat : forall n l b l', length (Sem (Repeat_e n l b) l') = l.
Proof.
induction l.
simpl.

*****
IHl : forall (b : bool) (l' : list (list bool)),\neq (length (Sem (Repeat_e n l b) l')) l
n,l : nat
*****
forall (b : bool) (l' : list (list bool)), eq (S (length (Sem (Repeat_e n l b) l'))) (S l)
+++++
auto.
-----
Lemma length_Repeat : forall n l b l', length (Sem (Repeat_e n l b) l') = l.
Proof.
induction l.

*****

*****

+++++
Qed.
-----
Opaque Repeat_e.
-----
Definition RoseS'_e : Cobham :=\n  Rec2\n    (Zero_e 2)\n    (Comp 4 PlusOneMinusMod2_e [\n      Comp 4 (Succ false) [Proj 4 1];\n      Comp 4 DivTwoPower_e [Comp 4 DivTwoPower_e [Proj 4 2; Proj 4 0]; Proj 4 3];\n      Comp 4 DivDivTwoPower_e [Proj 4 2; Proj 4 2; Comp 4 (Succ false) [Proj 4 0]]\n    ])\n    (Comp 3 Smash [Proj 3 0; Repeat_e 3 2 true]).
-----
Definition arity_RoseS' :\n  arity RoseS'_e = ok_arity 3.
-----
Definition arity_RoseS' : arity RoseS'_e = ok_arity 3.

*****

*****
eq (arity RoseS'_e) (ok_arity (S (S (S O))))
+++++
Proof.
-----
Definition arity_RoseS' : arity RoseS'_e = ok_arity 3.
Proof.

*****

*****
eq (arity RoseS'_e) (ok_arity (S (S (S O))))
+++++
trivial.
-----
Definition arity_RoseS' : arity RoseS'_e = ok_arity 3.
Proof.
trivial.

*****

*****

+++++
Qed.
-----
Lemma rec_bounded_RoseS' :\n  rec_bounded RoseS'_e.
-----
Lemma rec_bounded_RoseS' : rec_bounded RoseS'_e.

*****

*****
rec_bounded RoseS'_e
+++++
Proof.
-----
Lemma rec_bounded_RoseS' : rec_bounded RoseS'_e.
Proof.

*****

*****
rec_bounded RoseS'_e
+++++
simpl.
-----
Lemma rec_bounded_RoseS' : rec_bounded RoseS'_e.
Proof.
simpl.

*****

*****
and (and True (and True (and (rec_bounded (Repeat_e (S (S (S O))) (S (S O)) true)) True))) (and (rec_bounded (Zero_e (S (S O)))) (and (and (rec_bounded PlusOneMinusMod2_e) (and (and True (and True True)) (and (and (rec_bounded DivTwoPower_e) (and (and (rec_bounded DivTwoPower_e) (and True (and True True))) (and True True))) (and (and (rec_bounded DivDivTwoPower_e) (and True (and True (and (and True (and True True)) True)))) True)))) (and (and (rec_bounded PlusOneMinusMod2_e) (and (and True (and True True)) (and (and (rec_bounded DivTwoPower_e) (and (and (rec_bounded DivTwoPower_e) (and True (and True True))) (and True True))) (and (and (rec_bounded DivDivTwoPower_e) (and True (and True (and (and True (and True True)) True)))) True)))) (forall l : list (list bool), le (length (sem_Rec (Sem (Zero_e (S (S O)))) (fun vl : list (list bool) => Sem PlusOneMinusMod2_e (cons (cons false (nth (S O) vl nil)) (cons (Sem DivTwoPower_e (cons (Sem DivTwoPower_e (cons (nth (S (S O)) vl nil) (cons (nth O vl nil) nil))) (cons (nth (S (S (S O))) vl nil) nil))) (cons (Sem DivDivTwoPower_e (cons (nth (S (S O)) vl nil) (cons (nth (S (S O)) vl nil) (cons (cons false (nth O vl nil)) nil)))) nil)))) (fun vl : list (list bool) => Sem PlusOneMinusMod2_e (cons (cons false (nth (S O) vl nil)) (cons (Sem DivTwoPower_e (cons (Sem DivTwoPower_e (cons (nth (S (S O)) vl nil) (cons (nth O vl nil) nil))) (cons (nth (S (S (S O))) vl nil) nil))) (cons (Sem DivDivTwoPower_e (cons (nth (S (S O)) vl nil) (cons (nth (S (S O)) vl nil) (cons (cons false (nth O vl nil)) nil)))) nil)))) (hd nil l) (tl l))) (length (smash_bs (nth O l nil) (Sem (Repeat_e (S (S (S O))) (S (S O)) true) l)))))))
+++++
intuition.
-----
Lemma rec_bounded_RoseS' : rec_bounded RoseS'_e.
Proof.
simpl.
intuition.

*****

*****
rec_bounded (Repeat_e (S (S (S O))) (S (S O)) true)
+++++
apply rec_bounded_Repeat.
-----
Lemma rec_bounded_RoseS' : rec_bounded RoseS'_e.
Proof.
simpl.
intuition.

*****

*****
rec_bounded (Zero_e (S (S O)))
+++++
apply rec_bounded_Zero.
-----
Lemma rec_bounded_RoseS' : rec_bounded RoseS'_e.
Proof.
simpl.
intuition.

*****

*****
rec_bounded PlusOneMinusMod2_e
+++++
apply rec_bounded_PlusOneMinusMod2.
-----
Lemma rec_bounded_RoseS' : rec_bounded RoseS'_e.
Proof.
simpl.
intuition.

*****

*****
rec_bounded DivTwoPower_e
+++++
apply rec_bounded_DivTwoPower.
-----
Lemma rec_bounded_RoseS' : rec_bounded RoseS'_e.
Proof.
simpl.
intuition.

*****

*****
rec_bounded DivTwoPower_e
+++++
apply rec_bounded_DivTwoPower.
-----
Lemma rec_bounded_RoseS' : rec_bounded RoseS'_e.
Proof.
simpl.
intuition.

*****

*****
rec_bounded DivDivTwoPower_e
+++++
apply rec_bounded_DivDivTwoPower.
-----
Lemma rec_bounded_RoseS' : rec_bounded RoseS'_e.
Proof.
simpl.
intuition.

*****

*****
rec_bounded PlusOneMinusMod2_e
+++++
apply rec_bounded_PlusOneMinusMod2.
-----
Lemma rec_bounded_RoseS' : rec_bounded RoseS'_e.
Proof.
simpl.
intuition.

*****

*****
rec_bounded DivTwoPower_e
+++++
apply rec_bounded_DivTwoPower.
-----
Lemma rec_bounded_RoseS' : rec_bounded RoseS'_e.
Proof.
simpl.
intuition.

*****

*****
rec_bounded DivTwoPower_e
+++++
apply rec_bounded_DivTwoPower.
-----
Lemma rec_bounded_RoseS' : rec_bounded RoseS'_e.
Proof.
simpl.
intuition.

*****

*****
rec_bounded DivDivTwoPower_e
+++++
apply rec_bounded_DivDivTwoPower.
-----
Lemma rec_bounded_RoseS' : rec_bounded RoseS'_e.
Proof.
simpl.
intuition.

*****
l : list (list bool)
*****
le (length (sem_Rec (Sem (Zero_e (S (S O)))) (fun vl : list (list bool) => Sem PlusOneMinusMod2_e (cons (cons false (nth (S O) vl nil)) (cons (Sem DivTwoPower_e (cons (Sem DivTwoPower_e (cons (nth (S (S O)) vl nil) (cons (nth O vl nil) nil))) (cons (nth (S (S (S O))) vl nil) nil))) (cons (Sem DivDivTwoPower_e (cons (nth (S (S O)) vl nil) (cons (nth (S (S O)) vl nil) (cons (cons false (nth O vl nil)) nil)))) nil)))) (fun vl : list (list bool) => Sem PlusOneMinusMod2_e (cons (cons false (nth (S O) vl nil)) (cons (Sem DivTwoPower_e (cons (Sem DivTwoPower_e (cons (nth (S (S O)) vl nil) (cons (nth O vl nil) nil))) (cons (nth (S (S (S O))) vl nil) nil))) (cons (Sem DivDivTwoPower_e (cons (nth (S (S O)) vl nil) (cons (nth (S (S O)) vl nil) (cons (cons false (nth O vl nil)) nil)))) nil)))) (hd nil l) (tl l))) (length (smash_bs (nth O l nil) (Sem (Repeat_e (S (S (S O))) (S (S O)) true) l)))
+++++
rewrite <- hd_nth_0.
-----
Lemma rec_bounded_RoseS' : rec_bounded RoseS'_e.
Proof.
simpl.
intuition.
rewrite <- hd_nth_0.

*****
l : list (list bool)
*****
le (length (sem_Rec (Sem (Zero_e (S (S O)))) (fun vl : list (list bool) => Sem PlusOneMinusMod2_e (cons (cons false (nth (S O) vl nil)) (cons (Sem DivTwoPower_e (cons (Sem DivTwoPower_e (cons (nth (S (S O)) vl nil) (cons (nth O vl nil) nil))) (cons (nth (S (S (S O))) vl nil) nil))) (cons (Sem DivDivTwoPower_e (cons (nth (S (S O)) vl nil) (cons (nth (S (S O)) vl nil) (cons (cons false (nth O vl nil)) nil)))) nil)))) (fun vl : list (list bool) => Sem PlusOneMinusMod2_e (cons (cons false (nth (S O) vl nil)) (cons (Sem DivTwoPower_e (cons (Sem DivTwoPower_e (cons (nth (S (S O)) vl nil) (cons (nth O vl nil) nil))) (cons (nth (S (S (S O))) vl nil) nil))) (cons (Sem DivDivTwoPower_e (cons (nth (S (S O)) vl nil) (cons (nth (S (S O)) vl nil) (cons (cons false (nth O vl nil)) nil)))) nil)))) (hd nil l) (tl l))) (length (smash_bs (hd nil l) (Sem (Repeat_e (S (S (S O))) (S (S O)) true) l)))
+++++
induction (hd nil l).
-----
Lemma rec_bounded_RoseS' : rec_bounded RoseS'_e.
Proof.
simpl.
intuition.
rewrite <- hd_nth_0.
induction (hd nil l).

*****
l : list (list bool)
*****
le (length (sem_Rec (Sem (Zero_e (S (S O)))) (fun vl : list (list bool) => Sem PlusOneMinusMod2_e (cons (cons false (nth (S O) vl nil)) (cons (Sem DivTwoPower_e (cons (Sem DivTwoPower_e (cons (nth (S (S O)) vl nil) (cons (nth O vl nil) nil))) (cons (nth (S (S (S O))) vl nil) nil))) (cons (Sem DivDivTwoPower_e (cons (nth (S (S O)) vl nil) (cons (nth (S (S O)) vl nil) (cons (cons false (nth O vl nil)) nil)))) nil)))) (fun vl : list (list bool) => Sem PlusOneMinusMod2_e (cons (cons false (nth (S O) vl nil)) (cons (Sem DivTwoPower_e (cons (Sem DivTwoPower_e (cons (nth (S (S O)) vl nil) (cons (nth O vl nil) nil))) (cons (nth (S (S (S O))) vl nil) nil))) (cons (Sem DivDivTwoPower_e (cons (nth (S (S O)) vl nil) (cons (nth (S (S O)) vl nil) (cons (cons false (nth O vl nil)) nil)))) nil)))) nil (tl l))) (length (smash_bs nil (Sem (Repeat_e (S (S (S O))) (S (S O)) true) l)))
+++++
simpl.
-----
Lemma rec_bounded_RoseS' : rec_bounded RoseS'_e.
Proof.
simpl.
intuition.
rewrite <- hd_nth_0.
induction (hd nil l).
simpl.

*****
l : list (list bool)
*****
le (length (Sem (Zero_e (S (S O))) (tl l))) (S O)
+++++
rewrite Zero_correct_bs.
-----
Lemma rec_bounded_RoseS' : rec_bounded RoseS'_e.
Proof.
simpl.
intuition.
rewrite <- hd_nth_0.
induction (hd nil l).
simpl.
rewrite Zero_correct_bs.

*****
l : list (list bool)
*****
le (length nil) (S O)
+++++
simpl.
-----
Lemma rec_bounded_RoseS' : rec_bounded RoseS'_e.
Proof.
simpl.
intuition.
rewrite <- hd_nth_0.
induction (hd nil l).
simpl.
rewrite Zero_correct_bs.
simpl.

*****
l : list (list bool)
*****
le O (S O)
+++++
auto with arith.
-----
Lemma rec_bounded_RoseS' : rec_bounded RoseS'_e.
Proof.
simpl.
intuition.
rewrite <- hd_nth_0.
induction (hd nil l).

*****
IHl0 : le\n (length\n (sem_Rec (Sem (Zero_e (S (S O))))\n (fun vl : list (list bool) =>\n Sem PlusOneMinusMod2_e\n (cons (cons false (nth (S O) vl nil))\n (cons\n (Sem DivTwoPower_e\n (cons\n (Sem DivTwoPower_e\n (cons (nth (S (S O)) vl nil)\n (cons (nth O vl nil) nil)))\n (cons (nth (S (S (S O))) vl nil) nil)))\n (cons\n (Sem DivDivTwoPower_e\n (cons (nth (S (S O)) vl nil)\n (cons (nth (S (S O)) vl nil)\n (cons (cons false (nth O vl nil)) nil))))\n nil))))\n (fun vl : list (list bool) =>\n Sem PlusOneMinusMod2_e\n (cons (cons false (nth (S O) vl nil))\n (cons\n (Sem DivTwoPower_e\n (cons\n (Sem DivTwoPower_e\n (cons (nth (S (S O)) vl nil)\n (cons (nth O vl nil) nil)))\n (cons (nth (S (S (S O))) vl nil) nil)))\n (cons\n (Sem DivDivTwoPower_e\n (cons (nth (S (S O)) vl nil)\n (cons (nth (S (S O)) vl nil)\n (cons (cons false (nth O vl nil)) nil))))\n nil)))) l0 (tl l)))\n (length (smash_bs l0 (Sem (Repeat_e (S (S (S O))) (S (S O)) true) l)))
l0 : list bool
a : bool
l : list (list bool)
*****
le (length (sem_Rec (Sem (Zero_e (S (S O)))) (fun vl : list (list bool) => Sem PlusOneMinusMod2_e (cons (cons false (nth (S O) vl nil)) (cons (Sem DivTwoPower_e (cons (Sem DivTwoPower_e (cons (nth (S (S O)) vl nil) (cons (nth O vl nil) nil))) (cons (nth (S (S (S O))) vl nil) nil))) (cons (Sem DivDivTwoPower_e (cons (nth (S (S O)) vl nil) (cons (nth (S (S O)) vl nil) (cons (cons false (nth O vl nil)) nil)))) nil)))) (fun vl : list (list bool) => Sem PlusOneMinusMod2_e (cons (cons false (nth (S O) vl nil)) (cons (Sem DivTwoPower_e (cons (Sem DivTwoPower_e (cons (nth (S (S O)) vl nil) (cons (nth O vl nil) nil))) (cons (nth (S (S (S O))) vl nil) nil))) (cons (Sem DivDivTwoPower_e (cons (nth (S (S O)) vl nil) (cons (nth (S (S O)) vl nil) (cons (cons false (nth O vl nil)) nil)))) nil)))) (cons a l0) (tl l))) (length (smash_bs (cons a l0) (Sem (Repeat_e (S (S (S O))) (S (S O)) true) l)))
+++++
simpl.
-----
Lemma rec_bounded_RoseS' : rec_bounded RoseS'_e.
Proof.
simpl.
intuition.
rewrite <- hd_nth_0.
induction (hd nil l).
simpl.

*****
IHl0 : le\n (length\n (sem_Rec (Sem (Zero_e (S (S O))))\n (fun vl : list (list bool) =>\n Sem PlusOneMinusMod2_e\n (cons (cons false (nth (S O) vl nil))\n (cons\n (Sem DivTwoPower_e\n (cons\n (Sem DivTwoPower_e\n (cons (nth (S (S O)) vl nil)\n (cons (nth O vl nil) nil)))\n (cons (nth (S (S (S O))) vl nil) nil)))\n (cons\n (Sem DivDivTwoPower_e\n (cons (nth (S (S O)) vl nil)\n (cons (nth (S (S O)) vl nil)\n (cons (cons false (nth O vl nil)) nil))))\n nil))))\n (fun vl : list (list bool) =>\n Sem PlusOneMinusMod2_e\n (cons (cons false (nth (S O) vl nil))\n (cons\n (Sem DivTwoPower_e\n (cons\n (Sem DivTwoPower_e\n (cons (nth (S (S O)) vl nil)\n (cons (nth O vl nil) nil)))\n (cons (nth (S (S (S O))) vl nil) nil)))\n (cons\n (Sem DivDivTwoPower_e\n (cons (nth (S (S O)) vl nil)\n (cons (nth (S (S O)) vl nil)\n (cons (cons false (nth O vl nil)) nil))))\n nil)))) l0 (tl l)))\n (length (smash_bs l0 (Sem (Repeat_e (S (S (S O))) (S (S O)) true) l)))
l0 : list bool
a : bool
l : list (list bool)
*****
le (length (if a then Sem PlusOneMinusMod2_e (cons (cons false (sem_Rec (Sem (Zero_e (S (S O)))) (fun vl : list (list bool) => Sem PlusOneMinusMod2_e (cons (cons false (nth (S O) vl nil)) (cons (Sem DivTwoPower_e (cons (Sem DivTwoPower_e (cons (nth (S (S O)) vl nil) (cons (nth O vl nil) nil))) (cons (nth (S (S (S O))) vl nil) nil))) (cons (Sem DivDivTwoPower_e (cons (nth (S (S O)) vl nil) (cons (nth (S (S O)) vl nil) (cons (cons false (nth O vl nil)) nil)))) nil)))) (fun vl : list (list bool) => Sem PlusOneMinusMod2_e (cons (cons false (nth (S O) vl nil)) (cons (Sem DivTwoPower_e (cons (Sem DivTwoPower_e (cons (nth (S (S O)) vl nil) (cons (nth O vl nil) nil))) (cons (nth (S (S (S O))) vl nil) nil))) (cons (Sem DivDivTwoPower_e (cons (nth (S (S O)) vl nil) (cons (nth (S (S O)) vl nil) (cons (cons false (nth O vl nil)) nil)))) nil)))) l0 (tl l))) (cons (Sem DivTwoPower_e (cons (Sem DivTwoPower_e (cons (nth O (tl l) nil) (cons l0 nil))) (cons (nth (S O) (tl l) nil) nil))) (cons (Sem DivDivTwoPower_e (cons (nth O (tl l) nil) (cons (nth O (tl l) nil) (cons (cons false l0) nil)))) nil))) else Sem PlusOneMinusMod2_e (cons (cons false (sem_Rec (Sem (Zero_e (S (S O)))) (fun vl : list (list bool) => Sem PlusOneMinusMod2_e (cons (cons false (nth (S O) vl nil)) (cons (Sem DivTwoPower_e (cons (Sem DivTwoPower_e (cons (nth (S (S O)) vl nil) (cons (nth O vl nil) nil))) (cons (nth (S (S (S O))) vl nil) nil))) (cons (Sem DivDivTwoPower_e (cons (nth (S (S O)) vl nil) (cons (nth (S (S O)) vl nil) (cons (cons false (nth O vl nil)) nil)))) nil)))) (fun vl : list (list bool) => Sem PlusOneMinusMod2_e (cons (cons false (nth (S O) vl nil)) (cons (Sem DivTwoPower_e (cons (Sem DivTwoPower_e (cons (nth (S (S O)) vl nil) (cons (nth O vl nil) nil))) (cons (nth (S (S (S O))) vl nil) nil))) (cons (Sem DivDivTwoPower_e (cons (nth (S (S O)) vl nil) (cons (nth (S (S O)) vl nil) (cons (cons false (nth O vl nil)) nil)))) nil)))) l0 (tl l))) (cons (Sem DivTwoPower_e (cons (Sem DivTwoPower_e (cons (nth O (tl l) nil) (cons l0 nil))) (cons (nth (S O) (tl l) nil) nil))) (cons (Sem DivDivTwoPower_e (cons (nth O (tl l) nil) (cons (nth O (tl l) nil) (cons (cons false l0) nil)))) nil))))) (length (smash' (Sem (Repeat_e (S (S (S O))) (S (S O)) true) l) (smash_bs l0 (Sem (Repeat_e (S (S (S O))) (S (S O)) true) l))))
+++++
case a.
-----
Lemma rec_bounded_RoseS' : rec_bounded RoseS'_e.
Proof.
simpl.
intuition.
rewrite <- hd_nth_0.
induction (hd nil l).
simpl.
case a.

*****
IHl0 : le\n (length\n (sem_Rec (Sem (Zero_e (S (S O))))\n (fun vl : list (list bool) =>\n Sem PlusOneMinusMod2_e\n (cons (cons false (nth (S O) vl nil))\n (cons\n (Sem DivTwoPower_e\n (cons\n (Sem DivTwoPower_e\n (cons (nth (S (S O)) vl nil)\n (cons (nth O vl nil) nil)))\n (cons (nth (S (S (S O))) vl nil) nil)))\n (cons\n (Sem DivDivTwoPower_e\n (cons (nth (S (S O)) vl nil)\n (cons (nth (S (S O)) vl nil)\n (cons (cons false (nth O vl nil)) nil))))\n nil))))\n (fun vl : list (list bool) =>\n Sem PlusOneMinusMod2_e\n (cons (cons false (nth (S O) vl nil))\n (cons\n (Sem DivTwoPower_e\n (cons\n (Sem DivTwoPower_e\n (cons (nth (S (S O)) vl nil)\n (cons (nth O vl nil) nil)))\n (cons (nth (S (S (S O))) vl nil) nil)))\n (cons\n (Sem DivDivTwoPower_e\n (cons (nth (S (S O)) vl nil)\n (cons (nth (S (S O)) vl nil)\n (cons (cons false (nth O vl nil)) nil))))\n nil)))) l0 (tl l)))\n (length (smash_bs l0 (Sem (Repeat_e (S (S (S O))) (S (S O)) true) l)))
l0 : list bool
a : bool
l : list (list bool)
*****
le (length (Sem PlusOneMinusMod2_e (cons (cons false (sem_Rec (Sem (Zero_e (S (S O)))) (fun vl : list (list bool) => Sem PlusOneMinusMod2_e (cons (cons false (nth (S O) vl nil)) (cons (Sem DivTwoPower_e (cons (Sem DivTwoPower_e (cons (nth (S (S O)) vl nil) (cons (nth O vl nil) nil))) (cons (nth (S (S (S O))) vl nil) nil))) (cons (Sem DivDivTwoPower_e (cons (nth (S (S O)) vl nil) (cons (nth (S (S O)) vl nil) (cons (cons false (nth O vl nil)) nil)))) nil)))) (fun vl : list (list bool) => Sem PlusOneMinusMod2_e (cons (cons false (nth (S O) vl nil)) (cons (Sem DivTwoPower_e (cons (Sem DivTwoPower_e (cons (nth (S (S O)) vl nil) (cons (nth O vl nil) nil))) (cons (nth (S (S (S O))) vl nil) nil))) (cons (Sem DivDivTwoPower_e (cons (nth (S (S O)) vl nil) (cons (nth (S (S O)) vl nil) (cons (cons false (nth O vl nil)) nil)))) nil)))) l0 (tl l))) (cons (Sem DivTwoPower_e (cons (Sem DivTwoPower_e (cons (nth O (tl l) nil) (cons l0 nil))) (cons (nth (S O) (tl l) nil) nil))) (cons (Sem DivDivTwoPower_e (cons (nth O (tl l) nil) (cons (nth O (tl l) nil) (cons (cons false l0) nil)))) nil))))) (length (smash' (Sem (Repeat_e (S (S (S O))) (S (S O)) true) l) (smash_bs l0 (Sem (Repeat_e (S (S (S O))) (S (S O)) true) l))))
+++++
eapply le_trans.
-----
Lemma rec_bounded_RoseS' : rec_bounded RoseS'_e.
Proof.
simpl.
intuition.
rewrite <- hd_nth_0.
induction (hd nil l).
simpl.
case a.
eapply le_trans.

*****
IHl0 : le\n (length\n (sem_Rec (Sem (Zero_e (S (S O))))\n (fun vl : list (list bool) =>\n Sem PlusOneMinusMod2_e\n (cons (cons false (nth (S O) vl nil))\n (cons\n (Sem DivTwoPower_e\n (cons\n (Sem DivTwoPower_e\n (cons (nth (S (S O)) vl nil)\n (cons (nth O vl nil) nil)))\n (cons (nth (S (S (S O))) vl nil) nil)))\n (cons\n (Sem DivDivTwoPower_e\n (cons (nth (S (S O)) vl nil)\n (cons (nth (S (S O)) vl nil)\n (cons (cons false (nth O vl nil)) nil))))\n nil))))\n (fun vl : list (list bool) =>\n Sem PlusOneMinusMod2_e\n (cons (cons false (nth (S O) vl nil))\n (cons\n (Sem DivTwoPower_e\n (cons\n (Sem DivTwoPower_e\n (cons (nth (S (S O)) vl nil)\n (cons (nth O vl nil) nil)))\n (cons (nth (S (S (S O))) vl nil) nil)))\n (cons\n (Sem DivDivTwoPower_e\n (cons (nth (S (S O)) vl nil)\n (cons (nth (S (S O)) vl nil)\n (cons (cons false (nth O vl nil)) nil))))\n nil)))) l0 (tl l)))\n (length (smash_bs l0 (Sem (Repeat_e (S (S (S O))) (S (S O)) true) l)))
l0 : list bool
a : bool
l : list (list bool)
*****
le (length (Sem PlusOneMinusMod2_e (cons (cons false (sem_Rec (Sem (Zero_e (S (S O)))) (fun vl : list (list bool) => Sem PlusOneMinusMod2_e (cons (cons false (nth (S O) vl nil)) (cons (Sem DivTwoPower_e (cons (Sem DivTwoPower_e (cons (nth (S (S O)) vl nil) (cons (nth O vl nil) nil))) (cons (nth (S (S (S O))) vl nil) nil))) (cons (Sem DivDivTwoPower_e (cons (nth (S (S O)) vl nil) (cons (nth (S (S O)) vl nil) (cons (cons false (nth O vl nil)) nil)))) nil)))) (fun vl : list (list bool) => Sem PlusOneMinusMod2_e (cons (cons false (nth (S O) vl nil)) (cons (Sem DivTwoPower_e (cons (Sem DivTwoPower_e (cons (nth (S (S O)) vl nil) (cons (nth O vl nil) nil))) (cons (nth (S (S (S O))) vl nil) nil))) (cons (Sem DivDivTwoPower_e (cons (nth (S (S O)) vl nil) (cons (nth (S (S O)) vl nil) (cons (cons false (nth O vl nil)) nil)))) nil)))) l0 (tl l))) (cons (Sem DivTwoPower_e (cons (Sem DivTwoPower_e (cons (nth O (tl l) nil) (cons l0 nil))) (cons (nth (S O) (tl l) nil) nil))) (cons (Sem DivDivTwoPower_e (cons (nth O (tl l) nil) (cons (nth O (tl l) nil) (cons (cons false l0) nil)))) nil))))) ?m
+++++
apply PlusOneMinusMod2_length.
-----
Lemma rec_bounded_RoseS' : rec_bounded RoseS'_e.
Proof.
simpl.
intuition.
rewrite <- hd_nth_0.
induction (hd nil l).
simpl.
case a.
eapply le_trans.

*****
IHl0 : le\n (length\n (sem_Rec (Sem (Zero_e (S (S O))))\n (fun vl : list (list bool) =>\n Sem PlusOneMinusMod2_e\n (cons (cons false (nth (S O) vl nil))\n (cons\n (Sem DivTwoPower_e\n (cons\n (Sem DivTwoPower_e\n (cons (nth (S (S O)) vl nil)\n (cons (nth O vl nil) nil)))\n (cons (nth (S (S (S O))) vl nil) nil)))\n (cons\n (Sem DivDivTwoPower_e\n (cons (nth (S (S O)) vl nil)\n (cons (nth (S (S O)) vl nil)\n (cons (cons false (nth O vl nil)) nil))))\n nil))))\n (fun vl : list (list bool) =>\n Sem PlusOneMinusMod2_e\n (cons (cons false (nth (S O) vl nil))\n (cons\n (Sem DivTwoPower_e\n (cons\n (Sem DivTwoPower_e\n (cons (nth (S (S O)) vl nil)\n (cons (nth O vl nil) nil)))\n (cons (nth (S (S (S O))) vl nil) nil)))\n (cons\n (Sem DivDivTwoPower_e\n (cons (nth (S (S O)) vl nil)\n (cons (nth (S (S O)) vl nil)\n (cons (cons false (nth O vl nil)) nil))))\n nil)))) l0 (tl l)))\n (length (smash_bs l0 (Sem (Repeat_e (S (S (S O))) (S (S O)) true) l)))
l0 : list bool
a : bool
l : list (list bool)
*****
le (S (length (hd nil (cons (cons false (sem_Rec (Sem (Zero_e (S (S O)))) (fun vl : list (list bool) => Sem PlusOneMinusMod2_e (cons (cons false (nth (S O) vl nil)) (cons (Sem DivTwoPower_e (cons (Sem DivTwoPower_e (cons (nth (S (S O)) vl nil) (cons (nth O vl nil) nil))) (cons (nth (S (S (S O))) vl nil) nil))) (cons (Sem DivDivTwoPower_e (cons (nth (S (S O)) vl nil) (cons (nth (S (S O)) vl nil) (cons (cons false (nth O vl nil)) nil)))) nil)))) (fun vl : list (list bool) => Sem PlusOneMinusMod2_e (cons (cons false (nth (S O) vl nil)) (cons (Sem DivTwoPower_e (cons (Sem DivTwoPower_e (cons (nth (S (S O)) vl nil) (cons (nth O vl nil) nil))) (cons (nth (S (S (S O))) vl nil) nil))) (cons (Sem DivDivTwoPower_e (cons (nth (S (S O)) vl nil) (cons (nth (S (S O)) vl nil) (cons (cons false (nth O vl nil)) nil)))) nil)))) l0 (tl l))) (cons (Sem DivTwoPower_e (cons (Sem DivTwoPower_e (cons (nth O (tl l) nil) (cons l0 nil))) (cons (nth (S O) (tl l) nil) nil))) (cons (Sem DivDivTwoPower_e (cons (nth O (tl l) nil) (cons (nth O (tl l) nil) (cons (cons false l0) nil)))) nil)))))) (length (smash' (Sem (Repeat_e (S (S (S O))) (S (S O)) true) l) (smash_bs l0 (Sem (Repeat_e (S (S (S O))) (S (S O)) true) l))))
+++++
simpl.
-----
Lemma rec_bounded_RoseS' : rec_bounded RoseS'_e.
Proof.
simpl.
intuition.
rewrite <- hd_nth_0.
induction (hd nil l).
simpl.
case a.
eapply le_trans.
simpl.

*****
IHl0 : le\n (length\n (sem_Rec (Sem (Zero_e (S (S O))))\n (fun vl : list (list bool) =>\n Sem PlusOneMinusMod2_e\n (cons (cons false (nth (S O) vl nil))\n (cons\n (Sem DivTwoPower_e\n (cons\n (Sem DivTwoPower_e\n (cons (nth (S (S O)) vl nil)\n (cons (nth O vl nil) nil)))\n (cons (nth (S (S (S O))) vl nil) nil)))\n (cons\n (Sem DivDivTwoPower_e\n (cons (nth (S (S O)) vl nil)\n (cons (nth (S (S O)) vl nil)\n (cons (cons false (nth O vl nil)) nil))))\n nil))))\n (fun vl : list (list bool) =>\n Sem PlusOneMinusMod2_e\n (cons (cons false (nth (S O) vl nil))\n (cons\n (Sem DivTwoPower_e\n (cons\n (Sem DivTwoPower_e\n (cons (nth (S (S O)) vl nil)\n (cons (nth O vl nil) nil)))\n (cons (nth (S (S (S O))) vl nil) nil)))\n (cons\n (Sem DivDivTwoPower_e\n (cons (nth (S (S O)) vl nil)\n (cons (nth (S (S O)) vl nil)\n (cons (cons false (nth O vl nil)) nil))))\n nil)))) l0 (tl l)))\n (length (smash_bs l0 (Sem (Repeat_e (S (S (S O))) (S (S O)) true) l)))
l0 : list bool
a : bool
l : list (list bool)
*****
le (S (S (length (sem_Rec (Sem (Zero_e (S (S O)))) (fun vl : list (list bool) => Sem PlusOneMinusMod2_e (cons (cons false (nth (S O) vl nil)) (cons (Sem DivTwoPower_e (cons (Sem DivTwoPower_e (cons (nth (S (S O)) vl nil) (cons (nth O vl nil) nil))) (cons (nth (S (S (S O))) vl nil) nil))) (cons (Sem DivDivTwoPower_e (cons (nth (S (S O)) vl nil) (cons (nth (S (S O)) vl nil) (cons (cons false (nth O vl nil)) nil)))) nil)))) (fun vl : list (list bool) => Sem PlusOneMinusMod2_e (cons (cons false (nth (S O) vl nil)) (cons (Sem DivTwoPower_e (cons (Sem DivTwoPower_e (cons (nth (S (S O)) vl nil) (cons (nth O vl nil) nil))) (cons (nth (S (S (S O))) vl nil) nil))) (cons (Sem DivDivTwoPower_e (cons (nth (S (S O)) vl nil) (cons (nth (S (S O)) vl nil) (cons (cons false (nth O vl nil)) nil)))) nil)))) l0 (tl l))))) (length (smash' (Sem (Repeat_e (S (S (S O))) (S (S O)) true) l) (smash_bs l0 (Sem (Repeat_e (S (S (S O))) (S (S O)) true) l))))
+++++
rewrite length_smash'.
-----
Lemma rec_bounded_RoseS' : rec_bounded RoseS'_e.
Proof.
simpl.
intuition.
rewrite <- hd_nth_0.
induction (hd nil l).
simpl.
case a.
eapply le_trans.
simpl.
rewrite length_smash'.

*****
IHl0 : le\n (length\n (sem_Rec (Sem (Zero_e (S (S O))))\n (fun vl : list (list bool) =>\n Sem PlusOneMinusMod2_e\n (cons (cons false (nth (S O) vl nil))\n (cons\n (Sem DivTwoPower_e\n (cons\n (Sem DivTwoPower_e\n (cons (nth (S (S O)) vl nil)\n (cons (nth O vl nil) nil)))\n (cons (nth (S (S (S O))) vl nil) nil)))\n (cons\n (Sem DivDivTwoPower_e\n (cons (nth (S (S O)) vl nil)\n (cons (nth (S (S O)) vl nil)\n (cons (cons false (nth O vl nil)) nil))))\n nil))))\n (fun vl : list (list bool) =>\n Sem PlusOneMinusMod2_e\n (cons (cons false (nth (S O) vl nil))\n (cons\n (Sem DivTwoPower_e\n (cons\n (Sem DivTwoPower_e\n (cons (nth (S (S O)) vl nil)\n (cons (nth O vl nil) nil)))\n (cons (nth (S (S (S O))) vl nil) nil)))\n (cons\n (Sem DivDivTwoPower_e\n (cons (nth (S (S O)) vl nil)\n (cons (nth (S (S O)) vl nil)\n (cons (cons false (nth O vl nil)) nil))))\n nil)))) l0 (tl l)))\n (length (smash_bs l0 (Sem (Repeat_e (S (S (S O))) (S (S O)) true) l)))
l0 : list bool
a : bool
l : list (list bool)
*****
le (S (S (length (sem_Rec (Sem (Zero_e (S (S O)))) (fun vl : list (list bool) => Sem PlusOneMinusMod2_e (cons (cons false (nth (S O) vl nil)) (cons (Sem DivTwoPower_e (cons (Sem DivTwoPower_e (cons (nth (S (S O)) vl nil) (cons (nth O vl nil) nil))) (cons (nth (S (S (S O))) vl nil) nil))) (cons (Sem DivDivTwoPower_e (cons (nth (S (S O)) vl nil) (cons (nth (S (S O)) vl nil) (cons (cons false (nth O vl nil)) nil)))) nil)))) (fun vl : list (list bool) => Sem PlusOneMinusMod2_e (cons (cons false (nth (S O) vl nil)) (cons (Sem DivTwoPower_e (cons (Sem DivTwoPower_e (cons (nth (S (S O)) vl nil) (cons (nth O vl nil) nil))) (cons (nth (S (S (S O))) vl nil) nil))) (cons (Sem DivDivTwoPower_e (cons (nth (S (S O)) vl nil) (cons (nth (S (S O)) vl nil) (cons (cons false (nth O vl nil)) nil)))) nil)))) l0 (tl l))))) (Init.Nat.add (length (Sem (Repeat_e (S (S (S O))) (S (S O)) true) l)) (length (smash_bs l0 (Sem (Repeat_e (S (S (S O))) (S (S O)) true) l))))
+++++
rewrite length_Repeat.
-----
Lemma rec_bounded_RoseS' : rec_bounded RoseS'_e.
Proof.
simpl.
intuition.
rewrite <- hd_nth_0.
induction (hd nil l).
simpl.
case a.
eapply le_trans.
simpl.
rewrite length_smash'.
rewrite length_Repeat.

*****
IHl0 : le\n (length\n (sem_Rec (Sem (Zero_e (S (S O))))\n (fun vl : list (list bool) =>\n Sem PlusOneMinusMod2_e\n (cons (cons false (nth (S O) vl nil))\n (cons\n (Sem DivTwoPower_e\n (cons\n (Sem DivTwoPower_e\n (cons (nth (S (S O)) vl nil)\n (cons (nth O vl nil) nil)))\n (cons (nth (S (S (S O))) vl nil) nil)))\n (cons\n (Sem DivDivTwoPower_e\n (cons (nth (S (S O)) vl nil)\n (cons (nth (S (S O)) vl nil)\n (cons (cons false (nth O vl nil)) nil))))\n nil))))\n (fun vl : list (list bool) =>\n Sem PlusOneMinusMod2_e\n (cons (cons false (nth (S O) vl nil))\n (cons\n (Sem DivTwoPower_e\n (cons\n (Sem DivTwoPower_e\n (cons (nth (S (S O)) vl nil)\n (cons (nth O vl nil) nil)))\n (cons (nth (S (S (S O))) vl nil) nil)))\n (cons\n (Sem DivDivTwoPower_e\n (cons (nth (S (S O)) vl nil)\n (cons (nth (S (S O)) vl nil)\n (cons (cons false (nth O vl nil)) nil))))\n nil)))) l0 (tl l)))\n (length (smash_bs l0 (Sem (Repeat_e (S (S (S O))) (S (S O)) true) l)))
l0 : list bool
a : bool
l : list (list bool)
*****
le (S (S (length (sem_Rec (Sem (Zero_e (S (S O)))) (fun vl : list (list bool) => Sem PlusOneMinusMod2_e (cons (cons false (nth (S O) vl nil)) (cons (Sem DivTwoPower_e (cons (Sem DivTwoPower_e (cons (nth (S (S O)) vl nil) (cons (nth O vl nil) nil))) (cons (nth (S (S (S O))) vl nil) nil))) (cons (Sem DivDivTwoPower_e (cons (nth (S (S O)) vl nil) (cons (nth (S (S O)) vl nil) (cons (cons false (nth O vl nil)) nil)))) nil)))) (fun vl : list (list bool) => Sem PlusOneMinusMod2_e (cons (cons false (nth (S O) vl nil)) (cons (Sem DivTwoPower_e (cons (Sem DivTwoPower_e (cons (nth (S (S O)) vl nil) (cons (nth O vl nil) nil))) (cons (nth (S (S (S O))) vl nil) nil))) (cons (Sem DivDivTwoPower_e (cons (nth (S (S O)) vl nil) (cons (nth (S (S O)) vl nil) (cons (cons false (nth O vl nil)) nil)))) nil)))) l0 (tl l))))) (Init.Nat.add (S (S O)) (length (smash_bs l0 (Sem (Repeat_e (S (S (S O))) (S (S O)) true) l))))
+++++
omega.
-----
Lemma rec_bounded_RoseS' : rec_bounded RoseS'_e.
Proof.
simpl.
intuition.
rewrite <- hd_nth_0.
induction (hd nil l).
simpl.
case a.

*****
IHl0 : le\n (length\n (sem_Rec (Sem (Zero_e (S (S O))))\n (fun vl : list (list bool) =>\n Sem PlusOneMinusMod2_e\n (cons (cons false (nth (S O) vl nil))\n (cons\n (Sem DivTwoPower_e\n (cons\n (Sem DivTwoPower_e\n (cons (nth (S (S O)) vl nil)\n (cons (nth O vl nil) nil)))\n (cons (nth (S (S (S O))) vl nil) nil)))\n (cons\n (Sem DivDivTwoPower_e\n (cons (nth (S (S O)) vl nil)\n (cons (nth (S (S O)) vl nil)\n (cons (cons false (nth O vl nil)) nil))))\n nil))))\n (fun vl : list (list bool) =>\n Sem PlusOneMinusMod2_e\n (cons (cons false (nth (S O) vl nil))\n (cons\n (Sem DivTwoPower_e\n (cons\n (Sem DivTwoPower_e\n (cons (nth (S (S O)) vl nil)\n (cons (nth O vl nil) nil)))\n (cons (nth (S (S (S O))) vl nil) nil)))\n (cons\n (Sem DivDivTwoPower_e\n (cons (nth (S (S O)) vl nil)\n (cons (nth (S (S O)) vl nil)\n (cons (cons false (nth O vl nil)) nil))))\n nil)))) l0 (tl l)))\n (length (smash_bs l0 (Sem (Repeat_e (S (S (S O))) (S (S O)) true) l)))
l0 : list bool
a : bool
l : list (list bool)
*****
le (length (Sem PlusOneMinusMod2_e (cons (cons false (sem_Rec (Sem (Zero_e (S (S O)))) (fun vl : list (list bool) => Sem PlusOneMinusMod2_e (cons (cons false (nth (S O) vl nil)) (cons (Sem DivTwoPower_e (cons (Sem DivTwoPower_e (cons (nth (S (S O)) vl nil) (cons (nth O vl nil) nil))) (cons (nth (S (S (S O))) vl nil) nil))) (cons (Sem DivDivTwoPower_e (cons (nth (S (S O)) vl nil) (cons (nth (S (S O)) vl nil) (cons (cons false (nth O vl nil)) nil)))) nil)))) (fun vl : list (list bool) => Sem PlusOneMinusMod2_e (cons (cons false (nth (S O) vl nil)) (cons (Sem DivTwoPower_e (cons (Sem DivTwoPower_e (cons (nth (S (S O)) vl nil) (cons (nth O vl nil) nil))) (cons (nth (S (S (S O))) vl nil) nil))) (cons (Sem DivDivTwoPower_e (cons (nth (S (S O)) vl nil) (cons (nth (S (S O)) vl nil) (cons (cons false (nth O vl nil)) nil)))) nil)))) l0 (tl l))) (cons (Sem DivTwoPower_e (cons (Sem DivTwoPower_e (cons (nth O (tl l) nil) (cons l0 nil))) (cons (nth (S O) (tl l) nil) nil))) (cons (Sem DivDivTwoPower_e (cons (nth O (tl l) nil) (cons (nth O (tl l) nil) (cons (cons false l0) nil)))) nil))))) (length (smash' (Sem (Repeat_e (S (S (S O))) (S (S O)) true) l) (smash_bs l0 (Sem (Repeat_e (S (S (S O))) (S (S O)) true) l))))
+++++
eapply le_trans.
-----
Lemma rec_bounded_RoseS' : rec_bounded RoseS'_e.
Proof.
simpl.
intuition.
rewrite <- hd_nth_0.
induction (hd nil l).
simpl.
case a.
eapply le_trans.

*****
IHl0 : le\n (length\n (sem_Rec (Sem (Zero_e (S (S O))))\n (fun vl : list (list bool) =>\n Sem PlusOneMinusMod2_e\n (cons (cons false (nth (S O) vl nil))\n (cons\n (Sem DivTwoPower_e\n (cons\n (Sem DivTwoPower_e\n (cons (nth (S (S O)) vl nil)\n (cons (nth O vl nil) nil)))\n (cons (nth (S (S (S O))) vl nil) nil)))\n (cons\n (Sem DivDivTwoPower_e\n (cons (nth (S (S O)) vl nil)\n (cons (nth (S (S O)) vl nil)\n (cons (cons false (nth O vl nil)) nil))))\n nil))))\n (fun vl : list (list bool) =>\n Sem PlusOneMinusMod2_e\n (cons (cons false (nth (S O) vl nil))\n (cons\n (Sem DivTwoPower_e\n (cons\n (Sem DivTwoPower_e\n (cons (nth (S (S O)) vl nil)\n (cons (nth O vl nil) nil)))\n (cons (nth (S (S (S O))) vl nil) nil)))\n (cons\n (Sem DivDivTwoPower_e\n (cons (nth (S (S O)) vl nil)\n (cons (nth (S (S O)) vl nil)\n (cons (cons false (nth O vl nil)) nil))))\n nil)))) l0 (tl l)))\n (length (smash_bs l0 (Sem (Repeat_e (S (S (S O))) (S (S O)) true) l)))
l0 : list bool
a : bool
l : list (list bool)
*****
le (length (Sem PlusOneMinusMod2_e (cons (cons false (sem_Rec (Sem (Zero_e (S (S O)))) (fun vl : list (list bool) => Sem PlusOneMinusMod2_e (cons (cons false (nth (S O) vl nil)) (cons (Sem DivTwoPower_e (cons (Sem DivTwoPower_e (cons (nth (S (S O)) vl nil) (cons (nth O vl nil) nil))) (cons (nth (S (S (S O))) vl nil) nil))) (cons (Sem DivDivTwoPower_e (cons (nth (S (S O)) vl nil) (cons (nth (S (S O)) vl nil) (cons (cons false (nth O vl nil)) nil)))) nil)))) (fun vl : list (list bool) => Sem PlusOneMinusMod2_e (cons (cons false (nth (S O) vl nil)) (cons (Sem DivTwoPower_e (cons (Sem DivTwoPower_e (cons (nth (S (S O)) vl nil) (cons (nth O vl nil) nil))) (cons (nth (S (S (S O))) vl nil) nil))) (cons (Sem DivDivTwoPower_e (cons (nth (S (S O)) vl nil) (cons (nth (S (S O)) vl nil) (cons (cons false (nth O vl nil)) nil)))) nil)))) l0 (tl l))) (cons (Sem DivTwoPower_e (cons (Sem DivTwoPower_e (cons (nth O (tl l) nil) (cons l0 nil))) (cons (nth (S O) (tl l) nil) nil))) (cons (Sem DivDivTwoPower_e (cons (nth O (tl l) nil) (cons (nth O (tl l) nil) (cons (cons false l0) nil)))) nil))))) ?m
+++++
apply PlusOneMinusMod2_length.
-----
Lemma rec_bounded_RoseS' : rec_bounded RoseS'_e.
Proof.
simpl.
intuition.
rewrite <- hd_nth_0.
induction (hd nil l).
simpl.
case a.
eapply le_trans.

*****
IHl0 : le\n (length\n (sem_Rec (Sem (Zero_e (S (S O))))\n (fun vl : list (list bool) =>\n Sem PlusOneMinusMod2_e\n (cons (cons false (nth (S O) vl nil))\n (cons\n (Sem DivTwoPower_e\n (cons\n (Sem DivTwoPower_e\n (cons (nth (S (S O)) vl nil)\n (cons (nth O vl nil) nil)))\n (cons (nth (S (S (S O))) vl nil) nil)))\n (cons\n (Sem DivDivTwoPower_e\n (cons (nth (S (S O)) vl nil)\n (cons (nth (S (S O)) vl nil)\n (cons (cons false (nth O vl nil)) nil))))\n nil))))\n (fun vl : list (list bool) =>\n Sem PlusOneMinusMod2_e\n (cons (cons false (nth (S O) vl nil))\n (cons\n (Sem DivTwoPower_e\n (cons\n (Sem DivTwoPower_e\n (cons (nth (S (S O)) vl nil)\n (cons (nth O vl nil) nil)))\n (cons (nth (S (S (S O))) vl nil) nil)))\n (cons\n (Sem DivDivTwoPower_e\n (cons (nth (S (S O)) vl nil)\n (cons (nth (S (S O)) vl nil)\n (cons (cons false (nth O vl nil)) nil))))\n nil)))) l0 (tl l)))\n (length (smash_bs l0 (Sem (Repeat_e (S (S (S O))) (S (S O)) true) l)))
l0 : list bool
a : bool
l : list (list bool)
*****
le (S (length (hd nil (cons (cons false (sem_Rec (Sem (Zero_e (S (S O)))) (fun vl : list (list bool) => Sem PlusOneMinusMod2_e (cons (cons false (nth (S O) vl nil)) (cons (Sem DivTwoPower_e (cons (Sem DivTwoPower_e (cons (nth (S (S O)) vl nil) (cons (nth O vl nil) nil))) (cons (nth (S (S (S O))) vl nil) nil))) (cons (Sem DivDivTwoPower_e (cons (nth (S (S O)) vl nil) (cons (nth (S (S O)) vl nil) (cons (cons false (nth O vl nil)) nil)))) nil)))) (fun vl : list (list bool) => Sem PlusOneMinusMod2_e (cons (cons false (nth (S O) vl nil)) (cons (Sem DivTwoPower_e (cons (Sem DivTwoPower_e (cons (nth (S (S O)) vl nil) (cons (nth O vl nil) nil))) (cons (nth (S (S (S O))) vl nil) nil))) (cons (Sem DivDivTwoPower_e (cons (nth (S (S O)) vl nil) (cons (nth (S (S O)) vl nil) (cons (cons false (nth O vl nil)) nil)))) nil)))) l0 (tl l))) (cons (Sem DivTwoPower_e (cons (Sem DivTwoPower_e (cons (nth O (tl l) nil) (cons l0 nil))) (cons (nth (S O) (tl l) nil) nil))) (cons (Sem DivDivTwoPower_e (cons (nth O (tl l) nil) (cons (nth O (tl l) nil) (cons (cons false l0) nil)))) nil)))))) (length (smash' (Sem (Repeat_e (S (S (S O))) (S (S O)) true) l) (smash_bs l0 (Sem (Repeat_e (S (S (S O))) (S (S O)) true) l))))
+++++
simpl.
-----
Lemma rec_bounded_RoseS' : rec_bounded RoseS'_e.
Proof.
simpl.
intuition.
rewrite <- hd_nth_0.
induction (hd nil l).
simpl.
case a.
eapply le_trans.
simpl.

*****
IHl0 : le\n (length\n (sem_Rec (Sem (Zero_e (S (S O))))\n (fun vl : list (list bool) =>\n Sem PlusOneMinusMod2_e\n (cons (cons false (nth (S O) vl nil))\n (cons\n (Sem DivTwoPower_e\n (cons\n (Sem DivTwoPower_e\n (cons (nth (S (S O)) vl nil)\n (cons (nth O vl nil) nil)))\n (cons (nth (S (S (S O))) vl nil) nil)))\n (cons\n (Sem DivDivTwoPower_e\n (cons (nth (S (S O)) vl nil)\n (cons (nth (S (S O)) vl nil)\n (cons (cons false (nth O vl nil)) nil))))\n nil))))\n (fun vl : list (list bool) =>\n Sem PlusOneMinusMod2_e\n (cons (cons false (nth (S O) vl nil))\n (cons\n (Sem DivTwoPower_e\n (cons\n (Sem DivTwoPower_e\n (cons (nth (S (S O)) vl nil)\n (cons (nth O vl nil) nil)))\n (cons (nth (S (S (S O))) vl nil) nil)))\n (cons\n (Sem DivDivTwoPower_e\n (cons (nth (S (S O)) vl nil)\n (cons (nth (S (S O)) vl nil)\n (cons (cons false (nth O vl nil)) nil))))\n nil)))) l0 (tl l)))\n (length (smash_bs l0 (Sem (Repeat_e (S (S (S O))) (S (S O)) true) l)))
l0 : list bool
a : bool
l : list (list bool)
*****
le (S (S (length (sem_Rec (Sem (Zero_e (S (S O)))) (fun vl : list (list bool) => Sem PlusOneMinusMod2_e (cons (cons false (nth (S O) vl nil)) (cons (Sem DivTwoPower_e (cons (Sem DivTwoPower_e (cons (nth (S (S O)) vl nil) (cons (nth O vl nil) nil))) (cons (nth (S (S (S O))) vl nil) nil))) (cons (Sem DivDivTwoPower_e (cons (nth (S (S O)) vl nil) (cons (nth (S (S O)) vl nil) (cons (cons false (nth O vl nil)) nil)))) nil)))) (fun vl : list (list bool) => Sem PlusOneMinusMod2_e (cons (cons false (nth (S O) vl nil)) (cons (Sem DivTwoPower_e (cons (Sem DivTwoPower_e (cons (nth (S (S O)) vl nil) (cons (nth O vl nil) nil))) (cons (nth (S (S (S O))) vl nil) nil))) (cons (Sem DivDivTwoPower_e (cons (nth (S (S O)) vl nil) (cons (nth (S (S O)) vl nil) (cons (cons false (nth O vl nil)) nil)))) nil)))) l0 (tl l))))) (length (smash' (Sem (Repeat_e (S (S (S O))) (S (S O)) true) l) (smash_bs l0 (Sem (Repeat_e (S (S (S O))) (S (S O)) true) l))))
+++++
rewrite length_smash'.
-----
Lemma rec_bounded_RoseS' : rec_bounded RoseS'_e.
Proof.
simpl.
intuition.
rewrite <- hd_nth_0.
induction (hd nil l).
simpl.
case a.
eapply le_trans.
simpl.
rewrite length_smash'.

*****
IHl0 : le\n (length\n (sem_Rec (Sem (Zero_e (S (S O))))\n (fun vl : list (list bool) =>\n Sem PlusOneMinusMod2_e\n (cons (cons false (nth (S O) vl nil))\n (cons\n (Sem DivTwoPower_e\n (cons\n (Sem DivTwoPower_e\n (cons (nth (S (S O)) vl nil)\n (cons (nth O vl nil) nil)))\n (cons (nth (S (S (S O))) vl nil) nil)))\n (cons\n (Sem DivDivTwoPower_e\n (cons (nth (S (S O)) vl nil)\n (cons (nth (S (S O)) vl nil)\n (cons (cons false (nth O vl nil)) nil))))\n nil))))\n (fun vl : list (list bool) =>\n Sem PlusOneMinusMod2_e\n (cons (cons false (nth (S O) vl nil))\n (cons\n (Sem DivTwoPower_e\n (cons\n (Sem DivTwoPower_e\n (cons (nth (S (S O)) vl nil)\n (cons (nth O vl nil) nil)))\n (cons (nth (S (S (S O))) vl nil) nil)))\n (cons\n (Sem DivDivTwoPower_e\n (cons (nth (S (S O)) vl nil)\n (cons (nth (S (S O)) vl nil)\n (cons (cons false (nth O vl nil)) nil))))\n nil)))) l0 (tl l)))\n (length (smash_bs l0 (Sem (Repeat_e (S (S (S O))) (S (S O)) true) l)))
l0 : list bool
a : bool
l : list (list bool)
*****
le (S (S (length (sem_Rec (Sem (Zero_e (S (S O)))) (fun vl : list (list bool) => Sem PlusOneMinusMod2_e (cons (cons false (nth (S O) vl nil)) (cons (Sem DivTwoPower_e (cons (Sem DivTwoPower_e (cons (nth (S (S O)) vl nil) (cons (nth O vl nil) nil))) (cons (nth (S (S (S O))) vl nil) nil))) (cons (Sem DivDivTwoPower_e (cons (nth (S (S O)) vl nil) (cons (nth (S (S O)) vl nil) (cons (cons false (nth O vl nil)) nil)))) nil)))) (fun vl : list (list bool) => Sem PlusOneMinusMod2_e (cons (cons false (nth (S O) vl nil)) (cons (Sem DivTwoPower_e (cons (Sem DivTwoPower_e (cons (nth (S (S O)) vl nil) (cons (nth O vl nil) nil))) (cons (nth (S (S (S O))) vl nil) nil))) (cons (Sem DivDivTwoPower_e (cons (nth (S (S O)) vl nil) (cons (nth (S (S O)) vl nil) (cons (cons false (nth O vl nil)) nil)))) nil)))) l0 (tl l))))) (Init.Nat.add (length (Sem (Repeat_e (S (S (S O))) (S (S O)) true) l)) (length (smash_bs l0 (Sem (Repeat_e (S (S (S O))) (S (S O)) true) l))))
+++++
rewrite length_Repeat.
-----
Lemma rec_bounded_RoseS' : rec_bounded RoseS'_e.
Proof.
simpl.
intuition.
rewrite <- hd_nth_0.
induction (hd nil l).
simpl.
case a.
eapply le_trans.
simpl.
rewrite length_smash'.
rewrite length_Repeat.

*****
IHl0 : le\n (length\n (sem_Rec (Sem (Zero_e (S (S O))))\n (fun vl : list (list bool) =>\n Sem PlusOneMinusMod2_e\n (cons (cons false (nth (S O) vl nil))\n (cons\n (Sem DivTwoPower_e\n (cons\n (Sem DivTwoPower_e\n (cons (nth (S (S O)) vl nil)\n (cons (nth O vl nil) nil)))\n (cons (nth (S (S (S O))) vl nil) nil)))\n (cons\n (Sem DivDivTwoPower_e\n (cons (nth (S (S O)) vl nil)\n (cons (nth (S (S O)) vl nil)\n (cons (cons false (nth O vl nil)) nil))))\n nil))))\n (fun vl : list (list bool) =>\n Sem PlusOneMinusMod2_e\n (cons (cons false (nth (S O) vl nil))\n (cons\n (Sem DivTwoPower_e\n (cons\n (Sem DivTwoPower_e\n (cons (nth (S (S O)) vl nil)\n (cons (nth O vl nil) nil)))\n (cons (nth (S (S (S O))) vl nil) nil)))\n (cons\n (Sem DivDivTwoPower_e\n (cons (nth (S (S O)) vl nil)\n (cons (nth (S (S O)) vl nil)\n (cons (cons false (nth O vl nil)) nil))))\n nil)))) l0 (tl l)))\n (length (smash_bs l0 (Sem (Repeat_e (S (S (S O))) (S (S O)) true) l)))
l0 : list bool
a : bool
l : list (list bool)
*****
le (S (S (length (sem_Rec (Sem (Zero_e (S (S O)))) (fun vl : list (list bool) => Sem PlusOneMinusMod2_e (cons (cons false (nth (S O) vl nil)) (cons (Sem DivTwoPower_e (cons (Sem DivTwoPower_e (cons (nth (S (S O)) vl nil) (cons (nth O vl nil) nil))) (cons (nth (S (S (S O))) vl nil) nil))) (cons (Sem DivDivTwoPower_e (cons (nth (S (S O)) vl nil) (cons (nth (S (S O)) vl nil) (cons (cons false (nth O vl nil)) nil)))) nil)))) (fun vl : list (list bool) => Sem PlusOneMinusMod2_e (cons (cons false (nth (S O) vl nil)) (cons (Sem DivTwoPower_e (cons (Sem DivTwoPower_e (cons (nth (S (S O)) vl nil) (cons (nth O vl nil) nil))) (cons (nth (S (S (S O))) vl nil) nil))) (cons (Sem DivDivTwoPower_e (cons (nth (S (S O)) vl nil) (cons (nth (S (S O)) vl nil) (cons (cons false (nth O vl nil)) nil)))) nil)))) l0 (tl l))))) (Init.Nat.add (S (S O)) (length (smash_bs l0 (Sem (Repeat_e (S (S (S O))) (S (S O)) true) l))))
+++++
omega.
-----
Lemma rec_bounded_RoseS' : rec_bounded RoseS'_e.
Proof.
simpl.
intuition.

*****

*****

+++++
Qed.
-----
Definition RoseS_e : Cobham :=\n  Comp 3 RoseS'_e [Proj 3 2; Proj 3 0; Proj 3 1].
-----
Lemma arity_RoseS :\n  arity RoseS_e = ok_arity 3.
-----
Lemma arity_RoseS : arity RoseS_e = ok_arity 3.

*****

*****
eq (arity RoseS_e) (ok_arity (S (S (S O))))
+++++
Proof.
-----
Lemma arity_RoseS : arity RoseS_e = ok_arity 3.
Proof.

*****

*****
eq (arity RoseS_e) (ok_arity (S (S (S O))))
+++++
trivial.
-----
Lemma arity_RoseS : arity RoseS_e = ok_arity 3.
Proof.
trivial.

*****

*****

+++++
Qed.
-----
Opaque RoseS'_e.
-----
Lemma rec_bounded_RoseS :\n  rec_bounded RoseS_e.
-----
Lemma rec_bounded_RoseS : rec_bounded RoseS_e.

*****

*****
rec_bounded RoseS_e
+++++
Proof.
-----
Lemma rec_bounded_RoseS : rec_bounded RoseS_e.
Proof.

*****

*****
rec_bounded RoseS_e
+++++
simpl.
-----
Lemma rec_bounded_RoseS : rec_bounded RoseS_e.
Proof.
simpl.

*****

*****
and (rec_bounded RoseS'_e) (and True (and True (and True True)))
+++++
intuition.
-----
Lemma rec_bounded_RoseS : rec_bounded RoseS_e.
Proof.
simpl.
intuition.

*****

*****
rec_bounded RoseS'_e
+++++
apply rec_bounded_RoseS'.
-----
Lemma rec_bounded_RoseS : rec_bounded RoseS_e.
Proof.
simpl.
intuition.
apply rec_bounded_RoseS'.

*****

*****

+++++
Qed.
-----
Transparent RoseS'_e.
-----
Lemma bs2nat_firstn_false : forall n l,\n  bs2nat (firstn n (false :: l)) = 2 * bs2nat (firstn (n-1) l).
-----
Lemma bs2nat_firstn_false : forall n l, bs2nat (firstn n (false :: l)) = 2 * bs2nat (firstn (n-1) l).

*****

*****
forall (n : nat) (l : list bool), eq (bs2nat (firstn n (cons false l))) (Init.Nat.mul (S (S O)) (bs2nat (firstn (Init.Nat.sub n (S O)) l)))
+++++
Proof.
-----
Lemma bs2nat_firstn_false : forall n l, bs2nat (firstn n (false :: l)) = 2 * bs2nat (firstn (n-1) l).
Proof.

*****

*****
forall (n : nat) (l : list bool), eq (bs2nat (firstn n (cons false l))) (Init.Nat.mul (S (S O)) (bs2nat (firstn (Init.Nat.sub n (S O)) l)))
+++++
intros.
-----
Lemma bs2nat_firstn_false : forall n l, bs2nat (firstn n (false :: l)) = 2 * bs2nat (firstn (n-1) l).
Proof.
intros.

*****
l : list bool
n : nat
*****
eq (bs2nat (firstn n (cons false l))) (Init.Nat.mul (S (S O)) (bs2nat (firstn (Init.Nat.sub n (S O)) l)))
+++++
destruct n.
-----
Lemma bs2nat_firstn_false : forall n l, bs2nat (firstn n (false :: l)) = 2 * bs2nat (firstn (n-1) l).
Proof.
intros.
destruct n.

*****
l : list bool
*****
eq (bs2nat (firstn O (cons false l))) (Init.Nat.mul (S (S O)) (bs2nat (firstn (Init.Nat.sub O (S O)) l)))
+++++
simpl.
-----
Lemma bs2nat_firstn_false : forall n l, bs2nat (firstn n (false :: l)) = 2 * bs2nat (firstn (n-1) l).
Proof.
intros.
destruct n.
simpl.

*****
l : list bool
*****
eq (bs2nat nil) (Init.Nat.add (bs2nat nil) (Init.Nat.add (bs2nat nil) O))
+++++
rewrite bs2nat_nil.
-----
Lemma bs2nat_firstn_false : forall n l, bs2nat (firstn n (false :: l)) = 2 * bs2nat (firstn (n-1) l).
Proof.
intros.
destruct n.
simpl.
rewrite bs2nat_nil.

*****
l : list bool
*****
eq O (Init.Nat.add O (Init.Nat.add O O))
+++++
ring.
-----
Lemma bs2nat_firstn_false : forall n l, bs2nat (firstn n (false :: l)) = 2 * bs2nat (firstn (n-1) l).
Proof.
intros.
destruct n.

*****
l : list bool
n : nat
*****
eq (bs2nat (firstn (S n) (cons false l))) (Init.Nat.mul (S (S O)) (bs2nat (firstn (Init.Nat.sub (S n) (S O)) l)))
+++++
simpl firstn.
-----
Lemma bs2nat_firstn_false : forall n l, bs2nat (firstn n (false :: l)) = 2 * bs2nat (firstn (n-1) l).
Proof.
intros.
destruct n.
simpl firstn.

*****
l : list bool
n : nat
*****
eq (bs2nat (cons false (firstn n l))) (Init.Nat.mul (S (S O)) (bs2nat (firstn (Init.Nat.sub n O) l)))
+++++
rewrite bs2nat_false.
-----
Lemma bs2nat_firstn_false : forall n l, bs2nat (firstn n (false :: l)) = 2 * bs2nat (firstn (n-1) l).
Proof.
intros.
destruct n.
simpl firstn.
rewrite bs2nat_false.

*****
l : list bool
n : nat
*****
eq (Init.Nat.mul (S (S O)) (bs2nat (firstn n l))) (Init.Nat.mul (S (S O)) (bs2nat (firstn (Init.Nat.sub n O) l)))
+++++
f_equal.
-----
Lemma bs2nat_firstn_false : forall n l, bs2nat (firstn n (false :: l)) = 2 * bs2nat (firstn (n-1) l).
Proof.
intros.
destruct n.
simpl firstn.
rewrite bs2nat_false.
f_equal.

*****
l : list bool
n : nat
*****
eq (bs2nat (firstn n l)) (bs2nat (firstn (Init.Nat.sub n O) l))
+++++
f_equal.
-----
Lemma bs2nat_firstn_false : forall n l, bs2nat (firstn n (false :: l)) = 2 * bs2nat (firstn (n-1) l).
Proof.
intros.
destruct n.
simpl firstn.
rewrite bs2nat_false.
f_equal.
f_equal.

*****
l : list bool
n : nat
*****
eq (firstn n l) (firstn (Init.Nat.sub n O) l)
+++++
f_equal.
-----
Lemma bs2nat_firstn_false : forall n l, bs2nat (firstn n (false :: l)) = 2 * bs2nat (firstn (n-1) l).
Proof.
intros.
destruct n.
simpl firstn.
rewrite bs2nat_false.
f_equal.
f_equal.
f_equal.

*****
l : list bool
n : nat
*****
eq n (Init.Nat.sub n O)
+++++
omega.
-----
Lemma bs2nat_firstn_false : forall n l, bs2nat (firstn n (false :: l)) = 2 * bs2nat (firstn (n-1) l).
Proof.
intros.
destruct n.

*****

*****

+++++
Qed.
-----
Lemma bs2nat_app : forall l1 l2,\n  bs2nat (l1 ++ l2) = bs2nat l1 + bs2nat (repeat (length l1) false ++ l2).
-----
Lemma bs2nat_app : forall l1 l2, bs2nat (l1 ++ l2) = bs2nat l1 + bs2nat (repeat (length l1) false ++ l2).

*****

*****
forall l1 l2 : list bool, eq (bs2nat (app l1 l2)) (Init.Nat.add (bs2nat l1) (bs2nat (app (repeat (length l1) false) l2)))
+++++
Proof.
-----
Lemma bs2nat_app : forall l1 l2, bs2nat (l1 ++ l2) = bs2nat l1 + bs2nat (repeat (length l1) false ++ l2).
Proof.

*****

*****
forall l1 l2 : list bool, eq (bs2nat (app l1 l2)) (Init.Nat.add (bs2nat l1) (bs2nat (app (repeat (length l1) false) l2)))
+++++
intros.
-----
Lemma bs2nat_app : forall l1 l2, bs2nat (l1 ++ l2) = bs2nat l1 + bs2nat (repeat (length l1) false ++ l2).
Proof.
intros.

*****
l1,l2 : list bool
*****
eq (bs2nat (app l1 l2)) (Init.Nat.add (bs2nat l1) (bs2nat (app (repeat (length l1) false) l2)))
+++++
induction l1.
-----
Lemma bs2nat_app : forall l1 l2, bs2nat (l1 ++ l2) = bs2nat l1 + bs2nat (repeat (length l1) false ++ l2).
Proof.
intros.
induction l1.

*****
l2 : list bool
*****
eq (bs2nat (app nil l2)) (Init.Nat.add (bs2nat nil) (bs2nat (app (repeat (length nil) false) l2)))
+++++
simpl.
-----
Lemma bs2nat_app : forall l1 l2, bs2nat (l1 ++ l2) = bs2nat l1 + bs2nat (repeat (length l1) false ++ l2).
Proof.
intros.
induction l1.
simpl.

*****
l2 : list bool
*****
eq (bs2nat l2) (Init.Nat.add (bs2nat nil) (bs2nat l2))
+++++
rewrite bs2nat_nil.
-----
Lemma bs2nat_app : forall l1 l2, bs2nat (l1 ++ l2) = bs2nat l1 + bs2nat (repeat (length l1) false ++ l2).
Proof.
intros.
induction l1.
simpl.
rewrite bs2nat_nil.

*****
l2 : list bool
*****
eq (bs2nat l2) (Init.Nat.add O (bs2nat l2))
+++++
auto.
-----
Lemma bs2nat_app : forall l1 l2, bs2nat (l1 ++ l2) = bs2nat l1 + bs2nat (repeat (length l1) false ++ l2).
Proof.
intros.
induction l1.

*****
IHl1 : eq (bs2nat (app l1 l2))\n (Init.Nat.add (bs2nat l1)\n (bs2nat (app (repeat (length l1) false) l2)))
l1,l2 : list bool
a : bool
*****
eq (bs2nat (app (cons a l1) l2)) (Init.Nat.add (bs2nat (cons a l1)) (bs2nat (app (repeat (length (cons a l1)) false) l2)))
+++++
simpl.
-----
Lemma bs2nat_app : forall l1 l2, bs2nat (l1 ++ l2) = bs2nat l1 + bs2nat (repeat (length l1) false ++ l2).
Proof.
intros.
induction l1.
simpl.

*****
IHl1 : eq (bs2nat (app l1 l2))\n (Init.Nat.add (bs2nat l1)\n (bs2nat (app (repeat (length l1) false) l2)))
l1,l2 : list bool
a : bool
*****
eq (bs2nat (cons a (app l1 l2))) (Init.Nat.add (bs2nat (cons a l1)) (bs2nat (cons false (app (repeat (length l1) false) l2))))
+++++
rewrite bs2nat_false.
-----
Lemma bs2nat_app : forall l1 l2, bs2nat (l1 ++ l2) = bs2nat l1 + bs2nat (repeat (length l1) false ++ l2).
Proof.
intros.
induction l1.
simpl.
rewrite bs2nat_false.

*****
IHl1 : eq (bs2nat (app l1 l2))\n (Init.Nat.add (bs2nat l1)\n (bs2nat (app (repeat (length l1) false) l2)))
l1,l2 : list bool
a : bool
*****
eq (bs2nat (cons a (app l1 l2))) (Init.Nat.add (bs2nat (cons a l1)) (Init.Nat.mul (S (S O)) (bs2nat (app (repeat (length l1) false) l2))))
+++++
simpl.
-----
Lemma bs2nat_app : forall l1 l2, bs2nat (l1 ++ l2) = bs2nat l1 + bs2nat (repeat (length l1) false ++ l2).
Proof.
intros.
induction l1.
simpl.
rewrite bs2nat_false.
simpl.

*****
IHl1 : eq (bs2nat (app l1 l2))\n (Init.Nat.add (bs2nat l1)\n (bs2nat (app (repeat (length l1) false) l2)))
l1,l2 : list bool
a : bool
*****
eq (bs2nat (cons a (app l1 l2))) (Init.Nat.add (bs2nat (cons a l1)) (Init.Nat.add (bs2nat (app (repeat (length l1) false) l2)) (Init.Nat.add (bs2nat (app (repeat (length l1) false) l2)) O)))
+++++
destruct a.
-----
Lemma bs2nat_app : forall l1 l2, bs2nat (l1 ++ l2) = bs2nat l1 + bs2nat (repeat (length l1) false ++ l2).
Proof.
intros.
induction l1.
simpl.
rewrite bs2nat_false.
simpl.
destruct a.

*****
IHl1 : eq (bs2nat (app l1 l2))\n (Init.Nat.add (bs2nat l1)\n (bs2nat (app (repeat (length l1) false) l2)))
l1,l2 : list bool
*****
eq (bs2nat (cons true (app l1 l2))) (Init.Nat.add (bs2nat (cons true l1)) (Init.Nat.add (bs2nat (app (repeat (length l1) false) l2)) (Init.Nat.add (bs2nat (app (repeat (length l1) false) l2)) O)))
+++++
simpl.
-----
Lemma bs2nat_app : forall l1 l2, bs2nat (l1 ++ l2) = bs2nat l1 + bs2nat (repeat (length l1) false ++ l2).
Proof.
intros.
induction l1.
simpl.
rewrite bs2nat_false.
simpl.
destruct a.
simpl.

*****
IHl1 : eq (bs2nat (app l1 l2))\n (Init.Nat.add (bs2nat l1)\n (bs2nat (app (repeat (length l1) false) l2)))
l1,l2 : list bool
*****
eq (bs2nat (cons true (app l1 l2))) (Init.Nat.add (bs2nat (cons true l1)) (Init.Nat.add (bs2nat (app (repeat (length l1) false) l2)) (Init.Nat.add (bs2nat (app (repeat (length l1) false) l2)) O)))
+++++
repeat rewrite bs2nat_true.
-----
Lemma bs2nat_app : forall l1 l2, bs2nat (l1 ++ l2) = bs2nat l1 + bs2nat (repeat (length l1) false ++ l2).
Proof.
intros.
induction l1.
simpl.
rewrite bs2nat_false.
simpl.
destruct a.
simpl.
repeat rewrite bs2nat_true.

*****
IHl1 : eq (bs2nat (app l1 l2))\n (Init.Nat.add (bs2nat l1)\n (bs2nat (app (repeat (length l1) false) l2)))
l1,l2 : list bool
*****
eq (Init.Nat.add (S O) (Init.Nat.mul (S (S O)) (bs2nat (app l1 l2)))) (Init.Nat.add (Init.Nat.add (S O) (Init.Nat.mul (S (S O)) (bs2nat l1))) (Init.Nat.add (bs2nat (app (repeat (length l1) false) l2)) (Init.Nat.add (bs2nat (app (repeat (length l1) false) l2)) O)))
+++++
rewrite IHl1.
-----
Lemma bs2nat_app : forall l1 l2, bs2nat (l1 ++ l2) = bs2nat l1 + bs2nat (repeat (length l1) false ++ l2).
Proof.
intros.
induction l1.
simpl.
rewrite bs2nat_false.
simpl.
destruct a.
simpl.
repeat rewrite bs2nat_true.
rewrite IHl1.

*****
IHl1 : eq (bs2nat (app l1 l2))\n (Init.Nat.add (bs2nat l1)\n (bs2nat (app (repeat (length l1) false) l2)))
l1,l2 : list bool
*****
eq (Init.Nat.add (S O) (Init.Nat.mul (S (S O)) (Init.Nat.add (bs2nat l1) (bs2nat (app (repeat (length l1) false) l2))))) (Init.Nat.add (Init.Nat.add (S O) (Init.Nat.mul (S (S O)) (bs2nat l1))) (Init.Nat.add (bs2nat (app (repeat (length l1) false) l2)) (Init.Nat.add (bs2nat (app (repeat (length l1) false) l2)) O)))
+++++
simpl.
-----
Lemma bs2nat_app : forall l1 l2, bs2nat (l1 ++ l2) = bs2nat l1 + bs2nat (repeat (length l1) false ++ l2).
Proof.
intros.
induction l1.
simpl.
rewrite bs2nat_false.
simpl.
destruct a.
simpl.
repeat rewrite bs2nat_true.
rewrite IHl1.
simpl.

*****
IHl1 : eq (bs2nat (app l1 l2))\n (Init.Nat.add (bs2nat l1)\n (bs2nat (app (repeat (length l1) false) l2)))
l1,l2 : list bool
*****
eq (S (Init.Nat.add (Init.Nat.add (bs2nat l1) (bs2nat (app (repeat (length l1) false) l2))) (Init.Nat.add (Init.Nat.add (bs2nat l1) (bs2nat (app (repeat (length l1) false) l2))) O))) (S (Init.Nat.add (Init.Nat.add (bs2nat l1) (Init.Nat.add (bs2nat l1) O)) (Init.Nat.add (bs2nat (app (repeat (length l1) false) l2)) (Init.Nat.add (bs2nat (app (repeat (length l1) false) l2)) O))))
+++++
simpl.
-----
Lemma bs2nat_app : forall l1 l2, bs2nat (l1 ++ l2) = bs2nat l1 + bs2nat (repeat (length l1) false ++ l2).
Proof.
intros.
induction l1.
simpl.
rewrite bs2nat_false.
simpl.
destruct a.
simpl.
repeat rewrite bs2nat_true.
rewrite IHl1.
simpl.
simpl.

*****
IHl1 : eq (bs2nat (app l1 l2))\n (Init.Nat.add (bs2nat l1)\n (bs2nat (app (repeat (length l1) false) l2)))
l1,l2 : list bool
*****
eq (S (Init.Nat.add (Init.Nat.add (bs2nat l1) (bs2nat (app (repeat (length l1) false) l2))) (Init.Nat.add (Init.Nat.add (bs2nat l1) (bs2nat (app (repeat (length l1) false) l2))) O))) (S (Init.Nat.add (Init.Nat.add (bs2nat l1) (Init.Nat.add (bs2nat l1) O)) (Init.Nat.add (bs2nat (app (repeat (length l1) false) l2)) (Init.Nat.add (bs2nat (app (repeat (length l1) false) l2)) O))))
+++++
ring.
-----
Lemma bs2nat_app : forall l1 l2, bs2nat (l1 ++ l2) = bs2nat l1 + bs2nat (repeat (length l1) false ++ l2).
Proof.
intros.
induction l1.
simpl.
rewrite bs2nat_false.
simpl.
destruct a.

*****
IHl1 : eq (bs2nat (app l1 l2))\n (Init.Nat.add (bs2nat l1)\n (bs2nat (app (repeat (length l1) false) l2)))
l1,l2 : list bool
*****
eq (bs2nat (cons false (app l1 l2))) (Init.Nat.add (bs2nat (cons false l1)) (Init.Nat.add (bs2nat (app (repeat (length l1) false) l2)) (Init.Nat.add (bs2nat (app (repeat (length l1) false) l2)) O)))
+++++
simpl.
-----
Lemma bs2nat_app : forall l1 l2, bs2nat (l1 ++ l2) = bs2nat l1 + bs2nat (repeat (length l1) false ++ l2).
Proof.
intros.
induction l1.
simpl.
rewrite bs2nat_false.
simpl.
destruct a.
simpl.

*****
IHl1 : eq (bs2nat (app l1 l2))\n (Init.Nat.add (bs2nat l1)\n (bs2nat (app (repeat (length l1) false) l2)))
l1,l2 : list bool
*****
eq (bs2nat (cons false (app l1 l2))) (Init.Nat.add (bs2nat (cons false l1)) (Init.Nat.add (bs2nat (app (repeat (length l1) false) l2)) (Init.Nat.add (bs2nat (app (repeat (length l1) false) l2)) O)))
+++++
repeat rewrite bs2nat_false.
-----
Lemma bs2nat_app : forall l1 l2, bs2nat (l1 ++ l2) = bs2nat l1 + bs2nat (repeat (length l1) false ++ l2).
Proof.
intros.
induction l1.
simpl.
rewrite bs2nat_false.
simpl.
destruct a.
simpl.
repeat rewrite bs2nat_false.

*****
IHl1 : eq (bs2nat (app l1 l2))\n (Init.Nat.add (bs2nat l1)\n (bs2nat (app (repeat (length l1) false) l2)))
l1,l2 : list bool
*****
eq (Init.Nat.mul (S (S O)) (bs2nat (app l1 l2))) (Init.Nat.add (Init.Nat.mul (S (S O)) (bs2nat l1)) (Init.Nat.add (bs2nat (app (repeat (length l1) false) l2)) (Init.Nat.add (bs2nat (app (repeat (length l1) false) l2)) O)))
+++++
rewrite IHl1.
-----
Lemma bs2nat_app : forall l1 l2, bs2nat (l1 ++ l2) = bs2nat l1 + bs2nat (repeat (length l1) false ++ l2).
Proof.
intros.
induction l1.
simpl.
rewrite bs2nat_false.
simpl.
destruct a.
simpl.
repeat rewrite bs2nat_false.
rewrite IHl1.

*****
IHl1 : eq (bs2nat (app l1 l2))\n (Init.Nat.add (bs2nat l1)\n (bs2nat (app (repeat (length l1) false) l2)))
l1,l2 : list bool
*****
eq (Init.Nat.mul (S (S O)) (Init.Nat.add (bs2nat l1) (bs2nat (app (repeat (length l1) false) l2)))) (Init.Nat.add (Init.Nat.mul (S (S O)) (bs2nat l1)) (Init.Nat.add (bs2nat (app (repeat (length l1) false) l2)) (Init.Nat.add (bs2nat (app (repeat (length l1) false) l2)) O)))
+++++
simpl.
-----
Lemma bs2nat_app : forall l1 l2, bs2nat (l1 ++ l2) = bs2nat l1 + bs2nat (repeat (length l1) false ++ l2).
Proof.
intros.
induction l1.
simpl.
rewrite bs2nat_false.
simpl.
destruct a.
simpl.
repeat rewrite bs2nat_false.
rewrite IHl1.
simpl.

*****
IHl1 : eq (bs2nat (app l1 l2))\n (Init.Nat.add (bs2nat l1)\n (bs2nat (app (repeat (length l1) false) l2)))
l1,l2 : list bool
*****
eq (Init.Nat.add (Init.Nat.add (bs2nat l1) (bs2nat (app (repeat (length l1) false) l2))) (Init.Nat.add (Init.Nat.add (bs2nat l1) (bs2nat (app (repeat (length l1) false) l2))) O)) (Init.Nat.add (Init.Nat.add (bs2nat l1) (Init.Nat.add (bs2nat l1) O)) (Init.Nat.add (bs2nat (app (repeat (length l1) false) l2)) (Init.Nat.add (bs2nat (app (repeat (length l1) false) l2)) O)))
+++++
simpl.
-----
Lemma bs2nat_app : forall l1 l2, bs2nat (l1 ++ l2) = bs2nat l1 + bs2nat (repeat (length l1) false ++ l2).
Proof.
intros.
induction l1.
simpl.
rewrite bs2nat_false.
simpl.
destruct a.
simpl.
repeat rewrite bs2nat_false.
rewrite IHl1.
simpl.
simpl.

*****
IHl1 : eq (bs2nat (app l1 l2))\n (Init.Nat.add (bs2nat l1)\n (bs2nat (app (repeat (length l1) false) l2)))
l1,l2 : list bool
*****
eq (Init.Nat.add (Init.Nat.add (bs2nat l1) (bs2nat (app (repeat (length l1) false) l2))) (Init.Nat.add (Init.Nat.add (bs2nat l1) (bs2nat (app (repeat (length l1) false) l2))) O)) (Init.Nat.add (Init.Nat.add (bs2nat l1) (Init.Nat.add (bs2nat l1) O)) (Init.Nat.add (bs2nat (app (repeat (length l1) false) l2)) (Init.Nat.add (bs2nat (app (repeat (length l1) false) l2)) O)))
+++++
ring.
-----
Lemma bs2nat_app : forall l1 l2, bs2nat (l1 ++ l2) = bs2nat l1 + bs2nat (repeat (length l1) false ++ l2).
Proof.
intros.
induction l1.

*****

*****

+++++
Qed.
-----
Lemma bs2nat_power : forall l n,\n  bs2nat (repeat n false ++ l) = (power 2 n) * (bs2nat l).
-----
Lemma bs2nat_power : forall l n, bs2nat (repeat n false ++ l) = (power 2 n) * (bs2nat l).

*****

*****
forall (l : list bool) (n : nat), eq (bs2nat (app (repeat n false) l)) (Init.Nat.mul (power (S (S O)) n) (bs2nat l))
+++++
Proof.
-----
Lemma bs2nat_power : forall l n, bs2nat (repeat n false ++ l) = (power 2 n) * (bs2nat l).
Proof.

*****

*****
forall (l : list bool) (n : nat), eq (bs2nat (app (repeat n false) l)) (Init.Nat.mul (power (S (S O)) n) (bs2nat l))
+++++
induction n.
-----
Lemma bs2nat_power : forall l n, bs2nat (repeat n false ++ l) = (power 2 n) * (bs2nat l).
Proof.
induction n.

*****
l : list bool
*****
eq (bs2nat (app (repeat O false) l)) (Init.Nat.mul (power (S (S O)) O) (bs2nat l))
+++++
simpl.
-----
Lemma bs2nat_power : forall l n, bs2nat (repeat n false ++ l) = (power 2 n) * (bs2nat l).
Proof.
induction n.
simpl.

*****
l : list bool
*****
eq (bs2nat l) (Init.Nat.add (bs2nat l) O)
+++++
auto.
-----
Lemma bs2nat_power : forall l n, bs2nat (repeat n false ++ l) = (power 2 n) * (bs2nat l).
Proof.
induction n.

*****
IHn : eq (bs2nat (app (repeat n false) l))\n (Init.Nat.mul (power (S (S O)) n) (bs2nat l))
n : nat
l : list bool
*****
eq (bs2nat (app (repeat (S n) false) l)) (Init.Nat.mul (power (S (S O)) (S n)) (bs2nat l))
+++++
simpl.
-----
Lemma bs2nat_power : forall l n, bs2nat (repeat n false ++ l) = (power 2 n) * (bs2nat l).
Proof.
induction n.
simpl.

*****
IHn : eq (bs2nat (app (repeat n false) l))\n (Init.Nat.mul (power (S (S O)) n) (bs2nat l))
n : nat
l : list bool
*****
eq (bs2nat (cons false (app (repeat n false) l))) (Init.Nat.mul (Init.Nat.add (power (S (S O)) n) (Init.Nat.add (power (S (S O)) n) O)) (bs2nat l))
+++++
auto.
-----
Lemma bs2nat_power : forall l n, bs2nat (repeat n false ++ l) = (power 2 n) * (bs2nat l).
Proof.
induction n.
simpl.
auto.

*****
IHn : eq (bs2nat (app (repeat n false) l))\n (Init.Nat.mul (power (S (S O)) n) (bs2nat l))
n : nat
l : list bool
*****
eq (bs2nat (cons false (app (repeat n false) l))) (Init.Nat.mul (Init.Nat.add (power (S (S O)) n) (Init.Nat.add (power (S (S O)) n) O)) (bs2nat l))
+++++
rewrite bs2nat_false.
-----
Lemma bs2nat_power : forall l n, bs2nat (repeat n false ++ l) = (power 2 n) * (bs2nat l).
Proof.
induction n.
simpl.
auto.
rewrite bs2nat_false.

*****
IHn : eq (bs2nat (app (repeat n false) l))\n (Init.Nat.mul (power (S (S O)) n) (bs2nat l))
n : nat
l : list bool
*****
eq (Init.Nat.mul (S (S O)) (bs2nat (app (repeat n false) l))) (Init.Nat.mul (Init.Nat.add (power (S (S O)) n) (Init.Nat.add (power (S (S O)) n) O)) (bs2nat l))
+++++
simpl.
-----
Lemma bs2nat_power : forall l n, bs2nat (repeat n false ++ l) = (power 2 n) * (bs2nat l).
Proof.
induction n.
simpl.
auto.
rewrite bs2nat_false.
simpl.

*****
IHn : eq (bs2nat (app (repeat n false) l))\n (Init.Nat.mul (power (S (S O)) n) (bs2nat l))
n : nat
l : list bool
*****
eq (Init.Nat.add (bs2nat (app (repeat n false) l)) (Init.Nat.add (bs2nat (app (repeat n false) l)) O)) (Init.Nat.mul (Init.Nat.add (power (S (S O)) n) (Init.Nat.add (power (S (S O)) n) O)) (bs2nat l))
+++++
rewrite IHn.
-----
Lemma bs2nat_power : forall l n, bs2nat (repeat n false ++ l) = (power 2 n) * (bs2nat l).
Proof.
induction n.
simpl.
auto.
rewrite bs2nat_false.
simpl.
rewrite IHn.

*****
IHn : eq (bs2nat (app (repeat n false) l))\n (Init.Nat.mul (power (S (S O)) n) (bs2nat l))
n : nat
l : list bool
*****
eq (Init.Nat.add (Init.Nat.mul (power (S (S O)) n) (bs2nat l)) (Init.Nat.add (Init.Nat.mul (power (S (S O)) n) (bs2nat l)) O)) (Init.Nat.mul (Init.Nat.add (power (S (S O)) n) (Init.Nat.add (power (S (S O)) n) O)) (bs2nat l))
+++++
ring.
-----
Lemma bs2nat_power : forall l n, bs2nat (repeat n false ++ l) = (power 2 n) * (bs2nat l).
Proof.
induction n.

*****

*****

+++++
Qed.
-----
Fixpoint RoseS_spec (x y z : bs) :=\n  match z with\n    | nil => nil\n    | _ :: z' =>\n      if leb (length z) (length x - length y)\n        then false :: RoseS_spec x y z'\n        else hd false (skipn (length x - length z) x) :: RoseS_spec x y z'\n  end.
-----
Lemma RoseS_spec2_false : forall x y z,\n  length z <= length x - length y ->\n  bs2nat (RoseS_spec x y z) = 0.
-----
Lemma RoseS_spec2_false : forall x y z, length z <= length x - length y -> bs2nat (RoseS_spec x y z) = 0.

*****

*****
forall (x y z : list bool) (_ : le (length z) (Init.Nat.sub (length x) (length y))), eq (bs2nat (RoseS_spec x y z)) O
+++++
Proof.
-----
Lemma RoseS_spec2_false : forall x y z, length z <= length x - length y -> bs2nat (RoseS_spec x y z) = 0.
Proof.

*****

*****
forall (x y z : list bool) (_ : le (length z) (Init.Nat.sub (length x) (length y))), eq (bs2nat (RoseS_spec x y z)) O
+++++
induction z.
-----
Lemma RoseS_spec2_false : forall x y z, length z <= length x - length y -> bs2nat (RoseS_spec x y z) = 0.
Proof.
induction z.

*****
x,y : list bool
*****
forall _ : le (length nil) (Init.Nat.sub (length x) (length y)), eq (bs2nat (RoseS_spec x y nil)) O
+++++
simpl.
-----
Lemma RoseS_spec2_false : forall x y z, length z <= length x - length y -> bs2nat (RoseS_spec x y z) = 0.
Proof.
induction z.
simpl.

*****
x,y : list bool
*****
forall _ : le O (Init.Nat.sub (length x) (length y)), eq (bs2nat nil) O
+++++
intros.
-----
Lemma RoseS_spec2_false : forall x y z, length z <= length x - length y -> bs2nat (RoseS_spec x y z) = 0.
Proof.
induction z.
simpl.
intros.

*****
H : le O (Init.Nat.sub (length x) (length y))
x,y : list bool
*****
eq (bs2nat nil) O
+++++
rewrite bs2nat_nil.
-----
Lemma RoseS_spec2_false : forall x y z, length z <= length x - length y -> bs2nat (RoseS_spec x y z) = 0.
Proof.
induction z.
simpl.
intros.
rewrite bs2nat_nil.

*****
H : le O (Init.Nat.sub (length x) (length y))
x,y : list bool
*****
eq O O
+++++
trivial.
-----
Lemma RoseS_spec2_false : forall x y z, length z <= length x - length y -> bs2nat (RoseS_spec x y z) = 0.
Proof.
induction z.

*****
IHz : forall _ : le (length z) (Init.Nat.sub (length x) (length y)),\neq (bs2nat (RoseS_spec x y z)) O
z : list bool
a : bool
x,y : list bool
*****
forall _ : le (length (cons a z)) (Init.Nat.sub (length x) (length y)), eq (bs2nat (RoseS_spec x y (cons a z))) O
+++++
simpl.
-----
Lemma RoseS_spec2_false : forall x y z, length z <= length x - length y -> bs2nat (RoseS_spec x y z) = 0.
Proof.
induction z.
simpl.

*****
IHz : forall _ : le (length z) (Init.Nat.sub (length x) (length y)),\neq (bs2nat (RoseS_spec x y z)) O
z : list bool
a : bool
x,y : list bool
*****
forall _ : le (S (length z)) (Init.Nat.sub (length x) (length y)), eq (bs2nat (if match Init.Nat.sub (length x) (length y) with | O => false | S m' => Nat.leb (length z) m' end then cons false (RoseS_spec x y z) else cons (hd false (skipn (Init.Nat.sub (length x) (S (length z))) x)) (RoseS_spec x y z))) O
+++++
intros.
-----
Lemma RoseS_spec2_false : forall x y z, length z <= length x - length y -> bs2nat (RoseS_spec x y z) = 0.
Proof.
induction z.
simpl.
intros.

*****
H : le (S (length z)) (Init.Nat.sub (length x) (length y))
IHz : forall _ : le (length z) (Init.Nat.sub (length x) (length y)),\neq (bs2nat (RoseS_spec x y z)) O
z : list bool
a : bool
x,y : list bool
*****
eq (bs2nat (if match Init.Nat.sub (length x) (length y) with | O => false | S m' => Nat.leb (length z) m' end then cons false (RoseS_spec x y z) else cons (hd false (skipn (Init.Nat.sub (length x) (S (length z))) x)) (RoseS_spec x y z))) O
+++++
case_eq (length x - length y).
-----
Lemma RoseS_spec2_false : forall x y z, length z <= length x - length y -> bs2nat (RoseS_spec x y z) = 0.
Proof.
induction z.
simpl.
intros.
case_eq (length x - length y).

*****
H : le (S (length z)) (Init.Nat.sub (length x) (length y))
IHz : forall _ : le (length z) (Init.Nat.sub (length x) (length y)),\neq (bs2nat (RoseS_spec x y z)) O
z : list bool
a : bool
x,y : list bool
*****
forall _ : eq (Init.Nat.sub (length x) (length y)) O, eq (bs2nat (cons (hd false (skipn (Init.Nat.sub (length x) (S (length z))) x)) (RoseS_spec x y z))) O
+++++
intros.
-----
Lemma RoseS_spec2_false : forall x y z, length z <= length x - length y -> bs2nat (RoseS_spec x y z) = 0.
Proof.
induction z.
simpl.
intros.
case_eq (length x - length y).
intros.

*****
H0 : eq (Init.Nat.sub (length x) (length y)) O
H : le (S (length z)) (Init.Nat.sub (length x) (length y))
IHz : forall _ : le (length z) (Init.Nat.sub (length x) (length y)),\neq (bs2nat (RoseS_spec x y z)) O
z : list bool
a : bool
x,y : list bool
*****
eq (bs2nat (cons (hd false (skipn (Init.Nat.sub (length x) (S (length z))) x)) (RoseS_spec x y z))) O
+++++
rewrite H0 in H.
-----
Lemma RoseS_spec2_false : forall x y z, length z <= length x - length y -> bs2nat (RoseS_spec x y z) = 0.
Proof.
induction z.
simpl.
intros.
case_eq (length x - length y).
intros.
rewrite H0 in H.

*****
H0 : eq (Init.Nat.sub (length x) (length y)) O
H : le (S (length z)) O
IHz : forall _ : le (length z) (Init.Nat.sub (length x) (length y)),\neq (bs2nat (RoseS_spec x y z)) O
z : list bool
a : bool
x,y : list bool
*****
eq (bs2nat (cons (hd false (skipn (Init.Nat.sub (length x) (S (length z))) x)) (RoseS_spec x y z))) O
+++++
elimtype False.
-----
Lemma RoseS_spec2_false : forall x y z, length z <= length x - length y -> bs2nat (RoseS_spec x y z) = 0.
Proof.
induction z.
simpl.
intros.
case_eq (length x - length y).
intros.
rewrite H0 in H.
elimtype False.

*****
H0 : eq (Init.Nat.sub (length x) (length y)) O
H : le (S (length z)) O
IHz : forall _ : le (length z) (Init.Nat.sub (length x) (length y)),\neq (bs2nat (RoseS_spec x y z)) O
z : list bool
a : bool
x,y : list bool
*****
False
+++++
omega.
-----
Lemma RoseS_spec2_false : forall x y z, length z <= length x - length y -> bs2nat (RoseS_spec x y z) = 0.
Proof.
induction z.
simpl.
intros.
case_eq (length x - length y).

*****
H : le (S (length z)) (Init.Nat.sub (length x) (length y))
IHz : forall _ : le (length z) (Init.Nat.sub (length x) (length y)),\neq (bs2nat (RoseS_spec x y z)) O
z : list bool
a : bool
x,y : list bool
*****
forall (n : nat) (_ : eq (Init.Nat.sub (length x) (length y)) (S n)), eq (bs2nat (if Nat.leb (length z) n then cons false (RoseS_spec x y z) else cons (hd false (skipn (Init.Nat.sub (length x) (S (length z))) x)) (RoseS_spec x y z))) O
+++++
intros.
-----
Lemma RoseS_spec2_false : forall x y z, length z <= length x - length y -> bs2nat (RoseS_spec x y z) = 0.
Proof.
induction z.
simpl.
intros.
case_eq (length x - length y).
intros.

*****
H0 : eq (Init.Nat.sub (length x) (length y)) (S n)
n : nat
H : le (S (length z)) (Init.Nat.sub (length x) (length y))
IHz : forall _ : le (length z) (Init.Nat.sub (length x) (length y)),\neq (bs2nat (RoseS_spec x y z)) O
z : list bool
a : bool
x,y : list bool
*****
eq (bs2nat (if Nat.leb (length z) n then cons false (RoseS_spec x y z) else cons (hd false (skipn (Init.Nat.sub (length x) (S (length z))) x)) (RoseS_spec x y z))) O
+++++
case_eq (leb (length z) n).
-----
Lemma RoseS_spec2_false : forall x y z, length z <= length x - length y -> bs2nat (RoseS_spec x y z) = 0.
Proof.
induction z.
simpl.
intros.
case_eq (length x - length y).
intros.
case_eq (leb (length z) n).

*****
H0 : eq (Init.Nat.sub (length x) (length y)) (S n)
n : nat
H : le (S (length z)) (Init.Nat.sub (length x) (length y))
IHz : forall _ : le (length z) (Init.Nat.sub (length x) (length y)),\neq (bs2nat (RoseS_spec x y z)) O
z : list bool
a : bool
x,y : list bool
*****
forall _ : eq (Nat.leb (length z) n) true, eq (bs2nat (cons false (RoseS_spec x y z))) O
+++++
intros.
-----
Lemma RoseS_spec2_false : forall x y z, length z <= length x - length y -> bs2nat (RoseS_spec x y z) = 0.
Proof.
induction z.
simpl.
intros.
case_eq (length x - length y).
intros.
case_eq (leb (length z) n).
intros.

*****
H1 : eq (Nat.leb (length z) n) true
H0 : eq (Init.Nat.sub (length x) (length y)) (S n)
n : nat
H : le (S (length z)) (Init.Nat.sub (length x) (length y))
IHz : forall _ : le (length z) (Init.Nat.sub (length x) (length y)),\neq (bs2nat (RoseS_spec x y z)) O
z : list bool
a : bool
x,y : list bool
*****
eq (bs2nat (cons false (RoseS_spec x y z))) O
+++++
apply leb_complete in H1.
-----
Lemma RoseS_spec2_false : forall x y z, length z <= length x - length y -> bs2nat (RoseS_spec x y z) = 0.
Proof.
induction z.
simpl.
intros.
case_eq (length x - length y).
intros.
case_eq (leb (length z) n).
intros.
apply leb_complete in H1.

*****
H1 : le (length z) n
H0 : eq (Init.Nat.sub (length x) (length y)) (S n)
n : nat
H : le (S (length z)) (Init.Nat.sub (length x) (length y))
IHz : forall _ : le (length z) (Init.Nat.sub (length x) (length y)),\neq (bs2nat (RoseS_spec x y z)) O
z : list bool
a : bool
x,y : list bool
*****
eq (bs2nat (cons false (RoseS_spec x y z))) O
+++++
rewrite bs2nat_false.
-----
Lemma RoseS_spec2_false : forall x y z, length z <= length x - length y -> bs2nat (RoseS_spec x y z) = 0.
Proof.
induction z.
simpl.
intros.
case_eq (length x - length y).
intros.
case_eq (leb (length z) n).
intros.
apply leb_complete in H1.
rewrite bs2nat_false.

*****
H1 : le (length z) n
H0 : eq (Init.Nat.sub (length x) (length y)) (S n)
n : nat
H : le (S (length z)) (Init.Nat.sub (length x) (length y))
IHz : forall _ : le (length z) (Init.Nat.sub (length x) (length y)),\neq (bs2nat (RoseS_spec x y z)) O
z : list bool
a : bool
x,y : list bool
*****
eq (Init.Nat.mul (S (S O)) (bs2nat (RoseS_spec x y z))) O
+++++
rewrite IHz.
-----
Lemma RoseS_spec2_false : forall x y z, length z <= length x - length y -> bs2nat (RoseS_spec x y z) = 0.
Proof.
induction z.
simpl.
intros.
case_eq (length x - length y).
intros.
case_eq (leb (length z) n).
intros.
apply leb_complete in H1.
rewrite bs2nat_false.
rewrite IHz.

*****
H1 : le (length z) n
H0 : eq (Init.Nat.sub (length x) (length y)) (S n)
n : nat
H : le (S (length z)) (Init.Nat.sub (length x) (length y))
IHz : forall _ : le (length z) (Init.Nat.sub (length x) (length y)),\neq (bs2nat (RoseS_spec x y z)) O
z : list bool
a : bool
x,y : list bool
*****
eq (Init.Nat.mul (S (S O)) O) O
+++++
auto.
-----
Lemma RoseS_spec2_false : forall x y z, length z <= length x - length y -> bs2nat (RoseS_spec x y z) = 0.
Proof.
induction z.
simpl.
intros.
case_eq (length x - length y).
intros.
case_eq (leb (length z) n).
intros.
apply leb_complete in H1.
rewrite bs2nat_false.
rewrite IHz.

*****
H1 : le (length z) n
H0 : eq (Init.Nat.sub (length x) (length y)) (S n)
n : nat
H : le (S (length z)) (Init.Nat.sub (length x) (length y))
IHz : forall _ : le (length z) (Init.Nat.sub (length x) (length y)),\neq (bs2nat (RoseS_spec x y z)) O
z : list bool
a : bool
x,y : list bool
*****
le (length z) (Init.Nat.sub (length x) (length y))
+++++
auto.
-----
Lemma RoseS_spec2_false : forall x y z, length z <= length x - length y -> bs2nat (RoseS_spec x y z) = 0.
Proof.
induction z.
simpl.
intros.
case_eq (length x - length y).
intros.
case_eq (leb (length z) n).
intros.
apply leb_complete in H1.
rewrite bs2nat_false.
rewrite IHz.
auto.

*****
H1 : le (length z) n
H0 : eq (Init.Nat.sub (length x) (length y)) (S n)
n : nat
H : le (S (length z)) (Init.Nat.sub (length x) (length y))
IHz : forall _ : le (length z) (Init.Nat.sub (length x) (length y)),\neq (bs2nat (RoseS_spec x y z)) O
z : list bool
a : bool
x,y : list bool
*****
le (length z) (Init.Nat.sub (length x) (length y))
+++++
omega.
-----
Lemma RoseS_spec2_false : forall x y z, length z <= length x - length y -> bs2nat (RoseS_spec x y z) = 0.
Proof.
induction z.
simpl.
intros.
case_eq (length x - length y).
intros.
case_eq (leb (length z) n).

*****
H0 : eq (Init.Nat.sub (length x) (length y)) (S n)
n : nat
H : le (S (length z)) (Init.Nat.sub (length x) (length y))
IHz : forall _ : le (length z) (Init.Nat.sub (length x) (length y)),\neq (bs2nat (RoseS_spec x y z)) O
z : list bool
a : bool
x,y : list bool
*****
forall _ : eq (Nat.leb (length z) n) false, eq (bs2nat (cons (hd false (skipn (Init.Nat.sub (length x) (S (length z))) x)) (RoseS_spec x y z))) O
+++++
intros.
-----
Lemma RoseS_spec2_false : forall x y z, length z <= length x - length y -> bs2nat (RoseS_spec x y z) = 0.
Proof.
induction z.
simpl.
intros.
case_eq (length x - length y).
intros.
case_eq (leb (length z) n).
intros.

*****
H1 : eq (Nat.leb (length z) n) false
H0 : eq (Init.Nat.sub (length x) (length y)) (S n)
n : nat
H : le (S (length z)) (Init.Nat.sub (length x) (length y))
IHz : forall _ : le (length z) (Init.Nat.sub (length x) (length y)),\neq (bs2nat (RoseS_spec x y z)) O
z : list bool
a : bool
x,y : list bool
*****
eq (bs2nat (cons (hd false (skipn (Init.Nat.sub (length x) (S (length z))) x)) (RoseS_spec x y z))) O
+++++
apply leb_complete_conv in H1.
-----
Lemma RoseS_spec2_false : forall x y z, length z <= length x - length y -> bs2nat (RoseS_spec x y z) = 0.
Proof.
induction z.
simpl.
intros.
case_eq (length x - length y).
intros.
case_eq (leb (length z) n).
intros.
apply leb_complete_conv in H1.

*****
H1 : lt n (length z)
H0 : eq (Init.Nat.sub (length x) (length y)) (S n)
n : nat
H : le (S (length z)) (Init.Nat.sub (length x) (length y))
IHz : forall _ : le (length z) (Init.Nat.sub (length x) (length y)),\neq (bs2nat (RoseS_spec x y z)) O
z : list bool
a : bool
x,y : list bool
*****
eq (bs2nat (cons (hd false (skipn (Init.Nat.sub (length x) (S (length z))) x)) (RoseS_spec x y z))) O
+++++
elimtype False.
-----
Lemma RoseS_spec2_false : forall x y z, length z <= length x - length y -> bs2nat (RoseS_spec x y z) = 0.
Proof.
induction z.
simpl.
intros.
case_eq (length x - length y).
intros.
case_eq (leb (length z) n).
intros.
apply leb_complete_conv in H1.
elimtype False.

*****
H1 : lt n (length z)
H0 : eq (Init.Nat.sub (length x) (length y)) (S n)
n : nat
H : le (S (length z)) (Init.Nat.sub (length x) (length y))
IHz : forall _ : le (length z) (Init.Nat.sub (length x) (length y)),\neq (bs2nat (RoseS_spec x y z)) O
z : list bool
a : bool
x,y : list bool
*****
False
+++++
omega.
-----
Lemma RoseS_spec2_false : forall x y z, length z <= length x - length y -> bs2nat (RoseS_spec x y z) = 0.
Proof.
induction z.

*****

*****

+++++
Qed.
-----
Lemma skipn_roseS : forall x y z,\n  bs2nat (skipn (length z) (RoseS_spec x y z)) = 0.
-----
Lemma skipn_roseS : forall x y z, bs2nat (skipn (length z) (RoseS_spec x y z)) = 0.

*****

*****
forall x y z : list bool, eq (bs2nat (skipn (length z) (RoseS_spec x y z))) O
+++++
Proof.
-----
Lemma skipn_roseS : forall x y z, bs2nat (skipn (length z) (RoseS_spec x y z)) = 0.
Proof.

*****

*****
forall x y z : list bool, eq (bs2nat (skipn (length z) (RoseS_spec x y z))) O
+++++
induction z.
-----
Lemma skipn_roseS : forall x y z, bs2nat (skipn (length z) (RoseS_spec x y z)) = 0.
Proof.
induction z.

*****
x,y : list bool
*****
eq (bs2nat (skipn (length nil) (RoseS_spec x y nil))) O
+++++
simpl.
-----
Lemma skipn_roseS : forall x y z, bs2nat (skipn (length z) (RoseS_spec x y z)) = 0.
Proof.
induction z.
simpl.

*****
x,y : list bool
*****
eq (bs2nat nil) O
+++++
rewrite bs2nat_nil.
-----
Lemma skipn_roseS : forall x y z, bs2nat (skipn (length z) (RoseS_spec x y z)) = 0.
Proof.
induction z.
simpl.
rewrite bs2nat_nil.

*****
x,y : list bool
*****
eq O O
+++++
auto.
-----
Lemma skipn_roseS : forall x y z, bs2nat (skipn (length z) (RoseS_spec x y z)) = 0.
Proof.
induction z.

*****
IHz : eq (bs2nat (skipn (length z) (RoseS_spec x y z))) O
z : list bool
a : bool
x,y : list bool
*****
eq (bs2nat (skipn (length (cons a z)) (RoseS_spec x y (cons a z)))) O
+++++
simpl.
-----
Lemma skipn_roseS : forall x y z, bs2nat (skipn (length z) (RoseS_spec x y z)) = 0.
Proof.
induction z.
simpl.

*****
IHz : eq (bs2nat (skipn (length z) (RoseS_spec x y z))) O
z : list bool
a : bool
x,y : list bool
*****
eq (bs2nat match (if match Init.Nat.sub (length x) (length y) with | O => false | S m' => Nat.leb (length z) m' end then cons false (RoseS_spec x y z) else cons (hd false (skipn (Init.Nat.sub (length x) (S (length z))) x)) (RoseS_spec x y z)) with | nil => nil | cons _ l => skipn (length z) l end) O
+++++
case_eq (length x - length y).
-----
Lemma skipn_roseS : forall x y z, bs2nat (skipn (length z) (RoseS_spec x y z)) = 0.
Proof.
induction z.
simpl.
case_eq (length x - length y).

*****
IHz : eq (bs2nat (skipn (length z) (RoseS_spec x y z))) O
z : list bool
a : bool
x,y : list bool
*****
forall _ : eq (Init.Nat.sub (length x) (length y)) O, eq (bs2nat (skipn (length z) (RoseS_spec x y z))) O
+++++
intros.
-----
Lemma skipn_roseS : forall x y z, bs2nat (skipn (length z) (RoseS_spec x y z)) = 0.
Proof.
induction z.
simpl.
case_eq (length x - length y).
intros.

*****
H : eq (Init.Nat.sub (length x) (length y)) O
IHz : eq (bs2nat (skipn (length z) (RoseS_spec x y z))) O
z : list bool
a : bool
x,y : list bool
*****
eq (bs2nat (skipn (length z) (RoseS_spec x y z))) O
+++++
auto.
-----
Lemma skipn_roseS : forall x y z, bs2nat (skipn (length z) (RoseS_spec x y z)) = 0.
Proof.
induction z.
simpl.
case_eq (length x - length y).

*****
IHz : eq (bs2nat (skipn (length z) (RoseS_spec x y z))) O
z : list bool
a : bool
x,y : list bool
*****
forall (n : nat) (_ : eq (Init.Nat.sub (length x) (length y)) (S n)), eq (bs2nat match (if Nat.leb (length z) n then cons false (RoseS_spec x y z) else cons (hd false (skipn (Init.Nat.sub (length x) (S (length z))) x)) (RoseS_spec x y z)) with | nil => nil | cons _ l => skipn (length z) l end) O
+++++
intros.
-----
Lemma skipn_roseS : forall x y z, bs2nat (skipn (length z) (RoseS_spec x y z)) = 0.
Proof.
induction z.
simpl.
case_eq (length x - length y).
intros.

*****
H : eq (Init.Nat.sub (length x) (length y)) (S n)
n : nat
IHz : eq (bs2nat (skipn (length z) (RoseS_spec x y z))) O
z : list bool
a : bool
x,y : list bool
*****
eq (bs2nat match (if Nat.leb (length z) n then cons false (RoseS_spec x y z) else cons (hd false (skipn (Init.Nat.sub (length x) (S (length z))) x)) (RoseS_spec x y z)) with | nil => nil | cons _ l => skipn (length z) l end) O
+++++
auto.
-----
Lemma skipn_roseS : forall x y z, bs2nat (skipn (length z) (RoseS_spec x y z)) = 0.
Proof.
induction z.
simpl.
case_eq (length x - length y).
intros.
auto.

*****
H : eq (Init.Nat.sub (length x) (length y)) (S n)
n : nat
IHz : eq (bs2nat (skipn (length z) (RoseS_spec x y z))) O
z : list bool
a : bool
x,y : list bool
*****
eq (bs2nat match (if Nat.leb (length z) n then cons false (RoseS_spec x y z) else cons (hd false (skipn (Init.Nat.sub (length x) (S (length z))) x)) (RoseS_spec x y z)) with | nil => nil | cons _ l => skipn (length z) l end) O
+++++
case_eq (leb (length z) n).
-----
Lemma skipn_roseS : forall x y z, bs2nat (skipn (length z) (RoseS_spec x y z)) = 0.
Proof.
induction z.
simpl.
case_eq (length x - length y).
intros.
auto.
case_eq (leb (length z) n).

*****
H : eq (Init.Nat.sub (length x) (length y)) (S n)
n : nat
IHz : eq (bs2nat (skipn (length z) (RoseS_spec x y z))) O
z : list bool
a : bool
x,y : list bool
*****
forall _ : eq (Nat.leb (length z) n) true, eq (bs2nat (skipn (length z) (RoseS_spec x y z))) O
+++++
intros.
-----
Lemma skipn_roseS : forall x y z, bs2nat (skipn (length z) (RoseS_spec x y z)) = 0.
Proof.
induction z.
simpl.
case_eq (length x - length y).
intros.
auto.
case_eq (leb (length z) n).
intros.

*****
H0 : eq (Nat.leb (length z) n) true
H : eq (Init.Nat.sub (length x) (length y)) (S n)
n : nat
IHz : eq (bs2nat (skipn (length z) (RoseS_spec x y z))) O
z : list bool
a : bool
x,y : list bool
*****
eq (bs2nat (skipn (length z) (RoseS_spec x y z))) O
+++++
auto.
-----
Lemma skipn_roseS : forall x y z, bs2nat (skipn (length z) (RoseS_spec x y z)) = 0.
Proof.
induction z.
simpl.
case_eq (length x - length y).
intros.
auto.
case_eq (leb (length z) n).

*****
H : eq (Init.Nat.sub (length x) (length y)) (S n)
n : nat
IHz : eq (bs2nat (skipn (length z) (RoseS_spec x y z))) O
z : list bool
a : bool
x,y : list bool
*****
forall _ : eq (Nat.leb (length z) n) false, eq (bs2nat (skipn (length z) (RoseS_spec x y z))) O
+++++
intros.
-----
Lemma skipn_roseS : forall x y z, bs2nat (skipn (length z) (RoseS_spec x y z)) = 0.
Proof.
induction z.
simpl.
case_eq (length x - length y).
intros.
auto.
case_eq (leb (length z) n).
intros.

*****
H0 : eq (Nat.leb (length z) n) false
H : eq (Init.Nat.sub (length x) (length y)) (S n)
n : nat
IHz : eq (bs2nat (skipn (length z) (RoseS_spec x y z))) O
z : list bool
a : bool
x,y : list bool
*****
eq (bs2nat (skipn (length z) (RoseS_spec x y z))) O
+++++
auto.
-----
Lemma skipn_roseS : forall x y z, bs2nat (skipn (length z) (RoseS_spec x y z)) = 0.
Proof.
induction z.

*****

*****

+++++
Qed.
-----
Lemma RoseS_cons : forall x y z b1 b2,\n  length z <= length x ->\n  RoseS_spec (b1 :: x) (b2 :: y) z = RoseS_spec x y z.
-----
Lemma RoseS_cons : forall x y z b1 b2, length z <= length x -> RoseS_spec (b1 :: x) (b2 :: y) z = RoseS_spec x y z.

*****

*****
forall (x y z : list bool) (b1 b2 : bool) (_ : le (length z) (length x)), eq (RoseS_spec (cons b1 x) (cons b2 y) z) (RoseS_spec x y z)
+++++
Proof.
-----
Lemma RoseS_cons : forall x y z b1 b2, length z <= length x -> RoseS_spec (b1 :: x) (b2 :: y) z = RoseS_spec x y z.
Proof.

*****

*****
forall (x y z : list bool) (b1 b2 : bool) (_ : le (length z) (length x)), eq (RoseS_spec (cons b1 x) (cons b2 y) z) (RoseS_spec x y z)
+++++
induction z.
-----
Lemma RoseS_cons : forall x y z b1 b2, length z <= length x -> RoseS_spec (b1 :: x) (b2 :: y) z = RoseS_spec x y z.
Proof.
induction z.

*****
x,y : list bool
*****
forall (b1 b2 : bool) (_ : le (length nil) (length x)), eq (RoseS_spec (cons b1 x) (cons b2 y) nil) (RoseS_spec x y nil)
+++++
simpl.
-----
Lemma RoseS_cons : forall x y z b1 b2, length z <= length x -> RoseS_spec (b1 :: x) (b2 :: y) z = RoseS_spec x y z.
Proof.
induction z.
simpl.

*****
x,y : list bool
*****
forall (_ : bool) (_ : bool) (_ : le O (length x)), eq nil nil
+++++
trivial.
-----
Lemma RoseS_cons : forall x y z b1 b2, length z <= length x -> RoseS_spec (b1 :: x) (b2 :: y) z = RoseS_spec x y z.
Proof.
induction z.

*****
IHz : forall (b1 b2 : bool) (_ : le (length z) (length x)),\neq (RoseS_spec (cons b1 x) (cons b2 y) z) (RoseS_spec x y z)
z : list bool
a : bool
x,y : list bool
*****
forall (b1 b2 : bool) (_ : le (length (cons a z)) (length x)), eq (RoseS_spec (cons b1 x) (cons b2 y) (cons a z)) (RoseS_spec x y (cons a z))
+++++
simpl.
-----
Lemma RoseS_cons : forall x y z b1 b2, length z <= length x -> RoseS_spec (b1 :: x) (b2 :: y) z = RoseS_spec x y z.
Proof.
induction z.
simpl.

*****
IHz : forall (b1 b2 : bool) (_ : le (length z) (length x)),\neq (RoseS_spec (cons b1 x) (cons b2 y) z) (RoseS_spec x y z)
z : list bool
a : bool
x,y : list bool
*****
forall (b1 b2 : bool) (_ : le (S (length z)) (length x)), eq (if match Init.Nat.sub (length x) (length y) with | O => false | S m' => Nat.leb (length z) m' end then cons false (RoseS_spec (cons b1 x) (cons b2 y) z) else cons (hd false (skipn (Init.Nat.sub (length x) (length z)) (cons b1 x))) (RoseS_spec (cons b1 x) (cons b2 y) z)) (if match Init.Nat.sub (length x) (length y) with | O => false | S m' => Nat.leb (length z) m' end then cons false (RoseS_spec x y z) else cons (hd false (skipn (Init.Nat.sub (length x) (S (length z))) x)) (RoseS_spec x y z))
+++++
trivial.
-----
Lemma RoseS_cons : forall x y z b1 b2, length z <= length x -> RoseS_spec (b1 :: x) (b2 :: y) z = RoseS_spec x y z.
Proof.
induction z.
simpl.
trivial.

*****
IHz : forall (b1 b2 : bool) (_ : le (length z) (length x)),\neq (RoseS_spec (cons b1 x) (cons b2 y) z) (RoseS_spec x y z)
z : list bool
a : bool
x,y : list bool
*****
forall (b1 b2 : bool) (_ : le (S (length z)) (length x)), eq (if match Init.Nat.sub (length x) (length y) with | O => false | S m' => Nat.leb (length z) m' end then cons false (RoseS_spec (cons b1 x) (cons b2 y) z) else cons (hd false (skipn (Init.Nat.sub (length x) (length z)) (cons b1 x))) (RoseS_spec (cons b1 x) (cons b2 y) z)) (if match Init.Nat.sub (length x) (length y) with | O => false | S m' => Nat.leb (length z) m' end then cons false (RoseS_spec x y z) else cons (hd false (skipn (Init.Nat.sub (length x) (S (length z))) x)) (RoseS_spec x y z))
+++++
intros.
-----
Lemma RoseS_cons : forall x y z b1 b2, length z <= length x -> RoseS_spec (b1 :: x) (b2 :: y) z = RoseS_spec x y z.
Proof.
induction z.
simpl.
trivial.
intros.

*****
H : le (S (length z)) (length x)
b1,b2 : bool
IHz : forall (b1 b2 : bool) (_ : le (length z) (length x)),\neq (RoseS_spec (cons b1 x) (cons b2 y) z) (RoseS_spec x y z)
z : list bool
a : bool
x,y : list bool
*****
eq (if match Init.Nat.sub (length x) (length y) with | O => false | S m' => Nat.leb (length z) m' end then cons false (RoseS_spec (cons b1 x) (cons b2 y) z) else cons (hd false (skipn (Init.Nat.sub (length x) (length z)) (cons b1 x))) (RoseS_spec (cons b1 x) (cons b2 y) z)) (if match Init.Nat.sub (length x) (length y) with | O => false | S m' => Nat.leb (length z) m' end then cons false (RoseS_spec x y z) else cons (hd false (skipn (Init.Nat.sub (length x) (S (length z))) x)) (RoseS_spec x y z))
+++++
case_eq (length x - length y).
-----
Lemma RoseS_cons : forall x y z b1 b2, length z <= length x -> RoseS_spec (b1 :: x) (b2 :: y) z = RoseS_spec x y z.
Proof.
induction z.
simpl.
trivial.
intros.
case_eq (length x - length y).

*****
H : le (S (length z)) (length x)
b1,b2 : bool
IHz : forall (b1 b2 : bool) (_ : le (length z) (length x)),\neq (RoseS_spec (cons b1 x) (cons b2 y) z) (RoseS_spec x y z)
z : list bool
a : bool
x,y : list bool
*****
forall _ : eq (Init.Nat.sub (length x) (length y)) O, eq (cons (hd false (skipn (Init.Nat.sub (length x) (length z)) (cons b1 x))) (RoseS_spec (cons b1 x) (cons b2 y) z)) (cons (hd false (skipn (Init.Nat.sub (length x) (S (length z))) x)) (RoseS_spec x y z))
+++++
intros.
-----
Lemma RoseS_cons : forall x y z b1 b2, length z <= length x -> RoseS_spec (b1 :: x) (b2 :: y) z = RoseS_spec x y z.
Proof.
induction z.
simpl.
trivial.
intros.
case_eq (length x - length y).
intros.

*****
H0 : eq (Init.Nat.sub (length x) (length y)) O
H : le (S (length z)) (length x)
b1,b2 : bool
IHz : forall (b1 b2 : bool) (_ : le (length z) (length x)),\neq (RoseS_spec (cons b1 x) (cons b2 y) z) (RoseS_spec x y z)
z : list bool
a : bool
x,y : list bool
*****
eq (cons (hd false (skipn (Init.Nat.sub (length x) (length z)) (cons b1 x))) (RoseS_spec (cons b1 x) (cons b2 y) z)) (cons (hd false (skipn (Init.Nat.sub (length x) (S (length z))) x)) (RoseS_spec x y z))
+++++
rewrite IHz.
-----
Lemma RoseS_cons : forall x y z b1 b2, length z <= length x -> RoseS_spec (b1 :: x) (b2 :: y) z = RoseS_spec x y z.
Proof.
induction z.
simpl.
trivial.
intros.
case_eq (length x - length y).
intros.
rewrite IHz.

*****
H0 : eq (Init.Nat.sub (length x) (length y)) O
H : le (S (length z)) (length x)
b1,b2 : bool
IHz : forall (b1 b2 : bool) (_ : le (length z) (length x)),\neq (RoseS_spec (cons b1 x) (cons b2 y) z) (RoseS_spec x y z)
z : list bool
a : bool
x,y : list bool
*****
eq (cons (hd false (skipn (Init.Nat.sub (length x) (length z)) (cons b1 x))) (RoseS_spec x y z)) (cons (hd false (skipn (Init.Nat.sub (length x) (S (length z))) x)) (RoseS_spec x y z))
+++++
idtac.
-----
Lemma RoseS_cons : forall x y z b1 b2, length z <= length x -> RoseS_spec (b1 :: x) (b2 :: y) z = RoseS_spec x y z.
Proof.
induction z.
simpl.
trivial.
intros.
case_eq (length x - length y).
intros.
rewrite IHz.
idtac.

*****
H0 : eq (Init.Nat.sub (length x) (length y)) O
H : le (S (length z)) (length x)
b1,b2 : bool
IHz : forall (b1 b2 : bool) (_ : le (length z) (length x)),\neq (RoseS_spec (cons b1 x) (cons b2 y) z) (RoseS_spec x y z)
z : list bool
a : bool
x,y : list bool
*****
eq (cons (hd false (skipn (Init.Nat.sub (length x) (length z)) (cons b1 x))) (RoseS_spec x y z)) (cons (hd false (skipn (Init.Nat.sub (length x) (S (length z))) x)) (RoseS_spec x y z))
+++++
clear IHz.
-----
Lemma RoseS_cons : forall x y z b1 b2, length z <= length x -> RoseS_spec (b1 :: x) (b2 :: y) z = RoseS_spec x y z.
Proof.
induction z.
simpl.
trivial.
intros.
case_eq (length x - length y).
intros.
rewrite IHz.
idtac.
clear IHz.

*****
H0 : eq (Init.Nat.sub (length x) (length y)) O
H : le (S (length z)) (length x)
b1,b2 : bool
z : list bool
a : bool
x,y : list bool
*****
eq (cons (hd false (skipn (Init.Nat.sub (length x) (length z)) (cons b1 x))) (RoseS_spec x y z)) (cons (hd false (skipn (Init.Nat.sub (length x) (S (length z))) x)) (RoseS_spec x y z))
+++++
f_equal.
-----
Lemma RoseS_cons : forall x y z b1 b2, length z <= length x -> RoseS_spec (b1 :: x) (b2 :: y) z = RoseS_spec x y z.
Proof.
induction z.
simpl.
trivial.
intros.
case_eq (length x - length y).
intros.
rewrite IHz.
idtac.
clear IHz.
f_equal.

*****
H0 : eq (Init.Nat.sub (length x) (length y)) O
H : le (S (length z)) (length x)
b1,b2 : bool
z : list bool
a : bool
x,y : list bool
*****
eq (hd false (skipn (Init.Nat.sub (length x) (length z)) (cons b1 x))) (hd false (skipn (Init.Nat.sub (length x) (S (length z))) x))
+++++
destruct x.
-----
Lemma RoseS_cons : forall x y z b1 b2, length z <= length x -> RoseS_spec (b1 :: x) (b2 :: y) z = RoseS_spec x y z.
Proof.
induction z.
simpl.
trivial.
intros.
case_eq (length x - length y).
intros.
rewrite IHz.
idtac.
clear IHz.
f_equal.
destruct x.

*****
H0 : eq (Init.Nat.sub (length nil) (length y)) O
H : le (S (length z)) (length nil)
b1,b2 : bool
z : list bool
a : bool
y : list bool
*****
eq (hd false (skipn (Init.Nat.sub (length nil) (length z)) (cons b1 nil))) (hd false (skipn (Init.Nat.sub (length nil) (S (length z))) nil))
+++++
simpl in *.
-----
Lemma RoseS_cons : forall x y z b1 b2, length z <= length x -> RoseS_spec (b1 :: x) (b2 :: y) z = RoseS_spec x y z.
Proof.
induction z.
simpl.
trivial.
intros.
case_eq (length x - length y).
intros.
rewrite IHz.
idtac.
clear IHz.
f_equal.
destruct x.
simpl in *.

*****
H0 : eq O O
H : le (S (length z)) O
b1,b2 : bool
z : list bool
a : bool
y : list bool
*****
eq b1 false
+++++
elimtype False.
-----
Lemma RoseS_cons : forall x y z b1 b2, length z <= length x -> RoseS_spec (b1 :: x) (b2 :: y) z = RoseS_spec x y z.
Proof.
induction z.
simpl.
trivial.
intros.
case_eq (length x - length y).
intros.
rewrite IHz.
idtac.
clear IHz.
f_equal.
destruct x.
simpl in *.
elimtype False.

*****
H0 : eq O O
H : le (S (length z)) O
b1,b2 : bool
z : list bool
a : bool
y : list bool
*****
False
+++++
omega.
-----
Lemma RoseS_cons : forall x y z b1 b2, length z <= length x -> RoseS_spec (b1 :: x) (b2 :: y) z = RoseS_spec x y z.
Proof.
induction z.
simpl.
trivial.
intros.
case_eq (length x - length y).
intros.
rewrite IHz.
idtac.
clear IHz.
f_equal.
destruct x.

*****
H0 : eq (Init.Nat.sub (length (cons b x)) (length y)) O
H : le (S (length z)) (length (cons b x))
b1,b2 : bool
z : list bool
a : bool
x,y : list bool
b : bool
*****
eq (hd false (skipn (Init.Nat.sub (length (cons b x)) (length z)) (cons b1 (cons b x)))) (hd false (skipn (Init.Nat.sub (length (cons b x)) (S (length z))) (cons b x)))
+++++
simpl in *.
-----
Lemma RoseS_cons : forall x y z b1 b2, length z <= length x -> RoseS_spec (b1 :: x) (b2 :: y) z = RoseS_spec x y z.
Proof.
induction z.
simpl.
trivial.
intros.
case_eq (length x - length y).
intros.
rewrite IHz.
idtac.
clear IHz.
f_equal.
destruct x.
simpl in *.

*****
H0 : eq\n match length y with\n | O => S (length x)\n | S l => Init.Nat.sub (length x) l\n end O
H : le (S (length z)) (S (length x))
b1,b2 : bool
z : list bool
a : bool
x,y : list bool
b : bool
*****
eq (hd false (skipn match length z with | O => S (length x) | S l => Init.Nat.sub (length x) l end (cons b1 (cons b x)))) (hd false (skipn (Init.Nat.sub (length x) (length z)) (cons b x)))
+++++
destruct y.
-----
Lemma RoseS_cons : forall x y z b1 b2, length z <= length x -> RoseS_spec (b1 :: x) (b2 :: y) z = RoseS_spec x y z.
Proof.
induction z.
simpl.
trivial.
intros.
case_eq (length x - length y).
intros.
rewrite IHz.
idtac.
clear IHz.
f_equal.
destruct x.
simpl in *.
destruct y.

*****
H0 : eq\n match length nil with\n | O => S (length x)\n | S l => Init.Nat.sub (length x) l\n end O
H : le (S (length z)) (S (length x))
b1,b2 : bool
z : list bool
a : bool
x : list bool
b : bool
*****
eq (hd false (skipn match length z with | O => S (length x) | S l => Init.Nat.sub (length x) l end (cons b1 (cons b x)))) (hd false (skipn (Init.Nat.sub (length x) (length z)) (cons b x)))
+++++
simpl in *.
-----
Lemma RoseS_cons : forall x y z b1 b2, length z <= length x -> RoseS_spec (b1 :: x) (b2 :: y) z = RoseS_spec x y z.
Proof.
induction z.
simpl.
trivial.
intros.
case_eq (length x - length y).
intros.
rewrite IHz.
idtac.
clear IHz.
f_equal.
destruct x.
simpl in *.
destruct y.
simpl in *.

*****
H0 : eq (S (length x)) O
H : le (S (length z)) (S (length x))
b1,b2 : bool
z : list bool
a : bool
x : list bool
b : bool
*****
eq (hd false (skipn match length z with | O => S (length x) | S l => Init.Nat.sub (length x) l end (cons b1 (cons b x)))) (hd false (skipn (Init.Nat.sub (length x) (length z)) (cons b x)))
+++++
discriminate.
-----
Lemma RoseS_cons : forall x y z b1 b2, length z <= length x -> RoseS_spec (b1 :: x) (b2 :: y) z = RoseS_spec x y z.
Proof.
induction z.
simpl.
trivial.
intros.
case_eq (length x - length y).
intros.
rewrite IHz.
idtac.
clear IHz.
f_equal.
destruct x.
simpl in *.
destruct y.

*****
H0 : eq\n match length (cons b0 y) with\n | O => S (length x)\n | S l => Init.Nat.sub (length x) l\n end O
H : le (S (length z)) (S (length x))
b1,b2 : bool
z : list bool
a : bool
y : list bool
b0 : bool
x : list bool
b : bool
*****
eq (hd false (skipn match length z with | O => S (length x) | S l => Init.Nat.sub (length x) l end (cons b1 (cons b x)))) (hd false (skipn (Init.Nat.sub (length x) (length z)) (cons b x)))
+++++
simpl in *.
-----
Lemma RoseS_cons : forall x y z b1 b2, length z <= length x -> RoseS_spec (b1 :: x) (b2 :: y) z = RoseS_spec x y z.
Proof.
induction z.
simpl.
trivial.
intros.
case_eq (length x - length y).
intros.
rewrite IHz.
idtac.
clear IHz.
f_equal.
destruct x.
simpl in *.
destruct y.
simpl in *.

*****
H0 : eq (Init.Nat.sub (length x) (length y)) O
H : le (S (length z)) (S (length x))
b1,b2 : bool
z : list bool
a : bool
y : list bool
b0 : bool
x : list bool
b : bool
*****
eq (hd false (skipn match length z with | O => S (length x) | S l => Init.Nat.sub (length x) l end (cons b1 (cons b x)))) (hd false (skipn (Init.Nat.sub (length x) (length z)) (cons b x)))
+++++
destruct z.
-----
Lemma RoseS_cons : forall x y z b1 b2, length z <= length x -> RoseS_spec (b1 :: x) (b2 :: y) z = RoseS_spec x y z.
Proof.
induction z.
simpl.
trivial.
intros.
case_eq (length x - length y).
intros.
rewrite IHz.
idtac.
clear IHz.
f_equal.
destruct x.
simpl in *.
destruct y.
simpl in *.
destruct z.

*****
H0 : eq (Init.Nat.sub (length x) (length y)) O
H : le (S (length nil)) (S (length x))
a,b1,b2 : bool
y : list bool
b0 : bool
x : list bool
b : bool
*****
eq (hd false (skipn match length nil with | O => S (length x) | S l => Init.Nat.sub (length x) l end (cons b1 (cons b x)))) (hd false (skipn (Init.Nat.sub (length x) (length nil)) (cons b x)))
+++++
simpl.
-----
Lemma RoseS_cons : forall x y z b1 b2, length z <= length x -> RoseS_spec (b1 :: x) (b2 :: y) z = RoseS_spec x y z.
Proof.
induction z.
simpl.
trivial.
intros.
case_eq (length x - length y).
intros.
rewrite IHz.
idtac.
clear IHz.
f_equal.
destruct x.
simpl in *.
destruct y.
simpl in *.
destruct z.
simpl.

*****
H0 : eq (Init.Nat.sub (length x) (length y)) O
H : le (S (length nil)) (S (length x))
a,b1,b2 : bool
y : list bool
b0 : bool
x : list bool
b : bool
*****
eq (hd false (skipn (length x) (cons b x))) (hd false (skipn (Init.Nat.sub (length x) O) (cons b x)))
+++++
rewrite <- minus_n_O.
-----
Lemma RoseS_cons : forall x y z b1 b2, length z <= length x -> RoseS_spec (b1 :: x) (b2 :: y) z = RoseS_spec x y z.
Proof.
induction z.
simpl.
trivial.
intros.
case_eq (length x - length y).
intros.
rewrite IHz.
idtac.
clear IHz.
f_equal.
destruct x.
simpl in *.
destruct y.
simpl in *.
destruct z.
simpl.
rewrite <- minus_n_O.

*****
H0 : eq (Init.Nat.sub (length x) (length y)) O
H : le (S (length nil)) (S (length x))
a,b1,b2 : bool
y : list bool
b0 : bool
x : list bool
b : bool
*****
eq (hd false (skipn (length x) (cons b x))) (hd false (skipn (length x) (cons b x)))
+++++
trivial.
-----
Lemma RoseS_cons : forall x y z b1 b2, length z <= length x -> RoseS_spec (b1 :: x) (b2 :: y) z = RoseS_spec x y z.
Proof.
induction z.
simpl.
trivial.
intros.
case_eq (length x - length y).
intros.
rewrite IHz.
idtac.
clear IHz.
f_equal.
destruct x.
simpl in *.
destruct y.
simpl in *.
destruct z.

*****
H0 : eq (Init.Nat.sub (length x) (length y)) O
H : le (S (length (cons b3 z))) (S (length x))
b1,b2 : bool
z : list bool
a,b3 : bool
y : list bool
b0 : bool
x : list bool
b : bool
*****
eq (hd false (skipn match length (cons b3 z) with | O => S (length x) | S l => Init.Nat.sub (length x) l end (cons b1 (cons b x)))) (hd false (skipn (Init.Nat.sub (length x) (length (cons b3 z))) (cons b x)))
+++++
simpl.
-----
Lemma RoseS_cons : forall x y z b1 b2, length z <= length x -> RoseS_spec (b1 :: x) (b2 :: y) z = RoseS_spec x y z.
Proof.
induction z.
simpl.
trivial.
intros.
case_eq (length x - length y).
intros.
rewrite IHz.
idtac.
clear IHz.
f_equal.
destruct x.
simpl in *.
destruct y.
simpl in *.
destruct z.
simpl.

*****
H0 : eq (Init.Nat.sub (length x) (length y)) O
H : le (S (length (cons b3 z))) (S (length x))
b1,b2 : bool
z : list bool
a,b3 : bool
y : list bool
b0 : bool
x : list bool
b : bool
*****
eq (hd false (skipn (Init.Nat.sub (length x) (length z)) (cons b1 (cons b x)))) (hd false (skipn (Init.Nat.sub (length x) (S (length z))) (cons b x)))
+++++
simpl in *.
-----
Lemma RoseS_cons : forall x y z b1 b2, length z <= length x -> RoseS_spec (b1 :: x) (b2 :: y) z = RoseS_spec x y z.
Proof.
induction z.
simpl.
trivial.
intros.
case_eq (length x - length y).
intros.
rewrite IHz.
idtac.
clear IHz.
f_equal.
destruct x.
simpl in *.
destruct y.
simpl in *.
destruct z.
simpl.
simpl in *.

*****
H0 : eq (Init.Nat.sub (length x) (length y)) O
H : le (S (S (length z))) (S (length x))
b1,b2 : bool
z : list bool
a,b3 : bool
y : list bool
b0 : bool
x : list bool
b : bool
*****
eq (hd false (skipn (Init.Nat.sub (length x) (length z)) (cons b1 (cons b x)))) (hd false (skipn (Init.Nat.sub (length x) (S (length z))) (cons b x)))
+++++
cutrewrite (length x - length z = S (length x - S (length z))).
-----
Lemma RoseS_cons : forall x y z b1 b2, length z <= length x -> RoseS_spec (b1 :: x) (b2 :: y) z = RoseS_spec x y z.
Proof.
induction z.
simpl.
trivial.
intros.
case_eq (length x - length y).
intros.
rewrite IHz.
idtac.
clear IHz.
f_equal.
destruct x.
simpl in *.
destruct y.
simpl in *.
destruct z.
simpl.
simpl in *.
cutrewrite (length x - length z = S (length x - S (length z))).

*****
H0 : eq (Init.Nat.sub (length x) (length y)) O
H : le (S (S (length z))) (S (length x))
b1,b2 : bool
z : list bool
a,b3 : bool
y : list bool
b0 : bool
x : list bool
b : bool
*****
eq (hd false (skipn (S (Init.Nat.sub (length x) (S (length z)))) (cons b1 (cons b x)))) (hd false (skipn (Init.Nat.sub (length x) (S (length z))) (cons b x)))
+++++
simpl.
-----
Lemma RoseS_cons : forall x y z b1 b2, length z <= length x -> RoseS_spec (b1 :: x) (b2 :: y) z = RoseS_spec x y z.
Proof.
induction z.
simpl.
trivial.
intros.
case_eq (length x - length y).
intros.
rewrite IHz.
idtac.
clear IHz.
f_equal.
destruct x.
simpl in *.
destruct y.
simpl in *.
destruct z.
simpl.
simpl in *.
cutrewrite (length x - length z = S (length x - S (length z))).
simpl.

*****
H0 : eq (Init.Nat.sub (length x) (length y)) O
H : le (S (S (length z))) (S (length x))
b1,b2 : bool
z : list bool
a,b3 : bool
y : list bool
b0 : bool
x : list bool
b : bool
*****
eq (hd false (skipn (Init.Nat.sub (length x) (S (length z))) (cons b x))) (hd false (skipn (Init.Nat.sub (length x) (S (length z))) (cons b x)))
+++++
trivial.
-----
Lemma RoseS_cons : forall x y z b1 b2, length z <= length x -> RoseS_spec (b1 :: x) (b2 :: y) z = RoseS_spec x y z.
Proof.
induction z.
simpl.
trivial.
intros.
case_eq (length x - length y).
intros.
rewrite IHz.
idtac.
clear IHz.
f_equal.
destruct x.
simpl in *.
destruct y.
simpl in *.
destruct z.
simpl.
simpl in *.
cutrewrite (length x - length z = S (length x - S (length z))).

*****
H0 : eq (Init.Nat.sub (length x) (length y)) O
H : le (S (S (length z))) (S (length x))
b1,b2 : bool
z : list bool
a,b3 : bool
y : list bool
b0 : bool
x : list bool
b : bool
*****
eq (Init.Nat.sub (length x) (length z)) (S (Init.Nat.sub (length x) (S (length z))))
+++++
omega.
-----
Lemma RoseS_cons : forall x y z b1 b2, length z <= length x -> RoseS_spec (b1 :: x) (b2 :: y) z = RoseS_spec x y z.
Proof.
induction z.
simpl.
trivial.
intros.
case_eq (length x - length y).
intros.
rewrite IHz.

*****
H0 : eq (Init.Nat.sub (length x) (length y)) O
H : le (S (length z)) (length x)
b1,b2 : bool
IHz : forall (b1 b2 : bool) (_ : le (length z) (length x)),\neq (RoseS_spec (cons b1 x) (cons b2 y) z) (RoseS_spec x y z)
z : list bool
a : bool
x,y : list bool
*****
le (length z) (length x)
+++++
omega.
-----
Lemma RoseS_cons : forall x y z b1 b2, length z <= length x -> RoseS_spec (b1 :: x) (b2 :: y) z = RoseS_spec x y z.
Proof.
induction z.
simpl.
trivial.
intros.
case_eq (length x - length y).

*****
H : le (S (length z)) (length x)
b1,b2 : bool
IHz : forall (b1 b2 : bool) (_ : le (length z) (length x)),\neq (RoseS_spec (cons b1 x) (cons b2 y) z) (RoseS_spec x y z)
z : list bool
a : bool
x,y : list bool
*****
forall (n : nat) (_ : eq (Init.Nat.sub (length x) (length y)) (S n)), eq (if Nat.leb (length z) n then cons false (RoseS_spec (cons b1 x) (cons b2 y) z) else cons (hd false (skipn (Init.Nat.sub (length x) (length z)) (cons b1 x))) (RoseS_spec (cons b1 x) (cons b2 y) z)) (if Nat.leb (length z) n then cons false (RoseS_spec x y z) else cons (hd false (skipn (Init.Nat.sub (length x) (S (length z))) x)) (RoseS_spec x y z))
+++++
intros.
-----
Lemma RoseS_cons : forall x y z b1 b2, length z <= length x -> RoseS_spec (b1 :: x) (b2 :: y) z = RoseS_spec x y z.
Proof.
induction z.
simpl.
trivial.
intros.
case_eq (length x - length y).
intros.

*****
H0 : eq (Init.Nat.sub (length x) (length y)) (S n)
n : nat
H : le (S (length z)) (length x)
b1,b2 : bool
IHz : forall (b1 b2 : bool) (_ : le (length z) (length x)),\neq (RoseS_spec (cons b1 x) (cons b2 y) z) (RoseS_spec x y z)
z : list bool
a : bool
x,y : list bool
*****
eq (if Nat.leb (length z) n then cons false (RoseS_spec (cons b1 x) (cons b2 y) z) else cons (hd false (skipn (Init.Nat.sub (length x) (length z)) (cons b1 x))) (RoseS_spec (cons b1 x) (cons b2 y) z)) (if Nat.leb (length z) n then cons false (RoseS_spec x y z) else cons (hd false (skipn (Init.Nat.sub (length x) (S (length z))) x)) (RoseS_spec x y z))
+++++
case_eq (leb (length z) n).
-----
Lemma RoseS_cons : forall x y z b1 b2, length z <= length x -> RoseS_spec (b1 :: x) (b2 :: y) z = RoseS_spec x y z.
Proof.
induction z.
simpl.
trivial.
intros.
case_eq (length x - length y).
intros.
case_eq (leb (length z) n).

*****
H0 : eq (Init.Nat.sub (length x) (length y)) (S n)
n : nat
H : le (S (length z)) (length x)
b1,b2 : bool
IHz : forall (b1 b2 : bool) (_ : le (length z) (length x)),\neq (RoseS_spec (cons b1 x) (cons b2 y) z) (RoseS_spec x y z)
z : list bool
a : bool
x,y : list bool
*****
forall _ : eq (Nat.leb (length z) n) true, eq (cons false (RoseS_spec (cons b1 x) (cons b2 y) z)) (cons false (RoseS_spec x y z))
+++++
intros.
-----
Lemma RoseS_cons : forall x y z b1 b2, length z <= length x -> RoseS_spec (b1 :: x) (b2 :: y) z = RoseS_spec x y z.
Proof.
induction z.
simpl.
trivial.
intros.
case_eq (length x - length y).
intros.
case_eq (leb (length z) n).
intros.

*****
H1 : eq (Nat.leb (length z) n) true
H0 : eq (Init.Nat.sub (length x) (length y)) (S n)
n : nat
H : le (S (length z)) (length x)
b1,b2 : bool
IHz : forall (b1 b2 : bool) (_ : le (length z) (length x)),\neq (RoseS_spec (cons b1 x) (cons b2 y) z) (RoseS_spec x y z)
z : list bool
a : bool
x,y : list bool
*****
eq (cons false (RoseS_spec (cons b1 x) (cons b2 y) z)) (cons false (RoseS_spec x y z))
+++++
rewrite IHz.
-----
Lemma RoseS_cons : forall x y z b1 b2, length z <= length x -> RoseS_spec (b1 :: x) (b2 :: y) z = RoseS_spec x y z.
Proof.
induction z.
simpl.
trivial.
intros.
case_eq (length x - length y).
intros.
case_eq (leb (length z) n).
intros.
rewrite IHz.

*****
H1 : eq (Nat.leb (length z) n) true
H0 : eq (Init.Nat.sub (length x) (length y)) (S n)
n : nat
H : le (S (length z)) (length x)
b1,b2 : bool
IHz : forall (b1 b2 : bool) (_ : le (length z) (length x)),\neq (RoseS_spec (cons b1 x) (cons b2 y) z) (RoseS_spec x y z)
z : list bool
a : bool
x,y : list bool
*****
eq (cons false (RoseS_spec x y z)) (cons false (RoseS_spec x y z))
+++++
auto.
-----
Lemma RoseS_cons : forall x y z b1 b2, length z <= length x -> RoseS_spec (b1 :: x) (b2 :: y) z = RoseS_spec x y z.
Proof.
induction z.
simpl.
trivial.
intros.
case_eq (length x - length y).
intros.
case_eq (leb (length z) n).
intros.
rewrite IHz.

*****
H1 : eq (Nat.leb (length z) n) true
H0 : eq (Init.Nat.sub (length x) (length y)) (S n)
n : nat
H : le (S (length z)) (length x)
b1,b2 : bool
IHz : forall (b1 b2 : bool) (_ : le (length z) (length x)),\neq (RoseS_spec (cons b1 x) (cons b2 y) z) (RoseS_spec x y z)
z : list bool
a : bool
x,y : list bool
*****
le (length z) (length x)
+++++
auto.
-----
Lemma RoseS_cons : forall x y z b1 b2, length z <= length x -> RoseS_spec (b1 :: x) (b2 :: y) z = RoseS_spec x y z.
Proof.
induction z.
simpl.
trivial.
intros.
case_eq (length x - length y).
intros.
case_eq (leb (length z) n).
intros.
rewrite IHz.
auto.

*****
H1 : eq (Nat.leb (length z) n) true
H0 : eq (Init.Nat.sub (length x) (length y)) (S n)
n : nat
H : le (S (length z)) (length x)
b1,b2 : bool
IHz : forall (b1 b2 : bool) (_ : le (length z) (length x)),\neq (RoseS_spec (cons b1 x) (cons b2 y) z) (RoseS_spec x y z)
z : list bool
a : bool
x,y : list bool
*****
le (length z) (length x)
+++++
omega.
-----
Lemma RoseS_cons : forall x y z b1 b2, length z <= length x -> RoseS_spec (b1 :: x) (b2 :: y) z = RoseS_spec x y z.
Proof.
induction z.
simpl.
trivial.
intros.
case_eq (length x - length y).
intros.
case_eq (leb (length z) n).

*****
H0 : eq (Init.Nat.sub (length x) (length y)) (S n)
n : nat
H : le (S (length z)) (length x)
b1,b2 : bool
IHz : forall (b1 b2 : bool) (_ : le (length z) (length x)),\neq (RoseS_spec (cons b1 x) (cons b2 y) z) (RoseS_spec x y z)
z : list bool
a : bool
x,y : list bool
*****
forall _ : eq (Nat.leb (length z) n) false, eq (cons (hd false (skipn (Init.Nat.sub (length x) (length z)) (cons b1 x))) (RoseS_spec (cons b1 x) (cons b2 y) z)) (cons (hd false (skipn (Init.Nat.sub (length x) (S (length z))) x)) (RoseS_spec x y z))
+++++
intros.
-----
Lemma RoseS_cons : forall x y z b1 b2, length z <= length x -> RoseS_spec (b1 :: x) (b2 :: y) z = RoseS_spec x y z.
Proof.
induction z.
simpl.
trivial.
intros.
case_eq (length x - length y).
intros.
case_eq (leb (length z) n).
intros.

*****
H1 : eq (Nat.leb (length z) n) false
H0 : eq (Init.Nat.sub (length x) (length y)) (S n)
n : nat
H : le (S (length z)) (length x)
b1,b2 : bool
IHz : forall (b1 b2 : bool) (_ : le (length z) (length x)),\neq (RoseS_spec (cons b1 x) (cons b2 y) z) (RoseS_spec x y z)
z : list bool
a : bool
x,y : list bool
*****
eq (cons (hd false (skipn (Init.Nat.sub (length x) (length z)) (cons b1 x))) (RoseS_spec (cons b1 x) (cons b2 y) z)) (cons (hd false (skipn (Init.Nat.sub (length x) (S (length z))) x)) (RoseS_spec x y z))
+++++
rewrite IHz.
-----
Lemma RoseS_cons : forall x y z b1 b2, length z <= length x -> RoseS_spec (b1 :: x) (b2 :: y) z = RoseS_spec x y z.
Proof.
induction z.
simpl.
trivial.
intros.
case_eq (length x - length y).
intros.
case_eq (leb (length z) n).
intros.
rewrite IHz.

*****
H1 : eq (Nat.leb (length z) n) false
H0 : eq (Init.Nat.sub (length x) (length y)) (S n)
n : nat
H : le (S (length z)) (length x)
b1,b2 : bool
IHz : forall (b1 b2 : bool) (_ : le (length z) (length x)),\neq (RoseS_spec (cons b1 x) (cons b2 y) z) (RoseS_spec x y z)
z : list bool
a : bool
x,y : list bool
*****
eq (cons (hd false (skipn (Init.Nat.sub (length x) (length z)) (cons b1 x))) (RoseS_spec x y z)) (cons (hd false (skipn (Init.Nat.sub (length x) (S (length z))) x)) (RoseS_spec x y z))
+++++
f_equal.
-----
Lemma RoseS_cons : forall x y z b1 b2, length z <= length x -> RoseS_spec (b1 :: x) (b2 :: y) z = RoseS_spec x y z.
Proof.
induction z.
simpl.
trivial.
intros.
case_eq (length x - length y).
intros.
case_eq (leb (length z) n).
intros.
rewrite IHz.
f_equal.

*****
H1 : eq (Nat.leb (length z) n) false
H0 : eq (Init.Nat.sub (length x) (length y)) (S n)
n : nat
H : le (S (length z)) (length x)
b1,b2 : bool
IHz : forall (b1 b2 : bool) (_ : le (length z) (length x)),\neq (RoseS_spec (cons b1 x) (cons b2 y) z) (RoseS_spec x y z)
z : list bool
a : bool
x,y : list bool
*****
eq (hd false (skipn (Init.Nat.sub (length x) (length z)) (cons b1 x))) (hd false (skipn (Init.Nat.sub (length x) (S (length z))) x))
+++++
apply leb_complete_conv in H1.
-----
Lemma RoseS_cons : forall x y z b1 b2, length z <= length x -> RoseS_spec (b1 :: x) (b2 :: y) z = RoseS_spec x y z.
Proof.
induction z.
simpl.
trivial.
intros.
case_eq (length x - length y).
intros.
case_eq (leb (length z) n).
intros.
rewrite IHz.
f_equal.
apply leb_complete_conv in H1.

*****
H1 : lt n (length z)
H0 : eq (Init.Nat.sub (length x) (length y)) (S n)
n : nat
H : le (S (length z)) (length x)
b1,b2 : bool
IHz : forall (b1 b2 : bool) (_ : le (length z) (length x)),\neq (RoseS_spec (cons b1 x) (cons b2 y) z) (RoseS_spec x y z)
z : list bool
a : bool
x,y : list bool
*****
eq (hd false (skipn (Init.Nat.sub (length x) (length z)) (cons b1 x))) (hd false (skipn (Init.Nat.sub (length x) (S (length z))) x))
+++++
destruct x.
-----
Lemma RoseS_cons : forall x y z b1 b2, length z <= length x -> RoseS_spec (b1 :: x) (b2 :: y) z = RoseS_spec x y z.
Proof.
induction z.
simpl.
trivial.
intros.
case_eq (length x - length y).
intros.
case_eq (leb (length z) n).
intros.
rewrite IHz.
f_equal.
apply leb_complete_conv in H1.
destruct x.

*****
H1 : lt n (length z)
H0 : eq (Init.Nat.sub (length nil) (length y)) (S n)
n : nat
H : le (S (length z)) (length nil)
b1,b2 : bool
IHz : forall (b1 b2 : bool) (_ : le (length z) (length nil)),\neq (RoseS_spec (cons b1 nil) (cons b2 y) z) (RoseS_spec nil y z)
z : list bool
a : bool
y : list bool
*****
eq (hd false (skipn (Init.Nat.sub (length nil) (length z)) (cons b1 nil))) (hd false (skipn (Init.Nat.sub (length nil) (S (length z))) nil))
+++++
simpl in *.
-----
Lemma RoseS_cons : forall x y z b1 b2, length z <= length x -> RoseS_spec (b1 :: x) (b2 :: y) z = RoseS_spec x y z.
Proof.
induction z.
simpl.
trivial.
intros.
case_eq (length x - length y).
intros.
case_eq (leb (length z) n).
intros.
rewrite IHz.
f_equal.
apply leb_complete_conv in H1.
destruct x.
simpl in *.

*****
H1 : lt n (length z)
H0 : eq O (S n)
n : nat
H : le (S (length z)) O
b1,b2 : bool
IHz : forall (b1 b2 : bool) (_ : le (length z) O),\neq (RoseS_spec (cons b1 nil) (cons b2 y) z) (RoseS_spec nil y z)
z : list bool
a : bool
y : list bool
*****
eq b1 false
+++++
discriminate.
-----
Lemma RoseS_cons : forall x y z b1 b2, length z <= length x -> RoseS_spec (b1 :: x) (b2 :: y) z = RoseS_spec x y z.
Proof.
induction z.
simpl.
trivial.
intros.
case_eq (length x - length y).
intros.
case_eq (leb (length z) n).
intros.
rewrite IHz.
f_equal.
apply leb_complete_conv in H1.
destruct x.

*****
H1 : lt n (length z)
H0 : eq (Init.Nat.sub (length (cons b x)) (length y)) (S n)
n : nat
H : le (S (length z)) (length (cons b x))
b1,b2 : bool
IHz : forall (b1 b2 : bool) (_ : le (length z) (length (cons b x))),\neq (RoseS_spec (cons b1 (cons b x)) (cons b2 y) z)\n (RoseS_spec (cons b x) y z)
z : list bool
a : bool
x,y : list bool
b : bool
*****
eq (hd false (skipn (Init.Nat.sub (length (cons b x)) (length z)) (cons b1 (cons b x)))) (hd false (skipn (Init.Nat.sub (length (cons b x)) (S (length z))) (cons b x)))
+++++
simpl in *.
-----
Lemma RoseS_cons : forall x y z b1 b2, length z <= length x -> RoseS_spec (b1 :: x) (b2 :: y) z = RoseS_spec x y z.
Proof.
induction z.
simpl.
trivial.
intros.
case_eq (length x - length y).
intros.
case_eq (leb (length z) n).
intros.
rewrite IHz.
f_equal.
apply leb_complete_conv in H1.
destruct x.
simpl in *.

*****
H1 : lt n (length z)
H0 : eq\n match length y with\n | O => S (length x)\n | S l => Init.Nat.sub (length x) l\n end (S n)
n : nat
H : le (S (length z)) (S (length x))
b1,b2 : bool
IHz : forall (b1 b2 : bool) (_ : le (length z) (S (length x))),\neq (RoseS_spec (cons b1 (cons b x)) (cons b2 y) z)\n (RoseS_spec (cons b x) y z)
z : list bool
a : bool
x,y : list bool
b : bool
*****
eq (hd false (skipn match length z with | O => S (length x) | S l => Init.Nat.sub (length x) l end (cons b1 (cons b x)))) (hd false (skipn (Init.Nat.sub (length x) (length z)) (cons b x)))
+++++
destruct y.
-----
Lemma RoseS_cons : forall x y z b1 b2, length z <= length x -> RoseS_spec (b1 :: x) (b2 :: y) z = RoseS_spec x y z.
Proof.
induction z.
simpl.
trivial.
intros.
case_eq (length x - length y).
intros.
case_eq (leb (length z) n).
intros.
rewrite IHz.
f_equal.
apply leb_complete_conv in H1.
destruct x.
simpl in *.
destruct y.

*****
H1 : lt n (length z)
H0 : eq\n match length nil with\n | O => S (length x)\n | S l => Init.Nat.sub (length x) l\n end (S n)
n : nat
H : le (S (length z)) (S (length x))
b1,b2 : bool
IHz : forall (b1 b2 : bool) (_ : le (length z) (S (length x))),\neq (RoseS_spec (cons b1 (cons b x)) (cons b2 nil) z)\n (RoseS_spec (cons b x) nil z)
z : list bool
a : bool
x : list bool
b : bool
*****
eq (hd false (skipn match length z with | O => S (length x) | S l => Init.Nat.sub (length x) l end (cons b1 (cons b x)))) (hd false (skipn (Init.Nat.sub (length x) (length z)) (cons b x)))
+++++
simpl in *.
-----
Lemma RoseS_cons : forall x y z b1 b2, length z <= length x -> RoseS_spec (b1 :: x) (b2 :: y) z = RoseS_spec x y z.
Proof.
induction z.
simpl.
trivial.
intros.
case_eq (length x - length y).
intros.
case_eq (leb (length z) n).
intros.
rewrite IHz.
f_equal.
apply leb_complete_conv in H1.
destruct x.
simpl in *.
destruct y.
simpl in *.

*****
H1 : lt n (length z)
H0 : eq (S (length x)) (S n)
n : nat
H : le (S (length z)) (S (length x))
b1,b2 : bool
IHz : forall (b1 b2 : bool) (_ : le (length z) (S (length x))),\neq (RoseS_spec (cons b1 (cons b x)) (cons b2 nil) z)\n (RoseS_spec (cons b x) nil z)
z : list bool
a : bool
x : list bool
b : bool
*****
eq (hd false (skipn match length z with | O => S (length x) | S l => Init.Nat.sub (length x) l end (cons b1 (cons b x)))) (hd false (skipn (Init.Nat.sub (length x) (length z)) (cons b x)))
+++++
elimtype False.
-----
Lemma RoseS_cons : forall x y z b1 b2, length z <= length x -> RoseS_spec (b1 :: x) (b2 :: y) z = RoseS_spec x y z.
Proof.
induction z.
simpl.
trivial.
intros.
case_eq (length x - length y).
intros.
case_eq (leb (length z) n).
intros.
rewrite IHz.
f_equal.
apply leb_complete_conv in H1.
destruct x.
simpl in *.
destruct y.
simpl in *.
elimtype False.

*****
H1 : lt n (length z)
H0 : eq (S (length x)) (S n)
n : nat
H : le (S (length z)) (S (length x))
b1,b2 : bool
IHz : forall (b1 b2 : bool) (_ : le (length z) (S (length x))),\neq (RoseS_spec (cons b1 (cons b x)) (cons b2 nil) z)\n (RoseS_spec (cons b x) nil z)
z : list bool
a : bool
x : list bool
b : bool
*****
False
+++++
omega.
-----
Lemma RoseS_cons : forall x y z b1 b2, length z <= length x -> RoseS_spec (b1 :: x) (b2 :: y) z = RoseS_spec x y z.
Proof.
induction z.
simpl.
trivial.
intros.
case_eq (length x - length y).
intros.
case_eq (leb (length z) n).
intros.
rewrite IHz.
f_equal.
apply leb_complete_conv in H1.
destruct x.
simpl in *.
destruct y.

*****
H1 : lt n (length z)
H0 : eq\n match length (cons b0 y) with\n | O => S (length x)\n | S l => Init.Nat.sub (length x) l\n end (S n)
n : nat
H : le (S (length z)) (S (length x))
b1,b2 : bool
IHz : forall (b1 b2 : bool) (_ : le (length z) (S (length x))),\neq (RoseS_spec (cons b1 (cons b x)) (cons b2 (cons b0 y)) z)\n (RoseS_spec (cons b x) (cons b0 y) z)
z : list bool
a : bool
y : list bool
b0 : bool
x : list bool
b : bool
*****
eq (hd false (skipn match length z with | O => S (length x) | S l => Init.Nat.sub (length x) l end (cons b1 (cons b x)))) (hd false (skipn (Init.Nat.sub (length x) (length z)) (cons b x)))
+++++
simpl in *.
-----
Lemma RoseS_cons : forall x y z b1 b2, length z <= length x -> RoseS_spec (b1 :: x) (b2 :: y) z = RoseS_spec x y z.
Proof.
induction z.
simpl.
trivial.
intros.
case_eq (length x - length y).
intros.
case_eq (leb (length z) n).
intros.
rewrite IHz.
f_equal.
apply leb_complete_conv in H1.
destruct x.
simpl in *.
destruct y.
simpl in *.

*****
H1 : lt n (length z)
H0 : eq (Init.Nat.sub (length x) (length y)) (S n)
n : nat
H : le (S (length z)) (S (length x))
b1,b2 : bool
IHz : forall (b1 b2 : bool) (_ : le (length z) (S (length x))),\neq (RoseS_spec (cons b1 (cons b x)) (cons b2 (cons b0 y)) z)\n (RoseS_spec (cons b x) (cons b0 y) z)
z : list bool
a : bool
y : list bool
b0 : bool
x : list bool
b : bool
*****
eq (hd false (skipn match length z with | O => S (length x) | S l => Init.Nat.sub (length x) l end (cons b1 (cons b x)))) (hd false (skipn (Init.Nat.sub (length x) (length z)) (cons b x)))
+++++
destruct z.
-----
Lemma RoseS_cons : forall x y z b1 b2, length z <= length x -> RoseS_spec (b1 :: x) (b2 :: y) z = RoseS_spec x y z.
Proof.
induction z.
simpl.
trivial.
intros.
case_eq (length x - length y).
intros.
case_eq (leb (length z) n).
intros.
rewrite IHz.
f_equal.
apply leb_complete_conv in H1.
destruct x.
simpl in *.
destruct y.
simpl in *.
destruct z.

*****
H1 : lt n (length nil)
H0 : eq (Init.Nat.sub (length x) (length y)) (S n)
n : nat
H : le (S (length nil)) (S (length x))
b1,b2 : bool
IHz : forall (b1 b2 : bool) (_ : le (length nil) (S (length x))),\neq (RoseS_spec (cons b1 (cons b x)) (cons b2 (cons b0 y)) nil)\n (RoseS_spec (cons b x) (cons b0 y) nil)
a : bool
y : list bool
b0 : bool
x : list bool
b : bool
*****
eq (hd false (skipn match length nil with | O => S (length x) | S l => Init.Nat.sub (length x) l end (cons b1 (cons b x)))) (hd false (skipn (Init.Nat.sub (length x) (length nil)) (cons b x)))
+++++
simpl.
-----
Lemma RoseS_cons : forall x y z b1 b2, length z <= length x -> RoseS_spec (b1 :: x) (b2 :: y) z = RoseS_spec x y z.
Proof.
induction z.
simpl.
trivial.
intros.
case_eq (length x - length y).
intros.
case_eq (leb (length z) n).
intros.
rewrite IHz.
f_equal.
apply leb_complete_conv in H1.
destruct x.
simpl in *.
destruct y.
simpl in *.
destruct z.
simpl.

*****
H1 : lt n (length nil)
H0 : eq (Init.Nat.sub (length x) (length y)) (S n)
n : nat
H : le (S (length nil)) (S (length x))
b1,b2 : bool
IHz : forall (b1 b2 : bool) (_ : le (length nil) (S (length x))),\neq (RoseS_spec (cons b1 (cons b x)) (cons b2 (cons b0 y)) nil)\n (RoseS_spec (cons b x) (cons b0 y) nil)
a : bool
y : list bool
b0 : bool
x : list bool
b : bool
*****
eq (hd false (skipn (length x) (cons b x))) (hd false (skipn (Init.Nat.sub (length x) O) (cons b x)))
+++++
rewrite <- minus_n_O.
-----
Lemma RoseS_cons : forall x y z b1 b2, length z <= length x -> RoseS_spec (b1 :: x) (b2 :: y) z = RoseS_spec x y z.
Proof.
induction z.
simpl.
trivial.
intros.
case_eq (length x - length y).
intros.
case_eq (leb (length z) n).
intros.
rewrite IHz.
f_equal.
apply leb_complete_conv in H1.
destruct x.
simpl in *.
destruct y.
simpl in *.
destruct z.
simpl.
rewrite <- minus_n_O.

*****
H1 : lt n (length nil)
H0 : eq (Init.Nat.sub (length x) (length y)) (S n)
n : nat
H : le (S (length nil)) (S (length x))
b1,b2 : bool
IHz : forall (b1 b2 : bool) (_ : le (length nil) (S (length x))),\neq (RoseS_spec (cons b1 (cons b x)) (cons b2 (cons b0 y)) nil)\n (RoseS_spec (cons b x) (cons b0 y) nil)
a : bool
y : list bool
b0 : bool
x : list bool
b : bool
*****
eq (hd false (skipn (length x) (cons b x))) (hd false (skipn (length x) (cons b x)))
+++++
trivial.
-----
Lemma RoseS_cons : forall x y z b1 b2, length z <= length x -> RoseS_spec (b1 :: x) (b2 :: y) z = RoseS_spec x y z.
Proof.
induction z.
simpl.
trivial.
intros.
case_eq (length x - length y).
intros.
case_eq (leb (length z) n).
intros.
rewrite IHz.
f_equal.
apply leb_complete_conv in H1.
destruct x.
simpl in *.
destruct y.
simpl in *.
destruct z.

*****
H1 : lt n (length (cons b3 z))
H0 : eq (Init.Nat.sub (length x) (length y)) (S n)
n : nat
H : le (S (length (cons b3 z))) (S (length x))
b1,b2 : bool
IHz : forall (b1 b2 : bool) (_ : le (length (cons b3 z)) (S (length x))),\neq (RoseS_spec (cons b1 (cons b x)) (cons b2 (cons b0 y)) (cons b3 z))\n (RoseS_spec (cons b x) (cons b0 y) (cons b3 z))
z : list bool
a,b3 : bool
y : list bool
b0 : bool
x : list bool
b : bool
*****
eq (hd false (skipn match length (cons b3 z) with | O => S (length x) | S l => Init.Nat.sub (length x) l end (cons b1 (cons b x)))) (hd false (skipn (Init.Nat.sub (length x) (length (cons b3 z))) (cons b x)))
+++++
simpl.
-----
Lemma RoseS_cons : forall x y z b1 b2, length z <= length x -> RoseS_spec (b1 :: x) (b2 :: y) z = RoseS_spec x y z.
Proof.
induction z.
simpl.
trivial.
intros.
case_eq (length x - length y).
intros.
case_eq (leb (length z) n).
intros.
rewrite IHz.
f_equal.
apply leb_complete_conv in H1.
destruct x.
simpl in *.
destruct y.
simpl in *.
destruct z.
simpl.

*****
H1 : lt n (length (cons b3 z))
H0 : eq (Init.Nat.sub (length x) (length y)) (S n)
n : nat
H : le (S (length (cons b3 z))) (S (length x))
b1,b2 : bool
IHz : forall (b1 b2 : bool) (_ : le (length (cons b3 z)) (S (length x))),\neq (RoseS_spec (cons b1 (cons b x)) (cons b2 (cons b0 y)) (cons b3 z))\n (RoseS_spec (cons b x) (cons b0 y) (cons b3 z))
z : list bool
a,b3 : bool
y : list bool
b0 : bool
x : list bool
b : bool
*****
eq (hd false (skipn (Init.Nat.sub (length x) (length z)) (cons b1 (cons b x)))) (hd false (skipn (Init.Nat.sub (length x) (S (length z))) (cons b x)))
+++++
cutrewrite (length x - length z = S (length x - S (length z))).
-----
Lemma RoseS_cons : forall x y z b1 b2, length z <= length x -> RoseS_spec (b1 :: x) (b2 :: y) z = RoseS_spec x y z.
Proof.
induction z.
simpl.
trivial.
intros.
case_eq (length x - length y).
intros.
case_eq (leb (length z) n).
intros.
rewrite IHz.
f_equal.
apply leb_complete_conv in H1.
destruct x.
simpl in *.
destruct y.
simpl in *.
destruct z.
simpl.
cutrewrite (length x - length z = S (length x - S (length z))).

*****
H1 : lt n (length (cons b3 z))
H0 : eq (Init.Nat.sub (length x) (length y)) (S n)
n : nat
H : le (S (length (cons b3 z))) (S (length x))
b1,b2 : bool
IHz : forall (b1 b2 : bool) (_ : le (length (cons b3 z)) (S (length x))),\neq (RoseS_spec (cons b1 (cons b x)) (cons b2 (cons b0 y)) (cons b3 z))\n (RoseS_spec (cons b x) (cons b0 y) (cons b3 z))
z : list bool
a,b3 : bool
y : list bool
b0 : bool
x : list bool
b : bool
*****
eq (hd false (skipn (S (Init.Nat.sub (length x) (S (length z)))) (cons b1 (cons b x)))) (hd false (skipn (Init.Nat.sub (length x) (S (length z))) (cons b x)))
+++++
simpl.
-----
Lemma RoseS_cons : forall x y z b1 b2, length z <= length x -> RoseS_spec (b1 :: x) (b2 :: y) z = RoseS_spec x y z.
Proof.
induction z.
simpl.
trivial.
intros.
case_eq (length x - length y).
intros.
case_eq (leb (length z) n).
intros.
rewrite IHz.
f_equal.
apply leb_complete_conv in H1.
destruct x.
simpl in *.
destruct y.
simpl in *.
destruct z.
simpl.
cutrewrite (length x - length z = S (length x - S (length z))).
simpl.

*****
H1 : lt n (length (cons b3 z))
H0 : eq (Init.Nat.sub (length x) (length y)) (S n)
n : nat
H : le (S (length (cons b3 z))) (S (length x))
b1,b2 : bool
IHz : forall (b1 b2 : bool) (_ : le (length (cons b3 z)) (S (length x))),\neq (RoseS_spec (cons b1 (cons b x)) (cons b2 (cons b0 y)) (cons b3 z))\n (RoseS_spec (cons b x) (cons b0 y) (cons b3 z))
z : list bool
a,b3 : bool
y : list bool
b0 : bool
x : list bool
b : bool
*****
eq (hd false (skipn (Init.Nat.sub (length x) (S (length z))) (cons b x))) (hd false (skipn (Init.Nat.sub (length x) (S (length z))) (cons b x)))
+++++
trivial.
-----
Lemma RoseS_cons : forall x y z b1 b2, length z <= length x -> RoseS_spec (b1 :: x) (b2 :: y) z = RoseS_spec x y z.
Proof.
induction z.
simpl.
trivial.
intros.
case_eq (length x - length y).
intros.
case_eq (leb (length z) n).
intros.
rewrite IHz.
f_equal.
apply leb_complete_conv in H1.
destruct x.
simpl in *.
destruct y.
simpl in *.
destruct z.
simpl.
cutrewrite (length x - length z = S (length x - S (length z))).

*****
H1 : lt n (length (cons b3 z))
H0 : eq (Init.Nat.sub (length x) (length y)) (S n)
n : nat
H : le (S (length (cons b3 z))) (S (length x))
b1,b2 : bool
IHz : forall (b1 b2 : bool) (_ : le (length (cons b3 z)) (S (length x))),\neq (RoseS_spec (cons b1 (cons b x)) (cons b2 (cons b0 y)) (cons b3 z))\n (RoseS_spec (cons b x) (cons b0 y) (cons b3 z))
z : list bool
a,b3 : bool
y : list bool
b0 : bool
x : list bool
b : bool
*****
eq (Init.Nat.sub (length x) (length z)) (S (Init.Nat.sub (length x) (S (length z))))
+++++
simpl in *.
-----
Lemma RoseS_cons : forall x y z b1 b2, length z <= length x -> RoseS_spec (b1 :: x) (b2 :: y) z = RoseS_spec x y z.
Proof.
induction z.
simpl.
trivial.
intros.
case_eq (length x - length y).
intros.
case_eq (leb (length z) n).
intros.
rewrite IHz.
f_equal.
apply leb_complete_conv in H1.
destruct x.
simpl in *.
destruct y.
simpl in *.
destruct z.
simpl.
cutrewrite (length x - length z = S (length x - S (length z))).
simpl in *.

*****
H1 : lt n (S (length z))
H0 : eq (Init.Nat.sub (length x) (length y)) (S n)
n : nat
H : le (S (S (length z))) (S (length x))
b1,b2 : bool
IHz : forall (b1 b2 : bool) (_ : le (S (length z)) (S (length x))),\neq\n (if\n match Init.Nat.sub (length x) (length y) with\n | O => false\n | S m' => Nat.leb (length z) m'\n end\n then\n cons false\n (RoseS_spec (cons b1 (cons b x)) (cons b2 (cons b0 y)) z)\n else\n cons\n (hd false\n (skipn\n match length z with\n | O => S (length x)\n | S l => Init.Nat.sub (length x) l\n end (cons b1 (cons b x))))\n (RoseS_spec (cons b1 (cons b x)) (cons b2 (cons b0 y)) z))\n (if\n match Init.Nat.sub (length x) (length y) with\n | O => false\n | S m' => Nat.leb (length z) m'\n end\n then cons false (RoseS_spec (cons b x) (cons b0 y) z)\n else\n cons\n (hd false (skipn (Init.Nat.sub (length x) (length z)) (cons b x)))\n (RoseS_spec (cons b x) (cons b0 y) z))
z : list bool
a,b3 : bool
y : list bool
b0 : bool
x : list bool
b : bool
*****
eq (Init.Nat.sub (length x) (length z)) (S (Init.Nat.sub (length x) (S (length z))))
+++++
omega.
-----
Lemma RoseS_cons : forall x y z b1 b2, length z <= length x -> RoseS_spec (b1 :: x) (b2 :: y) z = RoseS_spec x y z.
Proof.
induction z.
simpl.
trivial.
intros.
case_eq (length x - length y).
intros.
case_eq (leb (length z) n).
intros.
rewrite IHz.

*****
H1 : eq (Nat.leb (length z) n) false
H0 : eq (Init.Nat.sub (length x) (length y)) (S n)
n : nat
H : le (S (length z)) (length x)
b1,b2 : bool
IHz : forall (b1 b2 : bool) (_ : le (length z) (length x)),\neq (RoseS_spec (cons b1 x) (cons b2 y) z) (RoseS_spec x y z)
z : list bool
a : bool
x,y : list bool
*****
le (length z) (length x)
+++++
omega.
-----
Lemma RoseS_cons : forall x y z b1 b2, length z <= length x -> RoseS_spec (b1 :: x) (b2 :: y) z = RoseS_spec x y z.
Proof.
induction z.

*****

*****

+++++
Qed.
-----
Lemma bs2nat_cons_eq : forall b l1 l2,\n  bs2nat l1 = bs2nat l2 ->\n  bs2nat (b :: l1) = bs2nat (b :: l2).
-----
Lemma bs2nat_cons_eq : forall b l1 l2, bs2nat l1 = bs2nat l2 -> bs2nat (b :: l1) = bs2nat (b :: l2).

*****

*****
forall (b : bool) (l1 l2 : list bool) (_ : eq (bs2nat l1) (bs2nat l2)), eq (bs2nat (cons b l1)) (bs2nat (cons b l2))
+++++
Proof.
-----
Lemma bs2nat_cons_eq : forall b l1 l2, bs2nat l1 = bs2nat l2 -> bs2nat (b :: l1) = bs2nat (b :: l2).
Proof.

*****

*****
forall (b : bool) (l1 l2 : list bool) (_ : eq (bs2nat l1) (bs2nat l2)), eq (bs2nat (cons b l1)) (bs2nat (cons b l2))
+++++
intros.
-----
Lemma bs2nat_cons_eq : forall b l1 l2, bs2nat l1 = bs2nat l2 -> bs2nat (b :: l1) = bs2nat (b :: l2).
Proof.
intros.

*****
H : eq (bs2nat l1) (bs2nat l2)
l1,l2 : list bool
b : bool
*****
eq (bs2nat (cons b l1)) (bs2nat (cons b l2))
+++++
case b.
-----
Lemma bs2nat_cons_eq : forall b l1 l2, bs2nat l1 = bs2nat l2 -> bs2nat (b :: l1) = bs2nat (b :: l2).
Proof.
intros.
case b.

*****
H : eq (bs2nat l1) (bs2nat l2)
l1,l2 : list bool
b : bool
*****
eq (bs2nat (cons true l1)) (bs2nat (cons true l2))
+++++
repeat rewrite bs2nat_true.
-----
Lemma bs2nat_cons_eq : forall b l1 l2, bs2nat l1 = bs2nat l2 -> bs2nat (b :: l1) = bs2nat (b :: l2).
Proof.
intros.
case b.
repeat rewrite bs2nat_true.

*****
H : eq (bs2nat l1) (bs2nat l2)
l1,l2 : list bool
b : bool
*****
eq (Init.Nat.add (S O) (Init.Nat.mul (S (S O)) (bs2nat l1))) (Init.Nat.add (S O) (Init.Nat.mul (S (S O)) (bs2nat l2)))
+++++
ring [H].
-----
Lemma bs2nat_cons_eq : forall b l1 l2, bs2nat l1 = bs2nat l2 -> bs2nat (b :: l1) = bs2nat (b :: l2).
Proof.
intros.
case b.

*****
H : eq (bs2nat l1) (bs2nat l2)
l1,l2 : list bool
b : bool
*****
eq (bs2nat (cons false l1)) (bs2nat (cons false l2))
+++++
repeat rewrite bs2nat_false.
-----
Lemma bs2nat_cons_eq : forall b l1 l2, bs2nat l1 = bs2nat l2 -> bs2nat (b :: l1) = bs2nat (b :: l2).
Proof.
intros.
case b.
repeat rewrite bs2nat_false.

*****
H : eq (bs2nat l1) (bs2nat l2)
l1,l2 : list bool
b : bool
*****
eq (Init.Nat.mul (S (S O)) (bs2nat l1)) (Init.Nat.mul (S (S O)) (bs2nat l2))
+++++
ring [H].
-----
Lemma bs2nat_cons_eq : forall b l1 l2, bs2nat l1 = bs2nat l2 -> bs2nat (b :: l1) = bs2nat (b :: l2).
Proof.
intros.
case b.

*****

*****

+++++
Qed.
-----
Fixpoint RoseS_spec' (x : bs) (y z : nat) :=\n  match z with\n    | 0 => nil\n    | S z' =>\n      if leb z (length x - y)\n        then false :: RoseS_spec' x y z'\n        else hd false (skipn (length x - z) x) :: RoseS_spec' x y z'\n  end.
-----
