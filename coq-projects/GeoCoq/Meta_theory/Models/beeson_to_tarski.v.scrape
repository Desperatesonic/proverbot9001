Require Import GeoCoq.Axioms.beeson_s_axioms.
-----
Require Import GeoCoq.Axioms.tarski_axioms.
-----
Section Proof_of_eq_stability_in_IT.
-----
Context `{BTn:intuitionistic_Tarski_neutral_dimensionless}.
-----
Lemma cong_stability_eq_stability : forall A B : ITpoint, ~ A <> B -> A = B.
-----
Lemma cong_stability_eq_stability : forall A B : ITpoint, ~ A <> B -> A = B.

*****
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
forall (A B : ITpoint) (_ : not (not (eq A B))), eq A B
+++++
Proof.
-----
Lemma cong_stability_eq_stability : forall A B : ITpoint, ~ A <> B -> A = B.
Proof.

*****
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
forall (A B : ITpoint) (_ : not (not (eq A B))), eq A B
+++++
intros A B HAB.
-----
Lemma cong_stability_eq_stability : forall A B : ITpoint, ~ A <> B -> A = B.
Proof.
intros A B HAB.

*****
HAB : not (not (eq A B))
A,B : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
eq A B
+++++
apply Icong_identity with A.
-----
Lemma cong_stability_eq_stability : forall A B : ITpoint, ~ A <> B -> A = B.
Proof.
intros A B HAB.
apply Icong_identity with A.

*****
HAB : not (not (eq A B))
A,B : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
ICong A B A A
+++++
apply Cong_stability.
-----
Lemma cong_stability_eq_stability : forall A B : ITpoint, ~ A <> B -> A = B.
Proof.
intros A B HAB.
apply Icong_identity with A.
apply Cong_stability.

*****
HAB : not (not (eq A B))
A,B : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
not (not (ICong A B A A))
+++++
intro HNCong.
-----
Lemma cong_stability_eq_stability : forall A B : ITpoint, ~ A <> B -> A = B.
Proof.
intros A B HAB.
apply Icong_identity with A.
apply Cong_stability.
intro HNCong.

*****
HNCong : not (ICong A B A A)
HAB : not (not (eq A B))
A,B : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
False
+++++
apply HAB.
-----
Lemma cong_stability_eq_stability : forall A B : ITpoint, ~ A <> B -> A = B.
Proof.
intros A B HAB.
apply Icong_identity with A.
apply Cong_stability.
intro HNCong.
apply HAB.

*****
HNCong : not (ICong A B A A)
HAB : not (not (eq A B))
A,B : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
not (eq A B)
+++++
intro HEq.
-----
Lemma cong_stability_eq_stability : forall A B : ITpoint, ~ A <> B -> A = B.
Proof.
intros A B HAB.
apply Icong_identity with A.
apply Cong_stability.
intro HNCong.
apply HAB.
intro HEq.

*****
HEq : eq A B
HNCong : not (ICong A B A A)
HAB : not (not (eq A B))
A,B : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
False
+++++
subst.
-----
Lemma cong_stability_eq_stability : forall A B : ITpoint, ~ A <> B -> A = B.
Proof.
intros A B HAB.
apply Icong_identity with A.
apply Cong_stability.
intro HNCong.
apply HAB.
intro HEq.
subst.

*****
HAB : not (not (eq B B))
HNCong : not (ICong B B B B)
B : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
False
+++++
apply HNCong.
-----
Lemma cong_stability_eq_stability : forall A B : ITpoint, ~ A <> B -> A = B.
Proof.
intros A B HAB.
apply Icong_identity with A.
apply Cong_stability.
intro HNCong.
apply HAB.
intro HEq.
subst.
apply HNCong.

*****
HAB : not (not (eq B B))
HNCong : not (ICong B B B B)
B : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
ICong B B B B
+++++
apply Icong_pseudo_reflexivity.
-----
Lemma cong_stability_eq_stability : forall A B : ITpoint, ~ A <> B -> A = B.
Proof.
intros A B HAB.
apply Icong_identity with A.
apply Cong_stability.
intro HNCong.
apply HAB.
intro HEq.
subst.
apply HNCong.
apply Icong_pseudo_reflexivity.

*****

*****

+++++
Qed.
-----
End Proof_of_eq_stability_in_IT.
-----
From Coq Require Import Classical.
-----
Section Intuitionistic_Tarski_to_Tarski.
-----
Context `{BTn:intuitionistic_Tarski_neutral_dimensionless}.
-----
Lemma col_dec : forall A B C, ICol A B C \/ ~ ICol A B C.
-----
Lemma col_dec : forall A B C, ICol A B C \\/ ~ ICol A B C.

*****
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
forall A B C : ITpoint, or (ICol A B C) (not (ICol A B C))
+++++
Proof.
-----
Lemma col_dec : forall A B C, ICol A B C \\/ ~ ICol A B C.
Proof.

*****
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
forall A B C : ITpoint, or (ICol A B C) (not (ICol A B C))
+++++
intros.
-----
Lemma col_dec : forall A B C, ICol A B C \\/ ~ ICol A B C.
Proof.
intros.

*****
A,B,C : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
or (ICol A B C) (not (ICol A B C))
+++++
tauto.
-----
Lemma col_dec : forall A B C, ICol A B C \\/ ~ ICol A B C.
Proof.
intros.
tauto.

*****

*****

+++++
Qed.
-----
Lemma eq_dec : forall A B :ITpoint, A=B \/ A<>B.
-----
Lemma eq_dec : forall A B :ITpoint, A=B \\/ A<>B.

*****
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
forall A B : ITpoint, or (eq A B) (not (eq A B))
+++++
Proof.
-----
Lemma eq_dec : forall A B :ITpoint, A=B \\/ A<>B.
Proof.

*****
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
forall A B : ITpoint, or (eq A B) (not (eq A B))
+++++
intros.
-----
Lemma eq_dec : forall A B :ITpoint, A=B \\/ A<>B.
Proof.
intros.

*****
A,B : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
or (eq A B) (not (eq A B))
+++++
tauto.
-----
Lemma eq_dec : forall A B :ITpoint, A=B \\/ A<>B.
Proof.
intros.
tauto.

*****

*****

+++++
Qed.
-----
Definition BetT A B C := IBet A B C \/ A=B \/ B=C.
-----
Lemma bet_id : forall A B : ITpoint, BetT A B A -> A = B.
-----
Lemma bet_id : forall A B : ITpoint, BetT A B A -> A = B.

*****
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
forall (A B : ITpoint) (_ : BetT A B A), eq A B
+++++
Proof.
-----
Lemma bet_id : forall A B : ITpoint, BetT A B A -> A = B.
Proof.

*****
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
forall (A B : ITpoint) (_ : BetT A B A), eq A B
+++++
intros.
-----
Lemma bet_id : forall A B : ITpoint, BetT A B A -> A = B.
Proof.
intros.

*****
H : BetT A B A
A,B : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
eq A B
+++++
unfold BetT in H.
-----
Lemma bet_id : forall A B : ITpoint, BetT A B A -> A = B.
Proof.
intros.
unfold BetT in H.

*****
H : or (IBet A B A) (or (eq A B) (eq B A))
A,B : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
eq A B
+++++
decompose [or] H.
-----
Lemma bet_id : forall A B : ITpoint, BetT A B A -> A = B.
Proof.
intros.
unfold BetT in H.
decompose [or] H.

*****
H0 : IBet A B A
H : or (IBet A B A) (or (eq A B) (eq B A))
A,B : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
eq A B
+++++
apply Ibetween_identity in H0.
-----
Lemma bet_id : forall A B : ITpoint, BetT A B A -> A = B.
Proof.
intros.
unfold BetT in H.
decompose [or] H.
apply Ibetween_identity in H0.

*****
H0 : False
H : or (IBet A B A) (or (eq A B) (eq B A))
A,B : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
eq A B
+++++
elim H0.
-----
Lemma bet_id : forall A B : ITpoint, BetT A B A -> A = B.
Proof.
intros.
unfold BetT in H.
decompose [or] H.

*****
H1 : eq A B
H : or (IBet A B A) (or (eq A B) (eq B A))
A,B : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
eq A B
+++++
assumption.
-----
Lemma bet_id : forall A B : ITpoint, BetT A B A -> A = B.
Proof.
intros.
unfold BetT in H.
decompose [or] H.

*****
H1 : eq B A
H : or (IBet A B A) (or (eq A B) (eq B A))
A,B : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
eq A B
+++++
intuition.
-----
Lemma bet_id : forall A B : ITpoint, BetT A B A -> A = B.
Proof.
intros.
unfold BetT in H.
decompose [or] H.

*****

*****

+++++
Qed.
-----
Lemma IT_chara : forall A B C,\n IT A B C <-> A=B \/ B=C \/ IBet A B C.
-----
Lemma IT_chara : forall A B C, IT A B C <-> A=B \\/ B=C \\/ IBet A B C.

*****
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
forall A B C : ITpoint, iff (IT A B C) (or (eq A B) (or (eq B C) (IBet A B C)))
+++++
Proof.
-----
Lemma IT_chara : forall A B C, IT A B C <-> A=B \\/ B=C \\/ IBet A B C.
Proof.

*****
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
forall A B C : ITpoint, iff (IT A B C) (or (eq A B) (or (eq B C) (IBet A B C)))
+++++
intros.
-----
Lemma IT_chara : forall A B C, IT A B C <-> A=B \\/ B=C \\/ IBet A B C.
Proof.
intros.

*****
A,B,C : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
iff (IT A B C) (or (eq A B) (or (eq B C) (IBet A B C)))
+++++
unfold IT.
-----
Lemma IT_chara : forall A B C, IT A B C <-> A=B \\/ B=C \\/ IBet A B C.
Proof.
intros.
unfold IT.

*****
A,B,C : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
iff (not (and (not (eq A B)) (and (not (eq B C)) (not (IBet A B C))))) (or (eq A B) (or (eq B C) (IBet A B C)))
+++++
tauto.
-----
Lemma IT_chara : forall A B C, IT A B C <-> A=B \\/ B=C \\/ IBet A B C.
Proof.
intros.
unfold IT.
tauto.

*****

*****

+++++
Qed.
-----
Lemma BetT_symmetry : forall A B C, BetT A B C -> BetT C B A.
-----
Lemma BetT_symmetry : forall A B C, BetT A B C -> BetT C B A.

*****
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
forall (A B C : ITpoint) (_ : BetT A B C), BetT C B A
+++++
Proof.
-----
Lemma BetT_symmetry : forall A B C, BetT A B C -> BetT C B A.
Proof.

*****
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
forall (A B C : ITpoint) (_ : BetT A B C), BetT C B A
+++++
intros.
-----
Lemma BetT_symmetry : forall A B C, BetT A B C -> BetT C B A.
Proof.
intros.

*****
H : BetT A B C
A,B,C : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
BetT C B A
+++++
unfold BetT in *.
-----
Lemma BetT_symmetry : forall A B C, BetT A B C -> BetT C B A.
Proof.
intros.
unfold BetT in *.

*****
H : or (IBet A B C) (or (eq A B) (eq B C))
A,B,C : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
or (IBet C B A) (or (eq C B) (eq B A))
+++++
intuition.
-----
Lemma BetT_symmetry : forall A B C, BetT A B C -> BetT C B A.
Proof.
intros.
unfold BetT in *.
intuition.

*****
H0 : IBet A B C
A,B,C : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
or (IBet C B A) (or (eq C B) (eq B A))
+++++
left.
-----
Lemma BetT_symmetry : forall A B C, BetT A B C -> BetT C B A.
Proof.
intros.
unfold BetT in *.
intuition.
left.

*****
H0 : IBet A B C
A,B,C : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
IBet C B A
+++++
apply Ibetween_symmetry.
-----
Lemma BetT_symmetry : forall A B C, BetT A B C -> BetT C B A.
Proof.
intros.
unfold BetT in *.
intuition.
left.
apply Ibetween_symmetry.

*****
H0 : IBet A B C
A,B,C : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
IBet A B C
+++++
assumption.
-----
Lemma BetT_symmetry : forall A B C, BetT A B C -> BetT C B A.
Proof.
intros.
unfold BetT in *.
intuition.
left.
apply Ibetween_symmetry.
assumption.

*****

*****

+++++
Qed.
-----
Lemma BetT_id : forall A B, BetT A B A -> A=B.
-----
Lemma BetT_id : forall A B, BetT A B A -> A=B.

*****
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
forall (A B : ITpoint) (_ : BetT A B A), eq A B
+++++
Proof.
-----
Lemma BetT_id : forall A B, BetT A B A -> A=B.
Proof.

*****
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
forall (A B : ITpoint) (_ : BetT A B A), eq A B
+++++
intros.
-----
Lemma BetT_id : forall A B, BetT A B A -> A=B.
Proof.
intros.

*****
H : BetT A B A
A,B : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
eq A B
+++++
unfold BetT in *.
-----
Lemma BetT_id : forall A B, BetT A B A -> A=B.
Proof.
intros.
unfold BetT in *.

*****
H : or (IBet A B A) (or (eq A B) (eq B A))
A,B : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
eq A B
+++++
intuition.
-----
Lemma BetT_id : forall A B, BetT A B A -> A=B.
Proof.
intros.
unfold BetT in *.
intuition.

*****
H0 : IBet A B A
A,B : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
eq A B
+++++
apply Ibetween_identity in H0.
-----
Lemma BetT_id : forall A B, BetT A B A -> A=B.
Proof.
intros.
unfold BetT in *.
intuition.
apply Ibetween_identity in H0.

*****
H0 : False
A,B : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
eq A B
+++++
elim H0.
-----
Lemma BetT_id : forall A B, BetT A B A -> A=B.
Proof.
intros.
unfold BetT in *.
intuition.
apply Ibetween_identity in H0.
elim H0.

*****

*****

+++++
Qed.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint,\n        BetT A P C ->\n        BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\ BetT Q x A.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.

*****
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
forall (A B C P Q : ITpoint) (_ : BetT A P C) (_ : BetT B Q C) (_ : ICol A B C), ex (fun x : ITpoint => and (BetT P x B) (BetT Q x A))
+++++
Proof.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.

*****
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
forall (A B C P Q : ITpoint) (_ : BetT A P C) (_ : BetT B Q C) (_ : ICol A B C), ex (fun x : ITpoint => and (BetT P x B) (BetT Q x A))
+++++
intros.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.

*****
H1 : ICol A B C
H0 : BetT B Q C
H : BetT A P C
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
ex (fun x : ITpoint => and (BetT P x B) (BetT Q x A))
+++++
elim (eq_dec A B).
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).

*****
H1 : ICol A B C
H0 : BetT B Q C
H : BetT A P C
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
forall _ : eq A B, ex (fun x : ITpoint => and (BetT P x B) (BetT Q x A))
+++++
intro.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.

*****
H2 : eq A B
H1 : ICol A B C
H0 : BetT B Q C
H : BetT A P C
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
ex (fun x : ITpoint => and (BetT P x B) (BetT Q x A))
+++++
subst.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
subst.

*****
H1 : ICol B B C
H0 : BetT B Q C
H : BetT B P C
B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
ex (fun x : ITpoint => and (BetT P x B) (BetT Q x B))
+++++
exists B.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
subst.
exists B.

*****
H1 : ICol B B C
H0 : BetT B Q C
H : BetT B P C
B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
and (BetT P B B) (BetT Q B B)
+++++
unfold BetT.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
subst.
exists B.
unfold BetT.

*****
H1 : ICol B B C
H0 : BetT B Q C
H : BetT B P C
B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
and (or (IBet P B B) (or (eq P B) (eq B B))) (or (IBet Q B B) (or (eq Q B) (eq B B)))
+++++
auto.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).

*****
H1 : ICol A B C
H0 : BetT B Q C
H : BetT A P C
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
forall _ : not (eq A B), ex (fun x : ITpoint => and (BetT P x B) (BetT Q x A))
+++++
intro.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.

*****
H2 : not (eq A B)
H1 : ICol A B C
H0 : BetT B Q C
H : BetT A P C
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
ex (fun x : ITpoint => and (BetT P x B) (BetT Q x A))
+++++
elim (eq_dec A C).
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).

*****
H2 : not (eq A B)
H1 : ICol A B C
H0 : BetT B Q C
H : BetT A P C
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
forall _ : eq A C, ex (fun x : ITpoint => and (BetT P x B) (BetT Q x A))
+++++
intro.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.

*****
H3 : eq A C
H2 : not (eq A B)
H1 : ICol A B C
H0 : BetT B Q C
H : BetT A P C
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
ex (fun x : ITpoint => and (BetT P x B) (BetT Q x A))
+++++
subst.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
subst.

*****
H1 : ICol C B C
H2 : not (eq C B)
H0 : BetT B Q C
H : BetT C P C
B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
ex (fun x : ITpoint => and (BetT P x B) (BetT Q x C))
+++++
apply BetT_id in H.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
subst.
apply BetT_id in H.

*****
H1 : ICol C B C
H2 : not (eq C B)
H0 : BetT B Q C
H : eq C P
B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
ex (fun x : ITpoint => and (BetT P x B) (BetT Q x C))
+++++
subst.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
subst.
apply BetT_id in H.
subst.

*****
H0 : BetT B Q P
H2 : not (eq P B)
H1 : ICol P B P
B,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
ex (fun x : ITpoint => and (BetT P x B) (BetT Q x P))
+++++
exists P.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
subst.
apply BetT_id in H.
subst.
exists P.

*****
H0 : BetT B Q P
H2 : not (eq P B)
H1 : ICol P B P
B,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
and (BetT P P B) (BetT Q P P)
+++++
unfold BetT.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
subst.
apply BetT_id in H.
subst.
exists P.
unfold BetT.

*****
H0 : BetT B Q P
H2 : not (eq P B)
H1 : ICol P B P
B,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
and (or (IBet P P B) (or (eq P P) (eq P B))) (or (IBet Q P P) (or (eq Q P) (eq P P)))
+++++
auto.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).

*****
H2 : not (eq A B)
H1 : ICol A B C
H0 : BetT B Q C
H : BetT A P C
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
forall _ : not (eq A C), ex (fun x : ITpoint => and (BetT P x B) (BetT Q x A))
+++++
intro.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.

*****
H3 : not (eq A C)
H2 : not (eq A B)
H1 : ICol A B C
H0 : BetT B Q C
H : BetT A P C
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
ex (fun x : ITpoint => and (BetT P x B) (BetT Q x A))
+++++
elim (eq_dec B C).
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).

*****
H3 : not (eq A C)
H2 : not (eq A B)
H1 : ICol A B C
H0 : BetT B Q C
H : BetT A P C
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
forall _ : eq B C, ex (fun x : ITpoint => and (BetT P x B) (BetT Q x A))
+++++
intro.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.

*****
H4 : eq B C
H3 : not (eq A C)
H2 : not (eq A B)
H1 : ICol A B C
H0 : BetT B Q C
H : BetT A P C
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
ex (fun x : ITpoint => and (BetT P x B) (BetT Q x A))
+++++
subst.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
subst.

*****
H3 : not (eq A C)
H0 : BetT C Q C
H1 : ICol A C C
H2 : not (eq A C)
H : BetT A P C
A,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
ex (fun x : ITpoint => and (BetT P x C) (BetT Q x A))
+++++
apply BetT_id in H0.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
subst.
apply BetT_id in H0.

*****
H3 : not (eq A C)
H0 : eq C Q
H1 : ICol A C C
H2 : not (eq A C)
H : BetT A P C
A,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
ex (fun x : ITpoint => and (BetT P x C) (BetT Q x A))
+++++
subst.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
subst.
apply BetT_id in H0.
subst.

*****
H3 : not (eq A Q)
H : BetT A P Q
H2 : not (eq A Q)
H1 : ICol A Q Q
A,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
ex (fun x : ITpoint => and (BetT P x Q) (BetT Q x A))
+++++
exists Q.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
subst.
apply BetT_id in H0.
subst.
exists Q.

*****
H3 : not (eq A Q)
H : BetT A P Q
H2 : not (eq A Q)
H1 : ICol A Q Q
A,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
and (BetT P Q Q) (BetT Q Q A)
+++++
unfold BetT.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
subst.
apply BetT_id in H0.
subst.
exists Q.
unfold BetT.

*****
H3 : not (eq A Q)
H : BetT A P Q
H2 : not (eq A Q)
H1 : ICol A Q Q
A,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
and (or (IBet P Q Q) (or (eq P Q) (eq Q Q))) (or (IBet Q Q A) (or (eq Q Q) (eq Q A)))
+++++
auto.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).

*****
H3 : not (eq A C)
H2 : not (eq A B)
H1 : ICol A B C
H0 : BetT B Q C
H : BetT A P C
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
forall _ : not (eq B C), ex (fun x : ITpoint => and (BetT P x B) (BetT Q x A))
+++++
intro.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.

*****
H4 : not (eq B C)
H3 : not (eq A C)
H2 : not (eq A B)
H1 : ICol A B C
H0 : BetT B Q C
H : BetT A P C
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
ex (fun x : ITpoint => and (BetT P x B) (BetT Q x A))
+++++
elim (eq_dec B Q).
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).

*****
H4 : not (eq B C)
H3 : not (eq A C)
H2 : not (eq A B)
H1 : ICol A B C
H0 : BetT B Q C
H : BetT A P C
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
forall _ : eq B Q, ex (fun x : ITpoint => and (BetT P x B) (BetT Q x A))
+++++
intro.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.

*****
H5 : eq B Q
H4 : not (eq B C)
H3 : not (eq A C)
H2 : not (eq A B)
H1 : ICol A B C
H0 : BetT B Q C
H : BetT A P C
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
ex (fun x : ITpoint => and (BetT P x B) (BetT Q x A))
+++++
subst.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
subst.

*****
H4 : not (eq Q C)
H3 : not (eq A C)
H0 : BetT Q Q C
H1 : ICol A Q C
H2 : not (eq A Q)
H : BetT A P C
A,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
ex (fun x : ITpoint => and (BetT P x Q) (BetT Q x A))
+++++
exists Q.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
subst.
exists Q.

*****
H4 : not (eq Q C)
H3 : not (eq A C)
H0 : BetT Q Q C
H1 : ICol A Q C
H2 : not (eq A Q)
H : BetT A P C
A,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
and (BetT P Q Q) (BetT Q Q A)
+++++
unfold BetT.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
subst.
exists Q.
unfold BetT.

*****
H4 : not (eq Q C)
H3 : not (eq A C)
H0 : BetT Q Q C
H1 : ICol A Q C
H2 : not (eq A Q)
H : BetT A P C
A,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
and (or (IBet P Q Q) (or (eq P Q) (eq Q Q))) (or (IBet Q Q A) (or (eq Q Q) (eq Q A)))
+++++
auto.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).

*****
H4 : not (eq B C)
H3 : not (eq A C)
H2 : not (eq A B)
H1 : ICol A B C
H0 : BetT B Q C
H : BetT A P C
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
forall _ : not (eq B Q), ex (fun x : ITpoint => and (BetT P x B) (BetT Q x A))
+++++
intro.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.

*****
H5 : not (eq B Q)
H4 : not (eq B C)
H3 : not (eq A C)
H2 : not (eq A B)
H1 : ICol A B C
H0 : BetT B Q C
H : BetT A P C
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
ex (fun x : ITpoint => and (BetT P x B) (BetT Q x A))
+++++
elim (eq_dec C Q).
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).

*****
H5 : not (eq B Q)
H4 : not (eq B C)
H3 : not (eq A C)
H2 : not (eq A B)
H1 : ICol A B C
H0 : BetT B Q C
H : BetT A P C
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
forall _ : eq C Q, ex (fun x : ITpoint => and (BetT P x B) (BetT Q x A))
+++++
intro.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.

*****
H6 : eq C Q
H5 : not (eq B Q)
H4 : not (eq B C)
H3 : not (eq A C)
H2 : not (eq A B)
H1 : ICol A B C
H0 : BetT B Q C
H : BetT A P C
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
ex (fun x : ITpoint => and (BetT P x B) (BetT Q x A))
+++++
subst.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
subst.

*****
H5 : not (eq B Q)
H3 : not (eq A Q)
H4 : not (eq B Q)
H2 : not (eq A B)
H : BetT A P Q
H0 : BetT B Q Q
H1 : ICol A B Q
A,B,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
ex (fun x : ITpoint => and (BetT P x B) (BetT Q x A))
+++++
exists P.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
subst.
exists P.

*****
H5 : not (eq B Q)
H3 : not (eq A Q)
H4 : not (eq B Q)
H2 : not (eq A B)
H : BetT A P Q
H0 : BetT B Q Q
H1 : ICol A B Q
A,B,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
and (BetT P P B) (BetT Q P A)
+++++
split.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
subst.
exists P.
split.

*****
H5 : not (eq B Q)
H3 : not (eq A Q)
H4 : not (eq B Q)
H2 : not (eq A B)
H : BetT A P Q
H0 : BetT B Q Q
H1 : ICol A B Q
A,B,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
BetT P P B
+++++
unfold BetT.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
subst.
exists P.
split.
unfold BetT.

*****
H5 : not (eq B Q)
H3 : not (eq A Q)
H4 : not (eq B Q)
H2 : not (eq A B)
H : BetT A P Q
H0 : BetT B Q Q
H1 : ICol A B Q
A,B,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
or (IBet P P B) (or (eq P P) (eq P B))
+++++
auto.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
subst.
exists P.
split.

*****
H5 : not (eq B Q)
H3 : not (eq A Q)
H4 : not (eq B Q)
H2 : not (eq A B)
H : BetT A P Q
H0 : BetT B Q Q
H1 : ICol A B Q
A,B,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
BetT Q P A
+++++
apply BetT_symmetry.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
subst.
exists P.
split.
apply BetT_symmetry.

*****
H5 : not (eq B Q)
H3 : not (eq A Q)
H4 : not (eq B Q)
H2 : not (eq A B)
H : BetT A P Q
H0 : BetT B Q Q
H1 : ICol A B Q
A,B,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
BetT A P Q
+++++
auto.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).

*****
H5 : not (eq B Q)
H4 : not (eq B C)
H3 : not (eq A C)
H2 : not (eq A B)
H1 : ICol A B C
H0 : BetT B Q C
H : BetT A P C
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
forall _ : not (eq C Q), ex (fun x : ITpoint => and (BetT P x B) (BetT Q x A))
+++++
intro.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.

*****
H6 : not (eq C Q)
H5 : not (eq B Q)
H4 : not (eq B C)
H3 : not (eq A C)
H2 : not (eq A B)
H1 : ICol A B C
H0 : BetT B Q C
H : BetT A P C
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
ex (fun x : ITpoint => and (BetT P x B) (BetT Q x A))
+++++
elim (eq_dec A P).
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
elim (eq_dec A P).

*****
H6 : not (eq C Q)
H5 : not (eq B Q)
H4 : not (eq B C)
H3 : not (eq A C)
H2 : not (eq A B)
H1 : ICol A B C
H0 : BetT B Q C
H : BetT A P C
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
forall _ : eq A P, ex (fun x : ITpoint => and (BetT P x B) (BetT Q x A))
+++++
intro.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
elim (eq_dec A P).
intro.

*****
H7 : eq A P
H6 : not (eq C Q)
H5 : not (eq B Q)
H4 : not (eq B C)
H3 : not (eq A C)
H2 : not (eq A B)
H1 : ICol A B C
H0 : BetT B Q C
H : BetT A P C
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
ex (fun x : ITpoint => and (BetT P x B) (BetT Q x A))
+++++
subst.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
elim (eq_dec A P).
intro.
subst.

*****
H6 : not (eq C Q)
H5 : not (eq B Q)
H4 : not (eq B C)
H1 : ICol P B C
H2 : not (eq P B)
H3 : not (eq P C)
H0 : BetT B Q C
H : BetT P P C
B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
ex (fun x : ITpoint => and (BetT P x B) (BetT Q x P))
+++++
exists P.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
elim (eq_dec A P).
intro.
subst.
exists P.

*****
H6 : not (eq C Q)
H5 : not (eq B Q)
H4 : not (eq B C)
H1 : ICol P B C
H2 : not (eq P B)
H3 : not (eq P C)
H0 : BetT B Q C
H : BetT P P C
B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
and (BetT P P B) (BetT Q P P)
+++++
unfold BetT.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
elim (eq_dec A P).
intro.
subst.
exists P.
unfold BetT.

*****
H6 : not (eq C Q)
H5 : not (eq B Q)
H4 : not (eq B C)
H1 : ICol P B C
H2 : not (eq P B)
H3 : not (eq P C)
H0 : BetT B Q C
H : BetT P P C
B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
and (or (IBet P P B) (or (eq P P) (eq P B))) (or (IBet Q P P) (or (eq Q P) (eq P P)))
+++++
auto.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
elim (eq_dec A P).

*****
H6 : not (eq C Q)
H5 : not (eq B Q)
H4 : not (eq B C)
H3 : not (eq A C)
H2 : not (eq A B)
H1 : ICol A B C
H0 : BetT B Q C
H : BetT A P C
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
forall _ : not (eq A P), ex (fun x : ITpoint => and (BetT P x B) (BetT Q x A))
+++++
intro.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
elim (eq_dec A P).
intro.

*****
H7 : not (eq A P)
H6 : not (eq C Q)
H5 : not (eq B Q)
H4 : not (eq B C)
H3 : not (eq A C)
H2 : not (eq A B)
H1 : ICol A B C
H0 : BetT B Q C
H : BetT A P C
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
ex (fun x : ITpoint => and (BetT P x B) (BetT Q x A))
+++++
elim (eq_dec C P).
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
elim (eq_dec A P).
intro.
elim (eq_dec C P).

*****
H7 : not (eq A P)
H6 : not (eq C Q)
H5 : not (eq B Q)
H4 : not (eq B C)
H3 : not (eq A C)
H2 : not (eq A B)
H1 : ICol A B C
H0 : BetT B Q C
H : BetT A P C
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
forall _ : eq C P, ex (fun x : ITpoint => and (BetT P x B) (BetT Q x A))
+++++
intro.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
elim (eq_dec A P).
intro.
elim (eq_dec C P).
intro.

*****
H8 : eq C P
H7 : not (eq A P)
H6 : not (eq C Q)
H5 : not (eq B Q)
H4 : not (eq B C)
H3 : not (eq A C)
H2 : not (eq A B)
H1 : ICol A B C
H0 : BetT B Q C
H : BetT A P C
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
ex (fun x : ITpoint => and (BetT P x B) (BetT Q x A))
+++++
subst.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
elim (eq_dec A P).
intro.
elim (eq_dec C P).
intro.
subst.

*****
H7 : not (eq A P)
H6 : not (eq P Q)
H5 : not (eq B Q)
H3 : not (eq A P)
H4 : not (eq B P)
H2 : not (eq A B)
H : BetT A P P
H0 : BetT B Q P
H1 : ICol A B P
A,B,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
ex (fun x : ITpoint => and (BetT P x B) (BetT Q x A))
+++++
exists Q.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
elim (eq_dec A P).
intro.
elim (eq_dec C P).
intro.
subst.
exists Q.

*****
H7 : not (eq A P)
H6 : not (eq P Q)
H5 : not (eq B Q)
H3 : not (eq A P)
H4 : not (eq B P)
H2 : not (eq A B)
H : BetT A P P
H0 : BetT B Q P
H1 : ICol A B P
A,B,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
and (BetT P Q B) (BetT Q Q A)
+++++
split.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
elim (eq_dec A P).
intro.
elim (eq_dec C P).
intro.
subst.
exists Q.
split.

*****
H7 : not (eq A P)
H6 : not (eq P Q)
H5 : not (eq B Q)
H3 : not (eq A P)
H4 : not (eq B P)
H2 : not (eq A B)
H : BetT A P P
H0 : BetT B Q P
H1 : ICol A B P
A,B,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
BetT P Q B
+++++
apply BetT_symmetry.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
elim (eq_dec A P).
intro.
elim (eq_dec C P).
intro.
subst.
exists Q.
split.
apply BetT_symmetry.

*****
H7 : not (eq A P)
H6 : not (eq P Q)
H5 : not (eq B Q)
H3 : not (eq A P)
H4 : not (eq B P)
H2 : not (eq A B)
H : BetT A P P
H0 : BetT B Q P
H1 : ICol A B P
A,B,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
BetT B Q P
+++++
auto.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
elim (eq_dec A P).
intro.
elim (eq_dec C P).
intro.
subst.
exists Q.
split.

*****
H7 : not (eq A P)
H6 : not (eq P Q)
H5 : not (eq B Q)
H3 : not (eq A P)
H4 : not (eq B P)
H2 : not (eq A B)
H : BetT A P P
H0 : BetT B Q P
H1 : ICol A B P
A,B,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
BetT Q Q A
+++++
unfold BetT.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
elim (eq_dec A P).
intro.
elim (eq_dec C P).
intro.
subst.
exists Q.
split.
unfold BetT.

*****
H7 : not (eq A P)
H6 : not (eq P Q)
H5 : not (eq B Q)
H3 : not (eq A P)
H4 : not (eq B P)
H2 : not (eq A B)
H : BetT A P P
H0 : BetT B Q P
H1 : ICol A B P
A,B,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
or (IBet Q Q A) (or (eq Q Q) (eq Q A))
+++++
auto.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
elim (eq_dec A P).
intro.
elim (eq_dec C P).

*****
H7 : not (eq A P)
H6 : not (eq C Q)
H5 : not (eq B Q)
H4 : not (eq B C)
H3 : not (eq A C)
H2 : not (eq A B)
H1 : ICol A B C
H0 : BetT B Q C
H : BetT A P C
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
forall _ : not (eq C P), ex (fun x : ITpoint => and (BetT P x B) (BetT Q x A))
+++++
intro.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
elim (eq_dec A P).
intro.
elim (eq_dec C P).
intro.

*****
H8 : not (eq C P)
H7 : not (eq A P)
H6 : not (eq C Q)
H5 : not (eq B Q)
H4 : not (eq B C)
H3 : not (eq A C)
H2 : not (eq A B)
H1 : ICol A B C
H0 : BetT B Q C
H : BetT A P C
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
ex (fun x : ITpoint => and (BetT P x B) (BetT Q x A))
+++++
unfold ICol in H1.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
elim (eq_dec A P).
intro.
elim (eq_dec C P).
intro.
unfold ICol in H1.

*****
H8 : not (eq C P)
H7 : not (eq A P)
H6 : not (eq C Q)
H5 : not (eq B Q)
H4 : not (eq B C)
H3 : not (eq A C)
H2 : not (eq A B)
H1 : not (and (not (IT C A B)) (and (not (IT A C B)) (not (IT A B C))))
H0 : BetT B Q C
H : BetT A P C
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
ex (fun x : ITpoint => and (BetT P x B) (BetT Q x A))
+++++
spliter.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
elim (eq_dec A P).
intro.
elim (eq_dec C P).
intro.
unfold ICol in H1.
spliter.

*****
H8 : not (eq C P)
H7 : not (eq A P)
H6 : not (eq C Q)
H5 : not (eq B Q)
H4 : not (eq B C)
H3 : not (eq A C)
H2 : not (eq A B)
H1 : not (and (not (IT C A B)) (and (not (IT A C B)) (not (IT A B C))))
H0 : BetT B Q C
H : BetT A P C
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
ex (fun x : ITpoint => and (BetT P x B) (BetT Q x A))
+++++
apply not_and_or in H1.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
elim (eq_dec A P).
intro.
elim (eq_dec C P).
intro.
unfold ICol in H1.
spliter.
apply not_and_or in H1.

*****
H8 : not (eq C P)
H7 : not (eq A P)
H6 : not (eq C Q)
H5 : not (eq B Q)
H4 : not (eq B C)
H3 : not (eq A C)
H2 : not (eq A B)
H1 : or (not (not (IT C A B))) (not (and (not (IT A C B)) (not (IT A B C))))
H0 : BetT B Q C
H : BetT A P C
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
ex (fun x : ITpoint => and (BetT P x B) (BetT Q x A))
+++++
induction H1.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
elim (eq_dec A P).
intro.
elim (eq_dec C P).
intro.
unfold ICol in H1.
spliter.
apply not_and_or in H1.
induction H1.

*****
H8 : not (eq C P)
H7 : not (eq A P)
H6 : not (eq C Q)
H5 : not (eq B Q)
H4 : not (eq B C)
H3 : not (eq A C)
H2 : not (eq A B)
H1 : not (not (IT C A B))
H0 : BetT B Q C
H : BetT A P C
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
ex (fun x : ITpoint => and (BetT P x B) (BetT Q x A))
+++++
apply NNPP in H1.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
elim (eq_dec A P).
intro.
elim (eq_dec C P).
intro.
unfold ICol in H1.
spliter.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.

*****
H8 : not (eq C P)
H7 : not (eq A P)
H6 : not (eq C Q)
H5 : not (eq B Q)
H4 : not (eq B C)
H3 : not (eq A C)
H2 : not (eq A B)
H1 : IT C A B
H0 : BetT B Q C
H : BetT A P C
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
ex (fun x : ITpoint => and (BetT P x B) (BetT Q x A))
+++++
unfold IT in *.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
elim (eq_dec A P).
intro.
elim (eq_dec C P).
intro.
unfold ICol in H1.
spliter.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
unfold IT in *.

*****
H8 : not (eq C P)
H7 : not (eq A P)
H6 : not (eq C Q)
H5 : not (eq B Q)
H4 : not (eq B C)
H3 : not (eq A C)
H2 : not (eq A B)
H1 : not (and (not (eq C A)) (and (not (eq A B)) (not (IBet C A B))))
H0 : BetT B Q C
H : BetT A P C
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
ex (fun x : ITpoint => and (BetT P x B) (BetT Q x A))
+++++
apply not_and_or in H1.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
elim (eq_dec A P).
intro.
elim (eq_dec C P).
intro.
unfold ICol in H1.
spliter.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
unfold IT in *.
apply not_and_or in H1.

*****
H8 : not (eq C P)
H7 : not (eq A P)
H6 : not (eq C Q)
H5 : not (eq B Q)
H4 : not (eq B C)
H3 : not (eq A C)
H2 : not (eq A B)
H1 : or (not (not (eq C A))) (not (and (not (eq A B)) (not (IBet C A B))))
H0 : BetT B Q C
H : BetT A P C
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
ex (fun x : ITpoint => and (BetT P x B) (BetT Q x A))
+++++
induction H1.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
elim (eq_dec A P).
intro.
elim (eq_dec C P).
intro.
unfold ICol in H1.
spliter.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
unfold IT in *.
apply not_and_or in H1.
induction H1.

*****
H8 : not (eq C P)
H7 : not (eq A P)
H6 : not (eq C Q)
H5 : not (eq B Q)
H4 : not (eq B C)
H3 : not (eq A C)
H2 : not (eq A B)
H1 : not (not (eq C A))
H0 : BetT B Q C
H : BetT A P C
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
ex (fun x : ITpoint => and (BetT P x B) (BetT Q x A))
+++++
apply NNPP in H1.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
elim (eq_dec A P).
intro.
elim (eq_dec C P).
intro.
unfold ICol in H1.
spliter.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
unfold IT in *.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.

*****
H8 : not (eq C P)
H7 : not (eq A P)
H6 : not (eq C Q)
H5 : not (eq B Q)
H4 : not (eq B C)
H3 : not (eq A C)
H2 : not (eq A B)
H1 : eq C A
H0 : BetT B Q C
H : BetT A P C
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
ex (fun x : ITpoint => and (BetT P x B) (BetT Q x A))
+++++
subst.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
elim (eq_dec A P).
intro.
elim (eq_dec C P).
intro.
unfold ICol in H1.
spliter.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
unfold IT in *.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
subst.

*****
H7,H8 : not (eq A P)
H6 : not (eq A Q)
H5 : not (eq B Q)
H3 : not (eq A A)
H4 : not (eq B A)
H2 : not (eq A B)
H : BetT A P A
H0 : BetT B Q A
A,B,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
ex (fun x : ITpoint => and (BetT P x B) (BetT Q x A))
+++++
intuition.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
elim (eq_dec A P).
intro.
elim (eq_dec C P).
intro.
unfold ICol in H1.
spliter.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
unfold IT in *.
apply not_and_or in H1.
induction H1.

*****
H8 : not (eq C P)
H7 : not (eq A P)
H6 : not (eq C Q)
H5 : not (eq B Q)
H4 : not (eq B C)
H3 : not (eq A C)
H2 : not (eq A B)
H1 : not (and (not (eq A B)) (not (IBet C A B)))
H0 : BetT B Q C
H : BetT A P C
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
ex (fun x : ITpoint => and (BetT P x B) (BetT Q x A))
+++++
apply not_and_or in H1.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
elim (eq_dec A P).
intro.
elim (eq_dec C P).
intro.
unfold ICol in H1.
spliter.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
unfold IT in *.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.

*****
H8 : not (eq C P)
H7 : not (eq A P)
H6 : not (eq C Q)
H5 : not (eq B Q)
H4 : not (eq B C)
H3 : not (eq A C)
H2 : not (eq A B)
H1 : or (not (not (eq A B))) (not (not (IBet C A B)))
H0 : BetT B Q C
H : BetT A P C
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
ex (fun x : ITpoint => and (BetT P x B) (BetT Q x A))
+++++
induction H1.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
elim (eq_dec A P).
intro.
elim (eq_dec C P).
intro.
unfold ICol in H1.
spliter.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
unfold IT in *.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.

*****
H8 : not (eq C P)
H7 : not (eq A P)
H6 : not (eq C Q)
H5 : not (eq B Q)
H4 : not (eq B C)
H3 : not (eq A C)
H2 : not (eq A B)
H1 : not (not (eq A B))
H0 : BetT B Q C
H : BetT A P C
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
ex (fun x : ITpoint => and (BetT P x B) (BetT Q x A))
+++++
apply NNPP in H1.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
elim (eq_dec A P).
intro.
elim (eq_dec C P).
intro.
unfold ICol in H1.
spliter.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
unfold IT in *.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.

*****
H8 : not (eq C P)
H7 : not (eq A P)
H6 : not (eq C Q)
H5 : not (eq B Q)
H4 : not (eq B C)
H3 : not (eq A C)
H2 : not (eq A B)
H1 : eq A B
H0 : BetT B Q C
H : BetT A P C
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
ex (fun x : ITpoint => and (BetT P x B) (BetT Q x A))
+++++
subst.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
elim (eq_dec A P).
intro.
elim (eq_dec C P).
intro.
unfold ICol in H1.
spliter.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
unfold IT in *.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
subst.

*****
H8 : not (eq C P)
H7 : not (eq B P)
H6 : not (eq C Q)
H5 : not (eq B Q)
H4 : not (eq B C)
H2 : not (eq B B)
H3 : not (eq B C)
H0 : BetT B Q C
H : BetT B P C
B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
ex (fun x : ITpoint => and (BetT P x B) (BetT Q x B))
+++++
intuition.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
elim (eq_dec A P).
intro.
elim (eq_dec C P).
intro.
unfold ICol in H1.
spliter.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
unfold IT in *.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.

*****
H8 : not (eq C P)
H7 : not (eq A P)
H6 : not (eq C Q)
H5 : not (eq B Q)
H4 : not (eq B C)
H3 : not (eq A C)
H2 : not (eq A B)
H1 : not (not (IBet C A B))
H0 : BetT B Q C
H : BetT A P C
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
ex (fun x : ITpoint => and (BetT P x B) (BetT Q x A))
+++++
apply NNPP in H1.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
elim (eq_dec A P).
intro.
elim (eq_dec C P).
intro.
unfold ICol in H1.
spliter.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
unfold IT in *.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.

*****
H8 : not (eq C P)
H7 : not (eq A P)
H6 : not (eq C Q)
H5 : not (eq B Q)
H4 : not (eq B C)
H3 : not (eq A C)
H2 : not (eq A B)
H1 : IBet C A B
H0 : BetT B Q C
H : BetT A P C
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
ex (fun x : ITpoint => and (BetT P x B) (BetT Q x A))
+++++
exists A.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
elim (eq_dec A P).
intro.
elim (eq_dec C P).
intro.
unfold ICol in H1.
spliter.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
unfold IT in *.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
exists A.

*****
H8 : not (eq C P)
H7 : not (eq A P)
H6 : not (eq C Q)
H5 : not (eq B Q)
H4 : not (eq B C)
H3 : not (eq A C)
H2 : not (eq A B)
H1 : IBet C A B
H0 : BetT B Q C
H : BetT A P C
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
and (BetT P A B) (BetT Q A A)
+++++
split.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
elim (eq_dec A P).
intro.
elim (eq_dec C P).
intro.
unfold ICol in H1.
spliter.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
unfold IT in *.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
exists A.
split.

*****
H8 : not (eq C P)
H7 : not (eq A P)
H6 : not (eq C Q)
H5 : not (eq B Q)
H4 : not (eq B C)
H3 : not (eq A C)
H2 : not (eq A B)
H1 : IBet C A B
H0 : BetT B Q C
H : BetT A P C
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
BetT P A B
+++++
apply Ibetween_symmetry in H1.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
elim (eq_dec A P).
intro.
elim (eq_dec C P).
intro.
unfold ICol in H1.
spliter.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
unfold IT in *.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
exists A.
split.
apply Ibetween_symmetry in H1.

*****
H8 : not (eq C P)
H7 : not (eq A P)
H6 : not (eq C Q)
H5 : not (eq B Q)
H4 : not (eq B C)
H3 : not (eq A C)
H2 : not (eq A B)
H1 : IBet B A C
H0 : BetT B Q C
H : BetT A P C
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
BetT P A B
+++++
induction H.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
elim (eq_dec A P).
intro.
elim (eq_dec C P).
intro.
unfold ICol in H1.
spliter.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
unfold IT in *.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
exists A.
split.
apply Ibetween_symmetry in H1.
induction H.

*****
H8 : not (eq C P)
H7 : not (eq A P)
H6 : not (eq C Q)
H5 : not (eq B Q)
H4 : not (eq B C)
H3 : not (eq A C)
H2 : not (eq A B)
H1 : IBet B A C
H0 : BetT B Q C
H : IBet A P C
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
BetT P A B
+++++
assert (T:=Ibetween_inner_transitivity B A P C H1 H).
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
elim (eq_dec A P).
intro.
elim (eq_dec C P).
intro.
unfold ICol in H1.
spliter.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
unfold IT in *.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
exists A.
split.
apply Ibetween_symmetry in H1.
induction H.
assert (T:=Ibetween_inner_transitivity B A P C H1 H).

*****
T : IBet B A P
H8 : not (eq C P)
H7 : not (eq A P)
H6 : not (eq C Q)
H5 : not (eq B Q)
H4 : not (eq B C)
H3 : not (eq A C)
H2 : not (eq A B)
H1 : IBet B A C
H0 : BetT B Q C
H : IBet A P C
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
BetT P A B
+++++
unfold BetT.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
elim (eq_dec A P).
intro.
elim (eq_dec C P).
intro.
unfold ICol in H1.
spliter.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
unfold IT in *.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
exists A.
split.
apply Ibetween_symmetry in H1.
induction H.
assert (T:=Ibetween_inner_transitivity B A P C H1 H).
unfold BetT.

*****
T : IBet B A P
H8 : not (eq C P)
H7 : not (eq A P)
H6 : not (eq C Q)
H5 : not (eq B Q)
H4 : not (eq B C)
H3 : not (eq A C)
H2 : not (eq A B)
H1 : IBet B A C
H0 : BetT B Q C
H : IBet A P C
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
or (IBet P A B) (or (eq P A) (eq A B))
+++++
left.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
elim (eq_dec A P).
intro.
elim (eq_dec C P).
intro.
unfold ICol in H1.
spliter.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
unfold IT in *.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
exists A.
split.
apply Ibetween_symmetry in H1.
induction H.
assert (T:=Ibetween_inner_transitivity B A P C H1 H).
unfold BetT.
left.

*****
T : IBet B A P
H8 : not (eq C P)
H7 : not (eq A P)
H6 : not (eq C Q)
H5 : not (eq B Q)
H4 : not (eq B C)
H3 : not (eq A C)
H2 : not (eq A B)
H1 : IBet B A C
H0 : BetT B Q C
H : IBet A P C
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
IBet P A B
+++++
apply Ibetween_symmetry.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
elim (eq_dec A P).
intro.
elim (eq_dec C P).
intro.
unfold ICol in H1.
spliter.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
unfold IT in *.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
exists A.
split.
apply Ibetween_symmetry in H1.
induction H.
assert (T:=Ibetween_inner_transitivity B A P C H1 H).
unfold BetT.
left.
apply Ibetween_symmetry.

*****
T : IBet B A P
H8 : not (eq C P)
H7 : not (eq A P)
H6 : not (eq C Q)
H5 : not (eq B Q)
H4 : not (eq B C)
H3 : not (eq A C)
H2 : not (eq A B)
H1 : IBet B A C
H0 : BetT B Q C
H : IBet A P C
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
IBet B A P
+++++
auto.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
elim (eq_dec A P).
intro.
elim (eq_dec C P).
intro.
unfold ICol in H1.
spliter.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
unfold IT in *.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
exists A.
split.
apply Ibetween_symmetry in H1.
induction H.

*****
H8 : not (eq C P)
H7 : not (eq A P)
H6 : not (eq C Q)
H5 : not (eq B Q)
H4 : not (eq B C)
H3 : not (eq A C)
H2 : not (eq A B)
H1 : IBet B A C
H0 : BetT B Q C
H : or (eq A P) (eq P C)
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
BetT P A B
+++++
induction H.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
elim (eq_dec A P).
intro.
elim (eq_dec C P).
intro.
unfold ICol in H1.
spliter.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
unfold IT in *.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
exists A.
split.
apply Ibetween_symmetry in H1.
induction H.
induction H.

*****
H8 : not (eq C P)
H7 : not (eq A P)
H6 : not (eq C Q)
H5 : not (eq B Q)
H4 : not (eq B C)
H3 : not (eq A C)
H2 : not (eq A B)
H1 : IBet B A C
H0 : BetT B Q C
H : eq A P
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
BetT P A B
+++++
subst.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
elim (eq_dec A P).
intro.
elim (eq_dec C P).
intro.
unfold ICol in H1.
spliter.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
unfold IT in *.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
exists A.
split.
apply Ibetween_symmetry in H1.
induction H.
induction H.
subst.

*****
H8 : not (eq C P)
H7 : not (eq P P)
H6 : not (eq C Q)
H5 : not (eq B Q)
H4 : not (eq B C)
H1 : IBet B P C
H2 : not (eq P B)
H3 : not (eq P C)
H0 : BetT B Q C
B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
BetT P P B
+++++
unfold BetT.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
elim (eq_dec A P).
intro.
elim (eq_dec C P).
intro.
unfold ICol in H1.
spliter.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
unfold IT in *.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
exists A.
split.
apply Ibetween_symmetry in H1.
induction H.
induction H.
subst.
unfold BetT.

*****
H8 : not (eq C P)
H7 : not (eq P P)
H6 : not (eq C Q)
H5 : not (eq B Q)
H4 : not (eq B C)
H1 : IBet B P C
H2 : not (eq P B)
H3 : not (eq P C)
H0 : BetT B Q C
B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
or (IBet P P B) (or (eq P P) (eq P B))
+++++
auto.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
elim (eq_dec A P).
intro.
elim (eq_dec C P).
intro.
unfold ICol in H1.
spliter.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
unfold IT in *.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
exists A.
split.
apply Ibetween_symmetry in H1.
induction H.
induction H.

*****
H8 : not (eq C P)
H7 : not (eq A P)
H6 : not (eq C Q)
H5 : not (eq B Q)
H4 : not (eq B C)
H3 : not (eq A C)
H2 : not (eq A B)
H1 : IBet B A C
H0 : BetT B Q C
H : eq P C
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
BetT P A B
+++++
subst.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
elim (eq_dec A P).
intro.
elim (eq_dec C P).
intro.
unfold ICol in H1.
spliter.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
unfold IT in *.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
exists A.
split.
apply Ibetween_symmetry in H1.
induction H.
induction H.
subst.

*****
H7 : not (eq A C)
H8 : not (eq C C)
H6 : not (eq C Q)
H5 : not (eq B Q)
H4 : not (eq B C)
H3 : not (eq A C)
H2 : not (eq A B)
H1 : IBet B A C
H0 : BetT B Q C
A,B,C,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
BetT C A B
+++++
left.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
elim (eq_dec A P).
intro.
elim (eq_dec C P).
intro.
unfold ICol in H1.
spliter.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
unfold IT in *.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
exists A.
split.
apply Ibetween_symmetry in H1.
induction H.
induction H.
subst.
left.

*****
H7 : not (eq A C)
H8 : not (eq C C)
H6 : not (eq C Q)
H5 : not (eq B Q)
H4 : not (eq B C)
H3 : not (eq A C)
H2 : not (eq A B)
H1 : IBet B A C
H0 : BetT B Q C
A,B,C,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
IBet C A B
+++++
apply Ibetween_symmetry.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
elim (eq_dec A P).
intro.
elim (eq_dec C P).
intro.
unfold ICol in H1.
spliter.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
unfold IT in *.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
exists A.
split.
apply Ibetween_symmetry in H1.
induction H.
induction H.
subst.
left.
apply Ibetween_symmetry.

*****
H7 : not (eq A C)
H8 : not (eq C C)
H6 : not (eq C Q)
H5 : not (eq B Q)
H4 : not (eq B C)
H3 : not (eq A C)
H2 : not (eq A B)
H1 : IBet B A C
H0 : BetT B Q C
A,B,C,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
IBet B A C
+++++
auto.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
elim (eq_dec A P).
intro.
elim (eq_dec C P).
intro.
unfold ICol in H1.
spliter.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
unfold IT in *.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
exists A.
split.

*****
H8 : not (eq C P)
H7 : not (eq A P)
H6 : not (eq C Q)
H5 : not (eq B Q)
H4 : not (eq B C)
H3 : not (eq A C)
H2 : not (eq A B)
H1 : IBet C A B
H0 : BetT B Q C
H : BetT A P C
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
BetT Q A A
+++++
unfold BetT.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
elim (eq_dec A P).
intro.
elim (eq_dec C P).
intro.
unfold ICol in H1.
spliter.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
unfold IT in *.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
exists A.
split.
unfold BetT.

*****
H8 : not (eq C P)
H7 : not (eq A P)
H6 : not (eq C Q)
H5 : not (eq B Q)
H4 : not (eq B C)
H3 : not (eq A C)
H2 : not (eq A B)
H1 : IBet C A B
H0 : BetT B Q C
H : BetT A P C
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
or (IBet Q A A) (or (eq Q A) (eq A A))
+++++
auto.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
elim (eq_dec A P).
intro.
elim (eq_dec C P).
intro.
unfold ICol in H1.
spliter.
apply not_and_or in H1.
induction H1.

*****
H8 : not (eq C P)
H7 : not (eq A P)
H6 : not (eq C Q)
H5 : not (eq B Q)
H4 : not (eq B C)
H3 : not (eq A C)
H2 : not (eq A B)
H1 : not (and (not (IT A C B)) (not (IT A B C)))
H0 : BetT B Q C
H : BetT A P C
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
ex (fun x : ITpoint => and (BetT P x B) (BetT Q x A))
+++++
apply not_and_or in H1.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
elim (eq_dec A P).
intro.
elim (eq_dec C P).
intro.
unfold ICol in H1.
spliter.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.

*****
H8 : not (eq C P)
H7 : not (eq A P)
H6 : not (eq C Q)
H5 : not (eq B Q)
H4 : not (eq B C)
H3 : not (eq A C)
H2 : not (eq A B)
H1 : or (not (not (IT A C B))) (not (not (IT A B C)))
H0 : BetT B Q C
H : BetT A P C
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
ex (fun x : ITpoint => and (BetT P x B) (BetT Q x A))
+++++
induction H1.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
elim (eq_dec A P).
intro.
elim (eq_dec C P).
intro.
unfold ICol in H1.
spliter.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.

*****
H8 : not (eq C P)
H7 : not (eq A P)
H6 : not (eq C Q)
H5 : not (eq B Q)
H4 : not (eq B C)
H3 : not (eq A C)
H2 : not (eq A B)
H1 : not (not (IT A C B))
H0 : BetT B Q C
H : BetT A P C
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
ex (fun x : ITpoint => and (BetT P x B) (BetT Q x A))
+++++
apply NNPP in H1.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
elim (eq_dec A P).
intro.
elim (eq_dec C P).
intro.
unfold ICol in H1.
spliter.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.

*****
H8 : not (eq C P)
H7 : not (eq A P)
H6 : not (eq C Q)
H5 : not (eq B Q)
H4 : not (eq B C)
H3 : not (eq A C)
H2 : not (eq A B)
H1 : IT A C B
H0 : BetT B Q C
H : BetT A P C
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
ex (fun x : ITpoint => and (BetT P x B) (BetT Q x A))
+++++
unfold IT in H1.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
elim (eq_dec A P).
intro.
elim (eq_dec C P).
intro.
unfold ICol in H1.
spliter.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
unfold IT in H1.

*****
H8 : not (eq C P)
H7 : not (eq A P)
H6 : not (eq C Q)
H5 : not (eq B Q)
H4 : not (eq B C)
H3 : not (eq A C)
H2 : not (eq A B)
H1 : not (and (not (eq A C)) (and (not (eq C B)) (not (IBet A C B))))
H0 : BetT B Q C
H : BetT A P C
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
ex (fun x : ITpoint => and (BetT P x B) (BetT Q x A))
+++++
apply not_and_or in H1.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
elim (eq_dec A P).
intro.
elim (eq_dec C P).
intro.
unfold ICol in H1.
spliter.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
unfold IT in H1.
apply not_and_or in H1.

*****
H8 : not (eq C P)
H7 : not (eq A P)
H6 : not (eq C Q)
H5 : not (eq B Q)
H4 : not (eq B C)
H3 : not (eq A C)
H2 : not (eq A B)
H1 : or (not (not (eq A C))) (not (and (not (eq C B)) (not (IBet A C B))))
H0 : BetT B Q C
H : BetT A P C
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
ex (fun x : ITpoint => and (BetT P x B) (BetT Q x A))
+++++
induction H1.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
elim (eq_dec A P).
intro.
elim (eq_dec C P).
intro.
unfold ICol in H1.
spliter.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
unfold IT in H1.
apply not_and_or in H1.
induction H1.

*****
H8 : not (eq C P)
H7 : not (eq A P)
H6 : not (eq C Q)
H5 : not (eq B Q)
H4 : not (eq B C)
H3 : not (eq A C)
H2 : not (eq A B)
H1 : not (not (eq A C))
H0 : BetT B Q C
H : BetT A P C
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
ex (fun x : ITpoint => and (BetT P x B) (BetT Q x A))
+++++
apply NNPP in H1.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
elim (eq_dec A P).
intro.
elim (eq_dec C P).
intro.
unfold ICol in H1.
spliter.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
unfold IT in H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.

*****
H8 : not (eq C P)
H7 : not (eq A P)
H6 : not (eq C Q)
H5 : not (eq B Q)
H4 : not (eq B C)
H3 : not (eq A C)
H2 : not (eq A B)
H1 : eq A C
H0 : BetT B Q C
H : BetT A P C
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
ex (fun x : ITpoint => and (BetT P x B) (BetT Q x A))
+++++
subst.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
elim (eq_dec A P).
intro.
elim (eq_dec C P).
intro.
unfold ICol in H1.
spliter.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
unfold IT in H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
subst.

*****
H7,H8 : not (eq C P)
H6 : not (eq C Q)
H5 : not (eq B Q)
H4 : not (eq B C)
H2 : not (eq C B)
H3 : not (eq C C)
H0 : BetT B Q C
H : BetT C P C
B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
ex (fun x : ITpoint => and (BetT P x B) (BetT Q x C))
+++++
intuition.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
elim (eq_dec A P).
intro.
elim (eq_dec C P).
intro.
unfold ICol in H1.
spliter.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
unfold IT in H1.
apply not_and_or in H1.
induction H1.

*****
H8 : not (eq C P)
H7 : not (eq A P)
H6 : not (eq C Q)
H5 : not (eq B Q)
H4 : not (eq B C)
H3 : not (eq A C)
H2 : not (eq A B)
H1 : not (and (not (eq C B)) (not (IBet A C B)))
H0 : BetT B Q C
H : BetT A P C
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
ex (fun x : ITpoint => and (BetT P x B) (BetT Q x A))
+++++
apply not_and_or in H1.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
elim (eq_dec A P).
intro.
elim (eq_dec C P).
intro.
unfold ICol in H1.
spliter.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
unfold IT in H1.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.

*****
H8 : not (eq C P)
H7 : not (eq A P)
H6 : not (eq C Q)
H5 : not (eq B Q)
H4 : not (eq B C)
H3 : not (eq A C)
H2 : not (eq A B)
H1 : or (not (not (eq C B))) (not (not (IBet A C B)))
H0 : BetT B Q C
H : BetT A P C
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
ex (fun x : ITpoint => and (BetT P x B) (BetT Q x A))
+++++
induction H1.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
elim (eq_dec A P).
intro.
elim (eq_dec C P).
intro.
unfold ICol in H1.
spliter.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
unfold IT in H1.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.

*****
H8 : not (eq C P)
H7 : not (eq A P)
H6 : not (eq C Q)
H5 : not (eq B Q)
H4 : not (eq B C)
H3 : not (eq A C)
H2 : not (eq A B)
H1 : not (not (eq C B))
H0 : BetT B Q C
H : BetT A P C
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
ex (fun x : ITpoint => and (BetT P x B) (BetT Q x A))
+++++
apply NNPP in H1.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
elim (eq_dec A P).
intro.
elim (eq_dec C P).
intro.
unfold ICol in H1.
spliter.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
unfold IT in H1.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.

*****
H8 : not (eq C P)
H7 : not (eq A P)
H6 : not (eq C Q)
H5 : not (eq B Q)
H4 : not (eq B C)
H3 : not (eq A C)
H2 : not (eq A B)
H1 : eq C B
H0 : BetT B Q C
H : BetT A P C
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
ex (fun x : ITpoint => and (BetT P x B) (BetT Q x A))
+++++
subst.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
elim (eq_dec A P).
intro.
elim (eq_dec C P).
intro.
unfold ICol in H1.
spliter.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
unfold IT in H1.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
subst.

*****
H8 : not (eq B P)
H7 : not (eq A P)
H5,H6 : not (eq B Q)
H3 : not (eq A B)
H4 : not (eq B B)
H2 : not (eq A B)
H : BetT A P B
H0 : BetT B Q B
A,B,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
ex (fun x : ITpoint => and (BetT P x B) (BetT Q x A))
+++++
intuition.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
elim (eq_dec A P).
intro.
elim (eq_dec C P).
intro.
unfold ICol in H1.
spliter.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
unfold IT in H1.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.

*****
H8 : not (eq C P)
H7 : not (eq A P)
H6 : not (eq C Q)
H5 : not (eq B Q)
H4 : not (eq B C)
H3 : not (eq A C)
H2 : not (eq A B)
H1 : not (not (IBet A C B))
H0 : BetT B Q C
H : BetT A P C
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
ex (fun x : ITpoint => and (BetT P x B) (BetT Q x A))
+++++
apply NNPP in H1.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
elim (eq_dec A P).
intro.
elim (eq_dec C P).
intro.
unfold ICol in H1.
spliter.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
unfold IT in H1.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.

*****
H8 : not (eq C P)
H7 : not (eq A P)
H6 : not (eq C Q)
H5 : not (eq B Q)
H4 : not (eq B C)
H3 : not (eq A C)
H2 : not (eq A B)
H1 : IBet A C B
H0 : BetT B Q C
H : BetT A P C
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
ex (fun x : ITpoint => and (BetT P x B) (BetT Q x A))
+++++
exists C.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
elim (eq_dec A P).
intro.
elim (eq_dec C P).
intro.
unfold ICol in H1.
spliter.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
unfold IT in H1.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
exists C.

*****
H8 : not (eq C P)
H7 : not (eq A P)
H6 : not (eq C Q)
H5 : not (eq B Q)
H4 : not (eq B C)
H3 : not (eq A C)
H2 : not (eq A B)
H1 : IBet A C B
H0 : BetT B Q C
H : BetT A P C
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
and (BetT P C B) (BetT Q C A)
+++++
unfold BetT in H.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
elim (eq_dec A P).
intro.
elim (eq_dec C P).
intro.
unfold ICol in H1.
spliter.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
unfold IT in H1.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
exists C.
unfold BetT in H.

*****
H8 : not (eq C P)
H7 : not (eq A P)
H6 : not (eq C Q)
H5 : not (eq B Q)
H4 : not (eq B C)
H3 : not (eq A C)
H2 : not (eq A B)
H1 : IBet A C B
H0 : BetT B Q C
H : or (IBet A P C) (or (eq A P) (eq P C))
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
and (BetT P C B) (BetT Q C A)
+++++
induction H.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
elim (eq_dec A P).
intro.
elim (eq_dec C P).
intro.
unfold ICol in H1.
spliter.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
unfold IT in H1.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
exists C.
unfold BetT in H.
induction H.

*****
H8 : not (eq C P)
H7 : not (eq A P)
H6 : not (eq C Q)
H5 : not (eq B Q)
H4 : not (eq B C)
H3 : not (eq A C)
H2 : not (eq A B)
H1 : IBet A C B
H0 : BetT B Q C
H : IBet A P C
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
and (BetT P C B) (BetT Q C A)
+++++
induction H0.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
elim (eq_dec A P).
intro.
elim (eq_dec C P).
intro.
unfold ICol in H1.
spliter.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
unfold IT in H1.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
exists C.
unfold BetT in H.
induction H.
induction H0.

*****
H8 : not (eq C P)
H7 : not (eq A P)
H6 : not (eq C Q)
H5 : not (eq B Q)
H4 : not (eq B C)
H3 : not (eq A C)
H2 : not (eq A B)
H1 : IBet A C B
H0 : IBet B Q C
H : IBet A P C
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
and (BetT P C B) (BetT Q C A)
+++++
split.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
elim (eq_dec A P).
intro.
elim (eq_dec C P).
intro.
unfold ICol in H1.
spliter.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
unfold IT in H1.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
exists C.
unfold BetT in H.
induction H.
induction H0.
split.

*****
H8 : not (eq C P)
H7 : not (eq A P)
H6 : not (eq C Q)
H5 : not (eq B Q)
H4 : not (eq B C)
H3 : not (eq A C)
H2 : not (eq A B)
H1 : IBet A C B
H0 : IBet B Q C
H : IBet A P C
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
BetT P C B
+++++
apply BetT_symmetry.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
elim (eq_dec A P).
intro.
elim (eq_dec C P).
intro.
unfold ICol in H1.
spliter.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
unfold IT in H1.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
exists C.
unfold BetT in H.
induction H.
induction H0.
split.
apply BetT_symmetry.

*****
H8 : not (eq C P)
H7 : not (eq A P)
H6 : not (eq C Q)
H5 : not (eq B Q)
H4 : not (eq B C)
H3 : not (eq A C)
H2 : not (eq A B)
H1 : IBet A C B
H0 : IBet B Q C
H : IBet A P C
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
BetT B C P
+++++
left.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
elim (eq_dec A P).
intro.
elim (eq_dec C P).
intro.
unfold ICol in H1.
spliter.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
unfold IT in H1.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
exists C.
unfold BetT in H.
induction H.
induction H0.
split.
apply BetT_symmetry.
left.

*****
H8 : not (eq C P)
H7 : not (eq A P)
H6 : not (eq C Q)
H5 : not (eq B Q)
H4 : not (eq B C)
H3 : not (eq A C)
H2 : not (eq A B)
H1 : IBet A C B
H0 : IBet B Q C
H : IBet A P C
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
IBet B C P
+++++
apply Ibetween_inner_transitivity with A.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
elim (eq_dec A P).
intro.
elim (eq_dec C P).
intro.
unfold ICol in H1.
spliter.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
unfold IT in H1.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
exists C.
unfold BetT in H.
induction H.
induction H0.
split.
apply BetT_symmetry.
left.
apply Ibetween_inner_transitivity with A.

*****
H8 : not (eq C P)
H7 : not (eq A P)
H6 : not (eq C Q)
H5 : not (eq B Q)
H4 : not (eq B C)
H3 : not (eq A C)
H2 : not (eq A B)
H1 : IBet A C B
H0 : IBet B Q C
H : IBet A P C
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
IBet B C A
+++++
apply Ibetween_symmetry.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
elim (eq_dec A P).
intro.
elim (eq_dec C P).
intro.
unfold ICol in H1.
spliter.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
unfold IT in H1.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
exists C.
unfold BetT in H.
induction H.
induction H0.
split.
apply BetT_symmetry.
left.
apply Ibetween_inner_transitivity with A.
apply Ibetween_symmetry.

*****
H8 : not (eq C P)
H7 : not (eq A P)
H6 : not (eq C Q)
H5 : not (eq B Q)
H4 : not (eq B C)
H3 : not (eq A C)
H2 : not (eq A B)
H1 : IBet A C B
H0 : IBet B Q C
H : IBet A P C
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
IBet A C B
+++++
auto.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
elim (eq_dec A P).
intro.
elim (eq_dec C P).
intro.
unfold ICol in H1.
spliter.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
unfold IT in H1.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
exists C.
unfold BetT in H.
induction H.
induction H0.
split.
apply BetT_symmetry.
left.
apply Ibetween_inner_transitivity with A.

*****
H8 : not (eq C P)
H7 : not (eq A P)
H6 : not (eq C Q)
H5 : not (eq B Q)
H4 : not (eq B C)
H3 : not (eq A C)
H2 : not (eq A B)
H1 : IBet A C B
H0 : IBet B Q C
H : IBet A P C
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
IBet C P A
+++++
apply Ibetween_symmetry.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
elim (eq_dec A P).
intro.
elim (eq_dec C P).
intro.
unfold ICol in H1.
spliter.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
unfold IT in H1.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
exists C.
unfold BetT in H.
induction H.
induction H0.
split.
apply BetT_symmetry.
left.
apply Ibetween_inner_transitivity with A.
apply Ibetween_symmetry.

*****
H8 : not (eq C P)
H7 : not (eq A P)
H6 : not (eq C Q)
H5 : not (eq B Q)
H4 : not (eq B C)
H3 : not (eq A C)
H2 : not (eq A B)
H1 : IBet A C B
H0 : IBet B Q C
H : IBet A P C
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
IBet A P C
+++++
auto.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
elim (eq_dec A P).
intro.
elim (eq_dec C P).
intro.
unfold ICol in H1.
spliter.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
unfold IT in H1.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
exists C.
unfold BetT in H.
induction H.
induction H0.
split.

*****
H8 : not (eq C P)
H7 : not (eq A P)
H6 : not (eq C Q)
H5 : not (eq B Q)
H4 : not (eq B C)
H3 : not (eq A C)
H2 : not (eq A B)
H1 : IBet A C B
H0 : IBet B Q C
H : IBet A P C
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
BetT Q C A
+++++
apply BetT_symmetry.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
elim (eq_dec A P).
intro.
elim (eq_dec C P).
intro.
unfold ICol in H1.
spliter.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
unfold IT in H1.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
exists C.
unfold BetT in H.
induction H.
induction H0.
split.
apply BetT_symmetry.

*****
H8 : not (eq C P)
H7 : not (eq A P)
H6 : not (eq C Q)
H5 : not (eq B Q)
H4 : not (eq B C)
H3 : not (eq A C)
H2 : not (eq A B)
H1 : IBet A C B
H0 : IBet B Q C
H : IBet A P C
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
BetT A C Q
+++++
left.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
elim (eq_dec A P).
intro.
elim (eq_dec C P).
intro.
unfold ICol in H1.
spliter.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
unfold IT in H1.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
exists C.
unfold BetT in H.
induction H.
induction H0.
split.
apply BetT_symmetry.
left.

*****
H8 : not (eq C P)
H7 : not (eq A P)
H6 : not (eq C Q)
H5 : not (eq B Q)
H4 : not (eq B C)
H3 : not (eq A C)
H2 : not (eq A B)
H1 : IBet A C B
H0 : IBet B Q C
H : IBet A P C
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
IBet A C Q
+++++
apply Ibetween_inner_transitivity with B.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
elim (eq_dec A P).
intro.
elim (eq_dec C P).
intro.
unfold ICol in H1.
spliter.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
unfold IT in H1.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
exists C.
unfold BetT in H.
induction H.
induction H0.
split.
apply BetT_symmetry.
left.
apply Ibetween_inner_transitivity with B.

*****
H8 : not (eq C P)
H7 : not (eq A P)
H6 : not (eq C Q)
H5 : not (eq B Q)
H4 : not (eq B C)
H3 : not (eq A C)
H2 : not (eq A B)
H1 : IBet A C B
H0 : IBet B Q C
H : IBet A P C
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
IBet A C B
+++++
assumption.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
elim (eq_dec A P).
intro.
elim (eq_dec C P).
intro.
unfold ICol in H1.
spliter.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
unfold IT in H1.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
exists C.
unfold BetT in H.
induction H.
induction H0.
split.
apply BetT_symmetry.
left.
apply Ibetween_inner_transitivity with B.

*****
H8 : not (eq C P)
H7 : not (eq A P)
H6 : not (eq C Q)
H5 : not (eq B Q)
H4 : not (eq B C)
H3 : not (eq A C)
H2 : not (eq A B)
H1 : IBet A C B
H0 : IBet B Q C
H : IBet A P C
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
IBet C Q B
+++++
apply Ibetween_symmetry.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
elim (eq_dec A P).
intro.
elim (eq_dec C P).
intro.
unfold ICol in H1.
spliter.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
unfold IT in H1.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
exists C.
unfold BetT in H.
induction H.
induction H0.
split.
apply BetT_symmetry.
left.
apply Ibetween_inner_transitivity with B.
apply Ibetween_symmetry.

*****
H8 : not (eq C P)
H7 : not (eq A P)
H6 : not (eq C Q)
H5 : not (eq B Q)
H4 : not (eq B C)
H3 : not (eq A C)
H2 : not (eq A B)
H1 : IBet A C B
H0 : IBet B Q C
H : IBet A P C
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
IBet B Q C
+++++
auto.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
elim (eq_dec A P).
intro.
elim (eq_dec C P).
intro.
unfold ICol in H1.
spliter.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
unfold IT in H1.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
exists C.
unfold BetT in H.
induction H.
induction H0.

*****
H8 : not (eq C P)
H7 : not (eq A P)
H6 : not (eq C Q)
H5 : not (eq B Q)
H4 : not (eq B C)
H3 : not (eq A C)
H2 : not (eq A B)
H1 : IBet A C B
H0 : or (eq B Q) (eq Q C)
H : IBet A P C
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
and (BetT P C B) (BetT Q C A)
+++++
induction H0.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
elim (eq_dec A P).
intro.
elim (eq_dec C P).
intro.
unfold ICol in H1.
spliter.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
unfold IT in H1.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
exists C.
unfold BetT in H.
induction H.
induction H0.
induction H0.

*****
H8 : not (eq C P)
H7 : not (eq A P)
H6 : not (eq C Q)
H5 : not (eq B Q)
H4 : not (eq B C)
H3 : not (eq A C)
H2 : not (eq A B)
H1 : IBet A C B
H0 : eq B Q
H : IBet A P C
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
and (BetT P C B) (BetT Q C A)
+++++
subst.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
elim (eq_dec A P).
intro.
elim (eq_dec C P).
intro.
unfold ICol in H1.
spliter.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
unfold IT in H1.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
exists C.
unfold BetT in H.
induction H.
induction H0.
induction H0.
subst.

*****
H8 : not (eq C P)
H7 : not (eq A P)
H6 : not (eq C Q)
H4 : not (eq Q C)
H5 : not (eq Q Q)
H3 : not (eq A C)
H1 : IBet A C Q
H2 : not (eq A Q)
H : IBet A P C
A,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
and (BetT P C Q) (BetT Q C A)
+++++
intuition.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
elim (eq_dec A P).
intro.
elim (eq_dec C P).
intro.
unfold ICol in H1.
spliter.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
unfold IT in H1.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
exists C.
unfold BetT in H.
induction H.
induction H0.
induction H0.

*****
H8 : not (eq C P)
H7 : not (eq A P)
H6 : not (eq C Q)
H5 : not (eq B Q)
H4 : not (eq B C)
H3 : not (eq A C)
H2 : not (eq A B)
H1 : IBet A C B
H0 : eq Q C
H : IBet A P C
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
and (BetT P C B) (BetT Q C A)
+++++
subst.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
elim (eq_dec A P).
intro.
elim (eq_dec C P).
intro.
unfold ICol in H1.
spliter.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
unfold IT in H1.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
exists C.
unfold BetT in H.
induction H.
induction H0.
induction H0.
subst.

*****
H8 : not (eq C P)
H7 : not (eq A P)
H5 : not (eq B C)
H6 : not (eq C C)
H4 : not (eq B C)
H3 : not (eq A C)
H2 : not (eq A B)
H1 : IBet A C B
H : IBet A P C
A,B,C,P : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
and (BetT P C B) (BetT C C A)
+++++
intuition.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
elim (eq_dec A P).
intro.
elim (eq_dec C P).
intro.
unfold ICol in H1.
spliter.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
unfold IT in H1.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
exists C.
unfold BetT in H.
induction H.

*****
H8 : not (eq C P)
H7 : not (eq A P)
H6 : not (eq C Q)
H5 : not (eq B Q)
H4 : not (eq B C)
H3 : not (eq A C)
H2 : not (eq A B)
H1 : IBet A C B
H0 : BetT B Q C
H : or (eq A P) (eq P C)
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
and (BetT P C B) (BetT Q C A)
+++++
induction H0.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
elim (eq_dec A P).
intro.
elim (eq_dec C P).
intro.
unfold ICol in H1.
spliter.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
unfold IT in H1.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
exists C.
unfold BetT in H.
induction H.
induction H0.

*****
H8 : not (eq C P)
H7 : not (eq A P)
H6 : not (eq C Q)
H5 : not (eq B Q)
H4 : not (eq B C)
H3 : not (eq A C)
H2 : not (eq A B)
H1 : IBet A C B
H0 : IBet B Q C
H : or (eq A P) (eq P C)
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
and (BetT P C B) (BetT Q C A)
+++++
induction H.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
elim (eq_dec A P).
intro.
elim (eq_dec C P).
intro.
unfold ICol in H1.
spliter.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
unfold IT in H1.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
exists C.
unfold BetT in H.
induction H.
induction H0.
induction H.

*****
H8 : not (eq C P)
H7 : not (eq A P)
H6 : not (eq C Q)
H5 : not (eq B Q)
H4 : not (eq B C)
H3 : not (eq A C)
H2 : not (eq A B)
H1 : IBet A C B
H0 : IBet B Q C
H : eq A P
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
and (BetT P C B) (BetT Q C A)
+++++
subst.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
elim (eq_dec A P).
intro.
elim (eq_dec C P).
intro.
unfold ICol in H1.
spliter.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
unfold IT in H1.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
exists C.
unfold BetT in H.
induction H.
induction H0.
induction H.
subst.

*****
H8 : not (eq C P)
H7 : not (eq P P)
H6 : not (eq C Q)
H5 : not (eq B Q)
H4 : not (eq B C)
H1 : IBet P C B
H2 : not (eq P B)
H3 : not (eq P C)
H0 : IBet B Q C
B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
and (BetT P C B) (BetT Q C P)
+++++
intuition.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
elim (eq_dec A P).
intro.
elim (eq_dec C P).
intro.
unfold ICol in H1.
spliter.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
unfold IT in H1.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
exists C.
unfold BetT in H.
induction H.
induction H0.
induction H.

*****
H8 : not (eq C P)
H7 : not (eq A P)
H6 : not (eq C Q)
H5 : not (eq B Q)
H4 : not (eq B C)
H3 : not (eq A C)
H2 : not (eq A B)
H1 : IBet A C B
H0 : IBet B Q C
H : eq P C
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
and (BetT P C B) (BetT Q C A)
+++++
subst.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
elim (eq_dec A P).
intro.
elim (eq_dec C P).
intro.
unfold ICol in H1.
spliter.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
unfold IT in H1.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
exists C.
unfold BetT in H.
induction H.
induction H0.
induction H.
subst.

*****
H7 : not (eq A C)
H8 : not (eq C C)
H6 : not (eq C Q)
H5 : not (eq B Q)
H4 : not (eq B C)
H3 : not (eq A C)
H2 : not (eq A B)
H1 : IBet A C B
H0 : IBet B Q C
A,B,C,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
and (BetT C C B) (BetT Q C A)
+++++
intuition.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
elim (eq_dec A P).
intro.
elim (eq_dec C P).
intro.
unfold ICol in H1.
spliter.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
unfold IT in H1.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
exists C.
unfold BetT in H.
induction H.
induction H0.

*****
H8 : not (eq C P)
H7 : not (eq A P)
H6 : not (eq C Q)
H5 : not (eq B Q)
H4 : not (eq B C)
H3 : not (eq A C)
H2 : not (eq A B)
H1 : IBet A C B
H0 : or (eq B Q) (eq Q C)
H : or (eq A P) (eq P C)
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
and (BetT P C B) (BetT Q C A)
+++++
induction H.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
elim (eq_dec A P).
intro.
elim (eq_dec C P).
intro.
unfold ICol in H1.
spliter.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
unfold IT in H1.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
exists C.
unfold BetT in H.
induction H.
induction H0.
induction H.

*****
H8 : not (eq C P)
H7 : not (eq A P)
H6 : not (eq C Q)
H5 : not (eq B Q)
H4 : not (eq B C)
H3 : not (eq A C)
H2 : not (eq A B)
H1 : IBet A C B
H0 : or (eq B Q) (eq Q C)
H : eq A P
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
and (BetT P C B) (BetT Q C A)
+++++
subst.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
elim (eq_dec A P).
intro.
elim (eq_dec C P).
intro.
unfold ICol in H1.
spliter.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
unfold IT in H1.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
exists C.
unfold BetT in H.
induction H.
induction H0.
induction H.
subst.

*****
H8 : not (eq C P)
H7 : not (eq P P)
H6 : not (eq C Q)
H5 : not (eq B Q)
H4 : not (eq B C)
H1 : IBet P C B
H2 : not (eq P B)
H3 : not (eq P C)
H0 : or (eq B Q) (eq Q C)
B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
and (BetT P C B) (BetT Q C P)
+++++
intuition.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
elim (eq_dec A P).
intro.
elim (eq_dec C P).
intro.
unfold ICol in H1.
spliter.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
unfold IT in H1.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
exists C.
unfold BetT in H.
induction H.
induction H0.
induction H.

*****
H8 : not (eq C P)
H7 : not (eq A P)
H6 : not (eq C Q)
H5 : not (eq B Q)
H4 : not (eq B C)
H3 : not (eq A C)
H2 : not (eq A B)
H1 : IBet A C B
H0 : or (eq B Q) (eq Q C)
H : eq P C
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
and (BetT P C B) (BetT Q C A)
+++++
subst.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
elim (eq_dec A P).
intro.
elim (eq_dec C P).
intro.
unfold ICol in H1.
spliter.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
unfold IT in H1.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
exists C.
unfold BetT in H.
induction H.
induction H0.
induction H.
subst.

*****
H7 : not (eq A C)
H8 : not (eq C C)
H6 : not (eq C Q)
H5 : not (eq B Q)
H4 : not (eq B C)
H3 : not (eq A C)
H2 : not (eq A B)
H1 : IBet A C B
H0 : or (eq B Q) (eq Q C)
A,B,C,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
and (BetT C C B) (BetT Q C A)
+++++
intuition.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
elim (eq_dec A P).
intro.
elim (eq_dec C P).
intro.
unfold ICol in H1.
spliter.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.

*****
H8 : not (eq C P)
H7 : not (eq A P)
H6 : not (eq C Q)
H5 : not (eq B Q)
H4 : not (eq B C)
H3 : not (eq A C)
H2 : not (eq A B)
H1 : not (not (IT A B C))
H0 : BetT B Q C
H : BetT A P C
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
ex (fun x : ITpoint => and (BetT P x B) (BetT Q x A))
+++++
apply NNPP in H1.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
elim (eq_dec A P).
intro.
elim (eq_dec C P).
intro.
unfold ICol in H1.
spliter.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.

*****
H8 : not (eq C P)
H7 : not (eq A P)
H6 : not (eq C Q)
H5 : not (eq B Q)
H4 : not (eq B C)
H3 : not (eq A C)
H2 : not (eq A B)
H1 : IT A B C
H0 : BetT B Q C
H : BetT A P C
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
ex (fun x : ITpoint => and (BetT P x B) (BetT Q x A))
+++++
induction H.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
elim (eq_dec A P).
intro.
elim (eq_dec C P).
intro.
unfold ICol in H1.
spliter.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
induction H.

*****
H8 : not (eq C P)
H7 : not (eq A P)
H6 : not (eq C Q)
H5 : not (eq B Q)
H4 : not (eq B C)
H3 : not (eq A C)
H2 : not (eq A B)
H1 : IT A B C
H0 : BetT B Q C
H : IBet A P C
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
ex (fun x : ITpoint => and (BetT P x B) (BetT Q x A))
+++++
induction H0.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
elim (eq_dec A P).
intro.
elim (eq_dec C P).
intro.
unfold ICol in H1.
spliter.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
induction H.
induction H0.

*****
H8 : not (eq C P)
H7 : not (eq A P)
H6 : not (eq C Q)
H5 : not (eq B Q)
H4 : not (eq B C)
H3 : not (eq A C)
H2 : not (eq A B)
H1 : IT A B C
H0 : IBet B Q C
H : IBet A P C
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
ex (fun x : ITpoint => and (BetT P x B) (BetT Q x A))
+++++
exists B.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
elim (eq_dec A P).
intro.
elim (eq_dec C P).
intro.
unfold ICol in H1.
spliter.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
induction H.
induction H0.
exists B.

*****
H8 : not (eq C P)
H7 : not (eq A P)
H6 : not (eq C Q)
H5 : not (eq B Q)
H4 : not (eq B C)
H3 : not (eq A C)
H2 : not (eq A B)
H1 : IT A B C
H0 : IBet B Q C
H : IBet A P C
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
and (BetT P B B) (BetT Q B A)
+++++
split.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
elim (eq_dec A P).
intro.
elim (eq_dec C P).
intro.
unfold ICol in H1.
spliter.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
induction H.
induction H0.
exists B.
split.

*****
H8 : not (eq C P)
H7 : not (eq A P)
H6 : not (eq C Q)
H5 : not (eq B Q)
H4 : not (eq B C)
H3 : not (eq A C)
H2 : not (eq A B)
H1 : IT A B C
H0 : IBet B Q C
H : IBet A P C
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
BetT P B B
+++++
unfold BetT.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
elim (eq_dec A P).
intro.
elim (eq_dec C P).
intro.
unfold ICol in H1.
spliter.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
induction H.
induction H0.
exists B.
split.
unfold BetT.

*****
H8 : not (eq C P)
H7 : not (eq A P)
H6 : not (eq C Q)
H5 : not (eq B Q)
H4 : not (eq B C)
H3 : not (eq A C)
H2 : not (eq A B)
H1 : IT A B C
H0 : IBet B Q C
H : IBet A P C
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
or (IBet P B B) (or (eq P B) (eq B B))
+++++
auto.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
elim (eq_dec A P).
intro.
elim (eq_dec C P).
intro.
unfold ICol in H1.
spliter.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
induction H.
induction H0.
exists B.
split.

*****
H8 : not (eq C P)
H7 : not (eq A P)
H6 : not (eq C Q)
H5 : not (eq B Q)
H4 : not (eq B C)
H3 : not (eq A C)
H2 : not (eq A B)
H1 : IT A B C
H0 : IBet B Q C
H : IBet A P C
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
BetT Q B A
+++++
left.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
elim (eq_dec A P).
intro.
elim (eq_dec C P).
intro.
unfold ICol in H1.
spliter.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
induction H.
induction H0.
exists B.
split.
left.

*****
H8 : not (eq C P)
H7 : not (eq A P)
H6 : not (eq C Q)
H5 : not (eq B Q)
H4 : not (eq B C)
H3 : not (eq A C)
H2 : not (eq A B)
H1 : IT A B C
H0 : IBet B Q C
H : IBet A P C
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
IBet Q B A
+++++
apply Ibetween_symmetry.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
elim (eq_dec A P).
intro.
elim (eq_dec C P).
intro.
unfold ICol in H1.
spliter.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
induction H.
induction H0.
exists B.
split.
left.
apply Ibetween_symmetry.

*****
H8 : not (eq C P)
H7 : not (eq A P)
H6 : not (eq C Q)
H5 : not (eq B Q)
H4 : not (eq B C)
H3 : not (eq A C)
H2 : not (eq A B)
H1 : IT A B C
H0 : IBet B Q C
H : IBet A P C
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
IBet A B Q
+++++
apply Ibetween_inner_transitivity with C.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
elim (eq_dec A P).
intro.
elim (eq_dec C P).
intro.
unfold ICol in H1.
spliter.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
induction H.
induction H0.
exists B.
split.
left.
apply Ibetween_symmetry.
apply Ibetween_inner_transitivity with C.

*****
H8 : not (eq C P)
H7 : not (eq A P)
H6 : not (eq C Q)
H5 : not (eq B Q)
H4 : not (eq B C)
H3 : not (eq A C)
H2 : not (eq A B)
H1 : IT A B C
H0 : IBet B Q C
H : IBet A P C
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
IBet A B C
+++++
unfold IT in H1.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
elim (eq_dec A P).
intro.
elim (eq_dec C P).
intro.
unfold ICol in H1.
spliter.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
induction H.
induction H0.
exists B.
split.
left.
apply Ibetween_symmetry.
apply Ibetween_inner_transitivity with C.
unfold IT in H1.

*****
H8 : not (eq C P)
H7 : not (eq A P)
H6 : not (eq C Q)
H5 : not (eq B Q)
H4 : not (eq B C)
H3 : not (eq A C)
H2 : not (eq A B)
H1 : not (and (not (eq A B)) (and (not (eq B C)) (not (IBet A B C))))
H0 : IBet B Q C
H : IBet A P C
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
IBet A B C
+++++
apply not_and_or in H1.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
elim (eq_dec A P).
intro.
elim (eq_dec C P).
intro.
unfold ICol in H1.
spliter.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
induction H.
induction H0.
exists B.
split.
left.
apply Ibetween_symmetry.
apply Ibetween_inner_transitivity with C.
unfold IT in H1.
apply not_and_or in H1.

*****
H8 : not (eq C P)
H7 : not (eq A P)
H6 : not (eq C Q)
H5 : not (eq B Q)
H4 : not (eq B C)
H3 : not (eq A C)
H2 : not (eq A B)
H1 : or (not (not (eq A B))) (not (and (not (eq B C)) (not (IBet A B C))))
H0 : IBet B Q C
H : IBet A P C
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
IBet A B C
+++++
induction H1.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
elim (eq_dec A P).
intro.
elim (eq_dec C P).
intro.
unfold ICol in H1.
spliter.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
induction H.
induction H0.
exists B.
split.
left.
apply Ibetween_symmetry.
apply Ibetween_inner_transitivity with C.
unfold IT in H1.
apply not_and_or in H1.
induction H1.

*****
H8 : not (eq C P)
H7 : not (eq A P)
H6 : not (eq C Q)
H5 : not (eq B Q)
H4 : not (eq B C)
H3 : not (eq A C)
H2 : not (eq A B)
H1 : not (not (eq A B))
H0 : IBet B Q C
H : IBet A P C
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
IBet A B C
+++++
apply NNPP in H1.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
elim (eq_dec A P).
intro.
elim (eq_dec C P).
intro.
unfold ICol in H1.
spliter.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
induction H.
induction H0.
exists B.
split.
left.
apply Ibetween_symmetry.
apply Ibetween_inner_transitivity with C.
unfold IT in H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.

*****
H8 : not (eq C P)
H7 : not (eq A P)
H6 : not (eq C Q)
H5 : not (eq B Q)
H4 : not (eq B C)
H3 : not (eq A C)
H2 : not (eq A B)
H1 : eq A B
H0 : IBet B Q C
H : IBet A P C
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
IBet A B C
+++++
subst.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
elim (eq_dec A P).
intro.
elim (eq_dec C P).
intro.
unfold ICol in H1.
spliter.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
induction H.
induction H0.
exists B.
split.
left.
apply Ibetween_symmetry.
apply Ibetween_inner_transitivity with C.
unfold IT in H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
subst.

*****
H8 : not (eq C P)
H7 : not (eq B P)
H6 : not (eq C Q)
H5 : not (eq B Q)
H4 : not (eq B C)
H2 : not (eq B B)
H3 : not (eq B C)
H0 : IBet B Q C
H : IBet B P C
B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
IBet B B C
+++++
intuition.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
elim (eq_dec A P).
intro.
elim (eq_dec C P).
intro.
unfold ICol in H1.
spliter.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
induction H.
induction H0.
exists B.
split.
left.
apply Ibetween_symmetry.
apply Ibetween_inner_transitivity with C.
unfold IT in H1.
apply not_and_or in H1.
induction H1.

*****
H8 : not (eq C P)
H7 : not (eq A P)
H6 : not (eq C Q)
H5 : not (eq B Q)
H4 : not (eq B C)
H3 : not (eq A C)
H2 : not (eq A B)
H1 : not (and (not (eq B C)) (not (IBet A B C)))
H0 : IBet B Q C
H : IBet A P C
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
IBet A B C
+++++
apply not_and_or in H1.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
elim (eq_dec A P).
intro.
elim (eq_dec C P).
intro.
unfold ICol in H1.
spliter.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
induction H.
induction H0.
exists B.
split.
left.
apply Ibetween_symmetry.
apply Ibetween_inner_transitivity with C.
unfold IT in H1.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.

*****
H8 : not (eq C P)
H7 : not (eq A P)
H6 : not (eq C Q)
H5 : not (eq B Q)
H4 : not (eq B C)
H3 : not (eq A C)
H2 : not (eq A B)
H1 : or (not (not (eq B C))) (not (not (IBet A B C)))
H0 : IBet B Q C
H : IBet A P C
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
IBet A B C
+++++
induction H1.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
elim (eq_dec A P).
intro.
elim (eq_dec C P).
intro.
unfold ICol in H1.
spliter.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
induction H.
induction H0.
exists B.
split.
left.
apply Ibetween_symmetry.
apply Ibetween_inner_transitivity with C.
unfold IT in H1.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.

*****
H8 : not (eq C P)
H7 : not (eq A P)
H6 : not (eq C Q)
H5 : not (eq B Q)
H4 : not (eq B C)
H3 : not (eq A C)
H2 : not (eq A B)
H1 : not (not (eq B C))
H0 : IBet B Q C
H : IBet A P C
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
IBet A B C
+++++
apply NNPP in H1.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
elim (eq_dec A P).
intro.
elim (eq_dec C P).
intro.
unfold ICol in H1.
spliter.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
induction H.
induction H0.
exists B.
split.
left.
apply Ibetween_symmetry.
apply Ibetween_inner_transitivity with C.
unfold IT in H1.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.

*****
H8 : not (eq C P)
H7 : not (eq A P)
H6 : not (eq C Q)
H5 : not (eq B Q)
H4 : not (eq B C)
H3 : not (eq A C)
H2 : not (eq A B)
H1 : eq B C
H0 : IBet B Q C
H : IBet A P C
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
IBet A B C
+++++
subst.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
elim (eq_dec A P).
intro.
elim (eq_dec C P).
intro.
unfold ICol in H1.
spliter.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
induction H.
induction H0.
exists B.
split.
left.
apply Ibetween_symmetry.
apply Ibetween_inner_transitivity with C.
unfold IT in H1.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
subst.

*****
H8 : not (eq C P)
H7 : not (eq A P)
H6 : not (eq C Q)
H4 : not (eq C C)
H5 : not (eq C Q)
H2,H3 : not (eq A C)
H0 : IBet C Q C
H : IBet A P C
A,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
IBet A C C
+++++
intuition.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
elim (eq_dec A P).
intro.
elim (eq_dec C P).
intro.
unfold ICol in H1.
spliter.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
induction H.
induction H0.
exists B.
split.
left.
apply Ibetween_symmetry.
apply Ibetween_inner_transitivity with C.
unfold IT in H1.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.

*****
H8 : not (eq C P)
H7 : not (eq A P)
H6 : not (eq C Q)
H5 : not (eq B Q)
H4 : not (eq B C)
H3 : not (eq A C)
H2 : not (eq A B)
H1 : not (not (IBet A B C))
H0 : IBet B Q C
H : IBet A P C
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
IBet A B C
+++++
apply NNPP in H1.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
elim (eq_dec A P).
intro.
elim (eq_dec C P).
intro.
unfold ICol in H1.
spliter.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
induction H.
induction H0.
exists B.
split.
left.
apply Ibetween_symmetry.
apply Ibetween_inner_transitivity with C.
unfold IT in H1.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.

*****
H8 : not (eq C P)
H7 : not (eq A P)
H6 : not (eq C Q)
H5 : not (eq B Q)
H4 : not (eq B C)
H3 : not (eq A C)
H2 : not (eq A B)
H1 : IBet A B C
H0 : IBet B Q C
H : IBet A P C
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
IBet A B C
+++++
assumption.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
elim (eq_dec A P).
intro.
elim (eq_dec C P).
intro.
unfold ICol in H1.
spliter.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
induction H.
induction H0.
exists B.
split.
left.
apply Ibetween_symmetry.
apply Ibetween_inner_transitivity with C.

*****
H8 : not (eq C P)
H7 : not (eq A P)
H6 : not (eq C Q)
H5 : not (eq B Q)
H4 : not (eq B C)
H3 : not (eq A C)
H2 : not (eq A B)
H1 : IT A B C
H0 : IBet B Q C
H : IBet A P C
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
IBet B Q C
+++++
assumption.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
elim (eq_dec A P).
intro.
elim (eq_dec C P).
intro.
unfold ICol in H1.
spliter.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
induction H.
induction H0.

*****
H8 : not (eq C P)
H7 : not (eq A P)
H6 : not (eq C Q)
H5 : not (eq B Q)
H4 : not (eq B C)
H3 : not (eq A C)
H2 : not (eq A B)
H1 : IT A B C
H0 : or (eq B Q) (eq Q C)
H : IBet A P C
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
ex (fun x : ITpoint => and (BetT P x B) (BetT Q x A))
+++++
induction H0.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
elim (eq_dec A P).
intro.
elim (eq_dec C P).
intro.
unfold ICol in H1.
spliter.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
induction H.
induction H0.
induction H0.

*****
H8 : not (eq C P)
H7 : not (eq A P)
H6 : not (eq C Q)
H5 : not (eq B Q)
H4 : not (eq B C)
H3 : not (eq A C)
H2 : not (eq A B)
H1 : IT A B C
H0 : eq B Q
H : IBet A P C
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
ex (fun x : ITpoint => and (BetT P x B) (BetT Q x A))
+++++
subst.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
elim (eq_dec A P).
intro.
elim (eq_dec C P).
intro.
unfold ICol in H1.
spliter.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
induction H.
induction H0.
induction H0.
subst.

*****
H8 : not (eq C P)
H7 : not (eq A P)
H6 : not (eq C Q)
H4 : not (eq Q C)
H5 : not (eq Q Q)
H3 : not (eq A C)
H1 : IT A Q C
H2 : not (eq A Q)
H : IBet A P C
A,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
ex (fun x : ITpoint => and (BetT P x Q) (BetT Q x A))
+++++
intuition.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
elim (eq_dec A P).
intro.
elim (eq_dec C P).
intro.
unfold ICol in H1.
spliter.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
induction H.
induction H0.
induction H0.

*****
H8 : not (eq C P)
H7 : not (eq A P)
H6 : not (eq C Q)
H5 : not (eq B Q)
H4 : not (eq B C)
H3 : not (eq A C)
H2 : not (eq A B)
H1 : IT A B C
H0 : eq Q C
H : IBet A P C
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
ex (fun x : ITpoint => and (BetT P x B) (BetT Q x A))
+++++
subst.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
elim (eq_dec A P).
intro.
elim (eq_dec C P).
intro.
unfold ICol in H1.
spliter.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
induction H.
induction H0.
induction H0.
subst.

*****
H8 : not (eq C P)
H7 : not (eq A P)
H5 : not (eq B C)
H6 : not (eq C C)
H4 : not (eq B C)
H3 : not (eq A C)
H2 : not (eq A B)
H1 : IT A B C
H : IBet A P C
A,B,C,P : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
ex (fun x : ITpoint => and (BetT P x B) (BetT C x A))
+++++
intuition.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
elim (eq_dec A P).
intro.
elim (eq_dec C P).
intro.
unfold ICol in H1.
spliter.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
induction H.

*****
H8 : not (eq C P)
H7 : not (eq A P)
H6 : not (eq C Q)
H5 : not (eq B Q)
H4 : not (eq B C)
H3 : not (eq A C)
H2 : not (eq A B)
H1 : IT A B C
H0 : BetT B Q C
H : or (eq A P) (eq P C)
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
ex (fun x : ITpoint => and (BetT P x B) (BetT Q x A))
+++++
induction H0.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
elim (eq_dec A P).
intro.
elim (eq_dec C P).
intro.
unfold ICol in H1.
spliter.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
induction H.
induction H0.

*****
H8 : not (eq C P)
H7 : not (eq A P)
H6 : not (eq C Q)
H5 : not (eq B Q)
H4 : not (eq B C)
H3 : not (eq A C)
H2 : not (eq A B)
H1 : IT A B C
H0 : IBet B Q C
H : or (eq A P) (eq P C)
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
ex (fun x : ITpoint => and (BetT P x B) (BetT Q x A))
+++++
induction H.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
elim (eq_dec A P).
intro.
elim (eq_dec C P).
intro.
unfold ICol in H1.
spliter.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
induction H.
induction H0.
induction H.

*****
H8 : not (eq C P)
H7 : not (eq A P)
H6 : not (eq C Q)
H5 : not (eq B Q)
H4 : not (eq B C)
H3 : not (eq A C)
H2 : not (eq A B)
H1 : IT A B C
H0 : IBet B Q C
H : eq A P
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
ex (fun x : ITpoint => and (BetT P x B) (BetT Q x A))
+++++
subst.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
elim (eq_dec A P).
intro.
elim (eq_dec C P).
intro.
unfold ICol in H1.
spliter.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
induction H.
induction H0.
induction H.
subst.

*****
H8 : not (eq C P)
H7 : not (eq P P)
H6 : not (eq C Q)
H5 : not (eq B Q)
H4 : not (eq B C)
H1 : IT P B C
H2 : not (eq P B)
H3 : not (eq P C)
H0 : IBet B Q C
B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
ex (fun x : ITpoint => and (BetT P x B) (BetT Q x P))
+++++
intuition.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
elim (eq_dec A P).
intro.
elim (eq_dec C P).
intro.
unfold ICol in H1.
spliter.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
induction H.
induction H0.
induction H.

*****
H8 : not (eq C P)
H7 : not (eq A P)
H6 : not (eq C Q)
H5 : not (eq B Q)
H4 : not (eq B C)
H3 : not (eq A C)
H2 : not (eq A B)
H1 : IT A B C
H0 : IBet B Q C
H : eq P C
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
ex (fun x : ITpoint => and (BetT P x B) (BetT Q x A))
+++++
subst.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
elim (eq_dec A P).
intro.
elim (eq_dec C P).
intro.
unfold ICol in H1.
spliter.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
induction H.
induction H0.
induction H.
subst.

*****
H7 : not (eq A C)
H8 : not (eq C C)
H6 : not (eq C Q)
H5 : not (eq B Q)
H4 : not (eq B C)
H3 : not (eq A C)
H2 : not (eq A B)
H1 : IT A B C
H0 : IBet B Q C
A,B,C,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
ex (fun x : ITpoint => and (BetT C x B) (BetT Q x A))
+++++
intuition.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
elim (eq_dec A P).
intro.
elim (eq_dec C P).
intro.
unfold ICol in H1.
spliter.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
induction H.
induction H0.

*****
H8 : not (eq C P)
H7 : not (eq A P)
H6 : not (eq C Q)
H5 : not (eq B Q)
H4 : not (eq B C)
H3 : not (eq A C)
H2 : not (eq A B)
H1 : IT A B C
H0 : or (eq B Q) (eq Q C)
H : or (eq A P) (eq P C)
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
ex (fun x : ITpoint => and (BetT P x B) (BetT Q x A))
+++++
induction H.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
elim (eq_dec A P).
intro.
elim (eq_dec C P).
intro.
unfold ICol in H1.
spliter.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
induction H.
induction H0.
induction H.

*****
H8 : not (eq C P)
H7 : not (eq A P)
H6 : not (eq C Q)
H5 : not (eq B Q)
H4 : not (eq B C)
H3 : not (eq A C)
H2 : not (eq A B)
H1 : IT A B C
H0 : or (eq B Q) (eq Q C)
H : eq A P
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
ex (fun x : ITpoint => and (BetT P x B) (BetT Q x A))
+++++
subst.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
elim (eq_dec A P).
intro.
elim (eq_dec C P).
intro.
unfold ICol in H1.
spliter.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
induction H.
induction H0.
induction H.
subst.

*****
H8 : not (eq C P)
H7 : not (eq P P)
H6 : not (eq C Q)
H5 : not (eq B Q)
H4 : not (eq B C)
H1 : IT P B C
H2 : not (eq P B)
H3 : not (eq P C)
H0 : or (eq B Q) (eq Q C)
B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
ex (fun x : ITpoint => and (BetT P x B) (BetT Q x P))
+++++
intuition.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
elim (eq_dec A P).
intro.
elim (eq_dec C P).
intro.
unfold ICol in H1.
spliter.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
induction H.
induction H0.
induction H.

*****
H8 : not (eq C P)
H7 : not (eq A P)
H6 : not (eq C Q)
H5 : not (eq B Q)
H4 : not (eq B C)
H3 : not (eq A C)
H2 : not (eq A B)
H1 : IT A B C
H0 : or (eq B Q) (eq Q C)
H : eq P C
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
ex (fun x : ITpoint => and (BetT P x B) (BetT Q x A))
+++++
subst.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).
intro.
elim (eq_dec A C).
intro.
elim (eq_dec B C).
intro.
elim (eq_dec B Q).
intro.
elim (eq_dec C Q).
intro.
elim (eq_dec A P).
intro.
elim (eq_dec C P).
intro.
unfold ICol in H1.
spliter.
apply not_and_or in H1.
induction H1.
apply not_and_or in H1.
induction H1.
apply NNPP in H1.
induction H.
induction H0.
induction H.
subst.

*****
H7 : not (eq A C)
H8 : not (eq C C)
H6 : not (eq C Q)
H5 : not (eq B Q)
H4 : not (eq B C)
H3 : not (eq A C)
H2 : not (eq A B)
H1 : IT A B C
H0 : or (eq B Q) (eq Q C)
A,B,C,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
ex (fun x : ITpoint => and (BetT C x B) (BetT Q x A))
+++++
intuition.
-----
Lemma pasch_col_case : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> ICol A B C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
elim (eq_dec A B).

*****

*****

+++++
Qed.
-----
Lemma pasch : forall A B C P Q : ITpoint,\n        BetT A P C ->\n        BetT B Q C -> exists x : ITpoint, BetT P x B /\ BetT Q x A.
-----
Lemma pasch : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.

*****
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
forall (A B C P Q : ITpoint) (_ : BetT A P C) (_ : BetT B Q C), ex (fun x : ITpoint => and (BetT P x B) (BetT Q x A))
+++++
Proof.
-----
Lemma pasch : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.

*****
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
forall (A B C P Q : ITpoint) (_ : BetT A P C) (_ : BetT B Q C), ex (fun x : ITpoint => and (BetT P x B) (BetT Q x A))
+++++
intros.
-----
Lemma pasch : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.

*****
H0 : BetT B Q C
H : BetT A P C
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
ex (fun x : ITpoint => and (BetT P x B) (BetT Q x A))
+++++
induction (col_dec A B C).
-----
Lemma pasch : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
induction (col_dec A B C).

*****
H1 : ICol A B C
H0 : BetT B Q C
H : BetT A P C
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
ex (fun x : ITpoint => and (BetT P x B) (BetT Q x A))
+++++
eapply pasch_col_case.
-----
Lemma pasch : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
induction (col_dec A B C).
eapply pasch_col_case.

*****
H1 : ICol A B C
H0 : BetT B Q C
H : BetT A P C
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
BetT A P ?C
+++++
eauto.
-----
Lemma pasch : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
induction (col_dec A B C).
eapply pasch_col_case.

*****
H1 : ICol A B C
H0 : BetT B Q C
H : BetT A P C
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
BetT B Q C
+++++
eauto.
-----
Lemma pasch : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
induction (col_dec A B C).
eapply pasch_col_case.

*****
H1 : ICol A B C
H0 : BetT B Q C
H : BetT A P C
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
ICol A B C
+++++
eauto.
-----
Lemma pasch : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
induction (col_dec A B C).

*****
H1 : not (ICol A B C)
H0 : BetT B Q C
H : BetT A P C
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
ex (fun x : ITpoint => and (BetT P x B) (BetT Q x A))
+++++
unfold BetT in *.
-----
Lemma pasch : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
induction (col_dec A B C).
unfold BetT in *.

*****
H1 : not (ICol A B C)
H0 : or (IBet B Q C) (or (eq B Q) (eq Q C))
H : or (IBet A P C) (or (eq A P) (eq P C))
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
ex (fun x : ITpoint => and (or (IBet P x B) (or (eq P x) (eq x B))) (or (IBet Q x A) (or (eq Q x) (eq x A))))
+++++
decompose [or] H.
-----
Lemma pasch : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
induction (col_dec A B C).
unfold BetT in *.
decompose [or] H.

*****
H2 : IBet A P C
H1 : not (ICol A B C)
H0 : or (IBet B Q C) (or (eq B Q) (eq Q C))
H : or (IBet A P C) (or (eq A P) (eq P C))
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
ex (fun x : ITpoint => and (or (IBet P x B) (or (eq P x) (eq x B))) (or (IBet Q x A) (or (eq Q x) (eq x A))))
+++++
clear H.
-----
Lemma pasch : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
induction (col_dec A B C).
unfold BetT in *.
decompose [or] H.
clear H.

*****
H2 : IBet A P C
H1 : not (ICol A B C)
H0 : or (IBet B Q C) (or (eq B Q) (eq Q C))
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
ex (fun x : ITpoint => and (or (IBet P x B) (or (eq P x) (eq x B))) (or (IBet Q x A) (or (eq Q x) (eq x A))))
+++++
decompose [or] H0.
-----
Lemma pasch : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
induction (col_dec A B C).
unfold BetT in *.
decompose [or] H.
clear H.
decompose [or] H0.

*****
H : IBet B Q C
H2 : IBet A P C
H1 : not (ICol A B C)
H0 : or (IBet B Q C) (or (eq B Q) (eq Q C))
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
ex (fun x : ITpoint => and (or (IBet P x B) (or (eq P x) (eq x B))) (or (IBet Q x A) (or (eq Q x) (eq x A))))
+++++
clear H0.
-----
Lemma pasch : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
induction (col_dec A B C).
unfold BetT in *.
decompose [or] H.
clear H.
decompose [or] H0.
clear H0.

*****
H : IBet B Q C
H2 : IBet A P C
H1 : not (ICol A B C)
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
ex (fun x : ITpoint => and (or (IBet P x B) (or (eq P x) (eq x B))) (or (IBet Q x A) (or (eq Q x) (eq x A))))
+++++
elim (Iinner_pasch A B C P Q H2 H H1).
-----
Lemma pasch : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
induction (col_dec A B C).
unfold BetT in *.
decompose [or] H.
clear H.
decompose [or] H0.
clear H0.
elim (Iinner_pasch A B C P Q H2 H H1).

*****
H : IBet B Q C
H2 : IBet A P C
H1 : not (ICol A B C)
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
forall (x : ITpoint) (_ : and (IBet P x B) (IBet Q x A)), ex (fun x0 : ITpoint => and (or (IBet P x0 B) (or (eq P x0) (eq x0 B))) (or (IBet Q x0 A) (or (eq Q x0) (eq x0 A))))
+++++
intros.
-----
Lemma pasch : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
induction (col_dec A B C).
unfold BetT in *.
decompose [or] H.
clear H.
decompose [or] H0.
clear H0.
elim (Iinner_pasch A B C P Q H2 H H1).
intros.

*****
H0 : and (IBet P x B) (IBet Q x A)
x : ITpoint
H : IBet B Q C
H2 : IBet A P C
H1 : not (ICol A B C)
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
ex (fun x : ITpoint => and (or (IBet P x B) (or (eq P x) (eq x B))) (or (IBet Q x A) (or (eq Q x) (eq x A))))
+++++
spliter.
-----
Lemma pasch : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
induction (col_dec A B C).
unfold BetT in *.
decompose [or] H.
clear H.
decompose [or] H0.
clear H0.
elim (Iinner_pasch A B C P Q H2 H H1).
intros.
spliter.

*****
H3 : IBet Q x A
H0 : IBet P x B
x : ITpoint
H : IBet B Q C
H2 : IBet A P C
H1 : not (ICol A B C)
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
ex (fun x : ITpoint => and (or (IBet P x B) (or (eq P x) (eq x B))) (or (IBet Q x A) (or (eq Q x) (eq x A))))
+++++
exists x.
-----
Lemma pasch : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
induction (col_dec A B C).
unfold BetT in *.
decompose [or] H.
clear H.
decompose [or] H0.
clear H0.
elim (Iinner_pasch A B C P Q H2 H H1).
intros.
spliter.
exists x.

*****
H3 : IBet Q x A
H0 : IBet P x B
x : ITpoint
H : IBet B Q C
H2 : IBet A P C
H1 : not (ICol A B C)
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
and (or (IBet P x B) (or (eq P x) (eq x B))) (or (IBet Q x A) (or (eq Q x) (eq x A)))
+++++
split.
-----
Lemma pasch : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
induction (col_dec A B C).
unfold BetT in *.
decompose [or] H.
clear H.
decompose [or] H0.
clear H0.
elim (Iinner_pasch A B C P Q H2 H H1).
intros.
spliter.
exists x.
split.

*****
H3 : IBet Q x A
H0 : IBet P x B
x : ITpoint
H : IBet B Q C
H2 : IBet A P C
H1 : not (ICol A B C)
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
or (IBet P x B) (or (eq P x) (eq x B))
+++++
tauto.
-----
Lemma pasch : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
induction (col_dec A B C).
unfold BetT in *.
decompose [or] H.
clear H.
decompose [or] H0.
clear H0.
elim (Iinner_pasch A B C P Q H2 H H1).
intros.
spliter.
exists x.
split.

*****
H3 : IBet Q x A
H0 : IBet P x B
x : ITpoint
H : IBet B Q C
H2 : IBet A P C
H1 : not (ICol A B C)
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
or (IBet Q x A) (or (eq Q x) (eq x A))
+++++
tauto.
-----
Lemma pasch : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
induction (col_dec A B C).
unfold BetT in *.
decompose [or] H.
clear H.
decompose [or] H0.

*****
H3 : eq B Q
H2 : IBet A P C
H1 : not (ICol A B C)
H0 : or (IBet B Q C) (or (eq B Q) (eq Q C))
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
ex (fun x : ITpoint => and (or (IBet P x B) (or (eq P x) (eq x B))) (or (IBet Q x A) (or (eq Q x) (eq x A))))
+++++
clear H0.
-----
Lemma pasch : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
induction (col_dec A B C).
unfold BetT in *.
decompose [or] H.
clear H.
decompose [or] H0.
clear H0.

*****
H3 : eq B Q
H2 : IBet A P C
H1 : not (ICol A B C)
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
ex (fun x : ITpoint => and (or (IBet P x B) (or (eq P x) (eq x B))) (or (IBet Q x A) (or (eq Q x) (eq x A))))
+++++
subst.
-----
Lemma pasch : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
induction (col_dec A B C).
unfold BetT in *.
decompose [or] H.
clear H.
decompose [or] H0.
clear H0.
subst.

*****
H2 : IBet A P C
H1 : not (ICol A Q C)
A,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
ex (fun x : ITpoint => and (or (IBet P x Q) (or (eq P x) (eq x Q))) (or (IBet Q x A) (or (eq Q x) (eq x A))))
+++++
exists Q.
-----
Lemma pasch : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
induction (col_dec A B C).
unfold BetT in *.
decompose [or] H.
clear H.
decompose [or] H0.
clear H0.
subst.
exists Q.

*****
H2 : IBet A P C
H1 : not (ICol A Q C)
A,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
and (or (IBet P Q Q) (or (eq P Q) (eq Q Q))) (or (IBet Q Q A) (or (eq Q Q) (eq Q A)))
+++++
auto.
-----
Lemma pasch : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
induction (col_dec A B C).
unfold BetT in *.
decompose [or] H.
clear H.
decompose [or] H0.

*****
H3 : eq Q C
H2 : IBet A P C
H1 : not (ICol A B C)
H0 : or (IBet B Q C) (or (eq B Q) (eq Q C))
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
ex (fun x : ITpoint => and (or (IBet P x B) (or (eq P x) (eq x B))) (or (IBet Q x A) (or (eq Q x) (eq x A))))
+++++
clear H0.
-----
Lemma pasch : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
induction (col_dec A B C).
unfold BetT in *.
decompose [or] H.
clear H.
decompose [or] H0.
clear H0.

*****
H3 : eq Q C
H2 : IBet A P C
H1 : not (ICol A B C)
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
ex (fun x : ITpoint => and (or (IBet P x B) (or (eq P x) (eq x B))) (or (IBet Q x A) (or (eq Q x) (eq x A))))
+++++
subst.
-----
Lemma pasch : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
induction (col_dec A B C).
unfold BetT in *.
decompose [or] H.
clear H.
decompose [or] H0.
clear H0.
subst.

*****
H2 : IBet A P C
H1 : not (ICol A B C)
A,B,C,P : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
ex (fun x : ITpoint => and (or (IBet P x B) (or (eq P x) (eq x B))) (or (IBet C x A) (or (eq C x) (eq x A))))
+++++
exists P.
-----
Lemma pasch : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
induction (col_dec A B C).
unfold BetT in *.
decompose [or] H.
clear H.
decompose [or] H0.
clear H0.
subst.
exists P.

*****
H2 : IBet A P C
H1 : not (ICol A B C)
A,B,C,P : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
and (or (IBet P P B) (or (eq P P) (eq P B))) (or (IBet C P A) (or (eq C P) (eq P A)))
+++++
split.
-----
Lemma pasch : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
induction (col_dec A B C).
unfold BetT in *.
decompose [or] H.
clear H.
decompose [or] H0.
clear H0.
subst.
exists P.
split.

*****
H2 : IBet A P C
H1 : not (ICol A B C)
A,B,C,P : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
or (IBet P P B) (or (eq P P) (eq P B))
+++++
auto.
-----
Lemma pasch : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
induction (col_dec A B C).
unfold BetT in *.
decompose [or] H.
clear H.
decompose [or] H0.
clear H0.
subst.
exists P.
split.

*****
H2 : IBet A P C
H1 : not (ICol A B C)
A,B,C,P : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
or (IBet C P A) (or (eq C P) (eq P A))
+++++
left.
-----
Lemma pasch : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
induction (col_dec A B C).
unfold BetT in *.
decompose [or] H.
clear H.
decompose [or] H0.
clear H0.
subst.
exists P.
split.
left.

*****
H2 : IBet A P C
H1 : not (ICol A B C)
A,B,C,P : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
IBet C P A
+++++
apply Ibetween_symmetry.
-----
Lemma pasch : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
induction (col_dec A B C).
unfold BetT in *.
decompose [or] H.
clear H.
decompose [or] H0.
clear H0.
subst.
exists P.
split.
left.
apply Ibetween_symmetry.

*****
H2 : IBet A P C
H1 : not (ICol A B C)
A,B,C,P : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
IBet A P C
+++++
auto.
-----
Lemma pasch : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
induction (col_dec A B C).
unfold BetT in *.
decompose [or] H.

*****
H3 : eq A P
H1 : not (ICol A B C)
H0 : or (IBet B Q C) (or (eq B Q) (eq Q C))
H : or (IBet A P C) (or (eq A P) (eq P C))
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
ex (fun x : ITpoint => and (or (IBet P x B) (or (eq P x) (eq x B))) (or (IBet Q x A) (or (eq Q x) (eq x A))))
+++++
clear H.
-----
Lemma pasch : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
induction (col_dec A B C).
unfold BetT in *.
decompose [or] H.
clear H.

*****
H3 : eq A P
H1 : not (ICol A B C)
H0 : or (IBet B Q C) (or (eq B Q) (eq Q C))
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
ex (fun x : ITpoint => and (or (IBet P x B) (or (eq P x) (eq x B))) (or (IBet Q x A) (or (eq Q x) (eq x A))))
+++++
subst.
-----
Lemma pasch : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
induction (col_dec A B C).
unfold BetT in *.
decompose [or] H.
clear H.
subst.

*****
H1 : not (ICol P B C)
H0 : or (IBet B Q C) (or (eq B Q) (eq Q C))
B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
ex (fun x : ITpoint => and (or (IBet P x B) (or (eq P x) (eq x B))) (or (IBet Q x P) (or (eq Q x) (eq x P))))
+++++
exists P.
-----
Lemma pasch : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
induction (col_dec A B C).
unfold BetT in *.
decompose [or] H.
clear H.
subst.
exists P.

*****
H1 : not (ICol P B C)
H0 : or (IBet B Q C) (or (eq B Q) (eq Q C))
B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
and (or (IBet P P B) (or (eq P P) (eq P B))) (or (IBet Q P P) (or (eq Q P) (eq P P)))
+++++
auto.
-----
Lemma pasch : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
induction (col_dec A B C).
unfold BetT in *.
decompose [or] H.

*****
H3 : eq P C
H1 : not (ICol A B C)
H0 : or (IBet B Q C) (or (eq B Q) (eq Q C))
H : or (IBet A P C) (or (eq A P) (eq P C))
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
ex (fun x : ITpoint => and (or (IBet P x B) (or (eq P x) (eq x B))) (or (IBet Q x A) (or (eq Q x) (eq x A))))
+++++
clear H.
-----
Lemma pasch : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
induction (col_dec A B C).
unfold BetT in *.
decompose [or] H.
clear H.

*****
H3 : eq P C
H1 : not (ICol A B C)
H0 : or (IBet B Q C) (or (eq B Q) (eq Q C))
A,B,C,P,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
ex (fun x : ITpoint => and (or (IBet P x B) (or (eq P x) (eq x B))) (or (IBet Q x A) (or (eq Q x) (eq x A))))
+++++
subst.
-----
Lemma pasch : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
induction (col_dec A B C).
unfold BetT in *.
decompose [or] H.
clear H.
subst.

*****
H1 : not (ICol A B C)
H0 : or (IBet B Q C) (or (eq B Q) (eq Q C))
A,B,C,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
ex (fun x : ITpoint => and (or (IBet C x B) (or (eq C x) (eq x B))) (or (IBet Q x A) (or (eq Q x) (eq x A))))
+++++
decompose [or] H0.
-----
Lemma pasch : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
induction (col_dec A B C).
unfold BetT in *.
decompose [or] H.
clear H.
subst.
decompose [or] H0.

*****
H : IBet B Q C
H1 : not (ICol A B C)
H0 : or (IBet B Q C) (or (eq B Q) (eq Q C))
A,B,C,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
ex (fun x : ITpoint => and (or (IBet C x B) (or (eq C x) (eq x B))) (or (IBet Q x A) (or (eq Q x) (eq x A))))
+++++
clear H0.
-----
Lemma pasch : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
induction (col_dec A B C).
unfold BetT in *.
decompose [or] H.
clear H.
subst.
decompose [or] H0.
clear H0.

*****
H : IBet B Q C
H1 : not (ICol A B C)
A,B,C,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
ex (fun x : ITpoint => and (or (IBet C x B) (or (eq C x) (eq x B))) (or (IBet Q x A) (or (eq Q x) (eq x A))))
+++++
exists Q.
-----
Lemma pasch : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
induction (col_dec A B C).
unfold BetT in *.
decompose [or] H.
clear H.
subst.
decompose [or] H0.
clear H0.
exists Q.

*****
H : IBet B Q C
H1 : not (ICol A B C)
A,B,C,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
and (or (IBet C Q B) (or (eq C Q) (eq Q B))) (or (IBet Q Q A) (or (eq Q Q) (eq Q A)))
+++++
split.
-----
Lemma pasch : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
induction (col_dec A B C).
unfold BetT in *.
decompose [or] H.
clear H.
subst.
decompose [or] H0.
clear H0.
exists Q.
split.

*****
H : IBet B Q C
H1 : not (ICol A B C)
A,B,C,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
or (IBet C Q B) (or (eq C Q) (eq Q B))
+++++
left.
-----
Lemma pasch : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
induction (col_dec A B C).
unfold BetT in *.
decompose [or] H.
clear H.
subst.
decompose [or] H0.
clear H0.
exists Q.
split.
left.

*****
H : IBet B Q C
H1 : not (ICol A B C)
A,B,C,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
IBet C Q B
+++++
apply Ibetween_symmetry.
-----
Lemma pasch : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
induction (col_dec A B C).
unfold BetT in *.
decompose [or] H.
clear H.
subst.
decompose [or] H0.
clear H0.
exists Q.
split.
left.
apply Ibetween_symmetry.

*****
H : IBet B Q C
H1 : not (ICol A B C)
A,B,C,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
IBet B Q C
+++++
auto.
-----
Lemma pasch : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
induction (col_dec A B C).
unfold BetT in *.
decompose [or] H.
clear H.
subst.
decompose [or] H0.
clear H0.
exists Q.
split.

*****
H : IBet B Q C
H1 : not (ICol A B C)
A,B,C,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
or (IBet Q Q A) (or (eq Q Q) (eq Q A))
+++++
auto.
-----
Lemma pasch : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
induction (col_dec A B C).
unfold BetT in *.
decompose [or] H.
clear H.
subst.
decompose [or] H0.

*****
H2 : eq B Q
H1 : not (ICol A B C)
H0 : or (IBet B Q C) (or (eq B Q) (eq Q C))
A,B,C,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
ex (fun x : ITpoint => and (or (IBet C x B) (or (eq C x) (eq x B))) (or (IBet Q x A) (or (eq Q x) (eq x A))))
+++++
clear H0.
-----
Lemma pasch : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
induction (col_dec A B C).
unfold BetT in *.
decompose [or] H.
clear H.
subst.
decompose [or] H0.
clear H0.

*****
H2 : eq B Q
H1 : not (ICol A B C)
A,B,C,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
ex (fun x : ITpoint => and (or (IBet C x B) (or (eq C x) (eq x B))) (or (IBet Q x A) (or (eq Q x) (eq x A))))
+++++
subst.
-----
Lemma pasch : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
induction (col_dec A B C).
unfold BetT in *.
decompose [or] H.
clear H.
subst.
decompose [or] H0.
clear H0.
subst.

*****
H1 : not (ICol A Q C)
A,C,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
ex (fun x : ITpoint => and (or (IBet C x Q) (or (eq C x) (eq x Q))) (or (IBet Q x A) (or (eq Q x) (eq x A))))
+++++
exists Q.
-----
Lemma pasch : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
induction (col_dec A B C).
unfold BetT in *.
decompose [or] H.
clear H.
subst.
decompose [or] H0.
clear H0.
subst.
exists Q.

*****
H1 : not (ICol A Q C)
A,C,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
and (or (IBet C Q Q) (or (eq C Q) (eq Q Q))) (or (IBet Q Q A) (or (eq Q Q) (eq Q A)))
+++++
auto.
-----
Lemma pasch : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
induction (col_dec A B C).
unfold BetT in *.
decompose [or] H.
clear H.
subst.
decompose [or] H0.

*****
H2 : eq Q C
H1 : not (ICol A B C)
H0 : or (IBet B Q C) (or (eq B Q) (eq Q C))
A,B,C,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
ex (fun x : ITpoint => and (or (IBet C x B) (or (eq C x) (eq x B))) (or (IBet Q x A) (or (eq Q x) (eq x A))))
+++++
clear H0.
-----
Lemma pasch : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
induction (col_dec A B C).
unfold BetT in *.
decompose [or] H.
clear H.
subst.
decompose [or] H0.
clear H0.

*****
H2 : eq Q C
H1 : not (ICol A B C)
A,B,C,Q : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
ex (fun x : ITpoint => and (or (IBet C x B) (or (eq C x) (eq x B))) (or (IBet Q x A) (or (eq Q x) (eq x A))))
+++++
subst.
-----
Lemma pasch : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
induction (col_dec A B C).
unfold BetT in *.
decompose [or] H.
clear H.
subst.
decompose [or] H0.
clear H0.
subst.

*****
H1 : not (ICol A B C)
A,B,C : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
ex (fun x : ITpoint => and (or (IBet C x B) (or (eq C x) (eq x B))) (or (IBet C x A) (or (eq C x) (eq x A))))
+++++
exists C.
-----
Lemma pasch : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
induction (col_dec A B C).
unfold BetT in *.
decompose [or] H.
clear H.
subst.
decompose [or] H0.
clear H0.
subst.
exists C.

*****
H1 : not (ICol A B C)
A,B,C : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
and (or (IBet C C B) (or (eq C C) (eq C B))) (or (IBet C C A) (or (eq C C) (eq C A)))
+++++
auto.
-----
Lemma pasch : forall A B C P Q : ITpoint, BetT A P C -> BetT B Q C -> exists x : ITpoint, BetT P x B /\\ BetT Q x A.
Proof.
intros.
induction (col_dec A B C).

*****

*****

+++++
Qed.
-----
Lemma five_segment:\n forall A A' B B' C C' D D' : ITpoint,\n        ICong A B A' B' ->\n        ICong B C B' C' ->\n        ICong A D A' D' ->\n        ICong B D B' D' ->\n        BetT A B C -> BetT A' B' C' -> A <> B -> ICong C D C' D'.
-----
Lemma five_segment: forall A A' B B' C C' D D' : ITpoint, ICong A B A' B' -> ICong B C B' C' -> ICong A D A' D' -> ICong B D B' D' -> BetT A B C -> BetT A' B' C' -> A <> B -> ICong C D C' D'.

*****
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
forall (A A' B B' C C' D D' : ITpoint) (_ : ICong A B A' B') (_ : ICong B C B' C') (_ : ICong A D A' D') (_ : ICong B D B' D') (_ : BetT A B C) (_ : BetT A' B' C') (_ : not (eq A B)), ICong C D C' D'
+++++
Proof.
-----
Lemma five_segment: forall A A' B B' C C' D D' : ITpoint, ICong A B A' B' -> ICong B C B' C' -> ICong A D A' D' -> ICong B D B' D' -> BetT A B C -> BetT A' B' C' -> A <> B -> ICong C D C' D'.
Proof.

*****
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
forall (A A' B B' C C' D D' : ITpoint) (_ : ICong A B A' B') (_ : ICong B C B' C') (_ : ICong A D A' D') (_ : ICong B D B' D') (_ : BetT A B C) (_ : BetT A' B' C') (_ : not (eq A B)), ICong C D C' D'
+++++
intros.
-----
Lemma five_segment: forall A A' B B' C C' D D' : ITpoint, ICong A B A' B' -> ICong B C B' C' -> ICong A D A' D' -> ICong B D B' D' -> BetT A B C -> BetT A' B' C' -> A <> B -> ICong C D C' D'.
Proof.
intros.

*****
H5 : not (eq A B)
H4 : BetT A' B' C'
H3 : BetT A B C
H2 : ICong B D B' D'
H1 : ICong A D A' D'
H0 : ICong B C B' C'
H : ICong A B A' B'
A,A',B,B',C,C',D,D' : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
ICong C D C' D'
+++++
apply Ifive_segment with A A' B B'.
-----
Lemma five_segment: forall A A' B B' C C' D D' : ITpoint, ICong A B A' B' -> ICong B C B' C' -> ICong A D A' D' -> ICong B D B' D' -> BetT A B C -> BetT A' B' C' -> A <> B -> ICong C D C' D'.
Proof.
intros.
apply Ifive_segment with A A' B B'.

*****
H5 : not (eq A B)
H4 : BetT A' B' C'
H3 : BetT A B C
H2 : ICong B D B' D'
H1 : ICong A D A' D'
H0 : ICong B C B' C'
H : ICong A B A' B'
A,A',B,B',C,C',D,D' : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
ICong A B A' B'
+++++
try assumption.
-----
Lemma five_segment: forall A A' B B' C C' D D' : ITpoint, ICong A B A' B' -> ICong B C B' C' -> ICong A D A' D' -> ICong B D B' D' -> BetT A B C -> BetT A' B' C' -> A <> B -> ICong C D C' D'.
Proof.
intros.
apply Ifive_segment with A A' B B'.

*****
H5 : not (eq A B)
H4 : BetT A' B' C'
H3 : BetT A B C
H2 : ICong B D B' D'
H1 : ICong A D A' D'
H0 : ICong B C B' C'
H : ICong A B A' B'
A,A',B,B',C,C',D,D' : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
ICong B C B' C'
+++++
try assumption.
-----
Lemma five_segment: forall A A' B B' C C' D D' : ITpoint, ICong A B A' B' -> ICong B C B' C' -> ICong A D A' D' -> ICong B D B' D' -> BetT A B C -> BetT A' B' C' -> A <> B -> ICong C D C' D'.
Proof.
intros.
apply Ifive_segment with A A' B B'.

*****
H5 : not (eq A B)
H4 : BetT A' B' C'
H3 : BetT A B C
H2 : ICong B D B' D'
H1 : ICong A D A' D'
H0 : ICong B C B' C'
H : ICong A B A' B'
A,A',B,B',C,C',D,D' : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
ICong A D A' D'
+++++
try assumption.
-----
Lemma five_segment: forall A A' B B' C C' D D' : ITpoint, ICong A B A' B' -> ICong B C B' C' -> ICong A D A' D' -> ICong B D B' D' -> BetT A B C -> BetT A' B' C' -> A <> B -> ICong C D C' D'.
Proof.
intros.
apply Ifive_segment with A A' B B'.

*****
H5 : not (eq A B)
H4 : BetT A' B' C'
H3 : BetT A B C
H2 : ICong B D B' D'
H1 : ICong A D A' D'
H0 : ICong B C B' C'
H : ICong A B A' B'
A,A',B,B',C,C',D,D' : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
ICong B D B' D'
+++++
try assumption.
-----
Lemma five_segment: forall A A' B B' C C' D D' : ITpoint, ICong A B A' B' -> ICong B C B' C' -> ICong A D A' D' -> ICong B D B' D' -> BetT A B C -> BetT A' B' C' -> A <> B -> ICong C D C' D'.
Proof.
intros.
apply Ifive_segment with A A' B B'.

*****
H5 : not (eq A B)
H4 : BetT A' B' C'
H3 : BetT A B C
H2 : ICong B D B' D'
H1 : ICong A D A' D'
H0 : ICong B C B' C'
H : ICong A B A' B'
A,A',B,B',C,C',D,D' : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
IT A B C
+++++
try assumption.
-----
Lemma five_segment: forall A A' B B' C C' D D' : ITpoint, ICong A B A' B' -> ICong B C B' C' -> ICong A D A' D' -> ICong B D B' D' -> BetT A B C -> BetT A' B' C' -> A <> B -> ICong C D C' D'.
Proof.
intros.
apply Ifive_segment with A A' B B'.
try assumption.

*****
H5 : not (eq A B)
H4 : BetT A' B' C'
H3 : BetT A B C
H2 : ICong B D B' D'
H1 : ICong A D A' D'
H0 : ICong B C B' C'
H : ICong A B A' B'
A,A',B,B',C,C',D,D' : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
IT A B C
+++++
unfold IT.
-----
Lemma five_segment: forall A A' B B' C C' D D' : ITpoint, ICong A B A' B' -> ICong B C B' C' -> ICong A D A' D' -> ICong B D B' D' -> BetT A B C -> BetT A' B' C' -> A <> B -> ICong C D C' D'.
Proof.
intros.
apply Ifive_segment with A A' B B'.
try assumption.
unfold IT.

*****
H5 : not (eq A B)
H4 : BetT A' B' C'
H3 : BetT A B C
H2 : ICong B D B' D'
H1 : ICong A D A' D'
H0 : ICong B C B' C'
H : ICong A B A' B'
A,A',B,B',C,C',D,D' : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
not (and (not (eq A B)) (and (not (eq B C)) (not (IBet A B C))))
+++++
intro.
-----
Lemma five_segment: forall A A' B B' C C' D D' : ITpoint, ICong A B A' B' -> ICong B C B' C' -> ICong A D A' D' -> ICong B D B' D' -> BetT A B C -> BetT A' B' C' -> A <> B -> ICong C D C' D'.
Proof.
intros.
apply Ifive_segment with A A' B B'.
try assumption.
unfold IT.
intro.

*****
H6 : and (not (eq A B)) (and (not (eq B C)) (not (IBet A B C)))
H5 : not (eq A B)
H4 : BetT A' B' C'
H3 : BetT A B C
H2 : ICong B D B' D'
H1 : ICong A D A' D'
H0 : ICong B C B' C'
H : ICong A B A' B'
A,A',B,B',C,C',D,D' : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
False
+++++
spliter.
-----
Lemma five_segment: forall A A' B B' C C' D D' : ITpoint, ICong A B A' B' -> ICong B C B' C' -> ICong A D A' D' -> ICong B D B' D' -> BetT A B C -> BetT A' B' C' -> A <> B -> ICong C D C' D'.
Proof.
intros.
apply Ifive_segment with A A' B B'.
try assumption.
unfold IT.
intro.
spliter.

*****
H8 : not (IBet A B C)
H7 : not (eq B C)
H5,H6 : not (eq A B)
H4 : BetT A' B' C'
H3 : BetT A B C
H2 : ICong B D B' D'
H1 : ICong A D A' D'
H0 : ICong B C B' C'
H : ICong A B A' B'
A,A',B,B',C,C',D,D' : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
False
+++++
unfold BetT in *.
-----
Lemma five_segment: forall A A' B B' C C' D D' : ITpoint, ICong A B A' B' -> ICong B C B' C' -> ICong A D A' D' -> ICong B D B' D' -> BetT A B C -> BetT A' B' C' -> A <> B -> ICong C D C' D'.
Proof.
intros.
apply Ifive_segment with A A' B B'.
try assumption.
unfold IT.
intro.
spliter.
unfold BetT in *.

*****
H8 : not (IBet A B C)
H7 : not (eq B C)
H5,H6 : not (eq A B)
H4 : or (IBet A' B' C') (or (eq A' B') (eq B' C'))
H3 : or (IBet A B C) (or (eq A B) (eq B C))
H2 : ICong B D B' D'
H1 : ICong A D A' D'
H0 : ICong B C B' C'
H : ICong A B A' B'
A,A',B,B',C,C',D,D' : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
False
+++++
intuition.
-----
Lemma five_segment: forall A A' B B' C C' D D' : ITpoint, ICong A B A' B' -> ICong B C B' C' -> ICong A D A' D' -> ICong B D B' D' -> BetT A B C -> BetT A' B' C' -> A <> B -> ICong C D C' D'.
Proof.
intros.
apply Ifive_segment with A A' B B'.

*****
H5 : not (eq A B)
H4 : BetT A' B' C'
H3 : BetT A B C
H2 : ICong B D B' D'
H1 : ICong A D A' D'
H0 : ICong B C B' C'
H : ICong A B A' B'
A,A',B,B',C,C',D,D' : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
IT A' B' C'
+++++
try assumption.
-----
Lemma five_segment: forall A A' B B' C C' D D' : ITpoint, ICong A B A' B' -> ICong B C B' C' -> ICong A D A' D' -> ICong B D B' D' -> BetT A B C -> BetT A' B' C' -> A <> B -> ICong C D C' D'.
Proof.
intros.
apply Ifive_segment with A A' B B'.
try assumption.

*****
H5 : not (eq A B)
H4 : BetT A' B' C'
H3 : BetT A B C
H2 : ICong B D B' D'
H1 : ICong A D A' D'
H0 : ICong B C B' C'
H : ICong A B A' B'
A,A',B,B',C,C',D,D' : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
IT A' B' C'
+++++
unfold BetT in *.
-----
Lemma five_segment: forall A A' B B' C C' D D' : ITpoint, ICong A B A' B' -> ICong B C B' C' -> ICong A D A' D' -> ICong B D B' D' -> BetT A B C -> BetT A' B' C' -> A <> B -> ICong C D C' D'.
Proof.
intros.
apply Ifive_segment with A A' B B'.
try assumption.
unfold BetT in *.

*****
H5 : not (eq A B)
H4 : or (IBet A' B' C') (or (eq A' B') (eq B' C'))
H3 : or (IBet A B C) (or (eq A B) (eq B C))
H2 : ICong B D B' D'
H1 : ICong A D A' D'
H0 : ICong B C B' C'
H : ICong A B A' B'
A,A',B,B',C,C',D,D' : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
IT A' B' C'
+++++
unfold IT.
-----
Lemma five_segment: forall A A' B B' C C' D D' : ITpoint, ICong A B A' B' -> ICong B C B' C' -> ICong A D A' D' -> ICong B D B' D' -> BetT A B C -> BetT A' B' C' -> A <> B -> ICong C D C' D'.
Proof.
intros.
apply Ifive_segment with A A' B B'.
try assumption.
unfold BetT in *.
unfold IT.

*****
H5 : not (eq A B)
H4 : or (IBet A' B' C') (or (eq A' B') (eq B' C'))
H3 : or (IBet A B C) (or (eq A B) (eq B C))
H2 : ICong B D B' D'
H1 : ICong A D A' D'
H0 : ICong B C B' C'
H : ICong A B A' B'
A,A',B,B',C,C',D,D' : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
not (and (not (eq A' B')) (and (not (eq B' C')) (not (IBet A' B' C'))))
+++++
intro.
-----
Lemma five_segment: forall A A' B B' C C' D D' : ITpoint, ICong A B A' B' -> ICong B C B' C' -> ICong A D A' D' -> ICong B D B' D' -> BetT A B C -> BetT A' B' C' -> A <> B -> ICong C D C' D'.
Proof.
intros.
apply Ifive_segment with A A' B B'.
try assumption.
unfold BetT in *.
unfold IT.
intro.

*****
H6 : and (not (eq A' B')) (and (not (eq B' C')) (not (IBet A' B' C')))
H5 : not (eq A B)
H4 : or (IBet A' B' C') (or (eq A' B') (eq B' C'))
H3 : or (IBet A B C) (or (eq A B) (eq B C))
H2 : ICong B D B' D'
H1 : ICong A D A' D'
H0 : ICong B C B' C'
H : ICong A B A' B'
A,A',B,B',C,C',D,D' : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
False
+++++
intuition.
-----
Lemma five_segment: forall A A' B B' C C' D D' : ITpoint, ICong A B A' B' -> ICong B C B' C' -> ICong A D A' D' -> ICong B D B' D' -> BetT A B C -> BetT A' B' C' -> A <> B -> ICong C D C' D'.
Proof.
intros.
apply Ifive_segment with A A' B B'.

*****
H5 : not (eq A B)
H4 : BetT A' B' C'
H3 : BetT A B C
H2 : ICong B D B' D'
H1 : ICong A D A' D'
H0 : ICong B C B' C'
H : ICong A B A' B'
A,A',B,B',C,C',D,D' : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
not (eq A B)
+++++
try assumption.
-----
Lemma five_segment: forall A A' B B' C C' D D' : ITpoint, ICong A B A' B' -> ICong B C B' C' -> ICong A D A' D' -> ICong B D B' D' -> BetT A B C -> BetT A' B' C' -> A <> B -> ICong C D C' D'.
Proof.
intros.
apply Ifive_segment with A A' B B'.

*****

*****

+++++
Qed.
-----
Lemma IT_trivial : forall A B, IT A A B.
-----
Lemma IT_trivial : forall A B, IT A A B.

*****
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
forall A B : ITpoint, IT A A B
+++++
Proof.
-----
Lemma IT_trivial : forall A B, IT A A B.
Proof.

*****
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
forall A B : ITpoint, IT A A B
+++++
intros.
-----
Lemma IT_trivial : forall A B, IT A A B.
Proof.
intros.

*****
A,B : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
IT A A B
+++++
unfold IT.
-----
Lemma IT_trivial : forall A B, IT A A B.
Proof.
intros.
unfold IT.

*****
A,B : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
not (and (not (eq A A)) (and (not (eq A B)) (not (IBet A A B))))
+++++
intro.
-----
Lemma IT_trivial : forall A B, IT A A B.
Proof.
intros.
unfold IT.
intro.

*****
H : and (not (eq A A)) (and (not (eq A B)) (not (IBet A A B)))
A,B : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
False
+++++
spliter.
-----
Lemma IT_trivial : forall A B, IT A A B.
Proof.
intros.
unfold IT.
intro.
spliter.

*****
H1 : not (IBet A A B)
H0 : not (eq A B)
H : not (eq A A)
A,B : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
False
+++++
intuition.
-----
Lemma IT_trivial : forall A B, IT A A B.
Proof.
intros.
unfold IT.
intro.
spliter.
intuition.

*****

*****

+++++
Qed.
-----
Lemma IT_trivial2 : forall A B, IT A B B.
-----
Lemma IT_trivial2 : forall A B, IT A B B.

*****
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
forall A B : ITpoint, IT A B B
+++++
Proof.
-----
Lemma IT_trivial2 : forall A B, IT A B B.
Proof.

*****
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
forall A B : ITpoint, IT A B B
+++++
intros.
-----
Lemma IT_trivial2 : forall A B, IT A B B.
Proof.
intros.

*****
A,B : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
IT A B B
+++++
unfold IT.
-----
Lemma IT_trivial2 : forall A B, IT A B B.
Proof.
intros.
unfold IT.

*****
A,B : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
not (and (not (eq A B)) (and (not (eq B B)) (not (IBet A B B))))
+++++
intro.
-----
Lemma IT_trivial2 : forall A B, IT A B B.
Proof.
intros.
unfold IT.
intro.

*****
H : and (not (eq A B)) (and (not (eq B B)) (not (IBet A B B)))
A,B : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
False
+++++
spliter.
-----
Lemma IT_trivial2 : forall A B, IT A B B.
Proof.
intros.
unfold IT.
intro.
spliter.

*****
H1 : not (IBet A B B)
H0 : not (eq B B)
H : not (eq A B)
A,B : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
False
+++++
intuition.
-----
Lemma IT_trivial2 : forall A B, IT A B B.
Proof.
intros.
unfold IT.
intro.
spliter.
intuition.

*****

*****

+++++
Qed.
-----
Lemma another_point : forall A, exists B:ITpoint, A<>B.
-----
Lemma another_point : forall A, exists B:ITpoint, A<>B.

*****
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
forall A : ITpoint, ex (fun B : ITpoint => not (eq A B))
+++++
Proof.
-----
Lemma another_point : forall A, exists B:ITpoint, A<>B.
Proof.

*****
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
forall A : ITpoint, ex (fun B : ITpoint => not (eq A B))
+++++
intros.
-----
Lemma another_point : forall A, exists B:ITpoint, A<>B.
Proof.
intros.

*****
A : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
ex (fun B : ITpoint => not (eq A B))
+++++
assert (T:=Ilower_dim).
-----
Lemma another_point : forall A, exists B:ITpoint, A<>B.
Proof.
intros.
assert (T:=Ilower_dim).

*****
T : and (not (IT beeson_s_axioms.PC beeson_s_axioms.PA beeson_s_axioms.PB))\n (and\n (not (IT beeson_s_axioms.PA beeson_s_axioms.PC beeson_s_axioms.PB))\n (not (IT beeson_s_axioms.PA beeson_s_axioms.PB beeson_s_axioms.PC)))
A : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
ex (fun B : ITpoint => not (eq A B))
+++++
elim (eq_dec A beeson_s_axioms.PA).
-----
Lemma another_point : forall A, exists B:ITpoint, A<>B.
Proof.
intros.
assert (T:=Ilower_dim).
elim (eq_dec A beeson_s_axioms.PA).

*****
T : and (not (IT beeson_s_axioms.PC beeson_s_axioms.PA beeson_s_axioms.PB))\n (and\n (not (IT beeson_s_axioms.PA beeson_s_axioms.PC beeson_s_axioms.PB))\n (not (IT beeson_s_axioms.PA beeson_s_axioms.PB beeson_s_axioms.PC)))
A : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
forall _ : eq A beeson_s_axioms.PA, ex (fun B : ITpoint => not (eq A B))
+++++
intro.
-----
Lemma another_point : forall A, exists B:ITpoint, A<>B.
Proof.
intros.
assert (T:=Ilower_dim).
elim (eq_dec A beeson_s_axioms.PA).
intro.

*****
H : eq A beeson_s_axioms.PA
T : and (not (IT beeson_s_axioms.PC beeson_s_axioms.PA beeson_s_axioms.PB))\n (and\n (not (IT beeson_s_axioms.PA beeson_s_axioms.PC beeson_s_axioms.PB))\n (not (IT beeson_s_axioms.PA beeson_s_axioms.PB beeson_s_axioms.PC)))
A : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
ex (fun B : ITpoint => not (eq A B))
+++++
subst.
-----
Lemma another_point : forall A, exists B:ITpoint, A<>B.
Proof.
intros.
assert (T:=Ilower_dim).
elim (eq_dec A beeson_s_axioms.PA).
intro.
subst.

*****
T : and (not (IT beeson_s_axioms.PC beeson_s_axioms.PA beeson_s_axioms.PB))\n (and\n (not (IT beeson_s_axioms.PA beeson_s_axioms.PC beeson_s_axioms.PB))\n (not (IT beeson_s_axioms.PA beeson_s_axioms.PB beeson_s_axioms.PC)))
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
ex (fun B : ITpoint => not (eq beeson_s_axioms.PA B))
+++++
elim (eq_dec beeson_s_axioms.PA beeson_s_axioms.PB).
-----
Lemma another_point : forall A, exists B:ITpoint, A<>B.
Proof.
intros.
assert (T:=Ilower_dim).
elim (eq_dec A beeson_s_axioms.PA).
intro.
subst.
elim (eq_dec beeson_s_axioms.PA beeson_s_axioms.PB).

*****
T : and (not (IT beeson_s_axioms.PC beeson_s_axioms.PA beeson_s_axioms.PB))\n (and\n (not (IT beeson_s_axioms.PA beeson_s_axioms.PC beeson_s_axioms.PB))\n (not (IT beeson_s_axioms.PA beeson_s_axioms.PB beeson_s_axioms.PC)))
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
forall _ : eq beeson_s_axioms.PA beeson_s_axioms.PB, ex (fun B : ITpoint => not (eq beeson_s_axioms.PA B))
+++++
intro.
-----
Lemma another_point : forall A, exists B:ITpoint, A<>B.
Proof.
intros.
assert (T:=Ilower_dim).
elim (eq_dec A beeson_s_axioms.PA).
intro.
subst.
elim (eq_dec beeson_s_axioms.PA beeson_s_axioms.PB).
intro.

*****
H : eq beeson_s_axioms.PA beeson_s_axioms.PB
T : and (not (IT beeson_s_axioms.PC beeson_s_axioms.PA beeson_s_axioms.PB))\n (and\n (not (IT beeson_s_axioms.PA beeson_s_axioms.PC beeson_s_axioms.PB))\n (not (IT beeson_s_axioms.PA beeson_s_axioms.PB beeson_s_axioms.PC)))
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
ex (fun B : ITpoint => not (eq beeson_s_axioms.PA B))
+++++
rewrite <- H in *.
-----
Lemma another_point : forall A, exists B:ITpoint, A<>B.
Proof.
intros.
assert (T:=Ilower_dim).
elim (eq_dec A beeson_s_axioms.PA).
intro.
subst.
elim (eq_dec beeson_s_axioms.PA beeson_s_axioms.PB).
intro.
rewrite <- H in *.

*****
H : eq beeson_s_axioms.PA beeson_s_axioms.PB
T : and (not (IT beeson_s_axioms.PC beeson_s_axioms.PA beeson_s_axioms.PA))\n (and\n (not (IT beeson_s_axioms.PA beeson_s_axioms.PC beeson_s_axioms.PA))\n (not (IT beeson_s_axioms.PA beeson_s_axioms.PA beeson_s_axioms.PC)))
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
ex (fun B : ITpoint => not (eq beeson_s_axioms.PA B))
+++++
exfalso.
-----
Lemma another_point : forall A, exists B:ITpoint, A<>B.
Proof.
intros.
assert (T:=Ilower_dim).
elim (eq_dec A beeson_s_axioms.PA).
intro.
subst.
elim (eq_dec beeson_s_axioms.PA beeson_s_axioms.PB).
intro.
rewrite <- H in *.
exfalso.

*****
H : eq beeson_s_axioms.PA beeson_s_axioms.PB
T : and (not (IT beeson_s_axioms.PC beeson_s_axioms.PA beeson_s_axioms.PA))\n (and\n (not (IT beeson_s_axioms.PA beeson_s_axioms.PC beeson_s_axioms.PA))\n (not (IT beeson_s_axioms.PA beeson_s_axioms.PA beeson_s_axioms.PC)))
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
False
+++++
apply T.
-----
Lemma another_point : forall A, exists B:ITpoint, A<>B.
Proof.
intros.
assert (T:=Ilower_dim).
elim (eq_dec A beeson_s_axioms.PA).
intro.
subst.
elim (eq_dec beeson_s_axioms.PA beeson_s_axioms.PB).
intro.
rewrite <- H in *.
exfalso.
apply T.

*****
H : eq beeson_s_axioms.PA beeson_s_axioms.PB
T : and (not (IT beeson_s_axioms.PC beeson_s_axioms.PA beeson_s_axioms.PA))\n (and\n (not (IT beeson_s_axioms.PA beeson_s_axioms.PC beeson_s_axioms.PA))\n (not (IT beeson_s_axioms.PA beeson_s_axioms.PA beeson_s_axioms.PC)))
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
IT beeson_s_axioms.PA beeson_s_axioms.PA beeson_s_axioms.PC
+++++
apply IT_trivial.
-----
Lemma another_point : forall A, exists B:ITpoint, A<>B.
Proof.
intros.
assert (T:=Ilower_dim).
elim (eq_dec A beeson_s_axioms.PA).
intro.
subst.
elim (eq_dec beeson_s_axioms.PA beeson_s_axioms.PB).

*****
T : and (not (IT beeson_s_axioms.PC beeson_s_axioms.PA beeson_s_axioms.PB))\n (and\n (not (IT beeson_s_axioms.PA beeson_s_axioms.PC beeson_s_axioms.PB))\n (not (IT beeson_s_axioms.PA beeson_s_axioms.PB beeson_s_axioms.PC)))
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
forall _ : not (eq beeson_s_axioms.PA beeson_s_axioms.PB), ex (fun B : ITpoint => not (eq beeson_s_axioms.PA B))
+++++
intro.
-----
Lemma another_point : forall A, exists B:ITpoint, A<>B.
Proof.
intros.
assert (T:=Ilower_dim).
elim (eq_dec A beeson_s_axioms.PA).
intro.
subst.
elim (eq_dec beeson_s_axioms.PA beeson_s_axioms.PB).
intro.

*****
H : not (eq beeson_s_axioms.PA beeson_s_axioms.PB)
T : and (not (IT beeson_s_axioms.PC beeson_s_axioms.PA beeson_s_axioms.PB))\n (and\n (not (IT beeson_s_axioms.PA beeson_s_axioms.PC beeson_s_axioms.PB))\n (not (IT beeson_s_axioms.PA beeson_s_axioms.PB beeson_s_axioms.PC)))
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
ex (fun B : ITpoint => not (eq beeson_s_axioms.PA B))
+++++
exists beeson_s_axioms.PB.
-----
Lemma another_point : forall A, exists B:ITpoint, A<>B.
Proof.
intros.
assert (T:=Ilower_dim).
elim (eq_dec A beeson_s_axioms.PA).
intro.
subst.
elim (eq_dec beeson_s_axioms.PA beeson_s_axioms.PB).
intro.
exists beeson_s_axioms.PB.

*****
H : not (eq beeson_s_axioms.PA beeson_s_axioms.PB)
T : and (not (IT beeson_s_axioms.PC beeson_s_axioms.PA beeson_s_axioms.PB))\n (and\n (not (IT beeson_s_axioms.PA beeson_s_axioms.PC beeson_s_axioms.PB))\n (not (IT beeson_s_axioms.PA beeson_s_axioms.PB beeson_s_axioms.PC)))
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
not (eq beeson_s_axioms.PA beeson_s_axioms.PB)
+++++
assumption.
-----
Lemma another_point : forall A, exists B:ITpoint, A<>B.
Proof.
intros.
assert (T:=Ilower_dim).
elim (eq_dec A beeson_s_axioms.PA).

*****
T : and (not (IT beeson_s_axioms.PC beeson_s_axioms.PA beeson_s_axioms.PB))\n (and\n (not (IT beeson_s_axioms.PA beeson_s_axioms.PC beeson_s_axioms.PB))\n (not (IT beeson_s_axioms.PA beeson_s_axioms.PB beeson_s_axioms.PC)))
A : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
forall _ : not (eq A beeson_s_axioms.PA), ex (fun B : ITpoint => not (eq A B))
+++++
intro.
-----
Lemma another_point : forall A, exists B:ITpoint, A<>B.
Proof.
intros.
assert (T:=Ilower_dim).
elim (eq_dec A beeson_s_axioms.PA).
intro.

*****
H : not (eq A beeson_s_axioms.PA)
T : and (not (IT beeson_s_axioms.PC beeson_s_axioms.PA beeson_s_axioms.PB))\n (and\n (not (IT beeson_s_axioms.PA beeson_s_axioms.PC beeson_s_axioms.PB))\n (not (IT beeson_s_axioms.PA beeson_s_axioms.PB beeson_s_axioms.PC)))
A : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
ex (fun B : ITpoint => not (eq A B))
+++++
exists beeson_s_axioms.PA.
-----
Lemma another_point : forall A, exists B:ITpoint, A<>B.
Proof.
intros.
assert (T:=Ilower_dim).
elim (eq_dec A beeson_s_axioms.PA).
intro.
exists beeson_s_axioms.PA.

*****
H : not (eq A beeson_s_axioms.PA)
T : and (not (IT beeson_s_axioms.PC beeson_s_axioms.PA beeson_s_axioms.PB))\n (and\n (not (IT beeson_s_axioms.PA beeson_s_axioms.PC beeson_s_axioms.PB))\n (not (IT beeson_s_axioms.PA beeson_s_axioms.PB beeson_s_axioms.PC)))
A : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
not (eq A beeson_s_axioms.PA)
+++++
assumption.
-----
Lemma another_point : forall A, exists B:ITpoint, A<>B.
Proof.
intros.
assert (T:=Ilower_dim).
elim (eq_dec A beeson_s_axioms.PA).

*****

*****

+++++
Qed.
-----
Lemma segment_construction :\n forall A B C D : ITpoint,\n        exists E : ITpoint, BetT A B E /\ ICong B E C D.
-----
Lemma segment_construction : forall A B C D : ITpoint, exists E : ITpoint, BetT A B E /\\ ICong B E C D.

*****
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
forall A B C D : ITpoint, ex (fun E : ITpoint => and (BetT A B E) (ICong B E C D))
+++++
Proof.
-----
Lemma segment_construction : forall A B C D : ITpoint, exists E : ITpoint, BetT A B E /\\ ICong B E C D.
Proof.

*****
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
forall A B C D : ITpoint, ex (fun E : ITpoint => and (BetT A B E) (ICong B E C D))
+++++
intros.
-----
Lemma segment_construction : forall A B C D : ITpoint, exists E : ITpoint, BetT A B E /\\ ICong B E C D.
Proof.
intros.

*****
A,B,C,D : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
ex (fun E : ITpoint => and (BetT A B E) (ICong B E C D))
+++++
induction (eq_dec A B).
-----
Lemma segment_construction : forall A B C D : ITpoint, exists E : ITpoint, BetT A B E /\\ ICong B E C D.
Proof.
intros.
induction (eq_dec A B).

*****
H : eq A B
A,B,C,D : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
ex (fun E : ITpoint => and (BetT A B E) (ICong B E C D))
+++++
subst.
-----
Lemma segment_construction : forall A B C D : ITpoint, exists E : ITpoint, BetT A B E /\\ ICong B E C D.
Proof.
intros.
induction (eq_dec A B).
subst.

*****
B,C,D : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
ex (fun E : ITpoint => and (BetT B B E) (ICong B E C D))
+++++
elim (another_point B).
-----
Lemma segment_construction : forall A B C D : ITpoint, exists E : ITpoint, BetT A B E /\\ ICong B E C D.
Proof.
intros.
induction (eq_dec A B).
subst.
elim (another_point B).

*****
B,C,D : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
forall (x : ITpoint) (_ : not (eq B x)), ex (fun E : ITpoint => and (BetT B B E) (ICong B E C D))
+++++
intros.
-----
Lemma segment_construction : forall A B C D : ITpoint, exists E : ITpoint, BetT A B E /\\ ICong B E C D.
Proof.
intros.
induction (eq_dec A B).
subst.
elim (another_point B).
intros.

*****
H : not (eq B x)
B,C,D,x : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
ex (fun E : ITpoint => and (BetT B B E) (ICong B E C D))
+++++
elim (Isegment_construction x B C D).
-----
Lemma segment_construction : forall A B C D : ITpoint, exists E : ITpoint, BetT A B E /\\ ICong B E C D.
Proof.
intros.
induction (eq_dec A B).
subst.
elim (another_point B).
intros.
elim (Isegment_construction x B C D).

*****
H : not (eq B x)
B,C,D,x : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
forall (x0 : ITpoint) (_ : and (IT x B x0) (ICong B x0 C D)), ex (fun E : ITpoint => and (BetT B B E) (ICong B E C D))
+++++
intros.
-----
Lemma segment_construction : forall A B C D : ITpoint, exists E : ITpoint, BetT A B E /\\ ICong B E C D.
Proof.
intros.
induction (eq_dec A B).
subst.
elim (another_point B).
intros.
elim (Isegment_construction x B C D).
intros.

*****
H0 : and (IT x B x0) (ICong B x0 C D)
x0 : ITpoint
H : not (eq B x)
B,C,D,x : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
ex (fun E : ITpoint => and (BetT B B E) (ICong B E C D))
+++++
exists x0.
-----
Lemma segment_construction : forall A B C D : ITpoint, exists E : ITpoint, BetT A B E /\\ ICong B E C D.
Proof.
intros.
induction (eq_dec A B).
subst.
elim (another_point B).
intros.
elim (Isegment_construction x B C D).
intros.
exists x0.

*****
H0 : and (IT x B x0) (ICong B x0 C D)
x0 : ITpoint
H : not (eq B x)
B,C,D,x : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
and (BetT B B x0) (ICong B x0 C D)
+++++
split.
-----
Lemma segment_construction : forall A B C D : ITpoint, exists E : ITpoint, BetT A B E /\\ ICong B E C D.
Proof.
intros.
induction (eq_dec A B).
subst.
elim (another_point B).
intros.
elim (Isegment_construction x B C D).
intros.
exists x0.
split.

*****
H0 : and (IT x B x0) (ICong B x0 C D)
x0 : ITpoint
H : not (eq B x)
B,C,D,x : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
BetT B B x0
+++++
unfold BetT.
-----
Lemma segment_construction : forall A B C D : ITpoint, exists E : ITpoint, BetT A B E /\\ ICong B E C D.
Proof.
intros.
induction (eq_dec A B).
subst.
elim (another_point B).
intros.
elim (Isegment_construction x B C D).
intros.
exists x0.
split.
unfold BetT.

*****
H0 : and (IT x B x0) (ICong B x0 C D)
x0 : ITpoint
H : not (eq B x)
B,C,D,x : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
or (IBet B B x0) (or (eq B B) (eq B x0))
+++++
intuition.
-----
Lemma segment_construction : forall A B C D : ITpoint, exists E : ITpoint, BetT A B E /\\ ICong B E C D.
Proof.
intros.
induction (eq_dec A B).
subst.
elim (another_point B).
intros.
elim (Isegment_construction x B C D).
intros.
exists x0.
split.

*****
H0 : and (IT x B x0) (ICong B x0 C D)
x0 : ITpoint
H : not (eq B x)
B,C,D,x : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
ICong B x0 C D
+++++
intuition.
-----
Lemma segment_construction : forall A B C D : ITpoint, exists E : ITpoint, BetT A B E /\\ ICong B E C D.
Proof.
intros.
induction (eq_dec A B).
subst.
elim (another_point B).
intros.
elim (Isegment_construction x B C D).

*****
H : not (eq B x)
B,C,D,x : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
not (eq x B)
+++++
intros.
-----
Lemma segment_construction : forall A B C D : ITpoint, exists E : ITpoint, BetT A B E /\\ ICong B E C D.
Proof.
intros.
induction (eq_dec A B).
subst.
elim (another_point B).
intros.
elim (Isegment_construction x B C D).
intros.

*****
H : not (eq B x)
B,C,D,x : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
not (eq x B)
+++++
intuition.
-----
Lemma segment_construction : forall A B C D : ITpoint, exists E : ITpoint, BetT A B E /\\ ICong B E C D.
Proof.
intros.
induction (eq_dec A B).

*****
H : not (eq A B)
A,B,C,D : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
ex (fun E : ITpoint => and (BetT A B E) (ICong B E C D))
+++++
elim (Isegment_construction A B C D H).
-----
Lemma segment_construction : forall A B C D : ITpoint, exists E : ITpoint, BetT A B E /\\ ICong B E C D.
Proof.
intros.
induction (eq_dec A B).
elim (Isegment_construction A B C D H).

*****
H : not (eq A B)
A,B,C,D : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
forall (x : ITpoint) (_ : and (IT A B x) (ICong B x C D)), ex (fun E : ITpoint => and (BetT A B E) (ICong B E C D))
+++++
intros.
-----
Lemma segment_construction : forall A B C D : ITpoint, exists E : ITpoint, BetT A B E /\\ ICong B E C D.
Proof.
intros.
induction (eq_dec A B).
elim (Isegment_construction A B C D H).
intros.

*****
H0 : and (IT A B x) (ICong B x C D)
x : ITpoint
H : not (eq A B)
A,B,C,D : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
ex (fun E : ITpoint => and (BetT A B E) (ICong B E C D))
+++++
exists x.
-----
Lemma segment_construction : forall A B C D : ITpoint, exists E : ITpoint, BetT A B E /\\ ICong B E C D.
Proof.
intros.
induction (eq_dec A B).
elim (Isegment_construction A B C D H).
intros.
exists x.

*****
H0 : and (IT A B x) (ICong B x C D)
x : ITpoint
H : not (eq A B)
A,B,C,D : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
and (BetT A B x) (ICong B x C D)
+++++
spliter.
-----
Lemma segment_construction : forall A B C D : ITpoint, exists E : ITpoint, BetT A B E /\\ ICong B E C D.
Proof.
intros.
induction (eq_dec A B).
elim (Isegment_construction A B C D H).
intros.
exists x.
spliter.

*****
H1 : ICong B x C D
H0 : IT A B x
x : ITpoint
H : not (eq A B)
A,B,C,D : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
and (BetT A B x) (ICong B x C D)
+++++
split.
-----
Lemma segment_construction : forall A B C D : ITpoint, exists E : ITpoint, BetT A B E /\\ ICong B E C D.
Proof.
intros.
induction (eq_dec A B).
elim (Isegment_construction A B C D H).
intros.
exists x.
spliter.
split.

*****
H1 : ICong B x C D
H0 : IT A B x
x : ITpoint
H : not (eq A B)
A,B,C,D : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
BetT A B x
+++++
try assumption.
-----
Lemma segment_construction : forall A B C D : ITpoint, exists E : ITpoint, BetT A B E /\\ ICong B E C D.
Proof.
intros.
induction (eq_dec A B).
elim (Isegment_construction A B C D H).
intros.
exists x.
spliter.
split.
try assumption.

*****
H1 : ICong B x C D
H0 : IT A B x
x : ITpoint
H : not (eq A B)
A,B,C,D : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
BetT A B x
+++++
unfold IT in *.
-----
Lemma segment_construction : forall A B C D : ITpoint, exists E : ITpoint, BetT A B E /\\ ICong B E C D.
Proof.
intros.
induction (eq_dec A B).
elim (Isegment_construction A B C D H).
intros.
exists x.
spliter.
split.
try assumption.
unfold IT in *.

*****
H1 : ICong B x C D
H0 : not (and (not (eq A B)) (and (not (eq B x)) (not (IBet A B x))))
x : ITpoint
H : not (eq A B)
A,B,C,D : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
BetT A B x
+++++
unfold BetT.
-----
Lemma segment_construction : forall A B C D : ITpoint, exists E : ITpoint, BetT A B E /\\ ICong B E C D.
Proof.
intros.
induction (eq_dec A B).
elim (Isegment_construction A B C D H).
intros.
exists x.
spliter.
split.
try assumption.
unfold IT in *.
unfold BetT.

*****
H1 : ICong B x C D
H0 : not (and (not (eq A B)) (and (not (eq B x)) (not (IBet A B x))))
x : ITpoint
H : not (eq A B)
A,B,C,D : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
or (IBet A B x) (or (eq A B) (eq B x))
+++++
tauto.
-----
Lemma segment_construction : forall A B C D : ITpoint, exists E : ITpoint, BetT A B E /\\ ICong B E C D.
Proof.
intros.
induction (eq_dec A B).
elim (Isegment_construction A B C D H).
intros.
exists x.
spliter.
split.

*****
H1 : ICong B x C D
H0 : IT A B x
x : ITpoint
H : not (eq A B)
A,B,C,D : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
ICong B x C D
+++++
try assumption.
-----
Lemma segment_construction : forall A B C D : ITpoint, exists E : ITpoint, BetT A B E /\\ ICong B E C D.
Proof.
intros.
induction (eq_dec A B).

*****

*****

+++++
Qed.
-----
Lemma lower_dim :\n  ~ (BetT beeson_s_axioms.PA beeson_s_axioms.PB beeson_s_axioms.PC \/ \n     BetT beeson_s_axioms.PB beeson_s_axioms.PC beeson_s_axioms.PA \/ \n     BetT beeson_s_axioms.PC beeson_s_axioms.PA beeson_s_axioms.PB).
-----
Lemma lower_dim : ~ (BetT beeson_s_axioms.PA beeson_s_axioms.PB beeson_s_axioms.PC \\/ BetT beeson_s_axioms.PB beeson_s_axioms.PC beeson_s_axioms.PA \\/ BetT beeson_s_axioms.PC beeson_s_axioms.PA beeson_s_axioms.PB).

*****
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
not (or (BetT beeson_s_axioms.PA beeson_s_axioms.PB beeson_s_axioms.PC) (or (BetT beeson_s_axioms.PB beeson_s_axioms.PC beeson_s_axioms.PA) (BetT beeson_s_axioms.PC beeson_s_axioms.PA beeson_s_axioms.PB)))
+++++
Proof.
-----
Lemma lower_dim : ~ (BetT beeson_s_axioms.PA beeson_s_axioms.PB beeson_s_axioms.PC \\/ BetT beeson_s_axioms.PB beeson_s_axioms.PC beeson_s_axioms.PA \\/ BetT beeson_s_axioms.PC beeson_s_axioms.PA beeson_s_axioms.PB).
Proof.

*****
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
not (or (BetT beeson_s_axioms.PA beeson_s_axioms.PB beeson_s_axioms.PC) (or (BetT beeson_s_axioms.PB beeson_s_axioms.PC beeson_s_axioms.PA) (BetT beeson_s_axioms.PC beeson_s_axioms.PA beeson_s_axioms.PB)))
+++++
assert (T:=Ilower_dim).
-----
Lemma lower_dim : ~ (BetT beeson_s_axioms.PA beeson_s_axioms.PB beeson_s_axioms.PC \\/ BetT beeson_s_axioms.PB beeson_s_axioms.PC beeson_s_axioms.PA \\/ BetT beeson_s_axioms.PC beeson_s_axioms.PA beeson_s_axioms.PB).
Proof.
assert (T:=Ilower_dim).

*****
T : and (not (IT beeson_s_axioms.PC beeson_s_axioms.PA beeson_s_axioms.PB))\n (and\n (not (IT beeson_s_axioms.PA beeson_s_axioms.PC beeson_s_axioms.PB))\n (not (IT beeson_s_axioms.PA beeson_s_axioms.PB beeson_s_axioms.PC)))
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
not (or (BetT beeson_s_axioms.PA beeson_s_axioms.PB beeson_s_axioms.PC) (or (BetT beeson_s_axioms.PB beeson_s_axioms.PC beeson_s_axioms.PA) (BetT beeson_s_axioms.PC beeson_s_axioms.PA beeson_s_axioms.PB)))
+++++
unfold BetT in *.
-----
Lemma lower_dim : ~ (BetT beeson_s_axioms.PA beeson_s_axioms.PB beeson_s_axioms.PC \\/ BetT beeson_s_axioms.PB beeson_s_axioms.PC beeson_s_axioms.PA \\/ BetT beeson_s_axioms.PC beeson_s_axioms.PA beeson_s_axioms.PB).
Proof.
assert (T:=Ilower_dim).
unfold BetT in *.

*****
T : and (not (IT beeson_s_axioms.PC beeson_s_axioms.PA beeson_s_axioms.PB))\n (and\n (not (IT beeson_s_axioms.PA beeson_s_axioms.PC beeson_s_axioms.PB))\n (not (IT beeson_s_axioms.PA beeson_s_axioms.PB beeson_s_axioms.PC)))
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
not (or (or (IBet beeson_s_axioms.PA beeson_s_axioms.PB beeson_s_axioms.PC) (or (eq beeson_s_axioms.PA beeson_s_axioms.PB) (eq beeson_s_axioms.PB beeson_s_axioms.PC))) (or (or (IBet beeson_s_axioms.PB beeson_s_axioms.PC beeson_s_axioms.PA) (or (eq beeson_s_axioms.PB beeson_s_axioms.PC) (eq beeson_s_axioms.PC beeson_s_axioms.PA))) (or (IBet beeson_s_axioms.PC beeson_s_axioms.PA beeson_s_axioms.PB) (or (eq beeson_s_axioms.PC beeson_s_axioms.PA) (eq beeson_s_axioms.PA beeson_s_axioms.PB)))))
+++++
unfold ICol in *.
-----
Lemma lower_dim : ~ (BetT beeson_s_axioms.PA beeson_s_axioms.PB beeson_s_axioms.PC \\/ BetT beeson_s_axioms.PB beeson_s_axioms.PC beeson_s_axioms.PA \\/ BetT beeson_s_axioms.PC beeson_s_axioms.PA beeson_s_axioms.PB).
Proof.
assert (T:=Ilower_dim).
unfold BetT in *.
unfold ICol in *.

*****
T : and (not (IT beeson_s_axioms.PC beeson_s_axioms.PA beeson_s_axioms.PB))\n (and\n (not (IT beeson_s_axioms.PA beeson_s_axioms.PC beeson_s_axioms.PB))\n (not (IT beeson_s_axioms.PA beeson_s_axioms.PB beeson_s_axioms.PC)))
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
not (or (or (IBet beeson_s_axioms.PA beeson_s_axioms.PB beeson_s_axioms.PC) (or (eq beeson_s_axioms.PA beeson_s_axioms.PB) (eq beeson_s_axioms.PB beeson_s_axioms.PC))) (or (or (IBet beeson_s_axioms.PB beeson_s_axioms.PC beeson_s_axioms.PA) (or (eq beeson_s_axioms.PB beeson_s_axioms.PC) (eq beeson_s_axioms.PC beeson_s_axioms.PA))) (or (IBet beeson_s_axioms.PC beeson_s_axioms.PA beeson_s_axioms.PB) (or (eq beeson_s_axioms.PC beeson_s_axioms.PA) (eq beeson_s_axioms.PA beeson_s_axioms.PB)))))
+++++
unfold IT in *.
-----
Lemma lower_dim : ~ (BetT beeson_s_axioms.PA beeson_s_axioms.PB beeson_s_axioms.PC \\/ BetT beeson_s_axioms.PB beeson_s_axioms.PC beeson_s_axioms.PA \\/ BetT beeson_s_axioms.PC beeson_s_axioms.PA beeson_s_axioms.PB).
Proof.
assert (T:=Ilower_dim).
unfold BetT in *.
unfold ICol in *.
unfold IT in *.

*****
T : and\n (not\n (not\n (and (not (eq beeson_s_axioms.PC beeson_s_axioms.PA))\n (and (not (eq beeson_s_axioms.PA beeson_s_axioms.PB))\n (not\n (IBet beeson_s_axioms.PC beeson_s_axioms.PA\n beeson_s_axioms.PB))))))\n (and\n (not\n (not\n (and (not (eq beeson_s_axioms.PA beeson_s_axioms.PC))\n (and (not (eq beeson_s_axioms.PC beeson_s_axioms.PB))\n (not\n (IBet beeson_s_axioms.PA beeson_s_axioms.PC\n beeson_s_axioms.PB))))))\n (not\n (not\n (and (not (eq beeson_s_axioms.PA beeson_s_axioms.PB))\n (and (not (eq beeson_s_axioms.PB beeson_s_axioms.PC))\n (not\n (IBet beeson_s_axioms.PA beeson_s_axioms.PB\n beeson_s_axioms.PC)))))))
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
not (or (or (IBet beeson_s_axioms.PA beeson_s_axioms.PB beeson_s_axioms.PC) (or (eq beeson_s_axioms.PA beeson_s_axioms.PB) (eq beeson_s_axioms.PB beeson_s_axioms.PC))) (or (or (IBet beeson_s_axioms.PB beeson_s_axioms.PC beeson_s_axioms.PA) (or (eq beeson_s_axioms.PB beeson_s_axioms.PC) (eq beeson_s_axioms.PC beeson_s_axioms.PA))) (or (IBet beeson_s_axioms.PC beeson_s_axioms.PA beeson_s_axioms.PB) (or (eq beeson_s_axioms.PC beeson_s_axioms.PA) (eq beeson_s_axioms.PA beeson_s_axioms.PB)))))
+++++
firstorder using Ibetween_symmetry.
-----
Lemma lower_dim : ~ (BetT beeson_s_axioms.PA beeson_s_axioms.PB beeson_s_axioms.PC \\/ BetT beeson_s_axioms.PB beeson_s_axioms.PC beeson_s_axioms.PA \\/ BetT beeson_s_axioms.PC beeson_s_axioms.PA beeson_s_axioms.PB).
Proof.
assert (T:=Ilower_dim).
unfold BetT in *.
unfold ICol in *.
unfold IT in *.
firstorder using Ibetween_symmetry.

*****

*****

+++++
Qed.
-----
Lemma eq_dec_points_from_classic : forall A B : ITpoint, A = B \/ A <> B.
-----
Lemma eq_dec_points_from_classic : forall A B : ITpoint, A = B \\/ A <> B.

*****
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
forall A B : ITpoint, or (eq A B) (not (eq A B))
+++++
Proof.
-----
Lemma eq_dec_points_from_classic : forall A B : ITpoint, A = B \\/ A <> B.
Proof.

*****
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
forall A B : ITpoint, or (eq A B) (not (eq A B))
+++++
intros.
-----
Lemma eq_dec_points_from_classic : forall A B : ITpoint, A = B \\/ A <> B.
Proof.
intros.

*****
A,B : ITpoint
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
or (eq A B) (not (eq A B))
+++++
apply classic.
-----
Lemma eq_dec_points_from_classic : forall A B : ITpoint, A = B \\/ A <> B.
Proof.
intros.
apply classic.

*****

*****

+++++
Qed.
-----
Instance IT_to_T : Tarski_neutral_dimensionless.
-----
Instance IT_to_T : Tarski_neutral_dimensionless.

*****
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
Tarski_neutral_dimensionless
+++++
exact (Build_Tarski_neutral_dimensionless ITpoint BetT ICong Icong_pseudo_reflexivity Icong_inner_transitivity Icong_identity segment_construction five_segment bet_id pasch beeson_s_axioms.PA beeson_s_axioms.PB beeson_s_axioms.PC lower_dim).
-----
Instance IT_to_T : Tarski_neutral_dimensionless.
exact (Build_Tarski_neutral_dimensionless ITpoint BetT ICong Icong_pseudo_reflexivity Icong_inner_transitivity Icong_identity segment_construction five_segment bet_id pasch beeson_s_axioms.PA beeson_s_axioms.PB beeson_s_axioms.PC lower_dim).

*****

*****

+++++
Defined.
-----
Instance IT_to_TID :\n  Tarski_neutral_dimensionless_with_decidable_point_equality IT_to_T.
-----
Instance IT_to_TID : Tarski_neutral_dimensionless_with_decidable_point_equality IT_to_T.

*****
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
Tarski_neutral_dimensionless_with_decidable_point_equality IT_to_T
+++++
Proof.
-----
Instance IT_to_TID : Tarski_neutral_dimensionless_with_decidable_point_equality IT_to_T.
Proof.

*****
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
Tarski_neutral_dimensionless_with_decidable_point_equality IT_to_T
+++++
split.
-----
Instance IT_to_TID : Tarski_neutral_dimensionless_with_decidable_point_equality IT_to_T.
Proof.
split.

*****
BTn : intuitionistic_Tarski_neutral_dimensionless
*****
forall A B : Tpoint, or (eq A B) (not (eq A B))
+++++
apply eq_dec_points_from_classic.
-----
Instance IT_to_TID : Tarski_neutral_dimensionless_with_decidable_point_equality IT_to_T.
Proof.
split.
apply eq_dec_points_from_classic.

*****

*****

+++++
Defined.
-----
End Intuitionistic_Tarski_to_Tarski.
-----
