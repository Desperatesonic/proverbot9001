Unset Standard Proposition Elimination Names.
-----
Hypothesis Nam : Set.
-----
Inductive op : Set :=\n  | Pub : op\n  | Priv : op\n  | Hash : op.
-----
Lemma op_eq_dec : forall o1 o2 : op, {o1 = o2} + {o1 <> o2}.
-----
Lemma op_eq_dec : forall o1 o2 : op, {o1 = o2} + {o1 <> o2}.

*****

*****
forall o1 o2 : op, sumbool (eq o1 o2) (not (eq o1 o2))
+++++
simple destruct o1.
-----
Lemma op_eq_dec : forall o1 o2 : op, {o1 = o2} + {o1 <> o2}.
simple destruct o1.

*****
o1 : op
*****
forall o2 : op, sumbool (eq Pub o2) (not (eq Pub o2))
+++++
simple destruct o2.
-----
Lemma op_eq_dec : forall o1 o2 : op, {o1 = o2} + {o1 <> o2}.
simple destruct o1.
simple destruct o2.

*****
o1,o2 : op
*****
sumbool (eq Pub Pub) (not (eq Pub Pub))
+++++
try auto.
-----
Lemma op_eq_dec : forall o1 o2 : op, {o1 = o2} + {o1 <> o2}.
simple destruct o1.
simple destruct o2.

*****
o1,o2 : op
*****
sumbool (eq Pub Priv) (not (eq Pub Priv))
+++++
try auto.
-----
Lemma op_eq_dec : forall o1 o2 : op, {o1 = o2} + {o1 <> o2}.
simple destruct o1.
simple destruct o2.
try auto.

*****
o1,o2 : op
*****
sumbool (eq Pub Priv) (not (eq Pub Priv))
+++++
try (right; red in |- *; intro; inversion H).
-----
Lemma op_eq_dec : forall o1 o2 : op, {o1 = o2} + {o1 <> o2}.
simple destruct o1.
simple destruct o2.

*****
o1,o2 : op
*****
sumbool (eq Pub Hash) (not (eq Pub Hash))
+++++
try auto.
-----
Lemma op_eq_dec : forall o1 o2 : op, {o1 = o2} + {o1 <> o2}.
simple destruct o1.
simple destruct o2.
try auto.

*****
o1,o2 : op
*****
sumbool (eq Pub Hash) (not (eq Pub Hash))
+++++
try (right; red in |- *; intro; inversion H).
-----
Lemma op_eq_dec : forall o1 o2 : op, {o1 = o2} + {o1 <> o2}.
simple destruct o1.

*****
o1 : op
*****
forall o2 : op, sumbool (eq Priv o2) (not (eq Priv o2))
+++++
simple destruct o2.
-----
Lemma op_eq_dec : forall o1 o2 : op, {o1 = o2} + {o1 <> o2}.
simple destruct o1.
simple destruct o2.

*****
o1,o2 : op
*****
sumbool (eq Priv Pub) (not (eq Priv Pub))
+++++
try auto.
-----
Lemma op_eq_dec : forall o1 o2 : op, {o1 = o2} + {o1 <> o2}.
simple destruct o1.
simple destruct o2.
try auto.

*****
o1,o2 : op
*****
sumbool (eq Priv Pub) (not (eq Priv Pub))
+++++
try (right; red in |- *; intro; inversion H).
-----
Lemma op_eq_dec : forall o1 o2 : op, {o1 = o2} + {o1 <> o2}.
simple destruct o1.
simple destruct o2.

*****
o1,o2 : op
*****
sumbool (eq Priv Priv) (not (eq Priv Priv))
+++++
try auto.
-----
Lemma op_eq_dec : forall o1 o2 : op, {o1 = o2} + {o1 <> o2}.
simple destruct o1.
simple destruct o2.

*****
o1,o2 : op
*****
sumbool (eq Priv Hash) (not (eq Priv Hash))
+++++
try auto.
-----
Lemma op_eq_dec : forall o1 o2 : op, {o1 = o2} + {o1 <> o2}.
simple destruct o1.
simple destruct o2.
try auto.

*****
o1,o2 : op
*****
sumbool (eq Priv Hash) (not (eq Priv Hash))
+++++
try (right; red in |- *; intro; inversion H).
-----
Lemma op_eq_dec : forall o1 o2 : op, {o1 = o2} + {o1 <> o2}.
simple destruct o1.

*****
o1 : op
*****
forall o2 : op, sumbool (eq Hash o2) (not (eq Hash o2))
+++++
simple destruct o2.
-----
Lemma op_eq_dec : forall o1 o2 : op, {o1 = o2} + {o1 <> o2}.
simple destruct o1.
simple destruct o2.

*****
o1,o2 : op
*****
sumbool (eq Hash Pub) (not (eq Hash Pub))
+++++
try auto.
-----
Lemma op_eq_dec : forall o1 o2 : op, {o1 = o2} + {o1 <> o2}.
simple destruct o1.
simple destruct o2.
try auto.

*****
o1,o2 : op
*****
sumbool (eq Hash Pub) (not (eq Hash Pub))
+++++
try (right; red in |- *; intro; inversion H).
-----
Lemma op_eq_dec : forall o1 o2 : op, {o1 = o2} + {o1 <> o2}.
simple destruct o1.
simple destruct o2.

*****
o1,o2 : op
*****
sumbool (eq Hash Priv) (not (eq Hash Priv))
+++++
try auto.
-----
Lemma op_eq_dec : forall o1 o2 : op, {o1 = o2} + {o1 <> o2}.
simple destruct o1.
simple destruct o2.
try auto.

*****
o1,o2 : op
*****
sumbool (eq Hash Priv) (not (eq Hash Priv))
+++++
try (right; red in |- *; intro; inversion H).
-----
Lemma op_eq_dec : forall o1 o2 : op, {o1 = o2} + {o1 <> o2}.
simple destruct o1.
simple destruct o2.

*****
o1,o2 : op
*****
sumbool (eq Hash Hash) (not (eq Hash Hash))
+++++
try auto.
-----
Lemma op_eq_dec : forall o1 o2 : op, {o1 = o2} + {o1 <> o2}.
simple destruct o1.

*****

*****

+++++
Qed.
-----
Definition inv_op (o : op) : op :=\n  match o with\n  | Pub => Priv\n  | Priv => Pub\n  | _ => o\n  end.
-----
Inductive Msg : Set :=\n  | MNam : Nam -> Msg\n  | MEnc : Msg -> Msg -> Msg\n  | MPair : Msg -> Msg -> Msg\n  | Mop : op -> Msg -> Msg.
-----
Definition inv (M : Msg) : Msg :=\n  match M with\n  | Mop op M => Mop (inv_op op) M\n  | _ => M\n  end.
-----
Lemma inv_invol : forall M : Msg, inv (inv M) = M.
-----
Lemma inv_invol : forall M : Msg, inv (inv M) = M.

*****

*****
forall M : Msg, eq (inv (inv M)) M
+++++
simple induction M.
-----
Lemma inv_invol : forall M : Msg, inv (inv M) = M.
simple induction M.

*****
M : Msg
*****
forall n : Nam, eq (inv (inv (MNam n))) (MNam n)
+++++
simpl in |- *.
-----
Lemma inv_invol : forall M : Msg, inv (inv M) = M.
simple induction M.
simpl in |- *.

*****
M : Msg
*****
forall n : Nam, eq (MNam n) (MNam n)
+++++
trivial.
-----
Lemma inv_invol : forall M : Msg, inv (inv M) = M.
simple induction M.

*****
M : Msg
*****
forall (m : Msg) (_ : eq (inv (inv m)) m) (m0 : Msg) (_ : eq (inv (inv m0)) m0), eq (inv (inv (MEnc m m0))) (MEnc m m0)
+++++
simpl in |- *.
-----
Lemma inv_invol : forall M : Msg, inv (inv M) = M.
simple induction M.
simpl in |- *.

*****
M : Msg
*****
forall (m : Msg) (_ : eq (inv (inv m)) m) (m0 : Msg) (_ : eq (inv (inv m0)) m0), eq (MEnc m m0) (MEnc m m0)
+++++
trivial.
-----
Lemma inv_invol : forall M : Msg, inv (inv M) = M.
simple induction M.

*****
M : Msg
*****
forall (m : Msg) (_ : eq (inv (inv m)) m) (m0 : Msg) (_ : eq (inv (inv m0)) m0), eq (inv (inv (MPair m m0))) (MPair m m0)
+++++
simpl in |- *.
-----
Lemma inv_invol : forall M : Msg, inv (inv M) = M.
simple induction M.
simpl in |- *.

*****
M : Msg
*****
forall (m : Msg) (_ : eq (inv (inv m)) m) (m0 : Msg) (_ : eq (inv (inv m0)) m0), eq (MPair m m0) (MPair m m0)
+++++
trivial.
-----
Lemma inv_invol : forall M : Msg, inv (inv M) = M.
simple induction M.

*****
M : Msg
*****
forall (o : op) (m : Msg) (_ : eq (inv (inv m)) m), eq (inv (inv (Mop o m))) (Mop o m)
+++++
simpl in |- *.
-----
Lemma inv_invol : forall M : Msg, inv (inv M) = M.
simple induction M.
simpl in |- *.

*****
M : Msg
*****
forall (o : op) (m : Msg) (_ : eq (inv (inv m)) m), eq (Mop (inv_op (inv_op o)) m) (Mop o m)
+++++
trivial.
-----
Lemma inv_invol : forall M : Msg, inv (inv M) = M.
simple induction M.
simpl in |- *.
trivial.

*****
M : Msg
*****
forall (o : op) (m : Msg) (_ : eq (inv (inv m)) m), eq (Mop (inv_op (inv_op o)) m) (Mop o m)
+++++
simple destruct o.
-----
Lemma inv_invol : forall M : Msg, inv (inv M) = M.
simple induction M.
simpl in |- *.
trivial.
simple destruct o.

*****
o : op
M : Msg
*****
forall (m : Msg) (_ : eq (inv (inv m)) m), eq (Mop (inv_op (inv_op Pub)) m) (Mop Pub m)
+++++
simpl in |- *.
-----
Lemma inv_invol : forall M : Msg, inv (inv M) = M.
simple induction M.
simpl in |- *.
trivial.
simple destruct o.
simpl in |- *.

*****
o : op
M : Msg
*****
forall (m : Msg) (_ : eq (inv (inv m)) m), eq (Mop Pub m) (Mop Pub m)
+++++
trivial.
-----
Lemma inv_invol : forall M : Msg, inv (inv M) = M.
simple induction M.
simpl in |- *.
trivial.
simple destruct o.

*****
o : op
M : Msg
*****
forall (m : Msg) (_ : eq (inv (inv m)) m), eq (Mop (inv_op (inv_op Priv)) m) (Mop Priv m)
+++++
simpl in |- *.
-----
Lemma inv_invol : forall M : Msg, inv (inv M) = M.
simple induction M.
simpl in |- *.
trivial.
simple destruct o.
simpl in |- *.

*****
o : op
M : Msg
*****
forall (m : Msg) (_ : eq (inv (inv m)) m), eq (Mop Priv m) (Mop Priv m)
+++++
trivial.
-----
Lemma inv_invol : forall M : Msg, inv (inv M) = M.
simple induction M.
simpl in |- *.
trivial.
simple destruct o.

*****
o : op
M : Msg
*****
forall (m : Msg) (_ : eq (inv (inv m)) m), eq (Mop (inv_op (inv_op Hash)) m) (Mop Hash m)
+++++
simpl in |- *.
-----
Lemma inv_invol : forall M : Msg, inv (inv M) = M.
simple induction M.
simpl in |- *.
trivial.
simple destruct o.
simpl in |- *.

*****
o : op
M : Msg
*****
forall (m : Msg) (_ : eq (inv (inv m)) m), eq (Mop Hash m) (Mop Hash m)
+++++
trivial.
-----
Lemma inv_invol : forall M : Msg, inv (inv M) = M.
simple induction M.

*****

*****

+++++
Qed.
-----
Definition hedge := Msg -> Msg -> Prop.
-----
Require Import Classical_Prop.
-----
Lemma hedge_mem_dec : forall (h : hedge) (M N : Msg), h M N \/ ~ h M N.
-----
Lemma hedge_mem_dec : forall (h : hedge) (M N : Msg), h M N \\/ ~ h M N.

*****

*****
forall (h : hedge) (M N : Msg), or (h M N) (not (h M N))
+++++
intros.
-----
Lemma hedge_mem_dec : forall (h : hedge) (M N : Msg), h M N \\/ ~ h M N.
intros.

*****
M,N : Msg
h : hedge
*****
or (h M N) (not (h M N))
+++++
apply (classic (h M N)).
-----
Lemma hedge_mem_dec : forall (h : hedge) (M N : Msg), h M N \\/ ~ h M N.
intros.
apply (classic (h M N)).

*****

*****

+++++
Qed.
-----
Definition inclusion (g h : hedge) := forall M N : Msg, g M N -> h M N.
-----
Definition equal (g h : hedge) := inclusion g h /\ inclusion h g.
-----
Lemma inclusion_refl : forall h : hedge, inclusion h h.
-----
Lemma inclusion_refl : forall h : hedge, inclusion h h.

*****

*****
forall h : hedge, inclusion h h
+++++
unfold inclusion in |- *.
-----
Lemma inclusion_refl : forall h : hedge, inclusion h h.
unfold inclusion in |- *.

*****

*****
forall (h : hedge) (M N : Msg) (_ : h M N), h M N
+++++
trivial.
-----
Lemma inclusion_refl : forall h : hedge, inclusion h h.
unfold inclusion in |- *.
trivial.

*****

*****

+++++
Qed.
-----
Lemma inclusion_trans :\n forall f g h : hedge, inclusion f g -> inclusion g h -> inclusion f h.
-----
Lemma inclusion_trans : forall f g h : hedge, inclusion f g -> inclusion g h -> inclusion f h.

*****

*****
forall (f g h : hedge) (_ : inclusion f g) (_ : inclusion g h), inclusion f h
+++++
unfold inclusion in |- *.
-----
Lemma inclusion_trans : forall f g h : hedge, inclusion f g -> inclusion g h -> inclusion f h.
unfold inclusion in |- *.

*****

*****
forall (f g h : hedge) (_ : forall (M N : Msg) (_ : f M N), g M N) (_ : forall (M N : Msg) (_ : g M N), h M N) (M N : Msg) (_ : f M N), h M N
+++++
intros.
-----
Lemma inclusion_trans : forall f g h : hedge, inclusion f g -> inclusion g h -> inclusion f h.
unfold inclusion in |- *.
intros.

*****
H1 : f M N
M,N : Msg
H0 : forall (M N : Msg) (_ : g M N), h M N
H : forall (M N : Msg) (_ : f M N), g M N
f,g,h : hedge
*****
h M N
+++++
apply H0.
-----
Lemma inclusion_trans : forall f g h : hedge, inclusion f g -> inclusion g h -> inclusion f h.
unfold inclusion in |- *.
intros.
apply H0.

*****
H1 : f M N
M,N : Msg
H0 : forall (M N : Msg) (_ : g M N), h M N
H : forall (M N : Msg) (_ : f M N), g M N
f,g,h : hedge
*****
g M N
+++++
apply H.
-----
Lemma inclusion_trans : forall f g h : hedge, inclusion f g -> inclusion g h -> inclusion f h.
unfold inclusion in |- *.
intros.
apply H0.
apply H.

*****
H1 : f M N
M,N : Msg
H0 : forall (M N : Msg) (_ : g M N), h M N
H : forall (M N : Msg) (_ : f M N), g M N
f,g,h : hedge
*****
f M N
+++++
trivial.
-----
Lemma inclusion_trans : forall f g h : hedge, inclusion f g -> inclusion g h -> inclusion f h.
unfold inclusion in |- *.
intros.
apply H0.
apply H.
trivial.

*****

*****

+++++
Qed.
-----
Lemma inclusion_antisym :\n forall f g : hedge, inclusion f g -> inclusion g f -> equal f g.
-----
Lemma inclusion_antisym : forall f g : hedge, inclusion f g -> inclusion g f -> equal f g.

*****

*****
forall (f g : hedge) (_ : inclusion f g) (_ : inclusion g f), equal f g
+++++
unfold equal in |- *.
-----
Lemma inclusion_antisym : forall f g : hedge, inclusion f g -> inclusion g f -> equal f g.
unfold equal in |- *.

*****

*****
forall (f g : hedge) (_ : inclusion f g) (_ : inclusion g f), and (inclusion f g) (inclusion g f)
+++++
tauto.
-----
Lemma inclusion_antisym : forall f g : hedge, inclusion f g -> inclusion g f -> equal f g.
unfold equal in |- *.
tauto.

*****

*****

+++++
Qed.
-----
Lemma equal_refl : forall h : hedge, equal h h.
-----
Lemma equal_refl : forall h : hedge, equal h h.

*****

*****
forall h : hedge, equal h h
+++++
unfold equal in |- *.
-----
Lemma equal_refl : forall h : hedge, equal h h.
unfold equal in |- *.

*****

*****
forall h : hedge, and (inclusion h h) (inclusion h h)
+++++
intro.
-----
Lemma equal_refl : forall h : hedge, equal h h.
unfold equal in |- *.
intro.

*****
h : hedge
*****
and (inclusion h h) (inclusion h h)
+++++
split.
-----
Lemma equal_refl : forall h : hedge, equal h h.
unfold equal in |- *.
intro.
split.

*****
h : hedge
*****
inclusion h h
+++++
apply inclusion_refl.
-----
Lemma equal_refl : forall h : hedge, equal h h.
unfold equal in |- *.
intro.
split.

*****
h : hedge
*****
inclusion h h
+++++
apply inclusion_refl.
-----
Lemma equal_refl : forall h : hedge, equal h h.
unfold equal in |- *.
intro.
split.

*****

*****

+++++
Qed.
-----
Lemma equal_sym : forall g h : hedge, equal g h -> equal h g.
-----
Lemma equal_sym : forall g h : hedge, equal g h -> equal h g.

*****

*****
forall (g h : hedge) (_ : equal g h), equal h g
+++++
unfold equal in |- *.
-----
Lemma equal_sym : forall g h : hedge, equal g h -> equal h g.
unfold equal in |- *.

*****

*****
forall (g h : hedge) (_ : and (inclusion g h) (inclusion h g)), and (inclusion h g) (inclusion g h)
+++++
intros.
-----
Lemma equal_sym : forall g h : hedge, equal g h -> equal h g.
unfold equal in |- *.
intros.

*****
H : and (inclusion g h) (inclusion h g)
g,h : hedge
*****
and (inclusion h g) (inclusion g h)
+++++
elim H.
-----
Lemma equal_sym : forall g h : hedge, equal g h -> equal h g.
unfold equal in |- *.
intros.
elim H.

*****
H : and (inclusion g h) (inclusion h g)
g,h : hedge
*****
forall (_ : inclusion g h) (_ : inclusion h g), and (inclusion h g) (inclusion g h)
+++++
tauto.
-----
Lemma equal_sym : forall g h : hedge, equal g h -> equal h g.
unfold equal in |- *.
intros.
elim H.
tauto.

*****

*****

+++++
Qed.
-----
Lemma equal_trans : forall f g h : hedge, equal f g -> equal g h -> equal f h.
-----
Lemma equal_trans : forall f g h : hedge, equal f g -> equal g h -> equal f h.

*****

*****
forall (f g h : hedge) (_ : equal f g) (_ : equal g h), equal f h
+++++
unfold equal in |- *.
-----
Lemma equal_trans : forall f g h : hedge, equal f g -> equal g h -> equal f h.
unfold equal in |- *.

*****

*****
forall (f g h : hedge) (_ : and (inclusion f g) (inclusion g f)) (_ : and (inclusion g h) (inclusion h g)), and (inclusion f h) (inclusion h f)
+++++
intros.
-----
Lemma equal_trans : forall f g h : hedge, equal f g -> equal g h -> equal f h.
unfold equal in |- *.
intros.

*****
H0 : and (inclusion g h) (inclusion h g)
H : and (inclusion f g) (inclusion g f)
f,g,h : hedge
*****
and (inclusion f h) (inclusion h f)
+++++
elim H.
-----
Lemma equal_trans : forall f g h : hedge, equal f g -> equal g h -> equal f h.
unfold equal in |- *.
intros.
elim H.

*****
H0 : and (inclusion g h) (inclusion h g)
H : and (inclusion f g) (inclusion g f)
f,g,h : hedge
*****
forall (_ : inclusion f g) (_ : inclusion g f), and (inclusion f h) (inclusion h f)
+++++
elim H0.
-----
Lemma equal_trans : forall f g h : hedge, equal f g -> equal g h -> equal f h.
unfold equal in |- *.
intros.
elim H.
elim H0.

*****
H0 : and (inclusion g h) (inclusion h g)
H : and (inclusion f g) (inclusion g f)
f,g,h : hedge
*****
forall (_ : inclusion g h) (_ : inclusion h g) (_ : inclusion f g) (_ : inclusion g f), and (inclusion f h) (inclusion h f)
+++++
intros.
-----
Lemma equal_trans : forall f g h : hedge, equal f g -> equal g h -> equal f h.
unfold equal in |- *.
intros.
elim H.
elim H0.
intros.

*****
H4 : inclusion g f
H3 : inclusion f g
H2 : inclusion h g
H1 : inclusion g h
H0 : and (inclusion g h) (inclusion h g)
H : and (inclusion f g) (inclusion g f)
f,g,h : hedge
*****
and (inclusion f h) (inclusion h f)
+++++
split.
-----
Lemma equal_trans : forall f g h : hedge, equal f g -> equal g h -> equal f h.
unfold equal in |- *.
intros.
elim H.
elim H0.
intros.
split.

*****
H4 : inclusion g f
H3 : inclusion f g
H2 : inclusion h g
H1 : inclusion g h
H0 : and (inclusion g h) (inclusion h g)
H : and (inclusion f g) (inclusion g f)
f,g,h : hedge
*****
inclusion f h
+++++
apply inclusion_trans with g.
-----
Lemma equal_trans : forall f g h : hedge, equal f g -> equal g h -> equal f h.
unfold equal in |- *.
intros.
elim H.
elim H0.
intros.
split.
apply inclusion_trans with g.

*****
H4 : inclusion g f
H3 : inclusion f g
H2 : inclusion h g
H1 : inclusion g h
H0 : and (inclusion g h) (inclusion h g)
H : and (inclusion f g) (inclusion g f)
f,g,h : hedge
*****
inclusion f g
+++++
trivial.
-----
Lemma equal_trans : forall f g h : hedge, equal f g -> equal g h -> equal f h.
unfold equal in |- *.
intros.
elim H.
elim H0.
intros.
split.
apply inclusion_trans with g.

*****
H4 : inclusion g f
H3 : inclusion f g
H2 : inclusion h g
H1 : inclusion g h
H0 : and (inclusion g h) (inclusion h g)
H : and (inclusion f g) (inclusion g f)
f,g,h : hedge
*****
inclusion g h
+++++
trivial.
-----
Lemma equal_trans : forall f g h : hedge, equal f g -> equal g h -> equal f h.
unfold equal in |- *.
intros.
elim H.
elim H0.
intros.
split.

*****
H4 : inclusion g f
H3 : inclusion f g
H2 : inclusion h g
H1 : inclusion g h
H0 : and (inclusion g h) (inclusion h g)
H : and (inclusion f g) (inclusion g f)
f,g,h : hedge
*****
inclusion h f
+++++
apply inclusion_trans with g.
-----
Lemma equal_trans : forall f g h : hedge, equal f g -> equal g h -> equal f h.
unfold equal in |- *.
intros.
elim H.
elim H0.
intros.
split.
apply inclusion_trans with g.

*****
H4 : inclusion g f
H3 : inclusion f g
H2 : inclusion h g
H1 : inclusion g h
H0 : and (inclusion g h) (inclusion h g)
H : and (inclusion f g) (inclusion g f)
f,g,h : hedge
*****
inclusion h g
+++++
trivial.
-----
Lemma equal_trans : forall f g h : hedge, equal f g -> equal g h -> equal f h.
unfold equal in |- *.
intros.
elim H.
elim H0.
intros.
split.
apply inclusion_trans with g.

*****
H4 : inclusion g f
H3 : inclusion f g
H2 : inclusion h g
H1 : inclusion g h
H0 : and (inclusion g h) (inclusion h g)
H : and (inclusion f g) (inclusion g f)
f,g,h : hedge
*****
inclusion g f
+++++
trivial.
-----
Lemma equal_trans : forall f g h : hedge, equal f g -> equal g h -> equal f h.
unfold equal in |- *.
intros.
elim H.
elim H0.
intros.
split.

*****

*****

+++++
Qed.
-----
Definition union (g h : hedge) (M N : Msg) := g M N \/ h M N.
-----
Definition inter (g h : hedge) (M N : Msg) := g M N /\ h M N.
-----
Lemma union_sym : forall g h : hedge, equal (union g h) (union h g).
-----
Lemma union_sym : forall g h : hedge, equal (union g h) (union h g).

*****

*****
forall g h : hedge, equal (union g h) (union h g)
+++++
unfold union in |- *.
-----
Lemma union_sym : forall g h : hedge, equal (union g h) (union h g).
unfold union in |- *.

*****

*****
forall g h : hedge, equal (fun M N : Msg => or (g M N) (h M N)) (fun M N : Msg => or (h M N) (g M N))
+++++
unfold equal in |- *.
-----
Lemma union_sym : forall g h : hedge, equal (union g h) (union h g).
unfold union in |- *.
unfold equal in |- *.

*****

*****
forall g h : hedge, and (inclusion (fun M N : Msg => or (g M N) (h M N)) (fun M N : Msg => or (h M N) (g M N))) (inclusion (fun M N : Msg => or (h M N) (g M N)) (fun M N : Msg => or (g M N) (h M N)))
+++++
intros.
-----
Lemma union_sym : forall g h : hedge, equal (union g h) (union h g).
unfold union in |- *.
unfold equal in |- *.
intros.

*****
g,h : hedge
*****
and (inclusion (fun M N : Msg => or (g M N) (h M N)) (fun M N : Msg => or (h M N) (g M N))) (inclusion (fun M N : Msg => or (h M N) (g M N)) (fun M N : Msg => or (g M N) (h M N)))
+++++
unfold inclusion in |- *.
-----
Lemma union_sym : forall g h : hedge, equal (union g h) (union h g).
unfold union in |- *.
unfold equal in |- *.
intros.
unfold inclusion in |- *.

*****
g,h : hedge
*****
and (forall (M N : Msg) (_ : or (g M N) (h M N)), or (h M N) (g M N)) (forall (M N : Msg) (_ : or (h M N) (g M N)), or (g M N) (h M N))
+++++
tauto.
-----
Lemma union_sym : forall g h : hedge, equal (union g h) (union h g).
unfold union in |- *.
unfold equal in |- *.
intros.
unfold inclusion in |- *.
tauto.

*****

*****

+++++
Qed.
-----
Lemma inter_sym : forall g h : hedge, equal (inter g h) (inter h g).
-----
Lemma inter_sym : forall g h : hedge, equal (inter g h) (inter h g).

*****

*****
forall g h : hedge, equal (inter g h) (inter h g)
+++++
unfold inter in |- *.
-----
Lemma inter_sym : forall g h : hedge, equal (inter g h) (inter h g).
unfold inter in |- *.

*****

*****
forall g h : hedge, equal (fun M N : Msg => and (g M N) (h M N)) (fun M N : Msg => and (h M N) (g M N))
+++++
unfold equal in |- *.
-----
Lemma inter_sym : forall g h : hedge, equal (inter g h) (inter h g).
unfold inter in |- *.
unfold equal in |- *.

*****

*****
forall g h : hedge, and (inclusion (fun M N : Msg => and (g M N) (h M N)) (fun M N : Msg => and (h M N) (g M N))) (inclusion (fun M N : Msg => and (h M N) (g M N)) (fun M N : Msg => and (g M N) (h M N)))
+++++
intros.
-----
Lemma inter_sym : forall g h : hedge, equal (inter g h) (inter h g).
unfold inter in |- *.
unfold equal in |- *.
intros.

*****
g,h : hedge
*****
and (inclusion (fun M N : Msg => and (g M N) (h M N)) (fun M N : Msg => and (h M N) (g M N))) (inclusion (fun M N : Msg => and (h M N) (g M N)) (fun M N : Msg => and (g M N) (h M N)))
+++++
unfold inclusion in |- *.
-----
Lemma inter_sym : forall g h : hedge, equal (inter g h) (inter h g).
unfold inter in |- *.
unfold equal in |- *.
intros.
unfold inclusion in |- *.

*****
g,h : hedge
*****
and (forall (M N : Msg) (_ : and (g M N) (h M N)), and (h M N) (g M N)) (forall (M N : Msg) (_ : and (h M N) (g M N)), and (g M N) (h M N))
+++++
tauto.
-----
Lemma inter_sym : forall g h : hedge, equal (inter g h) (inter h g).
unfold inter in |- *.
unfold equal in |- *.
intros.
unfold inclusion in |- *.
tauto.

*****

*****

+++++
Qed.
-----
Lemma hedge_left_union : forall g h : hedge, inclusion g (union g h).
-----
Lemma hedge_left_union : forall g h : hedge, inclusion g (union g h).

*****

*****
forall g h : hedge, inclusion g (union g h)
+++++
unfold union in |- *.
-----
Lemma hedge_left_union : forall g h : hedge, inclusion g (union g h).
unfold union in |- *.

*****

*****
forall g h : hedge, inclusion g (fun M N : Msg => or (g M N) (h M N))
+++++
unfold inclusion in |- *.
-----
Lemma hedge_left_union : forall g h : hedge, inclusion g (union g h).
unfold union in |- *.
unfold inclusion in |- *.

*****

*****
forall (g h : hedge) (M N : Msg) (_ : g M N), or (g M N) (h M N)
+++++
tauto.
-----
Lemma hedge_left_union : forall g h : hedge, inclusion g (union g h).
unfold union in |- *.
unfold inclusion in |- *.
tauto.

*****

*****

+++++
Qed.
-----
Lemma hedge_right_union : forall g h : hedge, inclusion h (union g h).
-----
Lemma hedge_right_union : forall g h : hedge, inclusion h (union g h).

*****

*****
forall g h : hedge, inclusion h (union g h)
+++++
unfold union in |- *.
-----
Lemma hedge_right_union : forall g h : hedge, inclusion h (union g h).
unfold union in |- *.

*****

*****
forall g h : hedge, inclusion h (fun M N : Msg => or (g M N) (h M N))
+++++
unfold inclusion in |- *.
-----
Lemma hedge_right_union : forall g h : hedge, inclusion h (union g h).
unfold union in |- *.
unfold inclusion in |- *.

*****

*****
forall (g h : hedge) (M N : Msg) (_ : h M N), or (g M N) (h M N)
+++++
tauto.
-----
Lemma hedge_right_union : forall g h : hedge, inclusion h (union g h).
unfold union in |- *.
unfold inclusion in |- *.
tauto.

*****

*****

+++++
Qed.
-----
Lemma inter_hedge_left : forall g h : hedge, inclusion (inter g h) g.
-----
Lemma inter_hedge_left : forall g h : hedge, inclusion (inter g h) g.

*****

*****
forall g h : hedge, inclusion (inter g h) g
+++++
unfold inter in |- *.
-----
Lemma inter_hedge_left : forall g h : hedge, inclusion (inter g h) g.
unfold inter in |- *.

*****

*****
forall g h : hedge, inclusion (fun M N : Msg => and (g M N) (h M N)) g
+++++
unfold inclusion in |- *.
-----
Lemma inter_hedge_left : forall g h : hedge, inclusion (inter g h) g.
unfold inter in |- *.
unfold inclusion in |- *.

*****

*****
forall (g h : hedge) (M N : Msg) (_ : and (g M N) (h M N)), g M N
+++++
tauto.
-----
Lemma inter_hedge_left : forall g h : hedge, inclusion (inter g h) g.
unfold inter in |- *.
unfold inclusion in |- *.
tauto.

*****

*****

+++++
Qed.
-----
Lemma inter_hedge_right : forall g h : hedge, inclusion (inter g h) h.
-----
Lemma inter_hedge_right : forall g h : hedge, inclusion (inter g h) h.

*****

*****
forall g h : hedge, inclusion (inter g h) h
+++++
unfold inter in |- *.
-----
Lemma inter_hedge_right : forall g h : hedge, inclusion (inter g h) h.
unfold inter in |- *.

*****

*****
forall g h : hedge, inclusion (fun M N : Msg => and (g M N) (h M N)) h
+++++
unfold inclusion in |- *.
-----
Lemma inter_hedge_right : forall g h : hedge, inclusion (inter g h) h.
unfold inter in |- *.
unfold inclusion in |- *.

*****

*****
forall (g h : hedge) (M N : Msg) (_ : and (g M N) (h M N)), h M N
+++++
tauto.
-----
Lemma inter_hedge_right : forall g h : hedge, inclusion (inter g h) h.
unfold inter in |- *.
unfold inclusion in |- *.
tauto.

*****

*****

+++++
Qed.
-----
Lemma union_intro :\n forall f g h : hedge,\n inclusion f h -> inclusion g h -> inclusion (union f g) h.
-----
Lemma union_intro : forall f g h : hedge, inclusion f h -> inclusion g h -> inclusion (union f g) h.

*****

*****
forall (f g h : hedge) (_ : inclusion f h) (_ : inclusion g h), inclusion (union f g) h
+++++
unfold inclusion in |- *.
-----
Lemma union_intro : forall f g h : hedge, inclusion f h -> inclusion g h -> inclusion (union f g) h.
unfold inclusion in |- *.

*****

*****
forall (f g h : hedge) (_ : forall (M N : Msg) (_ : f M N), h M N) (_ : forall (M N : Msg) (_ : g M N), h M N) (M N : Msg) (_ : union f g M N), h M N
+++++
unfold union in |- *.
-----
Lemma union_intro : forall f g h : hedge, inclusion f h -> inclusion g h -> inclusion (union f g) h.
unfold inclusion in |- *.
unfold union in |- *.

*****

*****
forall (f g h : hedge) (_ : forall (M N : Msg) (_ : f M N), h M N) (_ : forall (M N : Msg) (_ : g M N), h M N) (M N : Msg) (_ : or (f M N) (g M N)), h M N
+++++
intros.
-----
Lemma union_intro : forall f g h : hedge, inclusion f h -> inclusion g h -> inclusion (union f g) h.
unfold inclusion in |- *.
unfold union in |- *.
intros.

*****
H1 : or (f M N) (g M N)
M,N : Msg
H0 : forall (M N : Msg) (_ : g M N), h M N
H : forall (M N : Msg) (_ : f M N), h M N
f,g,h : hedge
*****
h M N
+++++
case H1.
-----
Lemma union_intro : forall f g h : hedge, inclusion f h -> inclusion g h -> inclusion (union f g) h.
unfold inclusion in |- *.
unfold union in |- *.
intros.
case H1.

*****
H1 : or (f M N) (g M N)
M,N : Msg
H0 : forall (M N : Msg) (_ : g M N), h M N
H : forall (M N : Msg) (_ : f M N), h M N
f,g,h : hedge
*****
forall _ : f M N, h M N
+++++
apply H.
-----
Lemma union_intro : forall f g h : hedge, inclusion f h -> inclusion g h -> inclusion (union f g) h.
unfold inclusion in |- *.
unfold union in |- *.
intros.
case H1.

*****
H1 : or (f M N) (g M N)
M,N : Msg
H0 : forall (M N : Msg) (_ : g M N), h M N
H : forall (M N : Msg) (_ : f M N), h M N
f,g,h : hedge
*****
forall _ : g M N, h M N
+++++
apply H0.
-----
Lemma union_intro : forall f g h : hedge, inclusion f h -> inclusion g h -> inclusion (union f g) h.
unfold inclusion in |- *.
unfold union in |- *.
intros.
case H1.

*****

*****

+++++
Qed.
-----
Lemma inter_inclusion_union :\n forall g h : hedge, inclusion (inter g h) (union g h).
-----
Lemma inter_inclusion_union : forall g h : hedge, inclusion (inter g h) (union g h).

*****

*****
forall g h : hedge, inclusion (inter g h) (union g h)
+++++
intros.
-----
Lemma inter_inclusion_union : forall g h : hedge, inclusion (inter g h) (union g h).
intros.

*****
g,h : hedge
*****
inclusion (inter g h) (union g h)
+++++
unfold union in |- *.
-----
Lemma inter_inclusion_union : forall g h : hedge, inclusion (inter g h) (union g h).
intros.
unfold union in |- *.

*****
g,h : hedge
*****
inclusion (inter g h) (fun M N : Msg => or (g M N) (h M N))
+++++
unfold inter in |- *.
-----
Lemma inter_inclusion_union : forall g h : hedge, inclusion (inter g h) (union g h).
intros.
unfold union in |- *.
unfold inter in |- *.

*****
g,h : hedge
*****
inclusion (fun M N : Msg => and (g M N) (h M N)) (fun M N : Msg => or (g M N) (h M N))
+++++
unfold inclusion in |- *.
-----
Lemma inter_inclusion_union : forall g h : hedge, inclusion (inter g h) (union g h).
intros.
unfold union in |- *.
unfold inter in |- *.
unfold inclusion in |- *.

*****
g,h : hedge
*****
forall (M N : Msg) (_ : and (g M N) (h M N)), or (g M N) (h M N)
+++++
tauto.
-----
Lemma inter_inclusion_union : forall g h : hedge, inclusion (inter g h) (union g h).
intros.
unfold union in |- *.
unfold inter in |- *.
unfold inclusion in |- *.
tauto.

*****

*****

+++++
Qed.
-----
Inductive synthesis (h : hedge) : hedge :=\n  | SynInc : forall M N : Msg, h M N -> synthesis h M N\n  | SynEnc :\n      forall M N K L : Msg,\n      synthesis h M N -> synthesis h K L -> synthesis h (MEnc M K) (MEnc N L)\n  | SynPair :\n      forall M1 N1 M2 N2 : Msg,\n      synthesis h M1 N1 ->\n      synthesis h M2 N2 -> synthesis h (MPair M1 M2) (MPair N1 N2)\n  | SynOp :\n      forall (o : op) (M N : Msg),\n      synthesis h M N -> synthesis h (Mop o M) (Mop o N).
-----
Theorem nam_left_syn :\n forall (h : hedge) (a : Nam) (N : Msg),\n synthesis h (MNam a) N -> h (MNam a) N.
-----
Theorem nam_left_syn : forall (h : hedge) (a : Nam) (N : Msg), synthesis h (MNam a) N -> h (MNam a) N.

*****

*****
forall (h : hedge) (a : Nam) (N : Msg) (_ : synthesis h (MNam a) N), h (MNam a) N
+++++
intros.
-----
Theorem nam_left_syn : forall (h : hedge) (a : Nam) (N : Msg), synthesis h (MNam a) N -> h (MNam a) N.
intros.

*****
H : synthesis h (MNam a) N
N : Msg
a : Nam
h : hedge
*****
h (MNam a) N
+++++
inversion H.
-----
Theorem nam_left_syn : forall (h : hedge) (a : Nam) (N : Msg), synthesis h (MNam a) N -> h (MNam a) N.
intros.
inversion H.

*****
H2 : eq N0 N
H1 : eq M (MNam a)
H0 : h (MNam a) N
M,N0 : Msg
H : synthesis h (MNam a) N
N : Msg
a : Nam
h : hedge
*****
h (MNam a) N
+++++
trivial.
-----
Theorem nam_left_syn : forall (h : hedge) (a : Nam) (N : Msg), synthesis h (MNam a) N -> h (MNam a) N.
intros.
inversion H.
trivial.

*****

*****

+++++
Qed.
-----
Theorem nam_right_syn :\n forall (h : hedge) (M : Msg) (b : Nam),\n synthesis h M (MNam b) -> h M (MNam b).
-----
Theorem nam_right_syn : forall (h : hedge) (M : Msg) (b : Nam), synthesis h M (MNam b) -> h M (MNam b).

*****

*****
forall (h : hedge) (M : Msg) (b : Nam) (_ : synthesis h M (MNam b)), h M (MNam b)
+++++
intros.
-----
Theorem nam_right_syn : forall (h : hedge) (M : Msg) (b : Nam), synthesis h M (MNam b) -> h M (MNam b).
intros.

*****
H : synthesis h M (MNam b)
b : Nam
M : Msg
h : hedge
*****
h M (MNam b)
+++++
inversion H.
-----
Theorem nam_right_syn : forall (h : hedge) (M : Msg) (b : Nam), synthesis h M (MNam b) -> h M (MNam b).
intros.
inversion H.

*****
H2 : eq N (MNam b)
H1 : eq M0 M
H0 : h M (MNam b)
M0,N : Msg
H : synthesis h M (MNam b)
b : Nam
M : Msg
h : hedge
*****
h M (MNam b)
+++++
trivial.
-----
Theorem nam_right_syn : forall (h : hedge) (M : Msg) (b : Nam), synthesis h M (MNam b) -> h M (MNam b).
intros.
inversion H.
trivial.

*****

*****

+++++
Qed.
-----
Lemma h_incl_syn : forall h : hedge, inclusion h (synthesis h).
-----
Lemma h_incl_syn : forall h : hedge, inclusion h (synthesis h).

*****

*****
forall h : hedge, inclusion h (synthesis h)
+++++
unfold inclusion in |- *.
-----
Lemma h_incl_syn : forall h : hedge, inclusion h (synthesis h).
unfold inclusion in |- *.

*****

*****
forall (h : hedge) (M N : Msg) (_ : h M N), synthesis h M N
+++++
intros.
-----
Lemma h_incl_syn : forall h : hedge, inclusion h (synthesis h).
unfold inclusion in |- *.
intros.

*****
H : h M N
M,N : Msg
h : hedge
*****
synthesis h M N
+++++
apply SynInc.
-----
Lemma h_incl_syn : forall h : hedge, inclusion h (synthesis h).
unfold inclusion in |- *.
intros.
apply SynInc.

*****
H : h M N
M,N : Msg
h : hedge
*****
h M N
+++++
trivial.
-----
Lemma h_incl_syn : forall h : hedge, inclusion h (synthesis h).
unfold inclusion in |- *.
intros.
apply SynInc.
trivial.

*****

*****

+++++
Qed.
-----
Definition le_h (g h : hedge) := inclusion (synthesis g) (synthesis h).
-----
Definition equiv_h (g h : hedge) := le_h g h /\ le_h h g.
-----
Lemma le_h_refl : forall h : hedge, le_h h h.
-----
Lemma le_h_refl : forall h : hedge, le_h h h.

*****

*****
forall h : hedge, le_h h h
+++++
unfold le_h in |- *.
-----
Lemma le_h_refl : forall h : hedge, le_h h h.
unfold le_h in |- *.

*****

*****
forall h : hedge, inclusion (synthesis h) (synthesis h)
+++++
intro.
-----
Lemma le_h_refl : forall h : hedge, le_h h h.
unfold le_h in |- *.
intro.

*****
h : hedge
*****
inclusion (synthesis h) (synthesis h)
+++++
apply inclusion_refl.
-----
Lemma le_h_refl : forall h : hedge, le_h h h.
unfold le_h in |- *.
intro.
apply inclusion_refl.

*****

*****

+++++
Qed.
-----
Lemma le_h_trans : forall f g h : hedge, le_h f g -> le_h g h -> le_h f h.
-----
Lemma le_h_trans : forall f g h : hedge, le_h f g -> le_h g h -> le_h f h.

*****

*****
forall (f g h : hedge) (_ : le_h f g) (_ : le_h g h), le_h f h
+++++
unfold le_h in |- *.
-----
Lemma le_h_trans : forall f g h : hedge, le_h f g -> le_h g h -> le_h f h.
unfold le_h in |- *.

*****

*****
forall (f g h : hedge) (_ : inclusion (synthesis f) (synthesis g)) (_ : inclusion (synthesis g) (synthesis h)), inclusion (synthesis f) (synthesis h)
+++++
intros.
-----
Lemma le_h_trans : forall f g h : hedge, le_h f g -> le_h g h -> le_h f h.
unfold le_h in |- *.
intros.

*****
H0 : inclusion (synthesis g) (synthesis h)
H : inclusion (synthesis f) (synthesis g)
f,g,h : hedge
*****
inclusion (synthesis f) (synthesis h)
+++++
apply inclusion_trans with (synthesis g).
-----
Lemma le_h_trans : forall f g h : hedge, le_h f g -> le_h g h -> le_h f h.
unfold le_h in |- *.
intros.
apply inclusion_trans with (synthesis g).

*****
H0 : inclusion (synthesis g) (synthesis h)
H : inclusion (synthesis f) (synthesis g)
f,g,h : hedge
*****
inclusion (synthesis f) (synthesis g)
+++++
trivial.
-----
Lemma le_h_trans : forall f g h : hedge, le_h f g -> le_h g h -> le_h f h.
unfold le_h in |- *.
intros.
apply inclusion_trans with (synthesis g).

*****
H0 : inclusion (synthesis g) (synthesis h)
H : inclusion (synthesis f) (synthesis g)
f,g,h : hedge
*****
inclusion (synthesis g) (synthesis h)
+++++
trivial.
-----
Lemma le_h_trans : forall f g h : hedge, le_h f g -> le_h g h -> le_h f h.
unfold le_h in |- *.
intros.
apply inclusion_trans with (synthesis g).

*****

*****

+++++
Qed.
-----
Lemma le_h_antisym : forall g h : hedge, le_h g h -> le_h h g -> equiv_h g h.
-----
Lemma le_h_antisym : forall g h : hedge, le_h g h -> le_h h g -> equiv_h g h.

*****

*****
forall (g h : hedge) (_ : le_h g h) (_ : le_h h g), equiv_h g h
+++++
unfold equiv_h in |- *.
-----
Lemma le_h_antisym : forall g h : hedge, le_h g h -> le_h h g -> equiv_h g h.
unfold equiv_h in |- *.

*****

*****
forall (g h : hedge) (_ : le_h g h) (_ : le_h h g), and (le_h g h) (le_h h g)
+++++
tauto.
-----
Lemma le_h_antisym : forall g h : hedge, le_h g h -> le_h h g -> equiv_h g h.
unfold equiv_h in |- *.
tauto.

*****

*****

+++++
Qed.
-----
Lemma equiv_refl : forall h : hedge, equiv_h h h.
-----
Lemma equiv_refl : forall h : hedge, equiv_h h h.

*****

*****
forall h : hedge, equiv_h h h
+++++
unfold equiv_h in |- *.
-----
Lemma equiv_refl : forall h : hedge, equiv_h h h.
unfold equiv_h in |- *.

*****

*****
forall h : hedge, and (le_h h h) (le_h h h)
+++++
intro.
-----
Lemma equiv_refl : forall h : hedge, equiv_h h h.
unfold equiv_h in |- *.
intro.

*****
h : hedge
*****
and (le_h h h) (le_h h h)
+++++
split.
-----
Lemma equiv_refl : forall h : hedge, equiv_h h h.
unfold equiv_h in |- *.
intro.
split.

*****
h : hedge
*****
le_h h h
+++++
apply le_h_refl.
-----
Lemma equiv_refl : forall h : hedge, equiv_h h h.
unfold equiv_h in |- *.
intro.
split.

*****
h : hedge
*****
le_h h h
+++++
apply le_h_refl.
-----
Lemma equiv_refl : forall h : hedge, equiv_h h h.
unfold equiv_h in |- *.
intro.
split.

*****

*****

+++++
Qed.
-----
Lemma equiv_h_trans :\n forall f g h : hedge, equiv_h f g -> equiv_h g h -> equiv_h f h.
-----
Lemma equiv_h_trans : forall f g h : hedge, equiv_h f g -> equiv_h g h -> equiv_h f h.

*****

*****
forall (f g h : hedge) (_ : equiv_h f g) (_ : equiv_h g h), equiv_h f h
+++++
unfold equiv_h in |- *.
-----
Lemma equiv_h_trans : forall f g h : hedge, equiv_h f g -> equiv_h g h -> equiv_h f h.
unfold equiv_h in |- *.

*****

*****
forall (f g h : hedge) (_ : and (le_h f g) (le_h g f)) (_ : and (le_h g h) (le_h h g)), and (le_h f h) (le_h h f)
+++++
intros.
-----
Lemma equiv_h_trans : forall f g h : hedge, equiv_h f g -> equiv_h g h -> equiv_h f h.
unfold equiv_h in |- *.
intros.

*****
H0 : and (le_h g h) (le_h h g)
H : and (le_h f g) (le_h g f)
f,g,h : hedge
*****
and (le_h f h) (le_h h f)
+++++
elim H.
-----
Lemma equiv_h_trans : forall f g h : hedge, equiv_h f g -> equiv_h g h -> equiv_h f h.
unfold equiv_h in |- *.
intros.
elim H.

*****
H0 : and (le_h g h) (le_h h g)
H : and (le_h f g) (le_h g f)
f,g,h : hedge
*****
forall (_ : le_h f g) (_ : le_h g f), and (le_h f h) (le_h h f)
+++++
elim H0.
-----
Lemma equiv_h_trans : forall f g h : hedge, equiv_h f g -> equiv_h g h -> equiv_h f h.
unfold equiv_h in |- *.
intros.
elim H.
elim H0.

*****
H0 : and (le_h g h) (le_h h g)
H : and (le_h f g) (le_h g f)
f,g,h : hedge
*****
forall (_ : le_h g h) (_ : le_h h g) (_ : le_h f g) (_ : le_h g f), and (le_h f h) (le_h h f)
+++++
intros.
-----
Lemma equiv_h_trans : forall f g h : hedge, equiv_h f g -> equiv_h g h -> equiv_h f h.
unfold equiv_h in |- *.
intros.
elim H.
elim H0.
intros.

*****
H4 : le_h g f
H3 : le_h f g
H2 : le_h h g
H1 : le_h g h
H0 : and (le_h g h) (le_h h g)
H : and (le_h f g) (le_h g f)
f,g,h : hedge
*****
and (le_h f h) (le_h h f)
+++++
split.
-----
Lemma equiv_h_trans : forall f g h : hedge, equiv_h f g -> equiv_h g h -> equiv_h f h.
unfold equiv_h in |- *.
intros.
elim H.
elim H0.
intros.
split.

*****
H4 : le_h g f
H3 : le_h f g
H2 : le_h h g
H1 : le_h g h
H0 : and (le_h g h) (le_h h g)
H : and (le_h f g) (le_h g f)
f,g,h : hedge
*****
le_h f h
+++++
apply le_h_trans with g.
-----
Lemma equiv_h_trans : forall f g h : hedge, equiv_h f g -> equiv_h g h -> equiv_h f h.
unfold equiv_h in |- *.
intros.
elim H.
elim H0.
intros.
split.
apply le_h_trans with g.

*****
H4 : le_h g f
H3 : le_h f g
H2 : le_h h g
H1 : le_h g h
H0 : and (le_h g h) (le_h h g)
H : and (le_h f g) (le_h g f)
f,g,h : hedge
*****
le_h f g
+++++
trivial.
-----
Lemma equiv_h_trans : forall f g h : hedge, equiv_h f g -> equiv_h g h -> equiv_h f h.
unfold equiv_h in |- *.
intros.
elim H.
elim H0.
intros.
split.
apply le_h_trans with g.

*****
H4 : le_h g f
H3 : le_h f g
H2 : le_h h g
H1 : le_h g h
H0 : and (le_h g h) (le_h h g)
H : and (le_h f g) (le_h g f)
f,g,h : hedge
*****
le_h g h
+++++
trivial.
-----
Lemma equiv_h_trans : forall f g h : hedge, equiv_h f g -> equiv_h g h -> equiv_h f h.
unfold equiv_h in |- *.
intros.
elim H.
elim H0.
intros.
split.

*****
H4 : le_h g f
H3 : le_h f g
H2 : le_h h g
H1 : le_h g h
H0 : and (le_h g h) (le_h h g)
H : and (le_h f g) (le_h g f)
f,g,h : hedge
*****
le_h h f
+++++
apply le_h_trans with g.
-----
Lemma equiv_h_trans : forall f g h : hedge, equiv_h f g -> equiv_h g h -> equiv_h f h.
unfold equiv_h in |- *.
intros.
elim H.
elim H0.
intros.
split.
apply le_h_trans with g.

*****
H4 : le_h g f
H3 : le_h f g
H2 : le_h h g
H1 : le_h g h
H0 : and (le_h g h) (le_h h g)
H : and (le_h f g) (le_h g f)
f,g,h : hedge
*****
le_h h g
+++++
trivial.
-----
Lemma equiv_h_trans : forall f g h : hedge, equiv_h f g -> equiv_h g h -> equiv_h f h.
unfold equiv_h in |- *.
intros.
elim H.
elim H0.
intros.
split.
apply le_h_trans with g.

*****
H4 : le_h g f
H3 : le_h f g
H2 : le_h h g
H1 : le_h g h
H0 : and (le_h g h) (le_h h g)
H : and (le_h f g) (le_h g f)
f,g,h : hedge
*****
le_h g f
+++++
trivial.
-----
Lemma equiv_h_trans : forall f g h : hedge, equiv_h f g -> equiv_h g h -> equiv_h f h.
unfold equiv_h in |- *.
intros.
elim H.
elim H0.
intros.
split.

*****

*****

+++++
Qed.
-----
Lemma equiv_h_sym : forall g h : hedge, equiv_h g h -> equiv_h h g.
-----
Lemma equiv_h_sym : forall g h : hedge, equiv_h g h -> equiv_h h g.

*****

*****
forall (g h : hedge) (_ : equiv_h g h), equiv_h h g
+++++
unfold equiv_h in |- *.
-----
Lemma equiv_h_sym : forall g h : hedge, equiv_h g h -> equiv_h h g.
unfold equiv_h in |- *.

*****

*****
forall (g h : hedge) (_ : and (le_h g h) (le_h h g)), and (le_h h g) (le_h g h)
+++++
tauto.
-----
Lemma equiv_h_sym : forall g h : hedge, equiv_h g h -> equiv_h h g.
unfold equiv_h in |- *.
tauto.

*****

*****

+++++
Qed.
-----
Lemma le_h_impl_incl_syn :\n forall g h : hedge, le_h g h -> inclusion g (synthesis h).
-----
Lemma le_h_impl_incl_syn : forall g h : hedge, le_h g h -> inclusion g (synthesis h).

*****

*****
forall (g h : hedge) (_ : le_h g h), inclusion g (synthesis h)
+++++
unfold le_h in |- *.
-----
Lemma le_h_impl_incl_syn : forall g h : hedge, le_h g h -> inclusion g (synthesis h).
unfold le_h in |- *.

*****

*****
forall (g h : hedge) (_ : inclusion (synthesis g) (synthesis h)), inclusion g (synthesis h)
+++++
intros.
-----
Lemma le_h_impl_incl_syn : forall g h : hedge, le_h g h -> inclusion g (synthesis h).
unfold le_h in |- *.
intros.

*****
H : inclusion (synthesis g) (synthesis h)
g,h : hedge
*****
inclusion g (synthesis h)
+++++
apply inclusion_trans with (synthesis g).
-----
Lemma le_h_impl_incl_syn : forall g h : hedge, le_h g h -> inclusion g (synthesis h).
unfold le_h in |- *.
intros.
apply inclusion_trans with (synthesis g).

*****
H : inclusion (synthesis g) (synthesis h)
g,h : hedge
*****
inclusion g (synthesis g)
+++++
trivial.
-----
Lemma le_h_impl_incl_syn : forall g h : hedge, le_h g h -> inclusion g (synthesis h).
unfold le_h in |- *.
intros.
apply inclusion_trans with (synthesis g).
trivial.

*****
H : inclusion (synthesis g) (synthesis h)
g,h : hedge
*****
inclusion g (synthesis g)
+++++
apply h_incl_syn.
-----
Lemma le_h_impl_incl_syn : forall g h : hedge, le_h g h -> inclusion g (synthesis h).
unfold le_h in |- *.
intros.
apply inclusion_trans with (synthesis g).

*****
H : inclusion (synthesis g) (synthesis h)
g,h : hedge
*****
inclusion (synthesis g) (synthesis h)
+++++
trivial.
-----
Lemma le_h_impl_incl_syn : forall g h : hedge, le_h g h -> inclusion g (synthesis h).
unfold le_h in |- *.
intros.
apply inclusion_trans with (synthesis g).

*****

*****

+++++
Qed.
-----
Lemma incl_syn_impl_le_h :\n forall g h : hedge, inclusion g (synthesis h) -> le_h g h.
-----
Lemma incl_syn_impl_le_h : forall g h : hedge, inclusion g (synthesis h) -> le_h g h.

*****

*****
forall (g h : hedge) (_ : inclusion g (synthesis h)), le_h g h
+++++
unfold le_h in |- *.
-----
Lemma incl_syn_impl_le_h : forall g h : hedge, inclusion g (synthesis h) -> le_h g h.
unfold le_h in |- *.

*****

*****
forall (g h : hedge) (_ : inclusion g (synthesis h)), inclusion (synthesis g) (synthesis h)
+++++
unfold inclusion in |- *.
-----
Lemma incl_syn_impl_le_h : forall g h : hedge, inclusion g (synthesis h) -> le_h g h.
unfold le_h in |- *.
unfold inclusion in |- *.

*****

*****
forall (g h : hedge) (_ : forall (M N : Msg) (_ : g M N), synthesis h M N) (M N : Msg) (_ : synthesis g M N), synthesis h M N
+++++
intros.
-----
Lemma incl_syn_impl_le_h : forall g h : hedge, inclusion g (synthesis h) -> le_h g h.
unfold le_h in |- *.
unfold inclusion in |- *.
intros.

*****
H0 : synthesis g M N
M,N : Msg
H : forall (M N : Msg) (_ : g M N), synthesis h M N
g,h : hedge
*****
synthesis h M N
+++++
induction H0 as [M N H0| M N K L H0_1 HrecH0_1 H0_0 HrecH0_0| M1 N1 M2 N2 H0_1 HrecH0_1 H0_0 HrecH0_0| o M N H0 HrecH0].
-----
Lemma incl_syn_impl_le_h : forall g h : hedge, inclusion g (synthesis h) -> le_h g h.
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
induction H0 as [M N H0| M N K L H0_1 HrecH0_1 H0_0 HrecH0_0| M1 N1 M2 N2 H0_1 HrecH0_1 H0_0 HrecH0_0| o M N H0 HrecH0].

*****
H0 : g M N
M,N : Msg
H : forall (M N : Msg) (_ : g M N), synthesis h M N
g,h : hedge
*****
synthesis h M N
+++++
apply H.
-----
Lemma incl_syn_impl_le_h : forall g h : hedge, inclusion g (synthesis h) -> le_h g h.
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
induction H0 as [M N H0| M N K L H0_1 HrecH0_1 H0_0 HrecH0_0| M1 N1 M2 N2 H0_1 HrecH0_1 H0_0 HrecH0_0| o M N H0 HrecH0].
apply H.

*****
H0 : g M N
M,N : Msg
H : forall (M N : Msg) (_ : g M N), synthesis h M N
g,h : hedge
*****
g M N
+++++
trivial.
-----
Lemma incl_syn_impl_le_h : forall g h : hedge, inclusion g (synthesis h) -> le_h g h.
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
induction H0 as [M N H0| M N K L H0_1 HrecH0_1 H0_0 HrecH0_0| M1 N1 M2 N2 H0_1 HrecH0_1 H0_0 HrecH0_0| o M N H0 HrecH0].

*****
HrecH0_0 : synthesis h K L
HrecH0_1 : synthesis h M N
H0_0 : synthesis g K L
H0_1 : synthesis g M N
M,N,K,L : Msg
H : forall (M N : Msg) (_ : g M N), synthesis h M N
g,h : hedge
*****
synthesis h (MEnc M K) (MEnc N L)
+++++
apply SynEnc.
-----
Lemma incl_syn_impl_le_h : forall g h : hedge, inclusion g (synthesis h) -> le_h g h.
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
induction H0 as [M N H0| M N K L H0_1 HrecH0_1 H0_0 HrecH0_0| M1 N1 M2 N2 H0_1 HrecH0_1 H0_0 HrecH0_0| o M N H0 HrecH0].
apply SynEnc.

*****
HrecH0_0 : synthesis h K L
HrecH0_1 : synthesis h M N
H0_0 : synthesis g K L
H0_1 : synthesis g M N
M,N,K,L : Msg
H : forall (M N : Msg) (_ : g M N), synthesis h M N
g,h : hedge
*****
synthesis h M N
+++++
trivial.
-----
Lemma incl_syn_impl_le_h : forall g h : hedge, inclusion g (synthesis h) -> le_h g h.
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
induction H0 as [M N H0| M N K L H0_1 HrecH0_1 H0_0 HrecH0_0| M1 N1 M2 N2 H0_1 HrecH0_1 H0_0 HrecH0_0| o M N H0 HrecH0].
apply SynEnc.

*****
HrecH0_0 : synthesis h K L
HrecH0_1 : synthesis h M N
H0_0 : synthesis g K L
H0_1 : synthesis g M N
M,N,K,L : Msg
H : forall (M N : Msg) (_ : g M N), synthesis h M N
g,h : hedge
*****
synthesis h K L
+++++
trivial.
-----
Lemma incl_syn_impl_le_h : forall g h : hedge, inclusion g (synthesis h) -> le_h g h.
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
induction H0 as [M N H0| M N K L H0_1 HrecH0_1 H0_0 HrecH0_0| M1 N1 M2 N2 H0_1 HrecH0_1 H0_0 HrecH0_0| o M N H0 HrecH0].

*****
HrecH0_0 : synthesis h M2 N2
HrecH0_1 : synthesis h M1 N1
H0_0 : synthesis g M2 N2
H0_1 : synthesis g M1 N1
M1,N1,M2,N2 : Msg
H : forall (M N : Msg) (_ : g M N), synthesis h M N
g,h : hedge
*****
synthesis h (MPair M1 M2) (MPair N1 N2)
+++++
apply SynPair.
-----
Lemma incl_syn_impl_le_h : forall g h : hedge, inclusion g (synthesis h) -> le_h g h.
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
induction H0 as [M N H0| M N K L H0_1 HrecH0_1 H0_0 HrecH0_0| M1 N1 M2 N2 H0_1 HrecH0_1 H0_0 HrecH0_0| o M N H0 HrecH0].
apply SynPair.

*****
HrecH0_0 : synthesis h M2 N2
HrecH0_1 : synthesis h M1 N1
H0_0 : synthesis g M2 N2
H0_1 : synthesis g M1 N1
M1,N1,M2,N2 : Msg
H : forall (M N : Msg) (_ : g M N), synthesis h M N
g,h : hedge
*****
synthesis h M1 N1
+++++
trivial.
-----
Lemma incl_syn_impl_le_h : forall g h : hedge, inclusion g (synthesis h) -> le_h g h.
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
induction H0 as [M N H0| M N K L H0_1 HrecH0_1 H0_0 HrecH0_0| M1 N1 M2 N2 H0_1 HrecH0_1 H0_0 HrecH0_0| o M N H0 HrecH0].
apply SynPair.

*****
HrecH0_0 : synthesis h M2 N2
HrecH0_1 : synthesis h M1 N1
H0_0 : synthesis g M2 N2
H0_1 : synthesis g M1 N1
M1,N1,M2,N2 : Msg
H : forall (M N : Msg) (_ : g M N), synthesis h M N
g,h : hedge
*****
synthesis h M2 N2
+++++
trivial.
-----
Lemma incl_syn_impl_le_h : forall g h : hedge, inclusion g (synthesis h) -> le_h g h.
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
induction H0 as [M N H0| M N K L H0_1 HrecH0_1 H0_0 HrecH0_0| M1 N1 M2 N2 H0_1 HrecH0_1 H0_0 HrecH0_0| o M N H0 HrecH0].

*****
HrecH0 : synthesis h M N
H0 : synthesis g M N
M,N : Msg
o : op
H : forall (M N : Msg) (_ : g M N), synthesis h M N
g,h : hedge
*****
synthesis h (Mop o M) (Mop o N)
+++++
apply SynOp.
-----
Lemma incl_syn_impl_le_h : forall g h : hedge, inclusion g (synthesis h) -> le_h g h.
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
induction H0 as [M N H0| M N K L H0_1 HrecH0_1 H0_0 HrecH0_0| M1 N1 M2 N2 H0_1 HrecH0_1 H0_0 HrecH0_0| o M N H0 HrecH0].
apply SynOp.

*****
HrecH0 : synthesis h M N
H0 : synthesis g M N
M,N : Msg
o : op
H : forall (M N : Msg) (_ : g M N), synthesis h M N
g,h : hedge
*****
synthesis h M N
+++++
trivial.
-----
Lemma incl_syn_impl_le_h : forall g h : hedge, inclusion g (synthesis h) -> le_h g h.
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
induction H0 as [M N H0| M N K L H0_1 HrecH0_1 H0_0 HrecH0_0| M1 N1 M2 N2 H0_1 HrecH0_1 H0_0 HrecH0_0| o M N H0 HrecH0].

*****

*****

+++++
Qed.
-----
Theorem le_h_iff_incl_syn :\n forall g h : hedge, le_h g h <-> inclusion g (synthesis h).
-----
Theorem le_h_iff_incl_syn : forall g h : hedge, le_h g h <-> inclusion g (synthesis h).

*****

*****
forall g h : hedge, iff (le_h g h) (inclusion g (synthesis h))
+++++
split.
-----
Theorem le_h_iff_incl_syn : forall g h : hedge, le_h g h <-> inclusion g (synthesis h).
split.

*****
g,h : hedge
*****
forall _ : le_h g h, inclusion g (synthesis h)
+++++
apply le_h_impl_incl_syn.
-----
Theorem le_h_iff_incl_syn : forall g h : hedge, le_h g h <-> inclusion g (synthesis h).
split.

*****
g,h : hedge
*****
forall _ : inclusion g (synthesis h), le_h g h
+++++
apply incl_syn_impl_le_h.
-----
Theorem le_h_iff_incl_syn : forall g h : hedge, le_h g h <-> inclusion g (synthesis h).
split.

*****

*****

+++++
Qed.
-----
Theorem inclusion_impl_le_h : forall g h : hedge, inclusion g h -> le_h g h.
-----
Theorem inclusion_impl_le_h : forall g h : hedge, inclusion g h -> le_h g h.

*****

*****
forall (g h : hedge) (_ : inclusion g h), le_h g h
+++++
intros.
-----
Theorem inclusion_impl_le_h : forall g h : hedge, inclusion g h -> le_h g h.
intros.

*****
H : inclusion g h
g,h : hedge
*****
le_h g h
+++++
apply incl_syn_impl_le_h.
-----
Theorem inclusion_impl_le_h : forall g h : hedge, inclusion g h -> le_h g h.
intros.
apply incl_syn_impl_le_h.

*****
H : inclusion g h
g,h : hedge
*****
inclusion g (synthesis h)
+++++
apply inclusion_trans with h.
-----
Theorem inclusion_impl_le_h : forall g h : hedge, inclusion g h -> le_h g h.
intros.
apply incl_syn_impl_le_h.
apply inclusion_trans with h.

*****
H : inclusion g h
g,h : hedge
*****
inclusion g h
+++++
trivial.
-----
Theorem inclusion_impl_le_h : forall g h : hedge, inclusion g h -> le_h g h.
intros.
apply incl_syn_impl_le_h.
apply inclusion_trans with h.

*****
H : inclusion g h
g,h : hedge
*****
inclusion h (synthesis h)
+++++
trivial.
-----
Theorem inclusion_impl_le_h : forall g h : hedge, inclusion g h -> le_h g h.
intros.
apply incl_syn_impl_le_h.
apply inclusion_trans with h.
trivial.

*****
H : inclusion g h
g,h : hedge
*****
inclusion h (synthesis h)
+++++
apply h_incl_syn.
-----
Theorem inclusion_impl_le_h : forall g h : hedge, inclusion g h -> le_h g h.
intros.
apply incl_syn_impl_le_h.
apply inclusion_trans with h.

*****

*****

+++++
Qed.
-----
Lemma equal_impl_equiv_h : forall g h : hedge, equal g h -> equiv_h g h.
-----
Lemma equal_impl_equiv_h : forall g h : hedge, equal g h -> equiv_h g h.

*****

*****
forall (g h : hedge) (_ : equal g h), equiv_h g h
+++++
unfold equal in |- *.
-----
Lemma equal_impl_equiv_h : forall g h : hedge, equal g h -> equiv_h g h.
unfold equal in |- *.

*****

*****
forall (g h : hedge) (_ : and (inclusion g h) (inclusion h g)), equiv_h g h
+++++
unfold equiv_h in |- *.
-----
Lemma equal_impl_equiv_h : forall g h : hedge, equal g h -> equiv_h g h.
unfold equal in |- *.
unfold equiv_h in |- *.

*****

*****
forall (g h : hedge) (_ : and (inclusion g h) (inclusion h g)), and (le_h g h) (le_h h g)
+++++
intros.
-----
Lemma equal_impl_equiv_h : forall g h : hedge, equal g h -> equiv_h g h.
unfold equal in |- *.
unfold equiv_h in |- *.
intros.

*****
H : and (inclusion g h) (inclusion h g)
g,h : hedge
*****
and (le_h g h) (le_h h g)
+++++
elim H.
-----
Lemma equal_impl_equiv_h : forall g h : hedge, equal g h -> equiv_h g h.
unfold equal in |- *.
unfold equiv_h in |- *.
intros.
elim H.

*****
H : and (inclusion g h) (inclusion h g)
g,h : hedge
*****
forall (_ : inclusion g h) (_ : inclusion h g), and (le_h g h) (le_h h g)
+++++
intros.
-----
Lemma equal_impl_equiv_h : forall g h : hedge, equal g h -> equiv_h g h.
unfold equal in |- *.
unfold equiv_h in |- *.
intros.
elim H.
intros.

*****
H1 : inclusion h g
H0 : inclusion g h
H : and (inclusion g h) (inclusion h g)
g,h : hedge
*****
and (le_h g h) (le_h h g)
+++++
split.
-----
Lemma equal_impl_equiv_h : forall g h : hedge, equal g h -> equiv_h g h.
unfold equal in |- *.
unfold equiv_h in |- *.
intros.
elim H.
intros.
split.

*****
H1 : inclusion h g
H0 : inclusion g h
H : and (inclusion g h) (inclusion h g)
g,h : hedge
*****
le_h g h
+++++
apply inclusion_impl_le_h.
-----
Lemma equal_impl_equiv_h : forall g h : hedge, equal g h -> equiv_h g h.
unfold equal in |- *.
unfold equiv_h in |- *.
intros.
elim H.
intros.
split.
apply inclusion_impl_le_h.

*****
H1 : inclusion h g
H0 : inclusion g h
H : and (inclusion g h) (inclusion h g)
g,h : hedge
*****
inclusion g h
+++++
trivial.
-----
Lemma equal_impl_equiv_h : forall g h : hedge, equal g h -> equiv_h g h.
unfold equal in |- *.
unfold equiv_h in |- *.
intros.
elim H.
intros.
split.

*****
H1 : inclusion h g
H0 : inclusion g h
H : and (inclusion g h) (inclusion h g)
g,h : hedge
*****
le_h h g
+++++
apply inclusion_impl_le_h.
-----
Lemma equal_impl_equiv_h : forall g h : hedge, equal g h -> equiv_h g h.
unfold equal in |- *.
unfold equiv_h in |- *.
intros.
elim H.
intros.
split.
apply inclusion_impl_le_h.

*****
H1 : inclusion h g
H0 : inclusion g h
H : and (inclusion g h) (inclusion h g)
g,h : hedge
*****
inclusion h g
+++++
trivial.
-----
Lemma equal_impl_equiv_h : forall g h : hedge, equal g h -> equiv_h g h.
unfold equal in |- *.
unfold equiv_h in |- *.
intros.
elim H.
intros.
split.

*****

*****

+++++
Qed.
-----
Theorem le_h_le_h_impl_union_le_h :\n forall f g h : hedge, le_h f h -> le_h g h -> le_h (union f g) h.
-----
Theorem le_h_le_h_impl_union_le_h : forall f g h : hedge, le_h f h -> le_h g h -> le_h (union f g) h.

*****

*****
forall (f g h : hedge) (_ : le_h f h) (_ : le_h g h), le_h (union f g) h
+++++
intros.
-----
Theorem le_h_le_h_impl_union_le_h : forall f g h : hedge, le_h f h -> le_h g h -> le_h (union f g) h.
intros.

*****
H0 : le_h g h
H : le_h f h
f,g,h : hedge
*****
le_h (union f g) h
+++++
apply incl_syn_impl_le_h.
-----
Theorem le_h_le_h_impl_union_le_h : forall f g h : hedge, le_h f h -> le_h g h -> le_h (union f g) h.
intros.
apply incl_syn_impl_le_h.

*****
H0 : le_h g h
H : le_h f h
f,g,h : hedge
*****
inclusion (union f g) (synthesis h)
+++++
apply union_intro.
-----
Theorem le_h_le_h_impl_union_le_h : forall f g h : hedge, le_h f h -> le_h g h -> le_h (union f g) h.
intros.
apply incl_syn_impl_le_h.
apply union_intro.

*****
H0 : le_h g h
H : le_h f h
f,g,h : hedge
*****
inclusion f (synthesis h)
+++++
apply le_h_impl_incl_syn.
-----
Theorem le_h_le_h_impl_union_le_h : forall f g h : hedge, le_h f h -> le_h g h -> le_h (union f g) h.
intros.
apply incl_syn_impl_le_h.
apply union_intro.
apply le_h_impl_incl_syn.

*****
H0 : le_h g h
H : le_h f h
f,g,h : hedge
*****
le_h f h
+++++
trivial.
-----
Theorem le_h_le_h_impl_union_le_h : forall f g h : hedge, le_h f h -> le_h g h -> le_h (union f g) h.
intros.
apply incl_syn_impl_le_h.
apply union_intro.

*****
H0 : le_h g h
H : le_h f h
f,g,h : hedge
*****
inclusion g (synthesis h)
+++++
apply le_h_impl_incl_syn.
-----
Theorem le_h_le_h_impl_union_le_h : forall f g h : hedge, le_h f h -> le_h g h -> le_h (union f g) h.
intros.
apply incl_syn_impl_le_h.
apply union_intro.
apply le_h_impl_incl_syn.

*****
H0 : le_h g h
H : le_h f h
f,g,h : hedge
*****
le_h g h
+++++
trivial.
-----
Theorem le_h_le_h_impl_union_le_h : forall f g h : hedge, le_h f h -> le_h g h -> le_h (union f g) h.
intros.
apply incl_syn_impl_le_h.
apply union_intro.

*****

*****

+++++
Qed.
-----
Theorem le_h_le_h_impl_le_h_union :\n forall g1 g2 h1 h2 : hedge,\n le_h g1 h1 -> le_h g2 h2 -> le_h (union g1 g2) (union h1 h2).
-----
Theorem le_h_le_h_impl_le_h_union : forall g1 g2 h1 h2 : hedge, le_h g1 h1 -> le_h g2 h2 -> le_h (union g1 g2) (union h1 h2).

*****

*****
forall (g1 g2 h1 h2 : hedge) (_ : le_h g1 h1) (_ : le_h g2 h2), le_h (union g1 g2) (union h1 h2)
+++++
intros.
-----
Theorem le_h_le_h_impl_le_h_union : forall g1 g2 h1 h2 : hedge, le_h g1 h1 -> le_h g2 h2 -> le_h (union g1 g2) (union h1 h2).
intros.

*****
H0 : le_h g2 h2
H : le_h g1 h1
g1,g2,h1,h2 : hedge
*****
le_h (union g1 g2) (union h1 h2)
+++++
apply le_h_le_h_impl_union_le_h.
-----
Theorem le_h_le_h_impl_le_h_union : forall g1 g2 h1 h2 : hedge, le_h g1 h1 -> le_h g2 h2 -> le_h (union g1 g2) (union h1 h2).
intros.
apply le_h_le_h_impl_union_le_h.

*****
H0 : le_h g2 h2
H : le_h g1 h1
g1,g2,h1,h2 : hedge
*****
le_h g1 (union h1 h2)
+++++
apply le_h_trans with h1.
-----
Theorem le_h_le_h_impl_le_h_union : forall g1 g2 h1 h2 : hedge, le_h g1 h1 -> le_h g2 h2 -> le_h (union g1 g2) (union h1 h2).
intros.
apply le_h_le_h_impl_union_le_h.
apply le_h_trans with h1.

*****
H0 : le_h g2 h2
H : le_h g1 h1
g1,g2,h1,h2 : hedge
*****
le_h g1 h1
+++++
trivial.
-----
Theorem le_h_le_h_impl_le_h_union : forall g1 g2 h1 h2 : hedge, le_h g1 h1 -> le_h g2 h2 -> le_h (union g1 g2) (union h1 h2).
intros.
apply le_h_le_h_impl_union_le_h.
apply le_h_trans with h1.

*****
H0 : le_h g2 h2
H : le_h g1 h1
g1,g2,h1,h2 : hedge
*****
le_h h1 (union h1 h2)
+++++
trivial.
-----
Theorem le_h_le_h_impl_le_h_union : forall g1 g2 h1 h2 : hedge, le_h g1 h1 -> le_h g2 h2 -> le_h (union g1 g2) (union h1 h2).
intros.
apply le_h_le_h_impl_union_le_h.
apply le_h_trans with h1.
trivial.

*****
H0 : le_h g2 h2
H : le_h g1 h1
g1,g2,h1,h2 : hedge
*****
le_h h1 (union h1 h2)
+++++
apply inclusion_impl_le_h.
-----
Theorem le_h_le_h_impl_le_h_union : forall g1 g2 h1 h2 : hedge, le_h g1 h1 -> le_h g2 h2 -> le_h (union g1 g2) (union h1 h2).
intros.
apply le_h_le_h_impl_union_le_h.
apply le_h_trans with h1.
trivial.
apply inclusion_impl_le_h.

*****
H0 : le_h g2 h2
H : le_h g1 h1
g1,g2,h1,h2 : hedge
*****
inclusion h1 (union h1 h2)
+++++
apply hedge_left_union.
-----
Theorem le_h_le_h_impl_le_h_union : forall g1 g2 h1 h2 : hedge, le_h g1 h1 -> le_h g2 h2 -> le_h (union g1 g2) (union h1 h2).
intros.
apply le_h_le_h_impl_union_le_h.

*****
H0 : le_h g2 h2
H : le_h g1 h1
g1,g2,h1,h2 : hedge
*****
le_h g2 (union h1 h2)
+++++
apply le_h_trans with h2.
-----
Theorem le_h_le_h_impl_le_h_union : forall g1 g2 h1 h2 : hedge, le_h g1 h1 -> le_h g2 h2 -> le_h (union g1 g2) (union h1 h2).
intros.
apply le_h_le_h_impl_union_le_h.
apply le_h_trans with h2.

*****
H0 : le_h g2 h2
H : le_h g1 h1
g1,g2,h1,h2 : hedge
*****
le_h g2 h2
+++++
trivial.
-----
Theorem le_h_le_h_impl_le_h_union : forall g1 g2 h1 h2 : hedge, le_h g1 h1 -> le_h g2 h2 -> le_h (union g1 g2) (union h1 h2).
intros.
apply le_h_le_h_impl_union_le_h.
apply le_h_trans with h2.

*****
H0 : le_h g2 h2
H : le_h g1 h1
g1,g2,h1,h2 : hedge
*****
le_h h2 (union h1 h2)
+++++
trivial.
-----
Theorem le_h_le_h_impl_le_h_union : forall g1 g2 h1 h2 : hedge, le_h g1 h1 -> le_h g2 h2 -> le_h (union g1 g2) (union h1 h2).
intros.
apply le_h_le_h_impl_union_le_h.
apply le_h_trans with h2.
trivial.

*****
H0 : le_h g2 h2
H : le_h g1 h1
g1,g2,h1,h2 : hedge
*****
le_h h2 (union h1 h2)
+++++
apply inclusion_impl_le_h.
-----
Theorem le_h_le_h_impl_le_h_union : forall g1 g2 h1 h2 : hedge, le_h g1 h1 -> le_h g2 h2 -> le_h (union g1 g2) (union h1 h2).
intros.
apply le_h_le_h_impl_union_le_h.
apply le_h_trans with h2.
trivial.
apply inclusion_impl_le_h.

*****
H0 : le_h g2 h2
H : le_h g1 h1
g1,g2,h1,h2 : hedge
*****
inclusion h2 (union h1 h2)
+++++
apply hedge_right_union.
-----
Theorem le_h_le_h_impl_le_h_union : forall g1 g2 h1 h2 : hedge, le_h g1 h1 -> le_h g2 h2 -> le_h (union g1 g2) (union h1 h2).
intros.
apply le_h_le_h_impl_union_le_h.

*****

*****

+++++
Qed.
-----
Inductive analysis (h : hedge) : hedge :=\n  | AnaInc : forall M N : Msg, h M N -> analysis h M N\n  | AnaSplitL :\n      forall M1 M2 N1 N2 : Msg,\n      analysis h (MPair M1 M2) (MPair N1 N2) -> analysis h M1 N1\n  | AnaSplitR :\n      forall M1 M2 N1 N2 : Msg,\n      analysis h (MPair M1 M2) (MPair N1 N2) -> analysis h M2 N2\n  | AnaDec :\n      forall M N K L : Msg,\n      analysis h (MEnc M K) (MEnc N L) ->\n      synthesis h (inv K) (inv L) -> analysis h M N.
-----
Lemma inclusion_analysis_inclusion :\n forall g h : hedge, inclusion g h -> inclusion (analysis g) (analysis h).
-----
Lemma inclusion_analysis_inclusion : forall g h : hedge, inclusion g h -> inclusion (analysis g) (analysis h).

*****

*****
forall (g h : hedge) (_ : inclusion g h), inclusion (analysis g) (analysis h)
+++++
intros g h.
-----
Lemma inclusion_analysis_inclusion : forall g h : hedge, inclusion g h -> inclusion (analysis g) (analysis h).
intros g h.

*****
g,h : hedge
*****
forall _ : inclusion g h, inclusion (analysis g) (analysis h)
+++++
unfold inclusion in |- *.
-----
Lemma inclusion_analysis_inclusion : forall g h : hedge, inclusion g h -> inclusion (analysis g) (analysis h).
intros g h.
unfold inclusion in |- *.

*****
g,h : hedge
*****
forall (_ : forall (M N : Msg) (_ : g M N), h M N) (M N : Msg) (_ : analysis g M N), analysis h M N
+++++
intros.
-----
Lemma inclusion_analysis_inclusion : forall g h : hedge, inclusion g h -> inclusion (analysis g) (analysis h).
intros g h.
unfold inclusion in |- *.
intros.

*****
H0 : analysis g M N
M,N : Msg
H : forall (M N : Msg) (_ : g M N), h M N
g,h : hedge
*****
analysis h M N
+++++
induction H0 as [M N H0| M1 M2 N1 N2 H0 HrecH0| M1 M2 N1 N2 H0 HrecH0| M N K L H0 HrecH0 H1].
-----
Lemma inclusion_analysis_inclusion : forall g h : hedge, inclusion g h -> inclusion (analysis g) (analysis h).
intros g h.
unfold inclusion in |- *.
intros.
induction H0 as [M N H0| M1 M2 N1 N2 H0 HrecH0| M1 M2 N1 N2 H0 HrecH0| M N K L H0 HrecH0 H1].

*****
H0 : g M N
M,N : Msg
H : forall (M N : Msg) (_ : g M N), h M N
g,h : hedge
*****
analysis h M N
+++++
apply AnaInc.
-----
Lemma inclusion_analysis_inclusion : forall g h : hedge, inclusion g h -> inclusion (analysis g) (analysis h).
intros g h.
unfold inclusion in |- *.
intros.
induction H0 as [M N H0| M1 M2 N1 N2 H0 HrecH0| M1 M2 N1 N2 H0 HrecH0| M N K L H0 HrecH0 H1].
apply AnaInc.

*****
H0 : g M N
M,N : Msg
H : forall (M N : Msg) (_ : g M N), h M N
g,h : hedge
*****
h M N
+++++
apply H.
-----
Lemma inclusion_analysis_inclusion : forall g h : hedge, inclusion g h -> inclusion (analysis g) (analysis h).
intros g h.
unfold inclusion in |- *.
intros.
induction H0 as [M N H0| M1 M2 N1 N2 H0 HrecH0| M1 M2 N1 N2 H0 HrecH0| M N K L H0 HrecH0 H1].
apply AnaInc.
apply H.

*****
H0 : g M N
M,N : Msg
H : forall (M N : Msg) (_ : g M N), h M N
g,h : hedge
*****
g M N
+++++
trivial.
-----
Lemma inclusion_analysis_inclusion : forall g h : hedge, inclusion g h -> inclusion (analysis g) (analysis h).
intros g h.
unfold inclusion in |- *.
intros.
induction H0 as [M N H0| M1 M2 N1 N2 H0 HrecH0| M1 M2 N1 N2 H0 HrecH0| M N K L H0 HrecH0 H1].

*****
HrecH0 : analysis h (MPair M1 M2) (MPair N1 N2)
H0 : analysis g (MPair M1 M2) (MPair N1 N2)
M1,M2,N1,N2 : Msg
H : forall (M N : Msg) (_ : g M N), h M N
g,h : hedge
*****
analysis h M1 N1
+++++
apply (AnaSplitL h M1 M2 N1 N2).
-----
Lemma inclusion_analysis_inclusion : forall g h : hedge, inclusion g h -> inclusion (analysis g) (analysis h).
intros g h.
unfold inclusion in |- *.
intros.
induction H0 as [M N H0| M1 M2 N1 N2 H0 HrecH0| M1 M2 N1 N2 H0 HrecH0| M N K L H0 HrecH0 H1].
apply (AnaSplitL h M1 M2 N1 N2).

*****
HrecH0 : analysis h (MPair M1 M2) (MPair N1 N2)
H0 : analysis g (MPair M1 M2) (MPair N1 N2)
M1,M2,N1,N2 : Msg
H : forall (M N : Msg) (_ : g M N), h M N
g,h : hedge
*****
analysis h (MPair M1 M2) (MPair N1 N2)
+++++
trivial.
-----
Lemma inclusion_analysis_inclusion : forall g h : hedge, inclusion g h -> inclusion (analysis g) (analysis h).
intros g h.
unfold inclusion in |- *.
intros.
induction H0 as [M N H0| M1 M2 N1 N2 H0 HrecH0| M1 M2 N1 N2 H0 HrecH0| M N K L H0 HrecH0 H1].

*****
HrecH0 : analysis h (MPair M1 M2) (MPair N1 N2)
H0 : analysis g (MPair M1 M2) (MPair N1 N2)
M1,M2,N1,N2 : Msg
H : forall (M N : Msg) (_ : g M N), h M N
g,h : hedge
*****
analysis h M2 N2
+++++
apply (AnaSplitR h M1 M2 N1 N2).
-----
Lemma inclusion_analysis_inclusion : forall g h : hedge, inclusion g h -> inclusion (analysis g) (analysis h).
intros g h.
unfold inclusion in |- *.
intros.
induction H0 as [M N H0| M1 M2 N1 N2 H0 HrecH0| M1 M2 N1 N2 H0 HrecH0| M N K L H0 HrecH0 H1].
apply (AnaSplitR h M1 M2 N1 N2).

*****
HrecH0 : analysis h (MPair M1 M2) (MPair N1 N2)
H0 : analysis g (MPair M1 M2) (MPair N1 N2)
M1,M2,N1,N2 : Msg
H : forall (M N : Msg) (_ : g M N), h M N
g,h : hedge
*****
analysis h (MPair M1 M2) (MPair N1 N2)
+++++
trivial.
-----
Lemma inclusion_analysis_inclusion : forall g h : hedge, inclusion g h -> inclusion (analysis g) (analysis h).
intros g h.
unfold inclusion in |- *.
intros.
induction H0 as [M N H0| M1 M2 N1 N2 H0 HrecH0| M1 M2 N1 N2 H0 HrecH0| M N K L H0 HrecH0 H1].

*****
HrecH0 : analysis h (MEnc M K) (MEnc N L)
H1 : synthesis g (inv K) (inv L)
H0 : analysis g (MEnc M K) (MEnc N L)
M,N,K,L : Msg
H : forall (M N : Msg) (_ : g M N), h M N
g,h : hedge
*****
analysis h M N
+++++
apply (AnaDec h M N K L).
-----
Lemma inclusion_analysis_inclusion : forall g h : hedge, inclusion g h -> inclusion (analysis g) (analysis h).
intros g h.
unfold inclusion in |- *.
intros.
induction H0 as [M N H0| M1 M2 N1 N2 H0 HrecH0| M1 M2 N1 N2 H0 HrecH0| M N K L H0 HrecH0 H1].
apply (AnaDec h M N K L).

*****
HrecH0 : analysis h (MEnc M K) (MEnc N L)
H1 : synthesis g (inv K) (inv L)
H0 : analysis g (MEnc M K) (MEnc N L)
M,N,K,L : Msg
H : forall (M N : Msg) (_ : g M N), h M N
g,h : hedge
*****
analysis h (MEnc M K) (MEnc N L)
+++++
trivial.
-----
Lemma inclusion_analysis_inclusion : forall g h : hedge, inclusion g h -> inclusion (analysis g) (analysis h).
intros g h.
unfold inclusion in |- *.
intros.
induction H0 as [M N H0| M1 M2 N1 N2 H0 HrecH0| M1 M2 N1 N2 H0 HrecH0| M N K L H0 HrecH0 H1].
apply (AnaDec h M N K L).

*****
HrecH0 : analysis h (MEnc M K) (MEnc N L)
H1 : synthesis g (inv K) (inv L)
H0 : analysis g (MEnc M K) (MEnc N L)
M,N,K,L : Msg
H : forall (M N : Msg) (_ : g M N), h M N
g,h : hedge
*****
synthesis h (inv K) (inv L)
+++++
generalize (inclusion_impl_le_h g h H).
-----
Lemma inclusion_analysis_inclusion : forall g h : hedge, inclusion g h -> inclusion (analysis g) (analysis h).
intros g h.
unfold inclusion in |- *.
intros.
induction H0 as [M N H0| M1 M2 N1 N2 H0 HrecH0| M1 M2 N1 N2 H0 HrecH0| M N K L H0 HrecH0 H1].
apply (AnaDec h M N K L).
generalize (inclusion_impl_le_h g h H).

*****
HrecH0 : analysis h (MEnc M K) (MEnc N L)
H1 : synthesis g (inv K) (inv L)
H0 : analysis g (MEnc M K) (MEnc N L)
M,N,K,L : Msg
H : forall (M N : Msg) (_ : g M N), h M N
g,h : hedge
*****
forall _ : le_h g h, synthesis h (inv K) (inv L)
+++++
unfold le_h in |- *.
-----
Lemma inclusion_analysis_inclusion : forall g h : hedge, inclusion g h -> inclusion (analysis g) (analysis h).
intros g h.
unfold inclusion in |- *.
intros.
induction H0 as [M N H0| M1 M2 N1 N2 H0 HrecH0| M1 M2 N1 N2 H0 HrecH0| M N K L H0 HrecH0 H1].
apply (AnaDec h M N K L).
generalize (inclusion_impl_le_h g h H).
unfold le_h in |- *.

*****
HrecH0 : analysis h (MEnc M K) (MEnc N L)
H1 : synthesis g (inv K) (inv L)
H0 : analysis g (MEnc M K) (MEnc N L)
M,N,K,L : Msg
H : forall (M N : Msg) (_ : g M N), h M N
g,h : hedge
*****
forall _ : inclusion (synthesis g) (synthesis h), synthesis h (inv K) (inv L)
+++++
unfold inclusion in |- *.
-----
Lemma inclusion_analysis_inclusion : forall g h : hedge, inclusion g h -> inclusion (analysis g) (analysis h).
intros g h.
unfold inclusion in |- *.
intros.
induction H0 as [M N H0| M1 M2 N1 N2 H0 HrecH0| M1 M2 N1 N2 H0 HrecH0| M N K L H0 HrecH0 H1].
apply (AnaDec h M N K L).
generalize (inclusion_impl_le_h g h H).
unfold le_h in |- *.
unfold inclusion in |- *.

*****
HrecH0 : analysis h (MEnc M K) (MEnc N L)
H1 : synthesis g (inv K) (inv L)
H0 : analysis g (MEnc M K) (MEnc N L)
M,N,K,L : Msg
H : forall (M N : Msg) (_ : g M N), h M N
g,h : hedge
*****
forall _ : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N, synthesis h (inv K) (inv L)
+++++
intros.
-----
Lemma inclusion_analysis_inclusion : forall g h : hedge, inclusion g h -> inclusion (analysis g) (analysis h).
intros g h.
unfold inclusion in |- *.
intros.
induction H0 as [M N H0| M1 M2 N1 N2 H0 HrecH0| M1 M2 N1 N2 H0 HrecH0| M N K L H0 HrecH0 H1].
apply (AnaDec h M N K L).
generalize (inclusion_impl_le_h g h H).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.

*****
H2 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
HrecH0 : analysis h (MEnc M K) (MEnc N L)
H1 : synthesis g (inv K) (inv L)
H0 : analysis g (MEnc M K) (MEnc N L)
M,N,K,L : Msg
H : forall (M N : Msg) (_ : g M N), h M N
g,h : hedge
*****
synthesis h (inv K) (inv L)
+++++
auto.
-----
Lemma inclusion_analysis_inclusion : forall g h : hedge, inclusion g h -> inclusion (analysis g) (analysis h).
intros g h.
unfold inclusion in |- *.
intros.
induction H0 as [M N H0| M1 M2 N1 N2 H0 HrecH0| M1 M2 N1 N2 H0 HrecH0| M N K L H0 HrecH0 H1].

*****

*****

+++++
Qed.
-----
Fixpoint analysis_seq (h : hedge) (n : nat) {struct n} : hedge :=\n  match n with\n  | O => h\n  | S n => analysis (analysis_seq h n)\n  end.
-----
From Coq Require Import Arith.
-----
Lemma analysis_seq_grow_S :\n forall (n : nat) (h : hedge),\n inclusion (analysis_seq h n) (analysis_seq h (S n)).
-----
Lemma analysis_seq_grow_S : forall (n : nat) (h : hedge), inclusion (analysis_seq h n) (analysis_seq h (S n)).

*****

*****
forall (n : nat) (h : hedge), inclusion (analysis_seq h n) (analysis_seq h (S n))
+++++
simple induction n.
-----
Lemma analysis_seq_grow_S : forall (n : nat) (h : hedge), inclusion (analysis_seq h n) (analysis_seq h (S n)).
simple induction n.

*****
n : nat
*****
forall h : hedge, inclusion (analysis_seq h O) (analysis_seq h (S O))
+++++
simpl in |- *.
-----
Lemma analysis_seq_grow_S : forall (n : nat) (h : hedge), inclusion (analysis_seq h n) (analysis_seq h (S n)).
simple induction n.
simpl in |- *.

*****
n : nat
*****
forall h : hedge, inclusion h (analysis h)
+++++
intros.
-----
Lemma analysis_seq_grow_S : forall (n : nat) (h : hedge), inclusion (analysis_seq h n) (analysis_seq h (S n)).
simple induction n.
simpl in |- *.
intros.

*****
h : hedge
n : nat
*****
inclusion h (analysis h)
+++++
unfold inclusion in |- *.
-----
Lemma analysis_seq_grow_S : forall (n : nat) (h : hedge), inclusion (analysis_seq h n) (analysis_seq h (S n)).
simple induction n.
simpl in |- *.
intros.
unfold inclusion in |- *.

*****
h : hedge
n : nat
*****
forall (M N : Msg) (_ : h M N), analysis h M N
+++++
intros.
-----
Lemma analysis_seq_grow_S : forall (n : nat) (h : hedge), inclusion (analysis_seq h n) (analysis_seq h (S n)).
simple induction n.
simpl in |- *.
intros.
unfold inclusion in |- *.
intros.

*****
H : h M N
M,N : Msg
h : hedge
n : nat
*****
analysis h M N
+++++
apply AnaInc.
-----
Lemma analysis_seq_grow_S : forall (n : nat) (h : hedge), inclusion (analysis_seq h n) (analysis_seq h (S n)).
simple induction n.
simpl in |- *.
intros.
unfold inclusion in |- *.
intros.
apply AnaInc.

*****
H : h M N
M,N : Msg
h : hedge
n : nat
*****
h M N
+++++
trivial.
-----
Lemma analysis_seq_grow_S : forall (n : nat) (h : hedge), inclusion (analysis_seq h n) (analysis_seq h (S n)).
simple induction n.

*****
n : nat
*****
forall (n : nat) (_ : forall h : hedge, inclusion (analysis_seq h n) (analysis_seq h (S n))) (h : hedge), inclusion (analysis_seq h (S n)) (analysis_seq h (S (S n)))
+++++
intros.
-----
Lemma analysis_seq_grow_S : forall (n : nat) (h : hedge), inclusion (analysis_seq h n) (analysis_seq h (S n)).
simple induction n.
intros.

*****
h : hedge
H : forall h : hedge, inclusion (analysis_seq h n0) (analysis_seq h (S n0))
n,n0 : nat
*****
inclusion (analysis_seq h (S n0)) (analysis_seq h (S (S n0)))
+++++
simpl in |- *.
-----
Lemma analysis_seq_grow_S : forall (n : nat) (h : hedge), inclusion (analysis_seq h n) (analysis_seq h (S n)).
simple induction n.
intros.
simpl in |- *.

*****
h : hedge
H : forall h : hedge, inclusion (analysis_seq h n0) (analysis_seq h (S n0))
n,n0 : nat
*****
inclusion (analysis (analysis_seq h n0)) (analysis (analysis (analysis_seq h n0)))
+++++
unfold inclusion in |- *.
-----
Lemma analysis_seq_grow_S : forall (n : nat) (h : hedge), inclusion (analysis_seq h n) (analysis_seq h (S n)).
simple induction n.
intros.
simpl in |- *.
unfold inclusion in |- *.

*****
h : hedge
H : forall h : hedge, inclusion (analysis_seq h n0) (analysis_seq h (S n0))
n,n0 : nat
*****
forall (M N : Msg) (_ : analysis (analysis_seq h n0) M N), analysis (analysis (analysis_seq h n0)) M N
+++++
intros.
-----
Lemma analysis_seq_grow_S : forall (n : nat) (h : hedge), inclusion (analysis_seq h n) (analysis_seq h (S n)).
simple induction n.
intros.
simpl in |- *.
unfold inclusion in |- *.
intros.

*****
H0 : analysis (analysis_seq h n0) M N
M,N : Msg
h : hedge
H : forall h : hedge, inclusion (analysis_seq h n0) (analysis_seq h (S n0))
n,n0 : nat
*****
analysis (analysis (analysis_seq h n0)) M N
+++++
apply AnaInc.
-----
Lemma analysis_seq_grow_S : forall (n : nat) (h : hedge), inclusion (analysis_seq h n) (analysis_seq h (S n)).
simple induction n.
intros.
simpl in |- *.
unfold inclusion in |- *.
intros.
apply AnaInc.

*****
H0 : analysis (analysis_seq h n0) M N
M,N : Msg
h : hedge
H : forall h : hedge, inclusion (analysis_seq h n0) (analysis_seq h (S n0))
n,n0 : nat
*****
analysis (analysis_seq h n0) M N
+++++
trivial.
-----
Lemma analysis_seq_grow_S : forall (n : nat) (h : hedge), inclusion (analysis_seq h n) (analysis_seq h (S n)).
simple induction n.

*****

*****

+++++
Qed.
-----
Lemma analysis_seq_grows :\n forall (p n : nat) (h : hedge),\n inclusion (analysis_seq h n) (analysis_seq h (p + n)).
-----
Lemma analysis_seq_grows : forall (p n : nat) (h : hedge), inclusion (analysis_seq h n) (analysis_seq h (p + n)).

*****

*****
forall (p n : nat) (h : hedge), inclusion (analysis_seq h n) (analysis_seq h (Init.Nat.add p n))
+++++
simple induction p.
-----
Lemma analysis_seq_grows : forall (p n : nat) (h : hedge), inclusion (analysis_seq h n) (analysis_seq h (p + n)).
simple induction p.

*****
p : nat
*****
forall (n : nat) (h : hedge), inclusion (analysis_seq h n) (analysis_seq h (Init.Nat.add O n))
+++++
simpl in |- *.
-----
Lemma analysis_seq_grows : forall (p n : nat) (h : hedge), inclusion (analysis_seq h n) (analysis_seq h (p + n)).
simple induction p.
simpl in |- *.

*****
p : nat
*****
forall (n : nat) (h : hedge), inclusion (analysis_seq h n) (analysis_seq h n)
+++++
intros.
-----
Lemma analysis_seq_grows : forall (p n : nat) (h : hedge), inclusion (analysis_seq h n) (analysis_seq h (p + n)).
simple induction p.
simpl in |- *.
intros.

*****
h : hedge
p,n : nat
*****
inclusion (analysis_seq h n) (analysis_seq h n)
+++++
apply inclusion_refl.
-----
Lemma analysis_seq_grows : forall (p n : nat) (h : hedge), inclusion (analysis_seq h n) (analysis_seq h (p + n)).
simple induction p.

*****
p : nat
*****
forall (n : nat) (_ : forall (n0 : nat) (h : hedge), inclusion (analysis_seq h n0) (analysis_seq h (Init.Nat.add n n0))) (n0 : nat) (h : hedge), inclusion (analysis_seq h n0) (analysis_seq h (Init.Nat.add (S n) n0))
+++++
intros.
-----
Lemma analysis_seq_grows : forall (p n : nat) (h : hedge), inclusion (analysis_seq h n) (analysis_seq h (p + n)).
simple induction p.
intros.

*****
h : hedge
n0 : nat
H : forall (n0 : nat) (h : hedge),\ninclusion (analysis_seq h n0) (analysis_seq h (Init.Nat.add n n0))
p,n : nat
*****
inclusion (analysis_seq h n0) (analysis_seq h (Init.Nat.add (S n) n0))
+++++
replace (S n + n0) with (S (n + n0)).
-----
Lemma analysis_seq_grows : forall (p n : nat) (h : hedge), inclusion (analysis_seq h n) (analysis_seq h (p + n)).
simple induction p.
intros.
replace (S n + n0) with (S (n + n0)).

*****
h : hedge
n0 : nat
H : forall (n0 : nat) (h : hedge),\ninclusion (analysis_seq h n0) (analysis_seq h (Init.Nat.add n n0))
p,n : nat
*****
inclusion (analysis_seq h n0) (analysis_seq h (S (Init.Nat.add n n0)))
+++++
try auto with arith.
-----
Lemma analysis_seq_grows : forall (p n : nat) (h : hedge), inclusion (analysis_seq h n) (analysis_seq h (p + n)).
simple induction p.
intros.
replace (S n + n0) with (S (n + n0)).
try auto with arith.

*****
h : hedge
n0 : nat
H : forall (n0 : nat) (h : hedge),\ninclusion (analysis_seq h n0) (analysis_seq h (Init.Nat.add n n0))
p,n : nat
*****
inclusion (analysis_seq h n0) (analysis_seq h (S (Init.Nat.add n n0)))
+++++
apply inclusion_trans with (analysis_seq h (n + n0)).
-----
Lemma analysis_seq_grows : forall (p n : nat) (h : hedge), inclusion (analysis_seq h n) (analysis_seq h (p + n)).
simple induction p.
intros.
replace (S n + n0) with (S (n + n0)).
try auto with arith.
apply inclusion_trans with (analysis_seq h (n + n0)).

*****
h : hedge
n0 : nat
H : forall (n0 : nat) (h : hedge),\ninclusion (analysis_seq h n0) (analysis_seq h (Init.Nat.add n n0))
p,n : nat
*****
inclusion (analysis_seq h n0) (analysis_seq h (Init.Nat.add n n0))
+++++
trivial.
-----
Lemma analysis_seq_grows : forall (p n : nat) (h : hedge), inclusion (analysis_seq h n) (analysis_seq h (p + n)).
simple induction p.
intros.
replace (S n + n0) with (S (n + n0)).
try auto with arith.
apply inclusion_trans with (analysis_seq h (n + n0)).

*****
h : hedge
n0 : nat
H : forall (n0 : nat) (h : hedge),\ninclusion (analysis_seq h n0) (analysis_seq h (Init.Nat.add n n0))
p,n : nat
*****
inclusion (analysis_seq h (Init.Nat.add n n0)) (analysis_seq h (S (Init.Nat.add n n0)))
+++++
trivial.
-----
Lemma analysis_seq_grows : forall (p n : nat) (h : hedge), inclusion (analysis_seq h n) (analysis_seq h (p + n)).
simple induction p.
intros.
replace (S n + n0) with (S (n + n0)).
try auto with arith.
apply inclusion_trans with (analysis_seq h (n + n0)).
trivial.

*****
h : hedge
n0 : nat
H : forall (n0 : nat) (h : hedge),\ninclusion (analysis_seq h n0) (analysis_seq h (Init.Nat.add n n0))
p,n : nat
*****
inclusion (analysis_seq h (Init.Nat.add n n0)) (analysis_seq h (S (Init.Nat.add n n0)))
+++++
apply analysis_seq_grow_S.
-----
Lemma analysis_seq_grows : forall (p n : nat) (h : hedge), inclusion (analysis_seq h n) (analysis_seq h (p + n)).
simple induction p.
intros.
replace (S n + n0) with (S (n + n0)).

*****
h : hedge
n0 : nat
H : forall (n0 : nat) (h : hedge),\ninclusion (analysis_seq h n0) (analysis_seq h (Init.Nat.add n n0))
p,n : nat
*****
eq (S (Init.Nat.add n n0)) (Init.Nat.add (S n) n0)
+++++
try auto with arith.
-----
Lemma analysis_seq_grows : forall (p n : nat) (h : hedge), inclusion (analysis_seq h n) (analysis_seq h (p + n)).
simple induction p.

*****

*****

+++++
Qed.
-----
Lemma analysis_seq_increase :\n forall (n m : nat) (h : hedge),\n n <= m -> inclusion (analysis_seq h n) (analysis_seq h m).
-----
Lemma analysis_seq_increase : forall (n m : nat) (h : hedge), n <= m -> inclusion (analysis_seq h n) (analysis_seq h m).

*****

*****
forall (n m : nat) (h : hedge) (_ : le n m), inclusion (analysis_seq h n) (analysis_seq h m)
+++++
intros.
-----
Lemma analysis_seq_increase : forall (n m : nat) (h : hedge), n <= m -> inclusion (analysis_seq h n) (analysis_seq h m).
intros.

*****
H : le n m
h : hedge
n,m : nat
*****
inclusion (analysis_seq h n) (analysis_seq h m)
+++++
cut (exists p : nat, m = p + n).
-----
Lemma analysis_seq_increase : forall (n m : nat) (h : hedge), n <= m -> inclusion (analysis_seq h n) (analysis_seq h m).
intros.
cut (exists p : nat, m = p + n).

*****
H : le n m
h : hedge
n,m : nat
*****
forall _ : ex (fun p : nat => eq m (Init.Nat.add p n)), inclusion (analysis_seq h n) (analysis_seq h m)
+++++
intro.
-----
Lemma analysis_seq_increase : forall (n m : nat) (h : hedge), n <= m -> inclusion (analysis_seq h n) (analysis_seq h m).
intros.
cut (exists p : nat, m = p + n).
intro.

*****
H0 : ex (fun p : nat => eq m (Init.Nat.add p n))
H : le n m
h : hedge
n,m : nat
*****
inclusion (analysis_seq h n) (analysis_seq h m)
+++++
elim H0.
-----
Lemma analysis_seq_increase : forall (n m : nat) (h : hedge), n <= m -> inclusion (analysis_seq h n) (analysis_seq h m).
intros.
cut (exists p : nat, m = p + n).
intro.
elim H0.

*****
H0 : ex (fun p : nat => eq m (Init.Nat.add p n))
H : le n m
h : hedge
n,m : nat
*****
forall (x : nat) (_ : eq m (Init.Nat.add x n)), inclusion (analysis_seq h n) (analysis_seq h m)
+++++
intro p.
-----
Lemma analysis_seq_increase : forall (n m : nat) (h : hedge), n <= m -> inclusion (analysis_seq h n) (analysis_seq h m).
intros.
cut (exists p : nat, m = p + n).
intro.
elim H0.
intro p.

*****
p : nat
H0 : ex (fun p : nat => eq m (Init.Nat.add p n))
H : le n m
h : hedge
n,m : nat
*****
forall _ : eq m (Init.Nat.add p n), inclusion (analysis_seq h n) (analysis_seq h m)
+++++
intro.
-----
Lemma analysis_seq_increase : forall (n m : nat) (h : hedge), n <= m -> inclusion (analysis_seq h n) (analysis_seq h m).
intros.
cut (exists p : nat, m = p + n).
intro.
elim H0.
intro p.
intro.

*****
H1 : eq m (Init.Nat.add p n)
p : nat
H0 : ex (fun p : nat => eq m (Init.Nat.add p n))
H : le n m
h : hedge
n,m : nat
*****
inclusion (analysis_seq h n) (analysis_seq h m)
+++++
rewrite H1.
-----
Lemma analysis_seq_increase : forall (n m : nat) (h : hedge), n <= m -> inclusion (analysis_seq h n) (analysis_seq h m).
intros.
cut (exists p : nat, m = p + n).
intro.
elim H0.
intro p.
intro.
rewrite H1.

*****
H1 : eq m (Init.Nat.add p n)
p : nat
H0 : ex (fun p : nat => eq m (Init.Nat.add p n))
H : le n m
h : hedge
n,m : nat
*****
inclusion (analysis_seq h n) (analysis_seq h (Init.Nat.add p n))
+++++
apply analysis_seq_grows.
-----
Lemma analysis_seq_increase : forall (n m : nat) (h : hedge), n <= m -> inclusion (analysis_seq h n) (analysis_seq h m).
intros.
cut (exists p : nat, m = p + n).

*****
H : le n m
h : hedge
n,m : nat
*****
ex (fun p : nat => eq m (Init.Nat.add p n))
+++++
exists (m - n).
-----
Lemma analysis_seq_increase : forall (n m : nat) (h : hedge), n <= m -> inclusion (analysis_seq h n) (analysis_seq h m).
intros.
cut (exists p : nat, m = p + n).
exists (m - n).

*****
H : le n m
h : hedge
n,m : nat
*****
eq m (Init.Nat.add (Init.Nat.sub m n) n)
+++++
rewrite plus_comm.
-----
Lemma analysis_seq_increase : forall (n m : nat) (h : hedge), n <= m -> inclusion (analysis_seq h n) (analysis_seq h m).
intros.
cut (exists p : nat, m = p + n).
exists (m - n).
rewrite plus_comm.

*****
H : le n m
h : hedge
n,m : nat
*****
eq m (Nat.add n (Init.Nat.sub m n))
+++++
apply le_plus_minus.
-----
Lemma analysis_seq_increase : forall (n m : nat) (h : hedge), n <= m -> inclusion (analysis_seq h n) (analysis_seq h m).
intros.
cut (exists p : nat, m = p + n).
exists (m - n).
rewrite plus_comm.
apply le_plus_minus.

*****
H : le n m
h : hedge
n,m : nat
*****
le n m
+++++
trivial.
-----
Lemma analysis_seq_increase : forall (n m : nat) (h : hedge), n <= m -> inclusion (analysis_seq h n) (analysis_seq h m).
intros.
cut (exists p : nat, m = p + n).

*****

*****

+++++
Qed.
-----
Definition reduce (h : hedge) (M N : Msg) :=\n  h M N /\\n  match M with\n  | MEnc M' K =>\n      match N with\n      | MEnc N' L => ~ synthesis h M' N' \/ ~ synthesis h K L\n      | _ => True\n      end\n  | MPair M1 M2 =>\n      match N with\n      | MPair N1 N2 => ~ synthesis h M1 N1 \/ ~ synthesis h M2 N2\n      | _ => True\n      end\n  | Mop opM M' =>\n      match N with\n      | Mop opN N' => opM <> opN \/ ~ synthesis h M' N'\n      | _ => True\n      end\n  | _ => True\n  end.
-----
Lemma red_incl_h : forall h : hedge, inclusion (reduce h) h.
-----
Lemma red_incl_h : forall h : hedge, inclusion (reduce h) h.

*****

*****
forall h : hedge, inclusion (reduce h) h
+++++
unfold inclusion in |- *.
-----
Lemma red_incl_h : forall h : hedge, inclusion (reduce h) h.
unfold inclusion in |- *.

*****

*****
forall (h : hedge) (M N : Msg) (_ : reduce h M N), h M N
+++++
unfold reduce in |- *.
-----
Lemma red_incl_h : forall h : hedge, inclusion (reduce h) h.
unfold inclusion in |- *.
unfold reduce in |- *.

*****

*****
forall (h : hedge) (M N : Msg) (_ : and (h M N) match M with | MNam _ => True | MEnc M' K => match N with | MEnc N' L => or (not (synthesis h M' N')) (not (synthesis h K L)) | _ => True end | MPair M1 M2 => match N with | MPair N1 N2 => or (not (synthesis h M1 N1)) (not (synthesis h M2 N2)) | _ => True end | Mop opM M' => match N with | Mop opN N' => or (not (eq opM opN)) (not (synthesis h M' N')) | _ => True end end), h M N
+++++
tauto.
-----
Lemma red_incl_h : forall h : hedge, inclusion (reduce h) h.
unfold inclusion in |- *.
unfold reduce in |- *.
tauto.

*****

*****

+++++
Qed.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).

*****

*****
forall h : hedge, le_h h (reduce h)
+++++
unfold le_h in |- *.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.

*****

*****
forall h : hedge, inclusion (synthesis h) (synthesis (reduce h))
+++++
unfold inclusion in |- *.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.

*****

*****
forall (h : hedge) (M N : Msg) (_ : synthesis h M N), synthesis (reduce h) M N
+++++
intro.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.

*****
h : hedge
*****
forall (M N : Msg) (_ : synthesis h M N), synthesis (reduce h) M N
+++++
simple induction M.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.

*****
M : Msg
h : hedge
*****
forall (n : Nam) (N : Msg) (_ : synthesis h (MNam n) N), synthesis (reduce h) (MNam n) N
+++++
intros.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.
intros.

*****
H : synthesis h (MNam n) N
N : Msg
n : Nam
M : Msg
h : hedge
*****
synthesis (reduce h) (MNam n) N
+++++
apply SynInc.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.
intros.
apply SynInc.

*****
H : synthesis h (MNam n) N
N : Msg
n : Nam
M : Msg
h : hedge
*****
reduce h (MNam n) N
+++++
unfold reduce in |- *.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.
intros.
apply SynInc.
unfold reduce in |- *.

*****
H : synthesis h (MNam n) N
N : Msg
n : Nam
M : Msg
h : hedge
*****
and (h (MNam n) N) True
+++++
simpl in |- *.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.
intros.
apply SynInc.
unfold reduce in |- *.
simpl in |- *.

*****
H : synthesis h (MNam n) N
N : Msg
n : Nam
M : Msg
h : hedge
*****
and (h (MNam n) N) True
+++++
inversion H.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.
intros.
apply SynInc.
unfold reduce in |- *.
simpl in |- *.
inversion H.

*****
H2 : eq N0 N
H1 : eq M0 (MNam n)
H0 : h (MNam n) N
M0,N0 : Msg
H : synthesis h (MNam n) N
N : Msg
n : Nam
M : Msg
h : hedge
*****
and (h (MNam n) N) True
+++++
tauto.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.

*****
M : Msg
h : hedge
*****
forall (m : Msg) (_ : forall (N : Msg) (_ : synthesis h m N), synthesis (reduce h) m N) (m0 : Msg) (_ : forall (N : Msg) (_ : synthesis h m0 N), synthesis (reduce h) m0 N) (N : Msg) (_ : synthesis h (MEnc m m0) N), synthesis (reduce h) (MEnc m m0) N
+++++
intro M'.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.
intro M'.

*****
M,M' : Msg
h : hedge
*****
forall (_ : forall (N : Msg) (_ : synthesis h M' N), synthesis (reduce h) M' N) (m : Msg) (_ : forall (N : Msg) (_ : synthesis h m N), synthesis (reduce h) m N) (N : Msg) (_ : synthesis h (MEnc M' m) N), synthesis (reduce h) (MEnc M' m) N
+++++
intro.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.
intro M'.
intro.

*****
H : forall (N : Msg) (_ : synthesis h M' N), synthesis (reduce h) M' N
M,M' : Msg
h : hedge
*****
forall (m : Msg) (_ : forall (N : Msg) (_ : synthesis h m N), synthesis (reduce h) m N) (N : Msg) (_ : synthesis h (MEnc M' m) N), synthesis (reduce h) (MEnc M' m) N
+++++
intro K.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.
intro M'.
intro.
intro K.

*****
K : Msg
H : forall (N : Msg) (_ : synthesis h M' N), synthesis (reduce h) M' N
M,M' : Msg
h : hedge
*****
forall (_ : forall (N : Msg) (_ : synthesis h K N), synthesis (reduce h) K N) (N : Msg) (_ : synthesis h (MEnc M' K) N), synthesis (reduce h) (MEnc M' K) N
+++++
intro.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.
intro M'.
intro.
intro K.
intro.

*****
H0 : forall (N : Msg) (_ : synthesis h K N), synthesis (reduce h) K N
K : Msg
H : forall (N : Msg) (_ : synthesis h M' N), synthesis (reduce h) M' N
M,M' : Msg
h : hedge
*****
forall (N : Msg) (_ : synthesis h (MEnc M' K) N), synthesis (reduce h) (MEnc M' K) N
+++++
simple destruct N.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.
intro M'.
intro.
intro K.
intro.
simple destruct N.

*****
N : Msg
H0 : forall (N : Msg) (_ : synthesis h K N), synthesis (reduce h) K N
K : Msg
H : forall (N : Msg) (_ : synthesis h M' N), synthesis (reduce h) M' N
M,M' : Msg
h : hedge
*****
forall (n : Nam) (_ : synthesis h (MEnc M' K) (MNam n)), synthesis (reduce h) (MEnc M' K) (MNam n)
+++++
intros.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.
intro M'.
intro.
intro K.
intro.
simple destruct N.
intros.

*****
H1 : synthesis h (MEnc M' K) (MNam n)
n : Nam
N : Msg
H0 : forall (N : Msg) (_ : synthesis h K N), synthesis (reduce h) K N
K : Msg
H : forall (N : Msg) (_ : synthesis h M' N), synthesis (reduce h) M' N
M,M' : Msg
h : hedge
*****
synthesis (reduce h) (MEnc M' K) (MNam n)
+++++
apply SynInc.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.
intro M'.
intro.
intro K.
intro.
simple destruct N.
intros.
apply SynInc.

*****
H1 : synthesis h (MEnc M' K) (MNam n)
n : Nam
N : Msg
H0 : forall (N : Msg) (_ : synthesis h K N), synthesis (reduce h) K N
K : Msg
H : forall (N : Msg) (_ : synthesis h M' N), synthesis (reduce h) M' N
M,M' : Msg
h : hedge
*****
reduce h (MEnc M' K) (MNam n)
+++++
unfold reduce in |- *.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.
intro M'.
intro.
intro K.
intro.
simple destruct N.
intros.
apply SynInc.
unfold reduce in |- *.

*****
H1 : synthesis h (MEnc M' K) (MNam n)
n : Nam
N : Msg
H0 : forall (N : Msg) (_ : synthesis h K N), synthesis (reduce h) K N
K : Msg
H : forall (N : Msg) (_ : synthesis h M' N), synthesis (reduce h) M' N
M,M' : Msg
h : hedge
*****
and (h (MEnc M' K) (MNam n)) True
+++++
simpl in |- *.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.
intro M'.
intro.
intro K.
intro.
simple destruct N.
intros.
apply SynInc.
unfold reduce in |- *.
simpl in |- *.

*****
H1 : synthesis h (MEnc M' K) (MNam n)
n : Nam
N : Msg
H0 : forall (N : Msg) (_ : synthesis h K N), synthesis (reduce h) K N
K : Msg
H : forall (N : Msg) (_ : synthesis h M' N), synthesis (reduce h) M' N
M,M' : Msg
h : hedge
*****
and (h (MEnc M' K) (MNam n)) True
+++++
inversion H1.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.
intro M'.
intro.
intro K.
intro.
simple destruct N.
intros.
apply SynInc.
unfold reduce in |- *.
simpl in |- *.
inversion H1.

*****
H4 : eq N0 (MNam n)
H3 : eq M0 (MEnc M' K)
H2 : h (MEnc M' K) (MNam n)
M0,N0 : Msg
H1 : synthesis h (MEnc M' K) (MNam n)
n : Nam
N : Msg
H0 : forall (N : Msg) (_ : synthesis h K N), synthesis (reduce h) K N
K : Msg
H : forall (N : Msg) (_ : synthesis h M' N), synthesis (reduce h) M' N
M,M' : Msg
h : hedge
*****
and (h (MEnc M' K) (MNam n)) True
+++++
tauto.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.
intro M'.
intro.
intro K.
intro.
simple destruct N.

*****
N : Msg
H0 : forall (N : Msg) (_ : synthesis h K N), synthesis (reduce h) K N
K : Msg
H : forall (N : Msg) (_ : synthesis h M' N), synthesis (reduce h) M' N
M,M' : Msg
h : hedge
*****
forall (m m0 : Msg) (_ : synthesis h (MEnc M' K) (MEnc m m0)), synthesis (reduce h) (MEnc M' K) (MEnc m m0)
+++++
intros N' L.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.
intro M'.
intro.
intro K.
intro.
simple destruct N.
intros N' L.

*****
N,N',L : Msg
H0 : forall (N : Msg) (_ : synthesis h K N), synthesis (reduce h) K N
K : Msg
H : forall (N : Msg) (_ : synthesis h M' N), synthesis (reduce h) M' N
M,M' : Msg
h : hedge
*****
forall _ : synthesis h (MEnc M' K) (MEnc N' L), synthesis (reduce h) (MEnc M' K) (MEnc N' L)
+++++
intros.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.
intro M'.
intro.
intro K.
intro.
simple destruct N.
intros N' L.
intros.

*****
H1 : synthesis h (MEnc M' K) (MEnc N' L)
N,N',L : Msg
H0 : forall (N : Msg) (_ : synthesis h K N), synthesis (reduce h) K N
K : Msg
H : forall (N : Msg) (_ : synthesis h M' N), synthesis (reduce h) M' N
M,M' : Msg
h : hedge
*****
synthesis (reduce h) (MEnc M' K) (MEnc N' L)
+++++
case (hedge_mem_dec (synthesis h) M' N').
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.
intro M'.
intro.
intro K.
intro.
simple destruct N.
intros N' L.
intros.
case (hedge_mem_dec (synthesis h) M' N').

*****
H1 : synthesis h (MEnc M' K) (MEnc N' L)
N,N',L : Msg
H0 : forall (N : Msg) (_ : synthesis h K N), synthesis (reduce h) K N
K : Msg
H : forall (N : Msg) (_ : synthesis h M' N), synthesis (reduce h) M' N
M,M' : Msg
h : hedge
*****
forall _ : synthesis h M' N', synthesis (reduce h) (MEnc M' K) (MEnc N' L)
+++++
case (hedge_mem_dec (synthesis h) K L).
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.
intro M'.
intro.
intro K.
intro.
simple destruct N.
intros N' L.
intros.
case (hedge_mem_dec (synthesis h) M' N').
case (hedge_mem_dec (synthesis h) K L).

*****
H1 : synthesis h (MEnc M' K) (MEnc N' L)
N,N',L : Msg
H0 : forall (N : Msg) (_ : synthesis h K N), synthesis (reduce h) K N
K : Msg
H : forall (N : Msg) (_ : synthesis h M' N), synthesis (reduce h) M' N
M,M' : Msg
h : hedge
*****
forall (_ : synthesis h K L) (_ : synthesis h M' N'), synthesis (reduce h) (MEnc M' K) (MEnc N' L)
+++++
intros.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.
intro M'.
intro.
intro K.
intro.
simple destruct N.
intros N' L.
intros.
case (hedge_mem_dec (synthesis h) M' N').
case (hedge_mem_dec (synthesis h) K L).
intros.

*****
H3 : synthesis h M' N'
H2 : synthesis h K L
H1 : synthesis h (MEnc M' K) (MEnc N' L)
N,N',L : Msg
H0 : forall (N : Msg) (_ : synthesis h K N), synthesis (reduce h) K N
K : Msg
H : forall (N : Msg) (_ : synthesis h M' N), synthesis (reduce h) M' N
M,M' : Msg
h : hedge
*****
synthesis (reduce h) (MEnc M' K) (MEnc N' L)
+++++
apply SynEnc.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.
intro M'.
intro.
intro K.
intro.
simple destruct N.
intros N' L.
intros.
case (hedge_mem_dec (synthesis h) M' N').
case (hedge_mem_dec (synthesis h) K L).
intros.
apply SynEnc.

*****
H3 : synthesis h M' N'
H2 : synthesis h K L
H1 : synthesis h (MEnc M' K) (MEnc N' L)
N,N',L : Msg
H0 : forall (N : Msg) (_ : synthesis h K N), synthesis (reduce h) K N
K : Msg
H : forall (N : Msg) (_ : synthesis h M' N), synthesis (reduce h) M' N
M,M' : Msg
h : hedge
*****
synthesis (reduce h) M' N'
+++++
apply H.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.
intro M'.
intro.
intro K.
intro.
simple destruct N.
intros N' L.
intros.
case (hedge_mem_dec (synthesis h) M' N').
case (hedge_mem_dec (synthesis h) K L).
intros.
apply SynEnc.
apply H.

*****
H3 : synthesis h M' N'
H2 : synthesis h K L
H1 : synthesis h (MEnc M' K) (MEnc N' L)
N,N',L : Msg
H0 : forall (N : Msg) (_ : synthesis h K N), synthesis (reduce h) K N
K : Msg
H : forall (N : Msg) (_ : synthesis h M' N), synthesis (reduce h) M' N
M,M' : Msg
h : hedge
*****
synthesis h M' N'
+++++
trivial.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.
intro M'.
intro.
intro K.
intro.
simple destruct N.
intros N' L.
intros.
case (hedge_mem_dec (synthesis h) M' N').
case (hedge_mem_dec (synthesis h) K L).
intros.
apply SynEnc.

*****
H3 : synthesis h M' N'
H2 : synthesis h K L
H1 : synthesis h (MEnc M' K) (MEnc N' L)
N,N',L : Msg
H0 : forall (N : Msg) (_ : synthesis h K N), synthesis (reduce h) K N
K : Msg
H : forall (N : Msg) (_ : synthesis h M' N), synthesis (reduce h) M' N
M,M' : Msg
h : hedge
*****
synthesis (reduce h) K L
+++++
apply H0.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.
intro M'.
intro.
intro K.
intro.
simple destruct N.
intros N' L.
intros.
case (hedge_mem_dec (synthesis h) M' N').
case (hedge_mem_dec (synthesis h) K L).
intros.
apply SynEnc.
apply H0.

*****
H3 : synthesis h M' N'
H2 : synthesis h K L
H1 : synthesis h (MEnc M' K) (MEnc N' L)
N,N',L : Msg
H0 : forall (N : Msg) (_ : synthesis h K N), synthesis (reduce h) K N
K : Msg
H : forall (N : Msg) (_ : synthesis h M' N), synthesis (reduce h) M' N
M,M' : Msg
h : hedge
*****
synthesis h K L
+++++
trivial.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.
intro M'.
intro.
intro K.
intro.
simple destruct N.
intros N' L.
intros.
case (hedge_mem_dec (synthesis h) M' N').
case (hedge_mem_dec (synthesis h) K L).

*****
H1 : synthesis h (MEnc M' K) (MEnc N' L)
N,N',L : Msg
H0 : forall (N : Msg) (_ : synthesis h K N), synthesis (reduce h) K N
K : Msg
H : forall (N : Msg) (_ : synthesis h M' N), synthesis (reduce h) M' N
M,M' : Msg
h : hedge
*****
forall (_ : not (synthesis h K L)) (_ : synthesis h M' N'), synthesis (reduce h) (MEnc M' K) (MEnc N' L)
+++++
intros.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.
intro M'.
intro.
intro K.
intro.
simple destruct N.
intros N' L.
intros.
case (hedge_mem_dec (synthesis h) M' N').
case (hedge_mem_dec (synthesis h) K L).
intros.

*****
H3 : synthesis h M' N'
H2 : not (synthesis h K L)
H1 : synthesis h (MEnc M' K) (MEnc N' L)
N,N',L : Msg
H0 : forall (N : Msg) (_ : synthesis h K N), synthesis (reduce h) K N
K : Msg
H : forall (N : Msg) (_ : synthesis h M' N), synthesis (reduce h) M' N
M,M' : Msg
h : hedge
*****
synthesis (reduce h) (MEnc M' K) (MEnc N' L)
+++++
apply SynInc.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.
intro M'.
intro.
intro K.
intro.
simple destruct N.
intros N' L.
intros.
case (hedge_mem_dec (synthesis h) M' N').
case (hedge_mem_dec (synthesis h) K L).
intros.
apply SynInc.

*****
H3 : synthesis h M' N'
H2 : not (synthesis h K L)
H1 : synthesis h (MEnc M' K) (MEnc N' L)
N,N',L : Msg
H0 : forall (N : Msg) (_ : synthesis h K N), synthesis (reduce h) K N
K : Msg
H : forall (N : Msg) (_ : synthesis h M' N), synthesis (reduce h) M' N
M,M' : Msg
h : hedge
*****
reduce h (MEnc M' K) (MEnc N' L)
+++++
unfold reduce in |- *.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.
intro M'.
intro.
intro K.
intro.
simple destruct N.
intros N' L.
intros.
case (hedge_mem_dec (synthesis h) M' N').
case (hedge_mem_dec (synthesis h) K L).
intros.
apply SynInc.
unfold reduce in |- *.

*****
H3 : synthesis h M' N'
H2 : not (synthesis h K L)
H1 : synthesis h (MEnc M' K) (MEnc N' L)
N,N',L : Msg
H0 : forall (N : Msg) (_ : synthesis h K N), synthesis (reduce h) K N
K : Msg
H : forall (N : Msg) (_ : synthesis h M' N), synthesis (reduce h) M' N
M,M' : Msg
h : hedge
*****
and (h (MEnc M' K) (MEnc N' L)) (or (not (synthesis h M' N')) (not (synthesis h K L)))
+++++
simpl in |- *.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.
intro M'.
intro.
intro K.
intro.
simple destruct N.
intros N' L.
intros.
case (hedge_mem_dec (synthesis h) M' N').
case (hedge_mem_dec (synthesis h) K L).
intros.
apply SynInc.
unfold reduce in |- *.
simpl in |- *.

*****
H3 : synthesis h M' N'
H2 : not (synthesis h K L)
H1 : synthesis h (MEnc M' K) (MEnc N' L)
N,N',L : Msg
H0 : forall (N : Msg) (_ : synthesis h K N), synthesis (reduce h) K N
K : Msg
H : forall (N : Msg) (_ : synthesis h M' N), synthesis (reduce h) M' N
M,M' : Msg
h : hedge
*****
and (h (MEnc M' K) (MEnc N' L)) (or (not (synthesis h M' N')) (not (synthesis h K L)))
+++++
inversion H1.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.
intro M'.
intro.
intro K.
intro.
simple destruct N.
intros N' L.
intros.
case (hedge_mem_dec (synthesis h) M' N').
case (hedge_mem_dec (synthesis h) K L).
intros.
apply SynInc.
unfold reduce in |- *.
simpl in |- *.
inversion H1.

*****
H6 : eq N0 (MEnc N' L)
H5 : eq M0 (MEnc M' K)
H4 : h (MEnc M' K) (MEnc N' L)
M0,N0 : Msg
H3 : synthesis h M' N'
H2 : not (synthesis h K L)
H1 : synthesis h (MEnc M' K) (MEnc N' L)
N,N',L : Msg
H0 : forall (N : Msg) (_ : synthesis h K N), synthesis (reduce h) K N
K : Msg
H : forall (N : Msg) (_ : synthesis h M' N), synthesis (reduce h) M' N
M,M' : Msg
h : hedge
*****
and (h (MEnc M' K) (MEnc N' L)) (or (not (synthesis h M' N')) (not (synthesis h K L)))
+++++
split.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.
intro M'.
intro.
intro K.
intro.
simple destruct N.
intros N' L.
intros.
case (hedge_mem_dec (synthesis h) M' N').
case (hedge_mem_dec (synthesis h) K L).
intros.
apply SynInc.
unfold reduce in |- *.
simpl in |- *.
inversion H1.
split.

*****
H6 : eq N0 (MEnc N' L)
H5 : eq M0 (MEnc M' K)
H4 : h (MEnc M' K) (MEnc N' L)
M0,N0 : Msg
H3 : synthesis h M' N'
H2 : not (synthesis h K L)
H1 : synthesis h (MEnc M' K) (MEnc N' L)
N,N',L : Msg
H0 : forall (N : Msg) (_ : synthesis h K N), synthesis (reduce h) K N
K : Msg
H : forall (N : Msg) (_ : synthesis h M' N), synthesis (reduce h) M' N
M,M' : Msg
h : hedge
*****
h (MEnc M' K) (MEnc N' L)
+++++
tauto.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.
intro M'.
intro.
intro K.
intro.
simple destruct N.
intros N' L.
intros.
case (hedge_mem_dec (synthesis h) M' N').
case (hedge_mem_dec (synthesis h) K L).
intros.
apply SynInc.
unfold reduce in |- *.
simpl in |- *.
inversion H1.
split.

*****
H6 : eq N0 (MEnc N' L)
H5 : eq M0 (MEnc M' K)
H4 : h (MEnc M' K) (MEnc N' L)
M0,N0 : Msg
H3 : synthesis h M' N'
H2 : not (synthesis h K L)
H1 : synthesis h (MEnc M' K) (MEnc N' L)
N,N',L : Msg
H0 : forall (N : Msg) (_ : synthesis h K N), synthesis (reduce h) K N
K : Msg
H : forall (N : Msg) (_ : synthesis h M' N), synthesis (reduce h) M' N
M,M' : Msg
h : hedge
*****
or (not (synthesis h M' N')) (not (synthesis h K L))
+++++
tauto.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.
intro M'.
intro.
intro K.
intro.
simple destruct N.
intros N' L.
intros.
case (hedge_mem_dec (synthesis h) M' N').
case (hedge_mem_dec (synthesis h) K L).
intros.
apply SynInc.
unfold reduce in |- *.
simpl in |- *.
inversion H1.

*****
H8 : eq L0 L
H6 : eq N0 N'
H5 : eq K0 K
H4 : eq M0 M'
H9 : synthesis h K L
H7 : synthesis h M' N'
M0,N0,K0,L0 : Msg
H3 : synthesis h M' N'
H2 : not (synthesis h K L)
H1 : synthesis h (MEnc M' K) (MEnc N' L)
N,N',L : Msg
H0 : forall (N : Msg) (_ : synthesis h K N), synthesis (reduce h) K N
K : Msg
H : forall (N : Msg) (_ : synthesis h M' N), synthesis (reduce h) M' N
M,M' : Msg
h : hedge
*****
and (h (MEnc M' K) (MEnc N' L)) (or (not (synthesis h M' N')) (not (synthesis h K L)))
+++++
tauto.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.
intro M'.
intro.
intro K.
intro.
simple destruct N.
intros N' L.
intros.
case (hedge_mem_dec (synthesis h) M' N').

*****
H1 : synthesis h (MEnc M' K) (MEnc N' L)
N,N',L : Msg
H0 : forall (N : Msg) (_ : synthesis h K N), synthesis (reduce h) K N
K : Msg
H : forall (N : Msg) (_ : synthesis h M' N), synthesis (reduce h) M' N
M,M' : Msg
h : hedge
*****
forall _ : not (synthesis h M' N'), synthesis (reduce h) (MEnc M' K) (MEnc N' L)
+++++
intro.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.
intro M'.
intro.
intro K.
intro.
simple destruct N.
intros N' L.
intros.
case (hedge_mem_dec (synthesis h) M' N').
intro.

*****
H2 : not (synthesis h M' N')
H1 : synthesis h (MEnc M' K) (MEnc N' L)
N,N',L : Msg
H0 : forall (N : Msg) (_ : synthesis h K N), synthesis (reduce h) K N
K : Msg
H : forall (N : Msg) (_ : synthesis h M' N), synthesis (reduce h) M' N
M,M' : Msg
h : hedge
*****
synthesis (reduce h) (MEnc M' K) (MEnc N' L)
+++++
apply SynInc.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.
intro M'.
intro.
intro K.
intro.
simple destruct N.
intros N' L.
intros.
case (hedge_mem_dec (synthesis h) M' N').
intro.
apply SynInc.

*****
H2 : not (synthesis h M' N')
H1 : synthesis h (MEnc M' K) (MEnc N' L)
N,N',L : Msg
H0 : forall (N : Msg) (_ : synthesis h K N), synthesis (reduce h) K N
K : Msg
H : forall (N : Msg) (_ : synthesis h M' N), synthesis (reduce h) M' N
M,M' : Msg
h : hedge
*****
reduce h (MEnc M' K) (MEnc N' L)
+++++
unfold reduce in |- *.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.
intro M'.
intro.
intro K.
intro.
simple destruct N.
intros N' L.
intros.
case (hedge_mem_dec (synthesis h) M' N').
intro.
apply SynInc.
unfold reduce in |- *.

*****
H2 : not (synthesis h M' N')
H1 : synthesis h (MEnc M' K) (MEnc N' L)
N,N',L : Msg
H0 : forall (N : Msg) (_ : synthesis h K N), synthesis (reduce h) K N
K : Msg
H : forall (N : Msg) (_ : synthesis h M' N), synthesis (reduce h) M' N
M,M' : Msg
h : hedge
*****
and (h (MEnc M' K) (MEnc N' L)) (or (not (synthesis h M' N')) (not (synthesis h K L)))
+++++
simpl in |- *.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.
intro M'.
intro.
intro K.
intro.
simple destruct N.
intros N' L.
intros.
case (hedge_mem_dec (synthesis h) M' N').
intro.
apply SynInc.
unfold reduce in |- *.
simpl in |- *.

*****
H2 : not (synthesis h M' N')
H1 : synthesis h (MEnc M' K) (MEnc N' L)
N,N',L : Msg
H0 : forall (N : Msg) (_ : synthesis h K N), synthesis (reduce h) K N
K : Msg
H : forall (N : Msg) (_ : synthesis h M' N), synthesis (reduce h) M' N
M,M' : Msg
h : hedge
*****
and (h (MEnc M' K) (MEnc N' L)) (or (not (synthesis h M' N')) (not (synthesis h K L)))
+++++
inversion H1.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.
intro M'.
intro.
intro K.
intro.
simple destruct N.
intros N' L.
intros.
case (hedge_mem_dec (synthesis h) M' N').
intro.
apply SynInc.
unfold reduce in |- *.
simpl in |- *.
inversion H1.

*****
H5 : eq N0 (MEnc N' L)
H4 : eq M0 (MEnc M' K)
H3 : h (MEnc M' K) (MEnc N' L)
M0,N0 : Msg
H2 : not (synthesis h M' N')
H1 : synthesis h (MEnc M' K) (MEnc N' L)
N,N',L : Msg
H0 : forall (N : Msg) (_ : synthesis h K N), synthesis (reduce h) K N
K : Msg
H : forall (N : Msg) (_ : synthesis h M' N), synthesis (reduce h) M' N
M,M' : Msg
h : hedge
*****
and (h (MEnc M' K) (MEnc N' L)) (or (not (synthesis h M' N')) (not (synthesis h K L)))
+++++
tauto.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.
intro M'.
intro.
intro K.
intro.
simple destruct N.
intros N' L.
intros.
case (hedge_mem_dec (synthesis h) M' N').
intro.
apply SynInc.
unfold reduce in |- *.
simpl in |- *.
inversion H1.

*****
H7 : eq L0 L
H5 : eq N0 N'
H4 : eq K0 K
H3 : eq M0 M'
H8 : synthesis h K L
H6 : synthesis h M' N'
M0,N0,K0,L0 : Msg
H2 : not (synthesis h M' N')
H1 : synthesis h (MEnc M' K) (MEnc N' L)
N,N',L : Msg
H0 : forall (N : Msg) (_ : synthesis h K N), synthesis (reduce h) K N
K : Msg
H : forall (N : Msg) (_ : synthesis h M' N), synthesis (reduce h) M' N
M,M' : Msg
h : hedge
*****
and (h (MEnc M' K) (MEnc N' L)) (or (not (synthesis h M' N')) (not (synthesis h K L)))
+++++
tauto.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.
intro M'.
intro.
intro K.
intro.
simple destruct N.

*****
N : Msg
H0 : forall (N : Msg) (_ : synthesis h K N), synthesis (reduce h) K N
K : Msg
H : forall (N : Msg) (_ : synthesis h M' N), synthesis (reduce h) M' N
M,M' : Msg
h : hedge
*****
forall (m m0 : Msg) (_ : synthesis h (MEnc M' K) (MPair m m0)), synthesis (reduce h) (MEnc M' K) (MPair m m0)
+++++
intros.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.
intro M'.
intro.
intro K.
intro.
simple destruct N.
intros.

*****
H1 : synthesis h (MEnc M' K) (MPair m m0)
N,m,m0 : Msg
H0 : forall (N : Msg) (_ : synthesis h K N), synthesis (reduce h) K N
K : Msg
H : forall (N : Msg) (_ : synthesis h M' N), synthesis (reduce h) M' N
M,M' : Msg
h : hedge
*****
synthesis (reduce h) (MEnc M' K) (MPair m m0)
+++++
apply SynInc.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.
intro M'.
intro.
intro K.
intro.
simple destruct N.
intros.
apply SynInc.

*****
H1 : synthesis h (MEnc M' K) (MPair m m0)
N,m,m0 : Msg
H0 : forall (N : Msg) (_ : synthesis h K N), synthesis (reduce h) K N
K : Msg
H : forall (N : Msg) (_ : synthesis h M' N), synthesis (reduce h) M' N
M,M' : Msg
h : hedge
*****
reduce h (MEnc M' K) (MPair m m0)
+++++
unfold reduce in |- *.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.
intro M'.
intro.
intro K.
intro.
simple destruct N.
intros.
apply SynInc.
unfold reduce in |- *.

*****
H1 : synthesis h (MEnc M' K) (MPair m m0)
N,m,m0 : Msg
H0 : forall (N : Msg) (_ : synthesis h K N), synthesis (reduce h) K N
K : Msg
H : forall (N : Msg) (_ : synthesis h M' N), synthesis (reduce h) M' N
M,M' : Msg
h : hedge
*****
and (h (MEnc M' K) (MPair m m0)) True
+++++
simpl in |- *.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.
intro M'.
intro.
intro K.
intro.
simple destruct N.
intros.
apply SynInc.
unfold reduce in |- *.
simpl in |- *.

*****
H1 : synthesis h (MEnc M' K) (MPair m m0)
N,m,m0 : Msg
H0 : forall (N : Msg) (_ : synthesis h K N), synthesis (reduce h) K N
K : Msg
H : forall (N : Msg) (_ : synthesis h M' N), synthesis (reduce h) M' N
M,M' : Msg
h : hedge
*****
and (h (MEnc M' K) (MPair m m0)) True
+++++
inversion H1.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.
intro M'.
intro.
intro K.
intro.
simple destruct N.
intros.
apply SynInc.
unfold reduce in |- *.
simpl in |- *.
inversion H1.

*****
H4 : eq N0 (MPair m m0)
H3 : eq M0 (MEnc M' K)
H2 : h (MEnc M' K) (MPair m m0)
M0,N0 : Msg
H1 : synthesis h (MEnc M' K) (MPair m m0)
N,m,m0 : Msg
H0 : forall (N : Msg) (_ : synthesis h K N), synthesis (reduce h) K N
K : Msg
H : forall (N : Msg) (_ : synthesis h M' N), synthesis (reduce h) M' N
M,M' : Msg
h : hedge
*****
and (h (MEnc M' K) (MPair m m0)) True
+++++
tauto.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.
intro M'.
intro.
intro K.
intro.
simple destruct N.

*****
N : Msg
H0 : forall (N : Msg) (_ : synthesis h K N), synthesis (reduce h) K N
K : Msg
H : forall (N : Msg) (_ : synthesis h M' N), synthesis (reduce h) M' N
M,M' : Msg
h : hedge
*****
forall (o : op) (m : Msg) (_ : synthesis h (MEnc M' K) (Mop o m)), synthesis (reduce h) (MEnc M' K) (Mop o m)
+++++
intros.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.
intro M'.
intro.
intro K.
intro.
simple destruct N.
intros.

*****
H1 : synthesis h (MEnc M' K) (Mop o m)
m : Msg
o : op
N : Msg
H0 : forall (N : Msg) (_ : synthesis h K N), synthesis (reduce h) K N
K : Msg
H : forall (N : Msg) (_ : synthesis h M' N), synthesis (reduce h) M' N
M,M' : Msg
h : hedge
*****
synthesis (reduce h) (MEnc M' K) (Mop o m)
+++++
apply SynInc.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.
intro M'.
intro.
intro K.
intro.
simple destruct N.
intros.
apply SynInc.

*****
H1 : synthesis h (MEnc M' K) (Mop o m)
m : Msg
o : op
N : Msg
H0 : forall (N : Msg) (_ : synthesis h K N), synthesis (reduce h) K N
K : Msg
H : forall (N : Msg) (_ : synthesis h M' N), synthesis (reduce h) M' N
M,M' : Msg
h : hedge
*****
reduce h (MEnc M' K) (Mop o m)
+++++
unfold reduce in |- *.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.
intro M'.
intro.
intro K.
intro.
simple destruct N.
intros.
apply SynInc.
unfold reduce in |- *.

*****
H1 : synthesis h (MEnc M' K) (Mop o m)
m : Msg
o : op
N : Msg
H0 : forall (N : Msg) (_ : synthesis h K N), synthesis (reduce h) K N
K : Msg
H : forall (N : Msg) (_ : synthesis h M' N), synthesis (reduce h) M' N
M,M' : Msg
h : hedge
*****
and (h (MEnc M' K) (Mop o m)) True
+++++
simpl in |- *.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.
intro M'.
intro.
intro K.
intro.
simple destruct N.
intros.
apply SynInc.
unfold reduce in |- *.
simpl in |- *.

*****
H1 : synthesis h (MEnc M' K) (Mop o m)
m : Msg
o : op
N : Msg
H0 : forall (N : Msg) (_ : synthesis h K N), synthesis (reduce h) K N
K : Msg
H : forall (N : Msg) (_ : synthesis h M' N), synthesis (reduce h) M' N
M,M' : Msg
h : hedge
*****
and (h (MEnc M' K) (Mop o m)) True
+++++
inversion H1.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.
intro M'.
intro.
intro K.
intro.
simple destruct N.
intros.
apply SynInc.
unfold reduce in |- *.
simpl in |- *.
inversion H1.

*****
H4 : eq N0 (Mop o m)
H3 : eq M0 (MEnc M' K)
H2 : h (MEnc M' K) (Mop o m)
M0,N0 : Msg
H1 : synthesis h (MEnc M' K) (Mop o m)
m : Msg
o : op
N : Msg
H0 : forall (N : Msg) (_ : synthesis h K N), synthesis (reduce h) K N
K : Msg
H : forall (N : Msg) (_ : synthesis h M' N), synthesis (reduce h) M' N
M,M' : Msg
h : hedge
*****
and (h (MEnc M' K) (Mop o m)) True
+++++
tauto.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.

*****
M : Msg
h : hedge
*****
forall (m : Msg) (_ : forall (N : Msg) (_ : synthesis h m N), synthesis (reduce h) m N) (m0 : Msg) (_ : forall (N : Msg) (_ : synthesis h m0 N), synthesis (reduce h) m0 N) (N : Msg) (_ : synthesis h (MPair m m0) N), synthesis (reduce h) (MPair m m0) N
+++++
intro M1.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.
intro M1.

*****
M,M1 : Msg
h : hedge
*****
forall (_ : forall (N : Msg) (_ : synthesis h M1 N), synthesis (reduce h) M1 N) (m : Msg) (_ : forall (N : Msg) (_ : synthesis h m N), synthesis (reduce h) m N) (N : Msg) (_ : synthesis h (MPair M1 m) N), synthesis (reduce h) (MPair M1 m) N
+++++
intro.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.
intro M1.
intro.

*****
H : forall (N : Msg) (_ : synthesis h M1 N), synthesis (reduce h) M1 N
M,M1 : Msg
h : hedge
*****
forall (m : Msg) (_ : forall (N : Msg) (_ : synthesis h m N), synthesis (reduce h) m N) (N : Msg) (_ : synthesis h (MPair M1 m) N), synthesis (reduce h) (MPair M1 m) N
+++++
intro M2.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.
intro M1.
intro.
intro M2.

*****
M2 : Msg
H : forall (N : Msg) (_ : synthesis h M1 N), synthesis (reduce h) M1 N
M,M1 : Msg
h : hedge
*****
forall (_ : forall (N : Msg) (_ : synthesis h M2 N), synthesis (reduce h) M2 N) (N : Msg) (_ : synthesis h (MPair M1 M2) N), synthesis (reduce h) (MPair M1 M2) N
+++++
intro.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.
intro M1.
intro.
intro M2.
intro.

*****
H0 : forall (N : Msg) (_ : synthesis h M2 N), synthesis (reduce h) M2 N
M2 : Msg
H : forall (N : Msg) (_ : synthesis h M1 N), synthesis (reduce h) M1 N
M,M1 : Msg
h : hedge
*****
forall (N : Msg) (_ : synthesis h (MPair M1 M2) N), synthesis (reduce h) (MPair M1 M2) N
+++++
simple destruct N.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.
intro M1.
intro.
intro M2.
intro.
simple destruct N.

*****
N : Msg
H0 : forall (N : Msg) (_ : synthesis h M2 N), synthesis (reduce h) M2 N
M2 : Msg
H : forall (N : Msg) (_ : synthesis h M1 N), synthesis (reduce h) M1 N
M,M1 : Msg
h : hedge
*****
forall (n : Nam) (_ : synthesis h (MPair M1 M2) (MNam n)), synthesis (reduce h) (MPair M1 M2) (MNam n)
+++++
intros.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.
intro M1.
intro.
intro M2.
intro.
simple destruct N.
intros.

*****
H1 : synthesis h (MPair M1 M2) (MNam n)
n : Nam
N : Msg
H0 : forall (N : Msg) (_ : synthesis h M2 N), synthesis (reduce h) M2 N
M2 : Msg
H : forall (N : Msg) (_ : synthesis h M1 N), synthesis (reduce h) M1 N
M,M1 : Msg
h : hedge
*****
synthesis (reduce h) (MPair M1 M2) (MNam n)
+++++
apply SynInc.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.
intro M1.
intro.
intro M2.
intro.
simple destruct N.
intros.
apply SynInc.

*****
H1 : synthesis h (MPair M1 M2) (MNam n)
n : Nam
N : Msg
H0 : forall (N : Msg) (_ : synthesis h M2 N), synthesis (reduce h) M2 N
M2 : Msg
H : forall (N : Msg) (_ : synthesis h M1 N), synthesis (reduce h) M1 N
M,M1 : Msg
h : hedge
*****
reduce h (MPair M1 M2) (MNam n)
+++++
unfold reduce in |- *.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.
intro M1.
intro.
intro M2.
intro.
simple destruct N.
intros.
apply SynInc.
unfold reduce in |- *.

*****
H1 : synthesis h (MPair M1 M2) (MNam n)
n : Nam
N : Msg
H0 : forall (N : Msg) (_ : synthesis h M2 N), synthesis (reduce h) M2 N
M2 : Msg
H : forall (N : Msg) (_ : synthesis h M1 N), synthesis (reduce h) M1 N
M,M1 : Msg
h : hedge
*****
and (h (MPair M1 M2) (MNam n)) True
+++++
simpl in |- *.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.
intro M1.
intro.
intro M2.
intro.
simple destruct N.
intros.
apply SynInc.
unfold reduce in |- *.
simpl in |- *.

*****
H1 : synthesis h (MPair M1 M2) (MNam n)
n : Nam
N : Msg
H0 : forall (N : Msg) (_ : synthesis h M2 N), synthesis (reduce h) M2 N
M2 : Msg
H : forall (N : Msg) (_ : synthesis h M1 N), synthesis (reduce h) M1 N
M,M1 : Msg
h : hedge
*****
and (h (MPair M1 M2) (MNam n)) True
+++++
inversion H1.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.
intro M1.
intro.
intro M2.
intro.
simple destruct N.
intros.
apply SynInc.
unfold reduce in |- *.
simpl in |- *.
inversion H1.

*****
H4 : eq N0 (MNam n)
H3 : eq M0 (MPair M1 M2)
H2 : h (MPair M1 M2) (MNam n)
M0,N0 : Msg
H1 : synthesis h (MPair M1 M2) (MNam n)
n : Nam
N : Msg
H0 : forall (N : Msg) (_ : synthesis h M2 N), synthesis (reduce h) M2 N
M2 : Msg
H : forall (N : Msg) (_ : synthesis h M1 N), synthesis (reduce h) M1 N
M,M1 : Msg
h : hedge
*****
and (h (MPair M1 M2) (MNam n)) True
+++++
tauto.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.
intro M1.
intro.
intro M2.
intro.
simple destruct N.

*****
N : Msg
H0 : forall (N : Msg) (_ : synthesis h M2 N), synthesis (reduce h) M2 N
M2 : Msg
H : forall (N : Msg) (_ : synthesis h M1 N), synthesis (reduce h) M1 N
M,M1 : Msg
h : hedge
*****
forall (m m0 : Msg) (_ : synthesis h (MPair M1 M2) (MEnc m m0)), synthesis (reduce h) (MPair M1 M2) (MEnc m m0)
+++++
intros.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.
intro M1.
intro.
intro M2.
intro.
simple destruct N.
intros.

*****
H1 : synthesis h (MPair M1 M2) (MEnc m m0)
N,m,m0 : Msg
H0 : forall (N : Msg) (_ : synthesis h M2 N), synthesis (reduce h) M2 N
M2 : Msg
H : forall (N : Msg) (_ : synthesis h M1 N), synthesis (reduce h) M1 N
M,M1 : Msg
h : hedge
*****
synthesis (reduce h) (MPair M1 M2) (MEnc m m0)
+++++
apply SynInc.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.
intro M1.
intro.
intro M2.
intro.
simple destruct N.
intros.
apply SynInc.

*****
H1 : synthesis h (MPair M1 M2) (MEnc m m0)
N,m,m0 : Msg
H0 : forall (N : Msg) (_ : synthesis h M2 N), synthesis (reduce h) M2 N
M2 : Msg
H : forall (N : Msg) (_ : synthesis h M1 N), synthesis (reduce h) M1 N
M,M1 : Msg
h : hedge
*****
reduce h (MPair M1 M2) (MEnc m m0)
+++++
unfold reduce in |- *.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.
intro M1.
intro.
intro M2.
intro.
simple destruct N.
intros.
apply SynInc.
unfold reduce in |- *.

*****
H1 : synthesis h (MPair M1 M2) (MEnc m m0)
N,m,m0 : Msg
H0 : forall (N : Msg) (_ : synthesis h M2 N), synthesis (reduce h) M2 N
M2 : Msg
H : forall (N : Msg) (_ : synthesis h M1 N), synthesis (reduce h) M1 N
M,M1 : Msg
h : hedge
*****
and (h (MPair M1 M2) (MEnc m m0)) True
+++++
simpl in |- *.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.
intro M1.
intro.
intro M2.
intro.
simple destruct N.
intros.
apply SynInc.
unfold reduce in |- *.
simpl in |- *.

*****
H1 : synthesis h (MPair M1 M2) (MEnc m m0)
N,m,m0 : Msg
H0 : forall (N : Msg) (_ : synthesis h M2 N), synthesis (reduce h) M2 N
M2 : Msg
H : forall (N : Msg) (_ : synthesis h M1 N), synthesis (reduce h) M1 N
M,M1 : Msg
h : hedge
*****
and (h (MPair M1 M2) (MEnc m m0)) True
+++++
inversion H1.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.
intro M1.
intro.
intro M2.
intro.
simple destruct N.
intros.
apply SynInc.
unfold reduce in |- *.
simpl in |- *.
inversion H1.

*****
H4 : eq N0 (MEnc m m0)
H3 : eq M0 (MPair M1 M2)
H2 : h (MPair M1 M2) (MEnc m m0)
M0,N0 : Msg
H1 : synthesis h (MPair M1 M2) (MEnc m m0)
N,m,m0 : Msg
H0 : forall (N : Msg) (_ : synthesis h M2 N), synthesis (reduce h) M2 N
M2 : Msg
H : forall (N : Msg) (_ : synthesis h M1 N), synthesis (reduce h) M1 N
M,M1 : Msg
h : hedge
*****
and (h (MPair M1 M2) (MEnc m m0)) True
+++++
tauto.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.
intro M1.
intro.
intro M2.
intro.
simple destruct N.

*****
N : Msg
H0 : forall (N : Msg) (_ : synthesis h M2 N), synthesis (reduce h) M2 N
M2 : Msg
H : forall (N : Msg) (_ : synthesis h M1 N), synthesis (reduce h) M1 N
M,M1 : Msg
h : hedge
*****
forall (m m0 : Msg) (_ : synthesis h (MPair M1 M2) (MPair m m0)), synthesis (reduce h) (MPair M1 M2) (MPair m m0)
+++++
intros N1 N2.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.
intro M1.
intro.
intro M2.
intro.
simple destruct N.
intros N1 N2.

*****
N,N1,N2 : Msg
H0 : forall (N : Msg) (_ : synthesis h M2 N), synthesis (reduce h) M2 N
M2 : Msg
H : forall (N : Msg) (_ : synthesis h M1 N), synthesis (reduce h) M1 N
M,M1 : Msg
h : hedge
*****
forall _ : synthesis h (MPair M1 M2) (MPair N1 N2), synthesis (reduce h) (MPair M1 M2) (MPair N1 N2)
+++++
intro.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.
intro M1.
intro.
intro M2.
intro.
simple destruct N.
intros N1 N2.
intro.

*****
H1 : synthesis h (MPair M1 M2) (MPair N1 N2)
N,N1,N2 : Msg
H0 : forall (N : Msg) (_ : synthesis h M2 N), synthesis (reduce h) M2 N
M2 : Msg
H : forall (N : Msg) (_ : synthesis h M1 N), synthesis (reduce h) M1 N
M,M1 : Msg
h : hedge
*****
synthesis (reduce h) (MPair M1 M2) (MPair N1 N2)
+++++
case (hedge_mem_dec (synthesis h) M1 N1).
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.
intro M1.
intro.
intro M2.
intro.
simple destruct N.
intros N1 N2.
intro.
case (hedge_mem_dec (synthesis h) M1 N1).

*****
H1 : synthesis h (MPair M1 M2) (MPair N1 N2)
N,N1,N2 : Msg
H0 : forall (N : Msg) (_ : synthesis h M2 N), synthesis (reduce h) M2 N
M2 : Msg
H : forall (N : Msg) (_ : synthesis h M1 N), synthesis (reduce h) M1 N
M,M1 : Msg
h : hedge
*****
forall _ : synthesis h M1 N1, synthesis (reduce h) (MPair M1 M2) (MPair N1 N2)
+++++
case (hedge_mem_dec (synthesis h) M2 N2).
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.
intro M1.
intro.
intro M2.
intro.
simple destruct N.
intros N1 N2.
intro.
case (hedge_mem_dec (synthesis h) M1 N1).
case (hedge_mem_dec (synthesis h) M2 N2).

*****
H1 : synthesis h (MPair M1 M2) (MPair N1 N2)
N,N1,N2 : Msg
H0 : forall (N : Msg) (_ : synthesis h M2 N), synthesis (reduce h) M2 N
M2 : Msg
H : forall (N : Msg) (_ : synthesis h M1 N), synthesis (reduce h) M1 N
M,M1 : Msg
h : hedge
*****
forall (_ : synthesis h M2 N2) (_ : synthesis h M1 N1), synthesis (reduce h) (MPair M1 M2) (MPair N1 N2)
+++++
intros.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.
intro M1.
intro.
intro M2.
intro.
simple destruct N.
intros N1 N2.
intro.
case (hedge_mem_dec (synthesis h) M1 N1).
case (hedge_mem_dec (synthesis h) M2 N2).
intros.

*****
H3 : synthesis h M1 N1
H2 : synthesis h M2 N2
H1 : synthesis h (MPair M1 M2) (MPair N1 N2)
N,N1,N2 : Msg
H0 : forall (N : Msg) (_ : synthesis h M2 N), synthesis (reduce h) M2 N
M2 : Msg
H : forall (N : Msg) (_ : synthesis h M1 N), synthesis (reduce h) M1 N
M,M1 : Msg
h : hedge
*****
synthesis (reduce h) (MPair M1 M2) (MPair N1 N2)
+++++
apply SynPair.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.
intro M1.
intro.
intro M2.
intro.
simple destruct N.
intros N1 N2.
intro.
case (hedge_mem_dec (synthesis h) M1 N1).
case (hedge_mem_dec (synthesis h) M2 N2).
intros.
apply SynPair.

*****
H3 : synthesis h M1 N1
H2 : synthesis h M2 N2
H1 : synthesis h (MPair M1 M2) (MPair N1 N2)
N,N1,N2 : Msg
H0 : forall (N : Msg) (_ : synthesis h M2 N), synthesis (reduce h) M2 N
M2 : Msg
H : forall (N : Msg) (_ : synthesis h M1 N), synthesis (reduce h) M1 N
M,M1 : Msg
h : hedge
*****
synthesis (reduce h) M1 N1
+++++
apply H.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.
intro M1.
intro.
intro M2.
intro.
simple destruct N.
intros N1 N2.
intro.
case (hedge_mem_dec (synthesis h) M1 N1).
case (hedge_mem_dec (synthesis h) M2 N2).
intros.
apply SynPair.
apply H.

*****
H3 : synthesis h M1 N1
H2 : synthesis h M2 N2
H1 : synthesis h (MPair M1 M2) (MPair N1 N2)
N,N1,N2 : Msg
H0 : forall (N : Msg) (_ : synthesis h M2 N), synthesis (reduce h) M2 N
M2 : Msg
H : forall (N : Msg) (_ : synthesis h M1 N), synthesis (reduce h) M1 N
M,M1 : Msg
h : hedge
*****
synthesis h M1 N1
+++++
trivial.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.
intro M1.
intro.
intro M2.
intro.
simple destruct N.
intros N1 N2.
intro.
case (hedge_mem_dec (synthesis h) M1 N1).
case (hedge_mem_dec (synthesis h) M2 N2).
intros.
apply SynPair.

*****
H3 : synthesis h M1 N1
H2 : synthesis h M2 N2
H1 : synthesis h (MPair M1 M2) (MPair N1 N2)
N,N1,N2 : Msg
H0 : forall (N : Msg) (_ : synthesis h M2 N), synthesis (reduce h) M2 N
M2 : Msg
H : forall (N : Msg) (_ : synthesis h M1 N), synthesis (reduce h) M1 N
M,M1 : Msg
h : hedge
*****
synthesis (reduce h) M2 N2
+++++
apply H0.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.
intro M1.
intro.
intro M2.
intro.
simple destruct N.
intros N1 N2.
intro.
case (hedge_mem_dec (synthesis h) M1 N1).
case (hedge_mem_dec (synthesis h) M2 N2).
intros.
apply SynPair.
apply H0.

*****
H3 : synthesis h M1 N1
H2 : synthesis h M2 N2
H1 : synthesis h (MPair M1 M2) (MPair N1 N2)
N,N1,N2 : Msg
H0 : forall (N : Msg) (_ : synthesis h M2 N), synthesis (reduce h) M2 N
M2 : Msg
H : forall (N : Msg) (_ : synthesis h M1 N), synthesis (reduce h) M1 N
M,M1 : Msg
h : hedge
*****
synthesis h M2 N2
+++++
trivial.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.
intro M1.
intro.
intro M2.
intro.
simple destruct N.
intros N1 N2.
intro.
case (hedge_mem_dec (synthesis h) M1 N1).
case (hedge_mem_dec (synthesis h) M2 N2).

*****
H1 : synthesis h (MPair M1 M2) (MPair N1 N2)
N,N1,N2 : Msg
H0 : forall (N : Msg) (_ : synthesis h M2 N), synthesis (reduce h) M2 N
M2 : Msg
H : forall (N : Msg) (_ : synthesis h M1 N), synthesis (reduce h) M1 N
M,M1 : Msg
h : hedge
*****
forall (_ : not (synthesis h M2 N2)) (_ : synthesis h M1 N1), synthesis (reduce h) (MPair M1 M2) (MPair N1 N2)
+++++
intros.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.
intro M1.
intro.
intro M2.
intro.
simple destruct N.
intros N1 N2.
intro.
case (hedge_mem_dec (synthesis h) M1 N1).
case (hedge_mem_dec (synthesis h) M2 N2).
intros.

*****
H3 : synthesis h M1 N1
H2 : not (synthesis h M2 N2)
H1 : synthesis h (MPair M1 M2) (MPair N1 N2)
N,N1,N2 : Msg
H0 : forall (N : Msg) (_ : synthesis h M2 N), synthesis (reduce h) M2 N
M2 : Msg
H : forall (N : Msg) (_ : synthesis h M1 N), synthesis (reduce h) M1 N
M,M1 : Msg
h : hedge
*****
synthesis (reduce h) (MPair M1 M2) (MPair N1 N2)
+++++
apply SynInc.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.
intro M1.
intro.
intro M2.
intro.
simple destruct N.
intros N1 N2.
intro.
case (hedge_mem_dec (synthesis h) M1 N1).
case (hedge_mem_dec (synthesis h) M2 N2).
intros.
apply SynInc.

*****
H3 : synthesis h M1 N1
H2 : not (synthesis h M2 N2)
H1 : synthesis h (MPair M1 M2) (MPair N1 N2)
N,N1,N2 : Msg
H0 : forall (N : Msg) (_ : synthesis h M2 N), synthesis (reduce h) M2 N
M2 : Msg
H : forall (N : Msg) (_ : synthesis h M1 N), synthesis (reduce h) M1 N
M,M1 : Msg
h : hedge
*****
reduce h (MPair M1 M2) (MPair N1 N2)
+++++
unfold reduce in |- *.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.
intro M1.
intro.
intro M2.
intro.
simple destruct N.
intros N1 N2.
intro.
case (hedge_mem_dec (synthesis h) M1 N1).
case (hedge_mem_dec (synthesis h) M2 N2).
intros.
apply SynInc.
unfold reduce in |- *.

*****
H3 : synthesis h M1 N1
H2 : not (synthesis h M2 N2)
H1 : synthesis h (MPair M1 M2) (MPair N1 N2)
N,N1,N2 : Msg
H0 : forall (N : Msg) (_ : synthesis h M2 N), synthesis (reduce h) M2 N
M2 : Msg
H : forall (N : Msg) (_ : synthesis h M1 N), synthesis (reduce h) M1 N
M,M1 : Msg
h : hedge
*****
and (h (MPair M1 M2) (MPair N1 N2)) (or (not (synthesis h M1 N1)) (not (synthesis h M2 N2)))
+++++
simpl in |- *.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.
intro M1.
intro.
intro M2.
intro.
simple destruct N.
intros N1 N2.
intro.
case (hedge_mem_dec (synthesis h) M1 N1).
case (hedge_mem_dec (synthesis h) M2 N2).
intros.
apply SynInc.
unfold reduce in |- *.
simpl in |- *.

*****
H3 : synthesis h M1 N1
H2 : not (synthesis h M2 N2)
H1 : synthesis h (MPair M1 M2) (MPair N1 N2)
N,N1,N2 : Msg
H0 : forall (N : Msg) (_ : synthesis h M2 N), synthesis (reduce h) M2 N
M2 : Msg
H : forall (N : Msg) (_ : synthesis h M1 N), synthesis (reduce h) M1 N
M,M1 : Msg
h : hedge
*****
and (h (MPair M1 M2) (MPair N1 N2)) (or (not (synthesis h M1 N1)) (not (synthesis h M2 N2)))
+++++
inversion H1.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.
intro M1.
intro.
intro M2.
intro.
simple destruct N.
intros N1 N2.
intro.
case (hedge_mem_dec (synthesis h) M1 N1).
case (hedge_mem_dec (synthesis h) M2 N2).
intros.
apply SynInc.
unfold reduce in |- *.
simpl in |- *.
inversion H1.

*****
H6 : eq N0 (MPair N1 N2)
H5 : eq M0 (MPair M1 M2)
H4 : h (MPair M1 M2) (MPair N1 N2)
M0,N0 : Msg
H3 : synthesis h M1 N1
H2 : not (synthesis h M2 N2)
H1 : synthesis h (MPair M1 M2) (MPair N1 N2)
N,N1,N2 : Msg
H0 : forall (N : Msg) (_ : synthesis h M2 N), synthesis (reduce h) M2 N
M2 : Msg
H : forall (N : Msg) (_ : synthesis h M1 N), synthesis (reduce h) M1 N
M,M1 : Msg
h : hedge
*****
and (h (MPair M1 M2) (MPair N1 N2)) (or (not (synthesis h M1 N1)) (not (synthesis h M2 N2)))
+++++
tauto.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.
intro M1.
intro.
intro M2.
intro.
simple destruct N.
intros N1 N2.
intro.
case (hedge_mem_dec (synthesis h) M1 N1).
case (hedge_mem_dec (synthesis h) M2 N2).
intros.
apply SynInc.
unfold reduce in |- *.
simpl in |- *.
inversion H1.

*****
H8 : eq N3 N2
H6 : eq N0 N1
H5 : eq M3 M2
H4 : eq M0 M1
H9 : synthesis h M2 N2
H7 : synthesis h M1 N1
M0,N0,M3,N3 : Msg
H3 : synthesis h M1 N1
H2 : not (synthesis h M2 N2)
H1 : synthesis h (MPair M1 M2) (MPair N1 N2)
N,N1,N2 : Msg
H0 : forall (N : Msg) (_ : synthesis h M2 N), synthesis (reduce h) M2 N
M2 : Msg
H : forall (N : Msg) (_ : synthesis h M1 N), synthesis (reduce h) M1 N
M,M1 : Msg
h : hedge
*****
and (h (MPair M1 M2) (MPair N1 N2)) (or (not (synthesis h M1 N1)) (not (synthesis h M2 N2)))
+++++
tauto.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.
intro M1.
intro.
intro M2.
intro.
simple destruct N.
intros N1 N2.
intro.
case (hedge_mem_dec (synthesis h) M1 N1).

*****
H1 : synthesis h (MPair M1 M2) (MPair N1 N2)
N,N1,N2 : Msg
H0 : forall (N : Msg) (_ : synthesis h M2 N), synthesis (reduce h) M2 N
M2 : Msg
H : forall (N : Msg) (_ : synthesis h M1 N), synthesis (reduce h) M1 N
M,M1 : Msg
h : hedge
*****
forall _ : not (synthesis h M1 N1), synthesis (reduce h) (MPair M1 M2) (MPair N1 N2)
+++++
intro.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.
intro M1.
intro.
intro M2.
intro.
simple destruct N.
intros N1 N2.
intro.
case (hedge_mem_dec (synthesis h) M1 N1).
intro.

*****
H2 : not (synthesis h M1 N1)
H1 : synthesis h (MPair M1 M2) (MPair N1 N2)
N,N1,N2 : Msg
H0 : forall (N : Msg) (_ : synthesis h M2 N), synthesis (reduce h) M2 N
M2 : Msg
H : forall (N : Msg) (_ : synthesis h M1 N), synthesis (reduce h) M1 N
M,M1 : Msg
h : hedge
*****
synthesis (reduce h) (MPair M1 M2) (MPair N1 N2)
+++++
apply SynInc.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.
intro M1.
intro.
intro M2.
intro.
simple destruct N.
intros N1 N2.
intro.
case (hedge_mem_dec (synthesis h) M1 N1).
intro.
apply SynInc.

*****
H2 : not (synthesis h M1 N1)
H1 : synthesis h (MPair M1 M2) (MPair N1 N2)
N,N1,N2 : Msg
H0 : forall (N : Msg) (_ : synthesis h M2 N), synthesis (reduce h) M2 N
M2 : Msg
H : forall (N : Msg) (_ : synthesis h M1 N), synthesis (reduce h) M1 N
M,M1 : Msg
h : hedge
*****
reduce h (MPair M1 M2) (MPair N1 N2)
+++++
unfold reduce in |- *.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.
intro M1.
intro.
intro M2.
intro.
simple destruct N.
intros N1 N2.
intro.
case (hedge_mem_dec (synthesis h) M1 N1).
intro.
apply SynInc.
unfold reduce in |- *.

*****
H2 : not (synthesis h M1 N1)
H1 : synthesis h (MPair M1 M2) (MPair N1 N2)
N,N1,N2 : Msg
H0 : forall (N : Msg) (_ : synthesis h M2 N), synthesis (reduce h) M2 N
M2 : Msg
H : forall (N : Msg) (_ : synthesis h M1 N), synthesis (reduce h) M1 N
M,M1 : Msg
h : hedge
*****
and (h (MPair M1 M2) (MPair N1 N2)) (or (not (synthesis h M1 N1)) (not (synthesis h M2 N2)))
+++++
simpl in |- *.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.
intro M1.
intro.
intro M2.
intro.
simple destruct N.
intros N1 N2.
intro.
case (hedge_mem_dec (synthesis h) M1 N1).
intro.
apply SynInc.
unfold reduce in |- *.
simpl in |- *.

*****
H2 : not (synthesis h M1 N1)
H1 : synthesis h (MPair M1 M2) (MPair N1 N2)
N,N1,N2 : Msg
H0 : forall (N : Msg) (_ : synthesis h M2 N), synthesis (reduce h) M2 N
M2 : Msg
H : forall (N : Msg) (_ : synthesis h M1 N), synthesis (reduce h) M1 N
M,M1 : Msg
h : hedge
*****
and (h (MPair M1 M2) (MPair N1 N2)) (or (not (synthesis h M1 N1)) (not (synthesis h M2 N2)))
+++++
inversion H1.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.
intro M1.
intro.
intro M2.
intro.
simple destruct N.
intros N1 N2.
intro.
case (hedge_mem_dec (synthesis h) M1 N1).
intro.
apply SynInc.
unfold reduce in |- *.
simpl in |- *.
inversion H1.

*****
H5 : eq N0 (MPair N1 N2)
H4 : eq M0 (MPair M1 M2)
H3 : h (MPair M1 M2) (MPair N1 N2)
M0,N0 : Msg
H2 : not (synthesis h M1 N1)
H1 : synthesis h (MPair M1 M2) (MPair N1 N2)
N,N1,N2 : Msg
H0 : forall (N : Msg) (_ : synthesis h M2 N), synthesis (reduce h) M2 N
M2 : Msg
H : forall (N : Msg) (_ : synthesis h M1 N), synthesis (reduce h) M1 N
M,M1 : Msg
h : hedge
*****
and (h (MPair M1 M2) (MPair N1 N2)) (or (not (synthesis h M1 N1)) (not (synthesis h M2 N2)))
+++++
tauto.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.
intro M1.
intro.
intro M2.
intro.
simple destruct N.
intros N1 N2.
intro.
case (hedge_mem_dec (synthesis h) M1 N1).
intro.
apply SynInc.
unfold reduce in |- *.
simpl in |- *.
inversion H1.

*****
H7 : eq N3 N2
H5 : eq N0 N1
H4 : eq M3 M2
H3 : eq M0 M1
H8 : synthesis h M2 N2
H6 : synthesis h M1 N1
M0,N0,M3,N3 : Msg
H2 : not (synthesis h M1 N1)
H1 : synthesis h (MPair M1 M2) (MPair N1 N2)
N,N1,N2 : Msg
H0 : forall (N : Msg) (_ : synthesis h M2 N), synthesis (reduce h) M2 N
M2 : Msg
H : forall (N : Msg) (_ : synthesis h M1 N), synthesis (reduce h) M1 N
M,M1 : Msg
h : hedge
*****
and (h (MPair M1 M2) (MPair N1 N2)) (or (not (synthesis h M1 N1)) (not (synthesis h M2 N2)))
+++++
tauto.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.
intro M1.
intro.
intro M2.
intro.
simple destruct N.

*****
N : Msg
H0 : forall (N : Msg) (_ : synthesis h M2 N), synthesis (reduce h) M2 N
M2 : Msg
H : forall (N : Msg) (_ : synthesis h M1 N), synthesis (reduce h) M1 N
M,M1 : Msg
h : hedge
*****
forall (o : op) (m : Msg) (_ : synthesis h (MPair M1 M2) (Mop o m)), synthesis (reduce h) (MPair M1 M2) (Mop o m)
+++++
intros.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.
intro M1.
intro.
intro M2.
intro.
simple destruct N.
intros.

*****
H1 : synthesis h (MPair M1 M2) (Mop o m)
m : Msg
o : op
N : Msg
H0 : forall (N : Msg) (_ : synthesis h M2 N), synthesis (reduce h) M2 N
M2 : Msg
H : forall (N : Msg) (_ : synthesis h M1 N), synthesis (reduce h) M1 N
M,M1 : Msg
h : hedge
*****
synthesis (reduce h) (MPair M1 M2) (Mop o m)
+++++
apply SynInc.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.
intro M1.
intro.
intro M2.
intro.
simple destruct N.
intros.
apply SynInc.

*****
H1 : synthesis h (MPair M1 M2) (Mop o m)
m : Msg
o : op
N : Msg
H0 : forall (N : Msg) (_ : synthesis h M2 N), synthesis (reduce h) M2 N
M2 : Msg
H : forall (N : Msg) (_ : synthesis h M1 N), synthesis (reduce h) M1 N
M,M1 : Msg
h : hedge
*****
reduce h (MPair M1 M2) (Mop o m)
+++++
unfold reduce in |- *.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.
intro M1.
intro.
intro M2.
intro.
simple destruct N.
intros.
apply SynInc.
unfold reduce in |- *.

*****
H1 : synthesis h (MPair M1 M2) (Mop o m)
m : Msg
o : op
N : Msg
H0 : forall (N : Msg) (_ : synthesis h M2 N), synthesis (reduce h) M2 N
M2 : Msg
H : forall (N : Msg) (_ : synthesis h M1 N), synthesis (reduce h) M1 N
M,M1 : Msg
h : hedge
*****
and (h (MPair M1 M2) (Mop o m)) True
+++++
simpl in |- *.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.
intro M1.
intro.
intro M2.
intro.
simple destruct N.
intros.
apply SynInc.
unfold reduce in |- *.
simpl in |- *.

*****
H1 : synthesis h (MPair M1 M2) (Mop o m)
m : Msg
o : op
N : Msg
H0 : forall (N : Msg) (_ : synthesis h M2 N), synthesis (reduce h) M2 N
M2 : Msg
H : forall (N : Msg) (_ : synthesis h M1 N), synthesis (reduce h) M1 N
M,M1 : Msg
h : hedge
*****
and (h (MPair M1 M2) (Mop o m)) True
+++++
inversion H1.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.
intro M1.
intro.
intro M2.
intro.
simple destruct N.
intros.
apply SynInc.
unfold reduce in |- *.
simpl in |- *.
inversion H1.

*****
H4 : eq N0 (Mop o m)
H3 : eq M0 (MPair M1 M2)
H2 : h (MPair M1 M2) (Mop o m)
M0,N0 : Msg
H1 : synthesis h (MPair M1 M2) (Mop o m)
m : Msg
o : op
N : Msg
H0 : forall (N : Msg) (_ : synthesis h M2 N), synthesis (reduce h) M2 N
M2 : Msg
H : forall (N : Msg) (_ : synthesis h M1 N), synthesis (reduce h) M1 N
M,M1 : Msg
h : hedge
*****
and (h (MPair M1 M2) (Mop o m)) True
+++++
tauto.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.

*****
M : Msg
h : hedge
*****
forall (o : op) (m : Msg) (_ : forall (N : Msg) (_ : synthesis h m N), synthesis (reduce h) m N) (N : Msg) (_ : synthesis h (Mop o m) N), synthesis (reduce h) (Mop o m) N
+++++
intros oM M'.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.
intros oM M'.

*****
M' : Msg
oM : op
M : Msg
h : hedge
*****
forall (_ : forall (N : Msg) (_ : synthesis h M' N), synthesis (reduce h) M' N) (N : Msg) (_ : synthesis h (Mop oM M') N), synthesis (reduce h) (Mop oM M') N
+++++
intro.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.
intros oM M'.
intro.

*****
H : forall (N : Msg) (_ : synthesis h M' N), synthesis (reduce h) M' N
M' : Msg
oM : op
M : Msg
h : hedge
*****
forall (N : Msg) (_ : synthesis h (Mop oM M') N), synthesis (reduce h) (Mop oM M') N
+++++
simple destruct N.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.
intros oM M'.
intro.
simple destruct N.

*****
N : Msg
H : forall (N : Msg) (_ : synthesis h M' N), synthesis (reduce h) M' N
M' : Msg
oM : op
M : Msg
h : hedge
*****
forall (n : Nam) (_ : synthesis h (Mop oM M') (MNam n)), synthesis (reduce h) (Mop oM M') (MNam n)
+++++
intros.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.
intros oM M'.
intro.
simple destruct N.
intros.

*****
H0 : synthesis h (Mop oM M') (MNam n)
n : Nam
N : Msg
H : forall (N : Msg) (_ : synthesis h M' N), synthesis (reduce h) M' N
M' : Msg
oM : op
M : Msg
h : hedge
*****
synthesis (reduce h) (Mop oM M') (MNam n)
+++++
apply SynInc.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.
intros oM M'.
intro.
simple destruct N.
intros.
apply SynInc.

*****
H0 : synthesis h (Mop oM M') (MNam n)
n : Nam
N : Msg
H : forall (N : Msg) (_ : synthesis h M' N), synthesis (reduce h) M' N
M' : Msg
oM : op
M : Msg
h : hedge
*****
reduce h (Mop oM M') (MNam n)
+++++
unfold reduce in |- *.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.
intros oM M'.
intro.
simple destruct N.
intros.
apply SynInc.
unfold reduce in |- *.

*****
H0 : synthesis h (Mop oM M') (MNam n)
n : Nam
N : Msg
H : forall (N : Msg) (_ : synthesis h M' N), synthesis (reduce h) M' N
M' : Msg
oM : op
M : Msg
h : hedge
*****
and (h (Mop oM M') (MNam n)) True
+++++
simpl in |- *.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.
intros oM M'.
intro.
simple destruct N.
intros.
apply SynInc.
unfold reduce in |- *.
simpl in |- *.

*****
H0 : synthesis h (Mop oM M') (MNam n)
n : Nam
N : Msg
H : forall (N : Msg) (_ : synthesis h M' N), synthesis (reduce h) M' N
M' : Msg
oM : op
M : Msg
h : hedge
*****
and (h (Mop oM M') (MNam n)) True
+++++
inversion H0.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.
intros oM M'.
intro.
simple destruct N.
intros.
apply SynInc.
unfold reduce in |- *.
simpl in |- *.
inversion H0.

*****
H3 : eq N0 (MNam n)
H2 : eq M0 (Mop oM M')
H1 : h (Mop oM M') (MNam n)
M0,N0 : Msg
H0 : synthesis h (Mop oM M') (MNam n)
n : Nam
N : Msg
H : forall (N : Msg) (_ : synthesis h M' N), synthesis (reduce h) M' N
M' : Msg
oM : op
M : Msg
h : hedge
*****
and (h (Mop oM M') (MNam n)) True
+++++
tauto.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.
intros oM M'.
intro.
simple destruct N.

*****
N : Msg
H : forall (N : Msg) (_ : synthesis h M' N), synthesis (reduce h) M' N
M' : Msg
oM : op
M : Msg
h : hedge
*****
forall (m m0 : Msg) (_ : synthesis h (Mop oM M') (MEnc m m0)), synthesis (reduce h) (Mop oM M') (MEnc m m0)
+++++
intros.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.
intros oM M'.
intro.
simple destruct N.
intros.

*****
H0 : synthesis h (Mop oM M') (MEnc m m0)
N,m,m0 : Msg
H : forall (N : Msg) (_ : synthesis h M' N), synthesis (reduce h) M' N
M' : Msg
oM : op
M : Msg
h : hedge
*****
synthesis (reduce h) (Mop oM M') (MEnc m m0)
+++++
apply SynInc.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.
intros oM M'.
intro.
simple destruct N.
intros.
apply SynInc.

*****
H0 : synthesis h (Mop oM M') (MEnc m m0)
N,m,m0 : Msg
H : forall (N : Msg) (_ : synthesis h M' N), synthesis (reduce h) M' N
M' : Msg
oM : op
M : Msg
h : hedge
*****
reduce h (Mop oM M') (MEnc m m0)
+++++
unfold reduce in |- *.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.
intros oM M'.
intro.
simple destruct N.
intros.
apply SynInc.
unfold reduce in |- *.

*****
H0 : synthesis h (Mop oM M') (MEnc m m0)
N,m,m0 : Msg
H : forall (N : Msg) (_ : synthesis h M' N), synthesis (reduce h) M' N
M' : Msg
oM : op
M : Msg
h : hedge
*****
and (h (Mop oM M') (MEnc m m0)) True
+++++
simpl in |- *.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.
intros oM M'.
intro.
simple destruct N.
intros.
apply SynInc.
unfold reduce in |- *.
simpl in |- *.

*****
H0 : synthesis h (Mop oM M') (MEnc m m0)
N,m,m0 : Msg
H : forall (N : Msg) (_ : synthesis h M' N), synthesis (reduce h) M' N
M' : Msg
oM : op
M : Msg
h : hedge
*****
and (h (Mop oM M') (MEnc m m0)) True
+++++
inversion H0.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.
intros oM M'.
intro.
simple destruct N.
intros.
apply SynInc.
unfold reduce in |- *.
simpl in |- *.
inversion H0.

*****
H3 : eq N0 (MEnc m m0)
H2 : eq M0 (Mop oM M')
H1 : h (Mop oM M') (MEnc m m0)
M0,N0 : Msg
H0 : synthesis h (Mop oM M') (MEnc m m0)
N,m,m0 : Msg
H : forall (N : Msg) (_ : synthesis h M' N), synthesis (reduce h) M' N
M' : Msg
oM : op
M : Msg
h : hedge
*****
and (h (Mop oM M') (MEnc m m0)) True
+++++
tauto.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.
intros oM M'.
intro.
simple destruct N.

*****
N : Msg
H : forall (N : Msg) (_ : synthesis h M' N), synthesis (reduce h) M' N
M' : Msg
oM : op
M : Msg
h : hedge
*****
forall (m m0 : Msg) (_ : synthesis h (Mop oM M') (MPair m m0)), synthesis (reduce h) (Mop oM M') (MPair m m0)
+++++
intros.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.
intros oM M'.
intro.
simple destruct N.
intros.

*****
H0 : synthesis h (Mop oM M') (MPair m m0)
N,m,m0 : Msg
H : forall (N : Msg) (_ : synthesis h M' N), synthesis (reduce h) M' N
M' : Msg
oM : op
M : Msg
h : hedge
*****
synthesis (reduce h) (Mop oM M') (MPair m m0)
+++++
apply SynInc.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.
intros oM M'.
intro.
simple destruct N.
intros.
apply SynInc.

*****
H0 : synthesis h (Mop oM M') (MPair m m0)
N,m,m0 : Msg
H : forall (N : Msg) (_ : synthesis h M' N), synthesis (reduce h) M' N
M' : Msg
oM : op
M : Msg
h : hedge
*****
reduce h (Mop oM M') (MPair m m0)
+++++
unfold reduce in |- *.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.
intros oM M'.
intro.
simple destruct N.
intros.
apply SynInc.
unfold reduce in |- *.

*****
H0 : synthesis h (Mop oM M') (MPair m m0)
N,m,m0 : Msg
H : forall (N : Msg) (_ : synthesis h M' N), synthesis (reduce h) M' N
M' : Msg
oM : op
M : Msg
h : hedge
*****
and (h (Mop oM M') (MPair m m0)) True
+++++
simpl in |- *.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.
intros oM M'.
intro.
simple destruct N.
intros.
apply SynInc.
unfold reduce in |- *.
simpl in |- *.

*****
H0 : synthesis h (Mop oM M') (MPair m m0)
N,m,m0 : Msg
H : forall (N : Msg) (_ : synthesis h M' N), synthesis (reduce h) M' N
M' : Msg
oM : op
M : Msg
h : hedge
*****
and (h (Mop oM M') (MPair m m0)) True
+++++
inversion H0.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.
intros oM M'.
intro.
simple destruct N.
intros.
apply SynInc.
unfold reduce in |- *.
simpl in |- *.
inversion H0.

*****
H3 : eq N0 (MPair m m0)
H2 : eq M0 (Mop oM M')
H1 : h (Mop oM M') (MPair m m0)
M0,N0 : Msg
H0 : synthesis h (Mop oM M') (MPair m m0)
N,m,m0 : Msg
H : forall (N : Msg) (_ : synthesis h M' N), synthesis (reduce h) M' N
M' : Msg
oM : op
M : Msg
h : hedge
*****
and (h (Mop oM M') (MPair m m0)) True
+++++
tauto.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.
intros oM M'.
intro.
simple destruct N.

*****
N : Msg
H : forall (N : Msg) (_ : synthesis h M' N), synthesis (reduce h) M' N
M' : Msg
oM : op
M : Msg
h : hedge
*****
forall (o : op) (m : Msg) (_ : synthesis h (Mop oM M') (Mop o m)), synthesis (reduce h) (Mop oM M') (Mop o m)
+++++
intros oN N'.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.
intros oM M'.
intro.
simple destruct N.
intros oN N'.

*****
N' : Msg
oN : op
N : Msg
H : forall (N : Msg) (_ : synthesis h M' N), synthesis (reduce h) M' N
M' : Msg
oM : op
M : Msg
h : hedge
*****
forall _ : synthesis h (Mop oM M') (Mop oN N'), synthesis (reduce h) (Mop oM M') (Mop oN N')
+++++
intro.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.
intros oM M'.
intro.
simple destruct N.
intros oN N'.
intro.

*****
H0 : synthesis h (Mop oM M') (Mop oN N')
N' : Msg
oN : op
N : Msg
H : forall (N : Msg) (_ : synthesis h M' N), synthesis (reduce h) M' N
M' : Msg
oM : op
M : Msg
h : hedge
*****
synthesis (reduce h) (Mop oM M') (Mop oN N')
+++++
case (op_eq_dec oM oN).
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.
intros oM M'.
intro.
simple destruct N.
intros oN N'.
intro.
case (op_eq_dec oM oN).

*****
H0 : synthesis h (Mop oM M') (Mop oN N')
N' : Msg
oN : op
N : Msg
H : forall (N : Msg) (_ : synthesis h M' N), synthesis (reduce h) M' N
M' : Msg
oM : op
M : Msg
h : hedge
*****
forall _ : eq oM oN, synthesis (reduce h) (Mop oM M') (Mop oN N')
+++++
intro.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.
intros oM M'.
intro.
simple destruct N.
intros oN N'.
intro.
case (op_eq_dec oM oN).
intro.

*****
e : eq oM oN
H0 : synthesis h (Mop oM M') (Mop oN N')
N' : Msg
oN : op
N : Msg
H : forall (N : Msg) (_ : synthesis h M' N), synthesis (reduce h) M' N
M' : Msg
oM : op
M : Msg
h : hedge
*****
synthesis (reduce h) (Mop oM M') (Mop oN N')
+++++
rewrite e in H0.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.
intros oM M'.
intro.
simple destruct N.
intros oN N'.
intro.
case (op_eq_dec oM oN).
intro.
rewrite e in H0.

*****
e : eq oM oN
H0 : synthesis h (Mop oN M') (Mop oN N')
N' : Msg
oN : op
N : Msg
H : forall (N : Msg) (_ : synthesis h M' N), synthesis (reduce h) M' N
M' : Msg
oM : op
M : Msg
h : hedge
*****
synthesis (reduce h) (Mop oM M') (Mop oN N')
+++++
rewrite e.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.
intros oM M'.
intro.
simple destruct N.
intros oN N'.
intro.
case (op_eq_dec oM oN).
intro.
rewrite e in H0.
rewrite e.

*****
e : eq oM oN
H0 : synthesis h (Mop oN M') (Mop oN N')
N' : Msg
oN : op
N : Msg
H : forall (N : Msg) (_ : synthesis h M' N), synthesis (reduce h) M' N
M' : Msg
oM : op
M : Msg
h : hedge
*****
synthesis (reduce h) (Mop oN M') (Mop oN N')
+++++
case (hedge_mem_dec (synthesis h) M' N').
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.
intros oM M'.
intro.
simple destruct N.
intros oN N'.
intro.
case (op_eq_dec oM oN).
intro.
rewrite e in H0.
rewrite e.
case (hedge_mem_dec (synthesis h) M' N').

*****
e : eq oM oN
H0 : synthesis h (Mop oN M') (Mop oN N')
N' : Msg
oN : op
N : Msg
H : forall (N : Msg) (_ : synthesis h M' N), synthesis (reduce h) M' N
M' : Msg
oM : op
M : Msg
h : hedge
*****
forall _ : synthesis h M' N', synthesis (reduce h) (Mop oN M') (Mop oN N')
+++++
intro.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.
intros oM M'.
intro.
simple destruct N.
intros oN N'.
intro.
case (op_eq_dec oM oN).
intro.
rewrite e in H0.
rewrite e.
case (hedge_mem_dec (synthesis h) M' N').
intro.

*****
H1 : synthesis h M' N'
e : eq oM oN
H0 : synthesis h (Mop oN M') (Mop oN N')
N' : Msg
oN : op
N : Msg
H : forall (N : Msg) (_ : synthesis h M' N), synthesis (reduce h) M' N
M' : Msg
oM : op
M : Msg
h : hedge
*****
synthesis (reduce h) (Mop oN M') (Mop oN N')
+++++
apply SynOp.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.
intros oM M'.
intro.
simple destruct N.
intros oN N'.
intro.
case (op_eq_dec oM oN).
intro.
rewrite e in H0.
rewrite e.
case (hedge_mem_dec (synthesis h) M' N').
intro.
apply SynOp.

*****
H1 : synthesis h M' N'
e : eq oM oN
H0 : synthesis h (Mop oN M') (Mop oN N')
N' : Msg
oN : op
N : Msg
H : forall (N : Msg) (_ : synthesis h M' N), synthesis (reduce h) M' N
M' : Msg
oM : op
M : Msg
h : hedge
*****
synthesis (reduce h) M' N'
+++++
apply H.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.
intros oM M'.
intro.
simple destruct N.
intros oN N'.
intro.
case (op_eq_dec oM oN).
intro.
rewrite e in H0.
rewrite e.
case (hedge_mem_dec (synthesis h) M' N').
intro.
apply SynOp.
apply H.

*****
H1 : synthesis h M' N'
e : eq oM oN
H0 : synthesis h (Mop oN M') (Mop oN N')
N' : Msg
oN : op
N : Msg
H : forall (N : Msg) (_ : synthesis h M' N), synthesis (reduce h) M' N
M' : Msg
oM : op
M : Msg
h : hedge
*****
synthesis h M' N'
+++++
trivial.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.
intros oM M'.
intro.
simple destruct N.
intros oN N'.
intro.
case (op_eq_dec oM oN).
intro.
rewrite e in H0.
rewrite e.
case (hedge_mem_dec (synthesis h) M' N').

*****
e : eq oM oN
H0 : synthesis h (Mop oN M') (Mop oN N')
N' : Msg
oN : op
N : Msg
H : forall (N : Msg) (_ : synthesis h M' N), synthesis (reduce h) M' N
M' : Msg
oM : op
M : Msg
h : hedge
*****
forall _ : not (synthesis h M' N'), synthesis (reduce h) (Mop oN M') (Mop oN N')
+++++
intros.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.
intros oM M'.
intro.
simple destruct N.
intros oN N'.
intro.
case (op_eq_dec oM oN).
intro.
rewrite e in H0.
rewrite e.
case (hedge_mem_dec (synthesis h) M' N').
intros.

*****
H1 : not (synthesis h M' N')
e : eq oM oN
H0 : synthesis h (Mop oN M') (Mop oN N')
N' : Msg
oN : op
N : Msg
H : forall (N : Msg) (_ : synthesis h M' N), synthesis (reduce h) M' N
M' : Msg
oM : op
M : Msg
h : hedge
*****
synthesis (reduce h) (Mop oN M') (Mop oN N')
+++++
apply SynInc.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.
intros oM M'.
intro.
simple destruct N.
intros oN N'.
intro.
case (op_eq_dec oM oN).
intro.
rewrite e in H0.
rewrite e.
case (hedge_mem_dec (synthesis h) M' N').
intros.
apply SynInc.

*****
H1 : not (synthesis h M' N')
e : eq oM oN
H0 : synthesis h (Mop oN M') (Mop oN N')
N' : Msg
oN : op
N : Msg
H : forall (N : Msg) (_ : synthesis h M' N), synthesis (reduce h) M' N
M' : Msg
oM : op
M : Msg
h : hedge
*****
reduce h (Mop oN M') (Mop oN N')
+++++
unfold reduce in |- *.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.
intros oM M'.
intro.
simple destruct N.
intros oN N'.
intro.
case (op_eq_dec oM oN).
intro.
rewrite e in H0.
rewrite e.
case (hedge_mem_dec (synthesis h) M' N').
intros.
apply SynInc.
unfold reduce in |- *.

*****
H1 : not (synthesis h M' N')
e : eq oM oN
H0 : synthesis h (Mop oN M') (Mop oN N')
N' : Msg
oN : op
N : Msg
H : forall (N : Msg) (_ : synthesis h M' N), synthesis (reduce h) M' N
M' : Msg
oM : op
M : Msg
h : hedge
*****
and (h (Mop oN M') (Mop oN N')) (or (not (eq oN oN)) (not (synthesis h M' N')))
+++++
simpl in |- *.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.
intros oM M'.
intro.
simple destruct N.
intros oN N'.
intro.
case (op_eq_dec oM oN).
intro.
rewrite e in H0.
rewrite e.
case (hedge_mem_dec (synthesis h) M' N').
intros.
apply SynInc.
unfold reduce in |- *.
simpl in |- *.

*****
H1 : not (synthesis h M' N')
e : eq oM oN
H0 : synthesis h (Mop oN M') (Mop oN N')
N' : Msg
oN : op
N : Msg
H : forall (N : Msg) (_ : synthesis h M' N), synthesis (reduce h) M' N
M' : Msg
oM : op
M : Msg
h : hedge
*****
and (h (Mop oN M') (Mop oN N')) (or (not (eq oN oN)) (not (synthesis h M' N')))
+++++
inversion H0.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.
intros oM M'.
intro.
simple destruct N.
intros oN N'.
intro.
case (op_eq_dec oM oN).
intro.
rewrite e in H0.
rewrite e.
case (hedge_mem_dec (synthesis h) M' N').
intros.
apply SynInc.
unfold reduce in |- *.
simpl in |- *.
inversion H0.

*****
H4 : eq N0 (Mop oN N')
H3 : eq M0 (Mop oN M')
H2 : h (Mop oN M') (Mop oN N')
M0,N0 : Msg
H1 : not (synthesis h M' N')
e : eq oM oN
H0 : synthesis h (Mop oN M') (Mop oN N')
N' : Msg
oN : op
N : Msg
H : forall (N : Msg) (_ : synthesis h M' N), synthesis (reduce h) M' N
M' : Msg
oM : op
M : Msg
h : hedge
*****
and (h (Mop oN M') (Mop oN N')) (or (not (eq oN oN)) (not (synthesis h M' N')))
+++++
tauto.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.
intros oM M'.
intro.
simple destruct N.
intros oN N'.
intro.
case (op_eq_dec oM oN).
intro.
rewrite e in H0.
rewrite e.
case (hedge_mem_dec (synthesis h) M' N').
intros.
apply SynInc.
unfold reduce in |- *.
simpl in |- *.
inversion H0.

*****
H5 : eq N0 N'
H4 : eq M0 M'
H2 : eq o oN
H3 : synthesis h M' N'
M0,N0 : Msg
o : op
H1 : not (synthesis h M' N')
e : eq oM oN
H0 : synthesis h (Mop oN M') (Mop oN N')
N' : Msg
oN : op
N : Msg
H : forall (N : Msg) (_ : synthesis h M' N), synthesis (reduce h) M' N
M' : Msg
oM : op
M : Msg
h : hedge
*****
and (h (Mop oN M') (Mop oN N')) (or (not (eq oN oN)) (not (synthesis h M' N')))
+++++
tauto.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.
intros oM M'.
intro.
simple destruct N.
intros oN N'.
intro.
case (op_eq_dec oM oN).

*****
H0 : synthesis h (Mop oM M') (Mop oN N')
N' : Msg
oN : op
N : Msg
H : forall (N : Msg) (_ : synthesis h M' N), synthesis (reduce h) M' N
M' : Msg
oM : op
M : Msg
h : hedge
*****
forall _ : not (eq oM oN), synthesis (reduce h) (Mop oM M') (Mop oN N')
+++++
intros.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.
intros oM M'.
intro.
simple destruct N.
intros oN N'.
intro.
case (op_eq_dec oM oN).
intros.

*****
n : not (eq oM oN)
H0 : synthesis h (Mop oM M') (Mop oN N')
N' : Msg
oN : op
N : Msg
H : forall (N : Msg) (_ : synthesis h M' N), synthesis (reduce h) M' N
M' : Msg
oM : op
M : Msg
h : hedge
*****
synthesis (reduce h) (Mop oM M') (Mop oN N')
+++++
apply SynInc.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.
intros oM M'.
intro.
simple destruct N.
intros oN N'.
intro.
case (op_eq_dec oM oN).
intros.
apply SynInc.

*****
n : not (eq oM oN)
H0 : synthesis h (Mop oM M') (Mop oN N')
N' : Msg
oN : op
N : Msg
H : forall (N : Msg) (_ : synthesis h M' N), synthesis (reduce h) M' N
M' : Msg
oM : op
M : Msg
h : hedge
*****
reduce h (Mop oM M') (Mop oN N')
+++++
unfold reduce in |- *.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.
intros oM M'.
intro.
simple destruct N.
intros oN N'.
intro.
case (op_eq_dec oM oN).
intros.
apply SynInc.
unfold reduce in |- *.

*****
n : not (eq oM oN)
H0 : synthesis h (Mop oM M') (Mop oN N')
N' : Msg
oN : op
N : Msg
H : forall (N : Msg) (_ : synthesis h M' N), synthesis (reduce h) M' N
M' : Msg
oM : op
M : Msg
h : hedge
*****
and (h (Mop oM M') (Mop oN N')) (or (not (eq oM oN)) (not (synthesis h M' N')))
+++++
inversion H0.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.
intros oM M'.
intro.
simple destruct N.
intros oN N'.
intro.
case (op_eq_dec oM oN).
intros.
apply SynInc.
unfold reduce in |- *.
inversion H0.

*****
H3 : eq N0 (Mop oN N')
H2 : eq M0 (Mop oM M')
H1 : h (Mop oM M') (Mop oN N')
M0,N0 : Msg
n : not (eq oM oN)
H0 : synthesis h (Mop oM M') (Mop oN N')
N' : Msg
oN : op
N : Msg
H : forall (N : Msg) (_ : synthesis h M' N), synthesis (reduce h) M' N
M' : Msg
oM : op
M : Msg
h : hedge
*****
and (h (Mop oM M') (Mop oN N')) (or (not (eq oM oN)) (not (synthesis h M' N')))
+++++
tauto.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.
intros oM M'.
intro.
simple destruct N.
intros oN N'.
intro.
case (op_eq_dec oM oN).
intros.
apply SynInc.
unfold reduce in |- *.
inversion H0.

*****
H5 : eq N0 N'
H4 : eq oM oN
H3 : eq M0 M'
H1 : eq o oM
H2 : synthesis h M' N'
M0,N0 : Msg
o : op
n : not (eq oM oN)
H0 : synthesis h (Mop oM M') (Mop oN N')
N' : Msg
oN : op
N : Msg
H : forall (N : Msg) (_ : synthesis h M' N), synthesis (reduce h) M' N
M' : Msg
oM : op
M : Msg
h : hedge
*****
and (h (Mop oN M') (Mop oN N')) (or (not (eq oN oN)) (not (synthesis h M' N')))
+++++
tauto.
-----
Lemma h_le_h_red : forall h : hedge, le_h h (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
simple induction M.

*****

*****

+++++
Qed.
-----
Lemma h_equiv_h_red : forall h : hedge, equiv_h h (reduce h).
-----
Lemma h_equiv_h_red : forall h : hedge, equiv_h h (reduce h).

*****

*****
forall h : hedge, equiv_h h (reduce h)
+++++
unfold equiv_h in |- *.
-----
Lemma h_equiv_h_red : forall h : hedge, equiv_h h (reduce h).
unfold equiv_h in |- *.

*****

*****
forall h : hedge, and (le_h h (reduce h)) (le_h (reduce h) h)
+++++
intro.
-----
Lemma h_equiv_h_red : forall h : hedge, equiv_h h (reduce h).
unfold equiv_h in |- *.
intro.

*****
h : hedge
*****
and (le_h h (reduce h)) (le_h (reduce h) h)
+++++
split.
-----
Lemma h_equiv_h_red : forall h : hedge, equiv_h h (reduce h).
unfold equiv_h in |- *.
intro.
split.

*****
h : hedge
*****
le_h h (reduce h)
+++++
apply h_le_h_red.
-----
Lemma h_equiv_h_red : forall h : hedge, equiv_h h (reduce h).
unfold equiv_h in |- *.
intro.
split.

*****
h : hedge
*****
le_h (reduce h) h
+++++
apply inclusion_impl_le_h.
-----
Lemma h_equiv_h_red : forall h : hedge, equiv_h h (reduce h).
unfold equiv_h in |- *.
intro.
split.
apply inclusion_impl_le_h.

*****
h : hedge
*****
inclusion (reduce h) h
+++++
apply red_incl_h.
-----
Lemma h_equiv_h_red : forall h : hedge, equiv_h h (reduce h).
unfold equiv_h in |- *.
intro.
split.

*****

*****

+++++
Qed.
-----
Lemma inclusion_le_h_reduce_inclusion :\n forall g h : hedge,\n inclusion g h -> le_h h g -> inclusion (reduce g) (reduce h).
-----
Lemma inclusion_le_h_reduce_inclusion : forall g h : hedge, inclusion g h -> le_h h g -> inclusion (reduce g) (reduce h).

*****

*****
forall (g h : hedge) (_ : inclusion g h) (_ : le_h h g), inclusion (reduce g) (reduce h)
+++++
unfold le_h in |- *.
-----
Lemma inclusion_le_h_reduce_inclusion : forall g h : hedge, inclusion g h -> le_h h g -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.

*****

*****
forall (g h : hedge) (_ : inclusion g h) (_ : inclusion (synthesis h) (synthesis g)), inclusion (reduce g) (reduce h)
+++++
unfold inclusion in |- *.
-----
Lemma inclusion_le_h_reduce_inclusion : forall g h : hedge, inclusion g h -> le_h h g -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.

*****

*****
forall (g h : hedge) (_ : forall (M N : Msg) (_ : g M N), h M N) (_ : forall (M N : Msg) (_ : synthesis h M N), synthesis g M N) (M N : Msg) (_ : reduce g M N), reduce h M N
+++++
unfold reduce in |- *.
-----
Lemma inclusion_le_h_reduce_inclusion : forall g h : hedge, inclusion g h -> le_h h g -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
unfold reduce in |- *.

*****

*****
forall (g h : hedge) (_ : forall (M N : Msg) (_ : g M N), h M N) (_ : forall (M N : Msg) (_ : synthesis h M N), synthesis g M N) (M N : Msg) (_ : and (g M N) match M with | MNam _ => True | MEnc M' K => match N with | MEnc N' L => or (not (synthesis g M' N')) (not (synthesis g K L)) | _ => True end | MPair M1 M2 => match N with | MPair N1 N2 => or (not (synthesis g M1 N1)) (not (synthesis g M2 N2)) | _ => True end | Mop opM M' => match N with | Mop opN N' => or (not (eq opM opN)) (not (synthesis g M' N')) | _ => True end end), and (h M N) match M with | MNam _ => True | MEnc M' K => match N with | MEnc N' L => or (not (synthesis h M' N')) (not (synthesis h K L)) | _ => True end | MPair M1 M2 => match N with | MPair N1 N2 => or (not (synthesis h M1 N1)) (not (synthesis h M2 N2)) | _ => True end | Mop opM M' => match N with | Mop opN N' => or (not (eq opM opN)) (not (synthesis h M' N')) | _ => True end end
+++++
intros g h H H0.
-----
Lemma inclusion_le_h_reduce_inclusion : forall g h : hedge, inclusion g h -> le_h h g -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
unfold reduce in |- *.
intros g h H H0.

*****
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis g M N
H : forall (M N : Msg) (_ : g M N), h M N
g,h : hedge
*****
forall (M N : Msg) (_ : and (g M N) match M with | MNam _ => True | MEnc M' K => match N with | MEnc N' L => or (not (synthesis g M' N')) (not (synthesis g K L)) | _ => True end | MPair M1 M2 => match N with | MPair N1 N2 => or (not (synthesis g M1 N1)) (not (synthesis g M2 N2)) | _ => True end | Mop opM M' => match N with | Mop opN N' => or (not (eq opM opN)) (not (synthesis g M' N')) | _ => True end end), and (h M N) match M with | MNam _ => True | MEnc M' K => match N with | MEnc N' L => or (not (synthesis h M' N')) (not (synthesis h K L)) | _ => True end | MPair M1 M2 => match N with | MPair N1 N2 => or (not (synthesis h M1 N1)) (not (synthesis h M2 N2)) | _ => True end | Mop opM M' => match N with | Mop opN N' => or (not (eq opM opN)) (not (synthesis h M' N')) | _ => True end end
+++++
intros M N.
-----
Lemma inclusion_le_h_reduce_inclusion : forall g h : hedge, inclusion g h -> le_h h g -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
unfold reduce in |- *.
intros g h H H0.
intros M N.

*****
M,N : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis g M N
H : forall (M N : Msg) (_ : g M N), h M N
g,h : hedge
*****
forall _ : and (g M N) match M with | MNam _ => True | MEnc M' K => match N with | MEnc N' L => or (not (synthesis g M' N')) (not (synthesis g K L)) | _ => True end | MPair M1 M2 => match N with | MPair N1 N2 => or (not (synthesis g M1 N1)) (not (synthesis g M2 N2)) | _ => True end | Mop opM M' => match N with | Mop opN N' => or (not (eq opM opN)) (not (synthesis g M' N')) | _ => True end end, and (h M N) match M with | MNam _ => True | MEnc M' K => match N with | MEnc N' L => or (not (synthesis h M' N')) (not (synthesis h K L)) | _ => True end | MPair M1 M2 => match N with | MPair N1 N2 => or (not (synthesis h M1 N1)) (not (synthesis h M2 N2)) | _ => True end | Mop opM M' => match N with | Mop opN N' => or (not (eq opM opN)) (not (synthesis h M' N')) | _ => True end end
+++++
case M.
-----
Lemma inclusion_le_h_reduce_inclusion : forall g h : hedge, inclusion g h -> le_h h g -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
unfold reduce in |- *.
intros g h H H0.
intros M N.
case M.

*****
M,N : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis g M N
H : forall (M N : Msg) (_ : g M N), h M N
g,h : hedge
*****
forall (n : Nam) (_ : and (g (MNam n) N) True), and (h (MNam n) N) True
+++++
intros.
-----
Lemma inclusion_le_h_reduce_inclusion : forall g h : hedge, inclusion g h -> le_h h g -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
unfold reduce in |- *.
intros g h H H0.
intros M N.
case M.
intros.

*****
H1 : and (g (MNam n) N) True
n : Nam
M,N : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis g M N
H : forall (M N : Msg) (_ : g M N), h M N
g,h : hedge
*****
and (h (MNam n) N) True
+++++
elim H1.
-----
Lemma inclusion_le_h_reduce_inclusion : forall g h : hedge, inclusion g h -> le_h h g -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
unfold reduce in |- *.
intros g h H H0.
intros M N.
case M.
intros.
elim H1.

*****
H1 : and (g (MNam n) N) True
n : Nam
M,N : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis g M N
H : forall (M N : Msg) (_ : g M N), h M N
g,h : hedge
*****
forall (_ : g (MNam n) N) (_ : True), and (h (MNam n) N) True
+++++
auto.
-----
Lemma inclusion_le_h_reduce_inclusion : forall g h : hedge, inclusion g h -> le_h h g -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
unfold reduce in |- *.
intros g h H H0.
intros M N.
case M.

*****
M,N : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis g M N
H : forall (M N : Msg) (_ : g M N), h M N
g,h : hedge
*****
forall (m m0 : Msg) (_ : and (g (MEnc m m0) N) match N with | MEnc N' L => or (not (synthesis g m N')) (not (synthesis g m0 L)) | _ => True end), and (h (MEnc m m0) N) match N with | MEnc N' L => or (not (synthesis h m N')) (not (synthesis h m0 L)) | _ => True end
+++++
case N.
-----
Lemma inclusion_le_h_reduce_inclusion : forall g h : hedge, inclusion g h -> le_h h g -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
unfold reduce in |- *.
intros g h H H0.
intros M N.
case M.
case N.

*****
M,N : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis g M N
H : forall (M N : Msg) (_ : g M N), h M N
g,h : hedge
*****
forall (n : Nam) (m m0 : Msg) (_ : and (g (MEnc m m0) (MNam n)) True), and (h (MEnc m m0) (MNam n)) True
+++++
intros.
-----
Lemma inclusion_le_h_reduce_inclusion : forall g h : hedge, inclusion g h -> le_h h g -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
unfold reduce in |- *.
intros g h H H0.
intros M N.
case M.
case N.
intros.

*****
H1 : and (g (MEnc m m0) (MNam n)) True
m,m0 : Msg
n : Nam
M,N : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis g M N
H : forall (M N : Msg) (_ : g M N), h M N
g,h : hedge
*****
and (h (MEnc m m0) (MNam n)) True
+++++
elim H1.
-----
Lemma inclusion_le_h_reduce_inclusion : forall g h : hedge, inclusion g h -> le_h h g -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
unfold reduce in |- *.
intros g h H H0.
intros M N.
case M.
case N.
intros.
elim H1.

*****
H1 : and (g (MEnc m m0) (MNam n)) True
m,m0 : Msg
n : Nam
M,N : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis g M N
H : forall (M N : Msg) (_ : g M N), h M N
g,h : hedge
*****
forall (_ : g (MEnc m m0) (MNam n)) (_ : True), and (h (MEnc m m0) (MNam n)) True
+++++
auto.
-----
Lemma inclusion_le_h_reduce_inclusion : forall g h : hedge, inclusion g h -> le_h h g -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
unfold reduce in |- *.
intros g h H H0.
intros M N.
case M.
case N.

*****
M,N : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis g M N
H : forall (M N : Msg) (_ : g M N), h M N
g,h : hedge
*****
forall (m m0 m1 m2 : Msg) (_ : and (g (MEnc m1 m2) (MEnc m m0)) (or (not (synthesis g m1 m)) (not (synthesis g m2 m0)))), and (h (MEnc m1 m2) (MEnc m m0)) (or (not (synthesis h m1 m)) (not (synthesis h m2 m0)))
+++++
intros.
-----
Lemma inclusion_le_h_reduce_inclusion : forall g h : hedge, inclusion g h -> le_h h g -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
unfold reduce in |- *.
intros g h H H0.
intros M N.
case M.
case N.
intros.

*****
H1 : and (g (MEnc m1 m2) (MEnc m m0))\n (or (not (synthesis g m1 m)) (not (synthesis g m2 m0)))
M,N,m,m0,m1,m2 : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis g M N
H : forall (M N : Msg) (_ : g M N), h M N
g,h : hedge
*****
and (h (MEnc m1 m2) (MEnc m m0)) (or (not (synthesis h m1 m)) (not (synthesis h m2 m0)))
+++++
elim H1.
-----
Lemma inclusion_le_h_reduce_inclusion : forall g h : hedge, inclusion g h -> le_h h g -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
unfold reduce in |- *.
intros g h H H0.
intros M N.
case M.
case N.
intros.
elim H1.

*****
H1 : and (g (MEnc m1 m2) (MEnc m m0))\n (or (not (synthesis g m1 m)) (not (synthesis g m2 m0)))
M,N,m,m0,m1,m2 : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis g M N
H : forall (M N : Msg) (_ : g M N), h M N
g,h : hedge
*****
forall (_ : g (MEnc m1 m2) (MEnc m m0)) (_ : or (not (synthesis g m1 m)) (not (synthesis g m2 m0))), and (h (MEnc m1 m2) (MEnc m m0)) (or (not (synthesis h m1 m)) (not (synthesis h m2 m0)))
+++++
auto.
-----
Lemma inclusion_le_h_reduce_inclusion : forall g h : hedge, inclusion g h -> le_h h g -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
unfold reduce in |- *.
intros g h H H0.
intros M N.
case M.
case N.
intros.
elim H1.
auto.

*****
H1 : and (g (MEnc m1 m2) (MEnc m m0))\n (or (not (synthesis g m1 m)) (not (synthesis g m2 m0)))
M,N,m,m0,m1,m2 : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis g M N
H : forall (M N : Msg) (_ : g M N), h M N
g,h : hedge
*****
forall (_ : g (MEnc m1 m2) (MEnc m m0)) (_ : or (not (synthesis g m1 m)) (not (synthesis g m2 m0))), and (h (MEnc m1 m2) (MEnc m m0)) (or (not (synthesis h m1 m)) (not (synthesis h m2 m0)))
+++++
intros.
-----
Lemma inclusion_le_h_reduce_inclusion : forall g h : hedge, inclusion g h -> le_h h g -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
unfold reduce in |- *.
intros g h H H0.
intros M N.
case M.
case N.
intros.
elim H1.
auto.
intros.

*****
H3 : or (not (synthesis g m1 m)) (not (synthesis g m2 m0))
H2 : g (MEnc m1 m2) (MEnc m m0)
H1 : and (g (MEnc m1 m2) (MEnc m m0))\n (or (not (synthesis g m1 m)) (not (synthesis g m2 m0)))
M,N,m,m0,m1,m2 : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis g M N
H : forall (M N : Msg) (_ : g M N), h M N
g,h : hedge
*****
and (h (MEnc m1 m2) (MEnc m m0)) (or (not (synthesis h m1 m)) (not (synthesis h m2 m0)))
+++++
split.
-----
Lemma inclusion_le_h_reduce_inclusion : forall g h : hedge, inclusion g h -> le_h h g -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
unfold reduce in |- *.
intros g h H H0.
intros M N.
case M.
case N.
intros.
elim H1.
auto.
intros.
split.

*****
H3 : or (not (synthesis g m1 m)) (not (synthesis g m2 m0))
H2 : g (MEnc m1 m2) (MEnc m m0)
H1 : and (g (MEnc m1 m2) (MEnc m m0))\n (or (not (synthesis g m1 m)) (not (synthesis g m2 m0)))
M,N,m,m0,m1,m2 : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis g M N
H : forall (M N : Msg) (_ : g M N), h M N
g,h : hedge
*****
h (MEnc m1 m2) (MEnc m m0)
+++++
auto.
-----
Lemma inclusion_le_h_reduce_inclusion : forall g h : hedge, inclusion g h -> le_h h g -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
unfold reduce in |- *.
intros g h H H0.
intros M N.
case M.
case N.
intros.
elim H1.
auto.
intros.
split.

*****
H3 : or (not (synthesis g m1 m)) (not (synthesis g m2 m0))
H2 : g (MEnc m1 m2) (MEnc m m0)
H1 : and (g (MEnc m1 m2) (MEnc m m0))\n (or (not (synthesis g m1 m)) (not (synthesis g m2 m0)))
M,N,m,m0,m1,m2 : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis g M N
H : forall (M N : Msg) (_ : g M N), h M N
g,h : hedge
*****
or (not (synthesis h m1 m)) (not (synthesis h m2 m0))
+++++
auto.
-----
Lemma inclusion_le_h_reduce_inclusion : forall g h : hedge, inclusion g h -> le_h h g -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
unfold reduce in |- *.
intros g h H H0.
intros M N.
case M.
case N.
intros.
elim H1.
auto.
intros.
split.
auto.

*****
H3 : or (not (synthesis g m1 m)) (not (synthesis g m2 m0))
H2 : g (MEnc m1 m2) (MEnc m m0)
H1 : and (g (MEnc m1 m2) (MEnc m m0))\n (or (not (synthesis g m1 m)) (not (synthesis g m2 m0)))
M,N,m,m0,m1,m2 : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis g M N
H : forall (M N : Msg) (_ : g M N), h M N
g,h : hedge
*****
or (not (synthesis h m1 m)) (not (synthesis h m2 m0))
+++++
case H3.
-----
Lemma inclusion_le_h_reduce_inclusion : forall g h : hedge, inclusion g h -> le_h h g -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
unfold reduce in |- *.
intros g h H H0.
intros M N.
case M.
case N.
intros.
elim H1.
auto.
intros.
split.
auto.
case H3.

*****
H3 : or (not (synthesis g m1 m)) (not (synthesis g m2 m0))
H2 : g (MEnc m1 m2) (MEnc m m0)
H1 : and (g (MEnc m1 m2) (MEnc m m0))\n (or (not (synthesis g m1 m)) (not (synthesis g m2 m0)))
M,N,m,m0,m1,m2 : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis g M N
H : forall (M N : Msg) (_ : g M N), h M N
g,h : hedge
*****
forall _ : not (synthesis g m1 m), or (not (synthesis h m1 m)) (not (synthesis h m2 m0))
+++++
intro.
-----
Lemma inclusion_le_h_reduce_inclusion : forall g h : hedge, inclusion g h -> le_h h g -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
unfold reduce in |- *.
intros g h H H0.
intros M N.
case M.
case N.
intros.
elim H1.
auto.
intros.
split.
auto.
case H3.
intro.

*****
H4 : not (synthesis g m1 m)
H3 : or (not (synthesis g m1 m)) (not (synthesis g m2 m0))
H2 : g (MEnc m1 m2) (MEnc m m0)
H1 : and (g (MEnc m1 m2) (MEnc m m0))\n (or (not (synthesis g m1 m)) (not (synthesis g m2 m0)))
M,N,m,m0,m1,m2 : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis g M N
H : forall (M N : Msg) (_ : g M N), h M N
g,h : hedge
*****
or (not (synthesis h m1 m)) (not (synthesis h m2 m0))
+++++
left.
-----
Lemma inclusion_le_h_reduce_inclusion : forall g h : hedge, inclusion g h -> le_h h g -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
unfold reduce in |- *.
intros g h H H0.
intros M N.
case M.
case N.
intros.
elim H1.
auto.
intros.
split.
auto.
case H3.
intro.
left.

*****
H4 : not (synthesis g m1 m)
H3 : or (not (synthesis g m1 m)) (not (synthesis g m2 m0))
H2 : g (MEnc m1 m2) (MEnc m m0)
H1 : and (g (MEnc m1 m2) (MEnc m m0))\n (or (not (synthesis g m1 m)) (not (synthesis g m2 m0)))
M,N,m,m0,m1,m2 : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis g M N
H : forall (M N : Msg) (_ : g M N), h M N
g,h : hedge
*****
not (synthesis h m1 m)
+++++
red in |- *.
-----
Lemma inclusion_le_h_reduce_inclusion : forall g h : hedge, inclusion g h -> le_h h g -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
unfold reduce in |- *.
intros g h H H0.
intros M N.
case M.
case N.
intros.
elim H1.
auto.
intros.
split.
auto.
case H3.
intro.
left.
red in |- *.

*****
H4 : not (synthesis g m1 m)
H3 : or (not (synthesis g m1 m)) (not (synthesis g m2 m0))
H2 : g (MEnc m1 m2) (MEnc m m0)
H1 : and (g (MEnc m1 m2) (MEnc m m0))\n (or (not (synthesis g m1 m)) (not (synthesis g m2 m0)))
M,N,m,m0,m1,m2 : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis g M N
H : forall (M N : Msg) (_ : g M N), h M N
g,h : hedge
*****
forall _ : synthesis h m1 m, False
+++++
intro.
-----
Lemma inclusion_le_h_reduce_inclusion : forall g h : hedge, inclusion g h -> le_h h g -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
unfold reduce in |- *.
intros g h H H0.
intros M N.
case M.
case N.
intros.
elim H1.
auto.
intros.
split.
auto.
case H3.
intro.
left.
red in |- *.
intro.

*****
H5 : synthesis h m1 m
H4 : not (synthesis g m1 m)
H3 : or (not (synthesis g m1 m)) (not (synthesis g m2 m0))
H2 : g (MEnc m1 m2) (MEnc m m0)
H1 : and (g (MEnc m1 m2) (MEnc m m0))\n (or (not (synthesis g m1 m)) (not (synthesis g m2 m0)))
M,N,m,m0,m1,m2 : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis g M N
H : forall (M N : Msg) (_ : g M N), h M N
g,h : hedge
*****
False
+++++
apply H4.
-----
Lemma inclusion_le_h_reduce_inclusion : forall g h : hedge, inclusion g h -> le_h h g -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
unfold reduce in |- *.
intros g h H H0.
intros M N.
case M.
case N.
intros.
elim H1.
auto.
intros.
split.
auto.
case H3.
intro.
left.
red in |- *.
intro.
apply H4.

*****
H5 : synthesis h m1 m
H4 : not (synthesis g m1 m)
H3 : or (not (synthesis g m1 m)) (not (synthesis g m2 m0))
H2 : g (MEnc m1 m2) (MEnc m m0)
H1 : and (g (MEnc m1 m2) (MEnc m m0))\n (or (not (synthesis g m1 m)) (not (synthesis g m2 m0)))
M,N,m,m0,m1,m2 : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis g M N
H : forall (M N : Msg) (_ : g M N), h M N
g,h : hedge
*****
synthesis g m1 m
+++++
auto.
-----
Lemma inclusion_le_h_reduce_inclusion : forall g h : hedge, inclusion g h -> le_h h g -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
unfold reduce in |- *.
intros g h H H0.
intros M N.
case M.
case N.
intros.
elim H1.
auto.
intros.
split.
auto.
case H3.

*****
H3 : or (not (synthesis g m1 m)) (not (synthesis g m2 m0))
H2 : g (MEnc m1 m2) (MEnc m m0)
H1 : and (g (MEnc m1 m2) (MEnc m m0))\n (or (not (synthesis g m1 m)) (not (synthesis g m2 m0)))
M,N,m,m0,m1,m2 : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis g M N
H : forall (M N : Msg) (_ : g M N), h M N
g,h : hedge
*****
forall _ : not (synthesis g m2 m0), or (not (synthesis h m1 m)) (not (synthesis h m2 m0))
+++++
intro.
-----
Lemma inclusion_le_h_reduce_inclusion : forall g h : hedge, inclusion g h -> le_h h g -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
unfold reduce in |- *.
intros g h H H0.
intros M N.
case M.
case N.
intros.
elim H1.
auto.
intros.
split.
auto.
case H3.
intro.

*****
H4 : not (synthesis g m2 m0)
H3 : or (not (synthesis g m1 m)) (not (synthesis g m2 m0))
H2 : g (MEnc m1 m2) (MEnc m m0)
H1 : and (g (MEnc m1 m2) (MEnc m m0))\n (or (not (synthesis g m1 m)) (not (synthesis g m2 m0)))
M,N,m,m0,m1,m2 : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis g M N
H : forall (M N : Msg) (_ : g M N), h M N
g,h : hedge
*****
or (not (synthesis h m1 m)) (not (synthesis h m2 m0))
+++++
right.
-----
Lemma inclusion_le_h_reduce_inclusion : forall g h : hedge, inclusion g h -> le_h h g -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
unfold reduce in |- *.
intros g h H H0.
intros M N.
case M.
case N.
intros.
elim H1.
auto.
intros.
split.
auto.
case H3.
intro.
right.

*****
H4 : not (synthesis g m2 m0)
H3 : or (not (synthesis g m1 m)) (not (synthesis g m2 m0))
H2 : g (MEnc m1 m2) (MEnc m m0)
H1 : and (g (MEnc m1 m2) (MEnc m m0))\n (or (not (synthesis g m1 m)) (not (synthesis g m2 m0)))
M,N,m,m0,m1,m2 : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis g M N
H : forall (M N : Msg) (_ : g M N), h M N
g,h : hedge
*****
not (synthesis h m2 m0)
+++++
red in |- *.
-----
Lemma inclusion_le_h_reduce_inclusion : forall g h : hedge, inclusion g h -> le_h h g -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
unfold reduce in |- *.
intros g h H H0.
intros M N.
case M.
case N.
intros.
elim H1.
auto.
intros.
split.
auto.
case H3.
intro.
right.
red in |- *.

*****
H4 : not (synthesis g m2 m0)
H3 : or (not (synthesis g m1 m)) (not (synthesis g m2 m0))
H2 : g (MEnc m1 m2) (MEnc m m0)
H1 : and (g (MEnc m1 m2) (MEnc m m0))\n (or (not (synthesis g m1 m)) (not (synthesis g m2 m0)))
M,N,m,m0,m1,m2 : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis g M N
H : forall (M N : Msg) (_ : g M N), h M N
g,h : hedge
*****
forall _ : synthesis h m2 m0, False
+++++
intro.
-----
Lemma inclusion_le_h_reduce_inclusion : forall g h : hedge, inclusion g h -> le_h h g -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
unfold reduce in |- *.
intros g h H H0.
intros M N.
case M.
case N.
intros.
elim H1.
auto.
intros.
split.
auto.
case H3.
intro.
right.
red in |- *.
intro.

*****
H5 : synthesis h m2 m0
H4 : not (synthesis g m2 m0)
H3 : or (not (synthesis g m1 m)) (not (synthesis g m2 m0))
H2 : g (MEnc m1 m2) (MEnc m m0)
H1 : and (g (MEnc m1 m2) (MEnc m m0))\n (or (not (synthesis g m1 m)) (not (synthesis g m2 m0)))
M,N,m,m0,m1,m2 : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis g M N
H : forall (M N : Msg) (_ : g M N), h M N
g,h : hedge
*****
False
+++++
apply H4.
-----
Lemma inclusion_le_h_reduce_inclusion : forall g h : hedge, inclusion g h -> le_h h g -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
unfold reduce in |- *.
intros g h H H0.
intros M N.
case M.
case N.
intros.
elim H1.
auto.
intros.
split.
auto.
case H3.
intro.
right.
red in |- *.
intro.
apply H4.

*****
H5 : synthesis h m2 m0
H4 : not (synthesis g m2 m0)
H3 : or (not (synthesis g m1 m)) (not (synthesis g m2 m0))
H2 : g (MEnc m1 m2) (MEnc m m0)
H1 : and (g (MEnc m1 m2) (MEnc m m0))\n (or (not (synthesis g m1 m)) (not (synthesis g m2 m0)))
M,N,m,m0,m1,m2 : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis g M N
H : forall (M N : Msg) (_ : g M N), h M N
g,h : hedge
*****
synthesis g m2 m0
+++++
auto.
-----
Lemma inclusion_le_h_reduce_inclusion : forall g h : hedge, inclusion g h -> le_h h g -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
unfold reduce in |- *.
intros g h H H0.
intros M N.
case M.
case N.

*****
M,N : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis g M N
H : forall (M N : Msg) (_ : g M N), h M N
g,h : hedge
*****
forall (m m0 m1 m2 : Msg) (_ : and (g (MEnc m1 m2) (MPair m m0)) True), and (h (MEnc m1 m2) (MPair m m0)) True
+++++
intros.
-----
Lemma inclusion_le_h_reduce_inclusion : forall g h : hedge, inclusion g h -> le_h h g -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
unfold reduce in |- *.
intros g h H H0.
intros M N.
case M.
case N.
intros.

*****
H1 : and (g (MEnc m1 m2) (MPair m m0)) True
M,N,m,m0,m1,m2 : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis g M N
H : forall (M N : Msg) (_ : g M N), h M N
g,h : hedge
*****
and (h (MEnc m1 m2) (MPair m m0)) True
+++++
elim H1.
-----
Lemma inclusion_le_h_reduce_inclusion : forall g h : hedge, inclusion g h -> le_h h g -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
unfold reduce in |- *.
intros g h H H0.
intros M N.
case M.
case N.
intros.
elim H1.

*****
H1 : and (g (MEnc m1 m2) (MPair m m0)) True
M,N,m,m0,m1,m2 : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis g M N
H : forall (M N : Msg) (_ : g M N), h M N
g,h : hedge
*****
forall (_ : g (MEnc m1 m2) (MPair m m0)) (_ : True), and (h (MEnc m1 m2) (MPair m m0)) True
+++++
auto.
-----
Lemma inclusion_le_h_reduce_inclusion : forall g h : hedge, inclusion g h -> le_h h g -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
unfold reduce in |- *.
intros g h H H0.
intros M N.
case M.
case N.

*****
M,N : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis g M N
H : forall (M N : Msg) (_ : g M N), h M N
g,h : hedge
*****
forall (o : op) (m m0 m1 : Msg) (_ : and (g (MEnc m0 m1) (Mop o m)) True), and (h (MEnc m0 m1) (Mop o m)) True
+++++
intros.
-----
Lemma inclusion_le_h_reduce_inclusion : forall g h : hedge, inclusion g h -> le_h h g -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
unfold reduce in |- *.
intros g h H H0.
intros M N.
case M.
case N.
intros.

*****
H1 : and (g (MEnc m0 m1) (Mop o m)) True
m,m0,m1 : Msg
o : op
M,N : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis g M N
H : forall (M N : Msg) (_ : g M N), h M N
g,h : hedge
*****
and (h (MEnc m0 m1) (Mop o m)) True
+++++
elim H1.
-----
Lemma inclusion_le_h_reduce_inclusion : forall g h : hedge, inclusion g h -> le_h h g -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
unfold reduce in |- *.
intros g h H H0.
intros M N.
case M.
case N.
intros.
elim H1.

*****
H1 : and (g (MEnc m0 m1) (Mop o m)) True
m,m0,m1 : Msg
o : op
M,N : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis g M N
H : forall (M N : Msg) (_ : g M N), h M N
g,h : hedge
*****
forall (_ : g (MEnc m0 m1) (Mop o m)) (_ : True), and (h (MEnc m0 m1) (Mop o m)) True
+++++
auto.
-----
Lemma inclusion_le_h_reduce_inclusion : forall g h : hedge, inclusion g h -> le_h h g -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
unfold reduce in |- *.
intros g h H H0.
intros M N.
case M.

*****
M,N : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis g M N
H : forall (M N : Msg) (_ : g M N), h M N
g,h : hedge
*****
forall (m m0 : Msg) (_ : and (g (MPair m m0) N) match N with | MPair N1 N2 => or (not (synthesis g m N1)) (not (synthesis g m0 N2)) | _ => True end), and (h (MPair m m0) N) match N with | MPair N1 N2 => or (not (synthesis h m N1)) (not (synthesis h m0 N2)) | _ => True end
+++++
case N.
-----
Lemma inclusion_le_h_reduce_inclusion : forall g h : hedge, inclusion g h -> le_h h g -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
unfold reduce in |- *.
intros g h H H0.
intros M N.
case M.
case N.

*****
M,N : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis g M N
H : forall (M N : Msg) (_ : g M N), h M N
g,h : hedge
*****
forall (n : Nam) (m m0 : Msg) (_ : and (g (MPair m m0) (MNam n)) True), and (h (MPair m m0) (MNam n)) True
+++++
intros.
-----
Lemma inclusion_le_h_reduce_inclusion : forall g h : hedge, inclusion g h -> le_h h g -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
unfold reduce in |- *.
intros g h H H0.
intros M N.
case M.
case N.
intros.

*****
H1 : and (g (MPair m m0) (MNam n)) True
m,m0 : Msg
n : Nam
M,N : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis g M N
H : forall (M N : Msg) (_ : g M N), h M N
g,h : hedge
*****
and (h (MPair m m0) (MNam n)) True
+++++
elim H1.
-----
Lemma inclusion_le_h_reduce_inclusion : forall g h : hedge, inclusion g h -> le_h h g -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
unfold reduce in |- *.
intros g h H H0.
intros M N.
case M.
case N.
intros.
elim H1.

*****
H1 : and (g (MPair m m0) (MNam n)) True
m,m0 : Msg
n : Nam
M,N : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis g M N
H : forall (M N : Msg) (_ : g M N), h M N
g,h : hedge
*****
forall (_ : g (MPair m m0) (MNam n)) (_ : True), and (h (MPair m m0) (MNam n)) True
+++++
auto.
-----
Lemma inclusion_le_h_reduce_inclusion : forall g h : hedge, inclusion g h -> le_h h g -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
unfold reduce in |- *.
intros g h H H0.
intros M N.
case M.
case N.

*****
M,N : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis g M N
H : forall (M N : Msg) (_ : g M N), h M N
g,h : hedge
*****
forall (m m0 m1 m2 : Msg) (_ : and (g (MPair m1 m2) (MEnc m m0)) True), and (h (MPair m1 m2) (MEnc m m0)) True
+++++
intros.
-----
Lemma inclusion_le_h_reduce_inclusion : forall g h : hedge, inclusion g h -> le_h h g -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
unfold reduce in |- *.
intros g h H H0.
intros M N.
case M.
case N.
intros.

*****
H1 : and (g (MPair m1 m2) (MEnc m m0)) True
M,N,m,m0,m1,m2 : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis g M N
H : forall (M N : Msg) (_ : g M N), h M N
g,h : hedge
*****
and (h (MPair m1 m2) (MEnc m m0)) True
+++++
elim H1.
-----
Lemma inclusion_le_h_reduce_inclusion : forall g h : hedge, inclusion g h -> le_h h g -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
unfold reduce in |- *.
intros g h H H0.
intros M N.
case M.
case N.
intros.
elim H1.

*****
H1 : and (g (MPair m1 m2) (MEnc m m0)) True
M,N,m,m0,m1,m2 : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis g M N
H : forall (M N : Msg) (_ : g M N), h M N
g,h : hedge
*****
forall (_ : g (MPair m1 m2) (MEnc m m0)) (_ : True), and (h (MPair m1 m2) (MEnc m m0)) True
+++++
auto.
-----
Lemma inclusion_le_h_reduce_inclusion : forall g h : hedge, inclusion g h -> le_h h g -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
unfold reduce in |- *.
intros g h H H0.
intros M N.
case M.
case N.

*****
M,N : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis g M N
H : forall (M N : Msg) (_ : g M N), h M N
g,h : hedge
*****
forall (m m0 m1 m2 : Msg) (_ : and (g (MPair m1 m2) (MPair m m0)) (or (not (synthesis g m1 m)) (not (synthesis g m2 m0)))), and (h (MPair m1 m2) (MPair m m0)) (or (not (synthesis h m1 m)) (not (synthesis h m2 m0)))
+++++
intros.
-----
Lemma inclusion_le_h_reduce_inclusion : forall g h : hedge, inclusion g h -> le_h h g -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
unfold reduce in |- *.
intros g h H H0.
intros M N.
case M.
case N.
intros.

*****
H1 : and (g (MPair m1 m2) (MPair m m0))\n (or (not (synthesis g m1 m)) (not (synthesis g m2 m0)))
M,N,m,m0,m1,m2 : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis g M N
H : forall (M N : Msg) (_ : g M N), h M N
g,h : hedge
*****
and (h (MPair m1 m2) (MPair m m0)) (or (not (synthesis h m1 m)) (not (synthesis h m2 m0)))
+++++
elim H1.
-----
Lemma inclusion_le_h_reduce_inclusion : forall g h : hedge, inclusion g h -> le_h h g -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
unfold reduce in |- *.
intros g h H H0.
intros M N.
case M.
case N.
intros.
elim H1.

*****
H1 : and (g (MPair m1 m2) (MPair m m0))\n (or (not (synthesis g m1 m)) (not (synthesis g m2 m0)))
M,N,m,m0,m1,m2 : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis g M N
H : forall (M N : Msg) (_ : g M N), h M N
g,h : hedge
*****
forall (_ : g (MPair m1 m2) (MPair m m0)) (_ : or (not (synthesis g m1 m)) (not (synthesis g m2 m0))), and (h (MPair m1 m2) (MPair m m0)) (or (not (synthesis h m1 m)) (not (synthesis h m2 m0)))
+++++
auto.
-----
Lemma inclusion_le_h_reduce_inclusion : forall g h : hedge, inclusion g h -> le_h h g -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
unfold reduce in |- *.
intros g h H H0.
intros M N.
case M.
case N.
intros.
elim H1.
auto.

*****
H1 : and (g (MPair m1 m2) (MPair m m0))\n (or (not (synthesis g m1 m)) (not (synthesis g m2 m0)))
M,N,m,m0,m1,m2 : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis g M N
H : forall (M N : Msg) (_ : g M N), h M N
g,h : hedge
*****
forall (_ : g (MPair m1 m2) (MPair m m0)) (_ : or (not (synthesis g m1 m)) (not (synthesis g m2 m0))), and (h (MPair m1 m2) (MPair m m0)) (or (not (synthesis h m1 m)) (not (synthesis h m2 m0)))
+++++
split.
-----
Lemma inclusion_le_h_reduce_inclusion : forall g h : hedge, inclusion g h -> le_h h g -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
unfold reduce in |- *.
intros g h H H0.
intros M N.
case M.
case N.
intros.
elim H1.
auto.
split.

*****
H3 : or (not (synthesis g m1 m)) (not (synthesis g m2 m0))
H2 : g (MPair m1 m2) (MPair m m0)
H1 : and (g (MPair m1 m2) (MPair m m0))\n (or (not (synthesis g m1 m)) (not (synthesis g m2 m0)))
M,N,m,m0,m1,m2 : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis g M N
H : forall (M N : Msg) (_ : g M N), h M N
g,h : hedge
*****
h (MPair m1 m2) (MPair m m0)
+++++
auto.
-----
Lemma inclusion_le_h_reduce_inclusion : forall g h : hedge, inclusion g h -> le_h h g -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
unfold reduce in |- *.
intros g h H H0.
intros M N.
case M.
case N.
intros.
elim H1.
auto.
split.

*****
H3 : or (not (synthesis g m1 m)) (not (synthesis g m2 m0))
H2 : g (MPair m1 m2) (MPair m m0)
H1 : and (g (MPair m1 m2) (MPair m m0))\n (or (not (synthesis g m1 m)) (not (synthesis g m2 m0)))
M,N,m,m0,m1,m2 : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis g M N
H : forall (M N : Msg) (_ : g M N), h M N
g,h : hedge
*****
or (not (synthesis h m1 m)) (not (synthesis h m2 m0))
+++++
auto.
-----
Lemma inclusion_le_h_reduce_inclusion : forall g h : hedge, inclusion g h -> le_h h g -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
unfold reduce in |- *.
intros g h H H0.
intros M N.
case M.
case N.
intros.
elim H1.
auto.
split.
auto.

*****
H3 : or (not (synthesis g m1 m)) (not (synthesis g m2 m0))
H2 : g (MPair m1 m2) (MPair m m0)
H1 : and (g (MPair m1 m2) (MPair m m0))\n (or (not (synthesis g m1 m)) (not (synthesis g m2 m0)))
M,N,m,m0,m1,m2 : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis g M N
H : forall (M N : Msg) (_ : g M N), h M N
g,h : hedge
*****
or (not (synthesis h m1 m)) (not (synthesis h m2 m0))
+++++
case H3.
-----
Lemma inclusion_le_h_reduce_inclusion : forall g h : hedge, inclusion g h -> le_h h g -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
unfold reduce in |- *.
intros g h H H0.
intros M N.
case M.
case N.
intros.
elim H1.
auto.
split.
auto.
case H3.

*****
H3 : or (not (synthesis g m1 m)) (not (synthesis g m2 m0))
H2 : g (MPair m1 m2) (MPair m m0)
H1 : and (g (MPair m1 m2) (MPair m m0))\n (or (not (synthesis g m1 m)) (not (synthesis g m2 m0)))
M,N,m,m0,m1,m2 : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis g M N
H : forall (M N : Msg) (_ : g M N), h M N
g,h : hedge
*****
forall _ : not (synthesis g m1 m), or (not (synthesis h m1 m)) (not (synthesis h m2 m0))
+++++
intro.
-----
Lemma inclusion_le_h_reduce_inclusion : forall g h : hedge, inclusion g h -> le_h h g -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
unfold reduce in |- *.
intros g h H H0.
intros M N.
case M.
case N.
intros.
elim H1.
auto.
split.
auto.
case H3.
intro.

*****
H4 : not (synthesis g m1 m)
H3 : or (not (synthesis g m1 m)) (not (synthesis g m2 m0))
H2 : g (MPair m1 m2) (MPair m m0)
H1 : and (g (MPair m1 m2) (MPair m m0))\n (or (not (synthesis g m1 m)) (not (synthesis g m2 m0)))
M,N,m,m0,m1,m2 : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis g M N
H : forall (M N : Msg) (_ : g M N), h M N
g,h : hedge
*****
or (not (synthesis h m1 m)) (not (synthesis h m2 m0))
+++++
left.
-----
Lemma inclusion_le_h_reduce_inclusion : forall g h : hedge, inclusion g h -> le_h h g -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
unfold reduce in |- *.
intros g h H H0.
intros M N.
case M.
case N.
intros.
elim H1.
auto.
split.
auto.
case H3.
intro.
left.

*****
H4 : not (synthesis g m1 m)
H3 : or (not (synthesis g m1 m)) (not (synthesis g m2 m0))
H2 : g (MPair m1 m2) (MPair m m0)
H1 : and (g (MPair m1 m2) (MPair m m0))\n (or (not (synthesis g m1 m)) (not (synthesis g m2 m0)))
M,N,m,m0,m1,m2 : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis g M N
H : forall (M N : Msg) (_ : g M N), h M N
g,h : hedge
*****
not (synthesis h m1 m)
+++++
red in |- *.
-----
Lemma inclusion_le_h_reduce_inclusion : forall g h : hedge, inclusion g h -> le_h h g -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
unfold reduce in |- *.
intros g h H H0.
intros M N.
case M.
case N.
intros.
elim H1.
auto.
split.
auto.
case H3.
intro.
left.
red in |- *.

*****
H4 : not (synthesis g m1 m)
H3 : or (not (synthesis g m1 m)) (not (synthesis g m2 m0))
H2 : g (MPair m1 m2) (MPair m m0)
H1 : and (g (MPair m1 m2) (MPair m m0))\n (or (not (synthesis g m1 m)) (not (synthesis g m2 m0)))
M,N,m,m0,m1,m2 : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis g M N
H : forall (M N : Msg) (_ : g M N), h M N
g,h : hedge
*****
forall _ : synthesis h m1 m, False
+++++
intro.
-----
Lemma inclusion_le_h_reduce_inclusion : forall g h : hedge, inclusion g h -> le_h h g -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
unfold reduce in |- *.
intros g h H H0.
intros M N.
case M.
case N.
intros.
elim H1.
auto.
split.
auto.
case H3.
intro.
left.
red in |- *.
intro.

*****
H5 : synthesis h m1 m
H4 : not (synthesis g m1 m)
H3 : or (not (synthesis g m1 m)) (not (synthesis g m2 m0))
H2 : g (MPair m1 m2) (MPair m m0)
H1 : and (g (MPair m1 m2) (MPair m m0))\n (or (not (synthesis g m1 m)) (not (synthesis g m2 m0)))
M,N,m,m0,m1,m2 : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis g M N
H : forall (M N : Msg) (_ : g M N), h M N
g,h : hedge
*****
False
+++++
apply H4.
-----
Lemma inclusion_le_h_reduce_inclusion : forall g h : hedge, inclusion g h -> le_h h g -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
unfold reduce in |- *.
intros g h H H0.
intros M N.
case M.
case N.
intros.
elim H1.
auto.
split.
auto.
case H3.
intro.
left.
red in |- *.
intro.
apply H4.

*****
H5 : synthesis h m1 m
H4 : not (synthesis g m1 m)
H3 : or (not (synthesis g m1 m)) (not (synthesis g m2 m0))
H2 : g (MPair m1 m2) (MPair m m0)
H1 : and (g (MPair m1 m2) (MPair m m0))\n (or (not (synthesis g m1 m)) (not (synthesis g m2 m0)))
M,N,m,m0,m1,m2 : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis g M N
H : forall (M N : Msg) (_ : g M N), h M N
g,h : hedge
*****
synthesis g m1 m
+++++
auto.
-----
Lemma inclusion_le_h_reduce_inclusion : forall g h : hedge, inclusion g h -> le_h h g -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
unfold reduce in |- *.
intros g h H H0.
intros M N.
case M.
case N.
intros.
elim H1.
auto.
split.
auto.
case H3.

*****
H3 : or (not (synthesis g m1 m)) (not (synthesis g m2 m0))
H2 : g (MPair m1 m2) (MPair m m0)
H1 : and (g (MPair m1 m2) (MPair m m0))\n (or (not (synthesis g m1 m)) (not (synthesis g m2 m0)))
M,N,m,m0,m1,m2 : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis g M N
H : forall (M N : Msg) (_ : g M N), h M N
g,h : hedge
*****
forall _ : not (synthesis g m2 m0), or (not (synthesis h m1 m)) (not (synthesis h m2 m0))
+++++
intro.
-----
Lemma inclusion_le_h_reduce_inclusion : forall g h : hedge, inclusion g h -> le_h h g -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
unfold reduce in |- *.
intros g h H H0.
intros M N.
case M.
case N.
intros.
elim H1.
auto.
split.
auto.
case H3.
intro.

*****
H4 : not (synthesis g m2 m0)
H3 : or (not (synthesis g m1 m)) (not (synthesis g m2 m0))
H2 : g (MPair m1 m2) (MPair m m0)
H1 : and (g (MPair m1 m2) (MPair m m0))\n (or (not (synthesis g m1 m)) (not (synthesis g m2 m0)))
M,N,m,m0,m1,m2 : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis g M N
H : forall (M N : Msg) (_ : g M N), h M N
g,h : hedge
*****
or (not (synthesis h m1 m)) (not (synthesis h m2 m0))
+++++
right.
-----
Lemma inclusion_le_h_reduce_inclusion : forall g h : hedge, inclusion g h -> le_h h g -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
unfold reduce in |- *.
intros g h H H0.
intros M N.
case M.
case N.
intros.
elim H1.
auto.
split.
auto.
case H3.
intro.
right.

*****
H4 : not (synthesis g m2 m0)
H3 : or (not (synthesis g m1 m)) (not (synthesis g m2 m0))
H2 : g (MPair m1 m2) (MPair m m0)
H1 : and (g (MPair m1 m2) (MPair m m0))\n (or (not (synthesis g m1 m)) (not (synthesis g m2 m0)))
M,N,m,m0,m1,m2 : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis g M N
H : forall (M N : Msg) (_ : g M N), h M N
g,h : hedge
*****
not (synthesis h m2 m0)
+++++
red in |- *.
-----
Lemma inclusion_le_h_reduce_inclusion : forall g h : hedge, inclusion g h -> le_h h g -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
unfold reduce in |- *.
intros g h H H0.
intros M N.
case M.
case N.
intros.
elim H1.
auto.
split.
auto.
case H3.
intro.
right.
red in |- *.

*****
H4 : not (synthesis g m2 m0)
H3 : or (not (synthesis g m1 m)) (not (synthesis g m2 m0))
H2 : g (MPair m1 m2) (MPair m m0)
H1 : and (g (MPair m1 m2) (MPair m m0))\n (or (not (synthesis g m1 m)) (not (synthesis g m2 m0)))
M,N,m,m0,m1,m2 : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis g M N
H : forall (M N : Msg) (_ : g M N), h M N
g,h : hedge
*****
forall _ : synthesis h m2 m0, False
+++++
intro.
-----
Lemma inclusion_le_h_reduce_inclusion : forall g h : hedge, inclusion g h -> le_h h g -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
unfold reduce in |- *.
intros g h H H0.
intros M N.
case M.
case N.
intros.
elim H1.
auto.
split.
auto.
case H3.
intro.
right.
red in |- *.
intro.

*****
H5 : synthesis h m2 m0
H4 : not (synthesis g m2 m0)
H3 : or (not (synthesis g m1 m)) (not (synthesis g m2 m0))
H2 : g (MPair m1 m2) (MPair m m0)
H1 : and (g (MPair m1 m2) (MPair m m0))\n (or (not (synthesis g m1 m)) (not (synthesis g m2 m0)))
M,N,m,m0,m1,m2 : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis g M N
H : forall (M N : Msg) (_ : g M N), h M N
g,h : hedge
*****
False
+++++
apply H4.
-----
Lemma inclusion_le_h_reduce_inclusion : forall g h : hedge, inclusion g h -> le_h h g -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
unfold reduce in |- *.
intros g h H H0.
intros M N.
case M.
case N.
intros.
elim H1.
auto.
split.
auto.
case H3.
intro.
right.
red in |- *.
intro.
apply H4.

*****
H5 : synthesis h m2 m0
H4 : not (synthesis g m2 m0)
H3 : or (not (synthesis g m1 m)) (not (synthesis g m2 m0))
H2 : g (MPair m1 m2) (MPair m m0)
H1 : and (g (MPair m1 m2) (MPair m m0))\n (or (not (synthesis g m1 m)) (not (synthesis g m2 m0)))
M,N,m,m0,m1,m2 : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis g M N
H : forall (M N : Msg) (_ : g M N), h M N
g,h : hedge
*****
synthesis g m2 m0
+++++
auto.
-----
Lemma inclusion_le_h_reduce_inclusion : forall g h : hedge, inclusion g h -> le_h h g -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
unfold reduce in |- *.
intros g h H H0.
intros M N.
case M.
case N.

*****
M,N : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis g M N
H : forall (M N : Msg) (_ : g M N), h M N
g,h : hedge
*****
forall (o : op) (m m0 m1 : Msg) (_ : and (g (MPair m0 m1) (Mop o m)) True), and (h (MPair m0 m1) (Mop o m)) True
+++++
intros.
-----
Lemma inclusion_le_h_reduce_inclusion : forall g h : hedge, inclusion g h -> le_h h g -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
unfold reduce in |- *.
intros g h H H0.
intros M N.
case M.
case N.
intros.

*****
H1 : and (g (MPair m0 m1) (Mop o m)) True
m,m0,m1 : Msg
o : op
M,N : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis g M N
H : forall (M N : Msg) (_ : g M N), h M N
g,h : hedge
*****
and (h (MPair m0 m1) (Mop o m)) True
+++++
elim H1.
-----
Lemma inclusion_le_h_reduce_inclusion : forall g h : hedge, inclusion g h -> le_h h g -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
unfold reduce in |- *.
intros g h H H0.
intros M N.
case M.
case N.
intros.
elim H1.

*****
H1 : and (g (MPair m0 m1) (Mop o m)) True
m,m0,m1 : Msg
o : op
M,N : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis g M N
H : forall (M N : Msg) (_ : g M N), h M N
g,h : hedge
*****
forall (_ : g (MPair m0 m1) (Mop o m)) (_ : True), and (h (MPair m0 m1) (Mop o m)) True
+++++
auto.
-----
Lemma inclusion_le_h_reduce_inclusion : forall g h : hedge, inclusion g h -> le_h h g -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
unfold reduce in |- *.
intros g h H H0.
intros M N.
case M.

*****
M,N : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis g M N
H : forall (M N : Msg) (_ : g M N), h M N
g,h : hedge
*****
forall (o : op) (m : Msg) (_ : and (g (Mop o m) N) match N with | Mop opN N' => or (not (eq o opN)) (not (synthesis g m N')) | _ => True end), and (h (Mop o m) N) match N with | Mop opN N' => or (not (eq o opN)) (not (synthesis h m N')) | _ => True end
+++++
case N.
-----
Lemma inclusion_le_h_reduce_inclusion : forall g h : hedge, inclusion g h -> le_h h g -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
unfold reduce in |- *.
intros g h H H0.
intros M N.
case M.
case N.

*****
M,N : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis g M N
H : forall (M N : Msg) (_ : g M N), h M N
g,h : hedge
*****
forall (n : Nam) (o : op) (m : Msg) (_ : and (g (Mop o m) (MNam n)) True), and (h (Mop o m) (MNam n)) True
+++++
intros.
-----
Lemma inclusion_le_h_reduce_inclusion : forall g h : hedge, inclusion g h -> le_h h g -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
unfold reduce in |- *.
intros g h H H0.
intros M N.
case M.
case N.
intros.

*****
H1 : and (g (Mop o m) (MNam n)) True
m : Msg
o : op
n : Nam
M,N : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis g M N
H : forall (M N : Msg) (_ : g M N), h M N
g,h : hedge
*****
and (h (Mop o m) (MNam n)) True
+++++
elim H1.
-----
Lemma inclusion_le_h_reduce_inclusion : forall g h : hedge, inclusion g h -> le_h h g -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
unfold reduce in |- *.
intros g h H H0.
intros M N.
case M.
case N.
intros.
elim H1.

*****
H1 : and (g (Mop o m) (MNam n)) True
m : Msg
o : op
n : Nam
M,N : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis g M N
H : forall (M N : Msg) (_ : g M N), h M N
g,h : hedge
*****
forall (_ : g (Mop o m) (MNam n)) (_ : True), and (h (Mop o m) (MNam n)) True
+++++
auto.
-----
Lemma inclusion_le_h_reduce_inclusion : forall g h : hedge, inclusion g h -> le_h h g -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
unfold reduce in |- *.
intros g h H H0.
intros M N.
case M.
case N.

*****
M,N : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis g M N
H : forall (M N : Msg) (_ : g M N), h M N
g,h : hedge
*****
forall (m m0 : Msg) (o : op) (m1 : Msg) (_ : and (g (Mop o m1) (MEnc m m0)) True), and (h (Mop o m1) (MEnc m m0)) True
+++++
intros.
-----
Lemma inclusion_le_h_reduce_inclusion : forall g h : hedge, inclusion g h -> le_h h g -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
unfold reduce in |- *.
intros g h H H0.
intros M N.
case M.
case N.
intros.

*****
H1 : and (g (Mop o m1) (MEnc m m0)) True
m1 : Msg
o : op
M,N,m,m0 : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis g M N
H : forall (M N : Msg) (_ : g M N), h M N
g,h : hedge
*****
and (h (Mop o m1) (MEnc m m0)) True
+++++
elim H1.
-----
Lemma inclusion_le_h_reduce_inclusion : forall g h : hedge, inclusion g h -> le_h h g -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
unfold reduce in |- *.
intros g h H H0.
intros M N.
case M.
case N.
intros.
elim H1.

*****
H1 : and (g (Mop o m1) (MEnc m m0)) True
m1 : Msg
o : op
M,N,m,m0 : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis g M N
H : forall (M N : Msg) (_ : g M N), h M N
g,h : hedge
*****
forall (_ : g (Mop o m1) (MEnc m m0)) (_ : True), and (h (Mop o m1) (MEnc m m0)) True
+++++
auto.
-----
Lemma inclusion_le_h_reduce_inclusion : forall g h : hedge, inclusion g h -> le_h h g -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
unfold reduce in |- *.
intros g h H H0.
intros M N.
case M.
case N.

*****
M,N : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis g M N
H : forall (M N : Msg) (_ : g M N), h M N
g,h : hedge
*****
forall (m m0 : Msg) (o : op) (m1 : Msg) (_ : and (g (Mop o m1) (MPair m m0)) True), and (h (Mop o m1) (MPair m m0)) True
+++++
intros.
-----
Lemma inclusion_le_h_reduce_inclusion : forall g h : hedge, inclusion g h -> le_h h g -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
unfold reduce in |- *.
intros g h H H0.
intros M N.
case M.
case N.
intros.

*****
H1 : and (g (Mop o m1) (MPair m m0)) True
m1 : Msg
o : op
M,N,m,m0 : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis g M N
H : forall (M N : Msg) (_ : g M N), h M N
g,h : hedge
*****
and (h (Mop o m1) (MPair m m0)) True
+++++
elim H1.
-----
Lemma inclusion_le_h_reduce_inclusion : forall g h : hedge, inclusion g h -> le_h h g -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
unfold reduce in |- *.
intros g h H H0.
intros M N.
case M.
case N.
intros.
elim H1.

*****
H1 : and (g (Mop o m1) (MPair m m0)) True
m1 : Msg
o : op
M,N,m,m0 : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis g M N
H : forall (M N : Msg) (_ : g M N), h M N
g,h : hedge
*****
forall (_ : g (Mop o m1) (MPair m m0)) (_ : True), and (h (Mop o m1) (MPair m m0)) True
+++++
auto.
-----
Lemma inclusion_le_h_reduce_inclusion : forall g h : hedge, inclusion g h -> le_h h g -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
unfold reduce in |- *.
intros g h H H0.
intros M N.
case M.
case N.

*****
M,N : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis g M N
H : forall (M N : Msg) (_ : g M N), h M N
g,h : hedge
*****
forall (o : op) (m : Msg) (o0 : op) (m0 : Msg) (_ : and (g (Mop o0 m0) (Mop o m)) (or (not (eq o0 o)) (not (synthesis g m0 m)))), and (h (Mop o0 m0) (Mop o m)) (or (not (eq o0 o)) (not (synthesis h m0 m)))
+++++
intros.
-----
Lemma inclusion_le_h_reduce_inclusion : forall g h : hedge, inclusion g h -> le_h h g -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
unfold reduce in |- *.
intros g h H H0.
intros M N.
case M.
case N.
intros.

*****
H1 : and (g (Mop o0 m0) (Mop o m))\n (or (not (eq o0 o)) (not (synthesis g m0 m)))
m0 : Msg
o0 : op
m : Msg
o : op
M,N : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis g M N
H : forall (M N : Msg) (_ : g M N), h M N
g,h : hedge
*****
and (h (Mop o0 m0) (Mop o m)) (or (not (eq o0 o)) (not (synthesis h m0 m)))
+++++
elim H1.
-----
Lemma inclusion_le_h_reduce_inclusion : forall g h : hedge, inclusion g h -> le_h h g -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
unfold reduce in |- *.
intros g h H H0.
intros M N.
case M.
case N.
intros.
elim H1.

*****
H1 : and (g (Mop o0 m0) (Mop o m))\n (or (not (eq o0 o)) (not (synthesis g m0 m)))
m0 : Msg
o0 : op
m : Msg
o : op
M,N : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis g M N
H : forall (M N : Msg) (_ : g M N), h M N
g,h : hedge
*****
forall (_ : g (Mop o0 m0) (Mop o m)) (_ : or (not (eq o0 o)) (not (synthesis g m0 m))), and (h (Mop o0 m0) (Mop o m)) (or (not (eq o0 o)) (not (synthesis h m0 m)))
+++++
auto.
-----
Lemma inclusion_le_h_reduce_inclusion : forall g h : hedge, inclusion g h -> le_h h g -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
unfold reduce in |- *.
intros g h H H0.
intros M N.
case M.
case N.
intros.
elim H1.
auto.

*****
H1 : and (g (Mop o0 m0) (Mop o m))\n (or (not (eq o0 o)) (not (synthesis g m0 m)))
m0 : Msg
o0 : op
m : Msg
o : op
M,N : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis g M N
H : forall (M N : Msg) (_ : g M N), h M N
g,h : hedge
*****
forall (_ : g (Mop o0 m0) (Mop o m)) (_ : or (not (eq o0 o)) (not (synthesis g m0 m))), and (h (Mop o0 m0) (Mop o m)) (or (not (eq o0 o)) (not (synthesis h m0 m)))
+++++
split.
-----
Lemma inclusion_le_h_reduce_inclusion : forall g h : hedge, inclusion g h -> le_h h g -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
unfold reduce in |- *.
intros g h H H0.
intros M N.
case M.
case N.
intros.
elim H1.
auto.
split.

*****
H3 : or (not (eq o0 o)) (not (synthesis g m0 m))
H2 : g (Mop o0 m0) (Mop o m)
H1 : and (g (Mop o0 m0) (Mop o m))\n (or (not (eq o0 o)) (not (synthesis g m0 m)))
m0 : Msg
o0 : op
m : Msg
o : op
M,N : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis g M N
H : forall (M N : Msg) (_ : g M N), h M N
g,h : hedge
*****
h (Mop o0 m0) (Mop o m)
+++++
auto.
-----
Lemma inclusion_le_h_reduce_inclusion : forall g h : hedge, inclusion g h -> le_h h g -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
unfold reduce in |- *.
intros g h H H0.
intros M N.
case M.
case N.
intros.
elim H1.
auto.
split.

*****
H3 : or (not (eq o0 o)) (not (synthesis g m0 m))
H2 : g (Mop o0 m0) (Mop o m)
H1 : and (g (Mop o0 m0) (Mop o m))\n (or (not (eq o0 o)) (not (synthesis g m0 m)))
m0 : Msg
o0 : op
m : Msg
o : op
M,N : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis g M N
H : forall (M N : Msg) (_ : g M N), h M N
g,h : hedge
*****
or (not (eq o0 o)) (not (synthesis h m0 m))
+++++
auto.
-----
Lemma inclusion_le_h_reduce_inclusion : forall g h : hedge, inclusion g h -> le_h h g -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
unfold reduce in |- *.
intros g h H H0.
intros M N.
case M.
case N.
intros.
elim H1.
auto.
split.
auto.

*****
H3 : or (not (eq o0 o)) (not (synthesis g m0 m))
H2 : g (Mop o0 m0) (Mop o m)
H1 : and (g (Mop o0 m0) (Mop o m))\n (or (not (eq o0 o)) (not (synthesis g m0 m)))
m0 : Msg
o0 : op
m : Msg
o : op
M,N : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis g M N
H : forall (M N : Msg) (_ : g M N), h M N
g,h : hedge
*****
or (not (eq o0 o)) (not (synthesis h m0 m))
+++++
case H3.
-----
Lemma inclusion_le_h_reduce_inclusion : forall g h : hedge, inclusion g h -> le_h h g -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
unfold reduce in |- *.
intros g h H H0.
intros M N.
case M.
case N.
intros.
elim H1.
auto.
split.
auto.
case H3.

*****
H3 : or (not (eq o0 o)) (not (synthesis g m0 m))
H2 : g (Mop o0 m0) (Mop o m)
H1 : and (g (Mop o0 m0) (Mop o m))\n (or (not (eq o0 o)) (not (synthesis g m0 m)))
m0 : Msg
o0 : op
m : Msg
o : op
M,N : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis g M N
H : forall (M N : Msg) (_ : g M N), h M N
g,h : hedge
*****
forall _ : not (eq o0 o), or (not (eq o0 o)) (not (synthesis h m0 m))
+++++
try tauto.
-----
Lemma inclusion_le_h_reduce_inclusion : forall g h : hedge, inclusion g h -> le_h h g -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
unfold reduce in |- *.
intros g h H H0.
intros M N.
case M.
case N.
intros.
elim H1.
auto.
split.
auto.
case H3.

*****
H3 : or (not (eq o0 o)) (not (synthesis g m0 m))
H2 : g (Mop o0 m0) (Mop o m)
H1 : and (g (Mop o0 m0) (Mop o m))\n (or (not (eq o0 o)) (not (synthesis g m0 m)))
m0 : Msg
o0 : op
m : Msg
o : op
M,N : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis g M N
H : forall (M N : Msg) (_ : g M N), h M N
g,h : hedge
*****
forall _ : not (synthesis g m0 m), or (not (eq o0 o)) (not (synthesis h m0 m))
+++++
try tauto.
-----
Lemma inclusion_le_h_reduce_inclusion : forall g h : hedge, inclusion g h -> le_h h g -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
unfold reduce in |- *.
intros g h H H0.
intros M N.
case M.
case N.
intros.
elim H1.
auto.
split.
auto.
case H3.
try tauto.

*****
H3 : or (not (eq o0 o)) (not (synthesis g m0 m))
H2 : g (Mop o0 m0) (Mop o m)
H1 : and (g (Mop o0 m0) (Mop o m))\n (or (not (eq o0 o)) (not (synthesis g m0 m)))
m0 : Msg
o0 : op
m : Msg
o : op
M,N : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis g M N
H : forall (M N : Msg) (_ : g M N), h M N
g,h : hedge
*****
forall _ : not (synthesis g m0 m), or (not (eq o0 o)) (not (synthesis h m0 m))
+++++
intros.
-----
Lemma inclusion_le_h_reduce_inclusion : forall g h : hedge, inclusion g h -> le_h h g -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
unfold reduce in |- *.
intros g h H H0.
intros M N.
case M.
case N.
intros.
elim H1.
auto.
split.
auto.
case H3.
try tauto.
intros.

*****
H4 : not (synthesis g m0 m)
H3 : or (not (eq o0 o)) (not (synthesis g m0 m))
H2 : g (Mop o0 m0) (Mop o m)
H1 : and (g (Mop o0 m0) (Mop o m))\n (or (not (eq o0 o)) (not (synthesis g m0 m)))
m0 : Msg
o0 : op
m : Msg
o : op
M,N : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis g M N
H : forall (M N : Msg) (_ : g M N), h M N
g,h : hedge
*****
or (not (eq o0 o)) (not (synthesis h m0 m))
+++++
right.
-----
Lemma inclusion_le_h_reduce_inclusion : forall g h : hedge, inclusion g h -> le_h h g -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
unfold reduce in |- *.
intros g h H H0.
intros M N.
case M.
case N.
intros.
elim H1.
auto.
split.
auto.
case H3.
try tauto.
intros.
right.

*****
H4 : not (synthesis g m0 m)
H3 : or (not (eq o0 o)) (not (synthesis g m0 m))
H2 : g (Mop o0 m0) (Mop o m)
H1 : and (g (Mop o0 m0) (Mop o m))\n (or (not (eq o0 o)) (not (synthesis g m0 m)))
m0 : Msg
o0 : op
m : Msg
o : op
M,N : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis g M N
H : forall (M N : Msg) (_ : g M N), h M N
g,h : hedge
*****
not (synthesis h m0 m)
+++++
red in |- *.
-----
Lemma inclusion_le_h_reduce_inclusion : forall g h : hedge, inclusion g h -> le_h h g -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
unfold reduce in |- *.
intros g h H H0.
intros M N.
case M.
case N.
intros.
elim H1.
auto.
split.
auto.
case H3.
try tauto.
intros.
right.
red in |- *.

*****
H4 : not (synthesis g m0 m)
H3 : or (not (eq o0 o)) (not (synthesis g m0 m))
H2 : g (Mop o0 m0) (Mop o m)
H1 : and (g (Mop o0 m0) (Mop o m))\n (or (not (eq o0 o)) (not (synthesis g m0 m)))
m0 : Msg
o0 : op
m : Msg
o : op
M,N : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis g M N
H : forall (M N : Msg) (_ : g M N), h M N
g,h : hedge
*****
forall _ : synthesis h m0 m, False
+++++
intro.
-----
Lemma inclusion_le_h_reduce_inclusion : forall g h : hedge, inclusion g h -> le_h h g -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
unfold reduce in |- *.
intros g h H H0.
intros M N.
case M.
case N.
intros.
elim H1.
auto.
split.
auto.
case H3.
try tauto.
intros.
right.
red in |- *.
intro.

*****
H5 : synthesis h m0 m
H4 : not (synthesis g m0 m)
H3 : or (not (eq o0 o)) (not (synthesis g m0 m))
H2 : g (Mop o0 m0) (Mop o m)
H1 : and (g (Mop o0 m0) (Mop o m))\n (or (not (eq o0 o)) (not (synthesis g m0 m)))
m0 : Msg
o0 : op
m : Msg
o : op
M,N : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis g M N
H : forall (M N : Msg) (_ : g M N), h M N
g,h : hedge
*****
False
+++++
apply H4.
-----
Lemma inclusion_le_h_reduce_inclusion : forall g h : hedge, inclusion g h -> le_h h g -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
unfold reduce in |- *.
intros g h H H0.
intros M N.
case M.
case N.
intros.
elim H1.
auto.
split.
auto.
case H3.
try tauto.
intros.
right.
red in |- *.
intro.
apply H4.

*****
H5 : synthesis h m0 m
H4 : not (synthesis g m0 m)
H3 : or (not (eq o0 o)) (not (synthesis g m0 m))
H2 : g (Mop o0 m0) (Mop o m)
H1 : and (g (Mop o0 m0) (Mop o m))\n (or (not (eq o0 o)) (not (synthesis g m0 m)))
m0 : Msg
o0 : op
m : Msg
o : op
M,N : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis g M N
H : forall (M N : Msg) (_ : g M N), h M N
g,h : hedge
*****
synthesis g m0 m
+++++
auto.
-----
Lemma inclusion_le_h_reduce_inclusion : forall g h : hedge, inclusion g h -> le_h h g -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
unfold reduce in |- *.
intros g h H H0.
intros M N.
case M.

*****

*****

+++++
Qed.
-----
Lemma equal_reduce_equal :\n forall g h : hedge, equal g h -> equal (reduce g) (reduce h).
-----
Lemma equal_reduce_equal : forall g h : hedge, equal g h -> equal (reduce g) (reduce h).

*****

*****
forall (g h : hedge) (_ : equal g h), equal (reduce g) (reduce h)
+++++
unfold equal in |- *.
-----
Lemma equal_reduce_equal : forall g h : hedge, equal g h -> equal (reduce g) (reduce h).
unfold equal in |- *.

*****

*****
forall (g h : hedge) (_ : and (inclusion g h) (inclusion h g)), and (inclusion (reduce g) (reduce h)) (inclusion (reduce h) (reduce g))
+++++
intros.
-----
Lemma equal_reduce_equal : forall g h : hedge, equal g h -> equal (reduce g) (reduce h).
unfold equal in |- *.
intros.

*****
H : and (inclusion g h) (inclusion h g)
g,h : hedge
*****
and (inclusion (reduce g) (reduce h)) (inclusion (reduce h) (reduce g))
+++++
split.
-----
Lemma equal_reduce_equal : forall g h : hedge, equal g h -> equal (reduce g) (reduce h).
unfold equal in |- *.
intros.
split.

*****
H : and (inclusion g h) (inclusion h g)
g,h : hedge
*****
inclusion (reduce g) (reduce h)
+++++
apply inclusion_le_h_reduce_inclusion.
-----
Lemma equal_reduce_equal : forall g h : hedge, equal g h -> equal (reduce g) (reduce h).
unfold equal in |- *.
intros.
split.
apply inclusion_le_h_reduce_inclusion.

*****
H : and (inclusion g h) (inclusion h g)
g,h : hedge
*****
inclusion g h
+++++
tauto.
-----
Lemma equal_reduce_equal : forall g h : hedge, equal g h -> equal (reduce g) (reduce h).
unfold equal in |- *.
intros.
split.
apply inclusion_le_h_reduce_inclusion.

*****
H : and (inclusion g h) (inclusion h g)
g,h : hedge
*****
le_h h g
+++++
apply inclusion_impl_le_h.
-----
Lemma equal_reduce_equal : forall g h : hedge, equal g h -> equal (reduce g) (reduce h).
unfold equal in |- *.
intros.
split.
apply inclusion_le_h_reduce_inclusion.
apply inclusion_impl_le_h.

*****
H : and (inclusion g h) (inclusion h g)
g,h : hedge
*****
inclusion h g
+++++
tauto.
-----
Lemma equal_reduce_equal : forall g h : hedge, equal g h -> equal (reduce g) (reduce h).
unfold equal in |- *.
intros.
split.

*****
H : and (inclusion g h) (inclusion h g)
g,h : hedge
*****
inclusion (reduce h) (reduce g)
+++++
apply inclusion_le_h_reduce_inclusion.
-----
Lemma equal_reduce_equal : forall g h : hedge, equal g h -> equal (reduce g) (reduce h).
unfold equal in |- *.
intros.
split.
apply inclusion_le_h_reduce_inclusion.

*****
H : and (inclusion g h) (inclusion h g)
g,h : hedge
*****
inclusion h g
+++++
try tauto.
-----
Lemma equal_reduce_equal : forall g h : hedge, equal g h -> equal (reduce g) (reduce h).
unfold equal in |- *.
intros.
split.
apply inclusion_le_h_reduce_inclusion.

*****
H : and (inclusion g h) (inclusion h g)
g,h : hedge
*****
le_h g h
+++++
try tauto.
-----
Lemma equal_reduce_equal : forall g h : hedge, equal g h -> equal (reduce g) (reduce h).
unfold equal in |- *.
intros.
split.
apply inclusion_le_h_reduce_inclusion.
try tauto.

*****
H : and (inclusion g h) (inclusion h g)
g,h : hedge
*****
le_h g h
+++++
apply inclusion_impl_le_h.
-----
Lemma equal_reduce_equal : forall g h : hedge, equal g h -> equal (reduce g) (reduce h).
unfold equal in |- *.
intros.
split.
apply inclusion_le_h_reduce_inclusion.
try tauto.
apply inclusion_impl_le_h.

*****
H : and (inclusion g h) (inclusion h g)
g,h : hedge
*****
inclusion g h
+++++
tauto.
-----
Lemma equal_reduce_equal : forall g h : hedge, equal g h -> equal (reduce g) (reduce h).
unfold equal in |- *.
intros.
split.

*****

*****

+++++
Qed.
-----
Lemma inclusion_le_h_impl_inclusion_red :\n forall g h : hedge,\n inclusion (reduce g) h ->\n le_h h (reduce g) -> inclusion (reduce g) (reduce h).
-----
Lemma inclusion_le_h_impl_inclusion_red : forall g h : hedge, inclusion (reduce g) h -> le_h h (reduce g) -> inclusion (reduce g) (reduce h).

*****

*****
forall (g h : hedge) (_ : inclusion (reduce g) h) (_ : le_h h (reduce g)), inclusion (reduce g) (reduce h)
+++++
unfold le_h in |- *.
-----
Lemma inclusion_le_h_impl_inclusion_red : forall g h : hedge, inclusion (reduce g) h -> le_h h (reduce g) -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.

*****

*****
forall (g h : hedge) (_ : inclusion (reduce g) h) (_ : inclusion (synthesis h) (synthesis (reduce g))), inclusion (reduce g) (reduce h)
+++++
unfold inclusion in |- *.
-----
Lemma inclusion_le_h_impl_inclusion_red : forall g h : hedge, inclusion (reduce g) h -> le_h h (reduce g) -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.

*****

*****
forall (g h : hedge) (_ : forall (M N : Msg) (_ : reduce g M N), h M N) (_ : forall (M N : Msg) (_ : synthesis h M N), synthesis (reduce g) M N) (M N : Msg) (_ : reduce g M N), reduce h M N
+++++
intros.
-----
Lemma inclusion_le_h_impl_inclusion_red : forall g h : hedge, inclusion (reduce g) h -> le_h h (reduce g) -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.

*****
H1 : reduce g M N
M,N : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis (reduce g) M N
H : forall (M N : Msg) (_ : reduce g M N), h M N
g,h : hedge
*****
reduce h M N
+++++
generalize H1.
-----
Lemma inclusion_le_h_impl_inclusion_red : forall g h : hedge, inclusion (reduce g) h -> le_h h (reduce g) -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize H1.

*****
H1 : reduce g M N
M,N : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis (reduce g) M N
H : forall (M N : Msg) (_ : reduce g M N), h M N
g,h : hedge
*****
forall _ : reduce g M N, reduce h M N
+++++
generalize (H M N H1).
-----
Lemma inclusion_le_h_impl_inclusion_red : forall g h : hedge, inclusion (reduce g) h -> le_h h (reduce g) -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize H1.
generalize (H M N H1).

*****
H1 : reduce g M N
M,N : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis (reduce g) M N
H : forall (M N : Msg) (_ : reduce g M N), h M N
g,h : hedge
*****
forall (_ : h M N) (_ : reduce g M N), reduce h M N
+++++
unfold reduce in |- *.
-----
Lemma inclusion_le_h_impl_inclusion_red : forall g h : hedge, inclusion (reduce g) h -> le_h h (reduce g) -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize H1.
generalize (H M N H1).
unfold reduce in |- *.

*****
H1 : reduce g M N
M,N : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis (reduce g) M N
H : forall (M N : Msg) (_ : reduce g M N), h M N
g,h : hedge
*****
forall (_ : h M N) (_ : and (g M N) match M with | MNam _ => True | MEnc M' K => match N with | MEnc N' L => or (not (synthesis g M' N')) (not (synthesis g K L)) | _ => True end | MPair M1 M2 => match N with | MPair N1 N2 => or (not (synthesis g M1 N1)) (not (synthesis g M2 N2)) | _ => True end | Mop opM M' => match N with | Mop opN N' => or (not (eq opM opN)) (not (synthesis g M' N')) | _ => True end end), and (h M N) match M with | MNam _ => True | MEnc M' K => match N with | MEnc N' L => or (not (synthesis h M' N')) (not (synthesis h K L)) | _ => True end | MPair M1 M2 => match N with | MPair N1 N2 => or (not (synthesis h M1 N1)) (not (synthesis h M2 N2)) | _ => True end | Mop opM M' => match N with | Mop opN N' => or (not (eq opM opN)) (not (synthesis h M' N')) | _ => True end end
+++++
case M.
-----
Lemma inclusion_le_h_impl_inclusion_red : forall g h : hedge, inclusion (reduce g) h -> le_h h (reduce g) -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize H1.
generalize (H M N H1).
unfold reduce in |- *.
case M.

*****
H1 : reduce g M N
M,N : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis (reduce g) M N
H : forall (M N : Msg) (_ : reduce g M N), h M N
g,h : hedge
*****
forall (n : Nam) (_ : h (MNam n) N) (_ : and (g (MNam n) N) True), and (h (MNam n) N) True
+++++
try tauto.
-----
Lemma inclusion_le_h_impl_inclusion_red : forall g h : hedge, inclusion (reduce g) h -> le_h h (reduce g) -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize H1.
generalize (H M N H1).
unfold reduce in |- *.
case M.

*****
H1 : reduce g M N
M,N : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis (reduce g) M N
H : forall (M N : Msg) (_ : reduce g M N), h M N
g,h : hedge
*****
forall (m m0 : Msg) (_ : h (MEnc m m0) N) (_ : and (g (MEnc m m0) N) match N with | MEnc N' L => or (not (synthesis g m N')) (not (synthesis g m0 L)) | _ => True end), and (h (MEnc m m0) N) match N with | MEnc N' L => or (not (synthesis h m N')) (not (synthesis h m0 L)) | _ => True end
+++++
try tauto.
-----
Lemma inclusion_le_h_impl_inclusion_red : forall g h : hedge, inclusion (reduce g) h -> le_h h (reduce g) -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize H1.
generalize (H M N H1).
unfold reduce in |- *.
case M.
try tauto.

*****
H1 : reduce g M N
M,N : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis (reduce g) M N
H : forall (M N : Msg) (_ : reduce g M N), h M N
g,h : hedge
*****
forall (m m0 : Msg) (_ : h (MEnc m m0) N) (_ : and (g (MEnc m m0) N) match N with | MEnc N' L => or (not (synthesis g m N')) (not (synthesis g m0 L)) | _ => True end), and (h (MEnc m m0) N) match N with | MEnc N' L => or (not (synthesis h m N')) (not (synthesis h m0 L)) | _ => True end
+++++
case N.
-----
Lemma inclusion_le_h_impl_inclusion_red : forall g h : hedge, inclusion (reduce g) h -> le_h h (reduce g) -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize H1.
generalize (H M N H1).
unfold reduce in |- *.
case M.
try tauto.
case N.

*****
H1 : reduce g M N
M,N : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis (reduce g) M N
H : forall (M N : Msg) (_ : reduce g M N), h M N
g,h : hedge
*****
forall (n : Nam) (m m0 : Msg) (_ : h (MEnc m m0) (MNam n)) (_ : and (g (MEnc m m0) (MNam n)) True), and (h (MEnc m m0) (MNam n)) True
+++++
try tauto.
-----
Lemma inclusion_le_h_impl_inclusion_red : forall g h : hedge, inclusion (reduce g) h -> le_h h (reduce g) -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize H1.
generalize (H M N H1).
unfold reduce in |- *.
case M.
try tauto.
case N.

*****
H1 : reduce g M N
M,N : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis (reduce g) M N
H : forall (M N : Msg) (_ : reduce g M N), h M N
g,h : hedge
*****
forall (m m0 m1 m2 : Msg) (_ : h (MEnc m1 m2) (MEnc m m0)) (_ : and (g (MEnc m1 m2) (MEnc m m0)) (or (not (synthesis g m1 m)) (not (synthesis g m2 m0)))), and (h (MEnc m1 m2) (MEnc m m0)) (or (not (synthesis h m1 m)) (not (synthesis h m2 m0)))
+++++
try tauto.
-----
Lemma inclusion_le_h_impl_inclusion_red : forall g h : hedge, inclusion (reduce g) h -> le_h h (reduce g) -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize H1.
generalize (H M N H1).
unfold reduce in |- *.
case M.
try tauto.
case N.
try tauto.

*****
H1 : reduce g M N
M,N : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis (reduce g) M N
H : forall (M N : Msg) (_ : reduce g M N), h M N
g,h : hedge
*****
forall (m m0 m1 m2 : Msg) (_ : h (MEnc m1 m2) (MEnc m m0)) (_ : and (g (MEnc m1 m2) (MEnc m m0)) (or (not (synthesis g m1 m)) (not (synthesis g m2 m0)))), and (h (MEnc m1 m2) (MEnc m m0)) (or (not (synthesis h m1 m)) (not (synthesis h m2 m0)))
+++++
intros.
-----
Lemma inclusion_le_h_impl_inclusion_red : forall g h : hedge, inclusion (reduce g) h -> le_h h (reduce g) -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize H1.
generalize (H M N H1).
unfold reduce in |- *.
case M.
try tauto.
case N.
try tauto.
intros.

*****
H3 : and (g (MEnc m1 m2) (MEnc m m0))\n (or (not (synthesis g m1 m)) (not (synthesis g m2 m0)))
H2 : h (MEnc m1 m2) (MEnc m m0)
m,m0,m1,m2 : Msg
H1 : reduce g M N
M,N : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis (reduce g) M N
H : forall (M N : Msg) (_ : reduce g M N), h M N
g,h : hedge
*****
and (h (MEnc m1 m2) (MEnc m m0)) (or (not (synthesis h m1 m)) (not (synthesis h m2 m0)))
+++++
elim H3.
-----
Lemma inclusion_le_h_impl_inclusion_red : forall g h : hedge, inclusion (reduce g) h -> le_h h (reduce g) -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize H1.
generalize (H M N H1).
unfold reduce in |- *.
case M.
try tauto.
case N.
try tauto.
intros.
elim H3.

*****
H3 : and (g (MEnc m1 m2) (MEnc m m0))\n (or (not (synthesis g m1 m)) (not (synthesis g m2 m0)))
H2 : h (MEnc m1 m2) (MEnc m m0)
m,m0,m1,m2 : Msg
H1 : reduce g M N
M,N : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis (reduce g) M N
H : forall (M N : Msg) (_ : reduce g M N), h M N
g,h : hedge
*****
forall (_ : g (MEnc m1 m2) (MEnc m m0)) (_ : or (not (synthesis g m1 m)) (not (synthesis g m2 m0))), and (h (MEnc m1 m2) (MEnc m m0)) (or (not (synthesis h m1 m)) (not (synthesis h m2 m0)))
+++++
split.
-----
Lemma inclusion_le_h_impl_inclusion_red : forall g h : hedge, inclusion (reduce g) h -> le_h h (reduce g) -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize H1.
generalize (H M N H1).
unfold reduce in |- *.
case M.
try tauto.
case N.
try tauto.
intros.
elim H3.
split.

*****
H5 : or (not (synthesis g m1 m)) (not (synthesis g m2 m0))
H4 : g (MEnc m1 m2) (MEnc m m0)
H3 : and (g (MEnc m1 m2) (MEnc m m0))\n (or (not (synthesis g m1 m)) (not (synthesis g m2 m0)))
H2 : h (MEnc m1 m2) (MEnc m m0)
m,m0,m1,m2 : Msg
H1 : reduce g M N
M,N : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis (reduce g) M N
H : forall (M N : Msg) (_ : reduce g M N), h M N
g,h : hedge
*****
h (MEnc m1 m2) (MEnc m m0)
+++++
trivial.
-----
Lemma inclusion_le_h_impl_inclusion_red : forall g h : hedge, inclusion (reduce g) h -> le_h h (reduce g) -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize H1.
generalize (H M N H1).
unfold reduce in |- *.
case M.
try tauto.
case N.
try tauto.
intros.
elim H3.
split.

*****
H5 : or (not (synthesis g m1 m)) (not (synthesis g m2 m0))
H4 : g (MEnc m1 m2) (MEnc m m0)
H3 : and (g (MEnc m1 m2) (MEnc m m0))\n (or (not (synthesis g m1 m)) (not (synthesis g m2 m0)))
H2 : h (MEnc m1 m2) (MEnc m m0)
m,m0,m1,m2 : Msg
H1 : reduce g M N
M,N : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis (reduce g) M N
H : forall (M N : Msg) (_ : reduce g M N), h M N
g,h : hedge
*****
or (not (synthesis h m1 m)) (not (synthesis h m2 m0))
+++++
trivial.
-----
Lemma inclusion_le_h_impl_inclusion_red : forall g h : hedge, inclusion (reduce g) h -> le_h h (reduce g) -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize H1.
generalize (H M N H1).
unfold reduce in |- *.
case M.
try tauto.
case N.
try tauto.
intros.
elim H3.
split.
trivial.

*****
H5 : or (not (synthesis g m1 m)) (not (synthesis g m2 m0))
H4 : g (MEnc m1 m2) (MEnc m m0)
H3 : and (g (MEnc m1 m2) (MEnc m m0))\n (or (not (synthesis g m1 m)) (not (synthesis g m2 m0)))
H2 : h (MEnc m1 m2) (MEnc m m0)
m,m0,m1,m2 : Msg
H1 : reduce g M N
M,N : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis (reduce g) M N
H : forall (M N : Msg) (_ : reduce g M N), h M N
g,h : hedge
*****
or (not (synthesis h m1 m)) (not (synthesis h m2 m0))
+++++
case H5.
-----
Lemma inclusion_le_h_impl_inclusion_red : forall g h : hedge, inclusion (reduce g) h -> le_h h (reduce g) -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize H1.
generalize (H M N H1).
unfold reduce in |- *.
case M.
try tauto.
case N.
try tauto.
intros.
elim H3.
split.
trivial.
case H5.

*****
H5 : or (not (synthesis g m1 m)) (not (synthesis g m2 m0))
H4 : g (MEnc m1 m2) (MEnc m m0)
H3 : and (g (MEnc m1 m2) (MEnc m m0))\n (or (not (synthesis g m1 m)) (not (synthesis g m2 m0)))
H2 : h (MEnc m1 m2) (MEnc m m0)
m,m0,m1,m2 : Msg
H1 : reduce g M N
M,N : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis (reduce g) M N
H : forall (M N : Msg) (_ : reduce g M N), h M N
g,h : hedge
*****
forall _ : not (synthesis g m1 m), or (not (synthesis h m1 m)) (not (synthesis h m2 m0))
+++++
intro.
-----
Lemma inclusion_le_h_impl_inclusion_red : forall g h : hedge, inclusion (reduce g) h -> le_h h (reduce g) -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize H1.
generalize (H M N H1).
unfold reduce in |- *.
case M.
try tauto.
case N.
try tauto.
intros.
elim H3.
split.
trivial.
case H5.
intro.

*****
H6 : not (synthesis g m1 m)
H5 : or (not (synthesis g m1 m)) (not (synthesis g m2 m0))
H4 : g (MEnc m1 m2) (MEnc m m0)
H3 : and (g (MEnc m1 m2) (MEnc m m0))\n (or (not (synthesis g m1 m)) (not (synthesis g m2 m0)))
H2 : h (MEnc m1 m2) (MEnc m m0)
m,m0,m1,m2 : Msg
H1 : reduce g M N
M,N : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis (reduce g) M N
H : forall (M N : Msg) (_ : reduce g M N), h M N
g,h : hedge
*****
or (not (synthesis h m1 m)) (not (synthesis h m2 m0))
+++++
left.
-----
Lemma inclusion_le_h_impl_inclusion_red : forall g h : hedge, inclusion (reduce g) h -> le_h h (reduce g) -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize H1.
generalize (H M N H1).
unfold reduce in |- *.
case M.
try tauto.
case N.
try tauto.
intros.
elim H3.
split.
trivial.
case H5.
intro.
left.

*****
H6 : not (synthesis g m1 m)
H5 : or (not (synthesis g m1 m)) (not (synthesis g m2 m0))
H4 : g (MEnc m1 m2) (MEnc m m0)
H3 : and (g (MEnc m1 m2) (MEnc m m0))\n (or (not (synthesis g m1 m)) (not (synthesis g m2 m0)))
H2 : h (MEnc m1 m2) (MEnc m m0)
m,m0,m1,m2 : Msg
H1 : reduce g M N
M,N : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis (reduce g) M N
H : forall (M N : Msg) (_ : reduce g M N), h M N
g,h : hedge
*****
not (synthesis h m1 m)
+++++
red in |- *.
-----
Lemma inclusion_le_h_impl_inclusion_red : forall g h : hedge, inclusion (reduce g) h -> le_h h (reduce g) -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize H1.
generalize (H M N H1).
unfold reduce in |- *.
case M.
try tauto.
case N.
try tauto.
intros.
elim H3.
split.
trivial.
case H5.
intro.
left.
red in |- *.

*****
H6 : not (synthesis g m1 m)
H5 : or (not (synthesis g m1 m)) (not (synthesis g m2 m0))
H4 : g (MEnc m1 m2) (MEnc m m0)
H3 : and (g (MEnc m1 m2) (MEnc m m0))\n (or (not (synthesis g m1 m)) (not (synthesis g m2 m0)))
H2 : h (MEnc m1 m2) (MEnc m m0)
m,m0,m1,m2 : Msg
H1 : reduce g M N
M,N : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis (reduce g) M N
H : forall (M N : Msg) (_ : reduce g M N), h M N
g,h : hedge
*****
forall _ : synthesis h m1 m, False
+++++
intro.
-----
Lemma inclusion_le_h_impl_inclusion_red : forall g h : hedge, inclusion (reduce g) h -> le_h h (reduce g) -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize H1.
generalize (H M N H1).
unfold reduce in |- *.
case M.
try tauto.
case N.
try tauto.
intros.
elim H3.
split.
trivial.
case H5.
intro.
left.
red in |- *.
intro.

*****
H7 : synthesis h m1 m
H6 : not (synthesis g m1 m)
H5 : or (not (synthesis g m1 m)) (not (synthesis g m2 m0))
H4 : g (MEnc m1 m2) (MEnc m m0)
H3 : and (g (MEnc m1 m2) (MEnc m m0))\n (or (not (synthesis g m1 m)) (not (synthesis g m2 m0)))
H2 : h (MEnc m1 m2) (MEnc m m0)
m,m0,m1,m2 : Msg
H1 : reduce g M N
M,N : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis (reduce g) M N
H : forall (M N : Msg) (_ : reduce g M N), h M N
g,h : hedge
*****
False
+++++
apply H6.
-----
Lemma inclusion_le_h_impl_inclusion_red : forall g h : hedge, inclusion (reduce g) h -> le_h h (reduce g) -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize H1.
generalize (H M N H1).
unfold reduce in |- *.
case M.
try tauto.
case N.
try tauto.
intros.
elim H3.
split.
trivial.
case H5.
intro.
left.
red in |- *.
intro.
apply H6.

*****
H7 : synthesis h m1 m
H6 : not (synthesis g m1 m)
H5 : or (not (synthesis g m1 m)) (not (synthesis g m2 m0))
H4 : g (MEnc m1 m2) (MEnc m m0)
H3 : and (g (MEnc m1 m2) (MEnc m m0))\n (or (not (synthesis g m1 m)) (not (synthesis g m2 m0)))
H2 : h (MEnc m1 m2) (MEnc m m0)
m,m0,m1,m2 : Msg
H1 : reduce g M N
M,N : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis (reduce g) M N
H : forall (M N : Msg) (_ : reduce g M N), h M N
g,h : hedge
*****
synthesis g m1 m
+++++
generalize (inclusion_impl_le_h (reduce g) g (red_incl_h g)).
-----
Lemma inclusion_le_h_impl_inclusion_red : forall g h : hedge, inclusion (reduce g) h -> le_h h (reduce g) -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize H1.
generalize (H M N H1).
unfold reduce in |- *.
case M.
try tauto.
case N.
try tauto.
intros.
elim H3.
split.
trivial.
case H5.
intro.
left.
red in |- *.
intro.
apply H6.
generalize (inclusion_impl_le_h (reduce g) g (red_incl_h g)).

*****
H7 : synthesis h m1 m
H6 : not (synthesis g m1 m)
H5 : or (not (synthesis g m1 m)) (not (synthesis g m2 m0))
H4 : g (MEnc m1 m2) (MEnc m m0)
H3 : and (g (MEnc m1 m2) (MEnc m m0))\n (or (not (synthesis g m1 m)) (not (synthesis g m2 m0)))
H2 : h (MEnc m1 m2) (MEnc m m0)
m,m0,m1,m2 : Msg
H1 : reduce g M N
M,N : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis (reduce g) M N
H : forall (M N : Msg) (_ : reduce g M N), h M N
g,h : hedge
*****
forall _ : le_h (reduce g) g, synthesis g m1 m
+++++
unfold le_h in |- *.
-----
Lemma inclusion_le_h_impl_inclusion_red : forall g h : hedge, inclusion (reduce g) h -> le_h h (reduce g) -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize H1.
generalize (H M N H1).
unfold reduce in |- *.
case M.
try tauto.
case N.
try tauto.
intros.
elim H3.
split.
trivial.
case H5.
intro.
left.
red in |- *.
intro.
apply H6.
generalize (inclusion_impl_le_h (reduce g) g (red_incl_h g)).
unfold le_h in |- *.

*****
H7 : synthesis h m1 m
H6 : not (synthesis g m1 m)
H5 : or (not (synthesis g m1 m)) (not (synthesis g m2 m0))
H4 : g (MEnc m1 m2) (MEnc m m0)
H3 : and (g (MEnc m1 m2) (MEnc m m0))\n (or (not (synthesis g m1 m)) (not (synthesis g m2 m0)))
H2 : h (MEnc m1 m2) (MEnc m m0)
m,m0,m1,m2 : Msg
H1 : reduce g M N
M,N : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis (reduce g) M N
H : forall (M N : Msg) (_ : reduce g M N), h M N
g,h : hedge
*****
forall _ : inclusion (synthesis (reduce g)) (synthesis g), synthesis g m1 m
+++++
unfold inclusion in |- *.
-----
Lemma inclusion_le_h_impl_inclusion_red : forall g h : hedge, inclusion (reduce g) h -> le_h h (reduce g) -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize H1.
generalize (H M N H1).
unfold reduce in |- *.
case M.
try tauto.
case N.
try tauto.
intros.
elim H3.
split.
trivial.
case H5.
intro.
left.
red in |- *.
intro.
apply H6.
generalize (inclusion_impl_le_h (reduce g) g (red_incl_h g)).
unfold le_h in |- *.
unfold inclusion in |- *.

*****
H7 : synthesis h m1 m
H6 : not (synthesis g m1 m)
H5 : or (not (synthesis g m1 m)) (not (synthesis g m2 m0))
H4 : g (MEnc m1 m2) (MEnc m m0)
H3 : and (g (MEnc m1 m2) (MEnc m m0))\n (or (not (synthesis g m1 m)) (not (synthesis g m2 m0)))
H2 : h (MEnc m1 m2) (MEnc m m0)
m,m0,m1,m2 : Msg
H1 : reduce g M N
M,N : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis (reduce g) M N
H : forall (M N : Msg) (_ : reduce g M N), h M N
g,h : hedge
*****
forall _ : forall (M N : Msg) (_ : synthesis (reduce g) M N), synthesis g M N, synthesis g m1 m
+++++
intros.
-----
Lemma inclusion_le_h_impl_inclusion_red : forall g h : hedge, inclusion (reduce g) h -> le_h h (reduce g) -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize H1.
generalize (H M N H1).
unfold reduce in |- *.
case M.
try tauto.
case N.
try tauto.
intros.
elim H3.
split.
trivial.
case H5.
intro.
left.
red in |- *.
intro.
apply H6.
generalize (inclusion_impl_le_h (reduce g) g (red_incl_h g)).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.

*****
H8 : forall (M N : Msg) (_ : synthesis (reduce g) M N), synthesis g M N
H7 : synthesis h m1 m
H6 : not (synthesis g m1 m)
H5 : or (not (synthesis g m1 m)) (not (synthesis g m2 m0))
H4 : g (MEnc m1 m2) (MEnc m m0)
H3 : and (g (MEnc m1 m2) (MEnc m m0))\n (or (not (synthesis g m1 m)) (not (synthesis g m2 m0)))
H2 : h (MEnc m1 m2) (MEnc m m0)
m,m0,m1,m2 : Msg
H1 : reduce g M N
M,N : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis (reduce g) M N
H : forall (M N : Msg) (_ : reduce g M N), h M N
g,h : hedge
*****
synthesis g m1 m
+++++
apply H8.
-----
Lemma inclusion_le_h_impl_inclusion_red : forall g h : hedge, inclusion (reduce g) h -> le_h h (reduce g) -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize H1.
generalize (H M N H1).
unfold reduce in |- *.
case M.
try tauto.
case N.
try tauto.
intros.
elim H3.
split.
trivial.
case H5.
intro.
left.
red in |- *.
intro.
apply H6.
generalize (inclusion_impl_le_h (reduce g) g (red_incl_h g)).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
apply H8.

*****
H8 : forall (M N : Msg) (_ : synthesis (reduce g) M N), synthesis g M N
H7 : synthesis h m1 m
H6 : not (synthesis g m1 m)
H5 : or (not (synthesis g m1 m)) (not (synthesis g m2 m0))
H4 : g (MEnc m1 m2) (MEnc m m0)
H3 : and (g (MEnc m1 m2) (MEnc m m0))\n (or (not (synthesis g m1 m)) (not (synthesis g m2 m0)))
H2 : h (MEnc m1 m2) (MEnc m m0)
m,m0,m1,m2 : Msg
H1 : reduce g M N
M,N : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis (reduce g) M N
H : forall (M N : Msg) (_ : reduce g M N), h M N
g,h : hedge
*****
synthesis (reduce g) m1 m
+++++
apply H0.
-----
Lemma inclusion_le_h_impl_inclusion_red : forall g h : hedge, inclusion (reduce g) h -> le_h h (reduce g) -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize H1.
generalize (H M N H1).
unfold reduce in |- *.
case M.
try tauto.
case N.
try tauto.
intros.
elim H3.
split.
trivial.
case H5.
intro.
left.
red in |- *.
intro.
apply H6.
generalize (inclusion_impl_le_h (reduce g) g (red_incl_h g)).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
apply H8.
apply H0.

*****
H8 : forall (M N : Msg) (_ : synthesis (reduce g) M N), synthesis g M N
H7 : synthesis h m1 m
H6 : not (synthesis g m1 m)
H5 : or (not (synthesis g m1 m)) (not (synthesis g m2 m0))
H4 : g (MEnc m1 m2) (MEnc m m0)
H3 : and (g (MEnc m1 m2) (MEnc m m0))\n (or (not (synthesis g m1 m)) (not (synthesis g m2 m0)))
H2 : h (MEnc m1 m2) (MEnc m m0)
m,m0,m1,m2 : Msg
H1 : reduce g M N
M,N : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis (reduce g) M N
H : forall (M N : Msg) (_ : reduce g M N), h M N
g,h : hedge
*****
synthesis h m1 m
+++++
trivial.
-----
Lemma inclusion_le_h_impl_inclusion_red : forall g h : hedge, inclusion (reduce g) h -> le_h h (reduce g) -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize H1.
generalize (H M N H1).
unfold reduce in |- *.
case M.
try tauto.
case N.
try tauto.
intros.
elim H3.
split.
trivial.
case H5.

*****
H5 : or (not (synthesis g m1 m)) (not (synthesis g m2 m0))
H4 : g (MEnc m1 m2) (MEnc m m0)
H3 : and (g (MEnc m1 m2) (MEnc m m0))\n (or (not (synthesis g m1 m)) (not (synthesis g m2 m0)))
H2 : h (MEnc m1 m2) (MEnc m m0)
m,m0,m1,m2 : Msg
H1 : reduce g M N
M,N : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis (reduce g) M N
H : forall (M N : Msg) (_ : reduce g M N), h M N
g,h : hedge
*****
forall _ : not (synthesis g m2 m0), or (not (synthesis h m1 m)) (not (synthesis h m2 m0))
+++++
intro.
-----
Lemma inclusion_le_h_impl_inclusion_red : forall g h : hedge, inclusion (reduce g) h -> le_h h (reduce g) -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize H1.
generalize (H M N H1).
unfold reduce in |- *.
case M.
try tauto.
case N.
try tauto.
intros.
elim H3.
split.
trivial.
case H5.
intro.

*****
H6 : not (synthesis g m2 m0)
H5 : or (not (synthesis g m1 m)) (not (synthesis g m2 m0))
H4 : g (MEnc m1 m2) (MEnc m m0)
H3 : and (g (MEnc m1 m2) (MEnc m m0))\n (or (not (synthesis g m1 m)) (not (synthesis g m2 m0)))
H2 : h (MEnc m1 m2) (MEnc m m0)
m,m0,m1,m2 : Msg
H1 : reduce g M N
M,N : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis (reduce g) M N
H : forall (M N : Msg) (_ : reduce g M N), h M N
g,h : hedge
*****
or (not (synthesis h m1 m)) (not (synthesis h m2 m0))
+++++
right.
-----
Lemma inclusion_le_h_impl_inclusion_red : forall g h : hedge, inclusion (reduce g) h -> le_h h (reduce g) -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize H1.
generalize (H M N H1).
unfold reduce in |- *.
case M.
try tauto.
case N.
try tauto.
intros.
elim H3.
split.
trivial.
case H5.
intro.
right.

*****
H6 : not (synthesis g m2 m0)
H5 : or (not (synthesis g m1 m)) (not (synthesis g m2 m0))
H4 : g (MEnc m1 m2) (MEnc m m0)
H3 : and (g (MEnc m1 m2) (MEnc m m0))\n (or (not (synthesis g m1 m)) (not (synthesis g m2 m0)))
H2 : h (MEnc m1 m2) (MEnc m m0)
m,m0,m1,m2 : Msg
H1 : reduce g M N
M,N : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis (reduce g) M N
H : forall (M N : Msg) (_ : reduce g M N), h M N
g,h : hedge
*****
not (synthesis h m2 m0)
+++++
red in |- *.
-----
Lemma inclusion_le_h_impl_inclusion_red : forall g h : hedge, inclusion (reduce g) h -> le_h h (reduce g) -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize H1.
generalize (H M N H1).
unfold reduce in |- *.
case M.
try tauto.
case N.
try tauto.
intros.
elim H3.
split.
trivial.
case H5.
intro.
right.
red in |- *.

*****
H6 : not (synthesis g m2 m0)
H5 : or (not (synthesis g m1 m)) (not (synthesis g m2 m0))
H4 : g (MEnc m1 m2) (MEnc m m0)
H3 : and (g (MEnc m1 m2) (MEnc m m0))\n (or (not (synthesis g m1 m)) (not (synthesis g m2 m0)))
H2 : h (MEnc m1 m2) (MEnc m m0)
m,m0,m1,m2 : Msg
H1 : reduce g M N
M,N : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis (reduce g) M N
H : forall (M N : Msg) (_ : reduce g M N), h M N
g,h : hedge
*****
forall _ : synthesis h m2 m0, False
+++++
intro.
-----
Lemma inclusion_le_h_impl_inclusion_red : forall g h : hedge, inclusion (reduce g) h -> le_h h (reduce g) -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize H1.
generalize (H M N H1).
unfold reduce in |- *.
case M.
try tauto.
case N.
try tauto.
intros.
elim H3.
split.
trivial.
case H5.
intro.
right.
red in |- *.
intro.

*****
H7 : synthesis h m2 m0
H6 : not (synthesis g m2 m0)
H5 : or (not (synthesis g m1 m)) (not (synthesis g m2 m0))
H4 : g (MEnc m1 m2) (MEnc m m0)
H3 : and (g (MEnc m1 m2) (MEnc m m0))\n (or (not (synthesis g m1 m)) (not (synthesis g m2 m0)))
H2 : h (MEnc m1 m2) (MEnc m m0)
m,m0,m1,m2 : Msg
H1 : reduce g M N
M,N : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis (reduce g) M N
H : forall (M N : Msg) (_ : reduce g M N), h M N
g,h : hedge
*****
False
+++++
apply H6.
-----
Lemma inclusion_le_h_impl_inclusion_red : forall g h : hedge, inclusion (reduce g) h -> le_h h (reduce g) -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize H1.
generalize (H M N H1).
unfold reduce in |- *.
case M.
try tauto.
case N.
try tauto.
intros.
elim H3.
split.
trivial.
case H5.
intro.
right.
red in |- *.
intro.
apply H6.

*****
H7 : synthesis h m2 m0
H6 : not (synthesis g m2 m0)
H5 : or (not (synthesis g m1 m)) (not (synthesis g m2 m0))
H4 : g (MEnc m1 m2) (MEnc m m0)
H3 : and (g (MEnc m1 m2) (MEnc m m0))\n (or (not (synthesis g m1 m)) (not (synthesis g m2 m0)))
H2 : h (MEnc m1 m2) (MEnc m m0)
m,m0,m1,m2 : Msg
H1 : reduce g M N
M,N : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis (reduce g) M N
H : forall (M N : Msg) (_ : reduce g M N), h M N
g,h : hedge
*****
synthesis g m2 m0
+++++
generalize (inclusion_impl_le_h (reduce g) g (red_incl_h g)).
-----
Lemma inclusion_le_h_impl_inclusion_red : forall g h : hedge, inclusion (reduce g) h -> le_h h (reduce g) -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize H1.
generalize (H M N H1).
unfold reduce in |- *.
case M.
try tauto.
case N.
try tauto.
intros.
elim H3.
split.
trivial.
case H5.
intro.
right.
red in |- *.
intro.
apply H6.
generalize (inclusion_impl_le_h (reduce g) g (red_incl_h g)).

*****
H7 : synthesis h m2 m0
H6 : not (synthesis g m2 m0)
H5 : or (not (synthesis g m1 m)) (not (synthesis g m2 m0))
H4 : g (MEnc m1 m2) (MEnc m m0)
H3 : and (g (MEnc m1 m2) (MEnc m m0))\n (or (not (synthesis g m1 m)) (not (synthesis g m2 m0)))
H2 : h (MEnc m1 m2) (MEnc m m0)
m,m0,m1,m2 : Msg
H1 : reduce g M N
M,N : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis (reduce g) M N
H : forall (M N : Msg) (_ : reduce g M N), h M N
g,h : hedge
*****
forall _ : le_h (reduce g) g, synthesis g m2 m0
+++++
unfold le_h in |- *.
-----
Lemma inclusion_le_h_impl_inclusion_red : forall g h : hedge, inclusion (reduce g) h -> le_h h (reduce g) -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize H1.
generalize (H M N H1).
unfold reduce in |- *.
case M.
try tauto.
case N.
try tauto.
intros.
elim H3.
split.
trivial.
case H5.
intro.
right.
red in |- *.
intro.
apply H6.
generalize (inclusion_impl_le_h (reduce g) g (red_incl_h g)).
unfold le_h in |- *.

*****
H7 : synthesis h m2 m0
H6 : not (synthesis g m2 m0)
H5 : or (not (synthesis g m1 m)) (not (synthesis g m2 m0))
H4 : g (MEnc m1 m2) (MEnc m m0)
H3 : and (g (MEnc m1 m2) (MEnc m m0))\n (or (not (synthesis g m1 m)) (not (synthesis g m2 m0)))
H2 : h (MEnc m1 m2) (MEnc m m0)
m,m0,m1,m2 : Msg
H1 : reduce g M N
M,N : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis (reduce g) M N
H : forall (M N : Msg) (_ : reduce g M N), h M N
g,h : hedge
*****
forall _ : inclusion (synthesis (reduce g)) (synthesis g), synthesis g m2 m0
+++++
unfold inclusion in |- *.
-----
Lemma inclusion_le_h_impl_inclusion_red : forall g h : hedge, inclusion (reduce g) h -> le_h h (reduce g) -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize H1.
generalize (H M N H1).
unfold reduce in |- *.
case M.
try tauto.
case N.
try tauto.
intros.
elim H3.
split.
trivial.
case H5.
intro.
right.
red in |- *.
intro.
apply H6.
generalize (inclusion_impl_le_h (reduce g) g (red_incl_h g)).
unfold le_h in |- *.
unfold inclusion in |- *.

*****
H7 : synthesis h m2 m0
H6 : not (synthesis g m2 m0)
H5 : or (not (synthesis g m1 m)) (not (synthesis g m2 m0))
H4 : g (MEnc m1 m2) (MEnc m m0)
H3 : and (g (MEnc m1 m2) (MEnc m m0))\n (or (not (synthesis g m1 m)) (not (synthesis g m2 m0)))
H2 : h (MEnc m1 m2) (MEnc m m0)
m,m0,m1,m2 : Msg
H1 : reduce g M N
M,N : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis (reduce g) M N
H : forall (M N : Msg) (_ : reduce g M N), h M N
g,h : hedge
*****
forall _ : forall (M N : Msg) (_ : synthesis (reduce g) M N), synthesis g M N, synthesis g m2 m0
+++++
intros.
-----
Lemma inclusion_le_h_impl_inclusion_red : forall g h : hedge, inclusion (reduce g) h -> le_h h (reduce g) -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize H1.
generalize (H M N H1).
unfold reduce in |- *.
case M.
try tauto.
case N.
try tauto.
intros.
elim H3.
split.
trivial.
case H5.
intro.
right.
red in |- *.
intro.
apply H6.
generalize (inclusion_impl_le_h (reduce g) g (red_incl_h g)).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.

*****
H8 : forall (M N : Msg) (_ : synthesis (reduce g) M N), synthesis g M N
H7 : synthesis h m2 m0
H6 : not (synthesis g m2 m0)
H5 : or (not (synthesis g m1 m)) (not (synthesis g m2 m0))
H4 : g (MEnc m1 m2) (MEnc m m0)
H3 : and (g (MEnc m1 m2) (MEnc m m0))\n (or (not (synthesis g m1 m)) (not (synthesis g m2 m0)))
H2 : h (MEnc m1 m2) (MEnc m m0)
m,m0,m1,m2 : Msg
H1 : reduce g M N
M,N : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis (reduce g) M N
H : forall (M N : Msg) (_ : reduce g M N), h M N
g,h : hedge
*****
synthesis g m2 m0
+++++
apply H8.
-----
Lemma inclusion_le_h_impl_inclusion_red : forall g h : hedge, inclusion (reduce g) h -> le_h h (reduce g) -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize H1.
generalize (H M N H1).
unfold reduce in |- *.
case M.
try tauto.
case N.
try tauto.
intros.
elim H3.
split.
trivial.
case H5.
intro.
right.
red in |- *.
intro.
apply H6.
generalize (inclusion_impl_le_h (reduce g) g (red_incl_h g)).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
apply H8.

*****
H8 : forall (M N : Msg) (_ : synthesis (reduce g) M N), synthesis g M N
H7 : synthesis h m2 m0
H6 : not (synthesis g m2 m0)
H5 : or (not (synthesis g m1 m)) (not (synthesis g m2 m0))
H4 : g (MEnc m1 m2) (MEnc m m0)
H3 : and (g (MEnc m1 m2) (MEnc m m0))\n (or (not (synthesis g m1 m)) (not (synthesis g m2 m0)))
H2 : h (MEnc m1 m2) (MEnc m m0)
m,m0,m1,m2 : Msg
H1 : reduce g M N
M,N : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis (reduce g) M N
H : forall (M N : Msg) (_ : reduce g M N), h M N
g,h : hedge
*****
synthesis (reduce g) m2 m0
+++++
apply H0.
-----
Lemma inclusion_le_h_impl_inclusion_red : forall g h : hedge, inclusion (reduce g) h -> le_h h (reduce g) -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize H1.
generalize (H M N H1).
unfold reduce in |- *.
case M.
try tauto.
case N.
try tauto.
intros.
elim H3.
split.
trivial.
case H5.
intro.
right.
red in |- *.
intro.
apply H6.
generalize (inclusion_impl_le_h (reduce g) g (red_incl_h g)).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
apply H8.
apply H0.

*****
H8 : forall (M N : Msg) (_ : synthesis (reduce g) M N), synthesis g M N
H7 : synthesis h m2 m0
H6 : not (synthesis g m2 m0)
H5 : or (not (synthesis g m1 m)) (not (synthesis g m2 m0))
H4 : g (MEnc m1 m2) (MEnc m m0)
H3 : and (g (MEnc m1 m2) (MEnc m m0))\n (or (not (synthesis g m1 m)) (not (synthesis g m2 m0)))
H2 : h (MEnc m1 m2) (MEnc m m0)
m,m0,m1,m2 : Msg
H1 : reduce g M N
M,N : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis (reduce g) M N
H : forall (M N : Msg) (_ : reduce g M N), h M N
g,h : hedge
*****
synthesis h m2 m0
+++++
trivial.
-----
Lemma inclusion_le_h_impl_inclusion_red : forall g h : hedge, inclusion (reduce g) h -> le_h h (reduce g) -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize H1.
generalize (H M N H1).
unfold reduce in |- *.
case M.
try tauto.
case N.

*****
H1 : reduce g M N
M,N : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis (reduce g) M N
H : forall (M N : Msg) (_ : reduce g M N), h M N
g,h : hedge
*****
forall (m m0 m1 m2 : Msg) (_ : h (MEnc m1 m2) (MPair m m0)) (_ : and (g (MEnc m1 m2) (MPair m m0)) True), and (h (MEnc m1 m2) (MPair m m0)) True
+++++
try tauto.
-----
Lemma inclusion_le_h_impl_inclusion_red : forall g h : hedge, inclusion (reduce g) h -> le_h h (reduce g) -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize H1.
generalize (H M N H1).
unfold reduce in |- *.
case M.
try tauto.
case N.

*****
H1 : reduce g M N
M,N : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis (reduce g) M N
H : forall (M N : Msg) (_ : reduce g M N), h M N
g,h : hedge
*****
forall (o : op) (m m0 m1 : Msg) (_ : h (MEnc m0 m1) (Mop o m)) (_ : and (g (MEnc m0 m1) (Mop o m)) True), and (h (MEnc m0 m1) (Mop o m)) True
+++++
try tauto.
-----
Lemma inclusion_le_h_impl_inclusion_red : forall g h : hedge, inclusion (reduce g) h -> le_h h (reduce g) -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize H1.
generalize (H M N H1).
unfold reduce in |- *.
case M.

*****
H1 : reduce g M N
M,N : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis (reduce g) M N
H : forall (M N : Msg) (_ : reduce g M N), h M N
g,h : hedge
*****
forall (m m0 : Msg) (_ : h (MPair m m0) N) (_ : and (g (MPair m m0) N) match N with | MPair N1 N2 => or (not (synthesis g m N1)) (not (synthesis g m0 N2)) | _ => True end), and (h (MPair m m0) N) match N with | MPair N1 N2 => or (not (synthesis h m N1)) (not (synthesis h m0 N2)) | _ => True end
+++++
try tauto.
-----
Lemma inclusion_le_h_impl_inclusion_red : forall g h : hedge, inclusion (reduce g) h -> le_h h (reduce g) -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize H1.
generalize (H M N H1).
unfold reduce in |- *.
case M.
try tauto.

*****
H1 : reduce g M N
M,N : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis (reduce g) M N
H : forall (M N : Msg) (_ : reduce g M N), h M N
g,h : hedge
*****
forall (m m0 : Msg) (_ : h (MPair m m0) N) (_ : and (g (MPair m m0) N) match N with | MPair N1 N2 => or (not (synthesis g m N1)) (not (synthesis g m0 N2)) | _ => True end), and (h (MPair m m0) N) match N with | MPair N1 N2 => or (not (synthesis h m N1)) (not (synthesis h m0 N2)) | _ => True end
+++++
case N.
-----
Lemma inclusion_le_h_impl_inclusion_red : forall g h : hedge, inclusion (reduce g) h -> le_h h (reduce g) -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize H1.
generalize (H M N H1).
unfold reduce in |- *.
case M.
try tauto.
case N.

*****
H1 : reduce g M N
M,N : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis (reduce g) M N
H : forall (M N : Msg) (_ : reduce g M N), h M N
g,h : hedge
*****
forall (n : Nam) (m m0 : Msg) (_ : h (MPair m m0) (MNam n)) (_ : and (g (MPair m m0) (MNam n)) True), and (h (MPair m m0) (MNam n)) True
+++++
try tauto.
-----
Lemma inclusion_le_h_impl_inclusion_red : forall g h : hedge, inclusion (reduce g) h -> le_h h (reduce g) -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize H1.
generalize (H M N H1).
unfold reduce in |- *.
case M.
try tauto.
case N.

*****
H1 : reduce g M N
M,N : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis (reduce g) M N
H : forall (M N : Msg) (_ : reduce g M N), h M N
g,h : hedge
*****
forall (m m0 m1 m2 : Msg) (_ : h (MPair m1 m2) (MEnc m m0)) (_ : and (g (MPair m1 m2) (MEnc m m0)) True), and (h (MPair m1 m2) (MEnc m m0)) True
+++++
try tauto.
-----
Lemma inclusion_le_h_impl_inclusion_red : forall g h : hedge, inclusion (reduce g) h -> le_h h (reduce g) -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize H1.
generalize (H M N H1).
unfold reduce in |- *.
case M.
try tauto.
case N.

*****
H1 : reduce g M N
M,N : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis (reduce g) M N
H : forall (M N : Msg) (_ : reduce g M N), h M N
g,h : hedge
*****
forall (m m0 m1 m2 : Msg) (_ : h (MPair m1 m2) (MPair m m0)) (_ : and (g (MPair m1 m2) (MPair m m0)) (or (not (synthesis g m1 m)) (not (synthesis g m2 m0)))), and (h (MPair m1 m2) (MPair m m0)) (or (not (synthesis h m1 m)) (not (synthesis h m2 m0)))
+++++
try tauto.
-----
Lemma inclusion_le_h_impl_inclusion_red : forall g h : hedge, inclusion (reduce g) h -> le_h h (reduce g) -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize H1.
generalize (H M N H1).
unfold reduce in |- *.
case M.
try tauto.
case N.
try tauto.

*****
H1 : reduce g M N
M,N : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis (reduce g) M N
H : forall (M N : Msg) (_ : reduce g M N), h M N
g,h : hedge
*****
forall (m m0 m1 m2 : Msg) (_ : h (MPair m1 m2) (MPair m m0)) (_ : and (g (MPair m1 m2) (MPair m m0)) (or (not (synthesis g m1 m)) (not (synthesis g m2 m0)))), and (h (MPair m1 m2) (MPair m m0)) (or (not (synthesis h m1 m)) (not (synthesis h m2 m0)))
+++++
intros.
-----
Lemma inclusion_le_h_impl_inclusion_red : forall g h : hedge, inclusion (reduce g) h -> le_h h (reduce g) -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize H1.
generalize (H M N H1).
unfold reduce in |- *.
case M.
try tauto.
case N.
try tauto.
intros.

*****
H3 : and (g (MPair m1 m2) (MPair m m0))\n (or (not (synthesis g m1 m)) (not (synthesis g m2 m0)))
H2 : h (MPair m1 m2) (MPair m m0)
m,m0,m1,m2 : Msg
H1 : reduce g M N
M,N : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis (reduce g) M N
H : forall (M N : Msg) (_ : reduce g M N), h M N
g,h : hedge
*****
and (h (MPair m1 m2) (MPair m m0)) (or (not (synthesis h m1 m)) (not (synthesis h m2 m0)))
+++++
split.
-----
Lemma inclusion_le_h_impl_inclusion_red : forall g h : hedge, inclusion (reduce g) h -> le_h h (reduce g) -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize H1.
generalize (H M N H1).
unfold reduce in |- *.
case M.
try tauto.
case N.
try tauto.
intros.
split.

*****
H3 : and (g (MPair m1 m2) (MPair m m0))\n (or (not (synthesis g m1 m)) (not (synthesis g m2 m0)))
H2 : h (MPair m1 m2) (MPair m m0)
m,m0,m1,m2 : Msg
H1 : reduce g M N
M,N : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis (reduce g) M N
H : forall (M N : Msg) (_ : reduce g M N), h M N
g,h : hedge
*****
h (MPair m1 m2) (MPair m m0)
+++++
trivial.
-----
Lemma inclusion_le_h_impl_inclusion_red : forall g h : hedge, inclusion (reduce g) h -> le_h h (reduce g) -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize H1.
generalize (H M N H1).
unfold reduce in |- *.
case M.
try tauto.
case N.
try tauto.
intros.
split.

*****
H3 : and (g (MPair m1 m2) (MPair m m0))\n (or (not (synthesis g m1 m)) (not (synthesis g m2 m0)))
H2 : h (MPair m1 m2) (MPair m m0)
m,m0,m1,m2 : Msg
H1 : reduce g M N
M,N : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis (reduce g) M N
H : forall (M N : Msg) (_ : reduce g M N), h M N
g,h : hedge
*****
or (not (synthesis h m1 m)) (not (synthesis h m2 m0))
+++++
trivial.
-----
Lemma inclusion_le_h_impl_inclusion_red : forall g h : hedge, inclusion (reduce g) h -> le_h h (reduce g) -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize H1.
generalize (H M N H1).
unfold reduce in |- *.
case M.
try tauto.
case N.
try tauto.
intros.
split.
trivial.

*****
H3 : and (g (MPair m1 m2) (MPair m m0))\n (or (not (synthesis g m1 m)) (not (synthesis g m2 m0)))
H2 : h (MPair m1 m2) (MPair m m0)
m,m0,m1,m2 : Msg
H1 : reduce g M N
M,N : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis (reduce g) M N
H : forall (M N : Msg) (_ : reduce g M N), h M N
g,h : hedge
*****
or (not (synthesis h m1 m)) (not (synthesis h m2 m0))
+++++
elim H3.
-----
Lemma inclusion_le_h_impl_inclusion_red : forall g h : hedge, inclusion (reduce g) h -> le_h h (reduce g) -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize H1.
generalize (H M N H1).
unfold reduce in |- *.
case M.
try tauto.
case N.
try tauto.
intros.
split.
trivial.
elim H3.

*****
H3 : and (g (MPair m1 m2) (MPair m m0))\n (or (not (synthesis g m1 m)) (not (synthesis g m2 m0)))
H2 : h (MPair m1 m2) (MPair m m0)
m,m0,m1,m2 : Msg
H1 : reduce g M N
M,N : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis (reduce g) M N
H : forall (M N : Msg) (_ : reduce g M N), h M N
g,h : hedge
*****
forall (_ : g (MPair m1 m2) (MPair m m0)) (_ : or (not (synthesis g m1 m)) (not (synthesis g m2 m0))), or (not (synthesis h m1 m)) (not (synthesis h m2 m0))
+++++
intros.
-----
Lemma inclusion_le_h_impl_inclusion_red : forall g h : hedge, inclusion (reduce g) h -> le_h h (reduce g) -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize H1.
generalize (H M N H1).
unfold reduce in |- *.
case M.
try tauto.
case N.
try tauto.
intros.
split.
trivial.
elim H3.
intros.

*****
H5 : or (not (synthesis g m1 m)) (not (synthesis g m2 m0))
H4 : g (MPair m1 m2) (MPair m m0)
H3 : and (g (MPair m1 m2) (MPair m m0))\n (or (not (synthesis g m1 m)) (not (synthesis g m2 m0)))
H2 : h (MPair m1 m2) (MPair m m0)
m,m0,m1,m2 : Msg
H1 : reduce g M N
M,N : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis (reduce g) M N
H : forall (M N : Msg) (_ : reduce g M N), h M N
g,h : hedge
*****
or (not (synthesis h m1 m)) (not (synthesis h m2 m0))
+++++
case H5.
-----
Lemma inclusion_le_h_impl_inclusion_red : forall g h : hedge, inclusion (reduce g) h -> le_h h (reduce g) -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize H1.
generalize (H M N H1).
unfold reduce in |- *.
case M.
try tauto.
case N.
try tauto.
intros.
split.
trivial.
elim H3.
intros.
case H5.

*****
H5 : or (not (synthesis g m1 m)) (not (synthesis g m2 m0))
H4 : g (MPair m1 m2) (MPair m m0)
H3 : and (g (MPair m1 m2) (MPair m m0))\n (or (not (synthesis g m1 m)) (not (synthesis g m2 m0)))
H2 : h (MPair m1 m2) (MPair m m0)
m,m0,m1,m2 : Msg
H1 : reduce g M N
M,N : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis (reduce g) M N
H : forall (M N : Msg) (_ : reduce g M N), h M N
g,h : hedge
*****
forall _ : not (synthesis g m1 m), or (not (synthesis h m1 m)) (not (synthesis h m2 m0))
+++++
left.
-----
Lemma inclusion_le_h_impl_inclusion_red : forall g h : hedge, inclusion (reduce g) h -> le_h h (reduce g) -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize H1.
generalize (H M N H1).
unfold reduce in |- *.
case M.
try tauto.
case N.
try tauto.
intros.
split.
trivial.
elim H3.
intros.
case H5.
left.

*****
H6 : not (synthesis g m1 m)
H5 : or (not (synthesis g m1 m)) (not (synthesis g m2 m0))
H4 : g (MPair m1 m2) (MPair m m0)
H3 : and (g (MPair m1 m2) (MPair m m0))\n (or (not (synthesis g m1 m)) (not (synthesis g m2 m0)))
H2 : h (MPair m1 m2) (MPair m m0)
m,m0,m1,m2 : Msg
H1 : reduce g M N
M,N : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis (reduce g) M N
H : forall (M N : Msg) (_ : reduce g M N), h M N
g,h : hedge
*****
not (synthesis h m1 m)
+++++
red in |- *.
-----
Lemma inclusion_le_h_impl_inclusion_red : forall g h : hedge, inclusion (reduce g) h -> le_h h (reduce g) -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize H1.
generalize (H M N H1).
unfold reduce in |- *.
case M.
try tauto.
case N.
try tauto.
intros.
split.
trivial.
elim H3.
intros.
case H5.
left.
red in |- *.

*****
H6 : not (synthesis g m1 m)
H5 : or (not (synthesis g m1 m)) (not (synthesis g m2 m0))
H4 : g (MPair m1 m2) (MPair m m0)
H3 : and (g (MPair m1 m2) (MPair m m0))\n (or (not (synthesis g m1 m)) (not (synthesis g m2 m0)))
H2 : h (MPair m1 m2) (MPair m m0)
m,m0,m1,m2 : Msg
H1 : reduce g M N
M,N : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis (reduce g) M N
H : forall (M N : Msg) (_ : reduce g M N), h M N
g,h : hedge
*****
forall _ : synthesis h m1 m, False
+++++
intro.
-----
Lemma inclusion_le_h_impl_inclusion_red : forall g h : hedge, inclusion (reduce g) h -> le_h h (reduce g) -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize H1.
generalize (H M N H1).
unfold reduce in |- *.
case M.
try tauto.
case N.
try tauto.
intros.
split.
trivial.
elim H3.
intros.
case H5.
left.
red in |- *.
intro.

*****
H7 : synthesis h m1 m
H6 : not (synthesis g m1 m)
H5 : or (not (synthesis g m1 m)) (not (synthesis g m2 m0))
H4 : g (MPair m1 m2) (MPair m m0)
H3 : and (g (MPair m1 m2) (MPair m m0))\n (or (not (synthesis g m1 m)) (not (synthesis g m2 m0)))
H2 : h (MPair m1 m2) (MPair m m0)
m,m0,m1,m2 : Msg
H1 : reduce g M N
M,N : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis (reduce g) M N
H : forall (M N : Msg) (_ : reduce g M N), h M N
g,h : hedge
*****
False
+++++
apply H6.
-----
Lemma inclusion_le_h_impl_inclusion_red : forall g h : hedge, inclusion (reduce g) h -> le_h h (reduce g) -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize H1.
generalize (H M N H1).
unfold reduce in |- *.
case M.
try tauto.
case N.
try tauto.
intros.
split.
trivial.
elim H3.
intros.
case H5.
left.
red in |- *.
intro.
apply H6.

*****
H7 : synthesis h m1 m
H6 : not (synthesis g m1 m)
H5 : or (not (synthesis g m1 m)) (not (synthesis g m2 m0))
H4 : g (MPair m1 m2) (MPair m m0)
H3 : and (g (MPair m1 m2) (MPair m m0))\n (or (not (synthesis g m1 m)) (not (synthesis g m2 m0)))
H2 : h (MPair m1 m2) (MPair m m0)
m,m0,m1,m2 : Msg
H1 : reduce g M N
M,N : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis (reduce g) M N
H : forall (M N : Msg) (_ : reduce g M N), h M N
g,h : hedge
*****
synthesis g m1 m
+++++
generalize (inclusion_impl_le_h (reduce g) g (red_incl_h g)).
-----
Lemma inclusion_le_h_impl_inclusion_red : forall g h : hedge, inclusion (reduce g) h -> le_h h (reduce g) -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize H1.
generalize (H M N H1).
unfold reduce in |- *.
case M.
try tauto.
case N.
try tauto.
intros.
split.
trivial.
elim H3.
intros.
case H5.
left.
red in |- *.
intro.
apply H6.
generalize (inclusion_impl_le_h (reduce g) g (red_incl_h g)).

*****
H7 : synthesis h m1 m
H6 : not (synthesis g m1 m)
H5 : or (not (synthesis g m1 m)) (not (synthesis g m2 m0))
H4 : g (MPair m1 m2) (MPair m m0)
H3 : and (g (MPair m1 m2) (MPair m m0))\n (or (not (synthesis g m1 m)) (not (synthesis g m2 m0)))
H2 : h (MPair m1 m2) (MPair m m0)
m,m0,m1,m2 : Msg
H1 : reduce g M N
M,N : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis (reduce g) M N
H : forall (M N : Msg) (_ : reduce g M N), h M N
g,h : hedge
*****
forall _ : le_h (reduce g) g, synthesis g m1 m
+++++
unfold le_h in |- *.
-----
Lemma inclusion_le_h_impl_inclusion_red : forall g h : hedge, inclusion (reduce g) h -> le_h h (reduce g) -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize H1.
generalize (H M N H1).
unfold reduce in |- *.
case M.
try tauto.
case N.
try tauto.
intros.
split.
trivial.
elim H3.
intros.
case H5.
left.
red in |- *.
intro.
apply H6.
generalize (inclusion_impl_le_h (reduce g) g (red_incl_h g)).
unfold le_h in |- *.

*****
H7 : synthesis h m1 m
H6 : not (synthesis g m1 m)
H5 : or (not (synthesis g m1 m)) (not (synthesis g m2 m0))
H4 : g (MPair m1 m2) (MPair m m0)
H3 : and (g (MPair m1 m2) (MPair m m0))\n (or (not (synthesis g m1 m)) (not (synthesis g m2 m0)))
H2 : h (MPair m1 m2) (MPair m m0)
m,m0,m1,m2 : Msg
H1 : reduce g M N
M,N : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis (reduce g) M N
H : forall (M N : Msg) (_ : reduce g M N), h M N
g,h : hedge
*****
forall _ : inclusion (synthesis (reduce g)) (synthesis g), synthesis g m1 m
+++++
unfold inclusion in |- *.
-----
Lemma inclusion_le_h_impl_inclusion_red : forall g h : hedge, inclusion (reduce g) h -> le_h h (reduce g) -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize H1.
generalize (H M N H1).
unfold reduce in |- *.
case M.
try tauto.
case N.
try tauto.
intros.
split.
trivial.
elim H3.
intros.
case H5.
left.
red in |- *.
intro.
apply H6.
generalize (inclusion_impl_le_h (reduce g) g (red_incl_h g)).
unfold le_h in |- *.
unfold inclusion in |- *.

*****
H7 : synthesis h m1 m
H6 : not (synthesis g m1 m)
H5 : or (not (synthesis g m1 m)) (not (synthesis g m2 m0))
H4 : g (MPair m1 m2) (MPair m m0)
H3 : and (g (MPair m1 m2) (MPair m m0))\n (or (not (synthesis g m1 m)) (not (synthesis g m2 m0)))
H2 : h (MPair m1 m2) (MPair m m0)
m,m0,m1,m2 : Msg
H1 : reduce g M N
M,N : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis (reduce g) M N
H : forall (M N : Msg) (_ : reduce g M N), h M N
g,h : hedge
*****
forall _ : forall (M N : Msg) (_ : synthesis (reduce g) M N), synthesis g M N, synthesis g m1 m
+++++
auto.
-----
Lemma inclusion_le_h_impl_inclusion_red : forall g h : hedge, inclusion (reduce g) h -> le_h h (reduce g) -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize H1.
generalize (H M N H1).
unfold reduce in |- *.
case M.
try tauto.
case N.
try tauto.
intros.
split.
trivial.
elim H3.
intros.
case H5.

*****
H5 : or (not (synthesis g m1 m)) (not (synthesis g m2 m0))
H4 : g (MPair m1 m2) (MPair m m0)
H3 : and (g (MPair m1 m2) (MPair m m0))\n (or (not (synthesis g m1 m)) (not (synthesis g m2 m0)))
H2 : h (MPair m1 m2) (MPair m m0)
m,m0,m1,m2 : Msg
H1 : reduce g M N
M,N : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis (reduce g) M N
H : forall (M N : Msg) (_ : reduce g M N), h M N
g,h : hedge
*****
forall _ : not (synthesis g m2 m0), or (not (synthesis h m1 m)) (not (synthesis h m2 m0))
+++++
right.
-----
Lemma inclusion_le_h_impl_inclusion_red : forall g h : hedge, inclusion (reduce g) h -> le_h h (reduce g) -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize H1.
generalize (H M N H1).
unfold reduce in |- *.
case M.
try tauto.
case N.
try tauto.
intros.
split.
trivial.
elim H3.
intros.
case H5.
right.

*****
H6 : not (synthesis g m2 m0)
H5 : or (not (synthesis g m1 m)) (not (synthesis g m2 m0))
H4 : g (MPair m1 m2) (MPair m m0)
H3 : and (g (MPair m1 m2) (MPair m m0))\n (or (not (synthesis g m1 m)) (not (synthesis g m2 m0)))
H2 : h (MPair m1 m2) (MPair m m0)
m,m0,m1,m2 : Msg
H1 : reduce g M N
M,N : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis (reduce g) M N
H : forall (M N : Msg) (_ : reduce g M N), h M N
g,h : hedge
*****
not (synthesis h m2 m0)
+++++
red in |- *.
-----
Lemma inclusion_le_h_impl_inclusion_red : forall g h : hedge, inclusion (reduce g) h -> le_h h (reduce g) -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize H1.
generalize (H M N H1).
unfold reduce in |- *.
case M.
try tauto.
case N.
try tauto.
intros.
split.
trivial.
elim H3.
intros.
case H5.
right.
red in |- *.

*****
H6 : not (synthesis g m2 m0)
H5 : or (not (synthesis g m1 m)) (not (synthesis g m2 m0))
H4 : g (MPair m1 m2) (MPair m m0)
H3 : and (g (MPair m1 m2) (MPair m m0))\n (or (not (synthesis g m1 m)) (not (synthesis g m2 m0)))
H2 : h (MPair m1 m2) (MPair m m0)
m,m0,m1,m2 : Msg
H1 : reduce g M N
M,N : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis (reduce g) M N
H : forall (M N : Msg) (_ : reduce g M N), h M N
g,h : hedge
*****
forall _ : synthesis h m2 m0, False
+++++
intro.
-----
Lemma inclusion_le_h_impl_inclusion_red : forall g h : hedge, inclusion (reduce g) h -> le_h h (reduce g) -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize H1.
generalize (H M N H1).
unfold reduce in |- *.
case M.
try tauto.
case N.
try tauto.
intros.
split.
trivial.
elim H3.
intros.
case H5.
right.
red in |- *.
intro.

*****
H7 : synthesis h m2 m0
H6 : not (synthesis g m2 m0)
H5 : or (not (synthesis g m1 m)) (not (synthesis g m2 m0))
H4 : g (MPair m1 m2) (MPair m m0)
H3 : and (g (MPair m1 m2) (MPair m m0))\n (or (not (synthesis g m1 m)) (not (synthesis g m2 m0)))
H2 : h (MPair m1 m2) (MPair m m0)
m,m0,m1,m2 : Msg
H1 : reduce g M N
M,N : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis (reduce g) M N
H : forall (M N : Msg) (_ : reduce g M N), h M N
g,h : hedge
*****
False
+++++
apply H6.
-----
Lemma inclusion_le_h_impl_inclusion_red : forall g h : hedge, inclusion (reduce g) h -> le_h h (reduce g) -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize H1.
generalize (H M N H1).
unfold reduce in |- *.
case M.
try tauto.
case N.
try tauto.
intros.
split.
trivial.
elim H3.
intros.
case H5.
right.
red in |- *.
intro.
apply H6.

*****
H7 : synthesis h m2 m0
H6 : not (synthesis g m2 m0)
H5 : or (not (synthesis g m1 m)) (not (synthesis g m2 m0))
H4 : g (MPair m1 m2) (MPair m m0)
H3 : and (g (MPair m1 m2) (MPair m m0))\n (or (not (synthesis g m1 m)) (not (synthesis g m2 m0)))
H2 : h (MPair m1 m2) (MPair m m0)
m,m0,m1,m2 : Msg
H1 : reduce g M N
M,N : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis (reduce g) M N
H : forall (M N : Msg) (_ : reduce g M N), h M N
g,h : hedge
*****
synthesis g m2 m0
+++++
generalize (inclusion_impl_le_h (reduce g) g (red_incl_h g)).
-----
Lemma inclusion_le_h_impl_inclusion_red : forall g h : hedge, inclusion (reduce g) h -> le_h h (reduce g) -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize H1.
generalize (H M N H1).
unfold reduce in |- *.
case M.
try tauto.
case N.
try tauto.
intros.
split.
trivial.
elim H3.
intros.
case H5.
right.
red in |- *.
intro.
apply H6.
generalize (inclusion_impl_le_h (reduce g) g (red_incl_h g)).

*****
H7 : synthesis h m2 m0
H6 : not (synthesis g m2 m0)
H5 : or (not (synthesis g m1 m)) (not (synthesis g m2 m0))
H4 : g (MPair m1 m2) (MPair m m0)
H3 : and (g (MPair m1 m2) (MPair m m0))\n (or (not (synthesis g m1 m)) (not (synthesis g m2 m0)))
H2 : h (MPair m1 m2) (MPair m m0)
m,m0,m1,m2 : Msg
H1 : reduce g M N
M,N : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis (reduce g) M N
H : forall (M N : Msg) (_ : reduce g M N), h M N
g,h : hedge
*****
forall _ : le_h (reduce g) g, synthesis g m2 m0
+++++
unfold le_h in |- *.
-----
Lemma inclusion_le_h_impl_inclusion_red : forall g h : hedge, inclusion (reduce g) h -> le_h h (reduce g) -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize H1.
generalize (H M N H1).
unfold reduce in |- *.
case M.
try tauto.
case N.
try tauto.
intros.
split.
trivial.
elim H3.
intros.
case H5.
right.
red in |- *.
intro.
apply H6.
generalize (inclusion_impl_le_h (reduce g) g (red_incl_h g)).
unfold le_h in |- *.

*****
H7 : synthesis h m2 m0
H6 : not (synthesis g m2 m0)
H5 : or (not (synthesis g m1 m)) (not (synthesis g m2 m0))
H4 : g (MPair m1 m2) (MPair m m0)
H3 : and (g (MPair m1 m2) (MPair m m0))\n (or (not (synthesis g m1 m)) (not (synthesis g m2 m0)))
H2 : h (MPair m1 m2) (MPair m m0)
m,m0,m1,m2 : Msg
H1 : reduce g M N
M,N : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis (reduce g) M N
H : forall (M N : Msg) (_ : reduce g M N), h M N
g,h : hedge
*****
forall _ : inclusion (synthesis (reduce g)) (synthesis g), synthesis g m2 m0
+++++
unfold inclusion in |- *.
-----
Lemma inclusion_le_h_impl_inclusion_red : forall g h : hedge, inclusion (reduce g) h -> le_h h (reduce g) -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize H1.
generalize (H M N H1).
unfold reduce in |- *.
case M.
try tauto.
case N.
try tauto.
intros.
split.
trivial.
elim H3.
intros.
case H5.
right.
red in |- *.
intro.
apply H6.
generalize (inclusion_impl_le_h (reduce g) g (red_incl_h g)).
unfold le_h in |- *.
unfold inclusion in |- *.

*****
H7 : synthesis h m2 m0
H6 : not (synthesis g m2 m0)
H5 : or (not (synthesis g m1 m)) (not (synthesis g m2 m0))
H4 : g (MPair m1 m2) (MPair m m0)
H3 : and (g (MPair m1 m2) (MPair m m0))\n (or (not (synthesis g m1 m)) (not (synthesis g m2 m0)))
H2 : h (MPair m1 m2) (MPair m m0)
m,m0,m1,m2 : Msg
H1 : reduce g M N
M,N : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis (reduce g) M N
H : forall (M N : Msg) (_ : reduce g M N), h M N
g,h : hedge
*****
forall _ : forall (M N : Msg) (_ : synthesis (reduce g) M N), synthesis g M N, synthesis g m2 m0
+++++
auto.
-----
Lemma inclusion_le_h_impl_inclusion_red : forall g h : hedge, inclusion (reduce g) h -> le_h h (reduce g) -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize H1.
generalize (H M N H1).
unfold reduce in |- *.
case M.
try tauto.
case N.

*****
H1 : reduce g M N
M,N : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis (reduce g) M N
H : forall (M N : Msg) (_ : reduce g M N), h M N
g,h : hedge
*****
forall (o : op) (m m0 m1 : Msg) (_ : h (MPair m0 m1) (Mop o m)) (_ : and (g (MPair m0 m1) (Mop o m)) True), and (h (MPair m0 m1) (Mop o m)) True
+++++
try tauto.
-----
Lemma inclusion_le_h_impl_inclusion_red : forall g h : hedge, inclusion (reduce g) h -> le_h h (reduce g) -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize H1.
generalize (H M N H1).
unfold reduce in |- *.
case M.

*****
H1 : reduce g M N
M,N : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis (reduce g) M N
H : forall (M N : Msg) (_ : reduce g M N), h M N
g,h : hedge
*****
forall (o : op) (m : Msg) (_ : h (Mop o m) N) (_ : and (g (Mop o m) N) match N with | Mop opN N' => or (not (eq o opN)) (not (synthesis g m N')) | _ => True end), and (h (Mop o m) N) match N with | Mop opN N' => or (not (eq o opN)) (not (synthesis h m N')) | _ => True end
+++++
try tauto.
-----
Lemma inclusion_le_h_impl_inclusion_red : forall g h : hedge, inclusion (reduce g) h -> le_h h (reduce g) -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize H1.
generalize (H M N H1).
unfold reduce in |- *.
case M.
try tauto.

*****
H1 : reduce g M N
M,N : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis (reduce g) M N
H : forall (M N : Msg) (_ : reduce g M N), h M N
g,h : hedge
*****
forall (o : op) (m : Msg) (_ : h (Mop o m) N) (_ : and (g (Mop o m) N) match N with | Mop opN N' => or (not (eq o opN)) (not (synthesis g m N')) | _ => True end), and (h (Mop o m) N) match N with | Mop opN N' => or (not (eq o opN)) (not (synthesis h m N')) | _ => True end
+++++
case N.
-----
Lemma inclusion_le_h_impl_inclusion_red : forall g h : hedge, inclusion (reduce g) h -> le_h h (reduce g) -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize H1.
generalize (H M N H1).
unfold reduce in |- *.
case M.
try tauto.
case N.

*****
H1 : reduce g M N
M,N : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis (reduce g) M N
H : forall (M N : Msg) (_ : reduce g M N), h M N
g,h : hedge
*****
forall (n : Nam) (o : op) (m : Msg) (_ : h (Mop o m) (MNam n)) (_ : and (g (Mop o m) (MNam n)) True), and (h (Mop o m) (MNam n)) True
+++++
try tauto.
-----
Lemma inclusion_le_h_impl_inclusion_red : forall g h : hedge, inclusion (reduce g) h -> le_h h (reduce g) -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize H1.
generalize (H M N H1).
unfold reduce in |- *.
case M.
try tauto.
case N.

*****
H1 : reduce g M N
M,N : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis (reduce g) M N
H : forall (M N : Msg) (_ : reduce g M N), h M N
g,h : hedge
*****
forall (m m0 : Msg) (o : op) (m1 : Msg) (_ : h (Mop o m1) (MEnc m m0)) (_ : and (g (Mop o m1) (MEnc m m0)) True), and (h (Mop o m1) (MEnc m m0)) True
+++++
try tauto.
-----
Lemma inclusion_le_h_impl_inclusion_red : forall g h : hedge, inclusion (reduce g) h -> le_h h (reduce g) -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize H1.
generalize (H M N H1).
unfold reduce in |- *.
case M.
try tauto.
case N.

*****
H1 : reduce g M N
M,N : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis (reduce g) M N
H : forall (M N : Msg) (_ : reduce g M N), h M N
g,h : hedge
*****
forall (m m0 : Msg) (o : op) (m1 : Msg) (_ : h (Mop o m1) (MPair m m0)) (_ : and (g (Mop o m1) (MPair m m0)) True), and (h (Mop o m1) (MPair m m0)) True
+++++
try tauto.
-----
Lemma inclusion_le_h_impl_inclusion_red : forall g h : hedge, inclusion (reduce g) h -> le_h h (reduce g) -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize H1.
generalize (H M N H1).
unfold reduce in |- *.
case M.
try tauto.
case N.

*****
H1 : reduce g M N
M,N : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis (reduce g) M N
H : forall (M N : Msg) (_ : reduce g M N), h M N
g,h : hedge
*****
forall (o : op) (m : Msg) (o0 : op) (m0 : Msg) (_ : h (Mop o0 m0) (Mop o m)) (_ : and (g (Mop o0 m0) (Mop o m)) (or (not (eq o0 o)) (not (synthesis g m0 m)))), and (h (Mop o0 m0) (Mop o m)) (or (not (eq o0 o)) (not (synthesis h m0 m)))
+++++
try tauto.
-----
Lemma inclusion_le_h_impl_inclusion_red : forall g h : hedge, inclusion (reduce g) h -> le_h h (reduce g) -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize H1.
generalize (H M N H1).
unfold reduce in |- *.
case M.
try tauto.
case N.
try tauto.

*****
H1 : reduce g M N
M,N : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis (reduce g) M N
H : forall (M N : Msg) (_ : reduce g M N), h M N
g,h : hedge
*****
forall (o : op) (m : Msg) (o0 : op) (m0 : Msg) (_ : h (Mop o0 m0) (Mop o m)) (_ : and (g (Mop o0 m0) (Mop o m)) (or (not (eq o0 o)) (not (synthesis g m0 m)))), and (h (Mop o0 m0) (Mop o m)) (or (not (eq o0 o)) (not (synthesis h m0 m)))
+++++
intros.
-----
Lemma inclusion_le_h_impl_inclusion_red : forall g h : hedge, inclusion (reduce g) h -> le_h h (reduce g) -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize H1.
generalize (H M N H1).
unfold reduce in |- *.
case M.
try tauto.
case N.
try tauto.
intros.

*****
H3 : and (g (Mop o0 m0) (Mop o m))\n (or (not (eq o0 o)) (not (synthesis g m0 m)))
H2 : h (Mop o0 m0) (Mop o m)
m0 : Msg
o0 : op
m : Msg
o : op
H1 : reduce g M N
M,N : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis (reduce g) M N
H : forall (M N : Msg) (_ : reduce g M N), h M N
g,h : hedge
*****
and (h (Mop o0 m0) (Mop o m)) (or (not (eq o0 o)) (not (synthesis h m0 m)))
+++++
split.
-----
Lemma inclusion_le_h_impl_inclusion_red : forall g h : hedge, inclusion (reduce g) h -> le_h h (reduce g) -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize H1.
generalize (H M N H1).
unfold reduce in |- *.
case M.
try tauto.
case N.
try tauto.
intros.
split.

*****
H3 : and (g (Mop o0 m0) (Mop o m))\n (or (not (eq o0 o)) (not (synthesis g m0 m)))
H2 : h (Mop o0 m0) (Mop o m)
m0 : Msg
o0 : op
m : Msg
o : op
H1 : reduce g M N
M,N : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis (reduce g) M N
H : forall (M N : Msg) (_ : reduce g M N), h M N
g,h : hedge
*****
h (Mop o0 m0) (Mop o m)
+++++
trivial.
-----
Lemma inclusion_le_h_impl_inclusion_red : forall g h : hedge, inclusion (reduce g) h -> le_h h (reduce g) -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize H1.
generalize (H M N H1).
unfold reduce in |- *.
case M.
try tauto.
case N.
try tauto.
intros.
split.

*****
H3 : and (g (Mop o0 m0) (Mop o m))\n (or (not (eq o0 o)) (not (synthesis g m0 m)))
H2 : h (Mop o0 m0) (Mop o m)
m0 : Msg
o0 : op
m : Msg
o : op
H1 : reduce g M N
M,N : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis (reduce g) M N
H : forall (M N : Msg) (_ : reduce g M N), h M N
g,h : hedge
*****
or (not (eq o0 o)) (not (synthesis h m0 m))
+++++
trivial.
-----
Lemma inclusion_le_h_impl_inclusion_red : forall g h : hedge, inclusion (reduce g) h -> le_h h (reduce g) -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize H1.
generalize (H M N H1).
unfold reduce in |- *.
case M.
try tauto.
case N.
try tauto.
intros.
split.
trivial.

*****
H3 : and (g (Mop o0 m0) (Mop o m))\n (or (not (eq o0 o)) (not (synthesis g m0 m)))
H2 : h (Mop o0 m0) (Mop o m)
m0 : Msg
o0 : op
m : Msg
o : op
H1 : reduce g M N
M,N : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis (reduce g) M N
H : forall (M N : Msg) (_ : reduce g M N), h M N
g,h : hedge
*****
or (not (eq o0 o)) (not (synthesis h m0 m))
+++++
elim H3.
-----
Lemma inclusion_le_h_impl_inclusion_red : forall g h : hedge, inclusion (reduce g) h -> le_h h (reduce g) -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize H1.
generalize (H M N H1).
unfold reduce in |- *.
case M.
try tauto.
case N.
try tauto.
intros.
split.
trivial.
elim H3.

*****
H3 : and (g (Mop o0 m0) (Mop o m))\n (or (not (eq o0 o)) (not (synthesis g m0 m)))
H2 : h (Mop o0 m0) (Mop o m)
m0 : Msg
o0 : op
m : Msg
o : op
H1 : reduce g M N
M,N : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis (reduce g) M N
H : forall (M N : Msg) (_ : reduce g M N), h M N
g,h : hedge
*****
forall (_ : g (Mop o0 m0) (Mop o m)) (_ : or (not (eq o0 o)) (not (synthesis g m0 m))), or (not (eq o0 o)) (not (synthesis h m0 m))
+++++
intros.
-----
Lemma inclusion_le_h_impl_inclusion_red : forall g h : hedge, inclusion (reduce g) h -> le_h h (reduce g) -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize H1.
generalize (H M N H1).
unfold reduce in |- *.
case M.
try tauto.
case N.
try tauto.
intros.
split.
trivial.
elim H3.
intros.

*****
H5 : or (not (eq o0 o)) (not (synthesis g m0 m))
H4 : g (Mop o0 m0) (Mop o m)
H3 : and (g (Mop o0 m0) (Mop o m))\n (or (not (eq o0 o)) (not (synthesis g m0 m)))
H2 : h (Mop o0 m0) (Mop o m)
m0 : Msg
o0 : op
m : Msg
o : op
H1 : reduce g M N
M,N : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis (reduce g) M N
H : forall (M N : Msg) (_ : reduce g M N), h M N
g,h : hedge
*****
or (not (eq o0 o)) (not (synthesis h m0 m))
+++++
case H5.
-----
Lemma inclusion_le_h_impl_inclusion_red : forall g h : hedge, inclusion (reduce g) h -> le_h h (reduce g) -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize H1.
generalize (H M N H1).
unfold reduce in |- *.
case M.
try tauto.
case N.
try tauto.
intros.
split.
trivial.
elim H3.
intros.
case H5.

*****
H5 : or (not (eq o0 o)) (not (synthesis g m0 m))
H4 : g (Mop o0 m0) (Mop o m)
H3 : and (g (Mop o0 m0) (Mop o m))\n (or (not (eq o0 o)) (not (synthesis g m0 m)))
H2 : h (Mop o0 m0) (Mop o m)
m0 : Msg
o0 : op
m : Msg
o : op
H1 : reduce g M N
M,N : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis (reduce g) M N
H : forall (M N : Msg) (_ : reduce g M N), h M N
g,h : hedge
*****
forall _ : not (eq o0 o), or (not (eq o0 o)) (not (synthesis h m0 m))
+++++
try tauto.
-----
Lemma inclusion_le_h_impl_inclusion_red : forall g h : hedge, inclusion (reduce g) h -> le_h h (reduce g) -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize H1.
generalize (H M N H1).
unfold reduce in |- *.
case M.
try tauto.
case N.
try tauto.
intros.
split.
trivial.
elim H3.
intros.
case H5.

*****
H5 : or (not (eq o0 o)) (not (synthesis g m0 m))
H4 : g (Mop o0 m0) (Mop o m)
H3 : and (g (Mop o0 m0) (Mop o m))\n (or (not (eq o0 o)) (not (synthesis g m0 m)))
H2 : h (Mop o0 m0) (Mop o m)
m0 : Msg
o0 : op
m : Msg
o : op
H1 : reduce g M N
M,N : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis (reduce g) M N
H : forall (M N : Msg) (_ : reduce g M N), h M N
g,h : hedge
*****
forall _ : not (synthesis g m0 m), or (not (eq o0 o)) (not (synthesis h m0 m))
+++++
try tauto.
-----
Lemma inclusion_le_h_impl_inclusion_red : forall g h : hedge, inclusion (reduce g) h -> le_h h (reduce g) -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize H1.
generalize (H M N H1).
unfold reduce in |- *.
case M.
try tauto.
case N.
try tauto.
intros.
split.
trivial.
elim H3.
intros.
case H5.
try tauto.

*****
H5 : or (not (eq o0 o)) (not (synthesis g m0 m))
H4 : g (Mop o0 m0) (Mop o m)
H3 : and (g (Mop o0 m0) (Mop o m))\n (or (not (eq o0 o)) (not (synthesis g m0 m)))
H2 : h (Mop o0 m0) (Mop o m)
m0 : Msg
o0 : op
m : Msg
o : op
H1 : reduce g M N
M,N : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis (reduce g) M N
H : forall (M N : Msg) (_ : reduce g M N), h M N
g,h : hedge
*****
forall _ : not (synthesis g m0 m), or (not (eq o0 o)) (not (synthesis h m0 m))
+++++
right.
-----
Lemma inclusion_le_h_impl_inclusion_red : forall g h : hedge, inclusion (reduce g) h -> le_h h (reduce g) -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize H1.
generalize (H M N H1).
unfold reduce in |- *.
case M.
try tauto.
case N.
try tauto.
intros.
split.
trivial.
elim H3.
intros.
case H5.
try tauto.
right.

*****
H6 : not (synthesis g m0 m)
H5 : or (not (eq o0 o)) (not (synthesis g m0 m))
H4 : g (Mop o0 m0) (Mop o m)
H3 : and (g (Mop o0 m0) (Mop o m))\n (or (not (eq o0 o)) (not (synthesis g m0 m)))
H2 : h (Mop o0 m0) (Mop o m)
m0 : Msg
o0 : op
m : Msg
o : op
H1 : reduce g M N
M,N : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis (reduce g) M N
H : forall (M N : Msg) (_ : reduce g M N), h M N
g,h : hedge
*****
not (synthesis h m0 m)
+++++
red in |- *.
-----
Lemma inclusion_le_h_impl_inclusion_red : forall g h : hedge, inclusion (reduce g) h -> le_h h (reduce g) -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize H1.
generalize (H M N H1).
unfold reduce in |- *.
case M.
try tauto.
case N.
try tauto.
intros.
split.
trivial.
elim H3.
intros.
case H5.
try tauto.
right.
red in |- *.

*****
H6 : not (synthesis g m0 m)
H5 : or (not (eq o0 o)) (not (synthesis g m0 m))
H4 : g (Mop o0 m0) (Mop o m)
H3 : and (g (Mop o0 m0) (Mop o m))\n (or (not (eq o0 o)) (not (synthesis g m0 m)))
H2 : h (Mop o0 m0) (Mop o m)
m0 : Msg
o0 : op
m : Msg
o : op
H1 : reduce g M N
M,N : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis (reduce g) M N
H : forall (M N : Msg) (_ : reduce g M N), h M N
g,h : hedge
*****
forall _ : synthesis h m0 m, False
+++++
intro.
-----
Lemma inclusion_le_h_impl_inclusion_red : forall g h : hedge, inclusion (reduce g) h -> le_h h (reduce g) -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize H1.
generalize (H M N H1).
unfold reduce in |- *.
case M.
try tauto.
case N.
try tauto.
intros.
split.
trivial.
elim H3.
intros.
case H5.
try tauto.
right.
red in |- *.
intro.

*****
H7 : synthesis h m0 m
H6 : not (synthesis g m0 m)
H5 : or (not (eq o0 o)) (not (synthesis g m0 m))
H4 : g (Mop o0 m0) (Mop o m)
H3 : and (g (Mop o0 m0) (Mop o m))\n (or (not (eq o0 o)) (not (synthesis g m0 m)))
H2 : h (Mop o0 m0) (Mop o m)
m0 : Msg
o0 : op
m : Msg
o : op
H1 : reduce g M N
M,N : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis (reduce g) M N
H : forall (M N : Msg) (_ : reduce g M N), h M N
g,h : hedge
*****
False
+++++
apply H6.
-----
Lemma inclusion_le_h_impl_inclusion_red : forall g h : hedge, inclusion (reduce g) h -> le_h h (reduce g) -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize H1.
generalize (H M N H1).
unfold reduce in |- *.
case M.
try tauto.
case N.
try tauto.
intros.
split.
trivial.
elim H3.
intros.
case H5.
try tauto.
right.
red in |- *.
intro.
apply H6.

*****
H7 : synthesis h m0 m
H6 : not (synthesis g m0 m)
H5 : or (not (eq o0 o)) (not (synthesis g m0 m))
H4 : g (Mop o0 m0) (Mop o m)
H3 : and (g (Mop o0 m0) (Mop o m))\n (or (not (eq o0 o)) (not (synthesis g m0 m)))
H2 : h (Mop o0 m0) (Mop o m)
m0 : Msg
o0 : op
m : Msg
o : op
H1 : reduce g M N
M,N : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis (reduce g) M N
H : forall (M N : Msg) (_ : reduce g M N), h M N
g,h : hedge
*****
synthesis g m0 m
+++++
generalize (inclusion_impl_le_h (reduce g) g (red_incl_h g)).
-----
Lemma inclusion_le_h_impl_inclusion_red : forall g h : hedge, inclusion (reduce g) h -> le_h h (reduce g) -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize H1.
generalize (H M N H1).
unfold reduce in |- *.
case M.
try tauto.
case N.
try tauto.
intros.
split.
trivial.
elim H3.
intros.
case H5.
try tauto.
right.
red in |- *.
intro.
apply H6.
generalize (inclusion_impl_le_h (reduce g) g (red_incl_h g)).

*****
H7 : synthesis h m0 m
H6 : not (synthesis g m0 m)
H5 : or (not (eq o0 o)) (not (synthesis g m0 m))
H4 : g (Mop o0 m0) (Mop o m)
H3 : and (g (Mop o0 m0) (Mop o m))\n (or (not (eq o0 o)) (not (synthesis g m0 m)))
H2 : h (Mop o0 m0) (Mop o m)
m0 : Msg
o0 : op
m : Msg
o : op
H1 : reduce g M N
M,N : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis (reduce g) M N
H : forall (M N : Msg) (_ : reduce g M N), h M N
g,h : hedge
*****
forall _ : le_h (reduce g) g, synthesis g m0 m
+++++
unfold le_h in |- *.
-----
Lemma inclusion_le_h_impl_inclusion_red : forall g h : hedge, inclusion (reduce g) h -> le_h h (reduce g) -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize H1.
generalize (H M N H1).
unfold reduce in |- *.
case M.
try tauto.
case N.
try tauto.
intros.
split.
trivial.
elim H3.
intros.
case H5.
try tauto.
right.
red in |- *.
intro.
apply H6.
generalize (inclusion_impl_le_h (reduce g) g (red_incl_h g)).
unfold le_h in |- *.

*****
H7 : synthesis h m0 m
H6 : not (synthesis g m0 m)
H5 : or (not (eq o0 o)) (not (synthesis g m0 m))
H4 : g (Mop o0 m0) (Mop o m)
H3 : and (g (Mop o0 m0) (Mop o m))\n (or (not (eq o0 o)) (not (synthesis g m0 m)))
H2 : h (Mop o0 m0) (Mop o m)
m0 : Msg
o0 : op
m : Msg
o : op
H1 : reduce g M N
M,N : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis (reduce g) M N
H : forall (M N : Msg) (_ : reduce g M N), h M N
g,h : hedge
*****
forall _ : inclusion (synthesis (reduce g)) (synthesis g), synthesis g m0 m
+++++
unfold inclusion in |- *.
-----
Lemma inclusion_le_h_impl_inclusion_red : forall g h : hedge, inclusion (reduce g) h -> le_h h (reduce g) -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize H1.
generalize (H M N H1).
unfold reduce in |- *.
case M.
try tauto.
case N.
try tauto.
intros.
split.
trivial.
elim H3.
intros.
case H5.
try tauto.
right.
red in |- *.
intro.
apply H6.
generalize (inclusion_impl_le_h (reduce g) g (red_incl_h g)).
unfold le_h in |- *.
unfold inclusion in |- *.

*****
H7 : synthesis h m0 m
H6 : not (synthesis g m0 m)
H5 : or (not (eq o0 o)) (not (synthesis g m0 m))
H4 : g (Mop o0 m0) (Mop o m)
H3 : and (g (Mop o0 m0) (Mop o m))\n (or (not (eq o0 o)) (not (synthesis g m0 m)))
H2 : h (Mop o0 m0) (Mop o m)
m0 : Msg
o0 : op
m : Msg
o : op
H1 : reduce g M N
M,N : Msg
H0 : forall (M N : Msg) (_ : synthesis h M N), synthesis (reduce g) M N
H : forall (M N : Msg) (_ : reduce g M N), h M N
g,h : hedge
*****
forall _ : forall (M N : Msg) (_ : synthesis (reduce g) M N), synthesis g M N, synthesis g m0 m
+++++
auto.
-----
Lemma inclusion_le_h_impl_inclusion_red : forall g h : hedge, inclusion (reduce g) h -> le_h h (reduce g) -> inclusion (reduce g) (reduce h).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize H1.
generalize (H M N H1).
unfold reduce in |- *.
case M.

*****

*****

+++++
Qed.
-----
Lemma reduce_idempotent :\n forall h : hedge, equal (reduce h) (reduce (reduce h)).
-----
Lemma reduce_idempotent : forall h : hedge, equal (reduce h) (reduce (reduce h)).

*****

*****
forall h : hedge, equal (reduce h) (reduce (reduce h))
+++++
unfold equal in |- *.
-----
Lemma reduce_idempotent : forall h : hedge, equal (reduce h) (reduce (reduce h)).
unfold equal in |- *.

*****

*****
forall h : hedge, and (inclusion (reduce h) (reduce (reduce h))) (inclusion (reduce (reduce h)) (reduce h))
+++++
intro.
-----
Lemma reduce_idempotent : forall h : hedge, equal (reduce h) (reduce (reduce h)).
unfold equal in |- *.
intro.

*****
h : hedge
*****
and (inclusion (reduce h) (reduce (reduce h))) (inclusion (reduce (reduce h)) (reduce h))
+++++
split.
-----
Lemma reduce_idempotent : forall h : hedge, equal (reduce h) (reduce (reduce h)).
unfold equal in |- *.
intro.
split.

*****
h : hedge
*****
inclusion (reduce h) (reduce (reduce h))
+++++
try apply red_incl_h.
-----
Lemma reduce_idempotent : forall h : hedge, equal (reduce h) (reduce (reduce h)).
unfold equal in |- *.
intro.
split.
try apply red_incl_h.

*****
h : hedge
*****
inclusion (reduce h) (reduce (reduce h))
+++++
apply inclusion_le_h_impl_inclusion_red.
-----
Lemma reduce_idempotent : forall h : hedge, equal (reduce h) (reduce (reduce h)).
unfold equal in |- *.
intro.
split.
try apply red_incl_h.
apply inclusion_le_h_impl_inclusion_red.

*****
h : hedge
*****
inclusion (reduce h) (reduce h)
+++++
apply inclusion_refl.
-----
Lemma reduce_idempotent : forall h : hedge, equal (reduce h) (reduce (reduce h)).
unfold equal in |- *.
intro.
split.
try apply red_incl_h.
apply inclusion_le_h_impl_inclusion_red.

*****
h : hedge
*****
le_h (reduce h) (reduce h)
+++++
apply le_h_refl.
-----
Lemma reduce_idempotent : forall h : hedge, equal (reduce h) (reduce (reduce h)).
unfold equal in |- *.
intro.
split.

*****
h : hedge
*****
inclusion (reduce (reduce h)) (reduce h)
+++++
try apply red_incl_h.
-----
Lemma reduce_idempotent : forall h : hedge, equal (reduce h) (reduce (reduce h)).
unfold equal in |- *.
intro.
split.

*****

*****

+++++
Qed.
-----
Lemma red_equiv_impl_red_incl :\n forall g h : hedge, equiv_h (reduce g) h -> inclusion (reduce g) h.
-----
Lemma red_equiv_impl_red_incl : forall g h : hedge, equiv_h (reduce g) h -> inclusion (reduce g) h.

*****

*****
forall (g h : hedge) (_ : equiv_h (reduce g) h), inclusion (reduce g) h
+++++
unfold equiv_h in |- *.
-----
Lemma red_equiv_impl_red_incl : forall g h : hedge, equiv_h (reduce g) h -> inclusion (reduce g) h.
unfold equiv_h in |- *.

*****

*****
forall (g h : hedge) (_ : and (le_h (reduce g) h) (le_h h (reduce g))), inclusion (reduce g) h
+++++
unfold inclusion in |- *.
-----
Lemma red_equiv_impl_red_incl : forall g h : hedge, equiv_h (reduce g) h -> inclusion (reduce g) h.
unfold equiv_h in |- *.
unfold inclusion in |- *.

*****

*****
forall (g h : hedge) (_ : and (le_h (reduce g) h) (le_h h (reduce g))) (M N : Msg) (_ : reduce g M N), h M N
+++++
intros.
-----
Lemma red_equiv_impl_red_incl : forall g h : hedge, equiv_h (reduce g) h -> inclusion (reduce g) h.
unfold equiv_h in |- *.
unfold inclusion in |- *.
intros.

*****
H0 : reduce g M N
M,N : Msg
H : and (le_h (reduce g) h) (le_h h (reduce g))
g,h : hedge
*****
h M N
+++++
elim H.
-----
Lemma red_equiv_impl_red_incl : forall g h : hedge, equiv_h (reduce g) h -> inclusion (reduce g) h.
unfold equiv_h in |- *.
unfold inclusion in |- *.
intros.
elim H.

*****
H0 : reduce g M N
M,N : Msg
H : and (le_h (reduce g) h) (le_h h (reduce g))
g,h : hedge
*****
forall (_ : le_h (reduce g) h) (_ : le_h h (reduce g)), h M N
+++++
intros.
-----
Lemma red_equiv_impl_red_incl : forall g h : hedge, equiv_h (reduce g) h -> inclusion (reduce g) h.
unfold equiv_h in |- *.
unfold inclusion in |- *.
intros.
elim H.
intros.

*****
H2 : le_h h (reduce g)
H1 : le_h (reduce g) h
H0 : reduce g M N
M,N : Msg
H : and (le_h (reduce g) h) (le_h h (reduce g))
g,h : hedge
*****
h M N
+++++
generalize (le_h_impl_incl_syn (reduce g) h H1).
-----
Lemma red_equiv_impl_red_incl : forall g h : hedge, equiv_h (reduce g) h -> inclusion (reduce g) h.
unfold equiv_h in |- *.
unfold inclusion in |- *.
intros.
elim H.
intros.
generalize (le_h_impl_incl_syn (reduce g) h H1).

*****
H2 : le_h h (reduce g)
H1 : le_h (reduce g) h
H0 : reduce g M N
M,N : Msg
H : and (le_h (reduce g) h) (le_h h (reduce g))
g,h : hedge
*****
forall _ : inclusion (reduce g) (synthesis h), h M N
+++++
unfold inclusion in |- *.
-----
Lemma red_equiv_impl_red_incl : forall g h : hedge, equiv_h (reduce g) h -> inclusion (reduce g) h.
unfold equiv_h in |- *.
unfold inclusion in |- *.
intros.
elim H.
intros.
generalize (le_h_impl_incl_syn (reduce g) h H1).
unfold inclusion in |- *.

*****
H2 : le_h h (reduce g)
H1 : le_h (reduce g) h
H0 : reduce g M N
M,N : Msg
H : and (le_h (reduce g) h) (le_h h (reduce g))
g,h : hedge
*****
forall _ : forall (M N : Msg) (_ : reduce g M N), synthesis h M N, h M N
+++++
intros.
-----
Lemma red_equiv_impl_red_incl : forall g h : hedge, equiv_h (reduce g) h -> inclusion (reduce g) h.
unfold equiv_h in |- *.
unfold inclusion in |- *.
intros.
elim H.
intros.
generalize (le_h_impl_incl_syn (reduce g) h H1).
unfold inclusion in |- *.
intros.

*****
H3 : forall (M N : Msg) (_ : reduce g M N), synthesis h M N
H2 : le_h h (reduce g)
H1 : le_h (reduce g) h
H0 : reduce g M N
M,N : Msg
H : and (le_h (reduce g) h) (le_h h (reduce g))
g,h : hedge
*****
h M N
+++++
generalize (H3 M N H0).
-----
Lemma red_equiv_impl_red_incl : forall g h : hedge, equiv_h (reduce g) h -> inclusion (reduce g) h.
unfold equiv_h in |- *.
unfold inclusion in |- *.
intros.
elim H.
intros.
generalize (le_h_impl_incl_syn (reduce g) h H1).
unfold inclusion in |- *.
intros.
generalize (H3 M N H0).

*****
H3 : forall (M N : Msg) (_ : reduce g M N), synthesis h M N
H2 : le_h h (reduce g)
H1 : le_h (reduce g) h
H0 : reduce g M N
M,N : Msg
H : and (le_h (reduce g) h) (le_h h (reduce g))
g,h : hedge
*****
forall _ : synthesis h M N, h M N
+++++
generalize H0.
-----
Lemma red_equiv_impl_red_incl : forall g h : hedge, equiv_h (reduce g) h -> inclusion (reduce g) h.
unfold equiv_h in |- *.
unfold inclusion in |- *.
intros.
elim H.
intros.
generalize (le_h_impl_incl_syn (reduce g) h H1).
unfold inclusion in |- *.
intros.
generalize (H3 M N H0).
generalize H0.

*****
H3 : forall (M N : Msg) (_ : reduce g M N), synthesis h M N
H2 : le_h h (reduce g)
H1 : le_h (reduce g) h
H0 : reduce g M N
M,N : Msg
H : and (le_h (reduce g) h) (le_h h (reduce g))
g,h : hedge
*****
forall (_ : reduce g M N) (_ : synthesis h M N), h M N
+++++
unfold reduce in |- *.
-----
Lemma red_equiv_impl_red_incl : forall g h : hedge, equiv_h (reduce g) h -> inclusion (reduce g) h.
unfold equiv_h in |- *.
unfold inclusion in |- *.
intros.
elim H.
intros.
generalize (le_h_impl_incl_syn (reduce g) h H1).
unfold inclusion in |- *.
intros.
generalize (H3 M N H0).
generalize H0.
unfold reduce in |- *.

*****
H3 : forall (M N : Msg) (_ : reduce g M N), synthesis h M N
H2 : le_h h (reduce g)
H1 : le_h (reduce g) h
H0 : reduce g M N
M,N : Msg
H : and (le_h (reduce g) h) (le_h h (reduce g))
g,h : hedge
*****
forall (_ : and (g M N) match M with | MNam _ => True | MEnc M' K => match N with | MEnc N' L => or (not (synthesis g M' N')) (not (synthesis g K L)) | _ => True end | MPair M1 M2 => match N with | MPair N1 N2 => or (not (synthesis g M1 N1)) (not (synthesis g M2 N2)) | _ => True end | Mop opM M' => match N with | Mop opN N' => or (not (eq opM opN)) (not (synthesis g M' N')) | _ => True end end) (_ : synthesis h M N), h M N
+++++
case M.
-----
Lemma red_equiv_impl_red_incl : forall g h : hedge, equiv_h (reduce g) h -> inclusion (reduce g) h.
unfold equiv_h in |- *.
unfold inclusion in |- *.
intros.
elim H.
intros.
generalize (le_h_impl_incl_syn (reduce g) h H1).
unfold inclusion in |- *.
intros.
generalize (H3 M N H0).
generalize H0.
unfold reduce in |- *.
case M.

*****
H3 : forall (M N : Msg) (_ : reduce g M N), synthesis h M N
H2 : le_h h (reduce g)
H1 : le_h (reduce g) h
H0 : reduce g M N
M,N : Msg
H : and (le_h (reduce g) h) (le_h h (reduce g))
g,h : hedge
*****
forall (n : Nam) (_ : and (g (MNam n) N) True) (_ : synthesis h (MNam n) N), h (MNam n) N
+++++
intros.
-----
Lemma red_equiv_impl_red_incl : forall g h : hedge, equiv_h (reduce g) h -> inclusion (reduce g) h.
unfold equiv_h in |- *.
unfold inclusion in |- *.
intros.
elim H.
intros.
generalize (le_h_impl_incl_syn (reduce g) h H1).
unfold inclusion in |- *.
intros.
generalize (H3 M N H0).
generalize H0.
unfold reduce in |- *.
case M.
intros.

*****
H5 : synthesis h (MNam n) N
H4 : and (g (MNam n) N) True
n : Nam
H3 : forall (M N : Msg) (_ : reduce g M N), synthesis h M N
H2 : le_h h (reduce g)
H1 : le_h (reduce g) h
H0 : reduce g M N
M,N : Msg
H : and (le_h (reduce g) h) (le_h h (reduce g))
g,h : hedge
*****
h (MNam n) N
+++++
apply nam_left_syn.
-----
Lemma red_equiv_impl_red_incl : forall g h : hedge, equiv_h (reduce g) h -> inclusion (reduce g) h.
unfold equiv_h in |- *.
unfold inclusion in |- *.
intros.
elim H.
intros.
generalize (le_h_impl_incl_syn (reduce g) h H1).
unfold inclusion in |- *.
intros.
generalize (H3 M N H0).
generalize H0.
unfold reduce in |- *.
case M.
intros.
apply nam_left_syn.

*****
H5 : synthesis h (MNam n) N
H4 : and (g (MNam n) N) True
n : Nam
H3 : forall (M N : Msg) (_ : reduce g M N), synthesis h M N
H2 : le_h h (reduce g)
H1 : le_h (reduce g) h
H0 : reduce g M N
M,N : Msg
H : and (le_h (reduce g) h) (le_h h (reduce g))
g,h : hedge
*****
synthesis h (MNam n) N
+++++
trivial.
-----
Lemma red_equiv_impl_red_incl : forall g h : hedge, equiv_h (reduce g) h -> inclusion (reduce g) h.
unfold equiv_h in |- *.
unfold inclusion in |- *.
intros.
elim H.
intros.
generalize (le_h_impl_incl_syn (reduce g) h H1).
unfold inclusion in |- *.
intros.
generalize (H3 M N H0).
generalize H0.
unfold reduce in |- *.
case M.

*****
H3 : forall (M N : Msg) (_ : reduce g M N), synthesis h M N
H2 : le_h h (reduce g)
H1 : le_h (reduce g) h
H0 : reduce g M N
M,N : Msg
H : and (le_h (reduce g) h) (le_h h (reduce g))
g,h : hedge
*****
forall (m m0 : Msg) (_ : and (g (MEnc m m0) N) match N with | MEnc N' L => or (not (synthesis g m N')) (not (synthesis g m0 L)) | _ => True end) (_ : synthesis h (MEnc m m0) N), h (MEnc m m0) N
+++++
case N.
-----
Lemma red_equiv_impl_red_incl : forall g h : hedge, equiv_h (reduce g) h -> inclusion (reduce g) h.
unfold equiv_h in |- *.
unfold inclusion in |- *.
intros.
elim H.
intros.
generalize (le_h_impl_incl_syn (reduce g) h H1).
unfold inclusion in |- *.
intros.
generalize (H3 M N H0).
generalize H0.
unfold reduce in |- *.
case M.
case N.

*****
H3 : forall (M N : Msg) (_ : reduce g M N), synthesis h M N
H2 : le_h h (reduce g)
H1 : le_h (reduce g) h
H0 : reduce g M N
M,N : Msg
H : and (le_h (reduce g) h) (le_h h (reduce g))
g,h : hedge
*****
forall (n : Nam) (m m0 : Msg) (_ : and (g (MEnc m m0) (MNam n)) True) (_ : synthesis h (MEnc m m0) (MNam n)), h (MEnc m m0) (MNam n)
+++++
intros.
-----
Lemma red_equiv_impl_red_incl : forall g h : hedge, equiv_h (reduce g) h -> inclusion (reduce g) h.
unfold equiv_h in |- *.
unfold inclusion in |- *.
intros.
elim H.
intros.
generalize (le_h_impl_incl_syn (reduce g) h H1).
unfold inclusion in |- *.
intros.
generalize (H3 M N H0).
generalize H0.
unfold reduce in |- *.
case M.
case N.
intros.

*****
H5 : synthesis h (MEnc m m0) (MNam n)
H4 : and (g (MEnc m m0) (MNam n)) True
m,m0 : Msg
n : Nam
H3 : forall (M N : Msg) (_ : reduce g M N), synthesis h M N
H2 : le_h h (reduce g)
H1 : le_h (reduce g) h
H0 : reduce g M N
M,N : Msg
H : and (le_h (reduce g) h) (le_h h (reduce g))
g,h : hedge
*****
h (MEnc m m0) (MNam n)
+++++
apply nam_right_syn.
-----
Lemma red_equiv_impl_red_incl : forall g h : hedge, equiv_h (reduce g) h -> inclusion (reduce g) h.
unfold equiv_h in |- *.
unfold inclusion in |- *.
intros.
elim H.
intros.
generalize (le_h_impl_incl_syn (reduce g) h H1).
unfold inclusion in |- *.
intros.
generalize (H3 M N H0).
generalize H0.
unfold reduce in |- *.
case M.
case N.
intros.
apply nam_right_syn.

*****
H5 : synthesis h (MEnc m m0) (MNam n)
H4 : and (g (MEnc m m0) (MNam n)) True
m,m0 : Msg
n : Nam
H3 : forall (M N : Msg) (_ : reduce g M N), synthesis h M N
H2 : le_h h (reduce g)
H1 : le_h (reduce g) h
H0 : reduce g M N
M,N : Msg
H : and (le_h (reduce g) h) (le_h h (reduce g))
g,h : hedge
*****
synthesis h (MEnc m m0) (MNam n)
+++++
trivial.
-----
Lemma red_equiv_impl_red_incl : forall g h : hedge, equiv_h (reduce g) h -> inclusion (reduce g) h.
unfold equiv_h in |- *.
unfold inclusion in |- *.
intros.
elim H.
intros.
generalize (le_h_impl_incl_syn (reduce g) h H1).
unfold inclusion in |- *.
intros.
generalize (H3 M N H0).
generalize H0.
unfold reduce in |- *.
case M.
case N.

*****
H3 : forall (M N : Msg) (_ : reduce g M N), synthesis h M N
H2 : le_h h (reduce g)
H1 : le_h (reduce g) h
H0 : reduce g M N
M,N : Msg
H : and (le_h (reduce g) h) (le_h h (reduce g))
g,h : hedge
*****
forall (m m0 m1 m2 : Msg) (_ : and (g (MEnc m1 m2) (MEnc m m0)) (or (not (synthesis g m1 m)) (not (synthesis g m2 m0)))) (_ : synthesis h (MEnc m1 m2) (MEnc m m0)), h (MEnc m1 m2) (MEnc m m0)
+++++
intros.
-----
Lemma red_equiv_impl_red_incl : forall g h : hedge, equiv_h (reduce g) h -> inclusion (reduce g) h.
unfold equiv_h in |- *.
unfold inclusion in |- *.
intros.
elim H.
intros.
generalize (le_h_impl_incl_syn (reduce g) h H1).
unfold inclusion in |- *.
intros.
generalize (H3 M N H0).
generalize H0.
unfold reduce in |- *.
case M.
case N.
intros.

*****
H5 : synthesis h (MEnc m1 m2) (MEnc m m0)
H4 : and (g (MEnc m1 m2) (MEnc m m0))\n (or (not (synthesis g m1 m)) (not (synthesis g m2 m0)))
m,m0,m1,m2 : Msg
H3 : forall (M N : Msg) (_ : reduce g M N), synthesis h M N
H2 : le_h h (reduce g)
H1 : le_h (reduce g) h
H0 : reduce g M N
M,N : Msg
H : and (le_h (reduce g) h) (le_h h (reduce g))
g,h : hedge
*****
h (MEnc m1 m2) (MEnc m m0)
+++++
elim H4.
-----
Lemma red_equiv_impl_red_incl : forall g h : hedge, equiv_h (reduce g) h -> inclusion (reduce g) h.
unfold equiv_h in |- *.
unfold inclusion in |- *.
intros.
elim H.
intros.
generalize (le_h_impl_incl_syn (reduce g) h H1).
unfold inclusion in |- *.
intros.
generalize (H3 M N H0).
generalize H0.
unfold reduce in |- *.
case M.
case N.
intros.
elim H4.

*****
H5 : synthesis h (MEnc m1 m2) (MEnc m m0)
H4 : and (g (MEnc m1 m2) (MEnc m m0))\n (or (not (synthesis g m1 m)) (not (synthesis g m2 m0)))
m,m0,m1,m2 : Msg
H3 : forall (M N : Msg) (_ : reduce g M N), synthesis h M N
H2 : le_h h (reduce g)
H1 : le_h (reduce g) h
H0 : reduce g M N
M,N : Msg
H : and (le_h (reduce g) h) (le_h h (reduce g))
g,h : hedge
*****
forall (_ : g (MEnc m1 m2) (MEnc m m0)) (_ : or (not (synthesis g m1 m)) (not (synthesis g m2 m0))), h (MEnc m1 m2) (MEnc m m0)
+++++
intros.
-----
Lemma red_equiv_impl_red_incl : forall g h : hedge, equiv_h (reduce g) h -> inclusion (reduce g) h.
unfold equiv_h in |- *.
unfold inclusion in |- *.
intros.
elim H.
intros.
generalize (le_h_impl_incl_syn (reduce g) h H1).
unfold inclusion in |- *.
intros.
generalize (H3 M N H0).
generalize H0.
unfold reduce in |- *.
case M.
case N.
intros.
elim H4.
intros.

*****
H7 : or (not (synthesis g m1 m)) (not (synthesis g m2 m0))
H6 : g (MEnc m1 m2) (MEnc m m0)
H5 : synthesis h (MEnc m1 m2) (MEnc m m0)
H4 : and (g (MEnc m1 m2) (MEnc m m0))\n (or (not (synthesis g m1 m)) (not (synthesis g m2 m0)))
m,m0,m1,m2 : Msg
H3 : forall (M N : Msg) (_ : reduce g M N), synthesis h M N
H2 : le_h h (reduce g)
H1 : le_h (reduce g) h
H0 : reduce g M N
M,N : Msg
H : and (le_h (reduce g) h) (le_h h (reduce g))
g,h : hedge
*****
h (MEnc m1 m2) (MEnc m m0)
+++++
inversion H5.
-----
Lemma red_equiv_impl_red_incl : forall g h : hedge, equiv_h (reduce g) h -> inclusion (reduce g) h.
unfold equiv_h in |- *.
unfold inclusion in |- *.
intros.
elim H.
intros.
generalize (le_h_impl_incl_syn (reduce g) h H1).
unfold inclusion in |- *.
intros.
generalize (H3 M N H0).
generalize H0.
unfold reduce in |- *.
case M.
case N.
intros.
elim H4.
intros.
inversion H5.

*****
H10 : eq N0 (MEnc m m0)
H9 : eq M0 (MEnc m1 m2)
H8 : h (MEnc m1 m2) (MEnc m m0)
M0,N0 : Msg
H7 : or (not (synthesis g m1 m)) (not (synthesis g m2 m0))
H6 : g (MEnc m1 m2) (MEnc m m0)
H5 : synthesis h (MEnc m1 m2) (MEnc m m0)
H4 : and (g (MEnc m1 m2) (MEnc m m0))\n (or (not (synthesis g m1 m)) (not (synthesis g m2 m0)))
m,m0,m1,m2 : Msg
H3 : forall (M N : Msg) (_ : reduce g M N), synthesis h M N
H2 : le_h h (reduce g)
H1 : le_h (reduce g) h
H0 : reduce g M N
M,N : Msg
H : and (le_h (reduce g) h) (le_h h (reduce g))
g,h : hedge
*****
h (MEnc m1 m2) (MEnc m m0)
+++++
trivial.
-----
Lemma red_equiv_impl_red_incl : forall g h : hedge, equiv_h (reduce g) h -> inclusion (reduce g) h.
unfold equiv_h in |- *.
unfold inclusion in |- *.
intros.
elim H.
intros.
generalize (le_h_impl_incl_syn (reduce g) h H1).
unfold inclusion in |- *.
intros.
generalize (H3 M N H0).
generalize H0.
unfold reduce in |- *.
case M.
case N.
intros.
elim H4.
intros.
inversion H5.

*****
H12 : eq L m0
H10 : eq N0 m
H9 : eq K m2
H8 : eq M0 m1
H13 : synthesis h m2 m0
H11 : synthesis h m1 m
M0,N0,K,L : Msg
H7 : or (not (synthesis g m1 m)) (not (synthesis g m2 m0))
H6 : g (MEnc m1 m2) (MEnc m m0)
H5 : synthesis h (MEnc m1 m2) (MEnc m m0)
H4 : and (g (MEnc m1 m2) (MEnc m m0))\n (or (not (synthesis g m1 m)) (not (synthesis g m2 m0)))
m,m0,m1,m2 : Msg
H3 : forall (M N : Msg) (_ : reduce g M N), synthesis h M N
H2 : le_h h (reduce g)
H1 : le_h (reduce g) h
H0 : reduce g M N
M,N : Msg
H : and (le_h (reduce g) h) (le_h h (reduce g))
g,h : hedge
*****
h (MEnc m1 m2) (MEnc m m0)
+++++
case H7.
-----
Lemma red_equiv_impl_red_incl : forall g h : hedge, equiv_h (reduce g) h -> inclusion (reduce g) h.
unfold equiv_h in |- *.
unfold inclusion in |- *.
intros.
elim H.
intros.
generalize (le_h_impl_incl_syn (reduce g) h H1).
unfold inclusion in |- *.
intros.
generalize (H3 M N H0).
generalize H0.
unfold reduce in |- *.
case M.
case N.
intros.
elim H4.
intros.
inversion H5.
case H7.

*****
H12 : eq L m0
H10 : eq N0 m
H9 : eq K m2
H8 : eq M0 m1
H13 : synthesis h m2 m0
H11 : synthesis h m1 m
M0,N0,K,L : Msg
H7 : or (not (synthesis g m1 m)) (not (synthesis g m2 m0))
H6 : g (MEnc m1 m2) (MEnc m m0)
H5 : synthesis h (MEnc m1 m2) (MEnc m m0)
H4 : and (g (MEnc m1 m2) (MEnc m m0))\n (or (not (synthesis g m1 m)) (not (synthesis g m2 m0)))
m,m0,m1,m2 : Msg
H3 : forall (M N : Msg) (_ : reduce g M N), synthesis h M N
H2 : le_h h (reduce g)
H1 : le_h (reduce g) h
H0 : reduce g M N
M,N : Msg
H : and (le_h (reduce g) h) (le_h h (reduce g))
g,h : hedge
*****
forall _ : not (synthesis g m1 m), h (MEnc m1 m2) (MEnc m m0)
+++++
intro.
-----
Lemma red_equiv_impl_red_incl : forall g h : hedge, equiv_h (reduce g) h -> inclusion (reduce g) h.
unfold equiv_h in |- *.
unfold inclusion in |- *.
intros.
elim H.
intros.
generalize (le_h_impl_incl_syn (reduce g) h H1).
unfold inclusion in |- *.
intros.
generalize (H3 M N H0).
generalize H0.
unfold reduce in |- *.
case M.
case N.
intros.
elim H4.
intros.
inversion H5.
case H7.
intro.

*****
H14 : not (synthesis g m1 m)
H12 : eq L m0
H10 : eq N0 m
H9 : eq K m2
H8 : eq M0 m1
H13 : synthesis h m2 m0
H11 : synthesis h m1 m
M0,N0,K,L : Msg
H7 : or (not (synthesis g m1 m)) (not (synthesis g m2 m0))
H6 : g (MEnc m1 m2) (MEnc m m0)
H5 : synthesis h (MEnc m1 m2) (MEnc m m0)
H4 : and (g (MEnc m1 m2) (MEnc m m0))\n (or (not (synthesis g m1 m)) (not (synthesis g m2 m0)))
m,m0,m1,m2 : Msg
H3 : forall (M N : Msg) (_ : reduce g M N), synthesis h M N
H2 : le_h h (reduce g)
H1 : le_h (reduce g) h
H0 : reduce g M N
M,N : Msg
H : and (le_h (reduce g) h) (le_h h (reduce g))
g,h : hedge
*****
h (MEnc m1 m2) (MEnc m m0)
+++++
cut False.
-----
Lemma red_equiv_impl_red_incl : forall g h : hedge, equiv_h (reduce g) h -> inclusion (reduce g) h.
unfold equiv_h in |- *.
unfold inclusion in |- *.
intros.
elim H.
intros.
generalize (le_h_impl_incl_syn (reduce g) h H1).
unfold inclusion in |- *.
intros.
generalize (H3 M N H0).
generalize H0.
unfold reduce in |- *.
case M.
case N.
intros.
elim H4.
intros.
inversion H5.
case H7.
intro.
cut False.

*****
H14 : not (synthesis g m1 m)
H12 : eq L m0
H10 : eq N0 m
H9 : eq K m2
H8 : eq M0 m1
H13 : synthesis h m2 m0
H11 : synthesis h m1 m
M0,N0,K,L : Msg
H7 : or (not (synthesis g m1 m)) (not (synthesis g m2 m0))
H6 : g (MEnc m1 m2) (MEnc m m0)
H5 : synthesis h (MEnc m1 m2) (MEnc m m0)
H4 : and (g (MEnc m1 m2) (MEnc m m0))\n (or (not (synthesis g m1 m)) (not (synthesis g m2 m0)))
m,m0,m1,m2 : Msg
H3 : forall (M N : Msg) (_ : reduce g M N), synthesis h M N
H2 : le_h h (reduce g)
H1 : le_h (reduce g) h
H0 : reduce g M N
M,N : Msg
H : and (le_h (reduce g) h) (le_h h (reduce g))
g,h : hedge
*****
forall _ : False, h (MEnc m1 m2) (MEnc m m0)
+++++
try tauto.
-----
Lemma red_equiv_impl_red_incl : forall g h : hedge, equiv_h (reduce g) h -> inclusion (reduce g) h.
unfold equiv_h in |- *.
unfold inclusion in |- *.
intros.
elim H.
intros.
generalize (le_h_impl_incl_syn (reduce g) h H1).
unfold inclusion in |- *.
intros.
generalize (H3 M N H0).
generalize H0.
unfold reduce in |- *.
case M.
case N.
intros.
elim H4.
intros.
inversion H5.
case H7.
intro.
cut False.

*****
H14 : not (synthesis g m1 m)
H12 : eq L m0
H10 : eq N0 m
H9 : eq K m2
H8 : eq M0 m1
H13 : synthesis h m2 m0
H11 : synthesis h m1 m
M0,N0,K,L : Msg
H7 : or (not (synthesis g m1 m)) (not (synthesis g m2 m0))
H6 : g (MEnc m1 m2) (MEnc m m0)
H5 : synthesis h (MEnc m1 m2) (MEnc m m0)
H4 : and (g (MEnc m1 m2) (MEnc m m0))\n (or (not (synthesis g m1 m)) (not (synthesis g m2 m0)))
m,m0,m1,m2 : Msg
H3 : forall (M N : Msg) (_ : reduce g M N), synthesis h M N
H2 : le_h h (reduce g)
H1 : le_h (reduce g) h
H0 : reduce g M N
M,N : Msg
H : and (le_h (reduce g) h) (le_h h (reduce g))
g,h : hedge
*****
False
+++++
try tauto.
-----
Lemma red_equiv_impl_red_incl : forall g h : hedge, equiv_h (reduce g) h -> inclusion (reduce g) h.
unfold equiv_h in |- *.
unfold inclusion in |- *.
intros.
elim H.
intros.
generalize (le_h_impl_incl_syn (reduce g) h H1).
unfold inclusion in |- *.
intros.
generalize (H3 M N H0).
generalize H0.
unfold reduce in |- *.
case M.
case N.
intros.
elim H4.
intros.
inversion H5.
case H7.
intro.
cut False.
try tauto.

*****
H14 : not (synthesis g m1 m)
H12 : eq L m0
H10 : eq N0 m
H9 : eq K m2
H8 : eq M0 m1
H13 : synthesis h m2 m0
H11 : synthesis h m1 m
M0,N0,K,L : Msg
H7 : or (not (synthesis g m1 m)) (not (synthesis g m2 m0))
H6 : g (MEnc m1 m2) (MEnc m m0)
H5 : synthesis h (MEnc m1 m2) (MEnc m m0)
H4 : and (g (MEnc m1 m2) (MEnc m m0))\n (or (not (synthesis g m1 m)) (not (synthesis g m2 m0)))
m,m0,m1,m2 : Msg
H3 : forall (M N : Msg) (_ : reduce g M N), synthesis h M N
H2 : le_h h (reduce g)
H1 : le_h (reduce g) h
H0 : reduce g M N
M,N : Msg
H : and (le_h (reduce g) h) (le_h h (reduce g))
g,h : hedge
*****
False
+++++
apply H14.
-----
Lemma red_equiv_impl_red_incl : forall g h : hedge, equiv_h (reduce g) h -> inclusion (reduce g) h.
unfold equiv_h in |- *.
unfold inclusion in |- *.
intros.
elim H.
intros.
generalize (le_h_impl_incl_syn (reduce g) h H1).
unfold inclusion in |- *.
intros.
generalize (H3 M N H0).
generalize H0.
unfold reduce in |- *.
case M.
case N.
intros.
elim H4.
intros.
inversion H5.
case H7.
intro.
cut False.
try tauto.
apply H14.

*****
H14 : not (synthesis g m1 m)
H12 : eq L m0
H10 : eq N0 m
H9 : eq K m2
H8 : eq M0 m1
H13 : synthesis h m2 m0
H11 : synthesis h m1 m
M0,N0,K,L : Msg
H7 : or (not (synthesis g m1 m)) (not (synthesis g m2 m0))
H6 : g (MEnc m1 m2) (MEnc m m0)
H5 : synthesis h (MEnc m1 m2) (MEnc m m0)
H4 : and (g (MEnc m1 m2) (MEnc m m0))\n (or (not (synthesis g m1 m)) (not (synthesis g m2 m0)))
m,m0,m1,m2 : Msg
H3 : forall (M N : Msg) (_ : reduce g M N), synthesis h M N
H2 : le_h h (reduce g)
H1 : le_h (reduce g) h
H0 : reduce g M N
M,N : Msg
H : and (le_h (reduce g) h) (le_h h (reduce g))
g,h : hedge
*****
synthesis g m1 m
+++++
generalize (le_h_trans h (reduce g) g H2 (inclusion_impl_le_h (reduce g) g (red_incl_h g))).
-----
Lemma red_equiv_impl_red_incl : forall g h : hedge, equiv_h (reduce g) h -> inclusion (reduce g) h.
unfold equiv_h in |- *.
unfold inclusion in |- *.
intros.
elim H.
intros.
generalize (le_h_impl_incl_syn (reduce g) h H1).
unfold inclusion in |- *.
intros.
generalize (H3 M N H0).
generalize H0.
unfold reduce in |- *.
case M.
case N.
intros.
elim H4.
intros.
inversion H5.
case H7.
intro.
cut False.
try tauto.
apply H14.
generalize (le_h_trans h (reduce g) g H2 (inclusion_impl_le_h (reduce g) g (red_incl_h g))).

*****
H14 : not (synthesis g m1 m)
H12 : eq L m0
H10 : eq N0 m
H9 : eq K m2
H8 : eq M0 m1
H13 : synthesis h m2 m0
H11 : synthesis h m1 m
M0,N0,K,L : Msg
H7 : or (not (synthesis g m1 m)) (not (synthesis g m2 m0))
H6 : g (MEnc m1 m2) (MEnc m m0)
H5 : synthesis h (MEnc m1 m2) (MEnc m m0)
H4 : and (g (MEnc m1 m2) (MEnc m m0))\n (or (not (synthesis g m1 m)) (not (synthesis g m2 m0)))
m,m0,m1,m2 : Msg
H3 : forall (M N : Msg) (_ : reduce g M N), synthesis h M N
H2 : le_h h (reduce g)
H1 : le_h (reduce g) h
H0 : reduce g M N
M,N : Msg
H : and (le_h (reduce g) h) (le_h h (reduce g))
g,h : hedge
*****
forall _ : le_h h g, synthesis g m1 m
+++++
unfold le_h in |- *.
-----
Lemma red_equiv_impl_red_incl : forall g h : hedge, equiv_h (reduce g) h -> inclusion (reduce g) h.
unfold equiv_h in |- *.
unfold inclusion in |- *.
intros.
elim H.
intros.
generalize (le_h_impl_incl_syn (reduce g) h H1).
unfold inclusion in |- *.
intros.
generalize (H3 M N H0).
generalize H0.
unfold reduce in |- *.
case M.
case N.
intros.
elim H4.
intros.
inversion H5.
case H7.
intro.
cut False.
try tauto.
apply H14.
generalize (le_h_trans h (reduce g) g H2 (inclusion_impl_le_h (reduce g) g (red_incl_h g))).
unfold le_h in |- *.

*****
H14 : not (synthesis g m1 m)
H12 : eq L m0
H10 : eq N0 m
H9 : eq K m2
H8 : eq M0 m1
H13 : synthesis h m2 m0
H11 : synthesis h m1 m
M0,N0,K,L : Msg
H7 : or (not (synthesis g m1 m)) (not (synthesis g m2 m0))
H6 : g (MEnc m1 m2) (MEnc m m0)
H5 : synthesis h (MEnc m1 m2) (MEnc m m0)
H4 : and (g (MEnc m1 m2) (MEnc m m0))\n (or (not (synthesis g m1 m)) (not (synthesis g m2 m0)))
m,m0,m1,m2 : Msg
H3 : forall (M N : Msg) (_ : reduce g M N), synthesis h M N
H2 : le_h h (reduce g)
H1 : le_h (reduce g) h
H0 : reduce g M N
M,N : Msg
H : and (le_h (reduce g) h) (le_h h (reduce g))
g,h : hedge
*****
forall _ : inclusion (synthesis h) (synthesis g), synthesis g m1 m
+++++
unfold inclusion in |- *.
-----
Lemma red_equiv_impl_red_incl : forall g h : hedge, equiv_h (reduce g) h -> inclusion (reduce g) h.
unfold equiv_h in |- *.
unfold inclusion in |- *.
intros.
elim H.
intros.
generalize (le_h_impl_incl_syn (reduce g) h H1).
unfold inclusion in |- *.
intros.
generalize (H3 M N H0).
generalize H0.
unfold reduce in |- *.
case M.
case N.
intros.
elim H4.
intros.
inversion H5.
case H7.
intro.
cut False.
try tauto.
apply H14.
generalize (le_h_trans h (reduce g) g H2 (inclusion_impl_le_h (reduce g) g (red_incl_h g))).
unfold le_h in |- *.
unfold inclusion in |- *.

*****
H14 : not (synthesis g m1 m)
H12 : eq L m0
H10 : eq N0 m
H9 : eq K m2
H8 : eq M0 m1
H13 : synthesis h m2 m0
H11 : synthesis h m1 m
M0,N0,K,L : Msg
H7 : or (not (synthesis g m1 m)) (not (synthesis g m2 m0))
H6 : g (MEnc m1 m2) (MEnc m m0)
H5 : synthesis h (MEnc m1 m2) (MEnc m m0)
H4 : and (g (MEnc m1 m2) (MEnc m m0))\n (or (not (synthesis g m1 m)) (not (synthesis g m2 m0)))
m,m0,m1,m2 : Msg
H3 : forall (M N : Msg) (_ : reduce g M N), synthesis h M N
H2 : le_h h (reduce g)
H1 : le_h (reduce g) h
H0 : reduce g M N
M,N : Msg
H : and (le_h (reduce g) h) (le_h h (reduce g))
g,h : hedge
*****
forall _ : forall (M N : Msg) (_ : synthesis h M N), synthesis g M N, synthesis g m1 m
+++++
auto.
-----
Lemma red_equiv_impl_red_incl : forall g h : hedge, equiv_h (reduce g) h -> inclusion (reduce g) h.
unfold equiv_h in |- *.
unfold inclusion in |- *.
intros.
elim H.
intros.
generalize (le_h_impl_incl_syn (reduce g) h H1).
unfold inclusion in |- *.
intros.
generalize (H3 M N H0).
generalize H0.
unfold reduce in |- *.
case M.
case N.
intros.
elim H4.
intros.
inversion H5.
case H7.

*****
H12 : eq L m0
H10 : eq N0 m
H9 : eq K m2
H8 : eq M0 m1
H13 : synthesis h m2 m0
H11 : synthesis h m1 m
M0,N0,K,L : Msg
H7 : or (not (synthesis g m1 m)) (not (synthesis g m2 m0))
H6 : g (MEnc m1 m2) (MEnc m m0)
H5 : synthesis h (MEnc m1 m2) (MEnc m m0)
H4 : and (g (MEnc m1 m2) (MEnc m m0))\n (or (not (synthesis g m1 m)) (not (synthesis g m2 m0)))
m,m0,m1,m2 : Msg
H3 : forall (M N : Msg) (_ : reduce g M N), synthesis h M N
H2 : le_h h (reduce g)
H1 : le_h (reduce g) h
H0 : reduce g M N
M,N : Msg
H : and (le_h (reduce g) h) (le_h h (reduce g))
g,h : hedge
*****
forall _ : not (synthesis g m2 m0), h (MEnc m1 m2) (MEnc m m0)
+++++
intro.
-----
Lemma red_equiv_impl_red_incl : forall g h : hedge, equiv_h (reduce g) h -> inclusion (reduce g) h.
unfold equiv_h in |- *.
unfold inclusion in |- *.
intros.
elim H.
intros.
generalize (le_h_impl_incl_syn (reduce g) h H1).
unfold inclusion in |- *.
intros.
generalize (H3 M N H0).
generalize H0.
unfold reduce in |- *.
case M.
case N.
intros.
elim H4.
intros.
inversion H5.
case H7.
intro.

*****
H14 : not (synthesis g m2 m0)
H12 : eq L m0
H10 : eq N0 m
H9 : eq K m2
H8 : eq M0 m1
H13 : synthesis h m2 m0
H11 : synthesis h m1 m
M0,N0,K,L : Msg
H7 : or (not (synthesis g m1 m)) (not (synthesis g m2 m0))
H6 : g (MEnc m1 m2) (MEnc m m0)
H5 : synthesis h (MEnc m1 m2) (MEnc m m0)
H4 : and (g (MEnc m1 m2) (MEnc m m0))\n (or (not (synthesis g m1 m)) (not (synthesis g m2 m0)))
m,m0,m1,m2 : Msg
H3 : forall (M N : Msg) (_ : reduce g M N), synthesis h M N
H2 : le_h h (reduce g)
H1 : le_h (reduce g) h
H0 : reduce g M N
M,N : Msg
H : and (le_h (reduce g) h) (le_h h (reduce g))
g,h : hedge
*****
h (MEnc m1 m2) (MEnc m m0)
+++++
cut False.
-----
Lemma red_equiv_impl_red_incl : forall g h : hedge, equiv_h (reduce g) h -> inclusion (reduce g) h.
unfold equiv_h in |- *.
unfold inclusion in |- *.
intros.
elim H.
intros.
generalize (le_h_impl_incl_syn (reduce g) h H1).
unfold inclusion in |- *.
intros.
generalize (H3 M N H0).
generalize H0.
unfold reduce in |- *.
case M.
case N.
intros.
elim H4.
intros.
inversion H5.
case H7.
intro.
cut False.

*****
H14 : not (synthesis g m2 m0)
H12 : eq L m0
H10 : eq N0 m
H9 : eq K m2
H8 : eq M0 m1
H13 : synthesis h m2 m0
H11 : synthesis h m1 m
M0,N0,K,L : Msg
H7 : or (not (synthesis g m1 m)) (not (synthesis g m2 m0))
H6 : g (MEnc m1 m2) (MEnc m m0)
H5 : synthesis h (MEnc m1 m2) (MEnc m m0)
H4 : and (g (MEnc m1 m2) (MEnc m m0))\n (or (not (synthesis g m1 m)) (not (synthesis g m2 m0)))
m,m0,m1,m2 : Msg
H3 : forall (M N : Msg) (_ : reduce g M N), synthesis h M N
H2 : le_h h (reduce g)
H1 : le_h (reduce g) h
H0 : reduce g M N
M,N : Msg
H : and (le_h (reduce g) h) (le_h h (reduce g))
g,h : hedge
*****
forall _ : False, h (MEnc m1 m2) (MEnc m m0)
+++++
try tauto.
-----
Lemma red_equiv_impl_red_incl : forall g h : hedge, equiv_h (reduce g) h -> inclusion (reduce g) h.
unfold equiv_h in |- *.
unfold inclusion in |- *.
intros.
elim H.
intros.
generalize (le_h_impl_incl_syn (reduce g) h H1).
unfold inclusion in |- *.
intros.
generalize (H3 M N H0).
generalize H0.
unfold reduce in |- *.
case M.
case N.
intros.
elim H4.
intros.
inversion H5.
case H7.
intro.
cut False.

*****
H14 : not (synthesis g m2 m0)
H12 : eq L m0
H10 : eq N0 m
H9 : eq K m2
H8 : eq M0 m1
H13 : synthesis h m2 m0
H11 : synthesis h m1 m
M0,N0,K,L : Msg
H7 : or (not (synthesis g m1 m)) (not (synthesis g m2 m0))
H6 : g (MEnc m1 m2) (MEnc m m0)
H5 : synthesis h (MEnc m1 m2) (MEnc m m0)
H4 : and (g (MEnc m1 m2) (MEnc m m0))\n (or (not (synthesis g m1 m)) (not (synthesis g m2 m0)))
m,m0,m1,m2 : Msg
H3 : forall (M N : Msg) (_ : reduce g M N), synthesis h M N
H2 : le_h h (reduce g)
H1 : le_h (reduce g) h
H0 : reduce g M N
M,N : Msg
H : and (le_h (reduce g) h) (le_h h (reduce g))
g,h : hedge
*****
False
+++++
try tauto.
-----
Lemma red_equiv_impl_red_incl : forall g h : hedge, equiv_h (reduce g) h -> inclusion (reduce g) h.
unfold equiv_h in |- *.
unfold inclusion in |- *.
intros.
elim H.
intros.
generalize (le_h_impl_incl_syn (reduce g) h H1).
unfold inclusion in |- *.
intros.
generalize (H3 M N H0).
generalize H0.
unfold reduce in |- *.
case M.
case N.
intros.
elim H4.
intros.
inversion H5.
case H7.
intro.
cut False.
try tauto.

*****
H14 : not (synthesis g m2 m0)
H12 : eq L m0
H10 : eq N0 m
H9 : eq K m2
H8 : eq M0 m1
H13 : synthesis h m2 m0
H11 : synthesis h m1 m
M0,N0,K,L : Msg
H7 : or (not (synthesis g m1 m)) (not (synthesis g m2 m0))
H6 : g (MEnc m1 m2) (MEnc m m0)
H5 : synthesis h (MEnc m1 m2) (MEnc m m0)
H4 : and (g (MEnc m1 m2) (MEnc m m0))\n (or (not (synthesis g m1 m)) (not (synthesis g m2 m0)))
m,m0,m1,m2 : Msg
H3 : forall (M N : Msg) (_ : reduce g M N), synthesis h M N
H2 : le_h h (reduce g)
H1 : le_h (reduce g) h
H0 : reduce g M N
M,N : Msg
H : and (le_h (reduce g) h) (le_h h (reduce g))
g,h : hedge
*****
False
+++++
apply H14.
-----
Lemma red_equiv_impl_red_incl : forall g h : hedge, equiv_h (reduce g) h -> inclusion (reduce g) h.
unfold equiv_h in |- *.
unfold inclusion in |- *.
intros.
elim H.
intros.
generalize (le_h_impl_incl_syn (reduce g) h H1).
unfold inclusion in |- *.
intros.
generalize (H3 M N H0).
generalize H0.
unfold reduce in |- *.
case M.
case N.
intros.
elim H4.
intros.
inversion H5.
case H7.
intro.
cut False.
try tauto.
apply H14.

*****
H14 : not (synthesis g m2 m0)
H12 : eq L m0
H10 : eq N0 m
H9 : eq K m2
H8 : eq M0 m1
H13 : synthesis h m2 m0
H11 : synthesis h m1 m
M0,N0,K,L : Msg
H7 : or (not (synthesis g m1 m)) (not (synthesis g m2 m0))
H6 : g (MEnc m1 m2) (MEnc m m0)
H5 : synthesis h (MEnc m1 m2) (MEnc m m0)
H4 : and (g (MEnc m1 m2) (MEnc m m0))\n (or (not (synthesis g m1 m)) (not (synthesis g m2 m0)))
m,m0,m1,m2 : Msg
H3 : forall (M N : Msg) (_ : reduce g M N), synthesis h M N
H2 : le_h h (reduce g)
H1 : le_h (reduce g) h
H0 : reduce g M N
M,N : Msg
H : and (le_h (reduce g) h) (le_h h (reduce g))
g,h : hedge
*****
synthesis g m2 m0
+++++
generalize (le_h_trans h (reduce g) g H2 (inclusion_impl_le_h (reduce g) g (red_incl_h g))).
-----
Lemma red_equiv_impl_red_incl : forall g h : hedge, equiv_h (reduce g) h -> inclusion (reduce g) h.
unfold equiv_h in |- *.
unfold inclusion in |- *.
intros.
elim H.
intros.
generalize (le_h_impl_incl_syn (reduce g) h H1).
unfold inclusion in |- *.
intros.
generalize (H3 M N H0).
generalize H0.
unfold reduce in |- *.
case M.
case N.
intros.
elim H4.
intros.
inversion H5.
case H7.
intro.
cut False.
try tauto.
apply H14.
generalize (le_h_trans h (reduce g) g H2 (inclusion_impl_le_h (reduce g) g (red_incl_h g))).

*****
H14 : not (synthesis g m2 m0)
H12 : eq L m0
H10 : eq N0 m
H9 : eq K m2
H8 : eq M0 m1
H13 : synthesis h m2 m0
H11 : synthesis h m1 m
M0,N0,K,L : Msg
H7 : or (not (synthesis g m1 m)) (not (synthesis g m2 m0))
H6 : g (MEnc m1 m2) (MEnc m m0)
H5 : synthesis h (MEnc m1 m2) (MEnc m m0)
H4 : and (g (MEnc m1 m2) (MEnc m m0))\n (or (not (synthesis g m1 m)) (not (synthesis g m2 m0)))
m,m0,m1,m2 : Msg
H3 : forall (M N : Msg) (_ : reduce g M N), synthesis h M N
H2 : le_h h (reduce g)
H1 : le_h (reduce g) h
H0 : reduce g M N
M,N : Msg
H : and (le_h (reduce g) h) (le_h h (reduce g))
g,h : hedge
*****
forall _ : le_h h g, synthesis g m2 m0
+++++
unfold le_h in |- *.
-----
Lemma red_equiv_impl_red_incl : forall g h : hedge, equiv_h (reduce g) h -> inclusion (reduce g) h.
unfold equiv_h in |- *.
unfold inclusion in |- *.
intros.
elim H.
intros.
generalize (le_h_impl_incl_syn (reduce g) h H1).
unfold inclusion in |- *.
intros.
generalize (H3 M N H0).
generalize H0.
unfold reduce in |- *.
case M.
case N.
intros.
elim H4.
intros.
inversion H5.
case H7.
intro.
cut False.
try tauto.
apply H14.
generalize (le_h_trans h (reduce g) g H2 (inclusion_impl_le_h (reduce g) g (red_incl_h g))).
unfold le_h in |- *.

*****
H14 : not (synthesis g m2 m0)
H12 : eq L m0
H10 : eq N0 m
H9 : eq K m2
H8 : eq M0 m1
H13 : synthesis h m2 m0
H11 : synthesis h m1 m
M0,N0,K,L : Msg
H7 : or (not (synthesis g m1 m)) (not (synthesis g m2 m0))
H6 : g (MEnc m1 m2) (MEnc m m0)
H5 : synthesis h (MEnc m1 m2) (MEnc m m0)
H4 : and (g (MEnc m1 m2) (MEnc m m0))\n (or (not (synthesis g m1 m)) (not (synthesis g m2 m0)))
m,m0,m1,m2 : Msg
H3 : forall (M N : Msg) (_ : reduce g M N), synthesis h M N
H2 : le_h h (reduce g)
H1 : le_h (reduce g) h
H0 : reduce g M N
M,N : Msg
H : and (le_h (reduce g) h) (le_h h (reduce g))
g,h : hedge
*****
forall _ : inclusion (synthesis h) (synthesis g), synthesis g m2 m0
+++++
unfold inclusion in |- *.
-----
Lemma red_equiv_impl_red_incl : forall g h : hedge, equiv_h (reduce g) h -> inclusion (reduce g) h.
unfold equiv_h in |- *.
unfold inclusion in |- *.
intros.
elim H.
intros.
generalize (le_h_impl_incl_syn (reduce g) h H1).
unfold inclusion in |- *.
intros.
generalize (H3 M N H0).
generalize H0.
unfold reduce in |- *.
case M.
case N.
intros.
elim H4.
intros.
inversion H5.
case H7.
intro.
cut False.
try tauto.
apply H14.
generalize (le_h_trans h (reduce g) g H2 (inclusion_impl_le_h (reduce g) g (red_incl_h g))).
unfold le_h in |- *.
unfold inclusion in |- *.

*****
H14 : not (synthesis g m2 m0)
H12 : eq L m0
H10 : eq N0 m
H9 : eq K m2
H8 : eq M0 m1
H13 : synthesis h m2 m0
H11 : synthesis h m1 m
M0,N0,K,L : Msg
H7 : or (not (synthesis g m1 m)) (not (synthesis g m2 m0))
H6 : g (MEnc m1 m2) (MEnc m m0)
H5 : synthesis h (MEnc m1 m2) (MEnc m m0)
H4 : and (g (MEnc m1 m2) (MEnc m m0))\n (or (not (synthesis g m1 m)) (not (synthesis g m2 m0)))
m,m0,m1,m2 : Msg
H3 : forall (M N : Msg) (_ : reduce g M N), synthesis h M N
H2 : le_h h (reduce g)
H1 : le_h (reduce g) h
H0 : reduce g M N
M,N : Msg
H : and (le_h (reduce g) h) (le_h h (reduce g))
g,h : hedge
*****
forall _ : forall (M N : Msg) (_ : synthesis h M N), synthesis g M N, synthesis g m2 m0
+++++
auto.
-----
Lemma red_equiv_impl_red_incl : forall g h : hedge, equiv_h (reduce g) h -> inclusion (reduce g) h.
unfold equiv_h in |- *.
unfold inclusion in |- *.
intros.
elim H.
intros.
generalize (le_h_impl_incl_syn (reduce g) h H1).
unfold inclusion in |- *.
intros.
generalize (H3 M N H0).
generalize H0.
unfold reduce in |- *.
case M.
case N.

*****
H3 : forall (M N : Msg) (_ : reduce g M N), synthesis h M N
H2 : le_h h (reduce g)
H1 : le_h (reduce g) h
H0 : reduce g M N
M,N : Msg
H : and (le_h (reduce g) h) (le_h h (reduce g))
g,h : hedge
*****
forall (m m0 m1 m2 : Msg) (_ : and (g (MEnc m1 m2) (MPair m m0)) True) (_ : synthesis h (MEnc m1 m2) (MPair m m0)), h (MEnc m1 m2) (MPair m m0)
+++++
intros.
-----
Lemma red_equiv_impl_red_incl : forall g h : hedge, equiv_h (reduce g) h -> inclusion (reduce g) h.
unfold equiv_h in |- *.
unfold inclusion in |- *.
intros.
elim H.
intros.
generalize (le_h_impl_incl_syn (reduce g) h H1).
unfold inclusion in |- *.
intros.
generalize (H3 M N H0).
generalize H0.
unfold reduce in |- *.
case M.
case N.
intros.

*****
H5 : synthesis h (MEnc m1 m2) (MPair m m0)
H4 : and (g (MEnc m1 m2) (MPair m m0)) True
m,m0,m1,m2 : Msg
H3 : forall (M N : Msg) (_ : reduce g M N), synthesis h M N
H2 : le_h h (reduce g)
H1 : le_h (reduce g) h
H0 : reduce g M N
M,N : Msg
H : and (le_h (reduce g) h) (le_h h (reduce g))
g,h : hedge
*****
h (MEnc m1 m2) (MPair m m0)
+++++
inversion H5.
-----
Lemma red_equiv_impl_red_incl : forall g h : hedge, equiv_h (reduce g) h -> inclusion (reduce g) h.
unfold equiv_h in |- *.
unfold inclusion in |- *.
intros.
elim H.
intros.
generalize (le_h_impl_incl_syn (reduce g) h H1).
unfold inclusion in |- *.
intros.
generalize (H3 M N H0).
generalize H0.
unfold reduce in |- *.
case M.
case N.
intros.
inversion H5.

*****
H8 : eq N0 (MPair m m0)
H7 : eq M0 (MEnc m1 m2)
H6 : h (MEnc m1 m2) (MPair m m0)
M0,N0 : Msg
H5 : synthesis h (MEnc m1 m2) (MPair m m0)
H4 : and (g (MEnc m1 m2) (MPair m m0)) True
m,m0,m1,m2 : Msg
H3 : forall (M N : Msg) (_ : reduce g M N), synthesis h M N
H2 : le_h h (reduce g)
H1 : le_h (reduce g) h
H0 : reduce g M N
M,N : Msg
H : and (le_h (reduce g) h) (le_h h (reduce g))
g,h : hedge
*****
h (MEnc m1 m2) (MPair m m0)
+++++
trivial.
-----
Lemma red_equiv_impl_red_incl : forall g h : hedge, equiv_h (reduce g) h -> inclusion (reduce g) h.
unfold equiv_h in |- *.
unfold inclusion in |- *.
intros.
elim H.
intros.
generalize (le_h_impl_incl_syn (reduce g) h H1).
unfold inclusion in |- *.
intros.
generalize (H3 M N H0).
generalize H0.
unfold reduce in |- *.
case M.
case N.

*****
H3 : forall (M N : Msg) (_ : reduce g M N), synthesis h M N
H2 : le_h h (reduce g)
H1 : le_h (reduce g) h
H0 : reduce g M N
M,N : Msg
H : and (le_h (reduce g) h) (le_h h (reduce g))
g,h : hedge
*****
forall (o : op) (m m0 m1 : Msg) (_ : and (g (MEnc m0 m1) (Mop o m)) True) (_ : synthesis h (MEnc m0 m1) (Mop o m)), h (MEnc m0 m1) (Mop o m)
+++++
intros.
-----
Lemma red_equiv_impl_red_incl : forall g h : hedge, equiv_h (reduce g) h -> inclusion (reduce g) h.
unfold equiv_h in |- *.
unfold inclusion in |- *.
intros.
elim H.
intros.
generalize (le_h_impl_incl_syn (reduce g) h H1).
unfold inclusion in |- *.
intros.
generalize (H3 M N H0).
generalize H0.
unfold reduce in |- *.
case M.
case N.
intros.

*****
H5 : synthesis h (MEnc m0 m1) (Mop o m)
H4 : and (g (MEnc m0 m1) (Mop o m)) True
m,m0,m1 : Msg
o : op
H3 : forall (M N : Msg) (_ : reduce g M N), synthesis h M N
H2 : le_h h (reduce g)
H1 : le_h (reduce g) h
H0 : reduce g M N
M,N : Msg
H : and (le_h (reduce g) h) (le_h h (reduce g))
g,h : hedge
*****
h (MEnc m0 m1) (Mop o m)
+++++
inversion H5.
-----
Lemma red_equiv_impl_red_incl : forall g h : hedge, equiv_h (reduce g) h -> inclusion (reduce g) h.
unfold equiv_h in |- *.
unfold inclusion in |- *.
intros.
elim H.
intros.
generalize (le_h_impl_incl_syn (reduce g) h H1).
unfold inclusion in |- *.
intros.
generalize (H3 M N H0).
generalize H0.
unfold reduce in |- *.
case M.
case N.
intros.
inversion H5.

*****
H8 : eq N0 (Mop o m)
H7 : eq M0 (MEnc m0 m1)
H6 : h (MEnc m0 m1) (Mop o m)
M0,N0 : Msg
H5 : synthesis h (MEnc m0 m1) (Mop o m)
H4 : and (g (MEnc m0 m1) (Mop o m)) True
m,m0,m1 : Msg
o : op
H3 : forall (M N : Msg) (_ : reduce g M N), synthesis h M N
H2 : le_h h (reduce g)
H1 : le_h (reduce g) h
H0 : reduce g M N
M,N : Msg
H : and (le_h (reduce g) h) (le_h h (reduce g))
g,h : hedge
*****
h (MEnc m0 m1) (Mop o m)
+++++
trivial.
-----
Lemma red_equiv_impl_red_incl : forall g h : hedge, equiv_h (reduce g) h -> inclusion (reduce g) h.
unfold equiv_h in |- *.
unfold inclusion in |- *.
intros.
elim H.
intros.
generalize (le_h_impl_incl_syn (reduce g) h H1).
unfold inclusion in |- *.
intros.
generalize (H3 M N H0).
generalize H0.
unfold reduce in |- *.
case M.

*****
H3 : forall (M N : Msg) (_ : reduce g M N), synthesis h M N
H2 : le_h h (reduce g)
H1 : le_h (reduce g) h
H0 : reduce g M N
M,N : Msg
H : and (le_h (reduce g) h) (le_h h (reduce g))
g,h : hedge
*****
forall (m m0 : Msg) (_ : and (g (MPair m m0) N) match N with | MPair N1 N2 => or (not (synthesis g m N1)) (not (synthesis g m0 N2)) | _ => True end) (_ : synthesis h (MPair m m0) N), h (MPair m m0) N
+++++
case N.
-----
Lemma red_equiv_impl_red_incl : forall g h : hedge, equiv_h (reduce g) h -> inclusion (reduce g) h.
unfold equiv_h in |- *.
unfold inclusion in |- *.
intros.
elim H.
intros.
generalize (le_h_impl_incl_syn (reduce g) h H1).
unfold inclusion in |- *.
intros.
generalize (H3 M N H0).
generalize H0.
unfold reduce in |- *.
case M.
case N.

*****
H3 : forall (M N : Msg) (_ : reduce g M N), synthesis h M N
H2 : le_h h (reduce g)
H1 : le_h (reduce g) h
H0 : reduce g M N
M,N : Msg
H : and (le_h (reduce g) h) (le_h h (reduce g))
g,h : hedge
*****
forall (n : Nam) (m m0 : Msg) (_ : and (g (MPair m m0) (MNam n)) True) (_ : synthesis h (MPair m m0) (MNam n)), h (MPair m m0) (MNam n)
+++++
intros.
-----
Lemma red_equiv_impl_red_incl : forall g h : hedge, equiv_h (reduce g) h -> inclusion (reduce g) h.
unfold equiv_h in |- *.
unfold inclusion in |- *.
intros.
elim H.
intros.
generalize (le_h_impl_incl_syn (reduce g) h H1).
unfold inclusion in |- *.
intros.
generalize (H3 M N H0).
generalize H0.
unfold reduce in |- *.
case M.
case N.
intros.

*****
H5 : synthesis h (MPair m m0) (MNam n)
H4 : and (g (MPair m m0) (MNam n)) True
m,m0 : Msg
n : Nam
H3 : forall (M N : Msg) (_ : reduce g M N), synthesis h M N
H2 : le_h h (reduce g)
H1 : le_h (reduce g) h
H0 : reduce g M N
M,N : Msg
H : and (le_h (reduce g) h) (le_h h (reduce g))
g,h : hedge
*****
h (MPair m m0) (MNam n)
+++++
inversion H5.
-----
Lemma red_equiv_impl_red_incl : forall g h : hedge, equiv_h (reduce g) h -> inclusion (reduce g) h.
unfold equiv_h in |- *.
unfold inclusion in |- *.
intros.
elim H.
intros.
generalize (le_h_impl_incl_syn (reduce g) h H1).
unfold inclusion in |- *.
intros.
generalize (H3 M N H0).
generalize H0.
unfold reduce in |- *.
case M.
case N.
intros.
inversion H5.

*****
H8 : eq N0 (MNam n)
H7 : eq M0 (MPair m m0)
H6 : h (MPair m m0) (MNam n)
M0,N0 : Msg
H5 : synthesis h (MPair m m0) (MNam n)
H4 : and (g (MPair m m0) (MNam n)) True
m,m0 : Msg
n : Nam
H3 : forall (M N : Msg) (_ : reduce g M N), synthesis h M N
H2 : le_h h (reduce g)
H1 : le_h (reduce g) h
H0 : reduce g M N
M,N : Msg
H : and (le_h (reduce g) h) (le_h h (reduce g))
g,h : hedge
*****
h (MPair m m0) (MNam n)
+++++
trivial.
-----
Lemma red_equiv_impl_red_incl : forall g h : hedge, equiv_h (reduce g) h -> inclusion (reduce g) h.
unfold equiv_h in |- *.
unfold inclusion in |- *.
intros.
elim H.
intros.
generalize (le_h_impl_incl_syn (reduce g) h H1).
unfold inclusion in |- *.
intros.
generalize (H3 M N H0).
generalize H0.
unfold reduce in |- *.
case M.
case N.

*****
H3 : forall (M N : Msg) (_ : reduce g M N), synthesis h M N
H2 : le_h h (reduce g)
H1 : le_h (reduce g) h
H0 : reduce g M N
M,N : Msg
H : and (le_h (reduce g) h) (le_h h (reduce g))
g,h : hedge
*****
forall (m m0 m1 m2 : Msg) (_ : and (g (MPair m1 m2) (MEnc m m0)) True) (_ : synthesis h (MPair m1 m2) (MEnc m m0)), h (MPair m1 m2) (MEnc m m0)
+++++
intros.
-----
Lemma red_equiv_impl_red_incl : forall g h : hedge, equiv_h (reduce g) h -> inclusion (reduce g) h.
unfold equiv_h in |- *.
unfold inclusion in |- *.
intros.
elim H.
intros.
generalize (le_h_impl_incl_syn (reduce g) h H1).
unfold inclusion in |- *.
intros.
generalize (H3 M N H0).
generalize H0.
unfold reduce in |- *.
case M.
case N.
intros.

*****
H5 : synthesis h (MPair m1 m2) (MEnc m m0)
H4 : and (g (MPair m1 m2) (MEnc m m0)) True
m,m0,m1,m2 : Msg
H3 : forall (M N : Msg) (_ : reduce g M N), synthesis h M N
H2 : le_h h (reduce g)
H1 : le_h (reduce g) h
H0 : reduce g M N
M,N : Msg
H : and (le_h (reduce g) h) (le_h h (reduce g))
g,h : hedge
*****
h (MPair m1 m2) (MEnc m m0)
+++++
inversion H5.
-----
Lemma red_equiv_impl_red_incl : forall g h : hedge, equiv_h (reduce g) h -> inclusion (reduce g) h.
unfold equiv_h in |- *.
unfold inclusion in |- *.
intros.
elim H.
intros.
generalize (le_h_impl_incl_syn (reduce g) h H1).
unfold inclusion in |- *.
intros.
generalize (H3 M N H0).
generalize H0.
unfold reduce in |- *.
case M.
case N.
intros.
inversion H5.

*****
H8 : eq N0 (MEnc m m0)
H7 : eq M0 (MPair m1 m2)
H6 : h (MPair m1 m2) (MEnc m m0)
M0,N0 : Msg
H5 : synthesis h (MPair m1 m2) (MEnc m m0)
H4 : and (g (MPair m1 m2) (MEnc m m0)) True
m,m0,m1,m2 : Msg
H3 : forall (M N : Msg) (_ : reduce g M N), synthesis h M N
H2 : le_h h (reduce g)
H1 : le_h (reduce g) h
H0 : reduce g M N
M,N : Msg
H : and (le_h (reduce g) h) (le_h h (reduce g))
g,h : hedge
*****
h (MPair m1 m2) (MEnc m m0)
+++++
trivial.
-----
Lemma red_equiv_impl_red_incl : forall g h : hedge, equiv_h (reduce g) h -> inclusion (reduce g) h.
unfold equiv_h in |- *.
unfold inclusion in |- *.
intros.
elim H.
intros.
generalize (le_h_impl_incl_syn (reduce g) h H1).
unfold inclusion in |- *.
intros.
generalize (H3 M N H0).
generalize H0.
unfold reduce in |- *.
case M.
case N.

*****
H3 : forall (M N : Msg) (_ : reduce g M N), synthesis h M N
H2 : le_h h (reduce g)
H1 : le_h (reduce g) h
H0 : reduce g M N
M,N : Msg
H : and (le_h (reduce g) h) (le_h h (reduce g))
g,h : hedge
*****
forall (m m0 m1 m2 : Msg) (_ : and (g (MPair m1 m2) (MPair m m0)) (or (not (synthesis g m1 m)) (not (synthesis g m2 m0)))) (_ : synthesis h (MPair m1 m2) (MPair m m0)), h (MPair m1 m2) (MPair m m0)
+++++
intros.
-----
Lemma red_equiv_impl_red_incl : forall g h : hedge, equiv_h (reduce g) h -> inclusion (reduce g) h.
unfold equiv_h in |- *.
unfold inclusion in |- *.
intros.
elim H.
intros.
generalize (le_h_impl_incl_syn (reduce g) h H1).
unfold inclusion in |- *.
intros.
generalize (H3 M N H0).
generalize H0.
unfold reduce in |- *.
case M.
case N.
intros.

*****
H5 : synthesis h (MPair m1 m2) (MPair m m0)
H4 : and (g (MPair m1 m2) (MPair m m0))\n (or (not (synthesis g m1 m)) (not (synthesis g m2 m0)))
m,m0,m1,m2 : Msg
H3 : forall (M N : Msg) (_ : reduce g M N), synthesis h M N
H2 : le_h h (reduce g)
H1 : le_h (reduce g) h
H0 : reduce g M N
M,N : Msg
H : and (le_h (reduce g) h) (le_h h (reduce g))
g,h : hedge
*****
h (MPair m1 m2) (MPair m m0)
+++++
inversion H5.
-----
Lemma red_equiv_impl_red_incl : forall g h : hedge, equiv_h (reduce g) h -> inclusion (reduce g) h.
unfold equiv_h in |- *.
unfold inclusion in |- *.
intros.
elim H.
intros.
generalize (le_h_impl_incl_syn (reduce g) h H1).
unfold inclusion in |- *.
intros.
generalize (H3 M N H0).
generalize H0.
unfold reduce in |- *.
case M.
case N.
intros.
inversion H5.

*****
H8 : eq N0 (MPair m m0)
H7 : eq M0 (MPair m1 m2)
H6 : h (MPair m1 m2) (MPair m m0)
M0,N0 : Msg
H5 : synthesis h (MPair m1 m2) (MPair m m0)
H4 : and (g (MPair m1 m2) (MPair m m0))\n (or (not (synthesis g m1 m)) (not (synthesis g m2 m0)))
m,m0,m1,m2 : Msg
H3 : forall (M N : Msg) (_ : reduce g M N), synthesis h M N
H2 : le_h h (reduce g)
H1 : le_h (reduce g) h
H0 : reduce g M N
M,N : Msg
H : and (le_h (reduce g) h) (le_h h (reduce g))
g,h : hedge
*****
h (MPair m1 m2) (MPair m m0)
+++++
trivial.
-----
Lemma red_equiv_impl_red_incl : forall g h : hedge, equiv_h (reduce g) h -> inclusion (reduce g) h.
unfold equiv_h in |- *.
unfold inclusion in |- *.
intros.
elim H.
intros.
generalize (le_h_impl_incl_syn (reduce g) h H1).
unfold inclusion in |- *.
intros.
generalize (H3 M N H0).
generalize H0.
unfold reduce in |- *.
case M.
case N.
intros.
inversion H5.

*****
H10 : eq N2 m0
H8 : eq N1 m
H7 : eq M2 m2
H6 : eq M1 m1
H11 : synthesis h m2 m0
H9 : synthesis h m1 m
M1,N1,M2,N2 : Msg
H5 : synthesis h (MPair m1 m2) (MPair m m0)
H4 : and (g (MPair m1 m2) (MPair m m0))\n (or (not (synthesis g m1 m)) (not (synthesis g m2 m0)))
m,m0,m1,m2 : Msg
H3 : forall (M N : Msg) (_ : reduce g M N), synthesis h M N
H2 : le_h h (reduce g)
H1 : le_h (reduce g) h
H0 : reduce g M N
M,N : Msg
H : and (le_h (reduce g) h) (le_h h (reduce g))
g,h : hedge
*****
h (MPair m1 m2) (MPair m m0)
+++++
trivial.
-----
Lemma red_equiv_impl_red_incl : forall g h : hedge, equiv_h (reduce g) h -> inclusion (reduce g) h.
unfold equiv_h in |- *.
unfold inclusion in |- *.
intros.
elim H.
intros.
generalize (le_h_impl_incl_syn (reduce g) h H1).
unfold inclusion in |- *.
intros.
generalize (H3 M N H0).
generalize H0.
unfold reduce in |- *.
case M.
case N.
intros.
inversion H5.
trivial.

*****
H10 : eq N2 m0
H8 : eq N1 m
H7 : eq M2 m2
H6 : eq M1 m1
H11 : synthesis h m2 m0
H9 : synthesis h m1 m
M1,N1,M2,N2 : Msg
H5 : synthesis h (MPair m1 m2) (MPair m m0)
H4 : and (g (MPair m1 m2) (MPair m m0))\n (or (not (synthesis g m1 m)) (not (synthesis g m2 m0)))
m,m0,m1,m2 : Msg
H3 : forall (M N : Msg) (_ : reduce g M N), synthesis h M N
H2 : le_h h (reduce g)
H1 : le_h (reduce g) h
H0 : reduce g M N
M,N : Msg
H : and (le_h (reduce g) h) (le_h h (reduce g))
g,h : hedge
*****
h (MPair m1 m2) (MPair m m0)
+++++
elim H4.
-----
Lemma red_equiv_impl_red_incl : forall g h : hedge, equiv_h (reduce g) h -> inclusion (reduce g) h.
unfold equiv_h in |- *.
unfold inclusion in |- *.
intros.
elim H.
intros.
generalize (le_h_impl_incl_syn (reduce g) h H1).
unfold inclusion in |- *.
intros.
generalize (H3 M N H0).
generalize H0.
unfold reduce in |- *.
case M.
case N.
intros.
inversion H5.
trivial.
elim H4.

*****
H10 : eq N2 m0
H8 : eq N1 m
H7 : eq M2 m2
H6 : eq M1 m1
H11 : synthesis h m2 m0
H9 : synthesis h m1 m
M1,N1,M2,N2 : Msg
H5 : synthesis h (MPair m1 m2) (MPair m m0)
H4 : and (g (MPair m1 m2) (MPair m m0))\n (or (not (synthesis g m1 m)) (not (synthesis g m2 m0)))
m,m0,m1,m2 : Msg
H3 : forall (M N : Msg) (_ : reduce g M N), synthesis h M N
H2 : le_h h (reduce g)
H1 : le_h (reduce g) h
H0 : reduce g M N
M,N : Msg
H : and (le_h (reduce g) h) (le_h h (reduce g))
g,h : hedge
*****
forall (_ : g (MPair m1 m2) (MPair m m0)) (_ : or (not (synthesis g m1 m)) (not (synthesis g m2 m0))), h (MPair m1 m2) (MPair m m0)
+++++
intros.
-----
Lemma red_equiv_impl_red_incl : forall g h : hedge, equiv_h (reduce g) h -> inclusion (reduce g) h.
unfold equiv_h in |- *.
unfold inclusion in |- *.
intros.
elim H.
intros.
generalize (le_h_impl_incl_syn (reduce g) h H1).
unfold inclusion in |- *.
intros.
generalize (H3 M N H0).
generalize H0.
unfold reduce in |- *.
case M.
case N.
intros.
inversion H5.
trivial.
elim H4.
intros.

*****
H13 : or (not (synthesis g m1 m)) (not (synthesis g m2 m0))
H12 : g (MPair m1 m2) (MPair m m0)
H10 : eq N2 m0
H8 : eq N1 m
H7 : eq M2 m2
H6 : eq M1 m1
H11 : synthesis h m2 m0
H9 : synthesis h m1 m
M1,N1,M2,N2 : Msg
H5 : synthesis h (MPair m1 m2) (MPair m m0)
H4 : and (g (MPair m1 m2) (MPair m m0))\n (or (not (synthesis g m1 m)) (not (synthesis g m2 m0)))
m,m0,m1,m2 : Msg
H3 : forall (M N : Msg) (_ : reduce g M N), synthesis h M N
H2 : le_h h (reduce g)
H1 : le_h (reduce g) h
H0 : reduce g M N
M,N : Msg
H : and (le_h (reduce g) h) (le_h h (reduce g))
g,h : hedge
*****
h (MPair m1 m2) (MPair m m0)
+++++
case H13.
-----
Lemma red_equiv_impl_red_incl : forall g h : hedge, equiv_h (reduce g) h -> inclusion (reduce g) h.
unfold equiv_h in |- *.
unfold inclusion in |- *.
intros.
elim H.
intros.
generalize (le_h_impl_incl_syn (reduce g) h H1).
unfold inclusion in |- *.
intros.
generalize (H3 M N H0).
generalize H0.
unfold reduce in |- *.
case M.
case N.
intros.
inversion H5.
trivial.
elim H4.
intros.
case H13.

*****
H13 : or (not (synthesis g m1 m)) (not (synthesis g m2 m0))
H12 : g (MPair m1 m2) (MPair m m0)
H10 : eq N2 m0
H8 : eq N1 m
H7 : eq M2 m2
H6 : eq M1 m1
H11 : synthesis h m2 m0
H9 : synthesis h m1 m
M1,N1,M2,N2 : Msg
H5 : synthesis h (MPair m1 m2) (MPair m m0)
H4 : and (g (MPair m1 m2) (MPair m m0))\n (or (not (synthesis g m1 m)) (not (synthesis g m2 m0)))
m,m0,m1,m2 : Msg
H3 : forall (M N : Msg) (_ : reduce g M N), synthesis h M N
H2 : le_h h (reduce g)
H1 : le_h (reduce g) h
H0 : reduce g M N
M,N : Msg
H : and (le_h (reduce g) h) (le_h h (reduce g))
g,h : hedge
*****
forall _ : not (synthesis g m1 m), h (MPair m1 m2) (MPair m m0)
+++++
intro.
-----
Lemma red_equiv_impl_red_incl : forall g h : hedge, equiv_h (reduce g) h -> inclusion (reduce g) h.
unfold equiv_h in |- *.
unfold inclusion in |- *.
intros.
elim H.
intros.
generalize (le_h_impl_incl_syn (reduce g) h H1).
unfold inclusion in |- *.
intros.
generalize (H3 M N H0).
generalize H0.
unfold reduce in |- *.
case M.
case N.
intros.
inversion H5.
trivial.
elim H4.
intros.
case H13.
intro.

*****
H14 : not (synthesis g m1 m)
H13 : or (not (synthesis g m1 m)) (not (synthesis g m2 m0))
H12 : g (MPair m1 m2) (MPair m m0)
H10 : eq N2 m0
H8 : eq N1 m
H7 : eq M2 m2
H6 : eq M1 m1
H11 : synthesis h m2 m0
H9 : synthesis h m1 m
M1,N1,M2,N2 : Msg
H5 : synthesis h (MPair m1 m2) (MPair m m0)
H4 : and (g (MPair m1 m2) (MPair m m0))\n (or (not (synthesis g m1 m)) (not (synthesis g m2 m0)))
m,m0,m1,m2 : Msg
H3 : forall (M N : Msg) (_ : reduce g M N), synthesis h M N
H2 : le_h h (reduce g)
H1 : le_h (reduce g) h
H0 : reduce g M N
M,N : Msg
H : and (le_h (reduce g) h) (le_h h (reduce g))
g,h : hedge
*****
h (MPair m1 m2) (MPair m m0)
+++++
cut False.
-----
Lemma red_equiv_impl_red_incl : forall g h : hedge, equiv_h (reduce g) h -> inclusion (reduce g) h.
unfold equiv_h in |- *.
unfold inclusion in |- *.
intros.
elim H.
intros.
generalize (le_h_impl_incl_syn (reduce g) h H1).
unfold inclusion in |- *.
intros.
generalize (H3 M N H0).
generalize H0.
unfold reduce in |- *.
case M.
case N.
intros.
inversion H5.
trivial.
elim H4.
intros.
case H13.
intro.
cut False.

*****
H14 : not (synthesis g m1 m)
H13 : or (not (synthesis g m1 m)) (not (synthesis g m2 m0))
H12 : g (MPair m1 m2) (MPair m m0)
H10 : eq N2 m0
H8 : eq N1 m
H7 : eq M2 m2
H6 : eq M1 m1
H11 : synthesis h m2 m0
H9 : synthesis h m1 m
M1,N1,M2,N2 : Msg
H5 : synthesis h (MPair m1 m2) (MPair m m0)
H4 : and (g (MPair m1 m2) (MPair m m0))\n (or (not (synthesis g m1 m)) (not (synthesis g m2 m0)))
m,m0,m1,m2 : Msg
H3 : forall (M N : Msg) (_ : reduce g M N), synthesis h M N
H2 : le_h h (reduce g)
H1 : le_h (reduce g) h
H0 : reduce g M N
M,N : Msg
H : and (le_h (reduce g) h) (le_h h (reduce g))
g,h : hedge
*****
forall _ : False, h (MPair m1 m2) (MPair m m0)
+++++
tauto.
-----
Lemma red_equiv_impl_red_incl : forall g h : hedge, equiv_h (reduce g) h -> inclusion (reduce g) h.
unfold equiv_h in |- *.
unfold inclusion in |- *.
intros.
elim H.
intros.
generalize (le_h_impl_incl_syn (reduce g) h H1).
unfold inclusion in |- *.
intros.
generalize (H3 M N H0).
generalize H0.
unfold reduce in |- *.
case M.
case N.
intros.
inversion H5.
trivial.
elim H4.
intros.
case H13.
intro.
cut False.

*****
H14 : not (synthesis g m1 m)
H13 : or (not (synthesis g m1 m)) (not (synthesis g m2 m0))
H12 : g (MPair m1 m2) (MPair m m0)
H10 : eq N2 m0
H8 : eq N1 m
H7 : eq M2 m2
H6 : eq M1 m1
H11 : synthesis h m2 m0
H9 : synthesis h m1 m
M1,N1,M2,N2 : Msg
H5 : synthesis h (MPair m1 m2) (MPair m m0)
H4 : and (g (MPair m1 m2) (MPair m m0))\n (or (not (synthesis g m1 m)) (not (synthesis g m2 m0)))
m,m0,m1,m2 : Msg
H3 : forall (M N : Msg) (_ : reduce g M N), synthesis h M N
H2 : le_h h (reduce g)
H1 : le_h (reduce g) h
H0 : reduce g M N
M,N : Msg
H : and (le_h (reduce g) h) (le_h h (reduce g))
g,h : hedge
*****
False
+++++
apply H14.
-----
Lemma red_equiv_impl_red_incl : forall g h : hedge, equiv_h (reduce g) h -> inclusion (reduce g) h.
unfold equiv_h in |- *.
unfold inclusion in |- *.
intros.
elim H.
intros.
generalize (le_h_impl_incl_syn (reduce g) h H1).
unfold inclusion in |- *.
intros.
generalize (H3 M N H0).
generalize H0.
unfold reduce in |- *.
case M.
case N.
intros.
inversion H5.
trivial.
elim H4.
intros.
case H13.
intro.
cut False.
apply H14.

*****
H14 : not (synthesis g m1 m)
H13 : or (not (synthesis g m1 m)) (not (synthesis g m2 m0))
H12 : g (MPair m1 m2) (MPair m m0)
H10 : eq N2 m0
H8 : eq N1 m
H7 : eq M2 m2
H6 : eq M1 m1
H11 : synthesis h m2 m0
H9 : synthesis h m1 m
M1,N1,M2,N2 : Msg
H5 : synthesis h (MPair m1 m2) (MPair m m0)
H4 : and (g (MPair m1 m2) (MPair m m0))\n (or (not (synthesis g m1 m)) (not (synthesis g m2 m0)))
m,m0,m1,m2 : Msg
H3 : forall (M N : Msg) (_ : reduce g M N), synthesis h M N
H2 : le_h h (reduce g)
H1 : le_h (reduce g) h
H0 : reduce g M N
M,N : Msg
H : and (le_h (reduce g) h) (le_h h (reduce g))
g,h : hedge
*****
synthesis g m1 m
+++++
generalize (le_h_trans h (reduce g) g H2 (inclusion_impl_le_h (reduce g) g (red_incl_h g))).
-----
Lemma red_equiv_impl_red_incl : forall g h : hedge, equiv_h (reduce g) h -> inclusion (reduce g) h.
unfold equiv_h in |- *.
unfold inclusion in |- *.
intros.
elim H.
intros.
generalize (le_h_impl_incl_syn (reduce g) h H1).
unfold inclusion in |- *.
intros.
generalize (H3 M N H0).
generalize H0.
unfold reduce in |- *.
case M.
case N.
intros.
inversion H5.
trivial.
elim H4.
intros.
case H13.
intro.
cut False.
apply H14.
generalize (le_h_trans h (reduce g) g H2 (inclusion_impl_le_h (reduce g) g (red_incl_h g))).

*****
H14 : not (synthesis g m1 m)
H13 : or (not (synthesis g m1 m)) (not (synthesis g m2 m0))
H12 : g (MPair m1 m2) (MPair m m0)
H10 : eq N2 m0
H8 : eq N1 m
H7 : eq M2 m2
H6 : eq M1 m1
H11 : synthesis h m2 m0
H9 : synthesis h m1 m
M1,N1,M2,N2 : Msg
H5 : synthesis h (MPair m1 m2) (MPair m m0)
H4 : and (g (MPair m1 m2) (MPair m m0))\n (or (not (synthesis g m1 m)) (not (synthesis g m2 m0)))
m,m0,m1,m2 : Msg
H3 : forall (M N : Msg) (_ : reduce g M N), synthesis h M N
H2 : le_h h (reduce g)
H1 : le_h (reduce g) h
H0 : reduce g M N
M,N : Msg
H : and (le_h (reduce g) h) (le_h h (reduce g))
g,h : hedge
*****
forall _ : le_h h g, synthesis g m1 m
+++++
unfold le_h in |- *.
-----
Lemma red_equiv_impl_red_incl : forall g h : hedge, equiv_h (reduce g) h -> inclusion (reduce g) h.
unfold equiv_h in |- *.
unfold inclusion in |- *.
intros.
elim H.
intros.
generalize (le_h_impl_incl_syn (reduce g) h H1).
unfold inclusion in |- *.
intros.
generalize (H3 M N H0).
generalize H0.
unfold reduce in |- *.
case M.
case N.
intros.
inversion H5.
trivial.
elim H4.
intros.
case H13.
intro.
cut False.
apply H14.
generalize (le_h_trans h (reduce g) g H2 (inclusion_impl_le_h (reduce g) g (red_incl_h g))).
unfold le_h in |- *.

*****
H14 : not (synthesis g m1 m)
H13 : or (not (synthesis g m1 m)) (not (synthesis g m2 m0))
H12 : g (MPair m1 m2) (MPair m m0)
H10 : eq N2 m0
H8 : eq N1 m
H7 : eq M2 m2
H6 : eq M1 m1
H11 : synthesis h m2 m0
H9 : synthesis h m1 m
M1,N1,M2,N2 : Msg
H5 : synthesis h (MPair m1 m2) (MPair m m0)
H4 : and (g (MPair m1 m2) (MPair m m0))\n (or (not (synthesis g m1 m)) (not (synthesis g m2 m0)))
m,m0,m1,m2 : Msg
H3 : forall (M N : Msg) (_ : reduce g M N), synthesis h M N
H2 : le_h h (reduce g)
H1 : le_h (reduce g) h
H0 : reduce g M N
M,N : Msg
H : and (le_h (reduce g) h) (le_h h (reduce g))
g,h : hedge
*****
forall _ : inclusion (synthesis h) (synthesis g), synthesis g m1 m
+++++
unfold inclusion in |- *.
-----
Lemma red_equiv_impl_red_incl : forall g h : hedge, equiv_h (reduce g) h -> inclusion (reduce g) h.
unfold equiv_h in |- *.
unfold inclusion in |- *.
intros.
elim H.
intros.
generalize (le_h_impl_incl_syn (reduce g) h H1).
unfold inclusion in |- *.
intros.
generalize (H3 M N H0).
generalize H0.
unfold reduce in |- *.
case M.
case N.
intros.
inversion H5.
trivial.
elim H4.
intros.
case H13.
intro.
cut False.
apply H14.
generalize (le_h_trans h (reduce g) g H2 (inclusion_impl_le_h (reduce g) g (red_incl_h g))).
unfold le_h in |- *.
unfold inclusion in |- *.

*****
H14 : not (synthesis g m1 m)
H13 : or (not (synthesis g m1 m)) (not (synthesis g m2 m0))
H12 : g (MPair m1 m2) (MPair m m0)
H10 : eq N2 m0
H8 : eq N1 m
H7 : eq M2 m2
H6 : eq M1 m1
H11 : synthesis h m2 m0
H9 : synthesis h m1 m
M1,N1,M2,N2 : Msg
H5 : synthesis h (MPair m1 m2) (MPair m m0)
H4 : and (g (MPair m1 m2) (MPair m m0))\n (or (not (synthesis g m1 m)) (not (synthesis g m2 m0)))
m,m0,m1,m2 : Msg
H3 : forall (M N : Msg) (_ : reduce g M N), synthesis h M N
H2 : le_h h (reduce g)
H1 : le_h (reduce g) h
H0 : reduce g M N
M,N : Msg
H : and (le_h (reduce g) h) (le_h h (reduce g))
g,h : hedge
*****
forall _ : forall (M N : Msg) (_ : synthesis h M N), synthesis g M N, synthesis g m1 m
+++++
auto.
-----
Lemma red_equiv_impl_red_incl : forall g h : hedge, equiv_h (reduce g) h -> inclusion (reduce g) h.
unfold equiv_h in |- *.
unfold inclusion in |- *.
intros.
elim H.
intros.
generalize (le_h_impl_incl_syn (reduce g) h H1).
unfold inclusion in |- *.
intros.
generalize (H3 M N H0).
generalize H0.
unfold reduce in |- *.
case M.
case N.
intros.
inversion H5.
trivial.
elim H4.
intros.
case H13.

*****
H13 : or (not (synthesis g m1 m)) (not (synthesis g m2 m0))
H12 : g (MPair m1 m2) (MPair m m0)
H10 : eq N2 m0
H8 : eq N1 m
H7 : eq M2 m2
H6 : eq M1 m1
H11 : synthesis h m2 m0
H9 : synthesis h m1 m
M1,N1,M2,N2 : Msg
H5 : synthesis h (MPair m1 m2) (MPair m m0)
H4 : and (g (MPair m1 m2) (MPair m m0))\n (or (not (synthesis g m1 m)) (not (synthesis g m2 m0)))
m,m0,m1,m2 : Msg
H3 : forall (M N : Msg) (_ : reduce g M N), synthesis h M N
H2 : le_h h (reduce g)
H1 : le_h (reduce g) h
H0 : reduce g M N
M,N : Msg
H : and (le_h (reduce g) h) (le_h h (reduce g))
g,h : hedge
*****
forall _ : not (synthesis g m2 m0), h (MPair m1 m2) (MPair m m0)
+++++
intro.
-----
Lemma red_equiv_impl_red_incl : forall g h : hedge, equiv_h (reduce g) h -> inclusion (reduce g) h.
unfold equiv_h in |- *.
unfold inclusion in |- *.
intros.
elim H.
intros.
generalize (le_h_impl_incl_syn (reduce g) h H1).
unfold inclusion in |- *.
intros.
generalize (H3 M N H0).
generalize H0.
unfold reduce in |- *.
case M.
case N.
intros.
inversion H5.
trivial.
elim H4.
intros.
case H13.
intro.

*****
H14 : not (synthesis g m2 m0)
H13 : or (not (synthesis g m1 m)) (not (synthesis g m2 m0))
H12 : g (MPair m1 m2) (MPair m m0)
H10 : eq N2 m0
H8 : eq N1 m
H7 : eq M2 m2
H6 : eq M1 m1
H11 : synthesis h m2 m0
H9 : synthesis h m1 m
M1,N1,M2,N2 : Msg
H5 : synthesis h (MPair m1 m2) (MPair m m0)
H4 : and (g (MPair m1 m2) (MPair m m0))\n (or (not (synthesis g m1 m)) (not (synthesis g m2 m0)))
m,m0,m1,m2 : Msg
H3 : forall (M N : Msg) (_ : reduce g M N), synthesis h M N
H2 : le_h h (reduce g)
H1 : le_h (reduce g) h
H0 : reduce g M N
M,N : Msg
H : and (le_h (reduce g) h) (le_h h (reduce g))
g,h : hedge
*****
h (MPair m1 m2) (MPair m m0)
+++++
cut False.
-----
Lemma red_equiv_impl_red_incl : forall g h : hedge, equiv_h (reduce g) h -> inclusion (reduce g) h.
unfold equiv_h in |- *.
unfold inclusion in |- *.
intros.
elim H.
intros.
generalize (le_h_impl_incl_syn (reduce g) h H1).
unfold inclusion in |- *.
intros.
generalize (H3 M N H0).
generalize H0.
unfold reduce in |- *.
case M.
case N.
intros.
inversion H5.
trivial.
elim H4.
intros.
case H13.
intro.
cut False.

*****
H14 : not (synthesis g m2 m0)
H13 : or (not (synthesis g m1 m)) (not (synthesis g m2 m0))
H12 : g (MPair m1 m2) (MPair m m0)
H10 : eq N2 m0
H8 : eq N1 m
H7 : eq M2 m2
H6 : eq M1 m1
H11 : synthesis h m2 m0
H9 : synthesis h m1 m
M1,N1,M2,N2 : Msg
H5 : synthesis h (MPair m1 m2) (MPair m m0)
H4 : and (g (MPair m1 m2) (MPair m m0))\n (or (not (synthesis g m1 m)) (not (synthesis g m2 m0)))
m,m0,m1,m2 : Msg
H3 : forall (M N : Msg) (_ : reduce g M N), synthesis h M N
H2 : le_h h (reduce g)
H1 : le_h (reduce g) h
H0 : reduce g M N
M,N : Msg
H : and (le_h (reduce g) h) (le_h h (reduce g))
g,h : hedge
*****
forall _ : False, h (MPair m1 m2) (MPair m m0)
+++++
try tauto.
-----
Lemma red_equiv_impl_red_incl : forall g h : hedge, equiv_h (reduce g) h -> inclusion (reduce g) h.
unfold equiv_h in |- *.
unfold inclusion in |- *.
intros.
elim H.
intros.
generalize (le_h_impl_incl_syn (reduce g) h H1).
unfold inclusion in |- *.
intros.
generalize (H3 M N H0).
generalize H0.
unfold reduce in |- *.
case M.
case N.
intros.
inversion H5.
trivial.
elim H4.
intros.
case H13.
intro.
cut False.

*****
H14 : not (synthesis g m2 m0)
H13 : or (not (synthesis g m1 m)) (not (synthesis g m2 m0))
H12 : g (MPair m1 m2) (MPair m m0)
H10 : eq N2 m0
H8 : eq N1 m
H7 : eq M2 m2
H6 : eq M1 m1
H11 : synthesis h m2 m0
H9 : synthesis h m1 m
M1,N1,M2,N2 : Msg
H5 : synthesis h (MPair m1 m2) (MPair m m0)
H4 : and (g (MPair m1 m2) (MPair m m0))\n (or (not (synthesis g m1 m)) (not (synthesis g m2 m0)))
m,m0,m1,m2 : Msg
H3 : forall (M N : Msg) (_ : reduce g M N), synthesis h M N
H2 : le_h h (reduce g)
H1 : le_h (reduce g) h
H0 : reduce g M N
M,N : Msg
H : and (le_h (reduce g) h) (le_h h (reduce g))
g,h : hedge
*****
False
+++++
try tauto.
-----
Lemma red_equiv_impl_red_incl : forall g h : hedge, equiv_h (reduce g) h -> inclusion (reduce g) h.
unfold equiv_h in |- *.
unfold inclusion in |- *.
intros.
elim H.
intros.
generalize (le_h_impl_incl_syn (reduce g) h H1).
unfold inclusion in |- *.
intros.
generalize (H3 M N H0).
generalize H0.
unfold reduce in |- *.
case M.
case N.
intros.
inversion H5.
trivial.
elim H4.
intros.
case H13.
intro.
cut False.
try tauto.

*****
H14 : not (synthesis g m2 m0)
H13 : or (not (synthesis g m1 m)) (not (synthesis g m2 m0))
H12 : g (MPair m1 m2) (MPair m m0)
H10 : eq N2 m0
H8 : eq N1 m
H7 : eq M2 m2
H6 : eq M1 m1
H11 : synthesis h m2 m0
H9 : synthesis h m1 m
M1,N1,M2,N2 : Msg
H5 : synthesis h (MPair m1 m2) (MPair m m0)
H4 : and (g (MPair m1 m2) (MPair m m0))\n (or (not (synthesis g m1 m)) (not (synthesis g m2 m0)))
m,m0,m1,m2 : Msg
H3 : forall (M N : Msg) (_ : reduce g M N), synthesis h M N
H2 : le_h h (reduce g)
H1 : le_h (reduce g) h
H0 : reduce g M N
M,N : Msg
H : and (le_h (reduce g) h) (le_h h (reduce g))
g,h : hedge
*****
False
+++++
apply H14.
-----
Lemma red_equiv_impl_red_incl : forall g h : hedge, equiv_h (reduce g) h -> inclusion (reduce g) h.
unfold equiv_h in |- *.
unfold inclusion in |- *.
intros.
elim H.
intros.
generalize (le_h_impl_incl_syn (reduce g) h H1).
unfold inclusion in |- *.
intros.
generalize (H3 M N H0).
generalize H0.
unfold reduce in |- *.
case M.
case N.
intros.
inversion H5.
trivial.
elim H4.
intros.
case H13.
intro.
cut False.
try tauto.
apply H14.

*****
H14 : not (synthesis g m2 m0)
H13 : or (not (synthesis g m1 m)) (not (synthesis g m2 m0))
H12 : g (MPair m1 m2) (MPair m m0)
H10 : eq N2 m0
H8 : eq N1 m
H7 : eq M2 m2
H6 : eq M1 m1
H11 : synthesis h m2 m0
H9 : synthesis h m1 m
M1,N1,M2,N2 : Msg
H5 : synthesis h (MPair m1 m2) (MPair m m0)
H4 : and (g (MPair m1 m2) (MPair m m0))\n (or (not (synthesis g m1 m)) (not (synthesis g m2 m0)))
m,m0,m1,m2 : Msg
H3 : forall (M N : Msg) (_ : reduce g M N), synthesis h M N
H2 : le_h h (reduce g)
H1 : le_h (reduce g) h
H0 : reduce g M N
M,N : Msg
H : and (le_h (reduce g) h) (le_h h (reduce g))
g,h : hedge
*****
synthesis g m2 m0
+++++
generalize (le_h_trans h (reduce g) g H2 (inclusion_impl_le_h (reduce g) g (red_incl_h g))).
-----
Lemma red_equiv_impl_red_incl : forall g h : hedge, equiv_h (reduce g) h -> inclusion (reduce g) h.
unfold equiv_h in |- *.
unfold inclusion in |- *.
intros.
elim H.
intros.
generalize (le_h_impl_incl_syn (reduce g) h H1).
unfold inclusion in |- *.
intros.
generalize (H3 M N H0).
generalize H0.
unfold reduce in |- *.
case M.
case N.
intros.
inversion H5.
trivial.
elim H4.
intros.
case H13.
intro.
cut False.
try tauto.
apply H14.
generalize (le_h_trans h (reduce g) g H2 (inclusion_impl_le_h (reduce g) g (red_incl_h g))).

*****
H14 : not (synthesis g m2 m0)
H13 : or (not (synthesis g m1 m)) (not (synthesis g m2 m0))
H12 : g (MPair m1 m2) (MPair m m0)
H10 : eq N2 m0
H8 : eq N1 m
H7 : eq M2 m2
H6 : eq M1 m1
H11 : synthesis h m2 m0
H9 : synthesis h m1 m
M1,N1,M2,N2 : Msg
H5 : synthesis h (MPair m1 m2) (MPair m m0)
H4 : and (g (MPair m1 m2) (MPair m m0))\n (or (not (synthesis g m1 m)) (not (synthesis g m2 m0)))
m,m0,m1,m2 : Msg
H3 : forall (M N : Msg) (_ : reduce g M N), synthesis h M N
H2 : le_h h (reduce g)
H1 : le_h (reduce g) h
H0 : reduce g M N
M,N : Msg
H : and (le_h (reduce g) h) (le_h h (reduce g))
g,h : hedge
*****
forall _ : le_h h g, synthesis g m2 m0
+++++
unfold le_h in |- *.
-----
Lemma red_equiv_impl_red_incl : forall g h : hedge, equiv_h (reduce g) h -> inclusion (reduce g) h.
unfold equiv_h in |- *.
unfold inclusion in |- *.
intros.
elim H.
intros.
generalize (le_h_impl_incl_syn (reduce g) h H1).
unfold inclusion in |- *.
intros.
generalize (H3 M N H0).
generalize H0.
unfold reduce in |- *.
case M.
case N.
intros.
inversion H5.
trivial.
elim H4.
intros.
case H13.
intro.
cut False.
try tauto.
apply H14.
generalize (le_h_trans h (reduce g) g H2 (inclusion_impl_le_h (reduce g) g (red_incl_h g))).
unfold le_h in |- *.

*****
H14 : not (synthesis g m2 m0)
H13 : or (not (synthesis g m1 m)) (not (synthesis g m2 m0))
H12 : g (MPair m1 m2) (MPair m m0)
H10 : eq N2 m0
H8 : eq N1 m
H7 : eq M2 m2
H6 : eq M1 m1
H11 : synthesis h m2 m0
H9 : synthesis h m1 m
M1,N1,M2,N2 : Msg
H5 : synthesis h (MPair m1 m2) (MPair m m0)
H4 : and (g (MPair m1 m2) (MPair m m0))\n (or (not (synthesis g m1 m)) (not (synthesis g m2 m0)))
m,m0,m1,m2 : Msg
H3 : forall (M N : Msg) (_ : reduce g M N), synthesis h M N
H2 : le_h h (reduce g)
H1 : le_h (reduce g) h
H0 : reduce g M N
M,N : Msg
H : and (le_h (reduce g) h) (le_h h (reduce g))
g,h : hedge
*****
forall _ : inclusion (synthesis h) (synthesis g), synthesis g m2 m0
+++++
unfold inclusion in |- *.
-----
Lemma red_equiv_impl_red_incl : forall g h : hedge, equiv_h (reduce g) h -> inclusion (reduce g) h.
unfold equiv_h in |- *.
unfold inclusion in |- *.
intros.
elim H.
intros.
generalize (le_h_impl_incl_syn (reduce g) h H1).
unfold inclusion in |- *.
intros.
generalize (H3 M N H0).
generalize H0.
unfold reduce in |- *.
case M.
case N.
intros.
inversion H5.
trivial.
elim H4.
intros.
case H13.
intro.
cut False.
try tauto.
apply H14.
generalize (le_h_trans h (reduce g) g H2 (inclusion_impl_le_h (reduce g) g (red_incl_h g))).
unfold le_h in |- *.
unfold inclusion in |- *.

*****
H14 : not (synthesis g m2 m0)
H13 : or (not (synthesis g m1 m)) (not (synthesis g m2 m0))
H12 : g (MPair m1 m2) (MPair m m0)
H10 : eq N2 m0
H8 : eq N1 m
H7 : eq M2 m2
H6 : eq M1 m1
H11 : synthesis h m2 m0
H9 : synthesis h m1 m
M1,N1,M2,N2 : Msg
H5 : synthesis h (MPair m1 m2) (MPair m m0)
H4 : and (g (MPair m1 m2) (MPair m m0))\n (or (not (synthesis g m1 m)) (not (synthesis g m2 m0)))
m,m0,m1,m2 : Msg
H3 : forall (M N : Msg) (_ : reduce g M N), synthesis h M N
H2 : le_h h (reduce g)
H1 : le_h (reduce g) h
H0 : reduce g M N
M,N : Msg
H : and (le_h (reduce g) h) (le_h h (reduce g))
g,h : hedge
*****
forall _ : forall (M N : Msg) (_ : synthesis h M N), synthesis g M N, synthesis g m2 m0
+++++
auto.
-----
Lemma red_equiv_impl_red_incl : forall g h : hedge, equiv_h (reduce g) h -> inclusion (reduce g) h.
unfold equiv_h in |- *.
unfold inclusion in |- *.
intros.
elim H.
intros.
generalize (le_h_impl_incl_syn (reduce g) h H1).
unfold inclusion in |- *.
intros.
generalize (H3 M N H0).
generalize H0.
unfold reduce in |- *.
case M.
case N.

*****
H3 : forall (M N : Msg) (_ : reduce g M N), synthesis h M N
H2 : le_h h (reduce g)
H1 : le_h (reduce g) h
H0 : reduce g M N
M,N : Msg
H : and (le_h (reduce g) h) (le_h h (reduce g))
g,h : hedge
*****
forall (o : op) (m m0 m1 : Msg) (_ : and (g (MPair m0 m1) (Mop o m)) True) (_ : synthesis h (MPair m0 m1) (Mop o m)), h (MPair m0 m1) (Mop o m)
+++++
intros.
-----
Lemma red_equiv_impl_red_incl : forall g h : hedge, equiv_h (reduce g) h -> inclusion (reduce g) h.
unfold equiv_h in |- *.
unfold inclusion in |- *.
intros.
elim H.
intros.
generalize (le_h_impl_incl_syn (reduce g) h H1).
unfold inclusion in |- *.
intros.
generalize (H3 M N H0).
generalize H0.
unfold reduce in |- *.
case M.
case N.
intros.

*****
H5 : synthesis h (MPair m0 m1) (Mop o m)
H4 : and (g (MPair m0 m1) (Mop o m)) True
m,m0,m1 : Msg
o : op
H3 : forall (M N : Msg) (_ : reduce g M N), synthesis h M N
H2 : le_h h (reduce g)
H1 : le_h (reduce g) h
H0 : reduce g M N
M,N : Msg
H : and (le_h (reduce g) h) (le_h h (reduce g))
g,h : hedge
*****
h (MPair m0 m1) (Mop o m)
+++++
inversion H5.
-----
Lemma red_equiv_impl_red_incl : forall g h : hedge, equiv_h (reduce g) h -> inclusion (reduce g) h.
unfold equiv_h in |- *.
unfold inclusion in |- *.
intros.
elim H.
intros.
generalize (le_h_impl_incl_syn (reduce g) h H1).
unfold inclusion in |- *.
intros.
generalize (H3 M N H0).
generalize H0.
unfold reduce in |- *.
case M.
case N.
intros.
inversion H5.

*****
H8 : eq N0 (Mop o m)
H7 : eq M0 (MPair m0 m1)
H6 : h (MPair m0 m1) (Mop o m)
M0,N0 : Msg
H5 : synthesis h (MPair m0 m1) (Mop o m)
H4 : and (g (MPair m0 m1) (Mop o m)) True
m,m0,m1 : Msg
o : op
H3 : forall (M N : Msg) (_ : reduce g M N), synthesis h M N
H2 : le_h h (reduce g)
H1 : le_h (reduce g) h
H0 : reduce g M N
M,N : Msg
H : and (le_h (reduce g) h) (le_h h (reduce g))
g,h : hedge
*****
h (MPair m0 m1) (Mop o m)
+++++
trivial.
-----
Lemma red_equiv_impl_red_incl : forall g h : hedge, equiv_h (reduce g) h -> inclusion (reduce g) h.
unfold equiv_h in |- *.
unfold inclusion in |- *.
intros.
elim H.
intros.
generalize (le_h_impl_incl_syn (reduce g) h H1).
unfold inclusion in |- *.
intros.
generalize (H3 M N H0).
generalize H0.
unfold reduce in |- *.
case M.

*****
H3 : forall (M N : Msg) (_ : reduce g M N), synthesis h M N
H2 : le_h h (reduce g)
H1 : le_h (reduce g) h
H0 : reduce g M N
M,N : Msg
H : and (le_h (reduce g) h) (le_h h (reduce g))
g,h : hedge
*****
forall (o : op) (m : Msg) (_ : and (g (Mop o m) N) match N with | Mop opN N' => or (not (eq o opN)) (not (synthesis g m N')) | _ => True end) (_ : synthesis h (Mop o m) N), h (Mop o m) N
+++++
case N.
-----
Lemma red_equiv_impl_red_incl : forall g h : hedge, equiv_h (reduce g) h -> inclusion (reduce g) h.
unfold equiv_h in |- *.
unfold inclusion in |- *.
intros.
elim H.
intros.
generalize (le_h_impl_incl_syn (reduce g) h H1).
unfold inclusion in |- *.
intros.
generalize (H3 M N H0).
generalize H0.
unfold reduce in |- *.
case M.
case N.

*****
H3 : forall (M N : Msg) (_ : reduce g M N), synthesis h M N
H2 : le_h h (reduce g)
H1 : le_h (reduce g) h
H0 : reduce g M N
M,N : Msg
H : and (le_h (reduce g) h) (le_h h (reduce g))
g,h : hedge
*****
forall (n : Nam) (o : op) (m : Msg) (_ : and (g (Mop o m) (MNam n)) True) (_ : synthesis h (Mop o m) (MNam n)), h (Mop o m) (MNam n)
+++++
intros.
-----
Lemma red_equiv_impl_red_incl : forall g h : hedge, equiv_h (reduce g) h -> inclusion (reduce g) h.
unfold equiv_h in |- *.
unfold inclusion in |- *.
intros.
elim H.
intros.
generalize (le_h_impl_incl_syn (reduce g) h H1).
unfold inclusion in |- *.
intros.
generalize (H3 M N H0).
generalize H0.
unfold reduce in |- *.
case M.
case N.
intros.

*****
H5 : synthesis h (Mop o m) (MNam n)
H4 : and (g (Mop o m) (MNam n)) True
m : Msg
o : op
n : Nam
H3 : forall (M N : Msg) (_ : reduce g M N), synthesis h M N
H2 : le_h h (reduce g)
H1 : le_h (reduce g) h
H0 : reduce g M N
M,N : Msg
H : and (le_h (reduce g) h) (le_h h (reduce g))
g,h : hedge
*****
h (Mop o m) (MNam n)
+++++
inversion H5.
-----
Lemma red_equiv_impl_red_incl : forall g h : hedge, equiv_h (reduce g) h -> inclusion (reduce g) h.
unfold equiv_h in |- *.
unfold inclusion in |- *.
intros.
elim H.
intros.
generalize (le_h_impl_incl_syn (reduce g) h H1).
unfold inclusion in |- *.
intros.
generalize (H3 M N H0).
generalize H0.
unfold reduce in |- *.
case M.
case N.
intros.
inversion H5.

*****
H8 : eq N0 (MNam n)
H7 : eq M0 (Mop o m)
H6 : h (Mop o m) (MNam n)
M0,N0 : Msg
H5 : synthesis h (Mop o m) (MNam n)
H4 : and (g (Mop o m) (MNam n)) True
m : Msg
o : op
n : Nam
H3 : forall (M N : Msg) (_ : reduce g M N), synthesis h M N
H2 : le_h h (reduce g)
H1 : le_h (reduce g) h
H0 : reduce g M N
M,N : Msg
H : and (le_h (reduce g) h) (le_h h (reduce g))
g,h : hedge
*****
h (Mop o m) (MNam n)
+++++
trivial.
-----
Lemma red_equiv_impl_red_incl : forall g h : hedge, equiv_h (reduce g) h -> inclusion (reduce g) h.
unfold equiv_h in |- *.
unfold inclusion in |- *.
intros.
elim H.
intros.
generalize (le_h_impl_incl_syn (reduce g) h H1).
unfold inclusion in |- *.
intros.
generalize (H3 M N H0).
generalize H0.
unfold reduce in |- *.
case M.
case N.

*****
H3 : forall (M N : Msg) (_ : reduce g M N), synthesis h M N
H2 : le_h h (reduce g)
H1 : le_h (reduce g) h
H0 : reduce g M N
M,N : Msg
H : and (le_h (reduce g) h) (le_h h (reduce g))
g,h : hedge
*****
forall (m m0 : Msg) (o : op) (m1 : Msg) (_ : and (g (Mop o m1) (MEnc m m0)) True) (_ : synthesis h (Mop o m1) (MEnc m m0)), h (Mop o m1) (MEnc m m0)
+++++
intros.
-----
Lemma red_equiv_impl_red_incl : forall g h : hedge, equiv_h (reduce g) h -> inclusion (reduce g) h.
unfold equiv_h in |- *.
unfold inclusion in |- *.
intros.
elim H.
intros.
generalize (le_h_impl_incl_syn (reduce g) h H1).
unfold inclusion in |- *.
intros.
generalize (H3 M N H0).
generalize H0.
unfold reduce in |- *.
case M.
case N.
intros.

*****
H5 : synthesis h (Mop o m1) (MEnc m m0)
H4 : and (g (Mop o m1) (MEnc m m0)) True
m1 : Msg
o : op
m,m0 : Msg
H3 : forall (M N : Msg) (_ : reduce g M N), synthesis h M N
H2 : le_h h (reduce g)
H1 : le_h (reduce g) h
H0 : reduce g M N
M,N : Msg
H : and (le_h (reduce g) h) (le_h h (reduce g))
g,h : hedge
*****
h (Mop o m1) (MEnc m m0)
+++++
inversion H5.
-----
Lemma red_equiv_impl_red_incl : forall g h : hedge, equiv_h (reduce g) h -> inclusion (reduce g) h.
unfold equiv_h in |- *.
unfold inclusion in |- *.
intros.
elim H.
intros.
generalize (le_h_impl_incl_syn (reduce g) h H1).
unfold inclusion in |- *.
intros.
generalize (H3 M N H0).
generalize H0.
unfold reduce in |- *.
case M.
case N.
intros.
inversion H5.

*****
H8 : eq N0 (MEnc m m0)
H7 : eq M0 (Mop o m1)
H6 : h (Mop o m1) (MEnc m m0)
M0,N0 : Msg
H5 : synthesis h (Mop o m1) (MEnc m m0)
H4 : and (g (Mop o m1) (MEnc m m0)) True
m1 : Msg
o : op
m,m0 : Msg
H3 : forall (M N : Msg) (_ : reduce g M N), synthesis h M N
H2 : le_h h (reduce g)
H1 : le_h (reduce g) h
H0 : reduce g M N
M,N : Msg
H : and (le_h (reduce g) h) (le_h h (reduce g))
g,h : hedge
*****
h (Mop o m1) (MEnc m m0)
+++++
trivial.
-----
Lemma red_equiv_impl_red_incl : forall g h : hedge, equiv_h (reduce g) h -> inclusion (reduce g) h.
unfold equiv_h in |- *.
unfold inclusion in |- *.
intros.
elim H.
intros.
generalize (le_h_impl_incl_syn (reduce g) h H1).
unfold inclusion in |- *.
intros.
generalize (H3 M N H0).
generalize H0.
unfold reduce in |- *.
case M.
case N.

*****
H3 : forall (M N : Msg) (_ : reduce g M N), synthesis h M N
H2 : le_h h (reduce g)
H1 : le_h (reduce g) h
H0 : reduce g M N
M,N : Msg
H : and (le_h (reduce g) h) (le_h h (reduce g))
g,h : hedge
*****
forall (m m0 : Msg) (o : op) (m1 : Msg) (_ : and (g (Mop o m1) (MPair m m0)) True) (_ : synthesis h (Mop o m1) (MPair m m0)), h (Mop o m1) (MPair m m0)
+++++
intros.
-----
Lemma red_equiv_impl_red_incl : forall g h : hedge, equiv_h (reduce g) h -> inclusion (reduce g) h.
unfold equiv_h in |- *.
unfold inclusion in |- *.
intros.
elim H.
intros.
generalize (le_h_impl_incl_syn (reduce g) h H1).
unfold inclusion in |- *.
intros.
generalize (H3 M N H0).
generalize H0.
unfold reduce in |- *.
case M.
case N.
intros.

*****
H5 : synthesis h (Mop o m1) (MPair m m0)
H4 : and (g (Mop o m1) (MPair m m0)) True
m1 : Msg
o : op
m,m0 : Msg
H3 : forall (M N : Msg) (_ : reduce g M N), synthesis h M N
H2 : le_h h (reduce g)
H1 : le_h (reduce g) h
H0 : reduce g M N
M,N : Msg
H : and (le_h (reduce g) h) (le_h h (reduce g))
g,h : hedge
*****
h (Mop o m1) (MPair m m0)
+++++
inversion H5.
-----
Lemma red_equiv_impl_red_incl : forall g h : hedge, equiv_h (reduce g) h -> inclusion (reduce g) h.
unfold equiv_h in |- *.
unfold inclusion in |- *.
intros.
elim H.
intros.
generalize (le_h_impl_incl_syn (reduce g) h H1).
unfold inclusion in |- *.
intros.
generalize (H3 M N H0).
generalize H0.
unfold reduce in |- *.
case M.
case N.
intros.
inversion H5.

*****
H8 : eq N0 (MPair m m0)
H7 : eq M0 (Mop o m1)
H6 : h (Mop o m1) (MPair m m0)
M0,N0 : Msg
H5 : synthesis h (Mop o m1) (MPair m m0)
H4 : and (g (Mop o m1) (MPair m m0)) True
m1 : Msg
o : op
m,m0 : Msg
H3 : forall (M N : Msg) (_ : reduce g M N), synthesis h M N
H2 : le_h h (reduce g)
H1 : le_h (reduce g) h
H0 : reduce g M N
M,N : Msg
H : and (le_h (reduce g) h) (le_h h (reduce g))
g,h : hedge
*****
h (Mop o m1) (MPair m m0)
+++++
trivial.
-----
Lemma red_equiv_impl_red_incl : forall g h : hedge, equiv_h (reduce g) h -> inclusion (reduce g) h.
unfold equiv_h in |- *.
unfold inclusion in |- *.
intros.
elim H.
intros.
generalize (le_h_impl_incl_syn (reduce g) h H1).
unfold inclusion in |- *.
intros.
generalize (H3 M N H0).
generalize H0.
unfold reduce in |- *.
case M.
case N.

*****
H3 : forall (M N : Msg) (_ : reduce g M N), synthesis h M N
H2 : le_h h (reduce g)
H1 : le_h (reduce g) h
H0 : reduce g M N
M,N : Msg
H : and (le_h (reduce g) h) (le_h h (reduce g))
g,h : hedge
*****
forall (o : op) (m : Msg) (o0 : op) (m0 : Msg) (_ : and (g (Mop o0 m0) (Mop o m)) (or (not (eq o0 o)) (not (synthesis g m0 m)))) (_ : synthesis h (Mop o0 m0) (Mop o m)), h (Mop o0 m0) (Mop o m)
+++++
intros.
-----
Lemma red_equiv_impl_red_incl : forall g h : hedge, equiv_h (reduce g) h -> inclusion (reduce g) h.
unfold equiv_h in |- *.
unfold inclusion in |- *.
intros.
elim H.
intros.
generalize (le_h_impl_incl_syn (reduce g) h H1).
unfold inclusion in |- *.
intros.
generalize (H3 M N H0).
generalize H0.
unfold reduce in |- *.
case M.
case N.
intros.

*****
H5 : synthesis h (Mop o0 m0) (Mop o m)
H4 : and (g (Mop o0 m0) (Mop o m))\n (or (not (eq o0 o)) (not (synthesis g m0 m)))
m0 : Msg
o0 : op
m : Msg
o : op
H3 : forall (M N : Msg) (_ : reduce g M N), synthesis h M N
H2 : le_h h (reduce g)
H1 : le_h (reduce g) h
H0 : reduce g M N
M,N : Msg
H : and (le_h (reduce g) h) (le_h h (reduce g))
g,h : hedge
*****
h (Mop o0 m0) (Mop o m)
+++++
elim H4.
-----
Lemma red_equiv_impl_red_incl : forall g h : hedge, equiv_h (reduce g) h -> inclusion (reduce g) h.
unfold equiv_h in |- *.
unfold inclusion in |- *.
intros.
elim H.
intros.
generalize (le_h_impl_incl_syn (reduce g) h H1).
unfold inclusion in |- *.
intros.
generalize (H3 M N H0).
generalize H0.
unfold reduce in |- *.
case M.
case N.
intros.
elim H4.

*****
H5 : synthesis h (Mop o0 m0) (Mop o m)
H4 : and (g (Mop o0 m0) (Mop o m))\n (or (not (eq o0 o)) (not (synthesis g m0 m)))
m0 : Msg
o0 : op
m : Msg
o : op
H3 : forall (M N : Msg) (_ : reduce g M N), synthesis h M N
H2 : le_h h (reduce g)
H1 : le_h (reduce g) h
H0 : reduce g M N
M,N : Msg
H : and (le_h (reduce g) h) (le_h h (reduce g))
g,h : hedge
*****
forall (_ : g (Mop o0 m0) (Mop o m)) (_ : or (not (eq o0 o)) (not (synthesis g m0 m))), h (Mop o0 m0) (Mop o m)
+++++
intros.
-----
Lemma red_equiv_impl_red_incl : forall g h : hedge, equiv_h (reduce g) h -> inclusion (reduce g) h.
unfold equiv_h in |- *.
unfold inclusion in |- *.
intros.
elim H.
intros.
generalize (le_h_impl_incl_syn (reduce g) h H1).
unfold inclusion in |- *.
intros.
generalize (H3 M N H0).
generalize H0.
unfold reduce in |- *.
case M.
case N.
intros.
elim H4.
intros.

*****
H7 : or (not (eq o0 o)) (not (synthesis g m0 m))
H6 : g (Mop o0 m0) (Mop o m)
H5 : synthesis h (Mop o0 m0) (Mop o m)
H4 : and (g (Mop o0 m0) (Mop o m))\n (or (not (eq o0 o)) (not (synthesis g m0 m)))
m0 : Msg
o0 : op
m : Msg
o : op
H3 : forall (M N : Msg) (_ : reduce g M N), synthesis h M N
H2 : le_h h (reduce g)
H1 : le_h (reduce g) h
H0 : reduce g M N
M,N : Msg
H : and (le_h (reduce g) h) (le_h h (reduce g))
g,h : hedge
*****
h (Mop o0 m0) (Mop o m)
+++++
case (op_eq_dec o0 o).
-----
Lemma red_equiv_impl_red_incl : forall g h : hedge, equiv_h (reduce g) h -> inclusion (reduce g) h.
unfold equiv_h in |- *.
unfold inclusion in |- *.
intros.
elim H.
intros.
generalize (le_h_impl_incl_syn (reduce g) h H1).
unfold inclusion in |- *.
intros.
generalize (H3 M N H0).
generalize H0.
unfold reduce in |- *.
case M.
case N.
intros.
elim H4.
intros.
case (op_eq_dec o0 o).

*****
H7 : or (not (eq o0 o)) (not (synthesis g m0 m))
H6 : g (Mop o0 m0) (Mop o m)
H5 : synthesis h (Mop o0 m0) (Mop o m)
H4 : and (g (Mop o0 m0) (Mop o m))\n (or (not (eq o0 o)) (not (synthesis g m0 m)))
m0 : Msg
o0 : op
m : Msg
o : op
H3 : forall (M N : Msg) (_ : reduce g M N), synthesis h M N
H2 : le_h h (reduce g)
H1 : le_h (reduce g) h
H0 : reduce g M N
M,N : Msg
H : and (le_h (reduce g) h) (le_h h (reduce g))
g,h : hedge
*****
forall _ : eq o0 o, h (Mop o0 m0) (Mop o m)
+++++
intro.
-----
Lemma red_equiv_impl_red_incl : forall g h : hedge, equiv_h (reduce g) h -> inclusion (reduce g) h.
unfold equiv_h in |- *.
unfold inclusion in |- *.
intros.
elim H.
intros.
generalize (le_h_impl_incl_syn (reduce g) h H1).
unfold inclusion in |- *.
intros.
generalize (H3 M N H0).
generalize H0.
unfold reduce in |- *.
case M.
case N.
intros.
elim H4.
intros.
case (op_eq_dec o0 o).
intro.

*****
e : eq o0 o
H7 : or (not (eq o0 o)) (not (synthesis g m0 m))
H6 : g (Mop o0 m0) (Mop o m)
H5 : synthesis h (Mop o0 m0) (Mop o m)
H4 : and (g (Mop o0 m0) (Mop o m))\n (or (not (eq o0 o)) (not (synthesis g m0 m)))
m0 : Msg
o0 : op
m : Msg
o : op
H3 : forall (M N : Msg) (_ : reduce g M N), synthesis h M N
H2 : le_h h (reduce g)
H1 : le_h (reduce g) h
H0 : reduce g M N
M,N : Msg
H : and (le_h (reduce g) h) (le_h h (reduce g))
g,h : hedge
*****
h (Mop o0 m0) (Mop o m)
+++++
rewrite e.
-----
Lemma red_equiv_impl_red_incl : forall g h : hedge, equiv_h (reduce g) h -> inclusion (reduce g) h.
unfold equiv_h in |- *.
unfold inclusion in |- *.
intros.
elim H.
intros.
generalize (le_h_impl_incl_syn (reduce g) h H1).
unfold inclusion in |- *.
intros.
generalize (H3 M N H0).
generalize H0.
unfold reduce in |- *.
case M.
case N.
intros.
elim H4.
intros.
case (op_eq_dec o0 o).
intro.
rewrite e.

*****
e : eq o0 o
H7 : or (not (eq o0 o)) (not (synthesis g m0 m))
H6 : g (Mop o0 m0) (Mop o m)
H5 : synthesis h (Mop o0 m0) (Mop o m)
H4 : and (g (Mop o0 m0) (Mop o m))\n (or (not (eq o0 o)) (not (synthesis g m0 m)))
m0 : Msg
o0 : op
m : Msg
o : op
H3 : forall (M N : Msg) (_ : reduce g M N), synthesis h M N
H2 : le_h h (reduce g)
H1 : le_h (reduce g) h
H0 : reduce g M N
M,N : Msg
H : and (le_h (reduce g) h) (le_h h (reduce g))
g,h : hedge
*****
h (Mop o m0) (Mop o m)
+++++
rewrite e in H5.
-----
Lemma red_equiv_impl_red_incl : forall g h : hedge, equiv_h (reduce g) h -> inclusion (reduce g) h.
unfold equiv_h in |- *.
unfold inclusion in |- *.
intros.
elim H.
intros.
generalize (le_h_impl_incl_syn (reduce g) h H1).
unfold inclusion in |- *.
intros.
generalize (H3 M N H0).
generalize H0.
unfold reduce in |- *.
case M.
case N.
intros.
elim H4.
intros.
case (op_eq_dec o0 o).
intro.
rewrite e.
rewrite e in H5.

*****
e : eq o0 o
H7 : or (not (eq o0 o)) (not (synthesis g m0 m))
H6 : g (Mop o0 m0) (Mop o m)
H5 : synthesis h (Mop o m0) (Mop o m)
H4 : and (g (Mop o0 m0) (Mop o m))\n (or (not (eq o0 o)) (not (synthesis g m0 m)))
m0 : Msg
o0 : op
m : Msg
o : op
H3 : forall (M N : Msg) (_ : reduce g M N), synthesis h M N
H2 : le_h h (reduce g)
H1 : le_h (reduce g) h
H0 : reduce g M N
M,N : Msg
H : and (le_h (reduce g) h) (le_h h (reduce g))
g,h : hedge
*****
h (Mop o m0) (Mop o m)
+++++
inversion H5.
-----
Lemma red_equiv_impl_red_incl : forall g h : hedge, equiv_h (reduce g) h -> inclusion (reduce g) h.
unfold equiv_h in |- *.
unfold inclusion in |- *.
intros.
elim H.
intros.
generalize (le_h_impl_incl_syn (reduce g) h H1).
unfold inclusion in |- *.
intros.
generalize (H3 M N H0).
generalize H0.
unfold reduce in |- *.
case M.
case N.
intros.
elim H4.
intros.
case (op_eq_dec o0 o).
intro.
rewrite e.
rewrite e in H5.
inversion H5.

*****
H10 : eq N0 (Mop o m)
H9 : eq M0 (Mop o m0)
H8 : h (Mop o m0) (Mop o m)
M0,N0 : Msg
e : eq o0 o
H7 : or (not (eq o0 o)) (not (synthesis g m0 m))
H6 : g (Mop o0 m0) (Mop o m)
H5 : synthesis h (Mop o m0) (Mop o m)
H4 : and (g (Mop o0 m0) (Mop o m))\n (or (not (eq o0 o)) (not (synthesis g m0 m)))
m0 : Msg
o0 : op
m : Msg
o : op
H3 : forall (M N : Msg) (_ : reduce g M N), synthesis h M N
H2 : le_h h (reduce g)
H1 : le_h (reduce g) h
H0 : reduce g M N
M,N : Msg
H : and (le_h (reduce g) h) (le_h h (reduce g))
g,h : hedge
*****
h (Mop o m0) (Mop o m)
+++++
trivial.
-----
Lemma red_equiv_impl_red_incl : forall g h : hedge, equiv_h (reduce g) h -> inclusion (reduce g) h.
unfold equiv_h in |- *.
unfold inclusion in |- *.
intros.
elim H.
intros.
generalize (le_h_impl_incl_syn (reduce g) h H1).
unfold inclusion in |- *.
intros.
generalize (H3 M N H0).
generalize H0.
unfold reduce in |- *.
case M.
case N.
intros.
elim H4.
intros.
case (op_eq_dec o0 o).
intro.
rewrite e.
rewrite e in H5.
inversion H5.

*****
H11 : eq N0 m
H10 : eq M0 m0
H8 : eq o1 o
H9 : synthesis h m0 m
M0,N0 : Msg
o1 : op
e : eq o0 o
H7 : or (not (eq o0 o)) (not (synthesis g m0 m))
H6 : g (Mop o0 m0) (Mop o m)
H5 : synthesis h (Mop o m0) (Mop o m)
H4 : and (g (Mop o0 m0) (Mop o m))\n (or (not (eq o0 o)) (not (synthesis g m0 m)))
m0 : Msg
o0 : op
m : Msg
o : op
H3 : forall (M N : Msg) (_ : reduce g M N), synthesis h M N
H2 : le_h h (reduce g)
H1 : le_h (reduce g) h
H0 : reduce g M N
M,N : Msg
H : and (le_h (reduce g) h) (le_h h (reduce g))
g,h : hedge
*****
h (Mop o m0) (Mop o m)
+++++
trivial.
-----
Lemma red_equiv_impl_red_incl : forall g h : hedge, equiv_h (reduce g) h -> inclusion (reduce g) h.
unfold equiv_h in |- *.
unfold inclusion in |- *.
intros.
elim H.
intros.
generalize (le_h_impl_incl_syn (reduce g) h H1).
unfold inclusion in |- *.
intros.
generalize (H3 M N H0).
generalize H0.
unfold reduce in |- *.
case M.
case N.
intros.
elim H4.
intros.
case (op_eq_dec o0 o).
intro.
rewrite e.
rewrite e in H5.
inversion H5.
trivial.

*****
H11 : eq N0 m
H10 : eq M0 m0
H8 : eq o1 o
H9 : synthesis h m0 m
M0,N0 : Msg
o1 : op
e : eq o0 o
H7 : or (not (eq o0 o)) (not (synthesis g m0 m))
H6 : g (Mop o0 m0) (Mop o m)
H5 : synthesis h (Mop o m0) (Mop o m)
H4 : and (g (Mop o0 m0) (Mop o m))\n (or (not (eq o0 o)) (not (synthesis g m0 m)))
m0 : Msg
o0 : op
m : Msg
o : op
H3 : forall (M N : Msg) (_ : reduce g M N), synthesis h M N
H2 : le_h h (reduce g)
H1 : le_h (reduce g) h
H0 : reduce g M N
M,N : Msg
H : and (le_h (reduce g) h) (le_h h (reduce g))
g,h : hedge
*****
h (Mop o m0) (Mop o m)
+++++
case H7.
-----
Lemma red_equiv_impl_red_incl : forall g h : hedge, equiv_h (reduce g) h -> inclusion (reduce g) h.
unfold equiv_h in |- *.
unfold inclusion in |- *.
intros.
elim H.
intros.
generalize (le_h_impl_incl_syn (reduce g) h H1).
unfold inclusion in |- *.
intros.
generalize (H3 M N H0).
generalize H0.
unfold reduce in |- *.
case M.
case N.
intros.
elim H4.
intros.
case (op_eq_dec o0 o).
intro.
rewrite e.
rewrite e in H5.
inversion H5.
trivial.
case H7.

*****
H11 : eq N0 m
H10 : eq M0 m0
H8 : eq o1 o
H9 : synthesis h m0 m
M0,N0 : Msg
o1 : op
e : eq o0 o
H7 : or (not (eq o0 o)) (not (synthesis g m0 m))
H6 : g (Mop o0 m0) (Mop o m)
H5 : synthesis h (Mop o m0) (Mop o m)
H4 : and (g (Mop o0 m0) (Mop o m))\n (or (not (eq o0 o)) (not (synthesis g m0 m)))
m0 : Msg
o0 : op
m : Msg
o : op
H3 : forall (M N : Msg) (_ : reduce g M N), synthesis h M N
H2 : le_h h (reduce g)
H1 : le_h (reduce g) h
H0 : reduce g M N
M,N : Msg
H : and (le_h (reduce g) h) (le_h h (reduce g))
g,h : hedge
*****
forall _ : not (eq o0 o), h (Mop o m0) (Mop o m)
+++++
intro.
-----
Lemma red_equiv_impl_red_incl : forall g h : hedge, equiv_h (reduce g) h -> inclusion (reduce g) h.
unfold equiv_h in |- *.
unfold inclusion in |- *.
intros.
elim H.
intros.
generalize (le_h_impl_incl_syn (reduce g) h H1).
unfold inclusion in |- *.
intros.
generalize (H3 M N H0).
generalize H0.
unfold reduce in |- *.
case M.
case N.
intros.
elim H4.
intros.
case (op_eq_dec o0 o).
intro.
rewrite e.
rewrite e in H5.
inversion H5.
trivial.
case H7.
intro.

*****
H12 : not (eq o0 o)
H11 : eq N0 m
H10 : eq M0 m0
H8 : eq o1 o
H9 : synthesis h m0 m
M0,N0 : Msg
o1 : op
e : eq o0 o
H7 : or (not (eq o0 o)) (not (synthesis g m0 m))
H6 : g (Mop o0 m0) (Mop o m)
H5 : synthesis h (Mop o m0) (Mop o m)
H4 : and (g (Mop o0 m0) (Mop o m))\n (or (not (eq o0 o)) (not (synthesis g m0 m)))
m0 : Msg
o0 : op
m : Msg
o : op
H3 : forall (M N : Msg) (_ : reduce g M N), synthesis h M N
H2 : le_h h (reduce g)
H1 : le_h (reduce g) h
H0 : reduce g M N
M,N : Msg
H : and (le_h (reduce g) h) (le_h h (reduce g))
g,h : hedge
*****
h (Mop o m0) (Mop o m)
+++++
tauto.
-----
Lemma red_equiv_impl_red_incl : forall g h : hedge, equiv_h (reduce g) h -> inclusion (reduce g) h.
unfold equiv_h in |- *.
unfold inclusion in |- *.
intros.
elim H.
intros.
generalize (le_h_impl_incl_syn (reduce g) h H1).
unfold inclusion in |- *.
intros.
generalize (H3 M N H0).
generalize H0.
unfold reduce in |- *.
case M.
case N.
intros.
elim H4.
intros.
case (op_eq_dec o0 o).
intro.
rewrite e.
rewrite e in H5.
inversion H5.
trivial.
case H7.

*****
H11 : eq N0 m
H10 : eq M0 m0
H8 : eq o1 o
H9 : synthesis h m0 m
M0,N0 : Msg
o1 : op
e : eq o0 o
H7 : or (not (eq o0 o)) (not (synthesis g m0 m))
H6 : g (Mop o0 m0) (Mop o m)
H5 : synthesis h (Mop o m0) (Mop o m)
H4 : and (g (Mop o0 m0) (Mop o m))\n (or (not (eq o0 o)) (not (synthesis g m0 m)))
m0 : Msg
o0 : op
m : Msg
o : op
H3 : forall (M N : Msg) (_ : reduce g M N), synthesis h M N
H2 : le_h h (reduce g)
H1 : le_h (reduce g) h
H0 : reduce g M N
M,N : Msg
H : and (le_h (reduce g) h) (le_h h (reduce g))
g,h : hedge
*****
forall _ : not (synthesis g m0 m), h (Mop o m0) (Mop o m)
+++++
intro.
-----
Lemma red_equiv_impl_red_incl : forall g h : hedge, equiv_h (reduce g) h -> inclusion (reduce g) h.
unfold equiv_h in |- *.
unfold inclusion in |- *.
intros.
elim H.
intros.
generalize (le_h_impl_incl_syn (reduce g) h H1).
unfold inclusion in |- *.
intros.
generalize (H3 M N H0).
generalize H0.
unfold reduce in |- *.
case M.
case N.
intros.
elim H4.
intros.
case (op_eq_dec o0 o).
intro.
rewrite e.
rewrite e in H5.
inversion H5.
trivial.
case H7.
intro.

*****
H12 : not (synthesis g m0 m)
H11 : eq N0 m
H10 : eq M0 m0
H8 : eq o1 o
H9 : synthesis h m0 m
M0,N0 : Msg
o1 : op
e : eq o0 o
H7 : or (not (eq o0 o)) (not (synthesis g m0 m))
H6 : g (Mop o0 m0) (Mop o m)
H5 : synthesis h (Mop o m0) (Mop o m)
H4 : and (g (Mop o0 m0) (Mop o m))\n (or (not (eq o0 o)) (not (synthesis g m0 m)))
m0 : Msg
o0 : op
m : Msg
o : op
H3 : forall (M N : Msg) (_ : reduce g M N), synthesis h M N
H2 : le_h h (reduce g)
H1 : le_h (reduce g) h
H0 : reduce g M N
M,N : Msg
H : and (le_h (reduce g) h) (le_h h (reduce g))
g,h : hedge
*****
h (Mop o m0) (Mop o m)
+++++
cut False.
-----
Lemma red_equiv_impl_red_incl : forall g h : hedge, equiv_h (reduce g) h -> inclusion (reduce g) h.
unfold equiv_h in |- *.
unfold inclusion in |- *.
intros.
elim H.
intros.
generalize (le_h_impl_incl_syn (reduce g) h H1).
unfold inclusion in |- *.
intros.
generalize (H3 M N H0).
generalize H0.
unfold reduce in |- *.
case M.
case N.
intros.
elim H4.
intros.
case (op_eq_dec o0 o).
intro.
rewrite e.
rewrite e in H5.
inversion H5.
trivial.
case H7.
intro.
cut False.

*****
H12 : not (synthesis g m0 m)
H11 : eq N0 m
H10 : eq M0 m0
H8 : eq o1 o
H9 : synthesis h m0 m
M0,N0 : Msg
o1 : op
e : eq o0 o
H7 : or (not (eq o0 o)) (not (synthesis g m0 m))
H6 : g (Mop o0 m0) (Mop o m)
H5 : synthesis h (Mop o m0) (Mop o m)
H4 : and (g (Mop o0 m0) (Mop o m))\n (or (not (eq o0 o)) (not (synthesis g m0 m)))
m0 : Msg
o0 : op
m : Msg
o : op
H3 : forall (M N : Msg) (_ : reduce g M N), synthesis h M N
H2 : le_h h (reduce g)
H1 : le_h (reduce g) h
H0 : reduce g M N
M,N : Msg
H : and (le_h (reduce g) h) (le_h h (reduce g))
g,h : hedge
*****
forall _ : False, h (Mop o m0) (Mop o m)
+++++
try tauto.
-----
Lemma red_equiv_impl_red_incl : forall g h : hedge, equiv_h (reduce g) h -> inclusion (reduce g) h.
unfold equiv_h in |- *.
unfold inclusion in |- *.
intros.
elim H.
intros.
generalize (le_h_impl_incl_syn (reduce g) h H1).
unfold inclusion in |- *.
intros.
generalize (H3 M N H0).
generalize H0.
unfold reduce in |- *.
case M.
case N.
intros.
elim H4.
intros.
case (op_eq_dec o0 o).
intro.
rewrite e.
rewrite e in H5.
inversion H5.
trivial.
case H7.
intro.
cut False.

*****
H12 : not (synthesis g m0 m)
H11 : eq N0 m
H10 : eq M0 m0
H8 : eq o1 o
H9 : synthesis h m0 m
M0,N0 : Msg
o1 : op
e : eq o0 o
H7 : or (not (eq o0 o)) (not (synthesis g m0 m))
H6 : g (Mop o0 m0) (Mop o m)
H5 : synthesis h (Mop o m0) (Mop o m)
H4 : and (g (Mop o0 m0) (Mop o m))\n (or (not (eq o0 o)) (not (synthesis g m0 m)))
m0 : Msg
o0 : op
m : Msg
o : op
H3 : forall (M N : Msg) (_ : reduce g M N), synthesis h M N
H2 : le_h h (reduce g)
H1 : le_h (reduce g) h
H0 : reduce g M N
M,N : Msg
H : and (le_h (reduce g) h) (le_h h (reduce g))
g,h : hedge
*****
False
+++++
try tauto.
-----
Lemma red_equiv_impl_red_incl : forall g h : hedge, equiv_h (reduce g) h -> inclusion (reduce g) h.
unfold equiv_h in |- *.
unfold inclusion in |- *.
intros.
elim H.
intros.
generalize (le_h_impl_incl_syn (reduce g) h H1).
unfold inclusion in |- *.
intros.
generalize (H3 M N H0).
generalize H0.
unfold reduce in |- *.
case M.
case N.
intros.
elim H4.
intros.
case (op_eq_dec o0 o).
intro.
rewrite e.
rewrite e in H5.
inversion H5.
trivial.
case H7.
intro.
cut False.
try tauto.

*****
H12 : not (synthesis g m0 m)
H11 : eq N0 m
H10 : eq M0 m0
H8 : eq o1 o
H9 : synthesis h m0 m
M0,N0 : Msg
o1 : op
e : eq o0 o
H7 : or (not (eq o0 o)) (not (synthesis g m0 m))
H6 : g (Mop o0 m0) (Mop o m)
H5 : synthesis h (Mop o m0) (Mop o m)
H4 : and (g (Mop o0 m0) (Mop o m))\n (or (not (eq o0 o)) (not (synthesis g m0 m)))
m0 : Msg
o0 : op
m : Msg
o : op
H3 : forall (M N : Msg) (_ : reduce g M N), synthesis h M N
H2 : le_h h (reduce g)
H1 : le_h (reduce g) h
H0 : reduce g M N
M,N : Msg
H : and (le_h (reduce g) h) (le_h h (reduce g))
g,h : hedge
*****
False
+++++
apply H12.
-----
Lemma red_equiv_impl_red_incl : forall g h : hedge, equiv_h (reduce g) h -> inclusion (reduce g) h.
unfold equiv_h in |- *.
unfold inclusion in |- *.
intros.
elim H.
intros.
generalize (le_h_impl_incl_syn (reduce g) h H1).
unfold inclusion in |- *.
intros.
generalize (H3 M N H0).
generalize H0.
unfold reduce in |- *.
case M.
case N.
intros.
elim H4.
intros.
case (op_eq_dec o0 o).
intro.
rewrite e.
rewrite e in H5.
inversion H5.
trivial.
case H7.
intro.
cut False.
try tauto.
apply H12.

*****
H12 : not (synthesis g m0 m)
H11 : eq N0 m
H10 : eq M0 m0
H8 : eq o1 o
H9 : synthesis h m0 m
M0,N0 : Msg
o1 : op
e : eq o0 o
H7 : or (not (eq o0 o)) (not (synthesis g m0 m))
H6 : g (Mop o0 m0) (Mop o m)
H5 : synthesis h (Mop o m0) (Mop o m)
H4 : and (g (Mop o0 m0) (Mop o m))\n (or (not (eq o0 o)) (not (synthesis g m0 m)))
m0 : Msg
o0 : op
m : Msg
o : op
H3 : forall (M N : Msg) (_ : reduce g M N), synthesis h M N
H2 : le_h h (reduce g)
H1 : le_h (reduce g) h
H0 : reduce g M N
M,N : Msg
H : and (le_h (reduce g) h) (le_h h (reduce g))
g,h : hedge
*****
synthesis g m0 m
+++++
generalize (le_h_trans h (reduce g) g H2 (inclusion_impl_le_h (reduce g) g (red_incl_h g))).
-----
Lemma red_equiv_impl_red_incl : forall g h : hedge, equiv_h (reduce g) h -> inclusion (reduce g) h.
unfold equiv_h in |- *.
unfold inclusion in |- *.
intros.
elim H.
intros.
generalize (le_h_impl_incl_syn (reduce g) h H1).
unfold inclusion in |- *.
intros.
generalize (H3 M N H0).
generalize H0.
unfold reduce in |- *.
case M.
case N.
intros.
elim H4.
intros.
case (op_eq_dec o0 o).
intro.
rewrite e.
rewrite e in H5.
inversion H5.
trivial.
case H7.
intro.
cut False.
try tauto.
apply H12.
generalize (le_h_trans h (reduce g) g H2 (inclusion_impl_le_h (reduce g) g (red_incl_h g))).

*****
H12 : not (synthesis g m0 m)
H11 : eq N0 m
H10 : eq M0 m0
H8 : eq o1 o
H9 : synthesis h m0 m
M0,N0 : Msg
o1 : op
e : eq o0 o
H7 : or (not (eq o0 o)) (not (synthesis g m0 m))
H6 : g (Mop o0 m0) (Mop o m)
H5 : synthesis h (Mop o m0) (Mop o m)
H4 : and (g (Mop o0 m0) (Mop o m))\n (or (not (eq o0 o)) (not (synthesis g m0 m)))
m0 : Msg
o0 : op
m : Msg
o : op
H3 : forall (M N : Msg) (_ : reduce g M N), synthesis h M N
H2 : le_h h (reduce g)
H1 : le_h (reduce g) h
H0 : reduce g M N
M,N : Msg
H : and (le_h (reduce g) h) (le_h h (reduce g))
g,h : hedge
*****
forall _ : le_h h g, synthesis g m0 m
+++++
unfold le_h in |- *.
-----
Lemma red_equiv_impl_red_incl : forall g h : hedge, equiv_h (reduce g) h -> inclusion (reduce g) h.
unfold equiv_h in |- *.
unfold inclusion in |- *.
intros.
elim H.
intros.
generalize (le_h_impl_incl_syn (reduce g) h H1).
unfold inclusion in |- *.
intros.
generalize (H3 M N H0).
generalize H0.
unfold reduce in |- *.
case M.
case N.
intros.
elim H4.
intros.
case (op_eq_dec o0 o).
intro.
rewrite e.
rewrite e in H5.
inversion H5.
trivial.
case H7.
intro.
cut False.
try tauto.
apply H12.
generalize (le_h_trans h (reduce g) g H2 (inclusion_impl_le_h (reduce g) g (red_incl_h g))).
unfold le_h in |- *.

*****
H12 : not (synthesis g m0 m)
H11 : eq N0 m
H10 : eq M0 m0
H8 : eq o1 o
H9 : synthesis h m0 m
M0,N0 : Msg
o1 : op
e : eq o0 o
H7 : or (not (eq o0 o)) (not (synthesis g m0 m))
H6 : g (Mop o0 m0) (Mop o m)
H5 : synthesis h (Mop o m0) (Mop o m)
H4 : and (g (Mop o0 m0) (Mop o m))\n (or (not (eq o0 o)) (not (synthesis g m0 m)))
m0 : Msg
o0 : op
m : Msg
o : op
H3 : forall (M N : Msg) (_ : reduce g M N), synthesis h M N
H2 : le_h h (reduce g)
H1 : le_h (reduce g) h
H0 : reduce g M N
M,N : Msg
H : and (le_h (reduce g) h) (le_h h (reduce g))
g,h : hedge
*****
forall _ : inclusion (synthesis h) (synthesis g), synthesis g m0 m
+++++
unfold inclusion in |- *.
-----
Lemma red_equiv_impl_red_incl : forall g h : hedge, equiv_h (reduce g) h -> inclusion (reduce g) h.
unfold equiv_h in |- *.
unfold inclusion in |- *.
intros.
elim H.
intros.
generalize (le_h_impl_incl_syn (reduce g) h H1).
unfold inclusion in |- *.
intros.
generalize (H3 M N H0).
generalize H0.
unfold reduce in |- *.
case M.
case N.
intros.
elim H4.
intros.
case (op_eq_dec o0 o).
intro.
rewrite e.
rewrite e in H5.
inversion H5.
trivial.
case H7.
intro.
cut False.
try tauto.
apply H12.
generalize (le_h_trans h (reduce g) g H2 (inclusion_impl_le_h (reduce g) g (red_incl_h g))).
unfold le_h in |- *.
unfold inclusion in |- *.

*****
H12 : not (synthesis g m0 m)
H11 : eq N0 m
H10 : eq M0 m0
H8 : eq o1 o
H9 : synthesis h m0 m
M0,N0 : Msg
o1 : op
e : eq o0 o
H7 : or (not (eq o0 o)) (not (synthesis g m0 m))
H6 : g (Mop o0 m0) (Mop o m)
H5 : synthesis h (Mop o m0) (Mop o m)
H4 : and (g (Mop o0 m0) (Mop o m))\n (or (not (eq o0 o)) (not (synthesis g m0 m)))
m0 : Msg
o0 : op
m : Msg
o : op
H3 : forall (M N : Msg) (_ : reduce g M N), synthesis h M N
H2 : le_h h (reduce g)
H1 : le_h (reduce g) h
H0 : reduce g M N
M,N : Msg
H : and (le_h (reduce g) h) (le_h h (reduce g))
g,h : hedge
*****
forall _ : forall (M N : Msg) (_ : synthesis h M N), synthesis g M N, synthesis g m0 m
+++++
auto.
-----
Lemma red_equiv_impl_red_incl : forall g h : hedge, equiv_h (reduce g) h -> inclusion (reduce g) h.
unfold equiv_h in |- *.
unfold inclusion in |- *.
intros.
elim H.
intros.
generalize (le_h_impl_incl_syn (reduce g) h H1).
unfold inclusion in |- *.
intros.
generalize (H3 M N H0).
generalize H0.
unfold reduce in |- *.
case M.
case N.
intros.
elim H4.
intros.
case (op_eq_dec o0 o).

*****
H7 : or (not (eq o0 o)) (not (synthesis g m0 m))
H6 : g (Mop o0 m0) (Mop o m)
H5 : synthesis h (Mop o0 m0) (Mop o m)
H4 : and (g (Mop o0 m0) (Mop o m))\n (or (not (eq o0 o)) (not (synthesis g m0 m)))
m0 : Msg
o0 : op
m : Msg
o : op
H3 : forall (M N : Msg) (_ : reduce g M N), synthesis h M N
H2 : le_h h (reduce g)
H1 : le_h (reduce g) h
H0 : reduce g M N
M,N : Msg
H : and (le_h (reduce g) h) (le_h h (reduce g))
g,h : hedge
*****
forall _ : not (eq o0 o), h (Mop o0 m0) (Mop o m)
+++++
intro.
-----
Lemma red_equiv_impl_red_incl : forall g h : hedge, equiv_h (reduce g) h -> inclusion (reduce g) h.
unfold equiv_h in |- *.
unfold inclusion in |- *.
intros.
elim H.
intros.
generalize (le_h_impl_incl_syn (reduce g) h H1).
unfold inclusion in |- *.
intros.
generalize (H3 M N H0).
generalize H0.
unfold reduce in |- *.
case M.
case N.
intros.
elim H4.
intros.
case (op_eq_dec o0 o).
intro.

*****
n : not (eq o0 o)
H7 : or (not (eq o0 o)) (not (synthesis g m0 m))
H6 : g (Mop o0 m0) (Mop o m)
H5 : synthesis h (Mop o0 m0) (Mop o m)
H4 : and (g (Mop o0 m0) (Mop o m))\n (or (not (eq o0 o)) (not (synthesis g m0 m)))
m0 : Msg
o0 : op
m : Msg
o : op
H3 : forall (M N : Msg) (_ : reduce g M N), synthesis h M N
H2 : le_h h (reduce g)
H1 : le_h (reduce g) h
H0 : reduce g M N
M,N : Msg
H : and (le_h (reduce g) h) (le_h h (reduce g))
g,h : hedge
*****
h (Mop o0 m0) (Mop o m)
+++++
inversion H5.
-----
Lemma red_equiv_impl_red_incl : forall g h : hedge, equiv_h (reduce g) h -> inclusion (reduce g) h.
unfold equiv_h in |- *.
unfold inclusion in |- *.
intros.
elim H.
intros.
generalize (le_h_impl_incl_syn (reduce g) h H1).
unfold inclusion in |- *.
intros.
generalize (H3 M N H0).
generalize H0.
unfold reduce in |- *.
case M.
case N.
intros.
elim H4.
intros.
case (op_eq_dec o0 o).
intro.
inversion H5.

*****
H10 : eq N0 (Mop o m)
H9 : eq M0 (Mop o0 m0)
H8 : h (Mop o0 m0) (Mop o m)
M0,N0 : Msg
n : not (eq o0 o)
H7 : or (not (eq o0 o)) (not (synthesis g m0 m))
H6 : g (Mop o0 m0) (Mop o m)
H5 : synthesis h (Mop o0 m0) (Mop o m)
H4 : and (g (Mop o0 m0) (Mop o m))\n (or (not (eq o0 o)) (not (synthesis g m0 m)))
m0 : Msg
o0 : op
m : Msg
o : op
H3 : forall (M N : Msg) (_ : reduce g M N), synthesis h M N
H2 : le_h h (reduce g)
H1 : le_h (reduce g) h
H0 : reduce g M N
M,N : Msg
H : and (le_h (reduce g) h) (le_h h (reduce g))
g,h : hedge
*****
h (Mop o0 m0) (Mop o m)
+++++
trivial.
-----
Lemma red_equiv_impl_red_incl : forall g h : hedge, equiv_h (reduce g) h -> inclusion (reduce g) h.
unfold equiv_h in |- *.
unfold inclusion in |- *.
intros.
elim H.
intros.
generalize (le_h_impl_incl_syn (reduce g) h H1).
unfold inclusion in |- *.
intros.
generalize (H3 M N H0).
generalize H0.
unfold reduce in |- *.
case M.
case N.
intros.
elim H4.
intros.
case (op_eq_dec o0 o).
intro.
inversion H5.

*****
H12 : eq N0 m
H11 : eq o0 o
H10 : eq M0 m0
H8 : eq o1 o0
H9 : synthesis h m0 m
M0,N0 : Msg
o1 : op
n : not (eq o0 o)
H7 : or (not (eq o0 o)) (not (synthesis g m0 m))
H6 : g (Mop o0 m0) (Mop o m)
H5 : synthesis h (Mop o0 m0) (Mop o m)
H4 : and (g (Mop o0 m0) (Mop o m))\n (or (not (eq o0 o)) (not (synthesis g m0 m)))
m0 : Msg
o0 : op
m : Msg
o : op
H3 : forall (M N : Msg) (_ : reduce g M N), synthesis h M N
H2 : le_h h (reduce g)
H1 : le_h (reduce g) h
H0 : reduce g M N
M,N : Msg
H : and (le_h (reduce g) h) (le_h h (reduce g))
g,h : hedge
*****
h (Mop o m0) (Mop o m)
+++++
trivial.
-----
Lemma red_equiv_impl_red_incl : forall g h : hedge, equiv_h (reduce g) h -> inclusion (reduce g) h.
unfold equiv_h in |- *.
unfold inclusion in |- *.
intros.
elim H.
intros.
generalize (le_h_impl_incl_syn (reduce g) h H1).
unfold inclusion in |- *.
intros.
generalize (H3 M N H0).
generalize H0.
unfold reduce in |- *.
case M.
case N.
intros.
elim H4.
intros.
case (op_eq_dec o0 o).
intro.
inversion H5.
trivial.

*****
H12 : eq N0 m
H11 : eq o0 o
H10 : eq M0 m0
H8 : eq o1 o0
H9 : synthesis h m0 m
M0,N0 : Msg
o1 : op
n : not (eq o0 o)
H7 : or (not (eq o0 o)) (not (synthesis g m0 m))
H6 : g (Mop o0 m0) (Mop o m)
H5 : synthesis h (Mop o0 m0) (Mop o m)
H4 : and (g (Mop o0 m0) (Mop o m))\n (or (not (eq o0 o)) (not (synthesis g m0 m)))
m0 : Msg
o0 : op
m : Msg
o : op
H3 : forall (M N : Msg) (_ : reduce g M N), synthesis h M N
H2 : le_h h (reduce g)
H1 : le_h (reduce g) h
H0 : reduce g M N
M,N : Msg
H : and (le_h (reduce g) h) (le_h h (reduce g))
g,h : hedge
*****
h (Mop o m0) (Mop o m)
+++++
tauto.
-----
Lemma red_equiv_impl_red_incl : forall g h : hedge, equiv_h (reduce g) h -> inclusion (reduce g) h.
unfold equiv_h in |- *.
unfold inclusion in |- *.
intros.
elim H.
intros.
generalize (le_h_impl_incl_syn (reduce g) h H1).
unfold inclusion in |- *.
intros.
generalize (H3 M N H0).
generalize H0.
unfold reduce in |- *.
case M.

*****

*****

+++++
Qed.
-----
Lemma red_stable_le_h :\n forall g h : hedge, le_h g h -> le_h (reduce g) (reduce h).
-----
Lemma red_stable_le_h : forall g h : hedge, le_h g h -> le_h (reduce g) (reduce h).

*****

*****
forall (g h : hedge) (_ : le_h g h), le_h (reduce g) (reduce h)
+++++
intros.
-----
Lemma red_stable_le_h : forall g h : hedge, le_h g h -> le_h (reduce g) (reduce h).
intros.

*****
H : le_h g h
g,h : hedge
*****
le_h (reduce g) (reduce h)
+++++
apply le_h_trans with h.
-----
Lemma red_stable_le_h : forall g h : hedge, le_h g h -> le_h (reduce g) (reduce h).
intros.
apply le_h_trans with h.

*****
H : le_h g h
g,h : hedge
*****
le_h (reduce g) h
+++++
apply le_h_trans with g.
-----
Lemma red_stable_le_h : forall g h : hedge, le_h g h -> le_h (reduce g) (reduce h).
intros.
apply le_h_trans with h.
apply le_h_trans with g.

*****
H : le_h g h
g,h : hedge
*****
le_h (reduce g) g
+++++
trivial.
-----
Lemma red_stable_le_h : forall g h : hedge, le_h g h -> le_h (reduce g) (reduce h).
intros.
apply le_h_trans with h.
apply le_h_trans with g.
trivial.

*****
H : le_h g h
g,h : hedge
*****
le_h (reduce g) g
+++++
apply inclusion_impl_le_h.
-----
Lemma red_stable_le_h : forall g h : hedge, le_h g h -> le_h (reduce g) (reduce h).
intros.
apply le_h_trans with h.
apply le_h_trans with g.
trivial.
apply inclusion_impl_le_h.

*****
H : le_h g h
g,h : hedge
*****
inclusion (reduce g) g
+++++
apply red_incl_h.
-----
Lemma red_stable_le_h : forall g h : hedge, le_h g h -> le_h (reduce g) (reduce h).
intros.
apply le_h_trans with h.
apply le_h_trans with g.

*****
H : le_h g h
g,h : hedge
*****
le_h g h
+++++
trivial.
-----
Lemma red_stable_le_h : forall g h : hedge, le_h g h -> le_h (reduce g) (reduce h).
intros.
apply le_h_trans with h.

*****
H : le_h g h
g,h : hedge
*****
le_h h (reduce h)
+++++
apply h_le_h_red.
-----
Lemma red_stable_le_h : forall g h : hedge, le_h g h -> le_h (reduce g) (reduce h).
intros.
apply le_h_trans with h.

*****

*****

+++++
Qed.
-----
Definition stable_analysis (h : hedge) := inclusion (analysis h) h.
-----
Lemma stable_closed :\n forall h : hedge, stable_analysis h -> equal h (analysis h).
-----
Lemma stable_closed : forall h : hedge, stable_analysis h -> equal h (analysis h).

*****

*****
forall (h : hedge) (_ : stable_analysis h), equal h (analysis h)
+++++
intro.
-----
Lemma stable_closed : forall h : hedge, stable_analysis h -> equal h (analysis h).
intro.

*****
h : hedge
*****
forall _ : stable_analysis h, equal h (analysis h)
+++++
unfold stable_analysis in |- *.
-----
Lemma stable_closed : forall h : hedge, stable_analysis h -> equal h (analysis h).
intro.
unfold stable_analysis in |- *.

*****
h : hedge
*****
forall _ : inclusion (analysis h) h, equal h (analysis h)
+++++
unfold equal in |- *.
-----
Lemma stable_closed : forall h : hedge, stable_analysis h -> equal h (analysis h).
intro.
unfold stable_analysis in |- *.
unfold equal in |- *.

*****
h : hedge
*****
forall _ : inclusion (analysis h) h, and (inclusion h (analysis h)) (inclusion (analysis h) h)
+++++
intro.
-----
Lemma stable_closed : forall h : hedge, stable_analysis h -> equal h (analysis h).
intro.
unfold stable_analysis in |- *.
unfold equal in |- *.
intro.

*****
H : inclusion (analysis h) h
h : hedge
*****
and (inclusion h (analysis h)) (inclusion (analysis h) h)
+++++
split.
-----
Lemma stable_closed : forall h : hedge, stable_analysis h -> equal h (analysis h).
intro.
unfold stable_analysis in |- *.
unfold equal in |- *.
intro.
split.

*****
H : inclusion (analysis h) h
h : hedge
*****
inclusion h (analysis h)
+++++
trivial.
-----
Lemma stable_closed : forall h : hedge, stable_analysis h -> equal h (analysis h).
intro.
unfold stable_analysis in |- *.
unfold equal in |- *.
intro.
split.
trivial.

*****
H : inclusion (analysis h) h
h : hedge
*****
inclusion h (analysis h)
+++++
unfold inclusion in |- *.
-----
Lemma stable_closed : forall h : hedge, stable_analysis h -> equal h (analysis h).
intro.
unfold stable_analysis in |- *.
unfold equal in |- *.
intro.
split.
trivial.
unfold inclusion in |- *.

*****
H : inclusion (analysis h) h
h : hedge
*****
forall (M N : Msg) (_ : h M N), analysis h M N
+++++
intros.
-----
Lemma stable_closed : forall h : hedge, stable_analysis h -> equal h (analysis h).
intro.
unfold stable_analysis in |- *.
unfold equal in |- *.
intro.
split.
trivial.
unfold inclusion in |- *.
intros.

*****
H0 : h M N
M,N : Msg
H : inclusion (analysis h) h
h : hedge
*****
analysis h M N
+++++
apply AnaInc.
-----
Lemma stable_closed : forall h : hedge, stable_analysis h -> equal h (analysis h).
intro.
unfold stable_analysis in |- *.
unfold equal in |- *.
intro.
split.
trivial.
unfold inclusion in |- *.
intros.
apply AnaInc.

*****
H0 : h M N
M,N : Msg
H : inclusion (analysis h) h
h : hedge
*****
h M N
+++++
trivial.
-----
Lemma stable_closed : forall h : hedge, stable_analysis h -> equal h (analysis h).
intro.
unfold stable_analysis in |- *.
unfold equal in |- *.
intro.
split.

*****
H : inclusion (analysis h) h
h : hedge
*****
inclusion (analysis h) h
+++++
trivial.
-----
Lemma stable_closed : forall h : hedge, stable_analysis h -> equal h (analysis h).
intro.
unfold stable_analysis in |- *.
unfold equal in |- *.
intro.
split.

*****

*****

+++++
Qed.
-----
Lemma stable_impl_ana_stable :\n forall h : hedge, stable_analysis h -> stable_analysis (analysis h).
-----
Lemma stable_impl_ana_stable : forall h : hedge, stable_analysis h -> stable_analysis (analysis h).

*****

*****
forall (h : hedge) (_ : stable_analysis h), stable_analysis (analysis h)
+++++
intros.
-----
Lemma stable_impl_ana_stable : forall h : hedge, stable_analysis h -> stable_analysis (analysis h).
intros.

*****
H : stable_analysis h
h : hedge
*****
stable_analysis (analysis h)
+++++
unfold stable_analysis in |- *.
-----
Lemma stable_impl_ana_stable : forall h : hedge, stable_analysis h -> stable_analysis (analysis h).
intros.
unfold stable_analysis in |- *.

*****
H : stable_analysis h
h : hedge
*****
inclusion (analysis (analysis h)) (analysis h)
+++++
apply inclusion_analysis_inclusion.
-----
Lemma stable_impl_ana_stable : forall h : hedge, stable_analysis h -> stable_analysis (analysis h).
intros.
unfold stable_analysis in |- *.
apply inclusion_analysis_inclusion.

*****
H : stable_analysis h
h : hedge
*****
inclusion (analysis h) h
+++++
unfold stable_analysis in H.
-----
Lemma stable_impl_ana_stable : forall h : hedge, stable_analysis h -> stable_analysis (analysis h).
intros.
unfold stable_analysis in |- *.
apply inclusion_analysis_inclusion.
unfold stable_analysis in H.

*****
H : inclusion (analysis h) h
h : hedge
*****
inclusion (analysis h) h
+++++
trivial.
-----
Lemma stable_impl_ana_stable : forall h : hedge, stable_analysis h -> stable_analysis (analysis h).
intros.
unfold stable_analysis in |- *.
apply inclusion_analysis_inclusion.
unfold stable_analysis in H.
trivial.

*****

*****

+++++
Qed.
-----
Lemma stable_ana_stable :\n forall (h : hedge) (n : nat),\n stable_analysis (analysis_seq h n) ->\n forall p : nat, stable_analysis (analysis_seq h (p + n)).
-----
Lemma stable_ana_stable : forall (h : hedge) (n : nat), stable_analysis (analysis_seq h n) -> forall p : nat, stable_analysis (analysis_seq h (p + n)).

*****

*****
forall (h : hedge) (n : nat) (_ : stable_analysis (analysis_seq h n)) (p : nat), stable_analysis (analysis_seq h (Init.Nat.add p n))
+++++
intros.
-----
Lemma stable_ana_stable : forall (h : hedge) (n : nat), stable_analysis (analysis_seq h n) -> forall p : nat, stable_analysis (analysis_seq h (p + n)).
intros.

*****
p : nat
H : stable_analysis (analysis_seq h n)
n : nat
h : hedge
*****
stable_analysis (analysis_seq h (Init.Nat.add p n))
+++++
induction p as [| p Hrecp].
-----
Lemma stable_ana_stable : forall (h : hedge) (n : nat), stable_analysis (analysis_seq h n) -> forall p : nat, stable_analysis (analysis_seq h (p + n)).
intros.
induction p as [| p Hrecp].

*****
H : stable_analysis (analysis_seq h n)
n : nat
h : hedge
*****
stable_analysis (analysis_seq h (Init.Nat.add O n))
+++++
simpl in |- *.
-----
Lemma stable_ana_stable : forall (h : hedge) (n : nat), stable_analysis (analysis_seq h n) -> forall p : nat, stable_analysis (analysis_seq h (p + n)).
intros.
induction p as [| p Hrecp].
simpl in |- *.

*****
H : stable_analysis (analysis_seq h n)
n : nat
h : hedge
*****
stable_analysis (analysis_seq h n)
+++++
trivial.
-----
Lemma stable_ana_stable : forall (h : hedge) (n : nat), stable_analysis (analysis_seq h n) -> forall p : nat, stable_analysis (analysis_seq h (p + n)).
intros.
induction p as [| p Hrecp].

*****
Hrecp : stable_analysis (analysis_seq h (Init.Nat.add p n))
p : nat
H : stable_analysis (analysis_seq h n)
n : nat
h : hedge
*****
stable_analysis (analysis_seq h (Init.Nat.add (S p) n))
+++++
simpl in |- *.
-----
Lemma stable_ana_stable : forall (h : hedge) (n : nat), stable_analysis (analysis_seq h n) -> forall p : nat, stable_analysis (analysis_seq h (p + n)).
intros.
induction p as [| p Hrecp].
simpl in |- *.

*****
Hrecp : stable_analysis (analysis_seq h (Init.Nat.add p n))
p : nat
H : stable_analysis (analysis_seq h n)
n : nat
h : hedge
*****
stable_analysis (analysis (analysis_seq h (Init.Nat.add p n)))
+++++
apply stable_impl_ana_stable.
-----
Lemma stable_ana_stable : forall (h : hedge) (n : nat), stable_analysis (analysis_seq h n) -> forall p : nat, stable_analysis (analysis_seq h (p + n)).
intros.
induction p as [| p Hrecp].
simpl in |- *.
apply stable_impl_ana_stable.

*****
Hrecp : stable_analysis (analysis_seq h (Init.Nat.add p n))
p : nat
H : stable_analysis (analysis_seq h n)
n : nat
h : hedge
*****
stable_analysis (analysis_seq h (Init.Nat.add p n))
+++++
trivial.
-----
Lemma stable_ana_stable : forall (h : hedge) (n : nat), stable_analysis (analysis_seq h n) -> forall p : nat, stable_analysis (analysis_seq h (p + n)).
intros.
induction p as [| p Hrecp].

*****

*****

+++++
Qed.
-----
Lemma stable_ana_const :\n forall (h : hedge) (n : nat),\n stable_analysis (analysis_seq h n) ->\n forall p : nat, equal (analysis_seq h n) (analysis_seq h (p + n)).
-----
Lemma stable_ana_const : forall (h : hedge) (n : nat), stable_analysis (analysis_seq h n) -> forall p : nat, equal (analysis_seq h n) (analysis_seq h (p + n)).

*****

*****
forall (h : hedge) (n : nat) (_ : stable_analysis (analysis_seq h n)) (p : nat), equal (analysis_seq h n) (analysis_seq h (Init.Nat.add p n))
+++++
intros.
-----
Lemma stable_ana_const : forall (h : hedge) (n : nat), stable_analysis (analysis_seq h n) -> forall p : nat, equal (analysis_seq h n) (analysis_seq h (p + n)).
intros.

*****
p : nat
H : stable_analysis (analysis_seq h n)
n : nat
h : hedge
*****
equal (analysis_seq h n) (analysis_seq h (Init.Nat.add p n))
+++++
induction p as [| p Hrecp].
-----
Lemma stable_ana_const : forall (h : hedge) (n : nat), stable_analysis (analysis_seq h n) -> forall p : nat, equal (analysis_seq h n) (analysis_seq h (p + n)).
intros.
induction p as [| p Hrecp].

*****
H : stable_analysis (analysis_seq h n)
n : nat
h : hedge
*****
equal (analysis_seq h n) (analysis_seq h (Init.Nat.add O n))
+++++
simpl in |- *.
-----
Lemma stable_ana_const : forall (h : hedge) (n : nat), stable_analysis (analysis_seq h n) -> forall p : nat, equal (analysis_seq h n) (analysis_seq h (p + n)).
intros.
induction p as [| p Hrecp].
simpl in |- *.

*****
H : stable_analysis (analysis_seq h n)
n : nat
h : hedge
*****
equal (analysis_seq h n) (analysis_seq h n)
+++++
apply equal_refl.
-----
Lemma stable_ana_const : forall (h : hedge) (n : nat), stable_analysis (analysis_seq h n) -> forall p : nat, equal (analysis_seq h n) (analysis_seq h (p + n)).
intros.
induction p as [| p Hrecp].

*****
Hrecp : equal (analysis_seq h n) (analysis_seq h (Init.Nat.add p n))
p : nat
H : stable_analysis (analysis_seq h n)
n : nat
h : hedge
*****
equal (analysis_seq h n) (analysis_seq h (Init.Nat.add (S p) n))
+++++
apply equal_trans with (analysis_seq h (p + n)).
-----
Lemma stable_ana_const : forall (h : hedge) (n : nat), stable_analysis (analysis_seq h n) -> forall p : nat, equal (analysis_seq h n) (analysis_seq h (p + n)).
intros.
induction p as [| p Hrecp].
apply equal_trans with (analysis_seq h (p + n)).

*****
Hrecp : equal (analysis_seq h n) (analysis_seq h (Init.Nat.add p n))
p : nat
H : stable_analysis (analysis_seq h n)
n : nat
h : hedge
*****
equal (analysis_seq h n) (analysis_seq h (Init.Nat.add p n))
+++++
trivial.
-----
Lemma stable_ana_const : forall (h : hedge) (n : nat), stable_analysis (analysis_seq h n) -> forall p : nat, equal (analysis_seq h n) (analysis_seq h (p + n)).
intros.
induction p as [| p Hrecp].
apply equal_trans with (analysis_seq h (p + n)).

*****
Hrecp : equal (analysis_seq h n) (analysis_seq h (Init.Nat.add p n))
p : nat
H : stable_analysis (analysis_seq h n)
n : nat
h : hedge
*****
equal (analysis_seq h (Init.Nat.add p n)) (analysis_seq h (Init.Nat.add (S p) n))
+++++
simpl in |- *.
-----
Lemma stable_ana_const : forall (h : hedge) (n : nat), stable_analysis (analysis_seq h n) -> forall p : nat, equal (analysis_seq h n) (analysis_seq h (p + n)).
intros.
induction p as [| p Hrecp].
apply equal_trans with (analysis_seq h (p + n)).
simpl in |- *.

*****
Hrecp : equal (analysis_seq h n) (analysis_seq h (Init.Nat.add p n))
p : nat
H : stable_analysis (analysis_seq h n)
n : nat
h : hedge
*****
equal (analysis_seq h (Init.Nat.add p n)) (analysis (analysis_seq h (Init.Nat.add p n)))
+++++
apply stable_closed.
-----
Lemma stable_ana_const : forall (h : hedge) (n : nat), stable_analysis (analysis_seq h n) -> forall p : nat, equal (analysis_seq h n) (analysis_seq h (p + n)).
intros.
induction p as [| p Hrecp].
apply equal_trans with (analysis_seq h (p + n)).
simpl in |- *.
apply stable_closed.

*****
Hrecp : equal (analysis_seq h n) (analysis_seq h (Init.Nat.add p n))
p : nat
H : stable_analysis (analysis_seq h n)
n : nat
h : hedge
*****
stable_analysis (analysis_seq h (Init.Nat.add p n))
+++++
apply stable_ana_stable.
-----
Lemma stable_ana_const : forall (h : hedge) (n : nat), stable_analysis (analysis_seq h n) -> forall p : nat, equal (analysis_seq h n) (analysis_seq h (p + n)).
intros.
induction p as [| p Hrecp].
apply equal_trans with (analysis_seq h (p + n)).
simpl in |- *.
apply stable_closed.
apply stable_ana_stable.

*****
Hrecp : equal (analysis_seq h n) (analysis_seq h (Init.Nat.add p n))
p : nat
H : stable_analysis (analysis_seq h n)
n : nat
h : hedge
*****
stable_analysis (analysis_seq h n)
+++++
trivial.
-----
Lemma stable_ana_const : forall (h : hedge) (n : nat), stable_analysis (analysis_seq h n) -> forall p : nat, equal (analysis_seq h n) (analysis_seq h (p + n)).
intros.
induction p as [| p Hrecp].

*****

*****

+++++
Qed.
-----
Definition analysis_cond (g h : hedge) := inclusion g h /\ stable_analysis h.
-----
Lemma analysis_seq_incl_analysis_cond :\n forall g h : hedge,\n analysis_cond g h -> forall n : nat, inclusion (analysis_seq g n) h.
-----
Lemma analysis_seq_incl_analysis_cond : forall g h : hedge, analysis_cond g h -> forall n : nat, inclusion (analysis_seq g n) h.

*****

*****
forall (g h : hedge) (_ : analysis_cond g h) (n : nat), inclusion (analysis_seq g n) h
+++++
intros.
-----
Lemma analysis_seq_incl_analysis_cond : forall g h : hedge, analysis_cond g h -> forall n : nat, inclusion (analysis_seq g n) h.
intros.

*****
n : nat
H : analysis_cond g h
g,h : hedge
*****
inclusion (analysis_seq g n) h
+++++
induction n as [| n Hrecn].
-----
Lemma analysis_seq_incl_analysis_cond : forall g h : hedge, analysis_cond g h -> forall n : nat, inclusion (analysis_seq g n) h.
intros.
induction n as [| n Hrecn].

*****
H : analysis_cond g h
g,h : hedge
*****
inclusion (analysis_seq g O) h
+++++
simpl in |- *.
-----
Lemma analysis_seq_incl_analysis_cond : forall g h : hedge, analysis_cond g h -> forall n : nat, inclusion (analysis_seq g n) h.
intros.
induction n as [| n Hrecn].
simpl in |- *.

*****
H : analysis_cond g h
g,h : hedge
*****
inclusion g h
+++++
unfold analysis_cond in H.
-----
Lemma analysis_seq_incl_analysis_cond : forall g h : hedge, analysis_cond g h -> forall n : nat, inclusion (analysis_seq g n) h.
intros.
induction n as [| n Hrecn].
simpl in |- *.
unfold analysis_cond in H.

*****
H : and (inclusion g h) (stable_analysis h)
g,h : hedge
*****
inclusion g h
+++++
tauto.
-----
Lemma analysis_seq_incl_analysis_cond : forall g h : hedge, analysis_cond g h -> forall n : nat, inclusion (analysis_seq g n) h.
intros.
induction n as [| n Hrecn].

*****
Hrecn : inclusion (analysis_seq g n) h
n : nat
H : analysis_cond g h
g,h : hedge
*****
inclusion (analysis_seq g (S n)) h
+++++
simpl in |- *.
-----
Lemma analysis_seq_incl_analysis_cond : forall g h : hedge, analysis_cond g h -> forall n : nat, inclusion (analysis_seq g n) h.
intros.
induction n as [| n Hrecn].
simpl in |- *.

*****
Hrecn : inclusion (analysis_seq g n) h
n : nat
H : analysis_cond g h
g,h : hedge
*****
inclusion (analysis (analysis_seq g n)) h
+++++
generalize (inclusion_analysis_inclusion (analysis_seq g n) h Hrecn).
-----
Lemma analysis_seq_incl_analysis_cond : forall g h : hedge, analysis_cond g h -> forall n : nat, inclusion (analysis_seq g n) h.
intros.
induction n as [| n Hrecn].
simpl in |- *.
generalize (inclusion_analysis_inclusion (analysis_seq g n) h Hrecn).

*****
Hrecn : inclusion (analysis_seq g n) h
n : nat
H : analysis_cond g h
g,h : hedge
*****
forall _ : inclusion (analysis (analysis_seq g n)) (analysis h), inclusion (analysis (analysis_seq g n)) h
+++++
intro.
-----
Lemma analysis_seq_incl_analysis_cond : forall g h : hedge, analysis_cond g h -> forall n : nat, inclusion (analysis_seq g n) h.
intros.
induction n as [| n Hrecn].
simpl in |- *.
generalize (inclusion_analysis_inclusion (analysis_seq g n) h Hrecn).
intro.

*****
H0 : inclusion (analysis (analysis_seq g n)) (analysis h)
Hrecn : inclusion (analysis_seq g n) h
n : nat
H : analysis_cond g h
g,h : hedge
*****
inclusion (analysis (analysis_seq g n)) h
+++++
apply inclusion_trans with (analysis h).
-----
Lemma analysis_seq_incl_analysis_cond : forall g h : hedge, analysis_cond g h -> forall n : nat, inclusion (analysis_seq g n) h.
intros.
induction n as [| n Hrecn].
simpl in |- *.
generalize (inclusion_analysis_inclusion (analysis_seq g n) h Hrecn).
intro.
apply inclusion_trans with (analysis h).

*****
H0 : inclusion (analysis (analysis_seq g n)) (analysis h)
Hrecn : inclusion (analysis_seq g n) h
n : nat
H : analysis_cond g h
g,h : hedge
*****
inclusion (analysis (analysis_seq g n)) (analysis h)
+++++
trivial.
-----
Lemma analysis_seq_incl_analysis_cond : forall g h : hedge, analysis_cond g h -> forall n : nat, inclusion (analysis_seq g n) h.
intros.
induction n as [| n Hrecn].
simpl in |- *.
generalize (inclusion_analysis_inclusion (analysis_seq g n) h Hrecn).
intro.
apply inclusion_trans with (analysis h).

*****
H0 : inclusion (analysis (analysis_seq g n)) (analysis h)
Hrecn : inclusion (analysis_seq g n) h
n : nat
H : analysis_cond g h
g,h : hedge
*****
inclusion (analysis h) h
+++++
trivial.
-----
Lemma analysis_seq_incl_analysis_cond : forall g h : hedge, analysis_cond g h -> forall n : nat, inclusion (analysis_seq g n) h.
intros.
induction n as [| n Hrecn].
simpl in |- *.
generalize (inclusion_analysis_inclusion (analysis_seq g n) h Hrecn).
intro.
apply inclusion_trans with (analysis h).
trivial.

*****
H0 : inclusion (analysis (analysis_seq g n)) (analysis h)
Hrecn : inclusion (analysis_seq g n) h
n : nat
H : analysis_cond g h
g,h : hedge
*****
inclusion (analysis h) h
+++++
unfold analysis_cond in H.
-----
Lemma analysis_seq_incl_analysis_cond : forall g h : hedge, analysis_cond g h -> forall n : nat, inclusion (analysis_seq g n) h.
intros.
induction n as [| n Hrecn].
simpl in |- *.
generalize (inclusion_analysis_inclusion (analysis_seq g n) h Hrecn).
intro.
apply inclusion_trans with (analysis h).
trivial.
unfold analysis_cond in H.

*****
H0 : inclusion (analysis (analysis_seq g n)) (analysis h)
Hrecn : inclusion (analysis_seq g n) h
n : nat
H : and (inclusion g h) (stable_analysis h)
g,h : hedge
*****
inclusion (analysis h) h
+++++
unfold stable_analysis in H.
-----
Lemma analysis_seq_incl_analysis_cond : forall g h : hedge, analysis_cond g h -> forall n : nat, inclusion (analysis_seq g n) h.
intros.
induction n as [| n Hrecn].
simpl in |- *.
generalize (inclusion_analysis_inclusion (analysis_seq g n) h Hrecn).
intro.
apply inclusion_trans with (analysis h).
trivial.
unfold analysis_cond in H.
unfold stable_analysis in H.

*****
H0 : inclusion (analysis (analysis_seq g n)) (analysis h)
Hrecn : inclusion (analysis_seq g n) h
n : nat
H : and (inclusion g h) (inclusion (analysis h) h)
g,h : hedge
*****
inclusion (analysis h) h
+++++
tauto.
-----
Lemma analysis_seq_incl_analysis_cond : forall g h : hedge, analysis_cond g h -> forall n : nat, inclusion (analysis_seq g n) h.
intros.
induction n as [| n Hrecn].

*****

*****

+++++
Qed.
-----
Definition is_analysis (g h : hedge) :=\n  analysis_cond g h /\\n  (forall h' : hedge, analysis_cond g h' -> inclusion h h').
-----
Lemma analysis_seq_incl_analysis :\n forall g h : hedge,\n is_analysis g h -> forall n : nat, inclusion (analysis_seq g n) h.
-----
Lemma analysis_seq_incl_analysis : forall g h : hedge, is_analysis g h -> forall n : nat, inclusion (analysis_seq g n) h.

*****

*****
forall (g h : hedge) (_ : is_analysis g h) (n : nat), inclusion (analysis_seq g n) h
+++++
unfold is_analysis in |- *.
-----
Lemma analysis_seq_incl_analysis : forall g h : hedge, is_analysis g h -> forall n : nat, inclusion (analysis_seq g n) h.
unfold is_analysis in |- *.

*****

*****
forall (g h : hedge) (_ : and (analysis_cond g h) (forall (h' : hedge) (_ : analysis_cond g h'), inclusion h h')) (n : nat), inclusion (analysis_seq g n) h
+++++
intros.
-----
Lemma analysis_seq_incl_analysis : forall g h : hedge, is_analysis g h -> forall n : nat, inclusion (analysis_seq g n) h.
unfold is_analysis in |- *.
intros.

*****
n : nat
H : and (analysis_cond g h)\n (forall (h' : hedge) (_ : analysis_cond g h'), inclusion h h')
g,h : hedge
*****
inclusion (analysis_seq g n) h
+++++
apply analysis_seq_incl_analysis_cond.
-----
Lemma analysis_seq_incl_analysis : forall g h : hedge, is_analysis g h -> forall n : nat, inclusion (analysis_seq g n) h.
unfold is_analysis in |- *.
intros.
apply analysis_seq_incl_analysis_cond.

*****
n : nat
H : and (analysis_cond g h)\n (forall (h' : hedge) (_ : analysis_cond g h'), inclusion h h')
g,h : hedge
*****
analysis_cond g h
+++++
tauto.
-----
Lemma analysis_seq_incl_analysis : forall g h : hedge, is_analysis g h -> forall n : nat, inclusion (analysis_seq g n) h.
unfold is_analysis in |- *.
intros.
apply analysis_seq_incl_analysis_cond.
tauto.

*****

*****

+++++
Qed.
-----
Lemma analysis_unique :\n forall g h h' : hedge, is_analysis g h -> is_analysis g h' -> equal h h'.
-----
Lemma analysis_unique : forall g h h' : hedge, is_analysis g h -> is_analysis g h' -> equal h h'.

*****

*****
forall (g h h' : hedge) (_ : is_analysis g h) (_ : is_analysis g h'), equal h h'
+++++
unfold is_analysis in |- *.
-----
Lemma analysis_unique : forall g h h' : hedge, is_analysis g h -> is_analysis g h' -> equal h h'.
unfold is_analysis in |- *.

*****

*****
forall (g h h' : hedge) (_ : and (analysis_cond g h) (forall (h'0 : hedge) (_ : analysis_cond g h'0), inclusion h h'0)) (_ : and (analysis_cond g h') (forall (h'0 : hedge) (_ : analysis_cond g h'0), inclusion h' h'0)), equal h h'
+++++
unfold equal in |- *.
-----
Lemma analysis_unique : forall g h h' : hedge, is_analysis g h -> is_analysis g h' -> equal h h'.
unfold is_analysis in |- *.
unfold equal in |- *.

*****

*****
forall (g h h' : hedge) (_ : and (analysis_cond g h) (forall (h'0 : hedge) (_ : analysis_cond g h'0), inclusion h h'0)) (_ : and (analysis_cond g h') (forall (h'0 : hedge) (_ : analysis_cond g h'0), inclusion h' h'0)), and (inclusion h h') (inclusion h' h)
+++++
intros.
-----
Lemma analysis_unique : forall g h h' : hedge, is_analysis g h -> is_analysis g h' -> equal h h'.
unfold is_analysis in |- *.
unfold equal in |- *.
intros.

*****
H0 : and (analysis_cond g h')\n (forall (h'0 : hedge) (_ : analysis_cond g h'0), inclusion h' h'0)
H : and (analysis_cond g h)\n (forall (h' : hedge) (_ : analysis_cond g h'), inclusion h h')
g,h,h' : hedge
*****
and (inclusion h h') (inclusion h' h)
+++++
elim H.
-----
Lemma analysis_unique : forall g h h' : hedge, is_analysis g h -> is_analysis g h' -> equal h h'.
unfold is_analysis in |- *.
unfold equal in |- *.
intros.
elim H.

*****
H0 : and (analysis_cond g h')\n (forall (h'0 : hedge) (_ : analysis_cond g h'0), inclusion h' h'0)
H : and (analysis_cond g h)\n (forall (h' : hedge) (_ : analysis_cond g h'), inclusion h h')
g,h,h' : hedge
*****
forall (_ : analysis_cond g h) (_ : forall (h' : hedge) (_ : analysis_cond g h'), inclusion h h'), and (inclusion h h') (inclusion h' h)
+++++
elim H0.
-----
Lemma analysis_unique : forall g h h' : hedge, is_analysis g h -> is_analysis g h' -> equal h h'.
unfold is_analysis in |- *.
unfold equal in |- *.
intros.
elim H.
elim H0.

*****
H0 : and (analysis_cond g h')\n (forall (h'0 : hedge) (_ : analysis_cond g h'0), inclusion h' h'0)
H : and (analysis_cond g h)\n (forall (h' : hedge) (_ : analysis_cond g h'), inclusion h h')
g,h,h' : hedge
*****
forall (_ : analysis_cond g h') (_ : forall (h'0 : hedge) (_ : analysis_cond g h'0), inclusion h' h'0) (_ : analysis_cond g h) (_ : forall (h' : hedge) (_ : analysis_cond g h'), inclusion h h'), and (inclusion h h') (inclusion h' h)
+++++
intros.
-----
Lemma analysis_unique : forall g h h' : hedge, is_analysis g h -> is_analysis g h' -> equal h h'.
unfold is_analysis in |- *.
unfold equal in |- *.
intros.
elim H.
elim H0.
intros.

*****
H4 : forall (h' : hedge) (_ : analysis_cond g h'), inclusion h h'
H3 : analysis_cond g h
H2 : forall (h'0 : hedge) (_ : analysis_cond g h'0), inclusion h' h'0
H1 : analysis_cond g h'
H0 : and (analysis_cond g h')\n (forall (h'0 : hedge) (_ : analysis_cond g h'0), inclusion h' h'0)
H : and (analysis_cond g h)\n (forall (h' : hedge) (_ : analysis_cond g h'), inclusion h h')
g,h,h' : hedge
*****
and (inclusion h h') (inclusion h' h)
+++++
split.
-----
Lemma analysis_unique : forall g h h' : hedge, is_analysis g h -> is_analysis g h' -> equal h h'.
unfold is_analysis in |- *.
unfold equal in |- *.
intros.
elim H.
elim H0.
intros.
split.

*****
H4 : forall (h' : hedge) (_ : analysis_cond g h'), inclusion h h'
H3 : analysis_cond g h
H2 : forall (h'0 : hedge) (_ : analysis_cond g h'0), inclusion h' h'0
H1 : analysis_cond g h'
H0 : and (analysis_cond g h')\n (forall (h'0 : hedge) (_ : analysis_cond g h'0), inclusion h' h'0)
H : and (analysis_cond g h)\n (forall (h' : hedge) (_ : analysis_cond g h'), inclusion h h')
g,h,h' : hedge
*****
inclusion h h'
+++++
apply H4.
-----
Lemma analysis_unique : forall g h h' : hedge, is_analysis g h -> is_analysis g h' -> equal h h'.
unfold is_analysis in |- *.
unfold equal in |- *.
intros.
elim H.
elim H0.
intros.
split.
apply H4.

*****
H4 : forall (h' : hedge) (_ : analysis_cond g h'), inclusion h h'
H3 : analysis_cond g h
H2 : forall (h'0 : hedge) (_ : analysis_cond g h'0), inclusion h' h'0
H1 : analysis_cond g h'
H0 : and (analysis_cond g h')\n (forall (h'0 : hedge) (_ : analysis_cond g h'0), inclusion h' h'0)
H : and (analysis_cond g h)\n (forall (h' : hedge) (_ : analysis_cond g h'), inclusion h h')
g,h,h' : hedge
*****
analysis_cond g h'
+++++
trivial.
-----
Lemma analysis_unique : forall g h h' : hedge, is_analysis g h -> is_analysis g h' -> equal h h'.
unfold is_analysis in |- *.
unfold equal in |- *.
intros.
elim H.
elim H0.
intros.
split.

*****
H4 : forall (h' : hedge) (_ : analysis_cond g h'), inclusion h h'
H3 : analysis_cond g h
H2 : forall (h'0 : hedge) (_ : analysis_cond g h'0), inclusion h' h'0
H1 : analysis_cond g h'
H0 : and (analysis_cond g h')\n (forall (h'0 : hedge) (_ : analysis_cond g h'0), inclusion h' h'0)
H : and (analysis_cond g h)\n (forall (h' : hedge) (_ : analysis_cond g h'), inclusion h h')
g,h,h' : hedge
*****
inclusion h' h
+++++
apply H2.
-----
Lemma analysis_unique : forall g h h' : hedge, is_analysis g h -> is_analysis g h' -> equal h h'.
unfold is_analysis in |- *.
unfold equal in |- *.
intros.
elim H.
elim H0.
intros.
split.
apply H2.

*****
H4 : forall (h' : hedge) (_ : analysis_cond g h'), inclusion h h'
H3 : analysis_cond g h
H2 : forall (h'0 : hedge) (_ : analysis_cond g h'0), inclusion h' h'0
H1 : analysis_cond g h'
H0 : and (analysis_cond g h')\n (forall (h'0 : hedge) (_ : analysis_cond g h'0), inclusion h' h'0)
H : and (analysis_cond g h)\n (forall (h' : hedge) (_ : analysis_cond g h'), inclusion h h')
g,h,h' : hedge
*****
analysis_cond g h
+++++
trivial.
-----
Lemma analysis_unique : forall g h h' : hedge, is_analysis g h -> is_analysis g h' -> equal h h'.
unfold is_analysis in |- *.
unfold equal in |- *.
intros.
elim H.
elim H0.
intros.
split.

*****

*****

+++++
Qed.
-----
Lemma analysis_trans :\n forall g h h' : hedge,\n is_analysis g h -> is_analysis h h' -> is_analysis g h'.
-----
Lemma analysis_trans : forall g h h' : hedge, is_analysis g h -> is_analysis h h' -> is_analysis g h'.

*****

*****
forall (g h h' : hedge) (_ : is_analysis g h) (_ : is_analysis h h'), is_analysis g h'
+++++
unfold is_analysis in |- *.
-----
Lemma analysis_trans : forall g h h' : hedge, is_analysis g h -> is_analysis h h' -> is_analysis g h'.
unfold is_analysis in |- *.

*****

*****
forall (g h h' : hedge) (_ : and (analysis_cond g h) (forall (h'0 : hedge) (_ : analysis_cond g h'0), inclusion h h'0)) (_ : and (analysis_cond h h') (forall (h'0 : hedge) (_ : analysis_cond h h'0), inclusion h' h'0)), and (analysis_cond g h') (forall (h'0 : hedge) (_ : analysis_cond g h'0), inclusion h' h'0)
+++++
unfold analysis_cond in |- *.
-----
Lemma analysis_trans : forall g h h' : hedge, is_analysis g h -> is_analysis h h' -> is_analysis g h'.
unfold is_analysis in |- *.
unfold analysis_cond in |- *.

*****

*****
forall (g h h' : hedge) (_ : and (and (inclusion g h) (stable_analysis h)) (forall (h'0 : hedge) (_ : and (inclusion g h'0) (stable_analysis h'0)), inclusion h h'0)) (_ : and (and (inclusion h h') (stable_analysis h')) (forall (h'0 : hedge) (_ : and (inclusion h h'0) (stable_analysis h'0)), inclusion h' h'0)), and (and (inclusion g h') (stable_analysis h')) (forall (h'0 : hedge) (_ : and (inclusion g h'0) (stable_analysis h'0)), inclusion h' h'0)
+++++
intros.
-----
Lemma analysis_trans : forall g h h' : hedge, is_analysis g h -> is_analysis h h' -> is_analysis g h'.
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.

*****
H0 : and (and (inclusion h h') (stable_analysis h'))\n (forall (h'0 : hedge)\n (_ : and (inclusion h h'0) (stable_analysis h'0)),\n inclusion h' h'0)
H : and (and (inclusion g h) (stable_analysis h))\n (forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\n inclusion h h')
g,h,h' : hedge
*****
and (and (inclusion g h') (stable_analysis h')) (forall (h'0 : hedge) (_ : and (inclusion g h'0) (stable_analysis h'0)), inclusion h' h'0)
+++++
elim H.
-----
Lemma analysis_trans : forall g h h' : hedge, is_analysis g h -> is_analysis h h' -> is_analysis g h'.
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.
elim H.

*****
H0 : and (and (inclusion h h') (stable_analysis h'))\n (forall (h'0 : hedge)\n (_ : and (inclusion h h'0) (stable_analysis h'0)),\n inclusion h' h'0)
H : and (and (inclusion g h) (stable_analysis h))\n (forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\n inclusion h h')
g,h,h' : hedge
*****
forall (_ : and (inclusion g h) (stable_analysis h)) (_ : forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')), inclusion h h'), and (and (inclusion g h') (stable_analysis h')) (forall (h'0 : hedge) (_ : and (inclusion g h'0) (stable_analysis h'0)), inclusion h' h'0)
+++++
elim H0.
-----
Lemma analysis_trans : forall g h h' : hedge, is_analysis g h -> is_analysis h h' -> is_analysis g h'.
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.
elim H.
elim H0.

*****
H0 : and (and (inclusion h h') (stable_analysis h'))\n (forall (h'0 : hedge)\n (_ : and (inclusion h h'0) (stable_analysis h'0)),\n inclusion h' h'0)
H : and (and (inclusion g h) (stable_analysis h))\n (forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\n inclusion h h')
g,h,h' : hedge
*****
forall (_ : and (inclusion h h') (stable_analysis h')) (_ : forall (h'0 : hedge) (_ : and (inclusion h h'0) (stable_analysis h'0)), inclusion h' h'0) (_ : and (inclusion g h) (stable_analysis h)) (_ : forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')), inclusion h h'), and (and (inclusion g h') (stable_analysis h')) (forall (h'0 : hedge) (_ : and (inclusion g h'0) (stable_analysis h'0)), inclusion h' h'0)
+++++
intros.
-----
Lemma analysis_trans : forall g h h' : hedge, is_analysis g h -> is_analysis h h' -> is_analysis g h'.
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.
elim H.
elim H0.
intros.

*****
H4 : forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\ninclusion h h'
H3 : and (inclusion g h) (stable_analysis h)
H2 : forall (h'0 : hedge) (_ : and (inclusion h h'0) (stable_analysis h'0)),\ninclusion h' h'0
H1 : and (inclusion h h') (stable_analysis h')
H0 : and (and (inclusion h h') (stable_analysis h'))\n (forall (h'0 : hedge)\n (_ : and (inclusion h h'0) (stable_analysis h'0)),\n inclusion h' h'0)
H : and (and (inclusion g h) (stable_analysis h))\n (forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\n inclusion h h')
g,h,h' : hedge
*****
and (and (inclusion g h') (stable_analysis h')) (forall (h'0 : hedge) (_ : and (inclusion g h'0) (stable_analysis h'0)), inclusion h' h'0)
+++++
elim H1.
-----
Lemma analysis_trans : forall g h h' : hedge, is_analysis g h -> is_analysis h h' -> is_analysis g h'.
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.
elim H.
elim H0.
intros.
elim H1.

*****
H4 : forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\ninclusion h h'
H3 : and (inclusion g h) (stable_analysis h)
H2 : forall (h'0 : hedge) (_ : and (inclusion h h'0) (stable_analysis h'0)),\ninclusion h' h'0
H1 : and (inclusion h h') (stable_analysis h')
H0 : and (and (inclusion h h') (stable_analysis h'))\n (forall (h'0 : hedge)\n (_ : and (inclusion h h'0) (stable_analysis h'0)),\n inclusion h' h'0)
H : and (and (inclusion g h) (stable_analysis h))\n (forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\n inclusion h h')
g,h,h' : hedge
*****
forall (_ : inclusion h h') (_ : stable_analysis h'), and (and (inclusion g h') (stable_analysis h')) (forall (h'0 : hedge) (_ : and (inclusion g h'0) (stable_analysis h'0)), inclusion h' h'0)
+++++
elim H3.
-----
Lemma analysis_trans : forall g h h' : hedge, is_analysis g h -> is_analysis h h' -> is_analysis g h'.
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.
elim H.
elim H0.
intros.
elim H1.
elim H3.

*****
H4 : forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\ninclusion h h'
H3 : and (inclusion g h) (stable_analysis h)
H2 : forall (h'0 : hedge) (_ : and (inclusion h h'0) (stable_analysis h'0)),\ninclusion h' h'0
H1 : and (inclusion h h') (stable_analysis h')
H0 : and (and (inclusion h h') (stable_analysis h'))\n (forall (h'0 : hedge)\n (_ : and (inclusion h h'0) (stable_analysis h'0)),\n inclusion h' h'0)
H : and (and (inclusion g h) (stable_analysis h))\n (forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\n inclusion h h')
g,h,h' : hedge
*****
forall (_ : inclusion g h) (_ : stable_analysis h) (_ : inclusion h h') (_ : stable_analysis h'), and (and (inclusion g h') (stable_analysis h')) (forall (h'0 : hedge) (_ : and (inclusion g h'0) (stable_analysis h'0)), inclusion h' h'0)
+++++
intros.
-----
Lemma analysis_trans : forall g h h' : hedge, is_analysis g h -> is_analysis h h' -> is_analysis g h'.
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.
elim H.
elim H0.
intros.
elim H1.
elim H3.
intros.

*****
H8 : stable_analysis h'
H7 : inclusion h h'
H6 : stable_analysis h
H5 : inclusion g h
H4 : forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\ninclusion h h'
H3 : and (inclusion g h) (stable_analysis h)
H2 : forall (h'0 : hedge) (_ : and (inclusion h h'0) (stable_analysis h'0)),\ninclusion h' h'0
H1 : and (inclusion h h') (stable_analysis h')
H0 : and (and (inclusion h h') (stable_analysis h'))\n (forall (h'0 : hedge)\n (_ : and (inclusion h h'0) (stable_analysis h'0)),\n inclusion h' h'0)
H : and (and (inclusion g h) (stable_analysis h))\n (forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\n inclusion h h')
g,h,h' : hedge
*****
and (and (inclusion g h') (stable_analysis h')) (forall (h'0 : hedge) (_ : and (inclusion g h'0) (stable_analysis h'0)), inclusion h' h'0)
+++++
split.
-----
Lemma analysis_trans : forall g h h' : hedge, is_analysis g h -> is_analysis h h' -> is_analysis g h'.
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.
elim H.
elim H0.
intros.
elim H1.
elim H3.
intros.
split.

*****
H8 : stable_analysis h'
H7 : inclusion h h'
H6 : stable_analysis h
H5 : inclusion g h
H4 : forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\ninclusion h h'
H3 : and (inclusion g h) (stable_analysis h)
H2 : forall (h'0 : hedge) (_ : and (inclusion h h'0) (stable_analysis h'0)),\ninclusion h' h'0
H1 : and (inclusion h h') (stable_analysis h')
H0 : and (and (inclusion h h') (stable_analysis h'))\n (forall (h'0 : hedge)\n (_ : and (inclusion h h'0) (stable_analysis h'0)),\n inclusion h' h'0)
H : and (and (inclusion g h) (stable_analysis h))\n (forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\n inclusion h h')
g,h,h' : hedge
*****
and (inclusion g h') (stable_analysis h')
+++++
split.
-----
Lemma analysis_trans : forall g h h' : hedge, is_analysis g h -> is_analysis h h' -> is_analysis g h'.
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.
elim H.
elim H0.
intros.
elim H1.
elim H3.
intros.
split.
split.

*****
H8 : stable_analysis h'
H7 : inclusion h h'
H6 : stable_analysis h
H5 : inclusion g h
H4 : forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\ninclusion h h'
H3 : and (inclusion g h) (stable_analysis h)
H2 : forall (h'0 : hedge) (_ : and (inclusion h h'0) (stable_analysis h'0)),\ninclusion h' h'0
H1 : and (inclusion h h') (stable_analysis h')
H0 : and (and (inclusion h h') (stable_analysis h'))\n (forall (h'0 : hedge)\n (_ : and (inclusion h h'0) (stable_analysis h'0)),\n inclusion h' h'0)
H : and (and (inclusion g h) (stable_analysis h))\n (forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\n inclusion h h')
g,h,h' : hedge
*****
inclusion g h'
+++++
trivial.
-----
Lemma analysis_trans : forall g h h' : hedge, is_analysis g h -> is_analysis h h' -> is_analysis g h'.
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.
elim H.
elim H0.
intros.
elim H1.
elim H3.
intros.
split.
split.
trivial.

*****
H8 : stable_analysis h'
H7 : inclusion h h'
H6 : stable_analysis h
H5 : inclusion g h
H4 : forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\ninclusion h h'
H3 : and (inclusion g h) (stable_analysis h)
H2 : forall (h'0 : hedge) (_ : and (inclusion h h'0) (stable_analysis h'0)),\ninclusion h' h'0
H1 : and (inclusion h h') (stable_analysis h')
H0 : and (and (inclusion h h') (stable_analysis h'))\n (forall (h'0 : hedge)\n (_ : and (inclusion h h'0) (stable_analysis h'0)),\n inclusion h' h'0)
H : and (and (inclusion g h) (stable_analysis h))\n (forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\n inclusion h h')
g,h,h' : hedge
*****
inclusion g h'
+++++
apply inclusion_trans with h.
-----
Lemma analysis_trans : forall g h h' : hedge, is_analysis g h -> is_analysis h h' -> is_analysis g h'.
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.
elim H.
elim H0.
intros.
elim H1.
elim H3.
intros.
split.
split.
trivial.
apply inclusion_trans with h.

*****
H8 : stable_analysis h'
H7 : inclusion h h'
H6 : stable_analysis h
H5 : inclusion g h
H4 : forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\ninclusion h h'
H3 : and (inclusion g h) (stable_analysis h)
H2 : forall (h'0 : hedge) (_ : and (inclusion h h'0) (stable_analysis h'0)),\ninclusion h' h'0
H1 : and (inclusion h h') (stable_analysis h')
H0 : and (and (inclusion h h') (stable_analysis h'))\n (forall (h'0 : hedge)\n (_ : and (inclusion h h'0) (stable_analysis h'0)),\n inclusion h' h'0)
H : and (and (inclusion g h) (stable_analysis h))\n (forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\n inclusion h h')
g,h,h' : hedge
*****
inclusion g h
+++++
trivial.
-----
Lemma analysis_trans : forall g h h' : hedge, is_analysis g h -> is_analysis h h' -> is_analysis g h'.
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.
elim H.
elim H0.
intros.
elim H1.
elim H3.
intros.
split.
split.
trivial.
apply inclusion_trans with h.

*****
H8 : stable_analysis h'
H7 : inclusion h h'
H6 : stable_analysis h
H5 : inclusion g h
H4 : forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\ninclusion h h'
H3 : and (inclusion g h) (stable_analysis h)
H2 : forall (h'0 : hedge) (_ : and (inclusion h h'0) (stable_analysis h'0)),\ninclusion h' h'0
H1 : and (inclusion h h') (stable_analysis h')
H0 : and (and (inclusion h h') (stable_analysis h'))\n (forall (h'0 : hedge)\n (_ : and (inclusion h h'0) (stable_analysis h'0)),\n inclusion h' h'0)
H : and (and (inclusion g h) (stable_analysis h))\n (forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\n inclusion h h')
g,h,h' : hedge
*****
inclusion h h'
+++++
trivial.
-----
Lemma analysis_trans : forall g h h' : hedge, is_analysis g h -> is_analysis h h' -> is_analysis g h'.
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.
elim H.
elim H0.
intros.
elim H1.
elim H3.
intros.
split.
split.

*****
H8 : stable_analysis h'
H7 : inclusion h h'
H6 : stable_analysis h
H5 : inclusion g h
H4 : forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\ninclusion h h'
H3 : and (inclusion g h) (stable_analysis h)
H2 : forall (h'0 : hedge) (_ : and (inclusion h h'0) (stable_analysis h'0)),\ninclusion h' h'0
H1 : and (inclusion h h') (stable_analysis h')
H0 : and (and (inclusion h h') (stable_analysis h'))\n (forall (h'0 : hedge)\n (_ : and (inclusion h h'0) (stable_analysis h'0)),\n inclusion h' h'0)
H : and (and (inclusion g h) (stable_analysis h))\n (forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\n inclusion h h')
g,h,h' : hedge
*****
stable_analysis h'
+++++
trivial.
-----
Lemma analysis_trans : forall g h h' : hedge, is_analysis g h -> is_analysis h h' -> is_analysis g h'.
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.
elim H.
elim H0.
intros.
elim H1.
elim H3.
intros.
split.

*****
H8 : stable_analysis h'
H7 : inclusion h h'
H6 : stable_analysis h
H5 : inclusion g h
H4 : forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\ninclusion h h'
H3 : and (inclusion g h) (stable_analysis h)
H2 : forall (h'0 : hedge) (_ : and (inclusion h h'0) (stable_analysis h'0)),\ninclusion h' h'0
H1 : and (inclusion h h') (stable_analysis h')
H0 : and (and (inclusion h h') (stable_analysis h'))\n (forall (h'0 : hedge)\n (_ : and (inclusion h h'0) (stable_analysis h'0)),\n inclusion h' h'0)
H : and (and (inclusion g h) (stable_analysis h))\n (forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\n inclusion h h')
g,h,h' : hedge
*****
forall (h'0 : hedge) (_ : and (inclusion g h'0) (stable_analysis h'0)), inclusion h' h'0
+++++
intros.
-----
Lemma analysis_trans : forall g h h' : hedge, is_analysis g h -> is_analysis h h' -> is_analysis g h'.
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.
elim H.
elim H0.
intros.
elim H1.
elim H3.
intros.
split.
intros.

*****
H9 : and (inclusion g h'0) (stable_analysis h'0)
h'0 : hedge
H8 : stable_analysis h'
H7 : inclusion h h'
H6 : stable_analysis h
H5 : inclusion g h
H4 : forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\ninclusion h h'
H3 : and (inclusion g h) (stable_analysis h)
H2 : forall (h'0 : hedge) (_ : and (inclusion h h'0) (stable_analysis h'0)),\ninclusion h' h'0
H1 : and (inclusion h h') (stable_analysis h')
H0 : and (and (inclusion h h') (stable_analysis h'))\n (forall (h'0 : hedge)\n (_ : and (inclusion h h'0) (stable_analysis h'0)),\n inclusion h' h'0)
H : and (and (inclusion g h) (stable_analysis h))\n (forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\n inclusion h h')
g,h,h' : hedge
*****
inclusion h' h'0
+++++
apply inclusion_trans with h.
-----
Lemma analysis_trans : forall g h h' : hedge, is_analysis g h -> is_analysis h h' -> is_analysis g h'.
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.
elim H.
elim H0.
intros.
elim H1.
elim H3.
intros.
split.
intros.
apply inclusion_trans with h.

*****
H9 : and (inclusion g h'0) (stable_analysis h'0)
h'0 : hedge
H8 : stable_analysis h'
H7 : inclusion h h'
H6 : stable_analysis h
H5 : inclusion g h
H4 : forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\ninclusion h h'
H3 : and (inclusion g h) (stable_analysis h)
H2 : forall (h'0 : hedge) (_ : and (inclusion h h'0) (stable_analysis h'0)),\ninclusion h' h'0
H1 : and (inclusion h h') (stable_analysis h')
H0 : and (and (inclusion h h') (stable_analysis h'))\n (forall (h'0 : hedge)\n (_ : and (inclusion h h'0) (stable_analysis h'0)),\n inclusion h' h'0)
H : and (and (inclusion g h) (stable_analysis h))\n (forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\n inclusion h h')
g,h,h' : hedge
*****
inclusion h' h
+++++
apply H2.
-----
Lemma analysis_trans : forall g h h' : hedge, is_analysis g h -> is_analysis h h' -> is_analysis g h'.
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.
elim H.
elim H0.
intros.
elim H1.
elim H3.
intros.
split.
intros.
apply inclusion_trans with h.
apply H2.

*****
H9 : and (inclusion g h'0) (stable_analysis h'0)
h'0 : hedge
H8 : stable_analysis h'
H7 : inclusion h h'
H6 : stable_analysis h
H5 : inclusion g h
H4 : forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\ninclusion h h'
H3 : and (inclusion g h) (stable_analysis h)
H2 : forall (h'0 : hedge) (_ : and (inclusion h h'0) (stable_analysis h'0)),\ninclusion h' h'0
H1 : and (inclusion h h') (stable_analysis h')
H0 : and (and (inclusion h h') (stable_analysis h'))\n (forall (h'0 : hedge)\n (_ : and (inclusion h h'0) (stable_analysis h'0)),\n inclusion h' h'0)
H : and (and (inclusion g h) (stable_analysis h))\n (forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\n inclusion h h')
g,h,h' : hedge
*****
and (inclusion h h) (stable_analysis h)
+++++
split.
-----
Lemma analysis_trans : forall g h h' : hedge, is_analysis g h -> is_analysis h h' -> is_analysis g h'.
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.
elim H.
elim H0.
intros.
elim H1.
elim H3.
intros.
split.
intros.
apply inclusion_trans with h.
apply H2.
split.

*****
H9 : and (inclusion g h'0) (stable_analysis h'0)
h'0 : hedge
H8 : stable_analysis h'
H7 : inclusion h h'
H6 : stable_analysis h
H5 : inclusion g h
H4 : forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\ninclusion h h'
H3 : and (inclusion g h) (stable_analysis h)
H2 : forall (h'0 : hedge) (_ : and (inclusion h h'0) (stable_analysis h'0)),\ninclusion h' h'0
H1 : and (inclusion h h') (stable_analysis h')
H0 : and (and (inclusion h h') (stable_analysis h'))\n (forall (h'0 : hedge)\n (_ : and (inclusion h h'0) (stable_analysis h'0)),\n inclusion h' h'0)
H : and (and (inclusion g h) (stable_analysis h))\n (forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\n inclusion h h')
g,h,h' : hedge
*****
inclusion h h
+++++
trivial.
-----
Lemma analysis_trans : forall g h h' : hedge, is_analysis g h -> is_analysis h h' -> is_analysis g h'.
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.
elim H.
elim H0.
intros.
elim H1.
elim H3.
intros.
split.
intros.
apply inclusion_trans with h.
apply H2.
split.
trivial.

*****
H9 : and (inclusion g h'0) (stable_analysis h'0)
h'0 : hedge
H8 : stable_analysis h'
H7 : inclusion h h'
H6 : stable_analysis h
H5 : inclusion g h
H4 : forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\ninclusion h h'
H3 : and (inclusion g h) (stable_analysis h)
H2 : forall (h'0 : hedge) (_ : and (inclusion h h'0) (stable_analysis h'0)),\ninclusion h' h'0
H1 : and (inclusion h h') (stable_analysis h')
H0 : and (and (inclusion h h') (stable_analysis h'))\n (forall (h'0 : hedge)\n (_ : and (inclusion h h'0) (stable_analysis h'0)),\n inclusion h' h'0)
H : and (and (inclusion g h) (stable_analysis h))\n (forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\n inclusion h h')
g,h,h' : hedge
*****
inclusion h h
+++++
apply inclusion_refl.
-----
Lemma analysis_trans : forall g h h' : hedge, is_analysis g h -> is_analysis h h' -> is_analysis g h'.
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.
elim H.
elim H0.
intros.
elim H1.
elim H3.
intros.
split.
intros.
apply inclusion_trans with h.
apply H2.
split.

*****
H9 : and (inclusion g h'0) (stable_analysis h'0)
h'0 : hedge
H8 : stable_analysis h'
H7 : inclusion h h'
H6 : stable_analysis h
H5 : inclusion g h
H4 : forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\ninclusion h h'
H3 : and (inclusion g h) (stable_analysis h)
H2 : forall (h'0 : hedge) (_ : and (inclusion h h'0) (stable_analysis h'0)),\ninclusion h' h'0
H1 : and (inclusion h h') (stable_analysis h')
H0 : and (and (inclusion h h') (stable_analysis h'))\n (forall (h'0 : hedge)\n (_ : and (inclusion h h'0) (stable_analysis h'0)),\n inclusion h' h'0)
H : and (and (inclusion g h) (stable_analysis h))\n (forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\n inclusion h h')
g,h,h' : hedge
*****
stable_analysis h
+++++
trivial.
-----
Lemma analysis_trans : forall g h h' : hedge, is_analysis g h -> is_analysis h h' -> is_analysis g h'.
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.
elim H.
elim H0.
intros.
elim H1.
elim H3.
intros.
split.
intros.
apply inclusion_trans with h.

*****
H9 : and (inclusion g h'0) (stable_analysis h'0)
h'0 : hedge
H8 : stable_analysis h'
H7 : inclusion h h'
H6 : stable_analysis h
H5 : inclusion g h
H4 : forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\ninclusion h h'
H3 : and (inclusion g h) (stable_analysis h)
H2 : forall (h'0 : hedge) (_ : and (inclusion h h'0) (stable_analysis h'0)),\ninclusion h' h'0
H1 : and (inclusion h h') (stable_analysis h')
H0 : and (and (inclusion h h') (stable_analysis h'))\n (forall (h'0 : hedge)\n (_ : and (inclusion h h'0) (stable_analysis h'0)),\n inclusion h' h'0)
H : and (and (inclusion g h) (stable_analysis h))\n (forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\n inclusion h h')
g,h,h' : hedge
*****
inclusion h h'0
+++++
apply H4.
-----
Lemma analysis_trans : forall g h h' : hedge, is_analysis g h -> is_analysis h h' -> is_analysis g h'.
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.
elim H.
elim H0.
intros.
elim H1.
elim H3.
intros.
split.
intros.
apply inclusion_trans with h.
apply H4.

*****
H9 : and (inclusion g h'0) (stable_analysis h'0)
h'0 : hedge
H8 : stable_analysis h'
H7 : inclusion h h'
H6 : stable_analysis h
H5 : inclusion g h
H4 : forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\ninclusion h h'
H3 : and (inclusion g h) (stable_analysis h)
H2 : forall (h'0 : hedge) (_ : and (inclusion h h'0) (stable_analysis h'0)),\ninclusion h' h'0
H1 : and (inclusion h h') (stable_analysis h')
H0 : and (and (inclusion h h') (stable_analysis h'))\n (forall (h'0 : hedge)\n (_ : and (inclusion h h'0) (stable_analysis h'0)),\n inclusion h' h'0)
H : and (and (inclusion g h) (stable_analysis h))\n (forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\n inclusion h h')
g,h,h' : hedge
*****
and (inclusion g h'0) (stable_analysis h'0)
+++++
tauto.
-----
Lemma analysis_trans : forall g h h' : hedge, is_analysis g h -> is_analysis h h' -> is_analysis g h'.
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.
elim H.
elim H0.
intros.
elim H1.
elim H3.
intros.
split.

*****

*****

+++++
Qed.
-----
Lemma analysis_analysed :\n forall g h h' : hedge, is_analysis g h -> is_analysis h h' -> equal h h'.
-----
Lemma analysis_analysed : forall g h h' : hedge, is_analysis g h -> is_analysis h h' -> equal h h'.

*****

*****
forall (g h h' : hedge) (_ : is_analysis g h) (_ : is_analysis h h'), equal h h'
+++++
intros.
-----
Lemma analysis_analysed : forall g h h' : hedge, is_analysis g h -> is_analysis h h' -> equal h h'.
intros.

*****
H0 : is_analysis h h'
H : is_analysis g h
g,h,h' : hedge
*****
equal h h'
+++++
apply analysis_unique with g.
-----
Lemma analysis_analysed : forall g h h' : hedge, is_analysis g h -> is_analysis h h' -> equal h h'.
intros.
apply analysis_unique with g.

*****
H0 : is_analysis h h'
H : is_analysis g h
g,h,h' : hedge
*****
is_analysis g h
+++++
trivial.
-----
Lemma analysis_analysed : forall g h h' : hedge, is_analysis g h -> is_analysis h h' -> equal h h'.
intros.
apply analysis_unique with g.

*****
H0 : is_analysis h h'
H : is_analysis g h
g,h,h' : hedge
*****
is_analysis g h'
+++++
trivial.
-----
Lemma analysis_analysed : forall g h h' : hedge, is_analysis g h -> is_analysis h h' -> equal h h'.
intros.
apply analysis_unique with g.
trivial.

*****
H0 : is_analysis h h'
H : is_analysis g h
g,h,h' : hedge
*****
is_analysis g h'
+++++
apply analysis_trans with h.
-----
Lemma analysis_analysed : forall g h h' : hedge, is_analysis g h -> is_analysis h h' -> equal h h'.
intros.
apply analysis_unique with g.
trivial.
apply analysis_trans with h.

*****
H0 : is_analysis h h'
H : is_analysis g h
g,h,h' : hedge
*****
is_analysis g h
+++++
trivial.
-----
Lemma analysis_analysed : forall g h h' : hedge, is_analysis g h -> is_analysis h h' -> equal h h'.
intros.
apply analysis_unique with g.
trivial.
apply analysis_trans with h.

*****
H0 : is_analysis h h'
H : is_analysis g h
g,h,h' : hedge
*****
is_analysis h h'
+++++
trivial.
-----
Lemma analysis_analysed : forall g h h' : hedge, is_analysis g h -> is_analysis h h' -> equal h h'.
intros.
apply analysis_unique with g.

*****

*****

+++++
Qed.
-----
Lemma analysis_seq_approx_analysis :\n forall (h : hedge) (n : nat),\n stable_analysis (analysis_seq h n) -> is_analysis h (analysis_seq h n).
-----
Lemma analysis_seq_approx_analysis : forall (h : hedge) (n : nat), stable_analysis (analysis_seq h n) -> is_analysis h (analysis_seq h n).

*****

*****
forall (h : hedge) (n : nat) (_ : stable_analysis (analysis_seq h n)), is_analysis h (analysis_seq h n)
+++++
unfold is_analysis in |- *.
-----
Lemma analysis_seq_approx_analysis : forall (h : hedge) (n : nat), stable_analysis (analysis_seq h n) -> is_analysis h (analysis_seq h n).
unfold is_analysis in |- *.

*****

*****
forall (h : hedge) (n : nat) (_ : stable_analysis (analysis_seq h n)), and (analysis_cond h (analysis_seq h n)) (forall (h' : hedge) (_ : analysis_cond h h'), inclusion (analysis_seq h n) h')
+++++
unfold analysis_cond in |- *.
-----
Lemma analysis_seq_approx_analysis : forall (h : hedge) (n : nat), stable_analysis (analysis_seq h n) -> is_analysis h (analysis_seq h n).
unfold is_analysis in |- *.
unfold analysis_cond in |- *.

*****

*****
forall (h : hedge) (n : nat) (_ : stable_analysis (analysis_seq h n)), and (and (inclusion h (analysis_seq h n)) (stable_analysis (analysis_seq h n))) (forall (h' : hedge) (_ : and (inclusion h h') (stable_analysis h')), inclusion (analysis_seq h n) h')
+++++
intros.
-----
Lemma analysis_seq_approx_analysis : forall (h : hedge) (n : nat), stable_analysis (analysis_seq h n) -> is_analysis h (analysis_seq h n).
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.

*****
H : stable_analysis (analysis_seq h n)
n : nat
h : hedge
*****
and (and (inclusion h (analysis_seq h n)) (stable_analysis (analysis_seq h n))) (forall (h' : hedge) (_ : and (inclusion h h') (stable_analysis h')), inclusion (analysis_seq h n) h')
+++++
split.
-----
Lemma analysis_seq_approx_analysis : forall (h : hedge) (n : nat), stable_analysis (analysis_seq h n) -> is_analysis h (analysis_seq h n).
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.
split.

*****
H : stable_analysis (analysis_seq h n)
n : nat
h : hedge
*****
and (inclusion h (analysis_seq h n)) (stable_analysis (analysis_seq h n))
+++++
split.
-----
Lemma analysis_seq_approx_analysis : forall (h : hedge) (n : nat), stable_analysis (analysis_seq h n) -> is_analysis h (analysis_seq h n).
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.
split.
split.

*****
H : stable_analysis (analysis_seq h n)
n : nat
h : hedge
*****
inclusion h (analysis_seq h n)
+++++
trivial.
-----
Lemma analysis_seq_approx_analysis : forall (h : hedge) (n : nat), stable_analysis (analysis_seq h n) -> is_analysis h (analysis_seq h n).
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.
split.
split.
trivial.

*****
H : stable_analysis (analysis_seq h n)
n : nat
h : hedge
*****
inclusion h (analysis_seq h n)
+++++
apply inclusion_trans with (analysis_seq h 0).
-----
Lemma analysis_seq_approx_analysis : forall (h : hedge) (n : nat), stable_analysis (analysis_seq h n) -> is_analysis h (analysis_seq h n).
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.
split.
split.
trivial.
apply inclusion_trans with (analysis_seq h 0).

*****
H : stable_analysis (analysis_seq h n)
n : nat
h : hedge
*****
inclusion h (analysis_seq h O)
+++++
simpl in |- *.
-----
Lemma analysis_seq_approx_analysis : forall (h : hedge) (n : nat), stable_analysis (analysis_seq h n) -> is_analysis h (analysis_seq h n).
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.
split.
split.
trivial.
apply inclusion_trans with (analysis_seq h 0).
simpl in |- *.

*****
H : stable_analysis (analysis_seq h n)
n : nat
h : hedge
*****
inclusion h h
+++++
apply inclusion_refl.
-----
Lemma analysis_seq_approx_analysis : forall (h : hedge) (n : nat), stable_analysis (analysis_seq h n) -> is_analysis h (analysis_seq h n).
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.
split.
split.
trivial.
apply inclusion_trans with (analysis_seq h 0).

*****
H : stable_analysis (analysis_seq h n)
n : nat
h : hedge
*****
inclusion (analysis_seq h O) (analysis_seq h n)
+++++
replace n with (n + 0).
-----
Lemma analysis_seq_approx_analysis : forall (h : hedge) (n : nat), stable_analysis (analysis_seq h n) -> is_analysis h (analysis_seq h n).
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.
split.
split.
trivial.
apply inclusion_trans with (analysis_seq h 0).
replace n with (n + 0).

*****
H : stable_analysis (analysis_seq h n)
n : nat
h : hedge
*****
inclusion (analysis_seq h O) (analysis_seq h (Init.Nat.add n O))
+++++
try auto with arith.
-----
Lemma analysis_seq_approx_analysis : forall (h : hedge) (n : nat), stable_analysis (analysis_seq h n) -> is_analysis h (analysis_seq h n).
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.
split.
split.
trivial.
apply inclusion_trans with (analysis_seq h 0).
replace n with (n + 0).
try auto with arith.

*****
H : stable_analysis (analysis_seq h n)
n : nat
h : hedge
*****
inclusion (analysis_seq h O) (analysis_seq h (Init.Nat.add n O))
+++++
apply analysis_seq_grows.
-----
Lemma analysis_seq_approx_analysis : forall (h : hedge) (n : nat), stable_analysis (analysis_seq h n) -> is_analysis h (analysis_seq h n).
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.
split.
split.
trivial.
apply inclusion_trans with (analysis_seq h 0).
replace n with (n + 0).

*****
H : stable_analysis (analysis_seq h n)
n : nat
h : hedge
*****
eq (Init.Nat.add n O) n
+++++
try auto with arith.
-----
Lemma analysis_seq_approx_analysis : forall (h : hedge) (n : nat), stable_analysis (analysis_seq h n) -> is_analysis h (analysis_seq h n).
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.
split.
split.

*****
H : stable_analysis (analysis_seq h n)
n : nat
h : hedge
*****
stable_analysis (analysis_seq h n)
+++++
trivial.
-----
Lemma analysis_seq_approx_analysis : forall (h : hedge) (n : nat), stable_analysis (analysis_seq h n) -> is_analysis h (analysis_seq h n).
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.
split.

*****
H : stable_analysis (analysis_seq h n)
n : nat
h : hedge
*****
forall (h' : hedge) (_ : and (inclusion h h') (stable_analysis h')), inclusion (analysis_seq h n) h'
+++++
intros.
-----
Lemma analysis_seq_approx_analysis : forall (h : hedge) (n : nat), stable_analysis (analysis_seq h n) -> is_analysis h (analysis_seq h n).
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.
split.
intros.

*****
H0 : and (inclusion h h') (stable_analysis h')
h' : hedge
H : stable_analysis (analysis_seq h n)
n : nat
h : hedge
*****
inclusion (analysis_seq h n) h'
+++++
apply analysis_seq_incl_analysis_cond.
-----
Lemma analysis_seq_approx_analysis : forall (h : hedge) (n : nat), stable_analysis (analysis_seq h n) -> is_analysis h (analysis_seq h n).
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.
split.
intros.
apply analysis_seq_incl_analysis_cond.

*****
H0 : and (inclusion h h') (stable_analysis h')
h' : hedge
H : stable_analysis (analysis_seq h n)
n : nat
h : hedge
*****
analysis_cond h h'
+++++
unfold analysis_cond in |- *.
-----
Lemma analysis_seq_approx_analysis : forall (h : hedge) (n : nat), stable_analysis (analysis_seq h n) -> is_analysis h (analysis_seq h n).
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.
split.
intros.
apply analysis_seq_incl_analysis_cond.
unfold analysis_cond in |- *.

*****
H0 : and (inclusion h h') (stable_analysis h')
h' : hedge
H : stable_analysis (analysis_seq h n)
n : nat
h : hedge
*****
and (inclusion h h') (stable_analysis h')
+++++
trivial.
-----
Lemma analysis_seq_approx_analysis : forall (h : hedge) (n : nat), stable_analysis (analysis_seq h n) -> is_analysis h (analysis_seq h n).
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.
split.

*****

*****

+++++
Qed.
-----
Definition analysis_def (h : hedge) (M N : Msg) :=\n  exists n : nat, analysis_seq h n M N.
-----
From Coq Require Import Max.
-----
Lemma synthesis_analysis_seq :\n forall (h : hedge) (M N : Msg),\n synthesis (analysis_def h) M N ->\n exists n : nat, synthesis (analysis_seq h n) M N.
-----
Lemma synthesis_analysis_seq : forall (h : hedge) (M N : Msg), synthesis (analysis_def h) M N -> exists n : nat, synthesis (analysis_seq h n) M N.

*****

*****
forall (h : hedge) (M N : Msg) (_ : synthesis (analysis_def h) M N), ex (fun n : nat => synthesis (analysis_seq h n) M N)
+++++
intros.
-----
Lemma synthesis_analysis_seq : forall (h : hedge) (M N : Msg), synthesis (analysis_def h) M N -> exists n : nat, synthesis (analysis_seq h n) M N.
intros.

*****
H : synthesis (analysis_def h) M N
M,N : Msg
h : hedge
*****
ex (fun n : nat => synthesis (analysis_seq h n) M N)
+++++
unfold analysis_def in |- *.
-----
Lemma synthesis_analysis_seq : forall (h : hedge) (M N : Msg), synthesis (analysis_def h) M N -> exists n : nat, synthesis (analysis_seq h n) M N.
intros.
unfold analysis_def in |- *.

*****
H : synthesis (analysis_def h) M N
M,N : Msg
h : hedge
*****
ex (fun n : nat => synthesis (analysis_seq h n) M N)
+++++
intros.
-----
Lemma synthesis_analysis_seq : forall (h : hedge) (M N : Msg), synthesis (analysis_def h) M N -> exists n : nat, synthesis (analysis_seq h n) M N.
intros.
unfold analysis_def in |- *.
intros.

*****
H : synthesis (analysis_def h) M N
M,N : Msg
h : hedge
*****
ex (fun n : nat => synthesis (analysis_seq h n) M N)
+++++
induction H as [M N H| M N K L H1 HrecH1 H0 HrecH0| M1 N1 M2 N2 H1 HrecH1 H0 HrecH0| o M N H HrecH].
-----
Lemma synthesis_analysis_seq : forall (h : hedge) (M N : Msg), synthesis (analysis_def h) M N -> exists n : nat, synthesis (analysis_seq h n) M N.
intros.
unfold analysis_def in |- *.
intros.
induction H as [M N H| M N K L H1 HrecH1 H0 HrecH0| M1 N1 M2 N2 H1 HrecH1 H0 HrecH0| o M N H HrecH].

*****
H : analysis_def h M N
M,N : Msg
h : hedge
*****
ex (fun n : nat => synthesis (analysis_seq h n) M N)
+++++
elim H.
-----
Lemma synthesis_analysis_seq : forall (h : hedge) (M N : Msg), synthesis (analysis_def h) M N -> exists n : nat, synthesis (analysis_seq h n) M N.
intros.
unfold analysis_def in |- *.
intros.
induction H as [M N H| M N K L H1 HrecH1 H0 HrecH0| M1 N1 M2 N2 H1 HrecH1 H0 HrecH0| o M N H HrecH].
elim H.

*****
H : analysis_def h M N
M,N : Msg
h : hedge
*****
forall (x : nat) (_ : analysis_seq h x M N), ex (fun n : nat => synthesis (analysis_seq h n) M N)
+++++
intro n.
-----
Lemma synthesis_analysis_seq : forall (h : hedge) (M N : Msg), synthesis (analysis_def h) M N -> exists n : nat, synthesis (analysis_seq h n) M N.
intros.
unfold analysis_def in |- *.
intros.
induction H as [M N H| M N K L H1 HrecH1 H0 HrecH0| M1 N1 M2 N2 H1 HrecH1 H0 HrecH0| o M N H HrecH].
elim H.
intro n.

*****
n : nat
H : analysis_def h M N
M,N : Msg
h : hedge
*****
forall _ : analysis_seq h n M N, ex (fun n : nat => synthesis (analysis_seq h n) M N)
+++++
intro.
-----
Lemma synthesis_analysis_seq : forall (h : hedge) (M N : Msg), synthesis (analysis_def h) M N -> exists n : nat, synthesis (analysis_seq h n) M N.
intros.
unfold analysis_def in |- *.
intros.
induction H as [M N H| M N K L H1 HrecH1 H0 HrecH0| M1 N1 M2 N2 H1 HrecH1 H0 HrecH0| o M N H HrecH].
elim H.
intro n.
intro.

*****
H0 : analysis_seq h n M N
n : nat
H : analysis_def h M N
M,N : Msg
h : hedge
*****
ex (fun n : nat => synthesis (analysis_seq h n) M N)
+++++
exists n.
-----
Lemma synthesis_analysis_seq : forall (h : hedge) (M N : Msg), synthesis (analysis_def h) M N -> exists n : nat, synthesis (analysis_seq h n) M N.
intros.
unfold analysis_def in |- *.
intros.
induction H as [M N H| M N K L H1 HrecH1 H0 HrecH0| M1 N1 M2 N2 H1 HrecH1 H0 HrecH0| o M N H HrecH].
elim H.
intro n.
intro.
exists n.

*****
H0 : analysis_seq h n M N
n : nat
H : analysis_def h M N
M,N : Msg
h : hedge
*****
synthesis (analysis_seq h n) M N
+++++
apply SynInc.
-----
Lemma synthesis_analysis_seq : forall (h : hedge) (M N : Msg), synthesis (analysis_def h) M N -> exists n : nat, synthesis (analysis_seq h n) M N.
intros.
unfold analysis_def in |- *.
intros.
induction H as [M N H| M N K L H1 HrecH1 H0 HrecH0| M1 N1 M2 N2 H1 HrecH1 H0 HrecH0| o M N H HrecH].
elim H.
intro n.
intro.
exists n.
apply SynInc.

*****
H0 : analysis_seq h n M N
n : nat
H : analysis_def h M N
M,N : Msg
h : hedge
*****
analysis_seq h n M N
+++++
trivial.
-----
Lemma synthesis_analysis_seq : forall (h : hedge) (M N : Msg), synthesis (analysis_def h) M N -> exists n : nat, synthesis (analysis_seq h n) M N.
intros.
unfold analysis_def in |- *.
intros.
induction H as [M N H| M N K L H1 HrecH1 H0 HrecH0| M1 N1 M2 N2 H1 HrecH1 H0 HrecH0| o M N H HrecH].

*****
HrecH0 : ex (fun n : nat => synthesis (analysis_seq h n) K L)
HrecH1 : ex (fun n : nat => synthesis (analysis_seq h n) M N)
H0 : synthesis (analysis_def h) K L
H1 : synthesis (analysis_def h) M N
M,N,K,L : Msg
h : hedge
*****
ex (fun n : nat => synthesis (analysis_seq h n) (MEnc M K) (MEnc N L))
+++++
elim HrecH1.
-----
Lemma synthesis_analysis_seq : forall (h : hedge) (M N : Msg), synthesis (analysis_def h) M N -> exists n : nat, synthesis (analysis_seq h n) M N.
intros.
unfold analysis_def in |- *.
intros.
induction H as [M N H| M N K L H1 HrecH1 H0 HrecH0| M1 N1 M2 N2 H1 HrecH1 H0 HrecH0| o M N H HrecH].
elim HrecH1.

*****
HrecH0 : ex (fun n : nat => synthesis (analysis_seq h n) K L)
HrecH1 : ex (fun n : nat => synthesis (analysis_seq h n) M N)
H0 : synthesis (analysis_def h) K L
H1 : synthesis (analysis_def h) M N
M,N,K,L : Msg
h : hedge
*****
forall (x : nat) (_ : synthesis (analysis_seq h x) M N), ex (fun n : nat => synthesis (analysis_seq h n) (MEnc M K) (MEnc N L))
+++++
intro n1.
-----
Lemma synthesis_analysis_seq : forall (h : hedge) (M N : Msg), synthesis (analysis_def h) M N -> exists n : nat, synthesis (analysis_seq h n) M N.
intros.
unfold analysis_def in |- *.
intros.
induction H as [M N H| M N K L H1 HrecH1 H0 HrecH0| M1 N1 M2 N2 H1 HrecH1 H0 HrecH0| o M N H HrecH].
elim HrecH1.
intro n1.

*****
n1 : nat
HrecH0 : ex (fun n : nat => synthesis (analysis_seq h n) K L)
HrecH1 : ex (fun n : nat => synthesis (analysis_seq h n) M N)
H0 : synthesis (analysis_def h) K L
H1 : synthesis (analysis_def h) M N
M,N,K,L : Msg
h : hedge
*****
forall _ : synthesis (analysis_seq h n1) M N, ex (fun n : nat => synthesis (analysis_seq h n) (MEnc M K) (MEnc N L))
+++++
intro.
-----
Lemma synthesis_analysis_seq : forall (h : hedge) (M N : Msg), synthesis (analysis_def h) M N -> exists n : nat, synthesis (analysis_seq h n) M N.
intros.
unfold analysis_def in |- *.
intros.
induction H as [M N H| M N K L H1 HrecH1 H0 HrecH0| M1 N1 M2 N2 H1 HrecH1 H0 HrecH0| o M N H HrecH].
elim HrecH1.
intro n1.
intro.

*****
H : synthesis (analysis_seq h n1) M N
n1 : nat
HrecH0 : ex (fun n : nat => synthesis (analysis_seq h n) K L)
HrecH1 : ex (fun n : nat => synthesis (analysis_seq h n) M N)
H0 : synthesis (analysis_def h) K L
H1 : synthesis (analysis_def h) M N
M,N,K,L : Msg
h : hedge
*****
ex (fun n : nat => synthesis (analysis_seq h n) (MEnc M K) (MEnc N L))
+++++
elim HrecH0.
-----
Lemma synthesis_analysis_seq : forall (h : hedge) (M N : Msg), synthesis (analysis_def h) M N -> exists n : nat, synthesis (analysis_seq h n) M N.
intros.
unfold analysis_def in |- *.
intros.
induction H as [M N H| M N K L H1 HrecH1 H0 HrecH0| M1 N1 M2 N2 H1 HrecH1 H0 HrecH0| o M N H HrecH].
elim HrecH1.
intro n1.
intro.
elim HrecH0.

*****
H : synthesis (analysis_seq h n1) M N
n1 : nat
HrecH0 : ex (fun n : nat => synthesis (analysis_seq h n) K L)
HrecH1 : ex (fun n : nat => synthesis (analysis_seq h n) M N)
H0 : synthesis (analysis_def h) K L
H1 : synthesis (analysis_def h) M N
M,N,K,L : Msg
h : hedge
*****
forall (x : nat) (_ : synthesis (analysis_seq h x) K L), ex (fun n : nat => synthesis (analysis_seq h n) (MEnc M K) (MEnc N L))
+++++
intro n2.
-----
Lemma synthesis_analysis_seq : forall (h : hedge) (M N : Msg), synthesis (analysis_def h) M N -> exists n : nat, synthesis (analysis_seq h n) M N.
intros.
unfold analysis_def in |- *.
intros.
induction H as [M N H| M N K L H1 HrecH1 H0 HrecH0| M1 N1 M2 N2 H1 HrecH1 H0 HrecH0| o M N H HrecH].
elim HrecH1.
intro n1.
intro.
elim HrecH0.
intro n2.

*****
n2 : nat
H : synthesis (analysis_seq h n1) M N
n1 : nat
HrecH0 : ex (fun n : nat => synthesis (analysis_seq h n) K L)
HrecH1 : ex (fun n : nat => synthesis (analysis_seq h n) M N)
H0 : synthesis (analysis_def h) K L
H1 : synthesis (analysis_def h) M N
M,N,K,L : Msg
h : hedge
*****
forall _ : synthesis (analysis_seq h n2) K L, ex (fun n : nat => synthesis (analysis_seq h n) (MEnc M K) (MEnc N L))
+++++
intro.
-----
Lemma synthesis_analysis_seq : forall (h : hedge) (M N : Msg), synthesis (analysis_def h) M N -> exists n : nat, synthesis (analysis_seq h n) M N.
intros.
unfold analysis_def in |- *.
intros.
induction H as [M N H| M N K L H1 HrecH1 H0 HrecH0| M1 N1 M2 N2 H1 HrecH1 H0 HrecH0| o M N H HrecH].
elim HrecH1.
intro n1.
intro.
elim HrecH0.
intro n2.
intro.

*****
H2 : synthesis (analysis_seq h n2) K L
n2 : nat
H : synthesis (analysis_seq h n1) M N
n1 : nat
HrecH0 : ex (fun n : nat => synthesis (analysis_seq h n) K L)
HrecH1 : ex (fun n : nat => synthesis (analysis_seq h n) M N)
H0 : synthesis (analysis_def h) K L
H1 : synthesis (analysis_def h) M N
M,N,K,L : Msg
h : hedge
*****
ex (fun n : nat => synthesis (analysis_seq h n) (MEnc M K) (MEnc N L))
+++++
exists (max n1 n2).
-----
Lemma synthesis_analysis_seq : forall (h : hedge) (M N : Msg), synthesis (analysis_def h) M N -> exists n : nat, synthesis (analysis_seq h n) M N.
intros.
unfold analysis_def in |- *.
intros.
induction H as [M N H| M N K L H1 HrecH1 H0 HrecH0| M1 N1 M2 N2 H1 HrecH1 H0 HrecH0| o M N H HrecH].
elim HrecH1.
intro n1.
intro.
elim HrecH0.
intro n2.
intro.
exists (max n1 n2).

*****
H2 : synthesis (analysis_seq h n2) K L
n2 : nat
H : synthesis (analysis_seq h n1) M N
n1 : nat
HrecH0 : ex (fun n : nat => synthesis (analysis_seq h n) K L)
HrecH1 : ex (fun n : nat => synthesis (analysis_seq h n) M N)
H0 : synthesis (analysis_def h) K L
H1 : synthesis (analysis_def h) M N
M,N,K,L : Msg
h : hedge
*****
synthesis (analysis_seq h (Nat.max n1 n2)) (MEnc M K) (MEnc N L)
+++++
apply SynEnc.
-----
Lemma synthesis_analysis_seq : forall (h : hedge) (M N : Msg), synthesis (analysis_def h) M N -> exists n : nat, synthesis (analysis_seq h n) M N.
intros.
unfold analysis_def in |- *.
intros.
induction H as [M N H| M N K L H1 HrecH1 H0 HrecH0| M1 N1 M2 N2 H1 HrecH1 H0 HrecH0| o M N H HrecH].
elim HrecH1.
intro n1.
intro.
elim HrecH0.
intro n2.
intro.
exists (max n1 n2).
apply SynEnc.

*****
H2 : synthesis (analysis_seq h n2) K L
n2 : nat
H : synthesis (analysis_seq h n1) M N
n1 : nat
HrecH0 : ex (fun n : nat => synthesis (analysis_seq h n) K L)
HrecH1 : ex (fun n : nat => synthesis (analysis_seq h n) M N)
H0 : synthesis (analysis_def h) K L
H1 : synthesis (analysis_def h) M N
M,N,K,L : Msg
h : hedge
*****
synthesis (analysis_seq h (Nat.max n1 n2)) M N
+++++
generalize (inclusion_impl_le_h (analysis_seq h n1) (analysis_seq h (max n1 n2)) (analysis_seq_increase n1 (max n1 n2) h (le_max_l n1 n2))).
-----
Lemma synthesis_analysis_seq : forall (h : hedge) (M N : Msg), synthesis (analysis_def h) M N -> exists n : nat, synthesis (analysis_seq h n) M N.
intros.
unfold analysis_def in |- *.
intros.
induction H as [M N H| M N K L H1 HrecH1 H0 HrecH0| M1 N1 M2 N2 H1 HrecH1 H0 HrecH0| o M N H HrecH].
elim HrecH1.
intro n1.
intro.
elim HrecH0.
intro n2.
intro.
exists (max n1 n2).
apply SynEnc.
generalize (inclusion_impl_le_h (analysis_seq h n1) (analysis_seq h (max n1 n2)) (analysis_seq_increase n1 (max n1 n2) h (le_max_l n1 n2))).

*****
H2 : synthesis (analysis_seq h n2) K L
n2 : nat
H : synthesis (analysis_seq h n1) M N
n1 : nat
HrecH0 : ex (fun n : nat => synthesis (analysis_seq h n) K L)
HrecH1 : ex (fun n : nat => synthesis (analysis_seq h n) M N)
H0 : synthesis (analysis_def h) K L
H1 : synthesis (analysis_def h) M N
M,N,K,L : Msg
h : hedge
*****
forall _ : le_h (analysis_seq h n1) (analysis_seq h (Nat.max n1 n2)), synthesis (analysis_seq h (Nat.max n1 n2)) M N
+++++
unfold le_h in |- *.
-----
Lemma synthesis_analysis_seq : forall (h : hedge) (M N : Msg), synthesis (analysis_def h) M N -> exists n : nat, synthesis (analysis_seq h n) M N.
intros.
unfold analysis_def in |- *.
intros.
induction H as [M N H| M N K L H1 HrecH1 H0 HrecH0| M1 N1 M2 N2 H1 HrecH1 H0 HrecH0| o M N H HrecH].
elim HrecH1.
intro n1.
intro.
elim HrecH0.
intro n2.
intro.
exists (max n1 n2).
apply SynEnc.
generalize (inclusion_impl_le_h (analysis_seq h n1) (analysis_seq h (max n1 n2)) (analysis_seq_increase n1 (max n1 n2) h (le_max_l n1 n2))).
unfold le_h in |- *.

*****
H2 : synthesis (analysis_seq h n2) K L
n2 : nat
H : synthesis (analysis_seq h n1) M N
n1 : nat
HrecH0 : ex (fun n : nat => synthesis (analysis_seq h n) K L)
HrecH1 : ex (fun n : nat => synthesis (analysis_seq h n) M N)
H0 : synthesis (analysis_def h) K L
H1 : synthesis (analysis_def h) M N
M,N,K,L : Msg
h : hedge
*****
forall _ : inclusion (synthesis (analysis_seq h n1)) (synthesis (analysis_seq h (Nat.max n1 n2))), synthesis (analysis_seq h (Nat.max n1 n2)) M N
+++++
auto.
-----
Lemma synthesis_analysis_seq : forall (h : hedge) (M N : Msg), synthesis (analysis_def h) M N -> exists n : nat, synthesis (analysis_seq h n) M N.
intros.
unfold analysis_def in |- *.
intros.
induction H as [M N H| M N K L H1 HrecH1 H0 HrecH0| M1 N1 M2 N2 H1 HrecH1 H0 HrecH0| o M N H HrecH].
elim HrecH1.
intro n1.
intro.
elim HrecH0.
intro n2.
intro.
exists (max n1 n2).
apply SynEnc.

*****
H2 : synthesis (analysis_seq h n2) K L
n2 : nat
H : synthesis (analysis_seq h n1) M N
n1 : nat
HrecH0 : ex (fun n : nat => synthesis (analysis_seq h n) K L)
HrecH1 : ex (fun n : nat => synthesis (analysis_seq h n) M N)
H0 : synthesis (analysis_def h) K L
H1 : synthesis (analysis_def h) M N
M,N,K,L : Msg
h : hedge
*****
synthesis (analysis_seq h (Nat.max n1 n2)) K L
+++++
generalize (inclusion_impl_le_h (analysis_seq h n2) (analysis_seq h (max n1 n2)) (analysis_seq_increase n2 (max n1 n2) h (le_max_r n1 n2))).
-----
Lemma synthesis_analysis_seq : forall (h : hedge) (M N : Msg), synthesis (analysis_def h) M N -> exists n : nat, synthesis (analysis_seq h n) M N.
intros.
unfold analysis_def in |- *.
intros.
induction H as [M N H| M N K L H1 HrecH1 H0 HrecH0| M1 N1 M2 N2 H1 HrecH1 H0 HrecH0| o M N H HrecH].
elim HrecH1.
intro n1.
intro.
elim HrecH0.
intro n2.
intro.
exists (max n1 n2).
apply SynEnc.
generalize (inclusion_impl_le_h (analysis_seq h n2) (analysis_seq h (max n1 n2)) (analysis_seq_increase n2 (max n1 n2) h (le_max_r n1 n2))).

*****
H2 : synthesis (analysis_seq h n2) K L
n2 : nat
H : synthesis (analysis_seq h n1) M N
n1 : nat
HrecH0 : ex (fun n : nat => synthesis (analysis_seq h n) K L)
HrecH1 : ex (fun n : nat => synthesis (analysis_seq h n) M N)
H0 : synthesis (analysis_def h) K L
H1 : synthesis (analysis_def h) M N
M,N,K,L : Msg
h : hedge
*****
forall _ : le_h (analysis_seq h n2) (analysis_seq h (Nat.max n1 n2)), synthesis (analysis_seq h (Nat.max n1 n2)) K L
+++++
unfold le_h in |- *.
-----
Lemma synthesis_analysis_seq : forall (h : hedge) (M N : Msg), synthesis (analysis_def h) M N -> exists n : nat, synthesis (analysis_seq h n) M N.
intros.
unfold analysis_def in |- *.
intros.
induction H as [M N H| M N K L H1 HrecH1 H0 HrecH0| M1 N1 M2 N2 H1 HrecH1 H0 HrecH0| o M N H HrecH].
elim HrecH1.
intro n1.
intro.
elim HrecH0.
intro n2.
intro.
exists (max n1 n2).
apply SynEnc.
generalize (inclusion_impl_le_h (analysis_seq h n2) (analysis_seq h (max n1 n2)) (analysis_seq_increase n2 (max n1 n2) h (le_max_r n1 n2))).
unfold le_h in |- *.

*****
H2 : synthesis (analysis_seq h n2) K L
n2 : nat
H : synthesis (analysis_seq h n1) M N
n1 : nat
HrecH0 : ex (fun n : nat => synthesis (analysis_seq h n) K L)
HrecH1 : ex (fun n : nat => synthesis (analysis_seq h n) M N)
H0 : synthesis (analysis_def h) K L
H1 : synthesis (analysis_def h) M N
M,N,K,L : Msg
h : hedge
*****
forall _ : inclusion (synthesis (analysis_seq h n2)) (synthesis (analysis_seq h (Nat.max n1 n2))), synthesis (analysis_seq h (Nat.max n1 n2)) K L
+++++
auto.
-----
Lemma synthesis_analysis_seq : forall (h : hedge) (M N : Msg), synthesis (analysis_def h) M N -> exists n : nat, synthesis (analysis_seq h n) M N.
intros.
unfold analysis_def in |- *.
intros.
induction H as [M N H| M N K L H1 HrecH1 H0 HrecH0| M1 N1 M2 N2 H1 HrecH1 H0 HrecH0| o M N H HrecH].

*****
HrecH0 : ex (fun n : nat => synthesis (analysis_seq h n) M2 N2)
HrecH1 : ex (fun n : nat => synthesis (analysis_seq h n) M1 N1)
H0 : synthesis (analysis_def h) M2 N2
H1 : synthesis (analysis_def h) M1 N1
M1,N1,M2,N2 : Msg
h : hedge
*****
ex (fun n : nat => synthesis (analysis_seq h n) (MPair M1 M2) (MPair N1 N2))
+++++
elim HrecH0.
-----
Lemma synthesis_analysis_seq : forall (h : hedge) (M N : Msg), synthesis (analysis_def h) M N -> exists n : nat, synthesis (analysis_seq h n) M N.
intros.
unfold analysis_def in |- *.
intros.
induction H as [M N H| M N K L H1 HrecH1 H0 HrecH0| M1 N1 M2 N2 H1 HrecH1 H0 HrecH0| o M N H HrecH].
elim HrecH0.

*****
HrecH0 : ex (fun n : nat => synthesis (analysis_seq h n) M2 N2)
HrecH1 : ex (fun n : nat => synthesis (analysis_seq h n) M1 N1)
H0 : synthesis (analysis_def h) M2 N2
H1 : synthesis (analysis_def h) M1 N1
M1,N1,M2,N2 : Msg
h : hedge
*****
forall (x : nat) (_ : synthesis (analysis_seq h x) M2 N2), ex (fun n : nat => synthesis (analysis_seq h n) (MPair M1 M2) (MPair N1 N2))
+++++
elim HrecH1.
-----
Lemma synthesis_analysis_seq : forall (h : hedge) (M N : Msg), synthesis (analysis_def h) M N -> exists n : nat, synthesis (analysis_seq h n) M N.
intros.
unfold analysis_def in |- *.
intros.
induction H as [M N H| M N K L H1 HrecH1 H0 HrecH0| M1 N1 M2 N2 H1 HrecH1 H0 HrecH0| o M N H HrecH].
elim HrecH0.
elim HrecH1.

*****
HrecH0 : ex (fun n : nat => synthesis (analysis_seq h n) M2 N2)
HrecH1 : ex (fun n : nat => synthesis (analysis_seq h n) M1 N1)
H0 : synthesis (analysis_def h) M2 N2
H1 : synthesis (analysis_def h) M1 N1
M1,N1,M2,N2 : Msg
h : hedge
*****
forall (x : nat) (_ : synthesis (analysis_seq h x) M1 N1) (x0 : nat) (_ : synthesis (analysis_seq h x0) M2 N2), ex (fun n : nat => synthesis (analysis_seq h n) (MPair M1 M2) (MPair N1 N2))
+++++
intro n1.
-----
Lemma synthesis_analysis_seq : forall (h : hedge) (M N : Msg), synthesis (analysis_def h) M N -> exists n : nat, synthesis (analysis_seq h n) M N.
intros.
unfold analysis_def in |- *.
intros.
induction H as [M N H| M N K L H1 HrecH1 H0 HrecH0| M1 N1 M2 N2 H1 HrecH1 H0 HrecH0| o M N H HrecH].
elim HrecH0.
elim HrecH1.
intro n1.

*****
n1 : nat
HrecH0 : ex (fun n : nat => synthesis (analysis_seq h n) M2 N2)
HrecH1 : ex (fun n : nat => synthesis (analysis_seq h n) M1 N1)
H0 : synthesis (analysis_def h) M2 N2
H1 : synthesis (analysis_def h) M1 N1
M1,N1,M2,N2 : Msg
h : hedge
*****
forall (_ : synthesis (analysis_seq h n1) M1 N1) (x : nat) (_ : synthesis (analysis_seq h x) M2 N2), ex (fun n : nat => synthesis (analysis_seq h n) (MPair M1 M2) (MPair N1 N2))
+++++
intro.
-----
Lemma synthesis_analysis_seq : forall (h : hedge) (M N : Msg), synthesis (analysis_def h) M N -> exists n : nat, synthesis (analysis_seq h n) M N.
intros.
unfold analysis_def in |- *.
intros.
induction H as [M N H| M N K L H1 HrecH1 H0 HrecH0| M1 N1 M2 N2 H1 HrecH1 H0 HrecH0| o M N H HrecH].
elim HrecH0.
elim HrecH1.
intro n1.
intro.

*****
H : synthesis (analysis_seq h n1) M1 N1
n1 : nat
HrecH0 : ex (fun n : nat => synthesis (analysis_seq h n) M2 N2)
HrecH1 : ex (fun n : nat => synthesis (analysis_seq h n) M1 N1)
H0 : synthesis (analysis_def h) M2 N2
H1 : synthesis (analysis_def h) M1 N1
M1,N1,M2,N2 : Msg
h : hedge
*****
forall (x : nat) (_ : synthesis (analysis_seq h x) M2 N2), ex (fun n : nat => synthesis (analysis_seq h n) (MPair M1 M2) (MPair N1 N2))
+++++
intro n2.
-----
Lemma synthesis_analysis_seq : forall (h : hedge) (M N : Msg), synthesis (analysis_def h) M N -> exists n : nat, synthesis (analysis_seq h n) M N.
intros.
unfold analysis_def in |- *.
intros.
induction H as [M N H| M N K L H1 HrecH1 H0 HrecH0| M1 N1 M2 N2 H1 HrecH1 H0 HrecH0| o M N H HrecH].
elim HrecH0.
elim HrecH1.
intro n1.
intro.
intro n2.

*****
n2 : nat
H : synthesis (analysis_seq h n1) M1 N1
n1 : nat
HrecH0 : ex (fun n : nat => synthesis (analysis_seq h n) M2 N2)
HrecH1 : ex (fun n : nat => synthesis (analysis_seq h n) M1 N1)
H0 : synthesis (analysis_def h) M2 N2
H1 : synthesis (analysis_def h) M1 N1
M1,N1,M2,N2 : Msg
h : hedge
*****
forall _ : synthesis (analysis_seq h n2) M2 N2, ex (fun n : nat => synthesis (analysis_seq h n) (MPair M1 M2) (MPair N1 N2))
+++++
intro.
-----
Lemma synthesis_analysis_seq : forall (h : hedge) (M N : Msg), synthesis (analysis_def h) M N -> exists n : nat, synthesis (analysis_seq h n) M N.
intros.
unfold analysis_def in |- *.
intros.
induction H as [M N H| M N K L H1 HrecH1 H0 HrecH0| M1 N1 M2 N2 H1 HrecH1 H0 HrecH0| o M N H HrecH].
elim HrecH0.
elim HrecH1.
intro n1.
intro.
intro n2.
intro.

*****
H2 : synthesis (analysis_seq h n2) M2 N2
n2 : nat
H : synthesis (analysis_seq h n1) M1 N1
n1 : nat
HrecH0 : ex (fun n : nat => synthesis (analysis_seq h n) M2 N2)
HrecH1 : ex (fun n : nat => synthesis (analysis_seq h n) M1 N1)
H0 : synthesis (analysis_def h) M2 N2
H1 : synthesis (analysis_def h) M1 N1
M1,N1,M2,N2 : Msg
h : hedge
*****
ex (fun n : nat => synthesis (analysis_seq h n) (MPair M1 M2) (MPair N1 N2))
+++++
exists (max n1 n2).
-----
Lemma synthesis_analysis_seq : forall (h : hedge) (M N : Msg), synthesis (analysis_def h) M N -> exists n : nat, synthesis (analysis_seq h n) M N.
intros.
unfold analysis_def in |- *.
intros.
induction H as [M N H| M N K L H1 HrecH1 H0 HrecH0| M1 N1 M2 N2 H1 HrecH1 H0 HrecH0| o M N H HrecH].
elim HrecH0.
elim HrecH1.
intro n1.
intro.
intro n2.
intro.
exists (max n1 n2).

*****
H2 : synthesis (analysis_seq h n2) M2 N2
n2 : nat
H : synthesis (analysis_seq h n1) M1 N1
n1 : nat
HrecH0 : ex (fun n : nat => synthesis (analysis_seq h n) M2 N2)
HrecH1 : ex (fun n : nat => synthesis (analysis_seq h n) M1 N1)
H0 : synthesis (analysis_def h) M2 N2
H1 : synthesis (analysis_def h) M1 N1
M1,N1,M2,N2 : Msg
h : hedge
*****
synthesis (analysis_seq h (Nat.max n1 n2)) (MPair M1 M2) (MPair N1 N2)
+++++
apply SynPair.
-----
Lemma synthesis_analysis_seq : forall (h : hedge) (M N : Msg), synthesis (analysis_def h) M N -> exists n : nat, synthesis (analysis_seq h n) M N.
intros.
unfold analysis_def in |- *.
intros.
induction H as [M N H| M N K L H1 HrecH1 H0 HrecH0| M1 N1 M2 N2 H1 HrecH1 H0 HrecH0| o M N H HrecH].
elim HrecH0.
elim HrecH1.
intro n1.
intro.
intro n2.
intro.
exists (max n1 n2).
apply SynPair.

*****
H2 : synthesis (analysis_seq h n2) M2 N2
n2 : nat
H : synthesis (analysis_seq h n1) M1 N1
n1 : nat
HrecH0 : ex (fun n : nat => synthesis (analysis_seq h n) M2 N2)
HrecH1 : ex (fun n : nat => synthesis (analysis_seq h n) M1 N1)
H0 : synthesis (analysis_def h) M2 N2
H1 : synthesis (analysis_def h) M1 N1
M1,N1,M2,N2 : Msg
h : hedge
*****
synthesis (analysis_seq h (Nat.max n1 n2)) M1 N1
+++++
generalize (inclusion_impl_le_h (analysis_seq h n1) (analysis_seq h (max n1 n2)) (analysis_seq_increase n1 (max n1 n2) h (le_max_l n1 n2))).
-----
Lemma synthesis_analysis_seq : forall (h : hedge) (M N : Msg), synthesis (analysis_def h) M N -> exists n : nat, synthesis (analysis_seq h n) M N.
intros.
unfold analysis_def in |- *.
intros.
induction H as [M N H| M N K L H1 HrecH1 H0 HrecH0| M1 N1 M2 N2 H1 HrecH1 H0 HrecH0| o M N H HrecH].
elim HrecH0.
elim HrecH1.
intro n1.
intro.
intro n2.
intro.
exists (max n1 n2).
apply SynPair.
generalize (inclusion_impl_le_h (analysis_seq h n1) (analysis_seq h (max n1 n2)) (analysis_seq_increase n1 (max n1 n2) h (le_max_l n1 n2))).

*****
H2 : synthesis (analysis_seq h n2) M2 N2
n2 : nat
H : synthesis (analysis_seq h n1) M1 N1
n1 : nat
HrecH0 : ex (fun n : nat => synthesis (analysis_seq h n) M2 N2)
HrecH1 : ex (fun n : nat => synthesis (analysis_seq h n) M1 N1)
H0 : synthesis (analysis_def h) M2 N2
H1 : synthesis (analysis_def h) M1 N1
M1,N1,M2,N2 : Msg
h : hedge
*****
forall _ : le_h (analysis_seq h n1) (analysis_seq h (Nat.max n1 n2)), synthesis (analysis_seq h (Nat.max n1 n2)) M1 N1
+++++
unfold le_h in |- *.
-----
Lemma synthesis_analysis_seq : forall (h : hedge) (M N : Msg), synthesis (analysis_def h) M N -> exists n : nat, synthesis (analysis_seq h n) M N.
intros.
unfold analysis_def in |- *.
intros.
induction H as [M N H| M N K L H1 HrecH1 H0 HrecH0| M1 N1 M2 N2 H1 HrecH1 H0 HrecH0| o M N H HrecH].
elim HrecH0.
elim HrecH1.
intro n1.
intro.
intro n2.
intro.
exists (max n1 n2).
apply SynPair.
generalize (inclusion_impl_le_h (analysis_seq h n1) (analysis_seq h (max n1 n2)) (analysis_seq_increase n1 (max n1 n2) h (le_max_l n1 n2))).
unfold le_h in |- *.

*****
H2 : synthesis (analysis_seq h n2) M2 N2
n2 : nat
H : synthesis (analysis_seq h n1) M1 N1
n1 : nat
HrecH0 : ex (fun n : nat => synthesis (analysis_seq h n) M2 N2)
HrecH1 : ex (fun n : nat => synthesis (analysis_seq h n) M1 N1)
H0 : synthesis (analysis_def h) M2 N2
H1 : synthesis (analysis_def h) M1 N1
M1,N1,M2,N2 : Msg
h : hedge
*****
forall _ : inclusion (synthesis (analysis_seq h n1)) (synthesis (analysis_seq h (Nat.max n1 n2))), synthesis (analysis_seq h (Nat.max n1 n2)) M1 N1
+++++
auto.
-----
Lemma synthesis_analysis_seq : forall (h : hedge) (M N : Msg), synthesis (analysis_def h) M N -> exists n : nat, synthesis (analysis_seq h n) M N.
intros.
unfold analysis_def in |- *.
intros.
induction H as [M N H| M N K L H1 HrecH1 H0 HrecH0| M1 N1 M2 N2 H1 HrecH1 H0 HrecH0| o M N H HrecH].
elim HrecH0.
elim HrecH1.
intro n1.
intro.
intro n2.
intro.
exists (max n1 n2).
apply SynPair.

*****
H2 : synthesis (analysis_seq h n2) M2 N2
n2 : nat
H : synthesis (analysis_seq h n1) M1 N1
n1 : nat
HrecH0 : ex (fun n : nat => synthesis (analysis_seq h n) M2 N2)
HrecH1 : ex (fun n : nat => synthesis (analysis_seq h n) M1 N1)
H0 : synthesis (analysis_def h) M2 N2
H1 : synthesis (analysis_def h) M1 N1
M1,N1,M2,N2 : Msg
h : hedge
*****
synthesis (analysis_seq h (Nat.max n1 n2)) M2 N2
+++++
generalize (inclusion_impl_le_h (analysis_seq h n2) (analysis_seq h (max n1 n2)) (analysis_seq_increase n2 (max n1 n2) h (le_max_r n1 n2))).
-----
Lemma synthesis_analysis_seq : forall (h : hedge) (M N : Msg), synthesis (analysis_def h) M N -> exists n : nat, synthesis (analysis_seq h n) M N.
intros.
unfold analysis_def in |- *.
intros.
induction H as [M N H| M N K L H1 HrecH1 H0 HrecH0| M1 N1 M2 N2 H1 HrecH1 H0 HrecH0| o M N H HrecH].
elim HrecH0.
elim HrecH1.
intro n1.
intro.
intro n2.
intro.
exists (max n1 n2).
apply SynPair.
generalize (inclusion_impl_le_h (analysis_seq h n2) (analysis_seq h (max n1 n2)) (analysis_seq_increase n2 (max n1 n2) h (le_max_r n1 n2))).

*****
H2 : synthesis (analysis_seq h n2) M2 N2
n2 : nat
H : synthesis (analysis_seq h n1) M1 N1
n1 : nat
HrecH0 : ex (fun n : nat => synthesis (analysis_seq h n) M2 N2)
HrecH1 : ex (fun n : nat => synthesis (analysis_seq h n) M1 N1)
H0 : synthesis (analysis_def h) M2 N2
H1 : synthesis (analysis_def h) M1 N1
M1,N1,M2,N2 : Msg
h : hedge
*****
forall _ : le_h (analysis_seq h n2) (analysis_seq h (Nat.max n1 n2)), synthesis (analysis_seq h (Nat.max n1 n2)) M2 N2
+++++
unfold le_h in |- *.
-----
Lemma synthesis_analysis_seq : forall (h : hedge) (M N : Msg), synthesis (analysis_def h) M N -> exists n : nat, synthesis (analysis_seq h n) M N.
intros.
unfold analysis_def in |- *.
intros.
induction H as [M N H| M N K L H1 HrecH1 H0 HrecH0| M1 N1 M2 N2 H1 HrecH1 H0 HrecH0| o M N H HrecH].
elim HrecH0.
elim HrecH1.
intro n1.
intro.
intro n2.
intro.
exists (max n1 n2).
apply SynPair.
generalize (inclusion_impl_le_h (analysis_seq h n2) (analysis_seq h (max n1 n2)) (analysis_seq_increase n2 (max n1 n2) h (le_max_r n1 n2))).
unfold le_h in |- *.

*****
H2 : synthesis (analysis_seq h n2) M2 N2
n2 : nat
H : synthesis (analysis_seq h n1) M1 N1
n1 : nat
HrecH0 : ex (fun n : nat => synthesis (analysis_seq h n) M2 N2)
HrecH1 : ex (fun n : nat => synthesis (analysis_seq h n) M1 N1)
H0 : synthesis (analysis_def h) M2 N2
H1 : synthesis (analysis_def h) M1 N1
M1,N1,M2,N2 : Msg
h : hedge
*****
forall _ : inclusion (synthesis (analysis_seq h n2)) (synthesis (analysis_seq h (Nat.max n1 n2))), synthesis (analysis_seq h (Nat.max n1 n2)) M2 N2
+++++
auto.
-----
Lemma synthesis_analysis_seq : forall (h : hedge) (M N : Msg), synthesis (analysis_def h) M N -> exists n : nat, synthesis (analysis_seq h n) M N.
intros.
unfold analysis_def in |- *.
intros.
induction H as [M N H| M N K L H1 HrecH1 H0 HrecH0| M1 N1 M2 N2 H1 HrecH1 H0 HrecH0| o M N H HrecH].

*****
HrecH : ex (fun n : nat => synthesis (analysis_seq h n) M N)
H : synthesis (analysis_def h) M N
M,N : Msg
o : op
h : hedge
*****
ex (fun n : nat => synthesis (analysis_seq h n) (Mop o M) (Mop o N))
+++++
elim HrecH.
-----
Lemma synthesis_analysis_seq : forall (h : hedge) (M N : Msg), synthesis (analysis_def h) M N -> exists n : nat, synthesis (analysis_seq h n) M N.
intros.
unfold analysis_def in |- *.
intros.
induction H as [M N H| M N K L H1 HrecH1 H0 HrecH0| M1 N1 M2 N2 H1 HrecH1 H0 HrecH0| o M N H HrecH].
elim HrecH.

*****
HrecH : ex (fun n : nat => synthesis (analysis_seq h n) M N)
H : synthesis (analysis_def h) M N
M,N : Msg
o : op
h : hedge
*****
forall (x : nat) (_ : synthesis (analysis_seq h x) M N), ex (fun n : nat => synthesis (analysis_seq h n) (Mop o M) (Mop o N))
+++++
intro n.
-----
Lemma synthesis_analysis_seq : forall (h : hedge) (M N : Msg), synthesis (analysis_def h) M N -> exists n : nat, synthesis (analysis_seq h n) M N.
intros.
unfold analysis_def in |- *.
intros.
induction H as [M N H| M N K L H1 HrecH1 H0 HrecH0| M1 N1 M2 N2 H1 HrecH1 H0 HrecH0| o M N H HrecH].
elim HrecH.
intro n.

*****
n : nat
HrecH : ex (fun n : nat => synthesis (analysis_seq h n) M N)
H : synthesis (analysis_def h) M N
M,N : Msg
o : op
h : hedge
*****
forall _ : synthesis (analysis_seq h n) M N, ex (fun n : nat => synthesis (analysis_seq h n) (Mop o M) (Mop o N))
+++++
intro.
-----
Lemma synthesis_analysis_seq : forall (h : hedge) (M N : Msg), synthesis (analysis_def h) M N -> exists n : nat, synthesis (analysis_seq h n) M N.
intros.
unfold analysis_def in |- *.
intros.
induction H as [M N H| M N K L H1 HrecH1 H0 HrecH0| M1 N1 M2 N2 H1 HrecH1 H0 HrecH0| o M N H HrecH].
elim HrecH.
intro n.
intro.

*****
H0 : synthesis (analysis_seq h n) M N
n : nat
HrecH : ex (fun n : nat => synthesis (analysis_seq h n) M N)
H : synthesis (analysis_def h) M N
M,N : Msg
o : op
h : hedge
*****
ex (fun n : nat => synthesis (analysis_seq h n) (Mop o M) (Mop o N))
+++++
exists n.
-----
Lemma synthesis_analysis_seq : forall (h : hedge) (M N : Msg), synthesis (analysis_def h) M N -> exists n : nat, synthesis (analysis_seq h n) M N.
intros.
unfold analysis_def in |- *.
intros.
induction H as [M N H| M N K L H1 HrecH1 H0 HrecH0| M1 N1 M2 N2 H1 HrecH1 H0 HrecH0| o M N H HrecH].
elim HrecH.
intro n.
intro.
exists n.

*****
H0 : synthesis (analysis_seq h n) M N
n : nat
HrecH : ex (fun n : nat => synthesis (analysis_seq h n) M N)
H : synthesis (analysis_def h) M N
M,N : Msg
o : op
h : hedge
*****
synthesis (analysis_seq h n) (Mop o M) (Mop o N)
+++++
apply SynOp.
-----
Lemma synthesis_analysis_seq : forall (h : hedge) (M N : Msg), synthesis (analysis_def h) M N -> exists n : nat, synthesis (analysis_seq h n) M N.
intros.
unfold analysis_def in |- *.
intros.
induction H as [M N H| M N K L H1 HrecH1 H0 HrecH0| M1 N1 M2 N2 H1 HrecH1 H0 HrecH0| o M N H HrecH].
elim HrecH.
intro n.
intro.
exists n.
apply SynOp.

*****
H0 : synthesis (analysis_seq h n) M N
n : nat
HrecH : ex (fun n : nat => synthesis (analysis_seq h n) M N)
H : synthesis (analysis_def h) M N
M,N : Msg
o : op
h : hedge
*****
synthesis (analysis_seq h n) M N
+++++
trivial.
-----
Lemma synthesis_analysis_seq : forall (h : hedge) (M N : Msg), synthesis (analysis_def h) M N -> exists n : nat, synthesis (analysis_seq h n) M N.
intros.
unfold analysis_def in |- *.
intros.
induction H as [M N H| M N K L H1 HrecH1 H0 HrecH0| M1 N1 M2 N2 H1 HrecH1 H0 HrecH0| o M N H HrecH].

*****

*****

+++++
Qed.
-----
Lemma analysis_is_analysis : forall h : hedge, is_analysis h (analysis_def h).
-----
Lemma analysis_is_analysis : forall h : hedge, is_analysis h (analysis_def h).

*****

*****
forall h : hedge, is_analysis h (analysis_def h)
+++++
unfold is_analysis in |- *.
-----
Lemma analysis_is_analysis : forall h : hedge, is_analysis h (analysis_def h).
unfold is_analysis in |- *.

*****

*****
forall h : hedge, and (analysis_cond h (analysis_def h)) (forall (h' : hedge) (_ : analysis_cond h h'), inclusion (analysis_def h) h')
+++++
split.
-----
Lemma analysis_is_analysis : forall h : hedge, is_analysis h (analysis_def h).
unfold is_analysis in |- *.
split.

*****
h : hedge
*****
analysis_cond h (analysis_def h)
+++++
unfold analysis_cond in |- *.
-----
Lemma analysis_is_analysis : forall h : hedge, is_analysis h (analysis_def h).
unfold is_analysis in |- *.
split.
unfold analysis_cond in |- *.

*****
h : hedge
*****
and (inclusion h (analysis_def h)) (stable_analysis (analysis_def h))
+++++
split.
-----
Lemma analysis_is_analysis : forall h : hedge, is_analysis h (analysis_def h).
unfold is_analysis in |- *.
split.
unfold analysis_cond in |- *.
split.

*****
h : hedge
*****
inclusion h (analysis_def h)
+++++
unfold inclusion in |- *.
-----
Lemma analysis_is_analysis : forall h : hedge, is_analysis h (analysis_def h).
unfold is_analysis in |- *.
split.
unfold analysis_cond in |- *.
split.
unfold inclusion in |- *.

*****
h : hedge
*****
forall (M N : Msg) (_ : h M N), analysis_def h M N
+++++
intros.
-----
Lemma analysis_is_analysis : forall h : hedge, is_analysis h (analysis_def h).
unfold is_analysis in |- *.
split.
unfold analysis_cond in |- *.
split.
unfold inclusion in |- *.
intros.

*****
H : h M N
M,N : Msg
h : hedge
*****
analysis_def h M N
+++++
unfold analysis_def in |- *.
-----
Lemma analysis_is_analysis : forall h : hedge, is_analysis h (analysis_def h).
unfold is_analysis in |- *.
split.
unfold analysis_cond in |- *.
split.
unfold inclusion in |- *.
intros.
unfold analysis_def in |- *.

*****
H : h M N
M,N : Msg
h : hedge
*****
ex (fun n : nat => analysis_seq h n M N)
+++++
exists 0.
-----
Lemma analysis_is_analysis : forall h : hedge, is_analysis h (analysis_def h).
unfold is_analysis in |- *.
split.
unfold analysis_cond in |- *.
split.
unfold inclusion in |- *.
intros.
unfold analysis_def in |- *.
exists 0.

*****
H : h M N
M,N : Msg
h : hedge
*****
analysis_seq h O M N
+++++
simpl in |- *.
-----
Lemma analysis_is_analysis : forall h : hedge, is_analysis h (analysis_def h).
unfold is_analysis in |- *.
split.
unfold analysis_cond in |- *.
split.
unfold inclusion in |- *.
intros.
unfold analysis_def in |- *.
exists 0.
simpl in |- *.

*****
H : h M N
M,N : Msg
h : hedge
*****
h M N
+++++
trivial.
-----
Lemma analysis_is_analysis : forall h : hedge, is_analysis h (analysis_def h).
unfold is_analysis in |- *.
split.
unfold analysis_cond in |- *.
split.

*****
h : hedge
*****
stable_analysis (analysis_def h)
+++++
unfold stable_analysis in |- *.
-----
Lemma analysis_is_analysis : forall h : hedge, is_analysis h (analysis_def h).
unfold is_analysis in |- *.
split.
unfold analysis_cond in |- *.
split.
unfold stable_analysis in |- *.

*****
h : hedge
*****
inclusion (analysis (analysis_def h)) (analysis_def h)
+++++
unfold inclusion in |- *.
-----
Lemma analysis_is_analysis : forall h : hedge, is_analysis h (analysis_def h).
unfold is_analysis in |- *.
split.
unfold analysis_cond in |- *.
split.
unfold stable_analysis in |- *.
unfold inclusion in |- *.

*****
h : hedge
*****
forall (M N : Msg) (_ : analysis (analysis_def h) M N), analysis_def h M N
+++++
unfold analysis_def in |- *.
-----
Lemma analysis_is_analysis : forall h : hedge, is_analysis h (analysis_def h).
unfold is_analysis in |- *.
split.
unfold analysis_cond in |- *.
split.
unfold stable_analysis in |- *.
unfold inclusion in |- *.
unfold analysis_def in |- *.

*****
h : hedge
*****
forall (M N : Msg) (_ : analysis (fun M0 N0 : Msg => ex (fun n : nat => analysis_seq h n M0 N0)) M N), ex (fun n : nat => analysis_seq h n M N)
+++++
intros.
-----
Lemma analysis_is_analysis : forall h : hedge, is_analysis h (analysis_def h).
unfold is_analysis in |- *.
split.
unfold analysis_cond in |- *.
split.
unfold stable_analysis in |- *.
unfold inclusion in |- *.
unfold analysis_def in |- *.
intros.

*****
H : analysis (fun M N : Msg => ex (fun n : nat => analysis_seq h n M N)) M\n N
M,N : Msg
h : hedge
*****
ex (fun n : nat => analysis_seq h n M N)
+++++
induction H as [M N H| M1 M2 N1 N2 H HrecH| M1 M2 N1 N2 H HrecH| M N K L H HrecH H0].
-----
Lemma analysis_is_analysis : forall h : hedge, is_analysis h (analysis_def h).
unfold is_analysis in |- *.
split.
unfold analysis_cond in |- *.
split.
unfold stable_analysis in |- *.
unfold inclusion in |- *.
unfold analysis_def in |- *.
intros.
induction H as [M N H| M1 M2 N1 N2 H HrecH| M1 M2 N1 N2 H HrecH| M N K L H HrecH H0].

*****
H : ex (fun n : nat => analysis_seq h n M N)
M,N : Msg
h : hedge
*****
ex (fun n : nat => analysis_seq h n M N)
+++++
trivial.
-----
Lemma analysis_is_analysis : forall h : hedge, is_analysis h (analysis_def h).
unfold is_analysis in |- *.
split.
unfold analysis_cond in |- *.
split.
unfold stable_analysis in |- *.
unfold inclusion in |- *.
unfold analysis_def in |- *.
intros.
induction H as [M N H| M1 M2 N1 N2 H HrecH| M1 M2 N1 N2 H HrecH| M N K L H HrecH H0].

*****
HrecH : ex (fun n : nat => analysis_seq h n (MPair M1 M2) (MPair N1 N2))
H : analysis (fun M N : Msg => ex (fun n : nat => analysis_seq h n M N))\n (MPair M1 M2) (MPair N1 N2)
M1,M2,N1,N2 : Msg
h : hedge
*****
ex (fun n : nat => analysis_seq h n M1 N1)
+++++
elim HrecH.
-----
Lemma analysis_is_analysis : forall h : hedge, is_analysis h (analysis_def h).
unfold is_analysis in |- *.
split.
unfold analysis_cond in |- *.
split.
unfold stable_analysis in |- *.
unfold inclusion in |- *.
unfold analysis_def in |- *.
intros.
induction H as [M N H| M1 M2 N1 N2 H HrecH| M1 M2 N1 N2 H HrecH| M N K L H HrecH H0].
elim HrecH.

*****
HrecH : ex (fun n : nat => analysis_seq h n (MPair M1 M2) (MPair N1 N2))
H : analysis (fun M N : Msg => ex (fun n : nat => analysis_seq h n M N))\n (MPair M1 M2) (MPair N1 N2)
M1,M2,N1,N2 : Msg
h : hedge
*****
forall (x : nat) (_ : analysis_seq h x (MPair M1 M2) (MPair N1 N2)), ex (fun n : nat => analysis_seq h n M1 N1)
+++++
intro n.
-----
Lemma analysis_is_analysis : forall h : hedge, is_analysis h (analysis_def h).
unfold is_analysis in |- *.
split.
unfold analysis_cond in |- *.
split.
unfold stable_analysis in |- *.
unfold inclusion in |- *.
unfold analysis_def in |- *.
intros.
induction H as [M N H| M1 M2 N1 N2 H HrecH| M1 M2 N1 N2 H HrecH| M N K L H HrecH H0].
elim HrecH.
intro n.

*****
n : nat
HrecH : ex (fun n : nat => analysis_seq h n (MPair M1 M2) (MPair N1 N2))
H : analysis (fun M N : Msg => ex (fun n : nat => analysis_seq h n M N))\n (MPair M1 M2) (MPair N1 N2)
M1,M2,N1,N2 : Msg
h : hedge
*****
forall _ : analysis_seq h n (MPair M1 M2) (MPair N1 N2), ex (fun n : nat => analysis_seq h n M1 N1)
+++++
intro.
-----
Lemma analysis_is_analysis : forall h : hedge, is_analysis h (analysis_def h).
unfold is_analysis in |- *.
split.
unfold analysis_cond in |- *.
split.
unfold stable_analysis in |- *.
unfold inclusion in |- *.
unfold analysis_def in |- *.
intros.
induction H as [M N H| M1 M2 N1 N2 H HrecH| M1 M2 N1 N2 H HrecH| M N K L H HrecH H0].
elim HrecH.
intro n.
intro.

*****
H0 : analysis_seq h n (MPair M1 M2) (MPair N1 N2)
n : nat
HrecH : ex (fun n : nat => analysis_seq h n (MPair M1 M2) (MPair N1 N2))
H : analysis (fun M N : Msg => ex (fun n : nat => analysis_seq h n M N))\n (MPair M1 M2) (MPair N1 N2)
M1,M2,N1,N2 : Msg
h : hedge
*****
ex (fun n : nat => analysis_seq h n M1 N1)
+++++
exists (S n).
-----
Lemma analysis_is_analysis : forall h : hedge, is_analysis h (analysis_def h).
unfold is_analysis in |- *.
split.
unfold analysis_cond in |- *.
split.
unfold stable_analysis in |- *.
unfold inclusion in |- *.
unfold analysis_def in |- *.
intros.
induction H as [M N H| M1 M2 N1 N2 H HrecH| M1 M2 N1 N2 H HrecH| M N K L H HrecH H0].
elim HrecH.
intro n.
intro.
exists (S n).

*****
H0 : analysis_seq h n (MPair M1 M2) (MPair N1 N2)
n : nat
HrecH : ex (fun n : nat => analysis_seq h n (MPair M1 M2) (MPair N1 N2))
H : analysis (fun M N : Msg => ex (fun n : nat => analysis_seq h n M N))\n (MPair M1 M2) (MPair N1 N2)
M1,M2,N1,N2 : Msg
h : hedge
*****
analysis_seq h (S n) M1 N1
+++++
simpl in |- *.
-----
Lemma analysis_is_analysis : forall h : hedge, is_analysis h (analysis_def h).
unfold is_analysis in |- *.
split.
unfold analysis_cond in |- *.
split.
unfold stable_analysis in |- *.
unfold inclusion in |- *.
unfold analysis_def in |- *.
intros.
induction H as [M N H| M1 M2 N1 N2 H HrecH| M1 M2 N1 N2 H HrecH| M N K L H HrecH H0].
elim HrecH.
intro n.
intro.
exists (S n).
simpl in |- *.

*****
H0 : analysis_seq h n (MPair M1 M2) (MPair N1 N2)
n : nat
HrecH : ex (fun n : nat => analysis_seq h n (MPair M1 M2) (MPair N1 N2))
H : analysis (fun M N : Msg => ex (fun n : nat => analysis_seq h n M N))\n (MPair M1 M2) (MPair N1 N2)
M1,M2,N1,N2 : Msg
h : hedge
*****
analysis (analysis_seq h n) M1 N1
+++++
apply (AnaSplitL (analysis_seq h n) M1 M2 N1 N2).
-----
Lemma analysis_is_analysis : forall h : hedge, is_analysis h (analysis_def h).
unfold is_analysis in |- *.
split.
unfold analysis_cond in |- *.
split.
unfold stable_analysis in |- *.
unfold inclusion in |- *.
unfold analysis_def in |- *.
intros.
induction H as [M N H| M1 M2 N1 N2 H HrecH| M1 M2 N1 N2 H HrecH| M N K L H HrecH H0].
elim HrecH.
intro n.
intro.
exists (S n).
simpl in |- *.
apply (AnaSplitL (analysis_seq h n) M1 M2 N1 N2).

*****
H0 : analysis_seq h n (MPair M1 M2) (MPair N1 N2)
n : nat
HrecH : ex (fun n : nat => analysis_seq h n (MPair M1 M2) (MPair N1 N2))
H : analysis (fun M N : Msg => ex (fun n : nat => analysis_seq h n M N))\n (MPair M1 M2) (MPair N1 N2)
M1,M2,N1,N2 : Msg
h : hedge
*****
analysis (analysis_seq h n) (MPair M1 M2) (MPair N1 N2)
+++++
apply AnaInc.
-----
Lemma analysis_is_analysis : forall h : hedge, is_analysis h (analysis_def h).
unfold is_analysis in |- *.
split.
unfold analysis_cond in |- *.
split.
unfold stable_analysis in |- *.
unfold inclusion in |- *.
unfold analysis_def in |- *.
intros.
induction H as [M N H| M1 M2 N1 N2 H HrecH| M1 M2 N1 N2 H HrecH| M N K L H HrecH H0].
elim HrecH.
intro n.
intro.
exists (S n).
simpl in |- *.
apply (AnaSplitL (analysis_seq h n) M1 M2 N1 N2).
apply AnaInc.

*****
H0 : analysis_seq h n (MPair M1 M2) (MPair N1 N2)
n : nat
HrecH : ex (fun n : nat => analysis_seq h n (MPair M1 M2) (MPair N1 N2))
H : analysis (fun M N : Msg => ex (fun n : nat => analysis_seq h n M N))\n (MPair M1 M2) (MPair N1 N2)
M1,M2,N1,N2 : Msg
h : hedge
*****
analysis_seq h n (MPair M1 M2) (MPair N1 N2)
+++++
trivial.
-----
Lemma analysis_is_analysis : forall h : hedge, is_analysis h (analysis_def h).
unfold is_analysis in |- *.
split.
unfold analysis_cond in |- *.
split.
unfold stable_analysis in |- *.
unfold inclusion in |- *.
unfold analysis_def in |- *.
intros.
induction H as [M N H| M1 M2 N1 N2 H HrecH| M1 M2 N1 N2 H HrecH| M N K L H HrecH H0].

*****
HrecH : ex (fun n : nat => analysis_seq h n (MPair M1 M2) (MPair N1 N2))
H : analysis (fun M N : Msg => ex (fun n : nat => analysis_seq h n M N))\n (MPair M1 M2) (MPair N1 N2)
M1,M2,N1,N2 : Msg
h : hedge
*****
ex (fun n : nat => analysis_seq h n M2 N2)
+++++
elim HrecH.
-----
Lemma analysis_is_analysis : forall h : hedge, is_analysis h (analysis_def h).
unfold is_analysis in |- *.
split.
unfold analysis_cond in |- *.
split.
unfold stable_analysis in |- *.
unfold inclusion in |- *.
unfold analysis_def in |- *.
intros.
induction H as [M N H| M1 M2 N1 N2 H HrecH| M1 M2 N1 N2 H HrecH| M N K L H HrecH H0].
elim HrecH.

*****
HrecH : ex (fun n : nat => analysis_seq h n (MPair M1 M2) (MPair N1 N2))
H : analysis (fun M N : Msg => ex (fun n : nat => analysis_seq h n M N))\n (MPair M1 M2) (MPair N1 N2)
M1,M2,N1,N2 : Msg
h : hedge
*****
forall (x : nat) (_ : analysis_seq h x (MPair M1 M2) (MPair N1 N2)), ex (fun n : nat => analysis_seq h n M2 N2)
+++++
intro n.
-----
Lemma analysis_is_analysis : forall h : hedge, is_analysis h (analysis_def h).
unfold is_analysis in |- *.
split.
unfold analysis_cond in |- *.
split.
unfold stable_analysis in |- *.
unfold inclusion in |- *.
unfold analysis_def in |- *.
intros.
induction H as [M N H| M1 M2 N1 N2 H HrecH| M1 M2 N1 N2 H HrecH| M N K L H HrecH H0].
elim HrecH.
intro n.

*****
n : nat
HrecH : ex (fun n : nat => analysis_seq h n (MPair M1 M2) (MPair N1 N2))
H : analysis (fun M N : Msg => ex (fun n : nat => analysis_seq h n M N))\n (MPair M1 M2) (MPair N1 N2)
M1,M2,N1,N2 : Msg
h : hedge
*****
forall _ : analysis_seq h n (MPair M1 M2) (MPair N1 N2), ex (fun n : nat => analysis_seq h n M2 N2)
+++++
intro.
-----
Lemma analysis_is_analysis : forall h : hedge, is_analysis h (analysis_def h).
unfold is_analysis in |- *.
split.
unfold analysis_cond in |- *.
split.
unfold stable_analysis in |- *.
unfold inclusion in |- *.
unfold analysis_def in |- *.
intros.
induction H as [M N H| M1 M2 N1 N2 H HrecH| M1 M2 N1 N2 H HrecH| M N K L H HrecH H0].
elim HrecH.
intro n.
intro.

*****
H0 : analysis_seq h n (MPair M1 M2) (MPair N1 N2)
n : nat
HrecH : ex (fun n : nat => analysis_seq h n (MPair M1 M2) (MPair N1 N2))
H : analysis (fun M N : Msg => ex (fun n : nat => analysis_seq h n M N))\n (MPair M1 M2) (MPair N1 N2)
M1,M2,N1,N2 : Msg
h : hedge
*****
ex (fun n : nat => analysis_seq h n M2 N2)
+++++
exists (S n).
-----
Lemma analysis_is_analysis : forall h : hedge, is_analysis h (analysis_def h).
unfold is_analysis in |- *.
split.
unfold analysis_cond in |- *.
split.
unfold stable_analysis in |- *.
unfold inclusion in |- *.
unfold analysis_def in |- *.
intros.
induction H as [M N H| M1 M2 N1 N2 H HrecH| M1 M2 N1 N2 H HrecH| M N K L H HrecH H0].
elim HrecH.
intro n.
intro.
exists (S n).

*****
H0 : analysis_seq h n (MPair M1 M2) (MPair N1 N2)
n : nat
HrecH : ex (fun n : nat => analysis_seq h n (MPair M1 M2) (MPair N1 N2))
H : analysis (fun M N : Msg => ex (fun n : nat => analysis_seq h n M N))\n (MPair M1 M2) (MPair N1 N2)
M1,M2,N1,N2 : Msg
h : hedge
*****
analysis_seq h (S n) M2 N2
+++++
apply (AnaSplitR (analysis_seq h n) M1 M2 N1 N2).
-----
Lemma analysis_is_analysis : forall h : hedge, is_analysis h (analysis_def h).
unfold is_analysis in |- *.
split.
unfold analysis_cond in |- *.
split.
unfold stable_analysis in |- *.
unfold inclusion in |- *.
unfold analysis_def in |- *.
intros.
induction H as [M N H| M1 M2 N1 N2 H HrecH| M1 M2 N1 N2 H HrecH| M N K L H HrecH H0].
elim HrecH.
intro n.
intro.
exists (S n).
apply (AnaSplitR (analysis_seq h n) M1 M2 N1 N2).

*****
H0 : analysis_seq h n (MPair M1 M2) (MPair N1 N2)
n : nat
HrecH : ex (fun n : nat => analysis_seq h n (MPair M1 M2) (MPair N1 N2))
H : analysis (fun M N : Msg => ex (fun n : nat => analysis_seq h n M N))\n (MPair M1 M2) (MPair N1 N2)
M1,M2,N1,N2 : Msg
h : hedge
*****
analysis (analysis_seq h n) (MPair M1 M2) (MPair N1 N2)
+++++
apply AnaInc.
-----
Lemma analysis_is_analysis : forall h : hedge, is_analysis h (analysis_def h).
unfold is_analysis in |- *.
split.
unfold analysis_cond in |- *.
split.
unfold stable_analysis in |- *.
unfold inclusion in |- *.
unfold analysis_def in |- *.
intros.
induction H as [M N H| M1 M2 N1 N2 H HrecH| M1 M2 N1 N2 H HrecH| M N K L H HrecH H0].
elim HrecH.
intro n.
intro.
exists (S n).
apply (AnaSplitR (analysis_seq h n) M1 M2 N1 N2).
apply AnaInc.

*****
H0 : analysis_seq h n (MPair M1 M2) (MPair N1 N2)
n : nat
HrecH : ex (fun n : nat => analysis_seq h n (MPair M1 M2) (MPair N1 N2))
H : analysis (fun M N : Msg => ex (fun n : nat => analysis_seq h n M N))\n (MPair M1 M2) (MPair N1 N2)
M1,M2,N1,N2 : Msg
h : hedge
*****
analysis_seq h n (MPair M1 M2) (MPair N1 N2)
+++++
trivial.
-----
Lemma analysis_is_analysis : forall h : hedge, is_analysis h (analysis_def h).
unfold is_analysis in |- *.
split.
unfold analysis_cond in |- *.
split.
unfold stable_analysis in |- *.
unfold inclusion in |- *.
unfold analysis_def in |- *.
intros.
induction H as [M N H| M1 M2 N1 N2 H HrecH| M1 M2 N1 N2 H HrecH| M N K L H HrecH H0].

*****
HrecH : ex (fun n : nat => analysis_seq h n (MEnc M K) (MEnc N L))
H0 : synthesis (fun M N : Msg => ex (fun n : nat => analysis_seq h n M N))\n (inv K) (inv L)
H : analysis (fun M N : Msg => ex (fun n : nat => analysis_seq h n M N))\n (MEnc M K) (MEnc N L)
M,N,K,L : Msg
h : hedge
*****
ex (fun n : nat => analysis_seq h n M N)
+++++
elim HrecH.
-----
Lemma analysis_is_analysis : forall h : hedge, is_analysis h (analysis_def h).
unfold is_analysis in |- *.
split.
unfold analysis_cond in |- *.
split.
unfold stable_analysis in |- *.
unfold inclusion in |- *.
unfold analysis_def in |- *.
intros.
induction H as [M N H| M1 M2 N1 N2 H HrecH| M1 M2 N1 N2 H HrecH| M N K L H HrecH H0].
elim HrecH.

*****
HrecH : ex (fun n : nat => analysis_seq h n (MEnc M K) (MEnc N L))
H0 : synthesis (fun M N : Msg => ex (fun n : nat => analysis_seq h n M N))\n (inv K) (inv L)
H : analysis (fun M N : Msg => ex (fun n : nat => analysis_seq h n M N))\n (MEnc M K) (MEnc N L)
M,N,K,L : Msg
h : hedge
*****
forall (x : nat) (_ : analysis_seq h x (MEnc M K) (MEnc N L)), ex (fun n : nat => analysis_seq h n M N)
+++++
intro n1.
-----
Lemma analysis_is_analysis : forall h : hedge, is_analysis h (analysis_def h).
unfold is_analysis in |- *.
split.
unfold analysis_cond in |- *.
split.
unfold stable_analysis in |- *.
unfold inclusion in |- *.
unfold analysis_def in |- *.
intros.
induction H as [M N H| M1 M2 N1 N2 H HrecH| M1 M2 N1 N2 H HrecH| M N K L H HrecH H0].
elim HrecH.
intro n1.

*****
n1 : nat
HrecH : ex (fun n : nat => analysis_seq h n (MEnc M K) (MEnc N L))
H0 : synthesis (fun M N : Msg => ex (fun n : nat => analysis_seq h n M N))\n (inv K) (inv L)
H : analysis (fun M N : Msg => ex (fun n : nat => analysis_seq h n M N))\n (MEnc M K) (MEnc N L)
M,N,K,L : Msg
h : hedge
*****
forall _ : analysis_seq h n1 (MEnc M K) (MEnc N L), ex (fun n : nat => analysis_seq h n M N)
+++++
intro.
-----
Lemma analysis_is_analysis : forall h : hedge, is_analysis h (analysis_def h).
unfold is_analysis in |- *.
split.
unfold analysis_cond in |- *.
split.
unfold stable_analysis in |- *.
unfold inclusion in |- *.
unfold analysis_def in |- *.
intros.
induction H as [M N H| M1 M2 N1 N2 H HrecH| M1 M2 N1 N2 H HrecH| M N K L H HrecH H0].
elim HrecH.
intro n1.
intro.

*****
H1 : analysis_seq h n1 (MEnc M K) (MEnc N L)
n1 : nat
HrecH : ex (fun n : nat => analysis_seq h n (MEnc M K) (MEnc N L))
H0 : synthesis (fun M N : Msg => ex (fun n : nat => analysis_seq h n M N))\n (inv K) (inv L)
H : analysis (fun M N : Msg => ex (fun n : nat => analysis_seq h n M N))\n (MEnc M K) (MEnc N L)
M,N,K,L : Msg
h : hedge
*****
ex (fun n : nat => analysis_seq h n M N)
+++++
generalize (synthesis_analysis_seq h (inv K) (inv L) H0).
-----
Lemma analysis_is_analysis : forall h : hedge, is_analysis h (analysis_def h).
unfold is_analysis in |- *.
split.
unfold analysis_cond in |- *.
split.
unfold stable_analysis in |- *.
unfold inclusion in |- *.
unfold analysis_def in |- *.
intros.
induction H as [M N H| M1 M2 N1 N2 H HrecH| M1 M2 N1 N2 H HrecH| M N K L H HrecH H0].
elim HrecH.
intro n1.
intro.
generalize (synthesis_analysis_seq h (inv K) (inv L) H0).

*****
H1 : analysis_seq h n1 (MEnc M K) (MEnc N L)
n1 : nat
HrecH : ex (fun n : nat => analysis_seq h n (MEnc M K) (MEnc N L))
H0 : synthesis (fun M N : Msg => ex (fun n : nat => analysis_seq h n M N))\n (inv K) (inv L)
H : analysis (fun M N : Msg => ex (fun n : nat => analysis_seq h n M N))\n (MEnc M K) (MEnc N L)
M,N,K,L : Msg
h : hedge
*****
forall _ : ex (fun n : nat => synthesis (analysis_seq h n) (inv K) (inv L)), ex (fun n : nat => analysis_seq h n M N)
+++++
intro.
-----
Lemma analysis_is_analysis : forall h : hedge, is_analysis h (analysis_def h).
unfold is_analysis in |- *.
split.
unfold analysis_cond in |- *.
split.
unfold stable_analysis in |- *.
unfold inclusion in |- *.
unfold analysis_def in |- *.
intros.
induction H as [M N H| M1 M2 N1 N2 H HrecH| M1 M2 N1 N2 H HrecH| M N K L H HrecH H0].
elim HrecH.
intro n1.
intro.
generalize (synthesis_analysis_seq h (inv K) (inv L) H0).
intro.

*****
H2 : ex (fun n : nat => synthesis (analysis_seq h n) (inv K) (inv L))
H1 : analysis_seq h n1 (MEnc M K) (MEnc N L)
n1 : nat
HrecH : ex (fun n : nat => analysis_seq h n (MEnc M K) (MEnc N L))
H0 : synthesis (fun M N : Msg => ex (fun n : nat => analysis_seq h n M N))\n (inv K) (inv L)
H : analysis (fun M N : Msg => ex (fun n : nat => analysis_seq h n M N))\n (MEnc M K) (MEnc N L)
M,N,K,L : Msg
h : hedge
*****
ex (fun n : nat => analysis_seq h n M N)
+++++
elim H2.
-----
Lemma analysis_is_analysis : forall h : hedge, is_analysis h (analysis_def h).
unfold is_analysis in |- *.
split.
unfold analysis_cond in |- *.
split.
unfold stable_analysis in |- *.
unfold inclusion in |- *.
unfold analysis_def in |- *.
intros.
induction H as [M N H| M1 M2 N1 N2 H HrecH| M1 M2 N1 N2 H HrecH| M N K L H HrecH H0].
elim HrecH.
intro n1.
intro.
generalize (synthesis_analysis_seq h (inv K) (inv L) H0).
intro.
elim H2.

*****
H2 : ex (fun n : nat => synthesis (analysis_seq h n) (inv K) (inv L))
H1 : analysis_seq h n1 (MEnc M K) (MEnc N L)
n1 : nat
HrecH : ex (fun n : nat => analysis_seq h n (MEnc M K) (MEnc N L))
H0 : synthesis (fun M N : Msg => ex (fun n : nat => analysis_seq h n M N))\n (inv K) (inv L)
H : analysis (fun M N : Msg => ex (fun n : nat => analysis_seq h n M N))\n (MEnc M K) (MEnc N L)
M,N,K,L : Msg
h : hedge
*****
forall (x : nat) (_ : synthesis (analysis_seq h x) (inv K) (inv L)), ex (fun n : nat => analysis_seq h n M N)
+++++
intro n2.
-----
Lemma analysis_is_analysis : forall h : hedge, is_analysis h (analysis_def h).
unfold is_analysis in |- *.
split.
unfold analysis_cond in |- *.
split.
unfold stable_analysis in |- *.
unfold inclusion in |- *.
unfold analysis_def in |- *.
intros.
induction H as [M N H| M1 M2 N1 N2 H HrecH| M1 M2 N1 N2 H HrecH| M N K L H HrecH H0].
elim HrecH.
intro n1.
intro.
generalize (synthesis_analysis_seq h (inv K) (inv L) H0).
intro.
elim H2.
intro n2.

*****
n2 : nat
H2 : ex (fun n : nat => synthesis (analysis_seq h n) (inv K) (inv L))
H1 : analysis_seq h n1 (MEnc M K) (MEnc N L)
n1 : nat
HrecH : ex (fun n : nat => analysis_seq h n (MEnc M K) (MEnc N L))
H0 : synthesis (fun M N : Msg => ex (fun n : nat => analysis_seq h n M N))\n (inv K) (inv L)
H : analysis (fun M N : Msg => ex (fun n : nat => analysis_seq h n M N))\n (MEnc M K) (MEnc N L)
M,N,K,L : Msg
h : hedge
*****
forall _ : synthesis (analysis_seq h n2) (inv K) (inv L), ex (fun n : nat => analysis_seq h n M N)
+++++
intro.
-----
Lemma analysis_is_analysis : forall h : hedge, is_analysis h (analysis_def h).
unfold is_analysis in |- *.
split.
unfold analysis_cond in |- *.
split.
unfold stable_analysis in |- *.
unfold inclusion in |- *.
unfold analysis_def in |- *.
intros.
induction H as [M N H| M1 M2 N1 N2 H HrecH| M1 M2 N1 N2 H HrecH| M N K L H HrecH H0].
elim HrecH.
intro n1.
intro.
generalize (synthesis_analysis_seq h (inv K) (inv L) H0).
intro.
elim H2.
intro n2.
intro.

*****
H3 : synthesis (analysis_seq h n2) (inv K) (inv L)
n2 : nat
H2 : ex (fun n : nat => synthesis (analysis_seq h n) (inv K) (inv L))
H1 : analysis_seq h n1 (MEnc M K) (MEnc N L)
n1 : nat
HrecH : ex (fun n : nat => analysis_seq h n (MEnc M K) (MEnc N L))
H0 : synthesis (fun M N : Msg => ex (fun n : nat => analysis_seq h n M N))\n (inv K) (inv L)
H : analysis (fun M N : Msg => ex (fun n : nat => analysis_seq h n M N))\n (MEnc M K) (MEnc N L)
M,N,K,L : Msg
h : hedge
*****
ex (fun n : nat => analysis_seq h n M N)
+++++
exists (S (max n1 n2)).
-----
Lemma analysis_is_analysis : forall h : hedge, is_analysis h (analysis_def h).
unfold is_analysis in |- *.
split.
unfold analysis_cond in |- *.
split.
unfold stable_analysis in |- *.
unfold inclusion in |- *.
unfold analysis_def in |- *.
intros.
induction H as [M N H| M1 M2 N1 N2 H HrecH| M1 M2 N1 N2 H HrecH| M N K L H HrecH H0].
elim HrecH.
intro n1.
intro.
generalize (synthesis_analysis_seq h (inv K) (inv L) H0).
intro.
elim H2.
intro n2.
intro.
exists (S (max n1 n2)).

*****
H3 : synthesis (analysis_seq h n2) (inv K) (inv L)
n2 : nat
H2 : ex (fun n : nat => synthesis (analysis_seq h n) (inv K) (inv L))
H1 : analysis_seq h n1 (MEnc M K) (MEnc N L)
n1 : nat
HrecH : ex (fun n : nat => analysis_seq h n (MEnc M K) (MEnc N L))
H0 : synthesis (fun M N : Msg => ex (fun n : nat => analysis_seq h n M N))\n (inv K) (inv L)
H : analysis (fun M N : Msg => ex (fun n : nat => analysis_seq h n M N))\n (MEnc M K) (MEnc N L)
M,N,K,L : Msg
h : hedge
*****
analysis_seq h (S (Nat.max n1 n2)) M N
+++++
simpl in |- *.
-----
Lemma analysis_is_analysis : forall h : hedge, is_analysis h (analysis_def h).
unfold is_analysis in |- *.
split.
unfold analysis_cond in |- *.
split.
unfold stable_analysis in |- *.
unfold inclusion in |- *.
unfold analysis_def in |- *.
intros.
induction H as [M N H| M1 M2 N1 N2 H HrecH| M1 M2 N1 N2 H HrecH| M N K L H HrecH H0].
elim HrecH.
intro n1.
intro.
generalize (synthesis_analysis_seq h (inv K) (inv L) H0).
intro.
elim H2.
intro n2.
intro.
exists (S (max n1 n2)).
simpl in |- *.

*****
H3 : synthesis (analysis_seq h n2) (inv K) (inv L)
n2 : nat
H2 : ex (fun n : nat => synthesis (analysis_seq h n) (inv K) (inv L))
H1 : analysis_seq h n1 (MEnc M K) (MEnc N L)
n1 : nat
HrecH : ex (fun n : nat => analysis_seq h n (MEnc M K) (MEnc N L))
H0 : synthesis (fun M N : Msg => ex (fun n : nat => analysis_seq h n M N))\n (inv K) (inv L)
H : analysis (fun M N : Msg => ex (fun n : nat => analysis_seq h n M N))\n (MEnc M K) (MEnc N L)
M,N,K,L : Msg
h : hedge
*****
analysis (analysis_seq h (Nat.max n1 n2)) M N
+++++
apply (AnaDec (analysis_seq h (max n1 n2)) M N K L).
-----
Lemma analysis_is_analysis : forall h : hedge, is_analysis h (analysis_def h).
unfold is_analysis in |- *.
split.
unfold analysis_cond in |- *.
split.
unfold stable_analysis in |- *.
unfold inclusion in |- *.
unfold analysis_def in |- *.
intros.
induction H as [M N H| M1 M2 N1 N2 H HrecH| M1 M2 N1 N2 H HrecH| M N K L H HrecH H0].
elim HrecH.
intro n1.
intro.
generalize (synthesis_analysis_seq h (inv K) (inv L) H0).
intro.
elim H2.
intro n2.
intro.
exists (S (max n1 n2)).
simpl in |- *.
apply (AnaDec (analysis_seq h (max n1 n2)) M N K L).

*****
H3 : synthesis (analysis_seq h n2) (inv K) (inv L)
n2 : nat
H2 : ex (fun n : nat => synthesis (analysis_seq h n) (inv K) (inv L))
H1 : analysis_seq h n1 (MEnc M K) (MEnc N L)
n1 : nat
HrecH : ex (fun n : nat => analysis_seq h n (MEnc M K) (MEnc N L))
H0 : synthesis (fun M N : Msg => ex (fun n : nat => analysis_seq h n M N))\n (inv K) (inv L)
H : analysis (fun M N : Msg => ex (fun n : nat => analysis_seq h n M N))\n (MEnc M K) (MEnc N L)
M,N,K,L : Msg
h : hedge
*****
analysis (analysis_seq h (Nat.max n1 n2)) (MEnc M K) (MEnc N L)
+++++
apply AnaInc.
-----
Lemma analysis_is_analysis : forall h : hedge, is_analysis h (analysis_def h).
unfold is_analysis in |- *.
split.
unfold analysis_cond in |- *.
split.
unfold stable_analysis in |- *.
unfold inclusion in |- *.
unfold analysis_def in |- *.
intros.
induction H as [M N H| M1 M2 N1 N2 H HrecH| M1 M2 N1 N2 H HrecH| M N K L H HrecH H0].
elim HrecH.
intro n1.
intro.
generalize (synthesis_analysis_seq h (inv K) (inv L) H0).
intro.
elim H2.
intro n2.
intro.
exists (S (max n1 n2)).
simpl in |- *.
apply (AnaDec (analysis_seq h (max n1 n2)) M N K L).
apply AnaInc.

*****
H3 : synthesis (analysis_seq h n2) (inv K) (inv L)
n2 : nat
H2 : ex (fun n : nat => synthesis (analysis_seq h n) (inv K) (inv L))
H1 : analysis_seq h n1 (MEnc M K) (MEnc N L)
n1 : nat
HrecH : ex (fun n : nat => analysis_seq h n (MEnc M K) (MEnc N L))
H0 : synthesis (fun M N : Msg => ex (fun n : nat => analysis_seq h n M N))\n (inv K) (inv L)
H : analysis (fun M N : Msg => ex (fun n : nat => analysis_seq h n M N))\n (MEnc M K) (MEnc N L)
M,N,K,L : Msg
h : hedge
*****
analysis_seq h (Nat.max n1 n2) (MEnc M K) (MEnc N L)
+++++
generalize (analysis_seq_increase n1 (max n1 n2) h (le_max_l n1 n2)).
-----
Lemma analysis_is_analysis : forall h : hedge, is_analysis h (analysis_def h).
unfold is_analysis in |- *.
split.
unfold analysis_cond in |- *.
split.
unfold stable_analysis in |- *.
unfold inclusion in |- *.
unfold analysis_def in |- *.
intros.
induction H as [M N H| M1 M2 N1 N2 H HrecH| M1 M2 N1 N2 H HrecH| M N K L H HrecH H0].
elim HrecH.
intro n1.
intro.
generalize (synthesis_analysis_seq h (inv K) (inv L) H0).
intro.
elim H2.
intro n2.
intro.
exists (S (max n1 n2)).
simpl in |- *.
apply (AnaDec (analysis_seq h (max n1 n2)) M N K L).
apply AnaInc.
generalize (analysis_seq_increase n1 (max n1 n2) h (le_max_l n1 n2)).

*****
H3 : synthesis (analysis_seq h n2) (inv K) (inv L)
n2 : nat
H2 : ex (fun n : nat => synthesis (analysis_seq h n) (inv K) (inv L))
H1 : analysis_seq h n1 (MEnc M K) (MEnc N L)
n1 : nat
HrecH : ex (fun n : nat => analysis_seq h n (MEnc M K) (MEnc N L))
H0 : synthesis (fun M N : Msg => ex (fun n : nat => analysis_seq h n M N))\n (inv K) (inv L)
H : analysis (fun M N : Msg => ex (fun n : nat => analysis_seq h n M N))\n (MEnc M K) (MEnc N L)
M,N,K,L : Msg
h : hedge
*****
forall _ : inclusion (analysis_seq h n1) (analysis_seq h (Nat.max n1 n2)), analysis_seq h (Nat.max n1 n2) (MEnc M K) (MEnc N L)
+++++
unfold inclusion in |- *.
-----
Lemma analysis_is_analysis : forall h : hedge, is_analysis h (analysis_def h).
unfold is_analysis in |- *.
split.
unfold analysis_cond in |- *.
split.
unfold stable_analysis in |- *.
unfold inclusion in |- *.
unfold analysis_def in |- *.
intros.
induction H as [M N H| M1 M2 N1 N2 H HrecH| M1 M2 N1 N2 H HrecH| M N K L H HrecH H0].
elim HrecH.
intro n1.
intro.
generalize (synthesis_analysis_seq h (inv K) (inv L) H0).
intro.
elim H2.
intro n2.
intro.
exists (S (max n1 n2)).
simpl in |- *.
apply (AnaDec (analysis_seq h (max n1 n2)) M N K L).
apply AnaInc.
generalize (analysis_seq_increase n1 (max n1 n2) h (le_max_l n1 n2)).
unfold inclusion in |- *.

*****
H3 : synthesis (analysis_seq h n2) (inv K) (inv L)
n2 : nat
H2 : ex (fun n : nat => synthesis (analysis_seq h n) (inv K) (inv L))
H1 : analysis_seq h n1 (MEnc M K) (MEnc N L)
n1 : nat
HrecH : ex (fun n : nat => analysis_seq h n (MEnc M K) (MEnc N L))
H0 : synthesis (fun M N : Msg => ex (fun n : nat => analysis_seq h n M N))\n (inv K) (inv L)
H : analysis (fun M N : Msg => ex (fun n : nat => analysis_seq h n M N))\n (MEnc M K) (MEnc N L)
M,N,K,L : Msg
h : hedge
*****
forall _ : forall (M N : Msg) (_ : analysis_seq h n1 M N), analysis_seq h (Nat.max n1 n2) M N, analysis_seq h (Nat.max n1 n2) (MEnc M K) (MEnc N L)
+++++
auto.
-----
Lemma analysis_is_analysis : forall h : hedge, is_analysis h (analysis_def h).
unfold is_analysis in |- *.
split.
unfold analysis_cond in |- *.
split.
unfold stable_analysis in |- *.
unfold inclusion in |- *.
unfold analysis_def in |- *.
intros.
induction H as [M N H| M1 M2 N1 N2 H HrecH| M1 M2 N1 N2 H HrecH| M N K L H HrecH H0].
elim HrecH.
intro n1.
intro.
generalize (synthesis_analysis_seq h (inv K) (inv L) H0).
intro.
elim H2.
intro n2.
intro.
exists (S (max n1 n2)).
simpl in |- *.
apply (AnaDec (analysis_seq h (max n1 n2)) M N K L).

*****
H3 : synthesis (analysis_seq h n2) (inv K) (inv L)
n2 : nat
H2 : ex (fun n : nat => synthesis (analysis_seq h n) (inv K) (inv L))
H1 : analysis_seq h n1 (MEnc M K) (MEnc N L)
n1 : nat
HrecH : ex (fun n : nat => analysis_seq h n (MEnc M K) (MEnc N L))
H0 : synthesis (fun M N : Msg => ex (fun n : nat => analysis_seq h n M N))\n (inv K) (inv L)
H : analysis (fun M N : Msg => ex (fun n : nat => analysis_seq h n M N))\n (MEnc M K) (MEnc N L)
M,N,K,L : Msg
h : hedge
*****
synthesis (analysis_seq h (Nat.max n1 n2)) (inv K) (inv L)
+++++
generalize (inclusion_impl_le_h (analysis_seq h n2) (analysis_seq h (max n1 n2)) (analysis_seq_increase n2 (max n1 n2) h (le_max_r n1 n2))).
-----
Lemma analysis_is_analysis : forall h : hedge, is_analysis h (analysis_def h).
unfold is_analysis in |- *.
split.
unfold analysis_cond in |- *.
split.
unfold stable_analysis in |- *.
unfold inclusion in |- *.
unfold analysis_def in |- *.
intros.
induction H as [M N H| M1 M2 N1 N2 H HrecH| M1 M2 N1 N2 H HrecH| M N K L H HrecH H0].
elim HrecH.
intro n1.
intro.
generalize (synthesis_analysis_seq h (inv K) (inv L) H0).
intro.
elim H2.
intro n2.
intro.
exists (S (max n1 n2)).
simpl in |- *.
apply (AnaDec (analysis_seq h (max n1 n2)) M N K L).
generalize (inclusion_impl_le_h (analysis_seq h n2) (analysis_seq h (max n1 n2)) (analysis_seq_increase n2 (max n1 n2) h (le_max_r n1 n2))).

*****
H3 : synthesis (analysis_seq h n2) (inv K) (inv L)
n2 : nat
H2 : ex (fun n : nat => synthesis (analysis_seq h n) (inv K) (inv L))
H1 : analysis_seq h n1 (MEnc M K) (MEnc N L)
n1 : nat
HrecH : ex (fun n : nat => analysis_seq h n (MEnc M K) (MEnc N L))
H0 : synthesis (fun M N : Msg => ex (fun n : nat => analysis_seq h n M N))\n (inv K) (inv L)
H : analysis (fun M N : Msg => ex (fun n : nat => analysis_seq h n M N))\n (MEnc M K) (MEnc N L)
M,N,K,L : Msg
h : hedge
*****
forall _ : le_h (analysis_seq h n2) (analysis_seq h (Nat.max n1 n2)), synthesis (analysis_seq h (Nat.max n1 n2)) (inv K) (inv L)
+++++
unfold le_h in |- *.
-----
Lemma analysis_is_analysis : forall h : hedge, is_analysis h (analysis_def h).
unfold is_analysis in |- *.
split.
unfold analysis_cond in |- *.
split.
unfold stable_analysis in |- *.
unfold inclusion in |- *.
unfold analysis_def in |- *.
intros.
induction H as [M N H| M1 M2 N1 N2 H HrecH| M1 M2 N1 N2 H HrecH| M N K L H HrecH H0].
elim HrecH.
intro n1.
intro.
generalize (synthesis_analysis_seq h (inv K) (inv L) H0).
intro.
elim H2.
intro n2.
intro.
exists (S (max n1 n2)).
simpl in |- *.
apply (AnaDec (analysis_seq h (max n1 n2)) M N K L).
generalize (inclusion_impl_le_h (analysis_seq h n2) (analysis_seq h (max n1 n2)) (analysis_seq_increase n2 (max n1 n2) h (le_max_r n1 n2))).
unfold le_h in |- *.

*****
H3 : synthesis (analysis_seq h n2) (inv K) (inv L)
n2 : nat
H2 : ex (fun n : nat => synthesis (analysis_seq h n) (inv K) (inv L))
H1 : analysis_seq h n1 (MEnc M K) (MEnc N L)
n1 : nat
HrecH : ex (fun n : nat => analysis_seq h n (MEnc M K) (MEnc N L))
H0 : synthesis (fun M N : Msg => ex (fun n : nat => analysis_seq h n M N))\n (inv K) (inv L)
H : analysis (fun M N : Msg => ex (fun n : nat => analysis_seq h n M N))\n (MEnc M K) (MEnc N L)
M,N,K,L : Msg
h : hedge
*****
forall _ : inclusion (synthesis (analysis_seq h n2)) (synthesis (analysis_seq h (Nat.max n1 n2))), synthesis (analysis_seq h (Nat.max n1 n2)) (inv K) (inv L)
+++++
auto.
-----
Lemma analysis_is_analysis : forall h : hedge, is_analysis h (analysis_def h).
unfold is_analysis in |- *.
split.

*****
h : hedge
*****
forall (h' : hedge) (_ : analysis_cond h h'), inclusion (analysis_def h) h'
+++++
intros.
-----
Lemma analysis_is_analysis : forall h : hedge, is_analysis h (analysis_def h).
unfold is_analysis in |- *.
split.
intros.

*****
H : analysis_cond h h'
h,h' : hedge
*****
inclusion (analysis_def h) h'
+++++
unfold inclusion in |- *.
-----
Lemma analysis_is_analysis : forall h : hedge, is_analysis h (analysis_def h).
unfold is_analysis in |- *.
split.
intros.
unfold inclusion in |- *.

*****
H : analysis_cond h h'
h,h' : hedge
*****
forall (M N : Msg) (_ : analysis_def h M N), h' M N
+++++
unfold analysis_def in |- *.
-----
Lemma analysis_is_analysis : forall h : hedge, is_analysis h (analysis_def h).
unfold is_analysis in |- *.
split.
intros.
unfold inclusion in |- *.
unfold analysis_def in |- *.

*****
H : analysis_cond h h'
h,h' : hedge
*****
forall (M N : Msg) (_ : ex (fun n : nat => analysis_seq h n M N)), h' M N
+++++
intros.
-----
Lemma analysis_is_analysis : forall h : hedge, is_analysis h (analysis_def h).
unfold is_analysis in |- *.
split.
intros.
unfold inclusion in |- *.
unfold analysis_def in |- *.
intros.

*****
H0 : ex (fun n : nat => analysis_seq h n M N)
M,N : Msg
H : analysis_cond h h'
h,h' : hedge
*****
h' M N
+++++
elim H0.
-----
Lemma analysis_is_analysis : forall h : hedge, is_analysis h (analysis_def h).
unfold is_analysis in |- *.
split.
intros.
unfold inclusion in |- *.
unfold analysis_def in |- *.
intros.
elim H0.

*****
H0 : ex (fun n : nat => analysis_seq h n M N)
M,N : Msg
H : analysis_cond h h'
h,h' : hedge
*****
forall (x : nat) (_ : analysis_seq h x M N), h' M N
+++++
intro n.
-----
Lemma analysis_is_analysis : forall h : hedge, is_analysis h (analysis_def h).
unfold is_analysis in |- *.
split.
intros.
unfold inclusion in |- *.
unfold analysis_def in |- *.
intros.
elim H0.
intro n.

*****
n : nat
H0 : ex (fun n : nat => analysis_seq h n M N)
M,N : Msg
H : analysis_cond h h'
h,h' : hedge
*****
forall _ : analysis_seq h n M N, h' M N
+++++
intro.
-----
Lemma analysis_is_analysis : forall h : hedge, is_analysis h (analysis_def h).
unfold is_analysis in |- *.
split.
intros.
unfold inclusion in |- *.
unfold analysis_def in |- *.
intros.
elim H0.
intro n.
intro.

*****
H1 : analysis_seq h n M N
n : nat
H0 : ex (fun n : nat => analysis_seq h n M N)
M,N : Msg
H : analysis_cond h h'
h,h' : hedge
*****
h' M N
+++++
generalize (analysis_seq_incl_analysis_cond h h' H n).
-----
Lemma analysis_is_analysis : forall h : hedge, is_analysis h (analysis_def h).
unfold is_analysis in |- *.
split.
intros.
unfold inclusion in |- *.
unfold analysis_def in |- *.
intros.
elim H0.
intro n.
intro.
generalize (analysis_seq_incl_analysis_cond h h' H n).

*****
H1 : analysis_seq h n M N
n : nat
H0 : ex (fun n : nat => analysis_seq h n M N)
M,N : Msg
H : analysis_cond h h'
h,h' : hedge
*****
forall _ : inclusion (analysis_seq h n) h', h' M N
+++++
unfold inclusion in |- *.
-----
Lemma analysis_is_analysis : forall h : hedge, is_analysis h (analysis_def h).
unfold is_analysis in |- *.
split.
intros.
unfold inclusion in |- *.
unfold analysis_def in |- *.
intros.
elim H0.
intro n.
intro.
generalize (analysis_seq_incl_analysis_cond h h' H n).
unfold inclusion in |- *.

*****
H1 : analysis_seq h n M N
n : nat
H0 : ex (fun n : nat => analysis_seq h n M N)
M,N : Msg
H : analysis_cond h h'
h,h' : hedge
*****
forall _ : forall (M N : Msg) (_ : analysis_seq h n M N), h' M N, h' M N
+++++
auto.
-----
Lemma analysis_is_analysis : forall h : hedge, is_analysis h (analysis_def h).
unfold is_analysis in |- *.
split.

*****

*****

+++++
Qed.
-----
Definition irreducible (h : hedge) := reduce (analysis_def h).
-----
Lemma irreducible_enc :\n forall (h : hedge) (M N K L : Msg),\n irreducible h (MEnc M K) (MEnc N L) <->\n analysis_def h (MEnc M K) (MEnc N L) /\\n (~ synthesis (analysis_def h) M N \/ ~ synthesis (analysis_def h) K L).
-----
Lemma irreducible_enc : forall (h : hedge) (M N K L : Msg), irreducible h (MEnc M K) (MEnc N L) <-> analysis_def h (MEnc M K) (MEnc N L) /\\ (~ synthesis (analysis_def h) M N \\/ ~ synthesis (analysis_def h) K L).

*****

*****
forall (h : hedge) (M N K L : Msg), iff (irreducible h (MEnc M K) (MEnc N L)) (and (analysis_def h (MEnc M K) (MEnc N L)) (or (not (synthesis (analysis_def h) M N)) (not (synthesis (analysis_def h) K L))))
+++++
intros h M N K L.
-----
Lemma irreducible_enc : forall (h : hedge) (M N K L : Msg), irreducible h (MEnc M K) (MEnc N L) <-> analysis_def h (MEnc M K) (MEnc N L) /\\ (~ synthesis (analysis_def h) M N \\/ ~ synthesis (analysis_def h) K L).
intros h M N K L.

*****
M,N,K,L : Msg
h : hedge
*****
iff (irreducible h (MEnc M K) (MEnc N L)) (and (analysis_def h (MEnc M K) (MEnc N L)) (or (not (synthesis (analysis_def h) M N)) (not (synthesis (analysis_def h) K L))))
+++++
unfold irreducible in |- *.
-----
Lemma irreducible_enc : forall (h : hedge) (M N K L : Msg), irreducible h (MEnc M K) (MEnc N L) <-> analysis_def h (MEnc M K) (MEnc N L) /\\ (~ synthesis (analysis_def h) M N \\/ ~ synthesis (analysis_def h) K L).
intros h M N K L.
unfold irreducible in |- *.

*****
M,N,K,L : Msg
h : hedge
*****
iff (reduce (analysis_def h) (MEnc M K) (MEnc N L)) (and (analysis_def h (MEnc M K) (MEnc N L)) (or (not (synthesis (analysis_def h) M N)) (not (synthesis (analysis_def h) K L))))
+++++
unfold reduce in |- *.
-----
Lemma irreducible_enc : forall (h : hedge) (M N K L : Msg), irreducible h (MEnc M K) (MEnc N L) <-> analysis_def h (MEnc M K) (MEnc N L) /\\ (~ synthesis (analysis_def h) M N \\/ ~ synthesis (analysis_def h) K L).
intros h M N K L.
unfold irreducible in |- *.
unfold reduce in |- *.

*****
M,N,K,L : Msg
h : hedge
*****
iff (and (analysis_def h (MEnc M K) (MEnc N L)) (or (not (synthesis (analysis_def h) M N)) (not (synthesis (analysis_def h) K L)))) (and (analysis_def h (MEnc M K) (MEnc N L)) (or (not (synthesis (analysis_def h) M N)) (not (synthesis (analysis_def h) K L))))
+++++
tauto.
-----
Lemma irreducible_enc : forall (h : hedge) (M N K L : Msg), irreducible h (MEnc M K) (MEnc N L) <-> analysis_def h (MEnc M K) (MEnc N L) /\\ (~ synthesis (analysis_def h) M N \\/ ~ synthesis (analysis_def h) K L).
intros h M N K L.
unfold irreducible in |- *.
unfold reduce in |- *.
tauto.

*****

*****

+++++
Qed.
-----
Lemma irreducible_op :\n forall (h : hedge) (oM oN : op) (M N : Msg),\n irreducible h (Mop oM M) (Mop oN N) <->\n analysis_def h (Mop oM M) (Mop oN N) /\\n (oM <> oN \/ ~ synthesis (analysis_def h) M N).
-----
Lemma irreducible_op : forall (h : hedge) (oM oN : op) (M N : Msg), irreducible h (Mop oM M) (Mop oN N) <-> analysis_def h (Mop oM M) (Mop oN N) /\\ (oM <> oN \\/ ~ synthesis (analysis_def h) M N).

*****

*****
forall (h : hedge) (oM oN : op) (M N : Msg), iff (irreducible h (Mop oM M) (Mop oN N)) (and (analysis_def h (Mop oM M) (Mop oN N)) (or (not (eq oM oN)) (not (synthesis (analysis_def h) M N))))
+++++
unfold irreducible in |- *.
-----
Lemma irreducible_op : forall (h : hedge) (oM oN : op) (M N : Msg), irreducible h (Mop oM M) (Mop oN N) <-> analysis_def h (Mop oM M) (Mop oN N) /\\ (oM <> oN \\/ ~ synthesis (analysis_def h) M N).
unfold irreducible in |- *.

*****

*****
forall (h : hedge) (oM oN : op) (M N : Msg), iff (reduce (analysis_def h) (Mop oM M) (Mop oN N)) (and (analysis_def h (Mop oM M) (Mop oN N)) (or (not (eq oM oN)) (not (synthesis (analysis_def h) M N))))
+++++
unfold reduce in |- *.
-----
Lemma irreducible_op : forall (h : hedge) (oM oN : op) (M N : Msg), irreducible h (Mop oM M) (Mop oN N) <-> analysis_def h (Mop oM M) (Mop oN N) /\\ (oM <> oN \\/ ~ synthesis (analysis_def h) M N).
unfold irreducible in |- *.
unfold reduce in |- *.

*****

*****
forall (h : hedge) (oM oN : op) (M N : Msg), iff (and (analysis_def h (Mop oM M) (Mop oN N)) (or (not (eq oM oN)) (not (synthesis (analysis_def h) M N)))) (and (analysis_def h (Mop oM M) (Mop oN N)) (or (not (eq oM oN)) (not (synthesis (analysis_def h) M N))))
+++++
tauto.
-----
Lemma irreducible_op : forall (h : hedge) (oM oN : op) (M N : Msg), irreducible h (Mop oM M) (Mop oN N) <-> analysis_def h (Mop oM M) (Mop oN N) /\\ (oM <> oN \\/ ~ synthesis (analysis_def h) M N).
unfold irreducible in |- *.
unfold reduce in |- *.
tauto.

*****

*****

+++++
Qed.
-----
Lemma irreducible_pair :\n forall (h : hedge) (M1 N1 M2 N2 : Msg),\n ~ irreducible h (MPair M1 M2) (MPair N1 N2).
-----
Lemma irreducible_pair : forall (h : hedge) (M1 N1 M2 N2 : Msg), ~ irreducible h (MPair M1 M2) (MPair N1 N2).

*****

*****
forall (h : hedge) (M1 N1 M2 N2 : Msg), not (irreducible h (MPair M1 M2) (MPair N1 N2))
+++++
unfold irreducible in |- *.
-----
Lemma irreducible_pair : forall (h : hedge) (M1 N1 M2 N2 : Msg), ~ irreducible h (MPair M1 M2) (MPair N1 N2).
unfold irreducible in |- *.

*****

*****
forall (h : hedge) (M1 N1 M2 N2 : Msg), not (reduce (analysis_def h) (MPair M1 M2) (MPair N1 N2))
+++++
unfold reduce in |- *.
-----
Lemma irreducible_pair : forall (h : hedge) (M1 N1 M2 N2 : Msg), ~ irreducible h (MPair M1 M2) (MPair N1 N2).
unfold irreducible in |- *.
unfold reduce in |- *.

*****

*****
forall (h : hedge) (M1 N1 M2 N2 : Msg), not (and (analysis_def h (MPair M1 M2) (MPair N1 N2)) (or (not (synthesis (analysis_def h) M1 N1)) (not (synthesis (analysis_def h) M2 N2))))
+++++
intros.
-----
Lemma irreducible_pair : forall (h : hedge) (M1 N1 M2 N2 : Msg), ~ irreducible h (MPair M1 M2) (MPair N1 N2).
unfold irreducible in |- *.
unfold reduce in |- *.
intros.

*****
M1,N1,M2,N2 : Msg
h : hedge
*****
not (and (analysis_def h (MPair M1 M2) (MPair N1 N2)) (or (not (synthesis (analysis_def h) M1 N1)) (not (synthesis (analysis_def h) M2 N2))))
+++++
red in |- *.
-----
Lemma irreducible_pair : forall (h : hedge) (M1 N1 M2 N2 : Msg), ~ irreducible h (MPair M1 M2) (MPair N1 N2).
unfold irreducible in |- *.
unfold reduce in |- *.
intros.
red in |- *.

*****
M1,N1,M2,N2 : Msg
h : hedge
*****
forall _ : and (analysis_def h (MPair M1 M2) (MPair N1 N2)) (or (not (synthesis (analysis_def h) M1 N1)) (not (synthesis (analysis_def h) M2 N2))), False
+++++
intro.
-----
Lemma irreducible_pair : forall (h : hedge) (M1 N1 M2 N2 : Msg), ~ irreducible h (MPair M1 M2) (MPair N1 N2).
unfold irreducible in |- *.
unfold reduce in |- *.
intros.
red in |- *.
intro.

*****
H : and (analysis_def h (MPair M1 M2) (MPair N1 N2))\n (or (not (synthesis (analysis_def h) M1 N1))\n (not (synthesis (analysis_def h) M2 N2)))
M1,N1,M2,N2 : Msg
h : hedge
*****
False
+++++
elim H.
-----
Lemma irreducible_pair : forall (h : hedge) (M1 N1 M2 N2 : Msg), ~ irreducible h (MPair M1 M2) (MPair N1 N2).
unfold irreducible in |- *.
unfold reduce in |- *.
intros.
red in |- *.
intro.
elim H.

*****
H : and (analysis_def h (MPair M1 M2) (MPair N1 N2))\n (or (not (synthesis (analysis_def h) M1 N1))\n (not (synthesis (analysis_def h) M2 N2)))
M1,N1,M2,N2 : Msg
h : hedge
*****
forall (_ : analysis_def h (MPair M1 M2) (MPair N1 N2)) (_ : or (not (synthesis (analysis_def h) M1 N1)) (not (synthesis (analysis_def h) M2 N2))), False
+++++
intro.
-----
Lemma irreducible_pair : forall (h : hedge) (M1 N1 M2 N2 : Msg), ~ irreducible h (MPair M1 M2) (MPair N1 N2).
unfold irreducible in |- *.
unfold reduce in |- *.
intros.
red in |- *.
intro.
elim H.
intro.

*****
H0 : analysis_def h (MPair M1 M2) (MPair N1 N2)
H : and (analysis_def h (MPair M1 M2) (MPair N1 N2))\n (or (not (synthesis (analysis_def h) M1 N1))\n (not (synthesis (analysis_def h) M2 N2)))
M1,N1,M2,N2 : Msg
h : hedge
*****
forall _ : or (not (synthesis (analysis_def h) M1 N1)) (not (synthesis (analysis_def h) M2 N2)), False
+++++
intro.
-----
Lemma irreducible_pair : forall (h : hedge) (M1 N1 M2 N2 : Msg), ~ irreducible h (MPair M1 M2) (MPair N1 N2).
unfold irreducible in |- *.
unfold reduce in |- *.
intros.
red in |- *.
intro.
elim H.
intro.
intro.

*****
H1 : or (not (synthesis (analysis_def h) M1 N1))\n (not (synthesis (analysis_def h) M2 N2))
H0 : analysis_def h (MPair M1 M2) (MPair N1 N2)
H : and (analysis_def h (MPair M1 M2) (MPair N1 N2))\n (or (not (synthesis (analysis_def h) M1 N1))\n (not (synthesis (analysis_def h) M2 N2)))
M1,N1,M2,N2 : Msg
h : hedge
*****
False
+++++
cut (analysis_def h M1 N1 /\ analysis_def h M2 N2).
-----
Lemma irreducible_pair : forall (h : hedge) (M1 N1 M2 N2 : Msg), ~ irreducible h (MPair M1 M2) (MPair N1 N2).
unfold irreducible in |- *.
unfold reduce in |- *.
intros.
red in |- *.
intro.
elim H.
intro.
intro.
cut (analysis_def h M1 N1 /\\ analysis_def h M2 N2).

*****
H1 : or (not (synthesis (analysis_def h) M1 N1))\n (not (synthesis (analysis_def h) M2 N2))
H0 : analysis_def h (MPair M1 M2) (MPair N1 N2)
H : and (analysis_def h (MPair M1 M2) (MPair N1 N2))\n (or (not (synthesis (analysis_def h) M1 N1))\n (not (synthesis (analysis_def h) M2 N2)))
M1,N1,M2,N2 : Msg
h : hedge
*****
forall _ : and (analysis_def h M1 N1) (analysis_def h M2 N2), False
+++++
intro.
-----
Lemma irreducible_pair : forall (h : hedge) (M1 N1 M2 N2 : Msg), ~ irreducible h (MPair M1 M2) (MPair N1 N2).
unfold irreducible in |- *.
unfold reduce in |- *.
intros.
red in |- *.
intro.
elim H.
intro.
intro.
cut (analysis_def h M1 N1 /\\ analysis_def h M2 N2).
intro.

*****
H2 : and (analysis_def h M1 N1) (analysis_def h M2 N2)
H1 : or (not (synthesis (analysis_def h) M1 N1))\n (not (synthesis (analysis_def h) M2 N2))
H0 : analysis_def h (MPair M1 M2) (MPair N1 N2)
H : and (analysis_def h (MPair M1 M2) (MPair N1 N2))\n (or (not (synthesis (analysis_def h) M1 N1))\n (not (synthesis (analysis_def h) M2 N2)))
M1,N1,M2,N2 : Msg
h : hedge
*****
False
+++++
elim H2.
-----
Lemma irreducible_pair : forall (h : hedge) (M1 N1 M2 N2 : Msg), ~ irreducible h (MPair M1 M2) (MPair N1 N2).
unfold irreducible in |- *.
unfold reduce in |- *.
intros.
red in |- *.
intro.
elim H.
intro.
intro.
cut (analysis_def h M1 N1 /\\ analysis_def h M2 N2).
intro.
elim H2.

*****
H2 : and (analysis_def h M1 N1) (analysis_def h M2 N2)
H1 : or (not (synthesis (analysis_def h) M1 N1))\n (not (synthesis (analysis_def h) M2 N2))
H0 : analysis_def h (MPair M1 M2) (MPair N1 N2)
H : and (analysis_def h (MPair M1 M2) (MPair N1 N2))\n (or (not (synthesis (analysis_def h) M1 N1))\n (not (synthesis (analysis_def h) M2 N2)))
M1,N1,M2,N2 : Msg
h : hedge
*****
forall (_ : analysis_def h M1 N1) (_ : analysis_def h M2 N2), False
+++++
intros.
-----
Lemma irreducible_pair : forall (h : hedge) (M1 N1 M2 N2 : Msg), ~ irreducible h (MPair M1 M2) (MPair N1 N2).
unfold irreducible in |- *.
unfold reduce in |- *.
intros.
red in |- *.
intro.
elim H.
intro.
intro.
cut (analysis_def h M1 N1 /\\ analysis_def h M2 N2).
intro.
elim H2.
intros.

*****
H4 : analysis_def h M2 N2
H3 : analysis_def h M1 N1
H2 : and (analysis_def h M1 N1) (analysis_def h M2 N2)
H1 : or (not (synthesis (analysis_def h) M1 N1))\n (not (synthesis (analysis_def h) M2 N2))
H0 : analysis_def h (MPair M1 M2) (MPair N1 N2)
H : and (analysis_def h (MPair M1 M2) (MPair N1 N2))\n (or (not (synthesis (analysis_def h) M1 N1))\n (not (synthesis (analysis_def h) M2 N2)))
M1,N1,M2,N2 : Msg
h : hedge
*****
False
+++++
case H1.
-----
Lemma irreducible_pair : forall (h : hedge) (M1 N1 M2 N2 : Msg), ~ irreducible h (MPair M1 M2) (MPair N1 N2).
unfold irreducible in |- *.
unfold reduce in |- *.
intros.
red in |- *.
intro.
elim H.
intro.
intro.
cut (analysis_def h M1 N1 /\\ analysis_def h M2 N2).
intro.
elim H2.
intros.
case H1.

*****
H4 : analysis_def h M2 N2
H3 : analysis_def h M1 N1
H2 : and (analysis_def h M1 N1) (analysis_def h M2 N2)
H1 : or (not (synthesis (analysis_def h) M1 N1))\n (not (synthesis (analysis_def h) M2 N2))
H0 : analysis_def h (MPair M1 M2) (MPair N1 N2)
H : and (analysis_def h (MPair M1 M2) (MPair N1 N2))\n (or (not (synthesis (analysis_def h) M1 N1))\n (not (synthesis (analysis_def h) M2 N2)))
M1,N1,M2,N2 : Msg
h : hedge
*****
forall _ : not (synthesis (analysis_def h) M1 N1), False
+++++
intro H5.
-----
Lemma irreducible_pair : forall (h : hedge) (M1 N1 M2 N2 : Msg), ~ irreducible h (MPair M1 M2) (MPair N1 N2).
unfold irreducible in |- *.
unfold reduce in |- *.
intros.
red in |- *.
intro.
elim H.
intro.
intro.
cut (analysis_def h M1 N1 /\\ analysis_def h M2 N2).
intro.
elim H2.
intros.
case H1.
intro H5.

*****
H5 : not (synthesis (analysis_def h) M1 N1)
H4 : analysis_def h M2 N2
H3 : analysis_def h M1 N1
H2 : and (analysis_def h M1 N1) (analysis_def h M2 N2)
H1 : or (not (synthesis (analysis_def h) M1 N1))\n (not (synthesis (analysis_def h) M2 N2))
H0 : analysis_def h (MPair M1 M2) (MPair N1 N2)
H : and (analysis_def h (MPair M1 M2) (MPair N1 N2))\n (or (not (synthesis (analysis_def h) M1 N1))\n (not (synthesis (analysis_def h) M2 N2)))
M1,N1,M2,N2 : Msg
h : hedge
*****
False
+++++
apply H5.
-----
Lemma irreducible_pair : forall (h : hedge) (M1 N1 M2 N2 : Msg), ~ irreducible h (MPair M1 M2) (MPair N1 N2).
unfold irreducible in |- *.
unfold reduce in |- *.
intros.
red in |- *.
intro.
elim H.
intro.
intro.
cut (analysis_def h M1 N1 /\\ analysis_def h M2 N2).
intro.
elim H2.
intros.
case H1.
intro H5.
apply H5.

*****
H5 : not (synthesis (analysis_def h) M1 N1)
H4 : analysis_def h M2 N2
H3 : analysis_def h M1 N1
H2 : and (analysis_def h M1 N1) (analysis_def h M2 N2)
H1 : or (not (synthesis (analysis_def h) M1 N1))\n (not (synthesis (analysis_def h) M2 N2))
H0 : analysis_def h (MPair M1 M2) (MPair N1 N2)
H : and (analysis_def h (MPair M1 M2) (MPair N1 N2))\n (or (not (synthesis (analysis_def h) M1 N1))\n (not (synthesis (analysis_def h) M2 N2)))
M1,N1,M2,N2 : Msg
h : hedge
*****
synthesis (analysis_def h) M1 N1
+++++
trivial.
-----
Lemma irreducible_pair : forall (h : hedge) (M1 N1 M2 N2 : Msg), ~ irreducible h (MPair M1 M2) (MPair N1 N2).
unfold irreducible in |- *.
unfold reduce in |- *.
intros.
red in |- *.
intro.
elim H.
intro.
intro.
cut (analysis_def h M1 N1 /\\ analysis_def h M2 N2).
intro.
elim H2.
intros.
case H1.
intro H5.
apply H5.
trivial.

*****
H5 : not (synthesis (analysis_def h) M1 N1)
H4 : analysis_def h M2 N2
H3 : analysis_def h M1 N1
H2 : and (analysis_def h M1 N1) (analysis_def h M2 N2)
H1 : or (not (synthesis (analysis_def h) M1 N1))\n (not (synthesis (analysis_def h) M2 N2))
H0 : analysis_def h (MPair M1 M2) (MPair N1 N2)
H : and (analysis_def h (MPair M1 M2) (MPair N1 N2))\n (or (not (synthesis (analysis_def h) M1 N1))\n (not (synthesis (analysis_def h) M2 N2)))
M1,N1,M2,N2 : Msg
h : hedge
*****
synthesis (analysis_def h) M1 N1
+++++
apply SynInc.
-----
Lemma irreducible_pair : forall (h : hedge) (M1 N1 M2 N2 : Msg), ~ irreducible h (MPair M1 M2) (MPair N1 N2).
unfold irreducible in |- *.
unfold reduce in |- *.
intros.
red in |- *.
intro.
elim H.
intro.
intro.
cut (analysis_def h M1 N1 /\\ analysis_def h M2 N2).
intro.
elim H2.
intros.
case H1.
intro H5.
apply H5.
trivial.
apply SynInc.

*****
H5 : not (synthesis (analysis_def h) M1 N1)
H4 : analysis_def h M2 N2
H3 : analysis_def h M1 N1
H2 : and (analysis_def h M1 N1) (analysis_def h M2 N2)
H1 : or (not (synthesis (analysis_def h) M1 N1))\n (not (synthesis (analysis_def h) M2 N2))
H0 : analysis_def h (MPair M1 M2) (MPair N1 N2)
H : and (analysis_def h (MPair M1 M2) (MPair N1 N2))\n (or (not (synthesis (analysis_def h) M1 N1))\n (not (synthesis (analysis_def h) M2 N2)))
M1,N1,M2,N2 : Msg
h : hedge
*****
analysis_def h M1 N1
+++++
trivial.
-----
Lemma irreducible_pair : forall (h : hedge) (M1 N1 M2 N2 : Msg), ~ irreducible h (MPair M1 M2) (MPair N1 N2).
unfold irreducible in |- *.
unfold reduce in |- *.
intros.
red in |- *.
intro.
elim H.
intro.
intro.
cut (analysis_def h M1 N1 /\\ analysis_def h M2 N2).
intro.
elim H2.
intros.
case H1.

*****
H4 : analysis_def h M2 N2
H3 : analysis_def h M1 N1
H2 : and (analysis_def h M1 N1) (analysis_def h M2 N2)
H1 : or (not (synthesis (analysis_def h) M1 N1))\n (not (synthesis (analysis_def h) M2 N2))
H0 : analysis_def h (MPair M1 M2) (MPair N1 N2)
H : and (analysis_def h (MPair M1 M2) (MPair N1 N2))\n (or (not (synthesis (analysis_def h) M1 N1))\n (not (synthesis (analysis_def h) M2 N2)))
M1,N1,M2,N2 : Msg
h : hedge
*****
forall _ : not (synthesis (analysis_def h) M2 N2), False
+++++
intro H5.
-----
Lemma irreducible_pair : forall (h : hedge) (M1 N1 M2 N2 : Msg), ~ irreducible h (MPair M1 M2) (MPair N1 N2).
unfold irreducible in |- *.
unfold reduce in |- *.
intros.
red in |- *.
intro.
elim H.
intro.
intro.
cut (analysis_def h M1 N1 /\\ analysis_def h M2 N2).
intro.
elim H2.
intros.
case H1.
intro H5.

*****
H5 : not (synthesis (analysis_def h) M2 N2)
H4 : analysis_def h M2 N2
H3 : analysis_def h M1 N1
H2 : and (analysis_def h M1 N1) (analysis_def h M2 N2)
H1 : or (not (synthesis (analysis_def h) M1 N1))\n (not (synthesis (analysis_def h) M2 N2))
H0 : analysis_def h (MPair M1 M2) (MPair N1 N2)
H : and (analysis_def h (MPair M1 M2) (MPair N1 N2))\n (or (not (synthesis (analysis_def h) M1 N1))\n (not (synthesis (analysis_def h) M2 N2)))
M1,N1,M2,N2 : Msg
h : hedge
*****
False
+++++
apply H5.
-----
Lemma irreducible_pair : forall (h : hedge) (M1 N1 M2 N2 : Msg), ~ irreducible h (MPair M1 M2) (MPair N1 N2).
unfold irreducible in |- *.
unfold reduce in |- *.
intros.
red in |- *.
intro.
elim H.
intro.
intro.
cut (analysis_def h M1 N1 /\\ analysis_def h M2 N2).
intro.
elim H2.
intros.
case H1.
intro H5.
apply H5.

*****
H5 : not (synthesis (analysis_def h) M2 N2)
H4 : analysis_def h M2 N2
H3 : analysis_def h M1 N1
H2 : and (analysis_def h M1 N1) (analysis_def h M2 N2)
H1 : or (not (synthesis (analysis_def h) M1 N1))\n (not (synthesis (analysis_def h) M2 N2))
H0 : analysis_def h (MPair M1 M2) (MPair N1 N2)
H : and (analysis_def h (MPair M1 M2) (MPair N1 N2))\n (or (not (synthesis (analysis_def h) M1 N1))\n (not (synthesis (analysis_def h) M2 N2)))
M1,N1,M2,N2 : Msg
h : hedge
*****
synthesis (analysis_def h) M2 N2
+++++
trivial.
-----
Lemma irreducible_pair : forall (h : hedge) (M1 N1 M2 N2 : Msg), ~ irreducible h (MPair M1 M2) (MPair N1 N2).
unfold irreducible in |- *.
unfold reduce in |- *.
intros.
red in |- *.
intro.
elim H.
intro.
intro.
cut (analysis_def h M1 N1 /\\ analysis_def h M2 N2).
intro.
elim H2.
intros.
case H1.
intro H5.
apply H5.
trivial.

*****
H5 : not (synthesis (analysis_def h) M2 N2)
H4 : analysis_def h M2 N2
H3 : analysis_def h M1 N1
H2 : and (analysis_def h M1 N1) (analysis_def h M2 N2)
H1 : or (not (synthesis (analysis_def h) M1 N1))\n (not (synthesis (analysis_def h) M2 N2))
H0 : analysis_def h (MPair M1 M2) (MPair N1 N2)
H : and (analysis_def h (MPair M1 M2) (MPair N1 N2))\n (or (not (synthesis (analysis_def h) M1 N1))\n (not (synthesis (analysis_def h) M2 N2)))
M1,N1,M2,N2 : Msg
h : hedge
*****
synthesis (analysis_def h) M2 N2
+++++
apply SynInc.
-----
Lemma irreducible_pair : forall (h : hedge) (M1 N1 M2 N2 : Msg), ~ irreducible h (MPair M1 M2) (MPair N1 N2).
unfold irreducible in |- *.
unfold reduce in |- *.
intros.
red in |- *.
intro.
elim H.
intro.
intro.
cut (analysis_def h M1 N1 /\\ analysis_def h M2 N2).
intro.
elim H2.
intros.
case H1.
intro H5.
apply H5.
trivial.
apply SynInc.

*****
H5 : not (synthesis (analysis_def h) M2 N2)
H4 : analysis_def h M2 N2
H3 : analysis_def h M1 N1
H2 : and (analysis_def h M1 N1) (analysis_def h M2 N2)
H1 : or (not (synthesis (analysis_def h) M1 N1))\n (not (synthesis (analysis_def h) M2 N2))
H0 : analysis_def h (MPair M1 M2) (MPair N1 N2)
H : and (analysis_def h (MPair M1 M2) (MPair N1 N2))\n (or (not (synthesis (analysis_def h) M1 N1))\n (not (synthesis (analysis_def h) M2 N2)))
M1,N1,M2,N2 : Msg
h : hedge
*****
analysis_def h M2 N2
+++++
trivial.
-----
Lemma irreducible_pair : forall (h : hedge) (M1 N1 M2 N2 : Msg), ~ irreducible h (MPair M1 M2) (MPair N1 N2).
unfold irreducible in |- *.
unfold reduce in |- *.
intros.
red in |- *.
intro.
elim H.
intro.
intro.
cut (analysis_def h M1 N1 /\\ analysis_def h M2 N2).

*****
H1 : or (not (synthesis (analysis_def h) M1 N1))\n (not (synthesis (analysis_def h) M2 N2))
H0 : analysis_def h (MPair M1 M2) (MPair N1 N2)
H : and (analysis_def h (MPair M1 M2) (MPair N1 N2))\n (or (not (synthesis (analysis_def h) M1 N1))\n (not (synthesis (analysis_def h) M2 N2)))
M1,N1,M2,N2 : Msg
h : hedge
*****
and (analysis_def h M1 N1) (analysis_def h M2 N2)
+++++
cut (is_analysis h (analysis_def h)).
-----
Lemma irreducible_pair : forall (h : hedge) (M1 N1 M2 N2 : Msg), ~ irreducible h (MPair M1 M2) (MPair N1 N2).
unfold irreducible in |- *.
unfold reduce in |- *.
intros.
red in |- *.
intro.
elim H.
intro.
intro.
cut (analysis_def h M1 N1 /\\ analysis_def h M2 N2).
cut (is_analysis h (analysis_def h)).

*****
H1 : or (not (synthesis (analysis_def h) M1 N1))\n (not (synthesis (analysis_def h) M2 N2))
H0 : analysis_def h (MPair M1 M2) (MPair N1 N2)
H : and (analysis_def h (MPair M1 M2) (MPair N1 N2))\n (or (not (synthesis (analysis_def h) M1 N1))\n (not (synthesis (analysis_def h) M2 N2)))
M1,N1,M2,N2 : Msg
h : hedge
*****
forall _ : is_analysis h (analysis_def h), and (analysis_def h M1 N1) (analysis_def h M2 N2)
+++++
try apply analysis_is_analysis.
-----
Lemma irreducible_pair : forall (h : hedge) (M1 N1 M2 N2 : Msg), ~ irreducible h (MPair M1 M2) (MPair N1 N2).
unfold irreducible in |- *.
unfold reduce in |- *.
intros.
red in |- *.
intro.
elim H.
intro.
intro.
cut (analysis_def h M1 N1 /\\ analysis_def h M2 N2).
cut (is_analysis h (analysis_def h)).
try apply analysis_is_analysis.

*****
H1 : or (not (synthesis (analysis_def h) M1 N1))\n (not (synthesis (analysis_def h) M2 N2))
H0 : analysis_def h (MPair M1 M2) (MPair N1 N2)
H : and (analysis_def h (MPair M1 M2) (MPair N1 N2))\n (or (not (synthesis (analysis_def h) M1 N1))\n (not (synthesis (analysis_def h) M2 N2)))
M1,N1,M2,N2 : Msg
h : hedge
*****
forall _ : is_analysis h (analysis_def h), and (analysis_def h M1 N1) (analysis_def h M2 N2)
+++++
unfold is_analysis in |- *.
-----
Lemma irreducible_pair : forall (h : hedge) (M1 N1 M2 N2 : Msg), ~ irreducible h (MPair M1 M2) (MPair N1 N2).
unfold irreducible in |- *.
unfold reduce in |- *.
intros.
red in |- *.
intro.
elim H.
intro.
intro.
cut (analysis_def h M1 N1 /\\ analysis_def h M2 N2).
cut (is_analysis h (analysis_def h)).
try apply analysis_is_analysis.
unfold is_analysis in |- *.

*****
H1 : or (not (synthesis (analysis_def h) M1 N1))\n (not (synthesis (analysis_def h) M2 N2))
H0 : analysis_def h (MPair M1 M2) (MPair N1 N2)
H : and (analysis_def h (MPair M1 M2) (MPair N1 N2))\n (or (not (synthesis (analysis_def h) M1 N1))\n (not (synthesis (analysis_def h) M2 N2)))
M1,N1,M2,N2 : Msg
h : hedge
*****
forall _ : and (analysis_cond h (analysis_def h)) (forall (h' : hedge) (_ : analysis_cond h h'), inclusion (analysis_def h) h'), and (analysis_def h M1 N1) (analysis_def h M2 N2)
+++++
intros.
-----
Lemma irreducible_pair : forall (h : hedge) (M1 N1 M2 N2 : Msg), ~ irreducible h (MPair M1 M2) (MPair N1 N2).
unfold irreducible in |- *.
unfold reduce in |- *.
intros.
red in |- *.
intro.
elim H.
intro.
intro.
cut (analysis_def h M1 N1 /\\ analysis_def h M2 N2).
cut (is_analysis h (analysis_def h)).
try apply analysis_is_analysis.
unfold is_analysis in |- *.
intros.

*****
H2 : and (analysis_cond h (analysis_def h))\n (forall (h' : hedge) (_ : analysis_cond h h'),\n inclusion (analysis_def h) h')
H1 : or (not (synthesis (analysis_def h) M1 N1))\n (not (synthesis (analysis_def h) M2 N2))
H0 : analysis_def h (MPair M1 M2) (MPair N1 N2)
H : and (analysis_def h (MPair M1 M2) (MPair N1 N2))\n (or (not (synthesis (analysis_def h) M1 N1))\n (not (synthesis (analysis_def h) M2 N2)))
M1,N1,M2,N2 : Msg
h : hedge
*****
and (analysis_def h M1 N1) (analysis_def h M2 N2)
+++++
elim H2.
-----
Lemma irreducible_pair : forall (h : hedge) (M1 N1 M2 N2 : Msg), ~ irreducible h (MPair M1 M2) (MPair N1 N2).
unfold irreducible in |- *.
unfold reduce in |- *.
intros.
red in |- *.
intro.
elim H.
intro.
intro.
cut (analysis_def h M1 N1 /\\ analysis_def h M2 N2).
cut (is_analysis h (analysis_def h)).
try apply analysis_is_analysis.
unfold is_analysis in |- *.
intros.
elim H2.

*****
H2 : and (analysis_cond h (analysis_def h))\n (forall (h' : hedge) (_ : analysis_cond h h'),\n inclusion (analysis_def h) h')
H1 : or (not (synthesis (analysis_def h) M1 N1))\n (not (synthesis (analysis_def h) M2 N2))
H0 : analysis_def h (MPair M1 M2) (MPair N1 N2)
H : and (analysis_def h (MPair M1 M2) (MPair N1 N2))\n (or (not (synthesis (analysis_def h) M1 N1))\n (not (synthesis (analysis_def h) M2 N2)))
M1,N1,M2,N2 : Msg
h : hedge
*****
forall (_ : analysis_cond h (analysis_def h)) (_ : forall (h' : hedge) (_ : analysis_cond h h'), inclusion (analysis_def h) h'), and (analysis_def h M1 N1) (analysis_def h M2 N2)
+++++
unfold analysis_cond in |- *.
-----
Lemma irreducible_pair : forall (h : hedge) (M1 N1 M2 N2 : Msg), ~ irreducible h (MPair M1 M2) (MPair N1 N2).
unfold irreducible in |- *.
unfold reduce in |- *.
intros.
red in |- *.
intro.
elim H.
intro.
intro.
cut (analysis_def h M1 N1 /\\ analysis_def h M2 N2).
cut (is_analysis h (analysis_def h)).
try apply analysis_is_analysis.
unfold is_analysis in |- *.
intros.
elim H2.
unfold analysis_cond in |- *.

*****
H2 : and (analysis_cond h (analysis_def h))\n (forall (h' : hedge) (_ : analysis_cond h h'),\n inclusion (analysis_def h) h')
H1 : or (not (synthesis (analysis_def h) M1 N1))\n (not (synthesis (analysis_def h) M2 N2))
H0 : analysis_def h (MPair M1 M2) (MPair N1 N2)
H : and (analysis_def h (MPair M1 M2) (MPair N1 N2))\n (or (not (synthesis (analysis_def h) M1 N1))\n (not (synthesis (analysis_def h) M2 N2)))
M1,N1,M2,N2 : Msg
h : hedge
*****
forall (_ : and (inclusion h (analysis_def h)) (stable_analysis (analysis_def h))) (_ : forall (h' : hedge) (_ : and (inclusion h h') (stable_analysis h')), inclusion (analysis_def h) h'), and (analysis_def h M1 N1) (analysis_def h M2 N2)
+++++
intros.
-----
Lemma irreducible_pair : forall (h : hedge) (M1 N1 M2 N2 : Msg), ~ irreducible h (MPair M1 M2) (MPair N1 N2).
unfold irreducible in |- *.
unfold reduce in |- *.
intros.
red in |- *.
intro.
elim H.
intro.
intro.
cut (analysis_def h M1 N1 /\\ analysis_def h M2 N2).
cut (is_analysis h (analysis_def h)).
try apply analysis_is_analysis.
unfold is_analysis in |- *.
intros.
elim H2.
unfold analysis_cond in |- *.
intros.

*****
H4 : forall (h' : hedge) (_ : and (inclusion h h') (stable_analysis h')),\ninclusion (analysis_def h) h'
H3 : and (inclusion h (analysis_def h)) (stable_analysis (analysis_def h))
H2 : and (analysis_cond h (analysis_def h))\n (forall (h' : hedge) (_ : analysis_cond h h'),\n inclusion (analysis_def h) h')
H1 : or (not (synthesis (analysis_def h) M1 N1))\n (not (synthesis (analysis_def h) M2 N2))
H0 : analysis_def h (MPair M1 M2) (MPair N1 N2)
H : and (analysis_def h (MPair M1 M2) (MPair N1 N2))\n (or (not (synthesis (analysis_def h) M1 N1))\n (not (synthesis (analysis_def h) M2 N2)))
M1,N1,M2,N2 : Msg
h : hedge
*****
and (analysis_def h M1 N1) (analysis_def h M2 N2)
+++++
elim H3.
-----
Lemma irreducible_pair : forall (h : hedge) (M1 N1 M2 N2 : Msg), ~ irreducible h (MPair M1 M2) (MPair N1 N2).
unfold irreducible in |- *.
unfold reduce in |- *.
intros.
red in |- *.
intro.
elim H.
intro.
intro.
cut (analysis_def h M1 N1 /\\ analysis_def h M2 N2).
cut (is_analysis h (analysis_def h)).
try apply analysis_is_analysis.
unfold is_analysis in |- *.
intros.
elim H2.
unfold analysis_cond in |- *.
intros.
elim H3.

*****
H4 : forall (h' : hedge) (_ : and (inclusion h h') (stable_analysis h')),\ninclusion (analysis_def h) h'
H3 : and (inclusion h (analysis_def h)) (stable_analysis (analysis_def h))
H2 : and (analysis_cond h (analysis_def h))\n (forall (h' : hedge) (_ : analysis_cond h h'),\n inclusion (analysis_def h) h')
H1 : or (not (synthesis (analysis_def h) M1 N1))\n (not (synthesis (analysis_def h) M2 N2))
H0 : analysis_def h (MPair M1 M2) (MPair N1 N2)
H : and (analysis_def h (MPair M1 M2) (MPair N1 N2))\n (or (not (synthesis (analysis_def h) M1 N1))\n (not (synthesis (analysis_def h) M2 N2)))
M1,N1,M2,N2 : Msg
h : hedge
*****
forall (_ : inclusion h (analysis_def h)) (_ : stable_analysis (analysis_def h)), and (analysis_def h M1 N1) (analysis_def h M2 N2)
+++++
intros.
-----
Lemma irreducible_pair : forall (h : hedge) (M1 N1 M2 N2 : Msg), ~ irreducible h (MPair M1 M2) (MPair N1 N2).
unfold irreducible in |- *.
unfold reduce in |- *.
intros.
red in |- *.
intro.
elim H.
intro.
intro.
cut (analysis_def h M1 N1 /\\ analysis_def h M2 N2).
cut (is_analysis h (analysis_def h)).
try apply analysis_is_analysis.
unfold is_analysis in |- *.
intros.
elim H2.
unfold analysis_cond in |- *.
intros.
elim H3.
intros.

*****
H6 : stable_analysis (analysis_def h)
H5 : inclusion h (analysis_def h)
H4 : forall (h' : hedge) (_ : and (inclusion h h') (stable_analysis h')),\ninclusion (analysis_def h) h'
H3 : and (inclusion h (analysis_def h)) (stable_analysis (analysis_def h))
H2 : and (analysis_cond h (analysis_def h))\n (forall (h' : hedge) (_ : analysis_cond h h'),\n inclusion (analysis_def h) h')
H1 : or (not (synthesis (analysis_def h) M1 N1))\n (not (synthesis (analysis_def h) M2 N2))
H0 : analysis_def h (MPair M1 M2) (MPair N1 N2)
H : and (analysis_def h (MPair M1 M2) (MPair N1 N2))\n (or (not (synthesis (analysis_def h) M1 N1))\n (not (synthesis (analysis_def h) M2 N2)))
M1,N1,M2,N2 : Msg
h : hedge
*****
and (analysis_def h M1 N1) (analysis_def h M2 N2)
+++++
unfold stable_analysis in H6.
-----
Lemma irreducible_pair : forall (h : hedge) (M1 N1 M2 N2 : Msg), ~ irreducible h (MPair M1 M2) (MPair N1 N2).
unfold irreducible in |- *.
unfold reduce in |- *.
intros.
red in |- *.
intro.
elim H.
intro.
intro.
cut (analysis_def h M1 N1 /\\ analysis_def h M2 N2).
cut (is_analysis h (analysis_def h)).
try apply analysis_is_analysis.
unfold is_analysis in |- *.
intros.
elim H2.
unfold analysis_cond in |- *.
intros.
elim H3.
intros.
unfold stable_analysis in H6.

*****
H6 : inclusion (analysis (analysis_def h)) (analysis_def h)
H5 : inclusion h (analysis_def h)
H4 : forall (h' : hedge) (_ : and (inclusion h h') (stable_analysis h')),\ninclusion (analysis_def h) h'
H3 : and (inclusion h (analysis_def h)) (stable_analysis (analysis_def h))
H2 : and (analysis_cond h (analysis_def h))\n (forall (h' : hedge) (_ : analysis_cond h h'),\n inclusion (analysis_def h) h')
H1 : or (not (synthesis (analysis_def h) M1 N1))\n (not (synthesis (analysis_def h) M2 N2))
H0 : analysis_def h (MPair M1 M2) (MPair N1 N2)
H : and (analysis_def h (MPair M1 M2) (MPair N1 N2))\n (or (not (synthesis (analysis_def h) M1 N1))\n (not (synthesis (analysis_def h) M2 N2)))
M1,N1,M2,N2 : Msg
h : hedge
*****
and (analysis_def h M1 N1) (analysis_def h M2 N2)
+++++
unfold inclusion in H6.
-----
Lemma irreducible_pair : forall (h : hedge) (M1 N1 M2 N2 : Msg), ~ irreducible h (MPair M1 M2) (MPair N1 N2).
unfold irreducible in |- *.
unfold reduce in |- *.
intros.
red in |- *.
intro.
elim H.
intro.
intro.
cut (analysis_def h M1 N1 /\\ analysis_def h M2 N2).
cut (is_analysis h (analysis_def h)).
try apply analysis_is_analysis.
unfold is_analysis in |- *.
intros.
elim H2.
unfold analysis_cond in |- *.
intros.
elim H3.
intros.
unfold stable_analysis in H6.
unfold inclusion in H6.

*****
H6 : forall (M N : Msg) (_ : analysis (analysis_def h) M N),\nanalysis_def h M N
H5 : inclusion h (analysis_def h)
H4 : forall (h' : hedge) (_ : and (inclusion h h') (stable_analysis h')),\ninclusion (analysis_def h) h'
H3 : and (inclusion h (analysis_def h)) (stable_analysis (analysis_def h))
H2 : and (analysis_cond h (analysis_def h))\n (forall (h' : hedge) (_ : analysis_cond h h'),\n inclusion (analysis_def h) h')
H1 : or (not (synthesis (analysis_def h) M1 N1))\n (not (synthesis (analysis_def h) M2 N2))
H0 : analysis_def h (MPair M1 M2) (MPair N1 N2)
H : and (analysis_def h (MPair M1 M2) (MPair N1 N2))\n (or (not (synthesis (analysis_def h) M1 N1))\n (not (synthesis (analysis_def h) M2 N2)))
M1,N1,M2,N2 : Msg
h : hedge
*****
and (analysis_def h M1 N1) (analysis_def h M2 N2)
+++++
split.
-----
Lemma irreducible_pair : forall (h : hedge) (M1 N1 M2 N2 : Msg), ~ irreducible h (MPair M1 M2) (MPair N1 N2).
unfold irreducible in |- *.
unfold reduce in |- *.
intros.
red in |- *.
intro.
elim H.
intro.
intro.
cut (analysis_def h M1 N1 /\\ analysis_def h M2 N2).
cut (is_analysis h (analysis_def h)).
try apply analysis_is_analysis.
unfold is_analysis in |- *.
intros.
elim H2.
unfold analysis_cond in |- *.
intros.
elim H3.
intros.
unfold stable_analysis in H6.
unfold inclusion in H6.
split.

*****
H6 : forall (M N : Msg) (_ : analysis (analysis_def h) M N),\nanalysis_def h M N
H5 : inclusion h (analysis_def h)
H4 : forall (h' : hedge) (_ : and (inclusion h h') (stable_analysis h')),\ninclusion (analysis_def h) h'
H3 : and (inclusion h (analysis_def h)) (stable_analysis (analysis_def h))
H2 : and (analysis_cond h (analysis_def h))\n (forall (h' : hedge) (_ : analysis_cond h h'),\n inclusion (analysis_def h) h')
H1 : or (not (synthesis (analysis_def h) M1 N1))\n (not (synthesis (analysis_def h) M2 N2))
H0 : analysis_def h (MPair M1 M2) (MPair N1 N2)
H : and (analysis_def h (MPair M1 M2) (MPair N1 N2))\n (or (not (synthesis (analysis_def h) M1 N1))\n (not (synthesis (analysis_def h) M2 N2)))
M1,N1,M2,N2 : Msg
h : hedge
*****
analysis_def h M1 N1
+++++
apply H6.
-----
Lemma irreducible_pair : forall (h : hedge) (M1 N1 M2 N2 : Msg), ~ irreducible h (MPair M1 M2) (MPair N1 N2).
unfold irreducible in |- *.
unfold reduce in |- *.
intros.
red in |- *.
intro.
elim H.
intro.
intro.
cut (analysis_def h M1 N1 /\\ analysis_def h M2 N2).
cut (is_analysis h (analysis_def h)).
try apply analysis_is_analysis.
unfold is_analysis in |- *.
intros.
elim H2.
unfold analysis_cond in |- *.
intros.
elim H3.
intros.
unfold stable_analysis in H6.
unfold inclusion in H6.
split.
apply H6.

*****
H6 : forall (M N : Msg) (_ : analysis (analysis_def h) M N),\nanalysis_def h M N
H5 : inclusion h (analysis_def h)
H4 : forall (h' : hedge) (_ : and (inclusion h h') (stable_analysis h')),\ninclusion (analysis_def h) h'
H3 : and (inclusion h (analysis_def h)) (stable_analysis (analysis_def h))
H2 : and (analysis_cond h (analysis_def h))\n (forall (h' : hedge) (_ : analysis_cond h h'),\n inclusion (analysis_def h) h')
H1 : or (not (synthesis (analysis_def h) M1 N1))\n (not (synthesis (analysis_def h) M2 N2))
H0 : analysis_def h (MPair M1 M2) (MPair N1 N2)
H : and (analysis_def h (MPair M1 M2) (MPair N1 N2))\n (or (not (synthesis (analysis_def h) M1 N1))\n (not (synthesis (analysis_def h) M2 N2)))
M1,N1,M2,N2 : Msg
h : hedge
*****
analysis (analysis_def h) M1 N1
+++++
apply (AnaSplitL (analysis_def h) M1 M2 N1 N2).
-----
Lemma irreducible_pair : forall (h : hedge) (M1 N1 M2 N2 : Msg), ~ irreducible h (MPair M1 M2) (MPair N1 N2).
unfold irreducible in |- *.
unfold reduce in |- *.
intros.
red in |- *.
intro.
elim H.
intro.
intro.
cut (analysis_def h M1 N1 /\\ analysis_def h M2 N2).
cut (is_analysis h (analysis_def h)).
try apply analysis_is_analysis.
unfold is_analysis in |- *.
intros.
elim H2.
unfold analysis_cond in |- *.
intros.
elim H3.
intros.
unfold stable_analysis in H6.
unfold inclusion in H6.
split.
apply H6.
apply (AnaSplitL (analysis_def h) M1 M2 N1 N2).

*****
H6 : forall (M N : Msg) (_ : analysis (analysis_def h) M N),\nanalysis_def h M N
H5 : inclusion h (analysis_def h)
H4 : forall (h' : hedge) (_ : and (inclusion h h') (stable_analysis h')),\ninclusion (analysis_def h) h'
H3 : and (inclusion h (analysis_def h)) (stable_analysis (analysis_def h))
H2 : and (analysis_cond h (analysis_def h))\n (forall (h' : hedge) (_ : analysis_cond h h'),\n inclusion (analysis_def h) h')
H1 : or (not (synthesis (analysis_def h) M1 N1))\n (not (synthesis (analysis_def h) M2 N2))
H0 : analysis_def h (MPair M1 M2) (MPair N1 N2)
H : and (analysis_def h (MPair M1 M2) (MPair N1 N2))\n (or (not (synthesis (analysis_def h) M1 N1))\n (not (synthesis (analysis_def h) M2 N2)))
M1,N1,M2,N2 : Msg
h : hedge
*****
analysis (analysis_def h) (MPair M1 M2) (MPair N1 N2)
+++++
apply AnaInc.
-----
Lemma irreducible_pair : forall (h : hedge) (M1 N1 M2 N2 : Msg), ~ irreducible h (MPair M1 M2) (MPair N1 N2).
unfold irreducible in |- *.
unfold reduce in |- *.
intros.
red in |- *.
intro.
elim H.
intro.
intro.
cut (analysis_def h M1 N1 /\\ analysis_def h M2 N2).
cut (is_analysis h (analysis_def h)).
try apply analysis_is_analysis.
unfold is_analysis in |- *.
intros.
elim H2.
unfold analysis_cond in |- *.
intros.
elim H3.
intros.
unfold stable_analysis in H6.
unfold inclusion in H6.
split.
apply H6.
apply (AnaSplitL (analysis_def h) M1 M2 N1 N2).
apply AnaInc.

*****
H6 : forall (M N : Msg) (_ : analysis (analysis_def h) M N),\nanalysis_def h M N
H5 : inclusion h (analysis_def h)
H4 : forall (h' : hedge) (_ : and (inclusion h h') (stable_analysis h')),\ninclusion (analysis_def h) h'
H3 : and (inclusion h (analysis_def h)) (stable_analysis (analysis_def h))
H2 : and (analysis_cond h (analysis_def h))\n (forall (h' : hedge) (_ : analysis_cond h h'),\n inclusion (analysis_def h) h')
H1 : or (not (synthesis (analysis_def h) M1 N1))\n (not (synthesis (analysis_def h) M2 N2))
H0 : analysis_def h (MPair M1 M2) (MPair N1 N2)
H : and (analysis_def h (MPair M1 M2) (MPair N1 N2))\n (or (not (synthesis (analysis_def h) M1 N1))\n (not (synthesis (analysis_def h) M2 N2)))
M1,N1,M2,N2 : Msg
h : hedge
*****
analysis_def h (MPair M1 M2) (MPair N1 N2)
+++++
trivial.
-----
Lemma irreducible_pair : forall (h : hedge) (M1 N1 M2 N2 : Msg), ~ irreducible h (MPair M1 M2) (MPair N1 N2).
unfold irreducible in |- *.
unfold reduce in |- *.
intros.
red in |- *.
intro.
elim H.
intro.
intro.
cut (analysis_def h M1 N1 /\\ analysis_def h M2 N2).
cut (is_analysis h (analysis_def h)).
try apply analysis_is_analysis.
unfold is_analysis in |- *.
intros.
elim H2.
unfold analysis_cond in |- *.
intros.
elim H3.
intros.
unfold stable_analysis in H6.
unfold inclusion in H6.
split.

*****
H6 : forall (M N : Msg) (_ : analysis (analysis_def h) M N),\nanalysis_def h M N
H5 : inclusion h (analysis_def h)
H4 : forall (h' : hedge) (_ : and (inclusion h h') (stable_analysis h')),\ninclusion (analysis_def h) h'
H3 : and (inclusion h (analysis_def h)) (stable_analysis (analysis_def h))
H2 : and (analysis_cond h (analysis_def h))\n (forall (h' : hedge) (_ : analysis_cond h h'),\n inclusion (analysis_def h) h')
H1 : or (not (synthesis (analysis_def h) M1 N1))\n (not (synthesis (analysis_def h) M2 N2))
H0 : analysis_def h (MPair M1 M2) (MPair N1 N2)
H : and (analysis_def h (MPair M1 M2) (MPair N1 N2))\n (or (not (synthesis (analysis_def h) M1 N1))\n (not (synthesis (analysis_def h) M2 N2)))
M1,N1,M2,N2 : Msg
h : hedge
*****
analysis_def h M2 N2
+++++
apply H6.
-----
Lemma irreducible_pair : forall (h : hedge) (M1 N1 M2 N2 : Msg), ~ irreducible h (MPair M1 M2) (MPair N1 N2).
unfold irreducible in |- *.
unfold reduce in |- *.
intros.
red in |- *.
intro.
elim H.
intro.
intro.
cut (analysis_def h M1 N1 /\\ analysis_def h M2 N2).
cut (is_analysis h (analysis_def h)).
try apply analysis_is_analysis.
unfold is_analysis in |- *.
intros.
elim H2.
unfold analysis_cond in |- *.
intros.
elim H3.
intros.
unfold stable_analysis in H6.
unfold inclusion in H6.
split.
apply H6.

*****
H6 : forall (M N : Msg) (_ : analysis (analysis_def h) M N),\nanalysis_def h M N
H5 : inclusion h (analysis_def h)
H4 : forall (h' : hedge) (_ : and (inclusion h h') (stable_analysis h')),\ninclusion (analysis_def h) h'
H3 : and (inclusion h (analysis_def h)) (stable_analysis (analysis_def h))
H2 : and (analysis_cond h (analysis_def h))\n (forall (h' : hedge) (_ : analysis_cond h h'),\n inclusion (analysis_def h) h')
H1 : or (not (synthesis (analysis_def h) M1 N1))\n (not (synthesis (analysis_def h) M2 N2))
H0 : analysis_def h (MPair M1 M2) (MPair N1 N2)
H : and (analysis_def h (MPair M1 M2) (MPair N1 N2))\n (or (not (synthesis (analysis_def h) M1 N1))\n (not (synthesis (analysis_def h) M2 N2)))
M1,N1,M2,N2 : Msg
h : hedge
*****
analysis (analysis_def h) M2 N2
+++++
apply (AnaSplitR (analysis_def h) M1 M2 N1 N2).
-----
Lemma irreducible_pair : forall (h : hedge) (M1 N1 M2 N2 : Msg), ~ irreducible h (MPair M1 M2) (MPair N1 N2).
unfold irreducible in |- *.
unfold reduce in |- *.
intros.
red in |- *.
intro.
elim H.
intro.
intro.
cut (analysis_def h M1 N1 /\\ analysis_def h M2 N2).
cut (is_analysis h (analysis_def h)).
try apply analysis_is_analysis.
unfold is_analysis in |- *.
intros.
elim H2.
unfold analysis_cond in |- *.
intros.
elim H3.
intros.
unfold stable_analysis in H6.
unfold inclusion in H6.
split.
apply H6.
apply (AnaSplitR (analysis_def h) M1 M2 N1 N2).

*****
H6 : forall (M N : Msg) (_ : analysis (analysis_def h) M N),\nanalysis_def h M N
H5 : inclusion h (analysis_def h)
H4 : forall (h' : hedge) (_ : and (inclusion h h') (stable_analysis h')),\ninclusion (analysis_def h) h'
H3 : and (inclusion h (analysis_def h)) (stable_analysis (analysis_def h))
H2 : and (analysis_cond h (analysis_def h))\n (forall (h' : hedge) (_ : analysis_cond h h'),\n inclusion (analysis_def h) h')
H1 : or (not (synthesis (analysis_def h) M1 N1))\n (not (synthesis (analysis_def h) M2 N2))
H0 : analysis_def h (MPair M1 M2) (MPair N1 N2)
H : and (analysis_def h (MPair M1 M2) (MPair N1 N2))\n (or (not (synthesis (analysis_def h) M1 N1))\n (not (synthesis (analysis_def h) M2 N2)))
M1,N1,M2,N2 : Msg
h : hedge
*****
analysis (analysis_def h) (MPair M1 M2) (MPair N1 N2)
+++++
apply AnaInc.
-----
Lemma irreducible_pair : forall (h : hedge) (M1 N1 M2 N2 : Msg), ~ irreducible h (MPair M1 M2) (MPair N1 N2).
unfold irreducible in |- *.
unfold reduce in |- *.
intros.
red in |- *.
intro.
elim H.
intro.
intro.
cut (analysis_def h M1 N1 /\\ analysis_def h M2 N2).
cut (is_analysis h (analysis_def h)).
try apply analysis_is_analysis.
unfold is_analysis in |- *.
intros.
elim H2.
unfold analysis_cond in |- *.
intros.
elim H3.
intros.
unfold stable_analysis in H6.
unfold inclusion in H6.
split.
apply H6.
apply (AnaSplitR (analysis_def h) M1 M2 N1 N2).
apply AnaInc.

*****
H6 : forall (M N : Msg) (_ : analysis (analysis_def h) M N),\nanalysis_def h M N
H5 : inclusion h (analysis_def h)
H4 : forall (h' : hedge) (_ : and (inclusion h h') (stable_analysis h')),\ninclusion (analysis_def h) h'
H3 : and (inclusion h (analysis_def h)) (stable_analysis (analysis_def h))
H2 : and (analysis_cond h (analysis_def h))\n (forall (h' : hedge) (_ : analysis_cond h h'),\n inclusion (analysis_def h) h')
H1 : or (not (synthesis (analysis_def h) M1 N1))\n (not (synthesis (analysis_def h) M2 N2))
H0 : analysis_def h (MPair M1 M2) (MPair N1 N2)
H : and (analysis_def h (MPair M1 M2) (MPair N1 N2))\n (or (not (synthesis (analysis_def h) M1 N1))\n (not (synthesis (analysis_def h) M2 N2)))
M1,N1,M2,N2 : Msg
h : hedge
*****
analysis_def h (MPair M1 M2) (MPair N1 N2)
+++++
trivial.
-----
Lemma irreducible_pair : forall (h : hedge) (M1 N1 M2 N2 : Msg), ~ irreducible h (MPair M1 M2) (MPair N1 N2).
unfold irreducible in |- *.
unfold reduce in |- *.
intros.
red in |- *.
intro.
elim H.
intro.
intro.
cut (analysis_def h M1 N1 /\\ analysis_def h M2 N2).
cut (is_analysis h (analysis_def h)).

*****
H1 : or (not (synthesis (analysis_def h) M1 N1))\n (not (synthesis (analysis_def h) M2 N2))
H0 : analysis_def h (MPair M1 M2) (MPair N1 N2)
H : and (analysis_def h (MPair M1 M2) (MPair N1 N2))\n (or (not (synthesis (analysis_def h) M1 N1))\n (not (synthesis (analysis_def h) M2 N2)))
M1,N1,M2,N2 : Msg
h : hedge
*****
is_analysis h (analysis_def h)
+++++
try apply analysis_is_analysis.
-----
Lemma irreducible_pair : forall (h : hedge) (M1 N1 M2 N2 : Msg), ~ irreducible h (MPair M1 M2) (MPair N1 N2).
unfold irreducible in |- *.
unfold reduce in |- *.
intros.
red in |- *.
intro.
elim H.
intro.
intro.
cut (analysis_def h M1 N1 /\\ analysis_def h M2 N2).

*****

*****

+++++
Qed.
-----
Definition is_irreducible (h : hedge) := equal h (irreducible h).
-----
Theorem h_le_h_ana_h : forall h : hedge, le_h h (analysis_def h).
-----
Theorem h_le_h_ana_h : forall h : hedge, le_h h (analysis_def h).

*****

*****
forall h : hedge, le_h h (analysis_def h)
+++++
intro.
-----
Theorem h_le_h_ana_h : forall h : hedge, le_h h (analysis_def h).
intro.

*****
h : hedge
*****
le_h h (analysis_def h)
+++++
apply inclusion_impl_le_h.
-----
Theorem h_le_h_ana_h : forall h : hedge, le_h h (analysis_def h).
intro.
apply inclusion_impl_le_h.

*****
h : hedge
*****
inclusion h (analysis_def h)
+++++
generalize (analysis_is_analysis h).
-----
Theorem h_le_h_ana_h : forall h : hedge, le_h h (analysis_def h).
intro.
apply inclusion_impl_le_h.
generalize (analysis_is_analysis h).

*****
h : hedge
*****
forall _ : is_analysis h (analysis_def h), inclusion h (analysis_def h)
+++++
intro.
-----
Theorem h_le_h_ana_h : forall h : hedge, le_h h (analysis_def h).
intro.
apply inclusion_impl_le_h.
generalize (analysis_is_analysis h).
intro.

*****
H : is_analysis h (analysis_def h)
h : hedge
*****
inclusion h (analysis_def h)
+++++
unfold is_analysis in H.
-----
Theorem h_le_h_ana_h : forall h : hedge, le_h h (analysis_def h).
intro.
apply inclusion_impl_le_h.
generalize (analysis_is_analysis h).
intro.
unfold is_analysis in H.

*****
H : and (analysis_cond h (analysis_def h))\n (forall (h' : hedge) (_ : analysis_cond h h'),\n inclusion (analysis_def h) h')
h : hedge
*****
inclusion h (analysis_def h)
+++++
unfold analysis_cond in H.
-----
Theorem h_le_h_ana_h : forall h : hedge, le_h h (analysis_def h).
intro.
apply inclusion_impl_le_h.
generalize (analysis_is_analysis h).
intro.
unfold is_analysis in H.
unfold analysis_cond in H.

*****
H : and\n (and (inclusion h (analysis_def h))\n (stable_analysis (analysis_def h)))\n (forall (h' : hedge) (_ : and (inclusion h h') (stable_analysis h')),\n inclusion (analysis_def h) h')
h : hedge
*****
inclusion h (analysis_def h)
+++++
elim H.
-----
Theorem h_le_h_ana_h : forall h : hedge, le_h h (analysis_def h).
intro.
apply inclusion_impl_le_h.
generalize (analysis_is_analysis h).
intro.
unfold is_analysis in H.
unfold analysis_cond in H.
elim H.

*****
H : and\n (and (inclusion h (analysis_def h))\n (stable_analysis (analysis_def h)))\n (forall (h' : hedge) (_ : and (inclusion h h') (stable_analysis h')),\n inclusion (analysis_def h) h')
h : hedge
*****
forall (_ : and (inclusion h (analysis_def h)) (stable_analysis (analysis_def h))) (_ : forall (h' : hedge) (_ : and (inclusion h h') (stable_analysis h')), inclusion (analysis_def h) h'), inclusion h (analysis_def h)
+++++
intros.
-----
Theorem h_le_h_ana_h : forall h : hedge, le_h h (analysis_def h).
intro.
apply inclusion_impl_le_h.
generalize (analysis_is_analysis h).
intro.
unfold is_analysis in H.
unfold analysis_cond in H.
elim H.
intros.

*****
H1 : forall (h' : hedge) (_ : and (inclusion h h') (stable_analysis h')),\ninclusion (analysis_def h) h'
H0 : and (inclusion h (analysis_def h)) (stable_analysis (analysis_def h))
H : and\n (and (inclusion h (analysis_def h))\n (stable_analysis (analysis_def h)))\n (forall (h' : hedge) (_ : and (inclusion h h') (stable_analysis h')),\n inclusion (analysis_def h) h')
h : hedge
*****
inclusion h (analysis_def h)
+++++
tauto.
-----
Theorem h_le_h_ana_h : forall h : hedge, le_h h (analysis_def h).
intro.
apply inclusion_impl_le_h.
generalize (analysis_is_analysis h).
intro.
unfold is_analysis in H.
unfold analysis_cond in H.
elim H.
intros.
tauto.

*****

*****

+++++
Qed.
-----
Theorem ana_h_equiv_irr_h :\n forall h : hedge, equiv_h (analysis_def h) (irreducible h).
-----
Theorem ana_h_equiv_irr_h : forall h : hedge, equiv_h (analysis_def h) (irreducible h).

*****

*****
forall h : hedge, equiv_h (analysis_def h) (irreducible h)
+++++
unfold irreducible in |- *.
-----
Theorem ana_h_equiv_irr_h : forall h : hedge, equiv_h (analysis_def h) (irreducible h).
unfold irreducible in |- *.

*****

*****
forall h : hedge, equiv_h (analysis_def h) (reduce (analysis_def h))
+++++
intro.
-----
Theorem ana_h_equiv_irr_h : forall h : hedge, equiv_h (analysis_def h) (irreducible h).
unfold irreducible in |- *.
intro.

*****
h : hedge
*****
equiv_h (analysis_def h) (reduce (analysis_def h))
+++++
apply h_equiv_h_red.
-----
Theorem ana_h_equiv_irr_h : forall h : hedge, equiv_h (analysis_def h) (irreducible h).
unfold irreducible in |- *.
intro.
apply h_equiv_h_red.

*****

*****

+++++
Qed.
-----
Theorem h_le_h_irr_h : forall h : hedge, le_h h (irreducible h).
-----
Theorem h_le_h_irr_h : forall h : hedge, le_h h (irreducible h).

*****

*****
forall h : hedge, le_h h (irreducible h)
+++++
intro.
-----
Theorem h_le_h_irr_h : forall h : hedge, le_h h (irreducible h).
intro.

*****
h : hedge
*****
le_h h (irreducible h)
+++++
apply le_h_trans with (analysis_def h).
-----
Theorem h_le_h_irr_h : forall h : hedge, le_h h (irreducible h).
intro.
apply le_h_trans with (analysis_def h).

*****
h : hedge
*****
le_h h (analysis_def h)
+++++
apply h_le_h_ana_h.
-----
Theorem h_le_h_irr_h : forall h : hedge, le_h h (irreducible h).
intro.
apply le_h_trans with (analysis_def h).

*****
h : hedge
*****
le_h (analysis_def h) (irreducible h)
+++++
generalize (ana_h_equiv_irr_h h).
-----
Theorem h_le_h_irr_h : forall h : hedge, le_h h (irreducible h).
intro.
apply le_h_trans with (analysis_def h).
generalize (ana_h_equiv_irr_h h).

*****
h : hedge
*****
forall _ : equiv_h (analysis_def h) (irreducible h), le_h (analysis_def h) (irreducible h)
+++++
unfold equiv_h in |- *.
-----
Theorem h_le_h_irr_h : forall h : hedge, le_h h (irreducible h).
intro.
apply le_h_trans with (analysis_def h).
generalize (ana_h_equiv_irr_h h).
unfold equiv_h in |- *.

*****
h : hedge
*****
forall _ : and (le_h (analysis_def h) (irreducible h)) (le_h (irreducible h) (analysis_def h)), le_h (analysis_def h) (irreducible h)
+++++
tauto.
-----
Theorem h_le_h_irr_h : forall h : hedge, le_h h (irreducible h).
intro.
apply le_h_trans with (analysis_def h).

*****

*****

+++++
Qed.
-----
Lemma ana_irr_incl_ana :\n forall h : hedge, inclusion (analysis_def (irreducible h)) (analysis_def h).
-----
Lemma ana_irr_incl_ana : forall h : hedge, inclusion (analysis_def (irreducible h)) (analysis_def h).

*****

*****
forall h : hedge, inclusion (analysis_def (irreducible h)) (analysis_def h)
+++++
intro.
-----
Lemma ana_irr_incl_ana : forall h : hedge, inclusion (analysis_def (irreducible h)) (analysis_def h).
intro.

*****
h : hedge
*****
inclusion (analysis_def (irreducible h)) (analysis_def h)
+++++
generalize (analysis_is_analysis (irreducible h)).
-----
Lemma ana_irr_incl_ana : forall h : hedge, inclusion (analysis_def (irreducible h)) (analysis_def h).
intro.
generalize (analysis_is_analysis (irreducible h)).

*****
h : hedge
*****
forall _ : is_analysis (irreducible h) (analysis_def (irreducible h)), inclusion (analysis_def (irreducible h)) (analysis_def h)
+++++
unfold is_analysis in |- *.
-----
Lemma ana_irr_incl_ana : forall h : hedge, inclusion (analysis_def (irreducible h)) (analysis_def h).
intro.
generalize (analysis_is_analysis (irreducible h)).
unfold is_analysis in |- *.

*****
h : hedge
*****
forall _ : and (analysis_cond (irreducible h) (analysis_def (irreducible h))) (forall (h' : hedge) (_ : analysis_cond (irreducible h) h'), inclusion (analysis_def (irreducible h)) h'), inclusion (analysis_def (irreducible h)) (analysis_def h)
+++++
unfold analysis_cond in |- *.
-----
Lemma ana_irr_incl_ana : forall h : hedge, inclusion (analysis_def (irreducible h)) (analysis_def h).
intro.
generalize (analysis_is_analysis (irreducible h)).
unfold is_analysis in |- *.
unfold analysis_cond in |- *.

*****
h : hedge
*****
forall _ : and (and (inclusion (irreducible h) (analysis_def (irreducible h))) (stable_analysis (analysis_def (irreducible h)))) (forall (h' : hedge) (_ : and (inclusion (irreducible h) h') (stable_analysis h')), inclusion (analysis_def (irreducible h)) h'), inclusion (analysis_def (irreducible h)) (analysis_def h)
+++++
intros.
-----
Lemma ana_irr_incl_ana : forall h : hedge, inclusion (analysis_def (irreducible h)) (analysis_def h).
intro.
generalize (analysis_is_analysis (irreducible h)).
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.

*****
H : and\n (and (inclusion (irreducible h) (analysis_def (irreducible h)))\n (stable_analysis (analysis_def (irreducible h))))\n (forall (h' : hedge)\n (_ : and (inclusion (irreducible h) h') (stable_analysis h')),\n inclusion (analysis_def (irreducible h)) h')
h : hedge
*****
inclusion (analysis_def (irreducible h)) (analysis_def h)
+++++
elim H.
-----
Lemma ana_irr_incl_ana : forall h : hedge, inclusion (analysis_def (irreducible h)) (analysis_def h).
intro.
generalize (analysis_is_analysis (irreducible h)).
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.
elim H.

*****
H : and\n (and (inclusion (irreducible h) (analysis_def (irreducible h)))\n (stable_analysis (analysis_def (irreducible h))))\n (forall (h' : hedge)\n (_ : and (inclusion (irreducible h) h') (stable_analysis h')),\n inclusion (analysis_def (irreducible h)) h')
h : hedge
*****
forall (_ : and (inclusion (irreducible h) (analysis_def (irreducible h))) (stable_analysis (analysis_def (irreducible h)))) (_ : forall (h' : hedge) (_ : and (inclusion (irreducible h) h') (stable_analysis h')), inclusion (analysis_def (irreducible h)) h'), inclusion (analysis_def (irreducible h)) (analysis_def h)
+++++
intros.
-----
Lemma ana_irr_incl_ana : forall h : hedge, inclusion (analysis_def (irreducible h)) (analysis_def h).
intro.
generalize (analysis_is_analysis (irreducible h)).
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.
elim H.
intros.

*****
H1 : forall (h' : hedge)\n (_ : and (inclusion (irreducible h) h') (stable_analysis h')),\ninclusion (analysis_def (irreducible h)) h'
H0 : and (inclusion (irreducible h) (analysis_def (irreducible h)))\n (stable_analysis (analysis_def (irreducible h)))
H : and\n (and (inclusion (irreducible h) (analysis_def (irreducible h)))\n (stable_analysis (analysis_def (irreducible h))))\n (forall (h' : hedge)\n (_ : and (inclusion (irreducible h) h') (stable_analysis h')),\n inclusion (analysis_def (irreducible h)) h')
h : hedge
*****
inclusion (analysis_def (irreducible h)) (analysis_def h)
+++++
apply H1.
-----
Lemma ana_irr_incl_ana : forall h : hedge, inclusion (analysis_def (irreducible h)) (analysis_def h).
intro.
generalize (analysis_is_analysis (irreducible h)).
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.
elim H.
intros.
apply H1.

*****
H1 : forall (h' : hedge)\n (_ : and (inclusion (irreducible h) h') (stable_analysis h')),\ninclusion (analysis_def (irreducible h)) h'
H0 : and (inclusion (irreducible h) (analysis_def (irreducible h)))\n (stable_analysis (analysis_def (irreducible h)))
H : and\n (and (inclusion (irreducible h) (analysis_def (irreducible h)))\n (stable_analysis (analysis_def (irreducible h))))\n (forall (h' : hedge)\n (_ : and (inclusion (irreducible h) h') (stable_analysis h')),\n inclusion (analysis_def (irreducible h)) h')
h : hedge
*****
and (inclusion (irreducible h) (analysis_def h)) (stable_analysis (analysis_def h))
+++++
split.
-----
Lemma ana_irr_incl_ana : forall h : hedge, inclusion (analysis_def (irreducible h)) (analysis_def h).
intro.
generalize (analysis_is_analysis (irreducible h)).
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.
elim H.
intros.
apply H1.
split.

*****
H1 : forall (h' : hedge)\n (_ : and (inclusion (irreducible h) h') (stable_analysis h')),\ninclusion (analysis_def (irreducible h)) h'
H0 : and (inclusion (irreducible h) (analysis_def (irreducible h)))\n (stable_analysis (analysis_def (irreducible h)))
H : and\n (and (inclusion (irreducible h) (analysis_def (irreducible h)))\n (stable_analysis (analysis_def (irreducible h))))\n (forall (h' : hedge)\n (_ : and (inclusion (irreducible h) h') (stable_analysis h')),\n inclusion (analysis_def (irreducible h)) h')
h : hedge
*****
inclusion (irreducible h) (analysis_def h)
+++++
unfold irreducible in |- *.
-----
Lemma ana_irr_incl_ana : forall h : hedge, inclusion (analysis_def (irreducible h)) (analysis_def h).
intro.
generalize (analysis_is_analysis (irreducible h)).
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.
elim H.
intros.
apply H1.
split.
unfold irreducible in |- *.

*****
H1 : forall (h' : hedge)\n (_ : and (inclusion (irreducible h) h') (stable_analysis h')),\ninclusion (analysis_def (irreducible h)) h'
H0 : and (inclusion (irreducible h) (analysis_def (irreducible h)))\n (stable_analysis (analysis_def (irreducible h)))
H : and\n (and (inclusion (irreducible h) (analysis_def (irreducible h)))\n (stable_analysis (analysis_def (irreducible h))))\n (forall (h' : hedge)\n (_ : and (inclusion (irreducible h) h') (stable_analysis h')),\n inclusion (analysis_def (irreducible h)) h')
h : hedge
*****
inclusion (reduce (analysis_def h)) (analysis_def h)
+++++
apply red_incl_h.
-----
Lemma ana_irr_incl_ana : forall h : hedge, inclusion (analysis_def (irreducible h)) (analysis_def h).
intro.
generalize (analysis_is_analysis (irreducible h)).
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.
elim H.
intros.
apply H1.
split.

*****
H1 : forall (h' : hedge)\n (_ : and (inclusion (irreducible h) h') (stable_analysis h')),\ninclusion (analysis_def (irreducible h)) h'
H0 : and (inclusion (irreducible h) (analysis_def (irreducible h)))\n (stable_analysis (analysis_def (irreducible h)))
H : and\n (and (inclusion (irreducible h) (analysis_def (irreducible h)))\n (stable_analysis (analysis_def (irreducible h))))\n (forall (h' : hedge)\n (_ : and (inclusion (irreducible h) h') (stable_analysis h')),\n inclusion (analysis_def (irreducible h)) h')
h : hedge
*****
stable_analysis (analysis_def h)
+++++
generalize (analysis_is_analysis h).
-----
Lemma ana_irr_incl_ana : forall h : hedge, inclusion (analysis_def (irreducible h)) (analysis_def h).
intro.
generalize (analysis_is_analysis (irreducible h)).
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.
elim H.
intros.
apply H1.
split.
generalize (analysis_is_analysis h).

*****
H1 : forall (h' : hedge)\n (_ : and (inclusion (irreducible h) h') (stable_analysis h')),\ninclusion (analysis_def (irreducible h)) h'
H0 : and (inclusion (irreducible h) (analysis_def (irreducible h)))\n (stable_analysis (analysis_def (irreducible h)))
H : and\n (and (inclusion (irreducible h) (analysis_def (irreducible h)))\n (stable_analysis (analysis_def (irreducible h))))\n (forall (h' : hedge)\n (_ : and (inclusion (irreducible h) h') (stable_analysis h')),\n inclusion (analysis_def (irreducible h)) h')
h : hedge
*****
forall _ : is_analysis h (analysis_def h), stable_analysis (analysis_def h)
+++++
unfold is_analysis in |- *.
-----
Lemma ana_irr_incl_ana : forall h : hedge, inclusion (analysis_def (irreducible h)) (analysis_def h).
intro.
generalize (analysis_is_analysis (irreducible h)).
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.
elim H.
intros.
apply H1.
split.
generalize (analysis_is_analysis h).
unfold is_analysis in |- *.

*****
H1 : forall (h' : hedge)\n (_ : and (inclusion (irreducible h) h') (stable_analysis h')),\ninclusion (analysis_def (irreducible h)) h'
H0 : and (inclusion (irreducible h) (analysis_def (irreducible h)))\n (stable_analysis (analysis_def (irreducible h)))
H : and\n (and (inclusion (irreducible h) (analysis_def (irreducible h)))\n (stable_analysis (analysis_def (irreducible h))))\n (forall (h' : hedge)\n (_ : and (inclusion (irreducible h) h') (stable_analysis h')),\n inclusion (analysis_def (irreducible h)) h')
h : hedge
*****
forall _ : and (analysis_cond h (analysis_def h)) (forall (h' : hedge) (_ : analysis_cond h h'), inclusion (analysis_def h) h'), stable_analysis (analysis_def h)
+++++
unfold analysis_cond in |- *.
-----
Lemma ana_irr_incl_ana : forall h : hedge, inclusion (analysis_def (irreducible h)) (analysis_def h).
intro.
generalize (analysis_is_analysis (irreducible h)).
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.
elim H.
intros.
apply H1.
split.
generalize (analysis_is_analysis h).
unfold is_analysis in |- *.
unfold analysis_cond in |- *.

*****
H1 : forall (h' : hedge)\n (_ : and (inclusion (irreducible h) h') (stable_analysis h')),\ninclusion (analysis_def (irreducible h)) h'
H0 : and (inclusion (irreducible h) (analysis_def (irreducible h)))\n (stable_analysis (analysis_def (irreducible h)))
H : and\n (and (inclusion (irreducible h) (analysis_def (irreducible h)))\n (stable_analysis (analysis_def (irreducible h))))\n (forall (h' : hedge)\n (_ : and (inclusion (irreducible h) h') (stable_analysis h')),\n inclusion (analysis_def (irreducible h)) h')
h : hedge
*****
forall _ : and (and (inclusion h (analysis_def h)) (stable_analysis (analysis_def h))) (forall (h' : hedge) (_ : and (inclusion h h') (stable_analysis h')), inclusion (analysis_def h) h'), stable_analysis (analysis_def h)
+++++
tauto.
-----
Lemma ana_irr_incl_ana : forall h : hedge, inclusion (analysis_def (irreducible h)) (analysis_def h).
intro.
generalize (analysis_is_analysis (irreducible h)).
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.
elim H.
intros.
apply H1.
split.

*****

*****

+++++
Qed.
-----
Lemma irr_irr_incl_irr :\n forall h : hedge, inclusion (irreducible (irreducible h)) (irreducible h).
-----
Lemma irr_irr_incl_irr : forall h : hedge, inclusion (irreducible (irreducible h)) (irreducible h).

*****

*****
forall h : hedge, inclusion (irreducible (irreducible h)) (irreducible h)
+++++
unfold irreducible in |- *.
-----
Lemma irr_irr_incl_irr : forall h : hedge, inclusion (irreducible (irreducible h)) (irreducible h).
unfold irreducible in |- *.

*****

*****
forall h : hedge, inclusion (reduce (analysis_def (reduce (analysis_def h)))) (reduce (analysis_def h))
+++++
intro.
-----
Lemma irr_irr_incl_irr : forall h : hedge, inclusion (irreducible (irreducible h)) (irreducible h).
unfold irreducible in |- *.
intro.

*****
h : hedge
*****
inclusion (reduce (analysis_def (reduce (analysis_def h)))) (reduce (analysis_def h))
+++++
apply inclusion_le_h_reduce_inclusion.
-----
Lemma irr_irr_incl_irr : forall h : hedge, inclusion (irreducible (irreducible h)) (irreducible h).
unfold irreducible in |- *.
intro.
apply inclusion_le_h_reduce_inclusion.

*****
h : hedge
*****
inclusion (analysis_def (reduce (analysis_def h))) (analysis_def h)
+++++
replace (reduce (analysis_def h)) with (irreducible h).
-----
Lemma irr_irr_incl_irr : forall h : hedge, inclusion (irreducible (irreducible h)) (irreducible h).
unfold irreducible in |- *.
intro.
apply inclusion_le_h_reduce_inclusion.
replace (reduce (analysis_def h)) with (irreducible h).

*****
h : hedge
*****
inclusion (analysis_def (irreducible h)) (analysis_def h)
+++++
apply ana_irr_incl_ana.
-----
Lemma irr_irr_incl_irr : forall h : hedge, inclusion (irreducible (irreducible h)) (irreducible h).
unfold irreducible in |- *.
intro.
apply inclusion_le_h_reduce_inclusion.
replace (reduce (analysis_def h)) with (irreducible h).

*****
h : hedge
*****
eq (irreducible h) (reduce (analysis_def h))
+++++
unfold irreducible in |- *.
-----
Lemma irr_irr_incl_irr : forall h : hedge, inclusion (irreducible (irreducible h)) (irreducible h).
unfold irreducible in |- *.
intro.
apply inclusion_le_h_reduce_inclusion.
replace (reduce (analysis_def h)) with (irreducible h).
unfold irreducible in |- *.

*****
h : hedge
*****
eq (reduce (analysis_def h)) (reduce (analysis_def h))
+++++
trivial.
-----
Lemma irr_irr_incl_irr : forall h : hedge, inclusion (irreducible (irreducible h)) (irreducible h).
unfold irreducible in |- *.
intro.
apply inclusion_le_h_reduce_inclusion.

*****
h : hedge
*****
le_h (analysis_def h) (analysis_def (reduce (analysis_def h)))
+++++
replace (reduce (analysis_def h)) with (irreducible h).
-----
Lemma irr_irr_incl_irr : forall h : hedge, inclusion (irreducible (irreducible h)) (irreducible h).
unfold irreducible in |- *.
intro.
apply inclusion_le_h_reduce_inclusion.
replace (reduce (analysis_def h)) with (irreducible h).

*****
h : hedge
*****
le_h (analysis_def h) (analysis_def (irreducible h))
+++++
apply le_h_trans with (irreducible h).
-----
Lemma irr_irr_incl_irr : forall h : hedge, inclusion (irreducible (irreducible h)) (irreducible h).
unfold irreducible in |- *.
intro.
apply inclusion_le_h_reduce_inclusion.
replace (reduce (analysis_def h)) with (irreducible h).
apply le_h_trans with (irreducible h).

*****
h : hedge
*****
le_h (analysis_def h) (irreducible h)
+++++
generalize ana_h_equiv_irr_h.
-----
Lemma irr_irr_incl_irr : forall h : hedge, inclusion (irreducible (irreducible h)) (irreducible h).
unfold irreducible in |- *.
intro.
apply inclusion_le_h_reduce_inclusion.
replace (reduce (analysis_def h)) with (irreducible h).
apply le_h_trans with (irreducible h).
generalize ana_h_equiv_irr_h.

*****
h : hedge
*****
forall _ : forall h : hedge, equiv_h (analysis_def h) (irreducible h), le_h (analysis_def h) (irreducible h)
+++++
unfold equiv_h in |- *.
-----
Lemma irr_irr_incl_irr : forall h : hedge, inclusion (irreducible (irreducible h)) (irreducible h).
unfold irreducible in |- *.
intro.
apply inclusion_le_h_reduce_inclusion.
replace (reduce (analysis_def h)) with (irreducible h).
apply le_h_trans with (irreducible h).
generalize ana_h_equiv_irr_h.
unfold equiv_h in |- *.

*****
h : hedge
*****
forall _ : forall h : hedge, and (le_h (analysis_def h) (irreducible h)) (le_h (irreducible h) (analysis_def h)), le_h (analysis_def h) (irreducible h)
+++++
intros.
-----
Lemma irr_irr_incl_irr : forall h : hedge, inclusion (irreducible (irreducible h)) (irreducible h).
unfold irreducible in |- *.
intro.
apply inclusion_le_h_reduce_inclusion.
replace (reduce (analysis_def h)) with (irreducible h).
apply le_h_trans with (irreducible h).
generalize ana_h_equiv_irr_h.
unfold equiv_h in |- *.
intros.

*****
H : forall h : hedge,\nand (le_h (analysis_def h) (irreducible h))\n (le_h (irreducible h) (analysis_def h))
h : hedge
*****
le_h (analysis_def h) (irreducible h)
+++++
elim (H h).
-----
Lemma irr_irr_incl_irr : forall h : hedge, inclusion (irreducible (irreducible h)) (irreducible h).
unfold irreducible in |- *.
intro.
apply inclusion_le_h_reduce_inclusion.
replace (reduce (analysis_def h)) with (irreducible h).
apply le_h_trans with (irreducible h).
generalize ana_h_equiv_irr_h.
unfold equiv_h in |- *.
intros.
elim (H h).

*****
H : forall h : hedge,\nand (le_h (analysis_def h) (irreducible h))\n (le_h (irreducible h) (analysis_def h))
h : hedge
*****
forall (_ : le_h (analysis_def h) (irreducible h)) (_ : le_h (irreducible h) (analysis_def h)), le_h (analysis_def h) (irreducible h)
+++++
tauto.
-----
Lemma irr_irr_incl_irr : forall h : hedge, inclusion (irreducible (irreducible h)) (irreducible h).
unfold irreducible in |- *.
intro.
apply inclusion_le_h_reduce_inclusion.
replace (reduce (analysis_def h)) with (irreducible h).
apply le_h_trans with (irreducible h).

*****
h : hedge
*****
le_h (irreducible h) (analysis_def (irreducible h))
+++++
apply h_le_h_ana_h.
-----
Lemma irr_irr_incl_irr : forall h : hedge, inclusion (irreducible (irreducible h)) (irreducible h).
unfold irreducible in |- *.
intro.
apply inclusion_le_h_reduce_inclusion.
replace (reduce (analysis_def h)) with (irreducible h).

*****
h : hedge
*****
eq (irreducible h) (reduce (analysis_def h))
+++++
unfold irreducible in |- *.
-----
Lemma irr_irr_incl_irr : forall h : hedge, inclusion (irreducible (irreducible h)) (irreducible h).
unfold irreducible in |- *.
intro.
apply inclusion_le_h_reduce_inclusion.
replace (reduce (analysis_def h)) with (irreducible h).
unfold irreducible in |- *.

*****
h : hedge
*****
eq (reduce (analysis_def h)) (reduce (analysis_def h))
+++++
trivial.
-----
Lemma irr_irr_incl_irr : forall h : hedge, inclusion (irreducible (irreducible h)) (irreducible h).
unfold irreducible in |- *.
intro.
apply inclusion_le_h_reduce_inclusion.

*****

*****

+++++
Qed.
-----
Lemma irr_incl_irr_irr :\n forall h : hedge, inclusion (irreducible h) (irreducible (irreducible h)).
-----
Lemma irr_incl_irr_irr : forall h : hedge, inclusion (irreducible h) (irreducible (irreducible h)).

*****

*****
forall h : hedge, inclusion (irreducible h) (irreducible (irreducible h))
+++++
unfold irreducible in |- *.
-----
Lemma irr_incl_irr_irr : forall h : hedge, inclusion (irreducible h) (irreducible (irreducible h)).
unfold irreducible in |- *.

*****

*****
forall h : hedge, inclusion (reduce (analysis_def h)) (reduce (analysis_def (reduce (analysis_def h))))
+++++
intros.
-----
Lemma irr_incl_irr_irr : forall h : hedge, inclusion (irreducible h) (irreducible (irreducible h)).
unfold irreducible in |- *.
intros.

*****
h : hedge
*****
inclusion (reduce (analysis_def h)) (reduce (analysis_def (reduce (analysis_def h))))
+++++
apply inclusion_le_h_impl_inclusion_red.
-----
Lemma irr_incl_irr_irr : forall h : hedge, inclusion (irreducible h) (irreducible (irreducible h)).
unfold irreducible in |- *.
intros.
apply inclusion_le_h_impl_inclusion_red.

*****
h : hedge
*****
inclusion (reduce (analysis_def h)) (analysis_def (reduce (analysis_def h)))
+++++
generalize (analysis_is_analysis (reduce (analysis_def h))).
-----
Lemma irr_incl_irr_irr : forall h : hedge, inclusion (irreducible h) (irreducible (irreducible h)).
unfold irreducible in |- *.
intros.
apply inclusion_le_h_impl_inclusion_red.
generalize (analysis_is_analysis (reduce (analysis_def h))).

*****
h : hedge
*****
forall _ : is_analysis (reduce (analysis_def h)) (analysis_def (reduce (analysis_def h))), inclusion (reduce (analysis_def h)) (analysis_def (reduce (analysis_def h)))
+++++
unfold is_analysis in |- *.
-----
Lemma irr_incl_irr_irr : forall h : hedge, inclusion (irreducible h) (irreducible (irreducible h)).
unfold irreducible in |- *.
intros.
apply inclusion_le_h_impl_inclusion_red.
generalize (analysis_is_analysis (reduce (analysis_def h))).
unfold is_analysis in |- *.

*****
h : hedge
*****
forall _ : and (analysis_cond (reduce (analysis_def h)) (analysis_def (reduce (analysis_def h)))) (forall (h' : hedge) (_ : analysis_cond (reduce (analysis_def h)) h'), inclusion (analysis_def (reduce (analysis_def h))) h'), inclusion (reduce (analysis_def h)) (analysis_def (reduce (analysis_def h)))
+++++
unfold analysis_cond in |- *.
-----
Lemma irr_incl_irr_irr : forall h : hedge, inclusion (irreducible h) (irreducible (irreducible h)).
unfold irreducible in |- *.
intros.
apply inclusion_le_h_impl_inclusion_red.
generalize (analysis_is_analysis (reduce (analysis_def h))).
unfold is_analysis in |- *.
unfold analysis_cond in |- *.

*****
h : hedge
*****
forall _ : and (and (inclusion (reduce (analysis_def h)) (analysis_def (reduce (analysis_def h)))) (stable_analysis (analysis_def (reduce (analysis_def h))))) (forall (h' : hedge) (_ : and (inclusion (reduce (analysis_def h)) h') (stable_analysis h')), inclusion (analysis_def (reduce (analysis_def h))) h'), inclusion (reduce (analysis_def h)) (analysis_def (reduce (analysis_def h)))
+++++
tauto.
-----
Lemma irr_incl_irr_irr : forall h : hedge, inclusion (irreducible h) (irreducible (irreducible h)).
unfold irreducible in |- *.
intros.
apply inclusion_le_h_impl_inclusion_red.

*****
h : hedge
*****
le_h (analysis_def (reduce (analysis_def h))) (reduce (analysis_def h))
+++++
apply le_h_trans with (analysis_def h).
-----
Lemma irr_incl_irr_irr : forall h : hedge, inclusion (irreducible h) (irreducible (irreducible h)).
unfold irreducible in |- *.
intros.
apply inclusion_le_h_impl_inclusion_red.
apply le_h_trans with (analysis_def h).

*****
h : hedge
*****
le_h (analysis_def (reduce (analysis_def h))) (analysis_def h)
+++++
apply inclusion_impl_le_h.
-----
Lemma irr_incl_irr_irr : forall h : hedge, inclusion (irreducible h) (irreducible (irreducible h)).
unfold irreducible in |- *.
intros.
apply inclusion_le_h_impl_inclusion_red.
apply le_h_trans with (analysis_def h).
apply inclusion_impl_le_h.

*****
h : hedge
*****
inclusion (analysis_def (reduce (analysis_def h))) (analysis_def h)
+++++
fold (irreducible h) in |- *.
-----
Lemma irr_incl_irr_irr : forall h : hedge, inclusion (irreducible h) (irreducible (irreducible h)).
unfold irreducible in |- *.
intros.
apply inclusion_le_h_impl_inclusion_red.
apply le_h_trans with (analysis_def h).
apply inclusion_impl_le_h.
fold (irreducible h) in |- *.

*****
h : hedge
*****
inclusion (analysis_def (irreducible h)) (analysis_def h)
+++++
apply ana_irr_incl_ana.
-----
Lemma irr_incl_irr_irr : forall h : hedge, inclusion (irreducible h) (irreducible (irreducible h)).
unfold irreducible in |- *.
intros.
apply inclusion_le_h_impl_inclusion_red.
apply le_h_trans with (analysis_def h).

*****
h : hedge
*****
le_h (analysis_def h) (reduce (analysis_def h))
+++++
fold (irreducible h) in |- *.
-----
Lemma irr_incl_irr_irr : forall h : hedge, inclusion (irreducible h) (irreducible (irreducible h)).
unfold irreducible in |- *.
intros.
apply inclusion_le_h_impl_inclusion_red.
apply le_h_trans with (analysis_def h).
fold (irreducible h) in |- *.

*****
h : hedge
*****
le_h (analysis_def h) (irreducible h)
+++++
generalize ana_h_equiv_irr_h.
-----
Lemma irr_incl_irr_irr : forall h : hedge, inclusion (irreducible h) (irreducible (irreducible h)).
unfold irreducible in |- *.
intros.
apply inclusion_le_h_impl_inclusion_red.
apply le_h_trans with (analysis_def h).
fold (irreducible h) in |- *.
generalize ana_h_equiv_irr_h.

*****
h : hedge
*****
forall _ : forall h : hedge, equiv_h (analysis_def h) (irreducible h), le_h (analysis_def h) (irreducible h)
+++++
unfold equiv_h in |- *.
-----
Lemma irr_incl_irr_irr : forall h : hedge, inclusion (irreducible h) (irreducible (irreducible h)).
unfold irreducible in |- *.
intros.
apply inclusion_le_h_impl_inclusion_red.
apply le_h_trans with (analysis_def h).
fold (irreducible h) in |- *.
generalize ana_h_equiv_irr_h.
unfold equiv_h in |- *.

*****
h : hedge
*****
forall _ : forall h : hedge, and (le_h (analysis_def h) (irreducible h)) (le_h (irreducible h) (analysis_def h)), le_h (analysis_def h) (irreducible h)
+++++
intros.
-----
Lemma irr_incl_irr_irr : forall h : hedge, inclusion (irreducible h) (irreducible (irreducible h)).
unfold irreducible in |- *.
intros.
apply inclusion_le_h_impl_inclusion_red.
apply le_h_trans with (analysis_def h).
fold (irreducible h) in |- *.
generalize ana_h_equiv_irr_h.
unfold equiv_h in |- *.
intros.

*****
H : forall h : hedge,\nand (le_h (analysis_def h) (irreducible h))\n (le_h (irreducible h) (analysis_def h))
h : hedge
*****
le_h (analysis_def h) (irreducible h)
+++++
elim (H h).
-----
Lemma irr_incl_irr_irr : forall h : hedge, inclusion (irreducible h) (irreducible (irreducible h)).
unfold irreducible in |- *.
intros.
apply inclusion_le_h_impl_inclusion_red.
apply le_h_trans with (analysis_def h).
fold (irreducible h) in |- *.
generalize ana_h_equiv_irr_h.
unfold equiv_h in |- *.
intros.
elim (H h).

*****
H : forall h : hedge,\nand (le_h (analysis_def h) (irreducible h))\n (le_h (irreducible h) (analysis_def h))
h : hedge
*****
forall (_ : le_h (analysis_def h) (irreducible h)) (_ : le_h (irreducible h) (analysis_def h)), le_h (analysis_def h) (irreducible h)
+++++
auto.
-----
Lemma irr_incl_irr_irr : forall h : hedge, inclusion (irreducible h) (irreducible (irreducible h)).
unfold irreducible in |- *.
intros.
apply inclusion_le_h_impl_inclusion_red.

*****

*****

+++++
Qed.
-----
Theorem irreducible_is_irreducible :\n forall h : hedge, is_irreducible (irreducible h).
-----
Theorem irreducible_is_irreducible : forall h : hedge, is_irreducible (irreducible h).

*****

*****
forall h : hedge, is_irreducible (irreducible h)
+++++
unfold is_irreducible in |- *.
-----
Theorem irreducible_is_irreducible : forall h : hedge, is_irreducible (irreducible h).
unfold is_irreducible in |- *.

*****

*****
forall h : hedge, equal (irreducible h) (irreducible (irreducible h))
+++++
unfold equal in |- *.
-----
Theorem irreducible_is_irreducible : forall h : hedge, is_irreducible (irreducible h).
unfold is_irreducible in |- *.
unfold equal in |- *.

*****

*****
forall h : hedge, and (inclusion (irreducible h) (irreducible (irreducible h))) (inclusion (irreducible (irreducible h)) (irreducible h))
+++++
intros.
-----
Theorem irreducible_is_irreducible : forall h : hedge, is_irreducible (irreducible h).
unfold is_irreducible in |- *.
unfold equal in |- *.
intros.

*****
h : hedge
*****
and (inclusion (irreducible h) (irreducible (irreducible h))) (inclusion (irreducible (irreducible h)) (irreducible h))
+++++
generalize (irr_incl_irr_irr h).
-----
Theorem irreducible_is_irreducible : forall h : hedge, is_irreducible (irreducible h).
unfold is_irreducible in |- *.
unfold equal in |- *.
intros.
generalize (irr_incl_irr_irr h).

*****
h : hedge
*****
forall _ : inclusion (irreducible h) (irreducible (irreducible h)), and (inclusion (irreducible h) (irreducible (irreducible h))) (inclusion (irreducible (irreducible h)) (irreducible h))
+++++
generalize (irr_irr_incl_irr h).
-----
Theorem irreducible_is_irreducible : forall h : hedge, is_irreducible (irreducible h).
unfold is_irreducible in |- *.
unfold equal in |- *.
intros.
generalize (irr_incl_irr_irr h).
generalize (irr_irr_incl_irr h).

*****
h : hedge
*****
forall (_ : inclusion (irreducible (irreducible h)) (irreducible h)) (_ : inclusion (irreducible h) (irreducible (irreducible h))), and (inclusion (irreducible h) (irreducible (irreducible h))) (inclusion (irreducible (irreducible h)) (irreducible h))
+++++
tauto.
-----
Theorem irreducible_is_irreducible : forall h : hedge, is_irreducible (irreducible h).
unfold is_irreducible in |- *.
unfold equal in |- *.
intros.
generalize (irr_incl_irr_irr h).
generalize (irr_irr_incl_irr h).
tauto.

*****

*****

+++++
Qed.
-----
Theorem equiv_irr_impl_incl :\n forall g h : hedge, equiv_h g h -> is_irreducible g -> inclusion g h.
-----
Theorem equiv_irr_impl_incl : forall g h : hedge, equiv_h g h -> is_irreducible g -> inclusion g h.

*****

*****
forall (g h : hedge) (_ : equiv_h g h) (_ : is_irreducible g), inclusion g h
+++++
unfold is_irreducible in |- *.
-----
Theorem equiv_irr_impl_incl : forall g h : hedge, equiv_h g h -> is_irreducible g -> inclusion g h.
unfold is_irreducible in |- *.

*****

*****
forall (g h : hedge) (_ : equiv_h g h) (_ : equal g (irreducible g)), inclusion g h
+++++
unfold irreducible in |- *.
-----
Theorem equiv_irr_impl_incl : forall g h : hedge, equiv_h g h -> is_irreducible g -> inclusion g h.
unfold is_irreducible in |- *.
unfold irreducible in |- *.

*****

*****
forall (g h : hedge) (_ : equiv_h g h) (_ : equal g (reduce (analysis_def g))), inclusion g h
+++++
intros.
-----
Theorem equiv_irr_impl_incl : forall g h : hedge, equiv_h g h -> is_irreducible g -> inclusion g h.
unfold is_irreducible in |- *.
unfold irreducible in |- *.
intros.

*****
H0 : equal g (reduce (analysis_def g))
H : equiv_h g h
g,h : hedge
*****
inclusion g h
+++++
apply inclusion_trans with (reduce (analysis_def g)).
-----
Theorem equiv_irr_impl_incl : forall g h : hedge, equiv_h g h -> is_irreducible g -> inclusion g h.
unfold is_irreducible in |- *.
unfold irreducible in |- *.
intros.
apply inclusion_trans with (reduce (analysis_def g)).

*****
H0 : equal g (reduce (analysis_def g))
H : equiv_h g h
g,h : hedge
*****
inclusion g (reduce (analysis_def g))
+++++
unfold equal in H0.
-----
Theorem equiv_irr_impl_incl : forall g h : hedge, equiv_h g h -> is_irreducible g -> inclusion g h.
unfold is_irreducible in |- *.
unfold irreducible in |- *.
intros.
apply inclusion_trans with (reduce (analysis_def g)).
unfold equal in H0.

*****
H0 : and (inclusion g (reduce (analysis_def g)))\n (inclusion (reduce (analysis_def g)) g)
H : equiv_h g h
g,h : hedge
*****
inclusion g (reduce (analysis_def g))
+++++
tauto.
-----
Theorem equiv_irr_impl_incl : forall g h : hedge, equiv_h g h -> is_irreducible g -> inclusion g h.
unfold is_irreducible in |- *.
unfold irreducible in |- *.
intros.
apply inclusion_trans with (reduce (analysis_def g)).

*****
H0 : equal g (reduce (analysis_def g))
H : equiv_h g h
g,h : hedge
*****
inclusion (reduce (analysis_def g)) h
+++++
apply red_equiv_impl_red_incl.
-----
Theorem equiv_irr_impl_incl : forall g h : hedge, equiv_h g h -> is_irreducible g -> inclusion g h.
unfold is_irreducible in |- *.
unfold irreducible in |- *.
intros.
apply inclusion_trans with (reduce (analysis_def g)).
apply red_equiv_impl_red_incl.

*****
H0 : equal g (reduce (analysis_def g))
H : equiv_h g h
g,h : hedge
*****
equiv_h (reduce (analysis_def g)) h
+++++
apply equiv_h_trans with g.
-----
Theorem equiv_irr_impl_incl : forall g h : hedge, equiv_h g h -> is_irreducible g -> inclusion g h.
unfold is_irreducible in |- *.
unfold irreducible in |- *.
intros.
apply inclusion_trans with (reduce (analysis_def g)).
apply red_equiv_impl_red_incl.
apply equiv_h_trans with g.

*****
H0 : equal g (reduce (analysis_def g))
H : equiv_h g h
g,h : hedge
*****
equiv_h (reduce (analysis_def g)) g
+++++
apply equal_impl_equiv_h.
-----
Theorem equiv_irr_impl_incl : forall g h : hedge, equiv_h g h -> is_irreducible g -> inclusion g h.
unfold is_irreducible in |- *.
unfold irreducible in |- *.
intros.
apply inclusion_trans with (reduce (analysis_def g)).
apply red_equiv_impl_red_incl.
apply equiv_h_trans with g.
apply equal_impl_equiv_h.

*****
H0 : equal g (reduce (analysis_def g))
H : equiv_h g h
g,h : hedge
*****
equal (reduce (analysis_def g)) g
+++++
apply equal_sym.
-----
Theorem equiv_irr_impl_incl : forall g h : hedge, equiv_h g h -> is_irreducible g -> inclusion g h.
unfold is_irreducible in |- *.
unfold irreducible in |- *.
intros.
apply inclusion_trans with (reduce (analysis_def g)).
apply red_equiv_impl_red_incl.
apply equiv_h_trans with g.
apply equal_impl_equiv_h.
apply equal_sym.

*****
H0 : equal g (reduce (analysis_def g))
H : equiv_h g h
g,h : hedge
*****
equal g (reduce (analysis_def g))
+++++
trivial.
-----
Theorem equiv_irr_impl_incl : forall g h : hedge, equiv_h g h -> is_irreducible g -> inclusion g h.
unfold is_irreducible in |- *.
unfold irreducible in |- *.
intros.
apply inclusion_trans with (reduce (analysis_def g)).
apply red_equiv_impl_red_incl.
apply equiv_h_trans with g.

*****
H0 : equal g (reduce (analysis_def g))
H : equiv_h g h
g,h : hedge
*****
equiv_h g h
+++++
trivial.
-----
Theorem equiv_irr_impl_incl : forall g h : hedge, equiv_h g h -> is_irreducible g -> inclusion g h.
unfold is_irreducible in |- *.
unfold irreducible in |- *.
intros.
apply inclusion_trans with (reduce (analysis_def g)).

*****

*****

+++++
Qed.
-----
Theorem equiv_irr_irr_impl_equal :\n forall g h : hedge,\n equiv_h g h -> is_irreducible g -> is_irreducible h -> equal g h.
-----
Theorem equiv_irr_irr_impl_equal : forall g h : hedge, equiv_h g h -> is_irreducible g -> is_irreducible h -> equal g h.

*****

*****
forall (g h : hedge) (_ : equiv_h g h) (_ : is_irreducible g) (_ : is_irreducible h), equal g h
+++++
intros.
-----
Theorem equiv_irr_irr_impl_equal : forall g h : hedge, equiv_h g h -> is_irreducible g -> is_irreducible h -> equal g h.
intros.

*****
H1 : is_irreducible h
H0 : is_irreducible g
H : equiv_h g h
g,h : hedge
*****
equal g h
+++++
unfold equal in |- *.
-----
Theorem equiv_irr_irr_impl_equal : forall g h : hedge, equiv_h g h -> is_irreducible g -> is_irreducible h -> equal g h.
intros.
unfold equal in |- *.

*****
H1 : is_irreducible h
H0 : is_irreducible g
H : equiv_h g h
g,h : hedge
*****
and (inclusion g h) (inclusion h g)
+++++
split.
-----
Theorem equiv_irr_irr_impl_equal : forall g h : hedge, equiv_h g h -> is_irreducible g -> is_irreducible h -> equal g h.
intros.
unfold equal in |- *.
split.

*****
H1 : is_irreducible h
H0 : is_irreducible g
H : equiv_h g h
g,h : hedge
*****
inclusion g h
+++++
apply equiv_irr_impl_incl.
-----
Theorem equiv_irr_irr_impl_equal : forall g h : hedge, equiv_h g h -> is_irreducible g -> is_irreducible h -> equal g h.
intros.
unfold equal in |- *.
split.
apply equiv_irr_impl_incl.

*****
H1 : is_irreducible h
H0 : is_irreducible g
H : equiv_h g h
g,h : hedge
*****
equiv_h g h
+++++
trivial.
-----
Theorem equiv_irr_irr_impl_equal : forall g h : hedge, equiv_h g h -> is_irreducible g -> is_irreducible h -> equal g h.
intros.
unfold equal in |- *.
split.
apply equiv_irr_impl_incl.

*****
H1 : is_irreducible h
H0 : is_irreducible g
H : equiv_h g h
g,h : hedge
*****
is_irreducible g
+++++
trivial.
-----
Theorem equiv_irr_irr_impl_equal : forall g h : hedge, equiv_h g h -> is_irreducible g -> is_irreducible h -> equal g h.
intros.
unfold equal in |- *.
split.

*****
H1 : is_irreducible h
H0 : is_irreducible g
H : equiv_h g h
g,h : hedge
*****
inclusion h g
+++++
apply equiv_irr_impl_incl.
-----
Theorem equiv_irr_irr_impl_equal : forall g h : hedge, equiv_h g h -> is_irreducible g -> is_irreducible h -> equal g h.
intros.
unfold equal in |- *.
split.
apply equiv_irr_impl_incl.

*****
H1 : is_irreducible h
H0 : is_irreducible g
H : equiv_h g h
g,h : hedge
*****
equiv_h h g
+++++
trivial.
-----
Theorem equiv_irr_irr_impl_equal : forall g h : hedge, equiv_h g h -> is_irreducible g -> is_irreducible h -> equal g h.
intros.
unfold equal in |- *.
split.
apply equiv_irr_impl_incl.
trivial.

*****
H1 : is_irreducible h
H0 : is_irreducible g
H : equiv_h g h
g,h : hedge
*****
equiv_h h g
+++++
apply equiv_h_sym.
-----
Theorem equiv_irr_irr_impl_equal : forall g h : hedge, equiv_h g h -> is_irreducible g -> is_irreducible h -> equal g h.
intros.
unfold equal in |- *.
split.
apply equiv_irr_impl_incl.
trivial.
apply equiv_h_sym.

*****
H1 : is_irreducible h
H0 : is_irreducible g
H : equiv_h g h
g,h : hedge
*****
equiv_h g h
+++++
trivial.
-----
Theorem equiv_irr_irr_impl_equal : forall g h : hedge, equiv_h g h -> is_irreducible g -> is_irreducible h -> equal g h.
intros.
unfold equal in |- *.
split.
apply equiv_irr_impl_incl.

*****
H1 : is_irreducible h
H0 : is_irreducible g
H : equiv_h g h
g,h : hedge
*****
is_irreducible h
+++++
trivial.
-----
Theorem equiv_irr_irr_impl_equal : forall g h : hedge, equiv_h g h -> is_irreducible g -> is_irreducible h -> equal g h.
intros.
unfold equal in |- *.
split.

*****

*****

+++++
Qed.
-----
Lemma h_le_h_analysis : forall h : hedge, le_h h (analysis h).
-----
Lemma h_le_h_analysis : forall h : hedge, le_h h (analysis h).

*****

*****
forall h : hedge, le_h h (analysis h)
+++++
intro.
-----
Lemma h_le_h_analysis : forall h : hedge, le_h h (analysis h).
intro.

*****
h : hedge
*****
le_h h (analysis h)
+++++
apply inclusion_impl_le_h.
-----
Lemma h_le_h_analysis : forall h : hedge, le_h h (analysis h).
intro.
apply inclusion_impl_le_h.

*****
h : hedge
*****
inclusion h (analysis h)
+++++
unfold inclusion in |- *.
-----
Lemma h_le_h_analysis : forall h : hedge, le_h h (analysis h).
intro.
apply inclusion_impl_le_h.
unfold inclusion in |- *.

*****
h : hedge
*****
forall (M N : Msg) (_ : h M N), analysis h M N
+++++
intros.
-----
Lemma h_le_h_analysis : forall h : hedge, le_h h (analysis h).
intro.
apply inclusion_impl_le_h.
unfold inclusion in |- *.
intros.

*****
H : h M N
M,N : Msg
h : hedge
*****
analysis h M N
+++++
apply AnaInc.
-----
Lemma h_le_h_analysis : forall h : hedge, le_h h (analysis h).
intro.
apply inclusion_impl_le_h.
unfold inclusion in |- *.
intros.
apply AnaInc.

*****
H : h M N
M,N : Msg
h : hedge
*****
h M N
+++++
trivial.
-----
Lemma h_le_h_analysis : forall h : hedge, le_h h (analysis h).
intro.
apply inclusion_impl_le_h.
unfold inclusion in |- *.
intros.
apply AnaInc.
trivial.

*****

*****

+++++
Qed.
-----
Lemma synthesis_idempotent :\n forall h : hedge, equal (synthesis h) (synthesis (synthesis h)).
-----
Lemma synthesis_idempotent : forall h : hedge, equal (synthesis h) (synthesis (synthesis h)).

*****

*****
forall h : hedge, equal (synthesis h) (synthesis (synthesis h))
+++++
unfold equal in |- *.
-----
Lemma synthesis_idempotent : forall h : hedge, equal (synthesis h) (synthesis (synthesis h)).
unfold equal in |- *.

*****

*****
forall h : hedge, and (inclusion (synthesis h) (synthesis (synthesis h))) (inclusion (synthesis (synthesis h)) (synthesis h))
+++++
split.
-----
Lemma synthesis_idempotent : forall h : hedge, equal (synthesis h) (synthesis (synthesis h)).
unfold equal in |- *.
split.

*****
h : hedge
*****
inclusion (synthesis h) (synthesis (synthesis h))
+++++
unfold inclusion in |- *.
-----
Lemma synthesis_idempotent : forall h : hedge, equal (synthesis h) (synthesis (synthesis h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.

*****
h : hedge
*****
forall (M N : Msg) (_ : synthesis h M N), synthesis (synthesis h) M N
+++++
intros.
-----
Lemma synthesis_idempotent : forall h : hedge, equal (synthesis h) (synthesis (synthesis h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
intros.

*****
H : synthesis h M N
M,N : Msg
h : hedge
*****
synthesis (synthesis h) M N
+++++
apply SynInc.
-----
Lemma synthesis_idempotent : forall h : hedge, equal (synthesis h) (synthesis (synthesis h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
intros.
apply SynInc.

*****
H : synthesis h M N
M,N : Msg
h : hedge
*****
synthesis h M N
+++++
trivial.
-----
Lemma synthesis_idempotent : forall h : hedge, equal (synthesis h) (synthesis (synthesis h)).
unfold equal in |- *.
split.

*****
h : hedge
*****
inclusion (synthesis (synthesis h)) (synthesis h)
+++++
generalize (incl_syn_impl_le_h (synthesis h) h).
-----
Lemma synthesis_idempotent : forall h : hedge, equal (synthesis h) (synthesis (synthesis h)).
unfold equal in |- *.
split.
generalize (incl_syn_impl_le_h (synthesis h) h).

*****
h : hedge
*****
forall _ : forall _ : inclusion (synthesis h) (synthesis h), le_h (synthesis h) h, inclusion (synthesis (synthesis h)) (synthesis h)
+++++
unfold le_h in |- *.
-----
Lemma synthesis_idempotent : forall h : hedge, equal (synthesis h) (synthesis (synthesis h)).
unfold equal in |- *.
split.
generalize (incl_syn_impl_le_h (synthesis h) h).
unfold le_h in |- *.

*****
h : hedge
*****
forall _ : forall _ : inclusion (synthesis h) (synthesis h), inclusion (synthesis (synthesis h)) (synthesis h), inclusion (synthesis (synthesis h)) (synthesis h)
+++++
intros.
-----
Lemma synthesis_idempotent : forall h : hedge, equal (synthesis h) (synthesis (synthesis h)).
unfold equal in |- *.
split.
generalize (incl_syn_impl_le_h (synthesis h) h).
unfold le_h in |- *.
intros.

*****
H : forall _ : inclusion (synthesis h) (synthesis h),\ninclusion (synthesis (synthesis h)) (synthesis h)
h : hedge
*****
inclusion (synthesis (synthesis h)) (synthesis h)
+++++
apply H.
-----
Lemma synthesis_idempotent : forall h : hedge, equal (synthesis h) (synthesis (synthesis h)).
unfold equal in |- *.
split.
generalize (incl_syn_impl_le_h (synthesis h) h).
unfold le_h in |- *.
intros.
apply H.

*****
H : forall _ : inclusion (synthesis h) (synthesis h),\ninclusion (synthesis (synthesis h)) (synthesis h)
h : hedge
*****
inclusion (synthesis h) (synthesis h)
+++++
apply inclusion_refl.
-----
Lemma synthesis_idempotent : forall h : hedge, equal (synthesis h) (synthesis (synthesis h)).
unfold equal in |- *.
split.

*****

*****

+++++
Qed.
-----
Lemma stable_ana_impl_stable_syn_ana :\n forall h : hedge, stable_analysis h -> stable_analysis (synthesis h).
-----
Lemma stable_ana_impl_stable_syn_ana : forall h : hedge, stable_analysis h -> stable_analysis (synthesis h).

*****

*****
forall (h : hedge) (_ : stable_analysis h), stable_analysis (synthesis h)
+++++
unfold stable_analysis in |- *.
-----
Lemma stable_ana_impl_stable_syn_ana : forall h : hedge, stable_analysis h -> stable_analysis (synthesis h).
unfold stable_analysis in |- *.

*****

*****
forall (h : hedge) (_ : inclusion (analysis h) h), inclusion (analysis (synthesis h)) (synthesis h)
+++++
unfold inclusion in |- *.
-----
Lemma stable_ana_impl_stable_syn_ana : forall h : hedge, stable_analysis h -> stable_analysis (synthesis h).
unfold stable_analysis in |- *.
unfold inclusion in |- *.

*****

*****
forall (h : hedge) (_ : forall (M N : Msg) (_ : analysis h M N), h M N) (M N : Msg) (_ : analysis (synthesis h) M N), synthesis h M N
+++++
intros.
-----
Lemma stable_ana_impl_stable_syn_ana : forall h : hedge, stable_analysis h -> stable_analysis (synthesis h).
unfold stable_analysis in |- *.
unfold inclusion in |- *.
intros.

*****
H0 : analysis (synthesis h) M N
M,N : Msg
H : forall (M N : Msg) (_ : analysis h M N), h M N
h : hedge
*****
synthesis h M N
+++++
induction H0 as [M N H0| M1 M2 N1 N2 H0 HrecH0| M1 M2 N1 N2 H0 HrecH0| M N K L H0 HrecH0 H1].
-----
Lemma stable_ana_impl_stable_syn_ana : forall h : hedge, stable_analysis h -> stable_analysis (synthesis h).
unfold stable_analysis in |- *.
unfold inclusion in |- *.
intros.
induction H0 as [M N H0| M1 M2 N1 N2 H0 HrecH0| M1 M2 N1 N2 H0 HrecH0| M N K L H0 HrecH0 H1].

*****
H0 : synthesis h M N
M,N : Msg
H : forall (M N : Msg) (_ : analysis h M N), h M N
h : hedge
*****
synthesis h M N
+++++
trivial.
-----
Lemma stable_ana_impl_stable_syn_ana : forall h : hedge, stable_analysis h -> stable_analysis (synthesis h).
unfold stable_analysis in |- *.
unfold inclusion in |- *.
intros.
induction H0 as [M N H0| M1 M2 N1 N2 H0 HrecH0| M1 M2 N1 N2 H0 HrecH0| M N K L H0 HrecH0 H1].

*****
HrecH0 : synthesis h (MPair M1 M2) (MPair N1 N2)
H0 : analysis (synthesis h) (MPair M1 M2) (MPair N1 N2)
M1,M2,N1,N2 : Msg
H : forall (M N : Msg) (_ : analysis h M N), h M N
h : hedge
*****
synthesis h M1 N1
+++++
trivial.
-----
Lemma stable_ana_impl_stable_syn_ana : forall h : hedge, stable_analysis h -> stable_analysis (synthesis h).
unfold stable_analysis in |- *.
unfold inclusion in |- *.
intros.
induction H0 as [M N H0| M1 M2 N1 N2 H0 HrecH0| M1 M2 N1 N2 H0 HrecH0| M N K L H0 HrecH0 H1].
trivial.

*****
HrecH0 : synthesis h (MPair M1 M2) (MPair N1 N2)
H0 : analysis (synthesis h) (MPair M1 M2) (MPair N1 N2)
M1,M2,N1,N2 : Msg
H : forall (M N : Msg) (_ : analysis h M N), h M N
h : hedge
*****
synthesis h M1 N1
+++++
inversion HrecH0.
-----
Lemma stable_ana_impl_stable_syn_ana : forall h : hedge, stable_analysis h -> stable_analysis (synthesis h).
unfold stable_analysis in |- *.
unfold inclusion in |- *.
intros.
induction H0 as [M N H0| M1 M2 N1 N2 H0 HrecH0| M1 M2 N1 N2 H0 HrecH0| M N K L H0 HrecH0 H1].
trivial.
inversion HrecH0.

*****
H3 : eq N (MPair N1 N2)
H2 : eq M (MPair M1 M2)
H1 : h (MPair M1 M2) (MPair N1 N2)
M,N : Msg
HrecH0 : synthesis h (MPair M1 M2) (MPair N1 N2)
H0 : analysis (synthesis h) (MPair M1 M2) (MPair N1 N2)
M1,M2,N1,N2 : Msg
H : forall (M N : Msg) (_ : analysis h M N), h M N
h : hedge
*****
synthesis h M1 N1
+++++
trivial.
-----
Lemma stable_ana_impl_stable_syn_ana : forall h : hedge, stable_analysis h -> stable_analysis (synthesis h).
unfold stable_analysis in |- *.
unfold inclusion in |- *.
intros.
induction H0 as [M N H0| M1 M2 N1 N2 H0 HrecH0| M1 M2 N1 N2 H0 HrecH0| M N K L H0 HrecH0 H1].
trivial.
inversion HrecH0.
trivial.

*****
H3 : eq N (MPair N1 N2)
H2 : eq M (MPair M1 M2)
H1 : h (MPair M1 M2) (MPair N1 N2)
M,N : Msg
HrecH0 : synthesis h (MPair M1 M2) (MPair N1 N2)
H0 : analysis (synthesis h) (MPair M1 M2) (MPair N1 N2)
M1,M2,N1,N2 : Msg
H : forall (M N : Msg) (_ : analysis h M N), h M N
h : hedge
*****
synthesis h M1 N1
+++++
apply SynInc.
-----
Lemma stable_ana_impl_stable_syn_ana : forall h : hedge, stable_analysis h -> stable_analysis (synthesis h).
unfold stable_analysis in |- *.
unfold inclusion in |- *.
intros.
induction H0 as [M N H0| M1 M2 N1 N2 H0 HrecH0| M1 M2 N1 N2 H0 HrecH0| M N K L H0 HrecH0 H1].
trivial.
inversion HrecH0.
trivial.
apply SynInc.

*****
H3 : eq N (MPair N1 N2)
H2 : eq M (MPair M1 M2)
H1 : h (MPair M1 M2) (MPair N1 N2)
M,N : Msg
HrecH0 : synthesis h (MPair M1 M2) (MPair N1 N2)
H0 : analysis (synthesis h) (MPair M1 M2) (MPair N1 N2)
M1,M2,N1,N2 : Msg
H : forall (M N : Msg) (_ : analysis h M N), h M N
h : hedge
*****
h M1 N1
+++++
apply H.
-----
Lemma stable_ana_impl_stable_syn_ana : forall h : hedge, stable_analysis h -> stable_analysis (synthesis h).
unfold stable_analysis in |- *.
unfold inclusion in |- *.
intros.
induction H0 as [M N H0| M1 M2 N1 N2 H0 HrecH0| M1 M2 N1 N2 H0 HrecH0| M N K L H0 HrecH0 H1].
trivial.
inversion HrecH0.
trivial.
apply SynInc.
apply H.

*****
H3 : eq N (MPair N1 N2)
H2 : eq M (MPair M1 M2)
H1 : h (MPair M1 M2) (MPair N1 N2)
M,N : Msg
HrecH0 : synthesis h (MPair M1 M2) (MPair N1 N2)
H0 : analysis (synthesis h) (MPair M1 M2) (MPair N1 N2)
M1,M2,N1,N2 : Msg
H : forall (M N : Msg) (_ : analysis h M N), h M N
h : hedge
*****
analysis h M1 N1
+++++
apply (AnaSplitL h M1 M2 N1 N2).
-----
Lemma stable_ana_impl_stable_syn_ana : forall h : hedge, stable_analysis h -> stable_analysis (synthesis h).
unfold stable_analysis in |- *.
unfold inclusion in |- *.
intros.
induction H0 as [M N H0| M1 M2 N1 N2 H0 HrecH0| M1 M2 N1 N2 H0 HrecH0| M N K L H0 HrecH0 H1].
trivial.
inversion HrecH0.
trivial.
apply SynInc.
apply H.
apply (AnaSplitL h M1 M2 N1 N2).

*****
H3 : eq N (MPair N1 N2)
H2 : eq M (MPair M1 M2)
H1 : h (MPair M1 M2) (MPair N1 N2)
M,N : Msg
HrecH0 : synthesis h (MPair M1 M2) (MPair N1 N2)
H0 : analysis (synthesis h) (MPair M1 M2) (MPair N1 N2)
M1,M2,N1,N2 : Msg
H : forall (M N : Msg) (_ : analysis h M N), h M N
h : hedge
*****
analysis h (MPair M1 M2) (MPair N1 N2)
+++++
apply AnaInc.
-----
Lemma stable_ana_impl_stable_syn_ana : forall h : hedge, stable_analysis h -> stable_analysis (synthesis h).
unfold stable_analysis in |- *.
unfold inclusion in |- *.
intros.
induction H0 as [M N H0| M1 M2 N1 N2 H0 HrecH0| M1 M2 N1 N2 H0 HrecH0| M N K L H0 HrecH0 H1].
trivial.
inversion HrecH0.
trivial.
apply SynInc.
apply H.
apply (AnaSplitL h M1 M2 N1 N2).
apply AnaInc.

*****
H3 : eq N (MPair N1 N2)
H2 : eq M (MPair M1 M2)
H1 : h (MPair M1 M2) (MPair N1 N2)
M,N : Msg
HrecH0 : synthesis h (MPair M1 M2) (MPair N1 N2)
H0 : analysis (synthesis h) (MPair M1 M2) (MPair N1 N2)
M1,M2,N1,N2 : Msg
H : forall (M N : Msg) (_ : analysis h M N), h M N
h : hedge
*****
h (MPair M1 M2) (MPair N1 N2)
+++++
trivial.
-----
Lemma stable_ana_impl_stable_syn_ana : forall h : hedge, stable_analysis h -> stable_analysis (synthesis h).
unfold stable_analysis in |- *.
unfold inclusion in |- *.
intros.
induction H0 as [M N H0| M1 M2 N1 N2 H0 HrecH0| M1 M2 N1 N2 H0 HrecH0| M N K L H0 HrecH0 H1].
trivial.
inversion HrecH0.

*****
H5 : eq N3 N2
H3 : eq N0 N1
H2 : eq M3 M2
H1 : eq M0 M1
H6 : synthesis h M2 N2
H4 : synthesis h M1 N1
M0,N0,M3,N3 : Msg
HrecH0 : synthesis h (MPair M1 M2) (MPair N1 N2)
H0 : analysis (synthesis h) (MPair M1 M2) (MPair N1 N2)
M1,M2,N1,N2 : Msg
H : forall (M N : Msg) (_ : analysis h M N), h M N
h : hedge
*****
synthesis h M1 N1
+++++
trivial.
-----
Lemma stable_ana_impl_stable_syn_ana : forall h : hedge, stable_analysis h -> stable_analysis (synthesis h).
unfold stable_analysis in |- *.
unfold inclusion in |- *.
intros.
induction H0 as [M N H0| M1 M2 N1 N2 H0 HrecH0| M1 M2 N1 N2 H0 HrecH0| M N K L H0 HrecH0 H1].

*****
HrecH0 : synthesis h (MPair M1 M2) (MPair N1 N2)
H0 : analysis (synthesis h) (MPair M1 M2) (MPair N1 N2)
M1,M2,N1,N2 : Msg
H : forall (M N : Msg) (_ : analysis h M N), h M N
h : hedge
*****
synthesis h M2 N2
+++++
trivial.
-----
Lemma stable_ana_impl_stable_syn_ana : forall h : hedge, stable_analysis h -> stable_analysis (synthesis h).
unfold stable_analysis in |- *.
unfold inclusion in |- *.
intros.
induction H0 as [M N H0| M1 M2 N1 N2 H0 HrecH0| M1 M2 N1 N2 H0 HrecH0| M N K L H0 HrecH0 H1].
trivial.

*****
HrecH0 : synthesis h (MPair M1 M2) (MPair N1 N2)
H0 : analysis (synthesis h) (MPair M1 M2) (MPair N1 N2)
M1,M2,N1,N2 : Msg
H : forall (M N : Msg) (_ : analysis h M N), h M N
h : hedge
*****
synthesis h M2 N2
+++++
inversion HrecH0.
-----
Lemma stable_ana_impl_stable_syn_ana : forall h : hedge, stable_analysis h -> stable_analysis (synthesis h).
unfold stable_analysis in |- *.
unfold inclusion in |- *.
intros.
induction H0 as [M N H0| M1 M2 N1 N2 H0 HrecH0| M1 M2 N1 N2 H0 HrecH0| M N K L H0 HrecH0 H1].
trivial.
inversion HrecH0.

*****
H3 : eq N (MPair N1 N2)
H2 : eq M (MPair M1 M2)
H1 : h (MPair M1 M2) (MPair N1 N2)
M,N : Msg
HrecH0 : synthesis h (MPair M1 M2) (MPair N1 N2)
H0 : analysis (synthesis h) (MPair M1 M2) (MPair N1 N2)
M1,M2,N1,N2 : Msg
H : forall (M N : Msg) (_ : analysis h M N), h M N
h : hedge
*****
synthesis h M2 N2
+++++
trivial.
-----
Lemma stable_ana_impl_stable_syn_ana : forall h : hedge, stable_analysis h -> stable_analysis (synthesis h).
unfold stable_analysis in |- *.
unfold inclusion in |- *.
intros.
induction H0 as [M N H0| M1 M2 N1 N2 H0 HrecH0| M1 M2 N1 N2 H0 HrecH0| M N K L H0 HrecH0 H1].
trivial.
inversion HrecH0.
trivial.

*****
H3 : eq N (MPair N1 N2)
H2 : eq M (MPair M1 M2)
H1 : h (MPair M1 M2) (MPair N1 N2)
M,N : Msg
HrecH0 : synthesis h (MPair M1 M2) (MPair N1 N2)
H0 : analysis (synthesis h) (MPair M1 M2) (MPair N1 N2)
M1,M2,N1,N2 : Msg
H : forall (M N : Msg) (_ : analysis h M N), h M N
h : hedge
*****
synthesis h M2 N2
+++++
apply SynInc.
-----
Lemma stable_ana_impl_stable_syn_ana : forall h : hedge, stable_analysis h -> stable_analysis (synthesis h).
unfold stable_analysis in |- *.
unfold inclusion in |- *.
intros.
induction H0 as [M N H0| M1 M2 N1 N2 H0 HrecH0| M1 M2 N1 N2 H0 HrecH0| M N K L H0 HrecH0 H1].
trivial.
inversion HrecH0.
trivial.
apply SynInc.

*****
H3 : eq N (MPair N1 N2)
H2 : eq M (MPair M1 M2)
H1 : h (MPair M1 M2) (MPair N1 N2)
M,N : Msg
HrecH0 : synthesis h (MPair M1 M2) (MPair N1 N2)
H0 : analysis (synthesis h) (MPair M1 M2) (MPair N1 N2)
M1,M2,N1,N2 : Msg
H : forall (M N : Msg) (_ : analysis h M N), h M N
h : hedge
*****
h M2 N2
+++++
apply H.
-----
Lemma stable_ana_impl_stable_syn_ana : forall h : hedge, stable_analysis h -> stable_analysis (synthesis h).
unfold stable_analysis in |- *.
unfold inclusion in |- *.
intros.
induction H0 as [M N H0| M1 M2 N1 N2 H0 HrecH0| M1 M2 N1 N2 H0 HrecH0| M N K L H0 HrecH0 H1].
trivial.
inversion HrecH0.
trivial.
apply SynInc.
apply H.

*****
H3 : eq N (MPair N1 N2)
H2 : eq M (MPair M1 M2)
H1 : h (MPair M1 M2) (MPair N1 N2)
M,N : Msg
HrecH0 : synthesis h (MPair M1 M2) (MPair N1 N2)
H0 : analysis (synthesis h) (MPair M1 M2) (MPair N1 N2)
M1,M2,N1,N2 : Msg
H : forall (M N : Msg) (_ : analysis h M N), h M N
h : hedge
*****
analysis h M2 N2
+++++
apply (AnaSplitR h M1 M2 N1 N2).
-----
Lemma stable_ana_impl_stable_syn_ana : forall h : hedge, stable_analysis h -> stable_analysis (synthesis h).
unfold stable_analysis in |- *.
unfold inclusion in |- *.
intros.
induction H0 as [M N H0| M1 M2 N1 N2 H0 HrecH0| M1 M2 N1 N2 H0 HrecH0| M N K L H0 HrecH0 H1].
trivial.
inversion HrecH0.
trivial.
apply SynInc.
apply H.
apply (AnaSplitR h M1 M2 N1 N2).

*****
H3 : eq N (MPair N1 N2)
H2 : eq M (MPair M1 M2)
H1 : h (MPair M1 M2) (MPair N1 N2)
M,N : Msg
HrecH0 : synthesis h (MPair M1 M2) (MPair N1 N2)
H0 : analysis (synthesis h) (MPair M1 M2) (MPair N1 N2)
M1,M2,N1,N2 : Msg
H : forall (M N : Msg) (_ : analysis h M N), h M N
h : hedge
*****
analysis h (MPair M1 M2) (MPair N1 N2)
+++++
apply AnaInc.
-----
Lemma stable_ana_impl_stable_syn_ana : forall h : hedge, stable_analysis h -> stable_analysis (synthesis h).
unfold stable_analysis in |- *.
unfold inclusion in |- *.
intros.
induction H0 as [M N H0| M1 M2 N1 N2 H0 HrecH0| M1 M2 N1 N2 H0 HrecH0| M N K L H0 HrecH0 H1].
trivial.
inversion HrecH0.
trivial.
apply SynInc.
apply H.
apply (AnaSplitR h M1 M2 N1 N2).
apply AnaInc.

*****
H3 : eq N (MPair N1 N2)
H2 : eq M (MPair M1 M2)
H1 : h (MPair M1 M2) (MPair N1 N2)
M,N : Msg
HrecH0 : synthesis h (MPair M1 M2) (MPair N1 N2)
H0 : analysis (synthesis h) (MPair M1 M2) (MPair N1 N2)
M1,M2,N1,N2 : Msg
H : forall (M N : Msg) (_ : analysis h M N), h M N
h : hedge
*****
h (MPair M1 M2) (MPair N1 N2)
+++++
trivial.
-----
Lemma stable_ana_impl_stable_syn_ana : forall h : hedge, stable_analysis h -> stable_analysis (synthesis h).
unfold stable_analysis in |- *.
unfold inclusion in |- *.
intros.
induction H0 as [M N H0| M1 M2 N1 N2 H0 HrecH0| M1 M2 N1 N2 H0 HrecH0| M N K L H0 HrecH0 H1].
trivial.
inversion HrecH0.

*****
H5 : eq N3 N2
H3 : eq N0 N1
H2 : eq M3 M2
H1 : eq M0 M1
H6 : synthesis h M2 N2
H4 : synthesis h M1 N1
M0,N0,M3,N3 : Msg
HrecH0 : synthesis h (MPair M1 M2) (MPair N1 N2)
H0 : analysis (synthesis h) (MPair M1 M2) (MPair N1 N2)
M1,M2,N1,N2 : Msg
H : forall (M N : Msg) (_ : analysis h M N), h M N
h : hedge
*****
synthesis h M2 N2
+++++
trivial.
-----
Lemma stable_ana_impl_stable_syn_ana : forall h : hedge, stable_analysis h -> stable_analysis (synthesis h).
unfold stable_analysis in |- *.
unfold inclusion in |- *.
intros.
induction H0 as [M N H0| M1 M2 N1 N2 H0 HrecH0| M1 M2 N1 N2 H0 HrecH0| M N K L H0 HrecH0 H1].

*****
HrecH0 : synthesis h (MEnc M K) (MEnc N L)
H1 : synthesis (synthesis h) (inv K) (inv L)
H0 : analysis (synthesis h) (MEnc M K) (MEnc N L)
M,N,K,L : Msg
H : forall (M N : Msg) (_ : analysis h M N), h M N
h : hedge
*****
synthesis h M N
+++++
trivial.
-----
Lemma stable_ana_impl_stable_syn_ana : forall h : hedge, stable_analysis h -> stable_analysis (synthesis h).
unfold stable_analysis in |- *.
unfold inclusion in |- *.
intros.
induction H0 as [M N H0| M1 M2 N1 N2 H0 HrecH0| M1 M2 N1 N2 H0 HrecH0| M N K L H0 HrecH0 H1].
trivial.

*****
HrecH0 : synthesis h (MEnc M K) (MEnc N L)
H1 : synthesis (synthesis h) (inv K) (inv L)
H0 : analysis (synthesis h) (MEnc M K) (MEnc N L)
M,N,K,L : Msg
H : forall (M N : Msg) (_ : analysis h M N), h M N
h : hedge
*****
synthesis h M N
+++++
inversion HrecH0.
-----
Lemma stable_ana_impl_stable_syn_ana : forall h : hedge, stable_analysis h -> stable_analysis (synthesis h).
unfold stable_analysis in |- *.
unfold inclusion in |- *.
intros.
induction H0 as [M N H0| M1 M2 N1 N2 H0 HrecH0| M1 M2 N1 N2 H0 HrecH0| M N K L H0 HrecH0 H1].
trivial.
inversion HrecH0.

*****
H4 : eq N0 (MEnc N L)
H3 : eq M0 (MEnc M K)
H2 : h (MEnc M K) (MEnc N L)
M0,N0 : Msg
HrecH0 : synthesis h (MEnc M K) (MEnc N L)
H1 : synthesis (synthesis h) (inv K) (inv L)
H0 : analysis (synthesis h) (MEnc M K) (MEnc N L)
M,N,K,L : Msg
H : forall (M N : Msg) (_ : analysis h M N), h M N
h : hedge
*****
synthesis h M N
+++++
trivial.
-----
Lemma stable_ana_impl_stable_syn_ana : forall h : hedge, stable_analysis h -> stable_analysis (synthesis h).
unfold stable_analysis in |- *.
unfold inclusion in |- *.
intros.
induction H0 as [M N H0| M1 M2 N1 N2 H0 HrecH0| M1 M2 N1 N2 H0 HrecH0| M N K L H0 HrecH0 H1].
trivial.
inversion HrecH0.
trivial.

*****
H4 : eq N0 (MEnc N L)
H3 : eq M0 (MEnc M K)
H2 : h (MEnc M K) (MEnc N L)
M0,N0 : Msg
HrecH0 : synthesis h (MEnc M K) (MEnc N L)
H1 : synthesis (synthesis h) (inv K) (inv L)
H0 : analysis (synthesis h) (MEnc M K) (MEnc N L)
M,N,K,L : Msg
H : forall (M N : Msg) (_ : analysis h M N), h M N
h : hedge
*****
synthesis h M N
+++++
apply SynInc.
-----
Lemma stable_ana_impl_stable_syn_ana : forall h : hedge, stable_analysis h -> stable_analysis (synthesis h).
unfold stable_analysis in |- *.
unfold inclusion in |- *.
intros.
induction H0 as [M N H0| M1 M2 N1 N2 H0 HrecH0| M1 M2 N1 N2 H0 HrecH0| M N K L H0 HrecH0 H1].
trivial.
inversion HrecH0.
trivial.
apply SynInc.

*****
H4 : eq N0 (MEnc N L)
H3 : eq M0 (MEnc M K)
H2 : h (MEnc M K) (MEnc N L)
M0,N0 : Msg
HrecH0 : synthesis h (MEnc M K) (MEnc N L)
H1 : synthesis (synthesis h) (inv K) (inv L)
H0 : analysis (synthesis h) (MEnc M K) (MEnc N L)
M,N,K,L : Msg
H : forall (M N : Msg) (_ : analysis h M N), h M N
h : hedge
*****
h M N
+++++
apply H.
-----
Lemma stable_ana_impl_stable_syn_ana : forall h : hedge, stable_analysis h -> stable_analysis (synthesis h).
unfold stable_analysis in |- *.
unfold inclusion in |- *.
intros.
induction H0 as [M N H0| M1 M2 N1 N2 H0 HrecH0| M1 M2 N1 N2 H0 HrecH0| M N K L H0 HrecH0 H1].
trivial.
inversion HrecH0.
trivial.
apply SynInc.
apply H.

*****
H4 : eq N0 (MEnc N L)
H3 : eq M0 (MEnc M K)
H2 : h (MEnc M K) (MEnc N L)
M0,N0 : Msg
HrecH0 : synthesis h (MEnc M K) (MEnc N L)
H1 : synthesis (synthesis h) (inv K) (inv L)
H0 : analysis (synthesis h) (MEnc M K) (MEnc N L)
M,N,K,L : Msg
H : forall (M N : Msg) (_ : analysis h M N), h M N
h : hedge
*****
analysis h M N
+++++
apply (AnaDec h M N K L).
-----
Lemma stable_ana_impl_stable_syn_ana : forall h : hedge, stable_analysis h -> stable_analysis (synthesis h).
unfold stable_analysis in |- *.
unfold inclusion in |- *.
intros.
induction H0 as [M N H0| M1 M2 N1 N2 H0 HrecH0| M1 M2 N1 N2 H0 HrecH0| M N K L H0 HrecH0 H1].
trivial.
inversion HrecH0.
trivial.
apply SynInc.
apply H.
apply (AnaDec h M N K L).

*****
H4 : eq N0 (MEnc N L)
H3 : eq M0 (MEnc M K)
H2 : h (MEnc M K) (MEnc N L)
M0,N0 : Msg
HrecH0 : synthesis h (MEnc M K) (MEnc N L)
H1 : synthesis (synthesis h) (inv K) (inv L)
H0 : analysis (synthesis h) (MEnc M K) (MEnc N L)
M,N,K,L : Msg
H : forall (M N : Msg) (_ : analysis h M N), h M N
h : hedge
*****
analysis h (MEnc M K) (MEnc N L)
+++++
trivial.
-----
Lemma stable_ana_impl_stable_syn_ana : forall h : hedge, stable_analysis h -> stable_analysis (synthesis h).
unfold stable_analysis in |- *.
unfold inclusion in |- *.
intros.
induction H0 as [M N H0| M1 M2 N1 N2 H0 HrecH0| M1 M2 N1 N2 H0 HrecH0| M N K L H0 HrecH0 H1].
trivial.
inversion HrecH0.
trivial.
apply SynInc.
apply H.
apply (AnaDec h M N K L).
trivial.

*****
H4 : eq N0 (MEnc N L)
H3 : eq M0 (MEnc M K)
H2 : h (MEnc M K) (MEnc N L)
M0,N0 : Msg
HrecH0 : synthesis h (MEnc M K) (MEnc N L)
H1 : synthesis (synthesis h) (inv K) (inv L)
H0 : analysis (synthesis h) (MEnc M K) (MEnc N L)
M,N,K,L : Msg
H : forall (M N : Msg) (_ : analysis h M N), h M N
h : hedge
*****
analysis h (MEnc M K) (MEnc N L)
+++++
apply AnaInc.
-----
Lemma stable_ana_impl_stable_syn_ana : forall h : hedge, stable_analysis h -> stable_analysis (synthesis h).
unfold stable_analysis in |- *.
unfold inclusion in |- *.
intros.
induction H0 as [M N H0| M1 M2 N1 N2 H0 HrecH0| M1 M2 N1 N2 H0 HrecH0| M N K L H0 HrecH0 H1].
trivial.
inversion HrecH0.
trivial.
apply SynInc.
apply H.
apply (AnaDec h M N K L).
trivial.
apply AnaInc.

*****
H4 : eq N0 (MEnc N L)
H3 : eq M0 (MEnc M K)
H2 : h (MEnc M K) (MEnc N L)
M0,N0 : Msg
HrecH0 : synthesis h (MEnc M K) (MEnc N L)
H1 : synthesis (synthesis h) (inv K) (inv L)
H0 : analysis (synthesis h) (MEnc M K) (MEnc N L)
M,N,K,L : Msg
H : forall (M N : Msg) (_ : analysis h M N), h M N
h : hedge
*****
h (MEnc M K) (MEnc N L)
+++++
trivial.
-----
Lemma stable_ana_impl_stable_syn_ana : forall h : hedge, stable_analysis h -> stable_analysis (synthesis h).
unfold stable_analysis in |- *.
unfold inclusion in |- *.
intros.
induction H0 as [M N H0| M1 M2 N1 N2 H0 HrecH0| M1 M2 N1 N2 H0 HrecH0| M N K L H0 HrecH0 H1].
trivial.
inversion HrecH0.
trivial.
apply SynInc.
apply H.
apply (AnaDec h M N K L).

*****
H4 : eq N0 (MEnc N L)
H3 : eq M0 (MEnc M K)
H2 : h (MEnc M K) (MEnc N L)
M0,N0 : Msg
HrecH0 : synthesis h (MEnc M K) (MEnc N L)
H1 : synthesis (synthesis h) (inv K) (inv L)
H0 : analysis (synthesis h) (MEnc M K) (MEnc N L)
M,N,K,L : Msg
H : forall (M N : Msg) (_ : analysis h M N), h M N
h : hedge
*****
synthesis h (inv K) (inv L)
+++++
trivial.
-----
Lemma stable_ana_impl_stable_syn_ana : forall h : hedge, stable_analysis h -> stable_analysis (synthesis h).
unfold stable_analysis in |- *.
unfold inclusion in |- *.
intros.
induction H0 as [M N H0| M1 M2 N1 N2 H0 HrecH0| M1 M2 N1 N2 H0 HrecH0| M N K L H0 HrecH0 H1].
trivial.
inversion HrecH0.
trivial.
apply SynInc.
apply H.
apply (AnaDec h M N K L).
trivial.

*****
H4 : eq N0 (MEnc N L)
H3 : eq M0 (MEnc M K)
H2 : h (MEnc M K) (MEnc N L)
M0,N0 : Msg
HrecH0 : synthesis h (MEnc M K) (MEnc N L)
H1 : synthesis (synthesis h) (inv K) (inv L)
H0 : analysis (synthesis h) (MEnc M K) (MEnc N L)
M,N,K,L : Msg
H : forall (M N : Msg) (_ : analysis h M N), h M N
h : hedge
*****
synthesis h (inv K) (inv L)
+++++
generalize (synthesis_idempotent h).
-----
Lemma stable_ana_impl_stable_syn_ana : forall h : hedge, stable_analysis h -> stable_analysis (synthesis h).
unfold stable_analysis in |- *.
unfold inclusion in |- *.
intros.
induction H0 as [M N H0| M1 M2 N1 N2 H0 HrecH0| M1 M2 N1 N2 H0 HrecH0| M N K L H0 HrecH0 H1].
trivial.
inversion HrecH0.
trivial.
apply SynInc.
apply H.
apply (AnaDec h M N K L).
trivial.
generalize (synthesis_idempotent h).

*****
H4 : eq N0 (MEnc N L)
H3 : eq M0 (MEnc M K)
H2 : h (MEnc M K) (MEnc N L)
M0,N0 : Msg
HrecH0 : synthesis h (MEnc M K) (MEnc N L)
H1 : synthesis (synthesis h) (inv K) (inv L)
H0 : analysis (synthesis h) (MEnc M K) (MEnc N L)
M,N,K,L : Msg
H : forall (M N : Msg) (_ : analysis h M N), h M N
h : hedge
*****
forall _ : equal (synthesis h) (synthesis (synthesis h)), synthesis h (inv K) (inv L)
+++++
unfold equal in |- *.
-----
Lemma stable_ana_impl_stable_syn_ana : forall h : hedge, stable_analysis h -> stable_analysis (synthesis h).
unfold stable_analysis in |- *.
unfold inclusion in |- *.
intros.
induction H0 as [M N H0| M1 M2 N1 N2 H0 HrecH0| M1 M2 N1 N2 H0 HrecH0| M N K L H0 HrecH0 H1].
trivial.
inversion HrecH0.
trivial.
apply SynInc.
apply H.
apply (AnaDec h M N K L).
trivial.
generalize (synthesis_idempotent h).
unfold equal in |- *.

*****
H4 : eq N0 (MEnc N L)
H3 : eq M0 (MEnc M K)
H2 : h (MEnc M K) (MEnc N L)
M0,N0 : Msg
HrecH0 : synthesis h (MEnc M K) (MEnc N L)
H1 : synthesis (synthesis h) (inv K) (inv L)
H0 : analysis (synthesis h) (MEnc M K) (MEnc N L)
M,N,K,L : Msg
H : forall (M N : Msg) (_ : analysis h M N), h M N
h : hedge
*****
forall _ : and (inclusion (synthesis h) (synthesis (synthesis h))) (inclusion (synthesis (synthesis h)) (synthesis h)), synthesis h (inv K) (inv L)
+++++
intros.
-----
Lemma stable_ana_impl_stable_syn_ana : forall h : hedge, stable_analysis h -> stable_analysis (synthesis h).
unfold stable_analysis in |- *.
unfold inclusion in |- *.
intros.
induction H0 as [M N H0| M1 M2 N1 N2 H0 HrecH0| M1 M2 N1 N2 H0 HrecH0| M N K L H0 HrecH0 H1].
trivial.
inversion HrecH0.
trivial.
apply SynInc.
apply H.
apply (AnaDec h M N K L).
trivial.
generalize (synthesis_idempotent h).
unfold equal in |- *.
intros.

*****
H5 : and (inclusion (synthesis h) (synthesis (synthesis h)))\n (inclusion (synthesis (synthesis h)) (synthesis h))
H4 : eq N0 (MEnc N L)
H3 : eq M0 (MEnc M K)
H2 : h (MEnc M K) (MEnc N L)
M0,N0 : Msg
HrecH0 : synthesis h (MEnc M K) (MEnc N L)
H1 : synthesis (synthesis h) (inv K) (inv L)
H0 : analysis (synthesis h) (MEnc M K) (MEnc N L)
M,N,K,L : Msg
H : forall (M N : Msg) (_ : analysis h M N), h M N
h : hedge
*****
synthesis h (inv K) (inv L)
+++++
elim H5.
-----
Lemma stable_ana_impl_stable_syn_ana : forall h : hedge, stable_analysis h -> stable_analysis (synthesis h).
unfold stable_analysis in |- *.
unfold inclusion in |- *.
intros.
induction H0 as [M N H0| M1 M2 N1 N2 H0 HrecH0| M1 M2 N1 N2 H0 HrecH0| M N K L H0 HrecH0 H1].
trivial.
inversion HrecH0.
trivial.
apply SynInc.
apply H.
apply (AnaDec h M N K L).
trivial.
generalize (synthesis_idempotent h).
unfold equal in |- *.
intros.
elim H5.

*****
H5 : and (inclusion (synthesis h) (synthesis (synthesis h)))\n (inclusion (synthesis (synthesis h)) (synthesis h))
H4 : eq N0 (MEnc N L)
H3 : eq M0 (MEnc M K)
H2 : h (MEnc M K) (MEnc N L)
M0,N0 : Msg
HrecH0 : synthesis h (MEnc M K) (MEnc N L)
H1 : synthesis (synthesis h) (inv K) (inv L)
H0 : analysis (synthesis h) (MEnc M K) (MEnc N L)
M,N,K,L : Msg
H : forall (M N : Msg) (_ : analysis h M N), h M N
h : hedge
*****
forall (_ : inclusion (synthesis h) (synthesis (synthesis h))) (_ : inclusion (synthesis (synthesis h)) (synthesis h)), synthesis h (inv K) (inv L)
+++++
unfold inclusion in |- *.
-----
Lemma stable_ana_impl_stable_syn_ana : forall h : hedge, stable_analysis h -> stable_analysis (synthesis h).
unfold stable_analysis in |- *.
unfold inclusion in |- *.
intros.
induction H0 as [M N H0| M1 M2 N1 N2 H0 HrecH0| M1 M2 N1 N2 H0 HrecH0| M N K L H0 HrecH0 H1].
trivial.
inversion HrecH0.
trivial.
apply SynInc.
apply H.
apply (AnaDec h M N K L).
trivial.
generalize (synthesis_idempotent h).
unfold equal in |- *.
intros.
elim H5.
unfold inclusion in |- *.

*****
H5 : and (inclusion (synthesis h) (synthesis (synthesis h)))\n (inclusion (synthesis (synthesis h)) (synthesis h))
H4 : eq N0 (MEnc N L)
H3 : eq M0 (MEnc M K)
H2 : h (MEnc M K) (MEnc N L)
M0,N0 : Msg
HrecH0 : synthesis h (MEnc M K) (MEnc N L)
H1 : synthesis (synthesis h) (inv K) (inv L)
H0 : analysis (synthesis h) (MEnc M K) (MEnc N L)
M,N,K,L : Msg
H : forall (M N : Msg) (_ : analysis h M N), h M N
h : hedge
*****
forall (_ : forall (M N : Msg) (_ : synthesis h M N), synthesis (synthesis h) M N) (_ : forall (M N : Msg) (_ : synthesis (synthesis h) M N), synthesis h M N), synthesis h (inv K) (inv L)
+++++
intros.
-----
Lemma stable_ana_impl_stable_syn_ana : forall h : hedge, stable_analysis h -> stable_analysis (synthesis h).
unfold stable_analysis in |- *.
unfold inclusion in |- *.
intros.
induction H0 as [M N H0| M1 M2 N1 N2 H0 HrecH0| M1 M2 N1 N2 H0 HrecH0| M N K L H0 HrecH0 H1].
trivial.
inversion HrecH0.
trivial.
apply SynInc.
apply H.
apply (AnaDec h M N K L).
trivial.
generalize (synthesis_idempotent h).
unfold equal in |- *.
intros.
elim H5.
unfold inclusion in |- *.
intros.

*****
H7 : forall (M N : Msg) (_ : synthesis (synthesis h) M N), synthesis h M N
H6 : forall (M N : Msg) (_ : synthesis h M N), synthesis (synthesis h) M N
H5 : and (inclusion (synthesis h) (synthesis (synthesis h)))\n (inclusion (synthesis (synthesis h)) (synthesis h))
H4 : eq N0 (MEnc N L)
H3 : eq M0 (MEnc M K)
H2 : h (MEnc M K) (MEnc N L)
M0,N0 : Msg
HrecH0 : synthesis h (MEnc M K) (MEnc N L)
H1 : synthesis (synthesis h) (inv K) (inv L)
H0 : analysis (synthesis h) (MEnc M K) (MEnc N L)
M,N,K,L : Msg
H : forall (M N : Msg) (_ : analysis h M N), h M N
h : hedge
*****
synthesis h (inv K) (inv L)
+++++
apply H7.
-----
Lemma stable_ana_impl_stable_syn_ana : forall h : hedge, stable_analysis h -> stable_analysis (synthesis h).
unfold stable_analysis in |- *.
unfold inclusion in |- *.
intros.
induction H0 as [M N H0| M1 M2 N1 N2 H0 HrecH0| M1 M2 N1 N2 H0 HrecH0| M N K L H0 HrecH0 H1].
trivial.
inversion HrecH0.
trivial.
apply SynInc.
apply H.
apply (AnaDec h M N K L).
trivial.
generalize (synthesis_idempotent h).
unfold equal in |- *.
intros.
elim H5.
unfold inclusion in |- *.
intros.
apply H7.

*****
H7 : forall (M N : Msg) (_ : synthesis (synthesis h) M N), synthesis h M N
H6 : forall (M N : Msg) (_ : synthesis h M N), synthesis (synthesis h) M N
H5 : and (inclusion (synthesis h) (synthesis (synthesis h)))\n (inclusion (synthesis (synthesis h)) (synthesis h))
H4 : eq N0 (MEnc N L)
H3 : eq M0 (MEnc M K)
H2 : h (MEnc M K) (MEnc N L)
M0,N0 : Msg
HrecH0 : synthesis h (MEnc M K) (MEnc N L)
H1 : synthesis (synthesis h) (inv K) (inv L)
H0 : analysis (synthesis h) (MEnc M K) (MEnc N L)
M,N,K,L : Msg
H : forall (M N : Msg) (_ : analysis h M N), h M N
h : hedge
*****
synthesis (synthesis h) (inv K) (inv L)
+++++
trivial.
-----
Lemma stable_ana_impl_stable_syn_ana : forall h : hedge, stable_analysis h -> stable_analysis (synthesis h).
unfold stable_analysis in |- *.
unfold inclusion in |- *.
intros.
induction H0 as [M N H0| M1 M2 N1 N2 H0 HrecH0| M1 M2 N1 N2 H0 HrecH0| M N K L H0 HrecH0 H1].
trivial.
inversion HrecH0.

*****
H6 : eq L0 L
H4 : eq N0 N
H3 : eq K0 K
H2 : eq M0 M
H7 : synthesis h K L
H5 : synthesis h M N
M0,N0,K0,L0 : Msg
HrecH0 : synthesis h (MEnc M K) (MEnc N L)
H1 : synthesis (synthesis h) (inv K) (inv L)
H0 : analysis (synthesis h) (MEnc M K) (MEnc N L)
M,N,K,L : Msg
H : forall (M N : Msg) (_ : analysis h M N), h M N
h : hedge
*****
synthesis h M N
+++++
trivial.
-----
Lemma stable_ana_impl_stable_syn_ana : forall h : hedge, stable_analysis h -> stable_analysis (synthesis h).
unfold stable_analysis in |- *.
unfold inclusion in |- *.
intros.
induction H0 as [M N H0| M1 M2 N1 N2 H0 HrecH0| M1 M2 N1 N2 H0 HrecH0| M N K L H0 HrecH0 H1].

*****

*****

+++++
Qed.
-----
Lemma le_h_ana_le_h :\n forall g h : hedge, le_h g h -> le_h (analysis_def g) (analysis_def h).
-----
Lemma le_h_ana_le_h : forall g h : hedge, le_h g h -> le_h (analysis_def g) (analysis_def h).

*****

*****
forall (g h : hedge) (_ : le_h g h), le_h (analysis_def g) (analysis_def h)
+++++
intros.
-----
Lemma le_h_ana_le_h : forall g h : hedge, le_h g h -> le_h (analysis_def g) (analysis_def h).
intros.

*****
H : le_h g h
g,h : hedge
*****
le_h (analysis_def g) (analysis_def h)
+++++
generalize (le_h_impl_incl_syn g h H).
-----
Lemma le_h_ana_le_h : forall g h : hedge, le_h g h -> le_h (analysis_def g) (analysis_def h).
intros.
generalize (le_h_impl_incl_syn g h H).

*****
H : le_h g h
g,h : hedge
*****
forall _ : inclusion g (synthesis h), le_h (analysis_def g) (analysis_def h)
+++++
intro.
-----
Lemma le_h_ana_le_h : forall g h : hedge, le_h g h -> le_h (analysis_def g) (analysis_def h).
intros.
generalize (le_h_impl_incl_syn g h H).
intro.

*****
H0 : inclusion g (synthesis h)
H : le_h g h
g,h : hedge
*****
le_h (analysis_def g) (analysis_def h)
+++++
apply incl_syn_impl_le_h.
-----
Lemma le_h_ana_le_h : forall g h : hedge, le_h g h -> le_h (analysis_def g) (analysis_def h).
intros.
generalize (le_h_impl_incl_syn g h H).
intro.
apply incl_syn_impl_le_h.

*****
H0 : inclusion g (synthesis h)
H : le_h g h
g,h : hedge
*****
inclusion (analysis_def g) (synthesis (analysis_def h))
+++++
generalize (analysis_is_analysis g).
-----
Lemma le_h_ana_le_h : forall g h : hedge, le_h g h -> le_h (analysis_def g) (analysis_def h).
intros.
generalize (le_h_impl_incl_syn g h H).
intro.
apply incl_syn_impl_le_h.
generalize (analysis_is_analysis g).

*****
H0 : inclusion g (synthesis h)
H : le_h g h
g,h : hedge
*****
forall _ : is_analysis g (analysis_def g), inclusion (analysis_def g) (synthesis (analysis_def h))
+++++
unfold is_analysis in |- *.
-----
Lemma le_h_ana_le_h : forall g h : hedge, le_h g h -> le_h (analysis_def g) (analysis_def h).
intros.
generalize (le_h_impl_incl_syn g h H).
intro.
apply incl_syn_impl_le_h.
generalize (analysis_is_analysis g).
unfold is_analysis in |- *.

*****
H0 : inclusion g (synthesis h)
H : le_h g h
g,h : hedge
*****
forall _ : and (analysis_cond g (analysis_def g)) (forall (h' : hedge) (_ : analysis_cond g h'), inclusion (analysis_def g) h'), inclusion (analysis_def g) (synthesis (analysis_def h))
+++++
unfold analysis_cond in |- *.
-----
Lemma le_h_ana_le_h : forall g h : hedge, le_h g h -> le_h (analysis_def g) (analysis_def h).
intros.
generalize (le_h_impl_incl_syn g h H).
intro.
apply incl_syn_impl_le_h.
generalize (analysis_is_analysis g).
unfold is_analysis in |- *.
unfold analysis_cond in |- *.

*****
H0 : inclusion g (synthesis h)
H : le_h g h
g,h : hedge
*****
forall _ : and (and (inclusion g (analysis_def g)) (stable_analysis (analysis_def g))) (forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')), inclusion (analysis_def g) h'), inclusion (analysis_def g) (synthesis (analysis_def h))
+++++
intros.
-----
Lemma le_h_ana_le_h : forall g h : hedge, le_h g h -> le_h (analysis_def g) (analysis_def h).
intros.
generalize (le_h_impl_incl_syn g h H).
intro.
apply incl_syn_impl_le_h.
generalize (analysis_is_analysis g).
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.

*****
H1 : and\n (and (inclusion g (analysis_def g))\n (stable_analysis (analysis_def g)))\n (forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\n inclusion (analysis_def g) h')
H0 : inclusion g (synthesis h)
H : le_h g h
g,h : hedge
*****
inclusion (analysis_def g) (synthesis (analysis_def h))
+++++
elim H1.
-----
Lemma le_h_ana_le_h : forall g h : hedge, le_h g h -> le_h (analysis_def g) (analysis_def h).
intros.
generalize (le_h_impl_incl_syn g h H).
intro.
apply incl_syn_impl_le_h.
generalize (analysis_is_analysis g).
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.
elim H1.

*****
H1 : and\n (and (inclusion g (analysis_def g))\n (stable_analysis (analysis_def g)))\n (forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\n inclusion (analysis_def g) h')
H0 : inclusion g (synthesis h)
H : le_h g h
g,h : hedge
*****
forall (_ : and (inclusion g (analysis_def g)) (stable_analysis (analysis_def g))) (_ : forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')), inclusion (analysis_def g) h'), inclusion (analysis_def g) (synthesis (analysis_def h))
+++++
intros.
-----
Lemma le_h_ana_le_h : forall g h : hedge, le_h g h -> le_h (analysis_def g) (analysis_def h).
intros.
generalize (le_h_impl_incl_syn g h H).
intro.
apply incl_syn_impl_le_h.
generalize (analysis_is_analysis g).
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.
elim H1.
intros.

*****
H3 : forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\ninclusion (analysis_def g) h'
H2 : and (inclusion g (analysis_def g)) (stable_analysis (analysis_def g))
H1 : and\n (and (inclusion g (analysis_def g))\n (stable_analysis (analysis_def g)))\n (forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\n inclusion (analysis_def g) h')
H0 : inclusion g (synthesis h)
H : le_h g h
g,h : hedge
*****
inclusion (analysis_def g) (synthesis (analysis_def h))
+++++
apply H3.
-----
Lemma le_h_ana_le_h : forall g h : hedge, le_h g h -> le_h (analysis_def g) (analysis_def h).
intros.
generalize (le_h_impl_incl_syn g h H).
intro.
apply incl_syn_impl_le_h.
generalize (analysis_is_analysis g).
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.
elim H1.
intros.
apply H3.

*****
H3 : forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\ninclusion (analysis_def g) h'
H2 : and (inclusion g (analysis_def g)) (stable_analysis (analysis_def g))
H1 : and\n (and (inclusion g (analysis_def g))\n (stable_analysis (analysis_def g)))\n (forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\n inclusion (analysis_def g) h')
H0 : inclusion g (synthesis h)
H : le_h g h
g,h : hedge
*****
and (inclusion g (synthesis (analysis_def h))) (stable_analysis (synthesis (analysis_def h)))
+++++
split.
-----
Lemma le_h_ana_le_h : forall g h : hedge, le_h g h -> le_h (analysis_def g) (analysis_def h).
intros.
generalize (le_h_impl_incl_syn g h H).
intro.
apply incl_syn_impl_le_h.
generalize (analysis_is_analysis g).
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.
elim H1.
intros.
apply H3.
split.

*****
H3 : forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\ninclusion (analysis_def g) h'
H2 : and (inclusion g (analysis_def g)) (stable_analysis (analysis_def g))
H1 : and\n (and (inclusion g (analysis_def g))\n (stable_analysis (analysis_def g)))\n (forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\n inclusion (analysis_def g) h')
H0 : inclusion g (synthesis h)
H : le_h g h
g,h : hedge
*****
inclusion g (synthesis (analysis_def h))
+++++
apply inclusion_trans with (synthesis h).
-----
Lemma le_h_ana_le_h : forall g h : hedge, le_h g h -> le_h (analysis_def g) (analysis_def h).
intros.
generalize (le_h_impl_incl_syn g h H).
intro.
apply incl_syn_impl_le_h.
generalize (analysis_is_analysis g).
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.
elim H1.
intros.
apply H3.
split.
apply inclusion_trans with (synthesis h).

*****
H3 : forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\ninclusion (analysis_def g) h'
H2 : and (inclusion g (analysis_def g)) (stable_analysis (analysis_def g))
H1 : and\n (and (inclusion g (analysis_def g))\n (stable_analysis (analysis_def g)))\n (forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\n inclusion (analysis_def g) h')
H0 : inclusion g (synthesis h)
H : le_h g h
g,h : hedge
*****
inclusion g (synthesis h)
+++++
trivial.
-----
Lemma le_h_ana_le_h : forall g h : hedge, le_h g h -> le_h (analysis_def g) (analysis_def h).
intros.
generalize (le_h_impl_incl_syn g h H).
intro.
apply incl_syn_impl_le_h.
generalize (analysis_is_analysis g).
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.
elim H1.
intros.
apply H3.
split.
apply inclusion_trans with (synthesis h).

*****
H3 : forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\ninclusion (analysis_def g) h'
H2 : and (inclusion g (analysis_def g)) (stable_analysis (analysis_def g))
H1 : and\n (and (inclusion g (analysis_def g))\n (stable_analysis (analysis_def g)))\n (forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\n inclusion (analysis_def g) h')
H0 : inclusion g (synthesis h)
H : le_h g h
g,h : hedge
*****
inclusion (synthesis h) (synthesis (analysis_def h))
+++++
generalize h_le_h_ana_h.
-----
Lemma le_h_ana_le_h : forall g h : hedge, le_h g h -> le_h (analysis_def g) (analysis_def h).
intros.
generalize (le_h_impl_incl_syn g h H).
intro.
apply incl_syn_impl_le_h.
generalize (analysis_is_analysis g).
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.
elim H1.
intros.
apply H3.
split.
apply inclusion_trans with (synthesis h).
generalize h_le_h_ana_h.

*****
H3 : forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\ninclusion (analysis_def g) h'
H2 : and (inclusion g (analysis_def g)) (stable_analysis (analysis_def g))
H1 : and\n (and (inclusion g (analysis_def g))\n (stable_analysis (analysis_def g)))\n (forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\n inclusion (analysis_def g) h')
H0 : inclusion g (synthesis h)
H : le_h g h
g,h : hedge
*****
forall _ : forall h : hedge, le_h h (analysis_def h), inclusion (synthesis h) (synthesis (analysis_def h))
+++++
unfold le_h in |- *.
-----
Lemma le_h_ana_le_h : forall g h : hedge, le_h g h -> le_h (analysis_def g) (analysis_def h).
intros.
generalize (le_h_impl_incl_syn g h H).
intro.
apply incl_syn_impl_le_h.
generalize (analysis_is_analysis g).
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.
elim H1.
intros.
apply H3.
split.
apply inclusion_trans with (synthesis h).
generalize h_le_h_ana_h.
unfold le_h in |- *.

*****
H3 : forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\ninclusion (analysis_def g) h'
H2 : and (inclusion g (analysis_def g)) (stable_analysis (analysis_def g))
H1 : and\n (and (inclusion g (analysis_def g))\n (stable_analysis (analysis_def g)))\n (forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\n inclusion (analysis_def g) h')
H0 : inclusion g (synthesis h)
H : le_h g h
g,h : hedge
*****
forall _ : forall h : hedge, inclusion (synthesis h) (synthesis (analysis_def h)), inclusion (synthesis h) (synthesis (analysis_def h))
+++++
trivial.
-----
Lemma le_h_ana_le_h : forall g h : hedge, le_h g h -> le_h (analysis_def g) (analysis_def h).
intros.
generalize (le_h_impl_incl_syn g h H).
intro.
apply incl_syn_impl_le_h.
generalize (analysis_is_analysis g).
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.
elim H1.
intros.
apply H3.
split.

*****
H3 : forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\ninclusion (analysis_def g) h'
H2 : and (inclusion g (analysis_def g)) (stable_analysis (analysis_def g))
H1 : and\n (and (inclusion g (analysis_def g))\n (stable_analysis (analysis_def g)))\n (forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\n inclusion (analysis_def g) h')
H0 : inclusion g (synthesis h)
H : le_h g h
g,h : hedge
*****
stable_analysis (synthesis (analysis_def h))
+++++
apply stable_ana_impl_stable_syn_ana.
-----
Lemma le_h_ana_le_h : forall g h : hedge, le_h g h -> le_h (analysis_def g) (analysis_def h).
intros.
generalize (le_h_impl_incl_syn g h H).
intro.
apply incl_syn_impl_le_h.
generalize (analysis_is_analysis g).
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.
elim H1.
intros.
apply H3.
split.
apply stable_ana_impl_stable_syn_ana.

*****
H3 : forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\ninclusion (analysis_def g) h'
H2 : and (inclusion g (analysis_def g)) (stable_analysis (analysis_def g))
H1 : and\n (and (inclusion g (analysis_def g))\n (stable_analysis (analysis_def g)))\n (forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\n inclusion (analysis_def g) h')
H0 : inclusion g (synthesis h)
H : le_h g h
g,h : hedge
*****
stable_analysis (analysis_def h)
+++++
generalize (analysis_is_analysis h).
-----
Lemma le_h_ana_le_h : forall g h : hedge, le_h g h -> le_h (analysis_def g) (analysis_def h).
intros.
generalize (le_h_impl_incl_syn g h H).
intro.
apply incl_syn_impl_le_h.
generalize (analysis_is_analysis g).
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.
elim H1.
intros.
apply H3.
split.
apply stable_ana_impl_stable_syn_ana.
generalize (analysis_is_analysis h).

*****
H3 : forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\ninclusion (analysis_def g) h'
H2 : and (inclusion g (analysis_def g)) (stable_analysis (analysis_def g))
H1 : and\n (and (inclusion g (analysis_def g))\n (stable_analysis (analysis_def g)))\n (forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\n inclusion (analysis_def g) h')
H0 : inclusion g (synthesis h)
H : le_h g h
g,h : hedge
*****
forall _ : is_analysis h (analysis_def h), stable_analysis (analysis_def h)
+++++
unfold is_analysis in |- *.
-----
Lemma le_h_ana_le_h : forall g h : hedge, le_h g h -> le_h (analysis_def g) (analysis_def h).
intros.
generalize (le_h_impl_incl_syn g h H).
intro.
apply incl_syn_impl_le_h.
generalize (analysis_is_analysis g).
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.
elim H1.
intros.
apply H3.
split.
apply stable_ana_impl_stable_syn_ana.
generalize (analysis_is_analysis h).
unfold is_analysis in |- *.

*****
H3 : forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\ninclusion (analysis_def g) h'
H2 : and (inclusion g (analysis_def g)) (stable_analysis (analysis_def g))
H1 : and\n (and (inclusion g (analysis_def g))\n (stable_analysis (analysis_def g)))\n (forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\n inclusion (analysis_def g) h')
H0 : inclusion g (synthesis h)
H : le_h g h
g,h : hedge
*****
forall _ : and (analysis_cond h (analysis_def h)) (forall (h' : hedge) (_ : analysis_cond h h'), inclusion (analysis_def h) h'), stable_analysis (analysis_def h)
+++++
unfold analysis_cond in |- *.
-----
Lemma le_h_ana_le_h : forall g h : hedge, le_h g h -> le_h (analysis_def g) (analysis_def h).
intros.
generalize (le_h_impl_incl_syn g h H).
intro.
apply incl_syn_impl_le_h.
generalize (analysis_is_analysis g).
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.
elim H1.
intros.
apply H3.
split.
apply stable_ana_impl_stable_syn_ana.
generalize (analysis_is_analysis h).
unfold is_analysis in |- *.
unfold analysis_cond in |- *.

*****
H3 : forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\ninclusion (analysis_def g) h'
H2 : and (inclusion g (analysis_def g)) (stable_analysis (analysis_def g))
H1 : and\n (and (inclusion g (analysis_def g))\n (stable_analysis (analysis_def g)))\n (forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\n inclusion (analysis_def g) h')
H0 : inclusion g (synthesis h)
H : le_h g h
g,h : hedge
*****
forall _ : and (and (inclusion h (analysis_def h)) (stable_analysis (analysis_def h))) (forall (h' : hedge) (_ : and (inclusion h h') (stable_analysis h')), inclusion (analysis_def h) h'), stable_analysis (analysis_def h)
+++++
tauto.
-----
Lemma le_h_ana_le_h : forall g h : hedge, le_h g h -> le_h (analysis_def g) (analysis_def h).
intros.
generalize (le_h_impl_incl_syn g h H).
intro.
apply incl_syn_impl_le_h.
generalize (analysis_is_analysis g).
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.
elim H1.
intros.
apply H3.
split.

*****

*****

+++++
Qed.
-----
Theorem le_h_irr_le_h :\n forall g h : hedge, le_h g h -> le_h (irreducible g) (irreducible h).
-----
Theorem le_h_irr_le_h : forall g h : hedge, le_h g h -> le_h (irreducible g) (irreducible h).

*****

*****
forall (g h : hedge) (_ : le_h g h), le_h (irreducible g) (irreducible h)
+++++
intros.
-----
Theorem le_h_irr_le_h : forall g h : hedge, le_h g h -> le_h (irreducible g) (irreducible h).
intros.

*****
H : le_h g h
g,h : hedge
*****
le_h (irreducible g) (irreducible h)
+++++
apply le_h_trans with (analysis_def h).
-----
Theorem le_h_irr_le_h : forall g h : hedge, le_h g h -> le_h (irreducible g) (irreducible h).
intros.
apply le_h_trans with (analysis_def h).

*****
H : le_h g h
g,h : hedge
*****
le_h (irreducible g) (analysis_def h)
+++++
apply le_h_trans with (analysis_def g).
-----
Theorem le_h_irr_le_h : forall g h : hedge, le_h g h -> le_h (irreducible g) (irreducible h).
intros.
apply le_h_trans with (analysis_def h).
apply le_h_trans with (analysis_def g).

*****
H : le_h g h
g,h : hedge
*****
le_h (irreducible g) (analysis_def g)
+++++
generalize (ana_h_equiv_irr_h g).
-----
Theorem le_h_irr_le_h : forall g h : hedge, le_h g h -> le_h (irreducible g) (irreducible h).
intros.
apply le_h_trans with (analysis_def h).
apply le_h_trans with (analysis_def g).
generalize (ana_h_equiv_irr_h g).

*****
H : le_h g h
g,h : hedge
*****
forall _ : equiv_h (analysis_def g) (irreducible g), le_h (irreducible g) (analysis_def g)
+++++
unfold equiv_h in |- *.
-----
Theorem le_h_irr_le_h : forall g h : hedge, le_h g h -> le_h (irreducible g) (irreducible h).
intros.
apply le_h_trans with (analysis_def h).
apply le_h_trans with (analysis_def g).
generalize (ana_h_equiv_irr_h g).
unfold equiv_h in |- *.

*****
H : le_h g h
g,h : hedge
*****
forall _ : and (le_h (analysis_def g) (irreducible g)) (le_h (irreducible g) (analysis_def g)), le_h (irreducible g) (analysis_def g)
+++++
tauto.
-----
Theorem le_h_irr_le_h : forall g h : hedge, le_h g h -> le_h (irreducible g) (irreducible h).
intros.
apply le_h_trans with (analysis_def h).
apply le_h_trans with (analysis_def g).

*****
H : le_h g h
g,h : hedge
*****
le_h (analysis_def g) (analysis_def h)
+++++
apply le_h_ana_le_h.
-----
Theorem le_h_irr_le_h : forall g h : hedge, le_h g h -> le_h (irreducible g) (irreducible h).
intros.
apply le_h_trans with (analysis_def h).
apply le_h_trans with (analysis_def g).
apply le_h_ana_le_h.

*****
H : le_h g h
g,h : hedge
*****
le_h g h
+++++
trivial.
-----
Theorem le_h_irr_le_h : forall g h : hedge, le_h g h -> le_h (irreducible g) (irreducible h).
intros.
apply le_h_trans with (analysis_def h).

*****
H : le_h g h
g,h : hedge
*****
le_h (analysis_def h) (irreducible h)
+++++
generalize (ana_h_equiv_irr_h h).
-----
Theorem le_h_irr_le_h : forall g h : hedge, le_h g h -> le_h (irreducible g) (irreducible h).
intros.
apply le_h_trans with (analysis_def h).
generalize (ana_h_equiv_irr_h h).

*****
H : le_h g h
g,h : hedge
*****
forall _ : equiv_h (analysis_def h) (irreducible h), le_h (analysis_def h) (irreducible h)
+++++
unfold equiv_h in |- *.
-----
Theorem le_h_irr_le_h : forall g h : hedge, le_h g h -> le_h (irreducible g) (irreducible h).
intros.
apply le_h_trans with (analysis_def h).
generalize (ana_h_equiv_irr_h h).
unfold equiv_h in |- *.

*****
H : le_h g h
g,h : hedge
*****
forall _ : and (le_h (analysis_def h) (irreducible h)) (le_h (irreducible h) (analysis_def h)), le_h (analysis_def h) (irreducible h)
+++++
tauto.
-----
Theorem le_h_irr_le_h : forall g h : hedge, le_h g h -> le_h (irreducible g) (irreducible h).
intros.
apply le_h_trans with (analysis_def h).

*****

*****

+++++
Qed.
-----
Theorem equiv_h_impl_irr_unique :\n forall g h : hedge, equiv_h g h -> equal (irreducible g) (irreducible h).
-----
Theorem equiv_h_impl_irr_unique : forall g h : hedge, equiv_h g h -> equal (irreducible g) (irreducible h).

*****

*****
forall (g h : hedge) (_ : equiv_h g h), equal (irreducible g) (irreducible h)
+++++
unfold equiv_h in |- *.
-----
Theorem equiv_h_impl_irr_unique : forall g h : hedge, equiv_h g h -> equal (irreducible g) (irreducible h).
unfold equiv_h in |- *.

*****

*****
forall (g h : hedge) (_ : and (le_h g h) (le_h h g)), equal (irreducible g) (irreducible h)
+++++
intros.
-----
Theorem equiv_h_impl_irr_unique : forall g h : hedge, equiv_h g h -> equal (irreducible g) (irreducible h).
unfold equiv_h in |- *.
intros.

*****
H : and (le_h g h) (le_h h g)
g,h : hedge
*****
equal (irreducible g) (irreducible h)
+++++
apply equiv_irr_irr_impl_equal.
-----
Theorem equiv_h_impl_irr_unique : forall g h : hedge, equiv_h g h -> equal (irreducible g) (irreducible h).
unfold equiv_h in |- *.
intros.
apply equiv_irr_irr_impl_equal.

*****
H : and (le_h g h) (le_h h g)
g,h : hedge
*****
equiv_h (irreducible g) (irreducible h)
+++++
try apply irreducible_is_irreducible.
-----
Theorem equiv_h_impl_irr_unique : forall g h : hedge, equiv_h g h -> equal (irreducible g) (irreducible h).
unfold equiv_h in |- *.
intros.
apply equiv_irr_irr_impl_equal.
try apply irreducible_is_irreducible.

*****
H : and (le_h g h) (le_h h g)
g,h : hedge
*****
equiv_h (irreducible g) (irreducible h)
+++++
unfold equiv_h in |- *.
-----
Theorem equiv_h_impl_irr_unique : forall g h : hedge, equiv_h g h -> equal (irreducible g) (irreducible h).
unfold equiv_h in |- *.
intros.
apply equiv_irr_irr_impl_equal.
try apply irreducible_is_irreducible.
unfold equiv_h in |- *.

*****
H : and (le_h g h) (le_h h g)
g,h : hedge
*****
and (le_h (irreducible g) (irreducible h)) (le_h (irreducible h) (irreducible g))
+++++
elim H.
-----
Theorem equiv_h_impl_irr_unique : forall g h : hedge, equiv_h g h -> equal (irreducible g) (irreducible h).
unfold equiv_h in |- *.
intros.
apply equiv_irr_irr_impl_equal.
try apply irreducible_is_irreducible.
unfold equiv_h in |- *.
elim H.

*****
H : and (le_h g h) (le_h h g)
g,h : hedge
*****
forall (_ : le_h g h) (_ : le_h h g), and (le_h (irreducible g) (irreducible h)) (le_h (irreducible h) (irreducible g))
+++++
intros.
-----
Theorem equiv_h_impl_irr_unique : forall g h : hedge, equiv_h g h -> equal (irreducible g) (irreducible h).
unfold equiv_h in |- *.
intros.
apply equiv_irr_irr_impl_equal.
try apply irreducible_is_irreducible.
unfold equiv_h in |- *.
elim H.
intros.

*****
H1 : le_h h g
H0 : le_h g h
H : and (le_h g h) (le_h h g)
g,h : hedge
*****
and (le_h (irreducible g) (irreducible h)) (le_h (irreducible h) (irreducible g))
+++++
split.
-----
Theorem equiv_h_impl_irr_unique : forall g h : hedge, equiv_h g h -> equal (irreducible g) (irreducible h).
unfold equiv_h in |- *.
intros.
apply equiv_irr_irr_impl_equal.
try apply irreducible_is_irreducible.
unfold equiv_h in |- *.
elim H.
intros.
split.

*****
H1 : le_h h g
H0 : le_h g h
H : and (le_h g h) (le_h h g)
g,h : hedge
*****
le_h (irreducible g) (irreducible h)
+++++
apply le_h_irr_le_h.
-----
Theorem equiv_h_impl_irr_unique : forall g h : hedge, equiv_h g h -> equal (irreducible g) (irreducible h).
unfold equiv_h in |- *.
intros.
apply equiv_irr_irr_impl_equal.
try apply irreducible_is_irreducible.
unfold equiv_h in |- *.
elim H.
intros.
split.
apply le_h_irr_le_h.

*****
H1 : le_h h g
H0 : le_h g h
H : and (le_h g h) (le_h h g)
g,h : hedge
*****
le_h g h
+++++
trivial.
-----
Theorem equiv_h_impl_irr_unique : forall g h : hedge, equiv_h g h -> equal (irreducible g) (irreducible h).
unfold equiv_h in |- *.
intros.
apply equiv_irr_irr_impl_equal.
try apply irreducible_is_irreducible.
unfold equiv_h in |- *.
elim H.
intros.
split.

*****
H1 : le_h h g
H0 : le_h g h
H : and (le_h g h) (le_h h g)
g,h : hedge
*****
le_h (irreducible h) (irreducible g)
+++++
apply le_h_irr_le_h.
-----
Theorem equiv_h_impl_irr_unique : forall g h : hedge, equiv_h g h -> equal (irreducible g) (irreducible h).
unfold equiv_h in |- *.
intros.
apply equiv_irr_irr_impl_equal.
try apply irreducible_is_irreducible.
unfold equiv_h in |- *.
elim H.
intros.
split.
apply le_h_irr_le_h.

*****
H1 : le_h h g
H0 : le_h g h
H : and (le_h g h) (le_h h g)
g,h : hedge
*****
le_h h g
+++++
trivial.
-----
Theorem equiv_h_impl_irr_unique : forall g h : hedge, equiv_h g h -> equal (irreducible g) (irreducible h).
unfold equiv_h in |- *.
intros.
apply equiv_irr_irr_impl_equal.

*****
H : and (le_h g h) (le_h h g)
g,h : hedge
*****
is_irreducible (irreducible g)
+++++
try apply irreducible_is_irreducible.
-----
Theorem equiv_h_impl_irr_unique : forall g h : hedge, equiv_h g h -> equal (irreducible g) (irreducible h).
unfold equiv_h in |- *.
intros.
apply equiv_irr_irr_impl_equal.

*****
H : and (le_h g h) (le_h h g)
g,h : hedge
*****
is_irreducible (irreducible h)
+++++
try apply irreducible_is_irreducible.
-----
Theorem equiv_h_impl_irr_unique : forall g h : hedge, equiv_h g h -> equal (irreducible g) (irreducible h).
unfold equiv_h in |- *.
intros.
apply equiv_irr_irr_impl_equal.

*****

*****

+++++
Qed.
-----
Theorem update_irr :\n forall g h : hedge,\n equal (irreducible (union (irreducible h) g)) (irreducible (union h g)).
-----
Theorem update_irr : forall g h : hedge, equal (irreducible (union (irreducible h) g)) (irreducible (union h g)).

*****

*****
forall g h : hedge, equal (irreducible (union (irreducible h) g)) (irreducible (union h g))
+++++
intros.
-----
Theorem update_irr : forall g h : hedge, equal (irreducible (union (irreducible h) g)) (irreducible (union h g)).
intros.

*****
g,h : hedge
*****
equal (irreducible (union (irreducible h) g)) (irreducible (union h g))
+++++
apply equiv_irr_irr_impl_equal.
-----
Theorem update_irr : forall g h : hedge, equal (irreducible (union (irreducible h) g)) (irreducible (union h g)).
intros.
apply equiv_irr_irr_impl_equal.

*****
g,h : hedge
*****
equiv_h (irreducible (union (irreducible h) g)) (irreducible (union h g))
+++++
try apply irreducible_is_irreducible.
-----
Theorem update_irr : forall g h : hedge, equal (irreducible (union (irreducible h) g)) (irreducible (union h g)).
intros.
apply equiv_irr_irr_impl_equal.
try apply irreducible_is_irreducible.

*****
g,h : hedge
*****
equiv_h (irreducible (union (irreducible h) g)) (irreducible (union h g))
+++++
unfold equiv_h in |- *.
-----
Theorem update_irr : forall g h : hedge, equal (irreducible (union (irreducible h) g)) (irreducible (union h g)).
intros.
apply equiv_irr_irr_impl_equal.
try apply irreducible_is_irreducible.
unfold equiv_h in |- *.

*****
g,h : hedge
*****
and (le_h (irreducible (union (irreducible h) g)) (irreducible (union h g))) (le_h (irreducible (union h g)) (irreducible (union (irreducible h) g)))
+++++
split.
-----
Theorem update_irr : forall g h : hedge, equal (irreducible (union (irreducible h) g)) (irreducible (union h g)).
intros.
apply equiv_irr_irr_impl_equal.
try apply irreducible_is_irreducible.
unfold equiv_h in |- *.
split.

*****
g,h : hedge
*****
le_h (irreducible (union (irreducible h) g)) (irreducible (union h g))
+++++
apply le_h_trans with (irreducible (irreducible (union h g))).
-----
Theorem update_irr : forall g h : hedge, equal (irreducible (union (irreducible h) g)) (irreducible (union h g)).
intros.
apply equiv_irr_irr_impl_equal.
try apply irreducible_is_irreducible.
unfold equiv_h in |- *.
split.
apply le_h_trans with (irreducible (irreducible (union h g))).

*****
g,h : hedge
*****
le_h (irreducible (union (irreducible h) g)) (irreducible (irreducible (union h g)))
+++++
apply le_h_irr_le_h.
-----
Theorem update_irr : forall g h : hedge, equal (irreducible (union (irreducible h) g)) (irreducible (union h g)).
intros.
apply equiv_irr_irr_impl_equal.
try apply irreducible_is_irreducible.
unfold equiv_h in |- *.
split.
apply le_h_trans with (irreducible (irreducible (union h g))).
apply le_h_irr_le_h.

*****
g,h : hedge
*****
le_h (union (irreducible h) g) (irreducible (union h g))
+++++
apply le_h_le_h_impl_union_le_h.
-----
Theorem update_irr : forall g h : hedge, equal (irreducible (union (irreducible h) g)) (irreducible (union h g)).
intros.
apply equiv_irr_irr_impl_equal.
try apply irreducible_is_irreducible.
unfold equiv_h in |- *.
split.
apply le_h_trans with (irreducible (irreducible (union h g))).
apply le_h_irr_le_h.
apply le_h_le_h_impl_union_le_h.

*****
g,h : hedge
*****
le_h (irreducible h) (irreducible (union h g))
+++++
apply le_h_irr_le_h.
-----
Theorem update_irr : forall g h : hedge, equal (irreducible (union (irreducible h) g)) (irreducible (union h g)).
intros.
apply equiv_irr_irr_impl_equal.
try apply irreducible_is_irreducible.
unfold equiv_h in |- *.
split.
apply le_h_trans with (irreducible (irreducible (union h g))).
apply le_h_irr_le_h.
apply le_h_le_h_impl_union_le_h.
apply le_h_irr_le_h.

*****
g,h : hedge
*****
le_h h (union h g)
+++++
apply inclusion_impl_le_h.
-----
Theorem update_irr : forall g h : hedge, equal (irreducible (union (irreducible h) g)) (irreducible (union h g)).
intros.
apply equiv_irr_irr_impl_equal.
try apply irreducible_is_irreducible.
unfold equiv_h in |- *.
split.
apply le_h_trans with (irreducible (irreducible (union h g))).
apply le_h_irr_le_h.
apply le_h_le_h_impl_union_le_h.
apply le_h_irr_le_h.
apply inclusion_impl_le_h.

*****
g,h : hedge
*****
inclusion h (union h g)
+++++
apply hedge_left_union.
-----
Theorem update_irr : forall g h : hedge, equal (irreducible (union (irreducible h) g)) (irreducible (union h g)).
intros.
apply equiv_irr_irr_impl_equal.
try apply irreducible_is_irreducible.
unfold equiv_h in |- *.
split.
apply le_h_trans with (irreducible (irreducible (union h g))).
apply le_h_irr_le_h.
apply le_h_le_h_impl_union_le_h.

*****
g,h : hedge
*****
le_h g (irreducible (union h g))
+++++
apply le_h_trans with (irreducible g).
-----
Theorem update_irr : forall g h : hedge, equal (irreducible (union (irreducible h) g)) (irreducible (union h g)).
intros.
apply equiv_irr_irr_impl_equal.
try apply irreducible_is_irreducible.
unfold equiv_h in |- *.
split.
apply le_h_trans with (irreducible (irreducible (union h g))).
apply le_h_irr_le_h.
apply le_h_le_h_impl_union_le_h.
apply le_h_trans with (irreducible g).

*****
g,h : hedge
*****
le_h g (irreducible g)
+++++
apply h_le_h_irr_h.
-----
Theorem update_irr : forall g h : hedge, equal (irreducible (union (irreducible h) g)) (irreducible (union h g)).
intros.
apply equiv_irr_irr_impl_equal.
try apply irreducible_is_irreducible.
unfold equiv_h in |- *.
split.
apply le_h_trans with (irreducible (irreducible (union h g))).
apply le_h_irr_le_h.
apply le_h_le_h_impl_union_le_h.
apply le_h_trans with (irreducible g).

*****
g,h : hedge
*****
le_h (irreducible g) (irreducible (union h g))
+++++
apply le_h_irr_le_h.
-----
Theorem update_irr : forall g h : hedge, equal (irreducible (union (irreducible h) g)) (irreducible (union h g)).
intros.
apply equiv_irr_irr_impl_equal.
try apply irreducible_is_irreducible.
unfold equiv_h in |- *.
split.
apply le_h_trans with (irreducible (irreducible (union h g))).
apply le_h_irr_le_h.
apply le_h_le_h_impl_union_le_h.
apply le_h_trans with (irreducible g).
apply le_h_irr_le_h.

*****
g,h : hedge
*****
le_h g (union h g)
+++++
apply inclusion_impl_le_h.
-----
Theorem update_irr : forall g h : hedge, equal (irreducible (union (irreducible h) g)) (irreducible (union h g)).
intros.
apply equiv_irr_irr_impl_equal.
try apply irreducible_is_irreducible.
unfold equiv_h in |- *.
split.
apply le_h_trans with (irreducible (irreducible (union h g))).
apply le_h_irr_le_h.
apply le_h_le_h_impl_union_le_h.
apply le_h_trans with (irreducible g).
apply le_h_irr_le_h.
apply inclusion_impl_le_h.

*****
g,h : hedge
*****
inclusion g (union h g)
+++++
apply hedge_right_union.
-----
Theorem update_irr : forall g h : hedge, equal (irreducible (union (irreducible h) g)) (irreducible (union h g)).
intros.
apply equiv_irr_irr_impl_equal.
try apply irreducible_is_irreducible.
unfold equiv_h in |- *.
split.
apply le_h_trans with (irreducible (irreducible (union h g))).

*****
g,h : hedge
*****
le_h (irreducible (irreducible (union h g))) (irreducible (union h g))
+++++
generalize (irreducible_is_irreducible (union h g)).
-----
Theorem update_irr : forall g h : hedge, equal (irreducible (union (irreducible h) g)) (irreducible (union h g)).
intros.
apply equiv_irr_irr_impl_equal.
try apply irreducible_is_irreducible.
unfold equiv_h in |- *.
split.
apply le_h_trans with (irreducible (irreducible (union h g))).
generalize (irreducible_is_irreducible (union h g)).

*****
g,h : hedge
*****
forall _ : is_irreducible (irreducible (union h g)), le_h (irreducible (irreducible (union h g))) (irreducible (union h g))
+++++
unfold is_irreducible in |- *.
-----
Theorem update_irr : forall g h : hedge, equal (irreducible (union (irreducible h) g)) (irreducible (union h g)).
intros.
apply equiv_irr_irr_impl_equal.
try apply irreducible_is_irreducible.
unfold equiv_h in |- *.
split.
apply le_h_trans with (irreducible (irreducible (union h g))).
generalize (irreducible_is_irreducible (union h g)).
unfold is_irreducible in |- *.

*****
g,h : hedge
*****
forall _ : equal (irreducible (union h g)) (irreducible (irreducible (union h g))), le_h (irreducible (irreducible (union h g))) (irreducible (union h g))
+++++
unfold equal in |- *.
-----
Theorem update_irr : forall g h : hedge, equal (irreducible (union (irreducible h) g)) (irreducible (union h g)).
intros.
apply equiv_irr_irr_impl_equal.
try apply irreducible_is_irreducible.
unfold equiv_h in |- *.
split.
apply le_h_trans with (irreducible (irreducible (union h g))).
generalize (irreducible_is_irreducible (union h g)).
unfold is_irreducible in |- *.
unfold equal in |- *.

*****
g,h : hedge
*****
forall _ : and (inclusion (irreducible (union h g)) (irreducible (irreducible (union h g)))) (inclusion (irreducible (irreducible (union h g))) (irreducible (union h g))), le_h (irreducible (irreducible (union h g))) (irreducible (union h g))
+++++
intros.
-----
Theorem update_irr : forall g h : hedge, equal (irreducible (union (irreducible h) g)) (irreducible (union h g)).
intros.
apply equiv_irr_irr_impl_equal.
try apply irreducible_is_irreducible.
unfold equiv_h in |- *.
split.
apply le_h_trans with (irreducible (irreducible (union h g))).
generalize (irreducible_is_irreducible (union h g)).
unfold is_irreducible in |- *.
unfold equal in |- *.
intros.

*****
H : and\n (inclusion (irreducible (union h g))\n (irreducible (irreducible (union h g))))\n (inclusion (irreducible (irreducible (union h g)))\n (irreducible (union h g)))
g,h : hedge
*****
le_h (irreducible (irreducible (union h g))) (irreducible (union h g))
+++++
apply inclusion_impl_le_h.
-----
Theorem update_irr : forall g h : hedge, equal (irreducible (union (irreducible h) g)) (irreducible (union h g)).
intros.
apply equiv_irr_irr_impl_equal.
try apply irreducible_is_irreducible.
unfold equiv_h in |- *.
split.
apply le_h_trans with (irreducible (irreducible (union h g))).
generalize (irreducible_is_irreducible (union h g)).
unfold is_irreducible in |- *.
unfold equal in |- *.
intros.
apply inclusion_impl_le_h.

*****
H : and\n (inclusion (irreducible (union h g))\n (irreducible (irreducible (union h g))))\n (inclusion (irreducible (irreducible (union h g)))\n (irreducible (union h g)))
g,h : hedge
*****
inclusion (irreducible (irreducible (union h g))) (irreducible (union h g))
+++++
tauto.
-----
Theorem update_irr : forall g h : hedge, equal (irreducible (union (irreducible h) g)) (irreducible (union h g)).
intros.
apply equiv_irr_irr_impl_equal.
try apply irreducible_is_irreducible.
unfold equiv_h in |- *.
split.

*****
g,h : hedge
*****
le_h (irreducible (union h g)) (irreducible (union (irreducible h) g))
+++++
apply le_h_irr_le_h.
-----
Theorem update_irr : forall g h : hedge, equal (irreducible (union (irreducible h) g)) (irreducible (union h g)).
intros.
apply equiv_irr_irr_impl_equal.
try apply irreducible_is_irreducible.
unfold equiv_h in |- *.
split.
apply le_h_irr_le_h.

*****
g,h : hedge
*****
le_h (union h g) (union (irreducible h) g)
+++++
apply le_h_le_h_impl_le_h_union.
-----
Theorem update_irr : forall g h : hedge, equal (irreducible (union (irreducible h) g)) (irreducible (union h g)).
intros.
apply equiv_irr_irr_impl_equal.
try apply irreducible_is_irreducible.
unfold equiv_h in |- *.
split.
apply le_h_irr_le_h.
apply le_h_le_h_impl_le_h_union.

*****
g,h : hedge
*****
le_h h (irreducible h)
+++++
apply h_le_h_irr_h.
-----
Theorem update_irr : forall g h : hedge, equal (irreducible (union (irreducible h) g)) (irreducible (union h g)).
intros.
apply equiv_irr_irr_impl_equal.
try apply irreducible_is_irreducible.
unfold equiv_h in |- *.
split.
apply le_h_irr_le_h.
apply le_h_le_h_impl_le_h_union.

*****
g,h : hedge
*****
le_h g g
+++++
apply le_h_refl.
-----
Theorem update_irr : forall g h : hedge, equal (irreducible (union (irreducible h) g)) (irreducible (union h g)).
intros.
apply equiv_irr_irr_impl_equal.

*****
g,h : hedge
*****
is_irreducible (irreducible (union (irreducible h) g))
+++++
try apply irreducible_is_irreducible.
-----
Theorem update_irr : forall g h : hedge, equal (irreducible (union (irreducible h) g)) (irreducible (union h g)).
intros.
apply equiv_irr_irr_impl_equal.

*****
g,h : hedge
*****
is_irreducible (irreducible (union h g))
+++++
try apply irreducible_is_irreducible.
-----
Theorem update_irr : forall g h : hedge, equal (irreducible (union (irreducible h) g)) (irreducible (union h g)).
intros.
apply equiv_irr_irr_impl_equal.

*****

*****

+++++
Qed.
-----
Definition name_left_name (h : hedge) :=\n  forall M N : Msg,\n  h M N -> forall a : Nam, M = MNam a -> exists b : Nam, N = MNam b.
-----
Definition injective_left (h : hedge) :=\n  forall M N : Msg, h M N -> forall M' N' : Msg, h M' N' -> M = M' -> N = N'.
-----
Definition op_synthesis_left (h : hedge) :=\n  forall (o : op) (M N : Msg),\n  h M N ->\n  forall M' : Msg, M = Mop o M' -> forall N' : Msg, ~ synthesis h M' N'.
-----
Definition enc_synthesis_left (h : hedge) :=\n  forall M N : Msg,\n  h M N ->\n  forall M' K : Msg,\n  M = MEnc M' K ->\n  forall N' L : Msg, ~ synthesis h M' N' \/ ~ synthesis h K L.
-----
Definition pair_free_left (h : hedge) :=\n  forall M1 M2 N : Msg, ~ h (MPair M1 M2) N.
-----
Definition enc_analysis_left (h : hedge) :=\n  forall M N : Msg,\n  h M N ->\n  forall M' K : Msg,\n  M = MEnc M' K ->\n  forall L : Msg,\n  synthesis h (inv K) (inv L) ->\n  exists N' : Msg, N = MEnc N' L /\ synthesis h M' N'.
-----
Definition injective_inv_left (h : hedge) :=\n  forall M N : Msg,\n  h M N -> forall M' N' : Msg, h M' N' -> M' = inv M -> N' = inv N.
-----
Definition is_left_consistent (h : hedge) : Prop :=\n  name_left_name h /\\n  injective_left h /\\n  op_synthesis_left h /\\n  pair_free_left h /\\n  enc_synthesis_left h /\ enc_analysis_left h /\ injective_inv_left h.
-----
Definition weak_left_consistent (h : hedge) :=\n  name_left_name h /\\n  injective_left h /\\n  op_synthesis_left h /\\n  pair_free_left h /\ enc_synthesis_left h /\ enc_analysis_left h.
-----
Theorem inj_left_syn :\n forall h : hedge,\n injective_left h ->\n enc_synthesis_left h ->\n op_synthesis_left h -> pair_free_left h -> injective_left (synthesis h).
-----
Theorem inj_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_left (synthesis h).

*****

*****
forall (h : hedge) (_ : injective_left h) (_ : enc_synthesis_left h) (_ : op_synthesis_left h) (_ : pair_free_left h), injective_left (synthesis h)
+++++
unfold injective_left in |- *.
-----
Theorem inj_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_left (synthesis h).
unfold injective_left in |- *.

*****

*****
forall (h : hedge) (_ : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N') (_ : eq M M'), eq N N') (_ : enc_synthesis_left h) (_ : op_synthesis_left h) (_ : pair_free_left h) (M N : Msg) (_ : synthesis h M N) (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M M'), eq N N'
+++++
unfold enc_synthesis_left in |- *.
-----
Theorem inj_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_left (synthesis h).
unfold injective_left in |- *.
unfold enc_synthesis_left in |- *.

*****

*****
forall (h : hedge) (_ : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N') (_ : eq M M'), eq N N') (_ : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K)) (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))) (_ : op_synthesis_left h) (_ : pair_free_left h) (M N : Msg) (_ : synthesis h M N) (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M M'), eq N N'
+++++
unfold op_synthesis_left in |- *.
-----
Theorem inj_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_left (synthesis h).
unfold injective_left in |- *.
unfold enc_synthesis_left in |- *.
unfold op_synthesis_left in |- *.

*****

*****
forall (h : hedge) (_ : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N') (_ : eq M M'), eq N N') (_ : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K)) (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))) (_ : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg) (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')) (_ : pair_free_left h) (M N : Msg) (_ : synthesis h M N) (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M M'), eq N N'
+++++
unfold pair_free_left in |- *.
-----
Theorem inj_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_left (synthesis h).
unfold injective_left in |- *.
unfold enc_synthesis_left in |- *.
unfold op_synthesis_left in |- *.
unfold pair_free_left in |- *.

*****

*****
forall (h : hedge) (_ : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N') (_ : eq M M'), eq N N') (_ : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K)) (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))) (_ : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg) (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')) (_ : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)) (M N : Msg) (_ : synthesis h M N) (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M M'), eq N N'
+++++
intro h.
-----
Theorem inj_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_left (synthesis h).
unfold injective_left in |- *.
unfold enc_synthesis_left in |- *.
unfold op_synthesis_left in |- *.
unfold pair_free_left in |- *.
intro h.

*****
h : hedge
*****
forall (_ : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N') (_ : eq M M'), eq N N') (_ : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K)) (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))) (_ : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg) (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')) (_ : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)) (M N : Msg) (_ : synthesis h M N) (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M M'), eq N N'
+++++
intro.
-----
Theorem inj_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_left (synthesis h).
unfold injective_left in |- *.
unfold enc_synthesis_left in |- *.
unfold op_synthesis_left in |- *.
unfold pair_free_left in |- *.
intro h.
intro.

*****
H : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
forall (_ : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K)) (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))) (_ : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg) (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')) (_ : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)) (M N : Msg) (_ : synthesis h M N) (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M M'), eq N N'
+++++
intro.
-----
Theorem inj_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_left (synthesis h).
unfold injective_left in |- *.
unfold enc_synthesis_left in |- *.
unfold op_synthesis_left in |- *.
unfold pair_free_left in |- *.
intro h.
intro.
intro.

*****
H0 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
forall (_ : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg) (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')) (_ : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)) (M N : Msg) (_ : synthesis h M N) (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M M'), eq N N'
+++++
intro.
-----
Theorem inj_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_left (synthesis h).
unfold injective_left in |- *.
unfold enc_synthesis_left in |- *.
unfold op_synthesis_left in |- *.
unfold pair_free_left in |- *.
intro h.
intro.
intro.
intro.

*****
H1 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H0 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
forall (_ : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)) (M N : Msg) (_ : synthesis h M N) (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M M'), eq N N'
+++++
intro.
-----
Theorem inj_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_left (synthesis h).
unfold injective_left in |- *.
unfold enc_synthesis_left in |- *.
unfold op_synthesis_left in |- *.
unfold pair_free_left in |- *.
intro h.
intro.
intro.
intro.
intro.

*****
H2 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H1 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H0 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
forall (M N : Msg) (_ : synthesis h M N) (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M M'), eq N N'
+++++
intros M N H3.
-----
Theorem inj_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_left (synthesis h).
unfold injective_left in |- *.
unfold enc_synthesis_left in |- *.
unfold op_synthesis_left in |- *.
unfold pair_free_left in |- *.
intro h.
intro.
intro.
intro.
intro.
intros M N H3.

*****
H3 : synthesis h M N
M,N : Msg
H2 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H1 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H0 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M M'), eq N N'
+++++
induction H3 as [M N H3| M N K L H3_1 HrecH3_1 H3_0 HrecH3_0| M1 N1 M2 N2 H3_1 HrecH3_1 H3_0 HrecH3_0| o M N H3 HrecH3]; intros M' N' H4; [ induction H4 as [M0 N0 H4| M0 N0 K L H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o M0 N0 H4 HrecH4] | induction H4 as [M0 N0 H3| M0 N0 K0 L0 H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o M0 N0 H4 HrecH4] | induction H4 as [M N H3| M N K L H4_1 HrecH4_1 H4_0 HrecH4_0| M0 N0 M3 N3 H4_1 HrecH4_1 H4_0 HrecH4_0| o M N H4 HrecH4] | induction H4 as [M0 N0 H4| M0 N0 K L H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o0 M0 N0 H4 HrecH4] ].
-----
Theorem inj_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_left (synthesis h).
unfold injective_left in |- *.
unfold enc_synthesis_left in |- *.
unfold op_synthesis_left in |- *.
unfold pair_free_left in |- *.
intro h.
intro.
intro.
intro.
intro.
intros M N H3.
induction H3 as [M N H3| M N K L H3_1 HrecH3_1 H3_0 HrecH3_0| M1 N1 M2 N2 H3_1 HrecH3_1 H3_0 HrecH3_0| o M N H3 HrecH3]; intros M' N' H4; [ induction H4 as [M0 N0 H4| M0 N0 K L H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o M0 N0 H4 HrecH4] | induction H4 as [M0 N0 H3| M0 N0 K0 L0 H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o M0 N0 H4 HrecH4] | induction H4 as [M N H3| M N K L H4_1 HrecH4_1 H4_0 HrecH4_0| M0 N0 M3 N3 H4_1 HrecH4_1 H4_0 HrecH4_0| o M N H4 HrecH4] | induction H4 as [M0 N0 H4| M0 N0 K L H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o0 M0 N0 H4 HrecH4] ].

*****
H4 : h M0 N0
M0,N0 : Msg
H3 : h M N
M,N : Msg
H2 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H1 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H0 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
forall _ : eq M M0, eq N N0
+++++
intro.
-----
Theorem inj_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_left (synthesis h).
unfold injective_left in |- *.
unfold enc_synthesis_left in |- *.
unfold op_synthesis_left in |- *.
unfold pair_free_left in |- *.
intro h.
intro.
intro.
intro.
intro.
intros M N H3.
induction H3 as [M N H3| M N K L H3_1 HrecH3_1 H3_0 HrecH3_0| M1 N1 M2 N2 H3_1 HrecH3_1 H3_0 HrecH3_0| o M N H3 HrecH3]; intros M' N' H4; [ induction H4 as [M0 N0 H4| M0 N0 K L H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o M0 N0 H4 HrecH4] | induction H4 as [M0 N0 H3| M0 N0 K0 L0 H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o M0 N0 H4 HrecH4] | induction H4 as [M N H3| M N K L H4_1 HrecH4_1 H4_0 HrecH4_0| M0 N0 M3 N3 H4_1 HrecH4_1 H4_0 HrecH4_0| o M N H4 HrecH4] | induction H4 as [M0 N0 H4| M0 N0 K L H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o0 M0 N0 H4 HrecH4] ].
intro.

*****
H5 : eq M M0
H4 : h M0 N0
M0,N0 : Msg
H3 : h M N
M,N : Msg
H2 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H1 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H0 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
eq N N0
+++++
exact (H M N H3 M0 N0 H4 H5).
-----
Theorem inj_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_left (synthesis h).
unfold injective_left in |- *.
unfold enc_synthesis_left in |- *.
unfold op_synthesis_left in |- *.
unfold pair_free_left in |- *.
intro h.
intro.
intro.
intro.
intro.
intros M N H3.
induction H3 as [M N H3| M N K L H3_1 HrecH3_1 H3_0 HrecH3_0| M1 N1 M2 N2 H3_1 HrecH3_1 H3_0 HrecH3_0| o M N H3 HrecH3]; intros M' N' H4; [ induction H4 as [M0 N0 H4| M0 N0 K L H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o M0 N0 H4 HrecH4] | induction H4 as [M0 N0 H3| M0 N0 K0 L0 H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o M0 N0 H4 HrecH4] | induction H4 as [M N H3| M N K L H4_1 HrecH4_1 H4_0 HrecH4_0| M0 N0 M3 N3 H4_1 HrecH4_1 H4_0 HrecH4_0| o M N H4 HrecH4] | induction H4 as [M0 N0 H4| M0 N0 K L H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o0 M0 N0 H4 HrecH4] ].
intro.
exact (H M N H3 M0 N0 H4 H5).

*****
HrecH4_0 : forall _ : eq M K, eq N L
HrecH4_1 : forall _ : eq M M0, eq N N0
H4_0 : synthesis h K L
H4_1 : synthesis h M0 N0
M0,N0,K,L : Msg
H3 : h M N
M,N : Msg
H2 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H1 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H0 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
forall _ : eq M (MEnc M0 K), eq N (MEnc N0 L)
+++++
intro.
-----
Theorem inj_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_left (synthesis h).
unfold injective_left in |- *.
unfold enc_synthesis_left in |- *.
unfold op_synthesis_left in |- *.
unfold pair_free_left in |- *.
intro h.
intro.
intro.
intro.
intro.
intros M N H3.
induction H3 as [M N H3| M N K L H3_1 HrecH3_1 H3_0 HrecH3_0| M1 N1 M2 N2 H3_1 HrecH3_1 H3_0 HrecH3_0| o M N H3 HrecH3]; intros M' N' H4; [ induction H4 as [M0 N0 H4| M0 N0 K L H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o M0 N0 H4 HrecH4] | induction H4 as [M0 N0 H3| M0 N0 K0 L0 H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o M0 N0 H4 HrecH4] | induction H4 as [M N H3| M N K L H4_1 HrecH4_1 H4_0 HrecH4_0| M0 N0 M3 N3 H4_1 HrecH4_1 H4_0 HrecH4_0| o M N H4 HrecH4] | induction H4 as [M0 N0 H4| M0 N0 K L H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o0 M0 N0 H4 HrecH4] ].
intro.
exact (H M N H3 M0 N0 H4 H5).
intro.

*****
H4 : eq M (MEnc M0 K)
HrecH4_0 : forall _ : eq M K, eq N L
HrecH4_1 : forall _ : eq M M0, eq N N0
H4_0 : synthesis h K L
H4_1 : synthesis h M0 N0
M0,N0,K,L : Msg
H3 : h M N
M,N : Msg
H2 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H1 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H0 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
eq N (MEnc N0 L)
+++++
cut (~ synthesis h M0 N0 \/ ~ synthesis h K L).
-----
Theorem inj_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_left (synthesis h).
unfold injective_left in |- *.
unfold enc_synthesis_left in |- *.
unfold op_synthesis_left in |- *.
unfold pair_free_left in |- *.
intro h.
intro.
intro.
intro.
intro.
intros M N H3.
induction H3 as [M N H3| M N K L H3_1 HrecH3_1 H3_0 HrecH3_0| M1 N1 M2 N2 H3_1 HrecH3_1 H3_0 HrecH3_0| o M N H3 HrecH3]; intros M' N' H4; [ induction H4 as [M0 N0 H4| M0 N0 K L H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o M0 N0 H4 HrecH4] | induction H4 as [M0 N0 H3| M0 N0 K0 L0 H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o M0 N0 H4 HrecH4] | induction H4 as [M N H3| M N K L H4_1 HrecH4_1 H4_0 HrecH4_0| M0 N0 M3 N3 H4_1 HrecH4_1 H4_0 HrecH4_0| o M N H4 HrecH4] | induction H4 as [M0 N0 H4| M0 N0 K L H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o0 M0 N0 H4 HrecH4] ].
intro.
exact (H M N H3 M0 N0 H4 H5).
intro.
cut (~ synthesis h M0 N0 \\/ ~ synthesis h K L).

*****
H4 : eq M (MEnc M0 K)
HrecH4_0 : forall _ : eq M K, eq N L
HrecH4_1 : forall _ : eq M M0, eq N N0
H4_0 : synthesis h K L
H4_1 : synthesis h M0 N0
M0,N0,K,L : Msg
H3 : h M N
M,N : Msg
H2 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H1 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H0 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
forall _ : or (not (synthesis h M0 N0)) (not (synthesis h K L)), eq N (MEnc N0 L)
+++++
intro.
-----
Theorem inj_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_left (synthesis h).
unfold injective_left in |- *.
unfold enc_synthesis_left in |- *.
unfold op_synthesis_left in |- *.
unfold pair_free_left in |- *.
intro h.
intro.
intro.
intro.
intro.
intros M N H3.
induction H3 as [M N H3| M N K L H3_1 HrecH3_1 H3_0 HrecH3_0| M1 N1 M2 N2 H3_1 HrecH3_1 H3_0 HrecH3_0| o M N H3 HrecH3]; intros M' N' H4; [ induction H4 as [M0 N0 H4| M0 N0 K L H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o M0 N0 H4 HrecH4] | induction H4 as [M0 N0 H3| M0 N0 K0 L0 H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o M0 N0 H4 HrecH4] | induction H4 as [M N H3| M N K L H4_1 HrecH4_1 H4_0 HrecH4_0| M0 N0 M3 N3 H4_1 HrecH4_1 H4_0 HrecH4_0| o M N H4 HrecH4] | induction H4 as [M0 N0 H4| M0 N0 K L H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o0 M0 N0 H4 HrecH4] ].
intro.
exact (H M N H3 M0 N0 H4 H5).
intro.
cut (~ synthesis h M0 N0 \\/ ~ synthesis h K L).
intro.

*****
H5 : or (not (synthesis h M0 N0)) (not (synthesis h K L))
H4 : eq M (MEnc M0 K)
HrecH4_0 : forall _ : eq M K, eq N L
HrecH4_1 : forall _ : eq M M0, eq N N0
H4_0 : synthesis h K L
H4_1 : synthesis h M0 N0
M0,N0,K,L : Msg
H3 : h M N
M,N : Msg
H2 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H1 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H0 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
eq N (MEnc N0 L)
+++++
case H5; intro H6; red in H6; tauto.
-----
Theorem inj_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_left (synthesis h).
unfold injective_left in |- *.
unfold enc_synthesis_left in |- *.
unfold op_synthesis_left in |- *.
unfold pair_free_left in |- *.
intro h.
intro.
intro.
intro.
intro.
intros M N H3.
induction H3 as [M N H3| M N K L H3_1 HrecH3_1 H3_0 HrecH3_0| M1 N1 M2 N2 H3_1 HrecH3_1 H3_0 HrecH3_0| o M N H3 HrecH3]; intros M' N' H4; [ induction H4 as [M0 N0 H4| M0 N0 K L H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o M0 N0 H4 HrecH4] | induction H4 as [M0 N0 H3| M0 N0 K0 L0 H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o M0 N0 H4 HrecH4] | induction H4 as [M N H3| M N K L H4_1 HrecH4_1 H4_0 HrecH4_0| M0 N0 M3 N3 H4_1 HrecH4_1 H4_0 HrecH4_0| o M N H4 HrecH4] | induction H4 as [M0 N0 H4| M0 N0 K L H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o0 M0 N0 H4 HrecH4] ].
intro.
exact (H M N H3 M0 N0 H4 H5).
intro.
cut (~ synthesis h M0 N0 \\/ ~ synthesis h K L).
intro.
case H5; intro H6; red in H6; tauto.

*****
H4 : eq M (MEnc M0 K)
HrecH4_0 : forall _ : eq M K, eq N L
HrecH4_1 : forall _ : eq M M0, eq N N0
H4_0 : synthesis h K L
H4_1 : synthesis h M0 N0
M0,N0,K,L : Msg
H3 : h M N
M,N : Msg
H2 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H1 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H0 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
or (not (synthesis h M0 N0)) (not (synthesis h K L))
+++++
apply (H0 M N H3 M0 K H4).
-----
Theorem inj_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_left (synthesis h).
unfold injective_left in |- *.
unfold enc_synthesis_left in |- *.
unfold op_synthesis_left in |- *.
unfold pair_free_left in |- *.
intro h.
intro.
intro.
intro.
intro.
intros M N H3.
induction H3 as [M N H3| M N K L H3_1 HrecH3_1 H3_0 HrecH3_0| M1 N1 M2 N2 H3_1 HrecH3_1 H3_0 HrecH3_0| o M N H3 HrecH3]; intros M' N' H4; [ induction H4 as [M0 N0 H4| M0 N0 K L H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o M0 N0 H4 HrecH4] | induction H4 as [M0 N0 H3| M0 N0 K0 L0 H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o M0 N0 H4 HrecH4] | induction H4 as [M N H3| M N K L H4_1 HrecH4_1 H4_0 HrecH4_0| M0 N0 M3 N3 H4_1 HrecH4_1 H4_0 HrecH4_0| o M N H4 HrecH4] | induction H4 as [M0 N0 H4| M0 N0 K L H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o0 M0 N0 H4 HrecH4] ].
intro.
exact (H M N H3 M0 N0 H4 H5).
intro.
cut (~ synthesis h M0 N0 \\/ ~ synthesis h K L).
intro.
case H5; intro H6; red in H6; tauto.
apply (H0 M N H3 M0 K H4).

*****
HrecH4_0 : forall _ : eq M M2, eq N N2
HrecH4_1 : forall _ : eq M M1, eq N N1
H4_0 : synthesis h M2 N2
H4_1 : synthesis h M1 N1
M1,N1,M2,N2 : Msg
H3 : h M N
M,N : Msg
H2 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H1 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H0 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
forall _ : eq M (MPair M1 M2), eq N (MPair N1 N2)
+++++
intro.
-----
Theorem inj_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_left (synthesis h).
unfold injective_left in |- *.
unfold enc_synthesis_left in |- *.
unfold op_synthesis_left in |- *.
unfold pair_free_left in |- *.
intro h.
intro.
intro.
intro.
intro.
intros M N H3.
induction H3 as [M N H3| M N K L H3_1 HrecH3_1 H3_0 HrecH3_0| M1 N1 M2 N2 H3_1 HrecH3_1 H3_0 HrecH3_0| o M N H3 HrecH3]; intros M' N' H4; [ induction H4 as [M0 N0 H4| M0 N0 K L H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o M0 N0 H4 HrecH4] | induction H4 as [M0 N0 H3| M0 N0 K0 L0 H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o M0 N0 H4 HrecH4] | induction H4 as [M N H3| M N K L H4_1 HrecH4_1 H4_0 HrecH4_0| M0 N0 M3 N3 H4_1 HrecH4_1 H4_0 HrecH4_0| o M N H4 HrecH4] | induction H4 as [M0 N0 H4| M0 N0 K L H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o0 M0 N0 H4 HrecH4] ].
intro.
exact (H M N H3 M0 N0 H4 H5).
intro.
cut (~ synthesis h M0 N0 \\/ ~ synthesis h K L).
intro.
case H5; intro H6; red in H6; tauto.
apply (H0 M N H3 M0 K H4).
intro.

*****
H4 : eq M (MPair M1 M2)
HrecH4_0 : forall _ : eq M M2, eq N N2
HrecH4_1 : forall _ : eq M M1, eq N N1
H4_0 : synthesis h M2 N2
H4_1 : synthesis h M1 N1
M1,N1,M2,N2 : Msg
H3 : h M N
M,N : Msg
H2 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H1 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H0 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
eq N (MPair N1 N2)
+++++
rewrite H4 in H3.
-----
Theorem inj_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_left (synthesis h).
unfold injective_left in |- *.
unfold enc_synthesis_left in |- *.
unfold op_synthesis_left in |- *.
unfold pair_free_left in |- *.
intro h.
intro.
intro.
intro.
intro.
intros M N H3.
induction H3 as [M N H3| M N K L H3_1 HrecH3_1 H3_0 HrecH3_0| M1 N1 M2 N2 H3_1 HrecH3_1 H3_0 HrecH3_0| o M N H3 HrecH3]; intros M' N' H4; [ induction H4 as [M0 N0 H4| M0 N0 K L H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o M0 N0 H4 HrecH4] | induction H4 as [M0 N0 H3| M0 N0 K0 L0 H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o M0 N0 H4 HrecH4] | induction H4 as [M N H3| M N K L H4_1 HrecH4_1 H4_0 HrecH4_0| M0 N0 M3 N3 H4_1 HrecH4_1 H4_0 HrecH4_0| o M N H4 HrecH4] | induction H4 as [M0 N0 H4| M0 N0 K L H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o0 M0 N0 H4 HrecH4] ].
intro.
exact (H M N H3 M0 N0 H4 H5).
intro.
cut (~ synthesis h M0 N0 \\/ ~ synthesis h K L).
intro.
case H5; intro H6; red in H6; tauto.
apply (H0 M N H3 M0 K H4).
intro.
rewrite H4 in H3.

*****
H4 : eq M (MPair M1 M2)
HrecH4_0 : forall _ : eq M M2, eq N N2
HrecH4_1 : forall _ : eq M M1, eq N N1
H4_0 : synthesis h M2 N2
H4_1 : synthesis h M1 N1
N1,N2 : Msg
H3 : h (MPair M1 M2) N
M,N,M1,M2 : Msg
H2 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H1 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H0 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
eq N (MPair N1 N2)
+++++
cut False.
-----
Theorem inj_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_left (synthesis h).
unfold injective_left in |- *.
unfold enc_synthesis_left in |- *.
unfold op_synthesis_left in |- *.
unfold pair_free_left in |- *.
intro h.
intro.
intro.
intro.
intro.
intros M N H3.
induction H3 as [M N H3| M N K L H3_1 HrecH3_1 H3_0 HrecH3_0| M1 N1 M2 N2 H3_1 HrecH3_1 H3_0 HrecH3_0| o M N H3 HrecH3]; intros M' N' H4; [ induction H4 as [M0 N0 H4| M0 N0 K L H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o M0 N0 H4 HrecH4] | induction H4 as [M0 N0 H3| M0 N0 K0 L0 H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o M0 N0 H4 HrecH4] | induction H4 as [M N H3| M N K L H4_1 HrecH4_1 H4_0 HrecH4_0| M0 N0 M3 N3 H4_1 HrecH4_1 H4_0 HrecH4_0| o M N H4 HrecH4] | induction H4 as [M0 N0 H4| M0 N0 K L H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o0 M0 N0 H4 HrecH4] ].
intro.
exact (H M N H3 M0 N0 H4 H5).
intro.
cut (~ synthesis h M0 N0 \\/ ~ synthesis h K L).
intro.
case H5; intro H6; red in H6; tauto.
apply (H0 M N H3 M0 K H4).
intro.
rewrite H4 in H3.
cut False.

*****
H4 : eq M (MPair M1 M2)
HrecH4_0 : forall _ : eq M M2, eq N N2
HrecH4_1 : forall _ : eq M M1, eq N N1
H4_0 : synthesis h M2 N2
H4_1 : synthesis h M1 N1
N1,N2 : Msg
H3 : h (MPair M1 M2) N
M,N,M1,M2 : Msg
H2 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H1 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H0 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
forall _ : False, eq N (MPair N1 N2)
+++++
tauto.
-----
Theorem inj_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_left (synthesis h).
unfold injective_left in |- *.
unfold enc_synthesis_left in |- *.
unfold op_synthesis_left in |- *.
unfold pair_free_left in |- *.
intro h.
intro.
intro.
intro.
intro.
intros M N H3.
induction H3 as [M N H3| M N K L H3_1 HrecH3_1 H3_0 HrecH3_0| M1 N1 M2 N2 H3_1 HrecH3_1 H3_0 HrecH3_0| o M N H3 HrecH3]; intros M' N' H4; [ induction H4 as [M0 N0 H4| M0 N0 K L H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o M0 N0 H4 HrecH4] | induction H4 as [M0 N0 H3| M0 N0 K0 L0 H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o M0 N0 H4 HrecH4] | induction H4 as [M N H3| M N K L H4_1 HrecH4_1 H4_0 HrecH4_0| M0 N0 M3 N3 H4_1 HrecH4_1 H4_0 HrecH4_0| o M N H4 HrecH4] | induction H4 as [M0 N0 H4| M0 N0 K L H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o0 M0 N0 H4 HrecH4] ].
intro.
exact (H M N H3 M0 N0 H4 H5).
intro.
cut (~ synthesis h M0 N0 \\/ ~ synthesis h K L).
intro.
case H5; intro H6; red in H6; tauto.
apply (H0 M N H3 M0 K H4).
intro.
rewrite H4 in H3.
cut False.
tauto.

*****
H4 : eq M (MPair M1 M2)
HrecH4_0 : forall _ : eq M M2, eq N N2
HrecH4_1 : forall _ : eq M M1, eq N N1
H4_0 : synthesis h M2 N2
H4_1 : synthesis h M1 N1
N1,N2 : Msg
H3 : h (MPair M1 M2) N
M,N,M1,M2 : Msg
H2 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H1 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H0 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
False
+++++
apply (H2 M1 M2 N); trivial.
-----
Theorem inj_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_left (synthesis h).
unfold injective_left in |- *.
unfold enc_synthesis_left in |- *.
unfold op_synthesis_left in |- *.
unfold pair_free_left in |- *.
intro h.
intro.
intro.
intro.
intro.
intros M N H3.
induction H3 as [M N H3| M N K L H3_1 HrecH3_1 H3_0 HrecH3_0| M1 N1 M2 N2 H3_1 HrecH3_1 H3_0 HrecH3_0| o M N H3 HrecH3]; intros M' N' H4; [ induction H4 as [M0 N0 H4| M0 N0 K L H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o M0 N0 H4 HrecH4] | induction H4 as [M0 N0 H3| M0 N0 K0 L0 H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o M0 N0 H4 HrecH4] | induction H4 as [M N H3| M N K L H4_1 HrecH4_1 H4_0 HrecH4_0| M0 N0 M3 N3 H4_1 HrecH4_1 H4_0 HrecH4_0| o M N H4 HrecH4] | induction H4 as [M0 N0 H4| M0 N0 K L H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o0 M0 N0 H4 HrecH4] ].
intro.
exact (H M N H3 M0 N0 H4 H5).
intro.
cut (~ synthesis h M0 N0 \\/ ~ synthesis h K L).
intro.
case H5; intro H6; red in H6; tauto.
apply (H0 M N H3 M0 K H4).
intro.
rewrite H4 in H3.
cut False.
tauto.
apply (H2 M1 M2 N); trivial.

*****
HrecH4 : forall _ : eq M M0, eq N N0
H4 : synthesis h M0 N0
M0,N0 : Msg
o : op
H3 : h M N
M,N : Msg
H2 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H1 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H0 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
forall _ : eq M (Mop o M0), eq N (Mop o N0)
+++++
intro.
-----
Theorem inj_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_left (synthesis h).
unfold injective_left in |- *.
unfold enc_synthesis_left in |- *.
unfold op_synthesis_left in |- *.
unfold pair_free_left in |- *.
intro h.
intro.
intro.
intro.
intro.
intros M N H3.
induction H3 as [M N H3| M N K L H3_1 HrecH3_1 H3_0 HrecH3_0| M1 N1 M2 N2 H3_1 HrecH3_1 H3_0 HrecH3_0| o M N H3 HrecH3]; intros M' N' H4; [ induction H4 as [M0 N0 H4| M0 N0 K L H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o M0 N0 H4 HrecH4] | induction H4 as [M0 N0 H3| M0 N0 K0 L0 H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o M0 N0 H4 HrecH4] | induction H4 as [M N H3| M N K L H4_1 HrecH4_1 H4_0 HrecH4_0| M0 N0 M3 N3 H4_1 HrecH4_1 H4_0 HrecH4_0| o M N H4 HrecH4] | induction H4 as [M0 N0 H4| M0 N0 K L H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o0 M0 N0 H4 HrecH4] ].
intro.
exact (H M N H3 M0 N0 H4 H5).
intro.
cut (~ synthesis h M0 N0 \\/ ~ synthesis h K L).
intro.
case H5; intro H6; red in H6; tauto.
apply (H0 M N H3 M0 K H4).
intro.
rewrite H4 in H3.
cut False.
tauto.
apply (H2 M1 M2 N); trivial.
intro.

*****
H5 : eq M (Mop o M0)
HrecH4 : forall _ : eq M M0, eq N N0
H4 : synthesis h M0 N0
M0,N0 : Msg
o : op
H3 : h M N
M,N : Msg
H2 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H1 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H0 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
eq N (Mop o N0)
+++++
cut (~ synthesis h M0 N0).
-----
Theorem inj_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_left (synthesis h).
unfold injective_left in |- *.
unfold enc_synthesis_left in |- *.
unfold op_synthesis_left in |- *.
unfold pair_free_left in |- *.
intro h.
intro.
intro.
intro.
intro.
intros M N H3.
induction H3 as [M N H3| M N K L H3_1 HrecH3_1 H3_0 HrecH3_0| M1 N1 M2 N2 H3_1 HrecH3_1 H3_0 HrecH3_0| o M N H3 HrecH3]; intros M' N' H4; [ induction H4 as [M0 N0 H4| M0 N0 K L H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o M0 N0 H4 HrecH4] | induction H4 as [M0 N0 H3| M0 N0 K0 L0 H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o M0 N0 H4 HrecH4] | induction H4 as [M N H3| M N K L H4_1 HrecH4_1 H4_0 HrecH4_0| M0 N0 M3 N3 H4_1 HrecH4_1 H4_0 HrecH4_0| o M N H4 HrecH4] | induction H4 as [M0 N0 H4| M0 N0 K L H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o0 M0 N0 H4 HrecH4] ].
intro.
exact (H M N H3 M0 N0 H4 H5).
intro.
cut (~ synthesis h M0 N0 \\/ ~ synthesis h K L).
intro.
case H5; intro H6; red in H6; tauto.
apply (H0 M N H3 M0 K H4).
intro.
rewrite H4 in H3.
cut False.
tauto.
apply (H2 M1 M2 N); trivial.
intro.
cut (~ synthesis h M0 N0).

*****
H5 : eq M (Mop o M0)
HrecH4 : forall _ : eq M M0, eq N N0
H4 : synthesis h M0 N0
M0,N0 : Msg
o : op
H3 : h M N
M,N : Msg
H2 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H1 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H0 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
forall _ : not (synthesis h M0 N0), eq N (Mop o N0)
+++++
intro.
-----
Theorem inj_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_left (synthesis h).
unfold injective_left in |- *.
unfold enc_synthesis_left in |- *.
unfold op_synthesis_left in |- *.
unfold pair_free_left in |- *.
intro h.
intro.
intro.
intro.
intro.
intros M N H3.
induction H3 as [M N H3| M N K L H3_1 HrecH3_1 H3_0 HrecH3_0| M1 N1 M2 N2 H3_1 HrecH3_1 H3_0 HrecH3_0| o M N H3 HrecH3]; intros M' N' H4; [ induction H4 as [M0 N0 H4| M0 N0 K L H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o M0 N0 H4 HrecH4] | induction H4 as [M0 N0 H3| M0 N0 K0 L0 H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o M0 N0 H4 HrecH4] | induction H4 as [M N H3| M N K L H4_1 HrecH4_1 H4_0 HrecH4_0| M0 N0 M3 N3 H4_1 HrecH4_1 H4_0 HrecH4_0| o M N H4 HrecH4] | induction H4 as [M0 N0 H4| M0 N0 K L H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o0 M0 N0 H4 HrecH4] ].
intro.
exact (H M N H3 M0 N0 H4 H5).
intro.
cut (~ synthesis h M0 N0 \\/ ~ synthesis h K L).
intro.
case H5; intro H6; red in H6; tauto.
apply (H0 M N H3 M0 K H4).
intro.
rewrite H4 in H3.
cut False.
tauto.
apply (H2 M1 M2 N); trivial.
intro.
cut (~ synthesis h M0 N0).
intro.

*****
H6 : not (synthesis h M0 N0)
H5 : eq M (Mop o M0)
HrecH4 : forall _ : eq M M0, eq N N0
H4 : synthesis h M0 N0
M0,N0 : Msg
o : op
H3 : h M N
M,N : Msg
H2 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H1 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H0 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
eq N (Mop o N0)
+++++
tauto.
-----
Theorem inj_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_left (synthesis h).
unfold injective_left in |- *.
unfold enc_synthesis_left in |- *.
unfold op_synthesis_left in |- *.
unfold pair_free_left in |- *.
intro h.
intro.
intro.
intro.
intro.
intros M N H3.
induction H3 as [M N H3| M N K L H3_1 HrecH3_1 H3_0 HrecH3_0| M1 N1 M2 N2 H3_1 HrecH3_1 H3_0 HrecH3_0| o M N H3 HrecH3]; intros M' N' H4; [ induction H4 as [M0 N0 H4| M0 N0 K L H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o M0 N0 H4 HrecH4] | induction H4 as [M0 N0 H3| M0 N0 K0 L0 H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o M0 N0 H4 HrecH4] | induction H4 as [M N H3| M N K L H4_1 HrecH4_1 H4_0 HrecH4_0| M0 N0 M3 N3 H4_1 HrecH4_1 H4_0 HrecH4_0| o M N H4 HrecH4] | induction H4 as [M0 N0 H4| M0 N0 K L H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o0 M0 N0 H4 HrecH4] ].
intro.
exact (H M N H3 M0 N0 H4 H5).
intro.
cut (~ synthesis h M0 N0 \\/ ~ synthesis h K L).
intro.
case H5; intro H6; red in H6; tauto.
apply (H0 M N H3 M0 K H4).
intro.
rewrite H4 in H3.
cut False.
tauto.
apply (H2 M1 M2 N); trivial.
intro.
cut (~ synthesis h M0 N0).
intro.
tauto.

*****
H5 : eq M (Mop o M0)
HrecH4 : forall _ : eq M M0, eq N N0
H4 : synthesis h M0 N0
M0,N0 : Msg
o : op
H3 : h M N
M,N : Msg
H2 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H1 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H0 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
not (synthesis h M0 N0)
+++++
apply (H1 o M N H3 M0 H5); trivial.
-----
Theorem inj_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_left (synthesis h).
unfold injective_left in |- *.
unfold enc_synthesis_left in |- *.
unfold op_synthesis_left in |- *.
unfold pair_free_left in |- *.
intro h.
intro.
intro.
intro.
intro.
intros M N H3.
induction H3 as [M N H3| M N K L H3_1 HrecH3_1 H3_0 HrecH3_0| M1 N1 M2 N2 H3_1 HrecH3_1 H3_0 HrecH3_0| o M N H3 HrecH3]; intros M' N' H4; [ induction H4 as [M0 N0 H4| M0 N0 K L H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o M0 N0 H4 HrecH4] | induction H4 as [M0 N0 H3| M0 N0 K0 L0 H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o M0 N0 H4 HrecH4] | induction H4 as [M N H3| M N K L H4_1 HrecH4_1 H4_0 HrecH4_0| M0 N0 M3 N3 H4_1 HrecH4_1 H4_0 HrecH4_0| o M N H4 HrecH4] | induction H4 as [M0 N0 H4| M0 N0 K L H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o0 M0 N0 H4 HrecH4] ].
intro.
exact (H M N H3 M0 N0 H4 H5).
intro.
cut (~ synthesis h M0 N0 \\/ ~ synthesis h K L).
intro.
case H5; intro H6; red in H6; tauto.
apply (H0 M N H3 M0 K H4).
intro.
rewrite H4 in H3.
cut False.
tauto.
apply (H2 M1 M2 N); trivial.
intro.
cut (~ synthesis h M0 N0).
intro.
tauto.
apply (H1 o M N H3 M0 H5); trivial.

*****
H3 : h M0 N0
M0,N0 : Msg
HrecH3_0 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq K M'), eq L N'
HrecH3_1 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M M'), eq N N'
H3_0 : synthesis h K L
H3_1 : synthesis h M N
M,N,K,L : Msg
H2 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H1 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H0 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
forall _ : eq (MEnc M K) M0, eq (MEnc N L) N0
+++++
intro.
-----
Theorem inj_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_left (synthesis h).
unfold injective_left in |- *.
unfold enc_synthesis_left in |- *.
unfold op_synthesis_left in |- *.
unfold pair_free_left in |- *.
intro h.
intro.
intro.
intro.
intro.
intros M N H3.
induction H3 as [M N H3| M N K L H3_1 HrecH3_1 H3_0 HrecH3_0| M1 N1 M2 N2 H3_1 HrecH3_1 H3_0 HrecH3_0| o M N H3 HrecH3]; intros M' N' H4; [ induction H4 as [M0 N0 H4| M0 N0 K L H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o M0 N0 H4 HrecH4] | induction H4 as [M0 N0 H3| M0 N0 K0 L0 H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o M0 N0 H4 HrecH4] | induction H4 as [M N H3| M N K L H4_1 HrecH4_1 H4_0 HrecH4_0| M0 N0 M3 N3 H4_1 HrecH4_1 H4_0 HrecH4_0| o M N H4 HrecH4] | induction H4 as [M0 N0 H4| M0 N0 K L H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o0 M0 N0 H4 HrecH4] ].
intro.
exact (H M N H3 M0 N0 H4 H5).
intro.
cut (~ synthesis h M0 N0 \\/ ~ synthesis h K L).
intro.
case H5; intro H6; red in H6; tauto.
apply (H0 M N H3 M0 K H4).
intro.
rewrite H4 in H3.
cut False.
tauto.
apply (H2 M1 M2 N); trivial.
intro.
cut (~ synthesis h M0 N0).
intro.
tauto.
apply (H1 o M N H3 M0 H5); trivial.
intro.

*****
H4 : eq (MEnc M K) M0
H3 : h M0 N0
M0,N0 : Msg
HrecH3_0 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq K M'), eq L N'
HrecH3_1 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M M'), eq N N'
H3_0 : synthesis h K L
H3_1 : synthesis h M N
M,N,K,L : Msg
H2 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H1 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H0 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
eq (MEnc N L) N0
+++++
cut (~ synthesis h M N \/ ~ synthesis h K L).
-----
Theorem inj_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_left (synthesis h).
unfold injective_left in |- *.
unfold enc_synthesis_left in |- *.
unfold op_synthesis_left in |- *.
unfold pair_free_left in |- *.
intro h.
intro.
intro.
intro.
intro.
intros M N H3.
induction H3 as [M N H3| M N K L H3_1 HrecH3_1 H3_0 HrecH3_0| M1 N1 M2 N2 H3_1 HrecH3_1 H3_0 HrecH3_0| o M N H3 HrecH3]; intros M' N' H4; [ induction H4 as [M0 N0 H4| M0 N0 K L H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o M0 N0 H4 HrecH4] | induction H4 as [M0 N0 H3| M0 N0 K0 L0 H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o M0 N0 H4 HrecH4] | induction H4 as [M N H3| M N K L H4_1 HrecH4_1 H4_0 HrecH4_0| M0 N0 M3 N3 H4_1 HrecH4_1 H4_0 HrecH4_0| o M N H4 HrecH4] | induction H4 as [M0 N0 H4| M0 N0 K L H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o0 M0 N0 H4 HrecH4] ].
intro.
exact (H M N H3 M0 N0 H4 H5).
intro.
cut (~ synthesis h M0 N0 \\/ ~ synthesis h K L).
intro.
case H5; intro H6; red in H6; tauto.
apply (H0 M N H3 M0 K H4).
intro.
rewrite H4 in H3.
cut False.
tauto.
apply (H2 M1 M2 N); trivial.
intro.
cut (~ synthesis h M0 N0).
intro.
tauto.
apply (H1 o M N H3 M0 H5); trivial.
intro.
cut (~ synthesis h M N \\/ ~ synthesis h K L).

*****
H4 : eq (MEnc M K) M0
H3 : h M0 N0
M0,N0 : Msg
HrecH3_0 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq K M'), eq L N'
HrecH3_1 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M M'), eq N N'
H3_0 : synthesis h K L
H3_1 : synthesis h M N
M,N,K,L : Msg
H2 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H1 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H0 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
forall _ : or (not (synthesis h M N)) (not (synthesis h K L)), eq (MEnc N L) N0
+++++
intro.
-----
Theorem inj_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_left (synthesis h).
unfold injective_left in |- *.
unfold enc_synthesis_left in |- *.
unfold op_synthesis_left in |- *.
unfold pair_free_left in |- *.
intro h.
intro.
intro.
intro.
intro.
intros M N H3.
induction H3 as [M N H3| M N K L H3_1 HrecH3_1 H3_0 HrecH3_0| M1 N1 M2 N2 H3_1 HrecH3_1 H3_0 HrecH3_0| o M N H3 HrecH3]; intros M' N' H4; [ induction H4 as [M0 N0 H4| M0 N0 K L H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o M0 N0 H4 HrecH4] | induction H4 as [M0 N0 H3| M0 N0 K0 L0 H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o M0 N0 H4 HrecH4] | induction H4 as [M N H3| M N K L H4_1 HrecH4_1 H4_0 HrecH4_0| M0 N0 M3 N3 H4_1 HrecH4_1 H4_0 HrecH4_0| o M N H4 HrecH4] | induction H4 as [M0 N0 H4| M0 N0 K L H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o0 M0 N0 H4 HrecH4] ].
intro.
exact (H M N H3 M0 N0 H4 H5).
intro.
cut (~ synthesis h M0 N0 \\/ ~ synthesis h K L).
intro.
case H5; intro H6; red in H6; tauto.
apply (H0 M N H3 M0 K H4).
intro.
rewrite H4 in H3.
cut False.
tauto.
apply (H2 M1 M2 N); trivial.
intro.
cut (~ synthesis h M0 N0).
intro.
tauto.
apply (H1 o M N H3 M0 H5); trivial.
intro.
cut (~ synthesis h M N \\/ ~ synthesis h K L).
intro.

*****
H5 : or (not (synthesis h M N)) (not (synthesis h K L))
H4 : eq (MEnc M K) M0
H3 : h M0 N0
M0,N0 : Msg
HrecH3_0 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq K M'), eq L N'
HrecH3_1 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M M'), eq N N'
H3_0 : synthesis h K L
H3_1 : synthesis h M N
M,N,K,L : Msg
H2 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H1 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H0 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
eq (MEnc N L) N0
+++++
case H5; intro H6; red in H6; tauto.
-----
Theorem inj_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_left (synthesis h).
unfold injective_left in |- *.
unfold enc_synthesis_left in |- *.
unfold op_synthesis_left in |- *.
unfold pair_free_left in |- *.
intro h.
intro.
intro.
intro.
intro.
intros M N H3.
induction H3 as [M N H3| M N K L H3_1 HrecH3_1 H3_0 HrecH3_0| M1 N1 M2 N2 H3_1 HrecH3_1 H3_0 HrecH3_0| o M N H3 HrecH3]; intros M' N' H4; [ induction H4 as [M0 N0 H4| M0 N0 K L H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o M0 N0 H4 HrecH4] | induction H4 as [M0 N0 H3| M0 N0 K0 L0 H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o M0 N0 H4 HrecH4] | induction H4 as [M N H3| M N K L H4_1 HrecH4_1 H4_0 HrecH4_0| M0 N0 M3 N3 H4_1 HrecH4_1 H4_0 HrecH4_0| o M N H4 HrecH4] | induction H4 as [M0 N0 H4| M0 N0 K L H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o0 M0 N0 H4 HrecH4] ].
intro.
exact (H M N H3 M0 N0 H4 H5).
intro.
cut (~ synthesis h M0 N0 \\/ ~ synthesis h K L).
intro.
case H5; intro H6; red in H6; tauto.
apply (H0 M N H3 M0 K H4).
intro.
rewrite H4 in H3.
cut False.
tauto.
apply (H2 M1 M2 N); trivial.
intro.
cut (~ synthesis h M0 N0).
intro.
tauto.
apply (H1 o M N H3 M0 H5); trivial.
intro.
cut (~ synthesis h M N \\/ ~ synthesis h K L).
intro.
case H5; intro H6; red in H6; tauto.

*****
H4 : eq (MEnc M K) M0
H3 : h M0 N0
M0,N0 : Msg
HrecH3_0 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq K M'), eq L N'
HrecH3_1 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M M'), eq N N'
H3_0 : synthesis h K L
H3_1 : synthesis h M N
M,N,K,L : Msg
H2 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H1 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H0 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
or (not (synthesis h M N)) (not (synthesis h K L))
+++++
apply (H0 M0 N0 H3 M K); auto.
-----
Theorem inj_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_left (synthesis h).
unfold injective_left in |- *.
unfold enc_synthesis_left in |- *.
unfold op_synthesis_left in |- *.
unfold pair_free_left in |- *.
intro h.
intro.
intro.
intro.
intro.
intros M N H3.
induction H3 as [M N H3| M N K L H3_1 HrecH3_1 H3_0 HrecH3_0| M1 N1 M2 N2 H3_1 HrecH3_1 H3_0 HrecH3_0| o M N H3 HrecH3]; intros M' N' H4; [ induction H4 as [M0 N0 H4| M0 N0 K L H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o M0 N0 H4 HrecH4] | induction H4 as [M0 N0 H3| M0 N0 K0 L0 H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o M0 N0 H4 HrecH4] | induction H4 as [M N H3| M N K L H4_1 HrecH4_1 H4_0 HrecH4_0| M0 N0 M3 N3 H4_1 HrecH4_1 H4_0 HrecH4_0| o M N H4 HrecH4] | induction H4 as [M0 N0 H4| M0 N0 K L H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o0 M0 N0 H4 HrecH4] ].
intro.
exact (H M N H3 M0 N0 H4 H5).
intro.
cut (~ synthesis h M0 N0 \\/ ~ synthesis h K L).
intro.
case H5; intro H6; red in H6; tauto.
apply (H0 M N H3 M0 K H4).
intro.
rewrite H4 in H3.
cut False.
tauto.
apply (H2 M1 M2 N); trivial.
intro.
cut (~ synthesis h M0 N0).
intro.
tauto.
apply (H1 o M N H3 M0 H5); trivial.
intro.
cut (~ synthesis h M N \\/ ~ synthesis h K L).
intro.
case H5; intro H6; red in H6; tauto.
apply (H0 M0 N0 H3 M K); auto.

*****
HrecH4_0 : forall _ : eq (MEnc M K) K0, eq (MEnc N L) L0
HrecH4_1 : forall _ : eq (MEnc M K) M0, eq (MEnc N L) N0
H4_0 : synthesis h K0 L0
H4_1 : synthesis h M0 N0
M0,N0,K0,L0 : Msg
HrecH3_0 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq K M'), eq L N'
HrecH3_1 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M M'), eq N N'
H3_0 : synthesis h K L
H3_1 : synthesis h M N
M,N,K,L : Msg
H2 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H1 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H0 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
forall _ : eq (MEnc M K) (MEnc M0 K0), eq (MEnc N L) (MEnc N0 L0)
+++++
intro.
-----
Theorem inj_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_left (synthesis h).
unfold injective_left in |- *.
unfold enc_synthesis_left in |- *.
unfold op_synthesis_left in |- *.
unfold pair_free_left in |- *.
intro h.
intro.
intro.
intro.
intro.
intros M N H3.
induction H3 as [M N H3| M N K L H3_1 HrecH3_1 H3_0 HrecH3_0| M1 N1 M2 N2 H3_1 HrecH3_1 H3_0 HrecH3_0| o M N H3 HrecH3]; intros M' N' H4; [ induction H4 as [M0 N0 H4| M0 N0 K L H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o M0 N0 H4 HrecH4] | induction H4 as [M0 N0 H3| M0 N0 K0 L0 H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o M0 N0 H4 HrecH4] | induction H4 as [M N H3| M N K L H4_1 HrecH4_1 H4_0 HrecH4_0| M0 N0 M3 N3 H4_1 HrecH4_1 H4_0 HrecH4_0| o M N H4 HrecH4] | induction H4 as [M0 N0 H4| M0 N0 K L H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o0 M0 N0 H4 HrecH4] ].
intro.
exact (H M N H3 M0 N0 H4 H5).
intro.
cut (~ synthesis h M0 N0 \\/ ~ synthesis h K L).
intro.
case H5; intro H6; red in H6; tauto.
apply (H0 M N H3 M0 K H4).
intro.
rewrite H4 in H3.
cut False.
tauto.
apply (H2 M1 M2 N); trivial.
intro.
cut (~ synthesis h M0 N0).
intro.
tauto.
apply (H1 o M N H3 M0 H5); trivial.
intro.
cut (~ synthesis h M N \\/ ~ synthesis h K L).
intro.
case H5; intro H6; red in H6; tauto.
apply (H0 M0 N0 H3 M K); auto.
intro.

*****
H3 : eq (MEnc M K) (MEnc M0 K0)
HrecH4_0 : forall _ : eq (MEnc M K) K0, eq (MEnc N L) L0
HrecH4_1 : forall _ : eq (MEnc M K) M0, eq (MEnc N L) N0
H4_0 : synthesis h K0 L0
H4_1 : synthesis h M0 N0
M0,N0,K0,L0 : Msg
HrecH3_0 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq K M'), eq L N'
HrecH3_1 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M M'), eq N N'
H3_0 : synthesis h K L
H3_1 : synthesis h M N
M,N,K,L : Msg
H2 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H1 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H0 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
eq (MEnc N L) (MEnc N0 L0)
+++++
inversion H3.
-----
Theorem inj_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_left (synthesis h).
unfold injective_left in |- *.
unfold enc_synthesis_left in |- *.
unfold op_synthesis_left in |- *.
unfold pair_free_left in |- *.
intro h.
intro.
intro.
intro.
intro.
intros M N H3.
induction H3 as [M N H3| M N K L H3_1 HrecH3_1 H3_0 HrecH3_0| M1 N1 M2 N2 H3_1 HrecH3_1 H3_0 HrecH3_0| o M N H3 HrecH3]; intros M' N' H4; [ induction H4 as [M0 N0 H4| M0 N0 K L H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o M0 N0 H4 HrecH4] | induction H4 as [M0 N0 H3| M0 N0 K0 L0 H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o M0 N0 H4 HrecH4] | induction H4 as [M N H3| M N K L H4_1 HrecH4_1 H4_0 HrecH4_0| M0 N0 M3 N3 H4_1 HrecH4_1 H4_0 HrecH4_0| o M N H4 HrecH4] | induction H4 as [M0 N0 H4| M0 N0 K L H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o0 M0 N0 H4 HrecH4] ].
intro.
exact (H M N H3 M0 N0 H4 H5).
intro.
cut (~ synthesis h M0 N0 \\/ ~ synthesis h K L).
intro.
case H5; intro H6; red in H6; tauto.
apply (H0 M N H3 M0 K H4).
intro.
rewrite H4 in H3.
cut False.
tauto.
apply (H2 M1 M2 N); trivial.
intro.
cut (~ synthesis h M0 N0).
intro.
tauto.
apply (H1 o M N H3 M0 H5); trivial.
intro.
cut (~ synthesis h M N \\/ ~ synthesis h K L).
intro.
case H5; intro H6; red in H6; tauto.
apply (H0 M0 N0 H3 M K); auto.
intro.
inversion H3.

*****
H6 : eq K K0
H5 : eq M M0
H3 : eq (MEnc M K) (MEnc M0 K0)
HrecH4_0 : forall _ : eq (MEnc M K) K0, eq (MEnc N L) L0
HrecH4_1 : forall _ : eq (MEnc M K) M0, eq (MEnc N L) N0
H4_0 : synthesis h K0 L0
H4_1 : synthesis h M0 N0
M0,N0,K0,L0 : Msg
HrecH3_0 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq K M'), eq L N'
HrecH3_1 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M M'), eq N N'
H3_0 : synthesis h K L
H3_1 : synthesis h M N
M,N,K,L : Msg
H2 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H1 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H0 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
eq (MEnc N L) (MEnc N0 L0)
+++++
rewrite (HrecH3_1 M0 N0 H4_1 H5).
-----
Theorem inj_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_left (synthesis h).
unfold injective_left in |- *.
unfold enc_synthesis_left in |- *.
unfold op_synthesis_left in |- *.
unfold pair_free_left in |- *.
intro h.
intro.
intro.
intro.
intro.
intros M N H3.
induction H3 as [M N H3| M N K L H3_1 HrecH3_1 H3_0 HrecH3_0| M1 N1 M2 N2 H3_1 HrecH3_1 H3_0 HrecH3_0| o M N H3 HrecH3]; intros M' N' H4; [ induction H4 as [M0 N0 H4| M0 N0 K L H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o M0 N0 H4 HrecH4] | induction H4 as [M0 N0 H3| M0 N0 K0 L0 H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o M0 N0 H4 HrecH4] | induction H4 as [M N H3| M N K L H4_1 HrecH4_1 H4_0 HrecH4_0| M0 N0 M3 N3 H4_1 HrecH4_1 H4_0 HrecH4_0| o M N H4 HrecH4] | induction H4 as [M0 N0 H4| M0 N0 K L H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o0 M0 N0 H4 HrecH4] ].
intro.
exact (H M N H3 M0 N0 H4 H5).
intro.
cut (~ synthesis h M0 N0 \\/ ~ synthesis h K L).
intro.
case H5; intro H6; red in H6; tauto.
apply (H0 M N H3 M0 K H4).
intro.
rewrite H4 in H3.
cut False.
tauto.
apply (H2 M1 M2 N); trivial.
intro.
cut (~ synthesis h M0 N0).
intro.
tauto.
apply (H1 o M N H3 M0 H5); trivial.
intro.
cut (~ synthesis h M N \\/ ~ synthesis h K L).
intro.
case H5; intro H6; red in H6; tauto.
apply (H0 M0 N0 H3 M K); auto.
intro.
inversion H3.
rewrite (HrecH3_1 M0 N0 H4_1 H5).

*****
H6 : eq K K0
H5 : eq M M0
H3 : eq (MEnc M K) (MEnc M0 K0)
HrecH4_0 : forall _ : eq (MEnc M K) K0, eq (MEnc N L) L0
HrecH4_1 : forall _ : eq (MEnc M K) M0, eq (MEnc N L) N0
H4_0 : synthesis h K0 L0
H4_1 : synthesis h M0 N0
M0,N0,K0,L0 : Msg
HrecH3_0 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq K M'), eq L N'
HrecH3_1 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M M'), eq N N'
H3_0 : synthesis h K L
H3_1 : synthesis h M N
M,N,K,L : Msg
H2 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H1 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H0 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
eq (MEnc N0 L) (MEnc N0 L0)
+++++
rewrite (HrecH3_0 K0 L0 H4_0 H6).
-----
Theorem inj_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_left (synthesis h).
unfold injective_left in |- *.
unfold enc_synthesis_left in |- *.
unfold op_synthesis_left in |- *.
unfold pair_free_left in |- *.
intro h.
intro.
intro.
intro.
intro.
intros M N H3.
induction H3 as [M N H3| M N K L H3_1 HrecH3_1 H3_0 HrecH3_0| M1 N1 M2 N2 H3_1 HrecH3_1 H3_0 HrecH3_0| o M N H3 HrecH3]; intros M' N' H4; [ induction H4 as [M0 N0 H4| M0 N0 K L H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o M0 N0 H4 HrecH4] | induction H4 as [M0 N0 H3| M0 N0 K0 L0 H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o M0 N0 H4 HrecH4] | induction H4 as [M N H3| M N K L H4_1 HrecH4_1 H4_0 HrecH4_0| M0 N0 M3 N3 H4_1 HrecH4_1 H4_0 HrecH4_0| o M N H4 HrecH4] | induction H4 as [M0 N0 H4| M0 N0 K L H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o0 M0 N0 H4 HrecH4] ].
intro.
exact (H M N H3 M0 N0 H4 H5).
intro.
cut (~ synthesis h M0 N0 \\/ ~ synthesis h K L).
intro.
case H5; intro H6; red in H6; tauto.
apply (H0 M N H3 M0 K H4).
intro.
rewrite H4 in H3.
cut False.
tauto.
apply (H2 M1 M2 N); trivial.
intro.
cut (~ synthesis h M0 N0).
intro.
tauto.
apply (H1 o M N H3 M0 H5); trivial.
intro.
cut (~ synthesis h M N \\/ ~ synthesis h K L).
intro.
case H5; intro H6; red in H6; tauto.
apply (H0 M0 N0 H3 M K); auto.
intro.
inversion H3.
rewrite (HrecH3_1 M0 N0 H4_1 H5).
rewrite (HrecH3_0 K0 L0 H4_0 H6).

*****
H6 : eq K K0
H5 : eq M M0
H3 : eq (MEnc M K) (MEnc M0 K0)
HrecH4_0 : forall _ : eq (MEnc M K) K0, eq (MEnc N L) L0
HrecH4_1 : forall _ : eq (MEnc M K) M0, eq (MEnc N L) N0
H4_0 : synthesis h K0 L0
H4_1 : synthesis h M0 N0
M0,N0,K0,L0 : Msg
HrecH3_0 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq K M'), eq L N'
HrecH3_1 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M M'), eq N N'
H3_0 : synthesis h K L
H3_1 : synthesis h M N
M,N,K,L : Msg
H2 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H1 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H0 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
eq (MEnc N0 L0) (MEnc N0 L0)
+++++
trivial.
-----
Theorem inj_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_left (synthesis h).
unfold injective_left in |- *.
unfold enc_synthesis_left in |- *.
unfold op_synthesis_left in |- *.
unfold pair_free_left in |- *.
intro h.
intro.
intro.
intro.
intro.
intros M N H3.
induction H3 as [M N H3| M N K L H3_1 HrecH3_1 H3_0 HrecH3_0| M1 N1 M2 N2 H3_1 HrecH3_1 H3_0 HrecH3_0| o M N H3 HrecH3]; intros M' N' H4; [ induction H4 as [M0 N0 H4| M0 N0 K L H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o M0 N0 H4 HrecH4] | induction H4 as [M0 N0 H3| M0 N0 K0 L0 H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o M0 N0 H4 HrecH4] | induction H4 as [M N H3| M N K L H4_1 HrecH4_1 H4_0 HrecH4_0| M0 N0 M3 N3 H4_1 HrecH4_1 H4_0 HrecH4_0| o M N H4 HrecH4] | induction H4 as [M0 N0 H4| M0 N0 K L H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o0 M0 N0 H4 HrecH4] ].
intro.
exact (H M N H3 M0 N0 H4 H5).
intro.
cut (~ synthesis h M0 N0 \\/ ~ synthesis h K L).
intro.
case H5; intro H6; red in H6; tauto.
apply (H0 M N H3 M0 K H4).
intro.
rewrite H4 in H3.
cut False.
tauto.
apply (H2 M1 M2 N); trivial.
intro.
cut (~ synthesis h M0 N0).
intro.
tauto.
apply (H1 o M N H3 M0 H5); trivial.
intro.
cut (~ synthesis h M N \\/ ~ synthesis h K L).
intro.
case H5; intro H6; red in H6; tauto.
apply (H0 M0 N0 H3 M K); auto.
intro.
inversion H3.
rewrite (HrecH3_1 M0 N0 H4_1 H5).
rewrite (HrecH3_0 K0 L0 H4_0 H6).
trivial.

*****
HrecH4_0 : forall _ : eq (MEnc M K) M2, eq (MEnc N L) N2
HrecH4_1 : forall _ : eq (MEnc M K) M1, eq (MEnc N L) N1
H4_0 : synthesis h M2 N2
H4_1 : synthesis h M1 N1
M1,N1,M2,N2 : Msg
HrecH3_0 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq K M'), eq L N'
HrecH3_1 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M M'), eq N N'
H3_0 : synthesis h K L
H3_1 : synthesis h M N
M,N,K,L : Msg
H2 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H1 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H0 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
forall _ : eq (MEnc M K) (MPair M1 M2), eq (MEnc N L) (MPair N1 N2)
+++++
intro.
-----
Theorem inj_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_left (synthesis h).
unfold injective_left in |- *.
unfold enc_synthesis_left in |- *.
unfold op_synthesis_left in |- *.
unfold pair_free_left in |- *.
intro h.
intro.
intro.
intro.
intro.
intros M N H3.
induction H3 as [M N H3| M N K L H3_1 HrecH3_1 H3_0 HrecH3_0| M1 N1 M2 N2 H3_1 HrecH3_1 H3_0 HrecH3_0| o M N H3 HrecH3]; intros M' N' H4; [ induction H4 as [M0 N0 H4| M0 N0 K L H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o M0 N0 H4 HrecH4] | induction H4 as [M0 N0 H3| M0 N0 K0 L0 H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o M0 N0 H4 HrecH4] | induction H4 as [M N H3| M N K L H4_1 HrecH4_1 H4_0 HrecH4_0| M0 N0 M3 N3 H4_1 HrecH4_1 H4_0 HrecH4_0| o M N H4 HrecH4] | induction H4 as [M0 N0 H4| M0 N0 K L H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o0 M0 N0 H4 HrecH4] ].
intro.
exact (H M N H3 M0 N0 H4 H5).
intro.
cut (~ synthesis h M0 N0 \\/ ~ synthesis h K L).
intro.
case H5; intro H6; red in H6; tauto.
apply (H0 M N H3 M0 K H4).
intro.
rewrite H4 in H3.
cut False.
tauto.
apply (H2 M1 M2 N); trivial.
intro.
cut (~ synthesis h M0 N0).
intro.
tauto.
apply (H1 o M N H3 M0 H5); trivial.
intro.
cut (~ synthesis h M N \\/ ~ synthesis h K L).
intro.
case H5; intro H6; red in H6; tauto.
apply (H0 M0 N0 H3 M K); auto.
intro.
inversion H3.
rewrite (HrecH3_1 M0 N0 H4_1 H5).
rewrite (HrecH3_0 K0 L0 H4_0 H6).
trivial.
intro.

*****
H3 : eq (MEnc M K) (MPair M1 M2)
HrecH4_0 : forall _ : eq (MEnc M K) M2, eq (MEnc N L) N2
HrecH4_1 : forall _ : eq (MEnc M K) M1, eq (MEnc N L) N1
H4_0 : synthesis h M2 N2
H4_1 : synthesis h M1 N1
M1,N1,M2,N2 : Msg
HrecH3_0 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq K M'), eq L N'
HrecH3_1 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M M'), eq N N'
H3_0 : synthesis h K L
H3_1 : synthesis h M N
M,N,K,L : Msg
H2 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H1 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H0 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
eq (MEnc N L) (MPair N1 N2)
+++++
inversion H3.
-----
Theorem inj_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_left (synthesis h).
unfold injective_left in |- *.
unfold enc_synthesis_left in |- *.
unfold op_synthesis_left in |- *.
unfold pair_free_left in |- *.
intro h.
intro.
intro.
intro.
intro.
intros M N H3.
induction H3 as [M N H3| M N K L H3_1 HrecH3_1 H3_0 HrecH3_0| M1 N1 M2 N2 H3_1 HrecH3_1 H3_0 HrecH3_0| o M N H3 HrecH3]; intros M' N' H4; [ induction H4 as [M0 N0 H4| M0 N0 K L H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o M0 N0 H4 HrecH4] | induction H4 as [M0 N0 H3| M0 N0 K0 L0 H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o M0 N0 H4 HrecH4] | induction H4 as [M N H3| M N K L H4_1 HrecH4_1 H4_0 HrecH4_0| M0 N0 M3 N3 H4_1 HrecH4_1 H4_0 HrecH4_0| o M N H4 HrecH4] | induction H4 as [M0 N0 H4| M0 N0 K L H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o0 M0 N0 H4 HrecH4] ].
intro.
exact (H M N H3 M0 N0 H4 H5).
intro.
cut (~ synthesis h M0 N0 \\/ ~ synthesis h K L).
intro.
case H5; intro H6; red in H6; tauto.
apply (H0 M N H3 M0 K H4).
intro.
rewrite H4 in H3.
cut False.
tauto.
apply (H2 M1 M2 N); trivial.
intro.
cut (~ synthesis h M0 N0).
intro.
tauto.
apply (H1 o M N H3 M0 H5); trivial.
intro.
cut (~ synthesis h M N \\/ ~ synthesis h K L).
intro.
case H5; intro H6; red in H6; tauto.
apply (H0 M0 N0 H3 M K); auto.
intro.
inversion H3.
rewrite (HrecH3_1 M0 N0 H4_1 H5).
rewrite (HrecH3_0 K0 L0 H4_0 H6).
trivial.
intro.
inversion H3.

*****
HrecH4 : forall _ : eq (MEnc M K) M0, eq (MEnc N L) N0
H4 : synthesis h M0 N0
M0,N0 : Msg
o : op
HrecH3_0 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq K M'), eq L N'
HrecH3_1 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M M'), eq N N'
H3_0 : synthesis h K L
H3_1 : synthesis h M N
M,N,K,L : Msg
H2 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H1 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H0 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
forall _ : eq (MEnc M K) (Mop o M0), eq (MEnc N L) (Mop o N0)
+++++
intro.
-----
Theorem inj_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_left (synthesis h).
unfold injective_left in |- *.
unfold enc_synthesis_left in |- *.
unfold op_synthesis_left in |- *.
unfold pair_free_left in |- *.
intro h.
intro.
intro.
intro.
intro.
intros M N H3.
induction H3 as [M N H3| M N K L H3_1 HrecH3_1 H3_0 HrecH3_0| M1 N1 M2 N2 H3_1 HrecH3_1 H3_0 HrecH3_0| o M N H3 HrecH3]; intros M' N' H4; [ induction H4 as [M0 N0 H4| M0 N0 K L H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o M0 N0 H4 HrecH4] | induction H4 as [M0 N0 H3| M0 N0 K0 L0 H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o M0 N0 H4 HrecH4] | induction H4 as [M N H3| M N K L H4_1 HrecH4_1 H4_0 HrecH4_0| M0 N0 M3 N3 H4_1 HrecH4_1 H4_0 HrecH4_0| o M N H4 HrecH4] | induction H4 as [M0 N0 H4| M0 N0 K L H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o0 M0 N0 H4 HrecH4] ].
intro.
exact (H M N H3 M0 N0 H4 H5).
intro.
cut (~ synthesis h M0 N0 \\/ ~ synthesis h K L).
intro.
case H5; intro H6; red in H6; tauto.
apply (H0 M N H3 M0 K H4).
intro.
rewrite H4 in H3.
cut False.
tauto.
apply (H2 M1 M2 N); trivial.
intro.
cut (~ synthesis h M0 N0).
intro.
tauto.
apply (H1 o M N H3 M0 H5); trivial.
intro.
cut (~ synthesis h M N \\/ ~ synthesis h K L).
intro.
case H5; intro H6; red in H6; tauto.
apply (H0 M0 N0 H3 M K); auto.
intro.
inversion H3.
rewrite (HrecH3_1 M0 N0 H4_1 H5).
rewrite (HrecH3_0 K0 L0 H4_0 H6).
trivial.
intro.
inversion H3.
intro.

*****
H3 : eq (MEnc M K) (Mop o M0)
HrecH4 : forall _ : eq (MEnc M K) M0, eq (MEnc N L) N0
H4 : synthesis h M0 N0
M0,N0 : Msg
o : op
HrecH3_0 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq K M'), eq L N'
HrecH3_1 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M M'), eq N N'
H3_0 : synthesis h K L
H3_1 : synthesis h M N
M,N,K,L : Msg
H2 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H1 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H0 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
eq (MEnc N L) (Mop o N0)
+++++
inversion H3.
-----
Theorem inj_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_left (synthesis h).
unfold injective_left in |- *.
unfold enc_synthesis_left in |- *.
unfold op_synthesis_left in |- *.
unfold pair_free_left in |- *.
intro h.
intro.
intro.
intro.
intro.
intros M N H3.
induction H3 as [M N H3| M N K L H3_1 HrecH3_1 H3_0 HrecH3_0| M1 N1 M2 N2 H3_1 HrecH3_1 H3_0 HrecH3_0| o M N H3 HrecH3]; intros M' N' H4; [ induction H4 as [M0 N0 H4| M0 N0 K L H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o M0 N0 H4 HrecH4] | induction H4 as [M0 N0 H3| M0 N0 K0 L0 H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o M0 N0 H4 HrecH4] | induction H4 as [M N H3| M N K L H4_1 HrecH4_1 H4_0 HrecH4_0| M0 N0 M3 N3 H4_1 HrecH4_1 H4_0 HrecH4_0| o M N H4 HrecH4] | induction H4 as [M0 N0 H4| M0 N0 K L H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o0 M0 N0 H4 HrecH4] ].
intro.
exact (H M N H3 M0 N0 H4 H5).
intro.
cut (~ synthesis h M0 N0 \\/ ~ synthesis h K L).
intro.
case H5; intro H6; red in H6; tauto.
apply (H0 M N H3 M0 K H4).
intro.
rewrite H4 in H3.
cut False.
tauto.
apply (H2 M1 M2 N); trivial.
intro.
cut (~ synthesis h M0 N0).
intro.
tauto.
apply (H1 o M N H3 M0 H5); trivial.
intro.
cut (~ synthesis h M N \\/ ~ synthesis h K L).
intro.
case H5; intro H6; red in H6; tauto.
apply (H0 M0 N0 H3 M K); auto.
intro.
inversion H3.
rewrite (HrecH3_1 M0 N0 H4_1 H5).
rewrite (HrecH3_0 K0 L0 H4_0 H6).
trivial.
intro.
inversion H3.
intro.
inversion H3.

*****
H3 : h M N
M,N : Msg
HrecH3_0 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M2 M'), eq N2 N'
HrecH3_1 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M1 M'), eq N1 N'
H3_0 : synthesis h M2 N2
H3_1 : synthesis h M1 N1
M1,N1,M2,N2 : Msg
H2 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H1 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H0 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
forall _ : eq (MPair M1 M2) M, eq (MPair N1 N2) N
+++++
intro.
-----
Theorem inj_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_left (synthesis h).
unfold injective_left in |- *.
unfold enc_synthesis_left in |- *.
unfold op_synthesis_left in |- *.
unfold pair_free_left in |- *.
intro h.
intro.
intro.
intro.
intro.
intros M N H3.
induction H3 as [M N H3| M N K L H3_1 HrecH3_1 H3_0 HrecH3_0| M1 N1 M2 N2 H3_1 HrecH3_1 H3_0 HrecH3_0| o M N H3 HrecH3]; intros M' N' H4; [ induction H4 as [M0 N0 H4| M0 N0 K L H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o M0 N0 H4 HrecH4] | induction H4 as [M0 N0 H3| M0 N0 K0 L0 H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o M0 N0 H4 HrecH4] | induction H4 as [M N H3| M N K L H4_1 HrecH4_1 H4_0 HrecH4_0| M0 N0 M3 N3 H4_1 HrecH4_1 H4_0 HrecH4_0| o M N H4 HrecH4] | induction H4 as [M0 N0 H4| M0 N0 K L H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o0 M0 N0 H4 HrecH4] ].
intro.
exact (H M N H3 M0 N0 H4 H5).
intro.
cut (~ synthesis h M0 N0 \\/ ~ synthesis h K L).
intro.
case H5; intro H6; red in H6; tauto.
apply (H0 M N H3 M0 K H4).
intro.
rewrite H4 in H3.
cut False.
tauto.
apply (H2 M1 M2 N); trivial.
intro.
cut (~ synthesis h M0 N0).
intro.
tauto.
apply (H1 o M N H3 M0 H5); trivial.
intro.
cut (~ synthesis h M N \\/ ~ synthesis h K L).
intro.
case H5; intro H6; red in H6; tauto.
apply (H0 M0 N0 H3 M K); auto.
intro.
inversion H3.
rewrite (HrecH3_1 M0 N0 H4_1 H5).
rewrite (HrecH3_0 K0 L0 H4_0 H6).
trivial.
intro.
inversion H3.
intro.
inversion H3.
intro.

*****
H4 : eq (MPair M1 M2) M
H3 : h M N
M,N : Msg
HrecH3_0 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M2 M'), eq N2 N'
HrecH3_1 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M1 M'), eq N1 N'
H3_0 : synthesis h M2 N2
H3_1 : synthesis h M1 N1
M1,N1,M2,N2 : Msg
H2 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H1 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H0 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
eq (MPair N1 N2) N
+++++
rewrite <- H4 in H3.
-----
Theorem inj_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_left (synthesis h).
unfold injective_left in |- *.
unfold enc_synthesis_left in |- *.
unfold op_synthesis_left in |- *.
unfold pair_free_left in |- *.
intro h.
intro.
intro.
intro.
intro.
intros M N H3.
induction H3 as [M N H3| M N K L H3_1 HrecH3_1 H3_0 HrecH3_0| M1 N1 M2 N2 H3_1 HrecH3_1 H3_0 HrecH3_0| o M N H3 HrecH3]; intros M' N' H4; [ induction H4 as [M0 N0 H4| M0 N0 K L H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o M0 N0 H4 HrecH4] | induction H4 as [M0 N0 H3| M0 N0 K0 L0 H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o M0 N0 H4 HrecH4] | induction H4 as [M N H3| M N K L H4_1 HrecH4_1 H4_0 HrecH4_0| M0 N0 M3 N3 H4_1 HrecH4_1 H4_0 HrecH4_0| o M N H4 HrecH4] | induction H4 as [M0 N0 H4| M0 N0 K L H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o0 M0 N0 H4 HrecH4] ].
intro.
exact (H M N H3 M0 N0 H4 H5).
intro.
cut (~ synthesis h M0 N0 \\/ ~ synthesis h K L).
intro.
case H5; intro H6; red in H6; tauto.
apply (H0 M N H3 M0 K H4).
intro.
rewrite H4 in H3.
cut False.
tauto.
apply (H2 M1 M2 N); trivial.
intro.
cut (~ synthesis h M0 N0).
intro.
tauto.
apply (H1 o M N H3 M0 H5); trivial.
intro.
cut (~ synthesis h M N \\/ ~ synthesis h K L).
intro.
case H5; intro H6; red in H6; tauto.
apply (H0 M0 N0 H3 M K); auto.
intro.
inversion H3.
rewrite (HrecH3_1 M0 N0 H4_1 H5).
rewrite (HrecH3_0 K0 L0 H4_0 H6).
trivial.
intro.
inversion H3.
intro.
inversion H3.
intro.
rewrite <- H4 in H3.

*****
H4 : eq (MPair M1 M2) M
H3 : h (MPair M1 M2) N
M,N : Msg
HrecH3_0 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M2 M'), eq N2 N'
HrecH3_1 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M1 M'), eq N1 N'
H3_0 : synthesis h M2 N2
H3_1 : synthesis h M1 N1
M1,N1,M2,N2 : Msg
H2 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H1 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H0 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
eq (MPair N1 N2) N
+++++
cut False.
-----
Theorem inj_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_left (synthesis h).
unfold injective_left in |- *.
unfold enc_synthesis_left in |- *.
unfold op_synthesis_left in |- *.
unfold pair_free_left in |- *.
intro h.
intro.
intro.
intro.
intro.
intros M N H3.
induction H3 as [M N H3| M N K L H3_1 HrecH3_1 H3_0 HrecH3_0| M1 N1 M2 N2 H3_1 HrecH3_1 H3_0 HrecH3_0| o M N H3 HrecH3]; intros M' N' H4; [ induction H4 as [M0 N0 H4| M0 N0 K L H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o M0 N0 H4 HrecH4] | induction H4 as [M0 N0 H3| M0 N0 K0 L0 H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o M0 N0 H4 HrecH4] | induction H4 as [M N H3| M N K L H4_1 HrecH4_1 H4_0 HrecH4_0| M0 N0 M3 N3 H4_1 HrecH4_1 H4_0 HrecH4_0| o M N H4 HrecH4] | induction H4 as [M0 N0 H4| M0 N0 K L H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o0 M0 N0 H4 HrecH4] ].
intro.
exact (H M N H3 M0 N0 H4 H5).
intro.
cut (~ synthesis h M0 N0 \\/ ~ synthesis h K L).
intro.
case H5; intro H6; red in H6; tauto.
apply (H0 M N H3 M0 K H4).
intro.
rewrite H4 in H3.
cut False.
tauto.
apply (H2 M1 M2 N); trivial.
intro.
cut (~ synthesis h M0 N0).
intro.
tauto.
apply (H1 o M N H3 M0 H5); trivial.
intro.
cut (~ synthesis h M N \\/ ~ synthesis h K L).
intro.
case H5; intro H6; red in H6; tauto.
apply (H0 M0 N0 H3 M K); auto.
intro.
inversion H3.
rewrite (HrecH3_1 M0 N0 H4_1 H5).
rewrite (HrecH3_0 K0 L0 H4_0 H6).
trivial.
intro.
inversion H3.
intro.
inversion H3.
intro.
rewrite <- H4 in H3.
cut False.

*****
H4 : eq (MPair M1 M2) M
H3 : h (MPair M1 M2) N
M,N : Msg
HrecH3_0 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M2 M'), eq N2 N'
HrecH3_1 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M1 M'), eq N1 N'
H3_0 : synthesis h M2 N2
H3_1 : synthesis h M1 N1
M1,N1,M2,N2 : Msg
H2 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H1 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H0 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
forall _ : False, eq (MPair N1 N2) N
+++++
tauto.
-----
Theorem inj_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_left (synthesis h).
unfold injective_left in |- *.
unfold enc_synthesis_left in |- *.
unfold op_synthesis_left in |- *.
unfold pair_free_left in |- *.
intro h.
intro.
intro.
intro.
intro.
intros M N H3.
induction H3 as [M N H3| M N K L H3_1 HrecH3_1 H3_0 HrecH3_0| M1 N1 M2 N2 H3_1 HrecH3_1 H3_0 HrecH3_0| o M N H3 HrecH3]; intros M' N' H4; [ induction H4 as [M0 N0 H4| M0 N0 K L H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o M0 N0 H4 HrecH4] | induction H4 as [M0 N0 H3| M0 N0 K0 L0 H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o M0 N0 H4 HrecH4] | induction H4 as [M N H3| M N K L H4_1 HrecH4_1 H4_0 HrecH4_0| M0 N0 M3 N3 H4_1 HrecH4_1 H4_0 HrecH4_0| o M N H4 HrecH4] | induction H4 as [M0 N0 H4| M0 N0 K L H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o0 M0 N0 H4 HrecH4] ].
intro.
exact (H M N H3 M0 N0 H4 H5).
intro.
cut (~ synthesis h M0 N0 \\/ ~ synthesis h K L).
intro.
case H5; intro H6; red in H6; tauto.
apply (H0 M N H3 M0 K H4).
intro.
rewrite H4 in H3.
cut False.
tauto.
apply (H2 M1 M2 N); trivial.
intro.
cut (~ synthesis h M0 N0).
intro.
tauto.
apply (H1 o M N H3 M0 H5); trivial.
intro.
cut (~ synthesis h M N \\/ ~ synthesis h K L).
intro.
case H5; intro H6; red in H6; tauto.
apply (H0 M0 N0 H3 M K); auto.
intro.
inversion H3.
rewrite (HrecH3_1 M0 N0 H4_1 H5).
rewrite (HrecH3_0 K0 L0 H4_0 H6).
trivial.
intro.
inversion H3.
intro.
inversion H3.
intro.
rewrite <- H4 in H3.
cut False.
tauto.

*****
H4 : eq (MPair M1 M2) M
H3 : h (MPair M1 M2) N
M,N : Msg
HrecH3_0 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M2 M'), eq N2 N'
HrecH3_1 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M1 M'), eq N1 N'
H3_0 : synthesis h M2 N2
H3_1 : synthesis h M1 N1
M1,N1,M2,N2 : Msg
H2 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H1 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H0 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
False
+++++
apply (H2 M1 M2 N H3).
-----
Theorem inj_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_left (synthesis h).
unfold injective_left in |- *.
unfold enc_synthesis_left in |- *.
unfold op_synthesis_left in |- *.
unfold pair_free_left in |- *.
intro h.
intro.
intro.
intro.
intro.
intros M N H3.
induction H3 as [M N H3| M N K L H3_1 HrecH3_1 H3_0 HrecH3_0| M1 N1 M2 N2 H3_1 HrecH3_1 H3_0 HrecH3_0| o M N H3 HrecH3]; intros M' N' H4; [ induction H4 as [M0 N0 H4| M0 N0 K L H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o M0 N0 H4 HrecH4] | induction H4 as [M0 N0 H3| M0 N0 K0 L0 H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o M0 N0 H4 HrecH4] | induction H4 as [M N H3| M N K L H4_1 HrecH4_1 H4_0 HrecH4_0| M0 N0 M3 N3 H4_1 HrecH4_1 H4_0 HrecH4_0| o M N H4 HrecH4] | induction H4 as [M0 N0 H4| M0 N0 K L H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o0 M0 N0 H4 HrecH4] ].
intro.
exact (H M N H3 M0 N0 H4 H5).
intro.
cut (~ synthesis h M0 N0 \\/ ~ synthesis h K L).
intro.
case H5; intro H6; red in H6; tauto.
apply (H0 M N H3 M0 K H4).
intro.
rewrite H4 in H3.
cut False.
tauto.
apply (H2 M1 M2 N); trivial.
intro.
cut (~ synthesis h M0 N0).
intro.
tauto.
apply (H1 o M N H3 M0 H5); trivial.
intro.
cut (~ synthesis h M N \\/ ~ synthesis h K L).
intro.
case H5; intro H6; red in H6; tauto.
apply (H0 M0 N0 H3 M K); auto.
intro.
inversion H3.
rewrite (HrecH3_1 M0 N0 H4_1 H5).
rewrite (HrecH3_0 K0 L0 H4_0 H6).
trivial.
intro.
inversion H3.
intro.
inversion H3.
intro.
rewrite <- H4 in H3.
cut False.
tauto.
apply (H2 M1 M2 N H3).

*****
HrecH4_0 : forall _ : eq (MPair M1 M2) K, eq (MPair N1 N2) L
HrecH4_1 : forall _ : eq (MPair M1 M2) M, eq (MPair N1 N2) N
H4_0 : synthesis h K L
H4_1 : synthesis h M N
M,N,K,L : Msg
HrecH3_0 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M2 M'), eq N2 N'
HrecH3_1 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M1 M'), eq N1 N'
H3_0 : synthesis h M2 N2
H3_1 : synthesis h M1 N1
M1,N1,M2,N2 : Msg
H2 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H1 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H0 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
forall _ : eq (MPair M1 M2) (MEnc M K), eq (MPair N1 N2) (MEnc N L)
+++++
intro.
-----
Theorem inj_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_left (synthesis h).
unfold injective_left in |- *.
unfold enc_synthesis_left in |- *.
unfold op_synthesis_left in |- *.
unfold pair_free_left in |- *.
intro h.
intro.
intro.
intro.
intro.
intros M N H3.
induction H3 as [M N H3| M N K L H3_1 HrecH3_1 H3_0 HrecH3_0| M1 N1 M2 N2 H3_1 HrecH3_1 H3_0 HrecH3_0| o M N H3 HrecH3]; intros M' N' H4; [ induction H4 as [M0 N0 H4| M0 N0 K L H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o M0 N0 H4 HrecH4] | induction H4 as [M0 N0 H3| M0 N0 K0 L0 H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o M0 N0 H4 HrecH4] | induction H4 as [M N H3| M N K L H4_1 HrecH4_1 H4_0 HrecH4_0| M0 N0 M3 N3 H4_1 HrecH4_1 H4_0 HrecH4_0| o M N H4 HrecH4] | induction H4 as [M0 N0 H4| M0 N0 K L H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o0 M0 N0 H4 HrecH4] ].
intro.
exact (H M N H3 M0 N0 H4 H5).
intro.
cut (~ synthesis h M0 N0 \\/ ~ synthesis h K L).
intro.
case H5; intro H6; red in H6; tauto.
apply (H0 M N H3 M0 K H4).
intro.
rewrite H4 in H3.
cut False.
tauto.
apply (H2 M1 M2 N); trivial.
intro.
cut (~ synthesis h M0 N0).
intro.
tauto.
apply (H1 o M N H3 M0 H5); trivial.
intro.
cut (~ synthesis h M N \\/ ~ synthesis h K L).
intro.
case H5; intro H6; red in H6; tauto.
apply (H0 M0 N0 H3 M K); auto.
intro.
inversion H3.
rewrite (HrecH3_1 M0 N0 H4_1 H5).
rewrite (HrecH3_0 K0 L0 H4_0 H6).
trivial.
intro.
inversion H3.
intro.
inversion H3.
intro.
rewrite <- H4 in H3.
cut False.
tauto.
apply (H2 M1 M2 N H3).
intro.

*****
H3 : eq (MPair M1 M2) (MEnc M K)
HrecH4_0 : forall _ : eq (MPair M1 M2) K, eq (MPair N1 N2) L
HrecH4_1 : forall _ : eq (MPair M1 M2) M, eq (MPair N1 N2) N
H4_0 : synthesis h K L
H4_1 : synthesis h M N
M,N,K,L : Msg
HrecH3_0 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M2 M'), eq N2 N'
HrecH3_1 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M1 M'), eq N1 N'
H3_0 : synthesis h M2 N2
H3_1 : synthesis h M1 N1
M1,N1,M2,N2 : Msg
H2 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H1 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H0 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
eq (MPair N1 N2) (MEnc N L)
+++++
inversion H3.
-----
Theorem inj_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_left (synthesis h).
unfold injective_left in |- *.
unfold enc_synthesis_left in |- *.
unfold op_synthesis_left in |- *.
unfold pair_free_left in |- *.
intro h.
intro.
intro.
intro.
intro.
intros M N H3.
induction H3 as [M N H3| M N K L H3_1 HrecH3_1 H3_0 HrecH3_0| M1 N1 M2 N2 H3_1 HrecH3_1 H3_0 HrecH3_0| o M N H3 HrecH3]; intros M' N' H4; [ induction H4 as [M0 N0 H4| M0 N0 K L H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o M0 N0 H4 HrecH4] | induction H4 as [M0 N0 H3| M0 N0 K0 L0 H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o M0 N0 H4 HrecH4] | induction H4 as [M N H3| M N K L H4_1 HrecH4_1 H4_0 HrecH4_0| M0 N0 M3 N3 H4_1 HrecH4_1 H4_0 HrecH4_0| o M N H4 HrecH4] | induction H4 as [M0 N0 H4| M0 N0 K L H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o0 M0 N0 H4 HrecH4] ].
intro.
exact (H M N H3 M0 N0 H4 H5).
intro.
cut (~ synthesis h M0 N0 \\/ ~ synthesis h K L).
intro.
case H5; intro H6; red in H6; tauto.
apply (H0 M N H3 M0 K H4).
intro.
rewrite H4 in H3.
cut False.
tauto.
apply (H2 M1 M2 N); trivial.
intro.
cut (~ synthesis h M0 N0).
intro.
tauto.
apply (H1 o M N H3 M0 H5); trivial.
intro.
cut (~ synthesis h M N \\/ ~ synthesis h K L).
intro.
case H5; intro H6; red in H6; tauto.
apply (H0 M0 N0 H3 M K); auto.
intro.
inversion H3.
rewrite (HrecH3_1 M0 N0 H4_1 H5).
rewrite (HrecH3_0 K0 L0 H4_0 H6).
trivial.
intro.
inversion H3.
intro.
inversion H3.
intro.
rewrite <- H4 in H3.
cut False.
tauto.
apply (H2 M1 M2 N H3).
intro.
inversion H3.

*****
HrecH4_0 : forall _ : eq (MPair M1 M2) M3, eq (MPair N1 N2) N3
HrecH4_1 : forall _ : eq (MPair M1 M2) M0, eq (MPair N1 N2) N0
H4_0 : synthesis h M3 N3
H4_1 : synthesis h M0 N0
M0,N0,M3,N3 : Msg
HrecH3_0 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M2 M'), eq N2 N'
HrecH3_1 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M1 M'), eq N1 N'
H3_0 : synthesis h M2 N2
H3_1 : synthesis h M1 N1
M1,N1,M2,N2 : Msg
H2 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H1 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H0 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
forall _ : eq (MPair M1 M2) (MPair M0 M3), eq (MPair N1 N2) (MPair N0 N3)
+++++
intro.
-----
Theorem inj_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_left (synthesis h).
unfold injective_left in |- *.
unfold enc_synthesis_left in |- *.
unfold op_synthesis_left in |- *.
unfold pair_free_left in |- *.
intro h.
intro.
intro.
intro.
intro.
intros M N H3.
induction H3 as [M N H3| M N K L H3_1 HrecH3_1 H3_0 HrecH3_0| M1 N1 M2 N2 H3_1 HrecH3_1 H3_0 HrecH3_0| o M N H3 HrecH3]; intros M' N' H4; [ induction H4 as [M0 N0 H4| M0 N0 K L H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o M0 N0 H4 HrecH4] | induction H4 as [M0 N0 H3| M0 N0 K0 L0 H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o M0 N0 H4 HrecH4] | induction H4 as [M N H3| M N K L H4_1 HrecH4_1 H4_0 HrecH4_0| M0 N0 M3 N3 H4_1 HrecH4_1 H4_0 HrecH4_0| o M N H4 HrecH4] | induction H4 as [M0 N0 H4| M0 N0 K L H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o0 M0 N0 H4 HrecH4] ].
intro.
exact (H M N H3 M0 N0 H4 H5).
intro.
cut (~ synthesis h M0 N0 \\/ ~ synthesis h K L).
intro.
case H5; intro H6; red in H6; tauto.
apply (H0 M N H3 M0 K H4).
intro.
rewrite H4 in H3.
cut False.
tauto.
apply (H2 M1 M2 N); trivial.
intro.
cut (~ synthesis h M0 N0).
intro.
tauto.
apply (H1 o M N H3 M0 H5); trivial.
intro.
cut (~ synthesis h M N \\/ ~ synthesis h K L).
intro.
case H5; intro H6; red in H6; tauto.
apply (H0 M0 N0 H3 M K); auto.
intro.
inversion H3.
rewrite (HrecH3_1 M0 N0 H4_1 H5).
rewrite (HrecH3_0 K0 L0 H4_0 H6).
trivial.
intro.
inversion H3.
intro.
inversion H3.
intro.
rewrite <- H4 in H3.
cut False.
tauto.
apply (H2 M1 M2 N H3).
intro.
inversion H3.
intro.

*****
H3 : eq (MPair M1 M2) (MPair M0 M3)
HrecH4_0 : forall _ : eq (MPair M1 M2) M3, eq (MPair N1 N2) N3
HrecH4_1 : forall _ : eq (MPair M1 M2) M0, eq (MPair N1 N2) N0
H4_0 : synthesis h M3 N3
H4_1 : synthesis h M0 N0
M0,N0,M3,N3 : Msg
HrecH3_0 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M2 M'), eq N2 N'
HrecH3_1 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M1 M'), eq N1 N'
H3_0 : synthesis h M2 N2
H3_1 : synthesis h M1 N1
M1,N1,M2,N2 : Msg
H2 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H1 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H0 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
eq (MPair N1 N2) (MPair N0 N3)
+++++
inversion H3.
-----
Theorem inj_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_left (synthesis h).
unfold injective_left in |- *.
unfold enc_synthesis_left in |- *.
unfold op_synthesis_left in |- *.
unfold pair_free_left in |- *.
intro h.
intro.
intro.
intro.
intro.
intros M N H3.
induction H3 as [M N H3| M N K L H3_1 HrecH3_1 H3_0 HrecH3_0| M1 N1 M2 N2 H3_1 HrecH3_1 H3_0 HrecH3_0| o M N H3 HrecH3]; intros M' N' H4; [ induction H4 as [M0 N0 H4| M0 N0 K L H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o M0 N0 H4 HrecH4] | induction H4 as [M0 N0 H3| M0 N0 K0 L0 H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o M0 N0 H4 HrecH4] | induction H4 as [M N H3| M N K L H4_1 HrecH4_1 H4_0 HrecH4_0| M0 N0 M3 N3 H4_1 HrecH4_1 H4_0 HrecH4_0| o M N H4 HrecH4] | induction H4 as [M0 N0 H4| M0 N0 K L H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o0 M0 N0 H4 HrecH4] ].
intro.
exact (H M N H3 M0 N0 H4 H5).
intro.
cut (~ synthesis h M0 N0 \\/ ~ synthesis h K L).
intro.
case H5; intro H6; red in H6; tauto.
apply (H0 M N H3 M0 K H4).
intro.
rewrite H4 in H3.
cut False.
tauto.
apply (H2 M1 M2 N); trivial.
intro.
cut (~ synthesis h M0 N0).
intro.
tauto.
apply (H1 o M N H3 M0 H5); trivial.
intro.
cut (~ synthesis h M N \\/ ~ synthesis h K L).
intro.
case H5; intro H6; red in H6; tauto.
apply (H0 M0 N0 H3 M K); auto.
intro.
inversion H3.
rewrite (HrecH3_1 M0 N0 H4_1 H5).
rewrite (HrecH3_0 K0 L0 H4_0 H6).
trivial.
intro.
inversion H3.
intro.
inversion H3.
intro.
rewrite <- H4 in H3.
cut False.
tauto.
apply (H2 M1 M2 N H3).
intro.
inversion H3.
intro.
inversion H3.

*****
H6 : eq M2 M3
H5 : eq M1 M0
H3 : eq (MPair M1 M2) (MPair M0 M3)
HrecH4_0 : forall _ : eq (MPair M1 M2) M3, eq (MPair N1 N2) N3
HrecH4_1 : forall _ : eq (MPair M1 M2) M0, eq (MPair N1 N2) N0
H4_0 : synthesis h M3 N3
H4_1 : synthesis h M0 N0
M0,N0,M3,N3 : Msg
HrecH3_0 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M2 M'), eq N2 N'
HrecH3_1 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M1 M'), eq N1 N'
H3_0 : synthesis h M2 N2
H3_1 : synthesis h M1 N1
M1,N1,M2,N2 : Msg
H2 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H1 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H0 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
eq (MPair N1 N2) (MPair N0 N3)
+++++
rewrite (HrecH3_1 M0 N0 H4_1 H5).
-----
Theorem inj_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_left (synthesis h).
unfold injective_left in |- *.
unfold enc_synthesis_left in |- *.
unfold op_synthesis_left in |- *.
unfold pair_free_left in |- *.
intro h.
intro.
intro.
intro.
intro.
intros M N H3.
induction H3 as [M N H3| M N K L H3_1 HrecH3_1 H3_0 HrecH3_0| M1 N1 M2 N2 H3_1 HrecH3_1 H3_0 HrecH3_0| o M N H3 HrecH3]; intros M' N' H4; [ induction H4 as [M0 N0 H4| M0 N0 K L H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o M0 N0 H4 HrecH4] | induction H4 as [M0 N0 H3| M0 N0 K0 L0 H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o M0 N0 H4 HrecH4] | induction H4 as [M N H3| M N K L H4_1 HrecH4_1 H4_0 HrecH4_0| M0 N0 M3 N3 H4_1 HrecH4_1 H4_0 HrecH4_0| o M N H4 HrecH4] | induction H4 as [M0 N0 H4| M0 N0 K L H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o0 M0 N0 H4 HrecH4] ].
intro.
exact (H M N H3 M0 N0 H4 H5).
intro.
cut (~ synthesis h M0 N0 \\/ ~ synthesis h K L).
intro.
case H5; intro H6; red in H6; tauto.
apply (H0 M N H3 M0 K H4).
intro.
rewrite H4 in H3.
cut False.
tauto.
apply (H2 M1 M2 N); trivial.
intro.
cut (~ synthesis h M0 N0).
intro.
tauto.
apply (H1 o M N H3 M0 H5); trivial.
intro.
cut (~ synthesis h M N \\/ ~ synthesis h K L).
intro.
case H5; intro H6; red in H6; tauto.
apply (H0 M0 N0 H3 M K); auto.
intro.
inversion H3.
rewrite (HrecH3_1 M0 N0 H4_1 H5).
rewrite (HrecH3_0 K0 L0 H4_0 H6).
trivial.
intro.
inversion H3.
intro.
inversion H3.
intro.
rewrite <- H4 in H3.
cut False.
tauto.
apply (H2 M1 M2 N H3).
intro.
inversion H3.
intro.
inversion H3.
rewrite (HrecH3_1 M0 N0 H4_1 H5).

*****
H6 : eq M2 M3
H5 : eq M1 M0
H3 : eq (MPair M1 M2) (MPair M0 M3)
HrecH4_0 : forall _ : eq (MPair M1 M2) M3, eq (MPair N1 N2) N3
HrecH4_1 : forall _ : eq (MPair M1 M2) M0, eq (MPair N1 N2) N0
H4_0 : synthesis h M3 N3
H4_1 : synthesis h M0 N0
M0,N0,M3,N3 : Msg
HrecH3_0 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M2 M'), eq N2 N'
HrecH3_1 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M1 M'), eq N1 N'
H3_0 : synthesis h M2 N2
H3_1 : synthesis h M1 N1
M1,N1,M2,N2 : Msg
H2 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H1 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H0 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
eq (MPair N0 N2) (MPair N0 N3)
+++++
rewrite (HrecH3_0 M3 N3 H4_0 H6); trivial.
-----
Theorem inj_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_left (synthesis h).
unfold injective_left in |- *.
unfold enc_synthesis_left in |- *.
unfold op_synthesis_left in |- *.
unfold pair_free_left in |- *.
intro h.
intro.
intro.
intro.
intro.
intros M N H3.
induction H3 as [M N H3| M N K L H3_1 HrecH3_1 H3_0 HrecH3_0| M1 N1 M2 N2 H3_1 HrecH3_1 H3_0 HrecH3_0| o M N H3 HrecH3]; intros M' N' H4; [ induction H4 as [M0 N0 H4| M0 N0 K L H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o M0 N0 H4 HrecH4] | induction H4 as [M0 N0 H3| M0 N0 K0 L0 H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o M0 N0 H4 HrecH4] | induction H4 as [M N H3| M N K L H4_1 HrecH4_1 H4_0 HrecH4_0| M0 N0 M3 N3 H4_1 HrecH4_1 H4_0 HrecH4_0| o M N H4 HrecH4] | induction H4 as [M0 N0 H4| M0 N0 K L H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o0 M0 N0 H4 HrecH4] ].
intro.
exact (H M N H3 M0 N0 H4 H5).
intro.
cut (~ synthesis h M0 N0 \\/ ~ synthesis h K L).
intro.
case H5; intro H6; red in H6; tauto.
apply (H0 M N H3 M0 K H4).
intro.
rewrite H4 in H3.
cut False.
tauto.
apply (H2 M1 M2 N); trivial.
intro.
cut (~ synthesis h M0 N0).
intro.
tauto.
apply (H1 o M N H3 M0 H5); trivial.
intro.
cut (~ synthesis h M N \\/ ~ synthesis h K L).
intro.
case H5; intro H6; red in H6; tauto.
apply (H0 M0 N0 H3 M K); auto.
intro.
inversion H3.
rewrite (HrecH3_1 M0 N0 H4_1 H5).
rewrite (HrecH3_0 K0 L0 H4_0 H6).
trivial.
intro.
inversion H3.
intro.
inversion H3.
intro.
rewrite <- H4 in H3.
cut False.
tauto.
apply (H2 M1 M2 N H3).
intro.
inversion H3.
intro.
inversion H3.
rewrite (HrecH3_1 M0 N0 H4_1 H5).
rewrite (HrecH3_0 M3 N3 H4_0 H6); trivial.

*****
HrecH4 : forall _ : eq (MPair M1 M2) M, eq (MPair N1 N2) N
H4 : synthesis h M N
M,N : Msg
o : op
HrecH3_0 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M2 M'), eq N2 N'
HrecH3_1 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M1 M'), eq N1 N'
H3_0 : synthesis h M2 N2
H3_1 : synthesis h M1 N1
M1,N1,M2,N2 : Msg
H2 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H1 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H0 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
forall _ : eq (MPair M1 M2) (Mop o M), eq (MPair N1 N2) (Mop o N)
+++++
intro.
-----
Theorem inj_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_left (synthesis h).
unfold injective_left in |- *.
unfold enc_synthesis_left in |- *.
unfold op_synthesis_left in |- *.
unfold pair_free_left in |- *.
intro h.
intro.
intro.
intro.
intro.
intros M N H3.
induction H3 as [M N H3| M N K L H3_1 HrecH3_1 H3_0 HrecH3_0| M1 N1 M2 N2 H3_1 HrecH3_1 H3_0 HrecH3_0| o M N H3 HrecH3]; intros M' N' H4; [ induction H4 as [M0 N0 H4| M0 N0 K L H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o M0 N0 H4 HrecH4] | induction H4 as [M0 N0 H3| M0 N0 K0 L0 H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o M0 N0 H4 HrecH4] | induction H4 as [M N H3| M N K L H4_1 HrecH4_1 H4_0 HrecH4_0| M0 N0 M3 N3 H4_1 HrecH4_1 H4_0 HrecH4_0| o M N H4 HrecH4] | induction H4 as [M0 N0 H4| M0 N0 K L H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o0 M0 N0 H4 HrecH4] ].
intro.
exact (H M N H3 M0 N0 H4 H5).
intro.
cut (~ synthesis h M0 N0 \\/ ~ synthesis h K L).
intro.
case H5; intro H6; red in H6; tauto.
apply (H0 M N H3 M0 K H4).
intro.
rewrite H4 in H3.
cut False.
tauto.
apply (H2 M1 M2 N); trivial.
intro.
cut (~ synthesis h M0 N0).
intro.
tauto.
apply (H1 o M N H3 M0 H5); trivial.
intro.
cut (~ synthesis h M N \\/ ~ synthesis h K L).
intro.
case H5; intro H6; red in H6; tauto.
apply (H0 M0 N0 H3 M K); auto.
intro.
inversion H3.
rewrite (HrecH3_1 M0 N0 H4_1 H5).
rewrite (HrecH3_0 K0 L0 H4_0 H6).
trivial.
intro.
inversion H3.
intro.
inversion H3.
intro.
rewrite <- H4 in H3.
cut False.
tauto.
apply (H2 M1 M2 N H3).
intro.
inversion H3.
intro.
inversion H3.
rewrite (HrecH3_1 M0 N0 H4_1 H5).
rewrite (HrecH3_0 M3 N3 H4_0 H6); trivial.
intro.

*****
H3 : eq (MPair M1 M2) (Mop o M)
HrecH4 : forall _ : eq (MPair M1 M2) M, eq (MPair N1 N2) N
H4 : synthesis h M N
M,N : Msg
o : op
HrecH3_0 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M2 M'), eq N2 N'
HrecH3_1 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M1 M'), eq N1 N'
H3_0 : synthesis h M2 N2
H3_1 : synthesis h M1 N1
M1,N1,M2,N2 : Msg
H2 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H1 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H0 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
eq (MPair N1 N2) (Mop o N)
+++++
inversion H3.
-----
Theorem inj_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_left (synthesis h).
unfold injective_left in |- *.
unfold enc_synthesis_left in |- *.
unfold op_synthesis_left in |- *.
unfold pair_free_left in |- *.
intro h.
intro.
intro.
intro.
intro.
intros M N H3.
induction H3 as [M N H3| M N K L H3_1 HrecH3_1 H3_0 HrecH3_0| M1 N1 M2 N2 H3_1 HrecH3_1 H3_0 HrecH3_0| o M N H3 HrecH3]; intros M' N' H4; [ induction H4 as [M0 N0 H4| M0 N0 K L H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o M0 N0 H4 HrecH4] | induction H4 as [M0 N0 H3| M0 N0 K0 L0 H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o M0 N0 H4 HrecH4] | induction H4 as [M N H3| M N K L H4_1 HrecH4_1 H4_0 HrecH4_0| M0 N0 M3 N3 H4_1 HrecH4_1 H4_0 HrecH4_0| o M N H4 HrecH4] | induction H4 as [M0 N0 H4| M0 N0 K L H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o0 M0 N0 H4 HrecH4] ].
intro.
exact (H M N H3 M0 N0 H4 H5).
intro.
cut (~ synthesis h M0 N0 \\/ ~ synthesis h K L).
intro.
case H5; intro H6; red in H6; tauto.
apply (H0 M N H3 M0 K H4).
intro.
rewrite H4 in H3.
cut False.
tauto.
apply (H2 M1 M2 N); trivial.
intro.
cut (~ synthesis h M0 N0).
intro.
tauto.
apply (H1 o M N H3 M0 H5); trivial.
intro.
cut (~ synthesis h M N \\/ ~ synthesis h K L).
intro.
case H5; intro H6; red in H6; tauto.
apply (H0 M0 N0 H3 M K); auto.
intro.
inversion H3.
rewrite (HrecH3_1 M0 N0 H4_1 H5).
rewrite (HrecH3_0 K0 L0 H4_0 H6).
trivial.
intro.
inversion H3.
intro.
inversion H3.
intro.
rewrite <- H4 in H3.
cut False.
tauto.
apply (H2 M1 M2 N H3).
intro.
inversion H3.
intro.
inversion H3.
rewrite (HrecH3_1 M0 N0 H4_1 H5).
rewrite (HrecH3_0 M3 N3 H4_0 H6); trivial.
intro.
inversion H3.

*****
H4 : h M0 N0
M0,N0 : Msg
HrecH3 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M M'), eq N N'
H3 : synthesis h M N
M,N : Msg
o : op
H2 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H1 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H0 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
forall _ : eq (Mop o M) M0, eq (Mop o N) N0
+++++
intro.
-----
Theorem inj_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_left (synthesis h).
unfold injective_left in |- *.
unfold enc_synthesis_left in |- *.
unfold op_synthesis_left in |- *.
unfold pair_free_left in |- *.
intro h.
intro.
intro.
intro.
intro.
intros M N H3.
induction H3 as [M N H3| M N K L H3_1 HrecH3_1 H3_0 HrecH3_0| M1 N1 M2 N2 H3_1 HrecH3_1 H3_0 HrecH3_0| o M N H3 HrecH3]; intros M' N' H4; [ induction H4 as [M0 N0 H4| M0 N0 K L H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o M0 N0 H4 HrecH4] | induction H4 as [M0 N0 H3| M0 N0 K0 L0 H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o M0 N0 H4 HrecH4] | induction H4 as [M N H3| M N K L H4_1 HrecH4_1 H4_0 HrecH4_0| M0 N0 M3 N3 H4_1 HrecH4_1 H4_0 HrecH4_0| o M N H4 HrecH4] | induction H4 as [M0 N0 H4| M0 N0 K L H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o0 M0 N0 H4 HrecH4] ].
intro.
exact (H M N H3 M0 N0 H4 H5).
intro.
cut (~ synthesis h M0 N0 \\/ ~ synthesis h K L).
intro.
case H5; intro H6; red in H6; tauto.
apply (H0 M N H3 M0 K H4).
intro.
rewrite H4 in H3.
cut False.
tauto.
apply (H2 M1 M2 N); trivial.
intro.
cut (~ synthesis h M0 N0).
intro.
tauto.
apply (H1 o M N H3 M0 H5); trivial.
intro.
cut (~ synthesis h M N \\/ ~ synthesis h K L).
intro.
case H5; intro H6; red in H6; tauto.
apply (H0 M0 N0 H3 M K); auto.
intro.
inversion H3.
rewrite (HrecH3_1 M0 N0 H4_1 H5).
rewrite (HrecH3_0 K0 L0 H4_0 H6).
trivial.
intro.
inversion H3.
intro.
inversion H3.
intro.
rewrite <- H4 in H3.
cut False.
tauto.
apply (H2 M1 M2 N H3).
intro.
inversion H3.
intro.
inversion H3.
rewrite (HrecH3_1 M0 N0 H4_1 H5).
rewrite (HrecH3_0 M3 N3 H4_0 H6); trivial.
intro.
inversion H3.
intro.

*****
H5 : eq (Mop o M) M0
H4 : h M0 N0
M0,N0 : Msg
HrecH3 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M M'), eq N N'
H3 : synthesis h M N
M,N : Msg
o : op
H2 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H1 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H0 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
eq (Mop o N) N0
+++++
cut (~ synthesis h M N).
-----
Theorem inj_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_left (synthesis h).
unfold injective_left in |- *.
unfold enc_synthesis_left in |- *.
unfold op_synthesis_left in |- *.
unfold pair_free_left in |- *.
intro h.
intro.
intro.
intro.
intro.
intros M N H3.
induction H3 as [M N H3| M N K L H3_1 HrecH3_1 H3_0 HrecH3_0| M1 N1 M2 N2 H3_1 HrecH3_1 H3_0 HrecH3_0| o M N H3 HrecH3]; intros M' N' H4; [ induction H4 as [M0 N0 H4| M0 N0 K L H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o M0 N0 H4 HrecH4] | induction H4 as [M0 N0 H3| M0 N0 K0 L0 H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o M0 N0 H4 HrecH4] | induction H4 as [M N H3| M N K L H4_1 HrecH4_1 H4_0 HrecH4_0| M0 N0 M3 N3 H4_1 HrecH4_1 H4_0 HrecH4_0| o M N H4 HrecH4] | induction H4 as [M0 N0 H4| M0 N0 K L H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o0 M0 N0 H4 HrecH4] ].
intro.
exact (H M N H3 M0 N0 H4 H5).
intro.
cut (~ synthesis h M0 N0 \\/ ~ synthesis h K L).
intro.
case H5; intro H6; red in H6; tauto.
apply (H0 M N H3 M0 K H4).
intro.
rewrite H4 in H3.
cut False.
tauto.
apply (H2 M1 M2 N); trivial.
intro.
cut (~ synthesis h M0 N0).
intro.
tauto.
apply (H1 o M N H3 M0 H5); trivial.
intro.
cut (~ synthesis h M N \\/ ~ synthesis h K L).
intro.
case H5; intro H6; red in H6; tauto.
apply (H0 M0 N0 H3 M K); auto.
intro.
inversion H3.
rewrite (HrecH3_1 M0 N0 H4_1 H5).
rewrite (HrecH3_0 K0 L0 H4_0 H6).
trivial.
intro.
inversion H3.
intro.
inversion H3.
intro.
rewrite <- H4 in H3.
cut False.
tauto.
apply (H2 M1 M2 N H3).
intro.
inversion H3.
intro.
inversion H3.
rewrite (HrecH3_1 M0 N0 H4_1 H5).
rewrite (HrecH3_0 M3 N3 H4_0 H6); trivial.
intro.
inversion H3.
intro.
cut (~ synthesis h M N).

*****
H5 : eq (Mop o M) M0
H4 : h M0 N0
M0,N0 : Msg
HrecH3 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M M'), eq N N'
H3 : synthesis h M N
M,N : Msg
o : op
H2 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H1 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H0 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
forall _ : not (synthesis h M N), eq (Mop o N) N0
+++++
intro.
-----
Theorem inj_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_left (synthesis h).
unfold injective_left in |- *.
unfold enc_synthesis_left in |- *.
unfold op_synthesis_left in |- *.
unfold pair_free_left in |- *.
intro h.
intro.
intro.
intro.
intro.
intros M N H3.
induction H3 as [M N H3| M N K L H3_1 HrecH3_1 H3_0 HrecH3_0| M1 N1 M2 N2 H3_1 HrecH3_1 H3_0 HrecH3_0| o M N H3 HrecH3]; intros M' N' H4; [ induction H4 as [M0 N0 H4| M0 N0 K L H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o M0 N0 H4 HrecH4] | induction H4 as [M0 N0 H3| M0 N0 K0 L0 H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o M0 N0 H4 HrecH4] | induction H4 as [M N H3| M N K L H4_1 HrecH4_1 H4_0 HrecH4_0| M0 N0 M3 N3 H4_1 HrecH4_1 H4_0 HrecH4_0| o M N H4 HrecH4] | induction H4 as [M0 N0 H4| M0 N0 K L H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o0 M0 N0 H4 HrecH4] ].
intro.
exact (H M N H3 M0 N0 H4 H5).
intro.
cut (~ synthesis h M0 N0 \\/ ~ synthesis h K L).
intro.
case H5; intro H6; red in H6; tauto.
apply (H0 M N H3 M0 K H4).
intro.
rewrite H4 in H3.
cut False.
tauto.
apply (H2 M1 M2 N); trivial.
intro.
cut (~ synthesis h M0 N0).
intro.
tauto.
apply (H1 o M N H3 M0 H5); trivial.
intro.
cut (~ synthesis h M N \\/ ~ synthesis h K L).
intro.
case H5; intro H6; red in H6; tauto.
apply (H0 M0 N0 H3 M K); auto.
intro.
inversion H3.
rewrite (HrecH3_1 M0 N0 H4_1 H5).
rewrite (HrecH3_0 K0 L0 H4_0 H6).
trivial.
intro.
inversion H3.
intro.
inversion H3.
intro.
rewrite <- H4 in H3.
cut False.
tauto.
apply (H2 M1 M2 N H3).
intro.
inversion H3.
intro.
inversion H3.
rewrite (HrecH3_1 M0 N0 H4_1 H5).
rewrite (HrecH3_0 M3 N3 H4_0 H6); trivial.
intro.
inversion H3.
intro.
cut (~ synthesis h M N).
intro.

*****
H6 : not (synthesis h M N)
H5 : eq (Mop o M) M0
H4 : h M0 N0
M0,N0 : Msg
HrecH3 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M M'), eq N N'
H3 : synthesis h M N
M,N : Msg
o : op
H2 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H1 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H0 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
eq (Mop o N) N0
+++++
tauto.
-----
Theorem inj_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_left (synthesis h).
unfold injective_left in |- *.
unfold enc_synthesis_left in |- *.
unfold op_synthesis_left in |- *.
unfold pair_free_left in |- *.
intro h.
intro.
intro.
intro.
intro.
intros M N H3.
induction H3 as [M N H3| M N K L H3_1 HrecH3_1 H3_0 HrecH3_0| M1 N1 M2 N2 H3_1 HrecH3_1 H3_0 HrecH3_0| o M N H3 HrecH3]; intros M' N' H4; [ induction H4 as [M0 N0 H4| M0 N0 K L H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o M0 N0 H4 HrecH4] | induction H4 as [M0 N0 H3| M0 N0 K0 L0 H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o M0 N0 H4 HrecH4] | induction H4 as [M N H3| M N K L H4_1 HrecH4_1 H4_0 HrecH4_0| M0 N0 M3 N3 H4_1 HrecH4_1 H4_0 HrecH4_0| o M N H4 HrecH4] | induction H4 as [M0 N0 H4| M0 N0 K L H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o0 M0 N0 H4 HrecH4] ].
intro.
exact (H M N H3 M0 N0 H4 H5).
intro.
cut (~ synthesis h M0 N0 \\/ ~ synthesis h K L).
intro.
case H5; intro H6; red in H6; tauto.
apply (H0 M N H3 M0 K H4).
intro.
rewrite H4 in H3.
cut False.
tauto.
apply (H2 M1 M2 N); trivial.
intro.
cut (~ synthesis h M0 N0).
intro.
tauto.
apply (H1 o M N H3 M0 H5); trivial.
intro.
cut (~ synthesis h M N \\/ ~ synthesis h K L).
intro.
case H5; intro H6; red in H6; tauto.
apply (H0 M0 N0 H3 M K); auto.
intro.
inversion H3.
rewrite (HrecH3_1 M0 N0 H4_1 H5).
rewrite (HrecH3_0 K0 L0 H4_0 H6).
trivial.
intro.
inversion H3.
intro.
inversion H3.
intro.
rewrite <- H4 in H3.
cut False.
tauto.
apply (H2 M1 M2 N H3).
intro.
inversion H3.
intro.
inversion H3.
rewrite (HrecH3_1 M0 N0 H4_1 H5).
rewrite (HrecH3_0 M3 N3 H4_0 H6); trivial.
intro.
inversion H3.
intro.
cut (~ synthesis h M N).
intro.
tauto.

*****
H5 : eq (Mop o M) M0
H4 : h M0 N0
M0,N0 : Msg
HrecH3 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M M'), eq N N'
H3 : synthesis h M N
M,N : Msg
o : op
H2 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H1 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H0 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
not (synthesis h M N)
+++++
apply (H1 o M0 N0 H4 M); auto.
-----
Theorem inj_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_left (synthesis h).
unfold injective_left in |- *.
unfold enc_synthesis_left in |- *.
unfold op_synthesis_left in |- *.
unfold pair_free_left in |- *.
intro h.
intro.
intro.
intro.
intro.
intros M N H3.
induction H3 as [M N H3| M N K L H3_1 HrecH3_1 H3_0 HrecH3_0| M1 N1 M2 N2 H3_1 HrecH3_1 H3_0 HrecH3_0| o M N H3 HrecH3]; intros M' N' H4; [ induction H4 as [M0 N0 H4| M0 N0 K L H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o M0 N0 H4 HrecH4] | induction H4 as [M0 N0 H3| M0 N0 K0 L0 H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o M0 N0 H4 HrecH4] | induction H4 as [M N H3| M N K L H4_1 HrecH4_1 H4_0 HrecH4_0| M0 N0 M3 N3 H4_1 HrecH4_1 H4_0 HrecH4_0| o M N H4 HrecH4] | induction H4 as [M0 N0 H4| M0 N0 K L H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o0 M0 N0 H4 HrecH4] ].
intro.
exact (H M N H3 M0 N0 H4 H5).
intro.
cut (~ synthesis h M0 N0 \\/ ~ synthesis h K L).
intro.
case H5; intro H6; red in H6; tauto.
apply (H0 M N H3 M0 K H4).
intro.
rewrite H4 in H3.
cut False.
tauto.
apply (H2 M1 M2 N); trivial.
intro.
cut (~ synthesis h M0 N0).
intro.
tauto.
apply (H1 o M N H3 M0 H5); trivial.
intro.
cut (~ synthesis h M N \\/ ~ synthesis h K L).
intro.
case H5; intro H6; red in H6; tauto.
apply (H0 M0 N0 H3 M K); auto.
intro.
inversion H3.
rewrite (HrecH3_1 M0 N0 H4_1 H5).
rewrite (HrecH3_0 K0 L0 H4_0 H6).
trivial.
intro.
inversion H3.
intro.
inversion H3.
intro.
rewrite <- H4 in H3.
cut False.
tauto.
apply (H2 M1 M2 N H3).
intro.
inversion H3.
intro.
inversion H3.
rewrite (HrecH3_1 M0 N0 H4_1 H5).
rewrite (HrecH3_0 M3 N3 H4_0 H6); trivial.
intro.
inversion H3.
intro.
cut (~ synthesis h M N).
intro.
tauto.
apply (H1 o M0 N0 H4 M); auto.

*****
HrecH4_0 : forall _ : eq (Mop o M) K, eq (Mop o N) L
HrecH4_1 : forall _ : eq (Mop o M) M0, eq (Mop o N) N0
H4_0 : synthesis h K L
H4_1 : synthesis h M0 N0
M0,N0,K,L : Msg
HrecH3 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M M'), eq N N'
H3 : synthesis h M N
M,N : Msg
o : op
H2 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H1 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H0 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
forall _ : eq (Mop o M) (MEnc M0 K), eq (Mop o N) (MEnc N0 L)
+++++
intro.
-----
Theorem inj_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_left (synthesis h).
unfold injective_left in |- *.
unfold enc_synthesis_left in |- *.
unfold op_synthesis_left in |- *.
unfold pair_free_left in |- *.
intro h.
intro.
intro.
intro.
intro.
intros M N H3.
induction H3 as [M N H3| M N K L H3_1 HrecH3_1 H3_0 HrecH3_0| M1 N1 M2 N2 H3_1 HrecH3_1 H3_0 HrecH3_0| o M N H3 HrecH3]; intros M' N' H4; [ induction H4 as [M0 N0 H4| M0 N0 K L H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o M0 N0 H4 HrecH4] | induction H4 as [M0 N0 H3| M0 N0 K0 L0 H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o M0 N0 H4 HrecH4] | induction H4 as [M N H3| M N K L H4_1 HrecH4_1 H4_0 HrecH4_0| M0 N0 M3 N3 H4_1 HrecH4_1 H4_0 HrecH4_0| o M N H4 HrecH4] | induction H4 as [M0 N0 H4| M0 N0 K L H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o0 M0 N0 H4 HrecH4] ].
intro.
exact (H M N H3 M0 N0 H4 H5).
intro.
cut (~ synthesis h M0 N0 \\/ ~ synthesis h K L).
intro.
case H5; intro H6; red in H6; tauto.
apply (H0 M N H3 M0 K H4).
intro.
rewrite H4 in H3.
cut False.
tauto.
apply (H2 M1 M2 N); trivial.
intro.
cut (~ synthesis h M0 N0).
intro.
tauto.
apply (H1 o M N H3 M0 H5); trivial.
intro.
cut (~ synthesis h M N \\/ ~ synthesis h K L).
intro.
case H5; intro H6; red in H6; tauto.
apply (H0 M0 N0 H3 M K); auto.
intro.
inversion H3.
rewrite (HrecH3_1 M0 N0 H4_1 H5).
rewrite (HrecH3_0 K0 L0 H4_0 H6).
trivial.
intro.
inversion H3.
intro.
inversion H3.
intro.
rewrite <- H4 in H3.
cut False.
tauto.
apply (H2 M1 M2 N H3).
intro.
inversion H3.
intro.
inversion H3.
rewrite (HrecH3_1 M0 N0 H4_1 H5).
rewrite (HrecH3_0 M3 N3 H4_0 H6); trivial.
intro.
inversion H3.
intro.
cut (~ synthesis h M N).
intro.
tauto.
apply (H1 o M0 N0 H4 M); auto.
intro.

*****
H4 : eq (Mop o M) (MEnc M0 K)
HrecH4_0 : forall _ : eq (Mop o M) K, eq (Mop o N) L
HrecH4_1 : forall _ : eq (Mop o M) M0, eq (Mop o N) N0
H4_0 : synthesis h K L
H4_1 : synthesis h M0 N0
M0,N0,K,L : Msg
HrecH3 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M M'), eq N N'
H3 : synthesis h M N
M,N : Msg
o : op
H2 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H1 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H0 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
eq (Mop o N) (MEnc N0 L)
+++++
inversion H4.
-----
Theorem inj_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_left (synthesis h).
unfold injective_left in |- *.
unfold enc_synthesis_left in |- *.
unfold op_synthesis_left in |- *.
unfold pair_free_left in |- *.
intro h.
intro.
intro.
intro.
intro.
intros M N H3.
induction H3 as [M N H3| M N K L H3_1 HrecH3_1 H3_0 HrecH3_0| M1 N1 M2 N2 H3_1 HrecH3_1 H3_0 HrecH3_0| o M N H3 HrecH3]; intros M' N' H4; [ induction H4 as [M0 N0 H4| M0 N0 K L H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o M0 N0 H4 HrecH4] | induction H4 as [M0 N0 H3| M0 N0 K0 L0 H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o M0 N0 H4 HrecH4] | induction H4 as [M N H3| M N K L H4_1 HrecH4_1 H4_0 HrecH4_0| M0 N0 M3 N3 H4_1 HrecH4_1 H4_0 HrecH4_0| o M N H4 HrecH4] | induction H4 as [M0 N0 H4| M0 N0 K L H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o0 M0 N0 H4 HrecH4] ].
intro.
exact (H M N H3 M0 N0 H4 H5).
intro.
cut (~ synthesis h M0 N0 \\/ ~ synthesis h K L).
intro.
case H5; intro H6; red in H6; tauto.
apply (H0 M N H3 M0 K H4).
intro.
rewrite H4 in H3.
cut False.
tauto.
apply (H2 M1 M2 N); trivial.
intro.
cut (~ synthesis h M0 N0).
intro.
tauto.
apply (H1 o M N H3 M0 H5); trivial.
intro.
cut (~ synthesis h M N \\/ ~ synthesis h K L).
intro.
case H5; intro H6; red in H6; tauto.
apply (H0 M0 N0 H3 M K); auto.
intro.
inversion H3.
rewrite (HrecH3_1 M0 N0 H4_1 H5).
rewrite (HrecH3_0 K0 L0 H4_0 H6).
trivial.
intro.
inversion H3.
intro.
inversion H3.
intro.
rewrite <- H4 in H3.
cut False.
tauto.
apply (H2 M1 M2 N H3).
intro.
inversion H3.
intro.
inversion H3.
rewrite (HrecH3_1 M0 N0 H4_1 H5).
rewrite (HrecH3_0 M3 N3 H4_0 H6); trivial.
intro.
inversion H3.
intro.
cut (~ synthesis h M N).
intro.
tauto.
apply (H1 o M0 N0 H4 M); auto.
intro.
inversion H4.

*****
HrecH4_0 : forall _ : eq (Mop o M) M2, eq (Mop o N) N2
HrecH4_1 : forall _ : eq (Mop o M) M1, eq (Mop o N) N1
H4_0 : synthesis h M2 N2
H4_1 : synthesis h M1 N1
M1,N1,M2,N2 : Msg
HrecH3 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M M'), eq N N'
H3 : synthesis h M N
M,N : Msg
o : op
H2 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H1 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H0 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
forall _ : eq (Mop o M) (MPair M1 M2), eq (Mop o N) (MPair N1 N2)
+++++
intro.
-----
Theorem inj_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_left (synthesis h).
unfold injective_left in |- *.
unfold enc_synthesis_left in |- *.
unfold op_synthesis_left in |- *.
unfold pair_free_left in |- *.
intro h.
intro.
intro.
intro.
intro.
intros M N H3.
induction H3 as [M N H3| M N K L H3_1 HrecH3_1 H3_0 HrecH3_0| M1 N1 M2 N2 H3_1 HrecH3_1 H3_0 HrecH3_0| o M N H3 HrecH3]; intros M' N' H4; [ induction H4 as [M0 N0 H4| M0 N0 K L H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o M0 N0 H4 HrecH4] | induction H4 as [M0 N0 H3| M0 N0 K0 L0 H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o M0 N0 H4 HrecH4] | induction H4 as [M N H3| M N K L H4_1 HrecH4_1 H4_0 HrecH4_0| M0 N0 M3 N3 H4_1 HrecH4_1 H4_0 HrecH4_0| o M N H4 HrecH4] | induction H4 as [M0 N0 H4| M0 N0 K L H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o0 M0 N0 H4 HrecH4] ].
intro.
exact (H M N H3 M0 N0 H4 H5).
intro.
cut (~ synthesis h M0 N0 \\/ ~ synthesis h K L).
intro.
case H5; intro H6; red in H6; tauto.
apply (H0 M N H3 M0 K H4).
intro.
rewrite H4 in H3.
cut False.
tauto.
apply (H2 M1 M2 N); trivial.
intro.
cut (~ synthesis h M0 N0).
intro.
tauto.
apply (H1 o M N H3 M0 H5); trivial.
intro.
cut (~ synthesis h M N \\/ ~ synthesis h K L).
intro.
case H5; intro H6; red in H6; tauto.
apply (H0 M0 N0 H3 M K); auto.
intro.
inversion H3.
rewrite (HrecH3_1 M0 N0 H4_1 H5).
rewrite (HrecH3_0 K0 L0 H4_0 H6).
trivial.
intro.
inversion H3.
intro.
inversion H3.
intro.
rewrite <- H4 in H3.
cut False.
tauto.
apply (H2 M1 M2 N H3).
intro.
inversion H3.
intro.
inversion H3.
rewrite (HrecH3_1 M0 N0 H4_1 H5).
rewrite (HrecH3_0 M3 N3 H4_0 H6); trivial.
intro.
inversion H3.
intro.
cut (~ synthesis h M N).
intro.
tauto.
apply (H1 o M0 N0 H4 M); auto.
intro.
inversion H4.
intro.

*****
H4 : eq (Mop o M) (MPair M1 M2)
HrecH4_0 : forall _ : eq (Mop o M) M2, eq (Mop o N) N2
HrecH4_1 : forall _ : eq (Mop o M) M1, eq (Mop o N) N1
H4_0 : synthesis h M2 N2
H4_1 : synthesis h M1 N1
M1,N1,M2,N2 : Msg
HrecH3 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M M'), eq N N'
H3 : synthesis h M N
M,N : Msg
o : op
H2 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H1 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H0 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
eq (Mop o N) (MPair N1 N2)
+++++
inversion H4.
-----
Theorem inj_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_left (synthesis h).
unfold injective_left in |- *.
unfold enc_synthesis_left in |- *.
unfold op_synthesis_left in |- *.
unfold pair_free_left in |- *.
intro h.
intro.
intro.
intro.
intro.
intros M N H3.
induction H3 as [M N H3| M N K L H3_1 HrecH3_1 H3_0 HrecH3_0| M1 N1 M2 N2 H3_1 HrecH3_1 H3_0 HrecH3_0| o M N H3 HrecH3]; intros M' N' H4; [ induction H4 as [M0 N0 H4| M0 N0 K L H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o M0 N0 H4 HrecH4] | induction H4 as [M0 N0 H3| M0 N0 K0 L0 H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o M0 N0 H4 HrecH4] | induction H4 as [M N H3| M N K L H4_1 HrecH4_1 H4_0 HrecH4_0| M0 N0 M3 N3 H4_1 HrecH4_1 H4_0 HrecH4_0| o M N H4 HrecH4] | induction H4 as [M0 N0 H4| M0 N0 K L H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o0 M0 N0 H4 HrecH4] ].
intro.
exact (H M N H3 M0 N0 H4 H5).
intro.
cut (~ synthesis h M0 N0 \\/ ~ synthesis h K L).
intro.
case H5; intro H6; red in H6; tauto.
apply (H0 M N H3 M0 K H4).
intro.
rewrite H4 in H3.
cut False.
tauto.
apply (H2 M1 M2 N); trivial.
intro.
cut (~ synthesis h M0 N0).
intro.
tauto.
apply (H1 o M N H3 M0 H5); trivial.
intro.
cut (~ synthesis h M N \\/ ~ synthesis h K L).
intro.
case H5; intro H6; red in H6; tauto.
apply (H0 M0 N0 H3 M K); auto.
intro.
inversion H3.
rewrite (HrecH3_1 M0 N0 H4_1 H5).
rewrite (HrecH3_0 K0 L0 H4_0 H6).
trivial.
intro.
inversion H3.
intro.
inversion H3.
intro.
rewrite <- H4 in H3.
cut False.
tauto.
apply (H2 M1 M2 N H3).
intro.
inversion H3.
intro.
inversion H3.
rewrite (HrecH3_1 M0 N0 H4_1 H5).
rewrite (HrecH3_0 M3 N3 H4_0 H6); trivial.
intro.
inversion H3.
intro.
cut (~ synthesis h M N).
intro.
tauto.
apply (H1 o M0 N0 H4 M); auto.
intro.
inversion H4.
intro.
inversion H4.

*****
HrecH4 : forall _ : eq (Mop o M) M0, eq (Mop o N) N0
H4 : synthesis h M0 N0
M0,N0 : Msg
o0 : op
HrecH3 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M M'), eq N N'
H3 : synthesis h M N
M,N : Msg
o : op
H2 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H1 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H0 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
forall _ : eq (Mop o M) (Mop o0 M0), eq (Mop o N) (Mop o0 N0)
+++++
case (op_eq_dec o o0).
-----
Theorem inj_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_left (synthesis h).
unfold injective_left in |- *.
unfold enc_synthesis_left in |- *.
unfold op_synthesis_left in |- *.
unfold pair_free_left in |- *.
intro h.
intro.
intro.
intro.
intro.
intros M N H3.
induction H3 as [M N H3| M N K L H3_1 HrecH3_1 H3_0 HrecH3_0| M1 N1 M2 N2 H3_1 HrecH3_1 H3_0 HrecH3_0| o M N H3 HrecH3]; intros M' N' H4; [ induction H4 as [M0 N0 H4| M0 N0 K L H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o M0 N0 H4 HrecH4] | induction H4 as [M0 N0 H3| M0 N0 K0 L0 H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o M0 N0 H4 HrecH4] | induction H4 as [M N H3| M N K L H4_1 HrecH4_1 H4_0 HrecH4_0| M0 N0 M3 N3 H4_1 HrecH4_1 H4_0 HrecH4_0| o M N H4 HrecH4] | induction H4 as [M0 N0 H4| M0 N0 K L H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o0 M0 N0 H4 HrecH4] ].
intro.
exact (H M N H3 M0 N0 H4 H5).
intro.
cut (~ synthesis h M0 N0 \\/ ~ synthesis h K L).
intro.
case H5; intro H6; red in H6; tauto.
apply (H0 M N H3 M0 K H4).
intro.
rewrite H4 in H3.
cut False.
tauto.
apply (H2 M1 M2 N); trivial.
intro.
cut (~ synthesis h M0 N0).
intro.
tauto.
apply (H1 o M N H3 M0 H5); trivial.
intro.
cut (~ synthesis h M N \\/ ~ synthesis h K L).
intro.
case H5; intro H6; red in H6; tauto.
apply (H0 M0 N0 H3 M K); auto.
intro.
inversion H3.
rewrite (HrecH3_1 M0 N0 H4_1 H5).
rewrite (HrecH3_0 K0 L0 H4_0 H6).
trivial.
intro.
inversion H3.
intro.
inversion H3.
intro.
rewrite <- H4 in H3.
cut False.
tauto.
apply (H2 M1 M2 N H3).
intro.
inversion H3.
intro.
inversion H3.
rewrite (HrecH3_1 M0 N0 H4_1 H5).
rewrite (HrecH3_0 M3 N3 H4_0 H6); trivial.
intro.
inversion H3.
intro.
cut (~ synthesis h M N).
intro.
tauto.
apply (H1 o M0 N0 H4 M); auto.
intro.
inversion H4.
intro.
inversion H4.
case (op_eq_dec o o0).

*****
HrecH4 : forall _ : eq (Mop o M) M0, eq (Mop o N) N0
H4 : synthesis h M0 N0
M0,N0 : Msg
o0 : op
HrecH3 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M M'), eq N N'
H3 : synthesis h M N
M,N : Msg
o : op
H2 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H1 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H0 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
forall (_ : eq o o0) (_ : eq (Mop o M) (Mop o0 M0)), eq (Mop o N) (Mop o0 N0)
+++++
intro.
-----
Theorem inj_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_left (synthesis h).
unfold injective_left in |- *.
unfold enc_synthesis_left in |- *.
unfold op_synthesis_left in |- *.
unfold pair_free_left in |- *.
intro h.
intro.
intro.
intro.
intro.
intros M N H3.
induction H3 as [M N H3| M N K L H3_1 HrecH3_1 H3_0 HrecH3_0| M1 N1 M2 N2 H3_1 HrecH3_1 H3_0 HrecH3_0| o M N H3 HrecH3]; intros M' N' H4; [ induction H4 as [M0 N0 H4| M0 N0 K L H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o M0 N0 H4 HrecH4] | induction H4 as [M0 N0 H3| M0 N0 K0 L0 H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o M0 N0 H4 HrecH4] | induction H4 as [M N H3| M N K L H4_1 HrecH4_1 H4_0 HrecH4_0| M0 N0 M3 N3 H4_1 HrecH4_1 H4_0 HrecH4_0| o M N H4 HrecH4] | induction H4 as [M0 N0 H4| M0 N0 K L H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o0 M0 N0 H4 HrecH4] ].
intro.
exact (H M N H3 M0 N0 H4 H5).
intro.
cut (~ synthesis h M0 N0 \\/ ~ synthesis h K L).
intro.
case H5; intro H6; red in H6; tauto.
apply (H0 M N H3 M0 K H4).
intro.
rewrite H4 in H3.
cut False.
tauto.
apply (H2 M1 M2 N); trivial.
intro.
cut (~ synthesis h M0 N0).
intro.
tauto.
apply (H1 o M N H3 M0 H5); trivial.
intro.
cut (~ synthesis h M N \\/ ~ synthesis h K L).
intro.
case H5; intro H6; red in H6; tauto.
apply (H0 M0 N0 H3 M K); auto.
intro.
inversion H3.
rewrite (HrecH3_1 M0 N0 H4_1 H5).
rewrite (HrecH3_0 K0 L0 H4_0 H6).
trivial.
intro.
inversion H3.
intro.
inversion H3.
intro.
rewrite <- H4 in H3.
cut False.
tauto.
apply (H2 M1 M2 N H3).
intro.
inversion H3.
intro.
inversion H3.
rewrite (HrecH3_1 M0 N0 H4_1 H5).
rewrite (HrecH3_0 M3 N3 H4_0 H6); trivial.
intro.
inversion H3.
intro.
cut (~ synthesis h M N).
intro.
tauto.
apply (H1 o M0 N0 H4 M); auto.
intro.
inversion H4.
intro.
inversion H4.
case (op_eq_dec o o0).
intro.

*****
e : eq o o0
HrecH4 : forall _ : eq (Mop o M) M0, eq (Mop o N) N0
H4 : synthesis h M0 N0
M0,N0 : Msg
o0 : op
HrecH3 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M M'), eq N N'
H3 : synthesis h M N
M,N : Msg
o : op
H2 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H1 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H0 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
forall _ : eq (Mop o M) (Mop o0 M0), eq (Mop o N) (Mop o0 N0)
+++++
rewrite <- e.
-----
Theorem inj_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_left (synthesis h).
unfold injective_left in |- *.
unfold enc_synthesis_left in |- *.
unfold op_synthesis_left in |- *.
unfold pair_free_left in |- *.
intro h.
intro.
intro.
intro.
intro.
intros M N H3.
induction H3 as [M N H3| M N K L H3_1 HrecH3_1 H3_0 HrecH3_0| M1 N1 M2 N2 H3_1 HrecH3_1 H3_0 HrecH3_0| o M N H3 HrecH3]; intros M' N' H4; [ induction H4 as [M0 N0 H4| M0 N0 K L H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o M0 N0 H4 HrecH4] | induction H4 as [M0 N0 H3| M0 N0 K0 L0 H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o M0 N0 H4 HrecH4] | induction H4 as [M N H3| M N K L H4_1 HrecH4_1 H4_0 HrecH4_0| M0 N0 M3 N3 H4_1 HrecH4_1 H4_0 HrecH4_0| o M N H4 HrecH4] | induction H4 as [M0 N0 H4| M0 N0 K L H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o0 M0 N0 H4 HrecH4] ].
intro.
exact (H M N H3 M0 N0 H4 H5).
intro.
cut (~ synthesis h M0 N0 \\/ ~ synthesis h K L).
intro.
case H5; intro H6; red in H6; tauto.
apply (H0 M N H3 M0 K H4).
intro.
rewrite H4 in H3.
cut False.
tauto.
apply (H2 M1 M2 N); trivial.
intro.
cut (~ synthesis h M0 N0).
intro.
tauto.
apply (H1 o M N H3 M0 H5); trivial.
intro.
cut (~ synthesis h M N \\/ ~ synthesis h K L).
intro.
case H5; intro H6; red in H6; tauto.
apply (H0 M0 N0 H3 M K); auto.
intro.
inversion H3.
rewrite (HrecH3_1 M0 N0 H4_1 H5).
rewrite (HrecH3_0 K0 L0 H4_0 H6).
trivial.
intro.
inversion H3.
intro.
inversion H3.
intro.
rewrite <- H4 in H3.
cut False.
tauto.
apply (H2 M1 M2 N H3).
intro.
inversion H3.
intro.
inversion H3.
rewrite (HrecH3_1 M0 N0 H4_1 H5).
rewrite (HrecH3_0 M3 N3 H4_0 H6); trivial.
intro.
inversion H3.
intro.
cut (~ synthesis h M N).
intro.
tauto.
apply (H1 o M0 N0 H4 M); auto.
intro.
inversion H4.
intro.
inversion H4.
case (op_eq_dec o o0).
intro.
rewrite <- e.

*****
e : eq o o0
HrecH4 : forall _ : eq (Mop o M) M0, eq (Mop o N) N0
H4 : synthesis h M0 N0
M0,N0 : Msg
o0 : op
HrecH3 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M M'), eq N N'
H3 : synthesis h M N
M,N : Msg
o : op
H2 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H1 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H0 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
forall _ : eq (Mop o M) (Mop o M0), eq (Mop o N) (Mop o N0)
+++++
intro.
-----
Theorem inj_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_left (synthesis h).
unfold injective_left in |- *.
unfold enc_synthesis_left in |- *.
unfold op_synthesis_left in |- *.
unfold pair_free_left in |- *.
intro h.
intro.
intro.
intro.
intro.
intros M N H3.
induction H3 as [M N H3| M N K L H3_1 HrecH3_1 H3_0 HrecH3_0| M1 N1 M2 N2 H3_1 HrecH3_1 H3_0 HrecH3_0| o M N H3 HrecH3]; intros M' N' H4; [ induction H4 as [M0 N0 H4| M0 N0 K L H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o M0 N0 H4 HrecH4] | induction H4 as [M0 N0 H3| M0 N0 K0 L0 H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o M0 N0 H4 HrecH4] | induction H4 as [M N H3| M N K L H4_1 HrecH4_1 H4_0 HrecH4_0| M0 N0 M3 N3 H4_1 HrecH4_1 H4_0 HrecH4_0| o M N H4 HrecH4] | induction H4 as [M0 N0 H4| M0 N0 K L H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o0 M0 N0 H4 HrecH4] ].
intro.
exact (H M N H3 M0 N0 H4 H5).
intro.
cut (~ synthesis h M0 N0 \\/ ~ synthesis h K L).
intro.
case H5; intro H6; red in H6; tauto.
apply (H0 M N H3 M0 K H4).
intro.
rewrite H4 in H3.
cut False.
tauto.
apply (H2 M1 M2 N); trivial.
intro.
cut (~ synthesis h M0 N0).
intro.
tauto.
apply (H1 o M N H3 M0 H5); trivial.
intro.
cut (~ synthesis h M N \\/ ~ synthesis h K L).
intro.
case H5; intro H6; red in H6; tauto.
apply (H0 M0 N0 H3 M K); auto.
intro.
inversion H3.
rewrite (HrecH3_1 M0 N0 H4_1 H5).
rewrite (HrecH3_0 K0 L0 H4_0 H6).
trivial.
intro.
inversion H3.
intro.
inversion H3.
intro.
rewrite <- H4 in H3.
cut False.
tauto.
apply (H2 M1 M2 N H3).
intro.
inversion H3.
intro.
inversion H3.
rewrite (HrecH3_1 M0 N0 H4_1 H5).
rewrite (HrecH3_0 M3 N3 H4_0 H6); trivial.
intro.
inversion H3.
intro.
cut (~ synthesis h M N).
intro.
tauto.
apply (H1 o M0 N0 H4 M); auto.
intro.
inversion H4.
intro.
inversion H4.
case (op_eq_dec o o0).
intro.
rewrite <- e.
intro.

*****
H5 : eq (Mop o M) (Mop o M0)
e : eq o o0
HrecH4 : forall _ : eq (Mop o M) M0, eq (Mop o N) N0
H4 : synthesis h M0 N0
M0,N0 : Msg
o0 : op
HrecH3 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M M'), eq N N'
H3 : synthesis h M N
M,N : Msg
o : op
H2 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H1 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H0 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
eq (Mop o N) (Mop o N0)
+++++
inversion H5.
-----
Theorem inj_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_left (synthesis h).
unfold injective_left in |- *.
unfold enc_synthesis_left in |- *.
unfold op_synthesis_left in |- *.
unfold pair_free_left in |- *.
intro h.
intro.
intro.
intro.
intro.
intros M N H3.
induction H3 as [M N H3| M N K L H3_1 HrecH3_1 H3_0 HrecH3_0| M1 N1 M2 N2 H3_1 HrecH3_1 H3_0 HrecH3_0| o M N H3 HrecH3]; intros M' N' H4; [ induction H4 as [M0 N0 H4| M0 N0 K L H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o M0 N0 H4 HrecH4] | induction H4 as [M0 N0 H3| M0 N0 K0 L0 H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o M0 N0 H4 HrecH4] | induction H4 as [M N H3| M N K L H4_1 HrecH4_1 H4_0 HrecH4_0| M0 N0 M3 N3 H4_1 HrecH4_1 H4_0 HrecH4_0| o M N H4 HrecH4] | induction H4 as [M0 N0 H4| M0 N0 K L H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o0 M0 N0 H4 HrecH4] ].
intro.
exact (H M N H3 M0 N0 H4 H5).
intro.
cut (~ synthesis h M0 N0 \\/ ~ synthesis h K L).
intro.
case H5; intro H6; red in H6; tauto.
apply (H0 M N H3 M0 K H4).
intro.
rewrite H4 in H3.
cut False.
tauto.
apply (H2 M1 M2 N); trivial.
intro.
cut (~ synthesis h M0 N0).
intro.
tauto.
apply (H1 o M N H3 M0 H5); trivial.
intro.
cut (~ synthesis h M N \\/ ~ synthesis h K L).
intro.
case H5; intro H6; red in H6; tauto.
apply (H0 M0 N0 H3 M K); auto.
intro.
inversion H3.
rewrite (HrecH3_1 M0 N0 H4_1 H5).
rewrite (HrecH3_0 K0 L0 H4_0 H6).
trivial.
intro.
inversion H3.
intro.
inversion H3.
intro.
rewrite <- H4 in H3.
cut False.
tauto.
apply (H2 M1 M2 N H3).
intro.
inversion H3.
intro.
inversion H3.
rewrite (HrecH3_1 M0 N0 H4_1 H5).
rewrite (HrecH3_0 M3 N3 H4_0 H6); trivial.
intro.
inversion H3.
intro.
cut (~ synthesis h M N).
intro.
tauto.
apply (H1 o M0 N0 H4 M); auto.
intro.
inversion H4.
intro.
inversion H4.
case (op_eq_dec o o0).
intro.
rewrite <- e.
intro.
inversion H5.

*****
H7 : eq M M0
H5 : eq (Mop o M) (Mop o M0)
e : eq o o0
HrecH4 : forall _ : eq (Mop o M) M0, eq (Mop o N) N0
H4 : synthesis h M0 N0
M0,N0 : Msg
o0 : op
HrecH3 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M M'), eq N N'
H3 : synthesis h M N
M,N : Msg
o : op
H2 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H1 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H0 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
eq (Mop o N) (Mop o N0)
+++++
rewrite (HrecH3 M0 N0 H4 H7).
-----
Theorem inj_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_left (synthesis h).
unfold injective_left in |- *.
unfold enc_synthesis_left in |- *.
unfold op_synthesis_left in |- *.
unfold pair_free_left in |- *.
intro h.
intro.
intro.
intro.
intro.
intros M N H3.
induction H3 as [M N H3| M N K L H3_1 HrecH3_1 H3_0 HrecH3_0| M1 N1 M2 N2 H3_1 HrecH3_1 H3_0 HrecH3_0| o M N H3 HrecH3]; intros M' N' H4; [ induction H4 as [M0 N0 H4| M0 N0 K L H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o M0 N0 H4 HrecH4] | induction H4 as [M0 N0 H3| M0 N0 K0 L0 H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o M0 N0 H4 HrecH4] | induction H4 as [M N H3| M N K L H4_1 HrecH4_1 H4_0 HrecH4_0| M0 N0 M3 N3 H4_1 HrecH4_1 H4_0 HrecH4_0| o M N H4 HrecH4] | induction H4 as [M0 N0 H4| M0 N0 K L H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o0 M0 N0 H4 HrecH4] ].
intro.
exact (H M N H3 M0 N0 H4 H5).
intro.
cut (~ synthesis h M0 N0 \\/ ~ synthesis h K L).
intro.
case H5; intro H6; red in H6; tauto.
apply (H0 M N H3 M0 K H4).
intro.
rewrite H4 in H3.
cut False.
tauto.
apply (H2 M1 M2 N); trivial.
intro.
cut (~ synthesis h M0 N0).
intro.
tauto.
apply (H1 o M N H3 M0 H5); trivial.
intro.
cut (~ synthesis h M N \\/ ~ synthesis h K L).
intro.
case H5; intro H6; red in H6; tauto.
apply (H0 M0 N0 H3 M K); auto.
intro.
inversion H3.
rewrite (HrecH3_1 M0 N0 H4_1 H5).
rewrite (HrecH3_0 K0 L0 H4_0 H6).
trivial.
intro.
inversion H3.
intro.
inversion H3.
intro.
rewrite <- H4 in H3.
cut False.
tauto.
apply (H2 M1 M2 N H3).
intro.
inversion H3.
intro.
inversion H3.
rewrite (HrecH3_1 M0 N0 H4_1 H5).
rewrite (HrecH3_0 M3 N3 H4_0 H6); trivial.
intro.
inversion H3.
intro.
cut (~ synthesis h M N).
intro.
tauto.
apply (H1 o M0 N0 H4 M); auto.
intro.
inversion H4.
intro.
inversion H4.
case (op_eq_dec o o0).
intro.
rewrite <- e.
intro.
inversion H5.
rewrite (HrecH3 M0 N0 H4 H7).

*****
H7 : eq M M0
H5 : eq (Mop o M) (Mop o M0)
e : eq o o0
HrecH4 : forall _ : eq (Mop o M) M0, eq (Mop o N) N0
H4 : synthesis h M0 N0
M0,N0 : Msg
o0 : op
HrecH3 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M M'), eq N N'
H3 : synthesis h M N
M,N : Msg
o : op
H2 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H1 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H0 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
eq (Mop o N0) (Mop o N0)
+++++
trivial.
-----
Theorem inj_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_left (synthesis h).
unfold injective_left in |- *.
unfold enc_synthesis_left in |- *.
unfold op_synthesis_left in |- *.
unfold pair_free_left in |- *.
intro h.
intro.
intro.
intro.
intro.
intros M N H3.
induction H3 as [M N H3| M N K L H3_1 HrecH3_1 H3_0 HrecH3_0| M1 N1 M2 N2 H3_1 HrecH3_1 H3_0 HrecH3_0| o M N H3 HrecH3]; intros M' N' H4; [ induction H4 as [M0 N0 H4| M0 N0 K L H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o M0 N0 H4 HrecH4] | induction H4 as [M0 N0 H3| M0 N0 K0 L0 H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o M0 N0 H4 HrecH4] | induction H4 as [M N H3| M N K L H4_1 HrecH4_1 H4_0 HrecH4_0| M0 N0 M3 N3 H4_1 HrecH4_1 H4_0 HrecH4_0| o M N H4 HrecH4] | induction H4 as [M0 N0 H4| M0 N0 K L H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o0 M0 N0 H4 HrecH4] ].
intro.
exact (H M N H3 M0 N0 H4 H5).
intro.
cut (~ synthesis h M0 N0 \\/ ~ synthesis h K L).
intro.
case H5; intro H6; red in H6; tauto.
apply (H0 M N H3 M0 K H4).
intro.
rewrite H4 in H3.
cut False.
tauto.
apply (H2 M1 M2 N); trivial.
intro.
cut (~ synthesis h M0 N0).
intro.
tauto.
apply (H1 o M N H3 M0 H5); trivial.
intro.
cut (~ synthesis h M N \\/ ~ synthesis h K L).
intro.
case H5; intro H6; red in H6; tauto.
apply (H0 M0 N0 H3 M K); auto.
intro.
inversion H3.
rewrite (HrecH3_1 M0 N0 H4_1 H5).
rewrite (HrecH3_0 K0 L0 H4_0 H6).
trivial.
intro.
inversion H3.
intro.
inversion H3.
intro.
rewrite <- H4 in H3.
cut False.
tauto.
apply (H2 M1 M2 N H3).
intro.
inversion H3.
intro.
inversion H3.
rewrite (HrecH3_1 M0 N0 H4_1 H5).
rewrite (HrecH3_0 M3 N3 H4_0 H6); trivial.
intro.
inversion H3.
intro.
cut (~ synthesis h M N).
intro.
tauto.
apply (H1 o M0 N0 H4 M); auto.
intro.
inversion H4.
intro.
inversion H4.
case (op_eq_dec o o0).
intro.
rewrite <- e.
intro.
inversion H5.
rewrite (HrecH3 M0 N0 H4 H7).
trivial.

*****
HrecH4 : forall _ : eq (Mop o M) M0, eq (Mop o N) N0
H4 : synthesis h M0 N0
M0,N0 : Msg
o0 : op
HrecH3 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M M'), eq N N'
H3 : synthesis h M N
M,N : Msg
o : op
H2 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H1 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H0 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
forall (_ : not (eq o o0)) (_ : eq (Mop o M) (Mop o0 M0)), eq (Mop o N) (Mop o0 N0)
+++++
intros.
-----
Theorem inj_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_left (synthesis h).
unfold injective_left in |- *.
unfold enc_synthesis_left in |- *.
unfold op_synthesis_left in |- *.
unfold pair_free_left in |- *.
intro h.
intro.
intro.
intro.
intro.
intros M N H3.
induction H3 as [M N H3| M N K L H3_1 HrecH3_1 H3_0 HrecH3_0| M1 N1 M2 N2 H3_1 HrecH3_1 H3_0 HrecH3_0| o M N H3 HrecH3]; intros M' N' H4; [ induction H4 as [M0 N0 H4| M0 N0 K L H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o M0 N0 H4 HrecH4] | induction H4 as [M0 N0 H3| M0 N0 K0 L0 H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o M0 N0 H4 HrecH4] | induction H4 as [M N H3| M N K L H4_1 HrecH4_1 H4_0 HrecH4_0| M0 N0 M3 N3 H4_1 HrecH4_1 H4_0 HrecH4_0| o M N H4 HrecH4] | induction H4 as [M0 N0 H4| M0 N0 K L H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o0 M0 N0 H4 HrecH4] ].
intro.
exact (H M N H3 M0 N0 H4 H5).
intro.
cut (~ synthesis h M0 N0 \\/ ~ synthesis h K L).
intro.
case H5; intro H6; red in H6; tauto.
apply (H0 M N H3 M0 K H4).
intro.
rewrite H4 in H3.
cut False.
tauto.
apply (H2 M1 M2 N); trivial.
intro.
cut (~ synthesis h M0 N0).
intro.
tauto.
apply (H1 o M N H3 M0 H5); trivial.
intro.
cut (~ synthesis h M N \\/ ~ synthesis h K L).
intro.
case H5; intro H6; red in H6; tauto.
apply (H0 M0 N0 H3 M K); auto.
intro.
inversion H3.
rewrite (HrecH3_1 M0 N0 H4_1 H5).
rewrite (HrecH3_0 K0 L0 H4_0 H6).
trivial.
intro.
inversion H3.
intro.
inversion H3.
intro.
rewrite <- H4 in H3.
cut False.
tauto.
apply (H2 M1 M2 N H3).
intro.
inversion H3.
intro.
inversion H3.
rewrite (HrecH3_1 M0 N0 H4_1 H5).
rewrite (HrecH3_0 M3 N3 H4_0 H6); trivial.
intro.
inversion H3.
intro.
cut (~ synthesis h M N).
intro.
tauto.
apply (H1 o M0 N0 H4 M); auto.
intro.
inversion H4.
intro.
inversion H4.
case (op_eq_dec o o0).
intro.
rewrite <- e.
intro.
inversion H5.
rewrite (HrecH3 M0 N0 H4 H7).
trivial.
intros.

*****
H5 : eq (Mop o M) (Mop o0 M0)
n : not (eq o o0)
HrecH4 : forall _ : eq (Mop o M) M0, eq (Mop o N) N0
H4 : synthesis h M0 N0
M0,N0 : Msg
o0 : op
HrecH3 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M M'), eq N N'
H3 : synthesis h M N
M,N : Msg
o : op
H2 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H1 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H0 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
eq (Mop o N) (Mop o0 N0)
+++++
inversion H5.
-----
Theorem inj_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_left (synthesis h).
unfold injective_left in |- *.
unfold enc_synthesis_left in |- *.
unfold op_synthesis_left in |- *.
unfold pair_free_left in |- *.
intro h.
intro.
intro.
intro.
intro.
intros M N H3.
induction H3 as [M N H3| M N K L H3_1 HrecH3_1 H3_0 HrecH3_0| M1 N1 M2 N2 H3_1 HrecH3_1 H3_0 HrecH3_0| o M N H3 HrecH3]; intros M' N' H4; [ induction H4 as [M0 N0 H4| M0 N0 K L H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o M0 N0 H4 HrecH4] | induction H4 as [M0 N0 H3| M0 N0 K0 L0 H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o M0 N0 H4 HrecH4] | induction H4 as [M N H3| M N K L H4_1 HrecH4_1 H4_0 HrecH4_0| M0 N0 M3 N3 H4_1 HrecH4_1 H4_0 HrecH4_0| o M N H4 HrecH4] | induction H4 as [M0 N0 H4| M0 N0 K L H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o0 M0 N0 H4 HrecH4] ].
intro.
exact (H M N H3 M0 N0 H4 H5).
intro.
cut (~ synthesis h M0 N0 \\/ ~ synthesis h K L).
intro.
case H5; intro H6; red in H6; tauto.
apply (H0 M N H3 M0 K H4).
intro.
rewrite H4 in H3.
cut False.
tauto.
apply (H2 M1 M2 N); trivial.
intro.
cut (~ synthesis h M0 N0).
intro.
tauto.
apply (H1 o M N H3 M0 H5); trivial.
intro.
cut (~ synthesis h M N \\/ ~ synthesis h K L).
intro.
case H5; intro H6; red in H6; tauto.
apply (H0 M0 N0 H3 M K); auto.
intro.
inversion H3.
rewrite (HrecH3_1 M0 N0 H4_1 H5).
rewrite (HrecH3_0 K0 L0 H4_0 H6).
trivial.
intro.
inversion H3.
intro.
inversion H3.
intro.
rewrite <- H4 in H3.
cut False.
tauto.
apply (H2 M1 M2 N H3).
intro.
inversion H3.
intro.
inversion H3.
rewrite (HrecH3_1 M0 N0 H4_1 H5).
rewrite (HrecH3_0 M3 N3 H4_0 H6); trivial.
intro.
inversion H3.
intro.
cut (~ synthesis h M N).
intro.
tauto.
apply (H1 o M0 N0 H4 M); auto.
intro.
inversion H4.
intro.
inversion H4.
case (op_eq_dec o o0).
intro.
rewrite <- e.
intro.
inversion H5.
rewrite (HrecH3 M0 N0 H4 H7).
trivial.
intros.
inversion H5.

*****
H8 : eq M M0
H7 : eq o o0
H5 : eq (Mop o M) (Mop o0 M0)
n : not (eq o o0)
HrecH4 : forall _ : eq (Mop o M) M0, eq (Mop o N) N0
H4 : synthesis h M0 N0
M0,N0 : Msg
o0 : op
HrecH3 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M M'), eq N N'
H3 : synthesis h M N
M,N : Msg
o : op
H2 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H1 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H0 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
eq (Mop o0 N) (Mop o0 N0)
+++++
tauto.
-----
Theorem inj_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_left (synthesis h).
unfold injective_left in |- *.
unfold enc_synthesis_left in |- *.
unfold op_synthesis_left in |- *.
unfold pair_free_left in |- *.
intro h.
intro.
intro.
intro.
intro.
intros M N H3.
induction H3 as [M N H3| M N K L H3_1 HrecH3_1 H3_0 HrecH3_0| M1 N1 M2 N2 H3_1 HrecH3_1 H3_0 HrecH3_0| o M N H3 HrecH3]; intros M' N' H4; [ induction H4 as [M0 N0 H4| M0 N0 K L H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o M0 N0 H4 HrecH4] | induction H4 as [M0 N0 H3| M0 N0 K0 L0 H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o M0 N0 H4 HrecH4] | induction H4 as [M N H3| M N K L H4_1 HrecH4_1 H4_0 HrecH4_0| M0 N0 M3 N3 H4_1 HrecH4_1 H4_0 HrecH4_0| o M N H4 HrecH4] | induction H4 as [M0 N0 H4| M0 N0 K L H4_1 HrecH4_1 H4_0 HrecH4_0| M1 N1 M2 N2 H4_1 HrecH4_1 H4_0 HrecH4_0| o0 M0 N0 H4 HrecH4] ].
intro.
exact (H M N H3 M0 N0 H4 H5).
intro.
cut (~ synthesis h M0 N0 \\/ ~ synthesis h K L).
intro.
case H5; intro H6; red in H6; tauto.
apply (H0 M N H3 M0 K H4).
intro.
rewrite H4 in H3.
cut False.
tauto.
apply (H2 M1 M2 N); trivial.
intro.
cut (~ synthesis h M0 N0).
intro.
tauto.
apply (H1 o M N H3 M0 H5); trivial.
intro.
cut (~ synthesis h M N \\/ ~ synthesis h K L).
intro.
case H5; intro H6; red in H6; tauto.
apply (H0 M0 N0 H3 M K); auto.
intro.
inversion H3.
rewrite (HrecH3_1 M0 N0 H4_1 H5).
rewrite (HrecH3_0 K0 L0 H4_0 H6).
trivial.
intro.
inversion H3.
intro.
inversion H3.
intro.
rewrite <- H4 in H3.
cut False.
tauto.
apply (H2 M1 M2 N H3).
intro.
inversion H3.
intro.
inversion H3.
rewrite (HrecH3_1 M0 N0 H4_1 H5).
rewrite (HrecH3_0 M3 N3 H4_0 H6); trivial.
intro.
inversion H3.
intro.
cut (~ synthesis h M N).
intro.
tauto.
apply (H1 o M0 N0 H4 M); auto.
intro.
inversion H4.
intro.
inversion H4.
case (op_eq_dec o o0).
intro.
rewrite <- e.
intro.
inversion H5.
rewrite (HrecH3 M0 N0 H4 H7).
trivial.
intros.
inversion H5.
tauto.

*****

*****

+++++
Qed.
-----
Theorem inj_inv_left_syn :\n forall h : hedge,\n injective_left h ->\n enc_synthesis_left h ->\n op_synthesis_left h ->\n pair_free_left h -> injective_inv_left h -> injective_inv_left (synthesis h).
-----
Theorem inj_inv_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_inv_left h -> injective_inv_left (synthesis h).

*****

*****
forall (h : hedge) (_ : injective_left h) (_ : enc_synthesis_left h) (_ : op_synthesis_left h) (_ : pair_free_left h) (_ : injective_inv_left h), injective_inv_left (synthesis h)
+++++
intro h.
-----
Theorem inj_inv_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_inv_left h -> injective_inv_left (synthesis h).
intro h.

*****
h : hedge
*****
forall (_ : injective_left h) (_ : enc_synthesis_left h) (_ : op_synthesis_left h) (_ : pair_free_left h) (_ : injective_inv_left h), injective_inv_left (synthesis h)
+++++
intros H0 H1 H2 H3 H4.
-----
Theorem inj_inv_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_inv_left h -> injective_inv_left (synthesis h).
intro h.
intros H0 H1 H2 H3 H4.

*****
H4 : injective_inv_left h
H3 : pair_free_left h
H2 : op_synthesis_left h
H1 : enc_synthesis_left h
H0 : injective_left h
h : hedge
*****
injective_inv_left (synthesis h)
+++++
generalize (inj_left_syn h H0 H1 H2 H3).
-----
Theorem inj_inv_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_inv_left h -> injective_inv_left (synthesis h).
intro h.
intros H0 H1 H2 H3 H4.
generalize (inj_left_syn h H0 H1 H2 H3).

*****
H4 : injective_inv_left h
H3 : pair_free_left h
H2 : op_synthesis_left h
H1 : enc_synthesis_left h
H0 : injective_left h
h : hedge
*****
forall _ : injective_left (synthesis h), injective_inv_left (synthesis h)
+++++
intro H4bis.
-----
Theorem inj_inv_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_inv_left h -> injective_inv_left (synthesis h).
intro h.
intros H0 H1 H2 H3 H4.
generalize (inj_left_syn h H0 H1 H2 H3).
intro H4bis.

*****
H4bis : injective_left (synthesis h)
H4 : injective_inv_left h
H3 : pair_free_left h
H2 : op_synthesis_left h
H1 : enc_synthesis_left h
H0 : injective_left h
h : hedge
*****
injective_inv_left (synthesis h)
+++++
unfold injective_left in H0.
-----
Theorem inj_inv_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_inv_left h -> injective_inv_left (synthesis h).
intro h.
intros H0 H1 H2 H3 H4.
generalize (inj_left_syn h H0 H1 H2 H3).
intro H4bis.
unfold injective_left in H0.

*****
H4bis : injective_left (synthesis h)
H4 : injective_inv_left h
H3 : pair_free_left h
H2 : op_synthesis_left h
H1 : enc_synthesis_left h
H0 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
injective_inv_left (synthesis h)
+++++
unfold enc_synthesis_left in H1.
-----
Theorem inj_inv_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_inv_left h -> injective_inv_left (synthesis h).
intro h.
intros H0 H1 H2 H3 H4.
generalize (inj_left_syn h H0 H1 H2 H3).
intro H4bis.
unfold injective_left in H0.
unfold enc_synthesis_left in H1.

*****
H4bis : injective_left (synthesis h)
H4 : injective_inv_left h
H3 : pair_free_left h
H2 : op_synthesis_left h
H1 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H0 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
injective_inv_left (synthesis h)
+++++
unfold op_synthesis_left in H2.
-----
Theorem inj_inv_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_inv_left h -> injective_inv_left (synthesis h).
intro h.
intros H0 H1 H2 H3 H4.
generalize (inj_left_syn h H0 H1 H2 H3).
intro H4bis.
unfold injective_left in H0.
unfold enc_synthesis_left in H1.
unfold op_synthesis_left in H2.

*****
H4bis : injective_left (synthesis h)
H4 : injective_inv_left h
H3 : pair_free_left h
H2 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H1 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H0 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
injective_inv_left (synthesis h)
+++++
unfold pair_free_left in H3.
-----
Theorem inj_inv_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_inv_left h -> injective_inv_left (synthesis h).
intro h.
intros H0 H1 H2 H3 H4.
generalize (inj_left_syn h H0 H1 H2 H3).
intro H4bis.
unfold injective_left in H0.
unfold enc_synthesis_left in H1.
unfold op_synthesis_left in H2.
unfold pair_free_left in H3.

*****
H4bis : injective_left (synthesis h)
H4 : injective_inv_left h
H3 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H2 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H1 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H0 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
injective_inv_left (synthesis h)
+++++
unfold injective_inv_left in H4.
-----
Theorem inj_inv_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_inv_left h -> injective_inv_left (synthesis h).
intro h.
intros H0 H1 H2 H3 H4.
generalize (inj_left_syn h H0 H1 H2 H3).
intro H4bis.
unfold injective_left in H0.
unfold enc_synthesis_left in H1.
unfold op_synthesis_left in H2.
unfold pair_free_left in H3.
unfold injective_inv_left in H4.

*****
H4bis : injective_left (synthesis h)
H4 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M' (inv M)), eq N' (inv N)
H3 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H2 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H1 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H0 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
injective_inv_left (synthesis h)
+++++
unfold injective_left in H4bis.
-----
Theorem inj_inv_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_inv_left h -> injective_inv_left (synthesis h).
intro h.
intros H0 H1 H2 H3 H4.
generalize (inj_left_syn h H0 H1 H2 H3).
intro H4bis.
unfold injective_left in H0.
unfold enc_synthesis_left in H1.
unfold op_synthesis_left in H2.
unfold pair_free_left in H3.
unfold injective_inv_left in H4.
unfold injective_left in H4bis.

*****
H4bis : forall (M N : Msg) (_ : synthesis h M N) (M' N' : Msg)\n (_ : synthesis h M' N') (_ : eq M M'), eq N N'
H4 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M' (inv M)), eq N' (inv N)
H3 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H2 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H1 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H0 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
injective_inv_left (synthesis h)
+++++
unfold injective_inv_left in |- *.
-----
Theorem inj_inv_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_inv_left h -> injective_inv_left (synthesis h).
intro h.
intros H0 H1 H2 H3 H4.
generalize (inj_left_syn h H0 H1 H2 H3).
intro H4bis.
unfold injective_left in H0.
unfold enc_synthesis_left in H1.
unfold op_synthesis_left in H2.
unfold pair_free_left in H3.
unfold injective_inv_left in H4.
unfold injective_left in H4bis.
unfold injective_inv_left in |- *.

*****
H4bis : forall (M N : Msg) (_ : synthesis h M N) (M' N' : Msg)\n (_ : synthesis h M' N') (_ : eq M M'), eq N N'
H4 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M' (inv M)), eq N' (inv N)
H3 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H2 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H1 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H0 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
forall (M N : Msg) (_ : synthesis h M N) (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M' (inv M)), eq N' (inv N)
+++++
intros M N H5.
-----
Theorem inj_inv_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_inv_left h -> injective_inv_left (synthesis h).
intro h.
intros H0 H1 H2 H3 H4.
generalize (inj_left_syn h H0 H1 H2 H3).
intro H4bis.
unfold injective_left in H0.
unfold enc_synthesis_left in H1.
unfold op_synthesis_left in H2.
unfold pair_free_left in H3.
unfold injective_inv_left in H4.
unfold injective_left in H4bis.
unfold injective_inv_left in |- *.
intros M N H5.

*****
H5 : synthesis h M N
M,N : Msg
H4bis : forall (M N : Msg) (_ : synthesis h M N) (M' N' : Msg)\n (_ : synthesis h M' N') (_ : eq M M'), eq N N'
H4 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M' (inv M)), eq N' (inv N)
H3 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H2 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H1 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H0 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M' (inv M)), eq N' (inv N)
+++++
induction H5 as [M N H| M N K L H5_1 HrecH5_1 H5_0 HrecH5_0| M1 N1 M2 N2 H5_1 HrecH5_1 H5_0 HrecH5_0| o M N H5 HrecH5]; intros M' N' H6; [ induction H6 as [M0 N0 H5| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K0 L0 H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M N H| M N K L H6_1 HrecH6_1 H6_0 HrecH6_0| M0 N0 M3 N3 H6_1 HrecH6_1 H6_0 HrecH6_0| o M N H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o0 M0 N0 H6 HrecH6] ].
-----
Theorem inj_inv_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_inv_left h -> injective_inv_left (synthesis h).
intro h.
intros H0 H1 H2 H3 H4.
generalize (inj_left_syn h H0 H1 H2 H3).
intro H4bis.
unfold injective_left in H0.
unfold enc_synthesis_left in H1.
unfold op_synthesis_left in H2.
unfold pair_free_left in H3.
unfold injective_inv_left in H4.
unfold injective_left in H4bis.
unfold injective_inv_left in |- *.
intros M N H5.
induction H5 as [M N H| M N K L H5_1 HrecH5_1 H5_0 HrecH5_0| M1 N1 M2 N2 H5_1 HrecH5_1 H5_0 HrecH5_0| o M N H5 HrecH5]; intros M' N' H6; [ induction H6 as [M0 N0 H5| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K0 L0 H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M N H| M N K L H6_1 HrecH6_1 H6_0 HrecH6_0| M0 N0 M3 N3 H6_1 HrecH6_1 H6_0 HrecH6_0| o M N H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o0 M0 N0 H6 HrecH6] ].

*****
H5 : h M0 N0
M0,N0 : Msg
H : h M N
M,N : Msg
H4bis : forall (M N : Msg) (_ : synthesis h M N) (M' N' : Msg)\n (_ : synthesis h M' N') (_ : eq M M'), eq N N'
H4 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M' (inv M)), eq N' (inv N)
H3 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H2 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H1 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H0 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
forall _ : eq M0 (inv M), eq N0 (inv N)
+++++
intro.
-----
Theorem inj_inv_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_inv_left h -> injective_inv_left (synthesis h).
intro h.
intros H0 H1 H2 H3 H4.
generalize (inj_left_syn h H0 H1 H2 H3).
intro H4bis.
unfold injective_left in H0.
unfold enc_synthesis_left in H1.
unfold op_synthesis_left in H2.
unfold pair_free_left in H3.
unfold injective_inv_left in H4.
unfold injective_left in H4bis.
unfold injective_inv_left in |- *.
intros M N H5.
induction H5 as [M N H| M N K L H5_1 HrecH5_1 H5_0 HrecH5_0| M1 N1 M2 N2 H5_1 HrecH5_1 H5_0 HrecH5_0| o M N H5 HrecH5]; intros M' N' H6; [ induction H6 as [M0 N0 H5| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K0 L0 H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M N H| M N K L H6_1 HrecH6_1 H6_0 HrecH6_0| M0 N0 M3 N3 H6_1 HrecH6_1 H6_0 HrecH6_0| o M N H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o0 M0 N0 H6 HrecH6] ].
intro.

*****
H6 : eq M0 (inv M)
H5 : h M0 N0
M0,N0 : Msg
H : h M N
M,N : Msg
H4bis : forall (M N : Msg) (_ : synthesis h M N) (M' N' : Msg)\n (_ : synthesis h M' N') (_ : eq M M'), eq N N'
H4 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M' (inv M)), eq N' (inv N)
H3 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H2 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H1 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H0 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
eq N0 (inv N)
+++++
apply (H4 M N H M0 N0 H5 H6).
-----
Theorem inj_inv_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_inv_left h -> injective_inv_left (synthesis h).
intro h.
intros H0 H1 H2 H3 H4.
generalize (inj_left_syn h H0 H1 H2 H3).
intro H4bis.
unfold injective_left in H0.
unfold enc_synthesis_left in H1.
unfold op_synthesis_left in H2.
unfold pair_free_left in H3.
unfold injective_inv_left in H4.
unfold injective_left in H4bis.
unfold injective_inv_left in |- *.
intros M N H5.
induction H5 as [M N H| M N K L H5_1 HrecH5_1 H5_0 HrecH5_0| M1 N1 M2 N2 H5_1 HrecH5_1 H5_0 HrecH5_0| o M N H5 HrecH5]; intros M' N' H6; [ induction H6 as [M0 N0 H5| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K0 L0 H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M N H| M N K L H6_1 HrecH6_1 H6_0 HrecH6_0| M0 N0 M3 N3 H6_1 HrecH6_1 H6_0 HrecH6_0| o M N H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o0 M0 N0 H6 HrecH6] ].
intro.
apply (H4 M N H M0 N0 H5 H6).

*****
HrecH6_0 : forall _ : eq K (inv M), eq L (inv N)
HrecH6_1 : forall _ : eq M0 (inv M), eq N0 (inv N)
H6_0 : synthesis h K L
H6_1 : synthesis h M0 N0
M0,N0,K,L : Msg
H : h M N
M,N : Msg
H4bis : forall (M N : Msg) (_ : synthesis h M N) (M' N' : Msg)\n (_ : synthesis h M' N') (_ : eq M M'), eq N N'
H4 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M' (inv M)), eq N' (inv N)
H3 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H2 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H1 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H0 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
forall _ : eq (MEnc M0 K) (inv M), eq (MEnc N0 L) (inv N)
+++++
intro.
-----
Theorem inj_inv_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_inv_left h -> injective_inv_left (synthesis h).
intro h.
intros H0 H1 H2 H3 H4.
generalize (inj_left_syn h H0 H1 H2 H3).
intro H4bis.
unfold injective_left in H0.
unfold enc_synthesis_left in H1.
unfold op_synthesis_left in H2.
unfold pair_free_left in H3.
unfold injective_inv_left in H4.
unfold injective_left in H4bis.
unfold injective_inv_left in |- *.
intros M N H5.
induction H5 as [M N H| M N K L H5_1 HrecH5_1 H5_0 HrecH5_0| M1 N1 M2 N2 H5_1 HrecH5_1 H5_0 HrecH5_0| o M N H5 HrecH5]; intros M' N' H6; [ induction H6 as [M0 N0 H5| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K0 L0 H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M N H| M N K L H6_1 HrecH6_1 H6_0 HrecH6_0| M0 N0 M3 N3 H6_1 HrecH6_1 H6_0 HrecH6_0| o M N H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o0 M0 N0 H6 HrecH6] ].
intro.
apply (H4 M N H M0 N0 H5 H6).
intro.

*****
H5 : eq (MEnc M0 K) (inv M)
HrecH6_0 : forall _ : eq K (inv M), eq L (inv N)
HrecH6_1 : forall _ : eq M0 (inv M), eq N0 (inv N)
H6_0 : synthesis h K L
H6_1 : synthesis h M0 N0
M0,N0,K,L : Msg
H : h M N
M,N : Msg
H4bis : forall (M N : Msg) (_ : synthesis h M N) (M' N' : Msg)\n (_ : synthesis h M' N') (_ : eq M M'), eq N N'
H4 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M' (inv M)), eq N' (inv N)
H3 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H2 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H1 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H0 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
eq (MEnc N0 L) (inv N)
+++++
cut (M = inv (MEnc M0 K)).
-----
Theorem inj_inv_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_inv_left h -> injective_inv_left (synthesis h).
intro h.
intros H0 H1 H2 H3 H4.
generalize (inj_left_syn h H0 H1 H2 H3).
intro H4bis.
unfold injective_left in H0.
unfold enc_synthesis_left in H1.
unfold op_synthesis_left in H2.
unfold pair_free_left in H3.
unfold injective_inv_left in H4.
unfold injective_left in H4bis.
unfold injective_inv_left in |- *.
intros M N H5.
induction H5 as [M N H| M N K L H5_1 HrecH5_1 H5_0 HrecH5_0| M1 N1 M2 N2 H5_1 HrecH5_1 H5_0 HrecH5_0| o M N H5 HrecH5]; intros M' N' H6; [ induction H6 as [M0 N0 H5| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K0 L0 H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M N H| M N K L H6_1 HrecH6_1 H6_0 HrecH6_0| M0 N0 M3 N3 H6_1 HrecH6_1 H6_0 HrecH6_0| o M N H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o0 M0 N0 H6 HrecH6] ].
intro.
apply (H4 M N H M0 N0 H5 H6).
intro.
cut (M = inv (MEnc M0 K)).

*****
H5 : eq (MEnc M0 K) (inv M)
HrecH6_0 : forall _ : eq K (inv M), eq L (inv N)
HrecH6_1 : forall _ : eq M0 (inv M), eq N0 (inv N)
H6_0 : synthesis h K L
H6_1 : synthesis h M0 N0
M0,N0,K,L : Msg
H : h M N
M,N : Msg
H4bis : forall (M N : Msg) (_ : synthesis h M N) (M' N' : Msg)\n (_ : synthesis h M' N') (_ : eq M M'), eq N N'
H4 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M' (inv M)), eq N' (inv N)
H3 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H2 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H1 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H0 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
forall _ : eq M (inv (MEnc M0 K)), eq (MEnc N0 L) (inv N)
+++++
simpl in |- *.
-----
Theorem inj_inv_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_inv_left h -> injective_inv_left (synthesis h).
intro h.
intros H0 H1 H2 H3 H4.
generalize (inj_left_syn h H0 H1 H2 H3).
intro H4bis.
unfold injective_left in H0.
unfold enc_synthesis_left in H1.
unfold op_synthesis_left in H2.
unfold pair_free_left in H3.
unfold injective_inv_left in H4.
unfold injective_left in H4bis.
unfold injective_inv_left in |- *.
intros M N H5.
induction H5 as [M N H| M N K L H5_1 HrecH5_1 H5_0 HrecH5_0| M1 N1 M2 N2 H5_1 HrecH5_1 H5_0 HrecH5_0| o M N H5 HrecH5]; intros M' N' H6; [ induction H6 as [M0 N0 H5| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K0 L0 H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M N H| M N K L H6_1 HrecH6_1 H6_0 HrecH6_0| M0 N0 M3 N3 H6_1 HrecH6_1 H6_0 HrecH6_0| o M N H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o0 M0 N0 H6 HrecH6] ].
intro.
apply (H4 M N H M0 N0 H5 H6).
intro.
cut (M = inv (MEnc M0 K)).
simpl in |- *.

*****
H5 : eq (MEnc M0 K) (inv M)
HrecH6_0 : forall _ : eq K (inv M), eq L (inv N)
HrecH6_1 : forall _ : eq M0 (inv M), eq N0 (inv N)
H6_0 : synthesis h K L
H6_1 : synthesis h M0 N0
M0,N0,K,L : Msg
H : h M N
M,N : Msg
H4bis : forall (M N : Msg) (_ : synthesis h M N) (M' N' : Msg)\n (_ : synthesis h M' N') (_ : eq M M'), eq N N'
H4 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M' (inv M)), eq N' (inv N)
H3 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H2 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H1 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H0 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
forall _ : eq M (MEnc M0 K), eq (MEnc N0 L) (inv N)
+++++
intro.
-----
Theorem inj_inv_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_inv_left h -> injective_inv_left (synthesis h).
intro h.
intros H0 H1 H2 H3 H4.
generalize (inj_left_syn h H0 H1 H2 H3).
intro H4bis.
unfold injective_left in H0.
unfold enc_synthesis_left in H1.
unfold op_synthesis_left in H2.
unfold pair_free_left in H3.
unfold injective_inv_left in H4.
unfold injective_left in H4bis.
unfold injective_inv_left in |- *.
intros M N H5.
induction H5 as [M N H| M N K L H5_1 HrecH5_1 H5_0 HrecH5_0| M1 N1 M2 N2 H5_1 HrecH5_1 H5_0 HrecH5_0| o M N H5 HrecH5]; intros M' N' H6; [ induction H6 as [M0 N0 H5| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K0 L0 H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M N H| M N K L H6_1 HrecH6_1 H6_0 HrecH6_0| M0 N0 M3 N3 H6_1 HrecH6_1 H6_0 HrecH6_0| o M N H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o0 M0 N0 H6 HrecH6] ].
intro.
apply (H4 M N H M0 N0 H5 H6).
intro.
cut (M = inv (MEnc M0 K)).
simpl in |- *.
intro.

*****
H6 : eq M (MEnc M0 K)
H5 : eq (MEnc M0 K) (inv M)
HrecH6_0 : forall _ : eq K (inv M), eq L (inv N)
HrecH6_1 : forall _ : eq M0 (inv M), eq N0 (inv N)
H6_0 : synthesis h K L
H6_1 : synthesis h M0 N0
M0,N0,K,L : Msg
H : h M N
M,N : Msg
H4bis : forall (M N : Msg) (_ : synthesis h M N) (M' N' : Msg)\n (_ : synthesis h M' N') (_ : eq M M'), eq N N'
H4 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M' (inv M)), eq N' (inv N)
H3 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H2 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H1 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H0 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
eq (MEnc N0 L) (inv N)
+++++
case (H1 M N H M0 K H6 N0 L); intro; tauto.
-----
Theorem inj_inv_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_inv_left h -> injective_inv_left (synthesis h).
intro h.
intros H0 H1 H2 H3 H4.
generalize (inj_left_syn h H0 H1 H2 H3).
intro H4bis.
unfold injective_left in H0.
unfold enc_synthesis_left in H1.
unfold op_synthesis_left in H2.
unfold pair_free_left in H3.
unfold injective_inv_left in H4.
unfold injective_left in H4bis.
unfold injective_inv_left in |- *.
intros M N H5.
induction H5 as [M N H| M N K L H5_1 HrecH5_1 H5_0 HrecH5_0| M1 N1 M2 N2 H5_1 HrecH5_1 H5_0 HrecH5_0| o M N H5 HrecH5]; intros M' N' H6; [ induction H6 as [M0 N0 H5| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K0 L0 H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M N H| M N K L H6_1 HrecH6_1 H6_0 HrecH6_0| M0 N0 M3 N3 H6_1 HrecH6_1 H6_0 HrecH6_0| o M N H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o0 M0 N0 H6 HrecH6] ].
intro.
apply (H4 M N H M0 N0 H5 H6).
intro.
cut (M = inv (MEnc M0 K)).
simpl in |- *.
intro.
case (H1 M N H M0 K H6 N0 L); intro; tauto.

*****
H5 : eq (MEnc M0 K) (inv M)
HrecH6_0 : forall _ : eq K (inv M), eq L (inv N)
HrecH6_1 : forall _ : eq M0 (inv M), eq N0 (inv N)
H6_0 : synthesis h K L
H6_1 : synthesis h M0 N0
M0,N0,K,L : Msg
H : h M N
M,N : Msg
H4bis : forall (M N : Msg) (_ : synthesis h M N) (M' N' : Msg)\n (_ : synthesis h M' N') (_ : eq M M'), eq N N'
H4 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M' (inv M)), eq N' (inv N)
H3 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H2 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H1 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H0 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
eq M (inv (MEnc M0 K))
+++++
rewrite H5.
-----
Theorem inj_inv_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_inv_left h -> injective_inv_left (synthesis h).
intro h.
intros H0 H1 H2 H3 H4.
generalize (inj_left_syn h H0 H1 H2 H3).
intro H4bis.
unfold injective_left in H0.
unfold enc_synthesis_left in H1.
unfold op_synthesis_left in H2.
unfold pair_free_left in H3.
unfold injective_inv_left in H4.
unfold injective_left in H4bis.
unfold injective_inv_left in |- *.
intros M N H5.
induction H5 as [M N H| M N K L H5_1 HrecH5_1 H5_0 HrecH5_0| M1 N1 M2 N2 H5_1 HrecH5_1 H5_0 HrecH5_0| o M N H5 HrecH5]; intros M' N' H6; [ induction H6 as [M0 N0 H5| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K0 L0 H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M N H| M N K L H6_1 HrecH6_1 H6_0 HrecH6_0| M0 N0 M3 N3 H6_1 HrecH6_1 H6_0 HrecH6_0| o M N H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o0 M0 N0 H6 HrecH6] ].
intro.
apply (H4 M N H M0 N0 H5 H6).
intro.
cut (M = inv (MEnc M0 K)).
simpl in |- *.
intro.
case (H1 M N H M0 K H6 N0 L); intro; tauto.
rewrite H5.

*****
H5 : eq (MEnc M0 K) (inv M)
HrecH6_0 : forall _ : eq K (inv M), eq L (inv N)
HrecH6_1 : forall _ : eq M0 (inv M), eq N0 (inv N)
H6_0 : synthesis h K L
H6_1 : synthesis h M0 N0
M0,N0,K,L : Msg
H : h M N
M,N : Msg
H4bis : forall (M N : Msg) (_ : synthesis h M N) (M' N' : Msg)\n (_ : synthesis h M' N') (_ : eq M M'), eq N N'
H4 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M' (inv M)), eq N' (inv N)
H3 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H2 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H1 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H0 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
eq M (inv (inv M))
+++++
symmetry in |- *.
-----
Theorem inj_inv_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_inv_left h -> injective_inv_left (synthesis h).
intro h.
intros H0 H1 H2 H3 H4.
generalize (inj_left_syn h H0 H1 H2 H3).
intro H4bis.
unfold injective_left in H0.
unfold enc_synthesis_left in H1.
unfold op_synthesis_left in H2.
unfold pair_free_left in H3.
unfold injective_inv_left in H4.
unfold injective_left in H4bis.
unfold injective_inv_left in |- *.
intros M N H5.
induction H5 as [M N H| M N K L H5_1 HrecH5_1 H5_0 HrecH5_0| M1 N1 M2 N2 H5_1 HrecH5_1 H5_0 HrecH5_0| o M N H5 HrecH5]; intros M' N' H6; [ induction H6 as [M0 N0 H5| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K0 L0 H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M N H| M N K L H6_1 HrecH6_1 H6_0 HrecH6_0| M0 N0 M3 N3 H6_1 HrecH6_1 H6_0 HrecH6_0| o M N H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o0 M0 N0 H6 HrecH6] ].
intro.
apply (H4 M N H M0 N0 H5 H6).
intro.
cut (M = inv (MEnc M0 K)).
simpl in |- *.
intro.
case (H1 M N H M0 K H6 N0 L); intro; tauto.
rewrite H5.
symmetry in |- *.

*****
H5 : eq (MEnc M0 K) (inv M)
HrecH6_0 : forall _ : eq K (inv M), eq L (inv N)
HrecH6_1 : forall _ : eq M0 (inv M), eq N0 (inv N)
H6_0 : synthesis h K L
H6_1 : synthesis h M0 N0
M0,N0,K,L : Msg
H : h M N
M,N : Msg
H4bis : forall (M N : Msg) (_ : synthesis h M N) (M' N' : Msg)\n (_ : synthesis h M' N') (_ : eq M M'), eq N N'
H4 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M' (inv M)), eq N' (inv N)
H3 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H2 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H1 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H0 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
eq (inv (inv M)) M
+++++
apply inv_invol.
-----
Theorem inj_inv_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_inv_left h -> injective_inv_left (synthesis h).
intro h.
intros H0 H1 H2 H3 H4.
generalize (inj_left_syn h H0 H1 H2 H3).
intro H4bis.
unfold injective_left in H0.
unfold enc_synthesis_left in H1.
unfold op_synthesis_left in H2.
unfold pair_free_left in H3.
unfold injective_inv_left in H4.
unfold injective_left in H4bis.
unfold injective_inv_left in |- *.
intros M N H5.
induction H5 as [M N H| M N K L H5_1 HrecH5_1 H5_0 HrecH5_0| M1 N1 M2 N2 H5_1 HrecH5_1 H5_0 HrecH5_0| o M N H5 HrecH5]; intros M' N' H6; [ induction H6 as [M0 N0 H5| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K0 L0 H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M N H| M N K L H6_1 HrecH6_1 H6_0 HrecH6_0| M0 N0 M3 N3 H6_1 HrecH6_1 H6_0 HrecH6_0| o M N H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o0 M0 N0 H6 HrecH6] ].
intro.
apply (H4 M N H M0 N0 H5 H6).
intro.
cut (M = inv (MEnc M0 K)).
simpl in |- *.
intro.
case (H1 M N H M0 K H6 N0 L); intro; tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.

*****
HrecH6_0 : forall _ : eq M2 (inv M), eq N2 (inv N)
HrecH6_1 : forall _ : eq M1 (inv M), eq N1 (inv N)
H6_0 : synthesis h M2 N2
H6_1 : synthesis h M1 N1
M1,N1,M2,N2 : Msg
H : h M N
M,N : Msg
H4bis : forall (M N : Msg) (_ : synthesis h M N) (M' N' : Msg)\n (_ : synthesis h M' N') (_ : eq M M'), eq N N'
H4 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M' (inv M)), eq N' (inv N)
H3 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H2 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H1 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H0 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
forall _ : eq (MPair M1 M2) (inv M), eq (MPair N1 N2) (inv N)
+++++
intro.
-----
Theorem inj_inv_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_inv_left h -> injective_inv_left (synthesis h).
intro h.
intros H0 H1 H2 H3 H4.
generalize (inj_left_syn h H0 H1 H2 H3).
intro H4bis.
unfold injective_left in H0.
unfold enc_synthesis_left in H1.
unfold op_synthesis_left in H2.
unfold pair_free_left in H3.
unfold injective_inv_left in H4.
unfold injective_left in H4bis.
unfold injective_inv_left in |- *.
intros M N H5.
induction H5 as [M N H| M N K L H5_1 HrecH5_1 H5_0 HrecH5_0| M1 N1 M2 N2 H5_1 HrecH5_1 H5_0 HrecH5_0| o M N H5 HrecH5]; intros M' N' H6; [ induction H6 as [M0 N0 H5| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K0 L0 H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M N H| M N K L H6_1 HrecH6_1 H6_0 HrecH6_0| M0 N0 M3 N3 H6_1 HrecH6_1 H6_0 HrecH6_0| o M N H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o0 M0 N0 H6 HrecH6] ].
intro.
apply (H4 M N H M0 N0 H5 H6).
intro.
cut (M = inv (MEnc M0 K)).
simpl in |- *.
intro.
case (H1 M N H M0 K H6 N0 L); intro; tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.

*****
H5 : eq (MPair M1 M2) (inv M)
HrecH6_0 : forall _ : eq M2 (inv M), eq N2 (inv N)
HrecH6_1 : forall _ : eq M1 (inv M), eq N1 (inv N)
H6_0 : synthesis h M2 N2
H6_1 : synthesis h M1 N1
M1,N1,M2,N2 : Msg
H : h M N
M,N : Msg
H4bis : forall (M N : Msg) (_ : synthesis h M N) (M' N' : Msg)\n (_ : synthesis h M' N') (_ : eq M M'), eq N N'
H4 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M' (inv M)), eq N' (inv N)
H3 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H2 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H1 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H0 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
eq (MPair N1 N2) (inv N)
+++++
cut (M = inv (MPair M1 M2)).
-----
Theorem inj_inv_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_inv_left h -> injective_inv_left (synthesis h).
intro h.
intros H0 H1 H2 H3 H4.
generalize (inj_left_syn h H0 H1 H2 H3).
intro H4bis.
unfold injective_left in H0.
unfold enc_synthesis_left in H1.
unfold op_synthesis_left in H2.
unfold pair_free_left in H3.
unfold injective_inv_left in H4.
unfold injective_left in H4bis.
unfold injective_inv_left in |- *.
intros M N H5.
induction H5 as [M N H| M N K L H5_1 HrecH5_1 H5_0 HrecH5_0| M1 N1 M2 N2 H5_1 HrecH5_1 H5_0 HrecH5_0| o M N H5 HrecH5]; intros M' N' H6; [ induction H6 as [M0 N0 H5| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K0 L0 H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M N H| M N K L H6_1 HrecH6_1 H6_0 HrecH6_0| M0 N0 M3 N3 H6_1 HrecH6_1 H6_0 HrecH6_0| o M N H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o0 M0 N0 H6 HrecH6] ].
intro.
apply (H4 M N H M0 N0 H5 H6).
intro.
cut (M = inv (MEnc M0 K)).
simpl in |- *.
intro.
case (H1 M N H M0 K H6 N0 L); intro; tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (MPair M1 M2)).

*****
H5 : eq (MPair M1 M2) (inv M)
HrecH6_0 : forall _ : eq M2 (inv M), eq N2 (inv N)
HrecH6_1 : forall _ : eq M1 (inv M), eq N1 (inv N)
H6_0 : synthesis h M2 N2
H6_1 : synthesis h M1 N1
M1,N1,M2,N2 : Msg
H : h M N
M,N : Msg
H4bis : forall (M N : Msg) (_ : synthesis h M N) (M' N' : Msg)\n (_ : synthesis h M' N') (_ : eq M M'), eq N N'
H4 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M' (inv M)), eq N' (inv N)
H3 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H2 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H1 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H0 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
forall _ : eq M (inv (MPair M1 M2)), eq (MPair N1 N2) (inv N)
+++++
simpl in |- *.
-----
Theorem inj_inv_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_inv_left h -> injective_inv_left (synthesis h).
intro h.
intros H0 H1 H2 H3 H4.
generalize (inj_left_syn h H0 H1 H2 H3).
intro H4bis.
unfold injective_left in H0.
unfold enc_synthesis_left in H1.
unfold op_synthesis_left in H2.
unfold pair_free_left in H3.
unfold injective_inv_left in H4.
unfold injective_left in H4bis.
unfold injective_inv_left in |- *.
intros M N H5.
induction H5 as [M N H| M N K L H5_1 HrecH5_1 H5_0 HrecH5_0| M1 N1 M2 N2 H5_1 HrecH5_1 H5_0 HrecH5_0| o M N H5 HrecH5]; intros M' N' H6; [ induction H6 as [M0 N0 H5| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K0 L0 H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M N H| M N K L H6_1 HrecH6_1 H6_0 HrecH6_0| M0 N0 M3 N3 H6_1 HrecH6_1 H6_0 HrecH6_0| o M N H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o0 M0 N0 H6 HrecH6] ].
intro.
apply (H4 M N H M0 N0 H5 H6).
intro.
cut (M = inv (MEnc M0 K)).
simpl in |- *.
intro.
case (H1 M N H M0 K H6 N0 L); intro; tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (MPair M1 M2)).
simpl in |- *.

*****
H5 : eq (MPair M1 M2) (inv M)
HrecH6_0 : forall _ : eq M2 (inv M), eq N2 (inv N)
HrecH6_1 : forall _ : eq M1 (inv M), eq N1 (inv N)
H6_0 : synthesis h M2 N2
H6_1 : synthesis h M1 N1
M1,N1,M2,N2 : Msg
H : h M N
M,N : Msg
H4bis : forall (M N : Msg) (_ : synthesis h M N) (M' N' : Msg)\n (_ : synthesis h M' N') (_ : eq M M'), eq N N'
H4 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M' (inv M)), eq N' (inv N)
H3 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H2 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H1 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H0 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
forall _ : eq M (MPair M1 M2), eq (MPair N1 N2) (inv N)
+++++
intro.
-----
Theorem inj_inv_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_inv_left h -> injective_inv_left (synthesis h).
intro h.
intros H0 H1 H2 H3 H4.
generalize (inj_left_syn h H0 H1 H2 H3).
intro H4bis.
unfold injective_left in H0.
unfold enc_synthesis_left in H1.
unfold op_synthesis_left in H2.
unfold pair_free_left in H3.
unfold injective_inv_left in H4.
unfold injective_left in H4bis.
unfold injective_inv_left in |- *.
intros M N H5.
induction H5 as [M N H| M N K L H5_1 HrecH5_1 H5_0 HrecH5_0| M1 N1 M2 N2 H5_1 HrecH5_1 H5_0 HrecH5_0| o M N H5 HrecH5]; intros M' N' H6; [ induction H6 as [M0 N0 H5| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K0 L0 H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M N H| M N K L H6_1 HrecH6_1 H6_0 HrecH6_0| M0 N0 M3 N3 H6_1 HrecH6_1 H6_0 HrecH6_0| o M N H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o0 M0 N0 H6 HrecH6] ].
intro.
apply (H4 M N H M0 N0 H5 H6).
intro.
cut (M = inv (MEnc M0 K)).
simpl in |- *.
intro.
case (H1 M N H M0 K H6 N0 L); intro; tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (MPair M1 M2)).
simpl in |- *.
intro.

*****
H6 : eq M (MPair M1 M2)
H5 : eq (MPair M1 M2) (inv M)
HrecH6_0 : forall _ : eq M2 (inv M), eq N2 (inv N)
HrecH6_1 : forall _ : eq M1 (inv M), eq N1 (inv N)
H6_0 : synthesis h M2 N2
H6_1 : synthesis h M1 N1
M1,N1,M2,N2 : Msg
H : h M N
M,N : Msg
H4bis : forall (M N : Msg) (_ : synthesis h M N) (M' N' : Msg)\n (_ : synthesis h M' N') (_ : eq M M'), eq N N'
H4 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M' (inv M)), eq N' (inv N)
H3 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H2 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H1 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H0 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
eq (MPair N1 N2) (inv N)
+++++
rewrite H6 in H.
-----
Theorem inj_inv_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_inv_left h -> injective_inv_left (synthesis h).
intro h.
intros H0 H1 H2 H3 H4.
generalize (inj_left_syn h H0 H1 H2 H3).
intro H4bis.
unfold injective_left in H0.
unfold enc_synthesis_left in H1.
unfold op_synthesis_left in H2.
unfold pair_free_left in H3.
unfold injective_inv_left in H4.
unfold injective_left in H4bis.
unfold injective_inv_left in |- *.
intros M N H5.
induction H5 as [M N H| M N K L H5_1 HrecH5_1 H5_0 HrecH5_0| M1 N1 M2 N2 H5_1 HrecH5_1 H5_0 HrecH5_0| o M N H5 HrecH5]; intros M' N' H6; [ induction H6 as [M0 N0 H5| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K0 L0 H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M N H| M N K L H6_1 HrecH6_1 H6_0 HrecH6_0| M0 N0 M3 N3 H6_1 HrecH6_1 H6_0 HrecH6_0| o M N H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o0 M0 N0 H6 HrecH6] ].
intro.
apply (H4 M N H M0 N0 H5 H6).
intro.
cut (M = inv (MEnc M0 K)).
simpl in |- *.
intro.
case (H1 M N H M0 K H6 N0 L); intro; tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (MPair M1 M2)).
simpl in |- *.
intro.
rewrite H6 in H.

*****
H6 : eq M (MPair M1 M2)
H5 : eq (MPair M1 M2) (inv M)
HrecH6_0 : forall _ : eq M2 (inv M), eq N2 (inv N)
HrecH6_1 : forall _ : eq M1 (inv M), eq N1 (inv N)
H6_0 : synthesis h M2 N2
H6_1 : synthesis h M1 N1
N1,N2 : Msg
H : h (MPair M1 M2) N
M,N,M1,M2 : Msg
H4bis : forall (M N : Msg) (_ : synthesis h M N) (M' N' : Msg)\n (_ : synthesis h M' N') (_ : eq M M'), eq N N'
H4 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M' (inv M)), eq N' (inv N)
H3 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H2 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H1 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H0 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
eq (MPair N1 N2) (inv N)
+++++
generalize (H3 M1 M2 N).
-----
Theorem inj_inv_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_inv_left h -> injective_inv_left (synthesis h).
intro h.
intros H0 H1 H2 H3 H4.
generalize (inj_left_syn h H0 H1 H2 H3).
intro H4bis.
unfold injective_left in H0.
unfold enc_synthesis_left in H1.
unfold op_synthesis_left in H2.
unfold pair_free_left in H3.
unfold injective_inv_left in H4.
unfold injective_left in H4bis.
unfold injective_inv_left in |- *.
intros M N H5.
induction H5 as [M N H| M N K L H5_1 HrecH5_1 H5_0 HrecH5_0| M1 N1 M2 N2 H5_1 HrecH5_1 H5_0 HrecH5_0| o M N H5 HrecH5]; intros M' N' H6; [ induction H6 as [M0 N0 H5| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K0 L0 H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M N H| M N K L H6_1 HrecH6_1 H6_0 HrecH6_0| M0 N0 M3 N3 H6_1 HrecH6_1 H6_0 HrecH6_0| o M N H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o0 M0 N0 H6 HrecH6] ].
intro.
apply (H4 M N H M0 N0 H5 H6).
intro.
cut (M = inv (MEnc M0 K)).
simpl in |- *.
intro.
case (H1 M N H M0 K H6 N0 L); intro; tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (MPair M1 M2)).
simpl in |- *.
intro.
rewrite H6 in H.
generalize (H3 M1 M2 N).

*****
H6 : eq M (MPair M1 M2)
H5 : eq (MPair M1 M2) (inv M)
HrecH6_0 : forall _ : eq M2 (inv M), eq N2 (inv N)
HrecH6_1 : forall _ : eq M1 (inv M), eq N1 (inv N)
H6_0 : synthesis h M2 N2
H6_1 : synthesis h M1 N1
N1,N2 : Msg
H : h (MPair M1 M2) N
M,N,M1,M2 : Msg
H4bis : forall (M N : Msg) (_ : synthesis h M N) (M' N' : Msg)\n (_ : synthesis h M' N') (_ : eq M M'), eq N N'
H4 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M' (inv M)), eq N' (inv N)
H3 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H2 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H1 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H0 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
forall _ : not (h (MPair M1 M2) N), eq (MPair N1 N2) (inv N)
+++++
tauto.
-----
Theorem inj_inv_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_inv_left h -> injective_inv_left (synthesis h).
intro h.
intros H0 H1 H2 H3 H4.
generalize (inj_left_syn h H0 H1 H2 H3).
intro H4bis.
unfold injective_left in H0.
unfold enc_synthesis_left in H1.
unfold op_synthesis_left in H2.
unfold pair_free_left in H3.
unfold injective_inv_left in H4.
unfold injective_left in H4bis.
unfold injective_inv_left in |- *.
intros M N H5.
induction H5 as [M N H| M N K L H5_1 HrecH5_1 H5_0 HrecH5_0| M1 N1 M2 N2 H5_1 HrecH5_1 H5_0 HrecH5_0| o M N H5 HrecH5]; intros M' N' H6; [ induction H6 as [M0 N0 H5| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K0 L0 H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M N H| M N K L H6_1 HrecH6_1 H6_0 HrecH6_0| M0 N0 M3 N3 H6_1 HrecH6_1 H6_0 HrecH6_0| o M N H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o0 M0 N0 H6 HrecH6] ].
intro.
apply (H4 M N H M0 N0 H5 H6).
intro.
cut (M = inv (MEnc M0 K)).
simpl in |- *.
intro.
case (H1 M N H M0 K H6 N0 L); intro; tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (MPair M1 M2)).
simpl in |- *.
intro.
rewrite H6 in H.
generalize (H3 M1 M2 N).
tauto.

*****
H5 : eq (MPair M1 M2) (inv M)
HrecH6_0 : forall _ : eq M2 (inv M), eq N2 (inv N)
HrecH6_1 : forall _ : eq M1 (inv M), eq N1 (inv N)
H6_0 : synthesis h M2 N2
H6_1 : synthesis h M1 N1
M1,N1,M2,N2 : Msg
H : h M N
M,N : Msg
H4bis : forall (M N : Msg) (_ : synthesis h M N) (M' N' : Msg)\n (_ : synthesis h M' N') (_ : eq M M'), eq N N'
H4 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M' (inv M)), eq N' (inv N)
H3 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H2 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H1 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H0 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
eq M (inv (MPair M1 M2))
+++++
rewrite H5.
-----
Theorem inj_inv_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_inv_left h -> injective_inv_left (synthesis h).
intro h.
intros H0 H1 H2 H3 H4.
generalize (inj_left_syn h H0 H1 H2 H3).
intro H4bis.
unfold injective_left in H0.
unfold enc_synthesis_left in H1.
unfold op_synthesis_left in H2.
unfold pair_free_left in H3.
unfold injective_inv_left in H4.
unfold injective_left in H4bis.
unfold injective_inv_left in |- *.
intros M N H5.
induction H5 as [M N H| M N K L H5_1 HrecH5_1 H5_0 HrecH5_0| M1 N1 M2 N2 H5_1 HrecH5_1 H5_0 HrecH5_0| o M N H5 HrecH5]; intros M' N' H6; [ induction H6 as [M0 N0 H5| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K0 L0 H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M N H| M N K L H6_1 HrecH6_1 H6_0 HrecH6_0| M0 N0 M3 N3 H6_1 HrecH6_1 H6_0 HrecH6_0| o M N H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o0 M0 N0 H6 HrecH6] ].
intro.
apply (H4 M N H M0 N0 H5 H6).
intro.
cut (M = inv (MEnc M0 K)).
simpl in |- *.
intro.
case (H1 M N H M0 K H6 N0 L); intro; tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (MPair M1 M2)).
simpl in |- *.
intro.
rewrite H6 in H.
generalize (H3 M1 M2 N).
tauto.
rewrite H5.

*****
H5 : eq (MPair M1 M2) (inv M)
HrecH6_0 : forall _ : eq M2 (inv M), eq N2 (inv N)
HrecH6_1 : forall _ : eq M1 (inv M), eq N1 (inv N)
H6_0 : synthesis h M2 N2
H6_1 : synthesis h M1 N1
M1,N1,M2,N2 : Msg
H : h M N
M,N : Msg
H4bis : forall (M N : Msg) (_ : synthesis h M N) (M' N' : Msg)\n (_ : synthesis h M' N') (_ : eq M M'), eq N N'
H4 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M' (inv M)), eq N' (inv N)
H3 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H2 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H1 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H0 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
eq M (inv (inv M))
+++++
symmetry in |- *.
-----
Theorem inj_inv_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_inv_left h -> injective_inv_left (synthesis h).
intro h.
intros H0 H1 H2 H3 H4.
generalize (inj_left_syn h H0 H1 H2 H3).
intro H4bis.
unfold injective_left in H0.
unfold enc_synthesis_left in H1.
unfold op_synthesis_left in H2.
unfold pair_free_left in H3.
unfold injective_inv_left in H4.
unfold injective_left in H4bis.
unfold injective_inv_left in |- *.
intros M N H5.
induction H5 as [M N H| M N K L H5_1 HrecH5_1 H5_0 HrecH5_0| M1 N1 M2 N2 H5_1 HrecH5_1 H5_0 HrecH5_0| o M N H5 HrecH5]; intros M' N' H6; [ induction H6 as [M0 N0 H5| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K0 L0 H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M N H| M N K L H6_1 HrecH6_1 H6_0 HrecH6_0| M0 N0 M3 N3 H6_1 HrecH6_1 H6_0 HrecH6_0| o M N H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o0 M0 N0 H6 HrecH6] ].
intro.
apply (H4 M N H M0 N0 H5 H6).
intro.
cut (M = inv (MEnc M0 K)).
simpl in |- *.
intro.
case (H1 M N H M0 K H6 N0 L); intro; tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (MPair M1 M2)).
simpl in |- *.
intro.
rewrite H6 in H.
generalize (H3 M1 M2 N).
tauto.
rewrite H5.
symmetry in |- *.

*****
H5 : eq (MPair M1 M2) (inv M)
HrecH6_0 : forall _ : eq M2 (inv M), eq N2 (inv N)
HrecH6_1 : forall _ : eq M1 (inv M), eq N1 (inv N)
H6_0 : synthesis h M2 N2
H6_1 : synthesis h M1 N1
M1,N1,M2,N2 : Msg
H : h M N
M,N : Msg
H4bis : forall (M N : Msg) (_ : synthesis h M N) (M' N' : Msg)\n (_ : synthesis h M' N') (_ : eq M M'), eq N N'
H4 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M' (inv M)), eq N' (inv N)
H3 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H2 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H1 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H0 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
eq (inv (inv M)) M
+++++
apply inv_invol.
-----
Theorem inj_inv_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_inv_left h -> injective_inv_left (synthesis h).
intro h.
intros H0 H1 H2 H3 H4.
generalize (inj_left_syn h H0 H1 H2 H3).
intro H4bis.
unfold injective_left in H0.
unfold enc_synthesis_left in H1.
unfold op_synthesis_left in H2.
unfold pair_free_left in H3.
unfold injective_inv_left in H4.
unfold injective_left in H4bis.
unfold injective_inv_left in |- *.
intros M N H5.
induction H5 as [M N H| M N K L H5_1 HrecH5_1 H5_0 HrecH5_0| M1 N1 M2 N2 H5_1 HrecH5_1 H5_0 HrecH5_0| o M N H5 HrecH5]; intros M' N' H6; [ induction H6 as [M0 N0 H5| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K0 L0 H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M N H| M N K L H6_1 HrecH6_1 H6_0 HrecH6_0| M0 N0 M3 N3 H6_1 HrecH6_1 H6_0 HrecH6_0| o M N H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o0 M0 N0 H6 HrecH6] ].
intro.
apply (H4 M N H M0 N0 H5 H6).
intro.
cut (M = inv (MEnc M0 K)).
simpl in |- *.
intro.
case (H1 M N H M0 K H6 N0 L); intro; tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (MPair M1 M2)).
simpl in |- *.
intro.
rewrite H6 in H.
generalize (H3 M1 M2 N).
tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.

*****
HrecH6 : forall _ : eq M0 (inv M), eq N0 (inv N)
H6 : synthesis h M0 N0
M0,N0 : Msg
o : op
H : h M N
M,N : Msg
H4bis : forall (M N : Msg) (_ : synthesis h M N) (M' N' : Msg)\n (_ : synthesis h M' N') (_ : eq M M'), eq N N'
H4 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M' (inv M)), eq N' (inv N)
H3 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H2 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H1 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H0 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
forall _ : eq (Mop o M0) (inv M), eq (Mop o N0) (inv N)
+++++
intro.
-----
Theorem inj_inv_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_inv_left h -> injective_inv_left (synthesis h).
intro h.
intros H0 H1 H2 H3 H4.
generalize (inj_left_syn h H0 H1 H2 H3).
intro H4bis.
unfold injective_left in H0.
unfold enc_synthesis_left in H1.
unfold op_synthesis_left in H2.
unfold pair_free_left in H3.
unfold injective_inv_left in H4.
unfold injective_left in H4bis.
unfold injective_inv_left in |- *.
intros M N H5.
induction H5 as [M N H| M N K L H5_1 HrecH5_1 H5_0 HrecH5_0| M1 N1 M2 N2 H5_1 HrecH5_1 H5_0 HrecH5_0| o M N H5 HrecH5]; intros M' N' H6; [ induction H6 as [M0 N0 H5| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K0 L0 H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M N H| M N K L H6_1 HrecH6_1 H6_0 HrecH6_0| M0 N0 M3 N3 H6_1 HrecH6_1 H6_0 HrecH6_0| o M N H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o0 M0 N0 H6 HrecH6] ].
intro.
apply (H4 M N H M0 N0 H5 H6).
intro.
cut (M = inv (MEnc M0 K)).
simpl in |- *.
intro.
case (H1 M N H M0 K H6 N0 L); intro; tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (MPair M1 M2)).
simpl in |- *.
intro.
rewrite H6 in H.
generalize (H3 M1 M2 N).
tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.

*****
H5 : eq (Mop o M0) (inv M)
HrecH6 : forall _ : eq M0 (inv M), eq N0 (inv N)
H6 : synthesis h M0 N0
M0,N0 : Msg
o : op
H : h M N
M,N : Msg
H4bis : forall (M N : Msg) (_ : synthesis h M N) (M' N' : Msg)\n (_ : synthesis h M' N') (_ : eq M M'), eq N N'
H4 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M' (inv M)), eq N' (inv N)
H3 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H2 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H1 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H0 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
eq (Mop o N0) (inv N)
+++++
cut (M = inv (Mop o M0)).
-----
Theorem inj_inv_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_inv_left h -> injective_inv_left (synthesis h).
intro h.
intros H0 H1 H2 H3 H4.
generalize (inj_left_syn h H0 H1 H2 H3).
intro H4bis.
unfold injective_left in H0.
unfold enc_synthesis_left in H1.
unfold op_synthesis_left in H2.
unfold pair_free_left in H3.
unfold injective_inv_left in H4.
unfold injective_left in H4bis.
unfold injective_inv_left in |- *.
intros M N H5.
induction H5 as [M N H| M N K L H5_1 HrecH5_1 H5_0 HrecH5_0| M1 N1 M2 N2 H5_1 HrecH5_1 H5_0 HrecH5_0| o M N H5 HrecH5]; intros M' N' H6; [ induction H6 as [M0 N0 H5| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K0 L0 H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M N H| M N K L H6_1 HrecH6_1 H6_0 HrecH6_0| M0 N0 M3 N3 H6_1 HrecH6_1 H6_0 HrecH6_0| o M N H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o0 M0 N0 H6 HrecH6] ].
intro.
apply (H4 M N H M0 N0 H5 H6).
intro.
cut (M = inv (MEnc M0 K)).
simpl in |- *.
intro.
case (H1 M N H M0 K H6 N0 L); intro; tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (MPair M1 M2)).
simpl in |- *.
intro.
rewrite H6 in H.
generalize (H3 M1 M2 N).
tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (Mop o M0)).

*****
H5 : eq (Mop o M0) (inv M)
HrecH6 : forall _ : eq M0 (inv M), eq N0 (inv N)
H6 : synthesis h M0 N0
M0,N0 : Msg
o : op
H : h M N
M,N : Msg
H4bis : forall (M N : Msg) (_ : synthesis h M N) (M' N' : Msg)\n (_ : synthesis h M' N') (_ : eq M M'), eq N N'
H4 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M' (inv M)), eq N' (inv N)
H3 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H2 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H1 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H0 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
forall _ : eq M (inv (Mop o M0)), eq (Mop o N0) (inv N)
+++++
simpl in |- *.
-----
Theorem inj_inv_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_inv_left h -> injective_inv_left (synthesis h).
intro h.
intros H0 H1 H2 H3 H4.
generalize (inj_left_syn h H0 H1 H2 H3).
intro H4bis.
unfold injective_left in H0.
unfold enc_synthesis_left in H1.
unfold op_synthesis_left in H2.
unfold pair_free_left in H3.
unfold injective_inv_left in H4.
unfold injective_left in H4bis.
unfold injective_inv_left in |- *.
intros M N H5.
induction H5 as [M N H| M N K L H5_1 HrecH5_1 H5_0 HrecH5_0| M1 N1 M2 N2 H5_1 HrecH5_1 H5_0 HrecH5_0| o M N H5 HrecH5]; intros M' N' H6; [ induction H6 as [M0 N0 H5| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K0 L0 H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M N H| M N K L H6_1 HrecH6_1 H6_0 HrecH6_0| M0 N0 M3 N3 H6_1 HrecH6_1 H6_0 HrecH6_0| o M N H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o0 M0 N0 H6 HrecH6] ].
intro.
apply (H4 M N H M0 N0 H5 H6).
intro.
cut (M = inv (MEnc M0 K)).
simpl in |- *.
intro.
case (H1 M N H M0 K H6 N0 L); intro; tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (MPair M1 M2)).
simpl in |- *.
intro.
rewrite H6 in H.
generalize (H3 M1 M2 N).
tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (Mop o M0)).
simpl in |- *.

*****
H5 : eq (Mop o M0) (inv M)
HrecH6 : forall _ : eq M0 (inv M), eq N0 (inv N)
H6 : synthesis h M0 N0
M0,N0 : Msg
o : op
H : h M N
M,N : Msg
H4bis : forall (M N : Msg) (_ : synthesis h M N) (M' N' : Msg)\n (_ : synthesis h M' N') (_ : eq M M'), eq N N'
H4 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M' (inv M)), eq N' (inv N)
H3 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H2 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H1 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H0 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
forall _ : eq M (Mop (inv_op o) M0), eq (Mop o N0) (inv N)
+++++
intro.
-----
Theorem inj_inv_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_inv_left h -> injective_inv_left (synthesis h).
intro h.
intros H0 H1 H2 H3 H4.
generalize (inj_left_syn h H0 H1 H2 H3).
intro H4bis.
unfold injective_left in H0.
unfold enc_synthesis_left in H1.
unfold op_synthesis_left in H2.
unfold pair_free_left in H3.
unfold injective_inv_left in H4.
unfold injective_left in H4bis.
unfold injective_inv_left in |- *.
intros M N H5.
induction H5 as [M N H| M N K L H5_1 HrecH5_1 H5_0 HrecH5_0| M1 N1 M2 N2 H5_1 HrecH5_1 H5_0 HrecH5_0| o M N H5 HrecH5]; intros M' N' H6; [ induction H6 as [M0 N0 H5| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K0 L0 H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M N H| M N K L H6_1 HrecH6_1 H6_0 HrecH6_0| M0 N0 M3 N3 H6_1 HrecH6_1 H6_0 HrecH6_0| o M N H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o0 M0 N0 H6 HrecH6] ].
intro.
apply (H4 M N H M0 N0 H5 H6).
intro.
cut (M = inv (MEnc M0 K)).
simpl in |- *.
intro.
case (H1 M N H M0 K H6 N0 L); intro; tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (MPair M1 M2)).
simpl in |- *.
intro.
rewrite H6 in H.
generalize (H3 M1 M2 N).
tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (Mop o M0)).
simpl in |- *.
intro.

*****
H7 : eq M (Mop (inv_op o) M0)
H5 : eq (Mop o M0) (inv M)
HrecH6 : forall _ : eq M0 (inv M), eq N0 (inv N)
H6 : synthesis h M0 N0
M0,N0 : Msg
o : op
H : h M N
M,N : Msg
H4bis : forall (M N : Msg) (_ : synthesis h M N) (M' N' : Msg)\n (_ : synthesis h M' N') (_ : eq M M'), eq N N'
H4 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M' (inv M)), eq N' (inv N)
H3 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H2 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H1 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H0 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
eq (Mop o N0) (inv N)
+++++
generalize (H2 (inv_op o) M N H M0 H7 N0).
-----
Theorem inj_inv_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_inv_left h -> injective_inv_left (synthesis h).
intro h.
intros H0 H1 H2 H3 H4.
generalize (inj_left_syn h H0 H1 H2 H3).
intro H4bis.
unfold injective_left in H0.
unfold enc_synthesis_left in H1.
unfold op_synthesis_left in H2.
unfold pair_free_left in H3.
unfold injective_inv_left in H4.
unfold injective_left in H4bis.
unfold injective_inv_left in |- *.
intros M N H5.
induction H5 as [M N H| M N K L H5_1 HrecH5_1 H5_0 HrecH5_0| M1 N1 M2 N2 H5_1 HrecH5_1 H5_0 HrecH5_0| o M N H5 HrecH5]; intros M' N' H6; [ induction H6 as [M0 N0 H5| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K0 L0 H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M N H| M N K L H6_1 HrecH6_1 H6_0 HrecH6_0| M0 N0 M3 N3 H6_1 HrecH6_1 H6_0 HrecH6_0| o M N H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o0 M0 N0 H6 HrecH6] ].
intro.
apply (H4 M N H M0 N0 H5 H6).
intro.
cut (M = inv (MEnc M0 K)).
simpl in |- *.
intro.
case (H1 M N H M0 K H6 N0 L); intro; tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (MPair M1 M2)).
simpl in |- *.
intro.
rewrite H6 in H.
generalize (H3 M1 M2 N).
tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (Mop o M0)).
simpl in |- *.
intro.
generalize (H2 (inv_op o) M N H M0 H7 N0).

*****
H7 : eq M (Mop (inv_op o) M0)
H5 : eq (Mop o M0) (inv M)
HrecH6 : forall _ : eq M0 (inv M), eq N0 (inv N)
H6 : synthesis h M0 N0
M0,N0 : Msg
o : op
H : h M N
M,N : Msg
H4bis : forall (M N : Msg) (_ : synthesis h M N) (M' N' : Msg)\n (_ : synthesis h M' N') (_ : eq M M'), eq N N'
H4 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M' (inv M)), eq N' (inv N)
H3 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H2 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H1 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H0 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
forall _ : not (synthesis h M0 N0), eq (Mop o N0) (inv N)
+++++
tauto.
-----
Theorem inj_inv_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_inv_left h -> injective_inv_left (synthesis h).
intro h.
intros H0 H1 H2 H3 H4.
generalize (inj_left_syn h H0 H1 H2 H3).
intro H4bis.
unfold injective_left in H0.
unfold enc_synthesis_left in H1.
unfold op_synthesis_left in H2.
unfold pair_free_left in H3.
unfold injective_inv_left in H4.
unfold injective_left in H4bis.
unfold injective_inv_left in |- *.
intros M N H5.
induction H5 as [M N H| M N K L H5_1 HrecH5_1 H5_0 HrecH5_0| M1 N1 M2 N2 H5_1 HrecH5_1 H5_0 HrecH5_0| o M N H5 HrecH5]; intros M' N' H6; [ induction H6 as [M0 N0 H5| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K0 L0 H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M N H| M N K L H6_1 HrecH6_1 H6_0 HrecH6_0| M0 N0 M3 N3 H6_1 HrecH6_1 H6_0 HrecH6_0| o M N H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o0 M0 N0 H6 HrecH6] ].
intro.
apply (H4 M N H M0 N0 H5 H6).
intro.
cut (M = inv (MEnc M0 K)).
simpl in |- *.
intro.
case (H1 M N H M0 K H6 N0 L); intro; tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (MPair M1 M2)).
simpl in |- *.
intro.
rewrite H6 in H.
generalize (H3 M1 M2 N).
tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (Mop o M0)).
simpl in |- *.
intro.
generalize (H2 (inv_op o) M N H M0 H7 N0).
tauto.

*****
H5 : eq (Mop o M0) (inv M)
HrecH6 : forall _ : eq M0 (inv M), eq N0 (inv N)
H6 : synthesis h M0 N0
M0,N0 : Msg
o : op
H : h M N
M,N : Msg
H4bis : forall (M N : Msg) (_ : synthesis h M N) (M' N' : Msg)\n (_ : synthesis h M' N') (_ : eq M M'), eq N N'
H4 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M' (inv M)), eq N' (inv N)
H3 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H2 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H1 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H0 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
eq M (inv (Mop o M0))
+++++
rewrite H5.
-----
Theorem inj_inv_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_inv_left h -> injective_inv_left (synthesis h).
intro h.
intros H0 H1 H2 H3 H4.
generalize (inj_left_syn h H0 H1 H2 H3).
intro H4bis.
unfold injective_left in H0.
unfold enc_synthesis_left in H1.
unfold op_synthesis_left in H2.
unfold pair_free_left in H3.
unfold injective_inv_left in H4.
unfold injective_left in H4bis.
unfold injective_inv_left in |- *.
intros M N H5.
induction H5 as [M N H| M N K L H5_1 HrecH5_1 H5_0 HrecH5_0| M1 N1 M2 N2 H5_1 HrecH5_1 H5_0 HrecH5_0| o M N H5 HrecH5]; intros M' N' H6; [ induction H6 as [M0 N0 H5| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K0 L0 H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M N H| M N K L H6_1 HrecH6_1 H6_0 HrecH6_0| M0 N0 M3 N3 H6_1 HrecH6_1 H6_0 HrecH6_0| o M N H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o0 M0 N0 H6 HrecH6] ].
intro.
apply (H4 M N H M0 N0 H5 H6).
intro.
cut (M = inv (MEnc M0 K)).
simpl in |- *.
intro.
case (H1 M N H M0 K H6 N0 L); intro; tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (MPair M1 M2)).
simpl in |- *.
intro.
rewrite H6 in H.
generalize (H3 M1 M2 N).
tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (Mop o M0)).
simpl in |- *.
intro.
generalize (H2 (inv_op o) M N H M0 H7 N0).
tauto.
rewrite H5.

*****
H5 : eq (Mop o M0) (inv M)
HrecH6 : forall _ : eq M0 (inv M), eq N0 (inv N)
H6 : synthesis h M0 N0
M0,N0 : Msg
o : op
H : h M N
M,N : Msg
H4bis : forall (M N : Msg) (_ : synthesis h M N) (M' N' : Msg)\n (_ : synthesis h M' N') (_ : eq M M'), eq N N'
H4 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M' (inv M)), eq N' (inv N)
H3 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H2 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H1 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H0 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
eq M (inv (inv M))
+++++
symmetry in |- *.
-----
Theorem inj_inv_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_inv_left h -> injective_inv_left (synthesis h).
intro h.
intros H0 H1 H2 H3 H4.
generalize (inj_left_syn h H0 H1 H2 H3).
intro H4bis.
unfold injective_left in H0.
unfold enc_synthesis_left in H1.
unfold op_synthesis_left in H2.
unfold pair_free_left in H3.
unfold injective_inv_left in H4.
unfold injective_left in H4bis.
unfold injective_inv_left in |- *.
intros M N H5.
induction H5 as [M N H| M N K L H5_1 HrecH5_1 H5_0 HrecH5_0| M1 N1 M2 N2 H5_1 HrecH5_1 H5_0 HrecH5_0| o M N H5 HrecH5]; intros M' N' H6; [ induction H6 as [M0 N0 H5| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K0 L0 H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M N H| M N K L H6_1 HrecH6_1 H6_0 HrecH6_0| M0 N0 M3 N3 H6_1 HrecH6_1 H6_0 HrecH6_0| o M N H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o0 M0 N0 H6 HrecH6] ].
intro.
apply (H4 M N H M0 N0 H5 H6).
intro.
cut (M = inv (MEnc M0 K)).
simpl in |- *.
intro.
case (H1 M N H M0 K H6 N0 L); intro; tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (MPair M1 M2)).
simpl in |- *.
intro.
rewrite H6 in H.
generalize (H3 M1 M2 N).
tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (Mop o M0)).
simpl in |- *.
intro.
generalize (H2 (inv_op o) M N H M0 H7 N0).
tauto.
rewrite H5.
symmetry in |- *.

*****
H5 : eq (Mop o M0) (inv M)
HrecH6 : forall _ : eq M0 (inv M), eq N0 (inv N)
H6 : synthesis h M0 N0
M0,N0 : Msg
o : op
H : h M N
M,N : Msg
H4bis : forall (M N : Msg) (_ : synthesis h M N) (M' N' : Msg)\n (_ : synthesis h M' N') (_ : eq M M'), eq N N'
H4 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M' (inv M)), eq N' (inv N)
H3 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H2 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H1 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H0 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
eq (inv (inv M)) M
+++++
apply inv_invol.
-----
Theorem inj_inv_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_inv_left h -> injective_inv_left (synthesis h).
intro h.
intros H0 H1 H2 H3 H4.
generalize (inj_left_syn h H0 H1 H2 H3).
intro H4bis.
unfold injective_left in H0.
unfold enc_synthesis_left in H1.
unfold op_synthesis_left in H2.
unfold pair_free_left in H3.
unfold injective_inv_left in H4.
unfold injective_left in H4bis.
unfold injective_inv_left in |- *.
intros M N H5.
induction H5 as [M N H| M N K L H5_1 HrecH5_1 H5_0 HrecH5_0| M1 N1 M2 N2 H5_1 HrecH5_1 H5_0 HrecH5_0| o M N H5 HrecH5]; intros M' N' H6; [ induction H6 as [M0 N0 H5| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K0 L0 H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M N H| M N K L H6_1 HrecH6_1 H6_0 HrecH6_0| M0 N0 M3 N3 H6_1 HrecH6_1 H6_0 HrecH6_0| o M N H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o0 M0 N0 H6 HrecH6] ].
intro.
apply (H4 M N H M0 N0 H5 H6).
intro.
cut (M = inv (MEnc M0 K)).
simpl in |- *.
intro.
case (H1 M N H M0 K H6 N0 L); intro; tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (MPair M1 M2)).
simpl in |- *.
intro.
rewrite H6 in H.
generalize (H3 M1 M2 N).
tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (Mop o M0)).
simpl in |- *.
intro.
generalize (H2 (inv_op o) M N H M0 H7 N0).
tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.

*****
H : h M0 N0
M0,N0 : Msg
HrecH5_0 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M' (inv K)),\neq N' (inv L)
HrecH5_1 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M' (inv M)),\neq N' (inv N)
H5_0 : synthesis h K L
H5_1 : synthesis h M N
M,N,K,L : Msg
H4bis : forall (M N : Msg) (_ : synthesis h M N) (M' N' : Msg)\n (_ : synthesis h M' N') (_ : eq M M'), eq N N'
H4 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M' (inv M)), eq N' (inv N)
H3 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H2 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H1 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H0 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
forall _ : eq M0 (inv (MEnc M K)), eq N0 (inv (MEnc N L))
+++++
simpl in |- *.
-----
Theorem inj_inv_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_inv_left h -> injective_inv_left (synthesis h).
intro h.
intros H0 H1 H2 H3 H4.
generalize (inj_left_syn h H0 H1 H2 H3).
intro H4bis.
unfold injective_left in H0.
unfold enc_synthesis_left in H1.
unfold op_synthesis_left in H2.
unfold pair_free_left in H3.
unfold injective_inv_left in H4.
unfold injective_left in H4bis.
unfold injective_inv_left in |- *.
intros M N H5.
induction H5 as [M N H| M N K L H5_1 HrecH5_1 H5_0 HrecH5_0| M1 N1 M2 N2 H5_1 HrecH5_1 H5_0 HrecH5_0| o M N H5 HrecH5]; intros M' N' H6; [ induction H6 as [M0 N0 H5| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K0 L0 H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M N H| M N K L H6_1 HrecH6_1 H6_0 HrecH6_0| M0 N0 M3 N3 H6_1 HrecH6_1 H6_0 HrecH6_0| o M N H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o0 M0 N0 H6 HrecH6] ].
intro.
apply (H4 M N H M0 N0 H5 H6).
intro.
cut (M = inv (MEnc M0 K)).
simpl in |- *.
intro.
case (H1 M N H M0 K H6 N0 L); intro; tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (MPair M1 M2)).
simpl in |- *.
intro.
rewrite H6 in H.
generalize (H3 M1 M2 N).
tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (Mop o M0)).
simpl in |- *.
intro.
generalize (H2 (inv_op o) M N H M0 H7 N0).
tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
simpl in |- *.

*****
H : h M0 N0
M0,N0 : Msg
HrecH5_0 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M' (inv K)),\neq N' (inv L)
HrecH5_1 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M' (inv M)),\neq N' (inv N)
H5_0 : synthesis h K L
H5_1 : synthesis h M N
M,N,K,L : Msg
H4bis : forall (M N : Msg) (_ : synthesis h M N) (M' N' : Msg)\n (_ : synthesis h M' N') (_ : eq M M'), eq N N'
H4 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M' (inv M)), eq N' (inv N)
H3 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H2 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H1 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H0 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
forall _ : eq M0 (MEnc M K), eq N0 (MEnc N L)
+++++
cut (synthesis h M0 N0).
-----
Theorem inj_inv_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_inv_left h -> injective_inv_left (synthesis h).
intro h.
intros H0 H1 H2 H3 H4.
generalize (inj_left_syn h H0 H1 H2 H3).
intro H4bis.
unfold injective_left in H0.
unfold enc_synthesis_left in H1.
unfold op_synthesis_left in H2.
unfold pair_free_left in H3.
unfold injective_inv_left in H4.
unfold injective_left in H4bis.
unfold injective_inv_left in |- *.
intros M N H5.
induction H5 as [M N H| M N K L H5_1 HrecH5_1 H5_0 HrecH5_0| M1 N1 M2 N2 H5_1 HrecH5_1 H5_0 HrecH5_0| o M N H5 HrecH5]; intros M' N' H6; [ induction H6 as [M0 N0 H5| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K0 L0 H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M N H| M N K L H6_1 HrecH6_1 H6_0 HrecH6_0| M0 N0 M3 N3 H6_1 HrecH6_1 H6_0 HrecH6_0| o M N H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o0 M0 N0 H6 HrecH6] ].
intro.
apply (H4 M N H M0 N0 H5 H6).
intro.
cut (M = inv (MEnc M0 K)).
simpl in |- *.
intro.
case (H1 M N H M0 K H6 N0 L); intro; tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (MPair M1 M2)).
simpl in |- *.
intro.
rewrite H6 in H.
generalize (H3 M1 M2 N).
tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (Mop o M0)).
simpl in |- *.
intro.
generalize (H2 (inv_op o) M N H M0 H7 N0).
tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
simpl in |- *.
cut (synthesis h M0 N0).

*****
H : h M0 N0
M0,N0 : Msg
HrecH5_0 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M' (inv K)),\neq N' (inv L)
HrecH5_1 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M' (inv M)),\neq N' (inv N)
H5_0 : synthesis h K L
H5_1 : synthesis h M N
M,N,K,L : Msg
H4bis : forall (M N : Msg) (_ : synthesis h M N) (M' N' : Msg)\n (_ : synthesis h M' N') (_ : eq M M'), eq N N'
H4 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M' (inv M)), eq N' (inv N)
H3 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H2 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H1 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H0 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
forall (_ : synthesis h M0 N0) (_ : eq M0 (MEnc M K)), eq N0 (MEnc N L)
+++++
intro.
-----
Theorem inj_inv_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_inv_left h -> injective_inv_left (synthesis h).
intro h.
intros H0 H1 H2 H3 H4.
generalize (inj_left_syn h H0 H1 H2 H3).
intro H4bis.
unfold injective_left in H0.
unfold enc_synthesis_left in H1.
unfold op_synthesis_left in H2.
unfold pair_free_left in H3.
unfold injective_inv_left in H4.
unfold injective_left in H4bis.
unfold injective_inv_left in |- *.
intros M N H5.
induction H5 as [M N H| M N K L H5_1 HrecH5_1 H5_0 HrecH5_0| M1 N1 M2 N2 H5_1 HrecH5_1 H5_0 HrecH5_0| o M N H5 HrecH5]; intros M' N' H6; [ induction H6 as [M0 N0 H5| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K0 L0 H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M N H| M N K L H6_1 HrecH6_1 H6_0 HrecH6_0| M0 N0 M3 N3 H6_1 HrecH6_1 H6_0 HrecH6_0| o M N H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o0 M0 N0 H6 HrecH6] ].
intro.
apply (H4 M N H M0 N0 H5 H6).
intro.
cut (M = inv (MEnc M0 K)).
simpl in |- *.
intro.
case (H1 M N H M0 K H6 N0 L); intro; tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (MPair M1 M2)).
simpl in |- *.
intro.
rewrite H6 in H.
generalize (H3 M1 M2 N).
tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (Mop o M0)).
simpl in |- *.
intro.
generalize (H2 (inv_op o) M N H M0 H7 N0).
tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
simpl in |- *.
cut (synthesis h M0 N0).
intro.

*****
H5 : synthesis h M0 N0
H : h M0 N0
M0,N0 : Msg
HrecH5_0 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M' (inv K)),\neq N' (inv L)
HrecH5_1 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M' (inv M)),\neq N' (inv N)
H5_0 : synthesis h K L
H5_1 : synthesis h M N
M,N,K,L : Msg
H4bis : forall (M N : Msg) (_ : synthesis h M N) (M' N' : Msg)\n (_ : synthesis h M' N') (_ : eq M M'), eq N N'
H4 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M' (inv M)), eq N' (inv N)
H3 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H2 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H1 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H0 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
forall _ : eq M0 (MEnc M K), eq N0 (MEnc N L)
+++++
intro.
-----
Theorem inj_inv_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_inv_left h -> injective_inv_left (synthesis h).
intro h.
intros H0 H1 H2 H3 H4.
generalize (inj_left_syn h H0 H1 H2 H3).
intro H4bis.
unfold injective_left in H0.
unfold enc_synthesis_left in H1.
unfold op_synthesis_left in H2.
unfold pair_free_left in H3.
unfold injective_inv_left in H4.
unfold injective_left in H4bis.
unfold injective_inv_left in |- *.
intros M N H5.
induction H5 as [M N H| M N K L H5_1 HrecH5_1 H5_0 HrecH5_0| M1 N1 M2 N2 H5_1 HrecH5_1 H5_0 HrecH5_0| o M N H5 HrecH5]; intros M' N' H6; [ induction H6 as [M0 N0 H5| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K0 L0 H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M N H| M N K L H6_1 HrecH6_1 H6_0 HrecH6_0| M0 N0 M3 N3 H6_1 HrecH6_1 H6_0 HrecH6_0| o M N H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o0 M0 N0 H6 HrecH6] ].
intro.
apply (H4 M N H M0 N0 H5 H6).
intro.
cut (M = inv (MEnc M0 K)).
simpl in |- *.
intro.
case (H1 M N H M0 K H6 N0 L); intro; tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (MPair M1 M2)).
simpl in |- *.
intro.
rewrite H6 in H.
generalize (H3 M1 M2 N).
tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (Mop o M0)).
simpl in |- *.
intro.
generalize (H2 (inv_op o) M N H M0 H7 N0).
tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
simpl in |- *.
cut (synthesis h M0 N0).
intro.
intro.

*****
H6 : eq M0 (MEnc M K)
H5 : synthesis h M0 N0
H : h M0 N0
M0,N0 : Msg
HrecH5_0 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M' (inv K)),\neq N' (inv L)
HrecH5_1 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M' (inv M)),\neq N' (inv N)
H5_0 : synthesis h K L
H5_1 : synthesis h M N
M,N,K,L : Msg
H4bis : forall (M N : Msg) (_ : synthesis h M N) (M' N' : Msg)\n (_ : synthesis h M' N') (_ : eq M M'), eq N N'
H4 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M' (inv M)), eq N' (inv N)
H3 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H2 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H1 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H0 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
eq N0 (MEnc N L)
+++++
cut (synthesis h (MEnc M K) (MEnc N L)).
-----
Theorem inj_inv_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_inv_left h -> injective_inv_left (synthesis h).
intro h.
intros H0 H1 H2 H3 H4.
generalize (inj_left_syn h H0 H1 H2 H3).
intro H4bis.
unfold injective_left in H0.
unfold enc_synthesis_left in H1.
unfold op_synthesis_left in H2.
unfold pair_free_left in H3.
unfold injective_inv_left in H4.
unfold injective_left in H4bis.
unfold injective_inv_left in |- *.
intros M N H5.
induction H5 as [M N H| M N K L H5_1 HrecH5_1 H5_0 HrecH5_0| M1 N1 M2 N2 H5_1 HrecH5_1 H5_0 HrecH5_0| o M N H5 HrecH5]; intros M' N' H6; [ induction H6 as [M0 N0 H5| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K0 L0 H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M N H| M N K L H6_1 HrecH6_1 H6_0 HrecH6_0| M0 N0 M3 N3 H6_1 HrecH6_1 H6_0 HrecH6_0| o M N H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o0 M0 N0 H6 HrecH6] ].
intro.
apply (H4 M N H M0 N0 H5 H6).
intro.
cut (M = inv (MEnc M0 K)).
simpl in |- *.
intro.
case (H1 M N H M0 K H6 N0 L); intro; tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (MPair M1 M2)).
simpl in |- *.
intro.
rewrite H6 in H.
generalize (H3 M1 M2 N).
tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (Mop o M0)).
simpl in |- *.
intro.
generalize (H2 (inv_op o) M N H M0 H7 N0).
tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
simpl in |- *.
cut (synthesis h M0 N0).
intro.
intro.
cut (synthesis h (MEnc M K) (MEnc N L)).

*****
H6 : eq M0 (MEnc M K)
H5 : synthesis h M0 N0
H : h M0 N0
M0,N0 : Msg
HrecH5_0 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M' (inv K)),\neq N' (inv L)
HrecH5_1 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M' (inv M)),\neq N' (inv N)
H5_0 : synthesis h K L
H5_1 : synthesis h M N
M,N,K,L : Msg
H4bis : forall (M N : Msg) (_ : synthesis h M N) (M' N' : Msg)\n (_ : synthesis h M' N') (_ : eq M M'), eq N N'
H4 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M' (inv M)), eq N' (inv N)
H3 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H2 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H1 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H0 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
forall _ : synthesis h (MEnc M K) (MEnc N L), eq N0 (MEnc N L)
+++++
intro.
-----
Theorem inj_inv_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_inv_left h -> injective_inv_left (synthesis h).
intro h.
intros H0 H1 H2 H3 H4.
generalize (inj_left_syn h H0 H1 H2 H3).
intro H4bis.
unfold injective_left in H0.
unfold enc_synthesis_left in H1.
unfold op_synthesis_left in H2.
unfold pair_free_left in H3.
unfold injective_inv_left in H4.
unfold injective_left in H4bis.
unfold injective_inv_left in |- *.
intros M N H5.
induction H5 as [M N H| M N K L H5_1 HrecH5_1 H5_0 HrecH5_0| M1 N1 M2 N2 H5_1 HrecH5_1 H5_0 HrecH5_0| o M N H5 HrecH5]; intros M' N' H6; [ induction H6 as [M0 N0 H5| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K0 L0 H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M N H| M N K L H6_1 HrecH6_1 H6_0 HrecH6_0| M0 N0 M3 N3 H6_1 HrecH6_1 H6_0 HrecH6_0| o M N H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o0 M0 N0 H6 HrecH6] ].
intro.
apply (H4 M N H M0 N0 H5 H6).
intro.
cut (M = inv (MEnc M0 K)).
simpl in |- *.
intro.
case (H1 M N H M0 K H6 N0 L); intro; tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (MPair M1 M2)).
simpl in |- *.
intro.
rewrite H6 in H.
generalize (H3 M1 M2 N).
tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (Mop o M0)).
simpl in |- *.
intro.
generalize (H2 (inv_op o) M N H M0 H7 N0).
tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
simpl in |- *.
cut (synthesis h M0 N0).
intro.
intro.
cut (synthesis h (MEnc M K) (MEnc N L)).
intro.

*****
H7 : synthesis h (MEnc M K) (MEnc N L)
H6 : eq M0 (MEnc M K)
H5 : synthesis h M0 N0
H : h M0 N0
M0,N0 : Msg
HrecH5_0 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M' (inv K)),\neq N' (inv L)
HrecH5_1 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M' (inv M)),\neq N' (inv N)
H5_0 : synthesis h K L
H5_1 : synthesis h M N
M,N,K,L : Msg
H4bis : forall (M N : Msg) (_ : synthesis h M N) (M' N' : Msg)\n (_ : synthesis h M' N') (_ : eq M M'), eq N N'
H4 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M' (inv M)), eq N' (inv N)
H3 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H2 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H1 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H0 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
eq N0 (MEnc N L)
+++++
apply (H4bis M0 N0 H5 (MEnc M K) (MEnc N L) H7 H6).
-----
Theorem inj_inv_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_inv_left h -> injective_inv_left (synthesis h).
intro h.
intros H0 H1 H2 H3 H4.
generalize (inj_left_syn h H0 H1 H2 H3).
intro H4bis.
unfold injective_left in H0.
unfold enc_synthesis_left in H1.
unfold op_synthesis_left in H2.
unfold pair_free_left in H3.
unfold injective_inv_left in H4.
unfold injective_left in H4bis.
unfold injective_inv_left in |- *.
intros M N H5.
induction H5 as [M N H| M N K L H5_1 HrecH5_1 H5_0 HrecH5_0| M1 N1 M2 N2 H5_1 HrecH5_1 H5_0 HrecH5_0| o M N H5 HrecH5]; intros M' N' H6; [ induction H6 as [M0 N0 H5| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K0 L0 H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M N H| M N K L H6_1 HrecH6_1 H6_0 HrecH6_0| M0 N0 M3 N3 H6_1 HrecH6_1 H6_0 HrecH6_0| o M N H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o0 M0 N0 H6 HrecH6] ].
intro.
apply (H4 M N H M0 N0 H5 H6).
intro.
cut (M = inv (MEnc M0 K)).
simpl in |- *.
intro.
case (H1 M N H M0 K H6 N0 L); intro; tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (MPair M1 M2)).
simpl in |- *.
intro.
rewrite H6 in H.
generalize (H3 M1 M2 N).
tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (Mop o M0)).
simpl in |- *.
intro.
generalize (H2 (inv_op o) M N H M0 H7 N0).
tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
simpl in |- *.
cut (synthesis h M0 N0).
intro.
intro.
cut (synthesis h (MEnc M K) (MEnc N L)).
intro.
apply (H4bis M0 N0 H5 (MEnc M K) (MEnc N L) H7 H6).

*****
H6 : eq M0 (MEnc M K)
H5 : synthesis h M0 N0
H : h M0 N0
M0,N0 : Msg
HrecH5_0 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M' (inv K)),\neq N' (inv L)
HrecH5_1 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M' (inv M)),\neq N' (inv N)
H5_0 : synthesis h K L
H5_1 : synthesis h M N
M,N,K,L : Msg
H4bis : forall (M N : Msg) (_ : synthesis h M N) (M' N' : Msg)\n (_ : synthesis h M' N') (_ : eq M M'), eq N N'
H4 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M' (inv M)), eq N' (inv N)
H3 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H2 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H1 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H0 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
synthesis h (MEnc M K) (MEnc N L)
+++++
apply SynEnc; trivial.
-----
Theorem inj_inv_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_inv_left h -> injective_inv_left (synthesis h).
intro h.
intros H0 H1 H2 H3 H4.
generalize (inj_left_syn h H0 H1 H2 H3).
intro H4bis.
unfold injective_left in H0.
unfold enc_synthesis_left in H1.
unfold op_synthesis_left in H2.
unfold pair_free_left in H3.
unfold injective_inv_left in H4.
unfold injective_left in H4bis.
unfold injective_inv_left in |- *.
intros M N H5.
induction H5 as [M N H| M N K L H5_1 HrecH5_1 H5_0 HrecH5_0| M1 N1 M2 N2 H5_1 HrecH5_1 H5_0 HrecH5_0| o M N H5 HrecH5]; intros M' N' H6; [ induction H6 as [M0 N0 H5| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K0 L0 H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M N H| M N K L H6_1 HrecH6_1 H6_0 HrecH6_0| M0 N0 M3 N3 H6_1 HrecH6_1 H6_0 HrecH6_0| o M N H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o0 M0 N0 H6 HrecH6] ].
intro.
apply (H4 M N H M0 N0 H5 H6).
intro.
cut (M = inv (MEnc M0 K)).
simpl in |- *.
intro.
case (H1 M N H M0 K H6 N0 L); intro; tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (MPair M1 M2)).
simpl in |- *.
intro.
rewrite H6 in H.
generalize (H3 M1 M2 N).
tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (Mop o M0)).
simpl in |- *.
intro.
generalize (H2 (inv_op o) M N H M0 H7 N0).
tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
simpl in |- *.
cut (synthesis h M0 N0).
intro.
intro.
cut (synthesis h (MEnc M K) (MEnc N L)).
intro.
apply (H4bis M0 N0 H5 (MEnc M K) (MEnc N L) H7 H6).
apply SynEnc; trivial.

*****
H : h M0 N0
M0,N0 : Msg
HrecH5_0 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M' (inv K)),\neq N' (inv L)
HrecH5_1 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M' (inv M)),\neq N' (inv N)
H5_0 : synthesis h K L
H5_1 : synthesis h M N
M,N,K,L : Msg
H4bis : forall (M N : Msg) (_ : synthesis h M N) (M' N' : Msg)\n (_ : synthesis h M' N') (_ : eq M M'), eq N N'
H4 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M' (inv M)), eq N' (inv N)
H3 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H2 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H1 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H0 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
synthesis h M0 N0
+++++
apply SynInc; trivial.
-----
Theorem inj_inv_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_inv_left h -> injective_inv_left (synthesis h).
intro h.
intros H0 H1 H2 H3 H4.
generalize (inj_left_syn h H0 H1 H2 H3).
intro H4bis.
unfold injective_left in H0.
unfold enc_synthesis_left in H1.
unfold op_synthesis_left in H2.
unfold pair_free_left in H3.
unfold injective_inv_left in H4.
unfold injective_left in H4bis.
unfold injective_inv_left in |- *.
intros M N H5.
induction H5 as [M N H| M N K L H5_1 HrecH5_1 H5_0 HrecH5_0| M1 N1 M2 N2 H5_1 HrecH5_1 H5_0 HrecH5_0| o M N H5 HrecH5]; intros M' N' H6; [ induction H6 as [M0 N0 H5| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K0 L0 H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M N H| M N K L H6_1 HrecH6_1 H6_0 HrecH6_0| M0 N0 M3 N3 H6_1 HrecH6_1 H6_0 HrecH6_0| o M N H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o0 M0 N0 H6 HrecH6] ].
intro.
apply (H4 M N H M0 N0 H5 H6).
intro.
cut (M = inv (MEnc M0 K)).
simpl in |- *.
intro.
case (H1 M N H M0 K H6 N0 L); intro; tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (MPair M1 M2)).
simpl in |- *.
intro.
rewrite H6 in H.
generalize (H3 M1 M2 N).
tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (Mop o M0)).
simpl in |- *.
intro.
generalize (H2 (inv_op o) M N H M0 H7 N0).
tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
simpl in |- *.
cut (synthesis h M0 N0).
intro.
intro.
cut (synthesis h (MEnc M K) (MEnc N L)).
intro.
apply (H4bis M0 N0 H5 (MEnc M K) (MEnc N L) H7 H6).
apply SynEnc; trivial.
apply SynInc; trivial.

*****
HrecH6_0 : forall _ : eq K0 (inv (MEnc M K)), eq L0 (inv (MEnc N L))
HrecH6_1 : forall _ : eq M0 (inv (MEnc M K)), eq N0 (inv (MEnc N L))
H6_0 : synthesis h K0 L0
H6_1 : synthesis h M0 N0
M0,N0,K0,L0 : Msg
HrecH5_0 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M' (inv K)),\neq N' (inv L)
HrecH5_1 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M' (inv M)),\neq N' (inv N)
H5_0 : synthesis h K L
H5_1 : synthesis h M N
M,N,K,L : Msg
H4bis : forall (M N : Msg) (_ : synthesis h M N) (M' N' : Msg)\n (_ : synthesis h M' N') (_ : eq M M'), eq N N'
H4 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M' (inv M)), eq N' (inv N)
H3 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H2 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H1 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H0 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
forall _ : eq (MEnc M0 K0) (inv (MEnc M K)), eq (MEnc N0 L0) (inv (MEnc N L))
+++++
simpl in |- *.
-----
Theorem inj_inv_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_inv_left h -> injective_inv_left (synthesis h).
intro h.
intros H0 H1 H2 H3 H4.
generalize (inj_left_syn h H0 H1 H2 H3).
intro H4bis.
unfold injective_left in H0.
unfold enc_synthesis_left in H1.
unfold op_synthesis_left in H2.
unfold pair_free_left in H3.
unfold injective_inv_left in H4.
unfold injective_left in H4bis.
unfold injective_inv_left in |- *.
intros M N H5.
induction H5 as [M N H| M N K L H5_1 HrecH5_1 H5_0 HrecH5_0| M1 N1 M2 N2 H5_1 HrecH5_1 H5_0 HrecH5_0| o M N H5 HrecH5]; intros M' N' H6; [ induction H6 as [M0 N0 H5| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K0 L0 H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M N H| M N K L H6_1 HrecH6_1 H6_0 HrecH6_0| M0 N0 M3 N3 H6_1 HrecH6_1 H6_0 HrecH6_0| o M N H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o0 M0 N0 H6 HrecH6] ].
intro.
apply (H4 M N H M0 N0 H5 H6).
intro.
cut (M = inv (MEnc M0 K)).
simpl in |- *.
intro.
case (H1 M N H M0 K H6 N0 L); intro; tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (MPair M1 M2)).
simpl in |- *.
intro.
rewrite H6 in H.
generalize (H3 M1 M2 N).
tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (Mop o M0)).
simpl in |- *.
intro.
generalize (H2 (inv_op o) M N H M0 H7 N0).
tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
simpl in |- *.
cut (synthesis h M0 N0).
intro.
intro.
cut (synthesis h (MEnc M K) (MEnc N L)).
intro.
apply (H4bis M0 N0 H5 (MEnc M K) (MEnc N L) H7 H6).
apply SynEnc; trivial.
apply SynInc; trivial.
simpl in |- *.

*****
HrecH6_0 : forall _ : eq K0 (inv (MEnc M K)), eq L0 (inv (MEnc N L))
HrecH6_1 : forall _ : eq M0 (inv (MEnc M K)), eq N0 (inv (MEnc N L))
H6_0 : synthesis h K0 L0
H6_1 : synthesis h M0 N0
M0,N0,K0,L0 : Msg
HrecH5_0 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M' (inv K)),\neq N' (inv L)
HrecH5_1 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M' (inv M)),\neq N' (inv N)
H5_0 : synthesis h K L
H5_1 : synthesis h M N
M,N,K,L : Msg
H4bis : forall (M N : Msg) (_ : synthesis h M N) (M' N' : Msg)\n (_ : synthesis h M' N') (_ : eq M M'), eq N N'
H4 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M' (inv M)), eq N' (inv N)
H3 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H2 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H1 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H0 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
forall _ : eq (MEnc M0 K0) (MEnc M K), eq (MEnc N0 L0) (MEnc N L)
+++++
intro.
-----
Theorem inj_inv_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_inv_left h -> injective_inv_left (synthesis h).
intro h.
intros H0 H1 H2 H3 H4.
generalize (inj_left_syn h H0 H1 H2 H3).
intro H4bis.
unfold injective_left in H0.
unfold enc_synthesis_left in H1.
unfold op_synthesis_left in H2.
unfold pair_free_left in H3.
unfold injective_inv_left in H4.
unfold injective_left in H4bis.
unfold injective_inv_left in |- *.
intros M N H5.
induction H5 as [M N H| M N K L H5_1 HrecH5_1 H5_0 HrecH5_0| M1 N1 M2 N2 H5_1 HrecH5_1 H5_0 HrecH5_0| o M N H5 HrecH5]; intros M' N' H6; [ induction H6 as [M0 N0 H5| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K0 L0 H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M N H| M N K L H6_1 HrecH6_1 H6_0 HrecH6_0| M0 N0 M3 N3 H6_1 HrecH6_1 H6_0 HrecH6_0| o M N H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o0 M0 N0 H6 HrecH6] ].
intro.
apply (H4 M N H M0 N0 H5 H6).
intro.
cut (M = inv (MEnc M0 K)).
simpl in |- *.
intro.
case (H1 M N H M0 K H6 N0 L); intro; tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (MPair M1 M2)).
simpl in |- *.
intro.
rewrite H6 in H.
generalize (H3 M1 M2 N).
tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (Mop o M0)).
simpl in |- *.
intro.
generalize (H2 (inv_op o) M N H M0 H7 N0).
tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
simpl in |- *.
cut (synthesis h M0 N0).
intro.
intro.
cut (synthesis h (MEnc M K) (MEnc N L)).
intro.
apply (H4bis M0 N0 H5 (MEnc M K) (MEnc N L) H7 H6).
apply SynEnc; trivial.
apply SynInc; trivial.
simpl in |- *.
intro.

*****
H : eq (MEnc M0 K0) (MEnc M K)
HrecH6_0 : forall _ : eq K0 (inv (MEnc M K)), eq L0 (inv (MEnc N L))
HrecH6_1 : forall _ : eq M0 (inv (MEnc M K)), eq N0 (inv (MEnc N L))
H6_0 : synthesis h K0 L0
H6_1 : synthesis h M0 N0
M0,N0,K0,L0 : Msg
HrecH5_0 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M' (inv K)),\neq N' (inv L)
HrecH5_1 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M' (inv M)),\neq N' (inv N)
H5_0 : synthesis h K L
H5_1 : synthesis h M N
M,N,K,L : Msg
H4bis : forall (M N : Msg) (_ : synthesis h M N) (M' N' : Msg)\n (_ : synthesis h M' N') (_ : eq M M'), eq N N'
H4 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M' (inv M)), eq N' (inv N)
H3 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H2 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H1 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H0 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
eq (MEnc N0 L0) (MEnc N L)
+++++
inversion H.
-----
Theorem inj_inv_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_inv_left h -> injective_inv_left (synthesis h).
intro h.
intros H0 H1 H2 H3 H4.
generalize (inj_left_syn h H0 H1 H2 H3).
intro H4bis.
unfold injective_left in H0.
unfold enc_synthesis_left in H1.
unfold op_synthesis_left in H2.
unfold pair_free_left in H3.
unfold injective_inv_left in H4.
unfold injective_left in H4bis.
unfold injective_inv_left in |- *.
intros M N H5.
induction H5 as [M N H| M N K L H5_1 HrecH5_1 H5_0 HrecH5_0| M1 N1 M2 N2 H5_1 HrecH5_1 H5_0 HrecH5_0| o M N H5 HrecH5]; intros M' N' H6; [ induction H6 as [M0 N0 H5| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K0 L0 H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M N H| M N K L H6_1 HrecH6_1 H6_0 HrecH6_0| M0 N0 M3 N3 H6_1 HrecH6_1 H6_0 HrecH6_0| o M N H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o0 M0 N0 H6 HrecH6] ].
intro.
apply (H4 M N H M0 N0 H5 H6).
intro.
cut (M = inv (MEnc M0 K)).
simpl in |- *.
intro.
case (H1 M N H M0 K H6 N0 L); intro; tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (MPair M1 M2)).
simpl in |- *.
intro.
rewrite H6 in H.
generalize (H3 M1 M2 N).
tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (Mop o M0)).
simpl in |- *.
intro.
generalize (H2 (inv_op o) M N H M0 H7 N0).
tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
simpl in |- *.
cut (synthesis h M0 N0).
intro.
intro.
cut (synthesis h (MEnc M K) (MEnc N L)).
intro.
apply (H4bis M0 N0 H5 (MEnc M K) (MEnc N L) H7 H6).
apply SynEnc; trivial.
apply SynInc; trivial.
simpl in |- *.
intro.
inversion H.

*****
H7 : eq K0 K
H6 : eq M0 M
H : eq (MEnc M0 K0) (MEnc M K)
HrecH6_0 : forall _ : eq K0 (inv (MEnc M K)), eq L0 (inv (MEnc N L))
HrecH6_1 : forall _ : eq M0 (inv (MEnc M K)), eq N0 (inv (MEnc N L))
H6_0 : synthesis h K0 L0
H6_1 : synthesis h M0 N0
M0,N0,K0,L0 : Msg
HrecH5_0 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M' (inv K)),\neq N' (inv L)
HrecH5_1 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M' (inv M)),\neq N' (inv N)
H5_0 : synthesis h K L
H5_1 : synthesis h M N
M,N,K,L : Msg
H4bis : forall (M N : Msg) (_ : synthesis h M N) (M' N' : Msg)\n (_ : synthesis h M' N') (_ : eq M M'), eq N N'
H4 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M' (inv M)), eq N' (inv N)
H3 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H2 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H1 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H0 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
eq (MEnc N0 L0) (MEnc N L)
+++++
cut (synthesis h (MEnc M0 K0) (MEnc N0 L0)); try (apply SynEnc; trivial).
-----
Theorem inj_inv_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_inv_left h -> injective_inv_left (synthesis h).
intro h.
intros H0 H1 H2 H3 H4.
generalize (inj_left_syn h H0 H1 H2 H3).
intro H4bis.
unfold injective_left in H0.
unfold enc_synthesis_left in H1.
unfold op_synthesis_left in H2.
unfold pair_free_left in H3.
unfold injective_inv_left in H4.
unfold injective_left in H4bis.
unfold injective_inv_left in |- *.
intros M N H5.
induction H5 as [M N H| M N K L H5_1 HrecH5_1 H5_0 HrecH5_0| M1 N1 M2 N2 H5_1 HrecH5_1 H5_0 HrecH5_0| o M N H5 HrecH5]; intros M' N' H6; [ induction H6 as [M0 N0 H5| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K0 L0 H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M N H| M N K L H6_1 HrecH6_1 H6_0 HrecH6_0| M0 N0 M3 N3 H6_1 HrecH6_1 H6_0 HrecH6_0| o M N H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o0 M0 N0 H6 HrecH6] ].
intro.
apply (H4 M N H M0 N0 H5 H6).
intro.
cut (M = inv (MEnc M0 K)).
simpl in |- *.
intro.
case (H1 M N H M0 K H6 N0 L); intro; tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (MPair M1 M2)).
simpl in |- *.
intro.
rewrite H6 in H.
generalize (H3 M1 M2 N).
tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (Mop o M0)).
simpl in |- *.
intro.
generalize (H2 (inv_op o) M N H M0 H7 N0).
tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
simpl in |- *.
cut (synthesis h M0 N0).
intro.
intro.
cut (synthesis h (MEnc M K) (MEnc N L)).
intro.
apply (H4bis M0 N0 H5 (MEnc M K) (MEnc N L) H7 H6).
apply SynEnc; trivial.
apply SynInc; trivial.
simpl in |- *.
intro.
inversion H.
cut (synthesis h (MEnc M0 K0) (MEnc N0 L0)); try (apply SynEnc; trivial).

*****
H7 : eq K0 K
H6 : eq M0 M
H : eq (MEnc M0 K0) (MEnc M K)
HrecH6_0 : forall _ : eq K0 (inv (MEnc M K)), eq L0 (inv (MEnc N L))
HrecH6_1 : forall _ : eq M0 (inv (MEnc M K)), eq N0 (inv (MEnc N L))
H6_0 : synthesis h K0 L0
H6_1 : synthesis h M0 N0
M0,N0,K0,L0 : Msg
HrecH5_0 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M' (inv K)),\neq N' (inv L)
HrecH5_1 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M' (inv M)),\neq N' (inv N)
H5_0 : synthesis h K L
H5_1 : synthesis h M N
M,N,K,L : Msg
H4bis : forall (M N : Msg) (_ : synthesis h M N) (M' N' : Msg)\n (_ : synthesis h M' N') (_ : eq M M'), eq N N'
H4 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M' (inv M)), eq N' (inv N)
H3 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H2 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H1 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H0 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
forall _ : synthesis h (MEnc M0 K0) (MEnc N0 L0), eq (MEnc N0 L0) (MEnc N L)
+++++
intro.
-----
Theorem inj_inv_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_inv_left h -> injective_inv_left (synthesis h).
intro h.
intros H0 H1 H2 H3 H4.
generalize (inj_left_syn h H0 H1 H2 H3).
intro H4bis.
unfold injective_left in H0.
unfold enc_synthesis_left in H1.
unfold op_synthesis_left in H2.
unfold pair_free_left in H3.
unfold injective_inv_left in H4.
unfold injective_left in H4bis.
unfold injective_inv_left in |- *.
intros M N H5.
induction H5 as [M N H| M N K L H5_1 HrecH5_1 H5_0 HrecH5_0| M1 N1 M2 N2 H5_1 HrecH5_1 H5_0 HrecH5_0| o M N H5 HrecH5]; intros M' N' H6; [ induction H6 as [M0 N0 H5| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K0 L0 H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M N H| M N K L H6_1 HrecH6_1 H6_0 HrecH6_0| M0 N0 M3 N3 H6_1 HrecH6_1 H6_0 HrecH6_0| o M N H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o0 M0 N0 H6 HrecH6] ].
intro.
apply (H4 M N H M0 N0 H5 H6).
intro.
cut (M = inv (MEnc M0 K)).
simpl in |- *.
intro.
case (H1 M N H M0 K H6 N0 L); intro; tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (MPair M1 M2)).
simpl in |- *.
intro.
rewrite H6 in H.
generalize (H3 M1 M2 N).
tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (Mop o M0)).
simpl in |- *.
intro.
generalize (H2 (inv_op o) M N H M0 H7 N0).
tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
simpl in |- *.
cut (synthesis h M0 N0).
intro.
intro.
cut (synthesis h (MEnc M K) (MEnc N L)).
intro.
apply (H4bis M0 N0 H5 (MEnc M K) (MEnc N L) H7 H6).
apply SynEnc; trivial.
apply SynInc; trivial.
simpl in |- *.
intro.
inversion H.
cut (synthesis h (MEnc M0 K0) (MEnc N0 L0)); try (apply SynEnc; trivial).
intro.

*****
H5 : synthesis h (MEnc M0 K0) (MEnc N0 L0)
H7 : eq K0 K
H6 : eq M0 M
H : eq (MEnc M0 K0) (MEnc M K)
HrecH6_0 : forall _ : eq K0 (inv (MEnc M K)), eq L0 (inv (MEnc N L))
HrecH6_1 : forall _ : eq M0 (inv (MEnc M K)), eq N0 (inv (MEnc N L))
H6_0 : synthesis h K0 L0
H6_1 : synthesis h M0 N0
M0,N0,K0,L0 : Msg
HrecH5_0 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M' (inv K)),\neq N' (inv L)
HrecH5_1 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M' (inv M)),\neq N' (inv N)
H5_0 : synthesis h K L
H5_1 : synthesis h M N
M,N,K,L : Msg
H4bis : forall (M N : Msg) (_ : synthesis h M N) (M' N' : Msg)\n (_ : synthesis h M' N') (_ : eq M M'), eq N N'
H4 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M' (inv M)), eq N' (inv N)
H3 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H2 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H1 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H0 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
eq (MEnc N0 L0) (MEnc N L)
+++++
cut (synthesis h (MEnc M K) (MEnc N L)); try (apply SynEnc; trivial).
-----
Theorem inj_inv_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_inv_left h -> injective_inv_left (synthesis h).
intro h.
intros H0 H1 H2 H3 H4.
generalize (inj_left_syn h H0 H1 H2 H3).
intro H4bis.
unfold injective_left in H0.
unfold enc_synthesis_left in H1.
unfold op_synthesis_left in H2.
unfold pair_free_left in H3.
unfold injective_inv_left in H4.
unfold injective_left in H4bis.
unfold injective_inv_left in |- *.
intros M N H5.
induction H5 as [M N H| M N K L H5_1 HrecH5_1 H5_0 HrecH5_0| M1 N1 M2 N2 H5_1 HrecH5_1 H5_0 HrecH5_0| o M N H5 HrecH5]; intros M' N' H6; [ induction H6 as [M0 N0 H5| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K0 L0 H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M N H| M N K L H6_1 HrecH6_1 H6_0 HrecH6_0| M0 N0 M3 N3 H6_1 HrecH6_1 H6_0 HrecH6_0| o M N H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o0 M0 N0 H6 HrecH6] ].
intro.
apply (H4 M N H M0 N0 H5 H6).
intro.
cut (M = inv (MEnc M0 K)).
simpl in |- *.
intro.
case (H1 M N H M0 K H6 N0 L); intro; tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (MPair M1 M2)).
simpl in |- *.
intro.
rewrite H6 in H.
generalize (H3 M1 M2 N).
tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (Mop o M0)).
simpl in |- *.
intro.
generalize (H2 (inv_op o) M N H M0 H7 N0).
tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
simpl in |- *.
cut (synthesis h M0 N0).
intro.
intro.
cut (synthesis h (MEnc M K) (MEnc N L)).
intro.
apply (H4bis M0 N0 H5 (MEnc M K) (MEnc N L) H7 H6).
apply SynEnc; trivial.
apply SynInc; trivial.
simpl in |- *.
intro.
inversion H.
cut (synthesis h (MEnc M0 K0) (MEnc N0 L0)); try (apply SynEnc; trivial).
intro.
cut (synthesis h (MEnc M K) (MEnc N L)); try (apply SynEnc; trivial).

*****
H5 : synthesis h (MEnc M0 K0) (MEnc N0 L0)
H7 : eq K0 K
H6 : eq M0 M
H : eq (MEnc M0 K0) (MEnc M K)
HrecH6_0 : forall _ : eq K0 (inv (MEnc M K)), eq L0 (inv (MEnc N L))
HrecH6_1 : forall _ : eq M0 (inv (MEnc M K)), eq N0 (inv (MEnc N L))
H6_0 : synthesis h K0 L0
H6_1 : synthesis h M0 N0
M0,N0,K0,L0 : Msg
HrecH5_0 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M' (inv K)),\neq N' (inv L)
HrecH5_1 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M' (inv M)),\neq N' (inv N)
H5_0 : synthesis h K L
H5_1 : synthesis h M N
M,N,K,L : Msg
H4bis : forall (M N : Msg) (_ : synthesis h M N) (M' N' : Msg)\n (_ : synthesis h M' N') (_ : eq M M'), eq N N'
H4 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M' (inv M)), eq N' (inv N)
H3 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H2 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H1 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H0 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
forall _ : synthesis h (MEnc M K) (MEnc N L), eq (MEnc N0 L0) (MEnc N L)
+++++
intro.
-----
Theorem inj_inv_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_inv_left h -> injective_inv_left (synthesis h).
intro h.
intros H0 H1 H2 H3 H4.
generalize (inj_left_syn h H0 H1 H2 H3).
intro H4bis.
unfold injective_left in H0.
unfold enc_synthesis_left in H1.
unfold op_synthesis_left in H2.
unfold pair_free_left in H3.
unfold injective_inv_left in H4.
unfold injective_left in H4bis.
unfold injective_inv_left in |- *.
intros M N H5.
induction H5 as [M N H| M N K L H5_1 HrecH5_1 H5_0 HrecH5_0| M1 N1 M2 N2 H5_1 HrecH5_1 H5_0 HrecH5_0| o M N H5 HrecH5]; intros M' N' H6; [ induction H6 as [M0 N0 H5| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K0 L0 H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M N H| M N K L H6_1 HrecH6_1 H6_0 HrecH6_0| M0 N0 M3 N3 H6_1 HrecH6_1 H6_0 HrecH6_0| o M N H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o0 M0 N0 H6 HrecH6] ].
intro.
apply (H4 M N H M0 N0 H5 H6).
intro.
cut (M = inv (MEnc M0 K)).
simpl in |- *.
intro.
case (H1 M N H M0 K H6 N0 L); intro; tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (MPair M1 M2)).
simpl in |- *.
intro.
rewrite H6 in H.
generalize (H3 M1 M2 N).
tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (Mop o M0)).
simpl in |- *.
intro.
generalize (H2 (inv_op o) M N H M0 H7 N0).
tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
simpl in |- *.
cut (synthesis h M0 N0).
intro.
intro.
cut (synthesis h (MEnc M K) (MEnc N L)).
intro.
apply (H4bis M0 N0 H5 (MEnc M K) (MEnc N L) H7 H6).
apply SynEnc; trivial.
apply SynInc; trivial.
simpl in |- *.
intro.
inversion H.
cut (synthesis h (MEnc M0 K0) (MEnc N0 L0)); try (apply SynEnc; trivial).
intro.
cut (synthesis h (MEnc M K) (MEnc N L)); try (apply SynEnc; trivial).
intro.

*****
H8 : synthesis h (MEnc M K) (MEnc N L)
H5 : synthesis h (MEnc M0 K0) (MEnc N0 L0)
H7 : eq K0 K
H6 : eq M0 M
H : eq (MEnc M0 K0) (MEnc M K)
HrecH6_0 : forall _ : eq K0 (inv (MEnc M K)), eq L0 (inv (MEnc N L))
HrecH6_1 : forall _ : eq M0 (inv (MEnc M K)), eq N0 (inv (MEnc N L))
H6_0 : synthesis h K0 L0
H6_1 : synthesis h M0 N0
M0,N0,K0,L0 : Msg
HrecH5_0 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M' (inv K)),\neq N' (inv L)
HrecH5_1 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M' (inv M)),\neq N' (inv N)
H5_0 : synthesis h K L
H5_1 : synthesis h M N
M,N,K,L : Msg
H4bis : forall (M N : Msg) (_ : synthesis h M N) (M' N' : Msg)\n (_ : synthesis h M' N') (_ : eq M M'), eq N N'
H4 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M' (inv M)), eq N' (inv N)
H3 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H2 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H1 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H0 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
eq (MEnc N0 L0) (MEnc N L)
+++++
apply (H4bis (MEnc M0 K0) (MEnc N0 L0) H5 (MEnc M K) (MEnc N L) H8 H).
-----
Theorem inj_inv_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_inv_left h -> injective_inv_left (synthesis h).
intro h.
intros H0 H1 H2 H3 H4.
generalize (inj_left_syn h H0 H1 H2 H3).
intro H4bis.
unfold injective_left in H0.
unfold enc_synthesis_left in H1.
unfold op_synthesis_left in H2.
unfold pair_free_left in H3.
unfold injective_inv_left in H4.
unfold injective_left in H4bis.
unfold injective_inv_left in |- *.
intros M N H5.
induction H5 as [M N H| M N K L H5_1 HrecH5_1 H5_0 HrecH5_0| M1 N1 M2 N2 H5_1 HrecH5_1 H5_0 HrecH5_0| o M N H5 HrecH5]; intros M' N' H6; [ induction H6 as [M0 N0 H5| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K0 L0 H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M N H| M N K L H6_1 HrecH6_1 H6_0 HrecH6_0| M0 N0 M3 N3 H6_1 HrecH6_1 H6_0 HrecH6_0| o M N H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o0 M0 N0 H6 HrecH6] ].
intro.
apply (H4 M N H M0 N0 H5 H6).
intro.
cut (M = inv (MEnc M0 K)).
simpl in |- *.
intro.
case (H1 M N H M0 K H6 N0 L); intro; tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (MPair M1 M2)).
simpl in |- *.
intro.
rewrite H6 in H.
generalize (H3 M1 M2 N).
tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (Mop o M0)).
simpl in |- *.
intro.
generalize (H2 (inv_op o) M N H M0 H7 N0).
tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
simpl in |- *.
cut (synthesis h M0 N0).
intro.
intro.
cut (synthesis h (MEnc M K) (MEnc N L)).
intro.
apply (H4bis M0 N0 H5 (MEnc M K) (MEnc N L) H7 H6).
apply SynEnc; trivial.
apply SynInc; trivial.
simpl in |- *.
intro.
inversion H.
cut (synthesis h (MEnc M0 K0) (MEnc N0 L0)); try (apply SynEnc; trivial).
intro.
cut (synthesis h (MEnc M K) (MEnc N L)); try (apply SynEnc; trivial).
intro.
apply (H4bis (MEnc M0 K0) (MEnc N0 L0) H5 (MEnc M K) (MEnc N L) H8 H).

*****
HrecH6_0 : forall _ : eq M2 (inv (MEnc M K)), eq N2 (inv (MEnc N L))
HrecH6_1 : forall _ : eq M1 (inv (MEnc M K)), eq N1 (inv (MEnc N L))
H6_0 : synthesis h M2 N2
H6_1 : synthesis h M1 N1
M1,N1,M2,N2 : Msg
HrecH5_0 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M' (inv K)),\neq N' (inv L)
HrecH5_1 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M' (inv M)),\neq N' (inv N)
H5_0 : synthesis h K L
H5_1 : synthesis h M N
M,N,K,L : Msg
H4bis : forall (M N : Msg) (_ : synthesis h M N) (M' N' : Msg)\n (_ : synthesis h M' N') (_ : eq M M'), eq N N'
H4 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M' (inv M)), eq N' (inv N)
H3 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H2 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H1 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H0 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
forall _ : eq (MPair M1 M2) (inv (MEnc M K)), eq (MPair N1 N2) (inv (MEnc N L))
+++++
simpl in |- *.
-----
Theorem inj_inv_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_inv_left h -> injective_inv_left (synthesis h).
intro h.
intros H0 H1 H2 H3 H4.
generalize (inj_left_syn h H0 H1 H2 H3).
intro H4bis.
unfold injective_left in H0.
unfold enc_synthesis_left in H1.
unfold op_synthesis_left in H2.
unfold pair_free_left in H3.
unfold injective_inv_left in H4.
unfold injective_left in H4bis.
unfold injective_inv_left in |- *.
intros M N H5.
induction H5 as [M N H| M N K L H5_1 HrecH5_1 H5_0 HrecH5_0| M1 N1 M2 N2 H5_1 HrecH5_1 H5_0 HrecH5_0| o M N H5 HrecH5]; intros M' N' H6; [ induction H6 as [M0 N0 H5| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K0 L0 H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M N H| M N K L H6_1 HrecH6_1 H6_0 HrecH6_0| M0 N0 M3 N3 H6_1 HrecH6_1 H6_0 HrecH6_0| o M N H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o0 M0 N0 H6 HrecH6] ].
intro.
apply (H4 M N H M0 N0 H5 H6).
intro.
cut (M = inv (MEnc M0 K)).
simpl in |- *.
intro.
case (H1 M N H M0 K H6 N0 L); intro; tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (MPair M1 M2)).
simpl in |- *.
intro.
rewrite H6 in H.
generalize (H3 M1 M2 N).
tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (Mop o M0)).
simpl in |- *.
intro.
generalize (H2 (inv_op o) M N H M0 H7 N0).
tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
simpl in |- *.
cut (synthesis h M0 N0).
intro.
intro.
cut (synthesis h (MEnc M K) (MEnc N L)).
intro.
apply (H4bis M0 N0 H5 (MEnc M K) (MEnc N L) H7 H6).
apply SynEnc; trivial.
apply SynInc; trivial.
simpl in |- *.
intro.
inversion H.
cut (synthesis h (MEnc M0 K0) (MEnc N0 L0)); try (apply SynEnc; trivial).
intro.
cut (synthesis h (MEnc M K) (MEnc N L)); try (apply SynEnc; trivial).
intro.
apply (H4bis (MEnc M0 K0) (MEnc N0 L0) H5 (MEnc M K) (MEnc N L) H8 H).
simpl in |- *.

*****
HrecH6_0 : forall _ : eq M2 (inv (MEnc M K)), eq N2 (inv (MEnc N L))
HrecH6_1 : forall _ : eq M1 (inv (MEnc M K)), eq N1 (inv (MEnc N L))
H6_0 : synthesis h M2 N2
H6_1 : synthesis h M1 N1
M1,N1,M2,N2 : Msg
HrecH5_0 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M' (inv K)),\neq N' (inv L)
HrecH5_1 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M' (inv M)),\neq N' (inv N)
H5_0 : synthesis h K L
H5_1 : synthesis h M N
M,N,K,L : Msg
H4bis : forall (M N : Msg) (_ : synthesis h M N) (M' N' : Msg)\n (_ : synthesis h M' N') (_ : eq M M'), eq N N'
H4 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M' (inv M)), eq N' (inv N)
H3 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H2 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H1 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H0 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
forall _ : eq (MPair M1 M2) (MEnc M K), eq (MPair N1 N2) (MEnc N L)
+++++
intro.
-----
Theorem inj_inv_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_inv_left h -> injective_inv_left (synthesis h).
intro h.
intros H0 H1 H2 H3 H4.
generalize (inj_left_syn h H0 H1 H2 H3).
intro H4bis.
unfold injective_left in H0.
unfold enc_synthesis_left in H1.
unfold op_synthesis_left in H2.
unfold pair_free_left in H3.
unfold injective_inv_left in H4.
unfold injective_left in H4bis.
unfold injective_inv_left in |- *.
intros M N H5.
induction H5 as [M N H| M N K L H5_1 HrecH5_1 H5_0 HrecH5_0| M1 N1 M2 N2 H5_1 HrecH5_1 H5_0 HrecH5_0| o M N H5 HrecH5]; intros M' N' H6; [ induction H6 as [M0 N0 H5| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K0 L0 H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M N H| M N K L H6_1 HrecH6_1 H6_0 HrecH6_0| M0 N0 M3 N3 H6_1 HrecH6_1 H6_0 HrecH6_0| o M N H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o0 M0 N0 H6 HrecH6] ].
intro.
apply (H4 M N H M0 N0 H5 H6).
intro.
cut (M = inv (MEnc M0 K)).
simpl in |- *.
intro.
case (H1 M N H M0 K H6 N0 L); intro; tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (MPair M1 M2)).
simpl in |- *.
intro.
rewrite H6 in H.
generalize (H3 M1 M2 N).
tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (Mop o M0)).
simpl in |- *.
intro.
generalize (H2 (inv_op o) M N H M0 H7 N0).
tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
simpl in |- *.
cut (synthesis h M0 N0).
intro.
intro.
cut (synthesis h (MEnc M K) (MEnc N L)).
intro.
apply (H4bis M0 N0 H5 (MEnc M K) (MEnc N L) H7 H6).
apply SynEnc; trivial.
apply SynInc; trivial.
simpl in |- *.
intro.
inversion H.
cut (synthesis h (MEnc M0 K0) (MEnc N0 L0)); try (apply SynEnc; trivial).
intro.
cut (synthesis h (MEnc M K) (MEnc N L)); try (apply SynEnc; trivial).
intro.
apply (H4bis (MEnc M0 K0) (MEnc N0 L0) H5 (MEnc M K) (MEnc N L) H8 H).
simpl in |- *.
intro.

*****
H : eq (MPair M1 M2) (MEnc M K)
HrecH6_0 : forall _ : eq M2 (inv (MEnc M K)), eq N2 (inv (MEnc N L))
HrecH6_1 : forall _ : eq M1 (inv (MEnc M K)), eq N1 (inv (MEnc N L))
H6_0 : synthesis h M2 N2
H6_1 : synthesis h M1 N1
M1,N1,M2,N2 : Msg
HrecH5_0 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M' (inv K)),\neq N' (inv L)
HrecH5_1 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M' (inv M)),\neq N' (inv N)
H5_0 : synthesis h K L
H5_1 : synthesis h M N
M,N,K,L : Msg
H4bis : forall (M N : Msg) (_ : synthesis h M N) (M' N' : Msg)\n (_ : synthesis h M' N') (_ : eq M M'), eq N N'
H4 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M' (inv M)), eq N' (inv N)
H3 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H2 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H1 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H0 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
eq (MPair N1 N2) (MEnc N L)
+++++
inversion H.
-----
Theorem inj_inv_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_inv_left h -> injective_inv_left (synthesis h).
intro h.
intros H0 H1 H2 H3 H4.
generalize (inj_left_syn h H0 H1 H2 H3).
intro H4bis.
unfold injective_left in H0.
unfold enc_synthesis_left in H1.
unfold op_synthesis_left in H2.
unfold pair_free_left in H3.
unfold injective_inv_left in H4.
unfold injective_left in H4bis.
unfold injective_inv_left in |- *.
intros M N H5.
induction H5 as [M N H| M N K L H5_1 HrecH5_1 H5_0 HrecH5_0| M1 N1 M2 N2 H5_1 HrecH5_1 H5_0 HrecH5_0| o M N H5 HrecH5]; intros M' N' H6; [ induction H6 as [M0 N0 H5| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K0 L0 H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M N H| M N K L H6_1 HrecH6_1 H6_0 HrecH6_0| M0 N0 M3 N3 H6_1 HrecH6_1 H6_0 HrecH6_0| o M N H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o0 M0 N0 H6 HrecH6] ].
intro.
apply (H4 M N H M0 N0 H5 H6).
intro.
cut (M = inv (MEnc M0 K)).
simpl in |- *.
intro.
case (H1 M N H M0 K H6 N0 L); intro; tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (MPair M1 M2)).
simpl in |- *.
intro.
rewrite H6 in H.
generalize (H3 M1 M2 N).
tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (Mop o M0)).
simpl in |- *.
intro.
generalize (H2 (inv_op o) M N H M0 H7 N0).
tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
simpl in |- *.
cut (synthesis h M0 N0).
intro.
intro.
cut (synthesis h (MEnc M K) (MEnc N L)).
intro.
apply (H4bis M0 N0 H5 (MEnc M K) (MEnc N L) H7 H6).
apply SynEnc; trivial.
apply SynInc; trivial.
simpl in |- *.
intro.
inversion H.
cut (synthesis h (MEnc M0 K0) (MEnc N0 L0)); try (apply SynEnc; trivial).
intro.
cut (synthesis h (MEnc M K) (MEnc N L)); try (apply SynEnc; trivial).
intro.
apply (H4bis (MEnc M0 K0) (MEnc N0 L0) H5 (MEnc M K) (MEnc N L) H8 H).
simpl in |- *.
intro.
inversion H.

*****
HrecH6 : forall _ : eq M0 (inv (MEnc M K)), eq N0 (inv (MEnc N L))
H6 : synthesis h M0 N0
M0,N0 : Msg
o : op
HrecH5_0 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M' (inv K)),\neq N' (inv L)
HrecH5_1 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M' (inv M)),\neq N' (inv N)
H5_0 : synthesis h K L
H5_1 : synthesis h M N
M,N,K,L : Msg
H4bis : forall (M N : Msg) (_ : synthesis h M N) (M' N' : Msg)\n (_ : synthesis h M' N') (_ : eq M M'), eq N N'
H4 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M' (inv M)), eq N' (inv N)
H3 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H2 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H1 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H0 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
forall _ : eq (Mop o M0) (inv (MEnc M K)), eq (Mop o N0) (inv (MEnc N L))
+++++
simpl in |- *.
-----
Theorem inj_inv_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_inv_left h -> injective_inv_left (synthesis h).
intro h.
intros H0 H1 H2 H3 H4.
generalize (inj_left_syn h H0 H1 H2 H3).
intro H4bis.
unfold injective_left in H0.
unfold enc_synthesis_left in H1.
unfold op_synthesis_left in H2.
unfold pair_free_left in H3.
unfold injective_inv_left in H4.
unfold injective_left in H4bis.
unfold injective_inv_left in |- *.
intros M N H5.
induction H5 as [M N H| M N K L H5_1 HrecH5_1 H5_0 HrecH5_0| M1 N1 M2 N2 H5_1 HrecH5_1 H5_0 HrecH5_0| o M N H5 HrecH5]; intros M' N' H6; [ induction H6 as [M0 N0 H5| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K0 L0 H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M N H| M N K L H6_1 HrecH6_1 H6_0 HrecH6_0| M0 N0 M3 N3 H6_1 HrecH6_1 H6_0 HrecH6_0| o M N H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o0 M0 N0 H6 HrecH6] ].
intro.
apply (H4 M N H M0 N0 H5 H6).
intro.
cut (M = inv (MEnc M0 K)).
simpl in |- *.
intro.
case (H1 M N H M0 K H6 N0 L); intro; tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (MPair M1 M2)).
simpl in |- *.
intro.
rewrite H6 in H.
generalize (H3 M1 M2 N).
tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (Mop o M0)).
simpl in |- *.
intro.
generalize (H2 (inv_op o) M N H M0 H7 N0).
tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
simpl in |- *.
cut (synthesis h M0 N0).
intro.
intro.
cut (synthesis h (MEnc M K) (MEnc N L)).
intro.
apply (H4bis M0 N0 H5 (MEnc M K) (MEnc N L) H7 H6).
apply SynEnc; trivial.
apply SynInc; trivial.
simpl in |- *.
intro.
inversion H.
cut (synthesis h (MEnc M0 K0) (MEnc N0 L0)); try (apply SynEnc; trivial).
intro.
cut (synthesis h (MEnc M K) (MEnc N L)); try (apply SynEnc; trivial).
intro.
apply (H4bis (MEnc M0 K0) (MEnc N0 L0) H5 (MEnc M K) (MEnc N L) H8 H).
simpl in |- *.
intro.
inversion H.
simpl in |- *.

*****
HrecH6 : forall _ : eq M0 (inv (MEnc M K)), eq N0 (inv (MEnc N L))
H6 : synthesis h M0 N0
M0,N0 : Msg
o : op
HrecH5_0 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M' (inv K)),\neq N' (inv L)
HrecH5_1 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M' (inv M)),\neq N' (inv N)
H5_0 : synthesis h K L
H5_1 : synthesis h M N
M,N,K,L : Msg
H4bis : forall (M N : Msg) (_ : synthesis h M N) (M' N' : Msg)\n (_ : synthesis h M' N') (_ : eq M M'), eq N N'
H4 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M' (inv M)), eq N' (inv N)
H3 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H2 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H1 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H0 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
forall _ : eq (Mop o M0) (MEnc M K), eq (Mop o N0) (MEnc N L)
+++++
intro.
-----
Theorem inj_inv_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_inv_left h -> injective_inv_left (synthesis h).
intro h.
intros H0 H1 H2 H3 H4.
generalize (inj_left_syn h H0 H1 H2 H3).
intro H4bis.
unfold injective_left in H0.
unfold enc_synthesis_left in H1.
unfold op_synthesis_left in H2.
unfold pair_free_left in H3.
unfold injective_inv_left in H4.
unfold injective_left in H4bis.
unfold injective_inv_left in |- *.
intros M N H5.
induction H5 as [M N H| M N K L H5_1 HrecH5_1 H5_0 HrecH5_0| M1 N1 M2 N2 H5_1 HrecH5_1 H5_0 HrecH5_0| o M N H5 HrecH5]; intros M' N' H6; [ induction H6 as [M0 N0 H5| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K0 L0 H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M N H| M N K L H6_1 HrecH6_1 H6_0 HrecH6_0| M0 N0 M3 N3 H6_1 HrecH6_1 H6_0 HrecH6_0| o M N H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o0 M0 N0 H6 HrecH6] ].
intro.
apply (H4 M N H M0 N0 H5 H6).
intro.
cut (M = inv (MEnc M0 K)).
simpl in |- *.
intro.
case (H1 M N H M0 K H6 N0 L); intro; tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (MPair M1 M2)).
simpl in |- *.
intro.
rewrite H6 in H.
generalize (H3 M1 M2 N).
tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (Mop o M0)).
simpl in |- *.
intro.
generalize (H2 (inv_op o) M N H M0 H7 N0).
tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
simpl in |- *.
cut (synthesis h M0 N0).
intro.
intro.
cut (synthesis h (MEnc M K) (MEnc N L)).
intro.
apply (H4bis M0 N0 H5 (MEnc M K) (MEnc N L) H7 H6).
apply SynEnc; trivial.
apply SynInc; trivial.
simpl in |- *.
intro.
inversion H.
cut (synthesis h (MEnc M0 K0) (MEnc N0 L0)); try (apply SynEnc; trivial).
intro.
cut (synthesis h (MEnc M K) (MEnc N L)); try (apply SynEnc; trivial).
intro.
apply (H4bis (MEnc M0 K0) (MEnc N0 L0) H5 (MEnc M K) (MEnc N L) H8 H).
simpl in |- *.
intro.
inversion H.
simpl in |- *.
intro.

*****
H : eq (Mop o M0) (MEnc M K)
HrecH6 : forall _ : eq M0 (inv (MEnc M K)), eq N0 (inv (MEnc N L))
H6 : synthesis h M0 N0
M0,N0 : Msg
o : op
HrecH5_0 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M' (inv K)),\neq N' (inv L)
HrecH5_1 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M' (inv M)),\neq N' (inv N)
H5_0 : synthesis h K L
H5_1 : synthesis h M N
M,N,K,L : Msg
H4bis : forall (M N : Msg) (_ : synthesis h M N) (M' N' : Msg)\n (_ : synthesis h M' N') (_ : eq M M'), eq N N'
H4 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M' (inv M)), eq N' (inv N)
H3 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H2 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H1 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H0 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
eq (Mop o N0) (MEnc N L)
+++++
inversion H.
-----
Theorem inj_inv_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_inv_left h -> injective_inv_left (synthesis h).
intro h.
intros H0 H1 H2 H3 H4.
generalize (inj_left_syn h H0 H1 H2 H3).
intro H4bis.
unfold injective_left in H0.
unfold enc_synthesis_left in H1.
unfold op_synthesis_left in H2.
unfold pair_free_left in H3.
unfold injective_inv_left in H4.
unfold injective_left in H4bis.
unfold injective_inv_left in |- *.
intros M N H5.
induction H5 as [M N H| M N K L H5_1 HrecH5_1 H5_0 HrecH5_0| M1 N1 M2 N2 H5_1 HrecH5_1 H5_0 HrecH5_0| o M N H5 HrecH5]; intros M' N' H6; [ induction H6 as [M0 N0 H5| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K0 L0 H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M N H| M N K L H6_1 HrecH6_1 H6_0 HrecH6_0| M0 N0 M3 N3 H6_1 HrecH6_1 H6_0 HrecH6_0| o M N H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o0 M0 N0 H6 HrecH6] ].
intro.
apply (H4 M N H M0 N0 H5 H6).
intro.
cut (M = inv (MEnc M0 K)).
simpl in |- *.
intro.
case (H1 M N H M0 K H6 N0 L); intro; tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (MPair M1 M2)).
simpl in |- *.
intro.
rewrite H6 in H.
generalize (H3 M1 M2 N).
tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (Mop o M0)).
simpl in |- *.
intro.
generalize (H2 (inv_op o) M N H M0 H7 N0).
tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
simpl in |- *.
cut (synthesis h M0 N0).
intro.
intro.
cut (synthesis h (MEnc M K) (MEnc N L)).
intro.
apply (H4bis M0 N0 H5 (MEnc M K) (MEnc N L) H7 H6).
apply SynEnc; trivial.
apply SynInc; trivial.
simpl in |- *.
intro.
inversion H.
cut (synthesis h (MEnc M0 K0) (MEnc N0 L0)); try (apply SynEnc; trivial).
intro.
cut (synthesis h (MEnc M K) (MEnc N L)); try (apply SynEnc; trivial).
intro.
apply (H4bis (MEnc M0 K0) (MEnc N0 L0) H5 (MEnc M K) (MEnc N L) H8 H).
simpl in |- *.
intro.
inversion H.
simpl in |- *.
intro.
inversion H.

*****
H : h M N
M,N : Msg
HrecH5_0 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M' (inv M2)),\neq N' (inv N2)
HrecH5_1 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M' (inv M1)),\neq N' (inv N1)
H5_0 : synthesis h M2 N2
H5_1 : synthesis h M1 N1
M1,N1,M2,N2 : Msg
H4bis : forall (M N : Msg) (_ : synthesis h M N) (M' N' : Msg)\n (_ : synthesis h M' N') (_ : eq M M'), eq N N'
H4 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M' (inv M)), eq N' (inv N)
H3 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H2 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H1 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H0 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
forall _ : eq M (inv (MPair M1 M2)), eq N (inv (MPair N1 N2))
+++++
simpl in |- *.
-----
Theorem inj_inv_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_inv_left h -> injective_inv_left (synthesis h).
intro h.
intros H0 H1 H2 H3 H4.
generalize (inj_left_syn h H0 H1 H2 H3).
intro H4bis.
unfold injective_left in H0.
unfold enc_synthesis_left in H1.
unfold op_synthesis_left in H2.
unfold pair_free_left in H3.
unfold injective_inv_left in H4.
unfold injective_left in H4bis.
unfold injective_inv_left in |- *.
intros M N H5.
induction H5 as [M N H| M N K L H5_1 HrecH5_1 H5_0 HrecH5_0| M1 N1 M2 N2 H5_1 HrecH5_1 H5_0 HrecH5_0| o M N H5 HrecH5]; intros M' N' H6; [ induction H6 as [M0 N0 H5| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K0 L0 H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M N H| M N K L H6_1 HrecH6_1 H6_0 HrecH6_0| M0 N0 M3 N3 H6_1 HrecH6_1 H6_0 HrecH6_0| o M N H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o0 M0 N0 H6 HrecH6] ].
intro.
apply (H4 M N H M0 N0 H5 H6).
intro.
cut (M = inv (MEnc M0 K)).
simpl in |- *.
intro.
case (H1 M N H M0 K H6 N0 L); intro; tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (MPair M1 M2)).
simpl in |- *.
intro.
rewrite H6 in H.
generalize (H3 M1 M2 N).
tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (Mop o M0)).
simpl in |- *.
intro.
generalize (H2 (inv_op o) M N H M0 H7 N0).
tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
simpl in |- *.
cut (synthesis h M0 N0).
intro.
intro.
cut (synthesis h (MEnc M K) (MEnc N L)).
intro.
apply (H4bis M0 N0 H5 (MEnc M K) (MEnc N L) H7 H6).
apply SynEnc; trivial.
apply SynInc; trivial.
simpl in |- *.
intro.
inversion H.
cut (synthesis h (MEnc M0 K0) (MEnc N0 L0)); try (apply SynEnc; trivial).
intro.
cut (synthesis h (MEnc M K) (MEnc N L)); try (apply SynEnc; trivial).
intro.
apply (H4bis (MEnc M0 K0) (MEnc N0 L0) H5 (MEnc M K) (MEnc N L) H8 H).
simpl in |- *.
intro.
inversion H.
simpl in |- *.
intro.
inversion H.
simpl in |- *.

*****
H : h M N
M,N : Msg
HrecH5_0 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M' (inv M2)),\neq N' (inv N2)
HrecH5_1 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M' (inv M1)),\neq N' (inv N1)
H5_0 : synthesis h M2 N2
H5_1 : synthesis h M1 N1
M1,N1,M2,N2 : Msg
H4bis : forall (M N : Msg) (_ : synthesis h M N) (M' N' : Msg)\n (_ : synthesis h M' N') (_ : eq M M'), eq N N'
H4 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M' (inv M)), eq N' (inv N)
H3 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H2 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H1 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H0 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
forall _ : eq M (MPair M1 M2), eq N (MPair N1 N2)
+++++
cut (synthesis h M N); try (apply SynInc; trivial).
-----
Theorem inj_inv_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_inv_left h -> injective_inv_left (synthesis h).
intro h.
intros H0 H1 H2 H3 H4.
generalize (inj_left_syn h H0 H1 H2 H3).
intro H4bis.
unfold injective_left in H0.
unfold enc_synthesis_left in H1.
unfold op_synthesis_left in H2.
unfold pair_free_left in H3.
unfold injective_inv_left in H4.
unfold injective_left in H4bis.
unfold injective_inv_left in |- *.
intros M N H5.
induction H5 as [M N H| M N K L H5_1 HrecH5_1 H5_0 HrecH5_0| M1 N1 M2 N2 H5_1 HrecH5_1 H5_0 HrecH5_0| o M N H5 HrecH5]; intros M' N' H6; [ induction H6 as [M0 N0 H5| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K0 L0 H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M N H| M N K L H6_1 HrecH6_1 H6_0 HrecH6_0| M0 N0 M3 N3 H6_1 HrecH6_1 H6_0 HrecH6_0| o M N H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o0 M0 N0 H6 HrecH6] ].
intro.
apply (H4 M N H M0 N0 H5 H6).
intro.
cut (M = inv (MEnc M0 K)).
simpl in |- *.
intro.
case (H1 M N H M0 K H6 N0 L); intro; tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (MPair M1 M2)).
simpl in |- *.
intro.
rewrite H6 in H.
generalize (H3 M1 M2 N).
tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (Mop o M0)).
simpl in |- *.
intro.
generalize (H2 (inv_op o) M N H M0 H7 N0).
tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
simpl in |- *.
cut (synthesis h M0 N0).
intro.
intro.
cut (synthesis h (MEnc M K) (MEnc N L)).
intro.
apply (H4bis M0 N0 H5 (MEnc M K) (MEnc N L) H7 H6).
apply SynEnc; trivial.
apply SynInc; trivial.
simpl in |- *.
intro.
inversion H.
cut (synthesis h (MEnc M0 K0) (MEnc N0 L0)); try (apply SynEnc; trivial).
intro.
cut (synthesis h (MEnc M K) (MEnc N L)); try (apply SynEnc; trivial).
intro.
apply (H4bis (MEnc M0 K0) (MEnc N0 L0) H5 (MEnc M K) (MEnc N L) H8 H).
simpl in |- *.
intro.
inversion H.
simpl in |- *.
intro.
inversion H.
simpl in |- *.
cut (synthesis h M N); try (apply SynInc; trivial).

*****
H : h M N
M,N : Msg
HrecH5_0 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M' (inv M2)),\neq N' (inv N2)
HrecH5_1 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M' (inv M1)),\neq N' (inv N1)
H5_0 : synthesis h M2 N2
H5_1 : synthesis h M1 N1
M1,N1,M2,N2 : Msg
H4bis : forall (M N : Msg) (_ : synthesis h M N) (M' N' : Msg)\n (_ : synthesis h M' N') (_ : eq M M'), eq N N'
H4 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M' (inv M)), eq N' (inv N)
H3 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H2 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H1 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H0 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
forall (_ : synthesis h M N) (_ : eq M (MPair M1 M2)), eq N (MPair N1 N2)
+++++
intro.
-----
Theorem inj_inv_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_inv_left h -> injective_inv_left (synthesis h).
intro h.
intros H0 H1 H2 H3 H4.
generalize (inj_left_syn h H0 H1 H2 H3).
intro H4bis.
unfold injective_left in H0.
unfold enc_synthesis_left in H1.
unfold op_synthesis_left in H2.
unfold pair_free_left in H3.
unfold injective_inv_left in H4.
unfold injective_left in H4bis.
unfold injective_inv_left in |- *.
intros M N H5.
induction H5 as [M N H| M N K L H5_1 HrecH5_1 H5_0 HrecH5_0| M1 N1 M2 N2 H5_1 HrecH5_1 H5_0 HrecH5_0| o M N H5 HrecH5]; intros M' N' H6; [ induction H6 as [M0 N0 H5| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K0 L0 H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M N H| M N K L H6_1 HrecH6_1 H6_0 HrecH6_0| M0 N0 M3 N3 H6_1 HrecH6_1 H6_0 HrecH6_0| o M N H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o0 M0 N0 H6 HrecH6] ].
intro.
apply (H4 M N H M0 N0 H5 H6).
intro.
cut (M = inv (MEnc M0 K)).
simpl in |- *.
intro.
case (H1 M N H M0 K H6 N0 L); intro; tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (MPair M1 M2)).
simpl in |- *.
intro.
rewrite H6 in H.
generalize (H3 M1 M2 N).
tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (Mop o M0)).
simpl in |- *.
intro.
generalize (H2 (inv_op o) M N H M0 H7 N0).
tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
simpl in |- *.
cut (synthesis h M0 N0).
intro.
intro.
cut (synthesis h (MEnc M K) (MEnc N L)).
intro.
apply (H4bis M0 N0 H5 (MEnc M K) (MEnc N L) H7 H6).
apply SynEnc; trivial.
apply SynInc; trivial.
simpl in |- *.
intro.
inversion H.
cut (synthesis h (MEnc M0 K0) (MEnc N0 L0)); try (apply SynEnc; trivial).
intro.
cut (synthesis h (MEnc M K) (MEnc N L)); try (apply SynEnc; trivial).
intro.
apply (H4bis (MEnc M0 K0) (MEnc N0 L0) H5 (MEnc M K) (MEnc N L) H8 H).
simpl in |- *.
intro.
inversion H.
simpl in |- *.
intro.
inversion H.
simpl in |- *.
cut (synthesis h M N); try (apply SynInc; trivial).
intro.

*****
H5 : synthesis h M N
H : h M N
M,N : Msg
HrecH5_0 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M' (inv M2)),\neq N' (inv N2)
HrecH5_1 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M' (inv M1)),\neq N' (inv N1)
H5_0 : synthesis h M2 N2
H5_1 : synthesis h M1 N1
M1,N1,M2,N2 : Msg
H4bis : forall (M N : Msg) (_ : synthesis h M N) (M' N' : Msg)\n (_ : synthesis h M' N') (_ : eq M M'), eq N N'
H4 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M' (inv M)), eq N' (inv N)
H3 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H2 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H1 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H0 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
forall _ : eq M (MPair M1 M2), eq N (MPair N1 N2)
+++++
cut (synthesis h (MPair M1 M2) (MPair N1 N2)); try (apply SynPair; trivial).
-----
Theorem inj_inv_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_inv_left h -> injective_inv_left (synthesis h).
intro h.
intros H0 H1 H2 H3 H4.
generalize (inj_left_syn h H0 H1 H2 H3).
intro H4bis.
unfold injective_left in H0.
unfold enc_synthesis_left in H1.
unfold op_synthesis_left in H2.
unfold pair_free_left in H3.
unfold injective_inv_left in H4.
unfold injective_left in H4bis.
unfold injective_inv_left in |- *.
intros M N H5.
induction H5 as [M N H| M N K L H5_1 HrecH5_1 H5_0 HrecH5_0| M1 N1 M2 N2 H5_1 HrecH5_1 H5_0 HrecH5_0| o M N H5 HrecH5]; intros M' N' H6; [ induction H6 as [M0 N0 H5| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K0 L0 H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M N H| M N K L H6_1 HrecH6_1 H6_0 HrecH6_0| M0 N0 M3 N3 H6_1 HrecH6_1 H6_0 HrecH6_0| o M N H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o0 M0 N0 H6 HrecH6] ].
intro.
apply (H4 M N H M0 N0 H5 H6).
intro.
cut (M = inv (MEnc M0 K)).
simpl in |- *.
intro.
case (H1 M N H M0 K H6 N0 L); intro; tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (MPair M1 M2)).
simpl in |- *.
intro.
rewrite H6 in H.
generalize (H3 M1 M2 N).
tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (Mop o M0)).
simpl in |- *.
intro.
generalize (H2 (inv_op o) M N H M0 H7 N0).
tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
simpl in |- *.
cut (synthesis h M0 N0).
intro.
intro.
cut (synthesis h (MEnc M K) (MEnc N L)).
intro.
apply (H4bis M0 N0 H5 (MEnc M K) (MEnc N L) H7 H6).
apply SynEnc; trivial.
apply SynInc; trivial.
simpl in |- *.
intro.
inversion H.
cut (synthesis h (MEnc M0 K0) (MEnc N0 L0)); try (apply SynEnc; trivial).
intro.
cut (synthesis h (MEnc M K) (MEnc N L)); try (apply SynEnc; trivial).
intro.
apply (H4bis (MEnc M0 K0) (MEnc N0 L0) H5 (MEnc M K) (MEnc N L) H8 H).
simpl in |- *.
intro.
inversion H.
simpl in |- *.
intro.
inversion H.
simpl in |- *.
cut (synthesis h M N); try (apply SynInc; trivial).
intro.
cut (synthesis h (MPair M1 M2) (MPair N1 N2)); try (apply SynPair; trivial).

*****
H5 : synthesis h M N
H : h M N
M,N : Msg
HrecH5_0 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M' (inv M2)),\neq N' (inv N2)
HrecH5_1 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M' (inv M1)),\neq N' (inv N1)
H5_0 : synthesis h M2 N2
H5_1 : synthesis h M1 N1
M1,N1,M2,N2 : Msg
H4bis : forall (M N : Msg) (_ : synthesis h M N) (M' N' : Msg)\n (_ : synthesis h M' N') (_ : eq M M'), eq N N'
H4 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M' (inv M)), eq N' (inv N)
H3 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H2 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H1 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H0 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
forall (_ : synthesis h (MPair M1 M2) (MPair N1 N2)) (_ : eq M (MPair M1 M2)), eq N (MPair N1 N2)
+++++
intro.
-----
Theorem inj_inv_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_inv_left h -> injective_inv_left (synthesis h).
intro h.
intros H0 H1 H2 H3 H4.
generalize (inj_left_syn h H0 H1 H2 H3).
intro H4bis.
unfold injective_left in H0.
unfold enc_synthesis_left in H1.
unfold op_synthesis_left in H2.
unfold pair_free_left in H3.
unfold injective_inv_left in H4.
unfold injective_left in H4bis.
unfold injective_inv_left in |- *.
intros M N H5.
induction H5 as [M N H| M N K L H5_1 HrecH5_1 H5_0 HrecH5_0| M1 N1 M2 N2 H5_1 HrecH5_1 H5_0 HrecH5_0| o M N H5 HrecH5]; intros M' N' H6; [ induction H6 as [M0 N0 H5| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K0 L0 H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M N H| M N K L H6_1 HrecH6_1 H6_0 HrecH6_0| M0 N0 M3 N3 H6_1 HrecH6_1 H6_0 HrecH6_0| o M N H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o0 M0 N0 H6 HrecH6] ].
intro.
apply (H4 M N H M0 N0 H5 H6).
intro.
cut (M = inv (MEnc M0 K)).
simpl in |- *.
intro.
case (H1 M N H M0 K H6 N0 L); intro; tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (MPair M1 M2)).
simpl in |- *.
intro.
rewrite H6 in H.
generalize (H3 M1 M2 N).
tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (Mop o M0)).
simpl in |- *.
intro.
generalize (H2 (inv_op o) M N H M0 H7 N0).
tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
simpl in |- *.
cut (synthesis h M0 N0).
intro.
intro.
cut (synthesis h (MEnc M K) (MEnc N L)).
intro.
apply (H4bis M0 N0 H5 (MEnc M K) (MEnc N L) H7 H6).
apply SynEnc; trivial.
apply SynInc; trivial.
simpl in |- *.
intro.
inversion H.
cut (synthesis h (MEnc M0 K0) (MEnc N0 L0)); try (apply SynEnc; trivial).
intro.
cut (synthesis h (MEnc M K) (MEnc N L)); try (apply SynEnc; trivial).
intro.
apply (H4bis (MEnc M0 K0) (MEnc N0 L0) H5 (MEnc M K) (MEnc N L) H8 H).
simpl in |- *.
intro.
inversion H.
simpl in |- *.
intro.
inversion H.
simpl in |- *.
cut (synthesis h M N); try (apply SynInc; trivial).
intro.
cut (synthesis h (MPair M1 M2) (MPair N1 N2)); try (apply SynPair; trivial).
intro.

*****
H6 : synthesis h (MPair M1 M2) (MPair N1 N2)
H5 : synthesis h M N
H : h M N
M,N : Msg
HrecH5_0 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M' (inv M2)),\neq N' (inv N2)
HrecH5_1 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M' (inv M1)),\neq N' (inv N1)
H5_0 : synthesis h M2 N2
H5_1 : synthesis h M1 N1
M1,N1,M2,N2 : Msg
H4bis : forall (M N : Msg) (_ : synthesis h M N) (M' N' : Msg)\n (_ : synthesis h M' N') (_ : eq M M'), eq N N'
H4 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M' (inv M)), eq N' (inv N)
H3 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H2 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H1 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H0 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
forall _ : eq M (MPair M1 M2), eq N (MPair N1 N2)
+++++
intro.
-----
Theorem inj_inv_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_inv_left h -> injective_inv_left (synthesis h).
intro h.
intros H0 H1 H2 H3 H4.
generalize (inj_left_syn h H0 H1 H2 H3).
intro H4bis.
unfold injective_left in H0.
unfold enc_synthesis_left in H1.
unfold op_synthesis_left in H2.
unfold pair_free_left in H3.
unfold injective_inv_left in H4.
unfold injective_left in H4bis.
unfold injective_inv_left in |- *.
intros M N H5.
induction H5 as [M N H| M N K L H5_1 HrecH5_1 H5_0 HrecH5_0| M1 N1 M2 N2 H5_1 HrecH5_1 H5_0 HrecH5_0| o M N H5 HrecH5]; intros M' N' H6; [ induction H6 as [M0 N0 H5| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K0 L0 H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M N H| M N K L H6_1 HrecH6_1 H6_0 HrecH6_0| M0 N0 M3 N3 H6_1 HrecH6_1 H6_0 HrecH6_0| o M N H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o0 M0 N0 H6 HrecH6] ].
intro.
apply (H4 M N H M0 N0 H5 H6).
intro.
cut (M = inv (MEnc M0 K)).
simpl in |- *.
intro.
case (H1 M N H M0 K H6 N0 L); intro; tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (MPair M1 M2)).
simpl in |- *.
intro.
rewrite H6 in H.
generalize (H3 M1 M2 N).
tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (Mop o M0)).
simpl in |- *.
intro.
generalize (H2 (inv_op o) M N H M0 H7 N0).
tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
simpl in |- *.
cut (synthesis h M0 N0).
intro.
intro.
cut (synthesis h (MEnc M K) (MEnc N L)).
intro.
apply (H4bis M0 N0 H5 (MEnc M K) (MEnc N L) H7 H6).
apply SynEnc; trivial.
apply SynInc; trivial.
simpl in |- *.
intro.
inversion H.
cut (synthesis h (MEnc M0 K0) (MEnc N0 L0)); try (apply SynEnc; trivial).
intro.
cut (synthesis h (MEnc M K) (MEnc N L)); try (apply SynEnc; trivial).
intro.
apply (H4bis (MEnc M0 K0) (MEnc N0 L0) H5 (MEnc M K) (MEnc N L) H8 H).
simpl in |- *.
intro.
inversion H.
simpl in |- *.
intro.
inversion H.
simpl in |- *.
cut (synthesis h M N); try (apply SynInc; trivial).
intro.
cut (synthesis h (MPair M1 M2) (MPair N1 N2)); try (apply SynPair; trivial).
intro.
intro.

*****
H7 : eq M (MPair M1 M2)
H6 : synthesis h (MPair M1 M2) (MPair N1 N2)
H5 : synthesis h M N
H : h M N
M,N : Msg
HrecH5_0 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M' (inv M2)),\neq N' (inv N2)
HrecH5_1 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M' (inv M1)),\neq N' (inv N1)
H5_0 : synthesis h M2 N2
H5_1 : synthesis h M1 N1
M1,N1,M2,N2 : Msg
H4bis : forall (M N : Msg) (_ : synthesis h M N) (M' N' : Msg)\n (_ : synthesis h M' N') (_ : eq M M'), eq N N'
H4 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M' (inv M)), eq N' (inv N)
H3 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H2 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H1 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H0 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
eq N (MPair N1 N2)
+++++
apply (H4bis M N H5 (MPair M1 M2) (MPair N1 N2) H6 H7).
-----
Theorem inj_inv_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_inv_left h -> injective_inv_left (synthesis h).
intro h.
intros H0 H1 H2 H3 H4.
generalize (inj_left_syn h H0 H1 H2 H3).
intro H4bis.
unfold injective_left in H0.
unfold enc_synthesis_left in H1.
unfold op_synthesis_left in H2.
unfold pair_free_left in H3.
unfold injective_inv_left in H4.
unfold injective_left in H4bis.
unfold injective_inv_left in |- *.
intros M N H5.
induction H5 as [M N H| M N K L H5_1 HrecH5_1 H5_0 HrecH5_0| M1 N1 M2 N2 H5_1 HrecH5_1 H5_0 HrecH5_0| o M N H5 HrecH5]; intros M' N' H6; [ induction H6 as [M0 N0 H5| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K0 L0 H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M N H| M N K L H6_1 HrecH6_1 H6_0 HrecH6_0| M0 N0 M3 N3 H6_1 HrecH6_1 H6_0 HrecH6_0| o M N H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o0 M0 N0 H6 HrecH6] ].
intro.
apply (H4 M N H M0 N0 H5 H6).
intro.
cut (M = inv (MEnc M0 K)).
simpl in |- *.
intro.
case (H1 M N H M0 K H6 N0 L); intro; tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (MPair M1 M2)).
simpl in |- *.
intro.
rewrite H6 in H.
generalize (H3 M1 M2 N).
tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (Mop o M0)).
simpl in |- *.
intro.
generalize (H2 (inv_op o) M N H M0 H7 N0).
tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
simpl in |- *.
cut (synthesis h M0 N0).
intro.
intro.
cut (synthesis h (MEnc M K) (MEnc N L)).
intro.
apply (H4bis M0 N0 H5 (MEnc M K) (MEnc N L) H7 H6).
apply SynEnc; trivial.
apply SynInc; trivial.
simpl in |- *.
intro.
inversion H.
cut (synthesis h (MEnc M0 K0) (MEnc N0 L0)); try (apply SynEnc; trivial).
intro.
cut (synthesis h (MEnc M K) (MEnc N L)); try (apply SynEnc; trivial).
intro.
apply (H4bis (MEnc M0 K0) (MEnc N0 L0) H5 (MEnc M K) (MEnc N L) H8 H).
simpl in |- *.
intro.
inversion H.
simpl in |- *.
intro.
inversion H.
simpl in |- *.
cut (synthesis h M N); try (apply SynInc; trivial).
intro.
cut (synthesis h (MPair M1 M2) (MPair N1 N2)); try (apply SynPair; trivial).
intro.
intro.
apply (H4bis M N H5 (MPair M1 M2) (MPair N1 N2) H6 H7).

*****
HrecH6_0 : forall _ : eq K (inv (MPair M1 M2)), eq L (inv (MPair N1 N2))
HrecH6_1 : forall _ : eq M (inv (MPair M1 M2)), eq N (inv (MPair N1 N2))
H6_0 : synthesis h K L
H6_1 : synthesis h M N
M,N,K,L : Msg
HrecH5_0 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M' (inv M2)),\neq N' (inv N2)
HrecH5_1 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M' (inv M1)),\neq N' (inv N1)
H5_0 : synthesis h M2 N2
H5_1 : synthesis h M1 N1
M1,N1,M2,N2 : Msg
H4bis : forall (M N : Msg) (_ : synthesis h M N) (M' N' : Msg)\n (_ : synthesis h M' N') (_ : eq M M'), eq N N'
H4 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M' (inv M)), eq N' (inv N)
H3 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H2 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H1 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H0 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
forall _ : eq (MEnc M K) (inv (MPair M1 M2)), eq (MEnc N L) (inv (MPair N1 N2))
+++++
simpl in |- *.
-----
Theorem inj_inv_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_inv_left h -> injective_inv_left (synthesis h).
intro h.
intros H0 H1 H2 H3 H4.
generalize (inj_left_syn h H0 H1 H2 H3).
intro H4bis.
unfold injective_left in H0.
unfold enc_synthesis_left in H1.
unfold op_synthesis_left in H2.
unfold pair_free_left in H3.
unfold injective_inv_left in H4.
unfold injective_left in H4bis.
unfold injective_inv_left in |- *.
intros M N H5.
induction H5 as [M N H| M N K L H5_1 HrecH5_1 H5_0 HrecH5_0| M1 N1 M2 N2 H5_1 HrecH5_1 H5_0 HrecH5_0| o M N H5 HrecH5]; intros M' N' H6; [ induction H6 as [M0 N0 H5| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K0 L0 H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M N H| M N K L H6_1 HrecH6_1 H6_0 HrecH6_0| M0 N0 M3 N3 H6_1 HrecH6_1 H6_0 HrecH6_0| o M N H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o0 M0 N0 H6 HrecH6] ].
intro.
apply (H4 M N H M0 N0 H5 H6).
intro.
cut (M = inv (MEnc M0 K)).
simpl in |- *.
intro.
case (H1 M N H M0 K H6 N0 L); intro; tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (MPair M1 M2)).
simpl in |- *.
intro.
rewrite H6 in H.
generalize (H3 M1 M2 N).
tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (Mop o M0)).
simpl in |- *.
intro.
generalize (H2 (inv_op o) M N H M0 H7 N0).
tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
simpl in |- *.
cut (synthesis h M0 N0).
intro.
intro.
cut (synthesis h (MEnc M K) (MEnc N L)).
intro.
apply (H4bis M0 N0 H5 (MEnc M K) (MEnc N L) H7 H6).
apply SynEnc; trivial.
apply SynInc; trivial.
simpl in |- *.
intro.
inversion H.
cut (synthesis h (MEnc M0 K0) (MEnc N0 L0)); try (apply SynEnc; trivial).
intro.
cut (synthesis h (MEnc M K) (MEnc N L)); try (apply SynEnc; trivial).
intro.
apply (H4bis (MEnc M0 K0) (MEnc N0 L0) H5 (MEnc M K) (MEnc N L) H8 H).
simpl in |- *.
intro.
inversion H.
simpl in |- *.
intro.
inversion H.
simpl in |- *.
cut (synthesis h M N); try (apply SynInc; trivial).
intro.
cut (synthesis h (MPair M1 M2) (MPair N1 N2)); try (apply SynPair; trivial).
intro.
intro.
apply (H4bis M N H5 (MPair M1 M2) (MPair N1 N2) H6 H7).
simpl in |- *.

*****
HrecH6_0 : forall _ : eq K (inv (MPair M1 M2)), eq L (inv (MPair N1 N2))
HrecH6_1 : forall _ : eq M (inv (MPair M1 M2)), eq N (inv (MPair N1 N2))
H6_0 : synthesis h K L
H6_1 : synthesis h M N
M,N,K,L : Msg
HrecH5_0 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M' (inv M2)),\neq N' (inv N2)
HrecH5_1 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M' (inv M1)),\neq N' (inv N1)
H5_0 : synthesis h M2 N2
H5_1 : synthesis h M1 N1
M1,N1,M2,N2 : Msg
H4bis : forall (M N : Msg) (_ : synthesis h M N) (M' N' : Msg)\n (_ : synthesis h M' N') (_ : eq M M'), eq N N'
H4 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M' (inv M)), eq N' (inv N)
H3 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H2 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H1 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H0 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
forall _ : eq (MEnc M K) (MPair M1 M2), eq (MEnc N L) (MPair N1 N2)
+++++
intro.
-----
Theorem inj_inv_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_inv_left h -> injective_inv_left (synthesis h).
intro h.
intros H0 H1 H2 H3 H4.
generalize (inj_left_syn h H0 H1 H2 H3).
intro H4bis.
unfold injective_left in H0.
unfold enc_synthesis_left in H1.
unfold op_synthesis_left in H2.
unfold pair_free_left in H3.
unfold injective_inv_left in H4.
unfold injective_left in H4bis.
unfold injective_inv_left in |- *.
intros M N H5.
induction H5 as [M N H| M N K L H5_1 HrecH5_1 H5_0 HrecH5_0| M1 N1 M2 N2 H5_1 HrecH5_1 H5_0 HrecH5_0| o M N H5 HrecH5]; intros M' N' H6; [ induction H6 as [M0 N0 H5| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K0 L0 H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M N H| M N K L H6_1 HrecH6_1 H6_0 HrecH6_0| M0 N0 M3 N3 H6_1 HrecH6_1 H6_0 HrecH6_0| o M N H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o0 M0 N0 H6 HrecH6] ].
intro.
apply (H4 M N H M0 N0 H5 H6).
intro.
cut (M = inv (MEnc M0 K)).
simpl in |- *.
intro.
case (H1 M N H M0 K H6 N0 L); intro; tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (MPair M1 M2)).
simpl in |- *.
intro.
rewrite H6 in H.
generalize (H3 M1 M2 N).
tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (Mop o M0)).
simpl in |- *.
intro.
generalize (H2 (inv_op o) M N H M0 H7 N0).
tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
simpl in |- *.
cut (synthesis h M0 N0).
intro.
intro.
cut (synthesis h (MEnc M K) (MEnc N L)).
intro.
apply (H4bis M0 N0 H5 (MEnc M K) (MEnc N L) H7 H6).
apply SynEnc; trivial.
apply SynInc; trivial.
simpl in |- *.
intro.
inversion H.
cut (synthesis h (MEnc M0 K0) (MEnc N0 L0)); try (apply SynEnc; trivial).
intro.
cut (synthesis h (MEnc M K) (MEnc N L)); try (apply SynEnc; trivial).
intro.
apply (H4bis (MEnc M0 K0) (MEnc N0 L0) H5 (MEnc M K) (MEnc N L) H8 H).
simpl in |- *.
intro.
inversion H.
simpl in |- *.
intro.
inversion H.
simpl in |- *.
cut (synthesis h M N); try (apply SynInc; trivial).
intro.
cut (synthesis h (MPair M1 M2) (MPair N1 N2)); try (apply SynPair; trivial).
intro.
intro.
apply (H4bis M N H5 (MPair M1 M2) (MPair N1 N2) H6 H7).
simpl in |- *.
intro.

*****
H : eq (MEnc M K) (MPair M1 M2)
HrecH6_0 : forall _ : eq K (inv (MPair M1 M2)), eq L (inv (MPair N1 N2))
HrecH6_1 : forall _ : eq M (inv (MPair M1 M2)), eq N (inv (MPair N1 N2))
H6_0 : synthesis h K L
H6_1 : synthesis h M N
M,N,K,L : Msg
HrecH5_0 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M' (inv M2)),\neq N' (inv N2)
HrecH5_1 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M' (inv M1)),\neq N' (inv N1)
H5_0 : synthesis h M2 N2
H5_1 : synthesis h M1 N1
M1,N1,M2,N2 : Msg
H4bis : forall (M N : Msg) (_ : synthesis h M N) (M' N' : Msg)\n (_ : synthesis h M' N') (_ : eq M M'), eq N N'
H4 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M' (inv M)), eq N' (inv N)
H3 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H2 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H1 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H0 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
eq (MEnc N L) (MPair N1 N2)
+++++
inversion H.
-----
Theorem inj_inv_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_inv_left h -> injective_inv_left (synthesis h).
intro h.
intros H0 H1 H2 H3 H4.
generalize (inj_left_syn h H0 H1 H2 H3).
intro H4bis.
unfold injective_left in H0.
unfold enc_synthesis_left in H1.
unfold op_synthesis_left in H2.
unfold pair_free_left in H3.
unfold injective_inv_left in H4.
unfold injective_left in H4bis.
unfold injective_inv_left in |- *.
intros M N H5.
induction H5 as [M N H| M N K L H5_1 HrecH5_1 H5_0 HrecH5_0| M1 N1 M2 N2 H5_1 HrecH5_1 H5_0 HrecH5_0| o M N H5 HrecH5]; intros M' N' H6; [ induction H6 as [M0 N0 H5| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K0 L0 H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M N H| M N K L H6_1 HrecH6_1 H6_0 HrecH6_0| M0 N0 M3 N3 H6_1 HrecH6_1 H6_0 HrecH6_0| o M N H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o0 M0 N0 H6 HrecH6] ].
intro.
apply (H4 M N H M0 N0 H5 H6).
intro.
cut (M = inv (MEnc M0 K)).
simpl in |- *.
intro.
case (H1 M N H M0 K H6 N0 L); intro; tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (MPair M1 M2)).
simpl in |- *.
intro.
rewrite H6 in H.
generalize (H3 M1 M2 N).
tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (Mop o M0)).
simpl in |- *.
intro.
generalize (H2 (inv_op o) M N H M0 H7 N0).
tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
simpl in |- *.
cut (synthesis h M0 N0).
intro.
intro.
cut (synthesis h (MEnc M K) (MEnc N L)).
intro.
apply (H4bis M0 N0 H5 (MEnc M K) (MEnc N L) H7 H6).
apply SynEnc; trivial.
apply SynInc; trivial.
simpl in |- *.
intro.
inversion H.
cut (synthesis h (MEnc M0 K0) (MEnc N0 L0)); try (apply SynEnc; trivial).
intro.
cut (synthesis h (MEnc M K) (MEnc N L)); try (apply SynEnc; trivial).
intro.
apply (H4bis (MEnc M0 K0) (MEnc N0 L0) H5 (MEnc M K) (MEnc N L) H8 H).
simpl in |- *.
intro.
inversion H.
simpl in |- *.
intro.
inversion H.
simpl in |- *.
cut (synthesis h M N); try (apply SynInc; trivial).
intro.
cut (synthesis h (MPair M1 M2) (MPair N1 N2)); try (apply SynPair; trivial).
intro.
intro.
apply (H4bis M N H5 (MPair M1 M2) (MPair N1 N2) H6 H7).
simpl in |- *.
intro.
inversion H.

*****
HrecH6_0 : forall _ : eq M3 (inv (MPair M1 M2)), eq N3 (inv (MPair N1 N2))
HrecH6_1 : forall _ : eq M0 (inv (MPair M1 M2)), eq N0 (inv (MPair N1 N2))
H6_0 : synthesis h M3 N3
H6_1 : synthesis h M0 N0
M0,N0,M3,N3 : Msg
HrecH5_0 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M' (inv M2)),\neq N' (inv N2)
HrecH5_1 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M' (inv M1)),\neq N' (inv N1)
H5_0 : synthesis h M2 N2
H5_1 : synthesis h M1 N1
M1,N1,M2,N2 : Msg
H4bis : forall (M N : Msg) (_ : synthesis h M N) (M' N' : Msg)\n (_ : synthesis h M' N') (_ : eq M M'), eq N N'
H4 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M' (inv M)), eq N' (inv N)
H3 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H2 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H1 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H0 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
forall _ : eq (MPair M0 M3) (inv (MPair M1 M2)), eq (MPair N0 N3) (inv (MPair N1 N2))
+++++
simpl in |- *.
-----
Theorem inj_inv_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_inv_left h -> injective_inv_left (synthesis h).
intro h.
intros H0 H1 H2 H3 H4.
generalize (inj_left_syn h H0 H1 H2 H3).
intro H4bis.
unfold injective_left in H0.
unfold enc_synthesis_left in H1.
unfold op_synthesis_left in H2.
unfold pair_free_left in H3.
unfold injective_inv_left in H4.
unfold injective_left in H4bis.
unfold injective_inv_left in |- *.
intros M N H5.
induction H5 as [M N H| M N K L H5_1 HrecH5_1 H5_0 HrecH5_0| M1 N1 M2 N2 H5_1 HrecH5_1 H5_0 HrecH5_0| o M N H5 HrecH5]; intros M' N' H6; [ induction H6 as [M0 N0 H5| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K0 L0 H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M N H| M N K L H6_1 HrecH6_1 H6_0 HrecH6_0| M0 N0 M3 N3 H6_1 HrecH6_1 H6_0 HrecH6_0| o M N H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o0 M0 N0 H6 HrecH6] ].
intro.
apply (H4 M N H M0 N0 H5 H6).
intro.
cut (M = inv (MEnc M0 K)).
simpl in |- *.
intro.
case (H1 M N H M0 K H6 N0 L); intro; tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (MPair M1 M2)).
simpl in |- *.
intro.
rewrite H6 in H.
generalize (H3 M1 M2 N).
tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (Mop o M0)).
simpl in |- *.
intro.
generalize (H2 (inv_op o) M N H M0 H7 N0).
tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
simpl in |- *.
cut (synthesis h M0 N0).
intro.
intro.
cut (synthesis h (MEnc M K) (MEnc N L)).
intro.
apply (H4bis M0 N0 H5 (MEnc M K) (MEnc N L) H7 H6).
apply SynEnc; trivial.
apply SynInc; trivial.
simpl in |- *.
intro.
inversion H.
cut (synthesis h (MEnc M0 K0) (MEnc N0 L0)); try (apply SynEnc; trivial).
intro.
cut (synthesis h (MEnc M K) (MEnc N L)); try (apply SynEnc; trivial).
intro.
apply (H4bis (MEnc M0 K0) (MEnc N0 L0) H5 (MEnc M K) (MEnc N L) H8 H).
simpl in |- *.
intro.
inversion H.
simpl in |- *.
intro.
inversion H.
simpl in |- *.
cut (synthesis h M N); try (apply SynInc; trivial).
intro.
cut (synthesis h (MPair M1 M2) (MPair N1 N2)); try (apply SynPair; trivial).
intro.
intro.
apply (H4bis M N H5 (MPair M1 M2) (MPair N1 N2) H6 H7).
simpl in |- *.
intro.
inversion H.
simpl in |- *.

*****
HrecH6_0 : forall _ : eq M3 (inv (MPair M1 M2)), eq N3 (inv (MPair N1 N2))
HrecH6_1 : forall _ : eq M0 (inv (MPair M1 M2)), eq N0 (inv (MPair N1 N2))
H6_0 : synthesis h M3 N3
H6_1 : synthesis h M0 N0
M0,N0,M3,N3 : Msg
HrecH5_0 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M' (inv M2)),\neq N' (inv N2)
HrecH5_1 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M' (inv M1)),\neq N' (inv N1)
H5_0 : synthesis h M2 N2
H5_1 : synthesis h M1 N1
M1,N1,M2,N2 : Msg
H4bis : forall (M N : Msg) (_ : synthesis h M N) (M' N' : Msg)\n (_ : synthesis h M' N') (_ : eq M M'), eq N N'
H4 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M' (inv M)), eq N' (inv N)
H3 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H2 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H1 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H0 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
forall _ : eq (MPair M0 M3) (MPair M1 M2), eq (MPair N0 N3) (MPair N1 N2)
+++++
intro.
-----
Theorem inj_inv_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_inv_left h -> injective_inv_left (synthesis h).
intro h.
intros H0 H1 H2 H3 H4.
generalize (inj_left_syn h H0 H1 H2 H3).
intro H4bis.
unfold injective_left in H0.
unfold enc_synthesis_left in H1.
unfold op_synthesis_left in H2.
unfold pair_free_left in H3.
unfold injective_inv_left in H4.
unfold injective_left in H4bis.
unfold injective_inv_left in |- *.
intros M N H5.
induction H5 as [M N H| M N K L H5_1 HrecH5_1 H5_0 HrecH5_0| M1 N1 M2 N2 H5_1 HrecH5_1 H5_0 HrecH5_0| o M N H5 HrecH5]; intros M' N' H6; [ induction H6 as [M0 N0 H5| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K0 L0 H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M N H| M N K L H6_1 HrecH6_1 H6_0 HrecH6_0| M0 N0 M3 N3 H6_1 HrecH6_1 H6_0 HrecH6_0| o M N H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o0 M0 N0 H6 HrecH6] ].
intro.
apply (H4 M N H M0 N0 H5 H6).
intro.
cut (M = inv (MEnc M0 K)).
simpl in |- *.
intro.
case (H1 M N H M0 K H6 N0 L); intro; tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (MPair M1 M2)).
simpl in |- *.
intro.
rewrite H6 in H.
generalize (H3 M1 M2 N).
tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (Mop o M0)).
simpl in |- *.
intro.
generalize (H2 (inv_op o) M N H M0 H7 N0).
tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
simpl in |- *.
cut (synthesis h M0 N0).
intro.
intro.
cut (synthesis h (MEnc M K) (MEnc N L)).
intro.
apply (H4bis M0 N0 H5 (MEnc M K) (MEnc N L) H7 H6).
apply SynEnc; trivial.
apply SynInc; trivial.
simpl in |- *.
intro.
inversion H.
cut (synthesis h (MEnc M0 K0) (MEnc N0 L0)); try (apply SynEnc; trivial).
intro.
cut (synthesis h (MEnc M K) (MEnc N L)); try (apply SynEnc; trivial).
intro.
apply (H4bis (MEnc M0 K0) (MEnc N0 L0) H5 (MEnc M K) (MEnc N L) H8 H).
simpl in |- *.
intro.
inversion H.
simpl in |- *.
intro.
inversion H.
simpl in |- *.
cut (synthesis h M N); try (apply SynInc; trivial).
intro.
cut (synthesis h (MPair M1 M2) (MPair N1 N2)); try (apply SynPair; trivial).
intro.
intro.
apply (H4bis M N H5 (MPair M1 M2) (MPair N1 N2) H6 H7).
simpl in |- *.
intro.
inversion H.
simpl in |- *.
intro.

*****
H : eq (MPair M0 M3) (MPair M1 M2)
HrecH6_0 : forall _ : eq M3 (inv (MPair M1 M2)), eq N3 (inv (MPair N1 N2))
HrecH6_1 : forall _ : eq M0 (inv (MPair M1 M2)), eq N0 (inv (MPair N1 N2))
H6_0 : synthesis h M3 N3
H6_1 : synthesis h M0 N0
M0,N0,M3,N3 : Msg
HrecH5_0 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M' (inv M2)),\neq N' (inv N2)
HrecH5_1 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M' (inv M1)),\neq N' (inv N1)
H5_0 : synthesis h M2 N2
H5_1 : synthesis h M1 N1
M1,N1,M2,N2 : Msg
H4bis : forall (M N : Msg) (_ : synthesis h M N) (M' N' : Msg)\n (_ : synthesis h M' N') (_ : eq M M'), eq N N'
H4 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M' (inv M)), eq N' (inv N)
H3 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H2 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H1 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H0 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
eq (MPair N0 N3) (MPair N1 N2)
+++++
cut (synthesis h (MPair M1 M2) (MPair N1 N2)); try (apply SynPair; trivial).
-----
Theorem inj_inv_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_inv_left h -> injective_inv_left (synthesis h).
intro h.
intros H0 H1 H2 H3 H4.
generalize (inj_left_syn h H0 H1 H2 H3).
intro H4bis.
unfold injective_left in H0.
unfold enc_synthesis_left in H1.
unfold op_synthesis_left in H2.
unfold pair_free_left in H3.
unfold injective_inv_left in H4.
unfold injective_left in H4bis.
unfold injective_inv_left in |- *.
intros M N H5.
induction H5 as [M N H| M N K L H5_1 HrecH5_1 H5_0 HrecH5_0| M1 N1 M2 N2 H5_1 HrecH5_1 H5_0 HrecH5_0| o M N H5 HrecH5]; intros M' N' H6; [ induction H6 as [M0 N0 H5| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K0 L0 H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M N H| M N K L H6_1 HrecH6_1 H6_0 HrecH6_0| M0 N0 M3 N3 H6_1 HrecH6_1 H6_0 HrecH6_0| o M N H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o0 M0 N0 H6 HrecH6] ].
intro.
apply (H4 M N H M0 N0 H5 H6).
intro.
cut (M = inv (MEnc M0 K)).
simpl in |- *.
intro.
case (H1 M N H M0 K H6 N0 L); intro; tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (MPair M1 M2)).
simpl in |- *.
intro.
rewrite H6 in H.
generalize (H3 M1 M2 N).
tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (Mop o M0)).
simpl in |- *.
intro.
generalize (H2 (inv_op o) M N H M0 H7 N0).
tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
simpl in |- *.
cut (synthesis h M0 N0).
intro.
intro.
cut (synthesis h (MEnc M K) (MEnc N L)).
intro.
apply (H4bis M0 N0 H5 (MEnc M K) (MEnc N L) H7 H6).
apply SynEnc; trivial.
apply SynInc; trivial.
simpl in |- *.
intro.
inversion H.
cut (synthesis h (MEnc M0 K0) (MEnc N0 L0)); try (apply SynEnc; trivial).
intro.
cut (synthesis h (MEnc M K) (MEnc N L)); try (apply SynEnc; trivial).
intro.
apply (H4bis (MEnc M0 K0) (MEnc N0 L0) H5 (MEnc M K) (MEnc N L) H8 H).
simpl in |- *.
intro.
inversion H.
simpl in |- *.
intro.
inversion H.
simpl in |- *.
cut (synthesis h M N); try (apply SynInc; trivial).
intro.
cut (synthesis h (MPair M1 M2) (MPair N1 N2)); try (apply SynPair; trivial).
intro.
intro.
apply (H4bis M N H5 (MPair M1 M2) (MPair N1 N2) H6 H7).
simpl in |- *.
intro.
inversion H.
simpl in |- *.
intro.
cut (synthesis h (MPair M1 M2) (MPair N1 N2)); try (apply SynPair; trivial).

*****
H : eq (MPair M0 M3) (MPair M1 M2)
HrecH6_0 : forall _ : eq M3 (inv (MPair M1 M2)), eq N3 (inv (MPair N1 N2))
HrecH6_1 : forall _ : eq M0 (inv (MPair M1 M2)), eq N0 (inv (MPair N1 N2))
H6_0 : synthesis h M3 N3
H6_1 : synthesis h M0 N0
M0,N0,M3,N3 : Msg
HrecH5_0 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M' (inv M2)),\neq N' (inv N2)
HrecH5_1 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M' (inv M1)),\neq N' (inv N1)
H5_0 : synthesis h M2 N2
H5_1 : synthesis h M1 N1
M1,N1,M2,N2 : Msg
H4bis : forall (M N : Msg) (_ : synthesis h M N) (M' N' : Msg)\n (_ : synthesis h M' N') (_ : eq M M'), eq N N'
H4 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M' (inv M)), eq N' (inv N)
H3 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H2 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H1 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H0 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
forall _ : synthesis h (MPair M1 M2) (MPair N1 N2), eq (MPair N0 N3) (MPair N1 N2)
+++++
intro.
-----
Theorem inj_inv_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_inv_left h -> injective_inv_left (synthesis h).
intro h.
intros H0 H1 H2 H3 H4.
generalize (inj_left_syn h H0 H1 H2 H3).
intro H4bis.
unfold injective_left in H0.
unfold enc_synthesis_left in H1.
unfold op_synthesis_left in H2.
unfold pair_free_left in H3.
unfold injective_inv_left in H4.
unfold injective_left in H4bis.
unfold injective_inv_left in |- *.
intros M N H5.
induction H5 as [M N H| M N K L H5_1 HrecH5_1 H5_0 HrecH5_0| M1 N1 M2 N2 H5_1 HrecH5_1 H5_0 HrecH5_0| o M N H5 HrecH5]; intros M' N' H6; [ induction H6 as [M0 N0 H5| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K0 L0 H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M N H| M N K L H6_1 HrecH6_1 H6_0 HrecH6_0| M0 N0 M3 N3 H6_1 HrecH6_1 H6_0 HrecH6_0| o M N H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o0 M0 N0 H6 HrecH6] ].
intro.
apply (H4 M N H M0 N0 H5 H6).
intro.
cut (M = inv (MEnc M0 K)).
simpl in |- *.
intro.
case (H1 M N H M0 K H6 N0 L); intro; tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (MPair M1 M2)).
simpl in |- *.
intro.
rewrite H6 in H.
generalize (H3 M1 M2 N).
tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (Mop o M0)).
simpl in |- *.
intro.
generalize (H2 (inv_op o) M N H M0 H7 N0).
tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
simpl in |- *.
cut (synthesis h M0 N0).
intro.
intro.
cut (synthesis h (MEnc M K) (MEnc N L)).
intro.
apply (H4bis M0 N0 H5 (MEnc M K) (MEnc N L) H7 H6).
apply SynEnc; trivial.
apply SynInc; trivial.
simpl in |- *.
intro.
inversion H.
cut (synthesis h (MEnc M0 K0) (MEnc N0 L0)); try (apply SynEnc; trivial).
intro.
cut (synthesis h (MEnc M K) (MEnc N L)); try (apply SynEnc; trivial).
intro.
apply (H4bis (MEnc M0 K0) (MEnc N0 L0) H5 (MEnc M K) (MEnc N L) H8 H).
simpl in |- *.
intro.
inversion H.
simpl in |- *.
intro.
inversion H.
simpl in |- *.
cut (synthesis h M N); try (apply SynInc; trivial).
intro.
cut (synthesis h (MPair M1 M2) (MPair N1 N2)); try (apply SynPair; trivial).
intro.
intro.
apply (H4bis M N H5 (MPair M1 M2) (MPair N1 N2) H6 H7).
simpl in |- *.
intro.
inversion H.
simpl in |- *.
intro.
cut (synthesis h (MPair M1 M2) (MPair N1 N2)); try (apply SynPair; trivial).
intro.

*****
H5 : synthesis h (MPair M1 M2) (MPair N1 N2)
H : eq (MPair M0 M3) (MPair M1 M2)
HrecH6_0 : forall _ : eq M3 (inv (MPair M1 M2)), eq N3 (inv (MPair N1 N2))
HrecH6_1 : forall _ : eq M0 (inv (MPair M1 M2)), eq N0 (inv (MPair N1 N2))
H6_0 : synthesis h M3 N3
H6_1 : synthesis h M0 N0
M0,N0,M3,N3 : Msg
HrecH5_0 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M' (inv M2)),\neq N' (inv N2)
HrecH5_1 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M' (inv M1)),\neq N' (inv N1)
H5_0 : synthesis h M2 N2
H5_1 : synthesis h M1 N1
M1,N1,M2,N2 : Msg
H4bis : forall (M N : Msg) (_ : synthesis h M N) (M' N' : Msg)\n (_ : synthesis h M' N') (_ : eq M M'), eq N N'
H4 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M' (inv M)), eq N' (inv N)
H3 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H2 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H1 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H0 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
eq (MPair N0 N3) (MPair N1 N2)
+++++
cut (synthesis h (MPair M0 M3) (MPair N0 N3)); try (apply SynPair; trivial).
-----
Theorem inj_inv_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_inv_left h -> injective_inv_left (synthesis h).
intro h.
intros H0 H1 H2 H3 H4.
generalize (inj_left_syn h H0 H1 H2 H3).
intro H4bis.
unfold injective_left in H0.
unfold enc_synthesis_left in H1.
unfold op_synthesis_left in H2.
unfold pair_free_left in H3.
unfold injective_inv_left in H4.
unfold injective_left in H4bis.
unfold injective_inv_left in |- *.
intros M N H5.
induction H5 as [M N H| M N K L H5_1 HrecH5_1 H5_0 HrecH5_0| M1 N1 M2 N2 H5_1 HrecH5_1 H5_0 HrecH5_0| o M N H5 HrecH5]; intros M' N' H6; [ induction H6 as [M0 N0 H5| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K0 L0 H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M N H| M N K L H6_1 HrecH6_1 H6_0 HrecH6_0| M0 N0 M3 N3 H6_1 HrecH6_1 H6_0 HrecH6_0| o M N H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o0 M0 N0 H6 HrecH6] ].
intro.
apply (H4 M N H M0 N0 H5 H6).
intro.
cut (M = inv (MEnc M0 K)).
simpl in |- *.
intro.
case (H1 M N H M0 K H6 N0 L); intro; tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (MPair M1 M2)).
simpl in |- *.
intro.
rewrite H6 in H.
generalize (H3 M1 M2 N).
tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (Mop o M0)).
simpl in |- *.
intro.
generalize (H2 (inv_op o) M N H M0 H7 N0).
tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
simpl in |- *.
cut (synthesis h M0 N0).
intro.
intro.
cut (synthesis h (MEnc M K) (MEnc N L)).
intro.
apply (H4bis M0 N0 H5 (MEnc M K) (MEnc N L) H7 H6).
apply SynEnc; trivial.
apply SynInc; trivial.
simpl in |- *.
intro.
inversion H.
cut (synthesis h (MEnc M0 K0) (MEnc N0 L0)); try (apply SynEnc; trivial).
intro.
cut (synthesis h (MEnc M K) (MEnc N L)); try (apply SynEnc; trivial).
intro.
apply (H4bis (MEnc M0 K0) (MEnc N0 L0) H5 (MEnc M K) (MEnc N L) H8 H).
simpl in |- *.
intro.
inversion H.
simpl in |- *.
intro.
inversion H.
simpl in |- *.
cut (synthesis h M N); try (apply SynInc; trivial).
intro.
cut (synthesis h (MPair M1 M2) (MPair N1 N2)); try (apply SynPair; trivial).
intro.
intro.
apply (H4bis M N H5 (MPair M1 M2) (MPair N1 N2) H6 H7).
simpl in |- *.
intro.
inversion H.
simpl in |- *.
intro.
cut (synthesis h (MPair M1 M2) (MPair N1 N2)); try (apply SynPair; trivial).
intro.
cut (synthesis h (MPair M0 M3) (MPair N0 N3)); try (apply SynPair; trivial).

*****
H5 : synthesis h (MPair M1 M2) (MPair N1 N2)
H : eq (MPair M0 M3) (MPair M1 M2)
HrecH6_0 : forall _ : eq M3 (inv (MPair M1 M2)), eq N3 (inv (MPair N1 N2))
HrecH6_1 : forall _ : eq M0 (inv (MPair M1 M2)), eq N0 (inv (MPair N1 N2))
H6_0 : synthesis h M3 N3
H6_1 : synthesis h M0 N0
M0,N0,M3,N3 : Msg
HrecH5_0 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M' (inv M2)),\neq N' (inv N2)
HrecH5_1 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M' (inv M1)),\neq N' (inv N1)
H5_0 : synthesis h M2 N2
H5_1 : synthesis h M1 N1
M1,N1,M2,N2 : Msg
H4bis : forall (M N : Msg) (_ : synthesis h M N) (M' N' : Msg)\n (_ : synthesis h M' N') (_ : eq M M'), eq N N'
H4 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M' (inv M)), eq N' (inv N)
H3 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H2 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H1 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H0 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
forall _ : synthesis h (MPair M0 M3) (MPair N0 N3), eq (MPair N0 N3) (MPair N1 N2)
+++++
intro.
-----
Theorem inj_inv_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_inv_left h -> injective_inv_left (synthesis h).
intro h.
intros H0 H1 H2 H3 H4.
generalize (inj_left_syn h H0 H1 H2 H3).
intro H4bis.
unfold injective_left in H0.
unfold enc_synthesis_left in H1.
unfold op_synthesis_left in H2.
unfold pair_free_left in H3.
unfold injective_inv_left in H4.
unfold injective_left in H4bis.
unfold injective_inv_left in |- *.
intros M N H5.
induction H5 as [M N H| M N K L H5_1 HrecH5_1 H5_0 HrecH5_0| M1 N1 M2 N2 H5_1 HrecH5_1 H5_0 HrecH5_0| o M N H5 HrecH5]; intros M' N' H6; [ induction H6 as [M0 N0 H5| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K0 L0 H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M N H| M N K L H6_1 HrecH6_1 H6_0 HrecH6_0| M0 N0 M3 N3 H6_1 HrecH6_1 H6_0 HrecH6_0| o M N H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o0 M0 N0 H6 HrecH6] ].
intro.
apply (H4 M N H M0 N0 H5 H6).
intro.
cut (M = inv (MEnc M0 K)).
simpl in |- *.
intro.
case (H1 M N H M0 K H6 N0 L); intro; tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (MPair M1 M2)).
simpl in |- *.
intro.
rewrite H6 in H.
generalize (H3 M1 M2 N).
tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (Mop o M0)).
simpl in |- *.
intro.
generalize (H2 (inv_op o) M N H M0 H7 N0).
tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
simpl in |- *.
cut (synthesis h M0 N0).
intro.
intro.
cut (synthesis h (MEnc M K) (MEnc N L)).
intro.
apply (H4bis M0 N0 H5 (MEnc M K) (MEnc N L) H7 H6).
apply SynEnc; trivial.
apply SynInc; trivial.
simpl in |- *.
intro.
inversion H.
cut (synthesis h (MEnc M0 K0) (MEnc N0 L0)); try (apply SynEnc; trivial).
intro.
cut (synthesis h (MEnc M K) (MEnc N L)); try (apply SynEnc; trivial).
intro.
apply (H4bis (MEnc M0 K0) (MEnc N0 L0) H5 (MEnc M K) (MEnc N L) H8 H).
simpl in |- *.
intro.
inversion H.
simpl in |- *.
intro.
inversion H.
simpl in |- *.
cut (synthesis h M N); try (apply SynInc; trivial).
intro.
cut (synthesis h (MPair M1 M2) (MPair N1 N2)); try (apply SynPair; trivial).
intro.
intro.
apply (H4bis M N H5 (MPair M1 M2) (MPair N1 N2) H6 H7).
simpl in |- *.
intro.
inversion H.
simpl in |- *.
intro.
cut (synthesis h (MPair M1 M2) (MPair N1 N2)); try (apply SynPair; trivial).
intro.
cut (synthesis h (MPair M0 M3) (MPair N0 N3)); try (apply SynPair; trivial).
intro.

*****
H6 : synthesis h (MPair M0 M3) (MPair N0 N3)
H5 : synthesis h (MPair M1 M2) (MPair N1 N2)
H : eq (MPair M0 M3) (MPair M1 M2)
HrecH6_0 : forall _ : eq M3 (inv (MPair M1 M2)), eq N3 (inv (MPair N1 N2))
HrecH6_1 : forall _ : eq M0 (inv (MPair M1 M2)), eq N0 (inv (MPair N1 N2))
H6_0 : synthesis h M3 N3
H6_1 : synthesis h M0 N0
M0,N0,M3,N3 : Msg
HrecH5_0 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M' (inv M2)),\neq N' (inv N2)
HrecH5_1 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M' (inv M1)),\neq N' (inv N1)
H5_0 : synthesis h M2 N2
H5_1 : synthesis h M1 N1
M1,N1,M2,N2 : Msg
H4bis : forall (M N : Msg) (_ : synthesis h M N) (M' N' : Msg)\n (_ : synthesis h M' N') (_ : eq M M'), eq N N'
H4 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M' (inv M)), eq N' (inv N)
H3 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H2 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H1 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H0 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
eq (MPair N0 N3) (MPair N1 N2)
+++++
apply (H4bis (MPair M0 M3) (MPair N0 N3) H6 (MPair M1 M2) (MPair N1 N2) H5 H).
-----
Theorem inj_inv_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_inv_left h -> injective_inv_left (synthesis h).
intro h.
intros H0 H1 H2 H3 H4.
generalize (inj_left_syn h H0 H1 H2 H3).
intro H4bis.
unfold injective_left in H0.
unfold enc_synthesis_left in H1.
unfold op_synthesis_left in H2.
unfold pair_free_left in H3.
unfold injective_inv_left in H4.
unfold injective_left in H4bis.
unfold injective_inv_left in |- *.
intros M N H5.
induction H5 as [M N H| M N K L H5_1 HrecH5_1 H5_0 HrecH5_0| M1 N1 M2 N2 H5_1 HrecH5_1 H5_0 HrecH5_0| o M N H5 HrecH5]; intros M' N' H6; [ induction H6 as [M0 N0 H5| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K0 L0 H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M N H| M N K L H6_1 HrecH6_1 H6_0 HrecH6_0| M0 N0 M3 N3 H6_1 HrecH6_1 H6_0 HrecH6_0| o M N H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o0 M0 N0 H6 HrecH6] ].
intro.
apply (H4 M N H M0 N0 H5 H6).
intro.
cut (M = inv (MEnc M0 K)).
simpl in |- *.
intro.
case (H1 M N H M0 K H6 N0 L); intro; tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (MPair M1 M2)).
simpl in |- *.
intro.
rewrite H6 in H.
generalize (H3 M1 M2 N).
tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (Mop o M0)).
simpl in |- *.
intro.
generalize (H2 (inv_op o) M N H M0 H7 N0).
tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
simpl in |- *.
cut (synthesis h M0 N0).
intro.
intro.
cut (synthesis h (MEnc M K) (MEnc N L)).
intro.
apply (H4bis M0 N0 H5 (MEnc M K) (MEnc N L) H7 H6).
apply SynEnc; trivial.
apply SynInc; trivial.
simpl in |- *.
intro.
inversion H.
cut (synthesis h (MEnc M0 K0) (MEnc N0 L0)); try (apply SynEnc; trivial).
intro.
cut (synthesis h (MEnc M K) (MEnc N L)); try (apply SynEnc; trivial).
intro.
apply (H4bis (MEnc M0 K0) (MEnc N0 L0) H5 (MEnc M K) (MEnc N L) H8 H).
simpl in |- *.
intro.
inversion H.
simpl in |- *.
intro.
inversion H.
simpl in |- *.
cut (synthesis h M N); try (apply SynInc; trivial).
intro.
cut (synthesis h (MPair M1 M2) (MPair N1 N2)); try (apply SynPair; trivial).
intro.
intro.
apply (H4bis M N H5 (MPair M1 M2) (MPair N1 N2) H6 H7).
simpl in |- *.
intro.
inversion H.
simpl in |- *.
intro.
cut (synthesis h (MPair M1 M2) (MPair N1 N2)); try (apply SynPair; trivial).
intro.
cut (synthesis h (MPair M0 M3) (MPair N0 N3)); try (apply SynPair; trivial).
intro.
apply (H4bis (MPair M0 M3) (MPair N0 N3) H6 (MPair M1 M2) (MPair N1 N2) H5 H).

*****
HrecH6 : forall _ : eq M (inv (MPair M1 M2)), eq N (inv (MPair N1 N2))
H6 : synthesis h M N
M,N : Msg
o : op
HrecH5_0 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M' (inv M2)),\neq N' (inv N2)
HrecH5_1 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M' (inv M1)),\neq N' (inv N1)
H5_0 : synthesis h M2 N2
H5_1 : synthesis h M1 N1
M1,N1,M2,N2 : Msg
H4bis : forall (M N : Msg) (_ : synthesis h M N) (M' N' : Msg)\n (_ : synthesis h M' N') (_ : eq M M'), eq N N'
H4 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M' (inv M)), eq N' (inv N)
H3 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H2 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H1 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H0 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
forall _ : eq (Mop o M) (inv (MPair M1 M2)), eq (Mop o N) (inv (MPair N1 N2))
+++++
simpl in |- *.
-----
Theorem inj_inv_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_inv_left h -> injective_inv_left (synthesis h).
intro h.
intros H0 H1 H2 H3 H4.
generalize (inj_left_syn h H0 H1 H2 H3).
intro H4bis.
unfold injective_left in H0.
unfold enc_synthesis_left in H1.
unfold op_synthesis_left in H2.
unfold pair_free_left in H3.
unfold injective_inv_left in H4.
unfold injective_left in H4bis.
unfold injective_inv_left in |- *.
intros M N H5.
induction H5 as [M N H| M N K L H5_1 HrecH5_1 H5_0 HrecH5_0| M1 N1 M2 N2 H5_1 HrecH5_1 H5_0 HrecH5_0| o M N H5 HrecH5]; intros M' N' H6; [ induction H6 as [M0 N0 H5| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K0 L0 H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M N H| M N K L H6_1 HrecH6_1 H6_0 HrecH6_0| M0 N0 M3 N3 H6_1 HrecH6_1 H6_0 HrecH6_0| o M N H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o0 M0 N0 H6 HrecH6] ].
intro.
apply (H4 M N H M0 N0 H5 H6).
intro.
cut (M = inv (MEnc M0 K)).
simpl in |- *.
intro.
case (H1 M N H M0 K H6 N0 L); intro; tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (MPair M1 M2)).
simpl in |- *.
intro.
rewrite H6 in H.
generalize (H3 M1 M2 N).
tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (Mop o M0)).
simpl in |- *.
intro.
generalize (H2 (inv_op o) M N H M0 H7 N0).
tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
simpl in |- *.
cut (synthesis h M0 N0).
intro.
intro.
cut (synthesis h (MEnc M K) (MEnc N L)).
intro.
apply (H4bis M0 N0 H5 (MEnc M K) (MEnc N L) H7 H6).
apply SynEnc; trivial.
apply SynInc; trivial.
simpl in |- *.
intro.
inversion H.
cut (synthesis h (MEnc M0 K0) (MEnc N0 L0)); try (apply SynEnc; trivial).
intro.
cut (synthesis h (MEnc M K) (MEnc N L)); try (apply SynEnc; trivial).
intro.
apply (H4bis (MEnc M0 K0) (MEnc N0 L0) H5 (MEnc M K) (MEnc N L) H8 H).
simpl in |- *.
intro.
inversion H.
simpl in |- *.
intro.
inversion H.
simpl in |- *.
cut (synthesis h M N); try (apply SynInc; trivial).
intro.
cut (synthesis h (MPair M1 M2) (MPair N1 N2)); try (apply SynPair; trivial).
intro.
intro.
apply (H4bis M N H5 (MPair M1 M2) (MPair N1 N2) H6 H7).
simpl in |- *.
intro.
inversion H.
simpl in |- *.
intro.
cut (synthesis h (MPair M1 M2) (MPair N1 N2)); try (apply SynPair; trivial).
intro.
cut (synthesis h (MPair M0 M3) (MPair N0 N3)); try (apply SynPair; trivial).
intro.
apply (H4bis (MPair M0 M3) (MPair N0 N3) H6 (MPair M1 M2) (MPair N1 N2) H5 H).
simpl in |- *.

*****
HrecH6 : forall _ : eq M (inv (MPair M1 M2)), eq N (inv (MPair N1 N2))
H6 : synthesis h M N
M,N : Msg
o : op
HrecH5_0 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M' (inv M2)),\neq N' (inv N2)
HrecH5_1 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M' (inv M1)),\neq N' (inv N1)
H5_0 : synthesis h M2 N2
H5_1 : synthesis h M1 N1
M1,N1,M2,N2 : Msg
H4bis : forall (M N : Msg) (_ : synthesis h M N) (M' N' : Msg)\n (_ : synthesis h M' N') (_ : eq M M'), eq N N'
H4 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M' (inv M)), eq N' (inv N)
H3 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H2 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H1 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H0 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
forall _ : eq (Mop o M) (MPair M1 M2), eq (Mop o N) (MPair N1 N2)
+++++
intro.
-----
Theorem inj_inv_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_inv_left h -> injective_inv_left (synthesis h).
intro h.
intros H0 H1 H2 H3 H4.
generalize (inj_left_syn h H0 H1 H2 H3).
intro H4bis.
unfold injective_left in H0.
unfold enc_synthesis_left in H1.
unfold op_synthesis_left in H2.
unfold pair_free_left in H3.
unfold injective_inv_left in H4.
unfold injective_left in H4bis.
unfold injective_inv_left in |- *.
intros M N H5.
induction H5 as [M N H| M N K L H5_1 HrecH5_1 H5_0 HrecH5_0| M1 N1 M2 N2 H5_1 HrecH5_1 H5_0 HrecH5_0| o M N H5 HrecH5]; intros M' N' H6; [ induction H6 as [M0 N0 H5| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K0 L0 H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M N H| M N K L H6_1 HrecH6_1 H6_0 HrecH6_0| M0 N0 M3 N3 H6_1 HrecH6_1 H6_0 HrecH6_0| o M N H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o0 M0 N0 H6 HrecH6] ].
intro.
apply (H4 M N H M0 N0 H5 H6).
intro.
cut (M = inv (MEnc M0 K)).
simpl in |- *.
intro.
case (H1 M N H M0 K H6 N0 L); intro; tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (MPair M1 M2)).
simpl in |- *.
intro.
rewrite H6 in H.
generalize (H3 M1 M2 N).
tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (Mop o M0)).
simpl in |- *.
intro.
generalize (H2 (inv_op o) M N H M0 H7 N0).
tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
simpl in |- *.
cut (synthesis h M0 N0).
intro.
intro.
cut (synthesis h (MEnc M K) (MEnc N L)).
intro.
apply (H4bis M0 N0 H5 (MEnc M K) (MEnc N L) H7 H6).
apply SynEnc; trivial.
apply SynInc; trivial.
simpl in |- *.
intro.
inversion H.
cut (synthesis h (MEnc M0 K0) (MEnc N0 L0)); try (apply SynEnc; trivial).
intro.
cut (synthesis h (MEnc M K) (MEnc N L)); try (apply SynEnc; trivial).
intro.
apply (H4bis (MEnc M0 K0) (MEnc N0 L0) H5 (MEnc M K) (MEnc N L) H8 H).
simpl in |- *.
intro.
inversion H.
simpl in |- *.
intro.
inversion H.
simpl in |- *.
cut (synthesis h M N); try (apply SynInc; trivial).
intro.
cut (synthesis h (MPair M1 M2) (MPair N1 N2)); try (apply SynPair; trivial).
intro.
intro.
apply (H4bis M N H5 (MPair M1 M2) (MPair N1 N2) H6 H7).
simpl in |- *.
intro.
inversion H.
simpl in |- *.
intro.
cut (synthesis h (MPair M1 M2) (MPair N1 N2)); try (apply SynPair; trivial).
intro.
cut (synthesis h (MPair M0 M3) (MPair N0 N3)); try (apply SynPair; trivial).
intro.
apply (H4bis (MPair M0 M3) (MPair N0 N3) H6 (MPair M1 M2) (MPair N1 N2) H5 H).
simpl in |- *.
intro.

*****
H : eq (Mop o M) (MPair M1 M2)
HrecH6 : forall _ : eq M (inv (MPair M1 M2)), eq N (inv (MPair N1 N2))
H6 : synthesis h M N
M,N : Msg
o : op
HrecH5_0 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M' (inv M2)),\neq N' (inv N2)
HrecH5_1 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M' (inv M1)),\neq N' (inv N1)
H5_0 : synthesis h M2 N2
H5_1 : synthesis h M1 N1
M1,N1,M2,N2 : Msg
H4bis : forall (M N : Msg) (_ : synthesis h M N) (M' N' : Msg)\n (_ : synthesis h M' N') (_ : eq M M'), eq N N'
H4 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M' (inv M)), eq N' (inv N)
H3 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H2 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H1 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H0 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
eq (Mop o N) (MPair N1 N2)
+++++
inversion H.
-----
Theorem inj_inv_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_inv_left h -> injective_inv_left (synthesis h).
intro h.
intros H0 H1 H2 H3 H4.
generalize (inj_left_syn h H0 H1 H2 H3).
intro H4bis.
unfold injective_left in H0.
unfold enc_synthesis_left in H1.
unfold op_synthesis_left in H2.
unfold pair_free_left in H3.
unfold injective_inv_left in H4.
unfold injective_left in H4bis.
unfold injective_inv_left in |- *.
intros M N H5.
induction H5 as [M N H| M N K L H5_1 HrecH5_1 H5_0 HrecH5_0| M1 N1 M2 N2 H5_1 HrecH5_1 H5_0 HrecH5_0| o M N H5 HrecH5]; intros M' N' H6; [ induction H6 as [M0 N0 H5| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K0 L0 H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M N H| M N K L H6_1 HrecH6_1 H6_0 HrecH6_0| M0 N0 M3 N3 H6_1 HrecH6_1 H6_0 HrecH6_0| o M N H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o0 M0 N0 H6 HrecH6] ].
intro.
apply (H4 M N H M0 N0 H5 H6).
intro.
cut (M = inv (MEnc M0 K)).
simpl in |- *.
intro.
case (H1 M N H M0 K H6 N0 L); intro; tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (MPair M1 M2)).
simpl in |- *.
intro.
rewrite H6 in H.
generalize (H3 M1 M2 N).
tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (Mop o M0)).
simpl in |- *.
intro.
generalize (H2 (inv_op o) M N H M0 H7 N0).
tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
simpl in |- *.
cut (synthesis h M0 N0).
intro.
intro.
cut (synthesis h (MEnc M K) (MEnc N L)).
intro.
apply (H4bis M0 N0 H5 (MEnc M K) (MEnc N L) H7 H6).
apply SynEnc; trivial.
apply SynInc; trivial.
simpl in |- *.
intro.
inversion H.
cut (synthesis h (MEnc M0 K0) (MEnc N0 L0)); try (apply SynEnc; trivial).
intro.
cut (synthesis h (MEnc M K) (MEnc N L)); try (apply SynEnc; trivial).
intro.
apply (H4bis (MEnc M0 K0) (MEnc N0 L0) H5 (MEnc M K) (MEnc N L) H8 H).
simpl in |- *.
intro.
inversion H.
simpl in |- *.
intro.
inversion H.
simpl in |- *.
cut (synthesis h M N); try (apply SynInc; trivial).
intro.
cut (synthesis h (MPair M1 M2) (MPair N1 N2)); try (apply SynPair; trivial).
intro.
intro.
apply (H4bis M N H5 (MPair M1 M2) (MPair N1 N2) H6 H7).
simpl in |- *.
intro.
inversion H.
simpl in |- *.
intro.
cut (synthesis h (MPair M1 M2) (MPair N1 N2)); try (apply SynPair; trivial).
intro.
cut (synthesis h (MPair M0 M3) (MPair N0 N3)); try (apply SynPair; trivial).
intro.
apply (H4bis (MPair M0 M3) (MPair N0 N3) H6 (MPair M1 M2) (MPair N1 N2) H5 H).
simpl in |- *.
intro.
inversion H.

*****
H : h M0 N0
M0,N0 : Msg
HrecH5 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M' (inv M)),\neq N' (inv N)
H5 : synthesis h M N
M,N : Msg
o : op
H4bis : forall (M N : Msg) (_ : synthesis h M N) (M' N' : Msg)\n (_ : synthesis h M' N') (_ : eq M M'), eq N N'
H4 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M' (inv M)), eq N' (inv N)
H3 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H2 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H1 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H0 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
forall _ : eq M0 (inv (Mop o M)), eq N0 (inv (Mop o N))
+++++
simpl in |- *.
-----
Theorem inj_inv_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_inv_left h -> injective_inv_left (synthesis h).
intro h.
intros H0 H1 H2 H3 H4.
generalize (inj_left_syn h H0 H1 H2 H3).
intro H4bis.
unfold injective_left in H0.
unfold enc_synthesis_left in H1.
unfold op_synthesis_left in H2.
unfold pair_free_left in H3.
unfold injective_inv_left in H4.
unfold injective_left in H4bis.
unfold injective_inv_left in |- *.
intros M N H5.
induction H5 as [M N H| M N K L H5_1 HrecH5_1 H5_0 HrecH5_0| M1 N1 M2 N2 H5_1 HrecH5_1 H5_0 HrecH5_0| o M N H5 HrecH5]; intros M' N' H6; [ induction H6 as [M0 N0 H5| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K0 L0 H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M N H| M N K L H6_1 HrecH6_1 H6_0 HrecH6_0| M0 N0 M3 N3 H6_1 HrecH6_1 H6_0 HrecH6_0| o M N H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o0 M0 N0 H6 HrecH6] ].
intro.
apply (H4 M N H M0 N0 H5 H6).
intro.
cut (M = inv (MEnc M0 K)).
simpl in |- *.
intro.
case (H1 M N H M0 K H6 N0 L); intro; tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (MPair M1 M2)).
simpl in |- *.
intro.
rewrite H6 in H.
generalize (H3 M1 M2 N).
tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (Mop o M0)).
simpl in |- *.
intro.
generalize (H2 (inv_op o) M N H M0 H7 N0).
tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
simpl in |- *.
cut (synthesis h M0 N0).
intro.
intro.
cut (synthesis h (MEnc M K) (MEnc N L)).
intro.
apply (H4bis M0 N0 H5 (MEnc M K) (MEnc N L) H7 H6).
apply SynEnc; trivial.
apply SynInc; trivial.
simpl in |- *.
intro.
inversion H.
cut (synthesis h (MEnc M0 K0) (MEnc N0 L0)); try (apply SynEnc; trivial).
intro.
cut (synthesis h (MEnc M K) (MEnc N L)); try (apply SynEnc; trivial).
intro.
apply (H4bis (MEnc M0 K0) (MEnc N0 L0) H5 (MEnc M K) (MEnc N L) H8 H).
simpl in |- *.
intro.
inversion H.
simpl in |- *.
intro.
inversion H.
simpl in |- *.
cut (synthesis h M N); try (apply SynInc; trivial).
intro.
cut (synthesis h (MPair M1 M2) (MPair N1 N2)); try (apply SynPair; trivial).
intro.
intro.
apply (H4bis M N H5 (MPair M1 M2) (MPair N1 N2) H6 H7).
simpl in |- *.
intro.
inversion H.
simpl in |- *.
intro.
cut (synthesis h (MPair M1 M2) (MPair N1 N2)); try (apply SynPair; trivial).
intro.
cut (synthesis h (MPair M0 M3) (MPair N0 N3)); try (apply SynPair; trivial).
intro.
apply (H4bis (MPair M0 M3) (MPair N0 N3) H6 (MPair M1 M2) (MPair N1 N2) H5 H).
simpl in |- *.
intro.
inversion H.
simpl in |- *.

*****
H : h M0 N0
M0,N0 : Msg
HrecH5 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M' (inv M)),\neq N' (inv N)
H5 : synthesis h M N
M,N : Msg
o : op
H4bis : forall (M N : Msg) (_ : synthesis h M N) (M' N' : Msg)\n (_ : synthesis h M' N') (_ : eq M M'), eq N N'
H4 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M' (inv M)), eq N' (inv N)
H3 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H2 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H1 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H0 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
forall _ : eq M0 (Mop (inv_op o) M), eq N0 (Mop (inv_op o) N)
+++++
cut (synthesis h M0 N0); try (apply SynInc; trivial).
-----
Theorem inj_inv_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_inv_left h -> injective_inv_left (synthesis h).
intro h.
intros H0 H1 H2 H3 H4.
generalize (inj_left_syn h H0 H1 H2 H3).
intro H4bis.
unfold injective_left in H0.
unfold enc_synthesis_left in H1.
unfold op_synthesis_left in H2.
unfold pair_free_left in H3.
unfold injective_inv_left in H4.
unfold injective_left in H4bis.
unfold injective_inv_left in |- *.
intros M N H5.
induction H5 as [M N H| M N K L H5_1 HrecH5_1 H5_0 HrecH5_0| M1 N1 M2 N2 H5_1 HrecH5_1 H5_0 HrecH5_0| o M N H5 HrecH5]; intros M' N' H6; [ induction H6 as [M0 N0 H5| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K0 L0 H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M N H| M N K L H6_1 HrecH6_1 H6_0 HrecH6_0| M0 N0 M3 N3 H6_1 HrecH6_1 H6_0 HrecH6_0| o M N H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o0 M0 N0 H6 HrecH6] ].
intro.
apply (H4 M N H M0 N0 H5 H6).
intro.
cut (M = inv (MEnc M0 K)).
simpl in |- *.
intro.
case (H1 M N H M0 K H6 N0 L); intro; tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (MPair M1 M2)).
simpl in |- *.
intro.
rewrite H6 in H.
generalize (H3 M1 M2 N).
tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (Mop o M0)).
simpl in |- *.
intro.
generalize (H2 (inv_op o) M N H M0 H7 N0).
tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
simpl in |- *.
cut (synthesis h M0 N0).
intro.
intro.
cut (synthesis h (MEnc M K) (MEnc N L)).
intro.
apply (H4bis M0 N0 H5 (MEnc M K) (MEnc N L) H7 H6).
apply SynEnc; trivial.
apply SynInc; trivial.
simpl in |- *.
intro.
inversion H.
cut (synthesis h (MEnc M0 K0) (MEnc N0 L0)); try (apply SynEnc; trivial).
intro.
cut (synthesis h (MEnc M K) (MEnc N L)); try (apply SynEnc; trivial).
intro.
apply (H4bis (MEnc M0 K0) (MEnc N0 L0) H5 (MEnc M K) (MEnc N L) H8 H).
simpl in |- *.
intro.
inversion H.
simpl in |- *.
intro.
inversion H.
simpl in |- *.
cut (synthesis h M N); try (apply SynInc; trivial).
intro.
cut (synthesis h (MPair M1 M2) (MPair N1 N2)); try (apply SynPair; trivial).
intro.
intro.
apply (H4bis M N H5 (MPair M1 M2) (MPair N1 N2) H6 H7).
simpl in |- *.
intro.
inversion H.
simpl in |- *.
intro.
cut (synthesis h (MPair M1 M2) (MPair N1 N2)); try (apply SynPair; trivial).
intro.
cut (synthesis h (MPair M0 M3) (MPair N0 N3)); try (apply SynPair; trivial).
intro.
apply (H4bis (MPair M0 M3) (MPair N0 N3) H6 (MPair M1 M2) (MPair N1 N2) H5 H).
simpl in |- *.
intro.
inversion H.
simpl in |- *.
cut (synthesis h M0 N0); try (apply SynInc; trivial).

*****
H : h M0 N0
M0,N0 : Msg
HrecH5 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M' (inv M)),\neq N' (inv N)
H5 : synthesis h M N
M,N : Msg
o : op
H4bis : forall (M N : Msg) (_ : synthesis h M N) (M' N' : Msg)\n (_ : synthesis h M' N') (_ : eq M M'), eq N N'
H4 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M' (inv M)), eq N' (inv N)
H3 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H2 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H1 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H0 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
forall (_ : synthesis h M0 N0) (_ : eq M0 (Mop (inv_op o) M)), eq N0 (Mop (inv_op o) N)
+++++
intro.
-----
Theorem inj_inv_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_inv_left h -> injective_inv_left (synthesis h).
intro h.
intros H0 H1 H2 H3 H4.
generalize (inj_left_syn h H0 H1 H2 H3).
intro H4bis.
unfold injective_left in H0.
unfold enc_synthesis_left in H1.
unfold op_synthesis_left in H2.
unfold pair_free_left in H3.
unfold injective_inv_left in H4.
unfold injective_left in H4bis.
unfold injective_inv_left in |- *.
intros M N H5.
induction H5 as [M N H| M N K L H5_1 HrecH5_1 H5_0 HrecH5_0| M1 N1 M2 N2 H5_1 HrecH5_1 H5_0 HrecH5_0| o M N H5 HrecH5]; intros M' N' H6; [ induction H6 as [M0 N0 H5| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K0 L0 H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M N H| M N K L H6_1 HrecH6_1 H6_0 HrecH6_0| M0 N0 M3 N3 H6_1 HrecH6_1 H6_0 HrecH6_0| o M N H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o0 M0 N0 H6 HrecH6] ].
intro.
apply (H4 M N H M0 N0 H5 H6).
intro.
cut (M = inv (MEnc M0 K)).
simpl in |- *.
intro.
case (H1 M N H M0 K H6 N0 L); intro; tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (MPair M1 M2)).
simpl in |- *.
intro.
rewrite H6 in H.
generalize (H3 M1 M2 N).
tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (Mop o M0)).
simpl in |- *.
intro.
generalize (H2 (inv_op o) M N H M0 H7 N0).
tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
simpl in |- *.
cut (synthesis h M0 N0).
intro.
intro.
cut (synthesis h (MEnc M K) (MEnc N L)).
intro.
apply (H4bis M0 N0 H5 (MEnc M K) (MEnc N L) H7 H6).
apply SynEnc; trivial.
apply SynInc; trivial.
simpl in |- *.
intro.
inversion H.
cut (synthesis h (MEnc M0 K0) (MEnc N0 L0)); try (apply SynEnc; trivial).
intro.
cut (synthesis h (MEnc M K) (MEnc N L)); try (apply SynEnc; trivial).
intro.
apply (H4bis (MEnc M0 K0) (MEnc N0 L0) H5 (MEnc M K) (MEnc N L) H8 H).
simpl in |- *.
intro.
inversion H.
simpl in |- *.
intro.
inversion H.
simpl in |- *.
cut (synthesis h M N); try (apply SynInc; trivial).
intro.
cut (synthesis h (MPair M1 M2) (MPair N1 N2)); try (apply SynPair; trivial).
intro.
intro.
apply (H4bis M N H5 (MPair M1 M2) (MPair N1 N2) H6 H7).
simpl in |- *.
intro.
inversion H.
simpl in |- *.
intro.
cut (synthesis h (MPair M1 M2) (MPair N1 N2)); try (apply SynPair; trivial).
intro.
cut (synthesis h (MPair M0 M3) (MPair N0 N3)); try (apply SynPair; trivial).
intro.
apply (H4bis (MPair M0 M3) (MPair N0 N3) H6 (MPair M1 M2) (MPair N1 N2) H5 H).
simpl in |- *.
intro.
inversion H.
simpl in |- *.
cut (synthesis h M0 N0); try (apply SynInc; trivial).
intro.

*****
H6 : synthesis h M0 N0
H : h M0 N0
M0,N0 : Msg
HrecH5 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M' (inv M)),\neq N' (inv N)
H5 : synthesis h M N
M,N : Msg
o : op
H4bis : forall (M N : Msg) (_ : synthesis h M N) (M' N' : Msg)\n (_ : synthesis h M' N') (_ : eq M M'), eq N N'
H4 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M' (inv M)), eq N' (inv N)
H3 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H2 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H1 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H0 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
forall _ : eq M0 (Mop (inv_op o) M), eq N0 (Mop (inv_op o) N)
+++++
cut (synthesis h (Mop (inv_op o) M) (Mop (inv_op o) N)); try (apply SynOp; trivial).
-----
Theorem inj_inv_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_inv_left h -> injective_inv_left (synthesis h).
intro h.
intros H0 H1 H2 H3 H4.
generalize (inj_left_syn h H0 H1 H2 H3).
intro H4bis.
unfold injective_left in H0.
unfold enc_synthesis_left in H1.
unfold op_synthesis_left in H2.
unfold pair_free_left in H3.
unfold injective_inv_left in H4.
unfold injective_left in H4bis.
unfold injective_inv_left in |- *.
intros M N H5.
induction H5 as [M N H| M N K L H5_1 HrecH5_1 H5_0 HrecH5_0| M1 N1 M2 N2 H5_1 HrecH5_1 H5_0 HrecH5_0| o M N H5 HrecH5]; intros M' N' H6; [ induction H6 as [M0 N0 H5| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K0 L0 H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M N H| M N K L H6_1 HrecH6_1 H6_0 HrecH6_0| M0 N0 M3 N3 H6_1 HrecH6_1 H6_0 HrecH6_0| o M N H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o0 M0 N0 H6 HrecH6] ].
intro.
apply (H4 M N H M0 N0 H5 H6).
intro.
cut (M = inv (MEnc M0 K)).
simpl in |- *.
intro.
case (H1 M N H M0 K H6 N0 L); intro; tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (MPair M1 M2)).
simpl in |- *.
intro.
rewrite H6 in H.
generalize (H3 M1 M2 N).
tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (Mop o M0)).
simpl in |- *.
intro.
generalize (H2 (inv_op o) M N H M0 H7 N0).
tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
simpl in |- *.
cut (synthesis h M0 N0).
intro.
intro.
cut (synthesis h (MEnc M K) (MEnc N L)).
intro.
apply (H4bis M0 N0 H5 (MEnc M K) (MEnc N L) H7 H6).
apply SynEnc; trivial.
apply SynInc; trivial.
simpl in |- *.
intro.
inversion H.
cut (synthesis h (MEnc M0 K0) (MEnc N0 L0)); try (apply SynEnc; trivial).
intro.
cut (synthesis h (MEnc M K) (MEnc N L)); try (apply SynEnc; trivial).
intro.
apply (H4bis (MEnc M0 K0) (MEnc N0 L0) H5 (MEnc M K) (MEnc N L) H8 H).
simpl in |- *.
intro.
inversion H.
simpl in |- *.
intro.
inversion H.
simpl in |- *.
cut (synthesis h M N); try (apply SynInc; trivial).
intro.
cut (synthesis h (MPair M1 M2) (MPair N1 N2)); try (apply SynPair; trivial).
intro.
intro.
apply (H4bis M N H5 (MPair M1 M2) (MPair N1 N2) H6 H7).
simpl in |- *.
intro.
inversion H.
simpl in |- *.
intro.
cut (synthesis h (MPair M1 M2) (MPair N1 N2)); try (apply SynPair; trivial).
intro.
cut (synthesis h (MPair M0 M3) (MPair N0 N3)); try (apply SynPair; trivial).
intro.
apply (H4bis (MPair M0 M3) (MPair N0 N3) H6 (MPair M1 M2) (MPair N1 N2) H5 H).
simpl in |- *.
intro.
inversion H.
simpl in |- *.
cut (synthesis h M0 N0); try (apply SynInc; trivial).
intro.
cut (synthesis h (Mop (inv_op o) M) (Mop (inv_op o) N)); try (apply SynOp; trivial).

*****
H6 : synthesis h M0 N0
H : h M0 N0
M0,N0 : Msg
HrecH5 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M' (inv M)),\neq N' (inv N)
H5 : synthesis h M N
M,N : Msg
o : op
H4bis : forall (M N : Msg) (_ : synthesis h M N) (M' N' : Msg)\n (_ : synthesis h M' N') (_ : eq M M'), eq N N'
H4 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M' (inv M)), eq N' (inv N)
H3 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H2 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H1 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H0 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
forall (_ : synthesis h (Mop (inv_op o) M) (Mop (inv_op o) N)) (_ : eq M0 (Mop (inv_op o) M)), eq N0 (Mop (inv_op o) N)
+++++
intro.
-----
Theorem inj_inv_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_inv_left h -> injective_inv_left (synthesis h).
intro h.
intros H0 H1 H2 H3 H4.
generalize (inj_left_syn h H0 H1 H2 H3).
intro H4bis.
unfold injective_left in H0.
unfold enc_synthesis_left in H1.
unfold op_synthesis_left in H2.
unfold pair_free_left in H3.
unfold injective_inv_left in H4.
unfold injective_left in H4bis.
unfold injective_inv_left in |- *.
intros M N H5.
induction H5 as [M N H| M N K L H5_1 HrecH5_1 H5_0 HrecH5_0| M1 N1 M2 N2 H5_1 HrecH5_1 H5_0 HrecH5_0| o M N H5 HrecH5]; intros M' N' H6; [ induction H6 as [M0 N0 H5| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K0 L0 H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M N H| M N K L H6_1 HrecH6_1 H6_0 HrecH6_0| M0 N0 M3 N3 H6_1 HrecH6_1 H6_0 HrecH6_0| o M N H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o0 M0 N0 H6 HrecH6] ].
intro.
apply (H4 M N H M0 N0 H5 H6).
intro.
cut (M = inv (MEnc M0 K)).
simpl in |- *.
intro.
case (H1 M N H M0 K H6 N0 L); intro; tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (MPair M1 M2)).
simpl in |- *.
intro.
rewrite H6 in H.
generalize (H3 M1 M2 N).
tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (Mop o M0)).
simpl in |- *.
intro.
generalize (H2 (inv_op o) M N H M0 H7 N0).
tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
simpl in |- *.
cut (synthesis h M0 N0).
intro.
intro.
cut (synthesis h (MEnc M K) (MEnc N L)).
intro.
apply (H4bis M0 N0 H5 (MEnc M K) (MEnc N L) H7 H6).
apply SynEnc; trivial.
apply SynInc; trivial.
simpl in |- *.
intro.
inversion H.
cut (synthesis h (MEnc M0 K0) (MEnc N0 L0)); try (apply SynEnc; trivial).
intro.
cut (synthesis h (MEnc M K) (MEnc N L)); try (apply SynEnc; trivial).
intro.
apply (H4bis (MEnc M0 K0) (MEnc N0 L0) H5 (MEnc M K) (MEnc N L) H8 H).
simpl in |- *.
intro.
inversion H.
simpl in |- *.
intro.
inversion H.
simpl in |- *.
cut (synthesis h M N); try (apply SynInc; trivial).
intro.
cut (synthesis h (MPair M1 M2) (MPair N1 N2)); try (apply SynPair; trivial).
intro.
intro.
apply (H4bis M N H5 (MPair M1 M2) (MPair N1 N2) H6 H7).
simpl in |- *.
intro.
inversion H.
simpl in |- *.
intro.
cut (synthesis h (MPair M1 M2) (MPair N1 N2)); try (apply SynPair; trivial).
intro.
cut (synthesis h (MPair M0 M3) (MPair N0 N3)); try (apply SynPair; trivial).
intro.
apply (H4bis (MPair M0 M3) (MPair N0 N3) H6 (MPair M1 M2) (MPair N1 N2) H5 H).
simpl in |- *.
intro.
inversion H.
simpl in |- *.
cut (synthesis h M0 N0); try (apply SynInc; trivial).
intro.
cut (synthesis h (Mop (inv_op o) M) (Mop (inv_op o) N)); try (apply SynOp; trivial).
intro.

*****
H7 : synthesis h (Mop (inv_op o) M) (Mop (inv_op o) N)
H6 : synthesis h M0 N0
H : h M0 N0
M0,N0 : Msg
HrecH5 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M' (inv M)),\neq N' (inv N)
H5 : synthesis h M N
M,N : Msg
o : op
H4bis : forall (M N : Msg) (_ : synthesis h M N) (M' N' : Msg)\n (_ : synthesis h M' N') (_ : eq M M'), eq N N'
H4 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M' (inv M)), eq N' (inv N)
H3 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H2 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H1 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H0 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
forall _ : eq M0 (Mop (inv_op o) M), eq N0 (Mop (inv_op o) N)
+++++
intro.
-----
Theorem inj_inv_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_inv_left h -> injective_inv_left (synthesis h).
intro h.
intros H0 H1 H2 H3 H4.
generalize (inj_left_syn h H0 H1 H2 H3).
intro H4bis.
unfold injective_left in H0.
unfold enc_synthesis_left in H1.
unfold op_synthesis_left in H2.
unfold pair_free_left in H3.
unfold injective_inv_left in H4.
unfold injective_left in H4bis.
unfold injective_inv_left in |- *.
intros M N H5.
induction H5 as [M N H| M N K L H5_1 HrecH5_1 H5_0 HrecH5_0| M1 N1 M2 N2 H5_1 HrecH5_1 H5_0 HrecH5_0| o M N H5 HrecH5]; intros M' N' H6; [ induction H6 as [M0 N0 H5| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K0 L0 H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M N H| M N K L H6_1 HrecH6_1 H6_0 HrecH6_0| M0 N0 M3 N3 H6_1 HrecH6_1 H6_0 HrecH6_0| o M N H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o0 M0 N0 H6 HrecH6] ].
intro.
apply (H4 M N H M0 N0 H5 H6).
intro.
cut (M = inv (MEnc M0 K)).
simpl in |- *.
intro.
case (H1 M N H M0 K H6 N0 L); intro; tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (MPair M1 M2)).
simpl in |- *.
intro.
rewrite H6 in H.
generalize (H3 M1 M2 N).
tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (Mop o M0)).
simpl in |- *.
intro.
generalize (H2 (inv_op o) M N H M0 H7 N0).
tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
simpl in |- *.
cut (synthesis h M0 N0).
intro.
intro.
cut (synthesis h (MEnc M K) (MEnc N L)).
intro.
apply (H4bis M0 N0 H5 (MEnc M K) (MEnc N L) H7 H6).
apply SynEnc; trivial.
apply SynInc; trivial.
simpl in |- *.
intro.
inversion H.
cut (synthesis h (MEnc M0 K0) (MEnc N0 L0)); try (apply SynEnc; trivial).
intro.
cut (synthesis h (MEnc M K) (MEnc N L)); try (apply SynEnc; trivial).
intro.
apply (H4bis (MEnc M0 K0) (MEnc N0 L0) H5 (MEnc M K) (MEnc N L) H8 H).
simpl in |- *.
intro.
inversion H.
simpl in |- *.
intro.
inversion H.
simpl in |- *.
cut (synthesis h M N); try (apply SynInc; trivial).
intro.
cut (synthesis h (MPair M1 M2) (MPair N1 N2)); try (apply SynPair; trivial).
intro.
intro.
apply (H4bis M N H5 (MPair M1 M2) (MPair N1 N2) H6 H7).
simpl in |- *.
intro.
inversion H.
simpl in |- *.
intro.
cut (synthesis h (MPair M1 M2) (MPair N1 N2)); try (apply SynPair; trivial).
intro.
cut (synthesis h (MPair M0 M3) (MPair N0 N3)); try (apply SynPair; trivial).
intro.
apply (H4bis (MPair M0 M3) (MPair N0 N3) H6 (MPair M1 M2) (MPair N1 N2) H5 H).
simpl in |- *.
intro.
inversion H.
simpl in |- *.
cut (synthesis h M0 N0); try (apply SynInc; trivial).
intro.
cut (synthesis h (Mop (inv_op o) M) (Mop (inv_op o) N)); try (apply SynOp; trivial).
intro.
intro.

*****
H8 : eq M0 (Mop (inv_op o) M)
H7 : synthesis h (Mop (inv_op o) M) (Mop (inv_op o) N)
H6 : synthesis h M0 N0
H : h M0 N0
M0,N0 : Msg
HrecH5 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M' (inv M)),\neq N' (inv N)
H5 : synthesis h M N
M,N : Msg
o : op
H4bis : forall (M N : Msg) (_ : synthesis h M N) (M' N' : Msg)\n (_ : synthesis h M' N') (_ : eq M M'), eq N N'
H4 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M' (inv M)), eq N' (inv N)
H3 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H2 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H1 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H0 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
eq N0 (Mop (inv_op o) N)
+++++
apply (H4bis M0 N0 H6 (Mop (inv_op o) M) (Mop (inv_op o) N) H7 H8).
-----
Theorem inj_inv_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_inv_left h -> injective_inv_left (synthesis h).
intro h.
intros H0 H1 H2 H3 H4.
generalize (inj_left_syn h H0 H1 H2 H3).
intro H4bis.
unfold injective_left in H0.
unfold enc_synthesis_left in H1.
unfold op_synthesis_left in H2.
unfold pair_free_left in H3.
unfold injective_inv_left in H4.
unfold injective_left in H4bis.
unfold injective_inv_left in |- *.
intros M N H5.
induction H5 as [M N H| M N K L H5_1 HrecH5_1 H5_0 HrecH5_0| M1 N1 M2 N2 H5_1 HrecH5_1 H5_0 HrecH5_0| o M N H5 HrecH5]; intros M' N' H6; [ induction H6 as [M0 N0 H5| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K0 L0 H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M N H| M N K L H6_1 HrecH6_1 H6_0 HrecH6_0| M0 N0 M3 N3 H6_1 HrecH6_1 H6_0 HrecH6_0| o M N H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o0 M0 N0 H6 HrecH6] ].
intro.
apply (H4 M N H M0 N0 H5 H6).
intro.
cut (M = inv (MEnc M0 K)).
simpl in |- *.
intro.
case (H1 M N H M0 K H6 N0 L); intro; tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (MPair M1 M2)).
simpl in |- *.
intro.
rewrite H6 in H.
generalize (H3 M1 M2 N).
tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (Mop o M0)).
simpl in |- *.
intro.
generalize (H2 (inv_op o) M N H M0 H7 N0).
tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
simpl in |- *.
cut (synthesis h M0 N0).
intro.
intro.
cut (synthesis h (MEnc M K) (MEnc N L)).
intro.
apply (H4bis M0 N0 H5 (MEnc M K) (MEnc N L) H7 H6).
apply SynEnc; trivial.
apply SynInc; trivial.
simpl in |- *.
intro.
inversion H.
cut (synthesis h (MEnc M0 K0) (MEnc N0 L0)); try (apply SynEnc; trivial).
intro.
cut (synthesis h (MEnc M K) (MEnc N L)); try (apply SynEnc; trivial).
intro.
apply (H4bis (MEnc M0 K0) (MEnc N0 L0) H5 (MEnc M K) (MEnc N L) H8 H).
simpl in |- *.
intro.
inversion H.
simpl in |- *.
intro.
inversion H.
simpl in |- *.
cut (synthesis h M N); try (apply SynInc; trivial).
intro.
cut (synthesis h (MPair M1 M2) (MPair N1 N2)); try (apply SynPair; trivial).
intro.
intro.
apply (H4bis M N H5 (MPair M1 M2) (MPair N1 N2) H6 H7).
simpl in |- *.
intro.
inversion H.
simpl in |- *.
intro.
cut (synthesis h (MPair M1 M2) (MPair N1 N2)); try (apply SynPair; trivial).
intro.
cut (synthesis h (MPair M0 M3) (MPair N0 N3)); try (apply SynPair; trivial).
intro.
apply (H4bis (MPair M0 M3) (MPair N0 N3) H6 (MPair M1 M2) (MPair N1 N2) H5 H).
simpl in |- *.
intro.
inversion H.
simpl in |- *.
cut (synthesis h M0 N0); try (apply SynInc; trivial).
intro.
cut (synthesis h (Mop (inv_op o) M) (Mop (inv_op o) N)); try (apply SynOp; trivial).
intro.
intro.
apply (H4bis M0 N0 H6 (Mop (inv_op o) M) (Mop (inv_op o) N) H7 H8).

*****
HrecH6_0 : forall _ : eq K (inv (Mop o M)), eq L (inv (Mop o N))
HrecH6_1 : forall _ : eq M0 (inv (Mop o M)), eq N0 (inv (Mop o N))
H6_0 : synthesis h K L
H6_1 : synthesis h M0 N0
M0,N0,K,L : Msg
HrecH5 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M' (inv M)),\neq N' (inv N)
H5 : synthesis h M N
M,N : Msg
o : op
H4bis : forall (M N : Msg) (_ : synthesis h M N) (M' N' : Msg)\n (_ : synthesis h M' N') (_ : eq M M'), eq N N'
H4 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M' (inv M)), eq N' (inv N)
H3 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H2 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H1 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H0 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
forall _ : eq (MEnc M0 K) (inv (Mop o M)), eq (MEnc N0 L) (inv (Mop o N))
+++++
simpl in |- *.
-----
Theorem inj_inv_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_inv_left h -> injective_inv_left (synthesis h).
intro h.
intros H0 H1 H2 H3 H4.
generalize (inj_left_syn h H0 H1 H2 H3).
intro H4bis.
unfold injective_left in H0.
unfold enc_synthesis_left in H1.
unfold op_synthesis_left in H2.
unfold pair_free_left in H3.
unfold injective_inv_left in H4.
unfold injective_left in H4bis.
unfold injective_inv_left in |- *.
intros M N H5.
induction H5 as [M N H| M N K L H5_1 HrecH5_1 H5_0 HrecH5_0| M1 N1 M2 N2 H5_1 HrecH5_1 H5_0 HrecH5_0| o M N H5 HrecH5]; intros M' N' H6; [ induction H6 as [M0 N0 H5| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K0 L0 H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M N H| M N K L H6_1 HrecH6_1 H6_0 HrecH6_0| M0 N0 M3 N3 H6_1 HrecH6_1 H6_0 HrecH6_0| o M N H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o0 M0 N0 H6 HrecH6] ].
intro.
apply (H4 M N H M0 N0 H5 H6).
intro.
cut (M = inv (MEnc M0 K)).
simpl in |- *.
intro.
case (H1 M N H M0 K H6 N0 L); intro; tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (MPair M1 M2)).
simpl in |- *.
intro.
rewrite H6 in H.
generalize (H3 M1 M2 N).
tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (Mop o M0)).
simpl in |- *.
intro.
generalize (H2 (inv_op o) M N H M0 H7 N0).
tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
simpl in |- *.
cut (synthesis h M0 N0).
intro.
intro.
cut (synthesis h (MEnc M K) (MEnc N L)).
intro.
apply (H4bis M0 N0 H5 (MEnc M K) (MEnc N L) H7 H6).
apply SynEnc; trivial.
apply SynInc; trivial.
simpl in |- *.
intro.
inversion H.
cut (synthesis h (MEnc M0 K0) (MEnc N0 L0)); try (apply SynEnc; trivial).
intro.
cut (synthesis h (MEnc M K) (MEnc N L)); try (apply SynEnc; trivial).
intro.
apply (H4bis (MEnc M0 K0) (MEnc N0 L0) H5 (MEnc M K) (MEnc N L) H8 H).
simpl in |- *.
intro.
inversion H.
simpl in |- *.
intro.
inversion H.
simpl in |- *.
cut (synthesis h M N); try (apply SynInc; trivial).
intro.
cut (synthesis h (MPair M1 M2) (MPair N1 N2)); try (apply SynPair; trivial).
intro.
intro.
apply (H4bis M N H5 (MPair M1 M2) (MPair N1 N2) H6 H7).
simpl in |- *.
intro.
inversion H.
simpl in |- *.
intro.
cut (synthesis h (MPair M1 M2) (MPair N1 N2)); try (apply SynPair; trivial).
intro.
cut (synthesis h (MPair M0 M3) (MPair N0 N3)); try (apply SynPair; trivial).
intro.
apply (H4bis (MPair M0 M3) (MPair N0 N3) H6 (MPair M1 M2) (MPair N1 N2) H5 H).
simpl in |- *.
intro.
inversion H.
simpl in |- *.
cut (synthesis h M0 N0); try (apply SynInc; trivial).
intro.
cut (synthesis h (Mop (inv_op o) M) (Mop (inv_op o) N)); try (apply SynOp; trivial).
intro.
intro.
apply (H4bis M0 N0 H6 (Mop (inv_op o) M) (Mop (inv_op o) N) H7 H8).
simpl in |- *.

*****
HrecH6_0 : forall _ : eq K (inv (Mop o M)), eq L (inv (Mop o N))
HrecH6_1 : forall _ : eq M0 (inv (Mop o M)), eq N0 (inv (Mop o N))
H6_0 : synthesis h K L
H6_1 : synthesis h M0 N0
M0,N0,K,L : Msg
HrecH5 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M' (inv M)),\neq N' (inv N)
H5 : synthesis h M N
M,N : Msg
o : op
H4bis : forall (M N : Msg) (_ : synthesis h M N) (M' N' : Msg)\n (_ : synthesis h M' N') (_ : eq M M'), eq N N'
H4 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M' (inv M)), eq N' (inv N)
H3 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H2 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H1 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H0 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
forall _ : eq (MEnc M0 K) (Mop (inv_op o) M), eq (MEnc N0 L) (Mop (inv_op o) N)
+++++
intro.
-----
Theorem inj_inv_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_inv_left h -> injective_inv_left (synthesis h).
intro h.
intros H0 H1 H2 H3 H4.
generalize (inj_left_syn h H0 H1 H2 H3).
intro H4bis.
unfold injective_left in H0.
unfold enc_synthesis_left in H1.
unfold op_synthesis_left in H2.
unfold pair_free_left in H3.
unfold injective_inv_left in H4.
unfold injective_left in H4bis.
unfold injective_inv_left in |- *.
intros M N H5.
induction H5 as [M N H| M N K L H5_1 HrecH5_1 H5_0 HrecH5_0| M1 N1 M2 N2 H5_1 HrecH5_1 H5_0 HrecH5_0| o M N H5 HrecH5]; intros M' N' H6; [ induction H6 as [M0 N0 H5| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K0 L0 H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M N H| M N K L H6_1 HrecH6_1 H6_0 HrecH6_0| M0 N0 M3 N3 H6_1 HrecH6_1 H6_0 HrecH6_0| o M N H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o0 M0 N0 H6 HrecH6] ].
intro.
apply (H4 M N H M0 N0 H5 H6).
intro.
cut (M = inv (MEnc M0 K)).
simpl in |- *.
intro.
case (H1 M N H M0 K H6 N0 L); intro; tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (MPair M1 M2)).
simpl in |- *.
intro.
rewrite H6 in H.
generalize (H3 M1 M2 N).
tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (Mop o M0)).
simpl in |- *.
intro.
generalize (H2 (inv_op o) M N H M0 H7 N0).
tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
simpl in |- *.
cut (synthesis h M0 N0).
intro.
intro.
cut (synthesis h (MEnc M K) (MEnc N L)).
intro.
apply (H4bis M0 N0 H5 (MEnc M K) (MEnc N L) H7 H6).
apply SynEnc; trivial.
apply SynInc; trivial.
simpl in |- *.
intro.
inversion H.
cut (synthesis h (MEnc M0 K0) (MEnc N0 L0)); try (apply SynEnc; trivial).
intro.
cut (synthesis h (MEnc M K) (MEnc N L)); try (apply SynEnc; trivial).
intro.
apply (H4bis (MEnc M0 K0) (MEnc N0 L0) H5 (MEnc M K) (MEnc N L) H8 H).
simpl in |- *.
intro.
inversion H.
simpl in |- *.
intro.
inversion H.
simpl in |- *.
cut (synthesis h M N); try (apply SynInc; trivial).
intro.
cut (synthesis h (MPair M1 M2) (MPair N1 N2)); try (apply SynPair; trivial).
intro.
intro.
apply (H4bis M N H5 (MPair M1 M2) (MPair N1 N2) H6 H7).
simpl in |- *.
intro.
inversion H.
simpl in |- *.
intro.
cut (synthesis h (MPair M1 M2) (MPair N1 N2)); try (apply SynPair; trivial).
intro.
cut (synthesis h (MPair M0 M3) (MPair N0 N3)); try (apply SynPair; trivial).
intro.
apply (H4bis (MPair M0 M3) (MPair N0 N3) H6 (MPair M1 M2) (MPair N1 N2) H5 H).
simpl in |- *.
intro.
inversion H.
simpl in |- *.
cut (synthesis h M0 N0); try (apply SynInc; trivial).
intro.
cut (synthesis h (Mop (inv_op o) M) (Mop (inv_op o) N)); try (apply SynOp; trivial).
intro.
intro.
apply (H4bis M0 N0 H6 (Mop (inv_op o) M) (Mop (inv_op o) N) H7 H8).
simpl in |- *.
intro.

*****
H : eq (MEnc M0 K) (Mop (inv_op o) M)
HrecH6_0 : forall _ : eq K (inv (Mop o M)), eq L (inv (Mop o N))
HrecH6_1 : forall _ : eq M0 (inv (Mop o M)), eq N0 (inv (Mop o N))
H6_0 : synthesis h K L
H6_1 : synthesis h M0 N0
M0,N0,K,L : Msg
HrecH5 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M' (inv M)),\neq N' (inv N)
H5 : synthesis h M N
M,N : Msg
o : op
H4bis : forall (M N : Msg) (_ : synthesis h M N) (M' N' : Msg)\n (_ : synthesis h M' N') (_ : eq M M'), eq N N'
H4 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M' (inv M)), eq N' (inv N)
H3 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H2 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H1 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H0 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
eq (MEnc N0 L) (Mop (inv_op o) N)
+++++
inversion H.
-----
Theorem inj_inv_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_inv_left h -> injective_inv_left (synthesis h).
intro h.
intros H0 H1 H2 H3 H4.
generalize (inj_left_syn h H0 H1 H2 H3).
intro H4bis.
unfold injective_left in H0.
unfold enc_synthesis_left in H1.
unfold op_synthesis_left in H2.
unfold pair_free_left in H3.
unfold injective_inv_left in H4.
unfold injective_left in H4bis.
unfold injective_inv_left in |- *.
intros M N H5.
induction H5 as [M N H| M N K L H5_1 HrecH5_1 H5_0 HrecH5_0| M1 N1 M2 N2 H5_1 HrecH5_1 H5_0 HrecH5_0| o M N H5 HrecH5]; intros M' N' H6; [ induction H6 as [M0 N0 H5| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K0 L0 H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M N H| M N K L H6_1 HrecH6_1 H6_0 HrecH6_0| M0 N0 M3 N3 H6_1 HrecH6_1 H6_0 HrecH6_0| o M N H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o0 M0 N0 H6 HrecH6] ].
intro.
apply (H4 M N H M0 N0 H5 H6).
intro.
cut (M = inv (MEnc M0 K)).
simpl in |- *.
intro.
case (H1 M N H M0 K H6 N0 L); intro; tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (MPair M1 M2)).
simpl in |- *.
intro.
rewrite H6 in H.
generalize (H3 M1 M2 N).
tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (Mop o M0)).
simpl in |- *.
intro.
generalize (H2 (inv_op o) M N H M0 H7 N0).
tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
simpl in |- *.
cut (synthesis h M0 N0).
intro.
intro.
cut (synthesis h (MEnc M K) (MEnc N L)).
intro.
apply (H4bis M0 N0 H5 (MEnc M K) (MEnc N L) H7 H6).
apply SynEnc; trivial.
apply SynInc; trivial.
simpl in |- *.
intro.
inversion H.
cut (synthesis h (MEnc M0 K0) (MEnc N0 L0)); try (apply SynEnc; trivial).
intro.
cut (synthesis h (MEnc M K) (MEnc N L)); try (apply SynEnc; trivial).
intro.
apply (H4bis (MEnc M0 K0) (MEnc N0 L0) H5 (MEnc M K) (MEnc N L) H8 H).
simpl in |- *.
intro.
inversion H.
simpl in |- *.
intro.
inversion H.
simpl in |- *.
cut (synthesis h M N); try (apply SynInc; trivial).
intro.
cut (synthesis h (MPair M1 M2) (MPair N1 N2)); try (apply SynPair; trivial).
intro.
intro.
apply (H4bis M N H5 (MPair M1 M2) (MPair N1 N2) H6 H7).
simpl in |- *.
intro.
inversion H.
simpl in |- *.
intro.
cut (synthesis h (MPair M1 M2) (MPair N1 N2)); try (apply SynPair; trivial).
intro.
cut (synthesis h (MPair M0 M3) (MPair N0 N3)); try (apply SynPair; trivial).
intro.
apply (H4bis (MPair M0 M3) (MPair N0 N3) H6 (MPair M1 M2) (MPair N1 N2) H5 H).
simpl in |- *.
intro.
inversion H.
simpl in |- *.
cut (synthesis h M0 N0); try (apply SynInc; trivial).
intro.
cut (synthesis h (Mop (inv_op o) M) (Mop (inv_op o) N)); try (apply SynOp; trivial).
intro.
intro.
apply (H4bis M0 N0 H6 (Mop (inv_op o) M) (Mop (inv_op o) N) H7 H8).
simpl in |- *.
intro.
inversion H.

*****
HrecH6_0 : forall _ : eq M2 (inv (Mop o M)), eq N2 (inv (Mop o N))
HrecH6_1 : forall _ : eq M1 (inv (Mop o M)), eq N1 (inv (Mop o N))
H6_0 : synthesis h M2 N2
H6_1 : synthesis h M1 N1
M1,N1,M2,N2 : Msg
HrecH5 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M' (inv M)),\neq N' (inv N)
H5 : synthesis h M N
M,N : Msg
o : op
H4bis : forall (M N : Msg) (_ : synthesis h M N) (M' N' : Msg)\n (_ : synthesis h M' N') (_ : eq M M'), eq N N'
H4 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M' (inv M)), eq N' (inv N)
H3 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H2 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H1 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H0 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
forall _ : eq (MPair M1 M2) (inv (Mop o M)), eq (MPair N1 N2) (inv (Mop o N))
+++++
simpl in |- *.
-----
Theorem inj_inv_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_inv_left h -> injective_inv_left (synthesis h).
intro h.
intros H0 H1 H2 H3 H4.
generalize (inj_left_syn h H0 H1 H2 H3).
intro H4bis.
unfold injective_left in H0.
unfold enc_synthesis_left in H1.
unfold op_synthesis_left in H2.
unfold pair_free_left in H3.
unfold injective_inv_left in H4.
unfold injective_left in H4bis.
unfold injective_inv_left in |- *.
intros M N H5.
induction H5 as [M N H| M N K L H5_1 HrecH5_1 H5_0 HrecH5_0| M1 N1 M2 N2 H5_1 HrecH5_1 H5_0 HrecH5_0| o M N H5 HrecH5]; intros M' N' H6; [ induction H6 as [M0 N0 H5| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K0 L0 H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M N H| M N K L H6_1 HrecH6_1 H6_0 HrecH6_0| M0 N0 M3 N3 H6_1 HrecH6_1 H6_0 HrecH6_0| o M N H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o0 M0 N0 H6 HrecH6] ].
intro.
apply (H4 M N H M0 N0 H5 H6).
intro.
cut (M = inv (MEnc M0 K)).
simpl in |- *.
intro.
case (H1 M N H M0 K H6 N0 L); intro; tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (MPair M1 M2)).
simpl in |- *.
intro.
rewrite H6 in H.
generalize (H3 M1 M2 N).
tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (Mop o M0)).
simpl in |- *.
intro.
generalize (H2 (inv_op o) M N H M0 H7 N0).
tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
simpl in |- *.
cut (synthesis h M0 N0).
intro.
intro.
cut (synthesis h (MEnc M K) (MEnc N L)).
intro.
apply (H4bis M0 N0 H5 (MEnc M K) (MEnc N L) H7 H6).
apply SynEnc; trivial.
apply SynInc; trivial.
simpl in |- *.
intro.
inversion H.
cut (synthesis h (MEnc M0 K0) (MEnc N0 L0)); try (apply SynEnc; trivial).
intro.
cut (synthesis h (MEnc M K) (MEnc N L)); try (apply SynEnc; trivial).
intro.
apply (H4bis (MEnc M0 K0) (MEnc N0 L0) H5 (MEnc M K) (MEnc N L) H8 H).
simpl in |- *.
intro.
inversion H.
simpl in |- *.
intro.
inversion H.
simpl in |- *.
cut (synthesis h M N); try (apply SynInc; trivial).
intro.
cut (synthesis h (MPair M1 M2) (MPair N1 N2)); try (apply SynPair; trivial).
intro.
intro.
apply (H4bis M N H5 (MPair M1 M2) (MPair N1 N2) H6 H7).
simpl in |- *.
intro.
inversion H.
simpl in |- *.
intro.
cut (synthesis h (MPair M1 M2) (MPair N1 N2)); try (apply SynPair; trivial).
intro.
cut (synthesis h (MPair M0 M3) (MPair N0 N3)); try (apply SynPair; trivial).
intro.
apply (H4bis (MPair M0 M3) (MPair N0 N3) H6 (MPair M1 M2) (MPair N1 N2) H5 H).
simpl in |- *.
intro.
inversion H.
simpl in |- *.
cut (synthesis h M0 N0); try (apply SynInc; trivial).
intro.
cut (synthesis h (Mop (inv_op o) M) (Mop (inv_op o) N)); try (apply SynOp; trivial).
intro.
intro.
apply (H4bis M0 N0 H6 (Mop (inv_op o) M) (Mop (inv_op o) N) H7 H8).
simpl in |- *.
intro.
inversion H.
simpl in |- *.

*****
HrecH6_0 : forall _ : eq M2 (inv (Mop o M)), eq N2 (inv (Mop o N))
HrecH6_1 : forall _ : eq M1 (inv (Mop o M)), eq N1 (inv (Mop o N))
H6_0 : synthesis h M2 N2
H6_1 : synthesis h M1 N1
M1,N1,M2,N2 : Msg
HrecH5 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M' (inv M)),\neq N' (inv N)
H5 : synthesis h M N
M,N : Msg
o : op
H4bis : forall (M N : Msg) (_ : synthesis h M N) (M' N' : Msg)\n (_ : synthesis h M' N') (_ : eq M M'), eq N N'
H4 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M' (inv M)), eq N' (inv N)
H3 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H2 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H1 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H0 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
forall _ : eq (MPair M1 M2) (Mop (inv_op o) M), eq (MPair N1 N2) (Mop (inv_op o) N)
+++++
intro.
-----
Theorem inj_inv_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_inv_left h -> injective_inv_left (synthesis h).
intro h.
intros H0 H1 H2 H3 H4.
generalize (inj_left_syn h H0 H1 H2 H3).
intro H4bis.
unfold injective_left in H0.
unfold enc_synthesis_left in H1.
unfold op_synthesis_left in H2.
unfold pair_free_left in H3.
unfold injective_inv_left in H4.
unfold injective_left in H4bis.
unfold injective_inv_left in |- *.
intros M N H5.
induction H5 as [M N H| M N K L H5_1 HrecH5_1 H5_0 HrecH5_0| M1 N1 M2 N2 H5_1 HrecH5_1 H5_0 HrecH5_0| o M N H5 HrecH5]; intros M' N' H6; [ induction H6 as [M0 N0 H5| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K0 L0 H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M N H| M N K L H6_1 HrecH6_1 H6_0 HrecH6_0| M0 N0 M3 N3 H6_1 HrecH6_1 H6_0 HrecH6_0| o M N H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o0 M0 N0 H6 HrecH6] ].
intro.
apply (H4 M N H M0 N0 H5 H6).
intro.
cut (M = inv (MEnc M0 K)).
simpl in |- *.
intro.
case (H1 M N H M0 K H6 N0 L); intro; tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (MPair M1 M2)).
simpl in |- *.
intro.
rewrite H6 in H.
generalize (H3 M1 M2 N).
tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (Mop o M0)).
simpl in |- *.
intro.
generalize (H2 (inv_op o) M N H M0 H7 N0).
tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
simpl in |- *.
cut (synthesis h M0 N0).
intro.
intro.
cut (synthesis h (MEnc M K) (MEnc N L)).
intro.
apply (H4bis M0 N0 H5 (MEnc M K) (MEnc N L) H7 H6).
apply SynEnc; trivial.
apply SynInc; trivial.
simpl in |- *.
intro.
inversion H.
cut (synthesis h (MEnc M0 K0) (MEnc N0 L0)); try (apply SynEnc; trivial).
intro.
cut (synthesis h (MEnc M K) (MEnc N L)); try (apply SynEnc; trivial).
intro.
apply (H4bis (MEnc M0 K0) (MEnc N0 L0) H5 (MEnc M K) (MEnc N L) H8 H).
simpl in |- *.
intro.
inversion H.
simpl in |- *.
intro.
inversion H.
simpl in |- *.
cut (synthesis h M N); try (apply SynInc; trivial).
intro.
cut (synthesis h (MPair M1 M2) (MPair N1 N2)); try (apply SynPair; trivial).
intro.
intro.
apply (H4bis M N H5 (MPair M1 M2) (MPair N1 N2) H6 H7).
simpl in |- *.
intro.
inversion H.
simpl in |- *.
intro.
cut (synthesis h (MPair M1 M2) (MPair N1 N2)); try (apply SynPair; trivial).
intro.
cut (synthesis h (MPair M0 M3) (MPair N0 N3)); try (apply SynPair; trivial).
intro.
apply (H4bis (MPair M0 M3) (MPair N0 N3) H6 (MPair M1 M2) (MPair N1 N2) H5 H).
simpl in |- *.
intro.
inversion H.
simpl in |- *.
cut (synthesis h M0 N0); try (apply SynInc; trivial).
intro.
cut (synthesis h (Mop (inv_op o) M) (Mop (inv_op o) N)); try (apply SynOp; trivial).
intro.
intro.
apply (H4bis M0 N0 H6 (Mop (inv_op o) M) (Mop (inv_op o) N) H7 H8).
simpl in |- *.
intro.
inversion H.
simpl in |- *.
intro.

*****
H : eq (MPair M1 M2) (Mop (inv_op o) M)
HrecH6_0 : forall _ : eq M2 (inv (Mop o M)), eq N2 (inv (Mop o N))
HrecH6_1 : forall _ : eq M1 (inv (Mop o M)), eq N1 (inv (Mop o N))
H6_0 : synthesis h M2 N2
H6_1 : synthesis h M1 N1
M1,N1,M2,N2 : Msg
HrecH5 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M' (inv M)),\neq N' (inv N)
H5 : synthesis h M N
M,N : Msg
o : op
H4bis : forall (M N : Msg) (_ : synthesis h M N) (M' N' : Msg)\n (_ : synthesis h M' N') (_ : eq M M'), eq N N'
H4 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M' (inv M)), eq N' (inv N)
H3 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H2 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H1 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H0 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
eq (MPair N1 N2) (Mop (inv_op o) N)
+++++
inversion H.
-----
Theorem inj_inv_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_inv_left h -> injective_inv_left (synthesis h).
intro h.
intros H0 H1 H2 H3 H4.
generalize (inj_left_syn h H0 H1 H2 H3).
intro H4bis.
unfold injective_left in H0.
unfold enc_synthesis_left in H1.
unfold op_synthesis_left in H2.
unfold pair_free_left in H3.
unfold injective_inv_left in H4.
unfold injective_left in H4bis.
unfold injective_inv_left in |- *.
intros M N H5.
induction H5 as [M N H| M N K L H5_1 HrecH5_1 H5_0 HrecH5_0| M1 N1 M2 N2 H5_1 HrecH5_1 H5_0 HrecH5_0| o M N H5 HrecH5]; intros M' N' H6; [ induction H6 as [M0 N0 H5| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K0 L0 H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M N H| M N K L H6_1 HrecH6_1 H6_0 HrecH6_0| M0 N0 M3 N3 H6_1 HrecH6_1 H6_0 HrecH6_0| o M N H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o0 M0 N0 H6 HrecH6] ].
intro.
apply (H4 M N H M0 N0 H5 H6).
intro.
cut (M = inv (MEnc M0 K)).
simpl in |- *.
intro.
case (H1 M N H M0 K H6 N0 L); intro; tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (MPair M1 M2)).
simpl in |- *.
intro.
rewrite H6 in H.
generalize (H3 M1 M2 N).
tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (Mop o M0)).
simpl in |- *.
intro.
generalize (H2 (inv_op o) M N H M0 H7 N0).
tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
simpl in |- *.
cut (synthesis h M0 N0).
intro.
intro.
cut (synthesis h (MEnc M K) (MEnc N L)).
intro.
apply (H4bis M0 N0 H5 (MEnc M K) (MEnc N L) H7 H6).
apply SynEnc; trivial.
apply SynInc; trivial.
simpl in |- *.
intro.
inversion H.
cut (synthesis h (MEnc M0 K0) (MEnc N0 L0)); try (apply SynEnc; trivial).
intro.
cut (synthesis h (MEnc M K) (MEnc N L)); try (apply SynEnc; trivial).
intro.
apply (H4bis (MEnc M0 K0) (MEnc N0 L0) H5 (MEnc M K) (MEnc N L) H8 H).
simpl in |- *.
intro.
inversion H.
simpl in |- *.
intro.
inversion H.
simpl in |- *.
cut (synthesis h M N); try (apply SynInc; trivial).
intro.
cut (synthesis h (MPair M1 M2) (MPair N1 N2)); try (apply SynPair; trivial).
intro.
intro.
apply (H4bis M N H5 (MPair M1 M2) (MPair N1 N2) H6 H7).
simpl in |- *.
intro.
inversion H.
simpl in |- *.
intro.
cut (synthesis h (MPair M1 M2) (MPair N1 N2)); try (apply SynPair; trivial).
intro.
cut (synthesis h (MPair M0 M3) (MPair N0 N3)); try (apply SynPair; trivial).
intro.
apply (H4bis (MPair M0 M3) (MPair N0 N3) H6 (MPair M1 M2) (MPair N1 N2) H5 H).
simpl in |- *.
intro.
inversion H.
simpl in |- *.
cut (synthesis h M0 N0); try (apply SynInc; trivial).
intro.
cut (synthesis h (Mop (inv_op o) M) (Mop (inv_op o) N)); try (apply SynOp; trivial).
intro.
intro.
apply (H4bis M0 N0 H6 (Mop (inv_op o) M) (Mop (inv_op o) N) H7 H8).
simpl in |- *.
intro.
inversion H.
simpl in |- *.
intro.
inversion H.

*****
HrecH6 : forall _ : eq M0 (inv (Mop o M)), eq N0 (inv (Mop o N))
H6 : synthesis h M0 N0
M0,N0 : Msg
o0 : op
HrecH5 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M' (inv M)),\neq N' (inv N)
H5 : synthesis h M N
M,N : Msg
o : op
H4bis : forall (M N : Msg) (_ : synthesis h M N) (M' N' : Msg)\n (_ : synthesis h M' N') (_ : eq M M'), eq N N'
H4 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M' (inv M)), eq N' (inv N)
H3 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H2 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H1 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H0 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
forall _ : eq (Mop o0 M0) (inv (Mop o M)), eq (Mop o0 N0) (inv (Mop o N))
+++++
simpl in |- *.
-----
Theorem inj_inv_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_inv_left h -> injective_inv_left (synthesis h).
intro h.
intros H0 H1 H2 H3 H4.
generalize (inj_left_syn h H0 H1 H2 H3).
intro H4bis.
unfold injective_left in H0.
unfold enc_synthesis_left in H1.
unfold op_synthesis_left in H2.
unfold pair_free_left in H3.
unfold injective_inv_left in H4.
unfold injective_left in H4bis.
unfold injective_inv_left in |- *.
intros M N H5.
induction H5 as [M N H| M N K L H5_1 HrecH5_1 H5_0 HrecH5_0| M1 N1 M2 N2 H5_1 HrecH5_1 H5_0 HrecH5_0| o M N H5 HrecH5]; intros M' N' H6; [ induction H6 as [M0 N0 H5| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K0 L0 H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M N H| M N K L H6_1 HrecH6_1 H6_0 HrecH6_0| M0 N0 M3 N3 H6_1 HrecH6_1 H6_0 HrecH6_0| o M N H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o0 M0 N0 H6 HrecH6] ].
intro.
apply (H4 M N H M0 N0 H5 H6).
intro.
cut (M = inv (MEnc M0 K)).
simpl in |- *.
intro.
case (H1 M N H M0 K H6 N0 L); intro; tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (MPair M1 M2)).
simpl in |- *.
intro.
rewrite H6 in H.
generalize (H3 M1 M2 N).
tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (Mop o M0)).
simpl in |- *.
intro.
generalize (H2 (inv_op o) M N H M0 H7 N0).
tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
simpl in |- *.
cut (synthesis h M0 N0).
intro.
intro.
cut (synthesis h (MEnc M K) (MEnc N L)).
intro.
apply (H4bis M0 N0 H5 (MEnc M K) (MEnc N L) H7 H6).
apply SynEnc; trivial.
apply SynInc; trivial.
simpl in |- *.
intro.
inversion H.
cut (synthesis h (MEnc M0 K0) (MEnc N0 L0)); try (apply SynEnc; trivial).
intro.
cut (synthesis h (MEnc M K) (MEnc N L)); try (apply SynEnc; trivial).
intro.
apply (H4bis (MEnc M0 K0) (MEnc N0 L0) H5 (MEnc M K) (MEnc N L) H8 H).
simpl in |- *.
intro.
inversion H.
simpl in |- *.
intro.
inversion H.
simpl in |- *.
cut (synthesis h M N); try (apply SynInc; trivial).
intro.
cut (synthesis h (MPair M1 M2) (MPair N1 N2)); try (apply SynPair; trivial).
intro.
intro.
apply (H4bis M N H5 (MPair M1 M2) (MPair N1 N2) H6 H7).
simpl in |- *.
intro.
inversion H.
simpl in |- *.
intro.
cut (synthesis h (MPair M1 M2) (MPair N1 N2)); try (apply SynPair; trivial).
intro.
cut (synthesis h (MPair M0 M3) (MPair N0 N3)); try (apply SynPair; trivial).
intro.
apply (H4bis (MPair M0 M3) (MPair N0 N3) H6 (MPair M1 M2) (MPair N1 N2) H5 H).
simpl in |- *.
intro.
inversion H.
simpl in |- *.
cut (synthesis h M0 N0); try (apply SynInc; trivial).
intro.
cut (synthesis h (Mop (inv_op o) M) (Mop (inv_op o) N)); try (apply SynOp; trivial).
intro.
intro.
apply (H4bis M0 N0 H6 (Mop (inv_op o) M) (Mop (inv_op o) N) H7 H8).
simpl in |- *.
intro.
inversion H.
simpl in |- *.
intro.
inversion H.
simpl in |- *.

*****
HrecH6 : forall _ : eq M0 (inv (Mop o M)), eq N0 (inv (Mop o N))
H6 : synthesis h M0 N0
M0,N0 : Msg
o0 : op
HrecH5 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M' (inv M)),\neq N' (inv N)
H5 : synthesis h M N
M,N : Msg
o : op
H4bis : forall (M N : Msg) (_ : synthesis h M N) (M' N' : Msg)\n (_ : synthesis h M' N') (_ : eq M M'), eq N N'
H4 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M' (inv M)), eq N' (inv N)
H3 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H2 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H1 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H0 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
forall _ : eq (Mop o0 M0) (Mop (inv_op o) M), eq (Mop o0 N0) (Mop (inv_op o) N)
+++++
intro.
-----
Theorem inj_inv_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_inv_left h -> injective_inv_left (synthesis h).
intro h.
intros H0 H1 H2 H3 H4.
generalize (inj_left_syn h H0 H1 H2 H3).
intro H4bis.
unfold injective_left in H0.
unfold enc_synthesis_left in H1.
unfold op_synthesis_left in H2.
unfold pair_free_left in H3.
unfold injective_inv_left in H4.
unfold injective_left in H4bis.
unfold injective_inv_left in |- *.
intros M N H5.
induction H5 as [M N H| M N K L H5_1 HrecH5_1 H5_0 HrecH5_0| M1 N1 M2 N2 H5_1 HrecH5_1 H5_0 HrecH5_0| o M N H5 HrecH5]; intros M' N' H6; [ induction H6 as [M0 N0 H5| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K0 L0 H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M N H| M N K L H6_1 HrecH6_1 H6_0 HrecH6_0| M0 N0 M3 N3 H6_1 HrecH6_1 H6_0 HrecH6_0| o M N H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o0 M0 N0 H6 HrecH6] ].
intro.
apply (H4 M N H M0 N0 H5 H6).
intro.
cut (M = inv (MEnc M0 K)).
simpl in |- *.
intro.
case (H1 M N H M0 K H6 N0 L); intro; tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (MPair M1 M2)).
simpl in |- *.
intro.
rewrite H6 in H.
generalize (H3 M1 M2 N).
tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (Mop o M0)).
simpl in |- *.
intro.
generalize (H2 (inv_op o) M N H M0 H7 N0).
tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
simpl in |- *.
cut (synthesis h M0 N0).
intro.
intro.
cut (synthesis h (MEnc M K) (MEnc N L)).
intro.
apply (H4bis M0 N0 H5 (MEnc M K) (MEnc N L) H7 H6).
apply SynEnc; trivial.
apply SynInc; trivial.
simpl in |- *.
intro.
inversion H.
cut (synthesis h (MEnc M0 K0) (MEnc N0 L0)); try (apply SynEnc; trivial).
intro.
cut (synthesis h (MEnc M K) (MEnc N L)); try (apply SynEnc; trivial).
intro.
apply (H4bis (MEnc M0 K0) (MEnc N0 L0) H5 (MEnc M K) (MEnc N L) H8 H).
simpl in |- *.
intro.
inversion H.
simpl in |- *.
intro.
inversion H.
simpl in |- *.
cut (synthesis h M N); try (apply SynInc; trivial).
intro.
cut (synthesis h (MPair M1 M2) (MPair N1 N2)); try (apply SynPair; trivial).
intro.
intro.
apply (H4bis M N H5 (MPair M1 M2) (MPair N1 N2) H6 H7).
simpl in |- *.
intro.
inversion H.
simpl in |- *.
intro.
cut (synthesis h (MPair M1 M2) (MPair N1 N2)); try (apply SynPair; trivial).
intro.
cut (synthesis h (MPair M0 M3) (MPair N0 N3)); try (apply SynPair; trivial).
intro.
apply (H4bis (MPair M0 M3) (MPair N0 N3) H6 (MPair M1 M2) (MPair N1 N2) H5 H).
simpl in |- *.
intro.
inversion H.
simpl in |- *.
cut (synthesis h M0 N0); try (apply SynInc; trivial).
intro.
cut (synthesis h (Mop (inv_op o) M) (Mop (inv_op o) N)); try (apply SynOp; trivial).
intro.
intro.
apply (H4bis M0 N0 H6 (Mop (inv_op o) M) (Mop (inv_op o) N) H7 H8).
simpl in |- *.
intro.
inversion H.
simpl in |- *.
intro.
inversion H.
simpl in |- *.
intro.

*****
H : eq (Mop o0 M0) (Mop (inv_op o) M)
HrecH6 : forall _ : eq M0 (inv (Mop o M)), eq N0 (inv (Mop o N))
H6 : synthesis h M0 N0
M0,N0 : Msg
o0 : op
HrecH5 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M' (inv M)),\neq N' (inv N)
H5 : synthesis h M N
M,N : Msg
o : op
H4bis : forall (M N : Msg) (_ : synthesis h M N) (M' N' : Msg)\n (_ : synthesis h M' N') (_ : eq M M'), eq N N'
H4 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M' (inv M)), eq N' (inv N)
H3 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H2 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H1 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H0 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
eq (Mop o0 N0) (Mop (inv_op o) N)
+++++
inversion H.
-----
Theorem inj_inv_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_inv_left h -> injective_inv_left (synthesis h).
intro h.
intros H0 H1 H2 H3 H4.
generalize (inj_left_syn h H0 H1 H2 H3).
intro H4bis.
unfold injective_left in H0.
unfold enc_synthesis_left in H1.
unfold op_synthesis_left in H2.
unfold pair_free_left in H3.
unfold injective_inv_left in H4.
unfold injective_left in H4bis.
unfold injective_inv_left in |- *.
intros M N H5.
induction H5 as [M N H| M N K L H5_1 HrecH5_1 H5_0 HrecH5_0| M1 N1 M2 N2 H5_1 HrecH5_1 H5_0 HrecH5_0| o M N H5 HrecH5]; intros M' N' H6; [ induction H6 as [M0 N0 H5| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K0 L0 H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M N H| M N K L H6_1 HrecH6_1 H6_0 HrecH6_0| M0 N0 M3 N3 H6_1 HrecH6_1 H6_0 HrecH6_0| o M N H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o0 M0 N0 H6 HrecH6] ].
intro.
apply (H4 M N H M0 N0 H5 H6).
intro.
cut (M = inv (MEnc M0 K)).
simpl in |- *.
intro.
case (H1 M N H M0 K H6 N0 L); intro; tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (MPair M1 M2)).
simpl in |- *.
intro.
rewrite H6 in H.
generalize (H3 M1 M2 N).
tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (Mop o M0)).
simpl in |- *.
intro.
generalize (H2 (inv_op o) M N H M0 H7 N0).
tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
simpl in |- *.
cut (synthesis h M0 N0).
intro.
intro.
cut (synthesis h (MEnc M K) (MEnc N L)).
intro.
apply (H4bis M0 N0 H5 (MEnc M K) (MEnc N L) H7 H6).
apply SynEnc; trivial.
apply SynInc; trivial.
simpl in |- *.
intro.
inversion H.
cut (synthesis h (MEnc M0 K0) (MEnc N0 L0)); try (apply SynEnc; trivial).
intro.
cut (synthesis h (MEnc M K) (MEnc N L)); try (apply SynEnc; trivial).
intro.
apply (H4bis (MEnc M0 K0) (MEnc N0 L0) H5 (MEnc M K) (MEnc N L) H8 H).
simpl in |- *.
intro.
inversion H.
simpl in |- *.
intro.
inversion H.
simpl in |- *.
cut (synthesis h M N); try (apply SynInc; trivial).
intro.
cut (synthesis h (MPair M1 M2) (MPair N1 N2)); try (apply SynPair; trivial).
intro.
intro.
apply (H4bis M N H5 (MPair M1 M2) (MPair N1 N2) H6 H7).
simpl in |- *.
intro.
inversion H.
simpl in |- *.
intro.
cut (synthesis h (MPair M1 M2) (MPair N1 N2)); try (apply SynPair; trivial).
intro.
cut (synthesis h (MPair M0 M3) (MPair N0 N3)); try (apply SynPair; trivial).
intro.
apply (H4bis (MPair M0 M3) (MPair N0 N3) H6 (MPair M1 M2) (MPair N1 N2) H5 H).
simpl in |- *.
intro.
inversion H.
simpl in |- *.
cut (synthesis h M0 N0); try (apply SynInc; trivial).
intro.
cut (synthesis h (Mop (inv_op o) M) (Mop (inv_op o) N)); try (apply SynOp; trivial).
intro.
intro.
apply (H4bis M0 N0 H6 (Mop (inv_op o) M) (Mop (inv_op o) N) H7 H8).
simpl in |- *.
intro.
inversion H.
simpl in |- *.
intro.
inversion H.
simpl in |- *.
intro.
inversion H.

*****
H9 : eq M0 M
H8 : eq o0 (inv_op o)
H : eq (Mop o0 M0) (Mop (inv_op o) M)
HrecH6 : forall _ : eq M0 (inv (Mop o M)), eq N0 (inv (Mop o N))
H6 : synthesis h M0 N0
M0,N0 : Msg
o0 : op
HrecH5 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M' (inv M)),\neq N' (inv N)
H5 : synthesis h M N
M,N : Msg
o : op
H4bis : forall (M N : Msg) (_ : synthesis h M N) (M' N' : Msg)\n (_ : synthesis h M' N') (_ : eq M M'), eq N N'
H4 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M' (inv M)), eq N' (inv N)
H3 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H2 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H1 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H0 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
eq (Mop (inv_op o) N0) (Mop (inv_op o) N)
+++++
cut (N0 = N).
-----
Theorem inj_inv_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_inv_left h -> injective_inv_left (synthesis h).
intro h.
intros H0 H1 H2 H3 H4.
generalize (inj_left_syn h H0 H1 H2 H3).
intro H4bis.
unfold injective_left in H0.
unfold enc_synthesis_left in H1.
unfold op_synthesis_left in H2.
unfold pair_free_left in H3.
unfold injective_inv_left in H4.
unfold injective_left in H4bis.
unfold injective_inv_left in |- *.
intros M N H5.
induction H5 as [M N H| M N K L H5_1 HrecH5_1 H5_0 HrecH5_0| M1 N1 M2 N2 H5_1 HrecH5_1 H5_0 HrecH5_0| o M N H5 HrecH5]; intros M' N' H6; [ induction H6 as [M0 N0 H5| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K0 L0 H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M N H| M N K L H6_1 HrecH6_1 H6_0 HrecH6_0| M0 N0 M3 N3 H6_1 HrecH6_1 H6_0 HrecH6_0| o M N H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o0 M0 N0 H6 HrecH6] ].
intro.
apply (H4 M N H M0 N0 H5 H6).
intro.
cut (M = inv (MEnc M0 K)).
simpl in |- *.
intro.
case (H1 M N H M0 K H6 N0 L); intro; tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (MPair M1 M2)).
simpl in |- *.
intro.
rewrite H6 in H.
generalize (H3 M1 M2 N).
tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (Mop o M0)).
simpl in |- *.
intro.
generalize (H2 (inv_op o) M N H M0 H7 N0).
tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
simpl in |- *.
cut (synthesis h M0 N0).
intro.
intro.
cut (synthesis h (MEnc M K) (MEnc N L)).
intro.
apply (H4bis M0 N0 H5 (MEnc M K) (MEnc N L) H7 H6).
apply SynEnc; trivial.
apply SynInc; trivial.
simpl in |- *.
intro.
inversion H.
cut (synthesis h (MEnc M0 K0) (MEnc N0 L0)); try (apply SynEnc; trivial).
intro.
cut (synthesis h (MEnc M K) (MEnc N L)); try (apply SynEnc; trivial).
intro.
apply (H4bis (MEnc M0 K0) (MEnc N0 L0) H5 (MEnc M K) (MEnc N L) H8 H).
simpl in |- *.
intro.
inversion H.
simpl in |- *.
intro.
inversion H.
simpl in |- *.
cut (synthesis h M N); try (apply SynInc; trivial).
intro.
cut (synthesis h (MPair M1 M2) (MPair N1 N2)); try (apply SynPair; trivial).
intro.
intro.
apply (H4bis M N H5 (MPair M1 M2) (MPair N1 N2) H6 H7).
simpl in |- *.
intro.
inversion H.
simpl in |- *.
intro.
cut (synthesis h (MPair M1 M2) (MPair N1 N2)); try (apply SynPair; trivial).
intro.
cut (synthesis h (MPair M0 M3) (MPair N0 N3)); try (apply SynPair; trivial).
intro.
apply (H4bis (MPair M0 M3) (MPair N0 N3) H6 (MPair M1 M2) (MPair N1 N2) H5 H).
simpl in |- *.
intro.
inversion H.
simpl in |- *.
cut (synthesis h M0 N0); try (apply SynInc; trivial).
intro.
cut (synthesis h (Mop (inv_op o) M) (Mop (inv_op o) N)); try (apply SynOp; trivial).
intro.
intro.
apply (H4bis M0 N0 H6 (Mop (inv_op o) M) (Mop (inv_op o) N) H7 H8).
simpl in |- *.
intro.
inversion H.
simpl in |- *.
intro.
inversion H.
simpl in |- *.
intro.
inversion H.
cut (N0 = N).

*****
H9 : eq M0 M
H8 : eq o0 (inv_op o)
H : eq (Mop o0 M0) (Mop (inv_op o) M)
HrecH6 : forall _ : eq M0 (inv (Mop o M)), eq N0 (inv (Mop o N))
H6 : synthesis h M0 N0
M0,N0 : Msg
o0 : op
HrecH5 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M' (inv M)),\neq N' (inv N)
H5 : synthesis h M N
M,N : Msg
o : op
H4bis : forall (M N : Msg) (_ : synthesis h M N) (M' N' : Msg)\n (_ : synthesis h M' N') (_ : eq M M'), eq N N'
H4 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M' (inv M)), eq N' (inv N)
H3 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H2 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H1 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H0 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
forall _ : eq N0 N, eq (Mop (inv_op o) N0) (Mop (inv_op o) N)
+++++
intro.
-----
Theorem inj_inv_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_inv_left h -> injective_inv_left (synthesis h).
intro h.
intros H0 H1 H2 H3 H4.
generalize (inj_left_syn h H0 H1 H2 H3).
intro H4bis.
unfold injective_left in H0.
unfold enc_synthesis_left in H1.
unfold op_synthesis_left in H2.
unfold pair_free_left in H3.
unfold injective_inv_left in H4.
unfold injective_left in H4bis.
unfold injective_inv_left in |- *.
intros M N H5.
induction H5 as [M N H| M N K L H5_1 HrecH5_1 H5_0 HrecH5_0| M1 N1 M2 N2 H5_1 HrecH5_1 H5_0 HrecH5_0| o M N H5 HrecH5]; intros M' N' H6; [ induction H6 as [M0 N0 H5| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K0 L0 H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M N H| M N K L H6_1 HrecH6_1 H6_0 HrecH6_0| M0 N0 M3 N3 H6_1 HrecH6_1 H6_0 HrecH6_0| o M N H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o0 M0 N0 H6 HrecH6] ].
intro.
apply (H4 M N H M0 N0 H5 H6).
intro.
cut (M = inv (MEnc M0 K)).
simpl in |- *.
intro.
case (H1 M N H M0 K H6 N0 L); intro; tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (MPair M1 M2)).
simpl in |- *.
intro.
rewrite H6 in H.
generalize (H3 M1 M2 N).
tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (Mop o M0)).
simpl in |- *.
intro.
generalize (H2 (inv_op o) M N H M0 H7 N0).
tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
simpl in |- *.
cut (synthesis h M0 N0).
intro.
intro.
cut (synthesis h (MEnc M K) (MEnc N L)).
intro.
apply (H4bis M0 N0 H5 (MEnc M K) (MEnc N L) H7 H6).
apply SynEnc; trivial.
apply SynInc; trivial.
simpl in |- *.
intro.
inversion H.
cut (synthesis h (MEnc M0 K0) (MEnc N0 L0)); try (apply SynEnc; trivial).
intro.
cut (synthesis h (MEnc M K) (MEnc N L)); try (apply SynEnc; trivial).
intro.
apply (H4bis (MEnc M0 K0) (MEnc N0 L0) H5 (MEnc M K) (MEnc N L) H8 H).
simpl in |- *.
intro.
inversion H.
simpl in |- *.
intro.
inversion H.
simpl in |- *.
cut (synthesis h M N); try (apply SynInc; trivial).
intro.
cut (synthesis h (MPair M1 M2) (MPair N1 N2)); try (apply SynPair; trivial).
intro.
intro.
apply (H4bis M N H5 (MPair M1 M2) (MPair N1 N2) H6 H7).
simpl in |- *.
intro.
inversion H.
simpl in |- *.
intro.
cut (synthesis h (MPair M1 M2) (MPair N1 N2)); try (apply SynPair; trivial).
intro.
cut (synthesis h (MPair M0 M3) (MPair N0 N3)); try (apply SynPair; trivial).
intro.
apply (H4bis (MPair M0 M3) (MPair N0 N3) H6 (MPair M1 M2) (MPair N1 N2) H5 H).
simpl in |- *.
intro.
inversion H.
simpl in |- *.
cut (synthesis h M0 N0); try (apply SynInc; trivial).
intro.
cut (synthesis h (Mop (inv_op o) M) (Mop (inv_op o) N)); try (apply SynOp; trivial).
intro.
intro.
apply (H4bis M0 N0 H6 (Mop (inv_op o) M) (Mop (inv_op o) N) H7 H8).
simpl in |- *.
intro.
inversion H.
simpl in |- *.
intro.
inversion H.
simpl in |- *.
intro.
inversion H.
cut (N0 = N).
intro.

*****
H7 : eq N0 N
H9 : eq M0 M
H8 : eq o0 (inv_op o)
H : eq (Mop o0 M0) (Mop (inv_op o) M)
HrecH6 : forall _ : eq M0 (inv (Mop o M)), eq N0 (inv (Mop o N))
H6 : synthesis h M0 N0
M0,N0 : Msg
o0 : op
HrecH5 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M' (inv M)),\neq N' (inv N)
H5 : synthesis h M N
M,N : Msg
o : op
H4bis : forall (M N : Msg) (_ : synthesis h M N) (M' N' : Msg)\n (_ : synthesis h M' N') (_ : eq M M'), eq N N'
H4 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M' (inv M)), eq N' (inv N)
H3 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H2 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H1 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H0 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
eq (Mop (inv_op o) N0) (Mop (inv_op o) N)
+++++
rewrite H7; trivial.
-----
Theorem inj_inv_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_inv_left h -> injective_inv_left (synthesis h).
intro h.
intros H0 H1 H2 H3 H4.
generalize (inj_left_syn h H0 H1 H2 H3).
intro H4bis.
unfold injective_left in H0.
unfold enc_synthesis_left in H1.
unfold op_synthesis_left in H2.
unfold pair_free_left in H3.
unfold injective_inv_left in H4.
unfold injective_left in H4bis.
unfold injective_inv_left in |- *.
intros M N H5.
induction H5 as [M N H| M N K L H5_1 HrecH5_1 H5_0 HrecH5_0| M1 N1 M2 N2 H5_1 HrecH5_1 H5_0 HrecH5_0| o M N H5 HrecH5]; intros M' N' H6; [ induction H6 as [M0 N0 H5| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K0 L0 H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M N H| M N K L H6_1 HrecH6_1 H6_0 HrecH6_0| M0 N0 M3 N3 H6_1 HrecH6_1 H6_0 HrecH6_0| o M N H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o0 M0 N0 H6 HrecH6] ].
intro.
apply (H4 M N H M0 N0 H5 H6).
intro.
cut (M = inv (MEnc M0 K)).
simpl in |- *.
intro.
case (H1 M N H M0 K H6 N0 L); intro; tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (MPair M1 M2)).
simpl in |- *.
intro.
rewrite H6 in H.
generalize (H3 M1 M2 N).
tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (Mop o M0)).
simpl in |- *.
intro.
generalize (H2 (inv_op o) M N H M0 H7 N0).
tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
simpl in |- *.
cut (synthesis h M0 N0).
intro.
intro.
cut (synthesis h (MEnc M K) (MEnc N L)).
intro.
apply (H4bis M0 N0 H5 (MEnc M K) (MEnc N L) H7 H6).
apply SynEnc; trivial.
apply SynInc; trivial.
simpl in |- *.
intro.
inversion H.
cut (synthesis h (MEnc M0 K0) (MEnc N0 L0)); try (apply SynEnc; trivial).
intro.
cut (synthesis h (MEnc M K) (MEnc N L)); try (apply SynEnc; trivial).
intro.
apply (H4bis (MEnc M0 K0) (MEnc N0 L0) H5 (MEnc M K) (MEnc N L) H8 H).
simpl in |- *.
intro.
inversion H.
simpl in |- *.
intro.
inversion H.
simpl in |- *.
cut (synthesis h M N); try (apply SynInc; trivial).
intro.
cut (synthesis h (MPair M1 M2) (MPair N1 N2)); try (apply SynPair; trivial).
intro.
intro.
apply (H4bis M N H5 (MPair M1 M2) (MPair N1 N2) H6 H7).
simpl in |- *.
intro.
inversion H.
simpl in |- *.
intro.
cut (synthesis h (MPair M1 M2) (MPair N1 N2)); try (apply SynPair; trivial).
intro.
cut (synthesis h (MPair M0 M3) (MPair N0 N3)); try (apply SynPair; trivial).
intro.
apply (H4bis (MPair M0 M3) (MPair N0 N3) H6 (MPair M1 M2) (MPair N1 N2) H5 H).
simpl in |- *.
intro.
inversion H.
simpl in |- *.
cut (synthesis h M0 N0); try (apply SynInc; trivial).
intro.
cut (synthesis h (Mop (inv_op o) M) (Mop (inv_op o) N)); try (apply SynOp; trivial).
intro.
intro.
apply (H4bis M0 N0 H6 (Mop (inv_op o) M) (Mop (inv_op o) N) H7 H8).
simpl in |- *.
intro.
inversion H.
simpl in |- *.
intro.
inversion H.
simpl in |- *.
intro.
inversion H.
cut (N0 = N).
intro.
rewrite H7; trivial.

*****
H9 : eq M0 M
H8 : eq o0 (inv_op o)
H : eq (Mop o0 M0) (Mop (inv_op o) M)
HrecH6 : forall _ : eq M0 (inv (Mop o M)), eq N0 (inv (Mop o N))
H6 : synthesis h M0 N0
M0,N0 : Msg
o0 : op
HrecH5 : forall (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M' (inv M)),\neq N' (inv N)
H5 : synthesis h M N
M,N : Msg
o : op
H4bis : forall (M N : Msg) (_ : synthesis h M N) (M' N' : Msg)\n (_ : synthesis h M' N') (_ : eq M M'), eq N N'
H4 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M' (inv M)), eq N' (inv N)
H3 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H2 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H1 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H0 : forall (M N : Msg) (_ : h M N) (M' N' : Msg) (_ : h M' N')\n (_ : eq M M'), eq N N'
h : hedge
*****
eq N0 N
+++++
apply (H4bis M0 N0 H6 M N H5 H9).
-----
Theorem inj_inv_left_syn : forall h : hedge, injective_left h -> enc_synthesis_left h -> op_synthesis_left h -> pair_free_left h -> injective_inv_left h -> injective_inv_left (synthesis h).
intro h.
intros H0 H1 H2 H3 H4.
generalize (inj_left_syn h H0 H1 H2 H3).
intro H4bis.
unfold injective_left in H0.
unfold enc_synthesis_left in H1.
unfold op_synthesis_left in H2.
unfold pair_free_left in H3.
unfold injective_inv_left in H4.
unfold injective_left in H4bis.
unfold injective_inv_left in |- *.
intros M N H5.
induction H5 as [M N H| M N K L H5_1 HrecH5_1 H5_0 HrecH5_0| M1 N1 M2 N2 H5_1 HrecH5_1 H5_0 HrecH5_0| o M N H5 HrecH5]; intros M' N' H6; [ induction H6 as [M0 N0 H5| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K0 L0 H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o M0 N0 H6 HrecH6] | induction H6 as [M N H| M N K L H6_1 HrecH6_1 H6_0 HrecH6_0| M0 N0 M3 N3 H6_1 HrecH6_1 H6_0 HrecH6_0| o M N H6 HrecH6] | induction H6 as [M0 N0 H| M0 N0 K L H6_1 HrecH6_1 H6_0 HrecH6_0| M1 N1 M2 N2 H6_1 HrecH6_1 H6_0 HrecH6_0| o0 M0 N0 H6 HrecH6] ].
intro.
apply (H4 M N H M0 N0 H5 H6).
intro.
cut (M = inv (MEnc M0 K)).
simpl in |- *.
intro.
case (H1 M N H M0 K H6 N0 L); intro; tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (MPair M1 M2)).
simpl in |- *.
intro.
rewrite H6 in H.
generalize (H3 M1 M2 N).
tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
intro.
cut (M = inv (Mop o M0)).
simpl in |- *.
intro.
generalize (H2 (inv_op o) M N H M0 H7 N0).
tauto.
rewrite H5.
symmetry in |- *.
apply inv_invol.
simpl in |- *.
cut (synthesis h M0 N0).
intro.
intro.
cut (synthesis h (MEnc M K) (MEnc N L)).
intro.
apply (H4bis M0 N0 H5 (MEnc M K) (MEnc N L) H7 H6).
apply SynEnc; trivial.
apply SynInc; trivial.
simpl in |- *.
intro.
inversion H.
cut (synthesis h (MEnc M0 K0) (MEnc N0 L0)); try (apply SynEnc; trivial).
intro.
cut (synthesis h (MEnc M K) (MEnc N L)); try (apply SynEnc; trivial).
intro.
apply (H4bis (MEnc M0 K0) (MEnc N0 L0) H5 (MEnc M K) (MEnc N L) H8 H).
simpl in |- *.
intro.
inversion H.
simpl in |- *.
intro.
inversion H.
simpl in |- *.
cut (synthesis h M N); try (apply SynInc; trivial).
intro.
cut (synthesis h (MPair M1 M2) (MPair N1 N2)); try (apply SynPair; trivial).
intro.
intro.
apply (H4bis M N H5 (MPair M1 M2) (MPair N1 N2) H6 H7).
simpl in |- *.
intro.
inversion H.
simpl in |- *.
intro.
cut (synthesis h (MPair M1 M2) (MPair N1 N2)); try (apply SynPair; trivial).
intro.
cut (synthesis h (MPair M0 M3) (MPair N0 N3)); try (apply SynPair; trivial).
intro.
apply (H4bis (MPair M0 M3) (MPair N0 N3) H6 (MPair M1 M2) (MPair N1 N2) H5 H).
simpl in |- *.
intro.
inversion H.
simpl in |- *.
cut (synthesis h M0 N0); try (apply SynInc; trivial).
intro.
cut (synthesis h (Mop (inv_op o) M) (Mop (inv_op o) N)); try (apply SynOp; trivial).
intro.
intro.
apply (H4bis M0 N0 H6 (Mop (inv_op o) M) (Mop (inv_op o) N) H7 H8).
simpl in |- *.
intro.
inversion H.
simpl in |- *.
intro.
inversion H.
simpl in |- *.
intro.
inversion H.
cut (N0 = N).
intro.
rewrite H7; trivial.
apply (H4bis M0 N0 H6 M N H5 H9).

*****

*****

+++++
Qed.
-----
Definition transpose (h : hedge) (M N : Msg) := h N M.
-----
Definition is_consistent (h : hedge) :=\n  is_left_consistent h /\ is_left_consistent (transpose h).
-----
Definition no_pairs (h : hedge) :=\n  forall M1 M2 N1 N2 : Msg, ~ h (MPair M1 M2) (MPair N1 N2).
-----
Definition no_syn_ops (h : hedge) :=\n  forall (o : op) (M N : Msg), h (Mop o M) (Mop o N) -> ~ synthesis h M N.
-----
Definition no_syn_cyph (h : hedge) :=\n  forall M N K L : Msg,\n  h (MEnc M K) (MEnc N L) -> ~ synthesis h M N \/ ~ synthesis h K L.
-----
Definition cyph_dec (h : hedge) :=\n  forall M N K L : Msg,\n  h (MEnc M K) (MEnc N L) -> synthesis h (inv K) (inv L) -> synthesis h M N.
-----
Definition cond_irr (h : hedge) :=\n  no_pairs h /\ no_syn_ops h /\ no_syn_cyph h /\ cyph_dec h.
-----
Lemma left_consistent_impl_cond_irr_strong :\n forall h : hedge,\n name_left_name h /\\n injective_left h /\\n op_synthesis_left h /\\n pair_free_left h /\ enc_synthesis_left h /\ enc_analysis_left h ->\n cond_irr h.
-----
Lemma left_consistent_impl_cond_irr_strong : forall h : hedge, name_left_name h /\\ injective_left h /\\ op_synthesis_left h /\\ pair_free_left h /\\ enc_synthesis_left h /\\ enc_analysis_left h -> cond_irr h.

*****

*****
forall (h : hedge) (_ : and (name_left_name h) (and (injective_left h) (and (op_synthesis_left h) (and (pair_free_left h) (and (enc_synthesis_left h) (enc_analysis_left h)))))), cond_irr h
+++++
intros.
-----
Lemma left_consistent_impl_cond_irr_strong : forall h : hedge, name_left_name h /\\ injective_left h /\\ op_synthesis_left h /\\ pair_free_left h /\\ enc_synthesis_left h /\\ enc_analysis_left h -> cond_irr h.
intros.

*****
H : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h)))))
h : hedge
*****
cond_irr h
+++++
elim H.
-----
Lemma left_consistent_impl_cond_irr_strong : forall h : hedge, name_left_name h /\\ injective_left h /\\ op_synthesis_left h /\\ pair_free_left h /\\ enc_synthesis_left h /\\ enc_analysis_left h -> cond_irr h.
intros.
elim H.

*****
H : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h)))))
h : hedge
*****
forall (_ : name_left_name h) (_ : and (injective_left h) (and (op_synthesis_left h) (and (pair_free_left h) (and (enc_synthesis_left h) (enc_analysis_left h))))), cond_irr h
+++++
intros.
-----
Lemma left_consistent_impl_cond_irr_strong : forall h : hedge, name_left_name h /\\ injective_left h /\\ op_synthesis_left h /\\ pair_free_left h /\\ enc_synthesis_left h /\\ enc_analysis_left h -> cond_irr h.
intros.
elim H.
intros.

*****
H1 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h))))
H0 : name_left_name h
H : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h)))))
h : hedge
*****
cond_irr h
+++++
elim H1.
-----
Lemma left_consistent_impl_cond_irr_strong : forall h : hedge, name_left_name h /\\ injective_left h /\\ op_synthesis_left h /\\ pair_free_left h /\\ enc_synthesis_left h /\\ enc_analysis_left h -> cond_irr h.
intros.
elim H.
intros.
elim H1.

*****
H1 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h))))
H0 : name_left_name h
H : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h)))))
h : hedge
*****
forall (_ : injective_left h) (_ : and (op_synthesis_left h) (and (pair_free_left h) (and (enc_synthesis_left h) (enc_analysis_left h)))), cond_irr h
+++++
intros.
-----
Lemma left_consistent_impl_cond_irr_strong : forall h : hedge, name_left_name h /\\ injective_left h /\\ op_synthesis_left h /\\ pair_free_left h /\\ enc_synthesis_left h /\\ enc_analysis_left h -> cond_irr h.
intros.
elim H.
intros.
elim H1.
intros.

*****
H3 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h)))
H2 : injective_left h
H1 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h))))
H0 : name_left_name h
H : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h)))))
h : hedge
*****
cond_irr h
+++++
elim H3.
-----
Lemma left_consistent_impl_cond_irr_strong : forall h : hedge, name_left_name h /\\ injective_left h /\\ op_synthesis_left h /\\ pair_free_left h /\\ enc_synthesis_left h /\\ enc_analysis_left h -> cond_irr h.
intros.
elim H.
intros.
elim H1.
intros.
elim H3.

*****
H3 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h)))
H2 : injective_left h
H1 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h))))
H0 : name_left_name h
H : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h)))))
h : hedge
*****
forall (_ : op_synthesis_left h) (_ : and (pair_free_left h) (and (enc_synthesis_left h) (enc_analysis_left h))), cond_irr h
+++++
intros.
-----
Lemma left_consistent_impl_cond_irr_strong : forall h : hedge, name_left_name h /\\ injective_left h /\\ op_synthesis_left h /\\ pair_free_left h /\\ enc_synthesis_left h /\\ enc_analysis_left h -> cond_irr h.
intros.
elim H.
intros.
elim H1.
intros.
elim H3.
intros.

*****
H5 : and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h))
H4 : op_synthesis_left h
H3 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h)))
H2 : injective_left h
H1 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h))))
H0 : name_left_name h
H : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h)))))
h : hedge
*****
cond_irr h
+++++
elim H5.
-----
Lemma left_consistent_impl_cond_irr_strong : forall h : hedge, name_left_name h /\\ injective_left h /\\ op_synthesis_left h /\\ pair_free_left h /\\ enc_synthesis_left h /\\ enc_analysis_left h -> cond_irr h.
intros.
elim H.
intros.
elim H1.
intros.
elim H3.
intros.
elim H5.

*****
H5 : and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h))
H4 : op_synthesis_left h
H3 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h)))
H2 : injective_left h
H1 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h))))
H0 : name_left_name h
H : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h)))))
h : hedge
*****
forall (_ : pair_free_left h) (_ : and (enc_synthesis_left h) (enc_analysis_left h)), cond_irr h
+++++
intros.
-----
Lemma left_consistent_impl_cond_irr_strong : forall h : hedge, name_left_name h /\\ injective_left h /\\ op_synthesis_left h /\\ pair_free_left h /\\ enc_synthesis_left h /\\ enc_analysis_left h -> cond_irr h.
intros.
elim H.
intros.
elim H1.
intros.
elim H3.
intros.
elim H5.
intros.

*****
H7 : and (enc_synthesis_left h) (enc_analysis_left h)
H6 : pair_free_left h
H5 : and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h))
H4 : op_synthesis_left h
H3 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h)))
H2 : injective_left h
H1 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h))))
H0 : name_left_name h
H : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h)))))
h : hedge
*****
cond_irr h
+++++
elim H7.
-----
Lemma left_consistent_impl_cond_irr_strong : forall h : hedge, name_left_name h /\\ injective_left h /\\ op_synthesis_left h /\\ pair_free_left h /\\ enc_synthesis_left h /\\ enc_analysis_left h -> cond_irr h.
intros.
elim H.
intros.
elim H1.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.

*****
H7 : and (enc_synthesis_left h) (enc_analysis_left h)
H6 : pair_free_left h
H5 : and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h))
H4 : op_synthesis_left h
H3 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h)))
H2 : injective_left h
H1 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h))))
H0 : name_left_name h
H : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h)))))
h : hedge
*****
forall (_ : enc_synthesis_left h) (_ : enc_analysis_left h), cond_irr h
+++++
intros.
-----
Lemma left_consistent_impl_cond_irr_strong : forall h : hedge, name_left_name h /\\ injective_left h /\\ op_synthesis_left h /\\ pair_free_left h /\\ enc_synthesis_left h /\\ enc_analysis_left h -> cond_irr h.
intros.
elim H.
intros.
elim H1.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.

*****
H9 : enc_analysis_left h
H8 : enc_synthesis_left h
H7 : and (enc_synthesis_left h) (enc_analysis_left h)
H6 : pair_free_left h
H5 : and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h))
H4 : op_synthesis_left h
H3 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h)))
H2 : injective_left h
H1 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h))))
H0 : name_left_name h
H : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h)))))
h : hedge
*****
cond_irr h
+++++
unfold cond_irr in |- *.
-----
Lemma left_consistent_impl_cond_irr_strong : forall h : hedge, name_left_name h /\\ injective_left h /\\ op_synthesis_left h /\\ pair_free_left h /\\ enc_synthesis_left h /\\ enc_analysis_left h -> cond_irr h.
intros.
elim H.
intros.
elim H1.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
unfold cond_irr in |- *.

*****
H9 : enc_analysis_left h
H8 : enc_synthesis_left h
H7 : and (enc_synthesis_left h) (enc_analysis_left h)
H6 : pair_free_left h
H5 : and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h))
H4 : op_synthesis_left h
H3 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h)))
H2 : injective_left h
H1 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h))))
H0 : name_left_name h
H : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h)))))
h : hedge
*****
and (no_pairs h) (and (no_syn_ops h) (and (no_syn_cyph h) (cyph_dec h)))
+++++
split.
-----
Lemma left_consistent_impl_cond_irr_strong : forall h : hedge, name_left_name h /\\ injective_left h /\\ op_synthesis_left h /\\ pair_free_left h /\\ enc_synthesis_left h /\\ enc_analysis_left h -> cond_irr h.
intros.
elim H.
intros.
elim H1.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
unfold cond_irr in |- *.
split.

*****
H9 : enc_analysis_left h
H8 : enc_synthesis_left h
H7 : and (enc_synthesis_left h) (enc_analysis_left h)
H6 : pair_free_left h
H5 : and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h))
H4 : op_synthesis_left h
H3 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h)))
H2 : injective_left h
H1 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h))))
H0 : name_left_name h
H : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h)))))
h : hedge
*****
no_pairs h
+++++
unfold no_pairs in |- *.
-----
Lemma left_consistent_impl_cond_irr_strong : forall h : hedge, name_left_name h /\\ injective_left h /\\ op_synthesis_left h /\\ pair_free_left h /\\ enc_synthesis_left h /\\ enc_analysis_left h -> cond_irr h.
intros.
elim H.
intros.
elim H1.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
unfold cond_irr in |- *.
split.
unfold no_pairs in |- *.

*****
H9 : enc_analysis_left h
H8 : enc_synthesis_left h
H7 : and (enc_synthesis_left h) (enc_analysis_left h)
H6 : pair_free_left h
H5 : and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h))
H4 : op_synthesis_left h
H3 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h)))
H2 : injective_left h
H1 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h))))
H0 : name_left_name h
H : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h)))))
h : hedge
*****
forall M1 M2 N1 N2 : Msg, not (h (MPair M1 M2) (MPair N1 N2))
+++++
intros.
-----
Lemma left_consistent_impl_cond_irr_strong : forall h : hedge, name_left_name h /\\ injective_left h /\\ op_synthesis_left h /\\ pair_free_left h /\\ enc_synthesis_left h /\\ enc_analysis_left h -> cond_irr h.
intros.
elim H.
intros.
elim H1.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
unfold cond_irr in |- *.
split.
unfold no_pairs in |- *.
intros.

*****
M1,M2,N1,N2 : Msg
H9 : enc_analysis_left h
H8 : enc_synthesis_left h
H7 : and (enc_synthesis_left h) (enc_analysis_left h)
H6 : pair_free_left h
H5 : and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h))
H4 : op_synthesis_left h
H3 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h)))
H2 : injective_left h
H1 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h))))
H0 : name_left_name h
H : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h)))))
h : hedge
*****
not (h (MPair M1 M2) (MPair N1 N2))
+++++
unfold pair_free_left in H6.
-----
Lemma left_consistent_impl_cond_irr_strong : forall h : hedge, name_left_name h /\\ injective_left h /\\ op_synthesis_left h /\\ pair_free_left h /\\ enc_synthesis_left h /\\ enc_analysis_left h -> cond_irr h.
intros.
elim H.
intros.
elim H1.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
unfold cond_irr in |- *.
split.
unfold no_pairs in |- *.
intros.
unfold pair_free_left in H6.

*****
M1,M2,N1,N2 : Msg
H9 : enc_analysis_left h
H8 : enc_synthesis_left h
H7 : and (enc_synthesis_left h) (enc_analysis_left h)
H6 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H5 : and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h))
H4 : op_synthesis_left h
H3 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h)))
H2 : injective_left h
H1 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h))))
H0 : name_left_name h
H : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h)))))
h : hedge
*****
not (h (MPair M1 M2) (MPair N1 N2))
+++++
red in |- *.
-----
Lemma left_consistent_impl_cond_irr_strong : forall h : hedge, name_left_name h /\\ injective_left h /\\ op_synthesis_left h /\\ pair_free_left h /\\ enc_synthesis_left h /\\ enc_analysis_left h -> cond_irr h.
intros.
elim H.
intros.
elim H1.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
unfold cond_irr in |- *.
split.
unfold no_pairs in |- *.
intros.
unfold pair_free_left in H6.
red in |- *.

*****
M1,M2,N1,N2 : Msg
H9 : enc_analysis_left h
H8 : enc_synthesis_left h
H7 : and (enc_synthesis_left h) (enc_analysis_left h)
H6 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H5 : and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h))
H4 : op_synthesis_left h
H3 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h)))
H2 : injective_left h
H1 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h))))
H0 : name_left_name h
H : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h)))))
h : hedge
*****
forall _ : h (MPair M1 M2) (MPair N1 N2), False
+++++
intro.
-----
Lemma left_consistent_impl_cond_irr_strong : forall h : hedge, name_left_name h /\\ injective_left h /\\ op_synthesis_left h /\\ pair_free_left h /\\ enc_synthesis_left h /\\ enc_analysis_left h -> cond_irr h.
intros.
elim H.
intros.
elim H1.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
unfold cond_irr in |- *.
split.
unfold no_pairs in |- *.
intros.
unfold pair_free_left in H6.
red in |- *.
intro.

*****
H10 : h (MPair M1 M2) (MPair N1 N2)
M1,M2,N1,N2 : Msg
H9 : enc_analysis_left h
H8 : enc_synthesis_left h
H7 : and (enc_synthesis_left h) (enc_analysis_left h)
H6 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H5 : and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h))
H4 : op_synthesis_left h
H3 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h)))
H2 : injective_left h
H1 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h))))
H0 : name_left_name h
H : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h)))))
h : hedge
*****
False
+++++
apply (H6 M1 M2 (MPair N1 N2)).
-----
Lemma left_consistent_impl_cond_irr_strong : forall h : hedge, name_left_name h /\\ injective_left h /\\ op_synthesis_left h /\\ pair_free_left h /\\ enc_synthesis_left h /\\ enc_analysis_left h -> cond_irr h.
intros.
elim H.
intros.
elim H1.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
unfold cond_irr in |- *.
split.
unfold no_pairs in |- *.
intros.
unfold pair_free_left in H6.
red in |- *.
intro.
apply (H6 M1 M2 (MPair N1 N2)).

*****
H10 : h (MPair M1 M2) (MPair N1 N2)
M1,M2,N1,N2 : Msg
H9 : enc_analysis_left h
H8 : enc_synthesis_left h
H7 : and (enc_synthesis_left h) (enc_analysis_left h)
H6 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H5 : and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h))
H4 : op_synthesis_left h
H3 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h)))
H2 : injective_left h
H1 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h))))
H0 : name_left_name h
H : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h)))))
h : hedge
*****
h (MPair M1 M2) (MPair N1 N2)
+++++
trivial.
-----
Lemma left_consistent_impl_cond_irr_strong : forall h : hedge, name_left_name h /\\ injective_left h /\\ op_synthesis_left h /\\ pair_free_left h /\\ enc_synthesis_left h /\\ enc_analysis_left h -> cond_irr h.
intros.
elim H.
intros.
elim H1.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
unfold cond_irr in |- *.
split.

*****
H9 : enc_analysis_left h
H8 : enc_synthesis_left h
H7 : and (enc_synthesis_left h) (enc_analysis_left h)
H6 : pair_free_left h
H5 : and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h))
H4 : op_synthesis_left h
H3 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h)))
H2 : injective_left h
H1 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h))))
H0 : name_left_name h
H : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h)))))
h : hedge
*****
and (no_syn_ops h) (and (no_syn_cyph h) (cyph_dec h))
+++++
split.
-----
Lemma left_consistent_impl_cond_irr_strong : forall h : hedge, name_left_name h /\\ injective_left h /\\ op_synthesis_left h /\\ pair_free_left h /\\ enc_synthesis_left h /\\ enc_analysis_left h -> cond_irr h.
intros.
elim H.
intros.
elim H1.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
unfold cond_irr in |- *.
split.
split.

*****
H9 : enc_analysis_left h
H8 : enc_synthesis_left h
H7 : and (enc_synthesis_left h) (enc_analysis_left h)
H6 : pair_free_left h
H5 : and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h))
H4 : op_synthesis_left h
H3 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h)))
H2 : injective_left h
H1 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h))))
H0 : name_left_name h
H : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h)))))
h : hedge
*****
no_syn_ops h
+++++
unfold op_synthesis_left in H4.
-----
Lemma left_consistent_impl_cond_irr_strong : forall h : hedge, name_left_name h /\\ injective_left h /\\ op_synthesis_left h /\\ pair_free_left h /\\ enc_synthesis_left h /\\ enc_analysis_left h -> cond_irr h.
intros.
elim H.
intros.
elim H1.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
unfold cond_irr in |- *.
split.
split.
unfold op_synthesis_left in H4.

*****
H9 : enc_analysis_left h
H8 : enc_synthesis_left h
H7 : and (enc_synthesis_left h) (enc_analysis_left h)
H6 : pair_free_left h
H5 : and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h))
H4 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H3 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h)))
H2 : injective_left h
H1 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h))))
H0 : name_left_name h
H : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h)))))
h : hedge
*****
no_syn_ops h
+++++
unfold no_syn_ops in |- *.
-----
Lemma left_consistent_impl_cond_irr_strong : forall h : hedge, name_left_name h /\\ injective_left h /\\ op_synthesis_left h /\\ pair_free_left h /\\ enc_synthesis_left h /\\ enc_analysis_left h -> cond_irr h.
intros.
elim H.
intros.
elim H1.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
unfold cond_irr in |- *.
split.
split.
unfold op_synthesis_left in H4.
unfold no_syn_ops in |- *.

*****
H9 : enc_analysis_left h
H8 : enc_synthesis_left h
H7 : and (enc_synthesis_left h) (enc_analysis_left h)
H6 : pair_free_left h
H5 : and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h))
H4 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H3 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h)))
H2 : injective_left h
H1 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h))))
H0 : name_left_name h
H : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h)))))
h : hedge
*****
forall (o : op) (M N : Msg) (_ : h (Mop o M) (Mop o N)), not (synthesis h M N)
+++++
intros.
-----
Lemma left_consistent_impl_cond_irr_strong : forall h : hedge, name_left_name h /\\ injective_left h /\\ op_synthesis_left h /\\ pair_free_left h /\\ enc_synthesis_left h /\\ enc_analysis_left h -> cond_irr h.
intros.
elim H.
intros.
elim H1.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
unfold cond_irr in |- *.
split.
split.
unfold op_synthesis_left in H4.
unfold no_syn_ops in |- *.
intros.

*****
H10 : h (Mop o M) (Mop o N)
M,N : Msg
o : op
H9 : enc_analysis_left h
H8 : enc_synthesis_left h
H7 : and (enc_synthesis_left h) (enc_analysis_left h)
H6 : pair_free_left h
H5 : and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h))
H4 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H3 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h)))
H2 : injective_left h
H1 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h))))
H0 : name_left_name h
H : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h)))))
h : hedge
*****
not (synthesis h M N)
+++++
apply (H4 o (Mop o M) (Mop o N)).
-----
Lemma left_consistent_impl_cond_irr_strong : forall h : hedge, name_left_name h /\\ injective_left h /\\ op_synthesis_left h /\\ pair_free_left h /\\ enc_synthesis_left h /\\ enc_analysis_left h -> cond_irr h.
intros.
elim H.
intros.
elim H1.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
unfold cond_irr in |- *.
split.
split.
unfold op_synthesis_left in H4.
unfold no_syn_ops in |- *.
intros.
apply (H4 o (Mop o M) (Mop o N)).

*****
H10 : h (Mop o M) (Mop o N)
M,N : Msg
o : op
H9 : enc_analysis_left h
H8 : enc_synthesis_left h
H7 : and (enc_synthesis_left h) (enc_analysis_left h)
H6 : pair_free_left h
H5 : and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h))
H4 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H3 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h)))
H2 : injective_left h
H1 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h))))
H0 : name_left_name h
H : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h)))))
h : hedge
*****
h (Mop o M) (Mop o N)
+++++
trivial.
-----
Lemma left_consistent_impl_cond_irr_strong : forall h : hedge, name_left_name h /\\ injective_left h /\\ op_synthesis_left h /\\ pair_free_left h /\\ enc_synthesis_left h /\\ enc_analysis_left h -> cond_irr h.
intros.
elim H.
intros.
elim H1.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
unfold cond_irr in |- *.
split.
split.
unfold op_synthesis_left in H4.
unfold no_syn_ops in |- *.
intros.
apply (H4 o (Mop o M) (Mop o N)).

*****
H10 : h (Mop o M) (Mop o N)
M,N : Msg
o : op
H9 : enc_analysis_left h
H8 : enc_synthesis_left h
H7 : and (enc_synthesis_left h) (enc_analysis_left h)
H6 : pair_free_left h
H5 : and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h))
H4 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H3 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h)))
H2 : injective_left h
H1 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h))))
H0 : name_left_name h
H : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h)))))
h : hedge
*****
eq (Mop o M) (Mop o M)
+++++
trivial.
-----
Lemma left_consistent_impl_cond_irr_strong : forall h : hedge, name_left_name h /\\ injective_left h /\\ op_synthesis_left h /\\ pair_free_left h /\\ enc_synthesis_left h /\\ enc_analysis_left h -> cond_irr h.
intros.
elim H.
intros.
elim H1.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
unfold cond_irr in |- *.
split.
split.

*****
H9 : enc_analysis_left h
H8 : enc_synthesis_left h
H7 : and (enc_synthesis_left h) (enc_analysis_left h)
H6 : pair_free_left h
H5 : and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h))
H4 : op_synthesis_left h
H3 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h)))
H2 : injective_left h
H1 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h))))
H0 : name_left_name h
H : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h)))))
h : hedge
*****
and (no_syn_cyph h) (cyph_dec h)
+++++
split.
-----
Lemma left_consistent_impl_cond_irr_strong : forall h : hedge, name_left_name h /\\ injective_left h /\\ op_synthesis_left h /\\ pair_free_left h /\\ enc_synthesis_left h /\\ enc_analysis_left h -> cond_irr h.
intros.
elim H.
intros.
elim H1.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
unfold cond_irr in |- *.
split.
split.
split.

*****
H9 : enc_analysis_left h
H8 : enc_synthesis_left h
H7 : and (enc_synthesis_left h) (enc_analysis_left h)
H6 : pair_free_left h
H5 : and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h))
H4 : op_synthesis_left h
H3 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h)))
H2 : injective_left h
H1 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h))))
H0 : name_left_name h
H : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h)))))
h : hedge
*****
no_syn_cyph h
+++++
unfold no_syn_cyph in |- *.
-----
Lemma left_consistent_impl_cond_irr_strong : forall h : hedge, name_left_name h /\\ injective_left h /\\ op_synthesis_left h /\\ pair_free_left h /\\ enc_synthesis_left h /\\ enc_analysis_left h -> cond_irr h.
intros.
elim H.
intros.
elim H1.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
unfold cond_irr in |- *.
split.
split.
split.
unfold no_syn_cyph in |- *.

*****
H9 : enc_analysis_left h
H8 : enc_synthesis_left h
H7 : and (enc_synthesis_left h) (enc_analysis_left h)
H6 : pair_free_left h
H5 : and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h))
H4 : op_synthesis_left h
H3 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h)))
H2 : injective_left h
H1 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h))))
H0 : name_left_name h
H : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h)))))
h : hedge
*****
forall (M N K L : Msg) (_ : h (MEnc M K) (MEnc N L)), or (not (synthesis h M N)) (not (synthesis h K L))
+++++
intros.
-----
Lemma left_consistent_impl_cond_irr_strong : forall h : hedge, name_left_name h /\\ injective_left h /\\ op_synthesis_left h /\\ pair_free_left h /\\ enc_synthesis_left h /\\ enc_analysis_left h -> cond_irr h.
intros.
elim H.
intros.
elim H1.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
unfold cond_irr in |- *.
split.
split.
split.
unfold no_syn_cyph in |- *.
intros.

*****
H10 : h (MEnc M K) (MEnc N L)
M,N,K,L : Msg
H9 : enc_analysis_left h
H8 : enc_synthesis_left h
H7 : and (enc_synthesis_left h) (enc_analysis_left h)
H6 : pair_free_left h
H5 : and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h))
H4 : op_synthesis_left h
H3 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h)))
H2 : injective_left h
H1 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h))))
H0 : name_left_name h
H : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h)))))
h : hedge
*****
or (not (synthesis h M N)) (not (synthesis h K L))
+++++
unfold enc_synthesis_left in H8.
-----
Lemma left_consistent_impl_cond_irr_strong : forall h : hedge, name_left_name h /\\ injective_left h /\\ op_synthesis_left h /\\ pair_free_left h /\\ enc_synthesis_left h /\\ enc_analysis_left h -> cond_irr h.
intros.
elim H.
intros.
elim H1.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
unfold cond_irr in |- *.
split.
split.
split.
unfold no_syn_cyph in |- *.
intros.
unfold enc_synthesis_left in H8.

*****
H10 : h (MEnc M K) (MEnc N L)
M,N,K,L : Msg
H9 : enc_analysis_left h
H8 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H7 : and (enc_synthesis_left h) (enc_analysis_left h)
H6 : pair_free_left h
H5 : and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h))
H4 : op_synthesis_left h
H3 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h)))
H2 : injective_left h
H1 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h))))
H0 : name_left_name h
H : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h)))))
h : hedge
*****
or (not (synthesis h M N)) (not (synthesis h K L))
+++++
apply (H8 (MEnc M K) (MEnc N L)).
-----
Lemma left_consistent_impl_cond_irr_strong : forall h : hedge, name_left_name h /\\ injective_left h /\\ op_synthesis_left h /\\ pair_free_left h /\\ enc_synthesis_left h /\\ enc_analysis_left h -> cond_irr h.
intros.
elim H.
intros.
elim H1.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
unfold cond_irr in |- *.
split.
split.
split.
unfold no_syn_cyph in |- *.
intros.
unfold enc_synthesis_left in H8.
apply (H8 (MEnc M K) (MEnc N L)).

*****
H10 : h (MEnc M K) (MEnc N L)
M,N,K,L : Msg
H9 : enc_analysis_left h
H8 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H7 : and (enc_synthesis_left h) (enc_analysis_left h)
H6 : pair_free_left h
H5 : and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h))
H4 : op_synthesis_left h
H3 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h)))
H2 : injective_left h
H1 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h))))
H0 : name_left_name h
H : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h)))))
h : hedge
*****
h (MEnc M K) (MEnc N L)
+++++
trivial.
-----
Lemma left_consistent_impl_cond_irr_strong : forall h : hedge, name_left_name h /\\ injective_left h /\\ op_synthesis_left h /\\ pair_free_left h /\\ enc_synthesis_left h /\\ enc_analysis_left h -> cond_irr h.
intros.
elim H.
intros.
elim H1.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
unfold cond_irr in |- *.
split.
split.
split.
unfold no_syn_cyph in |- *.
intros.
unfold enc_synthesis_left in H8.
apply (H8 (MEnc M K) (MEnc N L)).

*****
H10 : h (MEnc M K) (MEnc N L)
M,N,K,L : Msg
H9 : enc_analysis_left h
H8 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H7 : and (enc_synthesis_left h) (enc_analysis_left h)
H6 : pair_free_left h
H5 : and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h))
H4 : op_synthesis_left h
H3 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h)))
H2 : injective_left h
H1 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h))))
H0 : name_left_name h
H : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h)))))
h : hedge
*****
eq (MEnc M K) (MEnc M K)
+++++
trivial.
-----
Lemma left_consistent_impl_cond_irr_strong : forall h : hedge, name_left_name h /\\ injective_left h /\\ op_synthesis_left h /\\ pair_free_left h /\\ enc_synthesis_left h /\\ enc_analysis_left h -> cond_irr h.
intros.
elim H.
intros.
elim H1.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
unfold cond_irr in |- *.
split.
split.
split.

*****
H9 : enc_analysis_left h
H8 : enc_synthesis_left h
H7 : and (enc_synthesis_left h) (enc_analysis_left h)
H6 : pair_free_left h
H5 : and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h))
H4 : op_synthesis_left h
H3 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h)))
H2 : injective_left h
H1 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h))))
H0 : name_left_name h
H : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h)))))
h : hedge
*****
cyph_dec h
+++++
unfold cyph_dec in |- *.
-----
Lemma left_consistent_impl_cond_irr_strong : forall h : hedge, name_left_name h /\\ injective_left h /\\ op_synthesis_left h /\\ pair_free_left h /\\ enc_synthesis_left h /\\ enc_analysis_left h -> cond_irr h.
intros.
elim H.
intros.
elim H1.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
unfold cond_irr in |- *.
split.
split.
split.
unfold cyph_dec in |- *.

*****
H9 : enc_analysis_left h
H8 : enc_synthesis_left h
H7 : and (enc_synthesis_left h) (enc_analysis_left h)
H6 : pair_free_left h
H5 : and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h))
H4 : op_synthesis_left h
H3 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h)))
H2 : injective_left h
H1 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h))))
H0 : name_left_name h
H : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h)))))
h : hedge
*****
forall (M N K L : Msg) (_ : h (MEnc M K) (MEnc N L)) (_ : synthesis h (inv K) (inv L)), synthesis h M N
+++++
intros.
-----
Lemma left_consistent_impl_cond_irr_strong : forall h : hedge, name_left_name h /\\ injective_left h /\\ op_synthesis_left h /\\ pair_free_left h /\\ enc_synthesis_left h /\\ enc_analysis_left h -> cond_irr h.
intros.
elim H.
intros.
elim H1.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
unfold cond_irr in |- *.
split.
split.
split.
unfold cyph_dec in |- *.
intros.

*****
H11 : synthesis h (inv K) (inv L)
H10 : h (MEnc M K) (MEnc N L)
M,N,K,L : Msg
H9 : enc_analysis_left h
H8 : enc_synthesis_left h
H7 : and (enc_synthesis_left h) (enc_analysis_left h)
H6 : pair_free_left h
H5 : and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h))
H4 : op_synthesis_left h
H3 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h)))
H2 : injective_left h
H1 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h))))
H0 : name_left_name h
H : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h)))))
h : hedge
*****
synthesis h M N
+++++
unfold enc_analysis_left in H9.
-----
Lemma left_consistent_impl_cond_irr_strong : forall h : hedge, name_left_name h /\\ injective_left h /\\ op_synthesis_left h /\\ pair_free_left h /\\ enc_synthesis_left h /\\ enc_analysis_left h -> cond_irr h.
intros.
elim H.
intros.
elim H1.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
unfold cond_irr in |- *.
split.
split.
split.
unfold cyph_dec in |- *.
intros.
unfold enc_analysis_left in H9.

*****
H11 : synthesis h (inv K) (inv L)
H10 : h (MEnc M K) (MEnc N L)
M,N,K,L : Msg
H9 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (L : Msg) (_ : synthesis h (inv K) (inv L)),\nex (fun N' : Msg => and (eq N (MEnc N' L)) (synthesis h M' N'))
H8 : enc_synthesis_left h
H7 : and (enc_synthesis_left h) (enc_analysis_left h)
H6 : pair_free_left h
H5 : and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h))
H4 : op_synthesis_left h
H3 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h)))
H2 : injective_left h
H1 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h))))
H0 : name_left_name h
H : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h)))))
h : hedge
*****
synthesis h M N
+++++
generalize (H9 (MEnc M K) (MEnc N L) H10 M K).
-----
Lemma left_consistent_impl_cond_irr_strong : forall h : hedge, name_left_name h /\\ injective_left h /\\ op_synthesis_left h /\\ pair_free_left h /\\ enc_synthesis_left h /\\ enc_analysis_left h -> cond_irr h.
intros.
elim H.
intros.
elim H1.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
unfold cond_irr in |- *.
split.
split.
split.
unfold cyph_dec in |- *.
intros.
unfold enc_analysis_left in H9.
generalize (H9 (MEnc M K) (MEnc N L) H10 M K).

*****
H11 : synthesis h (inv K) (inv L)
H10 : h (MEnc M K) (MEnc N L)
M,N,K,L : Msg
H9 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (L : Msg) (_ : synthesis h (inv K) (inv L)),\nex (fun N' : Msg => and (eq N (MEnc N' L)) (synthesis h M' N'))
H8 : enc_synthesis_left h
H7 : and (enc_synthesis_left h) (enc_analysis_left h)
H6 : pair_free_left h
H5 : and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h))
H4 : op_synthesis_left h
H3 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h)))
H2 : injective_left h
H1 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h))))
H0 : name_left_name h
H : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h)))))
h : hedge
*****
forall _ : forall (_ : eq (MEnc M K) (MEnc M K)) (L0 : Msg) (_ : synthesis h (inv K) (inv L0)), ex (fun N' : Msg => and (eq (MEnc N L) (MEnc N' L0)) (synthesis h M N')), synthesis h M N
+++++
intros.
-----
Lemma left_consistent_impl_cond_irr_strong : forall h : hedge, name_left_name h /\\ injective_left h /\\ op_synthesis_left h /\\ pair_free_left h /\\ enc_synthesis_left h /\\ enc_analysis_left h -> cond_irr h.
intros.
elim H.
intros.
elim H1.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
unfold cond_irr in |- *.
split.
split.
split.
unfold cyph_dec in |- *.
intros.
unfold enc_analysis_left in H9.
generalize (H9 (MEnc M K) (MEnc N L) H10 M K).
intros.

*****
H12 : forall (_ : eq (MEnc M K) (MEnc M K)) (L0 : Msg)\n (_ : synthesis h (inv K) (inv L0)),\nex\n (fun N' : Msg => and (eq (MEnc N L) (MEnc N' L0)) (synthesis h M N'))
H11 : synthesis h (inv K) (inv L)
H10 : h (MEnc M K) (MEnc N L)
M,N,K,L : Msg
H9 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (L : Msg) (_ : synthesis h (inv K) (inv L)),\nex (fun N' : Msg => and (eq N (MEnc N' L)) (synthesis h M' N'))
H8 : enc_synthesis_left h
H7 : and (enc_synthesis_left h) (enc_analysis_left h)
H6 : pair_free_left h
H5 : and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h))
H4 : op_synthesis_left h
H3 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h)))
H2 : injective_left h
H1 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h))))
H0 : name_left_name h
H : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h)))))
h : hedge
*****
synthesis h M N
+++++
cut (exists N' : Msg, MEnc N L = MEnc N' L /\ synthesis h M N').
-----
Lemma left_consistent_impl_cond_irr_strong : forall h : hedge, name_left_name h /\\ injective_left h /\\ op_synthesis_left h /\\ pair_free_left h /\\ enc_synthesis_left h /\\ enc_analysis_left h -> cond_irr h.
intros.
elim H.
intros.
elim H1.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
unfold cond_irr in |- *.
split.
split.
split.
unfold cyph_dec in |- *.
intros.
unfold enc_analysis_left in H9.
generalize (H9 (MEnc M K) (MEnc N L) H10 M K).
intros.
cut (exists N' : Msg, MEnc N L = MEnc N' L /\\ synthesis h M N').

*****
H12 : forall (_ : eq (MEnc M K) (MEnc M K)) (L0 : Msg)\n (_ : synthesis h (inv K) (inv L0)),\nex\n (fun N' : Msg => and (eq (MEnc N L) (MEnc N' L0)) (synthesis h M N'))
H11 : synthesis h (inv K) (inv L)
H10 : h (MEnc M K) (MEnc N L)
M,N,K,L : Msg
H9 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (L : Msg) (_ : synthesis h (inv K) (inv L)),\nex (fun N' : Msg => and (eq N (MEnc N' L)) (synthesis h M' N'))
H8 : enc_synthesis_left h
H7 : and (enc_synthesis_left h) (enc_analysis_left h)
H6 : pair_free_left h
H5 : and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h))
H4 : op_synthesis_left h
H3 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h)))
H2 : injective_left h
H1 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h))))
H0 : name_left_name h
H : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h)))))
h : hedge
*****
forall _ : ex (fun N' : Msg => and (eq (MEnc N L) (MEnc N' L)) (synthesis h M N')), synthesis h M N
+++++
intro.
-----
Lemma left_consistent_impl_cond_irr_strong : forall h : hedge, name_left_name h /\\ injective_left h /\\ op_synthesis_left h /\\ pair_free_left h /\\ enc_synthesis_left h /\\ enc_analysis_left h -> cond_irr h.
intros.
elim H.
intros.
elim H1.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
unfold cond_irr in |- *.
split.
split.
split.
unfold cyph_dec in |- *.
intros.
unfold enc_analysis_left in H9.
generalize (H9 (MEnc M K) (MEnc N L) H10 M K).
intros.
cut (exists N' : Msg, MEnc N L = MEnc N' L /\\ synthesis h M N').
intro.

*****
H13 : ex (fun N' : Msg => and (eq (MEnc N L) (MEnc N' L)) (synthesis h M N'))
H12 : forall (_ : eq (MEnc M K) (MEnc M K)) (L0 : Msg)\n (_ : synthesis h (inv K) (inv L0)),\nex\n (fun N' : Msg => and (eq (MEnc N L) (MEnc N' L0)) (synthesis h M N'))
H11 : synthesis h (inv K) (inv L)
H10 : h (MEnc M K) (MEnc N L)
M,N,K,L : Msg
H9 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (L : Msg) (_ : synthesis h (inv K) (inv L)),\nex (fun N' : Msg => and (eq N (MEnc N' L)) (synthesis h M' N'))
H8 : enc_synthesis_left h
H7 : and (enc_synthesis_left h) (enc_analysis_left h)
H6 : pair_free_left h
H5 : and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h))
H4 : op_synthesis_left h
H3 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h)))
H2 : injective_left h
H1 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h))))
H0 : name_left_name h
H : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h)))))
h : hedge
*****
synthesis h M N
+++++
elim H13.
-----
Lemma left_consistent_impl_cond_irr_strong : forall h : hedge, name_left_name h /\\ injective_left h /\\ op_synthesis_left h /\\ pair_free_left h /\\ enc_synthesis_left h /\\ enc_analysis_left h -> cond_irr h.
intros.
elim H.
intros.
elim H1.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
unfold cond_irr in |- *.
split.
split.
split.
unfold cyph_dec in |- *.
intros.
unfold enc_analysis_left in H9.
generalize (H9 (MEnc M K) (MEnc N L) H10 M K).
intros.
cut (exists N' : Msg, MEnc N L = MEnc N' L /\\ synthesis h M N').
intro.
elim H13.

*****
H13 : ex (fun N' : Msg => and (eq (MEnc N L) (MEnc N' L)) (synthesis h M N'))
H12 : forall (_ : eq (MEnc M K) (MEnc M K)) (L0 : Msg)\n (_ : synthesis h (inv K) (inv L0)),\nex\n (fun N' : Msg => and (eq (MEnc N L) (MEnc N' L0)) (synthesis h M N'))
H11 : synthesis h (inv K) (inv L)
H10 : h (MEnc M K) (MEnc N L)
M,N,K,L : Msg
H9 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (L : Msg) (_ : synthesis h (inv K) (inv L)),\nex (fun N' : Msg => and (eq N (MEnc N' L)) (synthesis h M' N'))
H8 : enc_synthesis_left h
H7 : and (enc_synthesis_left h) (enc_analysis_left h)
H6 : pair_free_left h
H5 : and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h))
H4 : op_synthesis_left h
H3 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h)))
H2 : injective_left h
H1 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h))))
H0 : name_left_name h
H : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h)))))
h : hedge
*****
forall (x : Msg) (_ : and (eq (MEnc N L) (MEnc x L)) (synthesis h M x)), synthesis h M N
+++++
intro N'.
-----
Lemma left_consistent_impl_cond_irr_strong : forall h : hedge, name_left_name h /\\ injective_left h /\\ op_synthesis_left h /\\ pair_free_left h /\\ enc_synthesis_left h /\\ enc_analysis_left h -> cond_irr h.
intros.
elim H.
intros.
elim H1.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
unfold cond_irr in |- *.
split.
split.
split.
unfold cyph_dec in |- *.
intros.
unfold enc_analysis_left in H9.
generalize (H9 (MEnc M K) (MEnc N L) H10 M K).
intros.
cut (exists N' : Msg, MEnc N L = MEnc N' L /\\ synthesis h M N').
intro.
elim H13.
intro N'.

*****
N' : Msg
H13 : ex (fun N' : Msg => and (eq (MEnc N L) (MEnc N' L)) (synthesis h M N'))
H12 : forall (_ : eq (MEnc M K) (MEnc M K)) (L0 : Msg)\n (_ : synthesis h (inv K) (inv L0)),\nex\n (fun N' : Msg => and (eq (MEnc N L) (MEnc N' L0)) (synthesis h M N'))
H11 : synthesis h (inv K) (inv L)
H10 : h (MEnc M K) (MEnc N L)
M,N,K,L : Msg
H9 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (L : Msg) (_ : synthesis h (inv K) (inv L)),\nex (fun N' : Msg => and (eq N (MEnc N' L)) (synthesis h M' N'))
H8 : enc_synthesis_left h
H7 : and (enc_synthesis_left h) (enc_analysis_left h)
H6 : pair_free_left h
H5 : and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h))
H4 : op_synthesis_left h
H3 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h)))
H2 : injective_left h
H1 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h))))
H0 : name_left_name h
H : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h)))))
h : hedge
*****
forall _ : and (eq (MEnc N L) (MEnc N' L)) (synthesis h M N'), synthesis h M N
+++++
intro.
-----
Lemma left_consistent_impl_cond_irr_strong : forall h : hedge, name_left_name h /\\ injective_left h /\\ op_synthesis_left h /\\ pair_free_left h /\\ enc_synthesis_left h /\\ enc_analysis_left h -> cond_irr h.
intros.
elim H.
intros.
elim H1.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
unfold cond_irr in |- *.
split.
split.
split.
unfold cyph_dec in |- *.
intros.
unfold enc_analysis_left in H9.
generalize (H9 (MEnc M K) (MEnc N L) H10 M K).
intros.
cut (exists N' : Msg, MEnc N L = MEnc N' L /\\ synthesis h M N').
intro.
elim H13.
intro N'.
intro.

*****
H14 : and (eq (MEnc N L) (MEnc N' L)) (synthesis h M N')
N' : Msg
H13 : ex (fun N' : Msg => and (eq (MEnc N L) (MEnc N' L)) (synthesis h M N'))
H12 : forall (_ : eq (MEnc M K) (MEnc M K)) (L0 : Msg)\n (_ : synthesis h (inv K) (inv L0)),\nex\n (fun N' : Msg => and (eq (MEnc N L) (MEnc N' L0)) (synthesis h M N'))
H11 : synthesis h (inv K) (inv L)
H10 : h (MEnc M K) (MEnc N L)
M,N,K,L : Msg
H9 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (L : Msg) (_ : synthesis h (inv K) (inv L)),\nex (fun N' : Msg => and (eq N (MEnc N' L)) (synthesis h M' N'))
H8 : enc_synthesis_left h
H7 : and (enc_synthesis_left h) (enc_analysis_left h)
H6 : pair_free_left h
H5 : and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h))
H4 : op_synthesis_left h
H3 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h)))
H2 : injective_left h
H1 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h))))
H0 : name_left_name h
H : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h)))))
h : hedge
*****
synthesis h M N
+++++
elim H14.
-----
Lemma left_consistent_impl_cond_irr_strong : forall h : hedge, name_left_name h /\\ injective_left h /\\ op_synthesis_left h /\\ pair_free_left h /\\ enc_synthesis_left h /\\ enc_analysis_left h -> cond_irr h.
intros.
elim H.
intros.
elim H1.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
unfold cond_irr in |- *.
split.
split.
split.
unfold cyph_dec in |- *.
intros.
unfold enc_analysis_left in H9.
generalize (H9 (MEnc M K) (MEnc N L) H10 M K).
intros.
cut (exists N' : Msg, MEnc N L = MEnc N' L /\\ synthesis h M N').
intro.
elim H13.
intro N'.
intro.
elim H14.

*****
H14 : and (eq (MEnc N L) (MEnc N' L)) (synthesis h M N')
N' : Msg
H13 : ex (fun N' : Msg => and (eq (MEnc N L) (MEnc N' L)) (synthesis h M N'))
H12 : forall (_ : eq (MEnc M K) (MEnc M K)) (L0 : Msg)\n (_ : synthesis h (inv K) (inv L0)),\nex\n (fun N' : Msg => and (eq (MEnc N L) (MEnc N' L0)) (synthesis h M N'))
H11 : synthesis h (inv K) (inv L)
H10 : h (MEnc M K) (MEnc N L)
M,N,K,L : Msg
H9 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (L : Msg) (_ : synthesis h (inv K) (inv L)),\nex (fun N' : Msg => and (eq N (MEnc N' L)) (synthesis h M' N'))
H8 : enc_synthesis_left h
H7 : and (enc_synthesis_left h) (enc_analysis_left h)
H6 : pair_free_left h
H5 : and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h))
H4 : op_synthesis_left h
H3 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h)))
H2 : injective_left h
H1 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h))))
H0 : name_left_name h
H : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h)))))
h : hedge
*****
forall (_ : eq (MEnc N L) (MEnc N' L)) (_ : synthesis h M N'), synthesis h M N
+++++
intros.
-----
Lemma left_consistent_impl_cond_irr_strong : forall h : hedge, name_left_name h /\\ injective_left h /\\ op_synthesis_left h /\\ pair_free_left h /\\ enc_synthesis_left h /\\ enc_analysis_left h -> cond_irr h.
intros.
elim H.
intros.
elim H1.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
unfold cond_irr in |- *.
split.
split.
split.
unfold cyph_dec in |- *.
intros.
unfold enc_analysis_left in H9.
generalize (H9 (MEnc M K) (MEnc N L) H10 M K).
intros.
cut (exists N' : Msg, MEnc N L = MEnc N' L /\\ synthesis h M N').
intro.
elim H13.
intro N'.
intro.
elim H14.
intros.

*****
H16 : synthesis h M N'
H15 : eq (MEnc N L) (MEnc N' L)
H14 : and (eq (MEnc N L) (MEnc N' L)) (synthesis h M N')
N' : Msg
H13 : ex (fun N' : Msg => and (eq (MEnc N L) (MEnc N' L)) (synthesis h M N'))
H12 : forall (_ : eq (MEnc M K) (MEnc M K)) (L0 : Msg)\n (_ : synthesis h (inv K) (inv L0)),\nex\n (fun N' : Msg => and (eq (MEnc N L) (MEnc N' L0)) (synthesis h M N'))
H11 : synthesis h (inv K) (inv L)
H10 : h (MEnc M K) (MEnc N L)
M,N,K,L : Msg
H9 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (L : Msg) (_ : synthesis h (inv K) (inv L)),\nex (fun N' : Msg => and (eq N (MEnc N' L)) (synthesis h M' N'))
H8 : enc_synthesis_left h
H7 : and (enc_synthesis_left h) (enc_analysis_left h)
H6 : pair_free_left h
H5 : and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h))
H4 : op_synthesis_left h
H3 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h)))
H2 : injective_left h
H1 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h))))
H0 : name_left_name h
H : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h)))))
h : hedge
*****
synthesis h M N
+++++
inversion H15.
-----
Lemma left_consistent_impl_cond_irr_strong : forall h : hedge, name_left_name h /\\ injective_left h /\\ op_synthesis_left h /\\ pair_free_left h /\\ enc_synthesis_left h /\\ enc_analysis_left h -> cond_irr h.
intros.
elim H.
intros.
elim H1.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
unfold cond_irr in |- *.
split.
split.
split.
unfold cyph_dec in |- *.
intros.
unfold enc_analysis_left in H9.
generalize (H9 (MEnc M K) (MEnc N L) H10 M K).
intros.
cut (exists N' : Msg, MEnc N L = MEnc N' L /\\ synthesis h M N').
intro.
elim H13.
intro N'.
intro.
elim H14.
intros.
inversion H15.

*****
H18 : eq N N'
H16 : synthesis h M N'
H15 : eq (MEnc N L) (MEnc N' L)
H14 : and (eq (MEnc N L) (MEnc N' L)) (synthesis h M N')
N' : Msg
H13 : ex (fun N' : Msg => and (eq (MEnc N L) (MEnc N' L)) (synthesis h M N'))
H12 : forall (_ : eq (MEnc M K) (MEnc M K)) (L0 : Msg)\n (_ : synthesis h (inv K) (inv L0)),\nex\n (fun N' : Msg => and (eq (MEnc N L) (MEnc N' L0)) (synthesis h M N'))
H11 : synthesis h (inv K) (inv L)
H10 : h (MEnc M K) (MEnc N L)
M,N,K,L : Msg
H9 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (L : Msg) (_ : synthesis h (inv K) (inv L)),\nex (fun N' : Msg => and (eq N (MEnc N' L)) (synthesis h M' N'))
H8 : enc_synthesis_left h
H7 : and (enc_synthesis_left h) (enc_analysis_left h)
H6 : pair_free_left h
H5 : and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h))
H4 : op_synthesis_left h
H3 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h)))
H2 : injective_left h
H1 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h))))
H0 : name_left_name h
H : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h)))))
h : hedge
*****
synthesis h M N'
+++++
trivial.
-----
Lemma left_consistent_impl_cond_irr_strong : forall h : hedge, name_left_name h /\\ injective_left h /\\ op_synthesis_left h /\\ pair_free_left h /\\ enc_synthesis_left h /\\ enc_analysis_left h -> cond_irr h.
intros.
elim H.
intros.
elim H1.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
unfold cond_irr in |- *.
split.
split.
split.
unfold cyph_dec in |- *.
intros.
unfold enc_analysis_left in H9.
generalize (H9 (MEnc M K) (MEnc N L) H10 M K).
intros.
cut (exists N' : Msg, MEnc N L = MEnc N' L /\\ synthesis h M N').

*****
H12 : forall (_ : eq (MEnc M K) (MEnc M K)) (L0 : Msg)\n (_ : synthesis h (inv K) (inv L0)),\nex\n (fun N' : Msg => and (eq (MEnc N L) (MEnc N' L0)) (synthesis h M N'))
H11 : synthesis h (inv K) (inv L)
H10 : h (MEnc M K) (MEnc N L)
M,N,K,L : Msg
H9 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (L : Msg) (_ : synthesis h (inv K) (inv L)),\nex (fun N' : Msg => and (eq N (MEnc N' L)) (synthesis h M' N'))
H8 : enc_synthesis_left h
H7 : and (enc_synthesis_left h) (enc_analysis_left h)
H6 : pair_free_left h
H5 : and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h))
H4 : op_synthesis_left h
H3 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h)))
H2 : injective_left h
H1 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h))))
H0 : name_left_name h
H : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h)))))
h : hedge
*****
ex (fun N' : Msg => and (eq (MEnc N L) (MEnc N' L)) (synthesis h M N'))
+++++
apply H12.
-----
Lemma left_consistent_impl_cond_irr_strong : forall h : hedge, name_left_name h /\\ injective_left h /\\ op_synthesis_left h /\\ pair_free_left h /\\ enc_synthesis_left h /\\ enc_analysis_left h -> cond_irr h.
intros.
elim H.
intros.
elim H1.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
unfold cond_irr in |- *.
split.
split.
split.
unfold cyph_dec in |- *.
intros.
unfold enc_analysis_left in H9.
generalize (H9 (MEnc M K) (MEnc N L) H10 M K).
intros.
cut (exists N' : Msg, MEnc N L = MEnc N' L /\\ synthesis h M N').
apply H12.

*****
H12 : forall (_ : eq (MEnc M K) (MEnc M K)) (L0 : Msg)\n (_ : synthesis h (inv K) (inv L0)),\nex\n (fun N' : Msg => and (eq (MEnc N L) (MEnc N' L0)) (synthesis h M N'))
H11 : synthesis h (inv K) (inv L)
H10 : h (MEnc M K) (MEnc N L)
M,N,K,L : Msg
H9 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (L : Msg) (_ : synthesis h (inv K) (inv L)),\nex (fun N' : Msg => and (eq N (MEnc N' L)) (synthesis h M' N'))
H8 : enc_synthesis_left h
H7 : and (enc_synthesis_left h) (enc_analysis_left h)
H6 : pair_free_left h
H5 : and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h))
H4 : op_synthesis_left h
H3 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h)))
H2 : injective_left h
H1 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h))))
H0 : name_left_name h
H : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h)))))
h : hedge
*****
eq (MEnc M K) (MEnc M K)
+++++
auto.
-----
Lemma left_consistent_impl_cond_irr_strong : forall h : hedge, name_left_name h /\\ injective_left h /\\ op_synthesis_left h /\\ pair_free_left h /\\ enc_synthesis_left h /\\ enc_analysis_left h -> cond_irr h.
intros.
elim H.
intros.
elim H1.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
unfold cond_irr in |- *.
split.
split.
split.
unfold cyph_dec in |- *.
intros.
unfold enc_analysis_left in H9.
generalize (H9 (MEnc M K) (MEnc N L) H10 M K).
intros.
cut (exists N' : Msg, MEnc N L = MEnc N' L /\\ synthesis h M N').
apply H12.

*****
H12 : forall (_ : eq (MEnc M K) (MEnc M K)) (L0 : Msg)\n (_ : synthesis h (inv K) (inv L0)),\nex\n (fun N' : Msg => and (eq (MEnc N L) (MEnc N' L0)) (synthesis h M N'))
H11 : synthesis h (inv K) (inv L)
H10 : h (MEnc M K) (MEnc N L)
M,N,K,L : Msg
H9 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (L : Msg) (_ : synthesis h (inv K) (inv L)),\nex (fun N' : Msg => and (eq N (MEnc N' L)) (synthesis h M' N'))
H8 : enc_synthesis_left h
H7 : and (enc_synthesis_left h) (enc_analysis_left h)
H6 : pair_free_left h
H5 : and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h))
H4 : op_synthesis_left h
H3 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h)))
H2 : injective_left h
H1 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h))))
H0 : name_left_name h
H : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h) (enc_analysis_left h)))))
h : hedge
*****
synthesis h (inv K) (inv L)
+++++
auto.
-----
Lemma left_consistent_impl_cond_irr_strong : forall h : hedge, name_left_name h /\\ injective_left h /\\ op_synthesis_left h /\\ pair_free_left h /\\ enc_synthesis_left h /\\ enc_analysis_left h -> cond_irr h.
intros.
elim H.
intros.
elim H1.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
unfold cond_irr in |- *.
split.

*****

*****

+++++
Qed.
-----
Lemma left_consistent_impl_cond_irr :\n forall h : hedge, is_left_consistent h -> cond_irr h.
-----
Lemma left_consistent_impl_cond_irr : forall h : hedge, is_left_consistent h -> cond_irr h.

*****

*****
forall (h : hedge) (_ : is_left_consistent h), cond_irr h
+++++
intros.
-----
Lemma left_consistent_impl_cond_irr : forall h : hedge, is_left_consistent h -> cond_irr h.
intros.

*****
H : is_left_consistent h
h : hedge
*****
cond_irr h
+++++
apply left_consistent_impl_cond_irr_strong.
-----
Lemma left_consistent_impl_cond_irr : forall h : hedge, is_left_consistent h -> cond_irr h.
intros.
apply left_consistent_impl_cond_irr_strong.

*****
H : is_left_consistent h
h : hedge
*****
and (name_left_name h) (and (injective_left h) (and (op_synthesis_left h) (and (pair_free_left h) (and (enc_synthesis_left h) (enc_analysis_left h)))))
+++++
unfold is_left_consistent in H.
-----
Lemma left_consistent_impl_cond_irr : forall h : hedge, is_left_consistent h -> cond_irr h.
intros.
apply left_consistent_impl_cond_irr_strong.
unfold is_left_consistent in H.

*****
H : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
h : hedge
*****
and (name_left_name h) (and (injective_left h) (and (op_synthesis_left h) (and (pair_free_left h) (and (enc_synthesis_left h) (enc_analysis_left h)))))
+++++
tauto.
-----
Lemma left_consistent_impl_cond_irr : forall h : hedge, is_left_consistent h -> cond_irr h.
intros.
apply left_consistent_impl_cond_irr_strong.
unfold is_left_consistent in H.
tauto.

*****

*****

+++++
Qed.
-----
Lemma consistent_impl_cond_irr :\n forall h : hedge, is_consistent h -> cond_irr h.
-----
Lemma consistent_impl_cond_irr : forall h : hedge, is_consistent h -> cond_irr h.

*****

*****
forall (h : hedge) (_ : is_consistent h), cond_irr h
+++++
unfold is_consistent in |- *.
-----
Lemma consistent_impl_cond_irr : forall h : hedge, is_consistent h -> cond_irr h.
unfold is_consistent in |- *.

*****

*****
forall (h : hedge) (_ : and (is_left_consistent h) (is_left_consistent (transpose h))), cond_irr h
+++++
intros.
-----
Lemma consistent_impl_cond_irr : forall h : hedge, is_consistent h -> cond_irr h.
unfold is_consistent in |- *.
intros.

*****
H : and (is_left_consistent h) (is_left_consistent (transpose h))
h : hedge
*****
cond_irr h
+++++
elim H.
-----
Lemma consistent_impl_cond_irr : forall h : hedge, is_consistent h -> cond_irr h.
unfold is_consistent in |- *.
intros.
elim H.

*****
H : and (is_left_consistent h) (is_left_consistent (transpose h))
h : hedge
*****
forall (_ : is_left_consistent h) (_ : is_left_consistent (transpose h)), cond_irr h
+++++
intros.
-----
Lemma consistent_impl_cond_irr : forall h : hedge, is_consistent h -> cond_irr h.
unfold is_consistent in |- *.
intros.
elim H.
intros.

*****
H1 : is_left_consistent (transpose h)
H0 : is_left_consistent h
H : and (is_left_consistent h) (is_left_consistent (transpose h))
h : hedge
*****
cond_irr h
+++++
apply left_consistent_impl_cond_irr.
-----
Lemma consistent_impl_cond_irr : forall h : hedge, is_consistent h -> cond_irr h.
unfold is_consistent in |- *.
intros.
elim H.
intros.
apply left_consistent_impl_cond_irr.

*****
H1 : is_left_consistent (transpose h)
H0 : is_left_consistent h
H : and (is_left_consistent h) (is_left_consistent (transpose h))
h : hedge
*****
is_left_consistent h
+++++
trivial.
-----
Lemma consistent_impl_cond_irr : forall h : hedge, is_consistent h -> cond_irr h.
unfold is_consistent in |- *.
intros.
elim H.
intros.
apply left_consistent_impl_cond_irr.
trivial.

*****

*****

+++++
Qed.
-----
Lemma cond_irr_impl_le_h_ana :\n forall h : hedge, cond_irr h -> le_h (analysis_def h) h.
-----
Lemma cond_irr_impl_le_h_ana : forall h : hedge, cond_irr h -> le_h (analysis_def h) h.

*****

*****
forall (h : hedge) (_ : cond_irr h), le_h (analysis_def h) h
+++++
unfold cond_irr in |- *.
-----
Lemma cond_irr_impl_le_h_ana : forall h : hedge, cond_irr h -> le_h (analysis_def h) h.
unfold cond_irr in |- *.

*****

*****
forall (h : hedge) (_ : and (no_pairs h) (and (no_syn_ops h) (and (no_syn_cyph h) (cyph_dec h)))), le_h (analysis_def h) h
+++++
intros.
-----
Lemma cond_irr_impl_le_h_ana : forall h : hedge, cond_irr h -> le_h (analysis_def h) h.
unfold cond_irr in |- *.
intros.

*****
H : and (no_pairs h)\n (and (no_syn_ops h) (and (no_syn_cyph h) (cyph_dec h)))
h : hedge
*****
le_h (analysis_def h) h
+++++
apply incl_syn_impl_le_h.
-----
Lemma cond_irr_impl_le_h_ana : forall h : hedge, cond_irr h -> le_h (analysis_def h) h.
unfold cond_irr in |- *.
intros.
apply incl_syn_impl_le_h.

*****
H : and (no_pairs h)\n (and (no_syn_ops h) (and (no_syn_cyph h) (cyph_dec h)))
h : hedge
*****
inclusion (analysis_def h) (synthesis h)
+++++
generalize (analysis_is_analysis h).
-----
Lemma cond_irr_impl_le_h_ana : forall h : hedge, cond_irr h -> le_h (analysis_def h) h.
unfold cond_irr in |- *.
intros.
apply incl_syn_impl_le_h.
generalize (analysis_is_analysis h).

*****
H : and (no_pairs h)\n (and (no_syn_ops h) (and (no_syn_cyph h) (cyph_dec h)))
h : hedge
*****
forall _ : is_analysis h (analysis_def h), inclusion (analysis_def h) (synthesis h)
+++++
unfold is_analysis in |- *.
-----
Lemma cond_irr_impl_le_h_ana : forall h : hedge, cond_irr h -> le_h (analysis_def h) h.
unfold cond_irr in |- *.
intros.
apply incl_syn_impl_le_h.
generalize (analysis_is_analysis h).
unfold is_analysis in |- *.

*****
H : and (no_pairs h)\n (and (no_syn_ops h) (and (no_syn_cyph h) (cyph_dec h)))
h : hedge
*****
forall _ : and (analysis_cond h (analysis_def h)) (forall (h' : hedge) (_ : analysis_cond h h'), inclusion (analysis_def h) h'), inclusion (analysis_def h) (synthesis h)
+++++
intro.
-----
Lemma cond_irr_impl_le_h_ana : forall h : hedge, cond_irr h -> le_h (analysis_def h) h.
unfold cond_irr in |- *.
intros.
apply incl_syn_impl_le_h.
generalize (analysis_is_analysis h).
unfold is_analysis in |- *.
intro.

*****
H0 : and (analysis_cond h (analysis_def h))\n (forall (h' : hedge) (_ : analysis_cond h h'),\n inclusion (analysis_def h) h')
H : and (no_pairs h)\n (and (no_syn_ops h) (and (no_syn_cyph h) (cyph_dec h)))
h : hedge
*****
inclusion (analysis_def h) (synthesis h)
+++++
elim H0.
-----
Lemma cond_irr_impl_le_h_ana : forall h : hedge, cond_irr h -> le_h (analysis_def h) h.
unfold cond_irr in |- *.
intros.
apply incl_syn_impl_le_h.
generalize (analysis_is_analysis h).
unfold is_analysis in |- *.
intro.
elim H0.

*****
H0 : and (analysis_cond h (analysis_def h))\n (forall (h' : hedge) (_ : analysis_cond h h'),\n inclusion (analysis_def h) h')
H : and (no_pairs h)\n (and (no_syn_ops h) (and (no_syn_cyph h) (cyph_dec h)))
h : hedge
*****
forall (_ : analysis_cond h (analysis_def h)) (_ : forall (h' : hedge) (_ : analysis_cond h h'), inclusion (analysis_def h) h'), inclusion (analysis_def h) (synthesis h)
+++++
unfold analysis_cond in |- *.
-----
Lemma cond_irr_impl_le_h_ana : forall h : hedge, cond_irr h -> le_h (analysis_def h) h.
unfold cond_irr in |- *.
intros.
apply incl_syn_impl_le_h.
generalize (analysis_is_analysis h).
unfold is_analysis in |- *.
intro.
elim H0.
unfold analysis_cond in |- *.

*****
H0 : and (analysis_cond h (analysis_def h))\n (forall (h' : hedge) (_ : analysis_cond h h'),\n inclusion (analysis_def h) h')
H : and (no_pairs h)\n (and (no_syn_ops h) (and (no_syn_cyph h) (cyph_dec h)))
h : hedge
*****
forall (_ : and (inclusion h (analysis_def h)) (stable_analysis (analysis_def h))) (_ : forall (h' : hedge) (_ : and (inclusion h h') (stable_analysis h')), inclusion (analysis_def h) h'), inclusion (analysis_def h) (synthesis h)
+++++
intros.
-----
Lemma cond_irr_impl_le_h_ana : forall h : hedge, cond_irr h -> le_h (analysis_def h) h.
unfold cond_irr in |- *.
intros.
apply incl_syn_impl_le_h.
generalize (analysis_is_analysis h).
unfold is_analysis in |- *.
intro.
elim H0.
unfold analysis_cond in |- *.
intros.

*****
H2 : forall (h' : hedge) (_ : and (inclusion h h') (stable_analysis h')),\ninclusion (analysis_def h) h'
H1 : and (inclusion h (analysis_def h)) (stable_analysis (analysis_def h))
H0 : and (analysis_cond h (analysis_def h))\n (forall (h' : hedge) (_ : analysis_cond h h'),\n inclusion (analysis_def h) h')
H : and (no_pairs h)\n (and (no_syn_ops h) (and (no_syn_cyph h) (cyph_dec h)))
h : hedge
*****
inclusion (analysis_def h) (synthesis h)
+++++
apply H2.
-----
Lemma cond_irr_impl_le_h_ana : forall h : hedge, cond_irr h -> le_h (analysis_def h) h.
unfold cond_irr in |- *.
intros.
apply incl_syn_impl_le_h.
generalize (analysis_is_analysis h).
unfold is_analysis in |- *.
intro.
elim H0.
unfold analysis_cond in |- *.
intros.
apply H2.

*****
H2 : forall (h' : hedge) (_ : and (inclusion h h') (stable_analysis h')),\ninclusion (analysis_def h) h'
H1 : and (inclusion h (analysis_def h)) (stable_analysis (analysis_def h))
H0 : and (analysis_cond h (analysis_def h))\n (forall (h' : hedge) (_ : analysis_cond h h'),\n inclusion (analysis_def h) h')
H : and (no_pairs h)\n (and (no_syn_ops h) (and (no_syn_cyph h) (cyph_dec h)))
h : hedge
*****
and (inclusion h (synthesis h)) (stable_analysis (synthesis h))
+++++
split.
-----
Lemma cond_irr_impl_le_h_ana : forall h : hedge, cond_irr h -> le_h (analysis_def h) h.
unfold cond_irr in |- *.
intros.
apply incl_syn_impl_le_h.
generalize (analysis_is_analysis h).
unfold is_analysis in |- *.
intro.
elim H0.
unfold analysis_cond in |- *.
intros.
apply H2.
split.

*****
H2 : forall (h' : hedge) (_ : and (inclusion h h') (stable_analysis h')),\ninclusion (analysis_def h) h'
H1 : and (inclusion h (analysis_def h)) (stable_analysis (analysis_def h))
H0 : and (analysis_cond h (analysis_def h))\n (forall (h' : hedge) (_ : analysis_cond h h'),\n inclusion (analysis_def h) h')
H : and (no_pairs h)\n (and (no_syn_ops h) (and (no_syn_cyph h) (cyph_dec h)))
h : hedge
*****
inclusion h (synthesis h)
+++++
unfold inclusion in |- *.
-----
Lemma cond_irr_impl_le_h_ana : forall h : hedge, cond_irr h -> le_h (analysis_def h) h.
unfold cond_irr in |- *.
intros.
apply incl_syn_impl_le_h.
generalize (analysis_is_analysis h).
unfold is_analysis in |- *.
intro.
elim H0.
unfold analysis_cond in |- *.
intros.
apply H2.
split.
unfold inclusion in |- *.

*****
H2 : forall (h' : hedge) (_ : and (inclusion h h') (stable_analysis h')),\ninclusion (analysis_def h) h'
H1 : and (inclusion h (analysis_def h)) (stable_analysis (analysis_def h))
H0 : and (analysis_cond h (analysis_def h))\n (forall (h' : hedge) (_ : analysis_cond h h'),\n inclusion (analysis_def h) h')
H : and (no_pairs h)\n (and (no_syn_ops h) (and (no_syn_cyph h) (cyph_dec h)))
h : hedge
*****
forall (M N : Msg) (_ : h M N), synthesis h M N
+++++
intros.
-----
Lemma cond_irr_impl_le_h_ana : forall h : hedge, cond_irr h -> le_h (analysis_def h) h.
unfold cond_irr in |- *.
intros.
apply incl_syn_impl_le_h.
generalize (analysis_is_analysis h).
unfold is_analysis in |- *.
intro.
elim H0.
unfold analysis_cond in |- *.
intros.
apply H2.
split.
unfold inclusion in |- *.
intros.

*****
H3 : h M N
M,N : Msg
H2 : forall (h' : hedge) (_ : and (inclusion h h') (stable_analysis h')),\ninclusion (analysis_def h) h'
H1 : and (inclusion h (analysis_def h)) (stable_analysis (analysis_def h))
H0 : and (analysis_cond h (analysis_def h))\n (forall (h' : hedge) (_ : analysis_cond h h'),\n inclusion (analysis_def h) h')
H : and (no_pairs h)\n (and (no_syn_ops h) (and (no_syn_cyph h) (cyph_dec h)))
h : hedge
*****
synthesis h M N
+++++
apply SynInc.
-----
Lemma cond_irr_impl_le_h_ana : forall h : hedge, cond_irr h -> le_h (analysis_def h) h.
unfold cond_irr in |- *.
intros.
apply incl_syn_impl_le_h.
generalize (analysis_is_analysis h).
unfold is_analysis in |- *.
intro.
elim H0.
unfold analysis_cond in |- *.
intros.
apply H2.
split.
unfold inclusion in |- *.
intros.
apply SynInc.

*****
H3 : h M N
M,N : Msg
H2 : forall (h' : hedge) (_ : and (inclusion h h') (stable_analysis h')),\ninclusion (analysis_def h) h'
H1 : and (inclusion h (analysis_def h)) (stable_analysis (analysis_def h))
H0 : and (analysis_cond h (analysis_def h))\n (forall (h' : hedge) (_ : analysis_cond h h'),\n inclusion (analysis_def h) h')
H : and (no_pairs h)\n (and (no_syn_ops h) (and (no_syn_cyph h) (cyph_dec h)))
h : hedge
*****
h M N
+++++
trivial.
-----
Lemma cond_irr_impl_le_h_ana : forall h : hedge, cond_irr h -> le_h (analysis_def h) h.
unfold cond_irr in |- *.
intros.
apply incl_syn_impl_le_h.
generalize (analysis_is_analysis h).
unfold is_analysis in |- *.
intro.
elim H0.
unfold analysis_cond in |- *.
intros.
apply H2.
split.

*****
H2 : forall (h' : hedge) (_ : and (inclusion h h') (stable_analysis h')),\ninclusion (analysis_def h) h'
H1 : and (inclusion h (analysis_def h)) (stable_analysis (analysis_def h))
H0 : and (analysis_cond h (analysis_def h))\n (forall (h' : hedge) (_ : analysis_cond h h'),\n inclusion (analysis_def h) h')
H : and (no_pairs h)\n (and (no_syn_ops h) (and (no_syn_cyph h) (cyph_dec h)))
h : hedge
*****
stable_analysis (synthesis h)
+++++
unfold stable_analysis in |- *.
-----
Lemma cond_irr_impl_le_h_ana : forall h : hedge, cond_irr h -> le_h (analysis_def h) h.
unfold cond_irr in |- *.
intros.
apply incl_syn_impl_le_h.
generalize (analysis_is_analysis h).
unfold is_analysis in |- *.
intro.
elim H0.
unfold analysis_cond in |- *.
intros.
apply H2.
split.
unfold stable_analysis in |- *.

*****
H2 : forall (h' : hedge) (_ : and (inclusion h h') (stable_analysis h')),\ninclusion (analysis_def h) h'
H1 : and (inclusion h (analysis_def h)) (stable_analysis (analysis_def h))
H0 : and (analysis_cond h (analysis_def h))\n (forall (h' : hedge) (_ : analysis_cond h h'),\n inclusion (analysis_def h) h')
H : and (no_pairs h)\n (and (no_syn_ops h) (and (no_syn_cyph h) (cyph_dec h)))
h : hedge
*****
inclusion (analysis (synthesis h)) (synthesis h)
+++++
unfold inclusion in |- *.
-----
Lemma cond_irr_impl_le_h_ana : forall h : hedge, cond_irr h -> le_h (analysis_def h) h.
unfold cond_irr in |- *.
intros.
apply incl_syn_impl_le_h.
generalize (analysis_is_analysis h).
unfold is_analysis in |- *.
intro.
elim H0.
unfold analysis_cond in |- *.
intros.
apply H2.
split.
unfold stable_analysis in |- *.
unfold inclusion in |- *.

*****
H2 : forall (h' : hedge) (_ : and (inclusion h h') (stable_analysis h')),\ninclusion (analysis_def h) h'
H1 : and (inclusion h (analysis_def h)) (stable_analysis (analysis_def h))
H0 : and (analysis_cond h (analysis_def h))\n (forall (h' : hedge) (_ : analysis_cond h h'),\n inclusion (analysis_def h) h')
H : and (no_pairs h)\n (and (no_syn_ops h) (and (no_syn_cyph h) (cyph_dec h)))
h : hedge
*****
forall (M N : Msg) (_ : analysis (synthesis h) M N), synthesis h M N
+++++
intros.
-----
Lemma cond_irr_impl_le_h_ana : forall h : hedge, cond_irr h -> le_h (analysis_def h) h.
unfold cond_irr in |- *.
intros.
apply incl_syn_impl_le_h.
generalize (analysis_is_analysis h).
unfold is_analysis in |- *.
intro.
elim H0.
unfold analysis_cond in |- *.
intros.
apply H2.
split.
unfold stable_analysis in |- *.
unfold inclusion in |- *.
intros.

*****
H3 : analysis (synthesis h) M N
M,N : Msg
H2 : forall (h' : hedge) (_ : and (inclusion h h') (stable_analysis h')),\ninclusion (analysis_def h) h'
H1 : and (inclusion h (analysis_def h)) (stable_analysis (analysis_def h))
H0 : and (analysis_cond h (analysis_def h))\n (forall (h' : hedge) (_ : analysis_cond h h'),\n inclusion (analysis_def h) h')
H : and (no_pairs h)\n (and (no_syn_ops h) (and (no_syn_cyph h) (cyph_dec h)))
h : hedge
*****
synthesis h M N
+++++
induction H3 as [M N H3| M1 M2 N1 N2 H3 HrecH3| M1 M2 N1 N2 H3 HrecH3| M N K L H3 HrecH3 H4].
-----
Lemma cond_irr_impl_le_h_ana : forall h : hedge, cond_irr h -> le_h (analysis_def h) h.
unfold cond_irr in |- *.
intros.
apply incl_syn_impl_le_h.
generalize (analysis_is_analysis h).
unfold is_analysis in |- *.
intro.
elim H0.
unfold analysis_cond in |- *.
intros.
apply H2.
split.
unfold stable_analysis in |- *.
unfold inclusion in |- *.
intros.
induction H3 as [M N H3| M1 M2 N1 N2 H3 HrecH3| M1 M2 N1 N2 H3 HrecH3| M N K L H3 HrecH3 H4].

*****
H3 : synthesis h M N
M,N : Msg
H2 : forall (h' : hedge) (_ : and (inclusion h h') (stable_analysis h')),\ninclusion (analysis_def h) h'
H1 : and (inclusion h (analysis_def h)) (stable_analysis (analysis_def h))
H0 : and (analysis_cond h (analysis_def h))\n (forall (h' : hedge) (_ : analysis_cond h h'),\n inclusion (analysis_def h) h')
H : and (no_pairs h)\n (and (no_syn_ops h) (and (no_syn_cyph h) (cyph_dec h)))
h : hedge
*****
synthesis h M N
+++++
trivial.
-----
Lemma cond_irr_impl_le_h_ana : forall h : hedge, cond_irr h -> le_h (analysis_def h) h.
unfold cond_irr in |- *.
intros.
apply incl_syn_impl_le_h.
generalize (analysis_is_analysis h).
unfold is_analysis in |- *.
intro.
elim H0.
unfold analysis_cond in |- *.
intros.
apply H2.
split.
unfold stable_analysis in |- *.
unfold inclusion in |- *.
intros.
induction H3 as [M N H3| M1 M2 N1 N2 H3 HrecH3| M1 M2 N1 N2 H3 HrecH3| M N K L H3 HrecH3 H4].

*****
HrecH3 : synthesis h (MPair M1 M2) (MPair N1 N2)
H3 : analysis (synthesis h) (MPair M1 M2) (MPair N1 N2)
M1,M2,N1,N2 : Msg
H2 : forall (h' : hedge) (_ : and (inclusion h h') (stable_analysis h')),\ninclusion (analysis_def h) h'
H1 : and (inclusion h (analysis_def h)) (stable_analysis (analysis_def h))
H0 : and (analysis_cond h (analysis_def h))\n (forall (h' : hedge) (_ : analysis_cond h h'),\n inclusion (analysis_def h) h')
H : and (no_pairs h)\n (and (no_syn_ops h) (and (no_syn_cyph h) (cyph_dec h)))
h : hedge
*****
synthesis h M1 N1
+++++
trivial.
-----
Lemma cond_irr_impl_le_h_ana : forall h : hedge, cond_irr h -> le_h (analysis_def h) h.
unfold cond_irr in |- *.
intros.
apply incl_syn_impl_le_h.
generalize (analysis_is_analysis h).
unfold is_analysis in |- *.
intro.
elim H0.
unfold analysis_cond in |- *.
intros.
apply H2.
split.
unfold stable_analysis in |- *.
unfold inclusion in |- *.
intros.
induction H3 as [M N H3| M1 M2 N1 N2 H3 HrecH3| M1 M2 N1 N2 H3 HrecH3| M N K L H3 HrecH3 H4].
trivial.

*****
HrecH3 : synthesis h (MPair M1 M2) (MPair N1 N2)
H3 : analysis (synthesis h) (MPair M1 M2) (MPair N1 N2)
M1,M2,N1,N2 : Msg
H2 : forall (h' : hedge) (_ : and (inclusion h h') (stable_analysis h')),\ninclusion (analysis_def h) h'
H1 : and (inclusion h (analysis_def h)) (stable_analysis (analysis_def h))
H0 : and (analysis_cond h (analysis_def h))\n (forall (h' : hedge) (_ : analysis_cond h h'),\n inclusion (analysis_def h) h')
H : and (no_pairs h)\n (and (no_syn_ops h) (and (no_syn_cyph h) (cyph_dec h)))
h : hedge
*****
synthesis h M1 N1
+++++
inversion HrecH3.
-----
Lemma cond_irr_impl_le_h_ana : forall h : hedge, cond_irr h -> le_h (analysis_def h) h.
unfold cond_irr in |- *.
intros.
apply incl_syn_impl_le_h.
generalize (analysis_is_analysis h).
unfold is_analysis in |- *.
intro.
elim H0.
unfold analysis_cond in |- *.
intros.
apply H2.
split.
unfold stable_analysis in |- *.
unfold inclusion in |- *.
intros.
induction H3 as [M N H3| M1 M2 N1 N2 H3 HrecH3| M1 M2 N1 N2 H3 HrecH3| M N K L H3 HrecH3 H4].
trivial.
inversion HrecH3.

*****
H6 : eq N (MPair N1 N2)
H5 : eq M (MPair M1 M2)
H4 : h (MPair M1 M2) (MPair N1 N2)
M,N : Msg
HrecH3 : synthesis h (MPair M1 M2) (MPair N1 N2)
H3 : analysis (synthesis h) (MPair M1 M2) (MPair N1 N2)
M1,M2,N1,N2 : Msg
H2 : forall (h' : hedge) (_ : and (inclusion h h') (stable_analysis h')),\ninclusion (analysis_def h) h'
H1 : and (inclusion h (analysis_def h)) (stable_analysis (analysis_def h))
H0 : and (analysis_cond h (analysis_def h))\n (forall (h' : hedge) (_ : analysis_cond h h'),\n inclusion (analysis_def h) h')
H : and (no_pairs h)\n (and (no_syn_ops h) (and (no_syn_cyph h) (cyph_dec h)))
h : hedge
*****
synthesis h M1 N1
+++++
trivial.
-----
Lemma cond_irr_impl_le_h_ana : forall h : hedge, cond_irr h -> le_h (analysis_def h) h.
unfold cond_irr in |- *.
intros.
apply incl_syn_impl_le_h.
generalize (analysis_is_analysis h).
unfold is_analysis in |- *.
intro.
elim H0.
unfold analysis_cond in |- *.
intros.
apply H2.
split.
unfold stable_analysis in |- *.
unfold inclusion in |- *.
intros.
induction H3 as [M N H3| M1 M2 N1 N2 H3 HrecH3| M1 M2 N1 N2 H3 HrecH3| M N K L H3 HrecH3 H4].
trivial.
inversion HrecH3.
trivial.

*****
H6 : eq N (MPair N1 N2)
H5 : eq M (MPair M1 M2)
H4 : h (MPair M1 M2) (MPair N1 N2)
M,N : Msg
HrecH3 : synthesis h (MPair M1 M2) (MPair N1 N2)
H3 : analysis (synthesis h) (MPair M1 M2) (MPair N1 N2)
M1,M2,N1,N2 : Msg
H2 : forall (h' : hedge) (_ : and (inclusion h h') (stable_analysis h')),\ninclusion (analysis_def h) h'
H1 : and (inclusion h (analysis_def h)) (stable_analysis (analysis_def h))
H0 : and (analysis_cond h (analysis_def h))\n (forall (h' : hedge) (_ : analysis_cond h h'),\n inclusion (analysis_def h) h')
H : and (no_pairs h)\n (and (no_syn_ops h) (and (no_syn_cyph h) (cyph_dec h)))
h : hedge
*****
synthesis h M1 N1
+++++
unfold no_pairs in H.
-----
Lemma cond_irr_impl_le_h_ana : forall h : hedge, cond_irr h -> le_h (analysis_def h) h.
unfold cond_irr in |- *.
intros.
apply incl_syn_impl_le_h.
generalize (analysis_is_analysis h).
unfold is_analysis in |- *.
intro.
elim H0.
unfold analysis_cond in |- *.
intros.
apply H2.
split.
unfold stable_analysis in |- *.
unfold inclusion in |- *.
intros.
induction H3 as [M N H3| M1 M2 N1 N2 H3 HrecH3| M1 M2 N1 N2 H3 HrecH3| M N K L H3 HrecH3 H4].
trivial.
inversion HrecH3.
trivial.
unfold no_pairs in H.

*****
H6 : eq N (MPair N1 N2)
H5 : eq M (MPair M1 M2)
H4 : h (MPair M1 M2) (MPair N1 N2)
M,N : Msg
HrecH3 : synthesis h (MPair M1 M2) (MPair N1 N2)
H3 : analysis (synthesis h) (MPair M1 M2) (MPair N1 N2)
M1,M2,N1,N2 : Msg
H2 : forall (h' : hedge) (_ : and (inclusion h h') (stable_analysis h')),\ninclusion (analysis_def h) h'
H1 : and (inclusion h (analysis_def h)) (stable_analysis (analysis_def h))
H0 : and (analysis_cond h (analysis_def h))\n (forall (h' : hedge) (_ : analysis_cond h h'),\n inclusion (analysis_def h) h')
H : and (forall M1 M2 N1 N2 : Msg, not (h (MPair M1 M2) (MPair N1 N2)))\n (and (no_syn_ops h) (and (no_syn_cyph h) (cyph_dec h)))
h : hedge
*****
synthesis h M1 N1
+++++
elim H.
-----
Lemma cond_irr_impl_le_h_ana : forall h : hedge, cond_irr h -> le_h (analysis_def h) h.
unfold cond_irr in |- *.
intros.
apply incl_syn_impl_le_h.
generalize (analysis_is_analysis h).
unfold is_analysis in |- *.
intro.
elim H0.
unfold analysis_cond in |- *.
intros.
apply H2.
split.
unfold stable_analysis in |- *.
unfold inclusion in |- *.
intros.
induction H3 as [M N H3| M1 M2 N1 N2 H3 HrecH3| M1 M2 N1 N2 H3 HrecH3| M N K L H3 HrecH3 H4].
trivial.
inversion HrecH3.
trivial.
unfold no_pairs in H.
elim H.

*****
H6 : eq N (MPair N1 N2)
H5 : eq M (MPair M1 M2)
H4 : h (MPair M1 M2) (MPair N1 N2)
M,N : Msg
HrecH3 : synthesis h (MPair M1 M2) (MPair N1 N2)
H3 : analysis (synthesis h) (MPair M1 M2) (MPair N1 N2)
M1,M2,N1,N2 : Msg
H2 : forall (h' : hedge) (_ : and (inclusion h h') (stable_analysis h')),\ninclusion (analysis_def h) h'
H1 : and (inclusion h (analysis_def h)) (stable_analysis (analysis_def h))
H0 : and (analysis_cond h (analysis_def h))\n (forall (h' : hedge) (_ : analysis_cond h h'),\n inclusion (analysis_def h) h')
H : and (forall M1 M2 N1 N2 : Msg, not (h (MPair M1 M2) (MPair N1 N2)))\n (and (no_syn_ops h) (and (no_syn_cyph h) (cyph_dec h)))
h : hedge
*****
forall (_ : forall M1 M2 N1 N2 : Msg, not (h (MPair M1 M2) (MPair N1 N2))) (_ : and (no_syn_ops h) (and (no_syn_cyph h) (cyph_dec h))), synthesis h M1 N1
+++++
intros.
-----
Lemma cond_irr_impl_le_h_ana : forall h : hedge, cond_irr h -> le_h (analysis_def h) h.
unfold cond_irr in |- *.
intros.
apply incl_syn_impl_le_h.
generalize (analysis_is_analysis h).
unfold is_analysis in |- *.
intro.
elim H0.
unfold analysis_cond in |- *.
intros.
apply H2.
split.
unfold stable_analysis in |- *.
unfold inclusion in |- *.
intros.
induction H3 as [M N H3| M1 M2 N1 N2 H3 HrecH3| M1 M2 N1 N2 H3 HrecH3| M N K L H3 HrecH3 H4].
trivial.
inversion HrecH3.
trivial.
unfold no_pairs in H.
elim H.
intros.

*****
H8 : and (no_syn_ops h) (and (no_syn_cyph h) (cyph_dec h))
H7 : forall M1 M2 N1 N2 : Msg, not (h (MPair M1 M2) (MPair N1 N2))
H6 : eq N (MPair N1 N2)
H5 : eq M (MPair M1 M2)
H4 : h (MPair M1 M2) (MPair N1 N2)
M,N : Msg
HrecH3 : synthesis h (MPair M1 M2) (MPair N1 N2)
H3 : analysis (synthesis h) (MPair M1 M2) (MPair N1 N2)
M1,M2,N1,N2 : Msg
H2 : forall (h' : hedge) (_ : and (inclusion h h') (stable_analysis h')),\ninclusion (analysis_def h) h'
H1 : and (inclusion h (analysis_def h)) (stable_analysis (analysis_def h))
H0 : and (analysis_cond h (analysis_def h))\n (forall (h' : hedge) (_ : analysis_cond h h'),\n inclusion (analysis_def h) h')
H : and (forall M1 M2 N1 N2 : Msg, not (h (MPair M1 M2) (MPair N1 N2)))\n (and (no_syn_ops h) (and (no_syn_cyph h) (cyph_dec h)))
h : hedge
*****
synthesis h M1 N1
+++++
generalize (H7 M1 M2 N1 N2).
-----
Lemma cond_irr_impl_le_h_ana : forall h : hedge, cond_irr h -> le_h (analysis_def h) h.
unfold cond_irr in |- *.
intros.
apply incl_syn_impl_le_h.
generalize (analysis_is_analysis h).
unfold is_analysis in |- *.
intro.
elim H0.
unfold analysis_cond in |- *.
intros.
apply H2.
split.
unfold stable_analysis in |- *.
unfold inclusion in |- *.
intros.
induction H3 as [M N H3| M1 M2 N1 N2 H3 HrecH3| M1 M2 N1 N2 H3 HrecH3| M N K L H3 HrecH3 H4].
trivial.
inversion HrecH3.
trivial.
unfold no_pairs in H.
elim H.
intros.
generalize (H7 M1 M2 N1 N2).

*****
H8 : and (no_syn_ops h) (and (no_syn_cyph h) (cyph_dec h))
H7 : forall M1 M2 N1 N2 : Msg, not (h (MPair M1 M2) (MPair N1 N2))
H6 : eq N (MPair N1 N2)
H5 : eq M (MPair M1 M2)
H4 : h (MPair M1 M2) (MPair N1 N2)
M,N : Msg
HrecH3 : synthesis h (MPair M1 M2) (MPair N1 N2)
H3 : analysis (synthesis h) (MPair M1 M2) (MPair N1 N2)
M1,M2,N1,N2 : Msg
H2 : forall (h' : hedge) (_ : and (inclusion h h') (stable_analysis h')),\ninclusion (analysis_def h) h'
H1 : and (inclusion h (analysis_def h)) (stable_analysis (analysis_def h))
H0 : and (analysis_cond h (analysis_def h))\n (forall (h' : hedge) (_ : analysis_cond h h'),\n inclusion (analysis_def h) h')
H : and (forall M1 M2 N1 N2 : Msg, not (h (MPair M1 M2) (MPair N1 N2)))\n (and (no_syn_ops h) (and (no_syn_cyph h) (cyph_dec h)))
h : hedge
*****
forall _ : not (h (MPair M1 M2) (MPair N1 N2)), synthesis h M1 N1
+++++
tauto.
-----
Lemma cond_irr_impl_le_h_ana : forall h : hedge, cond_irr h -> le_h (analysis_def h) h.
unfold cond_irr in |- *.
intros.
apply incl_syn_impl_le_h.
generalize (analysis_is_analysis h).
unfold is_analysis in |- *.
intro.
elim H0.
unfold analysis_cond in |- *.
intros.
apply H2.
split.
unfold stable_analysis in |- *.
unfold inclusion in |- *.
intros.
induction H3 as [M N H3| M1 M2 N1 N2 H3 HrecH3| M1 M2 N1 N2 H3 HrecH3| M N K L H3 HrecH3 H4].
trivial.
inversion HrecH3.

*****
H8 : eq N3 N2
H6 : eq N0 N1
H5 : eq M3 M2
H4 : eq M0 M1
H9 : synthesis h M2 N2
H7 : synthesis h M1 N1
M0,N0,M3,N3 : Msg
HrecH3 : synthesis h (MPair M1 M2) (MPair N1 N2)
H3 : analysis (synthesis h) (MPair M1 M2) (MPair N1 N2)
M1,M2,N1,N2 : Msg
H2 : forall (h' : hedge) (_ : and (inclusion h h') (stable_analysis h')),\ninclusion (analysis_def h) h'
H1 : and (inclusion h (analysis_def h)) (stable_analysis (analysis_def h))
H0 : and (analysis_cond h (analysis_def h))\n (forall (h' : hedge) (_ : analysis_cond h h'),\n inclusion (analysis_def h) h')
H : and (no_pairs h)\n (and (no_syn_ops h) (and (no_syn_cyph h) (cyph_dec h)))
h : hedge
*****
synthesis h M1 N1
+++++
trivial.
-----
Lemma cond_irr_impl_le_h_ana : forall h : hedge, cond_irr h -> le_h (analysis_def h) h.
unfold cond_irr in |- *.
intros.
apply incl_syn_impl_le_h.
generalize (analysis_is_analysis h).
unfold is_analysis in |- *.
intro.
elim H0.
unfold analysis_cond in |- *.
intros.
apply H2.
split.
unfold stable_analysis in |- *.
unfold inclusion in |- *.
intros.
induction H3 as [M N H3| M1 M2 N1 N2 H3 HrecH3| M1 M2 N1 N2 H3 HrecH3| M N K L H3 HrecH3 H4].

*****
HrecH3 : synthesis h (MPair M1 M2) (MPair N1 N2)
H3 : analysis (synthesis h) (MPair M1 M2) (MPair N1 N2)
M1,M2,N1,N2 : Msg
H2 : forall (h' : hedge) (_ : and (inclusion h h') (stable_analysis h')),\ninclusion (analysis_def h) h'
H1 : and (inclusion h (analysis_def h)) (stable_analysis (analysis_def h))
H0 : and (analysis_cond h (analysis_def h))\n (forall (h' : hedge) (_ : analysis_cond h h'),\n inclusion (analysis_def h) h')
H : and (no_pairs h)\n (and (no_syn_ops h) (and (no_syn_cyph h) (cyph_dec h)))
h : hedge
*****
synthesis h M2 N2
+++++
trivial.
-----
Lemma cond_irr_impl_le_h_ana : forall h : hedge, cond_irr h -> le_h (analysis_def h) h.
unfold cond_irr in |- *.
intros.
apply incl_syn_impl_le_h.
generalize (analysis_is_analysis h).
unfold is_analysis in |- *.
intro.
elim H0.
unfold analysis_cond in |- *.
intros.
apply H2.
split.
unfold stable_analysis in |- *.
unfold inclusion in |- *.
intros.
induction H3 as [M N H3| M1 M2 N1 N2 H3 HrecH3| M1 M2 N1 N2 H3 HrecH3| M N K L H3 HrecH3 H4].
trivial.

*****
HrecH3 : synthesis h (MPair M1 M2) (MPair N1 N2)
H3 : analysis (synthesis h) (MPair M1 M2) (MPair N1 N2)
M1,M2,N1,N2 : Msg
H2 : forall (h' : hedge) (_ : and (inclusion h h') (stable_analysis h')),\ninclusion (analysis_def h) h'
H1 : and (inclusion h (analysis_def h)) (stable_analysis (analysis_def h))
H0 : and (analysis_cond h (analysis_def h))\n (forall (h' : hedge) (_ : analysis_cond h h'),\n inclusion (analysis_def h) h')
H : and (no_pairs h)\n (and (no_syn_ops h) (and (no_syn_cyph h) (cyph_dec h)))
h : hedge
*****
synthesis h M2 N2
+++++
inversion HrecH3.
-----
Lemma cond_irr_impl_le_h_ana : forall h : hedge, cond_irr h -> le_h (analysis_def h) h.
unfold cond_irr in |- *.
intros.
apply incl_syn_impl_le_h.
generalize (analysis_is_analysis h).
unfold is_analysis in |- *.
intro.
elim H0.
unfold analysis_cond in |- *.
intros.
apply H2.
split.
unfold stable_analysis in |- *.
unfold inclusion in |- *.
intros.
induction H3 as [M N H3| M1 M2 N1 N2 H3 HrecH3| M1 M2 N1 N2 H3 HrecH3| M N K L H3 HrecH3 H4].
trivial.
inversion HrecH3.

*****
H6 : eq N (MPair N1 N2)
H5 : eq M (MPair M1 M2)
H4 : h (MPair M1 M2) (MPair N1 N2)
M,N : Msg
HrecH3 : synthesis h (MPair M1 M2) (MPair N1 N2)
H3 : analysis (synthesis h) (MPair M1 M2) (MPair N1 N2)
M1,M2,N1,N2 : Msg
H2 : forall (h' : hedge) (_ : and (inclusion h h') (stable_analysis h')),\ninclusion (analysis_def h) h'
H1 : and (inclusion h (analysis_def h)) (stable_analysis (analysis_def h))
H0 : and (analysis_cond h (analysis_def h))\n (forall (h' : hedge) (_ : analysis_cond h h'),\n inclusion (analysis_def h) h')
H : and (no_pairs h)\n (and (no_syn_ops h) (and (no_syn_cyph h) (cyph_dec h)))
h : hedge
*****
synthesis h M2 N2
+++++
trivial.
-----
Lemma cond_irr_impl_le_h_ana : forall h : hedge, cond_irr h -> le_h (analysis_def h) h.
unfold cond_irr in |- *.
intros.
apply incl_syn_impl_le_h.
generalize (analysis_is_analysis h).
unfold is_analysis in |- *.
intro.
elim H0.
unfold analysis_cond in |- *.
intros.
apply H2.
split.
unfold stable_analysis in |- *.
unfold inclusion in |- *.
intros.
induction H3 as [M N H3| M1 M2 N1 N2 H3 HrecH3| M1 M2 N1 N2 H3 HrecH3| M N K L H3 HrecH3 H4].
trivial.
inversion HrecH3.
trivial.

*****
H6 : eq N (MPair N1 N2)
H5 : eq M (MPair M1 M2)
H4 : h (MPair M1 M2) (MPair N1 N2)
M,N : Msg
HrecH3 : synthesis h (MPair M1 M2) (MPair N1 N2)
H3 : analysis (synthesis h) (MPair M1 M2) (MPair N1 N2)
M1,M2,N1,N2 : Msg
H2 : forall (h' : hedge) (_ : and (inclusion h h') (stable_analysis h')),\ninclusion (analysis_def h) h'
H1 : and (inclusion h (analysis_def h)) (stable_analysis (analysis_def h))
H0 : and (analysis_cond h (analysis_def h))\n (forall (h' : hedge) (_ : analysis_cond h h'),\n inclusion (analysis_def h) h')
H : and (no_pairs h)\n (and (no_syn_ops h) (and (no_syn_cyph h) (cyph_dec h)))
h : hedge
*****
synthesis h M2 N2
+++++
unfold no_pairs in H.
-----
Lemma cond_irr_impl_le_h_ana : forall h : hedge, cond_irr h -> le_h (analysis_def h) h.
unfold cond_irr in |- *.
intros.
apply incl_syn_impl_le_h.
generalize (analysis_is_analysis h).
unfold is_analysis in |- *.
intro.
elim H0.
unfold analysis_cond in |- *.
intros.
apply H2.
split.
unfold stable_analysis in |- *.
unfold inclusion in |- *.
intros.
induction H3 as [M N H3| M1 M2 N1 N2 H3 HrecH3| M1 M2 N1 N2 H3 HrecH3| M N K L H3 HrecH3 H4].
trivial.
inversion HrecH3.
trivial.
unfold no_pairs in H.

*****
H6 : eq N (MPair N1 N2)
H5 : eq M (MPair M1 M2)
H4 : h (MPair M1 M2) (MPair N1 N2)
M,N : Msg
HrecH3 : synthesis h (MPair M1 M2) (MPair N1 N2)
H3 : analysis (synthesis h) (MPair M1 M2) (MPair N1 N2)
M1,M2,N1,N2 : Msg
H2 : forall (h' : hedge) (_ : and (inclusion h h') (stable_analysis h')),\ninclusion (analysis_def h) h'
H1 : and (inclusion h (analysis_def h)) (stable_analysis (analysis_def h))
H0 : and (analysis_cond h (analysis_def h))\n (forall (h' : hedge) (_ : analysis_cond h h'),\n inclusion (analysis_def h) h')
H : and (forall M1 M2 N1 N2 : Msg, not (h (MPair M1 M2) (MPair N1 N2)))\n (and (no_syn_ops h) (and (no_syn_cyph h) (cyph_dec h)))
h : hedge
*****
synthesis h M2 N2
+++++
elim H.
-----
Lemma cond_irr_impl_le_h_ana : forall h : hedge, cond_irr h -> le_h (analysis_def h) h.
unfold cond_irr in |- *.
intros.
apply incl_syn_impl_le_h.
generalize (analysis_is_analysis h).
unfold is_analysis in |- *.
intro.
elim H0.
unfold analysis_cond in |- *.
intros.
apply H2.
split.
unfold stable_analysis in |- *.
unfold inclusion in |- *.
intros.
induction H3 as [M N H3| M1 M2 N1 N2 H3 HrecH3| M1 M2 N1 N2 H3 HrecH3| M N K L H3 HrecH3 H4].
trivial.
inversion HrecH3.
trivial.
unfold no_pairs in H.
elim H.

*****
H6 : eq N (MPair N1 N2)
H5 : eq M (MPair M1 M2)
H4 : h (MPair M1 M2) (MPair N1 N2)
M,N : Msg
HrecH3 : synthesis h (MPair M1 M2) (MPair N1 N2)
H3 : analysis (synthesis h) (MPair M1 M2) (MPair N1 N2)
M1,M2,N1,N2 : Msg
H2 : forall (h' : hedge) (_ : and (inclusion h h') (stable_analysis h')),\ninclusion (analysis_def h) h'
H1 : and (inclusion h (analysis_def h)) (stable_analysis (analysis_def h))
H0 : and (analysis_cond h (analysis_def h))\n (forall (h' : hedge) (_ : analysis_cond h h'),\n inclusion (analysis_def h) h')
H : and (forall M1 M2 N1 N2 : Msg, not (h (MPair M1 M2) (MPair N1 N2)))\n (and (no_syn_ops h) (and (no_syn_cyph h) (cyph_dec h)))
h : hedge
*****
forall (_ : forall M1 M2 N1 N2 : Msg, not (h (MPair M1 M2) (MPair N1 N2))) (_ : and (no_syn_ops h) (and (no_syn_cyph h) (cyph_dec h))), synthesis h M2 N2
+++++
intros.
-----
Lemma cond_irr_impl_le_h_ana : forall h : hedge, cond_irr h -> le_h (analysis_def h) h.
unfold cond_irr in |- *.
intros.
apply incl_syn_impl_le_h.
generalize (analysis_is_analysis h).
unfold is_analysis in |- *.
intro.
elim H0.
unfold analysis_cond in |- *.
intros.
apply H2.
split.
unfold stable_analysis in |- *.
unfold inclusion in |- *.
intros.
induction H3 as [M N H3| M1 M2 N1 N2 H3 HrecH3| M1 M2 N1 N2 H3 HrecH3| M N K L H3 HrecH3 H4].
trivial.
inversion HrecH3.
trivial.
unfold no_pairs in H.
elim H.
intros.

*****
H8 : and (no_syn_ops h) (and (no_syn_cyph h) (cyph_dec h))
H7 : forall M1 M2 N1 N2 : Msg, not (h (MPair M1 M2) (MPair N1 N2))
H6 : eq N (MPair N1 N2)
H5 : eq M (MPair M1 M2)
H4 : h (MPair M1 M2) (MPair N1 N2)
M,N : Msg
HrecH3 : synthesis h (MPair M1 M2) (MPair N1 N2)
H3 : analysis (synthesis h) (MPair M1 M2) (MPair N1 N2)
M1,M2,N1,N2 : Msg
H2 : forall (h' : hedge) (_ : and (inclusion h h') (stable_analysis h')),\ninclusion (analysis_def h) h'
H1 : and (inclusion h (analysis_def h)) (stable_analysis (analysis_def h))
H0 : and (analysis_cond h (analysis_def h))\n (forall (h' : hedge) (_ : analysis_cond h h'),\n inclusion (analysis_def h) h')
H : and (forall M1 M2 N1 N2 : Msg, not (h (MPair M1 M2) (MPair N1 N2)))\n (and (no_syn_ops h) (and (no_syn_cyph h) (cyph_dec h)))
h : hedge
*****
synthesis h M2 N2
+++++
generalize (H7 M1 M2 N1 N2).
-----
Lemma cond_irr_impl_le_h_ana : forall h : hedge, cond_irr h -> le_h (analysis_def h) h.
unfold cond_irr in |- *.
intros.
apply incl_syn_impl_le_h.
generalize (analysis_is_analysis h).
unfold is_analysis in |- *.
intro.
elim H0.
unfold analysis_cond in |- *.
intros.
apply H2.
split.
unfold stable_analysis in |- *.
unfold inclusion in |- *.
intros.
induction H3 as [M N H3| M1 M2 N1 N2 H3 HrecH3| M1 M2 N1 N2 H3 HrecH3| M N K L H3 HrecH3 H4].
trivial.
inversion HrecH3.
trivial.
unfold no_pairs in H.
elim H.
intros.
generalize (H7 M1 M2 N1 N2).

*****
H8 : and (no_syn_ops h) (and (no_syn_cyph h) (cyph_dec h))
H7 : forall M1 M2 N1 N2 : Msg, not (h (MPair M1 M2) (MPair N1 N2))
H6 : eq N (MPair N1 N2)
H5 : eq M (MPair M1 M2)
H4 : h (MPair M1 M2) (MPair N1 N2)
M,N : Msg
HrecH3 : synthesis h (MPair M1 M2) (MPair N1 N2)
H3 : analysis (synthesis h) (MPair M1 M2) (MPair N1 N2)
M1,M2,N1,N2 : Msg
H2 : forall (h' : hedge) (_ : and (inclusion h h') (stable_analysis h')),\ninclusion (analysis_def h) h'
H1 : and (inclusion h (analysis_def h)) (stable_analysis (analysis_def h))
H0 : and (analysis_cond h (analysis_def h))\n (forall (h' : hedge) (_ : analysis_cond h h'),\n inclusion (analysis_def h) h')
H : and (forall M1 M2 N1 N2 : Msg, not (h (MPair M1 M2) (MPair N1 N2)))\n (and (no_syn_ops h) (and (no_syn_cyph h) (cyph_dec h)))
h : hedge
*****
forall _ : not (h (MPair M1 M2) (MPair N1 N2)), synthesis h M2 N2
+++++
tauto.
-----
Lemma cond_irr_impl_le_h_ana : forall h : hedge, cond_irr h -> le_h (analysis_def h) h.
unfold cond_irr in |- *.
intros.
apply incl_syn_impl_le_h.
generalize (analysis_is_analysis h).
unfold is_analysis in |- *.
intro.
elim H0.
unfold analysis_cond in |- *.
intros.
apply H2.
split.
unfold stable_analysis in |- *.
unfold inclusion in |- *.
intros.
induction H3 as [M N H3| M1 M2 N1 N2 H3 HrecH3| M1 M2 N1 N2 H3 HrecH3| M N K L H3 HrecH3 H4].
trivial.
inversion HrecH3.

*****
H8 : eq N3 N2
H6 : eq N0 N1
H5 : eq M3 M2
H4 : eq M0 M1
H9 : synthesis h M2 N2
H7 : synthesis h M1 N1
M0,N0,M3,N3 : Msg
HrecH3 : synthesis h (MPair M1 M2) (MPair N1 N2)
H3 : analysis (synthesis h) (MPair M1 M2) (MPair N1 N2)
M1,M2,N1,N2 : Msg
H2 : forall (h' : hedge) (_ : and (inclusion h h') (stable_analysis h')),\ninclusion (analysis_def h) h'
H1 : and (inclusion h (analysis_def h)) (stable_analysis (analysis_def h))
H0 : and (analysis_cond h (analysis_def h))\n (forall (h' : hedge) (_ : analysis_cond h h'),\n inclusion (analysis_def h) h')
H : and (no_pairs h)\n (and (no_syn_ops h) (and (no_syn_cyph h) (cyph_dec h)))
h : hedge
*****
synthesis h M2 N2
+++++
trivial.
-----
Lemma cond_irr_impl_le_h_ana : forall h : hedge, cond_irr h -> le_h (analysis_def h) h.
unfold cond_irr in |- *.
intros.
apply incl_syn_impl_le_h.
generalize (analysis_is_analysis h).
unfold is_analysis in |- *.
intro.
elim H0.
unfold analysis_cond in |- *.
intros.
apply H2.
split.
unfold stable_analysis in |- *.
unfold inclusion in |- *.
intros.
induction H3 as [M N H3| M1 M2 N1 N2 H3 HrecH3| M1 M2 N1 N2 H3 HrecH3| M N K L H3 HrecH3 H4].

*****
HrecH3 : synthesis h (MEnc M K) (MEnc N L)
H4 : synthesis (synthesis h) (inv K) (inv L)
H3 : analysis (synthesis h) (MEnc M K) (MEnc N L)
M,N,K,L : Msg
H2 : forall (h' : hedge) (_ : and (inclusion h h') (stable_analysis h')),\ninclusion (analysis_def h) h'
H1 : and (inclusion h (analysis_def h)) (stable_analysis (analysis_def h))
H0 : and (analysis_cond h (analysis_def h))\n (forall (h' : hedge) (_ : analysis_cond h h'),\n inclusion (analysis_def h) h')
H : and (no_pairs h)\n (and (no_syn_ops h) (and (no_syn_cyph h) (cyph_dec h)))
h : hedge
*****
synthesis h M N
+++++
trivial.
-----
Lemma cond_irr_impl_le_h_ana : forall h : hedge, cond_irr h -> le_h (analysis_def h) h.
unfold cond_irr in |- *.
intros.
apply incl_syn_impl_le_h.
generalize (analysis_is_analysis h).
unfold is_analysis in |- *.
intro.
elim H0.
unfold analysis_cond in |- *.
intros.
apply H2.
split.
unfold stable_analysis in |- *.
unfold inclusion in |- *.
intros.
induction H3 as [M N H3| M1 M2 N1 N2 H3 HrecH3| M1 M2 N1 N2 H3 HrecH3| M N K L H3 HrecH3 H4].
trivial.

*****
HrecH3 : synthesis h (MEnc M K) (MEnc N L)
H4 : synthesis (synthesis h) (inv K) (inv L)
H3 : analysis (synthesis h) (MEnc M K) (MEnc N L)
M,N,K,L : Msg
H2 : forall (h' : hedge) (_ : and (inclusion h h') (stable_analysis h')),\ninclusion (analysis_def h) h'
H1 : and (inclusion h (analysis_def h)) (stable_analysis (analysis_def h))
H0 : and (analysis_cond h (analysis_def h))\n (forall (h' : hedge) (_ : analysis_cond h h'),\n inclusion (analysis_def h) h')
H : and (no_pairs h)\n (and (no_syn_ops h) (and (no_syn_cyph h) (cyph_dec h)))
h : hedge
*****
synthesis h M N
+++++
generalize (synthesis_idempotent h).
-----
Lemma cond_irr_impl_le_h_ana : forall h : hedge, cond_irr h -> le_h (analysis_def h) h.
unfold cond_irr in |- *.
intros.
apply incl_syn_impl_le_h.
generalize (analysis_is_analysis h).
unfold is_analysis in |- *.
intro.
elim H0.
unfold analysis_cond in |- *.
intros.
apply H2.
split.
unfold stable_analysis in |- *.
unfold inclusion in |- *.
intros.
induction H3 as [M N H3| M1 M2 N1 N2 H3 HrecH3| M1 M2 N1 N2 H3 HrecH3| M N K L H3 HrecH3 H4].
trivial.
generalize (synthesis_idempotent h).

*****
HrecH3 : synthesis h (MEnc M K) (MEnc N L)
H4 : synthesis (synthesis h) (inv K) (inv L)
H3 : analysis (synthesis h) (MEnc M K) (MEnc N L)
M,N,K,L : Msg
H2 : forall (h' : hedge) (_ : and (inclusion h h') (stable_analysis h')),\ninclusion (analysis_def h) h'
H1 : and (inclusion h (analysis_def h)) (stable_analysis (analysis_def h))
H0 : and (analysis_cond h (analysis_def h))\n (forall (h' : hedge) (_ : analysis_cond h h'),\n inclusion (analysis_def h) h')
H : and (no_pairs h)\n (and (no_syn_ops h) (and (no_syn_cyph h) (cyph_dec h)))
h : hedge
*****
forall _ : equal (synthesis h) (synthesis (synthesis h)), synthesis h M N
+++++
unfold equal in |- *.
-----
Lemma cond_irr_impl_le_h_ana : forall h : hedge, cond_irr h -> le_h (analysis_def h) h.
unfold cond_irr in |- *.
intros.
apply incl_syn_impl_le_h.
generalize (analysis_is_analysis h).
unfold is_analysis in |- *.
intro.
elim H0.
unfold analysis_cond in |- *.
intros.
apply H2.
split.
unfold stable_analysis in |- *.
unfold inclusion in |- *.
intros.
induction H3 as [M N H3| M1 M2 N1 N2 H3 HrecH3| M1 M2 N1 N2 H3 HrecH3| M N K L H3 HrecH3 H4].
trivial.
generalize (synthesis_idempotent h).
unfold equal in |- *.

*****
HrecH3 : synthesis h (MEnc M K) (MEnc N L)
H4 : synthesis (synthesis h) (inv K) (inv L)
H3 : analysis (synthesis h) (MEnc M K) (MEnc N L)
M,N,K,L : Msg
H2 : forall (h' : hedge) (_ : and (inclusion h h') (stable_analysis h')),\ninclusion (analysis_def h) h'
H1 : and (inclusion h (analysis_def h)) (stable_analysis (analysis_def h))
H0 : and (analysis_cond h (analysis_def h))\n (forall (h' : hedge) (_ : analysis_cond h h'),\n inclusion (analysis_def h) h')
H : and (no_pairs h)\n (and (no_syn_ops h) (and (no_syn_cyph h) (cyph_dec h)))
h : hedge
*****
forall _ : and (inclusion (synthesis h) (synthesis (synthesis h))) (inclusion (synthesis (synthesis h)) (synthesis h)), synthesis h M N
+++++
intros.
-----
Lemma cond_irr_impl_le_h_ana : forall h : hedge, cond_irr h -> le_h (analysis_def h) h.
unfold cond_irr in |- *.
intros.
apply incl_syn_impl_le_h.
generalize (analysis_is_analysis h).
unfold is_analysis in |- *.
intro.
elim H0.
unfold analysis_cond in |- *.
intros.
apply H2.
split.
unfold stable_analysis in |- *.
unfold inclusion in |- *.
intros.
induction H3 as [M N H3| M1 M2 N1 N2 H3 HrecH3| M1 M2 N1 N2 H3 HrecH3| M N K L H3 HrecH3 H4].
trivial.
generalize (synthesis_idempotent h).
unfold equal in |- *.
intros.

*****
H5 : and (inclusion (synthesis h) (synthesis (synthesis h)))\n (inclusion (synthesis (synthesis h)) (synthesis h))
HrecH3 : synthesis h (MEnc M K) (MEnc N L)
H4 : synthesis (synthesis h) (inv K) (inv L)
H3 : analysis (synthesis h) (MEnc M K) (MEnc N L)
M,N,K,L : Msg
H2 : forall (h' : hedge) (_ : and (inclusion h h') (stable_analysis h')),\ninclusion (analysis_def h) h'
H1 : and (inclusion h (analysis_def h)) (stable_analysis (analysis_def h))
H0 : and (analysis_cond h (analysis_def h))\n (forall (h' : hedge) (_ : analysis_cond h h'),\n inclusion (analysis_def h) h')
H : and (no_pairs h)\n (and (no_syn_ops h) (and (no_syn_cyph h) (cyph_dec h)))
h : hedge
*****
synthesis h M N
+++++
elim H5.
-----
Lemma cond_irr_impl_le_h_ana : forall h : hedge, cond_irr h -> le_h (analysis_def h) h.
unfold cond_irr in |- *.
intros.
apply incl_syn_impl_le_h.
generalize (analysis_is_analysis h).
unfold is_analysis in |- *.
intro.
elim H0.
unfold analysis_cond in |- *.
intros.
apply H2.
split.
unfold stable_analysis in |- *.
unfold inclusion in |- *.
intros.
induction H3 as [M N H3| M1 M2 N1 N2 H3 HrecH3| M1 M2 N1 N2 H3 HrecH3| M N K L H3 HrecH3 H4].
trivial.
generalize (synthesis_idempotent h).
unfold equal in |- *.
intros.
elim H5.

*****
H5 : and (inclusion (synthesis h) (synthesis (synthesis h)))\n (inclusion (synthesis (synthesis h)) (synthesis h))
HrecH3 : synthesis h (MEnc M K) (MEnc N L)
H4 : synthesis (synthesis h) (inv K) (inv L)
H3 : analysis (synthesis h) (MEnc M K) (MEnc N L)
M,N,K,L : Msg
H2 : forall (h' : hedge) (_ : and (inclusion h h') (stable_analysis h')),\ninclusion (analysis_def h) h'
H1 : and (inclusion h (analysis_def h)) (stable_analysis (analysis_def h))
H0 : and (analysis_cond h (analysis_def h))\n (forall (h' : hedge) (_ : analysis_cond h h'),\n inclusion (analysis_def h) h')
H : and (no_pairs h)\n (and (no_syn_ops h) (and (no_syn_cyph h) (cyph_dec h)))
h : hedge
*****
forall (_ : inclusion (synthesis h) (synthesis (synthesis h))) (_ : inclusion (synthesis (synthesis h)) (synthesis h)), synthesis h M N
+++++
intros.
-----
Lemma cond_irr_impl_le_h_ana : forall h : hedge, cond_irr h -> le_h (analysis_def h) h.
unfold cond_irr in |- *.
intros.
apply incl_syn_impl_le_h.
generalize (analysis_is_analysis h).
unfold is_analysis in |- *.
intro.
elim H0.
unfold analysis_cond in |- *.
intros.
apply H2.
split.
unfold stable_analysis in |- *.
unfold inclusion in |- *.
intros.
induction H3 as [M N H3| M1 M2 N1 N2 H3 HrecH3| M1 M2 N1 N2 H3 HrecH3| M N K L H3 HrecH3 H4].
trivial.
generalize (synthesis_idempotent h).
unfold equal in |- *.
intros.
elim H5.
intros.

*****
H7 : inclusion (synthesis (synthesis h)) (synthesis h)
H6 : inclusion (synthesis h) (synthesis (synthesis h))
H5 : and (inclusion (synthesis h) (synthesis (synthesis h)))\n (inclusion (synthesis (synthesis h)) (synthesis h))
HrecH3 : synthesis h (MEnc M K) (MEnc N L)
H4 : synthesis (synthesis h) (inv K) (inv L)
H3 : analysis (synthesis h) (MEnc M K) (MEnc N L)
M,N,K,L : Msg
H2 : forall (h' : hedge) (_ : and (inclusion h h') (stable_analysis h')),\ninclusion (analysis_def h) h'
H1 : and (inclusion h (analysis_def h)) (stable_analysis (analysis_def h))
H0 : and (analysis_cond h (analysis_def h))\n (forall (h' : hedge) (_ : analysis_cond h h'),\n inclusion (analysis_def h) h')
H : and (no_pairs h)\n (and (no_syn_ops h) (and (no_syn_cyph h) (cyph_dec h)))
h : hedge
*****
synthesis h M N
+++++
unfold inclusion in H7.
-----
Lemma cond_irr_impl_le_h_ana : forall h : hedge, cond_irr h -> le_h (analysis_def h) h.
unfold cond_irr in |- *.
intros.
apply incl_syn_impl_le_h.
generalize (analysis_is_analysis h).
unfold is_analysis in |- *.
intro.
elim H0.
unfold analysis_cond in |- *.
intros.
apply H2.
split.
unfold stable_analysis in |- *.
unfold inclusion in |- *.
intros.
induction H3 as [M N H3| M1 M2 N1 N2 H3 HrecH3| M1 M2 N1 N2 H3 HrecH3| M N K L H3 HrecH3 H4].
trivial.
generalize (synthesis_idempotent h).
unfold equal in |- *.
intros.
elim H5.
intros.
unfold inclusion in H7.

*****
H7 : forall (M N : Msg) (_ : synthesis (synthesis h) M N), synthesis h M N
H6 : inclusion (synthesis h) (synthesis (synthesis h))
H5 : and (inclusion (synthesis h) (synthesis (synthesis h)))\n (inclusion (synthesis (synthesis h)) (synthesis h))
HrecH3 : synthesis h (MEnc M K) (MEnc N L)
H4 : synthesis (synthesis h) (inv K) (inv L)
H3 : analysis (synthesis h) (MEnc M K) (MEnc N L)
M,N,K,L : Msg
H2 : forall (h' : hedge) (_ : and (inclusion h h') (stable_analysis h')),\ninclusion (analysis_def h) h'
H1 : and (inclusion h (analysis_def h)) (stable_analysis (analysis_def h))
H0 : and (analysis_cond h (analysis_def h))\n (forall (h' : hedge) (_ : analysis_cond h h'),\n inclusion (analysis_def h) h')
H : and (no_pairs h)\n (and (no_syn_ops h) (and (no_syn_cyph h) (cyph_dec h)))
h : hedge
*****
synthesis h M N
+++++
generalize (H7 (inv K) (inv L) H4).
-----
Lemma cond_irr_impl_le_h_ana : forall h : hedge, cond_irr h -> le_h (analysis_def h) h.
unfold cond_irr in |- *.
intros.
apply incl_syn_impl_le_h.
generalize (analysis_is_analysis h).
unfold is_analysis in |- *.
intro.
elim H0.
unfold analysis_cond in |- *.
intros.
apply H2.
split.
unfold stable_analysis in |- *.
unfold inclusion in |- *.
intros.
induction H3 as [M N H3| M1 M2 N1 N2 H3 HrecH3| M1 M2 N1 N2 H3 HrecH3| M N K L H3 HrecH3 H4].
trivial.
generalize (synthesis_idempotent h).
unfold equal in |- *.
intros.
elim H5.
intros.
unfold inclusion in H7.
generalize (H7 (inv K) (inv L) H4).

*****
H7 : forall (M N : Msg) (_ : synthesis (synthesis h) M N), synthesis h M N
H6 : inclusion (synthesis h) (synthesis (synthesis h))
H5 : and (inclusion (synthesis h) (synthesis (synthesis h)))\n (inclusion (synthesis (synthesis h)) (synthesis h))
HrecH3 : synthesis h (MEnc M K) (MEnc N L)
H4 : synthesis (synthesis h) (inv K) (inv L)
H3 : analysis (synthesis h) (MEnc M K) (MEnc N L)
M,N,K,L : Msg
H2 : forall (h' : hedge) (_ : and (inclusion h h') (stable_analysis h')),\ninclusion (analysis_def h) h'
H1 : and (inclusion h (analysis_def h)) (stable_analysis (analysis_def h))
H0 : and (analysis_cond h (analysis_def h))\n (forall (h' : hedge) (_ : analysis_cond h h'),\n inclusion (analysis_def h) h')
H : and (no_pairs h)\n (and (no_syn_ops h) (and (no_syn_cyph h) (cyph_dec h)))
h : hedge
*****
forall _ : synthesis h (inv K) (inv L), synthesis h M N
+++++
intro.
-----
Lemma cond_irr_impl_le_h_ana : forall h : hedge, cond_irr h -> le_h (analysis_def h) h.
unfold cond_irr in |- *.
intros.
apply incl_syn_impl_le_h.
generalize (analysis_is_analysis h).
unfold is_analysis in |- *.
intro.
elim H0.
unfold analysis_cond in |- *.
intros.
apply H2.
split.
unfold stable_analysis in |- *.
unfold inclusion in |- *.
intros.
induction H3 as [M N H3| M1 M2 N1 N2 H3 HrecH3| M1 M2 N1 N2 H3 HrecH3| M N K L H3 HrecH3 H4].
trivial.
generalize (synthesis_idempotent h).
unfold equal in |- *.
intros.
elim H5.
intros.
unfold inclusion in H7.
generalize (H7 (inv K) (inv L) H4).
intro.

*****
H8 : synthesis h (inv K) (inv L)
H7 : forall (M N : Msg) (_ : synthesis (synthesis h) M N), synthesis h M N
H6 : inclusion (synthesis h) (synthesis (synthesis h))
H5 : and (inclusion (synthesis h) (synthesis (synthesis h)))\n (inclusion (synthesis (synthesis h)) (synthesis h))
HrecH3 : synthesis h (MEnc M K) (MEnc N L)
H4 : synthesis (synthesis h) (inv K) (inv L)
H3 : analysis (synthesis h) (MEnc M K) (MEnc N L)
M,N,K,L : Msg
H2 : forall (h' : hedge) (_ : and (inclusion h h') (stable_analysis h')),\ninclusion (analysis_def h) h'
H1 : and (inclusion h (analysis_def h)) (stable_analysis (analysis_def h))
H0 : and (analysis_cond h (analysis_def h))\n (forall (h' : hedge) (_ : analysis_cond h h'),\n inclusion (analysis_def h) h')
H : and (no_pairs h)\n (and (no_syn_ops h) (and (no_syn_cyph h) (cyph_dec h)))
h : hedge
*****
synthesis h M N
+++++
unfold cyph_dec in H.
-----
Lemma cond_irr_impl_le_h_ana : forall h : hedge, cond_irr h -> le_h (analysis_def h) h.
unfold cond_irr in |- *.
intros.
apply incl_syn_impl_le_h.
generalize (analysis_is_analysis h).
unfold is_analysis in |- *.
intro.
elim H0.
unfold analysis_cond in |- *.
intros.
apply H2.
split.
unfold stable_analysis in |- *.
unfold inclusion in |- *.
intros.
induction H3 as [M N H3| M1 M2 N1 N2 H3 HrecH3| M1 M2 N1 N2 H3 HrecH3| M N K L H3 HrecH3 H4].
trivial.
generalize (synthesis_idempotent h).
unfold equal in |- *.
intros.
elim H5.
intros.
unfold inclusion in H7.
generalize (H7 (inv K) (inv L) H4).
intro.
unfold cyph_dec in H.

*****
H8 : synthesis h (inv K) (inv L)
H7 : forall (M N : Msg) (_ : synthesis (synthesis h) M N), synthesis h M N
H6 : inclusion (synthesis h) (synthesis (synthesis h))
H5 : and (inclusion (synthesis h) (synthesis (synthesis h)))\n (inclusion (synthesis (synthesis h)) (synthesis h))
HrecH3 : synthesis h (MEnc M K) (MEnc N L)
H4 : synthesis (synthesis h) (inv K) (inv L)
H3 : analysis (synthesis h) (MEnc M K) (MEnc N L)
M,N,K,L : Msg
H2 : forall (h' : hedge) (_ : and (inclusion h h') (stable_analysis h')),\ninclusion (analysis_def h) h'
H1 : and (inclusion h (analysis_def h)) (stable_analysis (analysis_def h))
H0 : and (analysis_cond h (analysis_def h))\n (forall (h' : hedge) (_ : analysis_cond h h'),\n inclusion (analysis_def h) h')
H : and (no_pairs h)\n (and (no_syn_ops h)\n (and (no_syn_cyph h)\n (forall (M N K L : Msg) (_ : h (MEnc M K) (MEnc N L))\n (_ : synthesis h (inv K) (inv L)), synthesis h M N)))
h : hedge
*****
synthesis h M N
+++++
elim H.
-----
Lemma cond_irr_impl_le_h_ana : forall h : hedge, cond_irr h -> le_h (analysis_def h) h.
unfold cond_irr in |- *.
intros.
apply incl_syn_impl_le_h.
generalize (analysis_is_analysis h).
unfold is_analysis in |- *.
intro.
elim H0.
unfold analysis_cond in |- *.
intros.
apply H2.
split.
unfold stable_analysis in |- *.
unfold inclusion in |- *.
intros.
induction H3 as [M N H3| M1 M2 N1 N2 H3 HrecH3| M1 M2 N1 N2 H3 HrecH3| M N K L H3 HrecH3 H4].
trivial.
generalize (synthesis_idempotent h).
unfold equal in |- *.
intros.
elim H5.
intros.
unfold inclusion in H7.
generalize (H7 (inv K) (inv L) H4).
intro.
unfold cyph_dec in H.
elim H.

*****
H8 : synthesis h (inv K) (inv L)
H7 : forall (M N : Msg) (_ : synthesis (synthesis h) M N), synthesis h M N
H6 : inclusion (synthesis h) (synthesis (synthesis h))
H5 : and (inclusion (synthesis h) (synthesis (synthesis h)))\n (inclusion (synthesis (synthesis h)) (synthesis h))
HrecH3 : synthesis h (MEnc M K) (MEnc N L)
H4 : synthesis (synthesis h) (inv K) (inv L)
H3 : analysis (synthesis h) (MEnc M K) (MEnc N L)
M,N,K,L : Msg
H2 : forall (h' : hedge) (_ : and (inclusion h h') (stable_analysis h')),\ninclusion (analysis_def h) h'
H1 : and (inclusion h (analysis_def h)) (stable_analysis (analysis_def h))
H0 : and (analysis_cond h (analysis_def h))\n (forall (h' : hedge) (_ : analysis_cond h h'),\n inclusion (analysis_def h) h')
H : and (no_pairs h)\n (and (no_syn_ops h)\n (and (no_syn_cyph h)\n (forall (M N K L : Msg) (_ : h (MEnc M K) (MEnc N L))\n (_ : synthesis h (inv K) (inv L)), synthesis h M N)))
h : hedge
*****
forall (_ : no_pairs h) (_ : and (no_syn_ops h) (and (no_syn_cyph h) (forall (M N K L : Msg) (_ : h (MEnc M K) (MEnc N L)) (_ : synthesis h (inv K) (inv L)), synthesis h M N))), synthesis h M N
+++++
intros.
-----
Lemma cond_irr_impl_le_h_ana : forall h : hedge, cond_irr h -> le_h (analysis_def h) h.
unfold cond_irr in |- *.
intros.
apply incl_syn_impl_le_h.
generalize (analysis_is_analysis h).
unfold is_analysis in |- *.
intro.
elim H0.
unfold analysis_cond in |- *.
intros.
apply H2.
split.
unfold stable_analysis in |- *.
unfold inclusion in |- *.
intros.
induction H3 as [M N H3| M1 M2 N1 N2 H3 HrecH3| M1 M2 N1 N2 H3 HrecH3| M N K L H3 HrecH3 H4].
trivial.
generalize (synthesis_idempotent h).
unfold equal in |- *.
intros.
elim H5.
intros.
unfold inclusion in H7.
generalize (H7 (inv K) (inv L) H4).
intro.
unfold cyph_dec in H.
elim H.
intros.

*****
H10 : and (no_syn_ops h)\n (and (no_syn_cyph h)\n (forall (M N K L : Msg) (_ : h (MEnc M K) (MEnc N L))\n (_ : synthesis h (inv K) (inv L)), synthesis h M N))
H9 : no_pairs h
H8 : synthesis h (inv K) (inv L)
H7 : forall (M N : Msg) (_ : synthesis (synthesis h) M N), synthesis h M N
H6 : inclusion (synthesis h) (synthesis (synthesis h))
H5 : and (inclusion (synthesis h) (synthesis (synthesis h)))\n (inclusion (synthesis (synthesis h)) (synthesis h))
HrecH3 : synthesis h (MEnc M K) (MEnc N L)
H4 : synthesis (synthesis h) (inv K) (inv L)
H3 : analysis (synthesis h) (MEnc M K) (MEnc N L)
M,N,K,L : Msg
H2 : forall (h' : hedge) (_ : and (inclusion h h') (stable_analysis h')),\ninclusion (analysis_def h) h'
H1 : and (inclusion h (analysis_def h)) (stable_analysis (analysis_def h))
H0 : and (analysis_cond h (analysis_def h))\n (forall (h' : hedge) (_ : analysis_cond h h'),\n inclusion (analysis_def h) h')
H : and (no_pairs h)\n (and (no_syn_ops h)\n (and (no_syn_cyph h)\n (forall (M N K L : Msg) (_ : h (MEnc M K) (MEnc N L))\n (_ : synthesis h (inv K) (inv L)), synthesis h M N)))
h : hedge
*****
synthesis h M N
+++++
elim H10.
-----
Lemma cond_irr_impl_le_h_ana : forall h : hedge, cond_irr h -> le_h (analysis_def h) h.
unfold cond_irr in |- *.
intros.
apply incl_syn_impl_le_h.
generalize (analysis_is_analysis h).
unfold is_analysis in |- *.
intro.
elim H0.
unfold analysis_cond in |- *.
intros.
apply H2.
split.
unfold stable_analysis in |- *.
unfold inclusion in |- *.
intros.
induction H3 as [M N H3| M1 M2 N1 N2 H3 HrecH3| M1 M2 N1 N2 H3 HrecH3| M N K L H3 HrecH3 H4].
trivial.
generalize (synthesis_idempotent h).
unfold equal in |- *.
intros.
elim H5.
intros.
unfold inclusion in H7.
generalize (H7 (inv K) (inv L) H4).
intro.
unfold cyph_dec in H.
elim H.
intros.
elim H10.

*****
H10 : and (no_syn_ops h)\n (and (no_syn_cyph h)\n (forall (M N K L : Msg) (_ : h (MEnc M K) (MEnc N L))\n (_ : synthesis h (inv K) (inv L)), synthesis h M N))
H9 : no_pairs h
H8 : synthesis h (inv K) (inv L)
H7 : forall (M N : Msg) (_ : synthesis (synthesis h) M N), synthesis h M N
H6 : inclusion (synthesis h) (synthesis (synthesis h))
H5 : and (inclusion (synthesis h) (synthesis (synthesis h)))\n (inclusion (synthesis (synthesis h)) (synthesis h))
HrecH3 : synthesis h (MEnc M K) (MEnc N L)
H4 : synthesis (synthesis h) (inv K) (inv L)
H3 : analysis (synthesis h) (MEnc M K) (MEnc N L)
M,N,K,L : Msg
H2 : forall (h' : hedge) (_ : and (inclusion h h') (stable_analysis h')),\ninclusion (analysis_def h) h'
H1 : and (inclusion h (analysis_def h)) (stable_analysis (analysis_def h))
H0 : and (analysis_cond h (analysis_def h))\n (forall (h' : hedge) (_ : analysis_cond h h'),\n inclusion (analysis_def h) h')
H : and (no_pairs h)\n (and (no_syn_ops h)\n (and (no_syn_cyph h)\n (forall (M N K L : Msg) (_ : h (MEnc M K) (MEnc N L))\n (_ : synthesis h (inv K) (inv L)), synthesis h M N)))
h : hedge
*****
forall (_ : no_syn_ops h) (_ : and (no_syn_cyph h) (forall (M N K L : Msg) (_ : h (MEnc M K) (MEnc N L)) (_ : synthesis h (inv K) (inv L)), synthesis h M N)), synthesis h M N
+++++
intros.
-----
Lemma cond_irr_impl_le_h_ana : forall h : hedge, cond_irr h -> le_h (analysis_def h) h.
unfold cond_irr in |- *.
intros.
apply incl_syn_impl_le_h.
generalize (analysis_is_analysis h).
unfold is_analysis in |- *.
intro.
elim H0.
unfold analysis_cond in |- *.
intros.
apply H2.
split.
unfold stable_analysis in |- *.
unfold inclusion in |- *.
intros.
induction H3 as [M N H3| M1 M2 N1 N2 H3 HrecH3| M1 M2 N1 N2 H3 HrecH3| M N K L H3 HrecH3 H4].
trivial.
generalize (synthesis_idempotent h).
unfold equal in |- *.
intros.
elim H5.
intros.
unfold inclusion in H7.
generalize (H7 (inv K) (inv L) H4).
intro.
unfold cyph_dec in H.
elim H.
intros.
elim H10.
intros.

*****
H12 : and (no_syn_cyph h)\n (forall (M N K L : Msg) (_ : h (MEnc M K) (MEnc N L))\n (_ : synthesis h (inv K) (inv L)), synthesis h M N)
H11 : no_syn_ops h
H10 : and (no_syn_ops h)\n (and (no_syn_cyph h)\n (forall (M N K L : Msg) (_ : h (MEnc M K) (MEnc N L))\n (_ : synthesis h (inv K) (inv L)), synthesis h M N))
H9 : no_pairs h
H8 : synthesis h (inv K) (inv L)
H7 : forall (M N : Msg) (_ : synthesis (synthesis h) M N), synthesis h M N
H6 : inclusion (synthesis h) (synthesis (synthesis h))
H5 : and (inclusion (synthesis h) (synthesis (synthesis h)))\n (inclusion (synthesis (synthesis h)) (synthesis h))
HrecH3 : synthesis h (MEnc M K) (MEnc N L)
H4 : synthesis (synthesis h) (inv K) (inv L)
H3 : analysis (synthesis h) (MEnc M K) (MEnc N L)
M,N,K,L : Msg
H2 : forall (h' : hedge) (_ : and (inclusion h h') (stable_analysis h')),\ninclusion (analysis_def h) h'
H1 : and (inclusion h (analysis_def h)) (stable_analysis (analysis_def h))
H0 : and (analysis_cond h (analysis_def h))\n (forall (h' : hedge) (_ : analysis_cond h h'),\n inclusion (analysis_def h) h')
H : and (no_pairs h)\n (and (no_syn_ops h)\n (and (no_syn_cyph h)\n (forall (M N K L : Msg) (_ : h (MEnc M K) (MEnc N L))\n (_ : synthesis h (inv K) (inv L)), synthesis h M N)))
h : hedge
*****
synthesis h M N
+++++
elim H12.
-----
Lemma cond_irr_impl_le_h_ana : forall h : hedge, cond_irr h -> le_h (analysis_def h) h.
unfold cond_irr in |- *.
intros.
apply incl_syn_impl_le_h.
generalize (analysis_is_analysis h).
unfold is_analysis in |- *.
intro.
elim H0.
unfold analysis_cond in |- *.
intros.
apply H2.
split.
unfold stable_analysis in |- *.
unfold inclusion in |- *.
intros.
induction H3 as [M N H3| M1 M2 N1 N2 H3 HrecH3| M1 M2 N1 N2 H3 HrecH3| M N K L H3 HrecH3 H4].
trivial.
generalize (synthesis_idempotent h).
unfold equal in |- *.
intros.
elim H5.
intros.
unfold inclusion in H7.
generalize (H7 (inv K) (inv L) H4).
intro.
unfold cyph_dec in H.
elim H.
intros.
elim H10.
intros.
elim H12.

*****
H12 : and (no_syn_cyph h)\n (forall (M N K L : Msg) (_ : h (MEnc M K) (MEnc N L))\n (_ : synthesis h (inv K) (inv L)), synthesis h M N)
H11 : no_syn_ops h
H10 : and (no_syn_ops h)\n (and (no_syn_cyph h)\n (forall (M N K L : Msg) (_ : h (MEnc M K) (MEnc N L))\n (_ : synthesis h (inv K) (inv L)), synthesis h M N))
H9 : no_pairs h
H8 : synthesis h (inv K) (inv L)
H7 : forall (M N : Msg) (_ : synthesis (synthesis h) M N), synthesis h M N
H6 : inclusion (synthesis h) (synthesis (synthesis h))
H5 : and (inclusion (synthesis h) (synthesis (synthesis h)))\n (inclusion (synthesis (synthesis h)) (synthesis h))
HrecH3 : synthesis h (MEnc M K) (MEnc N L)
H4 : synthesis (synthesis h) (inv K) (inv L)
H3 : analysis (synthesis h) (MEnc M K) (MEnc N L)
M,N,K,L : Msg
H2 : forall (h' : hedge) (_ : and (inclusion h h') (stable_analysis h')),\ninclusion (analysis_def h) h'
H1 : and (inclusion h (analysis_def h)) (stable_analysis (analysis_def h))
H0 : and (analysis_cond h (analysis_def h))\n (forall (h' : hedge) (_ : analysis_cond h h'),\n inclusion (analysis_def h) h')
H : and (no_pairs h)\n (and (no_syn_ops h)\n (and (no_syn_cyph h)\n (forall (M N K L : Msg) (_ : h (MEnc M K) (MEnc N L))\n (_ : synthesis h (inv K) (inv L)), synthesis h M N)))
h : hedge
*****
forall (_ : no_syn_cyph h) (_ : forall (M N K L : Msg) (_ : h (MEnc M K) (MEnc N L)) (_ : synthesis h (inv K) (inv L)), synthesis h M N), synthesis h M N
+++++
intros.
-----
Lemma cond_irr_impl_le_h_ana : forall h : hedge, cond_irr h -> le_h (analysis_def h) h.
unfold cond_irr in |- *.
intros.
apply incl_syn_impl_le_h.
generalize (analysis_is_analysis h).
unfold is_analysis in |- *.
intro.
elim H0.
unfold analysis_cond in |- *.
intros.
apply H2.
split.
unfold stable_analysis in |- *.
unfold inclusion in |- *.
intros.
induction H3 as [M N H3| M1 M2 N1 N2 H3 HrecH3| M1 M2 N1 N2 H3 HrecH3| M N K L H3 HrecH3 H4].
trivial.
generalize (synthesis_idempotent h).
unfold equal in |- *.
intros.
elim H5.
intros.
unfold inclusion in H7.
generalize (H7 (inv K) (inv L) H4).
intro.
unfold cyph_dec in H.
elim H.
intros.
elim H10.
intros.
elim H12.
intros.

*****
H14 : forall (M N K L : Msg) (_ : h (MEnc M K) (MEnc N L))\n (_ : synthesis h (inv K) (inv L)), synthesis h M N
H13 : no_syn_cyph h
H12 : and (no_syn_cyph h)\n (forall (M N K L : Msg) (_ : h (MEnc M K) (MEnc N L))\n (_ : synthesis h (inv K) (inv L)), synthesis h M N)
H11 : no_syn_ops h
H10 : and (no_syn_ops h)\n (and (no_syn_cyph h)\n (forall (M N K L : Msg) (_ : h (MEnc M K) (MEnc N L))\n (_ : synthesis h (inv K) (inv L)), synthesis h M N))
H9 : no_pairs h
H8 : synthesis h (inv K) (inv L)
H7 : forall (M N : Msg) (_ : synthesis (synthesis h) M N), synthesis h M N
H6 : inclusion (synthesis h) (synthesis (synthesis h))
H5 : and (inclusion (synthesis h) (synthesis (synthesis h)))\n (inclusion (synthesis (synthesis h)) (synthesis h))
HrecH3 : synthesis h (MEnc M K) (MEnc N L)
H4 : synthesis (synthesis h) (inv K) (inv L)
H3 : analysis (synthesis h) (MEnc M K) (MEnc N L)
M,N,K,L : Msg
H2 : forall (h' : hedge) (_ : and (inclusion h h') (stable_analysis h')),\ninclusion (analysis_def h) h'
H1 : and (inclusion h (analysis_def h)) (stable_analysis (analysis_def h))
H0 : and (analysis_cond h (analysis_def h))\n (forall (h' : hedge) (_ : analysis_cond h h'),\n inclusion (analysis_def h) h')
H : and (no_pairs h)\n (and (no_syn_ops h)\n (and (no_syn_cyph h)\n (forall (M N K L : Msg) (_ : h (MEnc M K) (MEnc N L))\n (_ : synthesis h (inv K) (inv L)), synthesis h M N)))
h : hedge
*****
synthesis h M N
+++++
inversion HrecH3.
-----
Lemma cond_irr_impl_le_h_ana : forall h : hedge, cond_irr h -> le_h (analysis_def h) h.
unfold cond_irr in |- *.
intros.
apply incl_syn_impl_le_h.
generalize (analysis_is_analysis h).
unfold is_analysis in |- *.
intro.
elim H0.
unfold analysis_cond in |- *.
intros.
apply H2.
split.
unfold stable_analysis in |- *.
unfold inclusion in |- *.
intros.
induction H3 as [M N H3| M1 M2 N1 N2 H3 HrecH3| M1 M2 N1 N2 H3 HrecH3| M N K L H3 HrecH3 H4].
trivial.
generalize (synthesis_idempotent h).
unfold equal in |- *.
intros.
elim H5.
intros.
unfold inclusion in H7.
generalize (H7 (inv K) (inv L) H4).
intro.
unfold cyph_dec in H.
elim H.
intros.
elim H10.
intros.
elim H12.
intros.
inversion HrecH3.

*****
H17 : eq N0 (MEnc N L)
H16 : eq M0 (MEnc M K)
H15 : h (MEnc M K) (MEnc N L)
M0,N0 : Msg
H14 : forall (M N K L : Msg) (_ : h (MEnc M K) (MEnc N L))\n (_ : synthesis h (inv K) (inv L)), synthesis h M N
H13 : no_syn_cyph h
H12 : and (no_syn_cyph h)\n (forall (M N K L : Msg) (_ : h (MEnc M K) (MEnc N L))\n (_ : synthesis h (inv K) (inv L)), synthesis h M N)
H11 : no_syn_ops h
H10 : and (no_syn_ops h)\n (and (no_syn_cyph h)\n (forall (M N K L : Msg) (_ : h (MEnc M K) (MEnc N L))\n (_ : synthesis h (inv K) (inv L)), synthesis h M N))
H9 : no_pairs h
H8 : synthesis h (inv K) (inv L)
H7 : forall (M N : Msg) (_ : synthesis (synthesis h) M N), synthesis h M N
H6 : inclusion (synthesis h) (synthesis (synthesis h))
H5 : and (inclusion (synthesis h) (synthesis (synthesis h)))\n (inclusion (synthesis (synthesis h)) (synthesis h))
HrecH3 : synthesis h (MEnc M K) (MEnc N L)
H4 : synthesis (synthesis h) (inv K) (inv L)
H3 : analysis (synthesis h) (MEnc M K) (MEnc N L)
M,N,K,L : Msg
H2 : forall (h' : hedge) (_ : and (inclusion h h') (stable_analysis h')),\ninclusion (analysis_def h) h'
H1 : and (inclusion h (analysis_def h)) (stable_analysis (analysis_def h))
H0 : and (analysis_cond h (analysis_def h))\n (forall (h' : hedge) (_ : analysis_cond h h'),\n inclusion (analysis_def h) h')
H : and (no_pairs h)\n (and (no_syn_ops h)\n (and (no_syn_cyph h)\n (forall (M N K L : Msg) (_ : h (MEnc M K) (MEnc N L))\n (_ : synthesis h (inv K) (inv L)), synthesis h M N)))
h : hedge
*****
synthesis h M N
+++++
trivial.
-----
Lemma cond_irr_impl_le_h_ana : forall h : hedge, cond_irr h -> le_h (analysis_def h) h.
unfold cond_irr in |- *.
intros.
apply incl_syn_impl_le_h.
generalize (analysis_is_analysis h).
unfold is_analysis in |- *.
intro.
elim H0.
unfold analysis_cond in |- *.
intros.
apply H2.
split.
unfold stable_analysis in |- *.
unfold inclusion in |- *.
intros.
induction H3 as [M N H3| M1 M2 N1 N2 H3 HrecH3| M1 M2 N1 N2 H3 HrecH3| M N K L H3 HrecH3 H4].
trivial.
generalize (synthesis_idempotent h).
unfold equal in |- *.
intros.
elim H5.
intros.
unfold inclusion in H7.
generalize (H7 (inv K) (inv L) H4).
intro.
unfold cyph_dec in H.
elim H.
intros.
elim H10.
intros.
elim H12.
intros.
inversion HrecH3.
trivial.

*****
H17 : eq N0 (MEnc N L)
H16 : eq M0 (MEnc M K)
H15 : h (MEnc M K) (MEnc N L)
M0,N0 : Msg
H14 : forall (M N K L : Msg) (_ : h (MEnc M K) (MEnc N L))\n (_ : synthesis h (inv K) (inv L)), synthesis h M N
H13 : no_syn_cyph h
H12 : and (no_syn_cyph h)\n (forall (M N K L : Msg) (_ : h (MEnc M K) (MEnc N L))\n (_ : synthesis h (inv K) (inv L)), synthesis h M N)
H11 : no_syn_ops h
H10 : and (no_syn_ops h)\n (and (no_syn_cyph h)\n (forall (M N K L : Msg) (_ : h (MEnc M K) (MEnc N L))\n (_ : synthesis h (inv K) (inv L)), synthesis h M N))
H9 : no_pairs h
H8 : synthesis h (inv K) (inv L)
H7 : forall (M N : Msg) (_ : synthesis (synthesis h) M N), synthesis h M N
H6 : inclusion (synthesis h) (synthesis (synthesis h))
H5 : and (inclusion (synthesis h) (synthesis (synthesis h)))\n (inclusion (synthesis (synthesis h)) (synthesis h))
HrecH3 : synthesis h (MEnc M K) (MEnc N L)
H4 : synthesis (synthesis h) (inv K) (inv L)
H3 : analysis (synthesis h) (MEnc M K) (MEnc N L)
M,N,K,L : Msg
H2 : forall (h' : hedge) (_ : and (inclusion h h') (stable_analysis h')),\ninclusion (analysis_def h) h'
H1 : and (inclusion h (analysis_def h)) (stable_analysis (analysis_def h))
H0 : and (analysis_cond h (analysis_def h))\n (forall (h' : hedge) (_ : analysis_cond h h'),\n inclusion (analysis_def h) h')
H : and (no_pairs h)\n (and (no_syn_ops h)\n (and (no_syn_cyph h)\n (forall (M N K L : Msg) (_ : h (MEnc M K) (MEnc N L))\n (_ : synthesis h (inv K) (inv L)), synthesis h M N)))
h : hedge
*****
synthesis h M N
+++++
apply (H14 M N K L).
-----
Lemma cond_irr_impl_le_h_ana : forall h : hedge, cond_irr h -> le_h (analysis_def h) h.
unfold cond_irr in |- *.
intros.
apply incl_syn_impl_le_h.
generalize (analysis_is_analysis h).
unfold is_analysis in |- *.
intro.
elim H0.
unfold analysis_cond in |- *.
intros.
apply H2.
split.
unfold stable_analysis in |- *.
unfold inclusion in |- *.
intros.
induction H3 as [M N H3| M1 M2 N1 N2 H3 HrecH3| M1 M2 N1 N2 H3 HrecH3| M N K L H3 HrecH3 H4].
trivial.
generalize (synthesis_idempotent h).
unfold equal in |- *.
intros.
elim H5.
intros.
unfold inclusion in H7.
generalize (H7 (inv K) (inv L) H4).
intro.
unfold cyph_dec in H.
elim H.
intros.
elim H10.
intros.
elim H12.
intros.
inversion HrecH3.
trivial.
apply (H14 M N K L).

*****
H17 : eq N0 (MEnc N L)
H16 : eq M0 (MEnc M K)
H15 : h (MEnc M K) (MEnc N L)
M0,N0 : Msg
H14 : forall (M N K L : Msg) (_ : h (MEnc M K) (MEnc N L))\n (_ : synthesis h (inv K) (inv L)), synthesis h M N
H13 : no_syn_cyph h
H12 : and (no_syn_cyph h)\n (forall (M N K L : Msg) (_ : h (MEnc M K) (MEnc N L))\n (_ : synthesis h (inv K) (inv L)), synthesis h M N)
H11 : no_syn_ops h
H10 : and (no_syn_ops h)\n (and (no_syn_cyph h)\n (forall (M N K L : Msg) (_ : h (MEnc M K) (MEnc N L))\n (_ : synthesis h (inv K) (inv L)), synthesis h M N))
H9 : no_pairs h
H8 : synthesis h (inv K) (inv L)
H7 : forall (M N : Msg) (_ : synthesis (synthesis h) M N), synthesis h M N
H6 : inclusion (synthesis h) (synthesis (synthesis h))
H5 : and (inclusion (synthesis h) (synthesis (synthesis h)))\n (inclusion (synthesis (synthesis h)) (synthesis h))
HrecH3 : synthesis h (MEnc M K) (MEnc N L)
H4 : synthesis (synthesis h) (inv K) (inv L)
H3 : analysis (synthesis h) (MEnc M K) (MEnc N L)
M,N,K,L : Msg
H2 : forall (h' : hedge) (_ : and (inclusion h h') (stable_analysis h')),\ninclusion (analysis_def h) h'
H1 : and (inclusion h (analysis_def h)) (stable_analysis (analysis_def h))
H0 : and (analysis_cond h (analysis_def h))\n (forall (h' : hedge) (_ : analysis_cond h h'),\n inclusion (analysis_def h) h')
H : and (no_pairs h)\n (and (no_syn_ops h)\n (and (no_syn_cyph h)\n (forall (M N K L : Msg) (_ : h (MEnc M K) (MEnc N L))\n (_ : synthesis h (inv K) (inv L)), synthesis h M N)))
h : hedge
*****
h (MEnc M K) (MEnc N L)
+++++
trivial.
-----
Lemma cond_irr_impl_le_h_ana : forall h : hedge, cond_irr h -> le_h (analysis_def h) h.
unfold cond_irr in |- *.
intros.
apply incl_syn_impl_le_h.
generalize (analysis_is_analysis h).
unfold is_analysis in |- *.
intro.
elim H0.
unfold analysis_cond in |- *.
intros.
apply H2.
split.
unfold stable_analysis in |- *.
unfold inclusion in |- *.
intros.
induction H3 as [M N H3| M1 M2 N1 N2 H3 HrecH3| M1 M2 N1 N2 H3 HrecH3| M N K L H3 HrecH3 H4].
trivial.
generalize (synthesis_idempotent h).
unfold equal in |- *.
intros.
elim H5.
intros.
unfold inclusion in H7.
generalize (H7 (inv K) (inv L) H4).
intro.
unfold cyph_dec in H.
elim H.
intros.
elim H10.
intros.
elim H12.
intros.
inversion HrecH3.
trivial.
apply (H14 M N K L).

*****
H17 : eq N0 (MEnc N L)
H16 : eq M0 (MEnc M K)
H15 : h (MEnc M K) (MEnc N L)
M0,N0 : Msg
H14 : forall (M N K L : Msg) (_ : h (MEnc M K) (MEnc N L))\n (_ : synthesis h (inv K) (inv L)), synthesis h M N
H13 : no_syn_cyph h
H12 : and (no_syn_cyph h)\n (forall (M N K L : Msg) (_ : h (MEnc M K) (MEnc N L))\n (_ : synthesis h (inv K) (inv L)), synthesis h M N)
H11 : no_syn_ops h
H10 : and (no_syn_ops h)\n (and (no_syn_cyph h)\n (forall (M N K L : Msg) (_ : h (MEnc M K) (MEnc N L))\n (_ : synthesis h (inv K) (inv L)), synthesis h M N))
H9 : no_pairs h
H8 : synthesis h (inv K) (inv L)
H7 : forall (M N : Msg) (_ : synthesis (synthesis h) M N), synthesis h M N
H6 : inclusion (synthesis h) (synthesis (synthesis h))
H5 : and (inclusion (synthesis h) (synthesis (synthesis h)))\n (inclusion (synthesis (synthesis h)) (synthesis h))
HrecH3 : synthesis h (MEnc M K) (MEnc N L)
H4 : synthesis (synthesis h) (inv K) (inv L)
H3 : analysis (synthesis h) (MEnc M K) (MEnc N L)
M,N,K,L : Msg
H2 : forall (h' : hedge) (_ : and (inclusion h h') (stable_analysis h')),\ninclusion (analysis_def h) h'
H1 : and (inclusion h (analysis_def h)) (stable_analysis (analysis_def h))
H0 : and (analysis_cond h (analysis_def h))\n (forall (h' : hedge) (_ : analysis_cond h h'),\n inclusion (analysis_def h) h')
H : and (no_pairs h)\n (and (no_syn_ops h)\n (and (no_syn_cyph h)\n (forall (M N K L : Msg) (_ : h (MEnc M K) (MEnc N L))\n (_ : synthesis h (inv K) (inv L)), synthesis h M N)))
h : hedge
*****
synthesis h (inv K) (inv L)
+++++
trivial.
-----
Lemma cond_irr_impl_le_h_ana : forall h : hedge, cond_irr h -> le_h (analysis_def h) h.
unfold cond_irr in |- *.
intros.
apply incl_syn_impl_le_h.
generalize (analysis_is_analysis h).
unfold is_analysis in |- *.
intro.
elim H0.
unfold analysis_cond in |- *.
intros.
apply H2.
split.
unfold stable_analysis in |- *.
unfold inclusion in |- *.
intros.
induction H3 as [M N H3| M1 M2 N1 N2 H3 HrecH3| M1 M2 N1 N2 H3 HrecH3| M N K L H3 HrecH3 H4].
trivial.
generalize (synthesis_idempotent h).
unfold equal in |- *.
intros.
elim H5.
intros.
unfold inclusion in H7.
generalize (H7 (inv K) (inv L) H4).
intro.
unfold cyph_dec in H.
elim H.
intros.
elim H10.
intros.
elim H12.
intros.
inversion HrecH3.

*****
H19 : eq L0 L
H17 : eq N0 N
H16 : eq K0 K
H15 : eq M0 M
H20 : synthesis h K L
H18 : synthesis h M N
M0,N0,K0,L0 : Msg
H14 : forall (M N K L : Msg) (_ : h (MEnc M K) (MEnc N L))\n (_ : synthesis h (inv K) (inv L)), synthesis h M N
H13 : no_syn_cyph h
H12 : and (no_syn_cyph h)\n (forall (M N K L : Msg) (_ : h (MEnc M K) (MEnc N L))\n (_ : synthesis h (inv K) (inv L)), synthesis h M N)
H11 : no_syn_ops h
H10 : and (no_syn_ops h)\n (and (no_syn_cyph h)\n (forall (M N K L : Msg) (_ : h (MEnc M K) (MEnc N L))\n (_ : synthesis h (inv K) (inv L)), synthesis h M N))
H9 : no_pairs h
H8 : synthesis h (inv K) (inv L)
H7 : forall (M N : Msg) (_ : synthesis (synthesis h) M N), synthesis h M N
H6 : inclusion (synthesis h) (synthesis (synthesis h))
H5 : and (inclusion (synthesis h) (synthesis (synthesis h)))\n (inclusion (synthesis (synthesis h)) (synthesis h))
HrecH3 : synthesis h (MEnc M K) (MEnc N L)
H4 : synthesis (synthesis h) (inv K) (inv L)
H3 : analysis (synthesis h) (MEnc M K) (MEnc N L)
M,N,K,L : Msg
H2 : forall (h' : hedge) (_ : and (inclusion h h') (stable_analysis h')),\ninclusion (analysis_def h) h'
H1 : and (inclusion h (analysis_def h)) (stable_analysis (analysis_def h))
H0 : and (analysis_cond h (analysis_def h))\n (forall (h' : hedge) (_ : analysis_cond h h'),\n inclusion (analysis_def h) h')
H : and (no_pairs h)\n (and (no_syn_ops h)\n (and (no_syn_cyph h)\n (forall (M N K L : Msg) (_ : h (MEnc M K) (MEnc N L))\n (_ : synthesis h (inv K) (inv L)), synthesis h M N)))
h : hedge
*****
synthesis h M N
+++++
trivial.
-----
Lemma cond_irr_impl_le_h_ana : forall h : hedge, cond_irr h -> le_h (analysis_def h) h.
unfold cond_irr in |- *.
intros.
apply incl_syn_impl_le_h.
generalize (analysis_is_analysis h).
unfold is_analysis in |- *.
intro.
elim H0.
unfold analysis_cond in |- *.
intros.
apply H2.
split.

*****

*****

+++++
Qed.
-----
Lemma cond_irr_impl_equiv_h_irr :\n forall h : hedge, cond_irr h -> equiv_h h (irreducible h).
-----
Lemma cond_irr_impl_equiv_h_irr : forall h : hedge, cond_irr h -> equiv_h h (irreducible h).

*****

*****
forall (h : hedge) (_ : cond_irr h), equiv_h h (irreducible h)
+++++
intros.
-----
Lemma cond_irr_impl_equiv_h_irr : forall h : hedge, cond_irr h -> equiv_h h (irreducible h).
intros.

*****
H : cond_irr h
h : hedge
*****
equiv_h h (irreducible h)
+++++
apply equiv_h_trans with (analysis_def h).
-----
Lemma cond_irr_impl_equiv_h_irr : forall h : hedge, cond_irr h -> equiv_h h (irreducible h).
intros.
apply equiv_h_trans with (analysis_def h).

*****
H : cond_irr h
h : hedge
*****
equiv_h h (analysis_def h)
+++++
unfold equiv_h in |- *.
-----
Lemma cond_irr_impl_equiv_h_irr : forall h : hedge, cond_irr h -> equiv_h h (irreducible h).
intros.
apply equiv_h_trans with (analysis_def h).
unfold equiv_h in |- *.

*****
H : cond_irr h
h : hedge
*****
and (le_h h (analysis_def h)) (le_h (analysis_def h) h)
+++++
split.
-----
Lemma cond_irr_impl_equiv_h_irr : forall h : hedge, cond_irr h -> equiv_h h (irreducible h).
intros.
apply equiv_h_trans with (analysis_def h).
unfold equiv_h in |- *.
split.

*****
H : cond_irr h
h : hedge
*****
le_h h (analysis_def h)
+++++
apply h_le_h_ana_h.
-----
Lemma cond_irr_impl_equiv_h_irr : forall h : hedge, cond_irr h -> equiv_h h (irreducible h).
intros.
apply equiv_h_trans with (analysis_def h).
unfold equiv_h in |- *.
split.

*****
H : cond_irr h
h : hedge
*****
le_h (analysis_def h) h
+++++
apply cond_irr_impl_le_h_ana.
-----
Lemma cond_irr_impl_equiv_h_irr : forall h : hedge, cond_irr h -> equiv_h h (irreducible h).
intros.
apply equiv_h_trans with (analysis_def h).
unfold equiv_h in |- *.
split.
apply cond_irr_impl_le_h_ana.

*****
H : cond_irr h
h : hedge
*****
cond_irr h
+++++
trivial.
-----
Lemma cond_irr_impl_equiv_h_irr : forall h : hedge, cond_irr h -> equiv_h h (irreducible h).
intros.
apply equiv_h_trans with (analysis_def h).

*****
H : cond_irr h
h : hedge
*****
equiv_h (analysis_def h) (irreducible h)
+++++
apply ana_h_equiv_irr_h.
-----
Lemma cond_irr_impl_equiv_h_irr : forall h : hedge, cond_irr h -> equiv_h h (irreducible h).
intros.
apply equiv_h_trans with (analysis_def h).

*****

*****

+++++
Qed.
-----
Lemma cond_irr_impl_irr_incl_h :\n forall h : hedge, cond_irr h -> inclusion (irreducible h) h.
-----
Lemma cond_irr_impl_irr_incl_h : forall h : hedge, cond_irr h -> inclusion (irreducible h) h.

*****

*****
forall (h : hedge) (_ : cond_irr h), inclusion (irreducible h) h
+++++
intros.
-----
Lemma cond_irr_impl_irr_incl_h : forall h : hedge, cond_irr h -> inclusion (irreducible h) h.
intros.

*****
H : cond_irr h
h : hedge
*****
inclusion (irreducible h) h
+++++
apply equiv_irr_impl_incl.
-----
Lemma cond_irr_impl_irr_incl_h : forall h : hedge, cond_irr h -> inclusion (irreducible h) h.
intros.
apply equiv_irr_impl_incl.

*****
H : cond_irr h
h : hedge
*****
equiv_h (irreducible h) h
+++++
apply equiv_h_sym.
-----
Lemma cond_irr_impl_irr_incl_h : forall h : hedge, cond_irr h -> inclusion (irreducible h) h.
intros.
apply equiv_irr_impl_incl.
apply equiv_h_sym.

*****
H : cond_irr h
h : hedge
*****
equiv_h h (irreducible h)
+++++
apply cond_irr_impl_equiv_h_irr.
-----
Lemma cond_irr_impl_irr_incl_h : forall h : hedge, cond_irr h -> inclusion (irreducible h) h.
intros.
apply equiv_irr_impl_incl.
apply equiv_h_sym.
apply cond_irr_impl_equiv_h_irr.

*****
H : cond_irr h
h : hedge
*****
cond_irr h
+++++
trivial.
-----
Lemma cond_irr_impl_irr_incl_h : forall h : hedge, cond_irr h -> inclusion (irreducible h) h.
intros.
apply equiv_irr_impl_incl.

*****
H : cond_irr h
h : hedge
*****
is_irreducible (irreducible h)
+++++
apply irreducible_is_irreducible.
-----
Lemma cond_irr_impl_irr_incl_h : forall h : hedge, cond_irr h -> inclusion (irreducible h) h.
intros.
apply equiv_irr_impl_incl.

*****

*****

+++++
Qed.
-----
Lemma cond_irr_impl_stable_reduce :\n forall h : hedge, cond_irr h -> equal h (reduce h).
-----
Lemma cond_irr_impl_stable_reduce : forall h : hedge, cond_irr h -> equal h (reduce h).

*****

*****
forall (h : hedge) (_ : cond_irr h), equal h (reduce h)
+++++
intros.
-----
Lemma cond_irr_impl_stable_reduce : forall h : hedge, cond_irr h -> equal h (reduce h).
intros.

*****
H : cond_irr h
h : hedge
*****
equal h (reduce h)
+++++
unfold equal in |- *.
-----
Lemma cond_irr_impl_stable_reduce : forall h : hedge, cond_irr h -> equal h (reduce h).
intros.
unfold equal in |- *.

*****
H : cond_irr h
h : hedge
*****
and (inclusion h (reduce h)) (inclusion (reduce h) h)
+++++
split.
-----
Lemma cond_irr_impl_stable_reduce : forall h : hedge, cond_irr h -> equal h (reduce h).
intros.
unfold equal in |- *.
split.

*****
H : cond_irr h
h : hedge
*****
inclusion h (reduce h)
+++++
try apply red_incl_h.
-----
Lemma cond_irr_impl_stable_reduce : forall h : hedge, cond_irr h -> equal h (reduce h).
intros.
unfold equal in |- *.
split.
try apply red_incl_h.

*****
H : cond_irr h
h : hedge
*****
inclusion h (reduce h)
+++++
unfold inclusion in |- *.
-----
Lemma cond_irr_impl_stable_reduce : forall h : hedge, cond_irr h -> equal h (reduce h).
intros.
unfold equal in |- *.
split.
try apply red_incl_h.
unfold inclusion in |- *.

*****
H : cond_irr h
h : hedge
*****
forall (M N : Msg) (_ : h M N), reduce h M N
+++++
intros M N.
-----
Lemma cond_irr_impl_stable_reduce : forall h : hedge, cond_irr h -> equal h (reduce h).
intros.
unfold equal in |- *.
split.
try apply red_incl_h.
unfold inclusion in |- *.
intros M N.

*****
M,N : Msg
H : cond_irr h
h : hedge
*****
forall _ : h M N, reduce h M N
+++++
unfold reduce in |- *.
-----
Lemma cond_irr_impl_stable_reduce : forall h : hedge, cond_irr h -> equal h (reduce h).
intros.
unfold equal in |- *.
split.
try apply red_incl_h.
unfold inclusion in |- *.
intros M N.
unfold reduce in |- *.

*****
M,N : Msg
H : cond_irr h
h : hedge
*****
forall _ : h M N, and (h M N) match M with | MNam _ => True | MEnc M' K => match N with | MEnc N' L => or (not (synthesis h M' N')) (not (synthesis h K L)) | _ => True end | MPair M1 M2 => match N with | MPair N1 N2 => or (not (synthesis h M1 N1)) (not (synthesis h M2 N2)) | _ => True end | Mop opM M' => match N with | Mop opN N' => or (not (eq opM opN)) (not (synthesis h M' N')) | _ => True end end
+++++
case M.
-----
Lemma cond_irr_impl_stable_reduce : forall h : hedge, cond_irr h -> equal h (reduce h).
intros.
unfold equal in |- *.
split.
try apply red_incl_h.
unfold inclusion in |- *.
intros M N.
unfold reduce in |- *.
case M.

*****
M,N : Msg
H : cond_irr h
h : hedge
*****
forall (n : Nam) (_ : h (MNam n) N), and (h (MNam n) N) True
+++++
try tauto.
-----
Lemma cond_irr_impl_stable_reduce : forall h : hedge, cond_irr h -> equal h (reduce h).
intros.
unfold equal in |- *.
split.
try apply red_incl_h.
unfold inclusion in |- *.
intros M N.
unfold reduce in |- *.
case M.

*****
M,N : Msg
H : cond_irr h
h : hedge
*****
forall (m m0 : Msg) (_ : h (MEnc m m0) N), and (h (MEnc m m0) N) match N with | MEnc N' L => or (not (synthesis h m N')) (not (synthesis h m0 L)) | _ => True end
+++++
try tauto.
-----
Lemma cond_irr_impl_stable_reduce : forall h : hedge, cond_irr h -> equal h (reduce h).
intros.
unfold equal in |- *.
split.
try apply red_incl_h.
unfold inclusion in |- *.
intros M N.
unfold reduce in |- *.
case M.
try tauto.

*****
M,N : Msg
H : cond_irr h
h : hedge
*****
forall (m m0 : Msg) (_ : h (MEnc m m0) N), and (h (MEnc m m0) N) match N with | MEnc N' L => or (not (synthesis h m N')) (not (synthesis h m0 L)) | _ => True end
+++++
case N.
-----
Lemma cond_irr_impl_stable_reduce : forall h : hedge, cond_irr h -> equal h (reduce h).
intros.
unfold equal in |- *.
split.
try apply red_incl_h.
unfold inclusion in |- *.
intros M N.
unfold reduce in |- *.
case M.
try tauto.
case N.

*****
M,N : Msg
H : cond_irr h
h : hedge
*****
forall (n : Nam) (m m0 : Msg) (_ : h (MEnc m m0) (MNam n)), and (h (MEnc m m0) (MNam n)) True
+++++
try tauto.
-----
Lemma cond_irr_impl_stable_reduce : forall h : hedge, cond_irr h -> equal h (reduce h).
intros.
unfold equal in |- *.
split.
try apply red_incl_h.
unfold inclusion in |- *.
intros M N.
unfold reduce in |- *.
case M.
try tauto.
case N.

*****
M,N : Msg
H : cond_irr h
h : hedge
*****
forall (m m0 m1 m2 : Msg) (_ : h (MEnc m1 m2) (MEnc m m0)), and (h (MEnc m1 m2) (MEnc m m0)) (or (not (synthesis h m1 m)) (not (synthesis h m2 m0)))
+++++
try tauto.
-----
Lemma cond_irr_impl_stable_reduce : forall h : hedge, cond_irr h -> equal h (reduce h).
intros.
unfold equal in |- *.
split.
try apply red_incl_h.
unfold inclusion in |- *.
intros M N.
unfold reduce in |- *.
case M.
try tauto.
case N.
try tauto.

*****
M,N : Msg
H : cond_irr h
h : hedge
*****
forall (m m0 m1 m2 : Msg) (_ : h (MEnc m1 m2) (MEnc m m0)), and (h (MEnc m1 m2) (MEnc m m0)) (or (not (synthesis h m1 m)) (not (synthesis h m2 m0)))
+++++
intros.
-----
Lemma cond_irr_impl_stable_reduce : forall h : hedge, cond_irr h -> equal h (reduce h).
intros.
unfold equal in |- *.
split.
try apply red_incl_h.
unfold inclusion in |- *.
intros M N.
unfold reduce in |- *.
case M.
try tauto.
case N.
try tauto.
intros.

*****
H0 : h (MEnc m1 m2) (MEnc m m0)
M,N,m,m0,m1,m2 : Msg
H : cond_irr h
h : hedge
*****
and (h (MEnc m1 m2) (MEnc m m0)) (or (not (synthesis h m1 m)) (not (synthesis h m2 m0)))
+++++
unfold cond_irr in H.
-----
Lemma cond_irr_impl_stable_reduce : forall h : hedge, cond_irr h -> equal h (reduce h).
intros.
unfold equal in |- *.
split.
try apply red_incl_h.
unfold inclusion in |- *.
intros M N.
unfold reduce in |- *.
case M.
try tauto.
case N.
try tauto.
intros.
unfold cond_irr in H.

*****
H0 : h (MEnc m1 m2) (MEnc m m0)
M,N,m,m0,m1,m2 : Msg
H : and (no_pairs h)\n (and (no_syn_ops h) (and (no_syn_cyph h) (cyph_dec h)))
h : hedge
*****
and (h (MEnc m1 m2) (MEnc m m0)) (or (not (synthesis h m1 m)) (not (synthesis h m2 m0)))
+++++
unfold no_syn_cyph in H.
-----
Lemma cond_irr_impl_stable_reduce : forall h : hedge, cond_irr h -> equal h (reduce h).
intros.
unfold equal in |- *.
split.
try apply red_incl_h.
unfold inclusion in |- *.
intros M N.
unfold reduce in |- *.
case M.
try tauto.
case N.
try tauto.
intros.
unfold cond_irr in H.
unfold no_syn_cyph in H.

*****
H0 : h (MEnc m1 m2) (MEnc m m0)
M,N,m,m0,m1,m2 : Msg
H : and (no_pairs h)\n (and (no_syn_ops h)\n (and\n (forall (M N K L : Msg) (_ : h (MEnc M K) (MEnc N L)),\n or (not (synthesis h M N)) (not (synthesis h K L)))\n (cyph_dec h)))
h : hedge
*****
and (h (MEnc m1 m2) (MEnc m m0)) (or (not (synthesis h m1 m)) (not (synthesis h m2 m0)))
+++++
elim H.
-----
Lemma cond_irr_impl_stable_reduce : forall h : hedge, cond_irr h -> equal h (reduce h).
intros.
unfold equal in |- *.
split.
try apply red_incl_h.
unfold inclusion in |- *.
intros M N.
unfold reduce in |- *.
case M.
try tauto.
case N.
try tauto.
intros.
unfold cond_irr in H.
unfold no_syn_cyph in H.
elim H.

*****
H0 : h (MEnc m1 m2) (MEnc m m0)
M,N,m,m0,m1,m2 : Msg
H : and (no_pairs h)\n (and (no_syn_ops h)\n (and\n (forall (M N K L : Msg) (_ : h (MEnc M K) (MEnc N L)),\n or (not (synthesis h M N)) (not (synthesis h K L)))\n (cyph_dec h)))
h : hedge
*****
forall (_ : no_pairs h) (_ : and (no_syn_ops h) (and (forall (M N K L : Msg) (_ : h (MEnc M K) (MEnc N L)), or (not (synthesis h M N)) (not (synthesis h K L))) (cyph_dec h))), and (h (MEnc m1 m2) (MEnc m m0)) (or (not (synthesis h m1 m)) (not (synthesis h m2 m0)))
+++++
intros.
-----
Lemma cond_irr_impl_stable_reduce : forall h : hedge, cond_irr h -> equal h (reduce h).
intros.
unfold equal in |- *.
split.
try apply red_incl_h.
unfold inclusion in |- *.
intros M N.
unfold reduce in |- *.
case M.
try tauto.
case N.
try tauto.
intros.
unfold cond_irr in H.
unfold no_syn_cyph in H.
elim H.
intros.

*****
H2 : and (no_syn_ops h)\n (and\n (forall (M N K L : Msg) (_ : h (MEnc M K) (MEnc N L)),\n or (not (synthesis h M N)) (not (synthesis h K L))) \n (cyph_dec h))
H1 : no_pairs h
H0 : h (MEnc m1 m2) (MEnc m m0)
M,N,m,m0,m1,m2 : Msg
H : and (no_pairs h)\n (and (no_syn_ops h)\n (and\n (forall (M N K L : Msg) (_ : h (MEnc M K) (MEnc N L)),\n or (not (synthesis h M N)) (not (synthesis h K L)))\n (cyph_dec h)))
h : hedge
*****
and (h (MEnc m1 m2) (MEnc m m0)) (or (not (synthesis h m1 m)) (not (synthesis h m2 m0)))
+++++
elim H2.
-----
Lemma cond_irr_impl_stable_reduce : forall h : hedge, cond_irr h -> equal h (reduce h).
intros.
unfold equal in |- *.
split.
try apply red_incl_h.
unfold inclusion in |- *.
intros M N.
unfold reduce in |- *.
case M.
try tauto.
case N.
try tauto.
intros.
unfold cond_irr in H.
unfold no_syn_cyph in H.
elim H.
intros.
elim H2.

*****
H2 : and (no_syn_ops h)\n (and\n (forall (M N K L : Msg) (_ : h (MEnc M K) (MEnc N L)),\n or (not (synthesis h M N)) (not (synthesis h K L))) \n (cyph_dec h))
H1 : no_pairs h
H0 : h (MEnc m1 m2) (MEnc m m0)
M,N,m,m0,m1,m2 : Msg
H : and (no_pairs h)\n (and (no_syn_ops h)\n (and\n (forall (M N K L : Msg) (_ : h (MEnc M K) (MEnc N L)),\n or (not (synthesis h M N)) (not (synthesis h K L)))\n (cyph_dec h)))
h : hedge
*****
forall (_ : no_syn_ops h) (_ : and (forall (M N K L : Msg) (_ : h (MEnc M K) (MEnc N L)), or (not (synthesis h M N)) (not (synthesis h K L))) (cyph_dec h)), and (h (MEnc m1 m2) (MEnc m m0)) (or (not (synthesis h m1 m)) (not (synthesis h m2 m0)))
+++++
intros.
-----
Lemma cond_irr_impl_stable_reduce : forall h : hedge, cond_irr h -> equal h (reduce h).
intros.
unfold equal in |- *.
split.
try apply red_incl_h.
unfold inclusion in |- *.
intros M N.
unfold reduce in |- *.
case M.
try tauto.
case N.
try tauto.
intros.
unfold cond_irr in H.
unfold no_syn_cyph in H.
elim H.
intros.
elim H2.
intros.

*****
H4 : and\n (forall (M N K L : Msg) (_ : h (MEnc M K) (MEnc N L)),\n or (not (synthesis h M N)) (not (synthesis h K L))) \n (cyph_dec h)
H3 : no_syn_ops h
H2 : and (no_syn_ops h)\n (and\n (forall (M N K L : Msg) (_ : h (MEnc M K) (MEnc N L)),\n or (not (synthesis h M N)) (not (synthesis h K L))) \n (cyph_dec h))
H1 : no_pairs h
H0 : h (MEnc m1 m2) (MEnc m m0)
M,N,m,m0,m1,m2 : Msg
H : and (no_pairs h)\n (and (no_syn_ops h)\n (and\n (forall (M N K L : Msg) (_ : h (MEnc M K) (MEnc N L)),\n or (not (synthesis h M N)) (not (synthesis h K L)))\n (cyph_dec h)))
h : hedge
*****
and (h (MEnc m1 m2) (MEnc m m0)) (or (not (synthesis h m1 m)) (not (synthesis h m2 m0)))
+++++
elim H4.
-----
Lemma cond_irr_impl_stable_reduce : forall h : hedge, cond_irr h -> equal h (reduce h).
intros.
unfold equal in |- *.
split.
try apply red_incl_h.
unfold inclusion in |- *.
intros M N.
unfold reduce in |- *.
case M.
try tauto.
case N.
try tauto.
intros.
unfold cond_irr in H.
unfold no_syn_cyph in H.
elim H.
intros.
elim H2.
intros.
elim H4.

*****
H4 : and\n (forall (M N K L : Msg) (_ : h (MEnc M K) (MEnc N L)),\n or (not (synthesis h M N)) (not (synthesis h K L))) \n (cyph_dec h)
H3 : no_syn_ops h
H2 : and (no_syn_ops h)\n (and\n (forall (M N K L : Msg) (_ : h (MEnc M K) (MEnc N L)),\n or (not (synthesis h M N)) (not (synthesis h K L))) \n (cyph_dec h))
H1 : no_pairs h
H0 : h (MEnc m1 m2) (MEnc m m0)
M,N,m,m0,m1,m2 : Msg
H : and (no_pairs h)\n (and (no_syn_ops h)\n (and\n (forall (M N K L : Msg) (_ : h (MEnc M K) (MEnc N L)),\n or (not (synthesis h M N)) (not (synthesis h K L)))\n (cyph_dec h)))
h : hedge
*****
forall (_ : forall (M N K L : Msg) (_ : h (MEnc M K) (MEnc N L)), or (not (synthesis h M N)) (not (synthesis h K L))) (_ : cyph_dec h), and (h (MEnc m1 m2) (MEnc m m0)) (or (not (synthesis h m1 m)) (not (synthesis h m2 m0)))
+++++
intros.
-----
Lemma cond_irr_impl_stable_reduce : forall h : hedge, cond_irr h -> equal h (reduce h).
intros.
unfold equal in |- *.
split.
try apply red_incl_h.
unfold inclusion in |- *.
intros M N.
unfold reduce in |- *.
case M.
try tauto.
case N.
try tauto.
intros.
unfold cond_irr in H.
unfold no_syn_cyph in H.
elim H.
intros.
elim H2.
intros.
elim H4.
intros.

*****
H6 : cyph_dec h
H5 : forall (M N K L : Msg) (_ : h (MEnc M K) (MEnc N L)),\nor (not (synthesis h M N)) (not (synthesis h K L))
H4 : and\n (forall (M N K L : Msg) (_ : h (MEnc M K) (MEnc N L)),\n or (not (synthesis h M N)) (not (synthesis h K L))) \n (cyph_dec h)
H3 : no_syn_ops h
H2 : and (no_syn_ops h)\n (and\n (forall (M N K L : Msg) (_ : h (MEnc M K) (MEnc N L)),\n or (not (synthesis h M N)) (not (synthesis h K L))) \n (cyph_dec h))
H1 : no_pairs h
H0 : h (MEnc m1 m2) (MEnc m m0)
M,N,m,m0,m1,m2 : Msg
H : and (no_pairs h)\n (and (no_syn_ops h)\n (and\n (forall (M N K L : Msg) (_ : h (MEnc M K) (MEnc N L)),\n or (not (synthesis h M N)) (not (synthesis h K L)))\n (cyph_dec h)))
h : hedge
*****
and (h (MEnc m1 m2) (MEnc m m0)) (or (not (synthesis h m1 m)) (not (synthesis h m2 m0)))
+++++
split.
-----
Lemma cond_irr_impl_stable_reduce : forall h : hedge, cond_irr h -> equal h (reduce h).
intros.
unfold equal in |- *.
split.
try apply red_incl_h.
unfold inclusion in |- *.
intros M N.
unfold reduce in |- *.
case M.
try tauto.
case N.
try tauto.
intros.
unfold cond_irr in H.
unfold no_syn_cyph in H.
elim H.
intros.
elim H2.
intros.
elim H4.
intros.
split.

*****
H6 : cyph_dec h
H5 : forall (M N K L : Msg) (_ : h (MEnc M K) (MEnc N L)),\nor (not (synthesis h M N)) (not (synthesis h K L))
H4 : and\n (forall (M N K L : Msg) (_ : h (MEnc M K) (MEnc N L)),\n or (not (synthesis h M N)) (not (synthesis h K L))) \n (cyph_dec h)
H3 : no_syn_ops h
H2 : and (no_syn_ops h)\n (and\n (forall (M N K L : Msg) (_ : h (MEnc M K) (MEnc N L)),\n or (not (synthesis h M N)) (not (synthesis h K L))) \n (cyph_dec h))
H1 : no_pairs h
H0 : h (MEnc m1 m2) (MEnc m m0)
M,N,m,m0,m1,m2 : Msg
H : and (no_pairs h)\n (and (no_syn_ops h)\n (and\n (forall (M N K L : Msg) (_ : h (MEnc M K) (MEnc N L)),\n or (not (synthesis h M N)) (not (synthesis h K L)))\n (cyph_dec h)))
h : hedge
*****
h (MEnc m1 m2) (MEnc m m0)
+++++
trivial.
-----
Lemma cond_irr_impl_stable_reduce : forall h : hedge, cond_irr h -> equal h (reduce h).
intros.
unfold equal in |- *.
split.
try apply red_incl_h.
unfold inclusion in |- *.
intros M N.
unfold reduce in |- *.
case M.
try tauto.
case N.
try tauto.
intros.
unfold cond_irr in H.
unfold no_syn_cyph in H.
elim H.
intros.
elim H2.
intros.
elim H4.
intros.
split.

*****
H6 : cyph_dec h
H5 : forall (M N K L : Msg) (_ : h (MEnc M K) (MEnc N L)),\nor (not (synthesis h M N)) (not (synthesis h K L))
H4 : and\n (forall (M N K L : Msg) (_ : h (MEnc M K) (MEnc N L)),\n or (not (synthesis h M N)) (not (synthesis h K L))) \n (cyph_dec h)
H3 : no_syn_ops h
H2 : and (no_syn_ops h)\n (and\n (forall (M N K L : Msg) (_ : h (MEnc M K) (MEnc N L)),\n or (not (synthesis h M N)) (not (synthesis h K L))) \n (cyph_dec h))
H1 : no_pairs h
H0 : h (MEnc m1 m2) (MEnc m m0)
M,N,m,m0,m1,m2 : Msg
H : and (no_pairs h)\n (and (no_syn_ops h)\n (and\n (forall (M N K L : Msg) (_ : h (MEnc M K) (MEnc N L)),\n or (not (synthesis h M N)) (not (synthesis h K L)))\n (cyph_dec h)))
h : hedge
*****
or (not (synthesis h m1 m)) (not (synthesis h m2 m0))
+++++
trivial.
-----
Lemma cond_irr_impl_stable_reduce : forall h : hedge, cond_irr h -> equal h (reduce h).
intros.
unfold equal in |- *.
split.
try apply red_incl_h.
unfold inclusion in |- *.
intros M N.
unfold reduce in |- *.
case M.
try tauto.
case N.
try tauto.
intros.
unfold cond_irr in H.
unfold no_syn_cyph in H.
elim H.
intros.
elim H2.
intros.
elim H4.
intros.
split.
trivial.

*****
H6 : cyph_dec h
H5 : forall (M N K L : Msg) (_ : h (MEnc M K) (MEnc N L)),\nor (not (synthesis h M N)) (not (synthesis h K L))
H4 : and\n (forall (M N K L : Msg) (_ : h (MEnc M K) (MEnc N L)),\n or (not (synthesis h M N)) (not (synthesis h K L))) \n (cyph_dec h)
H3 : no_syn_ops h
H2 : and (no_syn_ops h)\n (and\n (forall (M N K L : Msg) (_ : h (MEnc M K) (MEnc N L)),\n or (not (synthesis h M N)) (not (synthesis h K L))) \n (cyph_dec h))
H1 : no_pairs h
H0 : h (MEnc m1 m2) (MEnc m m0)
M,N,m,m0,m1,m2 : Msg
H : and (no_pairs h)\n (and (no_syn_ops h)\n (and\n (forall (M N K L : Msg) (_ : h (MEnc M K) (MEnc N L)),\n or (not (synthesis h M N)) (not (synthesis h K L)))\n (cyph_dec h)))
h : hedge
*****
or (not (synthesis h m1 m)) (not (synthesis h m2 m0))
+++++
apply H5.
-----
Lemma cond_irr_impl_stable_reduce : forall h : hedge, cond_irr h -> equal h (reduce h).
intros.
unfold equal in |- *.
split.
try apply red_incl_h.
unfold inclusion in |- *.
intros M N.
unfold reduce in |- *.
case M.
try tauto.
case N.
try tauto.
intros.
unfold cond_irr in H.
unfold no_syn_cyph in H.
elim H.
intros.
elim H2.
intros.
elim H4.
intros.
split.
trivial.
apply H5.

*****
H6 : cyph_dec h
H5 : forall (M N K L : Msg) (_ : h (MEnc M K) (MEnc N L)),\nor (not (synthesis h M N)) (not (synthesis h K L))
H4 : and\n (forall (M N K L : Msg) (_ : h (MEnc M K) (MEnc N L)),\n or (not (synthesis h M N)) (not (synthesis h K L))) \n (cyph_dec h)
H3 : no_syn_ops h
H2 : and (no_syn_ops h)\n (and\n (forall (M N K L : Msg) (_ : h (MEnc M K) (MEnc N L)),\n or (not (synthesis h M N)) (not (synthesis h K L))) \n (cyph_dec h))
H1 : no_pairs h
H0 : h (MEnc m1 m2) (MEnc m m0)
M,N,m,m0,m1,m2 : Msg
H : and (no_pairs h)\n (and (no_syn_ops h)\n (and\n (forall (M N K L : Msg) (_ : h (MEnc M K) (MEnc N L)),\n or (not (synthesis h M N)) (not (synthesis h K L)))\n (cyph_dec h)))
h : hedge
*****
h (MEnc m1 m2) (MEnc m m0)
+++++
trivial.
-----
Lemma cond_irr_impl_stable_reduce : forall h : hedge, cond_irr h -> equal h (reduce h).
intros.
unfold equal in |- *.
split.
try apply red_incl_h.
unfold inclusion in |- *.
intros M N.
unfold reduce in |- *.
case M.
try tauto.
case N.

*****
M,N : Msg
H : cond_irr h
h : hedge
*****
forall (m m0 m1 m2 : Msg) (_ : h (MEnc m1 m2) (MPair m m0)), and (h (MEnc m1 m2) (MPair m m0)) True
+++++
try tauto.
-----
Lemma cond_irr_impl_stable_reduce : forall h : hedge, cond_irr h -> equal h (reduce h).
intros.
unfold equal in |- *.
split.
try apply red_incl_h.
unfold inclusion in |- *.
intros M N.
unfold reduce in |- *.
case M.
try tauto.
case N.

*****
M,N : Msg
H : cond_irr h
h : hedge
*****
forall (o : op) (m m0 m1 : Msg) (_ : h (MEnc m0 m1) (Mop o m)), and (h (MEnc m0 m1) (Mop o m)) True
+++++
try tauto.
-----
Lemma cond_irr_impl_stable_reduce : forall h : hedge, cond_irr h -> equal h (reduce h).
intros.
unfold equal in |- *.
split.
try apply red_incl_h.
unfold inclusion in |- *.
intros M N.
unfold reduce in |- *.
case M.

*****
M,N : Msg
H : cond_irr h
h : hedge
*****
forall (m m0 : Msg) (_ : h (MPair m m0) N), and (h (MPair m m0) N) match N with | MPair N1 N2 => or (not (synthesis h m N1)) (not (synthesis h m0 N2)) | _ => True end
+++++
try tauto.
-----
Lemma cond_irr_impl_stable_reduce : forall h : hedge, cond_irr h -> equal h (reduce h).
intros.
unfold equal in |- *.
split.
try apply red_incl_h.
unfold inclusion in |- *.
intros M N.
unfold reduce in |- *.
case M.
try tauto.

*****
M,N : Msg
H : cond_irr h
h : hedge
*****
forall (m m0 : Msg) (_ : h (MPair m m0) N), and (h (MPair m m0) N) match N with | MPair N1 N2 => or (not (synthesis h m N1)) (not (synthesis h m0 N2)) | _ => True end
+++++
case N.
-----
Lemma cond_irr_impl_stable_reduce : forall h : hedge, cond_irr h -> equal h (reduce h).
intros.
unfold equal in |- *.
split.
try apply red_incl_h.
unfold inclusion in |- *.
intros M N.
unfold reduce in |- *.
case M.
try tauto.
case N.

*****
M,N : Msg
H : cond_irr h
h : hedge
*****
forall (n : Nam) (m m0 : Msg) (_ : h (MPair m m0) (MNam n)), and (h (MPair m m0) (MNam n)) True
+++++
try tauto.
-----
Lemma cond_irr_impl_stable_reduce : forall h : hedge, cond_irr h -> equal h (reduce h).
intros.
unfold equal in |- *.
split.
try apply red_incl_h.
unfold inclusion in |- *.
intros M N.
unfold reduce in |- *.
case M.
try tauto.
case N.

*****
M,N : Msg
H : cond_irr h
h : hedge
*****
forall (m m0 m1 m2 : Msg) (_ : h (MPair m1 m2) (MEnc m m0)), and (h (MPair m1 m2) (MEnc m m0)) True
+++++
try tauto.
-----
Lemma cond_irr_impl_stable_reduce : forall h : hedge, cond_irr h -> equal h (reduce h).
intros.
unfold equal in |- *.
split.
try apply red_incl_h.
unfold inclusion in |- *.
intros M N.
unfold reduce in |- *.
case M.
try tauto.
case N.

*****
M,N : Msg
H : cond_irr h
h : hedge
*****
forall (m m0 m1 m2 : Msg) (_ : h (MPair m1 m2) (MPair m m0)), and (h (MPair m1 m2) (MPair m m0)) (or (not (synthesis h m1 m)) (not (synthesis h m2 m0)))
+++++
try tauto.
-----
Lemma cond_irr_impl_stable_reduce : forall h : hedge, cond_irr h -> equal h (reduce h).
intros.
unfold equal in |- *.
split.
try apply red_incl_h.
unfold inclusion in |- *.
intros M N.
unfold reduce in |- *.
case M.
try tauto.
case N.
try tauto.

*****
M,N : Msg
H : cond_irr h
h : hedge
*****
forall (m m0 m1 m2 : Msg) (_ : h (MPair m1 m2) (MPair m m0)), and (h (MPair m1 m2) (MPair m m0)) (or (not (synthesis h m1 m)) (not (synthesis h m2 m0)))
+++++
intros.
-----
Lemma cond_irr_impl_stable_reduce : forall h : hedge, cond_irr h -> equal h (reduce h).
intros.
unfold equal in |- *.
split.
try apply red_incl_h.
unfold inclusion in |- *.
intros M N.
unfold reduce in |- *.
case M.
try tauto.
case N.
try tauto.
intros.

*****
H0 : h (MPair m1 m2) (MPair m m0)
M,N,m,m0,m1,m2 : Msg
H : cond_irr h
h : hedge
*****
and (h (MPair m1 m2) (MPair m m0)) (or (not (synthesis h m1 m)) (not (synthesis h m2 m0)))
+++++
unfold cond_irr in H.
-----
Lemma cond_irr_impl_stable_reduce : forall h : hedge, cond_irr h -> equal h (reduce h).
intros.
unfold equal in |- *.
split.
try apply red_incl_h.
unfold inclusion in |- *.
intros M N.
unfold reduce in |- *.
case M.
try tauto.
case N.
try tauto.
intros.
unfold cond_irr in H.

*****
H0 : h (MPair m1 m2) (MPair m m0)
M,N,m,m0,m1,m2 : Msg
H : and (no_pairs h)\n (and (no_syn_ops h) (and (no_syn_cyph h) (cyph_dec h)))
h : hedge
*****
and (h (MPair m1 m2) (MPair m m0)) (or (not (synthesis h m1 m)) (not (synthesis h m2 m0)))
+++++
unfold no_pairs in H.
-----
Lemma cond_irr_impl_stable_reduce : forall h : hedge, cond_irr h -> equal h (reduce h).
intros.
unfold equal in |- *.
split.
try apply red_incl_h.
unfold inclusion in |- *.
intros M N.
unfold reduce in |- *.
case M.
try tauto.
case N.
try tauto.
intros.
unfold cond_irr in H.
unfold no_pairs in H.

*****
H0 : h (MPair m1 m2) (MPair m m0)
M,N,m,m0,m1,m2 : Msg
H : and (forall M1 M2 N1 N2 : Msg, not (h (MPair M1 M2) (MPair N1 N2)))\n (and (no_syn_ops h) (and (no_syn_cyph h) (cyph_dec h)))
h : hedge
*****
and (h (MPair m1 m2) (MPair m m0)) (or (not (synthesis h m1 m)) (not (synthesis h m2 m0)))
+++++
elim H.
-----
Lemma cond_irr_impl_stable_reduce : forall h : hedge, cond_irr h -> equal h (reduce h).
intros.
unfold equal in |- *.
split.
try apply red_incl_h.
unfold inclusion in |- *.
intros M N.
unfold reduce in |- *.
case M.
try tauto.
case N.
try tauto.
intros.
unfold cond_irr in H.
unfold no_pairs in H.
elim H.

*****
H0 : h (MPair m1 m2) (MPair m m0)
M,N,m,m0,m1,m2 : Msg
H : and (forall M1 M2 N1 N2 : Msg, not (h (MPair M1 M2) (MPair N1 N2)))\n (and (no_syn_ops h) (and (no_syn_cyph h) (cyph_dec h)))
h : hedge
*****
forall (_ : forall M1 M2 N1 N2 : Msg, not (h (MPair M1 M2) (MPair N1 N2))) (_ : and (no_syn_ops h) (and (no_syn_cyph h) (cyph_dec h))), and (h (MPair m1 m2) (MPair m m0)) (or (not (synthesis h m1 m)) (not (synthesis h m2 m0)))
+++++
intros.
-----
Lemma cond_irr_impl_stable_reduce : forall h : hedge, cond_irr h -> equal h (reduce h).
intros.
unfold equal in |- *.
split.
try apply red_incl_h.
unfold inclusion in |- *.
intros M N.
unfold reduce in |- *.
case M.
try tauto.
case N.
try tauto.
intros.
unfold cond_irr in H.
unfold no_pairs in H.
elim H.
intros.

*****
H2 : and (no_syn_ops h) (and (no_syn_cyph h) (cyph_dec h))
H1 : forall M1 M2 N1 N2 : Msg, not (h (MPair M1 M2) (MPair N1 N2))
H0 : h (MPair m1 m2) (MPair m m0)
M,N,m,m0,m1,m2 : Msg
H : and (forall M1 M2 N1 N2 : Msg, not (h (MPair M1 M2) (MPair N1 N2)))\n (and (no_syn_ops h) (and (no_syn_cyph h) (cyph_dec h)))
h : hedge
*****
and (h (MPair m1 m2) (MPair m m0)) (or (not (synthesis h m1 m)) (not (synthesis h m2 m0)))
+++++
generalize (H1 m1 m2 m m0).
-----
Lemma cond_irr_impl_stable_reduce : forall h : hedge, cond_irr h -> equal h (reduce h).
intros.
unfold equal in |- *.
split.
try apply red_incl_h.
unfold inclusion in |- *.
intros M N.
unfold reduce in |- *.
case M.
try tauto.
case N.
try tauto.
intros.
unfold cond_irr in H.
unfold no_pairs in H.
elim H.
intros.
generalize (H1 m1 m2 m m0).

*****
H2 : and (no_syn_ops h) (and (no_syn_cyph h) (cyph_dec h))
H1 : forall M1 M2 N1 N2 : Msg, not (h (MPair M1 M2) (MPair N1 N2))
H0 : h (MPair m1 m2) (MPair m m0)
M,N,m,m0,m1,m2 : Msg
H : and (forall M1 M2 N1 N2 : Msg, not (h (MPair M1 M2) (MPair N1 N2)))\n (and (no_syn_ops h) (and (no_syn_cyph h) (cyph_dec h)))
h : hedge
*****
forall _ : not (h (MPair m1 m2) (MPair m m0)), and (h (MPair m1 m2) (MPair m m0)) (or (not (synthesis h m1 m)) (not (synthesis h m2 m0)))
+++++
tauto.
-----
Lemma cond_irr_impl_stable_reduce : forall h : hedge, cond_irr h -> equal h (reduce h).
intros.
unfold equal in |- *.
split.
try apply red_incl_h.
unfold inclusion in |- *.
intros M N.
unfold reduce in |- *.
case M.
try tauto.
case N.

*****
M,N : Msg
H : cond_irr h
h : hedge
*****
forall (o : op) (m m0 m1 : Msg) (_ : h (MPair m0 m1) (Mop o m)), and (h (MPair m0 m1) (Mop o m)) True
+++++
try tauto.
-----
Lemma cond_irr_impl_stable_reduce : forall h : hedge, cond_irr h -> equal h (reduce h).
intros.
unfold equal in |- *.
split.
try apply red_incl_h.
unfold inclusion in |- *.
intros M N.
unfold reduce in |- *.
case M.

*****
M,N : Msg
H : cond_irr h
h : hedge
*****
forall (o : op) (m : Msg) (_ : h (Mop o m) N), and (h (Mop o m) N) match N with | Mop opN N' => or (not (eq o opN)) (not (synthesis h m N')) | _ => True end
+++++
try tauto.
-----
Lemma cond_irr_impl_stable_reduce : forall h : hedge, cond_irr h -> equal h (reduce h).
intros.
unfold equal in |- *.
split.
try apply red_incl_h.
unfold inclusion in |- *.
intros M N.
unfold reduce in |- *.
case M.
try tauto.

*****
M,N : Msg
H : cond_irr h
h : hedge
*****
forall (o : op) (m : Msg) (_ : h (Mop o m) N), and (h (Mop o m) N) match N with | Mop opN N' => or (not (eq o opN)) (not (synthesis h m N')) | _ => True end
+++++
case N.
-----
Lemma cond_irr_impl_stable_reduce : forall h : hedge, cond_irr h -> equal h (reduce h).
intros.
unfold equal in |- *.
split.
try apply red_incl_h.
unfold inclusion in |- *.
intros M N.
unfold reduce in |- *.
case M.
try tauto.
case N.

*****
M,N : Msg
H : cond_irr h
h : hedge
*****
forall (n : Nam) (o : op) (m : Msg) (_ : h (Mop o m) (MNam n)), and (h (Mop o m) (MNam n)) True
+++++
try tauto.
-----
Lemma cond_irr_impl_stable_reduce : forall h : hedge, cond_irr h -> equal h (reduce h).
intros.
unfold equal in |- *.
split.
try apply red_incl_h.
unfold inclusion in |- *.
intros M N.
unfold reduce in |- *.
case M.
try tauto.
case N.

*****
M,N : Msg
H : cond_irr h
h : hedge
*****
forall (m m0 : Msg) (o : op) (m1 : Msg) (_ : h (Mop o m1) (MEnc m m0)), and (h (Mop o m1) (MEnc m m0)) True
+++++
try tauto.
-----
Lemma cond_irr_impl_stable_reduce : forall h : hedge, cond_irr h -> equal h (reduce h).
intros.
unfold equal in |- *.
split.
try apply red_incl_h.
unfold inclusion in |- *.
intros M N.
unfold reduce in |- *.
case M.
try tauto.
case N.

*****
M,N : Msg
H : cond_irr h
h : hedge
*****
forall (m m0 : Msg) (o : op) (m1 : Msg) (_ : h (Mop o m1) (MPair m m0)), and (h (Mop o m1) (MPair m m0)) True
+++++
try tauto.
-----
Lemma cond_irr_impl_stable_reduce : forall h : hedge, cond_irr h -> equal h (reduce h).
intros.
unfold equal in |- *.
split.
try apply red_incl_h.
unfold inclusion in |- *.
intros M N.
unfold reduce in |- *.
case M.
try tauto.
case N.

*****
M,N : Msg
H : cond_irr h
h : hedge
*****
forall (o : op) (m : Msg) (o0 : op) (m0 : Msg) (_ : h (Mop o0 m0) (Mop o m)), and (h (Mop o0 m0) (Mop o m)) (or (not (eq o0 o)) (not (synthesis h m0 m)))
+++++
try tauto.
-----
Lemma cond_irr_impl_stable_reduce : forall h : hedge, cond_irr h -> equal h (reduce h).
intros.
unfold equal in |- *.
split.
try apply red_incl_h.
unfold inclusion in |- *.
intros M N.
unfold reduce in |- *.
case M.
try tauto.
case N.
try tauto.

*****
M,N : Msg
H : cond_irr h
h : hedge
*****
forall (o : op) (m : Msg) (o0 : op) (m0 : Msg) (_ : h (Mop o0 m0) (Mop o m)), and (h (Mop o0 m0) (Mop o m)) (or (not (eq o0 o)) (not (synthesis h m0 m)))
+++++
intros.
-----
Lemma cond_irr_impl_stable_reduce : forall h : hedge, cond_irr h -> equal h (reduce h).
intros.
unfold equal in |- *.
split.
try apply red_incl_h.
unfold inclusion in |- *.
intros M N.
unfold reduce in |- *.
case M.
try tauto.
case N.
try tauto.
intros.

*****
H0 : h (Mop o0 m0) (Mop o m)
m0 : Msg
o0 : op
m : Msg
o : op
M,N : Msg
H : cond_irr h
h : hedge
*****
and (h (Mop o0 m0) (Mop o m)) (or (not (eq o0 o)) (not (synthesis h m0 m)))
+++++
split.
-----
Lemma cond_irr_impl_stable_reduce : forall h : hedge, cond_irr h -> equal h (reduce h).
intros.
unfold equal in |- *.
split.
try apply red_incl_h.
unfold inclusion in |- *.
intros M N.
unfold reduce in |- *.
case M.
try tauto.
case N.
try tauto.
intros.
split.

*****
H0 : h (Mop o0 m0) (Mop o m)
m0 : Msg
o0 : op
m : Msg
o : op
M,N : Msg
H : cond_irr h
h : hedge
*****
h (Mop o0 m0) (Mop o m)
+++++
trivial.
-----
Lemma cond_irr_impl_stable_reduce : forall h : hedge, cond_irr h -> equal h (reduce h).
intros.
unfold equal in |- *.
split.
try apply red_incl_h.
unfold inclusion in |- *.
intros M N.
unfold reduce in |- *.
case M.
try tauto.
case N.
try tauto.
intros.
split.

*****
H0 : h (Mop o0 m0) (Mop o m)
m0 : Msg
o0 : op
m : Msg
o : op
M,N : Msg
H : cond_irr h
h : hedge
*****
or (not (eq o0 o)) (not (synthesis h m0 m))
+++++
trivial.
-----
Lemma cond_irr_impl_stable_reduce : forall h : hedge, cond_irr h -> equal h (reduce h).
intros.
unfold equal in |- *.
split.
try apply red_incl_h.
unfold inclusion in |- *.
intros M N.
unfold reduce in |- *.
case M.
try tauto.
case N.
try tauto.
intros.
split.
trivial.

*****
H0 : h (Mop o0 m0) (Mop o m)
m0 : Msg
o0 : op
m : Msg
o : op
M,N : Msg
H : cond_irr h
h : hedge
*****
or (not (eq o0 o)) (not (synthesis h m0 m))
+++++
case (op_eq_dec o0 o).
-----
Lemma cond_irr_impl_stable_reduce : forall h : hedge, cond_irr h -> equal h (reduce h).
intros.
unfold equal in |- *.
split.
try apply red_incl_h.
unfold inclusion in |- *.
intros M N.
unfold reduce in |- *.
case M.
try tauto.
case N.
try tauto.
intros.
split.
trivial.
case (op_eq_dec o0 o).

*****
H0 : h (Mop o0 m0) (Mop o m)
m0 : Msg
o0 : op
m : Msg
o : op
M,N : Msg
H : cond_irr h
h : hedge
*****
forall _ : eq o0 o, or (not (eq o0 o)) (not (synthesis h m0 m))
+++++
intro.
-----
Lemma cond_irr_impl_stable_reduce : forall h : hedge, cond_irr h -> equal h (reduce h).
intros.
unfold equal in |- *.
split.
try apply red_incl_h.
unfold inclusion in |- *.
intros M N.
unfold reduce in |- *.
case M.
try tauto.
case N.
try tauto.
intros.
split.
trivial.
case (op_eq_dec o0 o).
intro.

*****
e : eq o0 o
H0 : h (Mop o0 m0) (Mop o m)
m0 : Msg
o0 : op
m : Msg
o : op
M,N : Msg
H : cond_irr h
h : hedge
*****
or (not (eq o0 o)) (not (synthesis h m0 m))
+++++
right.
-----
Lemma cond_irr_impl_stable_reduce : forall h : hedge, cond_irr h -> equal h (reduce h).
intros.
unfold equal in |- *.
split.
try apply red_incl_h.
unfold inclusion in |- *.
intros M N.
unfold reduce in |- *.
case M.
try tauto.
case N.
try tauto.
intros.
split.
trivial.
case (op_eq_dec o0 o).
intro.
right.

*****
e : eq o0 o
H0 : h (Mop o0 m0) (Mop o m)
m0 : Msg
o0 : op
m : Msg
o : op
M,N : Msg
H : cond_irr h
h : hedge
*****
not (synthesis h m0 m)
+++++
rewrite e in H0.
-----
Lemma cond_irr_impl_stable_reduce : forall h : hedge, cond_irr h -> equal h (reduce h).
intros.
unfold equal in |- *.
split.
try apply red_incl_h.
unfold inclusion in |- *.
intros M N.
unfold reduce in |- *.
case M.
try tauto.
case N.
try tauto.
intros.
split.
trivial.
case (op_eq_dec o0 o).
intro.
right.
rewrite e in H0.

*****
e : eq o0 o
H0 : h (Mop o m0) (Mop o m)
m0 : Msg
o0 : op
m : Msg
o : op
M,N : Msg
H : cond_irr h
h : hedge
*****
not (synthesis h m0 m)
+++++
unfold cond_irr in H.
-----
Lemma cond_irr_impl_stable_reduce : forall h : hedge, cond_irr h -> equal h (reduce h).
intros.
unfold equal in |- *.
split.
try apply red_incl_h.
unfold inclusion in |- *.
intros M N.
unfold reduce in |- *.
case M.
try tauto.
case N.
try tauto.
intros.
split.
trivial.
case (op_eq_dec o0 o).
intro.
right.
rewrite e in H0.
unfold cond_irr in H.

*****
e : eq o0 o
H0 : h (Mop o m0) (Mop o m)
m0 : Msg
o0 : op
m : Msg
o : op
M,N : Msg
H : and (no_pairs h)\n (and (no_syn_ops h) (and (no_syn_cyph h) (cyph_dec h)))
h : hedge
*****
not (synthesis h m0 m)
+++++
unfold no_syn_ops in H.
-----
Lemma cond_irr_impl_stable_reduce : forall h : hedge, cond_irr h -> equal h (reduce h).
intros.
unfold equal in |- *.
split.
try apply red_incl_h.
unfold inclusion in |- *.
intros M N.
unfold reduce in |- *.
case M.
try tauto.
case N.
try tauto.
intros.
split.
trivial.
case (op_eq_dec o0 o).
intro.
right.
rewrite e in H0.
unfold cond_irr in H.
unfold no_syn_ops in H.

*****
e : eq o0 o
H0 : h (Mop o m0) (Mop o m)
m0 : Msg
o0 : op
m : Msg
o : op
M,N : Msg
H : and (no_pairs h)\n (and\n (forall (o : op) (M N : Msg) (_ : h (Mop o M) (Mop o N)),\n not (synthesis h M N)) (and (no_syn_cyph h) (cyph_dec h)))
h : hedge
*****
not (synthesis h m0 m)
+++++
elim H.
-----
Lemma cond_irr_impl_stable_reduce : forall h : hedge, cond_irr h -> equal h (reduce h).
intros.
unfold equal in |- *.
split.
try apply red_incl_h.
unfold inclusion in |- *.
intros M N.
unfold reduce in |- *.
case M.
try tauto.
case N.
try tauto.
intros.
split.
trivial.
case (op_eq_dec o0 o).
intro.
right.
rewrite e in H0.
unfold cond_irr in H.
unfold no_syn_ops in H.
elim H.

*****
e : eq o0 o
H0 : h (Mop o m0) (Mop o m)
m0 : Msg
o0 : op
m : Msg
o : op
M,N : Msg
H : and (no_pairs h)\n (and\n (forall (o : op) (M N : Msg) (_ : h (Mop o M) (Mop o N)),\n not (synthesis h M N)) (and (no_syn_cyph h) (cyph_dec h)))
h : hedge
*****
forall (_ : no_pairs h) (_ : and (forall (o : op) (M N : Msg) (_ : h (Mop o M) (Mop o N)), not (synthesis h M N)) (and (no_syn_cyph h) (cyph_dec h))), not (synthesis h m0 m)
+++++
intros.
-----
Lemma cond_irr_impl_stable_reduce : forall h : hedge, cond_irr h -> equal h (reduce h).
intros.
unfold equal in |- *.
split.
try apply red_incl_h.
unfold inclusion in |- *.
intros M N.
unfold reduce in |- *.
case M.
try tauto.
case N.
try tauto.
intros.
split.
trivial.
case (op_eq_dec o0 o).
intro.
right.
rewrite e in H0.
unfold cond_irr in H.
unfold no_syn_ops in H.
elim H.
intros.

*****
H2 : and\n (forall (o : op) (M N : Msg) (_ : h (Mop o M) (Mop o N)),\n not (synthesis h M N)) (and (no_syn_cyph h) (cyph_dec h))
H1 : no_pairs h
e : eq o0 o
H0 : h (Mop o m0) (Mop o m)
m0 : Msg
o0 : op
m : Msg
o : op
M,N : Msg
H : and (no_pairs h)\n (and\n (forall (o : op) (M N : Msg) (_ : h (Mop o M) (Mop o N)),\n not (synthesis h M N)) (and (no_syn_cyph h) (cyph_dec h)))
h : hedge
*****
not (synthesis h m0 m)
+++++
elim H2.
-----
Lemma cond_irr_impl_stable_reduce : forall h : hedge, cond_irr h -> equal h (reduce h).
intros.
unfold equal in |- *.
split.
try apply red_incl_h.
unfold inclusion in |- *.
intros M N.
unfold reduce in |- *.
case M.
try tauto.
case N.
try tauto.
intros.
split.
trivial.
case (op_eq_dec o0 o).
intro.
right.
rewrite e in H0.
unfold cond_irr in H.
unfold no_syn_ops in H.
elim H.
intros.
elim H2.

*****
H2 : and\n (forall (o : op) (M N : Msg) (_ : h (Mop o M) (Mop o N)),\n not (synthesis h M N)) (and (no_syn_cyph h) (cyph_dec h))
H1 : no_pairs h
e : eq o0 o
H0 : h (Mop o m0) (Mop o m)
m0 : Msg
o0 : op
m : Msg
o : op
M,N : Msg
H : and (no_pairs h)\n (and\n (forall (o : op) (M N : Msg) (_ : h (Mop o M) (Mop o N)),\n not (synthesis h M N)) (and (no_syn_cyph h) (cyph_dec h)))
h : hedge
*****
forall (_ : forall (o : op) (M N : Msg) (_ : h (Mop o M) (Mop o N)), not (synthesis h M N)) (_ : and (no_syn_cyph h) (cyph_dec h)), not (synthesis h m0 m)
+++++
intros.
-----
Lemma cond_irr_impl_stable_reduce : forall h : hedge, cond_irr h -> equal h (reduce h).
intros.
unfold equal in |- *.
split.
try apply red_incl_h.
unfold inclusion in |- *.
intros M N.
unfold reduce in |- *.
case M.
try tauto.
case N.
try tauto.
intros.
split.
trivial.
case (op_eq_dec o0 o).
intro.
right.
rewrite e in H0.
unfold cond_irr in H.
unfold no_syn_ops in H.
elim H.
intros.
elim H2.
intros.

*****
H4 : and (no_syn_cyph h) (cyph_dec h)
H3 : forall (o : op) (M N : Msg) (_ : h (Mop o M) (Mop o N)),\nnot (synthesis h M N)
H2 : and\n (forall (o : op) (M N : Msg) (_ : h (Mop o M) (Mop o N)),\n not (synthesis h M N)) (and (no_syn_cyph h) (cyph_dec h))
H1 : no_pairs h
e : eq o0 o
H0 : h (Mop o m0) (Mop o m)
m0 : Msg
o0 : op
m : Msg
o : op
M,N : Msg
H : and (no_pairs h)\n (and\n (forall (o : op) (M N : Msg) (_ : h (Mop o M) (Mop o N)),\n not (synthesis h M N)) (and (no_syn_cyph h) (cyph_dec h)))
h : hedge
*****
not (synthesis h m0 m)
+++++
apply (H3 o).
-----
Lemma cond_irr_impl_stable_reduce : forall h : hedge, cond_irr h -> equal h (reduce h).
intros.
unfold equal in |- *.
split.
try apply red_incl_h.
unfold inclusion in |- *.
intros M N.
unfold reduce in |- *.
case M.
try tauto.
case N.
try tauto.
intros.
split.
trivial.
case (op_eq_dec o0 o).
intro.
right.
rewrite e in H0.
unfold cond_irr in H.
unfold no_syn_ops in H.
elim H.
intros.
elim H2.
intros.
apply (H3 o).

*****
H4 : and (no_syn_cyph h) (cyph_dec h)
H3 : forall (o : op) (M N : Msg) (_ : h (Mop o M) (Mop o N)),\nnot (synthesis h M N)
H2 : and\n (forall (o : op) (M N : Msg) (_ : h (Mop o M) (Mop o N)),\n not (synthesis h M N)) (and (no_syn_cyph h) (cyph_dec h))
H1 : no_pairs h
e : eq o0 o
H0 : h (Mop o m0) (Mop o m)
m0 : Msg
o0 : op
m : Msg
o : op
M,N : Msg
H : and (no_pairs h)\n (and\n (forall (o : op) (M N : Msg) (_ : h (Mop o M) (Mop o N)),\n not (synthesis h M N)) (and (no_syn_cyph h) (cyph_dec h)))
h : hedge
*****
h (Mop o m0) (Mop o m)
+++++
trivial.
-----
Lemma cond_irr_impl_stable_reduce : forall h : hedge, cond_irr h -> equal h (reduce h).
intros.
unfold equal in |- *.
split.
try apply red_incl_h.
unfold inclusion in |- *.
intros M N.
unfold reduce in |- *.
case M.
try tauto.
case N.
try tauto.
intros.
split.
trivial.
case (op_eq_dec o0 o).

*****
H0 : h (Mop o0 m0) (Mop o m)
m0 : Msg
o0 : op
m : Msg
o : op
M,N : Msg
H : cond_irr h
h : hedge
*****
forall _ : not (eq o0 o), or (not (eq o0 o)) (not (synthesis h m0 m))
+++++
tauto.
-----
Lemma cond_irr_impl_stable_reduce : forall h : hedge, cond_irr h -> equal h (reduce h).
intros.
unfold equal in |- *.
split.

*****
H : cond_irr h
h : hedge
*****
inclusion (reduce h) h
+++++
try apply red_incl_h.
-----
Lemma cond_irr_impl_stable_reduce : forall h : hedge, cond_irr h -> equal h (reduce h).
intros.
unfold equal in |- *.
split.

*****

*****

+++++
Qed.
-----
Lemma cond_irr_impl_h_incl_irr :\n forall h : hedge, cond_irr h -> inclusion h (irreducible h).
-----
Lemma cond_irr_impl_h_incl_irr : forall h : hedge, cond_irr h -> inclusion h (irreducible h).

*****

*****
forall (h : hedge) (_ : cond_irr h), inclusion h (irreducible h)
+++++
intros.
-----
Lemma cond_irr_impl_h_incl_irr : forall h : hedge, cond_irr h -> inclusion h (irreducible h).
intros.

*****
H : cond_irr h
h : hedge
*****
inclusion h (irreducible h)
+++++
apply inclusion_trans with (reduce h).
-----
Lemma cond_irr_impl_h_incl_irr : forall h : hedge, cond_irr h -> inclusion h (irreducible h).
intros.
apply inclusion_trans with (reduce h).

*****
H : cond_irr h
h : hedge
*****
inclusion h (reduce h)
+++++
generalize (cond_irr_impl_stable_reduce h H).
-----
Lemma cond_irr_impl_h_incl_irr : forall h : hedge, cond_irr h -> inclusion h (irreducible h).
intros.
apply inclusion_trans with (reduce h).
generalize (cond_irr_impl_stable_reduce h H).

*****
H : cond_irr h
h : hedge
*****
forall _ : equal h (reduce h), inclusion h (reduce h)
+++++
unfold equal in |- *.
-----
Lemma cond_irr_impl_h_incl_irr : forall h : hedge, cond_irr h -> inclusion h (irreducible h).
intros.
apply inclusion_trans with (reduce h).
generalize (cond_irr_impl_stable_reduce h H).
unfold equal in |- *.

*****
H : cond_irr h
h : hedge
*****
forall _ : and (inclusion h (reduce h)) (inclusion (reduce h) h), inclusion h (reduce h)
+++++
tauto.
-----
Lemma cond_irr_impl_h_incl_irr : forall h : hedge, cond_irr h -> inclusion h (irreducible h).
intros.
apply inclusion_trans with (reduce h).

*****
H : cond_irr h
h : hedge
*****
inclusion (reduce h) (irreducible h)
+++++
apply red_equiv_impl_red_incl.
-----
Lemma cond_irr_impl_h_incl_irr : forall h : hedge, cond_irr h -> inclusion h (irreducible h).
intros.
apply inclusion_trans with (reduce h).
apply red_equiv_impl_red_incl.

*****
H : cond_irr h
h : hedge
*****
equiv_h (reduce h) (irreducible h)
+++++
apply equiv_h_trans with h.
-----
Lemma cond_irr_impl_h_incl_irr : forall h : hedge, cond_irr h -> inclusion h (irreducible h).
intros.
apply inclusion_trans with (reduce h).
apply red_equiv_impl_red_incl.
apply equiv_h_trans with h.

*****
H : cond_irr h
h : hedge
*****
equiv_h (reduce h) h
+++++
apply equiv_h_sym.
-----
Lemma cond_irr_impl_h_incl_irr : forall h : hedge, cond_irr h -> inclusion h (irreducible h).
intros.
apply inclusion_trans with (reduce h).
apply red_equiv_impl_red_incl.
apply equiv_h_trans with h.
apply equiv_h_sym.

*****
H : cond_irr h
h : hedge
*****
equiv_h h (reduce h)
+++++
apply h_equiv_h_red.
-----
Lemma cond_irr_impl_h_incl_irr : forall h : hedge, cond_irr h -> inclusion h (irreducible h).
intros.
apply inclusion_trans with (reduce h).
apply red_equiv_impl_red_incl.
apply equiv_h_trans with h.

*****
H : cond_irr h
h : hedge
*****
equiv_h h (irreducible h)
+++++
apply cond_irr_impl_equiv_h_irr.
-----
Lemma cond_irr_impl_h_incl_irr : forall h : hedge, cond_irr h -> inclusion h (irreducible h).
intros.
apply inclusion_trans with (reduce h).
apply red_equiv_impl_red_incl.
apply equiv_h_trans with h.
apply cond_irr_impl_equiv_h_irr.

*****
H : cond_irr h
h : hedge
*****
cond_irr h
+++++
trivial.
-----
Lemma cond_irr_impl_h_incl_irr : forall h : hedge, cond_irr h -> inclusion h (irreducible h).
intros.
apply inclusion_trans with (reduce h).

*****

*****

+++++
Qed.
-----
Lemma cond_irr_impl_irreducible :\n forall h : hedge, cond_irr h -> is_irreducible h.
-----
Lemma cond_irr_impl_irreducible : forall h : hedge, cond_irr h -> is_irreducible h.

*****

*****
forall (h : hedge) (_ : cond_irr h), is_irreducible h
+++++
unfold is_irreducible in |- *.
-----
Lemma cond_irr_impl_irreducible : forall h : hedge, cond_irr h -> is_irreducible h.
unfold is_irreducible in |- *.

*****

*****
forall (h : hedge) (_ : cond_irr h), equal h (irreducible h)
+++++
unfold equal in |- *.
-----
Lemma cond_irr_impl_irreducible : forall h : hedge, cond_irr h -> is_irreducible h.
unfold is_irreducible in |- *.
unfold equal in |- *.

*****

*****
forall (h : hedge) (_ : cond_irr h), and (inclusion h (irreducible h)) (inclusion (irreducible h) h)
+++++
intros.
-----
Lemma cond_irr_impl_irreducible : forall h : hedge, cond_irr h -> is_irreducible h.
unfold is_irreducible in |- *.
unfold equal in |- *.
intros.

*****
H : cond_irr h
h : hedge
*****
and (inclusion h (irreducible h)) (inclusion (irreducible h) h)
+++++
split.
-----
Lemma cond_irr_impl_irreducible : forall h : hedge, cond_irr h -> is_irreducible h.
unfold is_irreducible in |- *.
unfold equal in |- *.
intros.
split.

*****
H : cond_irr h
h : hedge
*****
inclusion h (irreducible h)
+++++
apply cond_irr_impl_h_incl_irr.
-----
Lemma cond_irr_impl_irreducible : forall h : hedge, cond_irr h -> is_irreducible h.
unfold is_irreducible in |- *.
unfold equal in |- *.
intros.
split.
apply cond_irr_impl_h_incl_irr.

*****
H : cond_irr h
h : hedge
*****
cond_irr h
+++++
trivial.
-----
Lemma cond_irr_impl_irreducible : forall h : hedge, cond_irr h -> is_irreducible h.
unfold is_irreducible in |- *.
unfold equal in |- *.
intros.
split.

*****
H : cond_irr h
h : hedge
*****
inclusion (irreducible h) h
+++++
apply cond_irr_impl_irr_incl_h.
-----
Lemma cond_irr_impl_irreducible : forall h : hedge, cond_irr h -> is_irreducible h.
unfold is_irreducible in |- *.
unfold equal in |- *.
intros.
split.
apply cond_irr_impl_irr_incl_h.

*****
H : cond_irr h
h : hedge
*****
cond_irr h
+++++
trivial.
-----
Lemma cond_irr_impl_irreducible : forall h : hedge, cond_irr h -> is_irreducible h.
unfold is_irreducible in |- *.
unfold equal in |- *.
intros.
split.

*****

*****

+++++
Qed.
-----
Lemma irreducible_impl_cond_irr :\n forall h : hedge, is_irreducible h -> cond_irr h.
-----
Lemma irreducible_impl_cond_irr : forall h : hedge, is_irreducible h -> cond_irr h.

*****

*****
forall (h : hedge) (_ : is_irreducible h), cond_irr h
+++++
unfold cond_irr in |- *.
-----
Lemma irreducible_impl_cond_irr : forall h : hedge, is_irreducible h -> cond_irr h.
unfold cond_irr in |- *.

*****

*****
forall (h : hedge) (_ : is_irreducible h), and (no_pairs h) (and (no_syn_ops h) (and (no_syn_cyph h) (cyph_dec h)))
+++++
unfold is_irreducible in |- *.
-----
Lemma irreducible_impl_cond_irr : forall h : hedge, is_irreducible h -> cond_irr h.
unfold cond_irr in |- *.
unfold is_irreducible in |- *.

*****

*****
forall (h : hedge) (_ : equal h (irreducible h)), and (no_pairs h) (and (no_syn_ops h) (and (no_syn_cyph h) (cyph_dec h)))
+++++
unfold equal in |- *.
-----
Lemma irreducible_impl_cond_irr : forall h : hedge, is_irreducible h -> cond_irr h.
unfold cond_irr in |- *.
unfold is_irreducible in |- *.
unfold equal in |- *.

*****

*****
forall (h : hedge) (_ : and (inclusion h (irreducible h)) (inclusion (irreducible h) h)), and (no_pairs h) (and (no_syn_ops h) (and (no_syn_cyph h) (cyph_dec h)))
+++++
intros.
-----
Lemma irreducible_impl_cond_irr : forall h : hedge, is_irreducible h -> cond_irr h.
unfold cond_irr in |- *.
unfold is_irreducible in |- *.
unfold equal in |- *.
intros.

*****
H : and (inclusion h (irreducible h)) (inclusion (irreducible h) h)
h : hedge
*****
and (no_pairs h) (and (no_syn_ops h) (and (no_syn_cyph h) (cyph_dec h)))
+++++
elim H.
-----
Lemma irreducible_impl_cond_irr : forall h : hedge, is_irreducible h -> cond_irr h.
unfold cond_irr in |- *.
unfold is_irreducible in |- *.
unfold equal in |- *.
intros.
elim H.

*****
H : and (inclusion h (irreducible h)) (inclusion (irreducible h) h)
h : hedge
*****
forall (_ : inclusion h (irreducible h)) (_ : inclusion (irreducible h) h), and (no_pairs h) (and (no_syn_ops h) (and (no_syn_cyph h) (cyph_dec h)))
+++++
unfold inclusion in |- *.
-----
Lemma irreducible_impl_cond_irr : forall h : hedge, is_irreducible h -> cond_irr h.
unfold cond_irr in |- *.
unfold is_irreducible in |- *.
unfold equal in |- *.
intros.
elim H.
unfold inclusion in |- *.

*****
H : and (inclusion h (irreducible h)) (inclusion (irreducible h) h)
h : hedge
*****
forall (_ : forall (M N : Msg) (_ : h M N), irreducible h M N) (_ : forall (M N : Msg) (_ : irreducible h M N), h M N), and (no_pairs h) (and (no_syn_ops h) (and (no_syn_cyph h) (cyph_dec h)))
+++++
intros.
-----
Lemma irreducible_impl_cond_irr : forall h : hedge, is_irreducible h -> cond_irr h.
unfold cond_irr in |- *.
unfold is_irreducible in |- *.
unfold equal in |- *.
intros.
elim H.
unfold inclusion in |- *.
intros.

*****
H1 : forall (M N : Msg) (_ : irreducible h M N), h M N
H0 : forall (M N : Msg) (_ : h M N), irreducible h M N
H : and (inclusion h (irreducible h)) (inclusion (irreducible h) h)
h : hedge
*****
and (no_pairs h) (and (no_syn_ops h) (and (no_syn_cyph h) (cyph_dec h)))
+++++
split.
-----
Lemma irreducible_impl_cond_irr : forall h : hedge, is_irreducible h -> cond_irr h.
unfold cond_irr in |- *.
unfold is_irreducible in |- *.
unfold equal in |- *.
intros.
elim H.
unfold inclusion in |- *.
intros.
split.

*****
H1 : forall (M N : Msg) (_ : irreducible h M N), h M N
H0 : forall (M N : Msg) (_ : h M N), irreducible h M N
H : and (inclusion h (irreducible h)) (inclusion (irreducible h) h)
h : hedge
*****
no_pairs h
+++++
unfold no_pairs in |- *.
-----
Lemma irreducible_impl_cond_irr : forall h : hedge, is_irreducible h -> cond_irr h.
unfold cond_irr in |- *.
unfold is_irreducible in |- *.
unfold equal in |- *.
intros.
elim H.
unfold inclusion in |- *.
intros.
split.
unfold no_pairs in |- *.

*****
H1 : forall (M N : Msg) (_ : irreducible h M N), h M N
H0 : forall (M N : Msg) (_ : h M N), irreducible h M N
H : and (inclusion h (irreducible h)) (inclusion (irreducible h) h)
h : hedge
*****
forall M1 M2 N1 N2 : Msg, not (h (MPair M1 M2) (MPair N1 N2))
+++++
intros.
-----
Lemma irreducible_impl_cond_irr : forall h : hedge, is_irreducible h -> cond_irr h.
unfold cond_irr in |- *.
unfold is_irreducible in |- *.
unfold equal in |- *.
intros.
elim H.
unfold inclusion in |- *.
intros.
split.
unfold no_pairs in |- *.
intros.

*****
M1,M2,N1,N2 : Msg
H1 : forall (M N : Msg) (_ : irreducible h M N), h M N
H0 : forall (M N : Msg) (_ : h M N), irreducible h M N
H : and (inclusion h (irreducible h)) (inclusion (irreducible h) h)
h : hedge
*****
not (h (MPair M1 M2) (MPair N1 N2))
+++++
red in |- *.
-----
Lemma irreducible_impl_cond_irr : forall h : hedge, is_irreducible h -> cond_irr h.
unfold cond_irr in |- *.
unfold is_irreducible in |- *.
unfold equal in |- *.
intros.
elim H.
unfold inclusion in |- *.
intros.
split.
unfold no_pairs in |- *.
intros.
red in |- *.

*****
M1,M2,N1,N2 : Msg
H1 : forall (M N : Msg) (_ : irreducible h M N), h M N
H0 : forall (M N : Msg) (_ : h M N), irreducible h M N
H : and (inclusion h (irreducible h)) (inclusion (irreducible h) h)
h : hedge
*****
forall _ : h (MPair M1 M2) (MPair N1 N2), False
+++++
intro.
-----
Lemma irreducible_impl_cond_irr : forall h : hedge, is_irreducible h -> cond_irr h.
unfold cond_irr in |- *.
unfold is_irreducible in |- *.
unfold equal in |- *.
intros.
elim H.
unfold inclusion in |- *.
intros.
split.
unfold no_pairs in |- *.
intros.
red in |- *.
intro.

*****
H2 : h (MPair M1 M2) (MPair N1 N2)
M1,M2,N1,N2 : Msg
H1 : forall (M N : Msg) (_ : irreducible h M N), h M N
H0 : forall (M N : Msg) (_ : h M N), irreducible h M N
H : and (inclusion h (irreducible h)) (inclusion (irreducible h) h)
h : hedge
*****
False
+++++
apply (irreducible_pair h M1 N1 M2 N2).
-----
Lemma irreducible_impl_cond_irr : forall h : hedge, is_irreducible h -> cond_irr h.
unfold cond_irr in |- *.
unfold is_irreducible in |- *.
unfold equal in |- *.
intros.
elim H.
unfold inclusion in |- *.
intros.
split.
unfold no_pairs in |- *.
intros.
red in |- *.
intro.
apply (irreducible_pair h M1 N1 M2 N2).

*****
H2 : h (MPair M1 M2) (MPair N1 N2)
M1,M2,N1,N2 : Msg
H1 : forall (M N : Msg) (_ : irreducible h M N), h M N
H0 : forall (M N : Msg) (_ : h M N), irreducible h M N
H : and (inclusion h (irreducible h)) (inclusion (irreducible h) h)
h : hedge
*****
irreducible h (MPair M1 M2) (MPair N1 N2)
+++++
apply H0.
-----
Lemma irreducible_impl_cond_irr : forall h : hedge, is_irreducible h -> cond_irr h.
unfold cond_irr in |- *.
unfold is_irreducible in |- *.
unfold equal in |- *.
intros.
elim H.
unfold inclusion in |- *.
intros.
split.
unfold no_pairs in |- *.
intros.
red in |- *.
intro.
apply (irreducible_pair h M1 N1 M2 N2).
apply H0.

*****
H2 : h (MPair M1 M2) (MPair N1 N2)
M1,M2,N1,N2 : Msg
H1 : forall (M N : Msg) (_ : irreducible h M N), h M N
H0 : forall (M N : Msg) (_ : h M N), irreducible h M N
H : and (inclusion h (irreducible h)) (inclusion (irreducible h) h)
h : hedge
*****
h (MPair M1 M2) (MPair N1 N2)
+++++
trivial.
-----
Lemma irreducible_impl_cond_irr : forall h : hedge, is_irreducible h -> cond_irr h.
unfold cond_irr in |- *.
unfold is_irreducible in |- *.
unfold equal in |- *.
intros.
elim H.
unfold inclusion in |- *.
intros.
split.

*****
H1 : forall (M N : Msg) (_ : irreducible h M N), h M N
H0 : forall (M N : Msg) (_ : h M N), irreducible h M N
H : and (inclusion h (irreducible h)) (inclusion (irreducible h) h)
h : hedge
*****
and (no_syn_ops h) (and (no_syn_cyph h) (cyph_dec h))
+++++
split.
-----
Lemma irreducible_impl_cond_irr : forall h : hedge, is_irreducible h -> cond_irr h.
unfold cond_irr in |- *.
unfold is_irreducible in |- *.
unfold equal in |- *.
intros.
elim H.
unfold inclusion in |- *.
intros.
split.
split.

*****
H1 : forall (M N : Msg) (_ : irreducible h M N), h M N
H0 : forall (M N : Msg) (_ : h M N), irreducible h M N
H : and (inclusion h (irreducible h)) (inclusion (irreducible h) h)
h : hedge
*****
no_syn_ops h
+++++
unfold no_syn_ops in |- *.
-----
Lemma irreducible_impl_cond_irr : forall h : hedge, is_irreducible h -> cond_irr h.
unfold cond_irr in |- *.
unfold is_irreducible in |- *.
unfold equal in |- *.
intros.
elim H.
unfold inclusion in |- *.
intros.
split.
split.
unfold no_syn_ops in |- *.

*****
H1 : forall (M N : Msg) (_ : irreducible h M N), h M N
H0 : forall (M N : Msg) (_ : h M N), irreducible h M N
H : and (inclusion h (irreducible h)) (inclusion (irreducible h) h)
h : hedge
*****
forall (o : op) (M N : Msg) (_ : h (Mop o M) (Mop o N)), not (synthesis h M N)
+++++
intros.
-----
Lemma irreducible_impl_cond_irr : forall h : hedge, is_irreducible h -> cond_irr h.
unfold cond_irr in |- *.
unfold is_irreducible in |- *.
unfold equal in |- *.
intros.
elim H.
unfold inclusion in |- *.
intros.
split.
split.
unfold no_syn_ops in |- *.
intros.

*****
H2 : h (Mop o M) (Mop o N)
M,N : Msg
o : op
H1 : forall (M N : Msg) (_ : irreducible h M N), h M N
H0 : forall (M N : Msg) (_ : h M N), irreducible h M N
H : and (inclusion h (irreducible h)) (inclusion (irreducible h) h)
h : hedge
*****
not (synthesis h M N)
+++++
red in |- *.
-----
Lemma irreducible_impl_cond_irr : forall h : hedge, is_irreducible h -> cond_irr h.
unfold cond_irr in |- *.
unfold is_irreducible in |- *.
unfold equal in |- *.
intros.
elim H.
unfold inclusion in |- *.
intros.
split.
split.
unfold no_syn_ops in |- *.
intros.
red in |- *.

*****
H2 : h (Mop o M) (Mop o N)
M,N : Msg
o : op
H1 : forall (M N : Msg) (_ : irreducible h M N), h M N
H0 : forall (M N : Msg) (_ : h M N), irreducible h M N
H : and (inclusion h (irreducible h)) (inclusion (irreducible h) h)
h : hedge
*****
forall _ : synthesis h M N, False
+++++
intro.
-----
Lemma irreducible_impl_cond_irr : forall h : hedge, is_irreducible h -> cond_irr h.
unfold cond_irr in |- *.
unfold is_irreducible in |- *.
unfold equal in |- *.
intros.
elim H.
unfold inclusion in |- *.
intros.
split.
split.
unfold no_syn_ops in |- *.
intros.
red in |- *.
intro.

*****
H3 : synthesis h M N
H2 : h (Mop o M) (Mop o N)
M,N : Msg
o : op
H1 : forall (M N : Msg) (_ : irreducible h M N), h M N
H0 : forall (M N : Msg) (_ : h M N), irreducible h M N
H : and (inclusion h (irreducible h)) (inclusion (irreducible h) h)
h : hedge
*****
False
+++++
generalize (irreducible_op h o o M N).
-----
Lemma irreducible_impl_cond_irr : forall h : hedge, is_irreducible h -> cond_irr h.
unfold cond_irr in |- *.
unfold is_irreducible in |- *.
unfold equal in |- *.
intros.
elim H.
unfold inclusion in |- *.
intros.
split.
split.
unfold no_syn_ops in |- *.
intros.
red in |- *.
intro.
generalize (irreducible_op h o o M N).

*****
H3 : synthesis h M N
H2 : h (Mop o M) (Mop o N)
M,N : Msg
o : op
H1 : forall (M N : Msg) (_ : irreducible h M N), h M N
H0 : forall (M N : Msg) (_ : h M N), irreducible h M N
H : and (inclusion h (irreducible h)) (inclusion (irreducible h) h)
h : hedge
*****
forall _ : iff (irreducible h (Mop o M) (Mop o N)) (and (analysis_def h (Mop o M) (Mop o N)) (or (not (eq o o)) (not (synthesis (analysis_def h) M N)))), False
+++++
intro.
-----
Lemma irreducible_impl_cond_irr : forall h : hedge, is_irreducible h -> cond_irr h.
unfold cond_irr in |- *.
unfold is_irreducible in |- *.
unfold equal in |- *.
intros.
elim H.
unfold inclusion in |- *.
intros.
split.
split.
unfold no_syn_ops in |- *.
intros.
red in |- *.
intro.
generalize (irreducible_op h o o M N).
intro.

*****
H4 : iff (irreducible h (Mop o M) (Mop o N))\n (and (analysis_def h (Mop o M) (Mop o N))\n (or (not (eq o o)) (not (synthesis (analysis_def h) M N))))
H3 : synthesis h M N
H2 : h (Mop o M) (Mop o N)
M,N : Msg
o : op
H1 : forall (M N : Msg) (_ : irreducible h M N), h M N
H0 : forall (M N : Msg) (_ : h M N), irreducible h M N
H : and (inclusion h (irreducible h)) (inclusion (irreducible h) h)
h : hedge
*****
False
+++++
elim H4.
-----
Lemma irreducible_impl_cond_irr : forall h : hedge, is_irreducible h -> cond_irr h.
unfold cond_irr in |- *.
unfold is_irreducible in |- *.
unfold equal in |- *.
intros.
elim H.
unfold inclusion in |- *.
intros.
split.
split.
unfold no_syn_ops in |- *.
intros.
red in |- *.
intro.
generalize (irreducible_op h o o M N).
intro.
elim H4.

*****
H4 : iff (irreducible h (Mop o M) (Mop o N))\n (and (analysis_def h (Mop o M) (Mop o N))\n (or (not (eq o o)) (not (synthesis (analysis_def h) M N))))
H3 : synthesis h M N
H2 : h (Mop o M) (Mop o N)
M,N : Msg
o : op
H1 : forall (M N : Msg) (_ : irreducible h M N), h M N
H0 : forall (M N : Msg) (_ : h M N), irreducible h M N
H : and (inclusion h (irreducible h)) (inclusion (irreducible h) h)
h : hedge
*****
forall (_ : forall _ : irreducible h (Mop o M) (Mop o N), and (analysis_def h (Mop o M) (Mop o N)) (or (not (eq o o)) (not (synthesis (analysis_def h) M N)))) (_ : forall _ : and (analysis_def h (Mop o M) (Mop o N)) (or (not (eq o o)) (not (synthesis (analysis_def h) M N))), irreducible h (Mop o M) (Mop o N)), False
+++++
intros.
-----
Lemma irreducible_impl_cond_irr : forall h : hedge, is_irreducible h -> cond_irr h.
unfold cond_irr in |- *.
unfold is_irreducible in |- *.
unfold equal in |- *.
intros.
elim H.
unfold inclusion in |- *.
intros.
split.
split.
unfold no_syn_ops in |- *.
intros.
red in |- *.
intro.
generalize (irreducible_op h o o M N).
intro.
elim H4.
intros.

*****
H6 : forall\n _ : and (analysis_def h (Mop o M) (Mop o N))\n (or (not (eq o o)) (not (synthesis (analysis_def h) M N))),\nirreducible h (Mop o M) (Mop o N)
H5 : forall _ : irreducible h (Mop o M) (Mop o N),\nand (analysis_def h (Mop o M) (Mop o N))\n (or (not (eq o o)) (not (synthesis (analysis_def h) M N)))
H4 : iff (irreducible h (Mop o M) (Mop o N))\n (and (analysis_def h (Mop o M) (Mop o N))\n (or (not (eq o o)) (not (synthesis (analysis_def h) M N))))
H3 : synthesis h M N
H2 : h (Mop o M) (Mop o N)
M,N : Msg
o : op
H1 : forall (M N : Msg) (_ : irreducible h M N), h M N
H0 : forall (M N : Msg) (_ : h M N), irreducible h M N
H : and (inclusion h (irreducible h)) (inclusion (irreducible h) h)
h : hedge
*****
False
+++++
generalize (H0 (Mop o M) (Mop o N) H2).
-----
Lemma irreducible_impl_cond_irr : forall h : hedge, is_irreducible h -> cond_irr h.
unfold cond_irr in |- *.
unfold is_irreducible in |- *.
unfold equal in |- *.
intros.
elim H.
unfold inclusion in |- *.
intros.
split.
split.
unfold no_syn_ops in |- *.
intros.
red in |- *.
intro.
generalize (irreducible_op h o o M N).
intro.
elim H4.
intros.
generalize (H0 (Mop o M) (Mop o N) H2).

*****
H6 : forall\n _ : and (analysis_def h (Mop o M) (Mop o N))\n (or (not (eq o o)) (not (synthesis (analysis_def h) M N))),\nirreducible h (Mop o M) (Mop o N)
H5 : forall _ : irreducible h (Mop o M) (Mop o N),\nand (analysis_def h (Mop o M) (Mop o N))\n (or (not (eq o o)) (not (synthesis (analysis_def h) M N)))
H4 : iff (irreducible h (Mop o M) (Mop o N))\n (and (analysis_def h (Mop o M) (Mop o N))\n (or (not (eq o o)) (not (synthesis (analysis_def h) M N))))
H3 : synthesis h M N
H2 : h (Mop o M) (Mop o N)
M,N : Msg
o : op
H1 : forall (M N : Msg) (_ : irreducible h M N), h M N
H0 : forall (M N : Msg) (_ : h M N), irreducible h M N
H : and (inclusion h (irreducible h)) (inclusion (irreducible h) h)
h : hedge
*****
forall _ : irreducible h (Mop o M) (Mop o N), False
+++++
intro.
-----
Lemma irreducible_impl_cond_irr : forall h : hedge, is_irreducible h -> cond_irr h.
unfold cond_irr in |- *.
unfold is_irreducible in |- *.
unfold equal in |- *.
intros.
elim H.
unfold inclusion in |- *.
intros.
split.
split.
unfold no_syn_ops in |- *.
intros.
red in |- *.
intro.
generalize (irreducible_op h o o M N).
intro.
elim H4.
intros.
generalize (H0 (Mop o M) (Mop o N) H2).
intro.

*****
H7 : irreducible h (Mop o M) (Mop o N)
H6 : forall\n _ : and (analysis_def h (Mop o M) (Mop o N))\n (or (not (eq o o)) (not (synthesis (analysis_def h) M N))),\nirreducible h (Mop o M) (Mop o N)
H5 : forall _ : irreducible h (Mop o M) (Mop o N),\nand (analysis_def h (Mop o M) (Mop o N))\n (or (not (eq o o)) (not (synthesis (analysis_def h) M N)))
H4 : iff (irreducible h (Mop o M) (Mop o N))\n (and (analysis_def h (Mop o M) (Mop o N))\n (or (not (eq o o)) (not (synthesis (analysis_def h) M N))))
H3 : synthesis h M N
H2 : h (Mop o M) (Mop o N)
M,N : Msg
o : op
H1 : forall (M N : Msg) (_ : irreducible h M N), h M N
H0 : forall (M N : Msg) (_ : h M N), irreducible h M N
H : and (inclusion h (irreducible h)) (inclusion (irreducible h) h)
h : hedge
*****
False
+++++
generalize (H5 H7).
-----
Lemma irreducible_impl_cond_irr : forall h : hedge, is_irreducible h -> cond_irr h.
unfold cond_irr in |- *.
unfold is_irreducible in |- *.
unfold equal in |- *.
intros.
elim H.
unfold inclusion in |- *.
intros.
split.
split.
unfold no_syn_ops in |- *.
intros.
red in |- *.
intro.
generalize (irreducible_op h o o M N).
intro.
elim H4.
intros.
generalize (H0 (Mop o M) (Mop o N) H2).
intro.
generalize (H5 H7).

*****
H7 : irreducible h (Mop o M) (Mop o N)
H6 : forall\n _ : and (analysis_def h (Mop o M) (Mop o N))\n (or (not (eq o o)) (not (synthesis (analysis_def h) M N))),\nirreducible h (Mop o M) (Mop o N)
H5 : forall _ : irreducible h (Mop o M) (Mop o N),\nand (analysis_def h (Mop o M) (Mop o N))\n (or (not (eq o o)) (not (synthesis (analysis_def h) M N)))
H4 : iff (irreducible h (Mop o M) (Mop o N))\n (and (analysis_def h (Mop o M) (Mop o N))\n (or (not (eq o o)) (not (synthesis (analysis_def h) M N))))
H3 : synthesis h M N
H2 : h (Mop o M) (Mop o N)
M,N : Msg
o : op
H1 : forall (M N : Msg) (_ : irreducible h M N), h M N
H0 : forall (M N : Msg) (_ : h M N), irreducible h M N
H : and (inclusion h (irreducible h)) (inclusion (irreducible h) h)
h : hedge
*****
forall _ : and (analysis_def h (Mop o M) (Mop o N)) (or (not (eq o o)) (not (synthesis (analysis_def h) M N))), False
+++++
intro.
-----
Lemma irreducible_impl_cond_irr : forall h : hedge, is_irreducible h -> cond_irr h.
unfold cond_irr in |- *.
unfold is_irreducible in |- *.
unfold equal in |- *.
intros.
elim H.
unfold inclusion in |- *.
intros.
split.
split.
unfold no_syn_ops in |- *.
intros.
red in |- *.
intro.
generalize (irreducible_op h o o M N).
intro.
elim H4.
intros.
generalize (H0 (Mop o M) (Mop o N) H2).
intro.
generalize (H5 H7).
intro.

*****
H8 : and (analysis_def h (Mop o M) (Mop o N))\n (or (not (eq o o)) (not (synthesis (analysis_def h) M N)))
H7 : irreducible h (Mop o M) (Mop o N)
H6 : forall\n _ : and (analysis_def h (Mop o M) (Mop o N))\n (or (not (eq o o)) (not (synthesis (analysis_def h) M N))),\nirreducible h (Mop o M) (Mop o N)
H5 : forall _ : irreducible h (Mop o M) (Mop o N),\nand (analysis_def h (Mop o M) (Mop o N))\n (or (not (eq o o)) (not (synthesis (analysis_def h) M N)))
H4 : iff (irreducible h (Mop o M) (Mop o N))\n (and (analysis_def h (Mop o M) (Mop o N))\n (or (not (eq o o)) (not (synthesis (analysis_def h) M N))))
H3 : synthesis h M N
H2 : h (Mop o M) (Mop o N)
M,N : Msg
o : op
H1 : forall (M N : Msg) (_ : irreducible h M N), h M N
H0 : forall (M N : Msg) (_ : h M N), irreducible h M N
H : and (inclusion h (irreducible h)) (inclusion (irreducible h) h)
h : hedge
*****
False
+++++
elim H8.
-----
Lemma irreducible_impl_cond_irr : forall h : hedge, is_irreducible h -> cond_irr h.
unfold cond_irr in |- *.
unfold is_irreducible in |- *.
unfold equal in |- *.
intros.
elim H.
unfold inclusion in |- *.
intros.
split.
split.
unfold no_syn_ops in |- *.
intros.
red in |- *.
intro.
generalize (irreducible_op h o o M N).
intro.
elim H4.
intros.
generalize (H0 (Mop o M) (Mop o N) H2).
intro.
generalize (H5 H7).
intro.
elim H8.

*****
H8 : and (analysis_def h (Mop o M) (Mop o N))\n (or (not (eq o o)) (not (synthesis (analysis_def h) M N)))
H7 : irreducible h (Mop o M) (Mop o N)
H6 : forall\n _ : and (analysis_def h (Mop o M) (Mop o N))\n (or (not (eq o o)) (not (synthesis (analysis_def h) M N))),\nirreducible h (Mop o M) (Mop o N)
H5 : forall _ : irreducible h (Mop o M) (Mop o N),\nand (analysis_def h (Mop o M) (Mop o N))\n (or (not (eq o o)) (not (synthesis (analysis_def h) M N)))
H4 : iff (irreducible h (Mop o M) (Mop o N))\n (and (analysis_def h (Mop o M) (Mop o N))\n (or (not (eq o o)) (not (synthesis (analysis_def h) M N))))
H3 : synthesis h M N
H2 : h (Mop o M) (Mop o N)
M,N : Msg
o : op
H1 : forall (M N : Msg) (_ : irreducible h M N), h M N
H0 : forall (M N : Msg) (_ : h M N), irreducible h M N
H : and (inclusion h (irreducible h)) (inclusion (irreducible h) h)
h : hedge
*****
forall (_ : analysis_def h (Mop o M) (Mop o N)) (_ : or (not (eq o o)) (not (synthesis (analysis_def h) M N))), False
+++++
intros.
-----
Lemma irreducible_impl_cond_irr : forall h : hedge, is_irreducible h -> cond_irr h.
unfold cond_irr in |- *.
unfold is_irreducible in |- *.
unfold equal in |- *.
intros.
elim H.
unfold inclusion in |- *.
intros.
split.
split.
unfold no_syn_ops in |- *.
intros.
red in |- *.
intro.
generalize (irreducible_op h o o M N).
intro.
elim H4.
intros.
generalize (H0 (Mop o M) (Mop o N) H2).
intro.
generalize (H5 H7).
intro.
elim H8.
intros.

*****
H10 : or (not (eq o o)) (not (synthesis (analysis_def h) M N))
H9 : analysis_def h (Mop o M) (Mop o N)
H8 : and (analysis_def h (Mop o M) (Mop o N))\n (or (not (eq o o)) (not (synthesis (analysis_def h) M N)))
H7 : irreducible h (Mop o M) (Mop o N)
H6 : forall\n _ : and (analysis_def h (Mop o M) (Mop o N))\n (or (not (eq o o)) (not (synthesis (analysis_def h) M N))),\nirreducible h (Mop o M) (Mop o N)
H5 : forall _ : irreducible h (Mop o M) (Mop o N),\nand (analysis_def h (Mop o M) (Mop o N))\n (or (not (eq o o)) (not (synthesis (analysis_def h) M N)))
H4 : iff (irreducible h (Mop o M) (Mop o N))\n (and (analysis_def h (Mop o M) (Mop o N))\n (or (not (eq o o)) (not (synthesis (analysis_def h) M N))))
H3 : synthesis h M N
H2 : h (Mop o M) (Mop o N)
M,N : Msg
o : op
H1 : forall (M N : Msg) (_ : irreducible h M N), h M N
H0 : forall (M N : Msg) (_ : h M N), irreducible h M N
H : and (inclusion h (irreducible h)) (inclusion (irreducible h) h)
h : hedge
*****
False
+++++
case H10.
-----
Lemma irreducible_impl_cond_irr : forall h : hedge, is_irreducible h -> cond_irr h.
unfold cond_irr in |- *.
unfold is_irreducible in |- *.
unfold equal in |- *.
intros.
elim H.
unfold inclusion in |- *.
intros.
split.
split.
unfold no_syn_ops in |- *.
intros.
red in |- *.
intro.
generalize (irreducible_op h o o M N).
intro.
elim H4.
intros.
generalize (H0 (Mop o M) (Mop o N) H2).
intro.
generalize (H5 H7).
intro.
elim H8.
intros.
case H10.

*****
H10 : or (not (eq o o)) (not (synthesis (analysis_def h) M N))
H9 : analysis_def h (Mop o M) (Mop o N)
H8 : and (analysis_def h (Mop o M) (Mop o N))\n (or (not (eq o o)) (not (synthesis (analysis_def h) M N)))
H7 : irreducible h (Mop o M) (Mop o N)
H6 : forall\n _ : and (analysis_def h (Mop o M) (Mop o N))\n (or (not (eq o o)) (not (synthesis (analysis_def h) M N))),\nirreducible h (Mop o M) (Mop o N)
H5 : forall _ : irreducible h (Mop o M) (Mop o N),\nand (analysis_def h (Mop o M) (Mop o N))\n (or (not (eq o o)) (not (synthesis (analysis_def h) M N)))
H4 : iff (irreducible h (Mop o M) (Mop o N))\n (and (analysis_def h (Mop o M) (Mop o N))\n (or (not (eq o o)) (not (synthesis (analysis_def h) M N))))
H3 : synthesis h M N
H2 : h (Mop o M) (Mop o N)
M,N : Msg
o : op
H1 : forall (M N : Msg) (_ : irreducible h M N), h M N
H0 : forall (M N : Msg) (_ : h M N), irreducible h M N
H : and (inclusion h (irreducible h)) (inclusion (irreducible h) h)
h : hedge
*****
forall _ : not (eq o o), False
+++++
tauto.
-----
Lemma irreducible_impl_cond_irr : forall h : hedge, is_irreducible h -> cond_irr h.
unfold cond_irr in |- *.
unfold is_irreducible in |- *.
unfold equal in |- *.
intros.
elim H.
unfold inclusion in |- *.
intros.
split.
split.
unfold no_syn_ops in |- *.
intros.
red in |- *.
intro.
generalize (irreducible_op h o o M N).
intro.
elim H4.
intros.
generalize (H0 (Mop o M) (Mop o N) H2).
intro.
generalize (H5 H7).
intro.
elim H8.
intros.
case H10.

*****
H10 : or (not (eq o o)) (not (synthesis (analysis_def h) M N))
H9 : analysis_def h (Mop o M) (Mop o N)
H8 : and (analysis_def h (Mop o M) (Mop o N))\n (or (not (eq o o)) (not (synthesis (analysis_def h) M N)))
H7 : irreducible h (Mop o M) (Mop o N)
H6 : forall\n _ : and (analysis_def h (Mop o M) (Mop o N))\n (or (not (eq o o)) (not (synthesis (analysis_def h) M N))),\nirreducible h (Mop o M) (Mop o N)
H5 : forall _ : irreducible h (Mop o M) (Mop o N),\nand (analysis_def h (Mop o M) (Mop o N))\n (or (not (eq o o)) (not (synthesis (analysis_def h) M N)))
H4 : iff (irreducible h (Mop o M) (Mop o N))\n (and (analysis_def h (Mop o M) (Mop o N))\n (or (not (eq o o)) (not (synthesis (analysis_def h) M N))))
H3 : synthesis h M N
H2 : h (Mop o M) (Mop o N)
M,N : Msg
o : op
H1 : forall (M N : Msg) (_ : irreducible h M N), h M N
H0 : forall (M N : Msg) (_ : h M N), irreducible h M N
H : and (inclusion h (irreducible h)) (inclusion (irreducible h) h)
h : hedge
*****
forall _ : not (synthesis (analysis_def h) M N), False
+++++
intro.
-----
Lemma irreducible_impl_cond_irr : forall h : hedge, is_irreducible h -> cond_irr h.
unfold cond_irr in |- *.
unfold is_irreducible in |- *.
unfold equal in |- *.
intros.
elim H.
unfold inclusion in |- *.
intros.
split.
split.
unfold no_syn_ops in |- *.
intros.
red in |- *.
intro.
generalize (irreducible_op h o o M N).
intro.
elim H4.
intros.
generalize (H0 (Mop o M) (Mop o N) H2).
intro.
generalize (H5 H7).
intro.
elim H8.
intros.
case H10.
intro.

*****
H11 : not (synthesis (analysis_def h) M N)
H10 : or (not (eq o o)) (not (synthesis (analysis_def h) M N))
H9 : analysis_def h (Mop o M) (Mop o N)
H8 : and (analysis_def h (Mop o M) (Mop o N))\n (or (not (eq o o)) (not (synthesis (analysis_def h) M N)))
H7 : irreducible h (Mop o M) (Mop o N)
H6 : forall\n _ : and (analysis_def h (Mop o M) (Mop o N))\n (or (not (eq o o)) (not (synthesis (analysis_def h) M N))),\nirreducible h (Mop o M) (Mop o N)
H5 : forall _ : irreducible h (Mop o M) (Mop o N),\nand (analysis_def h (Mop o M) (Mop o N))\n (or (not (eq o o)) (not (synthesis (analysis_def h) M N)))
H4 : iff (irreducible h (Mop o M) (Mop o N))\n (and (analysis_def h (Mop o M) (Mop o N))\n (or (not (eq o o)) (not (synthesis (analysis_def h) M N))))
H3 : synthesis h M N
H2 : h (Mop o M) (Mop o N)
M,N : Msg
o : op
H1 : forall (M N : Msg) (_ : irreducible h M N), h M N
H0 : forall (M N : Msg) (_ : h M N), irreducible h M N
H : and (inclusion h (irreducible h)) (inclusion (irreducible h) h)
h : hedge
*****
False
+++++
apply H11.
-----
Lemma irreducible_impl_cond_irr : forall h : hedge, is_irreducible h -> cond_irr h.
unfold cond_irr in |- *.
unfold is_irreducible in |- *.
unfold equal in |- *.
intros.
elim H.
unfold inclusion in |- *.
intros.
split.
split.
unfold no_syn_ops in |- *.
intros.
red in |- *.
intro.
generalize (irreducible_op h o o M N).
intro.
elim H4.
intros.
generalize (H0 (Mop o M) (Mop o N) H2).
intro.
generalize (H5 H7).
intro.
elim H8.
intros.
case H10.
intro.
apply H11.

*****
H11 : not (synthesis (analysis_def h) M N)
H10 : or (not (eq o o)) (not (synthesis (analysis_def h) M N))
H9 : analysis_def h (Mop o M) (Mop o N)
H8 : and (analysis_def h (Mop o M) (Mop o N))\n (or (not (eq o o)) (not (synthesis (analysis_def h) M N)))
H7 : irreducible h (Mop o M) (Mop o N)
H6 : forall\n _ : and (analysis_def h (Mop o M) (Mop o N))\n (or (not (eq o o)) (not (synthesis (analysis_def h) M N))),\nirreducible h (Mop o M) (Mop o N)
H5 : forall _ : irreducible h (Mop o M) (Mop o N),\nand (analysis_def h (Mop o M) (Mop o N))\n (or (not (eq o o)) (not (synthesis (analysis_def h) M N)))
H4 : iff (irreducible h (Mop o M) (Mop o N))\n (and (analysis_def h (Mop o M) (Mop o N))\n (or (not (eq o o)) (not (synthesis (analysis_def h) M N))))
H3 : synthesis h M N
H2 : h (Mop o M) (Mop o N)
M,N : Msg
o : op
H1 : forall (M N : Msg) (_ : irreducible h M N), h M N
H0 : forall (M N : Msg) (_ : h M N), irreducible h M N
H : and (inclusion h (irreducible h)) (inclusion (irreducible h) h)
h : hedge
*****
synthesis (analysis_def h) M N
+++++
generalize (h_le_h_ana_h h).
-----
Lemma irreducible_impl_cond_irr : forall h : hedge, is_irreducible h -> cond_irr h.
unfold cond_irr in |- *.
unfold is_irreducible in |- *.
unfold equal in |- *.
intros.
elim H.
unfold inclusion in |- *.
intros.
split.
split.
unfold no_syn_ops in |- *.
intros.
red in |- *.
intro.
generalize (irreducible_op h o o M N).
intro.
elim H4.
intros.
generalize (H0 (Mop o M) (Mop o N) H2).
intro.
generalize (H5 H7).
intro.
elim H8.
intros.
case H10.
intro.
apply H11.
generalize (h_le_h_ana_h h).

*****
H11 : not (synthesis (analysis_def h) M N)
H10 : or (not (eq o o)) (not (synthesis (analysis_def h) M N))
H9 : analysis_def h (Mop o M) (Mop o N)
H8 : and (analysis_def h (Mop o M) (Mop o N))\n (or (not (eq o o)) (not (synthesis (analysis_def h) M N)))
H7 : irreducible h (Mop o M) (Mop o N)
H6 : forall\n _ : and (analysis_def h (Mop o M) (Mop o N))\n (or (not (eq o o)) (not (synthesis (analysis_def h) M N))),\nirreducible h (Mop o M) (Mop o N)
H5 : forall _ : irreducible h (Mop o M) (Mop o N),\nand (analysis_def h (Mop o M) (Mop o N))\n (or (not (eq o o)) (not (synthesis (analysis_def h) M N)))
H4 : iff (irreducible h (Mop o M) (Mop o N))\n (and (analysis_def h (Mop o M) (Mop o N))\n (or (not (eq o o)) (not (synthesis (analysis_def h) M N))))
H3 : synthesis h M N
H2 : h (Mop o M) (Mop o N)
M,N : Msg
o : op
H1 : forall (M N : Msg) (_ : irreducible h M N), h M N
H0 : forall (M N : Msg) (_ : h M N), irreducible h M N
H : and (inclusion h (irreducible h)) (inclusion (irreducible h) h)
h : hedge
*****
forall _ : le_h h (analysis_def h), synthesis (analysis_def h) M N
+++++
unfold le_h in |- *.
-----
Lemma irreducible_impl_cond_irr : forall h : hedge, is_irreducible h -> cond_irr h.
unfold cond_irr in |- *.
unfold is_irreducible in |- *.
unfold equal in |- *.
intros.
elim H.
unfold inclusion in |- *.
intros.
split.
split.
unfold no_syn_ops in |- *.
intros.
red in |- *.
intro.
generalize (irreducible_op h o o M N).
intro.
elim H4.
intros.
generalize (H0 (Mop o M) (Mop o N) H2).
intro.
generalize (H5 H7).
intro.
elim H8.
intros.
case H10.
intro.
apply H11.
generalize (h_le_h_ana_h h).
unfold le_h in |- *.

*****
H11 : not (synthesis (analysis_def h) M N)
H10 : or (not (eq o o)) (not (synthesis (analysis_def h) M N))
H9 : analysis_def h (Mop o M) (Mop o N)
H8 : and (analysis_def h (Mop o M) (Mop o N))\n (or (not (eq o o)) (not (synthesis (analysis_def h) M N)))
H7 : irreducible h (Mop o M) (Mop o N)
H6 : forall\n _ : and (analysis_def h (Mop o M) (Mop o N))\n (or (not (eq o o)) (not (synthesis (analysis_def h) M N))),\nirreducible h (Mop o M) (Mop o N)
H5 : forall _ : irreducible h (Mop o M) (Mop o N),\nand (analysis_def h (Mop o M) (Mop o N))\n (or (not (eq o o)) (not (synthesis (analysis_def h) M N)))
H4 : iff (irreducible h (Mop o M) (Mop o N))\n (and (analysis_def h (Mop o M) (Mop o N))\n (or (not (eq o o)) (not (synthesis (analysis_def h) M N))))
H3 : synthesis h M N
H2 : h (Mop o M) (Mop o N)
M,N : Msg
o : op
H1 : forall (M N : Msg) (_ : irreducible h M N), h M N
H0 : forall (M N : Msg) (_ : h M N), irreducible h M N
H : and (inclusion h (irreducible h)) (inclusion (irreducible h) h)
h : hedge
*****
forall _ : inclusion (synthesis h) (synthesis (analysis_def h)), synthesis (analysis_def h) M N
+++++
unfold inclusion in |- *.
-----
Lemma irreducible_impl_cond_irr : forall h : hedge, is_irreducible h -> cond_irr h.
unfold cond_irr in |- *.
unfold is_irreducible in |- *.
unfold equal in |- *.
intros.
elim H.
unfold inclusion in |- *.
intros.
split.
split.
unfold no_syn_ops in |- *.
intros.
red in |- *.
intro.
generalize (irreducible_op h o o M N).
intro.
elim H4.
intros.
generalize (H0 (Mop o M) (Mop o N) H2).
intro.
generalize (H5 H7).
intro.
elim H8.
intros.
case H10.
intro.
apply H11.
generalize (h_le_h_ana_h h).
unfold le_h in |- *.
unfold inclusion in |- *.

*****
H11 : not (synthesis (analysis_def h) M N)
H10 : or (not (eq o o)) (not (synthesis (analysis_def h) M N))
H9 : analysis_def h (Mop o M) (Mop o N)
H8 : and (analysis_def h (Mop o M) (Mop o N))\n (or (not (eq o o)) (not (synthesis (analysis_def h) M N)))
H7 : irreducible h (Mop o M) (Mop o N)
H6 : forall\n _ : and (analysis_def h (Mop o M) (Mop o N))\n (or (not (eq o o)) (not (synthesis (analysis_def h) M N))),\nirreducible h (Mop o M) (Mop o N)
H5 : forall _ : irreducible h (Mop o M) (Mop o N),\nand (analysis_def h (Mop o M) (Mop o N))\n (or (not (eq o o)) (not (synthesis (analysis_def h) M N)))
H4 : iff (irreducible h (Mop o M) (Mop o N))\n (and (analysis_def h (Mop o M) (Mop o N))\n (or (not (eq o o)) (not (synthesis (analysis_def h) M N))))
H3 : synthesis h M N
H2 : h (Mop o M) (Mop o N)
M,N : Msg
o : op
H1 : forall (M N : Msg) (_ : irreducible h M N), h M N
H0 : forall (M N : Msg) (_ : h M N), irreducible h M N
H : and (inclusion h (irreducible h)) (inclusion (irreducible h) h)
h : hedge
*****
forall _ : forall (M N : Msg) (_ : synthesis h M N), synthesis (analysis_def h) M N, synthesis (analysis_def h) M N
+++++
auto.
-----
Lemma irreducible_impl_cond_irr : forall h : hedge, is_irreducible h -> cond_irr h.
unfold cond_irr in |- *.
unfold is_irreducible in |- *.
unfold equal in |- *.
intros.
elim H.
unfold inclusion in |- *.
intros.
split.
split.

*****
H1 : forall (M N : Msg) (_ : irreducible h M N), h M N
H0 : forall (M N : Msg) (_ : h M N), irreducible h M N
H : and (inclusion h (irreducible h)) (inclusion (irreducible h) h)
h : hedge
*****
and (no_syn_cyph h) (cyph_dec h)
+++++
split.
-----
Lemma irreducible_impl_cond_irr : forall h : hedge, is_irreducible h -> cond_irr h.
unfold cond_irr in |- *.
unfold is_irreducible in |- *.
unfold equal in |- *.
intros.
elim H.
unfold inclusion in |- *.
intros.
split.
split.
split.

*****
H1 : forall (M N : Msg) (_ : irreducible h M N), h M N
H0 : forall (M N : Msg) (_ : h M N), irreducible h M N
H : and (inclusion h (irreducible h)) (inclusion (irreducible h) h)
h : hedge
*****
no_syn_cyph h
+++++
unfold no_syn_cyph in |- *.
-----
Lemma irreducible_impl_cond_irr : forall h : hedge, is_irreducible h -> cond_irr h.
unfold cond_irr in |- *.
unfold is_irreducible in |- *.
unfold equal in |- *.
intros.
elim H.
unfold inclusion in |- *.
intros.
split.
split.
split.
unfold no_syn_cyph in |- *.

*****
H1 : forall (M N : Msg) (_ : irreducible h M N), h M N
H0 : forall (M N : Msg) (_ : h M N), irreducible h M N
H : and (inclusion h (irreducible h)) (inclusion (irreducible h) h)
h : hedge
*****
forall (M N K L : Msg) (_ : h (MEnc M K) (MEnc N L)), or (not (synthesis h M N)) (not (synthesis h K L))
+++++
intros.
-----
Lemma irreducible_impl_cond_irr : forall h : hedge, is_irreducible h -> cond_irr h.
unfold cond_irr in |- *.
unfold is_irreducible in |- *.
unfold equal in |- *.
intros.
elim H.
unfold inclusion in |- *.
intros.
split.
split.
split.
unfold no_syn_cyph in |- *.
intros.

*****
H2 : h (MEnc M K) (MEnc N L)
M,N,K,L : Msg
H1 : forall (M N : Msg) (_ : irreducible h M N), h M N
H0 : forall (M N : Msg) (_ : h M N), irreducible h M N
H : and (inclusion h (irreducible h)) (inclusion (irreducible h) h)
h : hedge
*****
or (not (synthesis h M N)) (not (synthesis h K L))
+++++
generalize (irreducible_enc h M N K L).
-----
Lemma irreducible_impl_cond_irr : forall h : hedge, is_irreducible h -> cond_irr h.
unfold cond_irr in |- *.
unfold is_irreducible in |- *.
unfold equal in |- *.
intros.
elim H.
unfold inclusion in |- *.
intros.
split.
split.
split.
unfold no_syn_cyph in |- *.
intros.
generalize (irreducible_enc h M N K L).

*****
H2 : h (MEnc M K) (MEnc N L)
M,N,K,L : Msg
H1 : forall (M N : Msg) (_ : irreducible h M N), h M N
H0 : forall (M N : Msg) (_ : h M N), irreducible h M N
H : and (inclusion h (irreducible h)) (inclusion (irreducible h) h)
h : hedge
*****
forall _ : iff (irreducible h (MEnc M K) (MEnc N L)) (and (analysis_def h (MEnc M K) (MEnc N L)) (or (not (synthesis (analysis_def h) M N)) (not (synthesis (analysis_def h) K L)))), or (not (synthesis h M N)) (not (synthesis h K L))
+++++
intro.
-----
Lemma irreducible_impl_cond_irr : forall h : hedge, is_irreducible h -> cond_irr h.
unfold cond_irr in |- *.
unfold is_irreducible in |- *.
unfold equal in |- *.
intros.
elim H.
unfold inclusion in |- *.
intros.
split.
split.
split.
unfold no_syn_cyph in |- *.
intros.
generalize (irreducible_enc h M N K L).
intro.

*****
H3 : iff (irreducible h (MEnc M K) (MEnc N L))\n (and (analysis_def h (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L))))
H2 : h (MEnc M K) (MEnc N L)
M,N,K,L : Msg
H1 : forall (M N : Msg) (_ : irreducible h M N), h M N
H0 : forall (M N : Msg) (_ : h M N), irreducible h M N
H : and (inclusion h (irreducible h)) (inclusion (irreducible h) h)
h : hedge
*****
or (not (synthesis h M N)) (not (synthesis h K L))
+++++
elim H3.
-----
Lemma irreducible_impl_cond_irr : forall h : hedge, is_irreducible h -> cond_irr h.
unfold cond_irr in |- *.
unfold is_irreducible in |- *.
unfold equal in |- *.
intros.
elim H.
unfold inclusion in |- *.
intros.
split.
split.
split.
unfold no_syn_cyph in |- *.
intros.
generalize (irreducible_enc h M N K L).
intro.
elim H3.

*****
H3 : iff (irreducible h (MEnc M K) (MEnc N L))\n (and (analysis_def h (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L))))
H2 : h (MEnc M K) (MEnc N L)
M,N,K,L : Msg
H1 : forall (M N : Msg) (_ : irreducible h M N), h M N
H0 : forall (M N : Msg) (_ : h M N), irreducible h M N
H : and (inclusion h (irreducible h)) (inclusion (irreducible h) h)
h : hedge
*****
forall (_ : forall _ : irreducible h (MEnc M K) (MEnc N L), and (analysis_def h (MEnc M K) (MEnc N L)) (or (not (synthesis (analysis_def h) M N)) (not (synthesis (analysis_def h) K L)))) (_ : forall _ : and (analysis_def h (MEnc M K) (MEnc N L)) (or (not (synthesis (analysis_def h) M N)) (not (synthesis (analysis_def h) K L))), irreducible h (MEnc M K) (MEnc N L)), or (not (synthesis h M N)) (not (synthesis h K L))
+++++
intros.
-----
Lemma irreducible_impl_cond_irr : forall h : hedge, is_irreducible h -> cond_irr h.
unfold cond_irr in |- *.
unfold is_irreducible in |- *.
unfold equal in |- *.
intros.
elim H.
unfold inclusion in |- *.
intros.
split.
split.
split.
unfold no_syn_cyph in |- *.
intros.
generalize (irreducible_enc h M N K L).
intro.
elim H3.
intros.

*****
H5 : forall\n _ : and (analysis_def h (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L))),\nirreducible h (MEnc M K) (MEnc N L)
H4 : forall _ : irreducible h (MEnc M K) (MEnc N L),\nand (analysis_def h (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L)))
H3 : iff (irreducible h (MEnc M K) (MEnc N L))\n (and (analysis_def h (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L))))
H2 : h (MEnc M K) (MEnc N L)
M,N,K,L : Msg
H1 : forall (M N : Msg) (_ : irreducible h M N), h M N
H0 : forall (M N : Msg) (_ : h M N), irreducible h M N
H : and (inclusion h (irreducible h)) (inclusion (irreducible h) h)
h : hedge
*****
or (not (synthesis h M N)) (not (synthesis h K L))
+++++
generalize (H4 (H0 (MEnc M K) (MEnc N L) H2)).
-----
Lemma irreducible_impl_cond_irr : forall h : hedge, is_irreducible h -> cond_irr h.
unfold cond_irr in |- *.
unfold is_irreducible in |- *.
unfold equal in |- *.
intros.
elim H.
unfold inclusion in |- *.
intros.
split.
split.
split.
unfold no_syn_cyph in |- *.
intros.
generalize (irreducible_enc h M N K L).
intro.
elim H3.
intros.
generalize (H4 (H0 (MEnc M K) (MEnc N L) H2)).

*****
H5 : forall\n _ : and (analysis_def h (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L))),\nirreducible h (MEnc M K) (MEnc N L)
H4 : forall _ : irreducible h (MEnc M K) (MEnc N L),\nand (analysis_def h (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L)))
H3 : iff (irreducible h (MEnc M K) (MEnc N L))\n (and (analysis_def h (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L))))
H2 : h (MEnc M K) (MEnc N L)
M,N,K,L : Msg
H1 : forall (M N : Msg) (_ : irreducible h M N), h M N
H0 : forall (M N : Msg) (_ : h M N), irreducible h M N
H : and (inclusion h (irreducible h)) (inclusion (irreducible h) h)
h : hedge
*****
forall _ : and (analysis_def h (MEnc M K) (MEnc N L)) (or (not (synthesis (analysis_def h) M N)) (not (synthesis (analysis_def h) K L))), or (not (synthesis h M N)) (not (synthesis h K L))
+++++
intro.
-----
Lemma irreducible_impl_cond_irr : forall h : hedge, is_irreducible h -> cond_irr h.
unfold cond_irr in |- *.
unfold is_irreducible in |- *.
unfold equal in |- *.
intros.
elim H.
unfold inclusion in |- *.
intros.
split.
split.
split.
unfold no_syn_cyph in |- *.
intros.
generalize (irreducible_enc h M N K L).
intro.
elim H3.
intros.
generalize (H4 (H0 (MEnc M K) (MEnc N L) H2)).
intro.

*****
H6 : and (analysis_def h (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L)))
H5 : forall\n _ : and (analysis_def h (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L))),\nirreducible h (MEnc M K) (MEnc N L)
H4 : forall _ : irreducible h (MEnc M K) (MEnc N L),\nand (analysis_def h (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L)))
H3 : iff (irreducible h (MEnc M K) (MEnc N L))\n (and (analysis_def h (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L))))
H2 : h (MEnc M K) (MEnc N L)
M,N,K,L : Msg
H1 : forall (M N : Msg) (_ : irreducible h M N), h M N
H0 : forall (M N : Msg) (_ : h M N), irreducible h M N
H : and (inclusion h (irreducible h)) (inclusion (irreducible h) h)
h : hedge
*****
or (not (synthesis h M N)) (not (synthesis h K L))
+++++
elim H6.
-----
Lemma irreducible_impl_cond_irr : forall h : hedge, is_irreducible h -> cond_irr h.
unfold cond_irr in |- *.
unfold is_irreducible in |- *.
unfold equal in |- *.
intros.
elim H.
unfold inclusion in |- *.
intros.
split.
split.
split.
unfold no_syn_cyph in |- *.
intros.
generalize (irreducible_enc h M N K L).
intro.
elim H3.
intros.
generalize (H4 (H0 (MEnc M K) (MEnc N L) H2)).
intro.
elim H6.

*****
H6 : and (analysis_def h (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L)))
H5 : forall\n _ : and (analysis_def h (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L))),\nirreducible h (MEnc M K) (MEnc N L)
H4 : forall _ : irreducible h (MEnc M K) (MEnc N L),\nand (analysis_def h (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L)))
H3 : iff (irreducible h (MEnc M K) (MEnc N L))\n (and (analysis_def h (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L))))
H2 : h (MEnc M K) (MEnc N L)
M,N,K,L : Msg
H1 : forall (M N : Msg) (_ : irreducible h M N), h M N
H0 : forall (M N : Msg) (_ : h M N), irreducible h M N
H : and (inclusion h (irreducible h)) (inclusion (irreducible h) h)
h : hedge
*****
forall (_ : analysis_def h (MEnc M K) (MEnc N L)) (_ : or (not (synthesis (analysis_def h) M N)) (not (synthesis (analysis_def h) K L))), or (not (synthesis h M N)) (not (synthesis h K L))
+++++
intros.
-----
Lemma irreducible_impl_cond_irr : forall h : hedge, is_irreducible h -> cond_irr h.
unfold cond_irr in |- *.
unfold is_irreducible in |- *.
unfold equal in |- *.
intros.
elim H.
unfold inclusion in |- *.
intros.
split.
split.
split.
unfold no_syn_cyph in |- *.
intros.
generalize (irreducible_enc h M N K L).
intro.
elim H3.
intros.
generalize (H4 (H0 (MEnc M K) (MEnc N L) H2)).
intro.
elim H6.
intros.

*****
H8 : or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L))
H7 : analysis_def h (MEnc M K) (MEnc N L)
H6 : and (analysis_def h (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L)))
H5 : forall\n _ : and (analysis_def h (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L))),\nirreducible h (MEnc M K) (MEnc N L)
H4 : forall _ : irreducible h (MEnc M K) (MEnc N L),\nand (analysis_def h (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L)))
H3 : iff (irreducible h (MEnc M K) (MEnc N L))\n (and (analysis_def h (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L))))
H2 : h (MEnc M K) (MEnc N L)
M,N,K,L : Msg
H1 : forall (M N : Msg) (_ : irreducible h M N), h M N
H0 : forall (M N : Msg) (_ : h M N), irreducible h M N
H : and (inclusion h (irreducible h)) (inclusion (irreducible h) h)
h : hedge
*****
or (not (synthesis h M N)) (not (synthesis h K L))
+++++
case H8.
-----
Lemma irreducible_impl_cond_irr : forall h : hedge, is_irreducible h -> cond_irr h.
unfold cond_irr in |- *.
unfold is_irreducible in |- *.
unfold equal in |- *.
intros.
elim H.
unfold inclusion in |- *.
intros.
split.
split.
split.
unfold no_syn_cyph in |- *.
intros.
generalize (irreducible_enc h M N K L).
intro.
elim H3.
intros.
generalize (H4 (H0 (MEnc M K) (MEnc N L) H2)).
intro.
elim H6.
intros.
case H8.

*****
H8 : or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L))
H7 : analysis_def h (MEnc M K) (MEnc N L)
H6 : and (analysis_def h (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L)))
H5 : forall\n _ : and (analysis_def h (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L))),\nirreducible h (MEnc M K) (MEnc N L)
H4 : forall _ : irreducible h (MEnc M K) (MEnc N L),\nand (analysis_def h (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L)))
H3 : iff (irreducible h (MEnc M K) (MEnc N L))\n (and (analysis_def h (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L))))
H2 : h (MEnc M K) (MEnc N L)
M,N,K,L : Msg
H1 : forall (M N : Msg) (_ : irreducible h M N), h M N
H0 : forall (M N : Msg) (_ : h M N), irreducible h M N
H : and (inclusion h (irreducible h)) (inclusion (irreducible h) h)
h : hedge
*****
forall _ : not (synthesis (analysis_def h) M N), or (not (synthesis h M N)) (not (synthesis h K L))
+++++
intro.
-----
Lemma irreducible_impl_cond_irr : forall h : hedge, is_irreducible h -> cond_irr h.
unfold cond_irr in |- *.
unfold is_irreducible in |- *.
unfold equal in |- *.
intros.
elim H.
unfold inclusion in |- *.
intros.
split.
split.
split.
unfold no_syn_cyph in |- *.
intros.
generalize (irreducible_enc h M N K L).
intro.
elim H3.
intros.
generalize (H4 (H0 (MEnc M K) (MEnc N L) H2)).
intro.
elim H6.
intros.
case H8.
intro.

*****
H9 : not (synthesis (analysis_def h) M N)
H8 : or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L))
H7 : analysis_def h (MEnc M K) (MEnc N L)
H6 : and (analysis_def h (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L)))
H5 : forall\n _ : and (analysis_def h (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L))),\nirreducible h (MEnc M K) (MEnc N L)
H4 : forall _ : irreducible h (MEnc M K) (MEnc N L),\nand (analysis_def h (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L)))
H3 : iff (irreducible h (MEnc M K) (MEnc N L))\n (and (analysis_def h (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L))))
H2 : h (MEnc M K) (MEnc N L)
M,N,K,L : Msg
H1 : forall (M N : Msg) (_ : irreducible h M N), h M N
H0 : forall (M N : Msg) (_ : h M N), irreducible h M N
H : and (inclusion h (irreducible h)) (inclusion (irreducible h) h)
h : hedge
*****
or (not (synthesis h M N)) (not (synthesis h K L))
+++++
left.
-----
Lemma irreducible_impl_cond_irr : forall h : hedge, is_irreducible h -> cond_irr h.
unfold cond_irr in |- *.
unfold is_irreducible in |- *.
unfold equal in |- *.
intros.
elim H.
unfold inclusion in |- *.
intros.
split.
split.
split.
unfold no_syn_cyph in |- *.
intros.
generalize (irreducible_enc h M N K L).
intro.
elim H3.
intros.
generalize (H4 (H0 (MEnc M K) (MEnc N L) H2)).
intro.
elim H6.
intros.
case H8.
intro.
left.

*****
H9 : not (synthesis (analysis_def h) M N)
H8 : or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L))
H7 : analysis_def h (MEnc M K) (MEnc N L)
H6 : and (analysis_def h (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L)))
H5 : forall\n _ : and (analysis_def h (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L))),\nirreducible h (MEnc M K) (MEnc N L)
H4 : forall _ : irreducible h (MEnc M K) (MEnc N L),\nand (analysis_def h (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L)))
H3 : iff (irreducible h (MEnc M K) (MEnc N L))\n (and (analysis_def h (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L))))
H2 : h (MEnc M K) (MEnc N L)
M,N,K,L : Msg
H1 : forall (M N : Msg) (_ : irreducible h M N), h M N
H0 : forall (M N : Msg) (_ : h M N), irreducible h M N
H : and (inclusion h (irreducible h)) (inclusion (irreducible h) h)
h : hedge
*****
not (synthesis h M N)
+++++
red in |- *.
-----
Lemma irreducible_impl_cond_irr : forall h : hedge, is_irreducible h -> cond_irr h.
unfold cond_irr in |- *.
unfold is_irreducible in |- *.
unfold equal in |- *.
intros.
elim H.
unfold inclusion in |- *.
intros.
split.
split.
split.
unfold no_syn_cyph in |- *.
intros.
generalize (irreducible_enc h M N K L).
intro.
elim H3.
intros.
generalize (H4 (H0 (MEnc M K) (MEnc N L) H2)).
intro.
elim H6.
intros.
case H8.
intro.
left.
red in |- *.

*****
H9 : not (synthesis (analysis_def h) M N)
H8 : or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L))
H7 : analysis_def h (MEnc M K) (MEnc N L)
H6 : and (analysis_def h (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L)))
H5 : forall\n _ : and (analysis_def h (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L))),\nirreducible h (MEnc M K) (MEnc N L)
H4 : forall _ : irreducible h (MEnc M K) (MEnc N L),\nand (analysis_def h (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L)))
H3 : iff (irreducible h (MEnc M K) (MEnc N L))\n (and (analysis_def h (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L))))
H2 : h (MEnc M K) (MEnc N L)
M,N,K,L : Msg
H1 : forall (M N : Msg) (_ : irreducible h M N), h M N
H0 : forall (M N : Msg) (_ : h M N), irreducible h M N
H : and (inclusion h (irreducible h)) (inclusion (irreducible h) h)
h : hedge
*****
forall _ : synthesis h M N, False
+++++
intro.
-----
Lemma irreducible_impl_cond_irr : forall h : hedge, is_irreducible h -> cond_irr h.
unfold cond_irr in |- *.
unfold is_irreducible in |- *.
unfold equal in |- *.
intros.
elim H.
unfold inclusion in |- *.
intros.
split.
split.
split.
unfold no_syn_cyph in |- *.
intros.
generalize (irreducible_enc h M N K L).
intro.
elim H3.
intros.
generalize (H4 (H0 (MEnc M K) (MEnc N L) H2)).
intro.
elim H6.
intros.
case H8.
intro.
left.
red in |- *.
intro.

*****
H10 : synthesis h M N
H9 : not (synthesis (analysis_def h) M N)
H8 : or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L))
H7 : analysis_def h (MEnc M K) (MEnc N L)
H6 : and (analysis_def h (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L)))
H5 : forall\n _ : and (analysis_def h (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L))),\nirreducible h (MEnc M K) (MEnc N L)
H4 : forall _ : irreducible h (MEnc M K) (MEnc N L),\nand (analysis_def h (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L)))
H3 : iff (irreducible h (MEnc M K) (MEnc N L))\n (and (analysis_def h (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L))))
H2 : h (MEnc M K) (MEnc N L)
M,N,K,L : Msg
H1 : forall (M N : Msg) (_ : irreducible h M N), h M N
H0 : forall (M N : Msg) (_ : h M N), irreducible h M N
H : and (inclusion h (irreducible h)) (inclusion (irreducible h) h)
h : hedge
*****
False
+++++
apply H9.
-----
Lemma irreducible_impl_cond_irr : forall h : hedge, is_irreducible h -> cond_irr h.
unfold cond_irr in |- *.
unfold is_irreducible in |- *.
unfold equal in |- *.
intros.
elim H.
unfold inclusion in |- *.
intros.
split.
split.
split.
unfold no_syn_cyph in |- *.
intros.
generalize (irreducible_enc h M N K L).
intro.
elim H3.
intros.
generalize (H4 (H0 (MEnc M K) (MEnc N L) H2)).
intro.
elim H6.
intros.
case H8.
intro.
left.
red in |- *.
intro.
apply H9.

*****
H10 : synthesis h M N
H9 : not (synthesis (analysis_def h) M N)
H8 : or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L))
H7 : analysis_def h (MEnc M K) (MEnc N L)
H6 : and (analysis_def h (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L)))
H5 : forall\n _ : and (analysis_def h (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L))),\nirreducible h (MEnc M K) (MEnc N L)
H4 : forall _ : irreducible h (MEnc M K) (MEnc N L),\nand (analysis_def h (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L)))
H3 : iff (irreducible h (MEnc M K) (MEnc N L))\n (and (analysis_def h (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L))))
H2 : h (MEnc M K) (MEnc N L)
M,N,K,L : Msg
H1 : forall (M N : Msg) (_ : irreducible h M N), h M N
H0 : forall (M N : Msg) (_ : h M N), irreducible h M N
H : and (inclusion h (irreducible h)) (inclusion (irreducible h) h)
h : hedge
*****
synthesis (analysis_def h) M N
+++++
generalize (h_le_h_ana_h h).
-----
Lemma irreducible_impl_cond_irr : forall h : hedge, is_irreducible h -> cond_irr h.
unfold cond_irr in |- *.
unfold is_irreducible in |- *.
unfold equal in |- *.
intros.
elim H.
unfold inclusion in |- *.
intros.
split.
split.
split.
unfold no_syn_cyph in |- *.
intros.
generalize (irreducible_enc h M N K L).
intro.
elim H3.
intros.
generalize (H4 (H0 (MEnc M K) (MEnc N L) H2)).
intro.
elim H6.
intros.
case H8.
intro.
left.
red in |- *.
intro.
apply H9.
generalize (h_le_h_ana_h h).

*****
H10 : synthesis h M N
H9 : not (synthesis (analysis_def h) M N)
H8 : or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L))
H7 : analysis_def h (MEnc M K) (MEnc N L)
H6 : and (analysis_def h (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L)))
H5 : forall\n _ : and (analysis_def h (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L))),\nirreducible h (MEnc M K) (MEnc N L)
H4 : forall _ : irreducible h (MEnc M K) (MEnc N L),\nand (analysis_def h (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L)))
H3 : iff (irreducible h (MEnc M K) (MEnc N L))\n (and (analysis_def h (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L))))
H2 : h (MEnc M K) (MEnc N L)
M,N,K,L : Msg
H1 : forall (M N : Msg) (_ : irreducible h M N), h M N
H0 : forall (M N : Msg) (_ : h M N), irreducible h M N
H : and (inclusion h (irreducible h)) (inclusion (irreducible h) h)
h : hedge
*****
forall _ : le_h h (analysis_def h), synthesis (analysis_def h) M N
+++++
unfold le_h in |- *.
-----
Lemma irreducible_impl_cond_irr : forall h : hedge, is_irreducible h -> cond_irr h.
unfold cond_irr in |- *.
unfold is_irreducible in |- *.
unfold equal in |- *.
intros.
elim H.
unfold inclusion in |- *.
intros.
split.
split.
split.
unfold no_syn_cyph in |- *.
intros.
generalize (irreducible_enc h M N K L).
intro.
elim H3.
intros.
generalize (H4 (H0 (MEnc M K) (MEnc N L) H2)).
intro.
elim H6.
intros.
case H8.
intro.
left.
red in |- *.
intro.
apply H9.
generalize (h_le_h_ana_h h).
unfold le_h in |- *.

*****
H10 : synthesis h M N
H9 : not (synthesis (analysis_def h) M N)
H8 : or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L))
H7 : analysis_def h (MEnc M K) (MEnc N L)
H6 : and (analysis_def h (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L)))
H5 : forall\n _ : and (analysis_def h (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L))),\nirreducible h (MEnc M K) (MEnc N L)
H4 : forall _ : irreducible h (MEnc M K) (MEnc N L),\nand (analysis_def h (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L)))
H3 : iff (irreducible h (MEnc M K) (MEnc N L))\n (and (analysis_def h (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L))))
H2 : h (MEnc M K) (MEnc N L)
M,N,K,L : Msg
H1 : forall (M N : Msg) (_ : irreducible h M N), h M N
H0 : forall (M N : Msg) (_ : h M N), irreducible h M N
H : and (inclusion h (irreducible h)) (inclusion (irreducible h) h)
h : hedge
*****
forall _ : inclusion (synthesis h) (synthesis (analysis_def h)), synthesis (analysis_def h) M N
+++++
unfold inclusion in |- *.
-----
Lemma irreducible_impl_cond_irr : forall h : hedge, is_irreducible h -> cond_irr h.
unfold cond_irr in |- *.
unfold is_irreducible in |- *.
unfold equal in |- *.
intros.
elim H.
unfold inclusion in |- *.
intros.
split.
split.
split.
unfold no_syn_cyph in |- *.
intros.
generalize (irreducible_enc h M N K L).
intro.
elim H3.
intros.
generalize (H4 (H0 (MEnc M K) (MEnc N L) H2)).
intro.
elim H6.
intros.
case H8.
intro.
left.
red in |- *.
intro.
apply H9.
generalize (h_le_h_ana_h h).
unfold le_h in |- *.
unfold inclusion in |- *.

*****
H10 : synthesis h M N
H9 : not (synthesis (analysis_def h) M N)
H8 : or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L))
H7 : analysis_def h (MEnc M K) (MEnc N L)
H6 : and (analysis_def h (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L)))
H5 : forall\n _ : and (analysis_def h (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L))),\nirreducible h (MEnc M K) (MEnc N L)
H4 : forall _ : irreducible h (MEnc M K) (MEnc N L),\nand (analysis_def h (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L)))
H3 : iff (irreducible h (MEnc M K) (MEnc N L))\n (and (analysis_def h (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L))))
H2 : h (MEnc M K) (MEnc N L)
M,N,K,L : Msg
H1 : forall (M N : Msg) (_ : irreducible h M N), h M N
H0 : forall (M N : Msg) (_ : h M N), irreducible h M N
H : and (inclusion h (irreducible h)) (inclusion (irreducible h) h)
h : hedge
*****
forall _ : forall (M N : Msg) (_ : synthesis h M N), synthesis (analysis_def h) M N, synthesis (analysis_def h) M N
+++++
auto.
-----
Lemma irreducible_impl_cond_irr : forall h : hedge, is_irreducible h -> cond_irr h.
unfold cond_irr in |- *.
unfold is_irreducible in |- *.
unfold equal in |- *.
intros.
elim H.
unfold inclusion in |- *.
intros.
split.
split.
split.
unfold no_syn_cyph in |- *.
intros.
generalize (irreducible_enc h M N K L).
intro.
elim H3.
intros.
generalize (H4 (H0 (MEnc M K) (MEnc N L) H2)).
intro.
elim H6.
intros.
case H8.

*****
H8 : or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L))
H7 : analysis_def h (MEnc M K) (MEnc N L)
H6 : and (analysis_def h (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L)))
H5 : forall\n _ : and (analysis_def h (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L))),\nirreducible h (MEnc M K) (MEnc N L)
H4 : forall _ : irreducible h (MEnc M K) (MEnc N L),\nand (analysis_def h (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L)))
H3 : iff (irreducible h (MEnc M K) (MEnc N L))\n (and (analysis_def h (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L))))
H2 : h (MEnc M K) (MEnc N L)
M,N,K,L : Msg
H1 : forall (M N : Msg) (_ : irreducible h M N), h M N
H0 : forall (M N : Msg) (_ : h M N), irreducible h M N
H : and (inclusion h (irreducible h)) (inclusion (irreducible h) h)
h : hedge
*****
forall _ : not (synthesis (analysis_def h) K L), or (not (synthesis h M N)) (not (synthesis h K L))
+++++
intro.
-----
Lemma irreducible_impl_cond_irr : forall h : hedge, is_irreducible h -> cond_irr h.
unfold cond_irr in |- *.
unfold is_irreducible in |- *.
unfold equal in |- *.
intros.
elim H.
unfold inclusion in |- *.
intros.
split.
split.
split.
unfold no_syn_cyph in |- *.
intros.
generalize (irreducible_enc h M N K L).
intro.
elim H3.
intros.
generalize (H4 (H0 (MEnc M K) (MEnc N L) H2)).
intro.
elim H6.
intros.
case H8.
intro.

*****
H9 : not (synthesis (analysis_def h) K L)
H8 : or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L))
H7 : analysis_def h (MEnc M K) (MEnc N L)
H6 : and (analysis_def h (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L)))
H5 : forall\n _ : and (analysis_def h (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L))),\nirreducible h (MEnc M K) (MEnc N L)
H4 : forall _ : irreducible h (MEnc M K) (MEnc N L),\nand (analysis_def h (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L)))
H3 : iff (irreducible h (MEnc M K) (MEnc N L))\n (and (analysis_def h (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L))))
H2 : h (MEnc M K) (MEnc N L)
M,N,K,L : Msg
H1 : forall (M N : Msg) (_ : irreducible h M N), h M N
H0 : forall (M N : Msg) (_ : h M N), irreducible h M N
H : and (inclusion h (irreducible h)) (inclusion (irreducible h) h)
h : hedge
*****
or (not (synthesis h M N)) (not (synthesis h K L))
+++++
right.
-----
Lemma irreducible_impl_cond_irr : forall h : hedge, is_irreducible h -> cond_irr h.
unfold cond_irr in |- *.
unfold is_irreducible in |- *.
unfold equal in |- *.
intros.
elim H.
unfold inclusion in |- *.
intros.
split.
split.
split.
unfold no_syn_cyph in |- *.
intros.
generalize (irreducible_enc h M N K L).
intro.
elim H3.
intros.
generalize (H4 (H0 (MEnc M K) (MEnc N L) H2)).
intro.
elim H6.
intros.
case H8.
intro.
right.

*****
H9 : not (synthesis (analysis_def h) K L)
H8 : or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L))
H7 : analysis_def h (MEnc M K) (MEnc N L)
H6 : and (analysis_def h (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L)))
H5 : forall\n _ : and (analysis_def h (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L))),\nirreducible h (MEnc M K) (MEnc N L)
H4 : forall _ : irreducible h (MEnc M K) (MEnc N L),\nand (analysis_def h (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L)))
H3 : iff (irreducible h (MEnc M K) (MEnc N L))\n (and (analysis_def h (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L))))
H2 : h (MEnc M K) (MEnc N L)
M,N,K,L : Msg
H1 : forall (M N : Msg) (_ : irreducible h M N), h M N
H0 : forall (M N : Msg) (_ : h M N), irreducible h M N
H : and (inclusion h (irreducible h)) (inclusion (irreducible h) h)
h : hedge
*****
not (synthesis h K L)
+++++
red in |- *.
-----
Lemma irreducible_impl_cond_irr : forall h : hedge, is_irreducible h -> cond_irr h.
unfold cond_irr in |- *.
unfold is_irreducible in |- *.
unfold equal in |- *.
intros.
elim H.
unfold inclusion in |- *.
intros.
split.
split.
split.
unfold no_syn_cyph in |- *.
intros.
generalize (irreducible_enc h M N K L).
intro.
elim H3.
intros.
generalize (H4 (H0 (MEnc M K) (MEnc N L) H2)).
intro.
elim H6.
intros.
case H8.
intro.
right.
red in |- *.

*****
H9 : not (synthesis (analysis_def h) K L)
H8 : or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L))
H7 : analysis_def h (MEnc M K) (MEnc N L)
H6 : and (analysis_def h (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L)))
H5 : forall\n _ : and (analysis_def h (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L))),\nirreducible h (MEnc M K) (MEnc N L)
H4 : forall _ : irreducible h (MEnc M K) (MEnc N L),\nand (analysis_def h (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L)))
H3 : iff (irreducible h (MEnc M K) (MEnc N L))\n (and (analysis_def h (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L))))
H2 : h (MEnc M K) (MEnc N L)
M,N,K,L : Msg
H1 : forall (M N : Msg) (_ : irreducible h M N), h M N
H0 : forall (M N : Msg) (_ : h M N), irreducible h M N
H : and (inclusion h (irreducible h)) (inclusion (irreducible h) h)
h : hedge
*****
forall _ : synthesis h K L, False
+++++
intro.
-----
Lemma irreducible_impl_cond_irr : forall h : hedge, is_irreducible h -> cond_irr h.
unfold cond_irr in |- *.
unfold is_irreducible in |- *.
unfold equal in |- *.
intros.
elim H.
unfold inclusion in |- *.
intros.
split.
split.
split.
unfold no_syn_cyph in |- *.
intros.
generalize (irreducible_enc h M N K L).
intro.
elim H3.
intros.
generalize (H4 (H0 (MEnc M K) (MEnc N L) H2)).
intro.
elim H6.
intros.
case H8.
intro.
right.
red in |- *.
intro.

*****
H10 : synthesis h K L
H9 : not (synthesis (analysis_def h) K L)
H8 : or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L))
H7 : analysis_def h (MEnc M K) (MEnc N L)
H6 : and (analysis_def h (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L)))
H5 : forall\n _ : and (analysis_def h (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L))),\nirreducible h (MEnc M K) (MEnc N L)
H4 : forall _ : irreducible h (MEnc M K) (MEnc N L),\nand (analysis_def h (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L)))
H3 : iff (irreducible h (MEnc M K) (MEnc N L))\n (and (analysis_def h (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L))))
H2 : h (MEnc M K) (MEnc N L)
M,N,K,L : Msg
H1 : forall (M N : Msg) (_ : irreducible h M N), h M N
H0 : forall (M N : Msg) (_ : h M N), irreducible h M N
H : and (inclusion h (irreducible h)) (inclusion (irreducible h) h)
h : hedge
*****
False
+++++
apply H9.
-----
Lemma irreducible_impl_cond_irr : forall h : hedge, is_irreducible h -> cond_irr h.
unfold cond_irr in |- *.
unfold is_irreducible in |- *.
unfold equal in |- *.
intros.
elim H.
unfold inclusion in |- *.
intros.
split.
split.
split.
unfold no_syn_cyph in |- *.
intros.
generalize (irreducible_enc h M N K L).
intro.
elim H3.
intros.
generalize (H4 (H0 (MEnc M K) (MEnc N L) H2)).
intro.
elim H6.
intros.
case H8.
intro.
right.
red in |- *.
intro.
apply H9.

*****
H10 : synthesis h K L
H9 : not (synthesis (analysis_def h) K L)
H8 : or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L))
H7 : analysis_def h (MEnc M K) (MEnc N L)
H6 : and (analysis_def h (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L)))
H5 : forall\n _ : and (analysis_def h (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L))),\nirreducible h (MEnc M K) (MEnc N L)
H4 : forall _ : irreducible h (MEnc M K) (MEnc N L),\nand (analysis_def h (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L)))
H3 : iff (irreducible h (MEnc M K) (MEnc N L))\n (and (analysis_def h (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L))))
H2 : h (MEnc M K) (MEnc N L)
M,N,K,L : Msg
H1 : forall (M N : Msg) (_ : irreducible h M N), h M N
H0 : forall (M N : Msg) (_ : h M N), irreducible h M N
H : and (inclusion h (irreducible h)) (inclusion (irreducible h) h)
h : hedge
*****
synthesis (analysis_def h) K L
+++++
generalize (h_le_h_ana_h h).
-----
Lemma irreducible_impl_cond_irr : forall h : hedge, is_irreducible h -> cond_irr h.
unfold cond_irr in |- *.
unfold is_irreducible in |- *.
unfold equal in |- *.
intros.
elim H.
unfold inclusion in |- *.
intros.
split.
split.
split.
unfold no_syn_cyph in |- *.
intros.
generalize (irreducible_enc h M N K L).
intro.
elim H3.
intros.
generalize (H4 (H0 (MEnc M K) (MEnc N L) H2)).
intro.
elim H6.
intros.
case H8.
intro.
right.
red in |- *.
intro.
apply H9.
generalize (h_le_h_ana_h h).

*****
H10 : synthesis h K L
H9 : not (synthesis (analysis_def h) K L)
H8 : or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L))
H7 : analysis_def h (MEnc M K) (MEnc N L)
H6 : and (analysis_def h (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L)))
H5 : forall\n _ : and (analysis_def h (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L))),\nirreducible h (MEnc M K) (MEnc N L)
H4 : forall _ : irreducible h (MEnc M K) (MEnc N L),\nand (analysis_def h (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L)))
H3 : iff (irreducible h (MEnc M K) (MEnc N L))\n (and (analysis_def h (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L))))
H2 : h (MEnc M K) (MEnc N L)
M,N,K,L : Msg
H1 : forall (M N : Msg) (_ : irreducible h M N), h M N
H0 : forall (M N : Msg) (_ : h M N), irreducible h M N
H : and (inclusion h (irreducible h)) (inclusion (irreducible h) h)
h : hedge
*****
forall _ : le_h h (analysis_def h), synthesis (analysis_def h) K L
+++++
unfold le_h in |- *.
-----
Lemma irreducible_impl_cond_irr : forall h : hedge, is_irreducible h -> cond_irr h.
unfold cond_irr in |- *.
unfold is_irreducible in |- *.
unfold equal in |- *.
intros.
elim H.
unfold inclusion in |- *.
intros.
split.
split.
split.
unfold no_syn_cyph in |- *.
intros.
generalize (irreducible_enc h M N K L).
intro.
elim H3.
intros.
generalize (H4 (H0 (MEnc M K) (MEnc N L) H2)).
intro.
elim H6.
intros.
case H8.
intro.
right.
red in |- *.
intro.
apply H9.
generalize (h_le_h_ana_h h).
unfold le_h in |- *.

*****
H10 : synthesis h K L
H9 : not (synthesis (analysis_def h) K L)
H8 : or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L))
H7 : analysis_def h (MEnc M K) (MEnc N L)
H6 : and (analysis_def h (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L)))
H5 : forall\n _ : and (analysis_def h (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L))),\nirreducible h (MEnc M K) (MEnc N L)
H4 : forall _ : irreducible h (MEnc M K) (MEnc N L),\nand (analysis_def h (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L)))
H3 : iff (irreducible h (MEnc M K) (MEnc N L))\n (and (analysis_def h (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L))))
H2 : h (MEnc M K) (MEnc N L)
M,N,K,L : Msg
H1 : forall (M N : Msg) (_ : irreducible h M N), h M N
H0 : forall (M N : Msg) (_ : h M N), irreducible h M N
H : and (inclusion h (irreducible h)) (inclusion (irreducible h) h)
h : hedge
*****
forall _ : inclusion (synthesis h) (synthesis (analysis_def h)), synthesis (analysis_def h) K L
+++++
unfold inclusion in |- *.
-----
Lemma irreducible_impl_cond_irr : forall h : hedge, is_irreducible h -> cond_irr h.
unfold cond_irr in |- *.
unfold is_irreducible in |- *.
unfold equal in |- *.
intros.
elim H.
unfold inclusion in |- *.
intros.
split.
split.
split.
unfold no_syn_cyph in |- *.
intros.
generalize (irreducible_enc h M N K L).
intro.
elim H3.
intros.
generalize (H4 (H0 (MEnc M K) (MEnc N L) H2)).
intro.
elim H6.
intros.
case H8.
intro.
right.
red in |- *.
intro.
apply H9.
generalize (h_le_h_ana_h h).
unfold le_h in |- *.
unfold inclusion in |- *.

*****
H10 : synthesis h K L
H9 : not (synthesis (analysis_def h) K L)
H8 : or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L))
H7 : analysis_def h (MEnc M K) (MEnc N L)
H6 : and (analysis_def h (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L)))
H5 : forall\n _ : and (analysis_def h (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L))),\nirreducible h (MEnc M K) (MEnc N L)
H4 : forall _ : irreducible h (MEnc M K) (MEnc N L),\nand (analysis_def h (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L)))
H3 : iff (irreducible h (MEnc M K) (MEnc N L))\n (and (analysis_def h (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L))))
H2 : h (MEnc M K) (MEnc N L)
M,N,K,L : Msg
H1 : forall (M N : Msg) (_ : irreducible h M N), h M N
H0 : forall (M N : Msg) (_ : h M N), irreducible h M N
H : and (inclusion h (irreducible h)) (inclusion (irreducible h) h)
h : hedge
*****
forall _ : forall (M N : Msg) (_ : synthesis h M N), synthesis (analysis_def h) M N, synthesis (analysis_def h) K L
+++++
auto.
-----
Lemma irreducible_impl_cond_irr : forall h : hedge, is_irreducible h -> cond_irr h.
unfold cond_irr in |- *.
unfold is_irreducible in |- *.
unfold equal in |- *.
intros.
elim H.
unfold inclusion in |- *.
intros.
split.
split.
split.

*****
H1 : forall (M N : Msg) (_ : irreducible h M N), h M N
H0 : forall (M N : Msg) (_ : h M N), irreducible h M N
H : and (inclusion h (irreducible h)) (inclusion (irreducible h) h)
h : hedge
*****
cyph_dec h
+++++
unfold cyph_dec in |- *.
-----
Lemma irreducible_impl_cond_irr : forall h : hedge, is_irreducible h -> cond_irr h.
unfold cond_irr in |- *.
unfold is_irreducible in |- *.
unfold equal in |- *.
intros.
elim H.
unfold inclusion in |- *.
intros.
split.
split.
split.
unfold cyph_dec in |- *.

*****
H1 : forall (M N : Msg) (_ : irreducible h M N), h M N
H0 : forall (M N : Msg) (_ : h M N), irreducible h M N
H : and (inclusion h (irreducible h)) (inclusion (irreducible h) h)
h : hedge
*****
forall (M N K L : Msg) (_ : h (MEnc M K) (MEnc N L)) (_ : synthesis h (inv K) (inv L)), synthesis h M N
+++++
intros.
-----
Lemma irreducible_impl_cond_irr : forall h : hedge, is_irreducible h -> cond_irr h.
unfold cond_irr in |- *.
unfold is_irreducible in |- *.
unfold equal in |- *.
intros.
elim H.
unfold inclusion in |- *.
intros.
split.
split.
split.
unfold cyph_dec in |- *.
intros.

*****
H3 : synthesis h (inv K) (inv L)
H2 : h (MEnc M K) (MEnc N L)
M,N,K,L : Msg
H1 : forall (M N : Msg) (_ : irreducible h M N), h M N
H0 : forall (M N : Msg) (_ : h M N), irreducible h M N
H : and (inclusion h (irreducible h)) (inclusion (irreducible h) h)
h : hedge
*****
synthesis h M N
+++++
generalize (H0 (MEnc M K) (MEnc N L) H2).
-----
Lemma irreducible_impl_cond_irr : forall h : hedge, is_irreducible h -> cond_irr h.
unfold cond_irr in |- *.
unfold is_irreducible in |- *.
unfold equal in |- *.
intros.
elim H.
unfold inclusion in |- *.
intros.
split.
split.
split.
unfold cyph_dec in |- *.
intros.
generalize (H0 (MEnc M K) (MEnc N L) H2).

*****
H3 : synthesis h (inv K) (inv L)
H2 : h (MEnc M K) (MEnc N L)
M,N,K,L : Msg
H1 : forall (M N : Msg) (_ : irreducible h M N), h M N
H0 : forall (M N : Msg) (_ : h M N), irreducible h M N
H : and (inclusion h (irreducible h)) (inclusion (irreducible h) h)
h : hedge
*****
forall _ : irreducible h (MEnc M K) (MEnc N L), synthesis h M N
+++++
unfold irreducible in |- *.
-----
Lemma irreducible_impl_cond_irr : forall h : hedge, is_irreducible h -> cond_irr h.
unfold cond_irr in |- *.
unfold is_irreducible in |- *.
unfold equal in |- *.
intros.
elim H.
unfold inclusion in |- *.
intros.
split.
split.
split.
unfold cyph_dec in |- *.
intros.
generalize (H0 (MEnc M K) (MEnc N L) H2).
unfold irreducible in |- *.

*****
H3 : synthesis h (inv K) (inv L)
H2 : h (MEnc M K) (MEnc N L)
M,N,K,L : Msg
H1 : forall (M N : Msg) (_ : irreducible h M N), h M N
H0 : forall (M N : Msg) (_ : h M N), irreducible h M N
H : and (inclusion h (irreducible h)) (inclusion (irreducible h) h)
h : hedge
*****
forall _ : reduce (analysis_def h) (MEnc M K) (MEnc N L), synthesis h M N
+++++
unfold reduce in |- *.
-----
Lemma irreducible_impl_cond_irr : forall h : hedge, is_irreducible h -> cond_irr h.
unfold cond_irr in |- *.
unfold is_irreducible in |- *.
unfold equal in |- *.
intros.
elim H.
unfold inclusion in |- *.
intros.
split.
split.
split.
unfold cyph_dec in |- *.
intros.
generalize (H0 (MEnc M K) (MEnc N L) H2).
unfold irreducible in |- *.
unfold reduce in |- *.

*****
H3 : synthesis h (inv K) (inv L)
H2 : h (MEnc M K) (MEnc N L)
M,N,K,L : Msg
H1 : forall (M N : Msg) (_ : irreducible h M N), h M N
H0 : forall (M N : Msg) (_ : h M N), irreducible h M N
H : and (inclusion h (irreducible h)) (inclusion (irreducible h) h)
h : hedge
*****
forall _ : and (analysis_def h (MEnc M K) (MEnc N L)) (or (not (synthesis (analysis_def h) M N)) (not (synthesis (analysis_def h) K L))), synthesis h M N
+++++
intros.
-----
Lemma irreducible_impl_cond_irr : forall h : hedge, is_irreducible h -> cond_irr h.
unfold cond_irr in |- *.
unfold is_irreducible in |- *.
unfold equal in |- *.
intros.
elim H.
unfold inclusion in |- *.
intros.
split.
split.
split.
unfold cyph_dec in |- *.
intros.
generalize (H0 (MEnc M K) (MEnc N L) H2).
unfold irreducible in |- *.
unfold reduce in |- *.
intros.

*****
H4 : and (analysis_def h (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L)))
H3 : synthesis h (inv K) (inv L)
H2 : h (MEnc M K) (MEnc N L)
M,N,K,L : Msg
H1 : forall (M N : Msg) (_ : irreducible h M N), h M N
H0 : forall (M N : Msg) (_ : h M N), irreducible h M N
H : and (inclusion h (irreducible h)) (inclusion (irreducible h) h)
h : hedge
*****
synthesis h M N
+++++
elim H4.
-----
Lemma irreducible_impl_cond_irr : forall h : hedge, is_irreducible h -> cond_irr h.
unfold cond_irr in |- *.
unfold is_irreducible in |- *.
unfold equal in |- *.
intros.
elim H.
unfold inclusion in |- *.
intros.
split.
split.
split.
unfold cyph_dec in |- *.
intros.
generalize (H0 (MEnc M K) (MEnc N L) H2).
unfold irreducible in |- *.
unfold reduce in |- *.
intros.
elim H4.

*****
H4 : and (analysis_def h (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L)))
H3 : synthesis h (inv K) (inv L)
H2 : h (MEnc M K) (MEnc N L)
M,N,K,L : Msg
H1 : forall (M N : Msg) (_ : irreducible h M N), h M N
H0 : forall (M N : Msg) (_ : h M N), irreducible h M N
H : and (inclusion h (irreducible h)) (inclusion (irreducible h) h)
h : hedge
*****
forall (_ : analysis_def h (MEnc M K) (MEnc N L)) (_ : or (not (synthesis (analysis_def h) M N)) (not (synthesis (analysis_def h) K L))), synthesis h M N
+++++
intros.
-----
Lemma irreducible_impl_cond_irr : forall h : hedge, is_irreducible h -> cond_irr h.
unfold cond_irr in |- *.
unfold is_irreducible in |- *.
unfold equal in |- *.
intros.
elim H.
unfold inclusion in |- *.
intros.
split.
split.
split.
unfold cyph_dec in |- *.
intros.
generalize (H0 (MEnc M K) (MEnc N L) H2).
unfold irreducible in |- *.
unfold reduce in |- *.
intros.
elim H4.
intros.

*****
H6 : or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L))
H5 : analysis_def h (MEnc M K) (MEnc N L)
H4 : and (analysis_def h (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L)))
H3 : synthesis h (inv K) (inv L)
H2 : h (MEnc M K) (MEnc N L)
M,N,K,L : Msg
H1 : forall (M N : Msg) (_ : irreducible h M N), h M N
H0 : forall (M N : Msg) (_ : h M N), irreducible h M N
H : and (inclusion h (irreducible h)) (inclusion (irreducible h) h)
h : hedge
*****
synthesis h M N
+++++
generalize (ana_h_equiv_irr_h h).
-----
Lemma irreducible_impl_cond_irr : forall h : hedge, is_irreducible h -> cond_irr h.
unfold cond_irr in |- *.
unfold is_irreducible in |- *.
unfold equal in |- *.
intros.
elim H.
unfold inclusion in |- *.
intros.
split.
split.
split.
unfold cyph_dec in |- *.
intros.
generalize (H0 (MEnc M K) (MEnc N L) H2).
unfold irreducible in |- *.
unfold reduce in |- *.
intros.
elim H4.
intros.
generalize (ana_h_equiv_irr_h h).

*****
H6 : or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L))
H5 : analysis_def h (MEnc M K) (MEnc N L)
H4 : and (analysis_def h (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L)))
H3 : synthesis h (inv K) (inv L)
H2 : h (MEnc M K) (MEnc N L)
M,N,K,L : Msg
H1 : forall (M N : Msg) (_ : irreducible h M N), h M N
H0 : forall (M N : Msg) (_ : h M N), irreducible h M N
H : and (inclusion h (irreducible h)) (inclusion (irreducible h) h)
h : hedge
*****
forall _ : equiv_h (analysis_def h) (irreducible h), synthesis h M N
+++++
unfold equiv_h in |- *.
-----
Lemma irreducible_impl_cond_irr : forall h : hedge, is_irreducible h -> cond_irr h.
unfold cond_irr in |- *.
unfold is_irreducible in |- *.
unfold equal in |- *.
intros.
elim H.
unfold inclusion in |- *.
intros.
split.
split.
split.
unfold cyph_dec in |- *.
intros.
generalize (H0 (MEnc M K) (MEnc N L) H2).
unfold irreducible in |- *.
unfold reduce in |- *.
intros.
elim H4.
intros.
generalize (ana_h_equiv_irr_h h).
unfold equiv_h in |- *.

*****
H6 : or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L))
H5 : analysis_def h (MEnc M K) (MEnc N L)
H4 : and (analysis_def h (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L)))
H3 : synthesis h (inv K) (inv L)
H2 : h (MEnc M K) (MEnc N L)
M,N,K,L : Msg
H1 : forall (M N : Msg) (_ : irreducible h M N), h M N
H0 : forall (M N : Msg) (_ : h M N), irreducible h M N
H : and (inclusion h (irreducible h)) (inclusion (irreducible h) h)
h : hedge
*****
forall _ : and (le_h (analysis_def h) (irreducible h)) (le_h (irreducible h) (analysis_def h)), synthesis h M N
+++++
intros.
-----
Lemma irreducible_impl_cond_irr : forall h : hedge, is_irreducible h -> cond_irr h.
unfold cond_irr in |- *.
unfold is_irreducible in |- *.
unfold equal in |- *.
intros.
elim H.
unfold inclusion in |- *.
intros.
split.
split.
split.
unfold cyph_dec in |- *.
intros.
generalize (H0 (MEnc M K) (MEnc N L) H2).
unfold irreducible in |- *.
unfold reduce in |- *.
intros.
elim H4.
intros.
generalize (ana_h_equiv_irr_h h).
unfold equiv_h in |- *.
intros.

*****
H7 : and (le_h (analysis_def h) (irreducible h))\n (le_h (irreducible h) (analysis_def h))
H6 : or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L))
H5 : analysis_def h (MEnc M K) (MEnc N L)
H4 : and (analysis_def h (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L)))
H3 : synthesis h (inv K) (inv L)
H2 : h (MEnc M K) (MEnc N L)
M,N,K,L : Msg
H1 : forall (M N : Msg) (_ : irreducible h M N), h M N
H0 : forall (M N : Msg) (_ : h M N), irreducible h M N
H : and (inclusion h (irreducible h)) (inclusion (irreducible h) h)
h : hedge
*****
synthesis h M N
+++++
elim H7.
-----
Lemma irreducible_impl_cond_irr : forall h : hedge, is_irreducible h -> cond_irr h.
unfold cond_irr in |- *.
unfold is_irreducible in |- *.
unfold equal in |- *.
intros.
elim H.
unfold inclusion in |- *.
intros.
split.
split.
split.
unfold cyph_dec in |- *.
intros.
generalize (H0 (MEnc M K) (MEnc N L) H2).
unfold irreducible in |- *.
unfold reduce in |- *.
intros.
elim H4.
intros.
generalize (ana_h_equiv_irr_h h).
unfold equiv_h in |- *.
intros.
elim H7.

*****
H7 : and (le_h (analysis_def h) (irreducible h))\n (le_h (irreducible h) (analysis_def h))
H6 : or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L))
H5 : analysis_def h (MEnc M K) (MEnc N L)
H4 : and (analysis_def h (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L)))
H3 : synthesis h (inv K) (inv L)
H2 : h (MEnc M K) (MEnc N L)
M,N,K,L : Msg
H1 : forall (M N : Msg) (_ : irreducible h M N), h M N
H0 : forall (M N : Msg) (_ : h M N), irreducible h M N
H : and (inclusion h (irreducible h)) (inclusion (irreducible h) h)
h : hedge
*****
forall (_ : le_h (analysis_def h) (irreducible h)) (_ : le_h (irreducible h) (analysis_def h)), synthesis h M N
+++++
unfold le_h in |- *.
-----
Lemma irreducible_impl_cond_irr : forall h : hedge, is_irreducible h -> cond_irr h.
unfold cond_irr in |- *.
unfold is_irreducible in |- *.
unfold equal in |- *.
intros.
elim H.
unfold inclusion in |- *.
intros.
split.
split.
split.
unfold cyph_dec in |- *.
intros.
generalize (H0 (MEnc M K) (MEnc N L) H2).
unfold irreducible in |- *.
unfold reduce in |- *.
intros.
elim H4.
intros.
generalize (ana_h_equiv_irr_h h).
unfold equiv_h in |- *.
intros.
elim H7.
unfold le_h in |- *.

*****
H7 : and (le_h (analysis_def h) (irreducible h))\n (le_h (irreducible h) (analysis_def h))
H6 : or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L))
H5 : analysis_def h (MEnc M K) (MEnc N L)
H4 : and (analysis_def h (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L)))
H3 : synthesis h (inv K) (inv L)
H2 : h (MEnc M K) (MEnc N L)
M,N,K,L : Msg
H1 : forall (M N : Msg) (_ : irreducible h M N), h M N
H0 : forall (M N : Msg) (_ : h M N), irreducible h M N
H : and (inclusion h (irreducible h)) (inclusion (irreducible h) h)
h : hedge
*****
forall (_ : inclusion (synthesis (analysis_def h)) (synthesis (irreducible h))) (_ : inclusion (synthesis (irreducible h)) (synthesis (analysis_def h))), synthesis h M N
+++++
intros.
-----
Lemma irreducible_impl_cond_irr : forall h : hedge, is_irreducible h -> cond_irr h.
unfold cond_irr in |- *.
unfold is_irreducible in |- *.
unfold equal in |- *.
intros.
elim H.
unfold inclusion in |- *.
intros.
split.
split.
split.
unfold cyph_dec in |- *.
intros.
generalize (H0 (MEnc M K) (MEnc N L) H2).
unfold irreducible in |- *.
unfold reduce in |- *.
intros.
elim H4.
intros.
generalize (ana_h_equiv_irr_h h).
unfold equiv_h in |- *.
intros.
elim H7.
unfold le_h in |- *.
intros.

*****
H9 : inclusion (synthesis (irreducible h)) (synthesis (analysis_def h))
H8 : inclusion (synthesis (analysis_def h)) (synthesis (irreducible h))
H7 : and (le_h (analysis_def h) (irreducible h))\n (le_h (irreducible h) (analysis_def h))
H6 : or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L))
H5 : analysis_def h (MEnc M K) (MEnc N L)
H4 : and (analysis_def h (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L)))
H3 : synthesis h (inv K) (inv L)
H2 : h (MEnc M K) (MEnc N L)
M,N,K,L : Msg
H1 : forall (M N : Msg) (_ : irreducible h M N), h M N
H0 : forall (M N : Msg) (_ : h M N), irreducible h M N
H : and (inclusion h (irreducible h)) (inclusion (irreducible h) h)
h : hedge
*****
synthesis h M N
+++++
cut (inclusion (synthesis (irreducible h)) (synthesis h)).
-----
Lemma irreducible_impl_cond_irr : forall h : hedge, is_irreducible h -> cond_irr h.
unfold cond_irr in |- *.
unfold is_irreducible in |- *.
unfold equal in |- *.
intros.
elim H.
unfold inclusion in |- *.
intros.
split.
split.
split.
unfold cyph_dec in |- *.
intros.
generalize (H0 (MEnc M K) (MEnc N L) H2).
unfold irreducible in |- *.
unfold reduce in |- *.
intros.
elim H4.
intros.
generalize (ana_h_equiv_irr_h h).
unfold equiv_h in |- *.
intros.
elim H7.
unfold le_h in |- *.
intros.
cut (inclusion (synthesis (irreducible h)) (synthesis h)).

*****
H9 : inclusion (synthesis (irreducible h)) (synthesis (analysis_def h))
H8 : inclusion (synthesis (analysis_def h)) (synthesis (irreducible h))
H7 : and (le_h (analysis_def h) (irreducible h))\n (le_h (irreducible h) (analysis_def h))
H6 : or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L))
H5 : analysis_def h (MEnc M K) (MEnc N L)
H4 : and (analysis_def h (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L)))
H3 : synthesis h (inv K) (inv L)
H2 : h (MEnc M K) (MEnc N L)
M,N,K,L : Msg
H1 : forall (M N : Msg) (_ : irreducible h M N), h M N
H0 : forall (M N : Msg) (_ : h M N), irreducible h M N
H : and (inclusion h (irreducible h)) (inclusion (irreducible h) h)
h : hedge
*****
forall _ : inclusion (synthesis (irreducible h)) (synthesis h), synthesis h M N
+++++
unfold inclusion in |- *.
-----
Lemma irreducible_impl_cond_irr : forall h : hedge, is_irreducible h -> cond_irr h.
unfold cond_irr in |- *.
unfold is_irreducible in |- *.
unfold equal in |- *.
intros.
elim H.
unfold inclusion in |- *.
intros.
split.
split.
split.
unfold cyph_dec in |- *.
intros.
generalize (H0 (MEnc M K) (MEnc N L) H2).
unfold irreducible in |- *.
unfold reduce in |- *.
intros.
elim H4.
intros.
generalize (ana_h_equiv_irr_h h).
unfold equiv_h in |- *.
intros.
elim H7.
unfold le_h in |- *.
intros.
cut (inclusion (synthesis (irreducible h)) (synthesis h)).
unfold inclusion in |- *.

*****
H9 : inclusion (synthesis (irreducible h)) (synthesis (analysis_def h))
H8 : inclusion (synthesis (analysis_def h)) (synthesis (irreducible h))
H7 : and (le_h (analysis_def h) (irreducible h))\n (le_h (irreducible h) (analysis_def h))
H6 : or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L))
H5 : analysis_def h (MEnc M K) (MEnc N L)
H4 : and (analysis_def h (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L)))
H3 : synthesis h (inv K) (inv L)
H2 : h (MEnc M K) (MEnc N L)
M,N,K,L : Msg
H1 : forall (M N : Msg) (_ : irreducible h M N), h M N
H0 : forall (M N : Msg) (_ : h M N), irreducible h M N
H : and (inclusion h (irreducible h)) (inclusion (irreducible h) h)
h : hedge
*****
forall _ : forall (M N : Msg) (_ : synthesis (irreducible h) M N), synthesis h M N, synthesis h M N
+++++
intros.
-----
Lemma irreducible_impl_cond_irr : forall h : hedge, is_irreducible h -> cond_irr h.
unfold cond_irr in |- *.
unfold is_irreducible in |- *.
unfold equal in |- *.
intros.
elim H.
unfold inclusion in |- *.
intros.
split.
split.
split.
unfold cyph_dec in |- *.
intros.
generalize (H0 (MEnc M K) (MEnc N L) H2).
unfold irreducible in |- *.
unfold reduce in |- *.
intros.
elim H4.
intros.
generalize (ana_h_equiv_irr_h h).
unfold equiv_h in |- *.
intros.
elim H7.
unfold le_h in |- *.
intros.
cut (inclusion (synthesis (irreducible h)) (synthesis h)).
unfold inclusion in |- *.
intros.

*****
H10 : forall (M N : Msg) (_ : synthesis (irreducible h) M N), synthesis h M N
H9 : inclusion (synthesis (irreducible h)) (synthesis (analysis_def h))
H8 : inclusion (synthesis (analysis_def h)) (synthesis (irreducible h))
H7 : and (le_h (analysis_def h) (irreducible h))\n (le_h (irreducible h) (analysis_def h))
H6 : or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L))
H5 : analysis_def h (MEnc M K) (MEnc N L)
H4 : and (analysis_def h (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L)))
H3 : synthesis h (inv K) (inv L)
H2 : h (MEnc M K) (MEnc N L)
M,N,K,L : Msg
H1 : forall (M N : Msg) (_ : irreducible h M N), h M N
H0 : forall (M N : Msg) (_ : h M N), irreducible h M N
H : and (inclusion h (irreducible h)) (inclusion (irreducible h) h)
h : hedge
*****
synthesis h M N
+++++
apply H10.
-----
Lemma irreducible_impl_cond_irr : forall h : hedge, is_irreducible h -> cond_irr h.
unfold cond_irr in |- *.
unfold is_irreducible in |- *.
unfold equal in |- *.
intros.
elim H.
unfold inclusion in |- *.
intros.
split.
split.
split.
unfold cyph_dec in |- *.
intros.
generalize (H0 (MEnc M K) (MEnc N L) H2).
unfold irreducible in |- *.
unfold reduce in |- *.
intros.
elim H4.
intros.
generalize (ana_h_equiv_irr_h h).
unfold equiv_h in |- *.
intros.
elim H7.
unfold le_h in |- *.
intros.
cut (inclusion (synthesis (irreducible h)) (synthesis h)).
unfold inclusion in |- *.
intros.
apply H10.

*****
H10 : forall (M N : Msg) (_ : synthesis (irreducible h) M N), synthesis h M N
H9 : inclusion (synthesis (irreducible h)) (synthesis (analysis_def h))
H8 : inclusion (synthesis (analysis_def h)) (synthesis (irreducible h))
H7 : and (le_h (analysis_def h) (irreducible h))\n (le_h (irreducible h) (analysis_def h))
H6 : or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L))
H5 : analysis_def h (MEnc M K) (MEnc N L)
H4 : and (analysis_def h (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L)))
H3 : synthesis h (inv K) (inv L)
H2 : h (MEnc M K) (MEnc N L)
M,N,K,L : Msg
H1 : forall (M N : Msg) (_ : irreducible h M N), h M N
H0 : forall (M N : Msg) (_ : h M N), irreducible h M N
H : and (inclusion h (irreducible h)) (inclusion (irreducible h) h)
h : hedge
*****
synthesis (irreducible h) M N
+++++
unfold inclusion in H8.
-----
Lemma irreducible_impl_cond_irr : forall h : hedge, is_irreducible h -> cond_irr h.
unfold cond_irr in |- *.
unfold is_irreducible in |- *.
unfold equal in |- *.
intros.
elim H.
unfold inclusion in |- *.
intros.
split.
split.
split.
unfold cyph_dec in |- *.
intros.
generalize (H0 (MEnc M K) (MEnc N L) H2).
unfold irreducible in |- *.
unfold reduce in |- *.
intros.
elim H4.
intros.
generalize (ana_h_equiv_irr_h h).
unfold equiv_h in |- *.
intros.
elim H7.
unfold le_h in |- *.
intros.
cut (inclusion (synthesis (irreducible h)) (synthesis h)).
unfold inclusion in |- *.
intros.
apply H10.
unfold inclusion in H8.

*****
H10 : forall (M N : Msg) (_ : synthesis (irreducible h) M N), synthesis h M N
H9 : inclusion (synthesis (irreducible h)) (synthesis (analysis_def h))
H8 : forall (M N : Msg) (_ : synthesis (analysis_def h) M N),\nsynthesis (irreducible h) M N
H7 : and (le_h (analysis_def h) (irreducible h))\n (le_h (irreducible h) (analysis_def h))
H6 : or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L))
H5 : analysis_def h (MEnc M K) (MEnc N L)
H4 : and (analysis_def h (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L)))
H3 : synthesis h (inv K) (inv L)
H2 : h (MEnc M K) (MEnc N L)
M,N,K,L : Msg
H1 : forall (M N : Msg) (_ : irreducible h M N), h M N
H0 : forall (M N : Msg) (_ : h M N), irreducible h M N
H : and (inclusion h (irreducible h)) (inclusion (irreducible h) h)
h : hedge
*****
synthesis (irreducible h) M N
+++++
apply H8.
-----
Lemma irreducible_impl_cond_irr : forall h : hedge, is_irreducible h -> cond_irr h.
unfold cond_irr in |- *.
unfold is_irreducible in |- *.
unfold equal in |- *.
intros.
elim H.
unfold inclusion in |- *.
intros.
split.
split.
split.
unfold cyph_dec in |- *.
intros.
generalize (H0 (MEnc M K) (MEnc N L) H2).
unfold irreducible in |- *.
unfold reduce in |- *.
intros.
elim H4.
intros.
generalize (ana_h_equiv_irr_h h).
unfold equiv_h in |- *.
intros.
elim H7.
unfold le_h in |- *.
intros.
cut (inclusion (synthesis (irreducible h)) (synthesis h)).
unfold inclusion in |- *.
intros.
apply H10.
unfold inclusion in H8.
apply H8.

*****
H10 : forall (M N : Msg) (_ : synthesis (irreducible h) M N), synthesis h M N
H9 : inclusion (synthesis (irreducible h)) (synthesis (analysis_def h))
H8 : forall (M N : Msg) (_ : synthesis (analysis_def h) M N),\nsynthesis (irreducible h) M N
H7 : and (le_h (analysis_def h) (irreducible h))\n (le_h (irreducible h) (analysis_def h))
H6 : or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L))
H5 : analysis_def h (MEnc M K) (MEnc N L)
H4 : and (analysis_def h (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L)))
H3 : synthesis h (inv K) (inv L)
H2 : h (MEnc M K) (MEnc N L)
M,N,K,L : Msg
H1 : forall (M N : Msg) (_ : irreducible h M N), h M N
H0 : forall (M N : Msg) (_ : h M N), irreducible h M N
H : and (inclusion h (irreducible h)) (inclusion (irreducible h) h)
h : hedge
*****
synthesis (analysis_def h) M N
+++++
apply SynInc.
-----
Lemma irreducible_impl_cond_irr : forall h : hedge, is_irreducible h -> cond_irr h.
unfold cond_irr in |- *.
unfold is_irreducible in |- *.
unfold equal in |- *.
intros.
elim H.
unfold inclusion in |- *.
intros.
split.
split.
split.
unfold cyph_dec in |- *.
intros.
generalize (H0 (MEnc M K) (MEnc N L) H2).
unfold irreducible in |- *.
unfold reduce in |- *.
intros.
elim H4.
intros.
generalize (ana_h_equiv_irr_h h).
unfold equiv_h in |- *.
intros.
elim H7.
unfold le_h in |- *.
intros.
cut (inclusion (synthesis (irreducible h)) (synthesis h)).
unfold inclusion in |- *.
intros.
apply H10.
unfold inclusion in H8.
apply H8.
apply SynInc.

*****
H10 : forall (M N : Msg) (_ : synthesis (irreducible h) M N), synthesis h M N
H9 : inclusion (synthesis (irreducible h)) (synthesis (analysis_def h))
H8 : forall (M N : Msg) (_ : synthesis (analysis_def h) M N),\nsynthesis (irreducible h) M N
H7 : and (le_h (analysis_def h) (irreducible h))\n (le_h (irreducible h) (analysis_def h))
H6 : or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L))
H5 : analysis_def h (MEnc M K) (MEnc N L)
H4 : and (analysis_def h (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L)))
H3 : synthesis h (inv K) (inv L)
H2 : h (MEnc M K) (MEnc N L)
M,N,K,L : Msg
H1 : forall (M N : Msg) (_ : irreducible h M N), h M N
H0 : forall (M N : Msg) (_ : h M N), irreducible h M N
H : and (inclusion h (irreducible h)) (inclusion (irreducible h) h)
h : hedge
*****
analysis_def h M N
+++++
generalize (analysis_is_analysis h).
-----
Lemma irreducible_impl_cond_irr : forall h : hedge, is_irreducible h -> cond_irr h.
unfold cond_irr in |- *.
unfold is_irreducible in |- *.
unfold equal in |- *.
intros.
elim H.
unfold inclusion in |- *.
intros.
split.
split.
split.
unfold cyph_dec in |- *.
intros.
generalize (H0 (MEnc M K) (MEnc N L) H2).
unfold irreducible in |- *.
unfold reduce in |- *.
intros.
elim H4.
intros.
generalize (ana_h_equiv_irr_h h).
unfold equiv_h in |- *.
intros.
elim H7.
unfold le_h in |- *.
intros.
cut (inclusion (synthesis (irreducible h)) (synthesis h)).
unfold inclusion in |- *.
intros.
apply H10.
unfold inclusion in H8.
apply H8.
apply SynInc.
generalize (analysis_is_analysis h).

*****
H10 : forall (M N : Msg) (_ : synthesis (irreducible h) M N), synthesis h M N
H9 : inclusion (synthesis (irreducible h)) (synthesis (analysis_def h))
H8 : forall (M N : Msg) (_ : synthesis (analysis_def h) M N),\nsynthesis (irreducible h) M N
H7 : and (le_h (analysis_def h) (irreducible h))\n (le_h (irreducible h) (analysis_def h))
H6 : or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L))
H5 : analysis_def h (MEnc M K) (MEnc N L)
H4 : and (analysis_def h (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L)))
H3 : synthesis h (inv K) (inv L)
H2 : h (MEnc M K) (MEnc N L)
M,N,K,L : Msg
H1 : forall (M N : Msg) (_ : irreducible h M N), h M N
H0 : forall (M N : Msg) (_ : h M N), irreducible h M N
H : and (inclusion h (irreducible h)) (inclusion (irreducible h) h)
h : hedge
*****
forall _ : is_analysis h (analysis_def h), analysis_def h M N
+++++
unfold is_analysis in |- *.
-----
Lemma irreducible_impl_cond_irr : forall h : hedge, is_irreducible h -> cond_irr h.
unfold cond_irr in |- *.
unfold is_irreducible in |- *.
unfold equal in |- *.
intros.
elim H.
unfold inclusion in |- *.
intros.
split.
split.
split.
unfold cyph_dec in |- *.
intros.
generalize (H0 (MEnc M K) (MEnc N L) H2).
unfold irreducible in |- *.
unfold reduce in |- *.
intros.
elim H4.
intros.
generalize (ana_h_equiv_irr_h h).
unfold equiv_h in |- *.
intros.
elim H7.
unfold le_h in |- *.
intros.
cut (inclusion (synthesis (irreducible h)) (synthesis h)).
unfold inclusion in |- *.
intros.
apply H10.
unfold inclusion in H8.
apply H8.
apply SynInc.
generalize (analysis_is_analysis h).
unfold is_analysis in |- *.

*****
H10 : forall (M N : Msg) (_ : synthesis (irreducible h) M N), synthesis h M N
H9 : inclusion (synthesis (irreducible h)) (synthesis (analysis_def h))
H8 : forall (M N : Msg) (_ : synthesis (analysis_def h) M N),\nsynthesis (irreducible h) M N
H7 : and (le_h (analysis_def h) (irreducible h))\n (le_h (irreducible h) (analysis_def h))
H6 : or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L))
H5 : analysis_def h (MEnc M K) (MEnc N L)
H4 : and (analysis_def h (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L)))
H3 : synthesis h (inv K) (inv L)
H2 : h (MEnc M K) (MEnc N L)
M,N,K,L : Msg
H1 : forall (M N : Msg) (_ : irreducible h M N), h M N
H0 : forall (M N : Msg) (_ : h M N), irreducible h M N
H : and (inclusion h (irreducible h)) (inclusion (irreducible h) h)
h : hedge
*****
forall _ : and (analysis_cond h (analysis_def h)) (forall (h' : hedge) (_ : analysis_cond h h'), inclusion (analysis_def h) h'), analysis_def h M N
+++++
unfold analysis_cond in |- *.
-----
Lemma irreducible_impl_cond_irr : forall h : hedge, is_irreducible h -> cond_irr h.
unfold cond_irr in |- *.
unfold is_irreducible in |- *.
unfold equal in |- *.
intros.
elim H.
unfold inclusion in |- *.
intros.
split.
split.
split.
unfold cyph_dec in |- *.
intros.
generalize (H0 (MEnc M K) (MEnc N L) H2).
unfold irreducible in |- *.
unfold reduce in |- *.
intros.
elim H4.
intros.
generalize (ana_h_equiv_irr_h h).
unfold equiv_h in |- *.
intros.
elim H7.
unfold le_h in |- *.
intros.
cut (inclusion (synthesis (irreducible h)) (synthesis h)).
unfold inclusion in |- *.
intros.
apply H10.
unfold inclusion in H8.
apply H8.
apply SynInc.
generalize (analysis_is_analysis h).
unfold is_analysis in |- *.
unfold analysis_cond in |- *.

*****
H10 : forall (M N : Msg) (_ : synthesis (irreducible h) M N), synthesis h M N
H9 : inclusion (synthesis (irreducible h)) (synthesis (analysis_def h))
H8 : forall (M N : Msg) (_ : synthesis (analysis_def h) M N),\nsynthesis (irreducible h) M N
H7 : and (le_h (analysis_def h) (irreducible h))\n (le_h (irreducible h) (analysis_def h))
H6 : or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L))
H5 : analysis_def h (MEnc M K) (MEnc N L)
H4 : and (analysis_def h (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L)))
H3 : synthesis h (inv K) (inv L)
H2 : h (MEnc M K) (MEnc N L)
M,N,K,L : Msg
H1 : forall (M N : Msg) (_ : irreducible h M N), h M N
H0 : forall (M N : Msg) (_ : h M N), irreducible h M N
H : and (inclusion h (irreducible h)) (inclusion (irreducible h) h)
h : hedge
*****
forall _ : and (and (inclusion h (analysis_def h)) (stable_analysis (analysis_def h))) (forall (h' : hedge) (_ : and (inclusion h h') (stable_analysis h')), inclusion (analysis_def h) h'), analysis_def h M N
+++++
intros.
-----
Lemma irreducible_impl_cond_irr : forall h : hedge, is_irreducible h -> cond_irr h.
unfold cond_irr in |- *.
unfold is_irreducible in |- *.
unfold equal in |- *.
intros.
elim H.
unfold inclusion in |- *.
intros.
split.
split.
split.
unfold cyph_dec in |- *.
intros.
generalize (H0 (MEnc M K) (MEnc N L) H2).
unfold irreducible in |- *.
unfold reduce in |- *.
intros.
elim H4.
intros.
generalize (ana_h_equiv_irr_h h).
unfold equiv_h in |- *.
intros.
elim H7.
unfold le_h in |- *.
intros.
cut (inclusion (synthesis (irreducible h)) (synthesis h)).
unfold inclusion in |- *.
intros.
apply H10.
unfold inclusion in H8.
apply H8.
apply SynInc.
generalize (analysis_is_analysis h).
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.

*****
H11 : and\n (and (inclusion h (analysis_def h))\n (stable_analysis (analysis_def h)))\n (forall (h' : hedge) (_ : and (inclusion h h') (stable_analysis h')),\n inclusion (analysis_def h) h')
H10 : forall (M N : Msg) (_ : synthesis (irreducible h) M N), synthesis h M N
H9 : inclusion (synthesis (irreducible h)) (synthesis (analysis_def h))
H8 : forall (M N : Msg) (_ : synthesis (analysis_def h) M N),\nsynthesis (irreducible h) M N
H7 : and (le_h (analysis_def h) (irreducible h))\n (le_h (irreducible h) (analysis_def h))
H6 : or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L))
H5 : analysis_def h (MEnc M K) (MEnc N L)
H4 : and (analysis_def h (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L)))
H3 : synthesis h (inv K) (inv L)
H2 : h (MEnc M K) (MEnc N L)
M,N,K,L : Msg
H1 : forall (M N : Msg) (_ : irreducible h M N), h M N
H0 : forall (M N : Msg) (_ : h M N), irreducible h M N
H : and (inclusion h (irreducible h)) (inclusion (irreducible h) h)
h : hedge
*****
analysis_def h M N
+++++
elim H11.
-----
Lemma irreducible_impl_cond_irr : forall h : hedge, is_irreducible h -> cond_irr h.
unfold cond_irr in |- *.
unfold is_irreducible in |- *.
unfold equal in |- *.
intros.
elim H.
unfold inclusion in |- *.
intros.
split.
split.
split.
unfold cyph_dec in |- *.
intros.
generalize (H0 (MEnc M K) (MEnc N L) H2).
unfold irreducible in |- *.
unfold reduce in |- *.
intros.
elim H4.
intros.
generalize (ana_h_equiv_irr_h h).
unfold equiv_h in |- *.
intros.
elim H7.
unfold le_h in |- *.
intros.
cut (inclusion (synthesis (irreducible h)) (synthesis h)).
unfold inclusion in |- *.
intros.
apply H10.
unfold inclusion in H8.
apply H8.
apply SynInc.
generalize (analysis_is_analysis h).
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.
elim H11.

*****
H11 : and\n (and (inclusion h (analysis_def h))\n (stable_analysis (analysis_def h)))\n (forall (h' : hedge) (_ : and (inclusion h h') (stable_analysis h')),\n inclusion (analysis_def h) h')
H10 : forall (M N : Msg) (_ : synthesis (irreducible h) M N), synthesis h M N
H9 : inclusion (synthesis (irreducible h)) (synthesis (analysis_def h))
H8 : forall (M N : Msg) (_ : synthesis (analysis_def h) M N),\nsynthesis (irreducible h) M N
H7 : and (le_h (analysis_def h) (irreducible h))\n (le_h (irreducible h) (analysis_def h))
H6 : or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L))
H5 : analysis_def h (MEnc M K) (MEnc N L)
H4 : and (analysis_def h (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L)))
H3 : synthesis h (inv K) (inv L)
H2 : h (MEnc M K) (MEnc N L)
M,N,K,L : Msg
H1 : forall (M N : Msg) (_ : irreducible h M N), h M N
H0 : forall (M N : Msg) (_ : h M N), irreducible h M N
H : and (inclusion h (irreducible h)) (inclusion (irreducible h) h)
h : hedge
*****
forall (_ : and (inclusion h (analysis_def h)) (stable_analysis (analysis_def h))) (_ : forall (h' : hedge) (_ : and (inclusion h h') (stable_analysis h')), inclusion (analysis_def h) h'), analysis_def h M N
+++++
intros.
-----
Lemma irreducible_impl_cond_irr : forall h : hedge, is_irreducible h -> cond_irr h.
unfold cond_irr in |- *.
unfold is_irreducible in |- *.
unfold equal in |- *.
intros.
elim H.
unfold inclusion in |- *.
intros.
split.
split.
split.
unfold cyph_dec in |- *.
intros.
generalize (H0 (MEnc M K) (MEnc N L) H2).
unfold irreducible in |- *.
unfold reduce in |- *.
intros.
elim H4.
intros.
generalize (ana_h_equiv_irr_h h).
unfold equiv_h in |- *.
intros.
elim H7.
unfold le_h in |- *.
intros.
cut (inclusion (synthesis (irreducible h)) (synthesis h)).
unfold inclusion in |- *.
intros.
apply H10.
unfold inclusion in H8.
apply H8.
apply SynInc.
generalize (analysis_is_analysis h).
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.
elim H11.
intros.

*****
H13 : forall (h' : hedge) (_ : and (inclusion h h') (stable_analysis h')),\ninclusion (analysis_def h) h'
H12 : and (inclusion h (analysis_def h)) (stable_analysis (analysis_def h))
H11 : and\n (and (inclusion h (analysis_def h))\n (stable_analysis (analysis_def h)))\n (forall (h' : hedge) (_ : and (inclusion h h') (stable_analysis h')),\n inclusion (analysis_def h) h')
H10 : forall (M N : Msg) (_ : synthesis (irreducible h) M N), synthesis h M N
H9 : inclusion (synthesis (irreducible h)) (synthesis (analysis_def h))
H8 : forall (M N : Msg) (_ : synthesis (analysis_def h) M N),\nsynthesis (irreducible h) M N
H7 : and (le_h (analysis_def h) (irreducible h))\n (le_h (irreducible h) (analysis_def h))
H6 : or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L))
H5 : analysis_def h (MEnc M K) (MEnc N L)
H4 : and (analysis_def h (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L)))
H3 : synthesis h (inv K) (inv L)
H2 : h (MEnc M K) (MEnc N L)
M,N,K,L : Msg
H1 : forall (M N : Msg) (_ : irreducible h M N), h M N
H0 : forall (M N : Msg) (_ : h M N), irreducible h M N
H : and (inclusion h (irreducible h)) (inclusion (irreducible h) h)
h : hedge
*****
analysis_def h M N
+++++
elim H12.
-----
Lemma irreducible_impl_cond_irr : forall h : hedge, is_irreducible h -> cond_irr h.
unfold cond_irr in |- *.
unfold is_irreducible in |- *.
unfold equal in |- *.
intros.
elim H.
unfold inclusion in |- *.
intros.
split.
split.
split.
unfold cyph_dec in |- *.
intros.
generalize (H0 (MEnc M K) (MEnc N L) H2).
unfold irreducible in |- *.
unfold reduce in |- *.
intros.
elim H4.
intros.
generalize (ana_h_equiv_irr_h h).
unfold equiv_h in |- *.
intros.
elim H7.
unfold le_h in |- *.
intros.
cut (inclusion (synthesis (irreducible h)) (synthesis h)).
unfold inclusion in |- *.
intros.
apply H10.
unfold inclusion in H8.
apply H8.
apply SynInc.
generalize (analysis_is_analysis h).
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.
elim H11.
intros.
elim H12.

*****
H13 : forall (h' : hedge) (_ : and (inclusion h h') (stable_analysis h')),\ninclusion (analysis_def h) h'
H12 : and (inclusion h (analysis_def h)) (stable_analysis (analysis_def h))
H11 : and\n (and (inclusion h (analysis_def h))\n (stable_analysis (analysis_def h)))\n (forall (h' : hedge) (_ : and (inclusion h h') (stable_analysis h')),\n inclusion (analysis_def h) h')
H10 : forall (M N : Msg) (_ : synthesis (irreducible h) M N), synthesis h M N
H9 : inclusion (synthesis (irreducible h)) (synthesis (analysis_def h))
H8 : forall (M N : Msg) (_ : synthesis (analysis_def h) M N),\nsynthesis (irreducible h) M N
H7 : and (le_h (analysis_def h) (irreducible h))\n (le_h (irreducible h) (analysis_def h))
H6 : or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L))
H5 : analysis_def h (MEnc M K) (MEnc N L)
H4 : and (analysis_def h (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L)))
H3 : synthesis h (inv K) (inv L)
H2 : h (MEnc M K) (MEnc N L)
M,N,K,L : Msg
H1 : forall (M N : Msg) (_ : irreducible h M N), h M N
H0 : forall (M N : Msg) (_ : h M N), irreducible h M N
H : and (inclusion h (irreducible h)) (inclusion (irreducible h) h)
h : hedge
*****
forall (_ : inclusion h (analysis_def h)) (_ : stable_analysis (analysis_def h)), analysis_def h M N
+++++
unfold stable_analysis in |- *.
-----
Lemma irreducible_impl_cond_irr : forall h : hedge, is_irreducible h -> cond_irr h.
unfold cond_irr in |- *.
unfold is_irreducible in |- *.
unfold equal in |- *.
intros.
elim H.
unfold inclusion in |- *.
intros.
split.
split.
split.
unfold cyph_dec in |- *.
intros.
generalize (H0 (MEnc M K) (MEnc N L) H2).
unfold irreducible in |- *.
unfold reduce in |- *.
intros.
elim H4.
intros.
generalize (ana_h_equiv_irr_h h).
unfold equiv_h in |- *.
intros.
elim H7.
unfold le_h in |- *.
intros.
cut (inclusion (synthesis (irreducible h)) (synthesis h)).
unfold inclusion in |- *.
intros.
apply H10.
unfold inclusion in H8.
apply H8.
apply SynInc.
generalize (analysis_is_analysis h).
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.
elim H11.
intros.
elim H12.
unfold stable_analysis in |- *.

*****
H13 : forall (h' : hedge) (_ : and (inclusion h h') (stable_analysis h')),\ninclusion (analysis_def h) h'
H12 : and (inclusion h (analysis_def h)) (stable_analysis (analysis_def h))
H11 : and\n (and (inclusion h (analysis_def h))\n (stable_analysis (analysis_def h)))\n (forall (h' : hedge) (_ : and (inclusion h h') (stable_analysis h')),\n inclusion (analysis_def h) h')
H10 : forall (M N : Msg) (_ : synthesis (irreducible h) M N), synthesis h M N
H9 : inclusion (synthesis (irreducible h)) (synthesis (analysis_def h))
H8 : forall (M N : Msg) (_ : synthesis (analysis_def h) M N),\nsynthesis (irreducible h) M N
H7 : and (le_h (analysis_def h) (irreducible h))\n (le_h (irreducible h) (analysis_def h))
H6 : or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L))
H5 : analysis_def h (MEnc M K) (MEnc N L)
H4 : and (analysis_def h (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L)))
H3 : synthesis h (inv K) (inv L)
H2 : h (MEnc M K) (MEnc N L)
M,N,K,L : Msg
H1 : forall (M N : Msg) (_ : irreducible h M N), h M N
H0 : forall (M N : Msg) (_ : h M N), irreducible h M N
H : and (inclusion h (irreducible h)) (inclusion (irreducible h) h)
h : hedge
*****
forall (_ : inclusion h (analysis_def h)) (_ : inclusion (analysis (analysis_def h)) (analysis_def h)), analysis_def h M N
+++++
intros.
-----
Lemma irreducible_impl_cond_irr : forall h : hedge, is_irreducible h -> cond_irr h.
unfold cond_irr in |- *.
unfold is_irreducible in |- *.
unfold equal in |- *.
intros.
elim H.
unfold inclusion in |- *.
intros.
split.
split.
split.
unfold cyph_dec in |- *.
intros.
generalize (H0 (MEnc M K) (MEnc N L) H2).
unfold irreducible in |- *.
unfold reduce in |- *.
intros.
elim H4.
intros.
generalize (ana_h_equiv_irr_h h).
unfold equiv_h in |- *.
intros.
elim H7.
unfold le_h in |- *.
intros.
cut (inclusion (synthesis (irreducible h)) (synthesis h)).
unfold inclusion in |- *.
intros.
apply H10.
unfold inclusion in H8.
apply H8.
apply SynInc.
generalize (analysis_is_analysis h).
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.
elim H11.
intros.
elim H12.
unfold stable_analysis in |- *.
intros.

*****
H15 : inclusion (analysis (analysis_def h)) (analysis_def h)
H14 : inclusion h (analysis_def h)
H13 : forall (h' : hedge) (_ : and (inclusion h h') (stable_analysis h')),\ninclusion (analysis_def h) h'
H12 : and (inclusion h (analysis_def h)) (stable_analysis (analysis_def h))
H11 : and\n (and (inclusion h (analysis_def h))\n (stable_analysis (analysis_def h)))\n (forall (h' : hedge) (_ : and (inclusion h h') (stable_analysis h')),\n inclusion (analysis_def h) h')
H10 : forall (M N : Msg) (_ : synthesis (irreducible h) M N), synthesis h M N
H9 : inclusion (synthesis (irreducible h)) (synthesis (analysis_def h))
H8 : forall (M N : Msg) (_ : synthesis (analysis_def h) M N),\nsynthesis (irreducible h) M N
H7 : and (le_h (analysis_def h) (irreducible h))\n (le_h (irreducible h) (analysis_def h))
H6 : or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L))
H5 : analysis_def h (MEnc M K) (MEnc N L)
H4 : and (analysis_def h (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L)))
H3 : synthesis h (inv K) (inv L)
H2 : h (MEnc M K) (MEnc N L)
M,N,K,L : Msg
H1 : forall (M N : Msg) (_ : irreducible h M N), h M N
H0 : forall (M N : Msg) (_ : h M N), irreducible h M N
H : and (inclusion h (irreducible h)) (inclusion (irreducible h) h)
h : hedge
*****
analysis_def h M N
+++++
unfold inclusion in H15.
-----
Lemma irreducible_impl_cond_irr : forall h : hedge, is_irreducible h -> cond_irr h.
unfold cond_irr in |- *.
unfold is_irreducible in |- *.
unfold equal in |- *.
intros.
elim H.
unfold inclusion in |- *.
intros.
split.
split.
split.
unfold cyph_dec in |- *.
intros.
generalize (H0 (MEnc M K) (MEnc N L) H2).
unfold irreducible in |- *.
unfold reduce in |- *.
intros.
elim H4.
intros.
generalize (ana_h_equiv_irr_h h).
unfold equiv_h in |- *.
intros.
elim H7.
unfold le_h in |- *.
intros.
cut (inclusion (synthesis (irreducible h)) (synthesis h)).
unfold inclusion in |- *.
intros.
apply H10.
unfold inclusion in H8.
apply H8.
apply SynInc.
generalize (analysis_is_analysis h).
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.
elim H11.
intros.
elim H12.
unfold stable_analysis in |- *.
intros.
unfold inclusion in H15.

*****
H15 : forall (M N : Msg) (_ : analysis (analysis_def h) M N),\nanalysis_def h M N
H14 : inclusion h (analysis_def h)
H13 : forall (h' : hedge) (_ : and (inclusion h h') (stable_analysis h')),\ninclusion (analysis_def h) h'
H12 : and (inclusion h (analysis_def h)) (stable_analysis (analysis_def h))
H11 : and\n (and (inclusion h (analysis_def h))\n (stable_analysis (analysis_def h)))\n (forall (h' : hedge) (_ : and (inclusion h h') (stable_analysis h')),\n inclusion (analysis_def h) h')
H10 : forall (M N : Msg) (_ : synthesis (irreducible h) M N), synthesis h M N
H9 : inclusion (synthesis (irreducible h)) (synthesis (analysis_def h))
H8 : forall (M N : Msg) (_ : synthesis (analysis_def h) M N),\nsynthesis (irreducible h) M N
H7 : and (le_h (analysis_def h) (irreducible h))\n (le_h (irreducible h) (analysis_def h))
H6 : or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L))
H5 : analysis_def h (MEnc M K) (MEnc N L)
H4 : and (analysis_def h (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L)))
H3 : synthesis h (inv K) (inv L)
H2 : h (MEnc M K) (MEnc N L)
M,N,K,L : Msg
H1 : forall (M N : Msg) (_ : irreducible h M N), h M N
H0 : forall (M N : Msg) (_ : h M N), irreducible h M N
H : and (inclusion h (irreducible h)) (inclusion (irreducible h) h)
h : hedge
*****
analysis_def h M N
+++++
apply H15.
-----
Lemma irreducible_impl_cond_irr : forall h : hedge, is_irreducible h -> cond_irr h.
unfold cond_irr in |- *.
unfold is_irreducible in |- *.
unfold equal in |- *.
intros.
elim H.
unfold inclusion in |- *.
intros.
split.
split.
split.
unfold cyph_dec in |- *.
intros.
generalize (H0 (MEnc M K) (MEnc N L) H2).
unfold irreducible in |- *.
unfold reduce in |- *.
intros.
elim H4.
intros.
generalize (ana_h_equiv_irr_h h).
unfold equiv_h in |- *.
intros.
elim H7.
unfold le_h in |- *.
intros.
cut (inclusion (synthesis (irreducible h)) (synthesis h)).
unfold inclusion in |- *.
intros.
apply H10.
unfold inclusion in H8.
apply H8.
apply SynInc.
generalize (analysis_is_analysis h).
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.
elim H11.
intros.
elim H12.
unfold stable_analysis in |- *.
intros.
unfold inclusion in H15.
apply H15.

*****
H15 : forall (M N : Msg) (_ : analysis (analysis_def h) M N),\nanalysis_def h M N
H14 : inclusion h (analysis_def h)
H13 : forall (h' : hedge) (_ : and (inclusion h h') (stable_analysis h')),\ninclusion (analysis_def h) h'
H12 : and (inclusion h (analysis_def h)) (stable_analysis (analysis_def h))
H11 : and\n (and (inclusion h (analysis_def h))\n (stable_analysis (analysis_def h)))\n (forall (h' : hedge) (_ : and (inclusion h h') (stable_analysis h')),\n inclusion (analysis_def h) h')
H10 : forall (M N : Msg) (_ : synthesis (irreducible h) M N), synthesis h M N
H9 : inclusion (synthesis (irreducible h)) (synthesis (analysis_def h))
H8 : forall (M N : Msg) (_ : synthesis (analysis_def h) M N),\nsynthesis (irreducible h) M N
H7 : and (le_h (analysis_def h) (irreducible h))\n (le_h (irreducible h) (analysis_def h))
H6 : or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L))
H5 : analysis_def h (MEnc M K) (MEnc N L)
H4 : and (analysis_def h (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L)))
H3 : synthesis h (inv K) (inv L)
H2 : h (MEnc M K) (MEnc N L)
M,N,K,L : Msg
H1 : forall (M N : Msg) (_ : irreducible h M N), h M N
H0 : forall (M N : Msg) (_ : h M N), irreducible h M N
H : and (inclusion h (irreducible h)) (inclusion (irreducible h) h)
h : hedge
*****
analysis (analysis_def h) M N
+++++
apply (AnaDec (analysis_def h) M N K L).
-----
Lemma irreducible_impl_cond_irr : forall h : hedge, is_irreducible h -> cond_irr h.
unfold cond_irr in |- *.
unfold is_irreducible in |- *.
unfold equal in |- *.
intros.
elim H.
unfold inclusion in |- *.
intros.
split.
split.
split.
unfold cyph_dec in |- *.
intros.
generalize (H0 (MEnc M K) (MEnc N L) H2).
unfold irreducible in |- *.
unfold reduce in |- *.
intros.
elim H4.
intros.
generalize (ana_h_equiv_irr_h h).
unfold equiv_h in |- *.
intros.
elim H7.
unfold le_h in |- *.
intros.
cut (inclusion (synthesis (irreducible h)) (synthesis h)).
unfold inclusion in |- *.
intros.
apply H10.
unfold inclusion in H8.
apply H8.
apply SynInc.
generalize (analysis_is_analysis h).
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.
elim H11.
intros.
elim H12.
unfold stable_analysis in |- *.
intros.
unfold inclusion in H15.
apply H15.
apply (AnaDec (analysis_def h) M N K L).

*****
H15 : forall (M N : Msg) (_ : analysis (analysis_def h) M N),\nanalysis_def h M N
H14 : inclusion h (analysis_def h)
H13 : forall (h' : hedge) (_ : and (inclusion h h') (stable_analysis h')),\ninclusion (analysis_def h) h'
H12 : and (inclusion h (analysis_def h)) (stable_analysis (analysis_def h))
H11 : and\n (and (inclusion h (analysis_def h))\n (stable_analysis (analysis_def h)))\n (forall (h' : hedge) (_ : and (inclusion h h') (stable_analysis h')),\n inclusion (analysis_def h) h')
H10 : forall (M N : Msg) (_ : synthesis (irreducible h) M N), synthesis h M N
H9 : inclusion (synthesis (irreducible h)) (synthesis (analysis_def h))
H8 : forall (M N : Msg) (_ : synthesis (analysis_def h) M N),\nsynthesis (irreducible h) M N
H7 : and (le_h (analysis_def h) (irreducible h))\n (le_h (irreducible h) (analysis_def h))
H6 : or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L))
H5 : analysis_def h (MEnc M K) (MEnc N L)
H4 : and (analysis_def h (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L)))
H3 : synthesis h (inv K) (inv L)
H2 : h (MEnc M K) (MEnc N L)
M,N,K,L : Msg
H1 : forall (M N : Msg) (_ : irreducible h M N), h M N
H0 : forall (M N : Msg) (_ : h M N), irreducible h M N
H : and (inclusion h (irreducible h)) (inclusion (irreducible h) h)
h : hedge
*****
analysis (analysis_def h) (MEnc M K) (MEnc N L)
+++++
apply AnaInc.
-----
Lemma irreducible_impl_cond_irr : forall h : hedge, is_irreducible h -> cond_irr h.
unfold cond_irr in |- *.
unfold is_irreducible in |- *.
unfold equal in |- *.
intros.
elim H.
unfold inclusion in |- *.
intros.
split.
split.
split.
unfold cyph_dec in |- *.
intros.
generalize (H0 (MEnc M K) (MEnc N L) H2).
unfold irreducible in |- *.
unfold reduce in |- *.
intros.
elim H4.
intros.
generalize (ana_h_equiv_irr_h h).
unfold equiv_h in |- *.
intros.
elim H7.
unfold le_h in |- *.
intros.
cut (inclusion (synthesis (irreducible h)) (synthesis h)).
unfold inclusion in |- *.
intros.
apply H10.
unfold inclusion in H8.
apply H8.
apply SynInc.
generalize (analysis_is_analysis h).
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.
elim H11.
intros.
elim H12.
unfold stable_analysis in |- *.
intros.
unfold inclusion in H15.
apply H15.
apply (AnaDec (analysis_def h) M N K L).
apply AnaInc.

*****
H15 : forall (M N : Msg) (_ : analysis (analysis_def h) M N),\nanalysis_def h M N
H14 : inclusion h (analysis_def h)
H13 : forall (h' : hedge) (_ : and (inclusion h h') (stable_analysis h')),\ninclusion (analysis_def h) h'
H12 : and (inclusion h (analysis_def h)) (stable_analysis (analysis_def h))
H11 : and\n (and (inclusion h (analysis_def h))\n (stable_analysis (analysis_def h)))\n (forall (h' : hedge) (_ : and (inclusion h h') (stable_analysis h')),\n inclusion (analysis_def h) h')
H10 : forall (M N : Msg) (_ : synthesis (irreducible h) M N), synthesis h M N
H9 : inclusion (synthesis (irreducible h)) (synthesis (analysis_def h))
H8 : forall (M N : Msg) (_ : synthesis (analysis_def h) M N),\nsynthesis (irreducible h) M N
H7 : and (le_h (analysis_def h) (irreducible h))\n (le_h (irreducible h) (analysis_def h))
H6 : or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L))
H5 : analysis_def h (MEnc M K) (MEnc N L)
H4 : and (analysis_def h (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L)))
H3 : synthesis h (inv K) (inv L)
H2 : h (MEnc M K) (MEnc N L)
M,N,K,L : Msg
H1 : forall (M N : Msg) (_ : irreducible h M N), h M N
H0 : forall (M N : Msg) (_ : h M N), irreducible h M N
H : and (inclusion h (irreducible h)) (inclusion (irreducible h) h)
h : hedge
*****
analysis_def h (MEnc M K) (MEnc N L)
+++++
trivial.
-----
Lemma irreducible_impl_cond_irr : forall h : hedge, is_irreducible h -> cond_irr h.
unfold cond_irr in |- *.
unfold is_irreducible in |- *.
unfold equal in |- *.
intros.
elim H.
unfold inclusion in |- *.
intros.
split.
split.
split.
unfold cyph_dec in |- *.
intros.
generalize (H0 (MEnc M K) (MEnc N L) H2).
unfold irreducible in |- *.
unfold reduce in |- *.
intros.
elim H4.
intros.
generalize (ana_h_equiv_irr_h h).
unfold equiv_h in |- *.
intros.
elim H7.
unfold le_h in |- *.
intros.
cut (inclusion (synthesis (irreducible h)) (synthesis h)).
unfold inclusion in |- *.
intros.
apply H10.
unfold inclusion in H8.
apply H8.
apply SynInc.
generalize (analysis_is_analysis h).
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.
elim H11.
intros.
elim H12.
unfold stable_analysis in |- *.
intros.
unfold inclusion in H15.
apply H15.
apply (AnaDec (analysis_def h) M N K L).

*****
H15 : forall (M N : Msg) (_ : analysis (analysis_def h) M N),\nanalysis_def h M N
H14 : inclusion h (analysis_def h)
H13 : forall (h' : hedge) (_ : and (inclusion h h') (stable_analysis h')),\ninclusion (analysis_def h) h'
H12 : and (inclusion h (analysis_def h)) (stable_analysis (analysis_def h))
H11 : and\n (and (inclusion h (analysis_def h))\n (stable_analysis (analysis_def h)))\n (forall (h' : hedge) (_ : and (inclusion h h') (stable_analysis h')),\n inclusion (analysis_def h) h')
H10 : forall (M N : Msg) (_ : synthesis (irreducible h) M N), synthesis h M N
H9 : inclusion (synthesis (irreducible h)) (synthesis (analysis_def h))
H8 : forall (M N : Msg) (_ : synthesis (analysis_def h) M N),\nsynthesis (irreducible h) M N
H7 : and (le_h (analysis_def h) (irreducible h))\n (le_h (irreducible h) (analysis_def h))
H6 : or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L))
H5 : analysis_def h (MEnc M K) (MEnc N L)
H4 : and (analysis_def h (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L)))
H3 : synthesis h (inv K) (inv L)
H2 : h (MEnc M K) (MEnc N L)
M,N,K,L : Msg
H1 : forall (M N : Msg) (_ : irreducible h M N), h M N
H0 : forall (M N : Msg) (_ : h M N), irreducible h M N
H : and (inclusion h (irreducible h)) (inclusion (irreducible h) h)
h : hedge
*****
synthesis (analysis_def h) (inv K) (inv L)
+++++
generalize (h_le_h_ana_h h).
-----
Lemma irreducible_impl_cond_irr : forall h : hedge, is_irreducible h -> cond_irr h.
unfold cond_irr in |- *.
unfold is_irreducible in |- *.
unfold equal in |- *.
intros.
elim H.
unfold inclusion in |- *.
intros.
split.
split.
split.
unfold cyph_dec in |- *.
intros.
generalize (H0 (MEnc M K) (MEnc N L) H2).
unfold irreducible in |- *.
unfold reduce in |- *.
intros.
elim H4.
intros.
generalize (ana_h_equiv_irr_h h).
unfold equiv_h in |- *.
intros.
elim H7.
unfold le_h in |- *.
intros.
cut (inclusion (synthesis (irreducible h)) (synthesis h)).
unfold inclusion in |- *.
intros.
apply H10.
unfold inclusion in H8.
apply H8.
apply SynInc.
generalize (analysis_is_analysis h).
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.
elim H11.
intros.
elim H12.
unfold stable_analysis in |- *.
intros.
unfold inclusion in H15.
apply H15.
apply (AnaDec (analysis_def h) M N K L).
generalize (h_le_h_ana_h h).

*****
H15 : forall (M N : Msg) (_ : analysis (analysis_def h) M N),\nanalysis_def h M N
H14 : inclusion h (analysis_def h)
H13 : forall (h' : hedge) (_ : and (inclusion h h') (stable_analysis h')),\ninclusion (analysis_def h) h'
H12 : and (inclusion h (analysis_def h)) (stable_analysis (analysis_def h))
H11 : and\n (and (inclusion h (analysis_def h))\n (stable_analysis (analysis_def h)))\n (forall (h' : hedge) (_ : and (inclusion h h') (stable_analysis h')),\n inclusion (analysis_def h) h')
H10 : forall (M N : Msg) (_ : synthesis (irreducible h) M N), synthesis h M N
H9 : inclusion (synthesis (irreducible h)) (synthesis (analysis_def h))
H8 : forall (M N : Msg) (_ : synthesis (analysis_def h) M N),\nsynthesis (irreducible h) M N
H7 : and (le_h (analysis_def h) (irreducible h))\n (le_h (irreducible h) (analysis_def h))
H6 : or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L))
H5 : analysis_def h (MEnc M K) (MEnc N L)
H4 : and (analysis_def h (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L)))
H3 : synthesis h (inv K) (inv L)
H2 : h (MEnc M K) (MEnc N L)
M,N,K,L : Msg
H1 : forall (M N : Msg) (_ : irreducible h M N), h M N
H0 : forall (M N : Msg) (_ : h M N), irreducible h M N
H : and (inclusion h (irreducible h)) (inclusion (irreducible h) h)
h : hedge
*****
forall _ : le_h h (analysis_def h), synthesis (analysis_def h) (inv K) (inv L)
+++++
unfold le_h in |- *.
-----
Lemma irreducible_impl_cond_irr : forall h : hedge, is_irreducible h -> cond_irr h.
unfold cond_irr in |- *.
unfold is_irreducible in |- *.
unfold equal in |- *.
intros.
elim H.
unfold inclusion in |- *.
intros.
split.
split.
split.
unfold cyph_dec in |- *.
intros.
generalize (H0 (MEnc M K) (MEnc N L) H2).
unfold irreducible in |- *.
unfold reduce in |- *.
intros.
elim H4.
intros.
generalize (ana_h_equiv_irr_h h).
unfold equiv_h in |- *.
intros.
elim H7.
unfold le_h in |- *.
intros.
cut (inclusion (synthesis (irreducible h)) (synthesis h)).
unfold inclusion in |- *.
intros.
apply H10.
unfold inclusion in H8.
apply H8.
apply SynInc.
generalize (analysis_is_analysis h).
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.
elim H11.
intros.
elim H12.
unfold stable_analysis in |- *.
intros.
unfold inclusion in H15.
apply H15.
apply (AnaDec (analysis_def h) M N K L).
generalize (h_le_h_ana_h h).
unfold le_h in |- *.

*****
H15 : forall (M N : Msg) (_ : analysis (analysis_def h) M N),\nanalysis_def h M N
H14 : inclusion h (analysis_def h)
H13 : forall (h' : hedge) (_ : and (inclusion h h') (stable_analysis h')),\ninclusion (analysis_def h) h'
H12 : and (inclusion h (analysis_def h)) (stable_analysis (analysis_def h))
H11 : and\n (and (inclusion h (analysis_def h))\n (stable_analysis (analysis_def h)))\n (forall (h' : hedge) (_ : and (inclusion h h') (stable_analysis h')),\n inclusion (analysis_def h) h')
H10 : forall (M N : Msg) (_ : synthesis (irreducible h) M N), synthesis h M N
H9 : inclusion (synthesis (irreducible h)) (synthesis (analysis_def h))
H8 : forall (M N : Msg) (_ : synthesis (analysis_def h) M N),\nsynthesis (irreducible h) M N
H7 : and (le_h (analysis_def h) (irreducible h))\n (le_h (irreducible h) (analysis_def h))
H6 : or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L))
H5 : analysis_def h (MEnc M K) (MEnc N L)
H4 : and (analysis_def h (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L)))
H3 : synthesis h (inv K) (inv L)
H2 : h (MEnc M K) (MEnc N L)
M,N,K,L : Msg
H1 : forall (M N : Msg) (_ : irreducible h M N), h M N
H0 : forall (M N : Msg) (_ : h M N), irreducible h M N
H : and (inclusion h (irreducible h)) (inclusion (irreducible h) h)
h : hedge
*****
forall _ : inclusion (synthesis h) (synthesis (analysis_def h)), synthesis (analysis_def h) (inv K) (inv L)
+++++
unfold inclusion in |- *.
-----
Lemma irreducible_impl_cond_irr : forall h : hedge, is_irreducible h -> cond_irr h.
unfold cond_irr in |- *.
unfold is_irreducible in |- *.
unfold equal in |- *.
intros.
elim H.
unfold inclusion in |- *.
intros.
split.
split.
split.
unfold cyph_dec in |- *.
intros.
generalize (H0 (MEnc M K) (MEnc N L) H2).
unfold irreducible in |- *.
unfold reduce in |- *.
intros.
elim H4.
intros.
generalize (ana_h_equiv_irr_h h).
unfold equiv_h in |- *.
intros.
elim H7.
unfold le_h in |- *.
intros.
cut (inclusion (synthesis (irreducible h)) (synthesis h)).
unfold inclusion in |- *.
intros.
apply H10.
unfold inclusion in H8.
apply H8.
apply SynInc.
generalize (analysis_is_analysis h).
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.
elim H11.
intros.
elim H12.
unfold stable_analysis in |- *.
intros.
unfold inclusion in H15.
apply H15.
apply (AnaDec (analysis_def h) M N K L).
generalize (h_le_h_ana_h h).
unfold le_h in |- *.
unfold inclusion in |- *.

*****
H15 : forall (M N : Msg) (_ : analysis (analysis_def h) M N),\nanalysis_def h M N
H14 : inclusion h (analysis_def h)
H13 : forall (h' : hedge) (_ : and (inclusion h h') (stable_analysis h')),\ninclusion (analysis_def h) h'
H12 : and (inclusion h (analysis_def h)) (stable_analysis (analysis_def h))
H11 : and\n (and (inclusion h (analysis_def h))\n (stable_analysis (analysis_def h)))\n (forall (h' : hedge) (_ : and (inclusion h h') (stable_analysis h')),\n inclusion (analysis_def h) h')
H10 : forall (M N : Msg) (_ : synthesis (irreducible h) M N), synthesis h M N
H9 : inclusion (synthesis (irreducible h)) (synthesis (analysis_def h))
H8 : forall (M N : Msg) (_ : synthesis (analysis_def h) M N),\nsynthesis (irreducible h) M N
H7 : and (le_h (analysis_def h) (irreducible h))\n (le_h (irreducible h) (analysis_def h))
H6 : or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L))
H5 : analysis_def h (MEnc M K) (MEnc N L)
H4 : and (analysis_def h (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L)))
H3 : synthesis h (inv K) (inv L)
H2 : h (MEnc M K) (MEnc N L)
M,N,K,L : Msg
H1 : forall (M N : Msg) (_ : irreducible h M N), h M N
H0 : forall (M N : Msg) (_ : h M N), irreducible h M N
H : and (inclusion h (irreducible h)) (inclusion (irreducible h) h)
h : hedge
*****
forall _ : forall (M N : Msg) (_ : synthesis h M N), synthesis (analysis_def h) M N, synthesis (analysis_def h) (inv K) (inv L)
+++++
auto.
-----
Lemma irreducible_impl_cond_irr : forall h : hedge, is_irreducible h -> cond_irr h.
unfold cond_irr in |- *.
unfold is_irreducible in |- *.
unfold equal in |- *.
intros.
elim H.
unfold inclusion in |- *.
intros.
split.
split.
split.
unfold cyph_dec in |- *.
intros.
generalize (H0 (MEnc M K) (MEnc N L) H2).
unfold irreducible in |- *.
unfold reduce in |- *.
intros.
elim H4.
intros.
generalize (ana_h_equiv_irr_h h).
unfold equiv_h in |- *.
intros.
elim H7.
unfold le_h in |- *.
intros.
cut (inclusion (synthesis (irreducible h)) (synthesis h)).

*****
H9 : inclusion (synthesis (irreducible h)) (synthesis (analysis_def h))
H8 : inclusion (synthesis (analysis_def h)) (synthesis (irreducible h))
H7 : and (le_h (analysis_def h) (irreducible h))\n (le_h (irreducible h) (analysis_def h))
H6 : or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L))
H5 : analysis_def h (MEnc M K) (MEnc N L)
H4 : and (analysis_def h (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L)))
H3 : synthesis h (inv K) (inv L)
H2 : h (MEnc M K) (MEnc N L)
M,N,K,L : Msg
H1 : forall (M N : Msg) (_ : irreducible h M N), h M N
H0 : forall (M N : Msg) (_ : h M N), irreducible h M N
H : and (inclusion h (irreducible h)) (inclusion (irreducible h) h)
h : hedge
*****
inclusion (synthesis (irreducible h)) (synthesis h)
+++++
fold (le_h (irreducible h) h) in |- *.
-----
Lemma irreducible_impl_cond_irr : forall h : hedge, is_irreducible h -> cond_irr h.
unfold cond_irr in |- *.
unfold is_irreducible in |- *.
unfold equal in |- *.
intros.
elim H.
unfold inclusion in |- *.
intros.
split.
split.
split.
unfold cyph_dec in |- *.
intros.
generalize (H0 (MEnc M K) (MEnc N L) H2).
unfold irreducible in |- *.
unfold reduce in |- *.
intros.
elim H4.
intros.
generalize (ana_h_equiv_irr_h h).
unfold equiv_h in |- *.
intros.
elim H7.
unfold le_h in |- *.
intros.
cut (inclusion (synthesis (irreducible h)) (synthesis h)).
fold (le_h (irreducible h) h) in |- *.

*****
H9 : inclusion (synthesis (irreducible h)) (synthesis (analysis_def h))
H8 : inclusion (synthesis (analysis_def h)) (synthesis (irreducible h))
H7 : and (le_h (analysis_def h) (irreducible h))\n (le_h (irreducible h) (analysis_def h))
H6 : or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L))
H5 : analysis_def h (MEnc M K) (MEnc N L)
H4 : and (analysis_def h (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L)))
H3 : synthesis h (inv K) (inv L)
H2 : h (MEnc M K) (MEnc N L)
M,N,K,L : Msg
H1 : forall (M N : Msg) (_ : irreducible h M N), h M N
H0 : forall (M N : Msg) (_ : h M N), irreducible h M N
H : and (inclusion h (irreducible h)) (inclusion (irreducible h) h)
h : hedge
*****
le_h (irreducible h) h
+++++
apply inclusion_impl_le_h.
-----
Lemma irreducible_impl_cond_irr : forall h : hedge, is_irreducible h -> cond_irr h.
unfold cond_irr in |- *.
unfold is_irreducible in |- *.
unfold equal in |- *.
intros.
elim H.
unfold inclusion in |- *.
intros.
split.
split.
split.
unfold cyph_dec in |- *.
intros.
generalize (H0 (MEnc M K) (MEnc N L) H2).
unfold irreducible in |- *.
unfold reduce in |- *.
intros.
elim H4.
intros.
generalize (ana_h_equiv_irr_h h).
unfold equiv_h in |- *.
intros.
elim H7.
unfold le_h in |- *.
intros.
cut (inclusion (synthesis (irreducible h)) (synthesis h)).
fold (le_h (irreducible h) h) in |- *.
apply inclusion_impl_le_h.

*****
H9 : inclusion (synthesis (irreducible h)) (synthesis (analysis_def h))
H8 : inclusion (synthesis (analysis_def h)) (synthesis (irreducible h))
H7 : and (le_h (analysis_def h) (irreducible h))\n (le_h (irreducible h) (analysis_def h))
H6 : or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L))
H5 : analysis_def h (MEnc M K) (MEnc N L)
H4 : and (analysis_def h (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def h) M N))\n (not (synthesis (analysis_def h) K L)))
H3 : synthesis h (inv K) (inv L)
H2 : h (MEnc M K) (MEnc N L)
M,N,K,L : Msg
H1 : forall (M N : Msg) (_ : irreducible h M N), h M N
H0 : forall (M N : Msg) (_ : h M N), irreducible h M N
H : and (inclusion h (irreducible h)) (inclusion (irreducible h) h)
h : hedge
*****
inclusion (irreducible h) h
+++++
tauto.
-----
Lemma irreducible_impl_cond_irr : forall h : hedge, is_irreducible h -> cond_irr h.
unfold cond_irr in |- *.
unfold is_irreducible in |- *.
unfold equal in |- *.
intros.
elim H.
unfold inclusion in |- *.
intros.
split.

*****

*****

+++++
Qed.
-----
Theorem irreducible_iff_cond_irr :\n forall h : hedge, cond_irr h <-> is_irreducible h.
-----
Theorem irreducible_iff_cond_irr : forall h : hedge, cond_irr h <-> is_irreducible h.

*****

*****
forall h : hedge, iff (cond_irr h) (is_irreducible h)
+++++
intros.
-----
Theorem irreducible_iff_cond_irr : forall h : hedge, cond_irr h <-> is_irreducible h.
intros.

*****
h : hedge
*****
iff (cond_irr h) (is_irreducible h)
+++++
split.
-----
Theorem irreducible_iff_cond_irr : forall h : hedge, cond_irr h <-> is_irreducible h.
intros.
split.

*****
h : hedge
*****
forall _ : cond_irr h, is_irreducible h
+++++
apply cond_irr_impl_irreducible.
-----
Theorem irreducible_iff_cond_irr : forall h : hedge, cond_irr h <-> is_irreducible h.
intros.
split.

*****
h : hedge
*****
forall _ : is_irreducible h, cond_irr h
+++++
apply irreducible_impl_cond_irr.
-----
Theorem irreducible_iff_cond_irr : forall h : hedge, cond_irr h <-> is_irreducible h.
intros.
split.

*****

*****

+++++
Qed.
-----
Theorem consistent_impl_irreducible :\n forall h : hedge, is_consistent h -> is_irreducible h.
-----
Theorem consistent_impl_irreducible : forall h : hedge, is_consistent h -> is_irreducible h.

*****

*****
forall (h : hedge) (_ : is_consistent h), is_irreducible h
+++++
intros.
-----
Theorem consistent_impl_irreducible : forall h : hedge, is_consistent h -> is_irreducible h.
intros.

*****
H : is_consistent h
h : hedge
*****
is_irreducible h
+++++
apply cond_irr_impl_irreducible.
-----
Theorem consistent_impl_irreducible : forall h : hedge, is_consistent h -> is_irreducible h.
intros.
apply cond_irr_impl_irreducible.

*****
H : is_consistent h
h : hedge
*****
cond_irr h
+++++
apply consistent_impl_cond_irr.
-----
Theorem consistent_impl_irreducible : forall h : hedge, is_consistent h -> is_irreducible h.
intros.
apply cond_irr_impl_irreducible.
apply consistent_impl_cond_irr.

*****
H : is_consistent h
h : hedge
*****
is_consistent h
+++++
trivial.
-----
Theorem consistent_impl_irreducible : forall h : hedge, is_consistent h -> is_irreducible h.
intros.
apply cond_irr_impl_irreducible.
apply consistent_impl_cond_irr.
trivial.

*****

*****

+++++
Qed.
-----
Theorem equiv_consistent_consistent_equal :\n forall g h : hedge,\n equiv_h g h -> is_consistent g -> is_consistent h -> equal g h.
-----
Theorem equiv_consistent_consistent_equal : forall g h : hedge, equiv_h g h -> is_consistent g -> is_consistent h -> equal g h.

*****

*****
forall (g h : hedge) (_ : equiv_h g h) (_ : is_consistent g) (_ : is_consistent h), equal g h
+++++
intros.
-----
Theorem equiv_consistent_consistent_equal : forall g h : hedge, equiv_h g h -> is_consistent g -> is_consistent h -> equal g h.
intros.

*****
H1 : is_consistent h
H0 : is_consistent g
H : equiv_h g h
g,h : hedge
*****
equal g h
+++++
apply equiv_irr_irr_impl_equal.
-----
Theorem equiv_consistent_consistent_equal : forall g h : hedge, equiv_h g h -> is_consistent g -> is_consistent h -> equal g h.
intros.
apply equiv_irr_irr_impl_equal.

*****
H1 : is_consistent h
H0 : is_consistent g
H : equiv_h g h
g,h : hedge
*****
equiv_h g h
+++++
try apply consistent_impl_irreducible.
-----
Theorem equiv_consistent_consistent_equal : forall g h : hedge, equiv_h g h -> is_consistent g -> is_consistent h -> equal g h.
intros.
apply equiv_irr_irr_impl_equal.
try apply consistent_impl_irreducible.

*****
H1 : is_consistent h
H0 : is_consistent g
H : equiv_h g h
g,h : hedge
*****
equiv_h g h
+++++
trivial.
-----
Theorem equiv_consistent_consistent_equal : forall g h : hedge, equiv_h g h -> is_consistent g -> is_consistent h -> equal g h.
intros.
apply equiv_irr_irr_impl_equal.

*****
H1 : is_consistent h
H0 : is_consistent g
H : equiv_h g h
g,h : hedge
*****
is_irreducible g
+++++
try apply consistent_impl_irreducible.
-----
Theorem equiv_consistent_consistent_equal : forall g h : hedge, equiv_h g h -> is_consistent g -> is_consistent h -> equal g h.
intros.
apply equiv_irr_irr_impl_equal.
try apply consistent_impl_irreducible.

*****
H1 : is_consistent h
H0 : is_consistent g
H : equiv_h g h
g,h : hedge
*****
is_consistent g
+++++
trivial.
-----
Theorem equiv_consistent_consistent_equal : forall g h : hedge, equiv_h g h -> is_consistent g -> is_consistent h -> equal g h.
intros.
apply equiv_irr_irr_impl_equal.

*****
H1 : is_consistent h
H0 : is_consistent g
H : equiv_h g h
g,h : hedge
*****
is_irreducible h
+++++
try apply consistent_impl_irreducible.
-----
Theorem equiv_consistent_consistent_equal : forall g h : hedge, equiv_h g h -> is_consistent g -> is_consistent h -> equal g h.
intros.
apply equiv_irr_irr_impl_equal.
try apply consistent_impl_irreducible.

*****
H1 : is_consistent h
H0 : is_consistent g
H : equiv_h g h
g,h : hedge
*****
is_consistent h
+++++
trivial.
-----
Theorem equiv_consistent_consistent_equal : forall g h : hedge, equiv_h g h -> is_consistent g -> is_consistent h -> equal g h.
intros.
apply equiv_irr_irr_impl_equal.

*****

*****

+++++
Qed.
-----
Lemma inclusion_transpose_inclusion :\n forall g h : hedge, inclusion g h -> inclusion (transpose g) (transpose h).
-----
Lemma inclusion_transpose_inclusion : forall g h : hedge, inclusion g h -> inclusion (transpose g) (transpose h).

*****

*****
forall (g h : hedge) (_ : inclusion g h), inclusion (transpose g) (transpose h)
+++++
unfold transpose in |- *.
-----
Lemma inclusion_transpose_inclusion : forall g h : hedge, inclusion g h -> inclusion (transpose g) (transpose h).
unfold transpose in |- *.

*****

*****
forall (g h : hedge) (_ : inclusion g h), inclusion (fun M N : Msg => g N M) (fun M N : Msg => h N M)
+++++
unfold inclusion in |- *.
-----
Lemma inclusion_transpose_inclusion : forall g h : hedge, inclusion g h -> inclusion (transpose g) (transpose h).
unfold transpose in |- *.
unfold inclusion in |- *.

*****

*****
forall (g h : hedge) (_ : forall (M N : Msg) (_ : g M N), h M N) (M N : Msg) (_ : g N M), h N M
+++++
intros.
-----
Lemma inclusion_transpose_inclusion : forall g h : hedge, inclusion g h -> inclusion (transpose g) (transpose h).
unfold transpose in |- *.
unfold inclusion in |- *.
intros.

*****
H0 : g N M
M,N : Msg
H : forall (M N : Msg) (_ : g M N), h M N
g,h : hedge
*****
h N M
+++++
apply H.
-----
Lemma inclusion_transpose_inclusion : forall g h : hedge, inclusion g h -> inclusion (transpose g) (transpose h).
unfold transpose in |- *.
unfold inclusion in |- *.
intros.
apply H.

*****
H0 : g N M
M,N : Msg
H : forall (M N : Msg) (_ : g M N), h M N
g,h : hedge
*****
g N M
+++++
trivial.
-----
Lemma inclusion_transpose_inclusion : forall g h : hedge, inclusion g h -> inclusion (transpose g) (transpose h).
unfold transpose in |- *.
unfold inclusion in |- *.
intros.
apply H.
trivial.

*****

*****

+++++
Qed.
-----
Lemma equal_transpose_equal :\n forall g h : hedge, equal g h -> equal (transpose g) (transpose h).
-----
Lemma equal_transpose_equal : forall g h : hedge, equal g h -> equal (transpose g) (transpose h).

*****

*****
forall (g h : hedge) (_ : equal g h), equal (transpose g) (transpose h)
+++++
unfold equal in |- *.
-----
Lemma equal_transpose_equal : forall g h : hedge, equal g h -> equal (transpose g) (transpose h).
unfold equal in |- *.

*****

*****
forall (g h : hedge) (_ : and (inclusion g h) (inclusion h g)), and (inclusion (transpose g) (transpose h)) (inclusion (transpose h) (transpose g))
+++++
intros.
-----
Lemma equal_transpose_equal : forall g h : hedge, equal g h -> equal (transpose g) (transpose h).
unfold equal in |- *.
intros.

*****
H : and (inclusion g h) (inclusion h g)
g,h : hedge
*****
and (inclusion (transpose g) (transpose h)) (inclusion (transpose h) (transpose g))
+++++
split.
-----
Lemma equal_transpose_equal : forall g h : hedge, equal g h -> equal (transpose g) (transpose h).
unfold equal in |- *.
intros.
split.

*****
H : and (inclusion g h) (inclusion h g)
g,h : hedge
*****
inclusion (transpose g) (transpose h)
+++++
apply inclusion_transpose_inclusion.
-----
Lemma equal_transpose_equal : forall g h : hedge, equal g h -> equal (transpose g) (transpose h).
unfold equal in |- *.
intros.
split.
apply inclusion_transpose_inclusion.

*****
H : and (inclusion g h) (inclusion h g)
g,h : hedge
*****
inclusion g h
+++++
tauto.
-----
Lemma equal_transpose_equal : forall g h : hedge, equal g h -> equal (transpose g) (transpose h).
unfold equal in |- *.
intros.
split.

*****
H : and (inclusion g h) (inclusion h g)
g,h : hedge
*****
inclusion (transpose h) (transpose g)
+++++
apply inclusion_transpose_inclusion.
-----
Lemma equal_transpose_equal : forall g h : hedge, equal g h -> equal (transpose g) (transpose h).
unfold equal in |- *.
intros.
split.
apply inclusion_transpose_inclusion.

*****
H : and (inclusion g h) (inclusion h g)
g,h : hedge
*****
inclusion h g
+++++
tauto.
-----
Lemma equal_transpose_equal : forall g h : hedge, equal g h -> equal (transpose g) (transpose h).
unfold equal in |- *.
intros.
split.

*****

*****

+++++
Qed.
-----
Lemma transpose_invol : forall h : hedge, equal h (transpose (transpose h)).
-----
Lemma transpose_invol : forall h : hedge, equal h (transpose (transpose h)).

*****

*****
forall h : hedge, equal h (transpose (transpose h))
+++++
unfold equal in |- *.
-----
Lemma transpose_invol : forall h : hedge, equal h (transpose (transpose h)).
unfold equal in |- *.

*****

*****
forall h : hedge, and (inclusion h (transpose (transpose h))) (inclusion (transpose (transpose h)) h)
+++++
unfold transpose in |- *.
-----
Lemma transpose_invol : forall h : hedge, equal h (transpose (transpose h)).
unfold equal in |- *.
unfold transpose in |- *.

*****

*****
forall h : hedge, and (inclusion h (fun M N : Msg => h M N)) (inclusion (fun M N : Msg => h M N) h)
+++++
unfold inclusion in |- *.
-----
Lemma transpose_invol : forall h : hedge, equal h (transpose (transpose h)).
unfold equal in |- *.
unfold transpose in |- *.
unfold inclusion in |- *.

*****

*****
forall h : hedge, and (forall (M N : Msg) (_ : h M N), h M N) (forall (M N : Msg) (_ : h M N), h M N)
+++++
tauto.
-----
Lemma transpose_invol : forall h : hedge, equal h (transpose (transpose h)).
unfold equal in |- *.
unfold transpose in |- *.
unfold inclusion in |- *.
tauto.

*****

*****

+++++
Qed.
-----
Lemma synthesis_transpose_transpose_synthesis :\n forall h : hedge, equal (synthesis (transpose h)) (transpose (synthesis h)).
-----
Lemma synthesis_transpose_transpose_synthesis : forall h : hedge, equal (synthesis (transpose h)) (transpose (synthesis h)).

*****

*****
forall h : hedge, equal (synthesis (transpose h)) (transpose (synthesis h))
+++++
unfold equal in |- *.
-----
Lemma synthesis_transpose_transpose_synthesis : forall h : hedge, equal (synthesis (transpose h)) (transpose (synthesis h)).
unfold equal in |- *.

*****

*****
forall h : hedge, and (inclusion (synthesis (transpose h)) (transpose (synthesis h))) (inclusion (transpose (synthesis h)) (synthesis (transpose h)))
+++++
unfold inclusion in |- *.
-----
Lemma synthesis_transpose_transpose_synthesis : forall h : hedge, equal (synthesis (transpose h)) (transpose (synthesis h)).
unfold equal in |- *.
unfold inclusion in |- *.

*****

*****
forall h : hedge, and (forall (M N : Msg) (_ : synthesis (transpose h) M N), transpose (synthesis h) M N) (forall (M N : Msg) (_ : transpose (synthesis h) M N), synthesis (transpose h) M N)
+++++
intros.
-----
Lemma synthesis_transpose_transpose_synthesis : forall h : hedge, equal (synthesis (transpose h)) (transpose (synthesis h)).
unfold equal in |- *.
unfold inclusion in |- *.
intros.

*****
h : hedge
*****
and (forall (M N : Msg) (_ : synthesis (transpose h) M N), transpose (synthesis h) M N) (forall (M N : Msg) (_ : transpose (synthesis h) M N), synthesis (transpose h) M N)
+++++
split.
-----
Lemma synthesis_transpose_transpose_synthesis : forall h : hedge, equal (synthesis (transpose h)) (transpose (synthesis h)).
unfold equal in |- *.
unfold inclusion in |- *.
intros.
split.

*****
h : hedge
*****
forall (M N : Msg) (_ : synthesis (transpose h) M N), transpose (synthesis h) M N
+++++
unfold transpose in |- *.
-----
Lemma synthesis_transpose_transpose_synthesis : forall h : hedge, equal (synthesis (transpose h)) (transpose (synthesis h)).
unfold equal in |- *.
unfold inclusion in |- *.
intros.
split.
unfold transpose in |- *.

*****
h : hedge
*****
forall (M N : Msg) (_ : synthesis (fun M0 N0 : Msg => h N0 M0) M N), synthesis h N M
+++++
intros.
-----
Lemma synthesis_transpose_transpose_synthesis : forall h : hedge, equal (synthesis (transpose h)) (transpose (synthesis h)).
unfold equal in |- *.
unfold inclusion in |- *.
intros.
split.
unfold transpose in |- *.
intros.

*****
H : synthesis (fun M N : Msg => h N M) M N
M,N : Msg
h : hedge
*****
synthesis h N M
+++++
induction H as [M N H| M N K L H1 HrecH1 H0 HrecH0| M1 N1 M2 N2 H1 HrecH1 H0 HrecH0| o M N H HrecH].
-----
Lemma synthesis_transpose_transpose_synthesis : forall h : hedge, equal (synthesis (transpose h)) (transpose (synthesis h)).
unfold equal in |- *.
unfold inclusion in |- *.
intros.
split.
unfold transpose in |- *.
intros.
induction H as [M N H| M N K L H1 HrecH1 H0 HrecH0| M1 N1 M2 N2 H1 HrecH1 H0 HrecH0| o M N H HrecH].

*****
H : h N M
M,N : Msg
h : hedge
*****
synthesis h N M
+++++
apply SynInc.
-----
Lemma synthesis_transpose_transpose_synthesis : forall h : hedge, equal (synthesis (transpose h)) (transpose (synthesis h)).
unfold equal in |- *.
unfold inclusion in |- *.
intros.
split.
unfold transpose in |- *.
intros.
induction H as [M N H| M N K L H1 HrecH1 H0 HrecH0| M1 N1 M2 N2 H1 HrecH1 H0 HrecH0| o M N H HrecH].
apply SynInc.

*****
H : h N M
M,N : Msg
h : hedge
*****
h N M
+++++
trivial.
-----
Lemma synthesis_transpose_transpose_synthesis : forall h : hedge, equal (synthesis (transpose h)) (transpose (synthesis h)).
unfold equal in |- *.
unfold inclusion in |- *.
intros.
split.
unfold transpose in |- *.
intros.
induction H as [M N H| M N K L H1 HrecH1 H0 HrecH0| M1 N1 M2 N2 H1 HrecH1 H0 HrecH0| o M N H HrecH].

*****
HrecH0 : synthesis h L K
HrecH1 : synthesis h N M
H0 : synthesis (fun M N : Msg => h N M) K L
H1 : synthesis (fun M N : Msg => h N M) M N
M,N,K,L : Msg
h : hedge
*****
synthesis h (MEnc N L) (MEnc M K)
+++++
apply SynEnc.
-----
Lemma synthesis_transpose_transpose_synthesis : forall h : hedge, equal (synthesis (transpose h)) (transpose (synthesis h)).
unfold equal in |- *.
unfold inclusion in |- *.
intros.
split.
unfold transpose in |- *.
intros.
induction H as [M N H| M N K L H1 HrecH1 H0 HrecH0| M1 N1 M2 N2 H1 HrecH1 H0 HrecH0| o M N H HrecH].
apply SynEnc.

*****
HrecH0 : synthesis h L K
HrecH1 : synthesis h N M
H0 : synthesis (fun M N : Msg => h N M) K L
H1 : synthesis (fun M N : Msg => h N M) M N
M,N,K,L : Msg
h : hedge
*****
synthesis h N M
+++++
trivial.
-----
Lemma synthesis_transpose_transpose_synthesis : forall h : hedge, equal (synthesis (transpose h)) (transpose (synthesis h)).
unfold equal in |- *.
unfold inclusion in |- *.
intros.
split.
unfold transpose in |- *.
intros.
induction H as [M N H| M N K L H1 HrecH1 H0 HrecH0| M1 N1 M2 N2 H1 HrecH1 H0 HrecH0| o M N H HrecH].
apply SynEnc.

*****
HrecH0 : synthesis h L K
HrecH1 : synthesis h N M
H0 : synthesis (fun M N : Msg => h N M) K L
H1 : synthesis (fun M N : Msg => h N M) M N
M,N,K,L : Msg
h : hedge
*****
synthesis h L K
+++++
trivial.
-----
Lemma synthesis_transpose_transpose_synthesis : forall h : hedge, equal (synthesis (transpose h)) (transpose (synthesis h)).
unfold equal in |- *.
unfold inclusion in |- *.
intros.
split.
unfold transpose in |- *.
intros.
induction H as [M N H| M N K L H1 HrecH1 H0 HrecH0| M1 N1 M2 N2 H1 HrecH1 H0 HrecH0| o M N H HrecH].

*****
HrecH0 : synthesis h N2 M2
HrecH1 : synthesis h N1 M1
H0 : synthesis (fun M N : Msg => h N M) M2 N2
H1 : synthesis (fun M N : Msg => h N M) M1 N1
M1,N1,M2,N2 : Msg
h : hedge
*****
synthesis h (MPair N1 N2) (MPair M1 M2)
+++++
apply SynPair.
-----
Lemma synthesis_transpose_transpose_synthesis : forall h : hedge, equal (synthesis (transpose h)) (transpose (synthesis h)).
unfold equal in |- *.
unfold inclusion in |- *.
intros.
split.
unfold transpose in |- *.
intros.
induction H as [M N H| M N K L H1 HrecH1 H0 HrecH0| M1 N1 M2 N2 H1 HrecH1 H0 HrecH0| o M N H HrecH].
apply SynPair.

*****
HrecH0 : synthesis h N2 M2
HrecH1 : synthesis h N1 M1
H0 : synthesis (fun M N : Msg => h N M) M2 N2
H1 : synthesis (fun M N : Msg => h N M) M1 N1
M1,N1,M2,N2 : Msg
h : hedge
*****
synthesis h N1 M1
+++++
trivial.
-----
Lemma synthesis_transpose_transpose_synthesis : forall h : hedge, equal (synthesis (transpose h)) (transpose (synthesis h)).
unfold equal in |- *.
unfold inclusion in |- *.
intros.
split.
unfold transpose in |- *.
intros.
induction H as [M N H| M N K L H1 HrecH1 H0 HrecH0| M1 N1 M2 N2 H1 HrecH1 H0 HrecH0| o M N H HrecH].
apply SynPair.

*****
HrecH0 : synthesis h N2 M2
HrecH1 : synthesis h N1 M1
H0 : synthesis (fun M N : Msg => h N M) M2 N2
H1 : synthesis (fun M N : Msg => h N M) M1 N1
M1,N1,M2,N2 : Msg
h : hedge
*****
synthesis h N2 M2
+++++
trivial.
-----
Lemma synthesis_transpose_transpose_synthesis : forall h : hedge, equal (synthesis (transpose h)) (transpose (synthesis h)).
unfold equal in |- *.
unfold inclusion in |- *.
intros.
split.
unfold transpose in |- *.
intros.
induction H as [M N H| M N K L H1 HrecH1 H0 HrecH0| M1 N1 M2 N2 H1 HrecH1 H0 HrecH0| o M N H HrecH].

*****
HrecH : synthesis h N M
H : synthesis (fun M N : Msg => h N M) M N
M,N : Msg
o : op
h : hedge
*****
synthesis h (Mop o N) (Mop o M)
+++++
apply SynOp.
-----
Lemma synthesis_transpose_transpose_synthesis : forall h : hedge, equal (synthesis (transpose h)) (transpose (synthesis h)).
unfold equal in |- *.
unfold inclusion in |- *.
intros.
split.
unfold transpose in |- *.
intros.
induction H as [M N H| M N K L H1 HrecH1 H0 HrecH0| M1 N1 M2 N2 H1 HrecH1 H0 HrecH0| o M N H HrecH].
apply SynOp.

*****
HrecH : synthesis h N M
H : synthesis (fun M N : Msg => h N M) M N
M,N : Msg
o : op
h : hedge
*****
synthesis h N M
+++++
trivial.
-----
Lemma synthesis_transpose_transpose_synthesis : forall h : hedge, equal (synthesis (transpose h)) (transpose (synthesis h)).
unfold equal in |- *.
unfold inclusion in |- *.
intros.
split.

*****
h : hedge
*****
forall (M N : Msg) (_ : transpose (synthesis h) M N), synthesis (transpose h) M N
+++++
unfold transpose in |- *.
-----
Lemma synthesis_transpose_transpose_synthesis : forall h : hedge, equal (synthesis (transpose h)) (transpose (synthesis h)).
unfold equal in |- *.
unfold inclusion in |- *.
intros.
split.
unfold transpose in |- *.

*****
h : hedge
*****
forall (M N : Msg) (_ : synthesis h N M), synthesis (fun M0 N0 : Msg => h N0 M0) M N
+++++
intros.
-----
Lemma synthesis_transpose_transpose_synthesis : forall h : hedge, equal (synthesis (transpose h)) (transpose (synthesis h)).
unfold equal in |- *.
unfold inclusion in |- *.
intros.
split.
unfold transpose in |- *.
intros.

*****
H : synthesis h N M
M,N : Msg
h : hedge
*****
synthesis (fun M N : Msg => h N M) M N
+++++
induction H as [M N H| M N K L H1 HrecH1 H0 HrecH0| M1 N1 M2 N2 H1 HrecH1 H0 HrecH0| o M N H HrecH].
-----
Lemma synthesis_transpose_transpose_synthesis : forall h : hedge, equal (synthesis (transpose h)) (transpose (synthesis h)).
unfold equal in |- *.
unfold inclusion in |- *.
intros.
split.
unfold transpose in |- *.
intros.
induction H as [M N H| M N K L H1 HrecH1 H0 HrecH0| M1 N1 M2 N2 H1 HrecH1 H0 HrecH0| o M N H HrecH].

*****
H : h M N
M,N : Msg
h : hedge
*****
synthesis (fun M N : Msg => h N M) N M
+++++
apply SynInc.
-----
Lemma synthesis_transpose_transpose_synthesis : forall h : hedge, equal (synthesis (transpose h)) (transpose (synthesis h)).
unfold equal in |- *.
unfold inclusion in |- *.
intros.
split.
unfold transpose in |- *.
intros.
induction H as [M N H| M N K L H1 HrecH1 H0 HrecH0| M1 N1 M2 N2 H1 HrecH1 H0 HrecH0| o M N H HrecH].
apply SynInc.

*****
H : h M N
M,N : Msg
h : hedge
*****
h M N
+++++
trivial.
-----
Lemma synthesis_transpose_transpose_synthesis : forall h : hedge, equal (synthesis (transpose h)) (transpose (synthesis h)).
unfold equal in |- *.
unfold inclusion in |- *.
intros.
split.
unfold transpose in |- *.
intros.
induction H as [M N H| M N K L H1 HrecH1 H0 HrecH0| M1 N1 M2 N2 H1 HrecH1 H0 HrecH0| o M N H HrecH].

*****
HrecH0 : synthesis (fun M N : Msg => h N M) L K
HrecH1 : synthesis (fun M N : Msg => h N M) N M
H0 : synthesis h K L
H1 : synthesis h M N
M,N,K,L : Msg
h : hedge
*****
synthesis (fun M N : Msg => h N M) (MEnc N L) (MEnc M K)
+++++
apply SynEnc.
-----
Lemma synthesis_transpose_transpose_synthesis : forall h : hedge, equal (synthesis (transpose h)) (transpose (synthesis h)).
unfold equal in |- *.
unfold inclusion in |- *.
intros.
split.
unfold transpose in |- *.
intros.
induction H as [M N H| M N K L H1 HrecH1 H0 HrecH0| M1 N1 M2 N2 H1 HrecH1 H0 HrecH0| o M N H HrecH].
apply SynEnc.

*****
HrecH0 : synthesis (fun M N : Msg => h N M) L K
HrecH1 : synthesis (fun M N : Msg => h N M) N M
H0 : synthesis h K L
H1 : synthesis h M N
M,N,K,L : Msg
h : hedge
*****
synthesis (fun M N : Msg => h N M) N M
+++++
trivial.
-----
Lemma synthesis_transpose_transpose_synthesis : forall h : hedge, equal (synthesis (transpose h)) (transpose (synthesis h)).
unfold equal in |- *.
unfold inclusion in |- *.
intros.
split.
unfold transpose in |- *.
intros.
induction H as [M N H| M N K L H1 HrecH1 H0 HrecH0| M1 N1 M2 N2 H1 HrecH1 H0 HrecH0| o M N H HrecH].
apply SynEnc.

*****
HrecH0 : synthesis (fun M N : Msg => h N M) L K
HrecH1 : synthesis (fun M N : Msg => h N M) N M
H0 : synthesis h K L
H1 : synthesis h M N
M,N,K,L : Msg
h : hedge
*****
synthesis (fun M N : Msg => h N M) L K
+++++
trivial.
-----
Lemma synthesis_transpose_transpose_synthesis : forall h : hedge, equal (synthesis (transpose h)) (transpose (synthesis h)).
unfold equal in |- *.
unfold inclusion in |- *.
intros.
split.
unfold transpose in |- *.
intros.
induction H as [M N H| M N K L H1 HrecH1 H0 HrecH0| M1 N1 M2 N2 H1 HrecH1 H0 HrecH0| o M N H HrecH].

*****
HrecH0 : synthesis (fun M N : Msg => h N M) N2 M2
HrecH1 : synthesis (fun M N : Msg => h N M) N1 M1
H0 : synthesis h M2 N2
H1 : synthesis h M1 N1
M1,N1,M2,N2 : Msg
h : hedge
*****
synthesis (fun M N : Msg => h N M) (MPair N1 N2) (MPair M1 M2)
+++++
apply SynPair.
-----
Lemma synthesis_transpose_transpose_synthesis : forall h : hedge, equal (synthesis (transpose h)) (transpose (synthesis h)).
unfold equal in |- *.
unfold inclusion in |- *.
intros.
split.
unfold transpose in |- *.
intros.
induction H as [M N H| M N K L H1 HrecH1 H0 HrecH0| M1 N1 M2 N2 H1 HrecH1 H0 HrecH0| o M N H HrecH].
apply SynPair.

*****
HrecH0 : synthesis (fun M N : Msg => h N M) N2 M2
HrecH1 : synthesis (fun M N : Msg => h N M) N1 M1
H0 : synthesis h M2 N2
H1 : synthesis h M1 N1
M1,N1,M2,N2 : Msg
h : hedge
*****
synthesis (fun M N : Msg => h N M) N1 M1
+++++
trivial.
-----
Lemma synthesis_transpose_transpose_synthesis : forall h : hedge, equal (synthesis (transpose h)) (transpose (synthesis h)).
unfold equal in |- *.
unfold inclusion in |- *.
intros.
split.
unfold transpose in |- *.
intros.
induction H as [M N H| M N K L H1 HrecH1 H0 HrecH0| M1 N1 M2 N2 H1 HrecH1 H0 HrecH0| o M N H HrecH].
apply SynPair.

*****
HrecH0 : synthesis (fun M N : Msg => h N M) N2 M2
HrecH1 : synthesis (fun M N : Msg => h N M) N1 M1
H0 : synthesis h M2 N2
H1 : synthesis h M1 N1
M1,N1,M2,N2 : Msg
h : hedge
*****
synthesis (fun M N : Msg => h N M) N2 M2
+++++
trivial.
-----
Lemma synthesis_transpose_transpose_synthesis : forall h : hedge, equal (synthesis (transpose h)) (transpose (synthesis h)).
unfold equal in |- *.
unfold inclusion in |- *.
intros.
split.
unfold transpose in |- *.
intros.
induction H as [M N H| M N K L H1 HrecH1 H0 HrecH0| M1 N1 M2 N2 H1 HrecH1 H0 HrecH0| o M N H HrecH].

*****
HrecH : synthesis (fun M N : Msg => h N M) N M
H : synthesis h M N
M,N : Msg
o : op
h : hedge
*****
synthesis (fun M N : Msg => h N M) (Mop o N) (Mop o M)
+++++
apply SynOp.
-----
Lemma synthesis_transpose_transpose_synthesis : forall h : hedge, equal (synthesis (transpose h)) (transpose (synthesis h)).
unfold equal in |- *.
unfold inclusion in |- *.
intros.
split.
unfold transpose in |- *.
intros.
induction H as [M N H| M N K L H1 HrecH1 H0 HrecH0| M1 N1 M2 N2 H1 HrecH1 H0 HrecH0| o M N H HrecH].
apply SynOp.

*****
HrecH : synthesis (fun M N : Msg => h N M) N M
H : synthesis h M N
M,N : Msg
o : op
h : hedge
*****
synthesis (fun M N : Msg => h N M) N M
+++++
trivial.
-----
Lemma synthesis_transpose_transpose_synthesis : forall h : hedge, equal (synthesis (transpose h)) (transpose (synthesis h)).
unfold equal in |- *.
unfold inclusion in |- *.
intros.
split.

*****

*****

+++++
Qed.
-----
Lemma le_h_transpose_le_h :\n forall g h : hedge, le_h g h -> le_h (transpose g) (transpose h).
-----
Lemma le_h_transpose_le_h : forall g h : hedge, le_h g h -> le_h (transpose g) (transpose h).

*****

*****
forall (g h : hedge) (_ : le_h g h), le_h (transpose g) (transpose h)
+++++
intros.
-----
Lemma le_h_transpose_le_h : forall g h : hedge, le_h g h -> le_h (transpose g) (transpose h).
intros.

*****
H : le_h g h
g,h : hedge
*****
le_h (transpose g) (transpose h)
+++++
apply incl_syn_impl_le_h.
-----
Lemma le_h_transpose_le_h : forall g h : hedge, le_h g h -> le_h (transpose g) (transpose h).
intros.
apply incl_syn_impl_le_h.

*****
H : le_h g h
g,h : hedge
*****
inclusion (transpose g) (synthesis (transpose h))
+++++
apply inclusion_trans with (transpose (synthesis h)).
-----
Lemma le_h_transpose_le_h : forall g h : hedge, le_h g h -> le_h (transpose g) (transpose h).
intros.
apply incl_syn_impl_le_h.
apply inclusion_trans with (transpose (synthesis h)).

*****
H : le_h g h
g,h : hedge
*****
inclusion (transpose g) (transpose (synthesis h))
+++++
apply inclusion_transpose_inclusion.
-----
Lemma le_h_transpose_le_h : forall g h : hedge, le_h g h -> le_h (transpose g) (transpose h).
intros.
apply incl_syn_impl_le_h.
apply inclusion_trans with (transpose (synthesis h)).
apply inclusion_transpose_inclusion.

*****
H : le_h g h
g,h : hedge
*****
inclusion g (synthesis h)
+++++
apply le_h_impl_incl_syn.
-----
Lemma le_h_transpose_le_h : forall g h : hedge, le_h g h -> le_h (transpose g) (transpose h).
intros.
apply incl_syn_impl_le_h.
apply inclusion_trans with (transpose (synthesis h)).
apply inclusion_transpose_inclusion.
apply le_h_impl_incl_syn.

*****
H : le_h g h
g,h : hedge
*****
le_h g h
+++++
trivial.
-----
Lemma le_h_transpose_le_h : forall g h : hedge, le_h g h -> le_h (transpose g) (transpose h).
intros.
apply incl_syn_impl_le_h.
apply inclusion_trans with (transpose (synthesis h)).

*****
H : le_h g h
g,h : hedge
*****
inclusion (transpose (synthesis h)) (synthesis (transpose h))
+++++
generalize (synthesis_transpose_transpose_synthesis h).
-----
Lemma le_h_transpose_le_h : forall g h : hedge, le_h g h -> le_h (transpose g) (transpose h).
intros.
apply incl_syn_impl_le_h.
apply inclusion_trans with (transpose (synthesis h)).
generalize (synthesis_transpose_transpose_synthesis h).

*****
H : le_h g h
g,h : hedge
*****
forall _ : equal (synthesis (transpose h)) (transpose (synthesis h)), inclusion (transpose (synthesis h)) (synthesis (transpose h))
+++++
unfold equal in |- *.
-----
Lemma le_h_transpose_le_h : forall g h : hedge, le_h g h -> le_h (transpose g) (transpose h).
intros.
apply incl_syn_impl_le_h.
apply inclusion_trans with (transpose (synthesis h)).
generalize (synthesis_transpose_transpose_synthesis h).
unfold equal in |- *.

*****
H : le_h g h
g,h : hedge
*****
forall _ : and (inclusion (synthesis (transpose h)) (transpose (synthesis h))) (inclusion (transpose (synthesis h)) (synthesis (transpose h))), inclusion (transpose (synthesis h)) (synthesis (transpose h))
+++++
tauto.
-----
Lemma le_h_transpose_le_h : forall g h : hedge, le_h g h -> le_h (transpose g) (transpose h).
intros.
apply incl_syn_impl_le_h.
apply inclusion_trans with (transpose (synthesis h)).

*****

*****

+++++
Qed.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak :\n forall g h : hedge,\n is_irreducible g ->\n is_left_consistent h -> le_h g h -> weak_left_consistent g.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.

*****

*****
forall (g h : hedge) (_ : is_irreducible g) (_ : is_left_consistent h) (_ : le_h g h), weak_left_consistent g
+++++
unfold is_left_consistent in |- *.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.

*****

*****
forall (g h : hedge) (_ : is_irreducible g) (_ : and (name_left_name h) (and (injective_left h) (and (op_synthesis_left h) (and (pair_free_left h) (and (enc_synthesis_left h) (and (enc_analysis_left h) (injective_inv_left h))))))) (_ : le_h g h), weak_left_consistent g
+++++
unfold weak_left_consistent in |- *.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.

*****

*****
forall (g h : hedge) (_ : is_irreducible g) (_ : and (name_left_name h) (and (injective_left h) (and (op_synthesis_left h) (and (pair_free_left h) (and (enc_synthesis_left h) (and (enc_analysis_left h) (injective_inv_left h))))))) (_ : le_h g h), and (name_left_name g) (and (injective_left g) (and (op_synthesis_left g) (and (pair_free_left g) (and (enc_synthesis_left g) (enc_analysis_left g)))))
+++++
intros.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.

*****
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
and (name_left_name g) (and (injective_left g) (and (op_synthesis_left g) (and (pair_free_left g) (and (enc_synthesis_left g) (enc_analysis_left g)))))
+++++
elim H0.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.

*****
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
forall (_ : name_left_name h) (_ : and (injective_left h) (and (op_synthesis_left h) (and (pair_free_left h) (and (enc_synthesis_left h) (and (enc_analysis_left h) (injective_inv_left h)))))), and (name_left_name g) (and (injective_left g) (and (op_synthesis_left g) (and (pair_free_left g) (and (enc_synthesis_left g) (enc_analysis_left g)))))
+++++
intros.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.

*****
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
and (name_left_name g) (and (injective_left g) (and (op_synthesis_left g) (and (pair_free_left g) (and (enc_synthesis_left g) (enc_analysis_left g)))))
+++++
elim H3.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.

*****
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
forall (_ : injective_left h) (_ : and (op_synthesis_left h) (and (pair_free_left h) (and (enc_synthesis_left h) (and (enc_analysis_left h) (injective_inv_left h))))), and (name_left_name g) (and (injective_left g) (and (op_synthesis_left g) (and (pair_free_left g) (and (enc_synthesis_left g) (enc_analysis_left g)))))
+++++
intros.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.

*****
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
and (name_left_name g) (and (injective_left g) (and (op_synthesis_left g) (and (pair_free_left g) (and (enc_synthesis_left g) (enc_analysis_left g)))))
+++++
elim H5.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.

*****
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
forall (_ : op_synthesis_left h) (_ : and (pair_free_left h) (and (enc_synthesis_left h) (and (enc_analysis_left h) (injective_inv_left h)))), and (name_left_name g) (and (injective_left g) (and (op_synthesis_left g) (and (pair_free_left g) (and (enc_synthesis_left g) (enc_analysis_left g)))))
+++++
intros.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.

*****
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
and (name_left_name g) (and (injective_left g) (and (op_synthesis_left g) (and (pair_free_left g) (and (enc_synthesis_left g) (enc_analysis_left g)))))
+++++
elim H7.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.

*****
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
forall (_ : pair_free_left h) (_ : and (enc_synthesis_left h) (and (enc_analysis_left h) (injective_inv_left h))), and (name_left_name g) (and (injective_left g) (and (op_synthesis_left g) (and (pair_free_left g) (and (enc_synthesis_left g) (enc_analysis_left g)))))
+++++
intros.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.

*****
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
and (name_left_name g) (and (injective_left g) (and (op_synthesis_left g) (and (pair_free_left g) (and (enc_synthesis_left g) (enc_analysis_left g)))))
+++++
elim H9.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.

*****
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
forall (_ : enc_synthesis_left h) (_ : and (enc_analysis_left h) (injective_inv_left h)), and (name_left_name g) (and (injective_left g) (and (op_synthesis_left g) (and (pair_free_left g) (and (enc_synthesis_left g) (enc_analysis_left g)))))
+++++
intros.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.

*****
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
and (name_left_name g) (and (injective_left g) (and (op_synthesis_left g) (and (pair_free_left g) (and (enc_synthesis_left g) (enc_analysis_left g)))))
+++++
generalize (inj_left_syn h H4 H10 H6 H8).
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).

*****
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
forall _ : injective_left (synthesis h), and (name_left_name g) (and (injective_left g) (and (op_synthesis_left g) (and (pair_free_left g) (and (enc_synthesis_left g) (enc_analysis_left g)))))
+++++
intro.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.

*****
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
and (name_left_name g) (and (injective_left g) (and (op_synthesis_left g) (and (pair_free_left g) (and (enc_synthesis_left g) (enc_analysis_left g)))))
+++++
split.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.

*****
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
name_left_name g
+++++
unfold name_left_name in |- *.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
unfold name_left_name in |- *.

*****
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
forall (M N : Msg) (_ : g M N) (a : Nam) (_ : eq M (MNam a)), ex (fun b : Nam => eq N (MNam b))
+++++
intros.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
unfold name_left_name in |- *.
intros.

*****
H14 : eq M (MNam a)
a : Nam
H13 : g M N
M,N : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
ex (fun b : Nam => eq N (MNam b))
+++++
generalize (le_h_impl_incl_syn g h H1).
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
unfold name_left_name in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).

*****
H14 : eq M (MNam a)
a : Nam
H13 : g M N
M,N : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
forall _ : inclusion g (synthesis h), ex (fun b : Nam => eq N (MNam b))
+++++
intro.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
unfold name_left_name in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
intro.

*****
H15 : inclusion g (synthesis h)
H14 : eq M (MNam a)
a : Nam
H13 : g M N
M,N : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
ex (fun b : Nam => eq N (MNam b))
+++++
unfold inclusion in H15.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
unfold name_left_name in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
intro.
unfold inclusion in H15.

*****
H15 : forall (M N : Msg) (_ : g M N), synthesis h M N
H14 : eq M (MNam a)
a : Nam
H13 : g M N
M,N : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
ex (fun b : Nam => eq N (MNam b))
+++++
generalize (H15 M N H13).
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
unfold name_left_name in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
intro.
unfold inclusion in H15.
generalize (H15 M N H13).

*****
H15 : forall (M N : Msg) (_ : g M N), synthesis h M N
H14 : eq M (MNam a)
a : Nam
H13 : g M N
M,N : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
forall _ : synthesis h M N, ex (fun b : Nam => eq N (MNam b))
+++++
rewrite H14.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
unfold name_left_name in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
intro.
unfold inclusion in H15.
generalize (H15 M N H13).
rewrite H14.

*****
H15 : forall (M N : Msg) (_ : g M N), synthesis h M N
H14 : eq M (MNam a)
a : Nam
H13 : g M N
M,N : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
forall _ : synthesis h (MNam a) N, ex (fun b : Nam => eq N (MNam b))
+++++
intros.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
unfold name_left_name in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
intro.
unfold inclusion in H15.
generalize (H15 M N H13).
rewrite H14.
intros.

*****
H16 : synthesis h (MNam a) N
H15 : forall (M N : Msg) (_ : g M N), synthesis h M N
H14 : eq M (MNam a)
a : Nam
H13 : g M N
M,N : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
ex (fun b : Nam => eq N (MNam b))
+++++
generalize (nam_left_syn h a N H16).
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
unfold name_left_name in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
intro.
unfold inclusion in H15.
generalize (H15 M N H13).
rewrite H14.
intros.
generalize (nam_left_syn h a N H16).

*****
H16 : synthesis h (MNam a) N
H15 : forall (M N : Msg) (_ : g M N), synthesis h M N
H14 : eq M (MNam a)
a : Nam
H13 : g M N
M,N : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
forall _ : h (MNam a) N, ex (fun b : Nam => eq N (MNam b))
+++++
rewrite <- H14.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
unfold name_left_name in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
intro.
unfold inclusion in H15.
generalize (H15 M N H13).
rewrite H14.
intros.
generalize (nam_left_syn h a N H16).
rewrite <- H14.

*****
H16 : synthesis h (MNam a) N
H15 : forall (M N : Msg) (_ : g M N), synthesis h M N
H14 : eq M (MNam a)
a : Nam
H13 : g M N
M,N : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
forall _ : h M N, ex (fun b : Nam => eq N (MNam b))
+++++
intro.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
unfold name_left_name in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
intro.
unfold inclusion in H15.
generalize (H15 M N H13).
rewrite H14.
intros.
generalize (nam_left_syn h a N H16).
rewrite <- H14.
intro.

*****
H17 : h M N
H16 : synthesis h (MNam a) N
H15 : forall (M N : Msg) (_ : g M N), synthesis h M N
H14 : eq M (MNam a)
a : Nam
H13 : g M N
M,N : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
ex (fun b : Nam => eq N (MNam b))
+++++
unfold name_left_name in H2.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
unfold name_left_name in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
intro.
unfold inclusion in H15.
generalize (H15 M N H13).
rewrite H14.
intros.
generalize (nam_left_syn h a N H16).
rewrite <- H14.
intro.
unfold name_left_name in H2.

*****
H17 : h M N
H16 : synthesis h (MNam a) N
H15 : forall (M N : Msg) (_ : g M N), synthesis h M N
H14 : eq M (MNam a)
a : Nam
H13 : g M N
M,N : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : forall (M N : Msg) (_ : h M N) (a : Nam) (_ : eq M (MNam a)),\nex (fun b : Nam => eq N (MNam b))
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
ex (fun b : Nam => eq N (MNam b))
+++++
apply (H2 M N H17 a H14).
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.

*****
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
and (injective_left g) (and (op_synthesis_left g) (and (pair_free_left g) (and (enc_synthesis_left g) (enc_analysis_left g))))
+++++
split.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.

*****
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
injective_left g
+++++
unfold injective_left in |- *.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
unfold injective_left in |- *.

*****
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
forall (M N : Msg) (_ : g M N) (M' N' : Msg) (_ : g M' N') (_ : eq M M'), eq N N'
+++++
intros.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
unfold injective_left in |- *.
intros.

*****
H15 : eq M M'
H14 : g M' N'
M',N' : Msg
H13 : g M N
M,N : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
eq N N'
+++++
generalize (le_h_impl_incl_syn g h H1).
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
unfold injective_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).

*****
H15 : eq M M'
H14 : g M' N'
M',N' : Msg
H13 : g M N
M,N : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
forall _ : inclusion g (synthesis h), eq N N'
+++++
unfold inclusion in |- *.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
unfold injective_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.

*****
H15 : eq M M'
H14 : g M' N'
M',N' : Msg
H13 : g M N
M,N : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
forall _ : forall (M N : Msg) (_ : g M N), synthesis h M N, eq N N'
+++++
intros.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
unfold injective_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intros.

*****
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : eq M M'
H14 : g M' N'
M',N' : Msg
H13 : g M N
M,N : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
eq N N'
+++++
generalize (H16 M N H13).
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
unfold injective_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intros.
generalize (H16 M N H13).

*****
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : eq M M'
H14 : g M' N'
M',N' : Msg
H13 : g M N
M,N : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
forall _ : synthesis h M N, eq N N'
+++++
generalize (H16 M' N' H14).
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
unfold injective_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intros.
generalize (H16 M N H13).
generalize (H16 M' N' H14).

*****
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : eq M M'
H14 : g M' N'
M',N' : Msg
H13 : g M N
M,N : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
forall (_ : synthesis h M' N') (_ : synthesis h M N), eq N N'
+++++
intros.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
unfold injective_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intros.
generalize (H16 M N H13).
generalize (H16 M' N' H14).
intros.

*****
H18 : synthesis h M N
H17 : synthesis h M' N'
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : eq M M'
H14 : g M' N'
M',N' : Msg
H13 : g M N
M,N : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
eq N N'
+++++
unfold injective_left in H12.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
unfold injective_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intros.
generalize (H16 M N H13).
generalize (H16 M' N' H14).
intros.
unfold injective_left in H12.

*****
H18 : synthesis h M N
H17 : synthesis h M' N'
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : eq M M'
H14 : g M' N'
M',N' : Msg
H13 : g M N
M,N : Msg
H12 : forall (M N : Msg) (_ : synthesis h M N) (M' N' : Msg)\n (_ : synthesis h M' N') (_ : eq M M'), eq N N'
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
eq N N'
+++++
apply (H12 M N H18 M' N' H17 H15).
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.

*****
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
and (op_synthesis_left g) (and (pair_free_left g) (and (enc_synthesis_left g) (enc_analysis_left g)))
+++++
split.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.

*****
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
op_synthesis_left g
+++++
unfold op_synthesis_left in |- *.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
unfold op_synthesis_left in |- *.

*****
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
forall (o : op) (M N : Msg) (_ : g M N) (M' : Msg) (_ : eq M (Mop o M')) (N' : Msg), not (synthesis g M' N')
+++++
intros.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
unfold op_synthesis_left in |- *.
intros.

*****
N' : Msg
H14 : eq M (Mop o M')
M' : Msg
H13 : g M N
M,N : Msg
o : op
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
not (synthesis g M' N')
+++++
generalize (le_h_impl_incl_syn g h H1).
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
unfold op_synthesis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).

*****
N' : Msg
H14 : eq M (Mop o M')
M' : Msg
H13 : g M N
M,N : Msg
o : op
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
forall _ : inclusion g (synthesis h), not (synthesis g M' N')
+++++
unfold inclusion in |- *.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
unfold op_synthesis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.

*****
N' : Msg
H14 : eq M (Mop o M')
M' : Msg
H13 : g M N
M,N : Msg
o : op
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
forall _ : forall (M N : Msg) (_ : g M N), synthesis h M N, not (synthesis g M' N')
+++++
intros.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
unfold op_synthesis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intros.

*****
H15 : forall (M N : Msg) (_ : g M N), synthesis h M N
N' : Msg
H14 : eq M (Mop o M')
M' : Msg
H13 : g M N
M,N : Msg
o : op
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
not (synthesis g M' N')
+++++
generalize (H15 M N H13).
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
unfold op_synthesis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intros.
generalize (H15 M N H13).

*****
H15 : forall (M N : Msg) (_ : g M N), synthesis h M N
N' : Msg
H14 : eq M (Mop o M')
M' : Msg
H13 : g M N
M,N : Msg
o : op
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
forall _ : synthesis h M N, not (synthesis g M' N')
+++++
rewrite H14.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
unfold op_synthesis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intros.
generalize (H15 M N H13).
rewrite H14.

*****
H15 : forall (M N : Msg) (_ : g M N), synthesis h M N
N' : Msg
H14 : eq M (Mop o M')
M' : Msg
H13 : g M N
M,N : Msg
o : op
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
forall _ : synthesis h (Mop o M') N, not (synthesis g M' N')
+++++
intros.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
unfold op_synthesis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intros.
generalize (H15 M N H13).
rewrite H14.
intros.

*****
H16 : synthesis h (Mop o M') N
H15 : forall (M N : Msg) (_ : g M N), synthesis h M N
N' : Msg
H14 : eq M (Mop o M')
M' : Msg
H13 : g M N
M,N : Msg
o : op
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
not (synthesis g M' N')
+++++
inversion H16.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
unfold op_synthesis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intros.
generalize (H15 M N H13).
rewrite H14.
intros.
inversion H16.

*****
H19 : eq N0 N
H18 : eq M0 (Mop o M')
H17 : h (Mop o M') N
M0,N0 : Msg
H16 : synthesis h (Mop o M') N
H15 : forall (M N : Msg) (_ : g M N), synthesis h M N
N' : Msg
H14 : eq M (Mop o M')
M' : Msg
H13 : g M N
M,N : Msg
o : op
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
not (synthesis g M' N')
+++++
unfold op_synthesis_left in H6.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
unfold op_synthesis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intros.
generalize (H15 M N H13).
rewrite H14.
intros.
inversion H16.
unfold op_synthesis_left in H6.

*****
H19 : eq N0 N
H18 : eq M0 (Mop o M')
H17 : h (Mop o M') N
M0,N0 : Msg
H16 : synthesis h (Mop o M') N
H15 : forall (M N : Msg) (_ : g M N), synthesis h M N
N' : Msg
H14 : eq M (Mop o M')
M' : Msg
H13 : g M N
M,N : Msg
o : op
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
not (synthesis g M' N')
+++++
rewrite <- H14 in H17.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
unfold op_synthesis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intros.
generalize (H15 M N H13).
rewrite H14.
intros.
inversion H16.
unfold op_synthesis_left in H6.
rewrite <- H14 in H17.

*****
H19 : eq N0 N
H18 : eq M0 (Mop o M')
H17 : h M N
M0,N0 : Msg
H16 : synthesis h (Mop o M') N
H15 : forall (M N : Msg) (_ : g M N), synthesis h M N
N' : Msg
H14 : eq M (Mop o M')
M' : Msg
H13 : g M N
M,N : Msg
o : op
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
not (synthesis g M' N')
+++++
generalize (H6 o M N H17 M' H14).
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
unfold op_synthesis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intros.
generalize (H15 M N H13).
rewrite H14.
intros.
inversion H16.
unfold op_synthesis_left in H6.
rewrite <- H14 in H17.
generalize (H6 o M N H17 M' H14).

*****
H19 : eq N0 N
H18 : eq M0 (Mop o M')
H17 : h M N
M0,N0 : Msg
H16 : synthesis h (Mop o M') N
H15 : forall (M N : Msg) (_ : g M N), synthesis h M N
N' : Msg
H14 : eq M (Mop o M')
M' : Msg
H13 : g M N
M,N : Msg
o : op
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
forall _ : forall N' : Msg, not (synthesis h M' N'), not (synthesis g M' N')
+++++
intros.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
unfold op_synthesis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intros.
generalize (H15 M N H13).
rewrite H14.
intros.
inversion H16.
unfold op_synthesis_left in H6.
rewrite <- H14 in H17.
generalize (H6 o M N H17 M' H14).
intros.

*****
H20 : forall N' : Msg, not (synthesis h M' N')
H19 : eq N0 N
H18 : eq M0 (Mop o M')
H17 : h M N
M0,N0 : Msg
H16 : synthesis h (Mop o M') N
H15 : forall (M N : Msg) (_ : g M N), synthesis h M N
N' : Msg
H14 : eq M (Mop o M')
M' : Msg
H13 : g M N
M,N : Msg
o : op
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
not (synthesis g M' N')
+++++
red in |- *.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
unfold op_synthesis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intros.
generalize (H15 M N H13).
rewrite H14.
intros.
inversion H16.
unfold op_synthesis_left in H6.
rewrite <- H14 in H17.
generalize (H6 o M N H17 M' H14).
intros.
red in |- *.

*****
H20 : forall N' : Msg, not (synthesis h M' N')
H19 : eq N0 N
H18 : eq M0 (Mop o M')
H17 : h M N
M0,N0 : Msg
H16 : synthesis h (Mop o M') N
H15 : forall (M N : Msg) (_ : g M N), synthesis h M N
N' : Msg
H14 : eq M (Mop o M')
M' : Msg
H13 : g M N
M,N : Msg
o : op
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
forall _ : synthesis g M' N', False
+++++
intro.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
unfold op_synthesis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intros.
generalize (H15 M N H13).
rewrite H14.
intros.
inversion H16.
unfold op_synthesis_left in H6.
rewrite <- H14 in H17.
generalize (H6 o M N H17 M' H14).
intros.
red in |- *.
intro.

*****
H21 : synthesis g M' N'
H20 : forall N' : Msg, not (synthesis h M' N')
H19 : eq N0 N
H18 : eq M0 (Mop o M')
H17 : h M N
M0,N0 : Msg
H16 : synthesis h (Mop o M') N
H15 : forall (M N : Msg) (_ : g M N), synthesis h M N
N' : Msg
H14 : eq M (Mop o M')
M' : Msg
H13 : g M N
M,N : Msg
o : op
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
False
+++++
apply (H20 N').
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
unfold op_synthesis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intros.
generalize (H15 M N H13).
rewrite H14.
intros.
inversion H16.
unfold op_synthesis_left in H6.
rewrite <- H14 in H17.
generalize (H6 o M N H17 M' H14).
intros.
red in |- *.
intro.
apply (H20 N').

*****
H21 : synthesis g M' N'
H20 : forall N' : Msg, not (synthesis h M' N')
H19 : eq N0 N
H18 : eq M0 (Mop o M')
H17 : h M N
M0,N0 : Msg
H16 : synthesis h (Mop o M') N
H15 : forall (M N : Msg) (_ : g M N), synthesis h M N
N' : Msg
H14 : eq M (Mop o M')
M' : Msg
H13 : g M N
M,N : Msg
o : op
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
synthesis h M' N'
+++++
unfold le_h in H1.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
unfold op_synthesis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intros.
generalize (H15 M N H13).
rewrite H14.
intros.
inversion H16.
unfold op_synthesis_left in H6.
rewrite <- H14 in H17.
generalize (H6 o M N H17 M' H14).
intros.
red in |- *.
intro.
apply (H20 N').
unfold le_h in H1.

*****
H21 : synthesis g M' N'
H20 : forall N' : Msg, not (synthesis h M' N')
H19 : eq N0 N
H18 : eq M0 (Mop o M')
H17 : h M N
M0,N0 : Msg
H16 : synthesis h (Mop o M') N
H15 : forall (M N : Msg) (_ : g M N), synthesis h M N
N' : Msg
H14 : eq M (Mop o M')
M' : Msg
H13 : g M N
M,N : Msg
o : op
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : inclusion (synthesis g) (synthesis h)
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
synthesis h M' N'
+++++
unfold inclusion in H1.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
unfold op_synthesis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intros.
generalize (H15 M N H13).
rewrite H14.
intros.
inversion H16.
unfold op_synthesis_left in H6.
rewrite <- H14 in H17.
generalize (H6 o M N H17 M' H14).
intros.
red in |- *.
intro.
apply (H20 N').
unfold le_h in H1.
unfold inclusion in H1.

*****
H21 : synthesis g M' N'
H20 : forall N' : Msg, not (synthesis h M' N')
H19 : eq N0 N
H18 : eq M0 (Mop o M')
H17 : h M N
M0,N0 : Msg
H16 : synthesis h (Mop o M') N
H15 : forall (M N : Msg) (_ : g M N), synthesis h M N
N' : Msg
H14 : eq M (Mop o M')
M' : Msg
H13 : g M N
M,N : Msg
o : op
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : forall (o : op) (M N : Msg) (_ : h M N) (M' : Msg)\n (_ : eq M (Mop o M')) (N' : Msg), not (synthesis h M' N')
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
synthesis h M' N'
+++++
auto.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
unfold op_synthesis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intros.
generalize (H15 M N H13).
rewrite H14.
intros.
inversion H16.

*****
H18 : eq (Mop o N0) N
H19 : eq M0 M'
H17 : eq o0 o
H20 : synthesis h M' N0
M0,N0 : Msg
o0 : op
H16 : synthesis h (Mop o M') N
H15 : forall (M N : Msg) (_ : g M N), synthesis h M N
N' : Msg
H14 : eq M (Mop o M')
M' : Msg
H13 : g M N
M,N : Msg
o : op
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
not (synthesis g M' N')
+++++
red in |- *.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
unfold op_synthesis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intros.
generalize (H15 M N H13).
rewrite H14.
intros.
inversion H16.
red in |- *.

*****
H18 : eq (Mop o N0) N
H19 : eq M0 M'
H17 : eq o0 o
H20 : synthesis h M' N0
M0,N0 : Msg
o0 : op
H16 : synthesis h (Mop o M') N
H15 : forall (M N : Msg) (_ : g M N), synthesis h M N
N' : Msg
H14 : eq M (Mop o M')
M' : Msg
H13 : g M N
M,N : Msg
o : op
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
forall _ : synthesis g M' N', False
+++++
intros.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
unfold op_synthesis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intros.
generalize (H15 M N H13).
rewrite H14.
intros.
inversion H16.
red in |- *.
intros.

*****
H21 : synthesis g M' N'
H18 : eq (Mop o N0) N
H19 : eq M0 M'
H17 : eq o0 o
H20 : synthesis h M' N0
M0,N0 : Msg
o0 : op
H16 : synthesis h (Mop o M') N
H15 : forall (M N : Msg) (_ : g M N), synthesis h M N
N' : Msg
H14 : eq M (Mop o M')
M' : Msg
H13 : g M N
M,N : Msg
o : op
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
False
+++++
unfold le_h in H1.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
unfold op_synthesis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intros.
generalize (H15 M N H13).
rewrite H14.
intros.
inversion H16.
red in |- *.
intros.
unfold le_h in H1.

*****
H21 : synthesis g M' N'
H18 : eq (Mop o N0) N
H19 : eq M0 M'
H17 : eq o0 o
H20 : synthesis h M' N0
M0,N0 : Msg
o0 : op
H16 : synthesis h (Mop o M') N
H15 : forall (M N : Msg) (_ : g M N), synthesis h M N
N' : Msg
H14 : eq M (Mop o M')
M' : Msg
H13 : g M N
M,N : Msg
o : op
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : inclusion (synthesis g) (synthesis h)
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
False
+++++
unfold inclusion in H1.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
unfold op_synthesis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intros.
generalize (H15 M N H13).
rewrite H14.
intros.
inversion H16.
red in |- *.
intros.
unfold le_h in H1.
unfold inclusion in H1.

*****
H21 : synthesis g M' N'
H18 : eq (Mop o N0) N
H19 : eq M0 M'
H17 : eq o0 o
H20 : synthesis h M' N0
M0,N0 : Msg
o0 : op
H16 : synthesis h (Mop o M') N
H15 : forall (M N : Msg) (_ : g M N), synthesis h M N
N' : Msg
H14 : eq M (Mop o M')
M' : Msg
H13 : g M N
M,N : Msg
o : op
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
False
+++++
generalize (H1 M' N' H21).
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
unfold op_synthesis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intros.
generalize (H15 M N H13).
rewrite H14.
intros.
inversion H16.
red in |- *.
intros.
unfold le_h in H1.
unfold inclusion in H1.
generalize (H1 M' N' H21).

*****
H21 : synthesis g M' N'
H18 : eq (Mop o N0) N
H19 : eq M0 M'
H17 : eq o0 o
H20 : synthesis h M' N0
M0,N0 : Msg
o0 : op
H16 : synthesis h (Mop o M') N
H15 : forall (M N : Msg) (_ : g M N), synthesis h M N
N' : Msg
H14 : eq M (Mop o M')
M' : Msg
H13 : g M N
M,N : Msg
o : op
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
forall _ : synthesis h M' N', False
+++++
intro.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
unfold op_synthesis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intros.
generalize (H15 M N H13).
rewrite H14.
intros.
inversion H16.
red in |- *.
intros.
unfold le_h in H1.
unfold inclusion in H1.
generalize (H1 M' N' H21).
intro.

*****
H22 : synthesis h M' N'
H21 : synthesis g M' N'
H18 : eq (Mop o N0) N
H19 : eq M0 M'
H17 : eq o0 o
H20 : synthesis h M' N0
M0,N0 : Msg
o0 : op
H16 : synthesis h (Mop o M') N
H15 : forall (M N : Msg) (_ : g M N), synthesis h M N
N' : Msg
H14 : eq M (Mop o M')
M' : Msg
H13 : g M N
M,N : Msg
o : op
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
False
+++++
cut (N' = N0).
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
unfold op_synthesis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intros.
generalize (H15 M N H13).
rewrite H14.
intros.
inversion H16.
red in |- *.
intros.
unfold le_h in H1.
unfold inclusion in H1.
generalize (H1 M' N' H21).
intro.
cut (N' = N0).

*****
H22 : synthesis h M' N'
H21 : synthesis g M' N'
H18 : eq (Mop o N0) N
H19 : eq M0 M'
H17 : eq o0 o
H20 : synthesis h M' N0
M0,N0 : Msg
o0 : op
H16 : synthesis h (Mop o M') N
H15 : forall (M N : Msg) (_ : g M N), synthesis h M N
N' : Msg
H14 : eq M (Mop o M')
M' : Msg
H13 : g M N
M,N : Msg
o : op
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
forall _ : eq N' N0, False
+++++
intro.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
unfold op_synthesis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intros.
generalize (H15 M N H13).
rewrite H14.
intros.
inversion H16.
red in |- *.
intros.
unfold le_h in H1.
unfold inclusion in H1.
generalize (H1 M' N' H21).
intro.
cut (N' = N0).
intro.

*****
H23 : eq N' N0
H22 : synthesis h M' N'
H21 : synthesis g M' N'
H18 : eq (Mop o N0) N
H19 : eq M0 M'
H17 : eq o0 o
H20 : synthesis h M' N0
M0,N0 : Msg
o0 : op
H16 : synthesis h (Mop o M') N
H15 : forall (M N : Msg) (_ : g M N), synthesis h M N
N' : Msg
H14 : eq M (Mop o M')
M' : Msg
H13 : g M N
M,N : Msg
o : op
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
False
+++++
rewrite <- H23 in H18.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
unfold op_synthesis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intros.
generalize (H15 M N H13).
rewrite H14.
intros.
inversion H16.
red in |- *.
intros.
unfold le_h in H1.
unfold inclusion in H1.
generalize (H1 M' N' H21).
intro.
cut (N' = N0).
intro.
rewrite <- H23 in H18.

*****
H23 : eq N' N0
H22 : synthesis h M' N'
H21 : synthesis g M' N'
H18 : eq (Mop o N') N
H19 : eq M0 M'
H17 : eq o0 o
H20 : synthesis h M' N0
M0,N0 : Msg
o0 : op
H16 : synthesis h (Mop o M') N
H15 : forall (M N : Msg) (_ : g M N), synthesis h M N
N' : Msg
H14 : eq M (Mop o M')
M' : Msg
H13 : g M N
M,N : Msg
o : op
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
False
+++++
rewrite H14 in H13.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
unfold op_synthesis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intros.
generalize (H15 M N H13).
rewrite H14.
intros.
inversion H16.
red in |- *.
intros.
unfold le_h in H1.
unfold inclusion in H1.
generalize (H1 M' N' H21).
intro.
cut (N' = N0).
intro.
rewrite <- H23 in H18.
rewrite H14 in H13.

*****
H23 : eq N' N0
H22 : synthesis h M' N'
H21 : synthesis g M' N'
H18 : eq (Mop o N') N
H19 : eq M0 M'
H17 : eq o0 o
H20 : synthesis h M' N0
M0,N0 : Msg
o0 : op
H16 : synthesis h (Mop o M') N
H15 : forall (M N : Msg) (_ : g M N), synthesis h M N
N' : Msg
H14 : eq M (Mop o M')
H13 : g (Mop o M') N
M,N,M' : Msg
o : op
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
False
+++++
rewrite <- H18 in H13.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
unfold op_synthesis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intros.
generalize (H15 M N H13).
rewrite H14.
intros.
inversion H16.
red in |- *.
intros.
unfold le_h in H1.
unfold inclusion in H1.
generalize (H1 M' N' H21).
intro.
cut (N' = N0).
intro.
rewrite <- H23 in H18.
rewrite H14 in H13.
rewrite <- H18 in H13.

*****
H23 : eq N' N0
H22 : synthesis h M' N'
H21 : synthesis g M' N'
H18 : eq (Mop o N') N
H19 : eq M0 M'
H17 : eq o0 o
H20 : synthesis h M' N0
M0,N0 : Msg
o0 : op
H16 : synthesis h (Mop o M') N
H15 : forall (M N : Msg) (_ : g M N), synthesis h M N
H14 : eq M (Mop o M')
H13 : g (Mop o M') (Mop o N')
M,N,M',N' : Msg
o : op
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
False
+++++
generalize (irreducible_op g).
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
unfold op_synthesis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intros.
generalize (H15 M N H13).
rewrite H14.
intros.
inversion H16.
red in |- *.
intros.
unfold le_h in H1.
unfold inclusion in H1.
generalize (H1 M' N' H21).
intro.
cut (N' = N0).
intro.
rewrite <- H23 in H18.
rewrite H14 in H13.
rewrite <- H18 in H13.
generalize (irreducible_op g).

*****
H23 : eq N' N0
H22 : synthesis h M' N'
H21 : synthesis g M' N'
H18 : eq (Mop o N') N
H19 : eq M0 M'
H17 : eq o0 o
H20 : synthesis h M' N0
M0,N0 : Msg
o0 : op
H16 : synthesis h (Mop o M') N
H15 : forall (M N : Msg) (_ : g M N), synthesis h M N
H14 : eq M (Mop o M')
H13 : g (Mop o M') (Mop o N')
M,N,M',N' : Msg
o : op
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
forall _ : forall (oM oN : op) (M N : Msg), iff (irreducible g (Mop oM M) (Mop oN N)) (and (analysis_def g (Mop oM M) (Mop oN N)) (or (not (eq oM oN)) (not (synthesis (analysis_def g) M N)))), False
+++++
intros.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
unfold op_synthesis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intros.
generalize (H15 M N H13).
rewrite H14.
intros.
inversion H16.
red in |- *.
intros.
unfold le_h in H1.
unfold inclusion in H1.
generalize (H1 M' N' H21).
intro.
cut (N' = N0).
intro.
rewrite <- H23 in H18.
rewrite H14 in H13.
rewrite <- H18 in H13.
generalize (irreducible_op g).
intros.

*****
H24 : forall (oM oN : op) (M N : Msg),\niff (irreducible g (Mop oM M) (Mop oN N))\n (and (analysis_def g (Mop oM M) (Mop oN N))\n (or (not (eq oM oN)) (not (synthesis (analysis_def g) M N))))
H23 : eq N' N0
H22 : synthesis h M' N'
H21 : synthesis g M' N'
H18 : eq (Mop o N') N
H19 : eq M0 M'
H17 : eq o0 o
H20 : synthesis h M' N0
M0,N0 : Msg
o0 : op
H16 : synthesis h (Mop o M') N
H15 : forall (M N : Msg) (_ : g M N), synthesis h M N
H14 : eq M (Mop o M')
H13 : g (Mop o M') (Mop o N')
M,N,M',N' : Msg
o : op
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
False
+++++
elim (H24 o o M' N').
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
unfold op_synthesis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intros.
generalize (H15 M N H13).
rewrite H14.
intros.
inversion H16.
red in |- *.
intros.
unfold le_h in H1.
unfold inclusion in H1.
generalize (H1 M' N' H21).
intro.
cut (N' = N0).
intro.
rewrite <- H23 in H18.
rewrite H14 in H13.
rewrite <- H18 in H13.
generalize (irreducible_op g).
intros.
elim (H24 o o M' N').

*****
H24 : forall (oM oN : op) (M N : Msg),\niff (irreducible g (Mop oM M) (Mop oN N))\n (and (analysis_def g (Mop oM M) (Mop oN N))\n (or (not (eq oM oN)) (not (synthesis (analysis_def g) M N))))
H23 : eq N' N0
H22 : synthesis h M' N'
H21 : synthesis g M' N'
H18 : eq (Mop o N') N
H19 : eq M0 M'
H17 : eq o0 o
H20 : synthesis h M' N0
M0,N0 : Msg
o0 : op
H16 : synthesis h (Mop o M') N
H15 : forall (M N : Msg) (_ : g M N), synthesis h M N
H14 : eq M (Mop o M')
H13 : g (Mop o M') (Mop o N')
M,N,M',N' : Msg
o : op
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
forall (_ : forall _ : irreducible g (Mop o M') (Mop o N'), and (analysis_def g (Mop o M') (Mop o N')) (or (not (eq o o)) (not (synthesis (analysis_def g) M' N')))) (_ : forall _ : and (analysis_def g (Mop o M') (Mop o N')) (or (not (eq o o)) (not (synthesis (analysis_def g) M' N'))), irreducible g (Mop o M') (Mop o N')), False
+++++
intros.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
unfold op_synthesis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intros.
generalize (H15 M N H13).
rewrite H14.
intros.
inversion H16.
red in |- *.
intros.
unfold le_h in H1.
unfold inclusion in H1.
generalize (H1 M' N' H21).
intro.
cut (N' = N0).
intro.
rewrite <- H23 in H18.
rewrite H14 in H13.
rewrite <- H18 in H13.
generalize (irreducible_op g).
intros.
elim (H24 o o M' N').
intros.

*****
H26 : forall\n _ : and (analysis_def g (Mop o M') (Mop o N'))\n (or (not (eq o o)) (not (synthesis (analysis_def g) M' N'))),\nirreducible g (Mop o M') (Mop o N')
H25 : forall _ : irreducible g (Mop o M') (Mop o N'),\nand (analysis_def g (Mop o M') (Mop o N'))\n (or (not (eq o o)) (not (synthesis (analysis_def g) M' N')))
H24 : forall (oM oN : op) (M N : Msg),\niff (irreducible g (Mop oM M) (Mop oN N))\n (and (analysis_def g (Mop oM M) (Mop oN N))\n (or (not (eq oM oN)) (not (synthesis (analysis_def g) M N))))
H23 : eq N' N0
H22 : synthesis h M' N'
H21 : synthesis g M' N'
H18 : eq (Mop o N') N
H19 : eq M0 M'
H17 : eq o0 o
H20 : synthesis h M' N0
M0,N0 : Msg
o0 : op
H16 : synthesis h (Mop o M') N
H15 : forall (M N : Msg) (_ : g M N), synthesis h M N
H14 : eq M (Mop o M')
H13 : g (Mop o M') (Mop o N')
M,N,M',N' : Msg
o : op
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
False
+++++
unfold is_irreducible in H.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
unfold op_synthesis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intros.
generalize (H15 M N H13).
rewrite H14.
intros.
inversion H16.
red in |- *.
intros.
unfold le_h in H1.
unfold inclusion in H1.
generalize (H1 M' N' H21).
intro.
cut (N' = N0).
intro.
rewrite <- H23 in H18.
rewrite H14 in H13.
rewrite <- H18 in H13.
generalize (irreducible_op g).
intros.
elim (H24 o o M' N').
intros.
unfold is_irreducible in H.

*****
H26 : forall\n _ : and (analysis_def g (Mop o M') (Mop o N'))\n (or (not (eq o o)) (not (synthesis (analysis_def g) M' N'))),\nirreducible g (Mop o M') (Mop o N')
H25 : forall _ : irreducible g (Mop o M') (Mop o N'),\nand (analysis_def g (Mop o M') (Mop o N'))\n (or (not (eq o o)) (not (synthesis (analysis_def g) M' N')))
H24 : forall (oM oN : op) (M N : Msg),\niff (irreducible g (Mop oM M) (Mop oN N))\n (and (analysis_def g (Mop oM M) (Mop oN N))\n (or (not (eq oM oN)) (not (synthesis (analysis_def g) M N))))
H23 : eq N' N0
H22 : synthesis h M' N'
H21 : synthesis g M' N'
H18 : eq (Mop o N') N
H19 : eq M0 M'
H17 : eq o0 o
H20 : synthesis h M' N0
M0,N0 : Msg
o0 : op
H16 : synthesis h (Mop o M') N
H15 : forall (M N : Msg) (_ : g M N), synthesis h M N
H14 : eq M (Mop o M')
H13 : g (Mop o M') (Mop o N')
M,N,M',N' : Msg
o : op
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : equal g (irreducible g)
g,h : hedge
*****
False
+++++
unfold equal in H.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
unfold op_synthesis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intros.
generalize (H15 M N H13).
rewrite H14.
intros.
inversion H16.
red in |- *.
intros.
unfold le_h in H1.
unfold inclusion in H1.
generalize (H1 M' N' H21).
intro.
cut (N' = N0).
intro.
rewrite <- H23 in H18.
rewrite H14 in H13.
rewrite <- H18 in H13.
generalize (irreducible_op g).
intros.
elim (H24 o o M' N').
intros.
unfold is_irreducible in H.
unfold equal in H.

*****
H26 : forall\n _ : and (analysis_def g (Mop o M') (Mop o N'))\n (or (not (eq o o)) (not (synthesis (analysis_def g) M' N'))),\nirreducible g (Mop o M') (Mop o N')
H25 : forall _ : irreducible g (Mop o M') (Mop o N'),\nand (analysis_def g (Mop o M') (Mop o N'))\n (or (not (eq o o)) (not (synthesis (analysis_def g) M' N')))
H24 : forall (oM oN : op) (M N : Msg),\niff (irreducible g (Mop oM M) (Mop oN N))\n (and (analysis_def g (Mop oM M) (Mop oN N))\n (or (not (eq oM oN)) (not (synthesis (analysis_def g) M N))))
H23 : eq N' N0
H22 : synthesis h M' N'
H21 : synthesis g M' N'
H18 : eq (Mop o N') N
H19 : eq M0 M'
H17 : eq o0 o
H20 : synthesis h M' N0
M0,N0 : Msg
o0 : op
H16 : synthesis h (Mop o M') N
H15 : forall (M N : Msg) (_ : g M N), synthesis h M N
H14 : eq M (Mop o M')
H13 : g (Mop o M') (Mop o N')
M,N,M',N' : Msg
o : op
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
False
+++++
elim H.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
unfold op_synthesis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intros.
generalize (H15 M N H13).
rewrite H14.
intros.
inversion H16.
red in |- *.
intros.
unfold le_h in H1.
unfold inclusion in H1.
generalize (H1 M' N' H21).
intro.
cut (N' = N0).
intro.
rewrite <- H23 in H18.
rewrite H14 in H13.
rewrite <- H18 in H13.
generalize (irreducible_op g).
intros.
elim (H24 o o M' N').
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.

*****
H26 : forall\n _ : and (analysis_def g (Mop o M') (Mop o N'))\n (or (not (eq o o)) (not (synthesis (analysis_def g) M' N'))),\nirreducible g (Mop o M') (Mop o N')
H25 : forall _ : irreducible g (Mop o M') (Mop o N'),\nand (analysis_def g (Mop o M') (Mop o N'))\n (or (not (eq o o)) (not (synthesis (analysis_def g) M' N')))
H24 : forall (oM oN : op) (M N : Msg),\niff (irreducible g (Mop oM M) (Mop oN N))\n (and (analysis_def g (Mop oM M) (Mop oN N))\n (or (not (eq oM oN)) (not (synthesis (analysis_def g) M N))))
H23 : eq N' N0
H22 : synthesis h M' N'
H21 : synthesis g M' N'
H18 : eq (Mop o N') N
H19 : eq M0 M'
H17 : eq o0 o
H20 : synthesis h M' N0
M0,N0 : Msg
o0 : op
H16 : synthesis h (Mop o M') N
H15 : forall (M N : Msg) (_ : g M N), synthesis h M N
H14 : eq M (Mop o M')
H13 : g (Mop o M') (Mop o N')
M,N,M',N' : Msg
o : op
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
forall (_ : inclusion g (irreducible g)) (_ : inclusion (irreducible g) g), False
+++++
unfold inclusion in |- *.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
unfold op_synthesis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intros.
generalize (H15 M N H13).
rewrite H14.
intros.
inversion H16.
red in |- *.
intros.
unfold le_h in H1.
unfold inclusion in H1.
generalize (H1 M' N' H21).
intro.
cut (N' = N0).
intro.
rewrite <- H23 in H18.
rewrite H14 in H13.
rewrite <- H18 in H13.
generalize (irreducible_op g).
intros.
elim (H24 o o M' N').
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.

*****
H26 : forall\n _ : and (analysis_def g (Mop o M') (Mop o N'))\n (or (not (eq o o)) (not (synthesis (analysis_def g) M' N'))),\nirreducible g (Mop o M') (Mop o N')
H25 : forall _ : irreducible g (Mop o M') (Mop o N'),\nand (analysis_def g (Mop o M') (Mop o N'))\n (or (not (eq o o)) (not (synthesis (analysis_def g) M' N')))
H24 : forall (oM oN : op) (M N : Msg),\niff (irreducible g (Mop oM M) (Mop oN N))\n (and (analysis_def g (Mop oM M) (Mop oN N))\n (or (not (eq oM oN)) (not (synthesis (analysis_def g) M N))))
H23 : eq N' N0
H22 : synthesis h M' N'
H21 : synthesis g M' N'
H18 : eq (Mop o N') N
H19 : eq M0 M'
H17 : eq o0 o
H20 : synthesis h M' N0
M0,N0 : Msg
o0 : op
H16 : synthesis h (Mop o M') N
H15 : forall (M N : Msg) (_ : g M N), synthesis h M N
H14 : eq M (Mop o M')
H13 : g (Mop o M') (Mop o N')
M,N,M',N' : Msg
o : op
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
forall (_ : forall (M N : Msg) (_ : g M N), irreducible g M N) (_ : forall (M N : Msg) (_ : irreducible g M N), g M N), False
+++++
intros.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
unfold op_synthesis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intros.
generalize (H15 M N H13).
rewrite H14.
intros.
inversion H16.
red in |- *.
intros.
unfold le_h in H1.
unfold inclusion in H1.
generalize (H1 M' N' H21).
intro.
cut (N' = N0).
intro.
rewrite <- H23 in H18.
rewrite H14 in H13.
rewrite <- H18 in H13.
generalize (irreducible_op g).
intros.
elim (H24 o o M' N').
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.

*****
H28 : forall (M N : Msg) (_ : irreducible g M N), g M N
H27 : forall (M N : Msg) (_ : g M N), irreducible g M N
H26 : forall\n _ : and (analysis_def g (Mop o M') (Mop o N'))\n (or (not (eq o o)) (not (synthesis (analysis_def g) M' N'))),\nirreducible g (Mop o M') (Mop o N')
H25 : forall _ : irreducible g (Mop o M') (Mop o N'),\nand (analysis_def g (Mop o M') (Mop o N'))\n (or (not (eq o o)) (not (synthesis (analysis_def g) M' N')))
H24 : forall (oM oN : op) (M N : Msg),\niff (irreducible g (Mop oM M) (Mop oN N))\n (and (analysis_def g (Mop oM M) (Mop oN N))\n (or (not (eq oM oN)) (not (synthesis (analysis_def g) M N))))
H23 : eq N' N0
H22 : synthesis h M' N'
H21 : synthesis g M' N'
H18 : eq (Mop o N') N
H19 : eq M0 M'
H17 : eq o0 o
H20 : synthesis h M' N0
M0,N0 : Msg
o0 : op
H16 : synthesis h (Mop o M') N
H15 : forall (M N : Msg) (_ : g M N), synthesis h M N
H14 : eq M (Mop o M')
H13 : g (Mop o M') (Mop o N')
M,N,M',N' : Msg
o : op
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
False
+++++
generalize (H25 (H27 (Mop o M') (Mop o N') H13)).
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
unfold op_synthesis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intros.
generalize (H15 M N H13).
rewrite H14.
intros.
inversion H16.
red in |- *.
intros.
unfold le_h in H1.
unfold inclusion in H1.
generalize (H1 M' N' H21).
intro.
cut (N' = N0).
intro.
rewrite <- H23 in H18.
rewrite H14 in H13.
rewrite <- H18 in H13.
generalize (irreducible_op g).
intros.
elim (H24 o o M' N').
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
generalize (H25 (H27 (Mop o M') (Mop o N') H13)).

*****
H28 : forall (M N : Msg) (_ : irreducible g M N), g M N
H27 : forall (M N : Msg) (_ : g M N), irreducible g M N
H26 : forall\n _ : and (analysis_def g (Mop o M') (Mop o N'))\n (or (not (eq o o)) (not (synthesis (analysis_def g) M' N'))),\nirreducible g (Mop o M') (Mop o N')
H25 : forall _ : irreducible g (Mop o M') (Mop o N'),\nand (analysis_def g (Mop o M') (Mop o N'))\n (or (not (eq o o)) (not (synthesis (analysis_def g) M' N')))
H24 : forall (oM oN : op) (M N : Msg),\niff (irreducible g (Mop oM M) (Mop oN N))\n (and (analysis_def g (Mop oM M) (Mop oN N))\n (or (not (eq oM oN)) (not (synthesis (analysis_def g) M N))))
H23 : eq N' N0
H22 : synthesis h M' N'
H21 : synthesis g M' N'
H18 : eq (Mop o N') N
H19 : eq M0 M'
H17 : eq o0 o
H20 : synthesis h M' N0
M0,N0 : Msg
o0 : op
H16 : synthesis h (Mop o M') N
H15 : forall (M N : Msg) (_ : g M N), synthesis h M N
H14 : eq M (Mop o M')
H13 : g (Mop o M') (Mop o N')
M,N,M',N' : Msg
o : op
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
forall _ : and (analysis_def g (Mop o M') (Mop o N')) (or (not (eq o o)) (not (synthesis (analysis_def g) M' N'))), False
+++++
intro.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
unfold op_synthesis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intros.
generalize (H15 M N H13).
rewrite H14.
intros.
inversion H16.
red in |- *.
intros.
unfold le_h in H1.
unfold inclusion in H1.
generalize (H1 M' N' H21).
intro.
cut (N' = N0).
intro.
rewrite <- H23 in H18.
rewrite H14 in H13.
rewrite <- H18 in H13.
generalize (irreducible_op g).
intros.
elim (H24 o o M' N').
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
generalize (H25 (H27 (Mop o M') (Mop o N') H13)).
intro.

*****
H29 : and (analysis_def g (Mop o M') (Mop o N'))\n (or (not (eq o o)) (not (synthesis (analysis_def g) M' N')))
H28 : forall (M N : Msg) (_ : irreducible g M N), g M N
H27 : forall (M N : Msg) (_ : g M N), irreducible g M N
H26 : forall\n _ : and (analysis_def g (Mop o M') (Mop o N'))\n (or (not (eq o o)) (not (synthesis (analysis_def g) M' N'))),\nirreducible g (Mop o M') (Mop o N')
H25 : forall _ : irreducible g (Mop o M') (Mop o N'),\nand (analysis_def g (Mop o M') (Mop o N'))\n (or (not (eq o o)) (not (synthesis (analysis_def g) M' N')))
H24 : forall (oM oN : op) (M N : Msg),\niff (irreducible g (Mop oM M) (Mop oN N))\n (and (analysis_def g (Mop oM M) (Mop oN N))\n (or (not (eq oM oN)) (not (synthesis (analysis_def g) M N))))
H23 : eq N' N0
H22 : synthesis h M' N'
H21 : synthesis g M' N'
H18 : eq (Mop o N') N
H19 : eq M0 M'
H17 : eq o0 o
H20 : synthesis h M' N0
M0,N0 : Msg
o0 : op
H16 : synthesis h (Mop o M') N
H15 : forall (M N : Msg) (_ : g M N), synthesis h M N
H14 : eq M (Mop o M')
H13 : g (Mop o M') (Mop o N')
M,N,M',N' : Msg
o : op
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
False
+++++
elim H29.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
unfold op_synthesis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intros.
generalize (H15 M N H13).
rewrite H14.
intros.
inversion H16.
red in |- *.
intros.
unfold le_h in H1.
unfold inclusion in H1.
generalize (H1 M' N' H21).
intro.
cut (N' = N0).
intro.
rewrite <- H23 in H18.
rewrite H14 in H13.
rewrite <- H18 in H13.
generalize (irreducible_op g).
intros.
elim (H24 o o M' N').
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
generalize (H25 (H27 (Mop o M') (Mop o N') H13)).
intro.
elim H29.

*****
H29 : and (analysis_def g (Mop o M') (Mop o N'))\n (or (not (eq o o)) (not (synthesis (analysis_def g) M' N')))
H28 : forall (M N : Msg) (_ : irreducible g M N), g M N
H27 : forall (M N : Msg) (_ : g M N), irreducible g M N
H26 : forall\n _ : and (analysis_def g (Mop o M') (Mop o N'))\n (or (not (eq o o)) (not (synthesis (analysis_def g) M' N'))),\nirreducible g (Mop o M') (Mop o N')
H25 : forall _ : irreducible g (Mop o M') (Mop o N'),\nand (analysis_def g (Mop o M') (Mop o N'))\n (or (not (eq o o)) (not (synthesis (analysis_def g) M' N')))
H24 : forall (oM oN : op) (M N : Msg),\niff (irreducible g (Mop oM M) (Mop oN N))\n (and (analysis_def g (Mop oM M) (Mop oN N))\n (or (not (eq oM oN)) (not (synthesis (analysis_def g) M N))))
H23 : eq N' N0
H22 : synthesis h M' N'
H21 : synthesis g M' N'
H18 : eq (Mop o N') N
H19 : eq M0 M'
H17 : eq o0 o
H20 : synthesis h M' N0
M0,N0 : Msg
o0 : op
H16 : synthesis h (Mop o M') N
H15 : forall (M N : Msg) (_ : g M N), synthesis h M N
H14 : eq M (Mop o M')
H13 : g (Mop o M') (Mop o N')
M,N,M',N' : Msg
o : op
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
forall (_ : analysis_def g (Mop o M') (Mop o N')) (_ : or (not (eq o o)) (not (synthesis (analysis_def g) M' N'))), False
+++++
intros.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
unfold op_synthesis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intros.
generalize (H15 M N H13).
rewrite H14.
intros.
inversion H16.
red in |- *.
intros.
unfold le_h in H1.
unfold inclusion in H1.
generalize (H1 M' N' H21).
intro.
cut (N' = N0).
intro.
rewrite <- H23 in H18.
rewrite H14 in H13.
rewrite <- H18 in H13.
generalize (irreducible_op g).
intros.
elim (H24 o o M' N').
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
generalize (H25 (H27 (Mop o M') (Mop o N') H13)).
intro.
elim H29.
intros.

*****
H31 : or (not (eq o o)) (not (synthesis (analysis_def g) M' N'))
H30 : analysis_def g (Mop o M') (Mop o N')
H29 : and (analysis_def g (Mop o M') (Mop o N'))\n (or (not (eq o o)) (not (synthesis (analysis_def g) M' N')))
H28 : forall (M N : Msg) (_ : irreducible g M N), g M N
H27 : forall (M N : Msg) (_ : g M N), irreducible g M N
H26 : forall\n _ : and (analysis_def g (Mop o M') (Mop o N'))\n (or (not (eq o o)) (not (synthesis (analysis_def g) M' N'))),\nirreducible g (Mop o M') (Mop o N')
H25 : forall _ : irreducible g (Mop o M') (Mop o N'),\nand (analysis_def g (Mop o M') (Mop o N'))\n (or (not (eq o o)) (not (synthesis (analysis_def g) M' N')))
H24 : forall (oM oN : op) (M N : Msg),\niff (irreducible g (Mop oM M) (Mop oN N))\n (and (analysis_def g (Mop oM M) (Mop oN N))\n (or (not (eq oM oN)) (not (synthesis (analysis_def g) M N))))
H23 : eq N' N0
H22 : synthesis h M' N'
H21 : synthesis g M' N'
H18 : eq (Mop o N') N
H19 : eq M0 M'
H17 : eq o0 o
H20 : synthesis h M' N0
M0,N0 : Msg
o0 : op
H16 : synthesis h (Mop o M') N
H15 : forall (M N : Msg) (_ : g M N), synthesis h M N
H14 : eq M (Mop o M')
H13 : g (Mop o M') (Mop o N')
M,N,M',N' : Msg
o : op
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
False
+++++
case H31.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
unfold op_synthesis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intros.
generalize (H15 M N H13).
rewrite H14.
intros.
inversion H16.
red in |- *.
intros.
unfold le_h in H1.
unfold inclusion in H1.
generalize (H1 M' N' H21).
intro.
cut (N' = N0).
intro.
rewrite <- H23 in H18.
rewrite H14 in H13.
rewrite <- H18 in H13.
generalize (irreducible_op g).
intros.
elim (H24 o o M' N').
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
generalize (H25 (H27 (Mop o M') (Mop o N') H13)).
intro.
elim H29.
intros.
case H31.

*****
H31 : or (not (eq o o)) (not (synthesis (analysis_def g) M' N'))
H30 : analysis_def g (Mop o M') (Mop o N')
H29 : and (analysis_def g (Mop o M') (Mop o N'))\n (or (not (eq o o)) (not (synthesis (analysis_def g) M' N')))
H28 : forall (M N : Msg) (_ : irreducible g M N), g M N
H27 : forall (M N : Msg) (_ : g M N), irreducible g M N
H26 : forall\n _ : and (analysis_def g (Mop o M') (Mop o N'))\n (or (not (eq o o)) (not (synthesis (analysis_def g) M' N'))),\nirreducible g (Mop o M') (Mop o N')
H25 : forall _ : irreducible g (Mop o M') (Mop o N'),\nand (analysis_def g (Mop o M') (Mop o N'))\n (or (not (eq o o)) (not (synthesis (analysis_def g) M' N')))
H24 : forall (oM oN : op) (M N : Msg),\niff (irreducible g (Mop oM M) (Mop oN N))\n (and (analysis_def g (Mop oM M) (Mop oN N))\n (or (not (eq oM oN)) (not (synthesis (analysis_def g) M N))))
H23 : eq N' N0
H22 : synthesis h M' N'
H21 : synthesis g M' N'
H18 : eq (Mop o N') N
H19 : eq M0 M'
H17 : eq o0 o
H20 : synthesis h M' N0
M0,N0 : Msg
o0 : op
H16 : synthesis h (Mop o M') N
H15 : forall (M N : Msg) (_ : g M N), synthesis h M N
H14 : eq M (Mop o M')
H13 : g (Mop o M') (Mop o N')
M,N,M',N' : Msg
o : op
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
forall _ : not (eq o o), False
+++++
try tauto.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
unfold op_synthesis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intros.
generalize (H15 M N H13).
rewrite H14.
intros.
inversion H16.
red in |- *.
intros.
unfold le_h in H1.
unfold inclusion in H1.
generalize (H1 M' N' H21).
intro.
cut (N' = N0).
intro.
rewrite <- H23 in H18.
rewrite H14 in H13.
rewrite <- H18 in H13.
generalize (irreducible_op g).
intros.
elim (H24 o o M' N').
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
generalize (H25 (H27 (Mop o M') (Mop o N') H13)).
intro.
elim H29.
intros.
case H31.

*****
H31 : or (not (eq o o)) (not (synthesis (analysis_def g) M' N'))
H30 : analysis_def g (Mop o M') (Mop o N')
H29 : and (analysis_def g (Mop o M') (Mop o N'))\n (or (not (eq o o)) (not (synthesis (analysis_def g) M' N')))
H28 : forall (M N : Msg) (_ : irreducible g M N), g M N
H27 : forall (M N : Msg) (_ : g M N), irreducible g M N
H26 : forall\n _ : and (analysis_def g (Mop o M') (Mop o N'))\n (or (not (eq o o)) (not (synthesis (analysis_def g) M' N'))),\nirreducible g (Mop o M') (Mop o N')
H25 : forall _ : irreducible g (Mop o M') (Mop o N'),\nand (analysis_def g (Mop o M') (Mop o N'))\n (or (not (eq o o)) (not (synthesis (analysis_def g) M' N')))
H24 : forall (oM oN : op) (M N : Msg),\niff (irreducible g (Mop oM M) (Mop oN N))\n (and (analysis_def g (Mop oM M) (Mop oN N))\n (or (not (eq oM oN)) (not (synthesis (analysis_def g) M N))))
H23 : eq N' N0
H22 : synthesis h M' N'
H21 : synthesis g M' N'
H18 : eq (Mop o N') N
H19 : eq M0 M'
H17 : eq o0 o
H20 : synthesis h M' N0
M0,N0 : Msg
o0 : op
H16 : synthesis h (Mop o M') N
H15 : forall (M N : Msg) (_ : g M N), synthesis h M N
H14 : eq M (Mop o M')
H13 : g (Mop o M') (Mop o N')
M,N,M',N' : Msg
o : op
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
forall _ : not (synthesis (analysis_def g) M' N'), False
+++++
try tauto.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
unfold op_synthesis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intros.
generalize (H15 M N H13).
rewrite H14.
intros.
inversion H16.
red in |- *.
intros.
unfold le_h in H1.
unfold inclusion in H1.
generalize (H1 M' N' H21).
intro.
cut (N' = N0).
intro.
rewrite <- H23 in H18.
rewrite H14 in H13.
rewrite <- H18 in H13.
generalize (irreducible_op g).
intros.
elim (H24 o o M' N').
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
generalize (H25 (H27 (Mop o M') (Mop o N') H13)).
intro.
elim H29.
intros.
case H31.
try tauto.

*****
H31 : or (not (eq o o)) (not (synthesis (analysis_def g) M' N'))
H30 : analysis_def g (Mop o M') (Mop o N')
H29 : and (analysis_def g (Mop o M') (Mop o N'))\n (or (not (eq o o)) (not (synthesis (analysis_def g) M' N')))
H28 : forall (M N : Msg) (_ : irreducible g M N), g M N
H27 : forall (M N : Msg) (_ : g M N), irreducible g M N
H26 : forall\n _ : and (analysis_def g (Mop o M') (Mop o N'))\n (or (not (eq o o)) (not (synthesis (analysis_def g) M' N'))),\nirreducible g (Mop o M') (Mop o N')
H25 : forall _ : irreducible g (Mop o M') (Mop o N'),\nand (analysis_def g (Mop o M') (Mop o N'))\n (or (not (eq o o)) (not (synthesis (analysis_def g) M' N')))
H24 : forall (oM oN : op) (M N : Msg),\niff (irreducible g (Mop oM M) (Mop oN N))\n (and (analysis_def g (Mop oM M) (Mop oN N))\n (or (not (eq oM oN)) (not (synthesis (analysis_def g) M N))))
H23 : eq N' N0
H22 : synthesis h M' N'
H21 : synthesis g M' N'
H18 : eq (Mop o N') N
H19 : eq M0 M'
H17 : eq o0 o
H20 : synthesis h M' N0
M0,N0 : Msg
o0 : op
H16 : synthesis h (Mop o M') N
H15 : forall (M N : Msg) (_ : g M N), synthesis h M N
H14 : eq M (Mop o M')
H13 : g (Mop o M') (Mop o N')
M,N,M',N' : Msg
o : op
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
forall _ : not (synthesis (analysis_def g) M' N'), False
+++++
intro.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
unfold op_synthesis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intros.
generalize (H15 M N H13).
rewrite H14.
intros.
inversion H16.
red in |- *.
intros.
unfold le_h in H1.
unfold inclusion in H1.
generalize (H1 M' N' H21).
intro.
cut (N' = N0).
intro.
rewrite <- H23 in H18.
rewrite H14 in H13.
rewrite <- H18 in H13.
generalize (irreducible_op g).
intros.
elim (H24 o o M' N').
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
generalize (H25 (H27 (Mop o M') (Mop o N') H13)).
intro.
elim H29.
intros.
case H31.
try tauto.
intro.

*****
H32 : not (synthesis (analysis_def g) M' N')
H31 : or (not (eq o o)) (not (synthesis (analysis_def g) M' N'))
H30 : analysis_def g (Mop o M') (Mop o N')
H29 : and (analysis_def g (Mop o M') (Mop o N'))\n (or (not (eq o o)) (not (synthesis (analysis_def g) M' N')))
H28 : forall (M N : Msg) (_ : irreducible g M N), g M N
H27 : forall (M N : Msg) (_ : g M N), irreducible g M N
H26 : forall\n _ : and (analysis_def g (Mop o M') (Mop o N'))\n (or (not (eq o o)) (not (synthesis (analysis_def g) M' N'))),\nirreducible g (Mop o M') (Mop o N')
H25 : forall _ : irreducible g (Mop o M') (Mop o N'),\nand (analysis_def g (Mop o M') (Mop o N'))\n (or (not (eq o o)) (not (synthesis (analysis_def g) M' N')))
H24 : forall (oM oN : op) (M N : Msg),\niff (irreducible g (Mop oM M) (Mop oN N))\n (and (analysis_def g (Mop oM M) (Mop oN N))\n (or (not (eq oM oN)) (not (synthesis (analysis_def g) M N))))
H23 : eq N' N0
H22 : synthesis h M' N'
H21 : synthesis g M' N'
H18 : eq (Mop o N') N
H19 : eq M0 M'
H17 : eq o0 o
H20 : synthesis h M' N0
M0,N0 : Msg
o0 : op
H16 : synthesis h (Mop o M') N
H15 : forall (M N : Msg) (_ : g M N), synthesis h M N
H14 : eq M (Mop o M')
H13 : g (Mop o M') (Mop o N')
M,N,M',N' : Msg
o : op
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
False
+++++
apply H32.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
unfold op_synthesis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intros.
generalize (H15 M N H13).
rewrite H14.
intros.
inversion H16.
red in |- *.
intros.
unfold le_h in H1.
unfold inclusion in H1.
generalize (H1 M' N' H21).
intro.
cut (N' = N0).
intro.
rewrite <- H23 in H18.
rewrite H14 in H13.
rewrite <- H18 in H13.
generalize (irreducible_op g).
intros.
elim (H24 o o M' N').
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
generalize (H25 (H27 (Mop o M') (Mop o N') H13)).
intro.
elim H29.
intros.
case H31.
try tauto.
intro.
apply H32.

*****
H32 : not (synthesis (analysis_def g) M' N')
H31 : or (not (eq o o)) (not (synthesis (analysis_def g) M' N'))
H30 : analysis_def g (Mop o M') (Mop o N')
H29 : and (analysis_def g (Mop o M') (Mop o N'))\n (or (not (eq o o)) (not (synthesis (analysis_def g) M' N')))
H28 : forall (M N : Msg) (_ : irreducible g M N), g M N
H27 : forall (M N : Msg) (_ : g M N), irreducible g M N
H26 : forall\n _ : and (analysis_def g (Mop o M') (Mop o N'))\n (or (not (eq o o)) (not (synthesis (analysis_def g) M' N'))),\nirreducible g (Mop o M') (Mop o N')
H25 : forall _ : irreducible g (Mop o M') (Mop o N'),\nand (analysis_def g (Mop o M') (Mop o N'))\n (or (not (eq o o)) (not (synthesis (analysis_def g) M' N')))
H24 : forall (oM oN : op) (M N : Msg),\niff (irreducible g (Mop oM M) (Mop oN N))\n (and (analysis_def g (Mop oM M) (Mop oN N))\n (or (not (eq oM oN)) (not (synthesis (analysis_def g) M N))))
H23 : eq N' N0
H22 : synthesis h M' N'
H21 : synthesis g M' N'
H18 : eq (Mop o N') N
H19 : eq M0 M'
H17 : eq o0 o
H20 : synthesis h M' N0
M0,N0 : Msg
o0 : op
H16 : synthesis h (Mop o M') N
H15 : forall (M N : Msg) (_ : g M N), synthesis h M N
H14 : eq M (Mop o M')
H13 : g (Mop o M') (Mop o N')
M,N,M',N' : Msg
o : op
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
synthesis (analysis_def g) M' N'
+++++
generalize (h_le_h_ana_h g).
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
unfold op_synthesis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intros.
generalize (H15 M N H13).
rewrite H14.
intros.
inversion H16.
red in |- *.
intros.
unfold le_h in H1.
unfold inclusion in H1.
generalize (H1 M' N' H21).
intro.
cut (N' = N0).
intro.
rewrite <- H23 in H18.
rewrite H14 in H13.
rewrite <- H18 in H13.
generalize (irreducible_op g).
intros.
elim (H24 o o M' N').
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
generalize (H25 (H27 (Mop o M') (Mop o N') H13)).
intro.
elim H29.
intros.
case H31.
try tauto.
intro.
apply H32.
generalize (h_le_h_ana_h g).

*****
H32 : not (synthesis (analysis_def g) M' N')
H31 : or (not (eq o o)) (not (synthesis (analysis_def g) M' N'))
H30 : analysis_def g (Mop o M') (Mop o N')
H29 : and (analysis_def g (Mop o M') (Mop o N'))\n (or (not (eq o o)) (not (synthesis (analysis_def g) M' N')))
H28 : forall (M N : Msg) (_ : irreducible g M N), g M N
H27 : forall (M N : Msg) (_ : g M N), irreducible g M N
H26 : forall\n _ : and (analysis_def g (Mop o M') (Mop o N'))\n (or (not (eq o o)) (not (synthesis (analysis_def g) M' N'))),\nirreducible g (Mop o M') (Mop o N')
H25 : forall _ : irreducible g (Mop o M') (Mop o N'),\nand (analysis_def g (Mop o M') (Mop o N'))\n (or (not (eq o o)) (not (synthesis (analysis_def g) M' N')))
H24 : forall (oM oN : op) (M N : Msg),\niff (irreducible g (Mop oM M) (Mop oN N))\n (and (analysis_def g (Mop oM M) (Mop oN N))\n (or (not (eq oM oN)) (not (synthesis (analysis_def g) M N))))
H23 : eq N' N0
H22 : synthesis h M' N'
H21 : synthesis g M' N'
H18 : eq (Mop o N') N
H19 : eq M0 M'
H17 : eq o0 o
H20 : synthesis h M' N0
M0,N0 : Msg
o0 : op
H16 : synthesis h (Mop o M') N
H15 : forall (M N : Msg) (_ : g M N), synthesis h M N
H14 : eq M (Mop o M')
H13 : g (Mop o M') (Mop o N')
M,N,M',N' : Msg
o : op
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
forall _ : le_h g (analysis_def g), synthesis (analysis_def g) M' N'
+++++
unfold le_h in |- *.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
unfold op_synthesis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intros.
generalize (H15 M N H13).
rewrite H14.
intros.
inversion H16.
red in |- *.
intros.
unfold le_h in H1.
unfold inclusion in H1.
generalize (H1 M' N' H21).
intro.
cut (N' = N0).
intro.
rewrite <- H23 in H18.
rewrite H14 in H13.
rewrite <- H18 in H13.
generalize (irreducible_op g).
intros.
elim (H24 o o M' N').
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
generalize (H25 (H27 (Mop o M') (Mop o N') H13)).
intro.
elim H29.
intros.
case H31.
try tauto.
intro.
apply H32.
generalize (h_le_h_ana_h g).
unfold le_h in |- *.

*****
H32 : not (synthesis (analysis_def g) M' N')
H31 : or (not (eq o o)) (not (synthesis (analysis_def g) M' N'))
H30 : analysis_def g (Mop o M') (Mop o N')
H29 : and (analysis_def g (Mop o M') (Mop o N'))\n (or (not (eq o o)) (not (synthesis (analysis_def g) M' N')))
H28 : forall (M N : Msg) (_ : irreducible g M N), g M N
H27 : forall (M N : Msg) (_ : g M N), irreducible g M N
H26 : forall\n _ : and (analysis_def g (Mop o M') (Mop o N'))\n (or (not (eq o o)) (not (synthesis (analysis_def g) M' N'))),\nirreducible g (Mop o M') (Mop o N')
H25 : forall _ : irreducible g (Mop o M') (Mop o N'),\nand (analysis_def g (Mop o M') (Mop o N'))\n (or (not (eq o o)) (not (synthesis (analysis_def g) M' N')))
H24 : forall (oM oN : op) (M N : Msg),\niff (irreducible g (Mop oM M) (Mop oN N))\n (and (analysis_def g (Mop oM M) (Mop oN N))\n (or (not (eq oM oN)) (not (synthesis (analysis_def g) M N))))
H23 : eq N' N0
H22 : synthesis h M' N'
H21 : synthesis g M' N'
H18 : eq (Mop o N') N
H19 : eq M0 M'
H17 : eq o0 o
H20 : synthesis h M' N0
M0,N0 : Msg
o0 : op
H16 : synthesis h (Mop o M') N
H15 : forall (M N : Msg) (_ : g M N), synthesis h M N
H14 : eq M (Mop o M')
H13 : g (Mop o M') (Mop o N')
M,N,M',N' : Msg
o : op
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
forall _ : inclusion (synthesis g) (synthesis (analysis_def g)), synthesis (analysis_def g) M' N'
+++++
unfold inclusion in |- *.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
unfold op_synthesis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intros.
generalize (H15 M N H13).
rewrite H14.
intros.
inversion H16.
red in |- *.
intros.
unfold le_h in H1.
unfold inclusion in H1.
generalize (H1 M' N' H21).
intro.
cut (N' = N0).
intro.
rewrite <- H23 in H18.
rewrite H14 in H13.
rewrite <- H18 in H13.
generalize (irreducible_op g).
intros.
elim (H24 o o M' N').
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
generalize (H25 (H27 (Mop o M') (Mop o N') H13)).
intro.
elim H29.
intros.
case H31.
try tauto.
intro.
apply H32.
generalize (h_le_h_ana_h g).
unfold le_h in |- *.
unfold inclusion in |- *.

*****
H32 : not (synthesis (analysis_def g) M' N')
H31 : or (not (eq o o)) (not (synthesis (analysis_def g) M' N'))
H30 : analysis_def g (Mop o M') (Mop o N')
H29 : and (analysis_def g (Mop o M') (Mop o N'))\n (or (not (eq o o)) (not (synthesis (analysis_def g) M' N')))
H28 : forall (M N : Msg) (_ : irreducible g M N), g M N
H27 : forall (M N : Msg) (_ : g M N), irreducible g M N
H26 : forall\n _ : and (analysis_def g (Mop o M') (Mop o N'))\n (or (not (eq o o)) (not (synthesis (analysis_def g) M' N'))),\nirreducible g (Mop o M') (Mop o N')
H25 : forall _ : irreducible g (Mop o M') (Mop o N'),\nand (analysis_def g (Mop o M') (Mop o N'))\n (or (not (eq o o)) (not (synthesis (analysis_def g) M' N')))
H24 : forall (oM oN : op) (M N : Msg),\niff (irreducible g (Mop oM M) (Mop oN N))\n (and (analysis_def g (Mop oM M) (Mop oN N))\n (or (not (eq oM oN)) (not (synthesis (analysis_def g) M N))))
H23 : eq N' N0
H22 : synthesis h M' N'
H21 : synthesis g M' N'
H18 : eq (Mop o N') N
H19 : eq M0 M'
H17 : eq o0 o
H20 : synthesis h M' N0
M0,N0 : Msg
o0 : op
H16 : synthesis h (Mop o M') N
H15 : forall (M N : Msg) (_ : g M N), synthesis h M N
H14 : eq M (Mop o M')
H13 : g (Mop o M') (Mop o N')
M,N,M',N' : Msg
o : op
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
forall _ : forall (M N : Msg) (_ : synthesis g M N), synthesis (analysis_def g) M N, synthesis (analysis_def g) M' N'
+++++
auto.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
unfold op_synthesis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intros.
generalize (H15 M N H13).
rewrite H14.
intros.
inversion H16.
red in |- *.
intros.
unfold le_h in H1.
unfold inclusion in H1.
generalize (H1 M' N' H21).
intro.
cut (N' = N0).

*****
H22 : synthesis h M' N'
H21 : synthesis g M' N'
H18 : eq (Mop o N0) N
H19 : eq M0 M'
H17 : eq o0 o
H20 : synthesis h M' N0
M0,N0 : Msg
o0 : op
H16 : synthesis h (Mop o M') N
H15 : forall (M N : Msg) (_ : g M N), synthesis h M N
N' : Msg
H14 : eq M (Mop o M')
M' : Msg
H13 : g M N
M,N : Msg
o : op
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
eq N' N0
+++++
generalize (inj_left_syn h H4 H10 H6 H8).
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
unfold op_synthesis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intros.
generalize (H15 M N H13).
rewrite H14.
intros.
inversion H16.
red in |- *.
intros.
unfold le_h in H1.
unfold inclusion in H1.
generalize (H1 M' N' H21).
intro.
cut (N' = N0).
generalize (inj_left_syn h H4 H10 H6 H8).

*****
H22 : synthesis h M' N'
H21 : synthesis g M' N'
H18 : eq (Mop o N0) N
H19 : eq M0 M'
H17 : eq o0 o
H20 : synthesis h M' N0
M0,N0 : Msg
o0 : op
H16 : synthesis h (Mop o M') N
H15 : forall (M N : Msg) (_ : g M N), synthesis h M N
N' : Msg
H14 : eq M (Mop o M')
M' : Msg
H13 : g M N
M,N : Msg
o : op
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
forall _ : injective_left (synthesis h), eq N' N0
+++++
unfold injective_left in |- *.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
unfold op_synthesis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intros.
generalize (H15 M N H13).
rewrite H14.
intros.
inversion H16.
red in |- *.
intros.
unfold le_h in H1.
unfold inclusion in H1.
generalize (H1 M' N' H21).
intro.
cut (N' = N0).
generalize (inj_left_syn h H4 H10 H6 H8).
unfold injective_left in |- *.

*****
H22 : synthesis h M' N'
H21 : synthesis g M' N'
H18 : eq (Mop o N0) N
H19 : eq M0 M'
H17 : eq o0 o
H20 : synthesis h M' N0
M0,N0 : Msg
o0 : op
H16 : synthesis h (Mop o M') N
H15 : forall (M N : Msg) (_ : g M N), synthesis h M N
N' : Msg
H14 : eq M (Mop o M')
M' : Msg
H13 : g M N
M,N : Msg
o : op
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
forall _ : forall (M N : Msg) (_ : synthesis h M N) (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M M'), eq N N', eq N' N0
+++++
intros.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
unfold op_synthesis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intros.
generalize (H15 M N H13).
rewrite H14.
intros.
inversion H16.
red in |- *.
intros.
unfold le_h in H1.
unfold inclusion in H1.
generalize (H1 M' N' H21).
intro.
cut (N' = N0).
generalize (inj_left_syn h H4 H10 H6 H8).
unfold injective_left in |- *.
intros.

*****
H23 : forall (M N : Msg) (_ : synthesis h M N) (M' N' : Msg)\n (_ : synthesis h M' N') (_ : eq M M'), eq N N'
H22 : synthesis h M' N'
H21 : synthesis g M' N'
H18 : eq (Mop o N0) N
H19 : eq M0 M'
H17 : eq o0 o
H20 : synthesis h M' N0
M0,N0 : Msg
o0 : op
H16 : synthesis h (Mop o M') N
H15 : forall (M N : Msg) (_ : g M N), synthesis h M N
N' : Msg
H14 : eq M (Mop o M')
M' : Msg
H13 : g M N
M,N : Msg
o : op
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
eq N' N0
+++++
apply (H23 M' N' H22 M' N0 H20).
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
unfold op_synthesis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intros.
generalize (H15 M N H13).
rewrite H14.
intros.
inversion H16.
red in |- *.
intros.
unfold le_h in H1.
unfold inclusion in H1.
generalize (H1 M' N' H21).
intro.
cut (N' = N0).
generalize (inj_left_syn h H4 H10 H6 H8).
unfold injective_left in |- *.
intros.
apply (H23 M' N' H22 M' N0 H20).

*****
H23 : forall (M N : Msg) (_ : synthesis h M N) (M' N' : Msg)\n (_ : synthesis h M' N') (_ : eq M M'), eq N N'
H22 : synthesis h M' N'
H21 : synthesis g M' N'
H18 : eq (Mop o N0) N
H19 : eq M0 M'
H17 : eq o0 o
H20 : synthesis h M' N0
M0,N0 : Msg
o0 : op
H16 : synthesis h (Mop o M') N
H15 : forall (M N : Msg) (_ : g M N), synthesis h M N
N' : Msg
H14 : eq M (Mop o M')
M' : Msg
H13 : g M N
M,N : Msg
o : op
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
eq M' M'
+++++
trivial.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.

*****
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
and (pair_free_left g) (and (enc_synthesis_left g) (enc_analysis_left g))
+++++
split.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.

*****
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
pair_free_left g
+++++
unfold pair_free_left in |- *.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
unfold pair_free_left in |- *.

*****
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
forall M1 M2 N : Msg, not (g (MPair M1 M2) N)
+++++
intros.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
unfold pair_free_left in |- *.
intros.

*****
M1,M2,N : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
not (g (MPair M1 M2) N)
+++++
red in |- *.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
unfold pair_free_left in |- *.
intros.
red in |- *.

*****
M1,M2,N : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
forall _ : g (MPair M1 M2) N, False
+++++
intro.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
unfold pair_free_left in |- *.
intros.
red in |- *.
intro.

*****
H13 : g (MPair M1 M2) N
M1,M2,N : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
False
+++++
generalize (le_h_impl_incl_syn g h H1).
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
unfold pair_free_left in |- *.
intros.
red in |- *.
intro.
generalize (le_h_impl_incl_syn g h H1).

*****
H13 : g (MPair M1 M2) N
M1,M2,N : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
forall _ : inclusion g (synthesis h), False
+++++
unfold inclusion in |- *.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
unfold pair_free_left in |- *.
intros.
red in |- *.
intro.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.

*****
H13 : g (MPair M1 M2) N
M1,M2,N : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
forall _ : forall (M N : Msg) (_ : g M N), synthesis h M N, False
+++++
intros.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
unfold pair_free_left in |- *.
intros.
red in |- *.
intro.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intros.

*****
H14 : forall (M N : Msg) (_ : g M N), synthesis h M N
H13 : g (MPair M1 M2) N
M1,M2,N : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
False
+++++
generalize (H14 (MPair M1 M2) N H13).
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
unfold pair_free_left in |- *.
intros.
red in |- *.
intro.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intros.
generalize (H14 (MPair M1 M2) N H13).

*****
H14 : forall (M N : Msg) (_ : g M N), synthesis h M N
H13 : g (MPair M1 M2) N
M1,M2,N : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
forall _ : synthesis h (MPair M1 M2) N, False
+++++
intro.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
unfold pair_free_left in |- *.
intros.
red in |- *.
intro.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intros.
generalize (H14 (MPair M1 M2) N H13).
intro.

*****
H15 : synthesis h (MPair M1 M2) N
H14 : forall (M N : Msg) (_ : g M N), synthesis h M N
H13 : g (MPair M1 M2) N
M1,M2,N : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
False
+++++
inversion H15.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
unfold pair_free_left in |- *.
intros.
red in |- *.
intro.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intros.
generalize (H14 (MPair M1 M2) N H13).
intro.
inversion H15.

*****
H18 : eq N0 N
H17 : eq M (MPair M1 M2)
H16 : h (MPair M1 M2) N
M,N0 : Msg
H15 : synthesis h (MPair M1 M2) N
H14 : forall (M N : Msg) (_ : g M N), synthesis h M N
H13 : g (MPair M1 M2) N
M1,M2,N : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
False
+++++
unfold pair_free_left in H8.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
unfold pair_free_left in |- *.
intros.
red in |- *.
intro.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intros.
generalize (H14 (MPair M1 M2) N H13).
intro.
inversion H15.
unfold pair_free_left in H8.

*****
H18 : eq N0 N
H17 : eq M (MPair M1 M2)
H16 : h (MPair M1 M2) N
M,N0 : Msg
H15 : synthesis h (MPair M1 M2) N
H14 : forall (M N : Msg) (_ : g M N), synthesis h M N
H13 : g (MPair M1 M2) N
M1,M2,N : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
False
+++++
apply (H8 M1 M2 N).
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
unfold pair_free_left in |- *.
intros.
red in |- *.
intro.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intros.
generalize (H14 (MPair M1 M2) N H13).
intro.
inversion H15.
unfold pair_free_left in H8.
apply (H8 M1 M2 N).

*****
H18 : eq N0 N
H17 : eq M (MPair M1 M2)
H16 : h (MPair M1 M2) N
M,N0 : Msg
H15 : synthesis h (MPair M1 M2) N
H14 : forall (M N : Msg) (_ : g M N), synthesis h M N
H13 : g (MPair M1 M2) N
M1,M2,N : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : forall M1 M2 N : Msg, not (h (MPair M1 M2) N)
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
h (MPair M1 M2) N
+++++
trivial.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
unfold pair_free_left in |- *.
intros.
red in |- *.
intro.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intros.
generalize (H14 (MPair M1 M2) N H13).
intro.
inversion H15.

*****
H19 : eq (MPair N1 N2) N
H17 : eq M3 M2
H16 : eq M0 M1
H20 : synthesis h M2 N2
H18 : synthesis h M1 N1
M0,N1,M3,N2 : Msg
H15 : synthesis h (MPair M1 M2) N
H14 : forall (M N : Msg) (_ : g M N), synthesis h M N
H13 : g (MPair M1 M2) N
M1,M2,N : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
False
+++++
rewrite <- H19 in H13.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
unfold pair_free_left in |- *.
intros.
red in |- *.
intro.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intros.
generalize (H14 (MPair M1 M2) N H13).
intro.
inversion H15.
rewrite <- H19 in H13.

*****
H19 : eq (MPair N1 N2) N
H17 : eq M3 M2
H16 : eq M0 M1
H20 : synthesis h M2 N2
H18 : synthesis h M1 N1
M0,M3 : Msg
H15 : synthesis h (MPair M1 M2) N
H14 : forall (M N : Msg) (_ : g M N), synthesis h M N
H13 : g (MPair M1 M2) (MPair N1 N2)
M1,M2,N,N1,N2 : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
False
+++++
generalize (irreducible_pair g M1 N1 M2 N2).
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
unfold pair_free_left in |- *.
intros.
red in |- *.
intro.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intros.
generalize (H14 (MPair M1 M2) N H13).
intro.
inversion H15.
rewrite <- H19 in H13.
generalize (irreducible_pair g M1 N1 M2 N2).

*****
H19 : eq (MPair N1 N2) N
H17 : eq M3 M2
H16 : eq M0 M1
H20 : synthesis h M2 N2
H18 : synthesis h M1 N1
M0,M3 : Msg
H15 : synthesis h (MPair M1 M2) N
H14 : forall (M N : Msg) (_ : g M N), synthesis h M N
H13 : g (MPair M1 M2) (MPair N1 N2)
M1,M2,N,N1,N2 : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
forall _ : not (irreducible g (MPair M1 M2) (MPair N1 N2)), False
+++++
intro.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
unfold pair_free_left in |- *.
intros.
red in |- *.
intro.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intros.
generalize (H14 (MPair M1 M2) N H13).
intro.
inversion H15.
rewrite <- H19 in H13.
generalize (irreducible_pair g M1 N1 M2 N2).
intro.

*****
H21 : not (irreducible g (MPair M1 M2) (MPair N1 N2))
H19 : eq (MPair N1 N2) N
H17 : eq M3 M2
H16 : eq M0 M1
H20 : synthesis h M2 N2
H18 : synthesis h M1 N1
M0,M3 : Msg
H15 : synthesis h (MPair M1 M2) N
H14 : forall (M N : Msg) (_ : g M N), synthesis h M N
H13 : g (MPair M1 M2) (MPair N1 N2)
M1,M2,N,N1,N2 : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
False
+++++
apply H21.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
unfold pair_free_left in |- *.
intros.
red in |- *.
intro.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intros.
generalize (H14 (MPair M1 M2) N H13).
intro.
inversion H15.
rewrite <- H19 in H13.
generalize (irreducible_pair g M1 N1 M2 N2).
intro.
apply H21.

*****
H21 : not (irreducible g (MPair M1 M2) (MPair N1 N2))
H19 : eq (MPair N1 N2) N
H17 : eq M3 M2
H16 : eq M0 M1
H20 : synthesis h M2 N2
H18 : synthesis h M1 N1
M0,M3 : Msg
H15 : synthesis h (MPair M1 M2) N
H14 : forall (M N : Msg) (_ : g M N), synthesis h M N
H13 : g (MPair M1 M2) (MPair N1 N2)
M1,M2,N,N1,N2 : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
irreducible g (MPair M1 M2) (MPair N1 N2)
+++++
unfold is_irreducible in H.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
unfold pair_free_left in |- *.
intros.
red in |- *.
intro.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intros.
generalize (H14 (MPair M1 M2) N H13).
intro.
inversion H15.
rewrite <- H19 in H13.
generalize (irreducible_pair g M1 N1 M2 N2).
intro.
apply H21.
unfold is_irreducible in H.

*****
H21 : not (irreducible g (MPair M1 M2) (MPair N1 N2))
H19 : eq (MPair N1 N2) N
H17 : eq M3 M2
H16 : eq M0 M1
H20 : synthesis h M2 N2
H18 : synthesis h M1 N1
M0,M3 : Msg
H15 : synthesis h (MPair M1 M2) N
H14 : forall (M N : Msg) (_ : g M N), synthesis h M N
H13 : g (MPair M1 M2) (MPair N1 N2)
M1,M2,N,N1,N2 : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : equal g (irreducible g)
g,h : hedge
*****
irreducible g (MPair M1 M2) (MPair N1 N2)
+++++
unfold equal in H.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
unfold pair_free_left in |- *.
intros.
red in |- *.
intro.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intros.
generalize (H14 (MPair M1 M2) N H13).
intro.
inversion H15.
rewrite <- H19 in H13.
generalize (irreducible_pair g M1 N1 M2 N2).
intro.
apply H21.
unfold is_irreducible in H.
unfold equal in H.

*****
H21 : not (irreducible g (MPair M1 M2) (MPair N1 N2))
H19 : eq (MPair N1 N2) N
H17 : eq M3 M2
H16 : eq M0 M1
H20 : synthesis h M2 N2
H18 : synthesis h M1 N1
M0,M3 : Msg
H15 : synthesis h (MPair M1 M2) N
H14 : forall (M N : Msg) (_ : g M N), synthesis h M N
H13 : g (MPair M1 M2) (MPair N1 N2)
M1,M2,N,N1,N2 : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
irreducible g (MPair M1 M2) (MPair N1 N2)
+++++
elim H.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
unfold pair_free_left in |- *.
intros.
red in |- *.
intro.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intros.
generalize (H14 (MPair M1 M2) N H13).
intro.
inversion H15.
rewrite <- H19 in H13.
generalize (irreducible_pair g M1 N1 M2 N2).
intro.
apply H21.
unfold is_irreducible in H.
unfold equal in H.
elim H.

*****
H21 : not (irreducible g (MPair M1 M2) (MPair N1 N2))
H19 : eq (MPair N1 N2) N
H17 : eq M3 M2
H16 : eq M0 M1
H20 : synthesis h M2 N2
H18 : synthesis h M1 N1
M0,M3 : Msg
H15 : synthesis h (MPair M1 M2) N
H14 : forall (M N : Msg) (_ : g M N), synthesis h M N
H13 : g (MPair M1 M2) (MPair N1 N2)
M1,M2,N,N1,N2 : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
forall (_ : inclusion g (irreducible g)) (_ : inclusion (irreducible g) g), irreducible g (MPair M1 M2) (MPair N1 N2)
+++++
unfold inclusion in |- *.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
unfold pair_free_left in |- *.
intros.
red in |- *.
intro.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intros.
generalize (H14 (MPair M1 M2) N H13).
intro.
inversion H15.
rewrite <- H19 in H13.
generalize (irreducible_pair g M1 N1 M2 N2).
intro.
apply H21.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.

*****
H21 : not (irreducible g (MPair M1 M2) (MPair N1 N2))
H19 : eq (MPair N1 N2) N
H17 : eq M3 M2
H16 : eq M0 M1
H20 : synthesis h M2 N2
H18 : synthesis h M1 N1
M0,M3 : Msg
H15 : synthesis h (MPair M1 M2) N
H14 : forall (M N : Msg) (_ : g M N), synthesis h M N
H13 : g (MPair M1 M2) (MPair N1 N2)
M1,M2,N,N1,N2 : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
forall (_ : forall (M N : Msg) (_ : g M N), irreducible g M N) (_ : forall (M N : Msg) (_ : irreducible g M N), g M N), irreducible g (MPair M1 M2) (MPair N1 N2)
+++++
auto.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.

*****
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
and (enc_synthesis_left g) (enc_analysis_left g)
+++++
split.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.

*****
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
enc_synthesis_left g
+++++
unfold enc_synthesis_left in |- *.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_synthesis_left in |- *.

*****
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
forall (M N : Msg) (_ : g M N) (M' K : Msg) (_ : eq M (MEnc M' K)) (N' L : Msg), or (not (synthesis g M' N')) (not (synthesis g K L))
+++++
intros.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_synthesis_left in |- *.
intros.

*****
N',L : Msg
H14 : eq M (MEnc M' K)
M',K : Msg
H13 : g M N
M,N : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
or (not (synthesis g M' N')) (not (synthesis g K L))
+++++
generalize (le_h_impl_incl_syn g h H1).
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_synthesis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).

*****
N',L : Msg
H14 : eq M (MEnc M' K)
M',K : Msg
H13 : g M N
M,N : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
forall _ : inclusion g (synthesis h), or (not (synthesis g M' N')) (not (synthesis g K L))
+++++
unfold inclusion in |- *.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_synthesis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.

*****
N',L : Msg
H14 : eq M (MEnc M' K)
M',K : Msg
H13 : g M N
M,N : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
forall _ : forall (M N : Msg) (_ : g M N), synthesis h M N, or (not (synthesis g M' N')) (not (synthesis g K L))
+++++
intro.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_synthesis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.

*****
H15 : forall (M N : Msg) (_ : g M N), synthesis h M N
N',L : Msg
H14 : eq M (MEnc M' K)
M',K : Msg
H13 : g M N
M,N : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
or (not (synthesis g M' N')) (not (synthesis g K L))
+++++
generalize (H15 M N H13).
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_synthesis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H15 M N H13).

*****
H15 : forall (M N : Msg) (_ : g M N), synthesis h M N
N',L : Msg
H14 : eq M (MEnc M' K)
M',K : Msg
H13 : g M N
M,N : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
forall _ : synthesis h M N, or (not (synthesis g M' N')) (not (synthesis g K L))
+++++
intro.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_synthesis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H15 M N H13).
intro.

*****
H16 : synthesis h M N
H15 : forall (M N : Msg) (_ : g M N), synthesis h M N
N',L : Msg
H14 : eq M (MEnc M' K)
M',K : Msg
H13 : g M N
M,N : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
or (not (synthesis g M' N')) (not (synthesis g K L))
+++++
rewrite H14 in H16.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_synthesis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H15 M N H13).
intro.
rewrite H14 in H16.

*****
H16 : synthesis h (MEnc M' K) N
H15 : forall (M N : Msg) (_ : g M N), synthesis h M N
N',L : Msg
H14 : eq M (MEnc M' K)
M',K : Msg
H13 : g M N
M,N : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
or (not (synthesis g M' N')) (not (synthesis g K L))
+++++
inversion H16.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_synthesis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H15 M N H13).
intro.
rewrite H14 in H16.
inversion H16.

*****
H19 : eq N0 N
H18 : eq M0 (MEnc M' K)
H17 : h (MEnc M' K) N
M0,N0 : Msg
H16 : synthesis h (MEnc M' K) N
H15 : forall (M N : Msg) (_ : g M N), synthesis h M N
N',L : Msg
H14 : eq M (MEnc M' K)
M',K : Msg
H13 : g M N
M,N : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
or (not (synthesis g M' N')) (not (synthesis g K L))
+++++
rewrite <- H14 in H17.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_synthesis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H15 M N H13).
intro.
rewrite H14 in H16.
inversion H16.
rewrite <- H14 in H17.

*****
H19 : eq N0 N
H18 : eq M0 (MEnc M' K)
H17 : h M N
M0,N0 : Msg
H16 : synthesis h (MEnc M' K) N
H15 : forall (M N : Msg) (_ : g M N), synthesis h M N
N',L : Msg
H14 : eq M (MEnc M' K)
M',K : Msg
H13 : g M N
M,N : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
or (not (synthesis g M' N')) (not (synthesis g K L))
+++++
unfold enc_synthesis_left in H10.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_synthesis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H15 M N H13).
intro.
rewrite H14 in H16.
inversion H16.
rewrite <- H14 in H17.
unfold enc_synthesis_left in H10.

*****
H19 : eq N0 N
H18 : eq M0 (MEnc M' K)
H17 : h M N
M0,N0 : Msg
H16 : synthesis h (MEnc M' K) N
H15 : forall (M N : Msg) (_ : g M N), synthesis h M N
N',L : Msg
H14 : eq M (MEnc M' K)
M',K : Msg
H13 : g M N
M,N : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
or (not (synthesis g M' N')) (not (synthesis g K L))
+++++
generalize (H10 M N H17 M' K H14).
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_synthesis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H15 M N H13).
intro.
rewrite H14 in H16.
inversion H16.
rewrite <- H14 in H17.
unfold enc_synthesis_left in H10.
generalize (H10 M N H17 M' K H14).

*****
H19 : eq N0 N
H18 : eq M0 (MEnc M' K)
H17 : h M N
M0,N0 : Msg
H16 : synthesis h (MEnc M' K) N
H15 : forall (M N : Msg) (_ : g M N), synthesis h M N
N',L : Msg
H14 : eq M (MEnc M' K)
M',K : Msg
H13 : g M N
M,N : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
forall _ : forall N' L : Msg, or (not (synthesis h M' N')) (not (synthesis h K L)), or (not (synthesis g M' N')) (not (synthesis g K L))
+++++
intros.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_synthesis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H15 M N H13).
intro.
rewrite H14 in H16.
inversion H16.
rewrite <- H14 in H17.
unfold enc_synthesis_left in H10.
generalize (H10 M N H17 M' K H14).
intros.

*****
H20 : forall N' L : Msg, or (not (synthesis h M' N')) (not (synthesis h K L))
H19 : eq N0 N
H18 : eq M0 (MEnc M' K)
H17 : h M N
M0,N0 : Msg
H16 : synthesis h (MEnc M' K) N
H15 : forall (M N : Msg) (_ : g M N), synthesis h M N
N',L : Msg
H14 : eq M (MEnc M' K)
M',K : Msg
H13 : g M N
M,N : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
or (not (synthesis g M' N')) (not (synthesis g K L))
+++++
case (H20 N' L).
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_synthesis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H15 M N H13).
intro.
rewrite H14 in H16.
inversion H16.
rewrite <- H14 in H17.
unfold enc_synthesis_left in H10.
generalize (H10 M N H17 M' K H14).
intros.
case (H20 N' L).

*****
H20 : forall N' L : Msg, or (not (synthesis h M' N')) (not (synthesis h K L))
H19 : eq N0 N
H18 : eq M0 (MEnc M' K)
H17 : h M N
M0,N0 : Msg
H16 : synthesis h (MEnc M' K) N
H15 : forall (M N : Msg) (_ : g M N), synthesis h M N
N',L : Msg
H14 : eq M (MEnc M' K)
M',K : Msg
H13 : g M N
M,N : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
forall _ : not (synthesis h M' N'), or (not (synthesis g M' N')) (not (synthesis g K L))
+++++
intro.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_synthesis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H15 M N H13).
intro.
rewrite H14 in H16.
inversion H16.
rewrite <- H14 in H17.
unfold enc_synthesis_left in H10.
generalize (H10 M N H17 M' K H14).
intros.
case (H20 N' L).
intro.

*****
H21 : not (synthesis h M' N')
H20 : forall N' L : Msg, or (not (synthesis h M' N')) (not (synthesis h K L))
H19 : eq N0 N
H18 : eq M0 (MEnc M' K)
H17 : h M N
M0,N0 : Msg
H16 : synthesis h (MEnc M' K) N
H15 : forall (M N : Msg) (_ : g M N), synthesis h M N
N',L : Msg
H14 : eq M (MEnc M' K)
M',K : Msg
H13 : g M N
M,N : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
or (not (synthesis g M' N')) (not (synthesis g K L))
+++++
left.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_synthesis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H15 M N H13).
intro.
rewrite H14 in H16.
inversion H16.
rewrite <- H14 in H17.
unfold enc_synthesis_left in H10.
generalize (H10 M N H17 M' K H14).
intros.
case (H20 N' L).
intro.
left.

*****
H21 : not (synthesis h M' N')
H20 : forall N' L : Msg, or (not (synthesis h M' N')) (not (synthesis h K L))
H19 : eq N0 N
H18 : eq M0 (MEnc M' K)
H17 : h M N
M0,N0 : Msg
H16 : synthesis h (MEnc M' K) N
H15 : forall (M N : Msg) (_ : g M N), synthesis h M N
N',L : Msg
H14 : eq M (MEnc M' K)
M',K : Msg
H13 : g M N
M,N : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
not (synthesis g M' N')
+++++
red in |- *.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_synthesis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H15 M N H13).
intro.
rewrite H14 in H16.
inversion H16.
rewrite <- H14 in H17.
unfold enc_synthesis_left in H10.
generalize (H10 M N H17 M' K H14).
intros.
case (H20 N' L).
intro.
left.
red in |- *.

*****
H21 : not (synthesis h M' N')
H20 : forall N' L : Msg, or (not (synthesis h M' N')) (not (synthesis h K L))
H19 : eq N0 N
H18 : eq M0 (MEnc M' K)
H17 : h M N
M0,N0 : Msg
H16 : synthesis h (MEnc M' K) N
H15 : forall (M N : Msg) (_ : g M N), synthesis h M N
N',L : Msg
H14 : eq M (MEnc M' K)
M',K : Msg
H13 : g M N
M,N : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
forall _ : synthesis g M' N', False
+++++
intro.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_synthesis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H15 M N H13).
intro.
rewrite H14 in H16.
inversion H16.
rewrite <- H14 in H17.
unfold enc_synthesis_left in H10.
generalize (H10 M N H17 M' K H14).
intros.
case (H20 N' L).
intro.
left.
red in |- *.
intro.

*****
H22 : synthesis g M' N'
H21 : not (synthesis h M' N')
H20 : forall N' L : Msg, or (not (synthesis h M' N')) (not (synthesis h K L))
H19 : eq N0 N
H18 : eq M0 (MEnc M' K)
H17 : h M N
M0,N0 : Msg
H16 : synthesis h (MEnc M' K) N
H15 : forall (M N : Msg) (_ : g M N), synthesis h M N
N',L : Msg
H14 : eq M (MEnc M' K)
M',K : Msg
H13 : g M N
M,N : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
False
+++++
apply H21.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_synthesis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H15 M N H13).
intro.
rewrite H14 in H16.
inversion H16.
rewrite <- H14 in H17.
unfold enc_synthesis_left in H10.
generalize (H10 M N H17 M' K H14).
intros.
case (H20 N' L).
intro.
left.
red in |- *.
intro.
apply H21.

*****
H22 : synthesis g M' N'
H21 : not (synthesis h M' N')
H20 : forall N' L : Msg, or (not (synthesis h M' N')) (not (synthesis h K L))
H19 : eq N0 N
H18 : eq M0 (MEnc M' K)
H17 : h M N
M0,N0 : Msg
H16 : synthesis h (MEnc M' K) N
H15 : forall (M N : Msg) (_ : g M N), synthesis h M N
N',L : Msg
H14 : eq M (MEnc M' K)
M',K : Msg
H13 : g M N
M,N : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
synthesis h M' N'
+++++
unfold le_h in H1.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_synthesis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H15 M N H13).
intro.
rewrite H14 in H16.
inversion H16.
rewrite <- H14 in H17.
unfold enc_synthesis_left in H10.
generalize (H10 M N H17 M' K H14).
intros.
case (H20 N' L).
intro.
left.
red in |- *.
intro.
apply H21.
unfold le_h in H1.

*****
H22 : synthesis g M' N'
H21 : not (synthesis h M' N')
H20 : forall N' L : Msg, or (not (synthesis h M' N')) (not (synthesis h K L))
H19 : eq N0 N
H18 : eq M0 (MEnc M' K)
H17 : h M N
M0,N0 : Msg
H16 : synthesis h (MEnc M' K) N
H15 : forall (M N : Msg) (_ : g M N), synthesis h M N
N',L : Msg
H14 : eq M (MEnc M' K)
M',K : Msg
H13 : g M N
M,N : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : inclusion (synthesis g) (synthesis h)
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
synthesis h M' N'
+++++
unfold inclusion in H1.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_synthesis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H15 M N H13).
intro.
rewrite H14 in H16.
inversion H16.
rewrite <- H14 in H17.
unfold enc_synthesis_left in H10.
generalize (H10 M N H17 M' K H14).
intros.
case (H20 N' L).
intro.
left.
red in |- *.
intro.
apply H21.
unfold le_h in H1.
unfold inclusion in H1.

*****
H22 : synthesis g M' N'
H21 : not (synthesis h M' N')
H20 : forall N' L : Msg, or (not (synthesis h M' N')) (not (synthesis h K L))
H19 : eq N0 N
H18 : eq M0 (MEnc M' K)
H17 : h M N
M0,N0 : Msg
H16 : synthesis h (MEnc M' K) N
H15 : forall (M N : Msg) (_ : g M N), synthesis h M N
N',L : Msg
H14 : eq M (MEnc M' K)
M',K : Msg
H13 : g M N
M,N : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
synthesis h M' N'
+++++
auto.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_synthesis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H15 M N H13).
intro.
rewrite H14 in H16.
inversion H16.
rewrite <- H14 in H17.
unfold enc_synthesis_left in H10.
generalize (H10 M N H17 M' K H14).
intros.
case (H20 N' L).

*****
H20 : forall N' L : Msg, or (not (synthesis h M' N')) (not (synthesis h K L))
H19 : eq N0 N
H18 : eq M0 (MEnc M' K)
H17 : h M N
M0,N0 : Msg
H16 : synthesis h (MEnc M' K) N
H15 : forall (M N : Msg) (_ : g M N), synthesis h M N
N',L : Msg
H14 : eq M (MEnc M' K)
M',K : Msg
H13 : g M N
M,N : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
forall _ : not (synthesis h K L), or (not (synthesis g M' N')) (not (synthesis g K L))
+++++
right.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_synthesis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H15 M N H13).
intro.
rewrite H14 in H16.
inversion H16.
rewrite <- H14 in H17.
unfold enc_synthesis_left in H10.
generalize (H10 M N H17 M' K H14).
intros.
case (H20 N' L).
right.

*****
H21 : not (synthesis h K L)
H20 : forall N' L : Msg, or (not (synthesis h M' N')) (not (synthesis h K L))
H19 : eq N0 N
H18 : eq M0 (MEnc M' K)
H17 : h M N
M0,N0 : Msg
H16 : synthesis h (MEnc M' K) N
H15 : forall (M N : Msg) (_ : g M N), synthesis h M N
N',L : Msg
H14 : eq M (MEnc M' K)
M',K : Msg
H13 : g M N
M,N : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
not (synthesis g K L)
+++++
red in |- *.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_synthesis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H15 M N H13).
intro.
rewrite H14 in H16.
inversion H16.
rewrite <- H14 in H17.
unfold enc_synthesis_left in H10.
generalize (H10 M N H17 M' K H14).
intros.
case (H20 N' L).
right.
red in |- *.

*****
H21 : not (synthesis h K L)
H20 : forall N' L : Msg, or (not (synthesis h M' N')) (not (synthesis h K L))
H19 : eq N0 N
H18 : eq M0 (MEnc M' K)
H17 : h M N
M0,N0 : Msg
H16 : synthesis h (MEnc M' K) N
H15 : forall (M N : Msg) (_ : g M N), synthesis h M N
N',L : Msg
H14 : eq M (MEnc M' K)
M',K : Msg
H13 : g M N
M,N : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
forall _ : synthesis g K L, False
+++++
intro.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_synthesis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H15 M N H13).
intro.
rewrite H14 in H16.
inversion H16.
rewrite <- H14 in H17.
unfold enc_synthesis_left in H10.
generalize (H10 M N H17 M' K H14).
intros.
case (H20 N' L).
right.
red in |- *.
intro.

*****
H22 : synthesis g K L
H21 : not (synthesis h K L)
H20 : forall N' L : Msg, or (not (synthesis h M' N')) (not (synthesis h K L))
H19 : eq N0 N
H18 : eq M0 (MEnc M' K)
H17 : h M N
M0,N0 : Msg
H16 : synthesis h (MEnc M' K) N
H15 : forall (M N : Msg) (_ : g M N), synthesis h M N
N',L : Msg
H14 : eq M (MEnc M' K)
M',K : Msg
H13 : g M N
M,N : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
False
+++++
apply H21.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_synthesis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H15 M N H13).
intro.
rewrite H14 in H16.
inversion H16.
rewrite <- H14 in H17.
unfold enc_synthesis_left in H10.
generalize (H10 M N H17 M' K H14).
intros.
case (H20 N' L).
right.
red in |- *.
intro.
apply H21.

*****
H22 : synthesis g K L
H21 : not (synthesis h K L)
H20 : forall N' L : Msg, or (not (synthesis h M' N')) (not (synthesis h K L))
H19 : eq N0 N
H18 : eq M0 (MEnc M' K)
H17 : h M N
M0,N0 : Msg
H16 : synthesis h (MEnc M' K) N
H15 : forall (M N : Msg) (_ : g M N), synthesis h M N
N',L : Msg
H14 : eq M (MEnc M' K)
M',K : Msg
H13 : g M N
M,N : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
synthesis h K L
+++++
unfold le_h in H1.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_synthesis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H15 M N H13).
intro.
rewrite H14 in H16.
inversion H16.
rewrite <- H14 in H17.
unfold enc_synthesis_left in H10.
generalize (H10 M N H17 M' K H14).
intros.
case (H20 N' L).
right.
red in |- *.
intro.
apply H21.
unfold le_h in H1.

*****
H22 : synthesis g K L
H21 : not (synthesis h K L)
H20 : forall N' L : Msg, or (not (synthesis h M' N')) (not (synthesis h K L))
H19 : eq N0 N
H18 : eq M0 (MEnc M' K)
H17 : h M N
M0,N0 : Msg
H16 : synthesis h (MEnc M' K) N
H15 : forall (M N : Msg) (_ : g M N), synthesis h M N
N',L : Msg
H14 : eq M (MEnc M' K)
M',K : Msg
H13 : g M N
M,N : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : inclusion (synthesis g) (synthesis h)
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
synthesis h K L
+++++
unfold inclusion in H1.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_synthesis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H15 M N H13).
intro.
rewrite H14 in H16.
inversion H16.
rewrite <- H14 in H17.
unfold enc_synthesis_left in H10.
generalize (H10 M N H17 M' K H14).
intros.
case (H20 N' L).
right.
red in |- *.
intro.
apply H21.
unfold le_h in H1.
unfold inclusion in H1.

*****
H22 : synthesis g K L
H21 : not (synthesis h K L)
H20 : forall N' L : Msg, or (not (synthesis h M' N')) (not (synthesis h K L))
H19 : eq N0 N
H18 : eq M0 (MEnc M' K)
H17 : h M N
M0,N0 : Msg
H16 : synthesis h (MEnc M' K) N
H15 : forall (M N : Msg) (_ : g M N), synthesis h M N
N',L : Msg
H14 : eq M (MEnc M' K)
M',K : Msg
H13 : g M N
M,N : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (N' L : Msg), or (not (synthesis h M' N')) (not (synthesis h K L))
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
synthesis h K L
+++++
auto.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_synthesis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H15 M N H13).
intro.
rewrite H14 in H16.
inversion H16.

*****
H20 : eq (MEnc N0 L0) N
H18 : eq K0 K
H17 : eq M0 M'
H21 : synthesis h K L0
H19 : synthesis h M' N0
M0,N0,K0,L0 : Msg
H16 : synthesis h (MEnc M' K) N
H15 : forall (M N : Msg) (_ : g M N), synthesis h M N
N',L : Msg
H14 : eq M (MEnc M' K)
M',K : Msg
H13 : g M N
M,N : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
or (not (synthesis g M' N')) (not (synthesis g K L))
+++++
rewrite H14 in H13.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_synthesis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H15 M N H13).
intro.
rewrite H14 in H16.
inversion H16.
rewrite H14 in H13.

*****
H20 : eq (MEnc N0 L0) N
H18 : eq K0 K
H17 : eq M0 M'
H21 : synthesis h K L0
H19 : synthesis h M' N0
M0,N0,K0,L0 : Msg
H16 : synthesis h (MEnc M' K) N
H15 : forall (M N : Msg) (_ : g M N), synthesis h M N
N',L : Msg
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) N
M,N,M',K : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
or (not (synthesis g M' N')) (not (synthesis g K L))
+++++
rewrite <- H20 in H13.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_synthesis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H15 M N H13).
intro.
rewrite H14 in H16.
inversion H16.
rewrite H14 in H13.
rewrite <- H20 in H13.

*****
H20 : eq (MEnc N0 L0) N
H18 : eq K0 K
H17 : eq M0 M'
H21 : synthesis h K L0
H19 : synthesis h M' N0
M0,K0 : Msg
H16 : synthesis h (MEnc M' K) N
H15 : forall (M N : Msg) (_ : g M N), synthesis h M N
N',L : Msg
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N0 L0)
M,N,M',K,N0,L0 : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
or (not (synthesis g M' N')) (not (synthesis g K L))
+++++
elim (irreducible_enc g M' N0 K L0).
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_synthesis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H15 M N H13).
intro.
rewrite H14 in H16.
inversion H16.
rewrite H14 in H13.
rewrite <- H20 in H13.
elim (irreducible_enc g M' N0 K L0).

*****
H20 : eq (MEnc N0 L0) N
H18 : eq K0 K
H17 : eq M0 M'
H21 : synthesis h K L0
H19 : synthesis h M' N0
M0,K0 : Msg
H16 : synthesis h (MEnc M' K) N
H15 : forall (M N : Msg) (_ : g M N), synthesis h M N
N',L : Msg
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N0 L0)
M,N,M',K,N0,L0 : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
forall (_ : forall _ : irreducible g (MEnc M' K) (MEnc N0 L0), and (analysis_def g (MEnc M' K) (MEnc N0 L0)) (or (not (synthesis (analysis_def g) M' N0)) (not (synthesis (analysis_def g) K L0)))) (_ : forall _ : and (analysis_def g (MEnc M' K) (MEnc N0 L0)) (or (not (synthesis (analysis_def g) M' N0)) (not (synthesis (analysis_def g) K L0))), irreducible g (MEnc M' K) (MEnc N0 L0)), or (not (synthesis g M' N')) (not (synthesis g K L))
+++++
intros.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_synthesis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H15 M N H13).
intro.
rewrite H14 in H16.
inversion H16.
rewrite H14 in H13.
rewrite <- H20 in H13.
elim (irreducible_enc g M' N0 K L0).
intros.

*****
H23 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))),\nirreducible g (MEnc M' K) (MEnc N0 L0)
H22 : forall _ : irreducible g (MEnc M' K) (MEnc N0 L0),\nand (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0)))
H20 : eq (MEnc N0 L0) N
H18 : eq K0 K
H17 : eq M0 M'
H21 : synthesis h K L0
H19 : synthesis h M' N0
M0,K0 : Msg
H16 : synthesis h (MEnc M' K) N
H15 : forall (M N : Msg) (_ : g M N), synthesis h M N
N',L : Msg
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N0 L0)
M,N,M',K,N0,L0 : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
or (not (synthesis g M' N')) (not (synthesis g K L))
+++++
unfold is_irreducible in H.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_synthesis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H15 M N H13).
intro.
rewrite H14 in H16.
inversion H16.
rewrite H14 in H13.
rewrite <- H20 in H13.
elim (irreducible_enc g M' N0 K L0).
intros.
unfold is_irreducible in H.

*****
H23 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))),\nirreducible g (MEnc M' K) (MEnc N0 L0)
H22 : forall _ : irreducible g (MEnc M' K) (MEnc N0 L0),\nand (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0)))
H20 : eq (MEnc N0 L0) N
H18 : eq K0 K
H17 : eq M0 M'
H21 : synthesis h K L0
H19 : synthesis h M' N0
M0,K0 : Msg
H16 : synthesis h (MEnc M' K) N
H15 : forall (M N : Msg) (_ : g M N), synthesis h M N
N',L : Msg
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N0 L0)
M,N,M',K,N0,L0 : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : equal g (irreducible g)
g,h : hedge
*****
or (not (synthesis g M' N')) (not (synthesis g K L))
+++++
unfold equal in H.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_synthesis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H15 M N H13).
intro.
rewrite H14 in H16.
inversion H16.
rewrite H14 in H13.
rewrite <- H20 in H13.
elim (irreducible_enc g M' N0 K L0).
intros.
unfold is_irreducible in H.
unfold equal in H.

*****
H23 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))),\nirreducible g (MEnc M' K) (MEnc N0 L0)
H22 : forall _ : irreducible g (MEnc M' K) (MEnc N0 L0),\nand (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0)))
H20 : eq (MEnc N0 L0) N
H18 : eq K0 K
H17 : eq M0 M'
H21 : synthesis h K L0
H19 : synthesis h M' N0
M0,K0 : Msg
H16 : synthesis h (MEnc M' K) N
H15 : forall (M N : Msg) (_ : g M N), synthesis h M N
N',L : Msg
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N0 L0)
M,N,M',K,N0,L0 : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
or (not (synthesis g M' N')) (not (synthesis g K L))
+++++
elim H.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_synthesis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H15 M N H13).
intro.
rewrite H14 in H16.
inversion H16.
rewrite H14 in H13.
rewrite <- H20 in H13.
elim (irreducible_enc g M' N0 K L0).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.

*****
H23 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))),\nirreducible g (MEnc M' K) (MEnc N0 L0)
H22 : forall _ : irreducible g (MEnc M' K) (MEnc N0 L0),\nand (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0)))
H20 : eq (MEnc N0 L0) N
H18 : eq K0 K
H17 : eq M0 M'
H21 : synthesis h K L0
H19 : synthesis h M' N0
M0,K0 : Msg
H16 : synthesis h (MEnc M' K) N
H15 : forall (M N : Msg) (_ : g M N), synthesis h M N
N',L : Msg
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N0 L0)
M,N,M',K,N0,L0 : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
forall (_ : inclusion g (irreducible g)) (_ : inclusion (irreducible g) g), or (not (synthesis g M' N')) (not (synthesis g K L))
+++++
unfold inclusion in |- *.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_synthesis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H15 M N H13).
intro.
rewrite H14 in H16.
inversion H16.
rewrite H14 in H13.
rewrite <- H20 in H13.
elim (irreducible_enc g M' N0 K L0).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.

*****
H23 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))),\nirreducible g (MEnc M' K) (MEnc N0 L0)
H22 : forall _ : irreducible g (MEnc M' K) (MEnc N0 L0),\nand (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0)))
H20 : eq (MEnc N0 L0) N
H18 : eq K0 K
H17 : eq M0 M'
H21 : synthesis h K L0
H19 : synthesis h M' N0
M0,K0 : Msg
H16 : synthesis h (MEnc M' K) N
H15 : forall (M N : Msg) (_ : g M N), synthesis h M N
N',L : Msg
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N0 L0)
M,N,M',K,N0,L0 : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
forall (_ : forall (M N : Msg) (_ : g M N), irreducible g M N) (_ : forall (M N : Msg) (_ : irreducible g M N), g M N), or (not (synthesis g M' N')) (not (synthesis g K L))
+++++
intros.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_synthesis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H15 M N H13).
intro.
rewrite H14 in H16.
inversion H16.
rewrite H14 in H13.
rewrite <- H20 in H13.
elim (irreducible_enc g M' N0 K L0).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.

*****
H25 : forall (M N : Msg) (_ : irreducible g M N), g M N
H24 : forall (M N : Msg) (_ : g M N), irreducible g M N
H23 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))),\nirreducible g (MEnc M' K) (MEnc N0 L0)
H22 : forall _ : irreducible g (MEnc M' K) (MEnc N0 L0),\nand (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0)))
H20 : eq (MEnc N0 L0) N
H18 : eq K0 K
H17 : eq M0 M'
H21 : synthesis h K L0
H19 : synthesis h M' N0
M0,K0 : Msg
H16 : synthesis h (MEnc M' K) N
H15 : forall (M N : Msg) (_ : g M N), synthesis h M N
N',L : Msg
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N0 L0)
M,N,M',K,N0,L0 : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
or (not (synthesis g M' N')) (not (synthesis g K L))
+++++
elim (H22 (H24 (MEnc M' K) (MEnc N0 L0) H13)).
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_synthesis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H15 M N H13).
intro.
rewrite H14 in H16.
inversion H16.
rewrite H14 in H13.
rewrite <- H20 in H13.
elim (irreducible_enc g M' N0 K L0).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
elim (H22 (H24 (MEnc M' K) (MEnc N0 L0) H13)).

*****
H25 : forall (M N : Msg) (_ : irreducible g M N), g M N
H24 : forall (M N : Msg) (_ : g M N), irreducible g M N
H23 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))),\nirreducible g (MEnc M' K) (MEnc N0 L0)
H22 : forall _ : irreducible g (MEnc M' K) (MEnc N0 L0),\nand (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0)))
H20 : eq (MEnc N0 L0) N
H18 : eq K0 K
H17 : eq M0 M'
H21 : synthesis h K L0
H19 : synthesis h M' N0
M0,K0 : Msg
H16 : synthesis h (MEnc M' K) N
H15 : forall (M N : Msg) (_ : g M N), synthesis h M N
N',L : Msg
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N0 L0)
M,N,M',K,N0,L0 : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
forall (_ : analysis_def g (MEnc M' K) (MEnc N0 L0)) (_ : or (not (synthesis (analysis_def g) M' N0)) (not (synthesis (analysis_def g) K L0))), or (not (synthesis g M' N')) (not (synthesis g K L))
+++++
intros.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_synthesis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H15 M N H13).
intro.
rewrite H14 in H16.
inversion H16.
rewrite H14 in H13.
rewrite <- H20 in H13.
elim (irreducible_enc g M' N0 K L0).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
elim (H22 (H24 (MEnc M' K) (MEnc N0 L0) H13)).
intros.

*****
H27 : or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))
H26 : analysis_def g (MEnc M' K) (MEnc N0 L0)
H25 : forall (M N : Msg) (_ : irreducible g M N), g M N
H24 : forall (M N : Msg) (_ : g M N), irreducible g M N
H23 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))),\nirreducible g (MEnc M' K) (MEnc N0 L0)
H22 : forall _ : irreducible g (MEnc M' K) (MEnc N0 L0),\nand (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0)))
H20 : eq (MEnc N0 L0) N
H18 : eq K0 K
H17 : eq M0 M'
H21 : synthesis h K L0
H19 : synthesis h M' N0
M0,K0 : Msg
H16 : synthesis h (MEnc M' K) N
H15 : forall (M N : Msg) (_ : g M N), synthesis h M N
N',L : Msg
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N0 L0)
M,N,M',K,N0,L0 : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
or (not (synthesis g M' N')) (not (synthesis g K L))
+++++
case H27.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_synthesis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H15 M N H13).
intro.
rewrite H14 in H16.
inversion H16.
rewrite H14 in H13.
rewrite <- H20 in H13.
elim (irreducible_enc g M' N0 K L0).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
elim (H22 (H24 (MEnc M' K) (MEnc N0 L0) H13)).
intros.
case H27.

*****
H27 : or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))
H26 : analysis_def g (MEnc M' K) (MEnc N0 L0)
H25 : forall (M N : Msg) (_ : irreducible g M N), g M N
H24 : forall (M N : Msg) (_ : g M N), irreducible g M N
H23 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))),\nirreducible g (MEnc M' K) (MEnc N0 L0)
H22 : forall _ : irreducible g (MEnc M' K) (MEnc N0 L0),\nand (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0)))
H20 : eq (MEnc N0 L0) N
H18 : eq K0 K
H17 : eq M0 M'
H21 : synthesis h K L0
H19 : synthesis h M' N0
M0,K0 : Msg
H16 : synthesis h (MEnc M' K) N
H15 : forall (M N : Msg) (_ : g M N), synthesis h M N
N',L : Msg
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N0 L0)
M,N,M',K,N0,L0 : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
forall _ : not (synthesis (analysis_def g) M' N0), or (not (synthesis g M' N')) (not (synthesis g K L))
+++++
intros.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_synthesis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H15 M N H13).
intro.
rewrite H14 in H16.
inversion H16.
rewrite H14 in H13.
rewrite <- H20 in H13.
elim (irreducible_enc g M' N0 K L0).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
elim (H22 (H24 (MEnc M' K) (MEnc N0 L0) H13)).
intros.
case H27.
intros.

*****
H28 : not (synthesis (analysis_def g) M' N0)
H27 : or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))
H26 : analysis_def g (MEnc M' K) (MEnc N0 L0)
H25 : forall (M N : Msg) (_ : irreducible g M N), g M N
H24 : forall (M N : Msg) (_ : g M N), irreducible g M N
H23 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))),\nirreducible g (MEnc M' K) (MEnc N0 L0)
H22 : forall _ : irreducible g (MEnc M' K) (MEnc N0 L0),\nand (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0)))
H20 : eq (MEnc N0 L0) N
H18 : eq K0 K
H17 : eq M0 M'
H21 : synthesis h K L0
H19 : synthesis h M' N0
M0,K0 : Msg
H16 : synthesis h (MEnc M' K) N
H15 : forall (M N : Msg) (_ : g M N), synthesis h M N
N',L : Msg
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N0 L0)
M,N,M',K,N0,L0 : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
or (not (synthesis g M' N')) (not (synthesis g K L))
+++++
left.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_synthesis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H15 M N H13).
intro.
rewrite H14 in H16.
inversion H16.
rewrite H14 in H13.
rewrite <- H20 in H13.
elim (irreducible_enc g M' N0 K L0).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
elim (H22 (H24 (MEnc M' K) (MEnc N0 L0) H13)).
intros.
case H27.
intros.
left.

*****
H28 : not (synthesis (analysis_def g) M' N0)
H27 : or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))
H26 : analysis_def g (MEnc M' K) (MEnc N0 L0)
H25 : forall (M N : Msg) (_ : irreducible g M N), g M N
H24 : forall (M N : Msg) (_ : g M N), irreducible g M N
H23 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))),\nirreducible g (MEnc M' K) (MEnc N0 L0)
H22 : forall _ : irreducible g (MEnc M' K) (MEnc N0 L0),\nand (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0)))
H20 : eq (MEnc N0 L0) N
H18 : eq K0 K
H17 : eq M0 M'
H21 : synthesis h K L0
H19 : synthesis h M' N0
M0,K0 : Msg
H16 : synthesis h (MEnc M' K) N
H15 : forall (M N : Msg) (_ : g M N), synthesis h M N
N',L : Msg
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N0 L0)
M,N,M',K,N0,L0 : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
not (synthesis g M' N')
+++++
red in |- *.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_synthesis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H15 M N H13).
intro.
rewrite H14 in H16.
inversion H16.
rewrite H14 in H13.
rewrite <- H20 in H13.
elim (irreducible_enc g M' N0 K L0).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
elim (H22 (H24 (MEnc M' K) (MEnc N0 L0) H13)).
intros.
case H27.
intros.
left.
red in |- *.

*****
H28 : not (synthesis (analysis_def g) M' N0)
H27 : or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))
H26 : analysis_def g (MEnc M' K) (MEnc N0 L0)
H25 : forall (M N : Msg) (_ : irreducible g M N), g M N
H24 : forall (M N : Msg) (_ : g M N), irreducible g M N
H23 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))),\nirreducible g (MEnc M' K) (MEnc N0 L0)
H22 : forall _ : irreducible g (MEnc M' K) (MEnc N0 L0),\nand (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0)))
H20 : eq (MEnc N0 L0) N
H18 : eq K0 K
H17 : eq M0 M'
H21 : synthesis h K L0
H19 : synthesis h M' N0
M0,K0 : Msg
H16 : synthesis h (MEnc M' K) N
H15 : forall (M N : Msg) (_ : g M N), synthesis h M N
N',L : Msg
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N0 L0)
M,N,M',K,N0,L0 : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
forall _ : synthesis g M' N', False
+++++
intro.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_synthesis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H15 M N H13).
intro.
rewrite H14 in H16.
inversion H16.
rewrite H14 in H13.
rewrite <- H20 in H13.
elim (irreducible_enc g M' N0 K L0).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
elim (H22 (H24 (MEnc M' K) (MEnc N0 L0) H13)).
intros.
case H27.
intros.
left.
red in |- *.
intro.

*****
H29 : synthesis g M' N'
H28 : not (synthesis (analysis_def g) M' N0)
H27 : or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))
H26 : analysis_def g (MEnc M' K) (MEnc N0 L0)
H25 : forall (M N : Msg) (_ : irreducible g M N), g M N
H24 : forall (M N : Msg) (_ : g M N), irreducible g M N
H23 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))),\nirreducible g (MEnc M' K) (MEnc N0 L0)
H22 : forall _ : irreducible g (MEnc M' K) (MEnc N0 L0),\nand (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0)))
H20 : eq (MEnc N0 L0) N
H18 : eq K0 K
H17 : eq M0 M'
H21 : synthesis h K L0
H19 : synthesis h M' N0
M0,K0 : Msg
H16 : synthesis h (MEnc M' K) N
H15 : forall (M N : Msg) (_ : g M N), synthesis h M N
N',L : Msg
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N0 L0)
M,N,M',K,N0,L0 : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
False
+++++
cut (N' = N0).
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_synthesis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H15 M N H13).
intro.
rewrite H14 in H16.
inversion H16.
rewrite H14 in H13.
rewrite <- H20 in H13.
elim (irreducible_enc g M' N0 K L0).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
elim (H22 (H24 (MEnc M' K) (MEnc N0 L0) H13)).
intros.
case H27.
intros.
left.
red in |- *.
intro.
cut (N' = N0).

*****
H29 : synthesis g M' N'
H28 : not (synthesis (analysis_def g) M' N0)
H27 : or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))
H26 : analysis_def g (MEnc M' K) (MEnc N0 L0)
H25 : forall (M N : Msg) (_ : irreducible g M N), g M N
H24 : forall (M N : Msg) (_ : g M N), irreducible g M N
H23 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))),\nirreducible g (MEnc M' K) (MEnc N0 L0)
H22 : forall _ : irreducible g (MEnc M' K) (MEnc N0 L0),\nand (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0)))
H20 : eq (MEnc N0 L0) N
H18 : eq K0 K
H17 : eq M0 M'
H21 : synthesis h K L0
H19 : synthesis h M' N0
M0,K0 : Msg
H16 : synthesis h (MEnc M' K) N
H15 : forall (M N : Msg) (_ : g M N), synthesis h M N
N',L : Msg
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N0 L0)
M,N,M',K,N0,L0 : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
forall _ : eq N' N0, False
+++++
intro.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_synthesis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H15 M N H13).
intro.
rewrite H14 in H16.
inversion H16.
rewrite H14 in H13.
rewrite <- H20 in H13.
elim (irreducible_enc g M' N0 K L0).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
elim (H22 (H24 (MEnc M' K) (MEnc N0 L0) H13)).
intros.
case H27.
intros.
left.
red in |- *.
intro.
cut (N' = N0).
intro.

*****
H30 : eq N' N0
H29 : synthesis g M' N'
H28 : not (synthesis (analysis_def g) M' N0)
H27 : or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))
H26 : analysis_def g (MEnc M' K) (MEnc N0 L0)
H25 : forall (M N : Msg) (_ : irreducible g M N), g M N
H24 : forall (M N : Msg) (_ : g M N), irreducible g M N
H23 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))),\nirreducible g (MEnc M' K) (MEnc N0 L0)
H22 : forall _ : irreducible g (MEnc M' K) (MEnc N0 L0),\nand (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0)))
H20 : eq (MEnc N0 L0) N
H18 : eq K0 K
H17 : eq M0 M'
H21 : synthesis h K L0
H19 : synthesis h M' N0
M0,K0 : Msg
H16 : synthesis h (MEnc M' K) N
H15 : forall (M N : Msg) (_ : g M N), synthesis h M N
N',L : Msg
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N0 L0)
M,N,M',K,N0,L0 : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
False
+++++
apply H28.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_synthesis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H15 M N H13).
intro.
rewrite H14 in H16.
inversion H16.
rewrite H14 in H13.
rewrite <- H20 in H13.
elim (irreducible_enc g M' N0 K L0).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
elim (H22 (H24 (MEnc M' K) (MEnc N0 L0) H13)).
intros.
case H27.
intros.
left.
red in |- *.
intro.
cut (N' = N0).
intro.
apply H28.

*****
H30 : eq N' N0
H29 : synthesis g M' N'
H28 : not (synthesis (analysis_def g) M' N0)
H27 : or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))
H26 : analysis_def g (MEnc M' K) (MEnc N0 L0)
H25 : forall (M N : Msg) (_ : irreducible g M N), g M N
H24 : forall (M N : Msg) (_ : g M N), irreducible g M N
H23 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))),\nirreducible g (MEnc M' K) (MEnc N0 L0)
H22 : forall _ : irreducible g (MEnc M' K) (MEnc N0 L0),\nand (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0)))
H20 : eq (MEnc N0 L0) N
H18 : eq K0 K
H17 : eq M0 M'
H21 : synthesis h K L0
H19 : synthesis h M' N0
M0,K0 : Msg
H16 : synthesis h (MEnc M' K) N
H15 : forall (M N : Msg) (_ : g M N), synthesis h M N
N',L : Msg
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N0 L0)
M,N,M',K,N0,L0 : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
synthesis (analysis_def g) M' N0
+++++
rewrite <- H30.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_synthesis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H15 M N H13).
intro.
rewrite H14 in H16.
inversion H16.
rewrite H14 in H13.
rewrite <- H20 in H13.
elim (irreducible_enc g M' N0 K L0).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
elim (H22 (H24 (MEnc M' K) (MEnc N0 L0) H13)).
intros.
case H27.
intros.
left.
red in |- *.
intro.
cut (N' = N0).
intro.
apply H28.
rewrite <- H30.

*****
H30 : eq N' N0
H29 : synthesis g M' N'
H28 : not (synthesis (analysis_def g) M' N0)
H27 : or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))
H26 : analysis_def g (MEnc M' K) (MEnc N0 L0)
H25 : forall (M N : Msg) (_ : irreducible g M N), g M N
H24 : forall (M N : Msg) (_ : g M N), irreducible g M N
H23 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))),\nirreducible g (MEnc M' K) (MEnc N0 L0)
H22 : forall _ : irreducible g (MEnc M' K) (MEnc N0 L0),\nand (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0)))
H20 : eq (MEnc N0 L0) N
H18 : eq K0 K
H17 : eq M0 M'
H21 : synthesis h K L0
H19 : synthesis h M' N0
M0,K0 : Msg
H16 : synthesis h (MEnc M' K) N
H15 : forall (M N : Msg) (_ : g M N), synthesis h M N
N',L : Msg
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N0 L0)
M,N,M',K,N0,L0 : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
synthesis (analysis_def g) M' N'
+++++
generalize (h_le_h_ana_h g).
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_synthesis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H15 M N H13).
intro.
rewrite H14 in H16.
inversion H16.
rewrite H14 in H13.
rewrite <- H20 in H13.
elim (irreducible_enc g M' N0 K L0).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
elim (H22 (H24 (MEnc M' K) (MEnc N0 L0) H13)).
intros.
case H27.
intros.
left.
red in |- *.
intro.
cut (N' = N0).
intro.
apply H28.
rewrite <- H30.
generalize (h_le_h_ana_h g).

*****
H30 : eq N' N0
H29 : synthesis g M' N'
H28 : not (synthesis (analysis_def g) M' N0)
H27 : or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))
H26 : analysis_def g (MEnc M' K) (MEnc N0 L0)
H25 : forall (M N : Msg) (_ : irreducible g M N), g M N
H24 : forall (M N : Msg) (_ : g M N), irreducible g M N
H23 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))),\nirreducible g (MEnc M' K) (MEnc N0 L0)
H22 : forall _ : irreducible g (MEnc M' K) (MEnc N0 L0),\nand (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0)))
H20 : eq (MEnc N0 L0) N
H18 : eq K0 K
H17 : eq M0 M'
H21 : synthesis h K L0
H19 : synthesis h M' N0
M0,K0 : Msg
H16 : synthesis h (MEnc M' K) N
H15 : forall (M N : Msg) (_ : g M N), synthesis h M N
N',L : Msg
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N0 L0)
M,N,M',K,N0,L0 : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
forall _ : le_h g (analysis_def g), synthesis (analysis_def g) M' N'
+++++
unfold le_h in |- *.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_synthesis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H15 M N H13).
intro.
rewrite H14 in H16.
inversion H16.
rewrite H14 in H13.
rewrite <- H20 in H13.
elim (irreducible_enc g M' N0 K L0).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
elim (H22 (H24 (MEnc M' K) (MEnc N0 L0) H13)).
intros.
case H27.
intros.
left.
red in |- *.
intro.
cut (N' = N0).
intro.
apply H28.
rewrite <- H30.
generalize (h_le_h_ana_h g).
unfold le_h in |- *.

*****
H30 : eq N' N0
H29 : synthesis g M' N'
H28 : not (synthesis (analysis_def g) M' N0)
H27 : or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))
H26 : analysis_def g (MEnc M' K) (MEnc N0 L0)
H25 : forall (M N : Msg) (_ : irreducible g M N), g M N
H24 : forall (M N : Msg) (_ : g M N), irreducible g M N
H23 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))),\nirreducible g (MEnc M' K) (MEnc N0 L0)
H22 : forall _ : irreducible g (MEnc M' K) (MEnc N0 L0),\nand (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0)))
H20 : eq (MEnc N0 L0) N
H18 : eq K0 K
H17 : eq M0 M'
H21 : synthesis h K L0
H19 : synthesis h M' N0
M0,K0 : Msg
H16 : synthesis h (MEnc M' K) N
H15 : forall (M N : Msg) (_ : g M N), synthesis h M N
N',L : Msg
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N0 L0)
M,N,M',K,N0,L0 : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
forall _ : inclusion (synthesis g) (synthesis (analysis_def g)), synthesis (analysis_def g) M' N'
+++++
unfold inclusion in |- *.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_synthesis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H15 M N H13).
intro.
rewrite H14 in H16.
inversion H16.
rewrite H14 in H13.
rewrite <- H20 in H13.
elim (irreducible_enc g M' N0 K L0).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
elim (H22 (H24 (MEnc M' K) (MEnc N0 L0) H13)).
intros.
case H27.
intros.
left.
red in |- *.
intro.
cut (N' = N0).
intro.
apply H28.
rewrite <- H30.
generalize (h_le_h_ana_h g).
unfold le_h in |- *.
unfold inclusion in |- *.

*****
H30 : eq N' N0
H29 : synthesis g M' N'
H28 : not (synthesis (analysis_def g) M' N0)
H27 : or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))
H26 : analysis_def g (MEnc M' K) (MEnc N0 L0)
H25 : forall (M N : Msg) (_ : irreducible g M N), g M N
H24 : forall (M N : Msg) (_ : g M N), irreducible g M N
H23 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))),\nirreducible g (MEnc M' K) (MEnc N0 L0)
H22 : forall _ : irreducible g (MEnc M' K) (MEnc N0 L0),\nand (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0)))
H20 : eq (MEnc N0 L0) N
H18 : eq K0 K
H17 : eq M0 M'
H21 : synthesis h K L0
H19 : synthesis h M' N0
M0,K0 : Msg
H16 : synthesis h (MEnc M' K) N
H15 : forall (M N : Msg) (_ : g M N), synthesis h M N
N',L : Msg
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N0 L0)
M,N,M',K,N0,L0 : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
forall _ : forall (M N : Msg) (_ : synthesis g M N), synthesis (analysis_def g) M N, synthesis (analysis_def g) M' N'
+++++
auto.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_synthesis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H15 M N H13).
intro.
rewrite H14 in H16.
inversion H16.
rewrite H14 in H13.
rewrite <- H20 in H13.
elim (irreducible_enc g M' N0 K L0).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
elim (H22 (H24 (MEnc M' K) (MEnc N0 L0) H13)).
intros.
case H27.
intros.
left.
red in |- *.
intro.
cut (N' = N0).

*****
H29 : synthesis g M' N'
H28 : not (synthesis (analysis_def g) M' N0)
H27 : or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))
H26 : analysis_def g (MEnc M' K) (MEnc N0 L0)
H25 : forall (M N : Msg) (_ : irreducible g M N), g M N
H24 : forall (M N : Msg) (_ : g M N), irreducible g M N
H23 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))),\nirreducible g (MEnc M' K) (MEnc N0 L0)
H22 : forall _ : irreducible g (MEnc M' K) (MEnc N0 L0),\nand (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0)))
H20 : eq (MEnc N0 L0) N
H18 : eq K0 K
H17 : eq M0 M'
H21 : synthesis h K L0
H19 : synthesis h M' N0
M0,K0 : Msg
H16 : synthesis h (MEnc M' K) N
H15 : forall (M N : Msg) (_ : g M N), synthesis h M N
N',L : Msg
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N0 L0)
M,N,M',K,N0,L0 : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
eq N' N0
+++++
unfold le_h in H1.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_synthesis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H15 M N H13).
intro.
rewrite H14 in H16.
inversion H16.
rewrite H14 in H13.
rewrite <- H20 in H13.
elim (irreducible_enc g M' N0 K L0).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
elim (H22 (H24 (MEnc M' K) (MEnc N0 L0) H13)).
intros.
case H27.
intros.
left.
red in |- *.
intro.
cut (N' = N0).
unfold le_h in H1.

*****
H29 : synthesis g M' N'
H28 : not (synthesis (analysis_def g) M' N0)
H27 : or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))
H26 : analysis_def g (MEnc M' K) (MEnc N0 L0)
H25 : forall (M N : Msg) (_ : irreducible g M N), g M N
H24 : forall (M N : Msg) (_ : g M N), irreducible g M N
H23 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))),\nirreducible g (MEnc M' K) (MEnc N0 L0)
H22 : forall _ : irreducible g (MEnc M' K) (MEnc N0 L0),\nand (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0)))
H20 : eq (MEnc N0 L0) N
H18 : eq K0 K
H17 : eq M0 M'
H21 : synthesis h K L0
H19 : synthesis h M' N0
M0,K0 : Msg
H16 : synthesis h (MEnc M' K) N
H15 : forall (M N : Msg) (_ : g M N), synthesis h M N
N',L : Msg
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N0 L0)
M,N,M',K,N0,L0 : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : inclusion (synthesis g) (synthesis h)
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
eq N' N0
+++++
unfold inclusion in H1.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_synthesis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H15 M N H13).
intro.
rewrite H14 in H16.
inversion H16.
rewrite H14 in H13.
rewrite <- H20 in H13.
elim (irreducible_enc g M' N0 K L0).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
elim (H22 (H24 (MEnc M' K) (MEnc N0 L0) H13)).
intros.
case H27.
intros.
left.
red in |- *.
intro.
cut (N' = N0).
unfold le_h in H1.
unfold inclusion in H1.

*****
H29 : synthesis g M' N'
H28 : not (synthesis (analysis_def g) M' N0)
H27 : or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))
H26 : analysis_def g (MEnc M' K) (MEnc N0 L0)
H25 : forall (M N : Msg) (_ : irreducible g M N), g M N
H24 : forall (M N : Msg) (_ : g M N), irreducible g M N
H23 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))),\nirreducible g (MEnc M' K) (MEnc N0 L0)
H22 : forall _ : irreducible g (MEnc M' K) (MEnc N0 L0),\nand (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0)))
H20 : eq (MEnc N0 L0) N
H18 : eq K0 K
H17 : eq M0 M'
H21 : synthesis h K L0
H19 : synthesis h M' N0
M0,K0 : Msg
H16 : synthesis h (MEnc M' K) N
H15 : forall (M N : Msg) (_ : g M N), synthesis h M N
N',L : Msg
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N0 L0)
M,N,M',K,N0,L0 : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
eq N' N0
+++++
generalize (H1 M' N' H29).
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_synthesis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H15 M N H13).
intro.
rewrite H14 in H16.
inversion H16.
rewrite H14 in H13.
rewrite <- H20 in H13.
elim (irreducible_enc g M' N0 K L0).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
elim (H22 (H24 (MEnc M' K) (MEnc N0 L0) H13)).
intros.
case H27.
intros.
left.
red in |- *.
intro.
cut (N' = N0).
unfold le_h in H1.
unfold inclusion in H1.
generalize (H1 M' N' H29).

*****
H29 : synthesis g M' N'
H28 : not (synthesis (analysis_def g) M' N0)
H27 : or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))
H26 : analysis_def g (MEnc M' K) (MEnc N0 L0)
H25 : forall (M N : Msg) (_ : irreducible g M N), g M N
H24 : forall (M N : Msg) (_ : g M N), irreducible g M N
H23 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))),\nirreducible g (MEnc M' K) (MEnc N0 L0)
H22 : forall _ : irreducible g (MEnc M' K) (MEnc N0 L0),\nand (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0)))
H20 : eq (MEnc N0 L0) N
H18 : eq K0 K
H17 : eq M0 M'
H21 : synthesis h K L0
H19 : synthesis h M' N0
M0,K0 : Msg
H16 : synthesis h (MEnc M' K) N
H15 : forall (M N : Msg) (_ : g M N), synthesis h M N
N',L : Msg
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N0 L0)
M,N,M',K,N0,L0 : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
forall _ : synthesis h M' N', eq N' N0
+++++
intro.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_synthesis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H15 M N H13).
intro.
rewrite H14 in H16.
inversion H16.
rewrite H14 in H13.
rewrite <- H20 in H13.
elim (irreducible_enc g M' N0 K L0).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
elim (H22 (H24 (MEnc M' K) (MEnc N0 L0) H13)).
intros.
case H27.
intros.
left.
red in |- *.
intro.
cut (N' = N0).
unfold le_h in H1.
unfold inclusion in H1.
generalize (H1 M' N' H29).
intro.

*****
H30 : synthesis h M' N'
H29 : synthesis g M' N'
H28 : not (synthesis (analysis_def g) M' N0)
H27 : or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))
H26 : analysis_def g (MEnc M' K) (MEnc N0 L0)
H25 : forall (M N : Msg) (_ : irreducible g M N), g M N
H24 : forall (M N : Msg) (_ : g M N), irreducible g M N
H23 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))),\nirreducible g (MEnc M' K) (MEnc N0 L0)
H22 : forall _ : irreducible g (MEnc M' K) (MEnc N0 L0),\nand (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0)))
H20 : eq (MEnc N0 L0) N
H18 : eq K0 K
H17 : eq M0 M'
H21 : synthesis h K L0
H19 : synthesis h M' N0
M0,K0 : Msg
H16 : synthesis h (MEnc M' K) N
H15 : forall (M N : Msg) (_ : g M N), synthesis h M N
N',L : Msg
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N0 L0)
M,N,M',K,N0,L0 : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
eq N' N0
+++++
unfold injective_left in H12.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_synthesis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H15 M N H13).
intro.
rewrite H14 in H16.
inversion H16.
rewrite H14 in H13.
rewrite <- H20 in H13.
elim (irreducible_enc g M' N0 K L0).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
elim (H22 (H24 (MEnc M' K) (MEnc N0 L0) H13)).
intros.
case H27.
intros.
left.
red in |- *.
intro.
cut (N' = N0).
unfold le_h in H1.
unfold inclusion in H1.
generalize (H1 M' N' H29).
intro.
unfold injective_left in H12.

*****
H30 : synthesis h M' N'
H29 : synthesis g M' N'
H28 : not (synthesis (analysis_def g) M' N0)
H27 : or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))
H26 : analysis_def g (MEnc M' K) (MEnc N0 L0)
H25 : forall (M N : Msg) (_ : irreducible g M N), g M N
H24 : forall (M N : Msg) (_ : g M N), irreducible g M N
H23 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))),\nirreducible g (MEnc M' K) (MEnc N0 L0)
H22 : forall _ : irreducible g (MEnc M' K) (MEnc N0 L0),\nand (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0)))
H20 : eq (MEnc N0 L0) N
H18 : eq K0 K
H17 : eq M0 M'
H21 : synthesis h K L0
H19 : synthesis h M' N0
M0,K0 : Msg
H16 : synthesis h (MEnc M' K) N
H15 : forall (M N : Msg) (_ : g M N), synthesis h M N
N',L : Msg
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N0 L0)
M,N,M',K,N0,L0 : Msg
H12 : forall (M N : Msg) (_ : synthesis h M N) (M' N' : Msg)\n (_ : synthesis h M' N') (_ : eq M M'), eq N N'
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
eq N' N0
+++++
apply (H12 M' N' H30 M' N0 H19).
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_synthesis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H15 M N H13).
intro.
rewrite H14 in H16.
inversion H16.
rewrite H14 in H13.
rewrite <- H20 in H13.
elim (irreducible_enc g M' N0 K L0).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
elim (H22 (H24 (MEnc M' K) (MEnc N0 L0) H13)).
intros.
case H27.
intros.
left.
red in |- *.
intro.
cut (N' = N0).
unfold le_h in H1.
unfold inclusion in H1.
generalize (H1 M' N' H29).
intro.
unfold injective_left in H12.
apply (H12 M' N' H30 M' N0 H19).

*****
H30 : synthesis h M' N'
H29 : synthesis g M' N'
H28 : not (synthesis (analysis_def g) M' N0)
H27 : or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))
H26 : analysis_def g (MEnc M' K) (MEnc N0 L0)
H25 : forall (M N : Msg) (_ : irreducible g M N), g M N
H24 : forall (M N : Msg) (_ : g M N), irreducible g M N
H23 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))),\nirreducible g (MEnc M' K) (MEnc N0 L0)
H22 : forall _ : irreducible g (MEnc M' K) (MEnc N0 L0),\nand (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0)))
H20 : eq (MEnc N0 L0) N
H18 : eq K0 K
H17 : eq M0 M'
H21 : synthesis h K L0
H19 : synthesis h M' N0
M0,K0 : Msg
H16 : synthesis h (MEnc M' K) N
H15 : forall (M N : Msg) (_ : g M N), synthesis h M N
N',L : Msg
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N0 L0)
M,N,M',K,N0,L0 : Msg
H12 : forall (M N : Msg) (_ : synthesis h M N) (M' N' : Msg)\n (_ : synthesis h M' N') (_ : eq M M'), eq N N'
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
eq M' M'
+++++
trivial.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_synthesis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H15 M N H13).
intro.
rewrite H14 in H16.
inversion H16.
rewrite H14 in H13.
rewrite <- H20 in H13.
elim (irreducible_enc g M' N0 K L0).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
elim (H22 (H24 (MEnc M' K) (MEnc N0 L0) H13)).
intros.
case H27.

*****
H27 : or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))
H26 : analysis_def g (MEnc M' K) (MEnc N0 L0)
H25 : forall (M N : Msg) (_ : irreducible g M N), g M N
H24 : forall (M N : Msg) (_ : g M N), irreducible g M N
H23 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))),\nirreducible g (MEnc M' K) (MEnc N0 L0)
H22 : forall _ : irreducible g (MEnc M' K) (MEnc N0 L0),\nand (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0)))
H20 : eq (MEnc N0 L0) N
H18 : eq K0 K
H17 : eq M0 M'
H21 : synthesis h K L0
H19 : synthesis h M' N0
M0,K0 : Msg
H16 : synthesis h (MEnc M' K) N
H15 : forall (M N : Msg) (_ : g M N), synthesis h M N
N',L : Msg
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N0 L0)
M,N,M',K,N0,L0 : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
forall _ : not (synthesis (analysis_def g) K L0), or (not (synthesis g M' N')) (not (synthesis g K L))
+++++
right.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_synthesis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H15 M N H13).
intro.
rewrite H14 in H16.
inversion H16.
rewrite H14 in H13.
rewrite <- H20 in H13.
elim (irreducible_enc g M' N0 K L0).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
elim (H22 (H24 (MEnc M' K) (MEnc N0 L0) H13)).
intros.
case H27.
right.

*****
H28 : not (synthesis (analysis_def g) K L0)
H27 : or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))
H26 : analysis_def g (MEnc M' K) (MEnc N0 L0)
H25 : forall (M N : Msg) (_ : irreducible g M N), g M N
H24 : forall (M N : Msg) (_ : g M N), irreducible g M N
H23 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))),\nirreducible g (MEnc M' K) (MEnc N0 L0)
H22 : forall _ : irreducible g (MEnc M' K) (MEnc N0 L0),\nand (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0)))
H20 : eq (MEnc N0 L0) N
H18 : eq K0 K
H17 : eq M0 M'
H21 : synthesis h K L0
H19 : synthesis h M' N0
M0,K0 : Msg
H16 : synthesis h (MEnc M' K) N
H15 : forall (M N : Msg) (_ : g M N), synthesis h M N
N',L : Msg
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N0 L0)
M,N,M',K,N0,L0 : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
not (synthesis g K L)
+++++
red in |- *.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_synthesis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H15 M N H13).
intro.
rewrite H14 in H16.
inversion H16.
rewrite H14 in H13.
rewrite <- H20 in H13.
elim (irreducible_enc g M' N0 K L0).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
elim (H22 (H24 (MEnc M' K) (MEnc N0 L0) H13)).
intros.
case H27.
right.
red in |- *.

*****
H28 : not (synthesis (analysis_def g) K L0)
H27 : or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))
H26 : analysis_def g (MEnc M' K) (MEnc N0 L0)
H25 : forall (M N : Msg) (_ : irreducible g M N), g M N
H24 : forall (M N : Msg) (_ : g M N), irreducible g M N
H23 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))),\nirreducible g (MEnc M' K) (MEnc N0 L0)
H22 : forall _ : irreducible g (MEnc M' K) (MEnc N0 L0),\nand (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0)))
H20 : eq (MEnc N0 L0) N
H18 : eq K0 K
H17 : eq M0 M'
H21 : synthesis h K L0
H19 : synthesis h M' N0
M0,K0 : Msg
H16 : synthesis h (MEnc M' K) N
H15 : forall (M N : Msg) (_ : g M N), synthesis h M N
N',L : Msg
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N0 L0)
M,N,M',K,N0,L0 : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
forall _ : synthesis g K L, False
+++++
intro.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_synthesis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H15 M N H13).
intro.
rewrite H14 in H16.
inversion H16.
rewrite H14 in H13.
rewrite <- H20 in H13.
elim (irreducible_enc g M' N0 K L0).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
elim (H22 (H24 (MEnc M' K) (MEnc N0 L0) H13)).
intros.
case H27.
right.
red in |- *.
intro.

*****
H29 : synthesis g K L
H28 : not (synthesis (analysis_def g) K L0)
H27 : or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))
H26 : analysis_def g (MEnc M' K) (MEnc N0 L0)
H25 : forall (M N : Msg) (_ : irreducible g M N), g M N
H24 : forall (M N : Msg) (_ : g M N), irreducible g M N
H23 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))),\nirreducible g (MEnc M' K) (MEnc N0 L0)
H22 : forall _ : irreducible g (MEnc M' K) (MEnc N0 L0),\nand (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0)))
H20 : eq (MEnc N0 L0) N
H18 : eq K0 K
H17 : eq M0 M'
H21 : synthesis h K L0
H19 : synthesis h M' N0
M0,K0 : Msg
H16 : synthesis h (MEnc M' K) N
H15 : forall (M N : Msg) (_ : g M N), synthesis h M N
N',L : Msg
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N0 L0)
M,N,M',K,N0,L0 : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
False
+++++
apply H28.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_synthesis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H15 M N H13).
intro.
rewrite H14 in H16.
inversion H16.
rewrite H14 in H13.
rewrite <- H20 in H13.
elim (irreducible_enc g M' N0 K L0).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
elim (H22 (H24 (MEnc M' K) (MEnc N0 L0) H13)).
intros.
case H27.
right.
red in |- *.
intro.
apply H28.

*****
H29 : synthesis g K L
H28 : not (synthesis (analysis_def g) K L0)
H27 : or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))
H26 : analysis_def g (MEnc M' K) (MEnc N0 L0)
H25 : forall (M N : Msg) (_ : irreducible g M N), g M N
H24 : forall (M N : Msg) (_ : g M N), irreducible g M N
H23 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))),\nirreducible g (MEnc M' K) (MEnc N0 L0)
H22 : forall _ : irreducible g (MEnc M' K) (MEnc N0 L0),\nand (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0)))
H20 : eq (MEnc N0 L0) N
H18 : eq K0 K
H17 : eq M0 M'
H21 : synthesis h K L0
H19 : synthesis h M' N0
M0,K0 : Msg
H16 : synthesis h (MEnc M' K) N
H15 : forall (M N : Msg) (_ : g M N), synthesis h M N
N',L : Msg
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N0 L0)
M,N,M',K,N0,L0 : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
synthesis (analysis_def g) K L0
+++++
cut (L = L0).
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_synthesis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H15 M N H13).
intro.
rewrite H14 in H16.
inversion H16.
rewrite H14 in H13.
rewrite <- H20 in H13.
elim (irreducible_enc g M' N0 K L0).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
elim (H22 (H24 (MEnc M' K) (MEnc N0 L0) H13)).
intros.
case H27.
right.
red in |- *.
intro.
apply H28.
cut (L = L0).

*****
H29 : synthesis g K L
H28 : not (synthesis (analysis_def g) K L0)
H27 : or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))
H26 : analysis_def g (MEnc M' K) (MEnc N0 L0)
H25 : forall (M N : Msg) (_ : irreducible g M N), g M N
H24 : forall (M N : Msg) (_ : g M N), irreducible g M N
H23 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))),\nirreducible g (MEnc M' K) (MEnc N0 L0)
H22 : forall _ : irreducible g (MEnc M' K) (MEnc N0 L0),\nand (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0)))
H20 : eq (MEnc N0 L0) N
H18 : eq K0 K
H17 : eq M0 M'
H21 : synthesis h K L0
H19 : synthesis h M' N0
M0,K0 : Msg
H16 : synthesis h (MEnc M' K) N
H15 : forall (M N : Msg) (_ : g M N), synthesis h M N
N',L : Msg
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N0 L0)
M,N,M',K,N0,L0 : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
forall _ : eq L L0, synthesis (analysis_def g) K L0
+++++
intro.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_synthesis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H15 M N H13).
intro.
rewrite H14 in H16.
inversion H16.
rewrite H14 in H13.
rewrite <- H20 in H13.
elim (irreducible_enc g M' N0 K L0).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
elim (H22 (H24 (MEnc M' K) (MEnc N0 L0) H13)).
intros.
case H27.
right.
red in |- *.
intro.
apply H28.
cut (L = L0).
intro.

*****
H30 : eq L L0
H29 : synthesis g K L
H28 : not (synthesis (analysis_def g) K L0)
H27 : or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))
H26 : analysis_def g (MEnc M' K) (MEnc N0 L0)
H25 : forall (M N : Msg) (_ : irreducible g M N), g M N
H24 : forall (M N : Msg) (_ : g M N), irreducible g M N
H23 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))),\nirreducible g (MEnc M' K) (MEnc N0 L0)
H22 : forall _ : irreducible g (MEnc M' K) (MEnc N0 L0),\nand (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0)))
H20 : eq (MEnc N0 L0) N
H18 : eq K0 K
H17 : eq M0 M'
H21 : synthesis h K L0
H19 : synthesis h M' N0
M0,K0 : Msg
H16 : synthesis h (MEnc M' K) N
H15 : forall (M N : Msg) (_ : g M N), synthesis h M N
N',L : Msg
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N0 L0)
M,N,M',K,N0,L0 : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
synthesis (analysis_def g) K L0
+++++
rewrite <- H30.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_synthesis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H15 M N H13).
intro.
rewrite H14 in H16.
inversion H16.
rewrite H14 in H13.
rewrite <- H20 in H13.
elim (irreducible_enc g M' N0 K L0).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
elim (H22 (H24 (MEnc M' K) (MEnc N0 L0) H13)).
intros.
case H27.
right.
red in |- *.
intro.
apply H28.
cut (L = L0).
intro.
rewrite <- H30.

*****
H30 : eq L L0
H29 : synthesis g K L
H28 : not (synthesis (analysis_def g) K L0)
H27 : or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))
H26 : analysis_def g (MEnc M' K) (MEnc N0 L0)
H25 : forall (M N : Msg) (_ : irreducible g M N), g M N
H24 : forall (M N : Msg) (_ : g M N), irreducible g M N
H23 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))),\nirreducible g (MEnc M' K) (MEnc N0 L0)
H22 : forall _ : irreducible g (MEnc M' K) (MEnc N0 L0),\nand (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0)))
H20 : eq (MEnc N0 L0) N
H18 : eq K0 K
H17 : eq M0 M'
H21 : synthesis h K L0
H19 : synthesis h M' N0
M0,K0 : Msg
H16 : synthesis h (MEnc M' K) N
H15 : forall (M N : Msg) (_ : g M N), synthesis h M N
N',L : Msg
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N0 L0)
M,N,M',K,N0,L0 : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
synthesis (analysis_def g) K L
+++++
generalize (h_le_h_ana_h g).
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_synthesis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H15 M N H13).
intro.
rewrite H14 in H16.
inversion H16.
rewrite H14 in H13.
rewrite <- H20 in H13.
elim (irreducible_enc g M' N0 K L0).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
elim (H22 (H24 (MEnc M' K) (MEnc N0 L0) H13)).
intros.
case H27.
right.
red in |- *.
intro.
apply H28.
cut (L = L0).
intro.
rewrite <- H30.
generalize (h_le_h_ana_h g).

*****
H30 : eq L L0
H29 : synthesis g K L
H28 : not (synthesis (analysis_def g) K L0)
H27 : or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))
H26 : analysis_def g (MEnc M' K) (MEnc N0 L0)
H25 : forall (M N : Msg) (_ : irreducible g M N), g M N
H24 : forall (M N : Msg) (_ : g M N), irreducible g M N
H23 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))),\nirreducible g (MEnc M' K) (MEnc N0 L0)
H22 : forall _ : irreducible g (MEnc M' K) (MEnc N0 L0),\nand (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0)))
H20 : eq (MEnc N0 L0) N
H18 : eq K0 K
H17 : eq M0 M'
H21 : synthesis h K L0
H19 : synthesis h M' N0
M0,K0 : Msg
H16 : synthesis h (MEnc M' K) N
H15 : forall (M N : Msg) (_ : g M N), synthesis h M N
N',L : Msg
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N0 L0)
M,N,M',K,N0,L0 : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
forall _ : le_h g (analysis_def g), synthesis (analysis_def g) K L
+++++
unfold le_h in |- *.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_synthesis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H15 M N H13).
intro.
rewrite H14 in H16.
inversion H16.
rewrite H14 in H13.
rewrite <- H20 in H13.
elim (irreducible_enc g M' N0 K L0).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
elim (H22 (H24 (MEnc M' K) (MEnc N0 L0) H13)).
intros.
case H27.
right.
red in |- *.
intro.
apply H28.
cut (L = L0).
intro.
rewrite <- H30.
generalize (h_le_h_ana_h g).
unfold le_h in |- *.

*****
H30 : eq L L0
H29 : synthesis g K L
H28 : not (synthesis (analysis_def g) K L0)
H27 : or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))
H26 : analysis_def g (MEnc M' K) (MEnc N0 L0)
H25 : forall (M N : Msg) (_ : irreducible g M N), g M N
H24 : forall (M N : Msg) (_ : g M N), irreducible g M N
H23 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))),\nirreducible g (MEnc M' K) (MEnc N0 L0)
H22 : forall _ : irreducible g (MEnc M' K) (MEnc N0 L0),\nand (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0)))
H20 : eq (MEnc N0 L0) N
H18 : eq K0 K
H17 : eq M0 M'
H21 : synthesis h K L0
H19 : synthesis h M' N0
M0,K0 : Msg
H16 : synthesis h (MEnc M' K) N
H15 : forall (M N : Msg) (_ : g M N), synthesis h M N
N',L : Msg
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N0 L0)
M,N,M',K,N0,L0 : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
forall _ : inclusion (synthesis g) (synthesis (analysis_def g)), synthesis (analysis_def g) K L
+++++
unfold inclusion in |- *.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_synthesis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H15 M N H13).
intro.
rewrite H14 in H16.
inversion H16.
rewrite H14 in H13.
rewrite <- H20 in H13.
elim (irreducible_enc g M' N0 K L0).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
elim (H22 (H24 (MEnc M' K) (MEnc N0 L0) H13)).
intros.
case H27.
right.
red in |- *.
intro.
apply H28.
cut (L = L0).
intro.
rewrite <- H30.
generalize (h_le_h_ana_h g).
unfold le_h in |- *.
unfold inclusion in |- *.

*****
H30 : eq L L0
H29 : synthesis g K L
H28 : not (synthesis (analysis_def g) K L0)
H27 : or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))
H26 : analysis_def g (MEnc M' K) (MEnc N0 L0)
H25 : forall (M N : Msg) (_ : irreducible g M N), g M N
H24 : forall (M N : Msg) (_ : g M N), irreducible g M N
H23 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))),\nirreducible g (MEnc M' K) (MEnc N0 L0)
H22 : forall _ : irreducible g (MEnc M' K) (MEnc N0 L0),\nand (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0)))
H20 : eq (MEnc N0 L0) N
H18 : eq K0 K
H17 : eq M0 M'
H21 : synthesis h K L0
H19 : synthesis h M' N0
M0,K0 : Msg
H16 : synthesis h (MEnc M' K) N
H15 : forall (M N : Msg) (_ : g M N), synthesis h M N
N',L : Msg
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N0 L0)
M,N,M',K,N0,L0 : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
forall _ : forall (M N : Msg) (_ : synthesis g M N), synthesis (analysis_def g) M N, synthesis (analysis_def g) K L
+++++
auto.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_synthesis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H15 M N H13).
intro.
rewrite H14 in H16.
inversion H16.
rewrite H14 in H13.
rewrite <- H20 in H13.
elim (irreducible_enc g M' N0 K L0).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
elim (H22 (H24 (MEnc M' K) (MEnc N0 L0) H13)).
intros.
case H27.
right.
red in |- *.
intro.
apply H28.
cut (L = L0).

*****
H29 : synthesis g K L
H28 : not (synthesis (analysis_def g) K L0)
H27 : or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))
H26 : analysis_def g (MEnc M' K) (MEnc N0 L0)
H25 : forall (M N : Msg) (_ : irreducible g M N), g M N
H24 : forall (M N : Msg) (_ : g M N), irreducible g M N
H23 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))),\nirreducible g (MEnc M' K) (MEnc N0 L0)
H22 : forall _ : irreducible g (MEnc M' K) (MEnc N0 L0),\nand (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0)))
H20 : eq (MEnc N0 L0) N
H18 : eq K0 K
H17 : eq M0 M'
H21 : synthesis h K L0
H19 : synthesis h M' N0
M0,K0 : Msg
H16 : synthesis h (MEnc M' K) N
H15 : forall (M N : Msg) (_ : g M N), synthesis h M N
N',L : Msg
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N0 L0)
M,N,M',K,N0,L0 : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
eq L L0
+++++
unfold le_h in H1.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_synthesis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H15 M N H13).
intro.
rewrite H14 in H16.
inversion H16.
rewrite H14 in H13.
rewrite <- H20 in H13.
elim (irreducible_enc g M' N0 K L0).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
elim (H22 (H24 (MEnc M' K) (MEnc N0 L0) H13)).
intros.
case H27.
right.
red in |- *.
intro.
apply H28.
cut (L = L0).
unfold le_h in H1.

*****
H29 : synthesis g K L
H28 : not (synthesis (analysis_def g) K L0)
H27 : or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))
H26 : analysis_def g (MEnc M' K) (MEnc N0 L0)
H25 : forall (M N : Msg) (_ : irreducible g M N), g M N
H24 : forall (M N : Msg) (_ : g M N), irreducible g M N
H23 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))),\nirreducible g (MEnc M' K) (MEnc N0 L0)
H22 : forall _ : irreducible g (MEnc M' K) (MEnc N0 L0),\nand (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0)))
H20 : eq (MEnc N0 L0) N
H18 : eq K0 K
H17 : eq M0 M'
H21 : synthesis h K L0
H19 : synthesis h M' N0
M0,K0 : Msg
H16 : synthesis h (MEnc M' K) N
H15 : forall (M N : Msg) (_ : g M N), synthesis h M N
N',L : Msg
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N0 L0)
M,N,M',K,N0,L0 : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : inclusion (synthesis g) (synthesis h)
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
eq L L0
+++++
unfold inclusion in H1.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_synthesis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H15 M N H13).
intro.
rewrite H14 in H16.
inversion H16.
rewrite H14 in H13.
rewrite <- H20 in H13.
elim (irreducible_enc g M' N0 K L0).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
elim (H22 (H24 (MEnc M' K) (MEnc N0 L0) H13)).
intros.
case H27.
right.
red in |- *.
intro.
apply H28.
cut (L = L0).
unfold le_h in H1.
unfold inclusion in H1.

*****
H29 : synthesis g K L
H28 : not (synthesis (analysis_def g) K L0)
H27 : or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))
H26 : analysis_def g (MEnc M' K) (MEnc N0 L0)
H25 : forall (M N : Msg) (_ : irreducible g M N), g M N
H24 : forall (M N : Msg) (_ : g M N), irreducible g M N
H23 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))),\nirreducible g (MEnc M' K) (MEnc N0 L0)
H22 : forall _ : irreducible g (MEnc M' K) (MEnc N0 L0),\nand (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0)))
H20 : eq (MEnc N0 L0) N
H18 : eq K0 K
H17 : eq M0 M'
H21 : synthesis h K L0
H19 : synthesis h M' N0
M0,K0 : Msg
H16 : synthesis h (MEnc M' K) N
H15 : forall (M N : Msg) (_ : g M N), synthesis h M N
N',L : Msg
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N0 L0)
M,N,M',K,N0,L0 : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
eq L L0
+++++
generalize (H1 K L H29).
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_synthesis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H15 M N H13).
intro.
rewrite H14 in H16.
inversion H16.
rewrite H14 in H13.
rewrite <- H20 in H13.
elim (irreducible_enc g M' N0 K L0).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
elim (H22 (H24 (MEnc M' K) (MEnc N0 L0) H13)).
intros.
case H27.
right.
red in |- *.
intro.
apply H28.
cut (L = L0).
unfold le_h in H1.
unfold inclusion in H1.
generalize (H1 K L H29).

*****
H29 : synthesis g K L
H28 : not (synthesis (analysis_def g) K L0)
H27 : or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))
H26 : analysis_def g (MEnc M' K) (MEnc N0 L0)
H25 : forall (M N : Msg) (_ : irreducible g M N), g M N
H24 : forall (M N : Msg) (_ : g M N), irreducible g M N
H23 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))),\nirreducible g (MEnc M' K) (MEnc N0 L0)
H22 : forall _ : irreducible g (MEnc M' K) (MEnc N0 L0),\nand (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0)))
H20 : eq (MEnc N0 L0) N
H18 : eq K0 K
H17 : eq M0 M'
H21 : synthesis h K L0
H19 : synthesis h M' N0
M0,K0 : Msg
H16 : synthesis h (MEnc M' K) N
H15 : forall (M N : Msg) (_ : g M N), synthesis h M N
N',L : Msg
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N0 L0)
M,N,M',K,N0,L0 : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
forall _ : synthesis h K L, eq L L0
+++++
intro.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_synthesis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H15 M N H13).
intro.
rewrite H14 in H16.
inversion H16.
rewrite H14 in H13.
rewrite <- H20 in H13.
elim (irreducible_enc g M' N0 K L0).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
elim (H22 (H24 (MEnc M' K) (MEnc N0 L0) H13)).
intros.
case H27.
right.
red in |- *.
intro.
apply H28.
cut (L = L0).
unfold le_h in H1.
unfold inclusion in H1.
generalize (H1 K L H29).
intro.

*****
H30 : synthesis h K L
H29 : synthesis g K L
H28 : not (synthesis (analysis_def g) K L0)
H27 : or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))
H26 : analysis_def g (MEnc M' K) (MEnc N0 L0)
H25 : forall (M N : Msg) (_ : irreducible g M N), g M N
H24 : forall (M N : Msg) (_ : g M N), irreducible g M N
H23 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))),\nirreducible g (MEnc M' K) (MEnc N0 L0)
H22 : forall _ : irreducible g (MEnc M' K) (MEnc N0 L0),\nand (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0)))
H20 : eq (MEnc N0 L0) N
H18 : eq K0 K
H17 : eq M0 M'
H21 : synthesis h K L0
H19 : synthesis h M' N0
M0,K0 : Msg
H16 : synthesis h (MEnc M' K) N
H15 : forall (M N : Msg) (_ : g M N), synthesis h M N
N',L : Msg
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N0 L0)
M,N,M',K,N0,L0 : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
eq L L0
+++++
unfold injective_left in H12.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_synthesis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H15 M N H13).
intro.
rewrite H14 in H16.
inversion H16.
rewrite H14 in H13.
rewrite <- H20 in H13.
elim (irreducible_enc g M' N0 K L0).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
elim (H22 (H24 (MEnc M' K) (MEnc N0 L0) H13)).
intros.
case H27.
right.
red in |- *.
intro.
apply H28.
cut (L = L0).
unfold le_h in H1.
unfold inclusion in H1.
generalize (H1 K L H29).
intro.
unfold injective_left in H12.

*****
H30 : synthesis h K L
H29 : synthesis g K L
H28 : not (synthesis (analysis_def g) K L0)
H27 : or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))
H26 : analysis_def g (MEnc M' K) (MEnc N0 L0)
H25 : forall (M N : Msg) (_ : irreducible g M N), g M N
H24 : forall (M N : Msg) (_ : g M N), irreducible g M N
H23 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))),\nirreducible g (MEnc M' K) (MEnc N0 L0)
H22 : forall _ : irreducible g (MEnc M' K) (MEnc N0 L0),\nand (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0)))
H20 : eq (MEnc N0 L0) N
H18 : eq K0 K
H17 : eq M0 M'
H21 : synthesis h K L0
H19 : synthesis h M' N0
M0,K0 : Msg
H16 : synthesis h (MEnc M' K) N
H15 : forall (M N : Msg) (_ : g M N), synthesis h M N
N',L : Msg
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N0 L0)
M,N,M',K,N0,L0 : Msg
H12 : forall (M N : Msg) (_ : synthesis h M N) (M' N' : Msg)\n (_ : synthesis h M' N') (_ : eq M M'), eq N N'
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
eq L L0
+++++
apply (H12 K L H30 K L0 H21).
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_synthesis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H15 M N H13).
intro.
rewrite H14 in H16.
inversion H16.
rewrite H14 in H13.
rewrite <- H20 in H13.
elim (irreducible_enc g M' N0 K L0).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
elim (H22 (H24 (MEnc M' K) (MEnc N0 L0) H13)).
intros.
case H27.
right.
red in |- *.
intro.
apply H28.
cut (L = L0).
unfold le_h in H1.
unfold inclusion in H1.
generalize (H1 K L H29).
intro.
unfold injective_left in H12.
apply (H12 K L H30 K L0 H21).

*****
H30 : synthesis h K L
H29 : synthesis g K L
H28 : not (synthesis (analysis_def g) K L0)
H27 : or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))
H26 : analysis_def g (MEnc M' K) (MEnc N0 L0)
H25 : forall (M N : Msg) (_ : irreducible g M N), g M N
H24 : forall (M N : Msg) (_ : g M N), irreducible g M N
H23 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))),\nirreducible g (MEnc M' K) (MEnc N0 L0)
H22 : forall _ : irreducible g (MEnc M' K) (MEnc N0 L0),\nand (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0)))
H20 : eq (MEnc N0 L0) N
H18 : eq K0 K
H17 : eq M0 M'
H21 : synthesis h K L0
H19 : synthesis h M' N0
M0,K0 : Msg
H16 : synthesis h (MEnc M' K) N
H15 : forall (M N : Msg) (_ : g M N), synthesis h M N
N',L : Msg
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N0 L0)
M,N,M',K,N0,L0 : Msg
H12 : forall (M N : Msg) (_ : synthesis h M N) (M' N' : Msg)\n (_ : synthesis h M' N') (_ : eq M M'), eq N N'
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
eq K K
+++++
trivial.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.

*****
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
enc_analysis_left g
+++++
unfold enc_analysis_left in |- *.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.

*****
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
forall (M N : Msg) (_ : g M N) (M' K : Msg) (_ : eq M (MEnc M' K)) (L : Msg) (_ : synthesis g (inv K) (inv L)), ex (fun N' : Msg => and (eq N (MEnc N' L)) (synthesis g M' N'))
+++++
intros.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.

*****
H15 : synthesis g (inv K) (inv L)
L : Msg
H14 : eq M (MEnc M' K)
M',K : Msg
H13 : g M N
M,N : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
ex (fun N' : Msg => and (eq N (MEnc N' L)) (synthesis g M' N'))
+++++
generalize (le_h_impl_incl_syn g h H1).
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).

*****
H15 : synthesis g (inv K) (inv L)
L : Msg
H14 : eq M (MEnc M' K)
M',K : Msg
H13 : g M N
M,N : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
forall _ : inclusion g (synthesis h), ex (fun N' : Msg => and (eq N (MEnc N' L)) (synthesis g M' N'))
+++++
unfold inclusion in |- *.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.

*****
H15 : synthesis g (inv K) (inv L)
L : Msg
H14 : eq M (MEnc M' K)
M',K : Msg
H13 : g M N
M,N : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
forall _ : forall (M N : Msg) (_ : g M N), synthesis h M N, ex (fun N' : Msg => and (eq N (MEnc N' L)) (synthesis g M' N'))
+++++
intro.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.

*****
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
L : Msg
H14 : eq M (MEnc M' K)
M',K : Msg
H13 : g M N
M,N : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
ex (fun N' : Msg => and (eq N (MEnc N' L)) (synthesis g M' N'))
+++++
generalize (H16 M N H13).
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).

*****
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
L : Msg
H14 : eq M (MEnc M' K)
M',K : Msg
H13 : g M N
M,N : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
forall _ : synthesis h M N, ex (fun N' : Msg => and (eq N (MEnc N' L)) (synthesis g M' N'))
+++++
rewrite H14.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.

*****
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
L : Msg
H14 : eq M (MEnc M' K)
M',K : Msg
H13 : g M N
M,N : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
forall _ : synthesis h (MEnc M' K) N, ex (fun N' : Msg => and (eq N (MEnc N' L)) (synthesis g M' N'))
+++++
intro.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.

*****
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
L : Msg
H14 : eq M (MEnc M' K)
M',K : Msg
H13 : g M N
M,N : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
ex (fun N' : Msg => and (eq N (MEnc N' L)) (synthesis g M' N'))
+++++
inversion H17.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.

*****
H20 : eq N0 N
H19 : eq M0 (MEnc M' K)
H18 : h (MEnc M' K) N
M0,N0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
L : Msg
H14 : eq M (MEnc M' K)
M',K : Msg
H13 : g M N
M,N : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
ex (fun N' : Msg => and (eq N (MEnc N' L)) (synthesis g M' N'))
+++++
unfold le_h in H1.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
unfold le_h in H1.

*****
H20 : eq N0 N
H19 : eq M0 (MEnc M' K)
H18 : h (MEnc M' K) N
M0,N0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
L : Msg
H14 : eq M (MEnc M' K)
M',K : Msg
H13 : g M N
M,N : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : inclusion (synthesis g) (synthesis h)
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
ex (fun N' : Msg => and (eq N (MEnc N' L)) (synthesis g M' N'))
+++++
unfold inclusion in H1.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
unfold le_h in H1.
unfold inclusion in H1.

*****
H20 : eq N0 N
H19 : eq M0 (MEnc M' K)
H18 : h (MEnc M' K) N
M0,N0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
L : Msg
H14 : eq M (MEnc M' K)
M',K : Msg
H13 : g M N
M,N : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
ex (fun N' : Msg => and (eq N (MEnc N' L)) (synthesis g M' N'))
+++++
generalize (H1 (inv K) (inv L) H15).
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
unfold le_h in H1.
unfold inclusion in H1.
generalize (H1 (inv K) (inv L) H15).

*****
H20 : eq N0 N
H19 : eq M0 (MEnc M' K)
H18 : h (MEnc M' K) N
M0,N0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
L : Msg
H14 : eq M (MEnc M' K)
M',K : Msg
H13 : g M N
M,N : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
forall _ : synthesis h (inv K) (inv L), ex (fun N' : Msg => and (eq N (MEnc N' L)) (synthesis g M' N'))
+++++
intro.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
unfold le_h in H1.
unfold inclusion in H1.
generalize (H1 (inv K) (inv L) H15).
intro.

*****
H21 : synthesis h (inv K) (inv L)
H20 : eq N0 N
H19 : eq M0 (MEnc M' K)
H18 : h (MEnc M' K) N
M0,N0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
L : Msg
H14 : eq M (MEnc M' K)
M',K : Msg
H13 : g M N
M,N : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
ex (fun N' : Msg => and (eq N (MEnc N' L)) (synthesis g M' N'))
+++++
elim H11.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
unfold le_h in H1.
unfold inclusion in H1.
generalize (H1 (inv K) (inv L) H15).
intro.
elim H11.

*****
H21 : synthesis h (inv K) (inv L)
H20 : eq N0 N
H19 : eq M0 (MEnc M' K)
H18 : h (MEnc M' K) N
M0,N0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
L : Msg
H14 : eq M (MEnc M' K)
M',K : Msg
H13 : g M N
M,N : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
forall (_ : enc_analysis_left h) (_ : injective_inv_left h), ex (fun N' : Msg => and (eq N (MEnc N' L)) (synthesis g M' N'))
+++++
intros.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
unfold le_h in H1.
unfold inclusion in H1.
generalize (H1 (inv K) (inv L) H15).
intro.
elim H11.
intros.

*****
H23 : injective_inv_left h
H22 : enc_analysis_left h
H21 : synthesis h (inv K) (inv L)
H20 : eq N0 N
H19 : eq M0 (MEnc M' K)
H18 : h (MEnc M' K) N
M0,N0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
L : Msg
H14 : eq M (MEnc M' K)
M',K : Msg
H13 : g M N
M,N : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
ex (fun N' : Msg => and (eq N (MEnc N' L)) (synthesis g M' N'))
+++++
unfold enc_analysis_left in H22.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
unfold le_h in H1.
unfold inclusion in H1.
generalize (H1 (inv K) (inv L) H15).
intro.
elim H11.
intros.
unfold enc_analysis_left in H22.

*****
H23 : injective_inv_left h
H22 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (L : Msg) (_ : synthesis h (inv K) (inv L)),\nex (fun N' : Msg => and (eq N (MEnc N' L)) (synthesis h M' N'))
H21 : synthesis h (inv K) (inv L)
H20 : eq N0 N
H19 : eq M0 (MEnc M' K)
H18 : h (MEnc M' K) N
M0,N0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
L : Msg
H14 : eq M (MEnc M' K)
M',K : Msg
H13 : g M N
M,N : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
ex (fun N' : Msg => and (eq N (MEnc N' L)) (synthesis g M' N'))
+++++
rewrite <- H14 in H18.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
unfold le_h in H1.
unfold inclusion in H1.
generalize (H1 (inv K) (inv L) H15).
intro.
elim H11.
intros.
unfold enc_analysis_left in H22.
rewrite <- H14 in H18.

*****
H23 : injective_inv_left h
H22 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (L : Msg) (_ : synthesis h (inv K) (inv L)),\nex (fun N' : Msg => and (eq N (MEnc N' L)) (synthesis h M' N'))
H21 : synthesis h (inv K) (inv L)
H20 : eq N0 N
H19 : eq M0 (MEnc M' K)
H18 : h M N
M0,N0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
L : Msg
H14 : eq M (MEnc M' K)
M',K : Msg
H13 : g M N
M,N : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
ex (fun N' : Msg => and (eq N (MEnc N' L)) (synthesis g M' N'))
+++++
elim (H22 M N H18 M' K H14 L H21).
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
unfold le_h in H1.
unfold inclusion in H1.
generalize (H1 (inv K) (inv L) H15).
intro.
elim H11.
intros.
unfold enc_analysis_left in H22.
rewrite <- H14 in H18.
elim (H22 M N H18 M' K H14 L H21).

*****
H23 : injective_inv_left h
H22 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (L : Msg) (_ : synthesis h (inv K) (inv L)),\nex (fun N' : Msg => and (eq N (MEnc N' L)) (synthesis h M' N'))
H21 : synthesis h (inv K) (inv L)
H20 : eq N0 N
H19 : eq M0 (MEnc M' K)
H18 : h M N
M0,N0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
L : Msg
H14 : eq M (MEnc M' K)
M',K : Msg
H13 : g M N
M,N : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
forall (x : Msg) (_ : and (eq N (MEnc x L)) (synthesis h M' x)), ex (fun N' : Msg => and (eq N (MEnc N' L)) (synthesis g M' N'))
+++++
intro N'.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
unfold le_h in H1.
unfold inclusion in H1.
generalize (H1 (inv K) (inv L) H15).
intro.
elim H11.
intros.
unfold enc_analysis_left in H22.
rewrite <- H14 in H18.
elim (H22 M N H18 M' K H14 L H21).
intro N'.

*****
N' : Msg
H23 : injective_inv_left h
H22 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (L : Msg) (_ : synthesis h (inv K) (inv L)),\nex (fun N' : Msg => and (eq N (MEnc N' L)) (synthesis h M' N'))
H21 : synthesis h (inv K) (inv L)
H20 : eq N0 N
H19 : eq M0 (MEnc M' K)
H18 : h M N
M0,N0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
L : Msg
H14 : eq M (MEnc M' K)
M',K : Msg
H13 : g M N
M,N : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
forall _ : and (eq N (MEnc N' L)) (synthesis h M' N'), ex (fun N' : Msg => and (eq N (MEnc N' L)) (synthesis g M' N'))
+++++
intro.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
unfold le_h in H1.
unfold inclusion in H1.
generalize (H1 (inv K) (inv L) H15).
intro.
elim H11.
intros.
unfold enc_analysis_left in H22.
rewrite <- H14 in H18.
elim (H22 M N H18 M' K H14 L H21).
intro N'.
intro.

*****
H24 : and (eq N (MEnc N' L)) (synthesis h M' N')
N' : Msg
H23 : injective_inv_left h
H22 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (L : Msg) (_ : synthesis h (inv K) (inv L)),\nex (fun N' : Msg => and (eq N (MEnc N' L)) (synthesis h M' N'))
H21 : synthesis h (inv K) (inv L)
H20 : eq N0 N
H19 : eq M0 (MEnc M' K)
H18 : h M N
M0,N0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
L : Msg
H14 : eq M (MEnc M' K)
M',K : Msg
H13 : g M N
M,N : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
ex (fun N' : Msg => and (eq N (MEnc N' L)) (synthesis g M' N'))
+++++
exists N'.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
unfold le_h in H1.
unfold inclusion in H1.
generalize (H1 (inv K) (inv L) H15).
intro.
elim H11.
intros.
unfold enc_analysis_left in H22.
rewrite <- H14 in H18.
elim (H22 M N H18 M' K H14 L H21).
intro N'.
intro.
exists N'.

*****
H24 : and (eq N (MEnc N' L)) (synthesis h M' N')
N' : Msg
H23 : injective_inv_left h
H22 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (L : Msg) (_ : synthesis h (inv K) (inv L)),\nex (fun N' : Msg => and (eq N (MEnc N' L)) (synthesis h M' N'))
H21 : synthesis h (inv K) (inv L)
H20 : eq N0 N
H19 : eq M0 (MEnc M' K)
H18 : h M N
M0,N0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
L : Msg
H14 : eq M (MEnc M' K)
M',K : Msg
H13 : g M N
M,N : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
and (eq N (MEnc N' L)) (synthesis g M' N')
+++++
elim H24.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
unfold le_h in H1.
unfold inclusion in H1.
generalize (H1 (inv K) (inv L) H15).
intro.
elim H11.
intros.
unfold enc_analysis_left in H22.
rewrite <- H14 in H18.
elim (H22 M N H18 M' K H14 L H21).
intro N'.
intro.
exists N'.
elim H24.

*****
H24 : and (eq N (MEnc N' L)) (synthesis h M' N')
N' : Msg
H23 : injective_inv_left h
H22 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (L : Msg) (_ : synthesis h (inv K) (inv L)),\nex (fun N' : Msg => and (eq N (MEnc N' L)) (synthesis h M' N'))
H21 : synthesis h (inv K) (inv L)
H20 : eq N0 N
H19 : eq M0 (MEnc M' K)
H18 : h M N
M0,N0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
L : Msg
H14 : eq M (MEnc M' K)
M',K : Msg
H13 : g M N
M,N : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
forall (_ : eq N (MEnc N' L)) (_ : synthesis h M' N'), and (eq N (MEnc N' L)) (synthesis g M' N')
+++++
intros.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
unfold le_h in H1.
unfold inclusion in H1.
generalize (H1 (inv K) (inv L) H15).
intro.
elim H11.
intros.
unfold enc_analysis_left in H22.
rewrite <- H14 in H18.
elim (H22 M N H18 M' K H14 L H21).
intro N'.
intro.
exists N'.
elim H24.
intros.

*****
H26 : synthesis h M' N'
H25 : eq N (MEnc N' L)
H24 : and (eq N (MEnc N' L)) (synthesis h M' N')
N' : Msg
H23 : injective_inv_left h
H22 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (L : Msg) (_ : synthesis h (inv K) (inv L)),\nex (fun N' : Msg => and (eq N (MEnc N' L)) (synthesis h M' N'))
H21 : synthesis h (inv K) (inv L)
H20 : eq N0 N
H19 : eq M0 (MEnc M' K)
H18 : h M N
M0,N0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
L : Msg
H14 : eq M (MEnc M' K)
M',K : Msg
H13 : g M N
M,N : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
and (eq N (MEnc N' L)) (synthesis g M' N')
+++++
split.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
unfold le_h in H1.
unfold inclusion in H1.
generalize (H1 (inv K) (inv L) H15).
intro.
elim H11.
intros.
unfold enc_analysis_left in H22.
rewrite <- H14 in H18.
elim (H22 M N H18 M' K H14 L H21).
intro N'.
intro.
exists N'.
elim H24.
intros.
split.

*****
H26 : synthesis h M' N'
H25 : eq N (MEnc N' L)
H24 : and (eq N (MEnc N' L)) (synthesis h M' N')
N' : Msg
H23 : injective_inv_left h
H22 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (L : Msg) (_ : synthesis h (inv K) (inv L)),\nex (fun N' : Msg => and (eq N (MEnc N' L)) (synthesis h M' N'))
H21 : synthesis h (inv K) (inv L)
H20 : eq N0 N
H19 : eq M0 (MEnc M' K)
H18 : h M N
M0,N0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
L : Msg
H14 : eq M (MEnc M' K)
M',K : Msg
H13 : g M N
M,N : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
eq N (MEnc N' L)
+++++
trivial.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
unfold le_h in H1.
unfold inclusion in H1.
generalize (H1 (inv K) (inv L) H15).
intro.
elim H11.
intros.
unfold enc_analysis_left in H22.
rewrite <- H14 in H18.
elim (H22 M N H18 M' K H14 L H21).
intro N'.
intro.
exists N'.
elim H24.
intros.
split.

*****
H26 : synthesis h M' N'
H25 : eq N (MEnc N' L)
H24 : and (eq N (MEnc N' L)) (synthesis h M' N')
N' : Msg
H23 : injective_inv_left h
H22 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (L : Msg) (_ : synthesis h (inv K) (inv L)),\nex (fun N' : Msg => and (eq N (MEnc N' L)) (synthesis h M' N'))
H21 : synthesis h (inv K) (inv L)
H20 : eq N0 N
H19 : eq M0 (MEnc M' K)
H18 : h M N
M0,N0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
L : Msg
H14 : eq M (MEnc M' K)
M',K : Msg
H13 : g M N
M,N : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
synthesis g M' N'
+++++
trivial.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
unfold le_h in H1.
unfold inclusion in H1.
generalize (H1 (inv K) (inv L) H15).
intro.
elim H11.
intros.
unfold enc_analysis_left in H22.
rewrite <- H14 in H18.
elim (H22 M N H18 M' K H14 L H21).
intro N'.
intro.
exists N'.
elim H24.
intros.
split.
trivial.

*****
H26 : synthesis h M' N'
H25 : eq N (MEnc N' L)
H24 : and (eq N (MEnc N' L)) (synthesis h M' N')
N' : Msg
H23 : injective_inv_left h
H22 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (L : Msg) (_ : synthesis h (inv K) (inv L)),\nex (fun N' : Msg => and (eq N (MEnc N' L)) (synthesis h M' N'))
H21 : synthesis h (inv K) (inv L)
H20 : eq N0 N
H19 : eq M0 (MEnc M' K)
H18 : h M N
M0,N0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
L : Msg
H14 : eq M (MEnc M' K)
M',K : Msg
H13 : g M N
M,N : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
synthesis g M' N'
+++++
rewrite H14 in H13.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
unfold le_h in H1.
unfold inclusion in H1.
generalize (H1 (inv K) (inv L) H15).
intro.
elim H11.
intros.
unfold enc_analysis_left in H22.
rewrite <- H14 in H18.
elim (H22 M N H18 M' K H14 L H21).
intro N'.
intro.
exists N'.
elim H24.
intros.
split.
trivial.
rewrite H14 in H13.

*****
H26 : synthesis h M' N'
H25 : eq N (MEnc N' L)
H24 : and (eq N (MEnc N' L)) (synthesis h M' N')
N' : Msg
H23 : injective_inv_left h
H22 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (L : Msg) (_ : synthesis h (inv K) (inv L)),\nex (fun N' : Msg => and (eq N (MEnc N' L)) (synthesis h M' N'))
H21 : synthesis h (inv K) (inv L)
H20 : eq N0 N
H19 : eq M0 (MEnc M' K)
H18 : h M N
M0,N0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
L : Msg
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) N
M,N,M',K : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
synthesis g M' N'
+++++
rewrite H25 in H13.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
unfold le_h in H1.
unfold inclusion in H1.
generalize (H1 (inv K) (inv L) H15).
intro.
elim H11.
intros.
unfold enc_analysis_left in H22.
rewrite <- H14 in H18.
elim (H22 M N H18 M' K H14 L H21).
intro N'.
intro.
exists N'.
elim H24.
intros.
split.
trivial.
rewrite H14 in H13.
rewrite H25 in H13.

*****
H26 : synthesis h M' N'
H25 : eq N (MEnc N' L)
H24 : and (eq N (MEnc N' L)) (synthesis h M' N')
H23 : injective_inv_left h
H22 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (L : Msg) (_ : synthesis h (inv K) (inv L)),\nex (fun N' : Msg => and (eq N (MEnc N' L)) (synthesis h M' N'))
H21 : synthesis h (inv K) (inv L)
H20 : eq N0 N
H19 : eq M0 (MEnc M' K)
H18 : h M N
M0,N0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N' L)
M,N,M',K,L,N' : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
synthesis g M' N'
+++++
elim (irreducible_enc g M' N' K L).
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
unfold le_h in H1.
unfold inclusion in H1.
generalize (H1 (inv K) (inv L) H15).
intro.
elim H11.
intros.
unfold enc_analysis_left in H22.
rewrite <- H14 in H18.
elim (H22 M N H18 M' K H14 L H21).
intro N'.
intro.
exists N'.
elim H24.
intros.
split.
trivial.
rewrite H14 in H13.
rewrite H25 in H13.
elim (irreducible_enc g M' N' K L).

*****
H26 : synthesis h M' N'
H25 : eq N (MEnc N' L)
H24 : and (eq N (MEnc N' L)) (synthesis h M' N')
H23 : injective_inv_left h
H22 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (L : Msg) (_ : synthesis h (inv K) (inv L)),\nex (fun N' : Msg => and (eq N (MEnc N' L)) (synthesis h M' N'))
H21 : synthesis h (inv K) (inv L)
H20 : eq N0 N
H19 : eq M0 (MEnc M' K)
H18 : h M N
M0,N0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N' L)
M,N,M',K,L,N' : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
forall (_ : forall _ : irreducible g (MEnc M' K) (MEnc N' L), and (analysis_def g (MEnc M' K) (MEnc N' L)) (or (not (synthesis (analysis_def g) M' N')) (not (synthesis (analysis_def g) K L)))) (_ : forall _ : and (analysis_def g (MEnc M' K) (MEnc N' L)) (or (not (synthesis (analysis_def g) M' N')) (not (synthesis (analysis_def g) K L))), irreducible g (MEnc M' K) (MEnc N' L)), synthesis g M' N'
+++++
intros.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
unfold le_h in H1.
unfold inclusion in H1.
generalize (H1 (inv K) (inv L) H15).
intro.
elim H11.
intros.
unfold enc_analysis_left in H22.
rewrite <- H14 in H18.
elim (H22 M N H18 M' K H14 L H21).
intro N'.
intro.
exists N'.
elim H24.
intros.
split.
trivial.
rewrite H14 in H13.
rewrite H25 in H13.
elim (irreducible_enc g M' N' K L).
intros.

*****
H28 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N' L))\n (or (not (synthesis (analysis_def g) M' N'))\n (not (synthesis (analysis_def g) K L))),\nirreducible g (MEnc M' K) (MEnc N' L)
H27 : forall _ : irreducible g (MEnc M' K) (MEnc N' L),\nand (analysis_def g (MEnc M' K) (MEnc N' L))\n (or (not (synthesis (analysis_def g) M' N'))\n (not (synthesis (analysis_def g) K L)))
H26 : synthesis h M' N'
H25 : eq N (MEnc N' L)
H24 : and (eq N (MEnc N' L)) (synthesis h M' N')
H23 : injective_inv_left h
H22 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (L : Msg) (_ : synthesis h (inv K) (inv L)),\nex (fun N' : Msg => and (eq N (MEnc N' L)) (synthesis h M' N'))
H21 : synthesis h (inv K) (inv L)
H20 : eq N0 N
H19 : eq M0 (MEnc M' K)
H18 : h M N
M0,N0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N' L)
M,N,M',K,L,N' : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
synthesis g M' N'
+++++
unfold is_irreducible in H.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
unfold le_h in H1.
unfold inclusion in H1.
generalize (H1 (inv K) (inv L) H15).
intro.
elim H11.
intros.
unfold enc_analysis_left in H22.
rewrite <- H14 in H18.
elim (H22 M N H18 M' K H14 L H21).
intro N'.
intro.
exists N'.
elim H24.
intros.
split.
trivial.
rewrite H14 in H13.
rewrite H25 in H13.
elim (irreducible_enc g M' N' K L).
intros.
unfold is_irreducible in H.

*****
H28 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N' L))\n (or (not (synthesis (analysis_def g) M' N'))\n (not (synthesis (analysis_def g) K L))),\nirreducible g (MEnc M' K) (MEnc N' L)
H27 : forall _ : irreducible g (MEnc M' K) (MEnc N' L),\nand (analysis_def g (MEnc M' K) (MEnc N' L))\n (or (not (synthesis (analysis_def g) M' N'))\n (not (synthesis (analysis_def g) K L)))
H26 : synthesis h M' N'
H25 : eq N (MEnc N' L)
H24 : and (eq N (MEnc N' L)) (synthesis h M' N')
H23 : injective_inv_left h
H22 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (L : Msg) (_ : synthesis h (inv K) (inv L)),\nex (fun N' : Msg => and (eq N (MEnc N' L)) (synthesis h M' N'))
H21 : synthesis h (inv K) (inv L)
H20 : eq N0 N
H19 : eq M0 (MEnc M' K)
H18 : h M N
M0,N0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N' L)
M,N,M',K,L,N' : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : equal g (irreducible g)
g,h : hedge
*****
synthesis g M' N'
+++++
unfold equal in H.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
unfold le_h in H1.
unfold inclusion in H1.
generalize (H1 (inv K) (inv L) H15).
intro.
elim H11.
intros.
unfold enc_analysis_left in H22.
rewrite <- H14 in H18.
elim (H22 M N H18 M' K H14 L H21).
intro N'.
intro.
exists N'.
elim H24.
intros.
split.
trivial.
rewrite H14 in H13.
rewrite H25 in H13.
elim (irreducible_enc g M' N' K L).
intros.
unfold is_irreducible in H.
unfold equal in H.

*****
H28 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N' L))\n (or (not (synthesis (analysis_def g) M' N'))\n (not (synthesis (analysis_def g) K L))),\nirreducible g (MEnc M' K) (MEnc N' L)
H27 : forall _ : irreducible g (MEnc M' K) (MEnc N' L),\nand (analysis_def g (MEnc M' K) (MEnc N' L))\n (or (not (synthesis (analysis_def g) M' N'))\n (not (synthesis (analysis_def g) K L)))
H26 : synthesis h M' N'
H25 : eq N (MEnc N' L)
H24 : and (eq N (MEnc N' L)) (synthesis h M' N')
H23 : injective_inv_left h
H22 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (L : Msg) (_ : synthesis h (inv K) (inv L)),\nex (fun N' : Msg => and (eq N (MEnc N' L)) (synthesis h M' N'))
H21 : synthesis h (inv K) (inv L)
H20 : eq N0 N
H19 : eq M0 (MEnc M' K)
H18 : h M N
M0,N0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N' L)
M,N,M',K,L,N' : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
synthesis g M' N'
+++++
elim H.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
unfold le_h in H1.
unfold inclusion in H1.
generalize (H1 (inv K) (inv L) H15).
intro.
elim H11.
intros.
unfold enc_analysis_left in H22.
rewrite <- H14 in H18.
elim (H22 M N H18 M' K H14 L H21).
intro N'.
intro.
exists N'.
elim H24.
intros.
split.
trivial.
rewrite H14 in H13.
rewrite H25 in H13.
elim (irreducible_enc g M' N' K L).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.

*****
H28 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N' L))\n (or (not (synthesis (analysis_def g) M' N'))\n (not (synthesis (analysis_def g) K L))),\nirreducible g (MEnc M' K) (MEnc N' L)
H27 : forall _ : irreducible g (MEnc M' K) (MEnc N' L),\nand (analysis_def g (MEnc M' K) (MEnc N' L))\n (or (not (synthesis (analysis_def g) M' N'))\n (not (synthesis (analysis_def g) K L)))
H26 : synthesis h M' N'
H25 : eq N (MEnc N' L)
H24 : and (eq N (MEnc N' L)) (synthesis h M' N')
H23 : injective_inv_left h
H22 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (L : Msg) (_ : synthesis h (inv K) (inv L)),\nex (fun N' : Msg => and (eq N (MEnc N' L)) (synthesis h M' N'))
H21 : synthesis h (inv K) (inv L)
H20 : eq N0 N
H19 : eq M0 (MEnc M' K)
H18 : h M N
M0,N0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N' L)
M,N,M',K,L,N' : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
forall (_ : inclusion g (irreducible g)) (_ : inclusion (irreducible g) g), synthesis g M' N'
+++++
unfold inclusion in |- *.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
unfold le_h in H1.
unfold inclusion in H1.
generalize (H1 (inv K) (inv L) H15).
intro.
elim H11.
intros.
unfold enc_analysis_left in H22.
rewrite <- H14 in H18.
elim (H22 M N H18 M' K H14 L H21).
intro N'.
intro.
exists N'.
elim H24.
intros.
split.
trivial.
rewrite H14 in H13.
rewrite H25 in H13.
elim (irreducible_enc g M' N' K L).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.

*****
H28 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N' L))\n (or (not (synthesis (analysis_def g) M' N'))\n (not (synthesis (analysis_def g) K L))),\nirreducible g (MEnc M' K) (MEnc N' L)
H27 : forall _ : irreducible g (MEnc M' K) (MEnc N' L),\nand (analysis_def g (MEnc M' K) (MEnc N' L))\n (or (not (synthesis (analysis_def g) M' N'))\n (not (synthesis (analysis_def g) K L)))
H26 : synthesis h M' N'
H25 : eq N (MEnc N' L)
H24 : and (eq N (MEnc N' L)) (synthesis h M' N')
H23 : injective_inv_left h
H22 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (L : Msg) (_ : synthesis h (inv K) (inv L)),\nex (fun N' : Msg => and (eq N (MEnc N' L)) (synthesis h M' N'))
H21 : synthesis h (inv K) (inv L)
H20 : eq N0 N
H19 : eq M0 (MEnc M' K)
H18 : h M N
M0,N0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N' L)
M,N,M',K,L,N' : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
forall (_ : forall (M N : Msg) (_ : g M N), irreducible g M N) (_ : forall (M N : Msg) (_ : irreducible g M N), g M N), synthesis g M' N'
+++++
intros.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
unfold le_h in H1.
unfold inclusion in H1.
generalize (H1 (inv K) (inv L) H15).
intro.
elim H11.
intros.
unfold enc_analysis_left in H22.
rewrite <- H14 in H18.
elim (H22 M N H18 M' K H14 L H21).
intro N'.
intro.
exists N'.
elim H24.
intros.
split.
trivial.
rewrite H14 in H13.
rewrite H25 in H13.
elim (irreducible_enc g M' N' K L).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.

*****
H30 : forall (M N : Msg) (_ : irreducible g M N), g M N
H29 : forall (M N : Msg) (_ : g M N), irreducible g M N
H28 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N' L))\n (or (not (synthesis (analysis_def g) M' N'))\n (not (synthesis (analysis_def g) K L))),\nirreducible g (MEnc M' K) (MEnc N' L)
H27 : forall _ : irreducible g (MEnc M' K) (MEnc N' L),\nand (analysis_def g (MEnc M' K) (MEnc N' L))\n (or (not (synthesis (analysis_def g) M' N'))\n (not (synthesis (analysis_def g) K L)))
H26 : synthesis h M' N'
H25 : eq N (MEnc N' L)
H24 : and (eq N (MEnc N' L)) (synthesis h M' N')
H23 : injective_inv_left h
H22 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (L : Msg) (_ : synthesis h (inv K) (inv L)),\nex (fun N' : Msg => and (eq N (MEnc N' L)) (synthesis h M' N'))
H21 : synthesis h (inv K) (inv L)
H20 : eq N0 N
H19 : eq M0 (MEnc M' K)
H18 : h M N
M0,N0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N' L)
M,N,M',K,L,N' : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
synthesis g M' N'
+++++
elim (H27 (H29 (MEnc M' K) (MEnc N' L) H13)).
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
unfold le_h in H1.
unfold inclusion in H1.
generalize (H1 (inv K) (inv L) H15).
intro.
elim H11.
intros.
unfold enc_analysis_left in H22.
rewrite <- H14 in H18.
elim (H22 M N H18 M' K H14 L H21).
intro N'.
intro.
exists N'.
elim H24.
intros.
split.
trivial.
rewrite H14 in H13.
rewrite H25 in H13.
elim (irreducible_enc g M' N' K L).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
elim (H27 (H29 (MEnc M' K) (MEnc N' L) H13)).

*****
H30 : forall (M N : Msg) (_ : irreducible g M N), g M N
H29 : forall (M N : Msg) (_ : g M N), irreducible g M N
H28 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N' L))\n (or (not (synthesis (analysis_def g) M' N'))\n (not (synthesis (analysis_def g) K L))),\nirreducible g (MEnc M' K) (MEnc N' L)
H27 : forall _ : irreducible g (MEnc M' K) (MEnc N' L),\nand (analysis_def g (MEnc M' K) (MEnc N' L))\n (or (not (synthesis (analysis_def g) M' N'))\n (not (synthesis (analysis_def g) K L)))
H26 : synthesis h M' N'
H25 : eq N (MEnc N' L)
H24 : and (eq N (MEnc N' L)) (synthesis h M' N')
H23 : injective_inv_left h
H22 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (L : Msg) (_ : synthesis h (inv K) (inv L)),\nex (fun N' : Msg => and (eq N (MEnc N' L)) (synthesis h M' N'))
H21 : synthesis h (inv K) (inv L)
H20 : eq N0 N
H19 : eq M0 (MEnc M' K)
H18 : h M N
M0,N0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N' L)
M,N,M',K,L,N' : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
forall (_ : analysis_def g (MEnc M' K) (MEnc N' L)) (_ : or (not (synthesis (analysis_def g) M' N')) (not (synthesis (analysis_def g) K L))), synthesis g M' N'
+++++
intros.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
unfold le_h in H1.
unfold inclusion in H1.
generalize (H1 (inv K) (inv L) H15).
intro.
elim H11.
intros.
unfold enc_analysis_left in H22.
rewrite <- H14 in H18.
elim (H22 M N H18 M' K H14 L H21).
intro N'.
intro.
exists N'.
elim H24.
intros.
split.
trivial.
rewrite H14 in H13.
rewrite H25 in H13.
elim (irreducible_enc g M' N' K L).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
elim (H27 (H29 (MEnc M' K) (MEnc N' L) H13)).
intros.

*****
H32 : or (not (synthesis (analysis_def g) M' N'))\n (not (synthesis (analysis_def g) K L))
H31 : analysis_def g (MEnc M' K) (MEnc N' L)
H30 : forall (M N : Msg) (_ : irreducible g M N), g M N
H29 : forall (M N : Msg) (_ : g M N), irreducible g M N
H28 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N' L))\n (or (not (synthesis (analysis_def g) M' N'))\n (not (synthesis (analysis_def g) K L))),\nirreducible g (MEnc M' K) (MEnc N' L)
H27 : forall _ : irreducible g (MEnc M' K) (MEnc N' L),\nand (analysis_def g (MEnc M' K) (MEnc N' L))\n (or (not (synthesis (analysis_def g) M' N'))\n (not (synthesis (analysis_def g) K L)))
H26 : synthesis h M' N'
H25 : eq N (MEnc N' L)
H24 : and (eq N (MEnc N' L)) (synthesis h M' N')
H23 : injective_inv_left h
H22 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (L : Msg) (_ : synthesis h (inv K) (inv L)),\nex (fun N' : Msg => and (eq N (MEnc N' L)) (synthesis h M' N'))
H21 : synthesis h (inv K) (inv L)
H20 : eq N0 N
H19 : eq M0 (MEnc M' K)
H18 : h M N
M0,N0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N' L)
M,N,M',K,L,N' : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
synthesis g M' N'
+++++
generalize (ana_h_equiv_irr_h g).
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
unfold le_h in H1.
unfold inclusion in H1.
generalize (H1 (inv K) (inv L) H15).
intro.
elim H11.
intros.
unfold enc_analysis_left in H22.
rewrite <- H14 in H18.
elim (H22 M N H18 M' K H14 L H21).
intro N'.
intro.
exists N'.
elim H24.
intros.
split.
trivial.
rewrite H14 in H13.
rewrite H25 in H13.
elim (irreducible_enc g M' N' K L).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
elim (H27 (H29 (MEnc M' K) (MEnc N' L) H13)).
intros.
generalize (ana_h_equiv_irr_h g).

*****
H32 : or (not (synthesis (analysis_def g) M' N'))\n (not (synthesis (analysis_def g) K L))
H31 : analysis_def g (MEnc M' K) (MEnc N' L)
H30 : forall (M N : Msg) (_ : irreducible g M N), g M N
H29 : forall (M N : Msg) (_ : g M N), irreducible g M N
H28 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N' L))\n (or (not (synthesis (analysis_def g) M' N'))\n (not (synthesis (analysis_def g) K L))),\nirreducible g (MEnc M' K) (MEnc N' L)
H27 : forall _ : irreducible g (MEnc M' K) (MEnc N' L),\nand (analysis_def g (MEnc M' K) (MEnc N' L))\n (or (not (synthesis (analysis_def g) M' N'))\n (not (synthesis (analysis_def g) K L)))
H26 : synthesis h M' N'
H25 : eq N (MEnc N' L)
H24 : and (eq N (MEnc N' L)) (synthesis h M' N')
H23 : injective_inv_left h
H22 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (L : Msg) (_ : synthesis h (inv K) (inv L)),\nex (fun N' : Msg => and (eq N (MEnc N' L)) (synthesis h M' N'))
H21 : synthesis h (inv K) (inv L)
H20 : eq N0 N
H19 : eq M0 (MEnc M' K)
H18 : h M N
M0,N0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N' L)
M,N,M',K,L,N' : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
forall _ : equiv_h (analysis_def g) (irreducible g), synthesis g M' N'
+++++
unfold equiv_h in |- *.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
unfold le_h in H1.
unfold inclusion in H1.
generalize (H1 (inv K) (inv L) H15).
intro.
elim H11.
intros.
unfold enc_analysis_left in H22.
rewrite <- H14 in H18.
elim (H22 M N H18 M' K H14 L H21).
intro N'.
intro.
exists N'.
elim H24.
intros.
split.
trivial.
rewrite H14 in H13.
rewrite H25 in H13.
elim (irreducible_enc g M' N' K L).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
elim (H27 (H29 (MEnc M' K) (MEnc N' L) H13)).
intros.
generalize (ana_h_equiv_irr_h g).
unfold equiv_h in |- *.

*****
H32 : or (not (synthesis (analysis_def g) M' N'))\n (not (synthesis (analysis_def g) K L))
H31 : analysis_def g (MEnc M' K) (MEnc N' L)
H30 : forall (M N : Msg) (_ : irreducible g M N), g M N
H29 : forall (M N : Msg) (_ : g M N), irreducible g M N
H28 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N' L))\n (or (not (synthesis (analysis_def g) M' N'))\n (not (synthesis (analysis_def g) K L))),\nirreducible g (MEnc M' K) (MEnc N' L)
H27 : forall _ : irreducible g (MEnc M' K) (MEnc N' L),\nand (analysis_def g (MEnc M' K) (MEnc N' L))\n (or (not (synthesis (analysis_def g) M' N'))\n (not (synthesis (analysis_def g) K L)))
H26 : synthesis h M' N'
H25 : eq N (MEnc N' L)
H24 : and (eq N (MEnc N' L)) (synthesis h M' N')
H23 : injective_inv_left h
H22 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (L : Msg) (_ : synthesis h (inv K) (inv L)),\nex (fun N' : Msg => and (eq N (MEnc N' L)) (synthesis h M' N'))
H21 : synthesis h (inv K) (inv L)
H20 : eq N0 N
H19 : eq M0 (MEnc M' K)
H18 : h M N
M0,N0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N' L)
M,N,M',K,L,N' : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
forall _ : and (le_h (analysis_def g) (irreducible g)) (le_h (irreducible g) (analysis_def g)), synthesis g M' N'
+++++
intro.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
unfold le_h in H1.
unfold inclusion in H1.
generalize (H1 (inv K) (inv L) H15).
intro.
elim H11.
intros.
unfold enc_analysis_left in H22.
rewrite <- H14 in H18.
elim (H22 M N H18 M' K H14 L H21).
intro N'.
intro.
exists N'.
elim H24.
intros.
split.
trivial.
rewrite H14 in H13.
rewrite H25 in H13.
elim (irreducible_enc g M' N' K L).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
elim (H27 (H29 (MEnc M' K) (MEnc N' L) H13)).
intros.
generalize (ana_h_equiv_irr_h g).
unfold equiv_h in |- *.
intro.

*****
H33 : and (le_h (analysis_def g) (irreducible g))\n (le_h (irreducible g) (analysis_def g))
H32 : or (not (synthesis (analysis_def g) M' N'))\n (not (synthesis (analysis_def g) K L))
H31 : analysis_def g (MEnc M' K) (MEnc N' L)
H30 : forall (M N : Msg) (_ : irreducible g M N), g M N
H29 : forall (M N : Msg) (_ : g M N), irreducible g M N
H28 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N' L))\n (or (not (synthesis (analysis_def g) M' N'))\n (not (synthesis (analysis_def g) K L))),\nirreducible g (MEnc M' K) (MEnc N' L)
H27 : forall _ : irreducible g (MEnc M' K) (MEnc N' L),\nand (analysis_def g (MEnc M' K) (MEnc N' L))\n (or (not (synthesis (analysis_def g) M' N'))\n (not (synthesis (analysis_def g) K L)))
H26 : synthesis h M' N'
H25 : eq N (MEnc N' L)
H24 : and (eq N (MEnc N' L)) (synthesis h M' N')
H23 : injective_inv_left h
H22 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (L : Msg) (_ : synthesis h (inv K) (inv L)),\nex (fun N' : Msg => and (eq N (MEnc N' L)) (synthesis h M' N'))
H21 : synthesis h (inv K) (inv L)
H20 : eq N0 N
H19 : eq M0 (MEnc M' K)
H18 : h M N
M0,N0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N' L)
M,N,M',K,L,N' : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
synthesis g M' N'
+++++
elim H33.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
unfold le_h in H1.
unfold inclusion in H1.
generalize (H1 (inv K) (inv L) H15).
intro.
elim H11.
intros.
unfold enc_analysis_left in H22.
rewrite <- H14 in H18.
elim (H22 M N H18 M' K H14 L H21).
intro N'.
intro.
exists N'.
elim H24.
intros.
split.
trivial.
rewrite H14 in H13.
rewrite H25 in H13.
elim (irreducible_enc g M' N' K L).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
elim (H27 (H29 (MEnc M' K) (MEnc N' L) H13)).
intros.
generalize (ana_h_equiv_irr_h g).
unfold equiv_h in |- *.
intro.
elim H33.

*****
H33 : and (le_h (analysis_def g) (irreducible g))\n (le_h (irreducible g) (analysis_def g))
H32 : or (not (synthesis (analysis_def g) M' N'))\n (not (synthesis (analysis_def g) K L))
H31 : analysis_def g (MEnc M' K) (MEnc N' L)
H30 : forall (M N : Msg) (_ : irreducible g M N), g M N
H29 : forall (M N : Msg) (_ : g M N), irreducible g M N
H28 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N' L))\n (or (not (synthesis (analysis_def g) M' N'))\n (not (synthesis (analysis_def g) K L))),\nirreducible g (MEnc M' K) (MEnc N' L)
H27 : forall _ : irreducible g (MEnc M' K) (MEnc N' L),\nand (analysis_def g (MEnc M' K) (MEnc N' L))\n (or (not (synthesis (analysis_def g) M' N'))\n (not (synthesis (analysis_def g) K L)))
H26 : synthesis h M' N'
H25 : eq N (MEnc N' L)
H24 : and (eq N (MEnc N' L)) (synthesis h M' N')
H23 : injective_inv_left h
H22 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (L : Msg) (_ : synthesis h (inv K) (inv L)),\nex (fun N' : Msg => and (eq N (MEnc N' L)) (synthesis h M' N'))
H21 : synthesis h (inv K) (inv L)
H20 : eq N0 N
H19 : eq M0 (MEnc M' K)
H18 : h M N
M0,N0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N' L)
M,N,M',K,L,N' : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
forall (_ : le_h (analysis_def g) (irreducible g)) (_ : le_h (irreducible g) (analysis_def g)), synthesis g M' N'
+++++
intros.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
unfold le_h in H1.
unfold inclusion in H1.
generalize (H1 (inv K) (inv L) H15).
intro.
elim H11.
intros.
unfold enc_analysis_left in H22.
rewrite <- H14 in H18.
elim (H22 M N H18 M' K H14 L H21).
intro N'.
intro.
exists N'.
elim H24.
intros.
split.
trivial.
rewrite H14 in H13.
rewrite H25 in H13.
elim (irreducible_enc g M' N' K L).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
elim (H27 (H29 (MEnc M' K) (MEnc N' L) H13)).
intros.
generalize (ana_h_equiv_irr_h g).
unfold equiv_h in |- *.
intro.
elim H33.
intros.

*****
H35 : le_h (irreducible g) (analysis_def g)
H34 : le_h (analysis_def g) (irreducible g)
H33 : and (le_h (analysis_def g) (irreducible g))\n (le_h (irreducible g) (analysis_def g))
H32 : or (not (synthesis (analysis_def g) M' N'))\n (not (synthesis (analysis_def g) K L))
H31 : analysis_def g (MEnc M' K) (MEnc N' L)
H30 : forall (M N : Msg) (_ : irreducible g M N), g M N
H29 : forall (M N : Msg) (_ : g M N), irreducible g M N
H28 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N' L))\n (or (not (synthesis (analysis_def g) M' N'))\n (not (synthesis (analysis_def g) K L))),\nirreducible g (MEnc M' K) (MEnc N' L)
H27 : forall _ : irreducible g (MEnc M' K) (MEnc N' L),\nand (analysis_def g (MEnc M' K) (MEnc N' L))\n (or (not (synthesis (analysis_def g) M' N'))\n (not (synthesis (analysis_def g) K L)))
H26 : synthesis h M' N'
H25 : eq N (MEnc N' L)
H24 : and (eq N (MEnc N' L)) (synthesis h M' N')
H23 : injective_inv_left h
H22 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (L : Msg) (_ : synthesis h (inv K) (inv L)),\nex (fun N' : Msg => and (eq N (MEnc N' L)) (synthesis h M' N'))
H21 : synthesis h (inv K) (inv L)
H20 : eq N0 N
H19 : eq M0 (MEnc M' K)
H18 : h M N
M0,N0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N' L)
M,N,M',K,L,N' : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
synthesis g M' N'
+++++
unfold le_h in H34.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
unfold le_h in H1.
unfold inclusion in H1.
generalize (H1 (inv K) (inv L) H15).
intro.
elim H11.
intros.
unfold enc_analysis_left in H22.
rewrite <- H14 in H18.
elim (H22 M N H18 M' K H14 L H21).
intro N'.
intro.
exists N'.
elim H24.
intros.
split.
trivial.
rewrite H14 in H13.
rewrite H25 in H13.
elim (irreducible_enc g M' N' K L).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
elim (H27 (H29 (MEnc M' K) (MEnc N' L) H13)).
intros.
generalize (ana_h_equiv_irr_h g).
unfold equiv_h in |- *.
intro.
elim H33.
intros.
unfold le_h in H34.

*****
H35 : le_h (irreducible g) (analysis_def g)
H34 : inclusion (synthesis (analysis_def g)) (synthesis (irreducible g))
H33 : and (le_h (analysis_def g) (irreducible g))\n (le_h (irreducible g) (analysis_def g))
H32 : or (not (synthesis (analysis_def g) M' N'))\n (not (synthesis (analysis_def g) K L))
H31 : analysis_def g (MEnc M' K) (MEnc N' L)
H30 : forall (M N : Msg) (_ : irreducible g M N), g M N
H29 : forall (M N : Msg) (_ : g M N), irreducible g M N
H28 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N' L))\n (or (not (synthesis (analysis_def g) M' N'))\n (not (synthesis (analysis_def g) K L))),\nirreducible g (MEnc M' K) (MEnc N' L)
H27 : forall _ : irreducible g (MEnc M' K) (MEnc N' L),\nand (analysis_def g (MEnc M' K) (MEnc N' L))\n (or (not (synthesis (analysis_def g) M' N'))\n (not (synthesis (analysis_def g) K L)))
H26 : synthesis h M' N'
H25 : eq N (MEnc N' L)
H24 : and (eq N (MEnc N' L)) (synthesis h M' N')
H23 : injective_inv_left h
H22 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (L : Msg) (_ : synthesis h (inv K) (inv L)),\nex (fun N' : Msg => and (eq N (MEnc N' L)) (synthesis h M' N'))
H21 : synthesis h (inv K) (inv L)
H20 : eq N0 N
H19 : eq M0 (MEnc M' K)
H18 : h M N
M0,N0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N' L)
M,N,M',K,L,N' : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
synthesis g M' N'
+++++
unfold inclusion in H34.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
unfold le_h in H1.
unfold inclusion in H1.
generalize (H1 (inv K) (inv L) H15).
intro.
elim H11.
intros.
unfold enc_analysis_left in H22.
rewrite <- H14 in H18.
elim (H22 M N H18 M' K H14 L H21).
intro N'.
intro.
exists N'.
elim H24.
intros.
split.
trivial.
rewrite H14 in H13.
rewrite H25 in H13.
elim (irreducible_enc g M' N' K L).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
elim (H27 (H29 (MEnc M' K) (MEnc N' L) H13)).
intros.
generalize (ana_h_equiv_irr_h g).
unfold equiv_h in |- *.
intro.
elim H33.
intros.
unfold le_h in H34.
unfold inclusion in H34.

*****
H35 : le_h (irreducible g) (analysis_def g)
H34 : forall (M N : Msg) (_ : synthesis (analysis_def g) M N),\nsynthesis (irreducible g) M N
H33 : and (le_h (analysis_def g) (irreducible g))\n (le_h (irreducible g) (analysis_def g))
H32 : or (not (synthesis (analysis_def g) M' N'))\n (not (synthesis (analysis_def g) K L))
H31 : analysis_def g (MEnc M' K) (MEnc N' L)
H30 : forall (M N : Msg) (_ : irreducible g M N), g M N
H29 : forall (M N : Msg) (_ : g M N), irreducible g M N
H28 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N' L))\n (or (not (synthesis (analysis_def g) M' N'))\n (not (synthesis (analysis_def g) K L))),\nirreducible g (MEnc M' K) (MEnc N' L)
H27 : forall _ : irreducible g (MEnc M' K) (MEnc N' L),\nand (analysis_def g (MEnc M' K) (MEnc N' L))\n (or (not (synthesis (analysis_def g) M' N'))\n (not (synthesis (analysis_def g) K L)))
H26 : synthesis h M' N'
H25 : eq N (MEnc N' L)
H24 : and (eq N (MEnc N' L)) (synthesis h M' N')
H23 : injective_inv_left h
H22 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (L : Msg) (_ : synthesis h (inv K) (inv L)),\nex (fun N' : Msg => and (eq N (MEnc N' L)) (synthesis h M' N'))
H21 : synthesis h (inv K) (inv L)
H20 : eq N0 N
H19 : eq M0 (MEnc M' K)
H18 : h M N
M0,N0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N' L)
M,N,M',K,L,N' : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
synthesis g M' N'
+++++
fold (inclusion (irreducible g) g) in H30.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
unfold le_h in H1.
unfold inclusion in H1.
generalize (H1 (inv K) (inv L) H15).
intro.
elim H11.
intros.
unfold enc_analysis_left in H22.
rewrite <- H14 in H18.
elim (H22 M N H18 M' K H14 L H21).
intro N'.
intro.
exists N'.
elim H24.
intros.
split.
trivial.
rewrite H14 in H13.
rewrite H25 in H13.
elim (irreducible_enc g M' N' K L).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
elim (H27 (H29 (MEnc M' K) (MEnc N' L) H13)).
intros.
generalize (ana_h_equiv_irr_h g).
unfold equiv_h in |- *.
intro.
elim H33.
intros.
unfold le_h in H34.
unfold inclusion in H34.
fold (inclusion (irreducible g) g) in H30.

*****
H35 : le_h (irreducible g) (analysis_def g)
H34 : forall (M N : Msg) (_ : synthesis (analysis_def g) M N),\nsynthesis (irreducible g) M N
H33 : and (le_h (analysis_def g) (irreducible g))\n (le_h (irreducible g) (analysis_def g))
H32 : or (not (synthesis (analysis_def g) M' N'))\n (not (synthesis (analysis_def g) K L))
H31 : analysis_def g (MEnc M' K) (MEnc N' L)
H30 : inclusion (irreducible g) g
H29 : forall (M N : Msg) (_ : g M N), irreducible g M N
H28 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N' L))\n (or (not (synthesis (analysis_def g) M' N'))\n (not (synthesis (analysis_def g) K L))),\nirreducible g (MEnc M' K) (MEnc N' L)
H27 : forall _ : irreducible g (MEnc M' K) (MEnc N' L),\nand (analysis_def g (MEnc M' K) (MEnc N' L))\n (or (not (synthesis (analysis_def g) M' N'))\n (not (synthesis (analysis_def g) K L)))
H26 : synthesis h M' N'
H25 : eq N (MEnc N' L)
H24 : and (eq N (MEnc N' L)) (synthesis h M' N')
H23 : injective_inv_left h
H22 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (L : Msg) (_ : synthesis h (inv K) (inv L)),\nex (fun N' : Msg => and (eq N (MEnc N' L)) (synthesis h M' N'))
H21 : synthesis h (inv K) (inv L)
H20 : eq N0 N
H19 : eq M0 (MEnc M' K)
H18 : h M N
M0,N0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N' L)
M,N,M',K,L,N' : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
synthesis g M' N'
+++++
generalize (inclusion_impl_le_h (irreducible g) g H30).
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
unfold le_h in H1.
unfold inclusion in H1.
generalize (H1 (inv K) (inv L) H15).
intro.
elim H11.
intros.
unfold enc_analysis_left in H22.
rewrite <- H14 in H18.
elim (H22 M N H18 M' K H14 L H21).
intro N'.
intro.
exists N'.
elim H24.
intros.
split.
trivial.
rewrite H14 in H13.
rewrite H25 in H13.
elim (irreducible_enc g M' N' K L).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
elim (H27 (H29 (MEnc M' K) (MEnc N' L) H13)).
intros.
generalize (ana_h_equiv_irr_h g).
unfold equiv_h in |- *.
intro.
elim H33.
intros.
unfold le_h in H34.
unfold inclusion in H34.
fold (inclusion (irreducible g) g) in H30.
generalize (inclusion_impl_le_h (irreducible g) g H30).

*****
H35 : le_h (irreducible g) (analysis_def g)
H34 : forall (M N : Msg) (_ : synthesis (analysis_def g) M N),\nsynthesis (irreducible g) M N
H33 : and (le_h (analysis_def g) (irreducible g))\n (le_h (irreducible g) (analysis_def g))
H32 : or (not (synthesis (analysis_def g) M' N'))\n (not (synthesis (analysis_def g) K L))
H31 : analysis_def g (MEnc M' K) (MEnc N' L)
H30 : inclusion (irreducible g) g
H29 : forall (M N : Msg) (_ : g M N), irreducible g M N
H28 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N' L))\n (or (not (synthesis (analysis_def g) M' N'))\n (not (synthesis (analysis_def g) K L))),\nirreducible g (MEnc M' K) (MEnc N' L)
H27 : forall _ : irreducible g (MEnc M' K) (MEnc N' L),\nand (analysis_def g (MEnc M' K) (MEnc N' L))\n (or (not (synthesis (analysis_def g) M' N'))\n (not (synthesis (analysis_def g) K L)))
H26 : synthesis h M' N'
H25 : eq N (MEnc N' L)
H24 : and (eq N (MEnc N' L)) (synthesis h M' N')
H23 : injective_inv_left h
H22 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (L : Msg) (_ : synthesis h (inv K) (inv L)),\nex (fun N' : Msg => and (eq N (MEnc N' L)) (synthesis h M' N'))
H21 : synthesis h (inv K) (inv L)
H20 : eq N0 N
H19 : eq M0 (MEnc M' K)
H18 : h M N
M0,N0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N' L)
M,N,M',K,L,N' : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
forall _ : le_h (irreducible g) g, synthesis g M' N'
+++++
unfold le_h in |- *.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
unfold le_h in H1.
unfold inclusion in H1.
generalize (H1 (inv K) (inv L) H15).
intro.
elim H11.
intros.
unfold enc_analysis_left in H22.
rewrite <- H14 in H18.
elim (H22 M N H18 M' K H14 L H21).
intro N'.
intro.
exists N'.
elim H24.
intros.
split.
trivial.
rewrite H14 in H13.
rewrite H25 in H13.
elim (irreducible_enc g M' N' K L).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
elim (H27 (H29 (MEnc M' K) (MEnc N' L) H13)).
intros.
generalize (ana_h_equiv_irr_h g).
unfold equiv_h in |- *.
intro.
elim H33.
intros.
unfold le_h in H34.
unfold inclusion in H34.
fold (inclusion (irreducible g) g) in H30.
generalize (inclusion_impl_le_h (irreducible g) g H30).
unfold le_h in |- *.

*****
H35 : le_h (irreducible g) (analysis_def g)
H34 : forall (M N : Msg) (_ : synthesis (analysis_def g) M N),\nsynthesis (irreducible g) M N
H33 : and (le_h (analysis_def g) (irreducible g))\n (le_h (irreducible g) (analysis_def g))
H32 : or (not (synthesis (analysis_def g) M' N'))\n (not (synthesis (analysis_def g) K L))
H31 : analysis_def g (MEnc M' K) (MEnc N' L)
H30 : inclusion (irreducible g) g
H29 : forall (M N : Msg) (_ : g M N), irreducible g M N
H28 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N' L))\n (or (not (synthesis (analysis_def g) M' N'))\n (not (synthesis (analysis_def g) K L))),\nirreducible g (MEnc M' K) (MEnc N' L)
H27 : forall _ : irreducible g (MEnc M' K) (MEnc N' L),\nand (analysis_def g (MEnc M' K) (MEnc N' L))\n (or (not (synthesis (analysis_def g) M' N'))\n (not (synthesis (analysis_def g) K L)))
H26 : synthesis h M' N'
H25 : eq N (MEnc N' L)
H24 : and (eq N (MEnc N' L)) (synthesis h M' N')
H23 : injective_inv_left h
H22 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (L : Msg) (_ : synthesis h (inv K) (inv L)),\nex (fun N' : Msg => and (eq N (MEnc N' L)) (synthesis h M' N'))
H21 : synthesis h (inv K) (inv L)
H20 : eq N0 N
H19 : eq M0 (MEnc M' K)
H18 : h M N
M0,N0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N' L)
M,N,M',K,L,N' : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
forall _ : inclusion (synthesis (irreducible g)) (synthesis g), synthesis g M' N'
+++++
unfold inclusion in |- *.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
unfold le_h in H1.
unfold inclusion in H1.
generalize (H1 (inv K) (inv L) H15).
intro.
elim H11.
intros.
unfold enc_analysis_left in H22.
rewrite <- H14 in H18.
elim (H22 M N H18 M' K H14 L H21).
intro N'.
intro.
exists N'.
elim H24.
intros.
split.
trivial.
rewrite H14 in H13.
rewrite H25 in H13.
elim (irreducible_enc g M' N' K L).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
elim (H27 (H29 (MEnc M' K) (MEnc N' L) H13)).
intros.
generalize (ana_h_equiv_irr_h g).
unfold equiv_h in |- *.
intro.
elim H33.
intros.
unfold le_h in H34.
unfold inclusion in H34.
fold (inclusion (irreducible g) g) in H30.
generalize (inclusion_impl_le_h (irreducible g) g H30).
unfold le_h in |- *.
unfold inclusion in |- *.

*****
H35 : le_h (irreducible g) (analysis_def g)
H34 : forall (M N : Msg) (_ : synthesis (analysis_def g) M N),\nsynthesis (irreducible g) M N
H33 : and (le_h (analysis_def g) (irreducible g))\n (le_h (irreducible g) (analysis_def g))
H32 : or (not (synthesis (analysis_def g) M' N'))\n (not (synthesis (analysis_def g) K L))
H31 : analysis_def g (MEnc M' K) (MEnc N' L)
H30 : inclusion (irreducible g) g
H29 : forall (M N : Msg) (_ : g M N), irreducible g M N
H28 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N' L))\n (or (not (synthesis (analysis_def g) M' N'))\n (not (synthesis (analysis_def g) K L))),\nirreducible g (MEnc M' K) (MEnc N' L)
H27 : forall _ : irreducible g (MEnc M' K) (MEnc N' L),\nand (analysis_def g (MEnc M' K) (MEnc N' L))\n (or (not (synthesis (analysis_def g) M' N'))\n (not (synthesis (analysis_def g) K L)))
H26 : synthesis h M' N'
H25 : eq N (MEnc N' L)
H24 : and (eq N (MEnc N' L)) (synthesis h M' N')
H23 : injective_inv_left h
H22 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (L : Msg) (_ : synthesis h (inv K) (inv L)),\nex (fun N' : Msg => and (eq N (MEnc N' L)) (synthesis h M' N'))
H21 : synthesis h (inv K) (inv L)
H20 : eq N0 N
H19 : eq M0 (MEnc M' K)
H18 : h M N
M0,N0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N' L)
M,N,M',K,L,N' : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
forall _ : forall (M N : Msg) (_ : synthesis (irreducible g) M N), synthesis g M N, synthesis g M' N'
+++++
intro.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
unfold le_h in H1.
unfold inclusion in H1.
generalize (H1 (inv K) (inv L) H15).
intro.
elim H11.
intros.
unfold enc_analysis_left in H22.
rewrite <- H14 in H18.
elim (H22 M N H18 M' K H14 L H21).
intro N'.
intro.
exists N'.
elim H24.
intros.
split.
trivial.
rewrite H14 in H13.
rewrite H25 in H13.
elim (irreducible_enc g M' N' K L).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
elim (H27 (H29 (MEnc M' K) (MEnc N' L) H13)).
intros.
generalize (ana_h_equiv_irr_h g).
unfold equiv_h in |- *.
intro.
elim H33.
intros.
unfold le_h in H34.
unfold inclusion in H34.
fold (inclusion (irreducible g) g) in H30.
generalize (inclusion_impl_le_h (irreducible g) g H30).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.

*****
H36 : forall (M N : Msg) (_ : synthesis (irreducible g) M N), synthesis g M N
H35 : le_h (irreducible g) (analysis_def g)
H34 : forall (M N : Msg) (_ : synthesis (analysis_def g) M N),\nsynthesis (irreducible g) M N
H33 : and (le_h (analysis_def g) (irreducible g))\n (le_h (irreducible g) (analysis_def g))
H32 : or (not (synthesis (analysis_def g) M' N'))\n (not (synthesis (analysis_def g) K L))
H31 : analysis_def g (MEnc M' K) (MEnc N' L)
H30 : inclusion (irreducible g) g
H29 : forall (M N : Msg) (_ : g M N), irreducible g M N
H28 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N' L))\n (or (not (synthesis (analysis_def g) M' N'))\n (not (synthesis (analysis_def g) K L))),\nirreducible g (MEnc M' K) (MEnc N' L)
H27 : forall _ : irreducible g (MEnc M' K) (MEnc N' L),\nand (analysis_def g (MEnc M' K) (MEnc N' L))\n (or (not (synthesis (analysis_def g) M' N'))\n (not (synthesis (analysis_def g) K L)))
H26 : synthesis h M' N'
H25 : eq N (MEnc N' L)
H24 : and (eq N (MEnc N' L)) (synthesis h M' N')
H23 : injective_inv_left h
H22 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (L : Msg) (_ : synthesis h (inv K) (inv L)),\nex (fun N' : Msg => and (eq N (MEnc N' L)) (synthesis h M' N'))
H21 : synthesis h (inv K) (inv L)
H20 : eq N0 N
H19 : eq M0 (MEnc M' K)
H18 : h M N
M0,N0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N' L)
M,N,M',K,L,N' : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
synthesis g M' N'
+++++
apply H36.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
unfold le_h in H1.
unfold inclusion in H1.
generalize (H1 (inv K) (inv L) H15).
intro.
elim H11.
intros.
unfold enc_analysis_left in H22.
rewrite <- H14 in H18.
elim (H22 M N H18 M' K H14 L H21).
intro N'.
intro.
exists N'.
elim H24.
intros.
split.
trivial.
rewrite H14 in H13.
rewrite H25 in H13.
elim (irreducible_enc g M' N' K L).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
elim (H27 (H29 (MEnc M' K) (MEnc N' L) H13)).
intros.
generalize (ana_h_equiv_irr_h g).
unfold equiv_h in |- *.
intro.
elim H33.
intros.
unfold le_h in H34.
unfold inclusion in H34.
fold (inclusion (irreducible g) g) in H30.
generalize (inclusion_impl_le_h (irreducible g) g H30).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
apply H36.

*****
H36 : forall (M N : Msg) (_ : synthesis (irreducible g) M N), synthesis g M N
H35 : le_h (irreducible g) (analysis_def g)
H34 : forall (M N : Msg) (_ : synthesis (analysis_def g) M N),\nsynthesis (irreducible g) M N
H33 : and (le_h (analysis_def g) (irreducible g))\n (le_h (irreducible g) (analysis_def g))
H32 : or (not (synthesis (analysis_def g) M' N'))\n (not (synthesis (analysis_def g) K L))
H31 : analysis_def g (MEnc M' K) (MEnc N' L)
H30 : inclusion (irreducible g) g
H29 : forall (M N : Msg) (_ : g M N), irreducible g M N
H28 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N' L))\n (or (not (synthesis (analysis_def g) M' N'))\n (not (synthesis (analysis_def g) K L))),\nirreducible g (MEnc M' K) (MEnc N' L)
H27 : forall _ : irreducible g (MEnc M' K) (MEnc N' L),\nand (analysis_def g (MEnc M' K) (MEnc N' L))\n (or (not (synthesis (analysis_def g) M' N'))\n (not (synthesis (analysis_def g) K L)))
H26 : synthesis h M' N'
H25 : eq N (MEnc N' L)
H24 : and (eq N (MEnc N' L)) (synthesis h M' N')
H23 : injective_inv_left h
H22 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (L : Msg) (_ : synthesis h (inv K) (inv L)),\nex (fun N' : Msg => and (eq N (MEnc N' L)) (synthesis h M' N'))
H21 : synthesis h (inv K) (inv L)
H20 : eq N0 N
H19 : eq M0 (MEnc M' K)
H18 : h M N
M0,N0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N' L)
M,N,M',K,L,N' : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
synthesis (irreducible g) M' N'
+++++
apply H34.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
unfold le_h in H1.
unfold inclusion in H1.
generalize (H1 (inv K) (inv L) H15).
intro.
elim H11.
intros.
unfold enc_analysis_left in H22.
rewrite <- H14 in H18.
elim (H22 M N H18 M' K H14 L H21).
intro N'.
intro.
exists N'.
elim H24.
intros.
split.
trivial.
rewrite H14 in H13.
rewrite H25 in H13.
elim (irreducible_enc g M' N' K L).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
elim (H27 (H29 (MEnc M' K) (MEnc N' L) H13)).
intros.
generalize (ana_h_equiv_irr_h g).
unfold equiv_h in |- *.
intro.
elim H33.
intros.
unfold le_h in H34.
unfold inclusion in H34.
fold (inclusion (irreducible g) g) in H30.
generalize (inclusion_impl_le_h (irreducible g) g H30).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
apply H36.
apply H34.

*****
H36 : forall (M N : Msg) (_ : synthesis (irreducible g) M N), synthesis g M N
H35 : le_h (irreducible g) (analysis_def g)
H34 : forall (M N : Msg) (_ : synthesis (analysis_def g) M N),\nsynthesis (irreducible g) M N
H33 : and (le_h (analysis_def g) (irreducible g))\n (le_h (irreducible g) (analysis_def g))
H32 : or (not (synthesis (analysis_def g) M' N'))\n (not (synthesis (analysis_def g) K L))
H31 : analysis_def g (MEnc M' K) (MEnc N' L)
H30 : inclusion (irreducible g) g
H29 : forall (M N : Msg) (_ : g M N), irreducible g M N
H28 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N' L))\n (or (not (synthesis (analysis_def g) M' N'))\n (not (synthesis (analysis_def g) K L))),\nirreducible g (MEnc M' K) (MEnc N' L)
H27 : forall _ : irreducible g (MEnc M' K) (MEnc N' L),\nand (analysis_def g (MEnc M' K) (MEnc N' L))\n (or (not (synthesis (analysis_def g) M' N'))\n (not (synthesis (analysis_def g) K L)))
H26 : synthesis h M' N'
H25 : eq N (MEnc N' L)
H24 : and (eq N (MEnc N' L)) (synthesis h M' N')
H23 : injective_inv_left h
H22 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (L : Msg) (_ : synthesis h (inv K) (inv L)),\nex (fun N' : Msg => and (eq N (MEnc N' L)) (synthesis h M' N'))
H21 : synthesis h (inv K) (inv L)
H20 : eq N0 N
H19 : eq M0 (MEnc M' K)
H18 : h M N
M0,N0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N' L)
M,N,M',K,L,N' : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
synthesis (analysis_def g) M' N'
+++++
apply SynInc.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
unfold le_h in H1.
unfold inclusion in H1.
generalize (H1 (inv K) (inv L) H15).
intro.
elim H11.
intros.
unfold enc_analysis_left in H22.
rewrite <- H14 in H18.
elim (H22 M N H18 M' K H14 L H21).
intro N'.
intro.
exists N'.
elim H24.
intros.
split.
trivial.
rewrite H14 in H13.
rewrite H25 in H13.
elim (irreducible_enc g M' N' K L).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
elim (H27 (H29 (MEnc M' K) (MEnc N' L) H13)).
intros.
generalize (ana_h_equiv_irr_h g).
unfold equiv_h in |- *.
intro.
elim H33.
intros.
unfold le_h in H34.
unfold inclusion in H34.
fold (inclusion (irreducible g) g) in H30.
generalize (inclusion_impl_le_h (irreducible g) g H30).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
apply H36.
apply H34.
apply SynInc.

*****
H36 : forall (M N : Msg) (_ : synthesis (irreducible g) M N), synthesis g M N
H35 : le_h (irreducible g) (analysis_def g)
H34 : forall (M N : Msg) (_ : synthesis (analysis_def g) M N),\nsynthesis (irreducible g) M N
H33 : and (le_h (analysis_def g) (irreducible g))\n (le_h (irreducible g) (analysis_def g))
H32 : or (not (synthesis (analysis_def g) M' N'))\n (not (synthesis (analysis_def g) K L))
H31 : analysis_def g (MEnc M' K) (MEnc N' L)
H30 : inclusion (irreducible g) g
H29 : forall (M N : Msg) (_ : g M N), irreducible g M N
H28 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N' L))\n (or (not (synthesis (analysis_def g) M' N'))\n (not (synthesis (analysis_def g) K L))),\nirreducible g (MEnc M' K) (MEnc N' L)
H27 : forall _ : irreducible g (MEnc M' K) (MEnc N' L),\nand (analysis_def g (MEnc M' K) (MEnc N' L))\n (or (not (synthesis (analysis_def g) M' N'))\n (not (synthesis (analysis_def g) K L)))
H26 : synthesis h M' N'
H25 : eq N (MEnc N' L)
H24 : and (eq N (MEnc N' L)) (synthesis h M' N')
H23 : injective_inv_left h
H22 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (L : Msg) (_ : synthesis h (inv K) (inv L)),\nex (fun N' : Msg => and (eq N (MEnc N' L)) (synthesis h M' N'))
H21 : synthesis h (inv K) (inv L)
H20 : eq N0 N
H19 : eq M0 (MEnc M' K)
H18 : h M N
M0,N0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N' L)
M,N,M',K,L,N' : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
analysis_def g M' N'
+++++
generalize (analysis_is_analysis g).
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
unfold le_h in H1.
unfold inclusion in H1.
generalize (H1 (inv K) (inv L) H15).
intro.
elim H11.
intros.
unfold enc_analysis_left in H22.
rewrite <- H14 in H18.
elim (H22 M N H18 M' K H14 L H21).
intro N'.
intro.
exists N'.
elim H24.
intros.
split.
trivial.
rewrite H14 in H13.
rewrite H25 in H13.
elim (irreducible_enc g M' N' K L).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
elim (H27 (H29 (MEnc M' K) (MEnc N' L) H13)).
intros.
generalize (ana_h_equiv_irr_h g).
unfold equiv_h in |- *.
intro.
elim H33.
intros.
unfold le_h in H34.
unfold inclusion in H34.
fold (inclusion (irreducible g) g) in H30.
generalize (inclusion_impl_le_h (irreducible g) g H30).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
apply H36.
apply H34.
apply SynInc.
generalize (analysis_is_analysis g).

*****
H36 : forall (M N : Msg) (_ : synthesis (irreducible g) M N), synthesis g M N
H35 : le_h (irreducible g) (analysis_def g)
H34 : forall (M N : Msg) (_ : synthesis (analysis_def g) M N),\nsynthesis (irreducible g) M N
H33 : and (le_h (analysis_def g) (irreducible g))\n (le_h (irreducible g) (analysis_def g))
H32 : or (not (synthesis (analysis_def g) M' N'))\n (not (synthesis (analysis_def g) K L))
H31 : analysis_def g (MEnc M' K) (MEnc N' L)
H30 : inclusion (irreducible g) g
H29 : forall (M N : Msg) (_ : g M N), irreducible g M N
H28 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N' L))\n (or (not (synthesis (analysis_def g) M' N'))\n (not (synthesis (analysis_def g) K L))),\nirreducible g (MEnc M' K) (MEnc N' L)
H27 : forall _ : irreducible g (MEnc M' K) (MEnc N' L),\nand (analysis_def g (MEnc M' K) (MEnc N' L))\n (or (not (synthesis (analysis_def g) M' N'))\n (not (synthesis (analysis_def g) K L)))
H26 : synthesis h M' N'
H25 : eq N (MEnc N' L)
H24 : and (eq N (MEnc N' L)) (synthesis h M' N')
H23 : injective_inv_left h
H22 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (L : Msg) (_ : synthesis h (inv K) (inv L)),\nex (fun N' : Msg => and (eq N (MEnc N' L)) (synthesis h M' N'))
H21 : synthesis h (inv K) (inv L)
H20 : eq N0 N
H19 : eq M0 (MEnc M' K)
H18 : h M N
M0,N0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N' L)
M,N,M',K,L,N' : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
forall _ : is_analysis g (analysis_def g), analysis_def g M' N'
+++++
unfold is_analysis in |- *.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
unfold le_h in H1.
unfold inclusion in H1.
generalize (H1 (inv K) (inv L) H15).
intro.
elim H11.
intros.
unfold enc_analysis_left in H22.
rewrite <- H14 in H18.
elim (H22 M N H18 M' K H14 L H21).
intro N'.
intro.
exists N'.
elim H24.
intros.
split.
trivial.
rewrite H14 in H13.
rewrite H25 in H13.
elim (irreducible_enc g M' N' K L).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
elim (H27 (H29 (MEnc M' K) (MEnc N' L) H13)).
intros.
generalize (ana_h_equiv_irr_h g).
unfold equiv_h in |- *.
intro.
elim H33.
intros.
unfold le_h in H34.
unfold inclusion in H34.
fold (inclusion (irreducible g) g) in H30.
generalize (inclusion_impl_le_h (irreducible g) g H30).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
apply H36.
apply H34.
apply SynInc.
generalize (analysis_is_analysis g).
unfold is_analysis in |- *.

*****
H36 : forall (M N : Msg) (_ : synthesis (irreducible g) M N), synthesis g M N
H35 : le_h (irreducible g) (analysis_def g)
H34 : forall (M N : Msg) (_ : synthesis (analysis_def g) M N),\nsynthesis (irreducible g) M N
H33 : and (le_h (analysis_def g) (irreducible g))\n (le_h (irreducible g) (analysis_def g))
H32 : or (not (synthesis (analysis_def g) M' N'))\n (not (synthesis (analysis_def g) K L))
H31 : analysis_def g (MEnc M' K) (MEnc N' L)
H30 : inclusion (irreducible g) g
H29 : forall (M N : Msg) (_ : g M N), irreducible g M N
H28 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N' L))\n (or (not (synthesis (analysis_def g) M' N'))\n (not (synthesis (analysis_def g) K L))),\nirreducible g (MEnc M' K) (MEnc N' L)
H27 : forall _ : irreducible g (MEnc M' K) (MEnc N' L),\nand (analysis_def g (MEnc M' K) (MEnc N' L))\n (or (not (synthesis (analysis_def g) M' N'))\n (not (synthesis (analysis_def g) K L)))
H26 : synthesis h M' N'
H25 : eq N (MEnc N' L)
H24 : and (eq N (MEnc N' L)) (synthesis h M' N')
H23 : injective_inv_left h
H22 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (L : Msg) (_ : synthesis h (inv K) (inv L)),\nex (fun N' : Msg => and (eq N (MEnc N' L)) (synthesis h M' N'))
H21 : synthesis h (inv K) (inv L)
H20 : eq N0 N
H19 : eq M0 (MEnc M' K)
H18 : h M N
M0,N0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N' L)
M,N,M',K,L,N' : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
forall _ : and (analysis_cond g (analysis_def g)) (forall (h' : hedge) (_ : analysis_cond g h'), inclusion (analysis_def g) h'), analysis_def g M' N'
+++++
unfold analysis_cond in |- *.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
unfold le_h in H1.
unfold inclusion in H1.
generalize (H1 (inv K) (inv L) H15).
intro.
elim H11.
intros.
unfold enc_analysis_left in H22.
rewrite <- H14 in H18.
elim (H22 M N H18 M' K H14 L H21).
intro N'.
intro.
exists N'.
elim H24.
intros.
split.
trivial.
rewrite H14 in H13.
rewrite H25 in H13.
elim (irreducible_enc g M' N' K L).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
elim (H27 (H29 (MEnc M' K) (MEnc N' L) H13)).
intros.
generalize (ana_h_equiv_irr_h g).
unfold equiv_h in |- *.
intro.
elim H33.
intros.
unfold le_h in H34.
unfold inclusion in H34.
fold (inclusion (irreducible g) g) in H30.
generalize (inclusion_impl_le_h (irreducible g) g H30).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
apply H36.
apply H34.
apply SynInc.
generalize (analysis_is_analysis g).
unfold is_analysis in |- *.
unfold analysis_cond in |- *.

*****
H36 : forall (M N : Msg) (_ : synthesis (irreducible g) M N), synthesis g M N
H35 : le_h (irreducible g) (analysis_def g)
H34 : forall (M N : Msg) (_ : synthesis (analysis_def g) M N),\nsynthesis (irreducible g) M N
H33 : and (le_h (analysis_def g) (irreducible g))\n (le_h (irreducible g) (analysis_def g))
H32 : or (not (synthesis (analysis_def g) M' N'))\n (not (synthesis (analysis_def g) K L))
H31 : analysis_def g (MEnc M' K) (MEnc N' L)
H30 : inclusion (irreducible g) g
H29 : forall (M N : Msg) (_ : g M N), irreducible g M N
H28 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N' L))\n (or (not (synthesis (analysis_def g) M' N'))\n (not (synthesis (analysis_def g) K L))),\nirreducible g (MEnc M' K) (MEnc N' L)
H27 : forall _ : irreducible g (MEnc M' K) (MEnc N' L),\nand (analysis_def g (MEnc M' K) (MEnc N' L))\n (or (not (synthesis (analysis_def g) M' N'))\n (not (synthesis (analysis_def g) K L)))
H26 : synthesis h M' N'
H25 : eq N (MEnc N' L)
H24 : and (eq N (MEnc N' L)) (synthesis h M' N')
H23 : injective_inv_left h
H22 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (L : Msg) (_ : synthesis h (inv K) (inv L)),\nex (fun N' : Msg => and (eq N (MEnc N' L)) (synthesis h M' N'))
H21 : synthesis h (inv K) (inv L)
H20 : eq N0 N
H19 : eq M0 (MEnc M' K)
H18 : h M N
M0,N0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N' L)
M,N,M',K,L,N' : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
forall _ : and (and (inclusion g (analysis_def g)) (stable_analysis (analysis_def g))) (forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')), inclusion (analysis_def g) h'), analysis_def g M' N'
+++++
intros.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
unfold le_h in H1.
unfold inclusion in H1.
generalize (H1 (inv K) (inv L) H15).
intro.
elim H11.
intros.
unfold enc_analysis_left in H22.
rewrite <- H14 in H18.
elim (H22 M N H18 M' K H14 L H21).
intro N'.
intro.
exists N'.
elim H24.
intros.
split.
trivial.
rewrite H14 in H13.
rewrite H25 in H13.
elim (irreducible_enc g M' N' K L).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
elim (H27 (H29 (MEnc M' K) (MEnc N' L) H13)).
intros.
generalize (ana_h_equiv_irr_h g).
unfold equiv_h in |- *.
intro.
elim H33.
intros.
unfold le_h in H34.
unfold inclusion in H34.
fold (inclusion (irreducible g) g) in H30.
generalize (inclusion_impl_le_h (irreducible g) g H30).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
apply H36.
apply H34.
apply SynInc.
generalize (analysis_is_analysis g).
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.

*****
H37 : and\n (and (inclusion g (analysis_def g))\n (stable_analysis (analysis_def g)))\n (forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\n inclusion (analysis_def g) h')
H36 : forall (M N : Msg) (_ : synthesis (irreducible g) M N), synthesis g M N
H35 : le_h (irreducible g) (analysis_def g)
H34 : forall (M N : Msg) (_ : synthesis (analysis_def g) M N),\nsynthesis (irreducible g) M N
H33 : and (le_h (analysis_def g) (irreducible g))\n (le_h (irreducible g) (analysis_def g))
H32 : or (not (synthesis (analysis_def g) M' N'))\n (not (synthesis (analysis_def g) K L))
H31 : analysis_def g (MEnc M' K) (MEnc N' L)
H30 : inclusion (irreducible g) g
H29 : forall (M N : Msg) (_ : g M N), irreducible g M N
H28 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N' L))\n (or (not (synthesis (analysis_def g) M' N'))\n (not (synthesis (analysis_def g) K L))),\nirreducible g (MEnc M' K) (MEnc N' L)
H27 : forall _ : irreducible g (MEnc M' K) (MEnc N' L),\nand (analysis_def g (MEnc M' K) (MEnc N' L))\n (or (not (synthesis (analysis_def g) M' N'))\n (not (synthesis (analysis_def g) K L)))
H26 : synthesis h M' N'
H25 : eq N (MEnc N' L)
H24 : and (eq N (MEnc N' L)) (synthesis h M' N')
H23 : injective_inv_left h
H22 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (L : Msg) (_ : synthesis h (inv K) (inv L)),\nex (fun N' : Msg => and (eq N (MEnc N' L)) (synthesis h M' N'))
H21 : synthesis h (inv K) (inv L)
H20 : eq N0 N
H19 : eq M0 (MEnc M' K)
H18 : h M N
M0,N0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N' L)
M,N,M',K,L,N' : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
analysis_def g M' N'
+++++
elim H37.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
unfold le_h in H1.
unfold inclusion in H1.
generalize (H1 (inv K) (inv L) H15).
intro.
elim H11.
intros.
unfold enc_analysis_left in H22.
rewrite <- H14 in H18.
elim (H22 M N H18 M' K H14 L H21).
intro N'.
intro.
exists N'.
elim H24.
intros.
split.
trivial.
rewrite H14 in H13.
rewrite H25 in H13.
elim (irreducible_enc g M' N' K L).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
elim (H27 (H29 (MEnc M' K) (MEnc N' L) H13)).
intros.
generalize (ana_h_equiv_irr_h g).
unfold equiv_h in |- *.
intro.
elim H33.
intros.
unfold le_h in H34.
unfold inclusion in H34.
fold (inclusion (irreducible g) g) in H30.
generalize (inclusion_impl_le_h (irreducible g) g H30).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
apply H36.
apply H34.
apply SynInc.
generalize (analysis_is_analysis g).
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.
elim H37.

*****
H37 : and\n (and (inclusion g (analysis_def g))\n (stable_analysis (analysis_def g)))\n (forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\n inclusion (analysis_def g) h')
H36 : forall (M N : Msg) (_ : synthesis (irreducible g) M N), synthesis g M N
H35 : le_h (irreducible g) (analysis_def g)
H34 : forall (M N : Msg) (_ : synthesis (analysis_def g) M N),\nsynthesis (irreducible g) M N
H33 : and (le_h (analysis_def g) (irreducible g))\n (le_h (irreducible g) (analysis_def g))
H32 : or (not (synthesis (analysis_def g) M' N'))\n (not (synthesis (analysis_def g) K L))
H31 : analysis_def g (MEnc M' K) (MEnc N' L)
H30 : inclusion (irreducible g) g
H29 : forall (M N : Msg) (_ : g M N), irreducible g M N
H28 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N' L))\n (or (not (synthesis (analysis_def g) M' N'))\n (not (synthesis (analysis_def g) K L))),\nirreducible g (MEnc M' K) (MEnc N' L)
H27 : forall _ : irreducible g (MEnc M' K) (MEnc N' L),\nand (analysis_def g (MEnc M' K) (MEnc N' L))\n (or (not (synthesis (analysis_def g) M' N'))\n (not (synthesis (analysis_def g) K L)))
H26 : synthesis h M' N'
H25 : eq N (MEnc N' L)
H24 : and (eq N (MEnc N' L)) (synthesis h M' N')
H23 : injective_inv_left h
H22 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (L : Msg) (_ : synthesis h (inv K) (inv L)),\nex (fun N' : Msg => and (eq N (MEnc N' L)) (synthesis h M' N'))
H21 : synthesis h (inv K) (inv L)
H20 : eq N0 N
H19 : eq M0 (MEnc M' K)
H18 : h M N
M0,N0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N' L)
M,N,M',K,L,N' : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
forall (_ : and (inclusion g (analysis_def g)) (stable_analysis (analysis_def g))) (_ : forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')), inclusion (analysis_def g) h'), analysis_def g M' N'
+++++
intros.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
unfold le_h in H1.
unfold inclusion in H1.
generalize (H1 (inv K) (inv L) H15).
intro.
elim H11.
intros.
unfold enc_analysis_left in H22.
rewrite <- H14 in H18.
elim (H22 M N H18 M' K H14 L H21).
intro N'.
intro.
exists N'.
elim H24.
intros.
split.
trivial.
rewrite H14 in H13.
rewrite H25 in H13.
elim (irreducible_enc g M' N' K L).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
elim (H27 (H29 (MEnc M' K) (MEnc N' L) H13)).
intros.
generalize (ana_h_equiv_irr_h g).
unfold equiv_h in |- *.
intro.
elim H33.
intros.
unfold le_h in H34.
unfold inclusion in H34.
fold (inclusion (irreducible g) g) in H30.
generalize (inclusion_impl_le_h (irreducible g) g H30).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
apply H36.
apply H34.
apply SynInc.
generalize (analysis_is_analysis g).
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.
elim H37.
intros.

*****
H39 : forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\ninclusion (analysis_def g) h'
H38 : and (inclusion g (analysis_def g)) (stable_analysis (analysis_def g))
H37 : and\n (and (inclusion g (analysis_def g))\n (stable_analysis (analysis_def g)))\n (forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\n inclusion (analysis_def g) h')
H36 : forall (M N : Msg) (_ : synthesis (irreducible g) M N), synthesis g M N
H35 : le_h (irreducible g) (analysis_def g)
H34 : forall (M N : Msg) (_ : synthesis (analysis_def g) M N),\nsynthesis (irreducible g) M N
H33 : and (le_h (analysis_def g) (irreducible g))\n (le_h (irreducible g) (analysis_def g))
H32 : or (not (synthesis (analysis_def g) M' N'))\n (not (synthesis (analysis_def g) K L))
H31 : analysis_def g (MEnc M' K) (MEnc N' L)
H30 : inclusion (irreducible g) g
H29 : forall (M N : Msg) (_ : g M N), irreducible g M N
H28 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N' L))\n (or (not (synthesis (analysis_def g) M' N'))\n (not (synthesis (analysis_def g) K L))),\nirreducible g (MEnc M' K) (MEnc N' L)
H27 : forall _ : irreducible g (MEnc M' K) (MEnc N' L),\nand (analysis_def g (MEnc M' K) (MEnc N' L))\n (or (not (synthesis (analysis_def g) M' N'))\n (not (synthesis (analysis_def g) K L)))
H26 : synthesis h M' N'
H25 : eq N (MEnc N' L)
H24 : and (eq N (MEnc N' L)) (synthesis h M' N')
H23 : injective_inv_left h
H22 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (L : Msg) (_ : synthesis h (inv K) (inv L)),\nex (fun N' : Msg => and (eq N (MEnc N' L)) (synthesis h M' N'))
H21 : synthesis h (inv K) (inv L)
H20 : eq N0 N
H19 : eq M0 (MEnc M' K)
H18 : h M N
M0,N0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N' L)
M,N,M',K,L,N' : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
analysis_def g M' N'
+++++
elim H38.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
unfold le_h in H1.
unfold inclusion in H1.
generalize (H1 (inv K) (inv L) H15).
intro.
elim H11.
intros.
unfold enc_analysis_left in H22.
rewrite <- H14 in H18.
elim (H22 M N H18 M' K H14 L H21).
intro N'.
intro.
exists N'.
elim H24.
intros.
split.
trivial.
rewrite H14 in H13.
rewrite H25 in H13.
elim (irreducible_enc g M' N' K L).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
elim (H27 (H29 (MEnc M' K) (MEnc N' L) H13)).
intros.
generalize (ana_h_equiv_irr_h g).
unfold equiv_h in |- *.
intro.
elim H33.
intros.
unfold le_h in H34.
unfold inclusion in H34.
fold (inclusion (irreducible g) g) in H30.
generalize (inclusion_impl_le_h (irreducible g) g H30).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
apply H36.
apply H34.
apply SynInc.
generalize (analysis_is_analysis g).
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.
elim H37.
intros.
elim H38.

*****
H39 : forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\ninclusion (analysis_def g) h'
H38 : and (inclusion g (analysis_def g)) (stable_analysis (analysis_def g))
H37 : and\n (and (inclusion g (analysis_def g))\n (stable_analysis (analysis_def g)))\n (forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\n inclusion (analysis_def g) h')
H36 : forall (M N : Msg) (_ : synthesis (irreducible g) M N), synthesis g M N
H35 : le_h (irreducible g) (analysis_def g)
H34 : forall (M N : Msg) (_ : synthesis (analysis_def g) M N),\nsynthesis (irreducible g) M N
H33 : and (le_h (analysis_def g) (irreducible g))\n (le_h (irreducible g) (analysis_def g))
H32 : or (not (synthesis (analysis_def g) M' N'))\n (not (synthesis (analysis_def g) K L))
H31 : analysis_def g (MEnc M' K) (MEnc N' L)
H30 : inclusion (irreducible g) g
H29 : forall (M N : Msg) (_ : g M N), irreducible g M N
H28 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N' L))\n (or (not (synthesis (analysis_def g) M' N'))\n (not (synthesis (analysis_def g) K L))),\nirreducible g (MEnc M' K) (MEnc N' L)
H27 : forall _ : irreducible g (MEnc M' K) (MEnc N' L),\nand (analysis_def g (MEnc M' K) (MEnc N' L))\n (or (not (synthesis (analysis_def g) M' N'))\n (not (synthesis (analysis_def g) K L)))
H26 : synthesis h M' N'
H25 : eq N (MEnc N' L)
H24 : and (eq N (MEnc N' L)) (synthesis h M' N')
H23 : injective_inv_left h
H22 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (L : Msg) (_ : synthesis h (inv K) (inv L)),\nex (fun N' : Msg => and (eq N (MEnc N' L)) (synthesis h M' N'))
H21 : synthesis h (inv K) (inv L)
H20 : eq N0 N
H19 : eq M0 (MEnc M' K)
H18 : h M N
M0,N0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N' L)
M,N,M',K,L,N' : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
forall (_ : inclusion g (analysis_def g)) (_ : stable_analysis (analysis_def g)), analysis_def g M' N'
+++++
unfold stable_analysis in |- *.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
unfold le_h in H1.
unfold inclusion in H1.
generalize (H1 (inv K) (inv L) H15).
intro.
elim H11.
intros.
unfold enc_analysis_left in H22.
rewrite <- H14 in H18.
elim (H22 M N H18 M' K H14 L H21).
intro N'.
intro.
exists N'.
elim H24.
intros.
split.
trivial.
rewrite H14 in H13.
rewrite H25 in H13.
elim (irreducible_enc g M' N' K L).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
elim (H27 (H29 (MEnc M' K) (MEnc N' L) H13)).
intros.
generalize (ana_h_equiv_irr_h g).
unfold equiv_h in |- *.
intro.
elim H33.
intros.
unfold le_h in H34.
unfold inclusion in H34.
fold (inclusion (irreducible g) g) in H30.
generalize (inclusion_impl_le_h (irreducible g) g H30).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
apply H36.
apply H34.
apply SynInc.
generalize (analysis_is_analysis g).
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.
elim H37.
intros.
elim H38.
unfold stable_analysis in |- *.

*****
H39 : forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\ninclusion (analysis_def g) h'
H38 : and (inclusion g (analysis_def g)) (stable_analysis (analysis_def g))
H37 : and\n (and (inclusion g (analysis_def g))\n (stable_analysis (analysis_def g)))\n (forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\n inclusion (analysis_def g) h')
H36 : forall (M N : Msg) (_ : synthesis (irreducible g) M N), synthesis g M N
H35 : le_h (irreducible g) (analysis_def g)
H34 : forall (M N : Msg) (_ : synthesis (analysis_def g) M N),\nsynthesis (irreducible g) M N
H33 : and (le_h (analysis_def g) (irreducible g))\n (le_h (irreducible g) (analysis_def g))
H32 : or (not (synthesis (analysis_def g) M' N'))\n (not (synthesis (analysis_def g) K L))
H31 : analysis_def g (MEnc M' K) (MEnc N' L)
H30 : inclusion (irreducible g) g
H29 : forall (M N : Msg) (_ : g M N), irreducible g M N
H28 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N' L))\n (or (not (synthesis (analysis_def g) M' N'))\n (not (synthesis (analysis_def g) K L))),\nirreducible g (MEnc M' K) (MEnc N' L)
H27 : forall _ : irreducible g (MEnc M' K) (MEnc N' L),\nand (analysis_def g (MEnc M' K) (MEnc N' L))\n (or (not (synthesis (analysis_def g) M' N'))\n (not (synthesis (analysis_def g) K L)))
H26 : synthesis h M' N'
H25 : eq N (MEnc N' L)
H24 : and (eq N (MEnc N' L)) (synthesis h M' N')
H23 : injective_inv_left h
H22 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (L : Msg) (_ : synthesis h (inv K) (inv L)),\nex (fun N' : Msg => and (eq N (MEnc N' L)) (synthesis h M' N'))
H21 : synthesis h (inv K) (inv L)
H20 : eq N0 N
H19 : eq M0 (MEnc M' K)
H18 : h M N
M0,N0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N' L)
M,N,M',K,L,N' : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
forall (_ : inclusion g (analysis_def g)) (_ : inclusion (analysis (analysis_def g)) (analysis_def g)), analysis_def g M' N'
+++++
unfold inclusion in |- *.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
unfold le_h in H1.
unfold inclusion in H1.
generalize (H1 (inv K) (inv L) H15).
intro.
elim H11.
intros.
unfold enc_analysis_left in H22.
rewrite <- H14 in H18.
elim (H22 M N H18 M' K H14 L H21).
intro N'.
intro.
exists N'.
elim H24.
intros.
split.
trivial.
rewrite H14 in H13.
rewrite H25 in H13.
elim (irreducible_enc g M' N' K L).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
elim (H27 (H29 (MEnc M' K) (MEnc N' L) H13)).
intros.
generalize (ana_h_equiv_irr_h g).
unfold equiv_h in |- *.
intro.
elim H33.
intros.
unfold le_h in H34.
unfold inclusion in H34.
fold (inclusion (irreducible g) g) in H30.
generalize (inclusion_impl_le_h (irreducible g) g H30).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
apply H36.
apply H34.
apply SynInc.
generalize (analysis_is_analysis g).
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.
elim H37.
intros.
elim H38.
unfold stable_analysis in |- *.
unfold inclusion in |- *.

*****
H39 : forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\ninclusion (analysis_def g) h'
H38 : and (inclusion g (analysis_def g)) (stable_analysis (analysis_def g))
H37 : and\n (and (inclusion g (analysis_def g))\n (stable_analysis (analysis_def g)))\n (forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\n inclusion (analysis_def g) h')
H36 : forall (M N : Msg) (_ : synthesis (irreducible g) M N), synthesis g M N
H35 : le_h (irreducible g) (analysis_def g)
H34 : forall (M N : Msg) (_ : synthesis (analysis_def g) M N),\nsynthesis (irreducible g) M N
H33 : and (le_h (analysis_def g) (irreducible g))\n (le_h (irreducible g) (analysis_def g))
H32 : or (not (synthesis (analysis_def g) M' N'))\n (not (synthesis (analysis_def g) K L))
H31 : analysis_def g (MEnc M' K) (MEnc N' L)
H30 : inclusion (irreducible g) g
H29 : forall (M N : Msg) (_ : g M N), irreducible g M N
H28 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N' L))\n (or (not (synthesis (analysis_def g) M' N'))\n (not (synthesis (analysis_def g) K L))),\nirreducible g (MEnc M' K) (MEnc N' L)
H27 : forall _ : irreducible g (MEnc M' K) (MEnc N' L),\nand (analysis_def g (MEnc M' K) (MEnc N' L))\n (or (not (synthesis (analysis_def g) M' N'))\n (not (synthesis (analysis_def g) K L)))
H26 : synthesis h M' N'
H25 : eq N (MEnc N' L)
H24 : and (eq N (MEnc N' L)) (synthesis h M' N')
H23 : injective_inv_left h
H22 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (L : Msg) (_ : synthesis h (inv K) (inv L)),\nex (fun N' : Msg => and (eq N (MEnc N' L)) (synthesis h M' N'))
H21 : synthesis h (inv K) (inv L)
H20 : eq N0 N
H19 : eq M0 (MEnc M' K)
H18 : h M N
M0,N0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N' L)
M,N,M',K,L,N' : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
forall (_ : forall (M N : Msg) (_ : g M N), analysis_def g M N) (_ : forall (M N : Msg) (_ : analysis (analysis_def g) M N), analysis_def g M N), analysis_def g M' N'
+++++
intros.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
unfold le_h in H1.
unfold inclusion in H1.
generalize (H1 (inv K) (inv L) H15).
intro.
elim H11.
intros.
unfold enc_analysis_left in H22.
rewrite <- H14 in H18.
elim (H22 M N H18 M' K H14 L H21).
intro N'.
intro.
exists N'.
elim H24.
intros.
split.
trivial.
rewrite H14 in H13.
rewrite H25 in H13.
elim (irreducible_enc g M' N' K L).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
elim (H27 (H29 (MEnc M' K) (MEnc N' L) H13)).
intros.
generalize (ana_h_equiv_irr_h g).
unfold equiv_h in |- *.
intro.
elim H33.
intros.
unfold le_h in H34.
unfold inclusion in H34.
fold (inclusion (irreducible g) g) in H30.
generalize (inclusion_impl_le_h (irreducible g) g H30).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
apply H36.
apply H34.
apply SynInc.
generalize (analysis_is_analysis g).
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.
elim H37.
intros.
elim H38.
unfold stable_analysis in |- *.
unfold inclusion in |- *.
intros.

*****
H41 : forall (M N : Msg) (_ : analysis (analysis_def g) M N),\nanalysis_def g M N
H40 : forall (M N : Msg) (_ : g M N), analysis_def g M N
H39 : forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\ninclusion (analysis_def g) h'
H38 : and (inclusion g (analysis_def g)) (stable_analysis (analysis_def g))
H37 : and\n (and (inclusion g (analysis_def g))\n (stable_analysis (analysis_def g)))\n (forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\n inclusion (analysis_def g) h')
H36 : forall (M N : Msg) (_ : synthesis (irreducible g) M N), synthesis g M N
H35 : le_h (irreducible g) (analysis_def g)
H34 : forall (M N : Msg) (_ : synthesis (analysis_def g) M N),\nsynthesis (irreducible g) M N
H33 : and (le_h (analysis_def g) (irreducible g))\n (le_h (irreducible g) (analysis_def g))
H32 : or (not (synthesis (analysis_def g) M' N'))\n (not (synthesis (analysis_def g) K L))
H31 : analysis_def g (MEnc M' K) (MEnc N' L)
H30 : inclusion (irreducible g) g
H29 : forall (M N : Msg) (_ : g M N), irreducible g M N
H28 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N' L))\n (or (not (synthesis (analysis_def g) M' N'))\n (not (synthesis (analysis_def g) K L))),\nirreducible g (MEnc M' K) (MEnc N' L)
H27 : forall _ : irreducible g (MEnc M' K) (MEnc N' L),\nand (analysis_def g (MEnc M' K) (MEnc N' L))\n (or (not (synthesis (analysis_def g) M' N'))\n (not (synthesis (analysis_def g) K L)))
H26 : synthesis h M' N'
H25 : eq N (MEnc N' L)
H24 : and (eq N (MEnc N' L)) (synthesis h M' N')
H23 : injective_inv_left h
H22 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (L : Msg) (_ : synthesis h (inv K) (inv L)),\nex (fun N' : Msg => and (eq N (MEnc N' L)) (synthesis h M' N'))
H21 : synthesis h (inv K) (inv L)
H20 : eq N0 N
H19 : eq M0 (MEnc M' K)
H18 : h M N
M0,N0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N' L)
M,N,M',K,L,N' : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
analysis_def g M' N'
+++++
apply H41.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
unfold le_h in H1.
unfold inclusion in H1.
generalize (H1 (inv K) (inv L) H15).
intro.
elim H11.
intros.
unfold enc_analysis_left in H22.
rewrite <- H14 in H18.
elim (H22 M N H18 M' K H14 L H21).
intro N'.
intro.
exists N'.
elim H24.
intros.
split.
trivial.
rewrite H14 in H13.
rewrite H25 in H13.
elim (irreducible_enc g M' N' K L).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
elim (H27 (H29 (MEnc M' K) (MEnc N' L) H13)).
intros.
generalize (ana_h_equiv_irr_h g).
unfold equiv_h in |- *.
intro.
elim H33.
intros.
unfold le_h in H34.
unfold inclusion in H34.
fold (inclusion (irreducible g) g) in H30.
generalize (inclusion_impl_le_h (irreducible g) g H30).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
apply H36.
apply H34.
apply SynInc.
generalize (analysis_is_analysis g).
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.
elim H37.
intros.
elim H38.
unfold stable_analysis in |- *.
unfold inclusion in |- *.
intros.
apply H41.

*****
H41 : forall (M N : Msg) (_ : analysis (analysis_def g) M N),\nanalysis_def g M N
H40 : forall (M N : Msg) (_ : g M N), analysis_def g M N
H39 : forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\ninclusion (analysis_def g) h'
H38 : and (inclusion g (analysis_def g)) (stable_analysis (analysis_def g))
H37 : and\n (and (inclusion g (analysis_def g))\n (stable_analysis (analysis_def g)))\n (forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\n inclusion (analysis_def g) h')
H36 : forall (M N : Msg) (_ : synthesis (irreducible g) M N), synthesis g M N
H35 : le_h (irreducible g) (analysis_def g)
H34 : forall (M N : Msg) (_ : synthesis (analysis_def g) M N),\nsynthesis (irreducible g) M N
H33 : and (le_h (analysis_def g) (irreducible g))\n (le_h (irreducible g) (analysis_def g))
H32 : or (not (synthesis (analysis_def g) M' N'))\n (not (synthesis (analysis_def g) K L))
H31 : analysis_def g (MEnc M' K) (MEnc N' L)
H30 : inclusion (irreducible g) g
H29 : forall (M N : Msg) (_ : g M N), irreducible g M N
H28 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N' L))\n (or (not (synthesis (analysis_def g) M' N'))\n (not (synthesis (analysis_def g) K L))),\nirreducible g (MEnc M' K) (MEnc N' L)
H27 : forall _ : irreducible g (MEnc M' K) (MEnc N' L),\nand (analysis_def g (MEnc M' K) (MEnc N' L))\n (or (not (synthesis (analysis_def g) M' N'))\n (not (synthesis (analysis_def g) K L)))
H26 : synthesis h M' N'
H25 : eq N (MEnc N' L)
H24 : and (eq N (MEnc N' L)) (synthesis h M' N')
H23 : injective_inv_left h
H22 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (L : Msg) (_ : synthesis h (inv K) (inv L)),\nex (fun N' : Msg => and (eq N (MEnc N' L)) (synthesis h M' N'))
H21 : synthesis h (inv K) (inv L)
H20 : eq N0 N
H19 : eq M0 (MEnc M' K)
H18 : h M N
M0,N0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N' L)
M,N,M',K,L,N' : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
analysis (analysis_def g) M' N'
+++++
apply (AnaDec (analysis_def g) M' N' K L).
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
unfold le_h in H1.
unfold inclusion in H1.
generalize (H1 (inv K) (inv L) H15).
intro.
elim H11.
intros.
unfold enc_analysis_left in H22.
rewrite <- H14 in H18.
elim (H22 M N H18 M' K H14 L H21).
intro N'.
intro.
exists N'.
elim H24.
intros.
split.
trivial.
rewrite H14 in H13.
rewrite H25 in H13.
elim (irreducible_enc g M' N' K L).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
elim (H27 (H29 (MEnc M' K) (MEnc N' L) H13)).
intros.
generalize (ana_h_equiv_irr_h g).
unfold equiv_h in |- *.
intro.
elim H33.
intros.
unfold le_h in H34.
unfold inclusion in H34.
fold (inclusion (irreducible g) g) in H30.
generalize (inclusion_impl_le_h (irreducible g) g H30).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
apply H36.
apply H34.
apply SynInc.
generalize (analysis_is_analysis g).
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.
elim H37.
intros.
elim H38.
unfold stable_analysis in |- *.
unfold inclusion in |- *.
intros.
apply H41.
apply (AnaDec (analysis_def g) M' N' K L).

*****
H41 : forall (M N : Msg) (_ : analysis (analysis_def g) M N),\nanalysis_def g M N
H40 : forall (M N : Msg) (_ : g M N), analysis_def g M N
H39 : forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\ninclusion (analysis_def g) h'
H38 : and (inclusion g (analysis_def g)) (stable_analysis (analysis_def g))
H37 : and\n (and (inclusion g (analysis_def g))\n (stable_analysis (analysis_def g)))\n (forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\n inclusion (analysis_def g) h')
H36 : forall (M N : Msg) (_ : synthesis (irreducible g) M N), synthesis g M N
H35 : le_h (irreducible g) (analysis_def g)
H34 : forall (M N : Msg) (_ : synthesis (analysis_def g) M N),\nsynthesis (irreducible g) M N
H33 : and (le_h (analysis_def g) (irreducible g))\n (le_h (irreducible g) (analysis_def g))
H32 : or (not (synthesis (analysis_def g) M' N'))\n (not (synthesis (analysis_def g) K L))
H31 : analysis_def g (MEnc M' K) (MEnc N' L)
H30 : inclusion (irreducible g) g
H29 : forall (M N : Msg) (_ : g M N), irreducible g M N
H28 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N' L))\n (or (not (synthesis (analysis_def g) M' N'))\n (not (synthesis (analysis_def g) K L))),\nirreducible g (MEnc M' K) (MEnc N' L)
H27 : forall _ : irreducible g (MEnc M' K) (MEnc N' L),\nand (analysis_def g (MEnc M' K) (MEnc N' L))\n (or (not (synthesis (analysis_def g) M' N'))\n (not (synthesis (analysis_def g) K L)))
H26 : synthesis h M' N'
H25 : eq N (MEnc N' L)
H24 : and (eq N (MEnc N' L)) (synthesis h M' N')
H23 : injective_inv_left h
H22 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (L : Msg) (_ : synthesis h (inv K) (inv L)),\nex (fun N' : Msg => and (eq N (MEnc N' L)) (synthesis h M' N'))
H21 : synthesis h (inv K) (inv L)
H20 : eq N0 N
H19 : eq M0 (MEnc M' K)
H18 : h M N
M0,N0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N' L)
M,N,M',K,L,N' : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
analysis (analysis_def g) (MEnc M' K) (MEnc N' L)
+++++
apply AnaInc.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
unfold le_h in H1.
unfold inclusion in H1.
generalize (H1 (inv K) (inv L) H15).
intro.
elim H11.
intros.
unfold enc_analysis_left in H22.
rewrite <- H14 in H18.
elim (H22 M N H18 M' K H14 L H21).
intro N'.
intro.
exists N'.
elim H24.
intros.
split.
trivial.
rewrite H14 in H13.
rewrite H25 in H13.
elim (irreducible_enc g M' N' K L).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
elim (H27 (H29 (MEnc M' K) (MEnc N' L) H13)).
intros.
generalize (ana_h_equiv_irr_h g).
unfold equiv_h in |- *.
intro.
elim H33.
intros.
unfold le_h in H34.
unfold inclusion in H34.
fold (inclusion (irreducible g) g) in H30.
generalize (inclusion_impl_le_h (irreducible g) g H30).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
apply H36.
apply H34.
apply SynInc.
generalize (analysis_is_analysis g).
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.
elim H37.
intros.
elim H38.
unfold stable_analysis in |- *.
unfold inclusion in |- *.
intros.
apply H41.
apply (AnaDec (analysis_def g) M' N' K L).
apply AnaInc.

*****
H41 : forall (M N : Msg) (_ : analysis (analysis_def g) M N),\nanalysis_def g M N
H40 : forall (M N : Msg) (_ : g M N), analysis_def g M N
H39 : forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\ninclusion (analysis_def g) h'
H38 : and (inclusion g (analysis_def g)) (stable_analysis (analysis_def g))
H37 : and\n (and (inclusion g (analysis_def g))\n (stable_analysis (analysis_def g)))\n (forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\n inclusion (analysis_def g) h')
H36 : forall (M N : Msg) (_ : synthesis (irreducible g) M N), synthesis g M N
H35 : le_h (irreducible g) (analysis_def g)
H34 : forall (M N : Msg) (_ : synthesis (analysis_def g) M N),\nsynthesis (irreducible g) M N
H33 : and (le_h (analysis_def g) (irreducible g))\n (le_h (irreducible g) (analysis_def g))
H32 : or (not (synthesis (analysis_def g) M' N'))\n (not (synthesis (analysis_def g) K L))
H31 : analysis_def g (MEnc M' K) (MEnc N' L)
H30 : inclusion (irreducible g) g
H29 : forall (M N : Msg) (_ : g M N), irreducible g M N
H28 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N' L))\n (or (not (synthesis (analysis_def g) M' N'))\n (not (synthesis (analysis_def g) K L))),\nirreducible g (MEnc M' K) (MEnc N' L)
H27 : forall _ : irreducible g (MEnc M' K) (MEnc N' L),\nand (analysis_def g (MEnc M' K) (MEnc N' L))\n (or (not (synthesis (analysis_def g) M' N'))\n (not (synthesis (analysis_def g) K L)))
H26 : synthesis h M' N'
H25 : eq N (MEnc N' L)
H24 : and (eq N (MEnc N' L)) (synthesis h M' N')
H23 : injective_inv_left h
H22 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (L : Msg) (_ : synthesis h (inv K) (inv L)),\nex (fun N' : Msg => and (eq N (MEnc N' L)) (synthesis h M' N'))
H21 : synthesis h (inv K) (inv L)
H20 : eq N0 N
H19 : eq M0 (MEnc M' K)
H18 : h M N
M0,N0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N' L)
M,N,M',K,L,N' : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
analysis_def g (MEnc M' K) (MEnc N' L)
+++++
trivial.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
unfold le_h in H1.
unfold inclusion in H1.
generalize (H1 (inv K) (inv L) H15).
intro.
elim H11.
intros.
unfold enc_analysis_left in H22.
rewrite <- H14 in H18.
elim (H22 M N H18 M' K H14 L H21).
intro N'.
intro.
exists N'.
elim H24.
intros.
split.
trivial.
rewrite H14 in H13.
rewrite H25 in H13.
elim (irreducible_enc g M' N' K L).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
elim (H27 (H29 (MEnc M' K) (MEnc N' L) H13)).
intros.
generalize (ana_h_equiv_irr_h g).
unfold equiv_h in |- *.
intro.
elim H33.
intros.
unfold le_h in H34.
unfold inclusion in H34.
fold (inclusion (irreducible g) g) in H30.
generalize (inclusion_impl_le_h (irreducible g) g H30).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
apply H36.
apply H34.
apply SynInc.
generalize (analysis_is_analysis g).
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.
elim H37.
intros.
elim H38.
unfold stable_analysis in |- *.
unfold inclusion in |- *.
intros.
apply H41.
apply (AnaDec (analysis_def g) M' N' K L).

*****
H41 : forall (M N : Msg) (_ : analysis (analysis_def g) M N),\nanalysis_def g M N
H40 : forall (M N : Msg) (_ : g M N), analysis_def g M N
H39 : forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\ninclusion (analysis_def g) h'
H38 : and (inclusion g (analysis_def g)) (stable_analysis (analysis_def g))
H37 : and\n (and (inclusion g (analysis_def g))\n (stable_analysis (analysis_def g)))\n (forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\n inclusion (analysis_def g) h')
H36 : forall (M N : Msg) (_ : synthesis (irreducible g) M N), synthesis g M N
H35 : le_h (irreducible g) (analysis_def g)
H34 : forall (M N : Msg) (_ : synthesis (analysis_def g) M N),\nsynthesis (irreducible g) M N
H33 : and (le_h (analysis_def g) (irreducible g))\n (le_h (irreducible g) (analysis_def g))
H32 : or (not (synthesis (analysis_def g) M' N'))\n (not (synthesis (analysis_def g) K L))
H31 : analysis_def g (MEnc M' K) (MEnc N' L)
H30 : inclusion (irreducible g) g
H29 : forall (M N : Msg) (_ : g M N), irreducible g M N
H28 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N' L))\n (or (not (synthesis (analysis_def g) M' N'))\n (not (synthesis (analysis_def g) K L))),\nirreducible g (MEnc M' K) (MEnc N' L)
H27 : forall _ : irreducible g (MEnc M' K) (MEnc N' L),\nand (analysis_def g (MEnc M' K) (MEnc N' L))\n (or (not (synthesis (analysis_def g) M' N'))\n (not (synthesis (analysis_def g) K L)))
H26 : synthesis h M' N'
H25 : eq N (MEnc N' L)
H24 : and (eq N (MEnc N' L)) (synthesis h M' N')
H23 : injective_inv_left h
H22 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (L : Msg) (_ : synthesis h (inv K) (inv L)),\nex (fun N' : Msg => and (eq N (MEnc N' L)) (synthesis h M' N'))
H21 : synthesis h (inv K) (inv L)
H20 : eq N0 N
H19 : eq M0 (MEnc M' K)
H18 : h M N
M0,N0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N' L)
M,N,M',K,L,N' : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
synthesis (analysis_def g) (inv K) (inv L)
+++++
generalize (h_le_h_ana_h g).
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
unfold le_h in H1.
unfold inclusion in H1.
generalize (H1 (inv K) (inv L) H15).
intro.
elim H11.
intros.
unfold enc_analysis_left in H22.
rewrite <- H14 in H18.
elim (H22 M N H18 M' K H14 L H21).
intro N'.
intro.
exists N'.
elim H24.
intros.
split.
trivial.
rewrite H14 in H13.
rewrite H25 in H13.
elim (irreducible_enc g M' N' K L).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
elim (H27 (H29 (MEnc M' K) (MEnc N' L) H13)).
intros.
generalize (ana_h_equiv_irr_h g).
unfold equiv_h in |- *.
intro.
elim H33.
intros.
unfold le_h in H34.
unfold inclusion in H34.
fold (inclusion (irreducible g) g) in H30.
generalize (inclusion_impl_le_h (irreducible g) g H30).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
apply H36.
apply H34.
apply SynInc.
generalize (analysis_is_analysis g).
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.
elim H37.
intros.
elim H38.
unfold stable_analysis in |- *.
unfold inclusion in |- *.
intros.
apply H41.
apply (AnaDec (analysis_def g) M' N' K L).
generalize (h_le_h_ana_h g).

*****
H41 : forall (M N : Msg) (_ : analysis (analysis_def g) M N),\nanalysis_def g M N
H40 : forall (M N : Msg) (_ : g M N), analysis_def g M N
H39 : forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\ninclusion (analysis_def g) h'
H38 : and (inclusion g (analysis_def g)) (stable_analysis (analysis_def g))
H37 : and\n (and (inclusion g (analysis_def g))\n (stable_analysis (analysis_def g)))\n (forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\n inclusion (analysis_def g) h')
H36 : forall (M N : Msg) (_ : synthesis (irreducible g) M N), synthesis g M N
H35 : le_h (irreducible g) (analysis_def g)
H34 : forall (M N : Msg) (_ : synthesis (analysis_def g) M N),\nsynthesis (irreducible g) M N
H33 : and (le_h (analysis_def g) (irreducible g))\n (le_h (irreducible g) (analysis_def g))
H32 : or (not (synthesis (analysis_def g) M' N'))\n (not (synthesis (analysis_def g) K L))
H31 : analysis_def g (MEnc M' K) (MEnc N' L)
H30 : inclusion (irreducible g) g
H29 : forall (M N : Msg) (_ : g M N), irreducible g M N
H28 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N' L))\n (or (not (synthesis (analysis_def g) M' N'))\n (not (synthesis (analysis_def g) K L))),\nirreducible g (MEnc M' K) (MEnc N' L)
H27 : forall _ : irreducible g (MEnc M' K) (MEnc N' L),\nand (analysis_def g (MEnc M' K) (MEnc N' L))\n (or (not (synthesis (analysis_def g) M' N'))\n (not (synthesis (analysis_def g) K L)))
H26 : synthesis h M' N'
H25 : eq N (MEnc N' L)
H24 : and (eq N (MEnc N' L)) (synthesis h M' N')
H23 : injective_inv_left h
H22 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (L : Msg) (_ : synthesis h (inv K) (inv L)),\nex (fun N' : Msg => and (eq N (MEnc N' L)) (synthesis h M' N'))
H21 : synthesis h (inv K) (inv L)
H20 : eq N0 N
H19 : eq M0 (MEnc M' K)
H18 : h M N
M0,N0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N' L)
M,N,M',K,L,N' : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
forall _ : le_h g (analysis_def g), synthesis (analysis_def g) (inv K) (inv L)
+++++
unfold le_h in |- *.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
unfold le_h in H1.
unfold inclusion in H1.
generalize (H1 (inv K) (inv L) H15).
intro.
elim H11.
intros.
unfold enc_analysis_left in H22.
rewrite <- H14 in H18.
elim (H22 M N H18 M' K H14 L H21).
intro N'.
intro.
exists N'.
elim H24.
intros.
split.
trivial.
rewrite H14 in H13.
rewrite H25 in H13.
elim (irreducible_enc g M' N' K L).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
elim (H27 (H29 (MEnc M' K) (MEnc N' L) H13)).
intros.
generalize (ana_h_equiv_irr_h g).
unfold equiv_h in |- *.
intro.
elim H33.
intros.
unfold le_h in H34.
unfold inclusion in H34.
fold (inclusion (irreducible g) g) in H30.
generalize (inclusion_impl_le_h (irreducible g) g H30).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
apply H36.
apply H34.
apply SynInc.
generalize (analysis_is_analysis g).
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.
elim H37.
intros.
elim H38.
unfold stable_analysis in |- *.
unfold inclusion in |- *.
intros.
apply H41.
apply (AnaDec (analysis_def g) M' N' K L).
generalize (h_le_h_ana_h g).
unfold le_h in |- *.

*****
H41 : forall (M N : Msg) (_ : analysis (analysis_def g) M N),\nanalysis_def g M N
H40 : forall (M N : Msg) (_ : g M N), analysis_def g M N
H39 : forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\ninclusion (analysis_def g) h'
H38 : and (inclusion g (analysis_def g)) (stable_analysis (analysis_def g))
H37 : and\n (and (inclusion g (analysis_def g))\n (stable_analysis (analysis_def g)))\n (forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\n inclusion (analysis_def g) h')
H36 : forall (M N : Msg) (_ : synthesis (irreducible g) M N), synthesis g M N
H35 : le_h (irreducible g) (analysis_def g)
H34 : forall (M N : Msg) (_ : synthesis (analysis_def g) M N),\nsynthesis (irreducible g) M N
H33 : and (le_h (analysis_def g) (irreducible g))\n (le_h (irreducible g) (analysis_def g))
H32 : or (not (synthesis (analysis_def g) M' N'))\n (not (synthesis (analysis_def g) K L))
H31 : analysis_def g (MEnc M' K) (MEnc N' L)
H30 : inclusion (irreducible g) g
H29 : forall (M N : Msg) (_ : g M N), irreducible g M N
H28 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N' L))\n (or (not (synthesis (analysis_def g) M' N'))\n (not (synthesis (analysis_def g) K L))),\nirreducible g (MEnc M' K) (MEnc N' L)
H27 : forall _ : irreducible g (MEnc M' K) (MEnc N' L),\nand (analysis_def g (MEnc M' K) (MEnc N' L))\n (or (not (synthesis (analysis_def g) M' N'))\n (not (synthesis (analysis_def g) K L)))
H26 : synthesis h M' N'
H25 : eq N (MEnc N' L)
H24 : and (eq N (MEnc N' L)) (synthesis h M' N')
H23 : injective_inv_left h
H22 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (L : Msg) (_ : synthesis h (inv K) (inv L)),\nex (fun N' : Msg => and (eq N (MEnc N' L)) (synthesis h M' N'))
H21 : synthesis h (inv K) (inv L)
H20 : eq N0 N
H19 : eq M0 (MEnc M' K)
H18 : h M N
M0,N0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N' L)
M,N,M',K,L,N' : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
forall _ : inclusion (synthesis g) (synthesis (analysis_def g)), synthesis (analysis_def g) (inv K) (inv L)
+++++
unfold inclusion in |- *.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
unfold le_h in H1.
unfold inclusion in H1.
generalize (H1 (inv K) (inv L) H15).
intro.
elim H11.
intros.
unfold enc_analysis_left in H22.
rewrite <- H14 in H18.
elim (H22 M N H18 M' K H14 L H21).
intro N'.
intro.
exists N'.
elim H24.
intros.
split.
trivial.
rewrite H14 in H13.
rewrite H25 in H13.
elim (irreducible_enc g M' N' K L).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
elim (H27 (H29 (MEnc M' K) (MEnc N' L) H13)).
intros.
generalize (ana_h_equiv_irr_h g).
unfold equiv_h in |- *.
intro.
elim H33.
intros.
unfold le_h in H34.
unfold inclusion in H34.
fold (inclusion (irreducible g) g) in H30.
generalize (inclusion_impl_le_h (irreducible g) g H30).
unfold le_h in |- *.
unfold inclusion in |- *.
intro.
apply H36.
apply H34.
apply SynInc.
generalize (analysis_is_analysis g).
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.
elim H37.
intros.
elim H38.
unfold stable_analysis in |- *.
unfold inclusion in |- *.
intros.
apply H41.
apply (AnaDec (analysis_def g) M' N' K L).
generalize (h_le_h_ana_h g).
unfold le_h in |- *.
unfold inclusion in |- *.

*****
H41 : forall (M N : Msg) (_ : analysis (analysis_def g) M N),\nanalysis_def g M N
H40 : forall (M N : Msg) (_ : g M N), analysis_def g M N
H39 : forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\ninclusion (analysis_def g) h'
H38 : and (inclusion g (analysis_def g)) (stable_analysis (analysis_def g))
H37 : and\n (and (inclusion g (analysis_def g))\n (stable_analysis (analysis_def g)))\n (forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\n inclusion (analysis_def g) h')
H36 : forall (M N : Msg) (_ : synthesis (irreducible g) M N), synthesis g M N
H35 : le_h (irreducible g) (analysis_def g)
H34 : forall (M N : Msg) (_ : synthesis (analysis_def g) M N),\nsynthesis (irreducible g) M N
H33 : and (le_h (analysis_def g) (irreducible g))\n (le_h (irreducible g) (analysis_def g))
H32 : or (not (synthesis (analysis_def g) M' N'))\n (not (synthesis (analysis_def g) K L))
H31 : analysis_def g (MEnc M' K) (MEnc N' L)
H30 : inclusion (irreducible g) g
H29 : forall (M N : Msg) (_ : g M N), irreducible g M N
H28 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N' L))\n (or (not (synthesis (analysis_def g) M' N'))\n (not (synthesis (analysis_def g) K L))),\nirreducible g (MEnc M' K) (MEnc N' L)
H27 : forall _ : irreducible g (MEnc M' K) (MEnc N' L),\nand (analysis_def g (MEnc M' K) (MEnc N' L))\n (or (not (synthesis (analysis_def g) M' N'))\n (not (synthesis (analysis_def g) K L)))
H26 : synthesis h M' N'
H25 : eq N (MEnc N' L)
H24 : and (eq N (MEnc N' L)) (synthesis h M' N')
H23 : injective_inv_left h
H22 : forall (M N : Msg) (_ : h M N) (M' K : Msg) (_ : eq M (MEnc M' K))\n (L : Msg) (_ : synthesis h (inv K) (inv L)),\nex (fun N' : Msg => and (eq N (MEnc N' L)) (synthesis h M' N'))
H21 : synthesis h (inv K) (inv L)
H20 : eq N0 N
H19 : eq M0 (MEnc M' K)
H18 : h M N
M0,N0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N' L)
M,N,M',K,L,N' : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
forall _ : forall (M N : Msg) (_ : synthesis g M N), synthesis (analysis_def g) M N, synthesis (analysis_def g) (inv K) (inv L)
+++++
auto.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.

*****
H21 : eq (MEnc N0 L0) N
H19 : eq K0 K
H18 : eq M0 M'
H22 : synthesis h K L0
H20 : synthesis h M' N0
M0,N0,K0,L0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
L : Msg
H14 : eq M (MEnc M' K)
M',K : Msg
H13 : g M N
M,N : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
ex (fun N' : Msg => and (eq (MEnc N0 L0) (MEnc N' L)) (synthesis g M' N'))
+++++
exists N0.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
exists N0.

*****
H21 : eq (MEnc N0 L0) N
H19 : eq K0 K
H18 : eq M0 M'
H22 : synthesis h K L0
H20 : synthesis h M' N0
M0,N0,K0,L0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
L : Msg
H14 : eq M (MEnc M' K)
M',K : Msg
H13 : g M N
M,N : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
and (eq (MEnc N0 L0) (MEnc N0 L)) (synthesis g M' N0)
+++++
split.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
exists N0.
split.

*****
H21 : eq (MEnc N0 L0) N
H19 : eq K0 K
H18 : eq M0 M'
H22 : synthesis h K L0
H20 : synthesis h M' N0
M0,N0,K0,L0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
L : Msg
H14 : eq M (MEnc M' K)
M',K : Msg
H13 : g M N
M,N : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
eq (MEnc N0 L0) (MEnc N0 L)
+++++
cut (L = L0).
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
exists N0.
split.
cut (L = L0).

*****
H21 : eq (MEnc N0 L0) N
H19 : eq K0 K
H18 : eq M0 M'
H22 : synthesis h K L0
H20 : synthesis h M' N0
M0,N0,K0,L0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
L : Msg
H14 : eq M (MEnc M' K)
M',K : Msg
H13 : g M N
M,N : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
forall _ : eq L L0, eq (MEnc N0 L0) (MEnc N0 L)
+++++
intro.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
exists N0.
split.
cut (L = L0).
intro.

*****
H23 : eq L L0
H21 : eq (MEnc N0 L0) N
H19 : eq K0 K
H18 : eq M0 M'
H22 : synthesis h K L0
H20 : synthesis h M' N0
M0,N0,K0,L0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
L : Msg
H14 : eq M (MEnc M' K)
M',K : Msg
H13 : g M N
M,N : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
eq (MEnc N0 L0) (MEnc N0 L)
+++++
rewrite H23.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
exists N0.
split.
cut (L = L0).
intro.
rewrite H23.

*****
H23 : eq L L0
H21 : eq (MEnc N0 L0) N
H19 : eq K0 K
H18 : eq M0 M'
H22 : synthesis h K L0
H20 : synthesis h M' N0
M0,N0,K0,L0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
L : Msg
H14 : eq M (MEnc M' K)
M',K : Msg
H13 : g M N
M,N : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
eq (MEnc N0 L0) (MEnc N0 L0)
+++++
trivial.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
exists N0.
split.
cut (L = L0).

*****
H21 : eq (MEnc N0 L0) N
H19 : eq K0 K
H18 : eq M0 M'
H22 : synthesis h K L0
H20 : synthesis h M' N0
M0,N0,K0,L0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
L : Msg
H14 : eq M (MEnc M' K)
M',K : Msg
H13 : g M N
M,N : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
eq L L0
+++++
unfold le_h in H1.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
exists N0.
split.
cut (L = L0).
unfold le_h in H1.

*****
H21 : eq (MEnc N0 L0) N
H19 : eq K0 K
H18 : eq M0 M'
H22 : synthesis h K L0
H20 : synthesis h M' N0
M0,N0,K0,L0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
L : Msg
H14 : eq M (MEnc M' K)
M',K : Msg
H13 : g M N
M,N : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : inclusion (synthesis g) (synthesis h)
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
eq L L0
+++++
unfold inclusion in H1.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
exists N0.
split.
cut (L = L0).
unfold le_h in H1.
unfold inclusion in H1.

*****
H21 : eq (MEnc N0 L0) N
H19 : eq K0 K
H18 : eq M0 M'
H22 : synthesis h K L0
H20 : synthesis h M' N0
M0,N0,K0,L0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
L : Msg
H14 : eq M (MEnc M' K)
M',K : Msg
H13 : g M N
M,N : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
eq L L0
+++++
generalize (H1 (inv K) (inv L) H15).
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
exists N0.
split.
cut (L = L0).
unfold le_h in H1.
unfold inclusion in H1.
generalize (H1 (inv K) (inv L) H15).

*****
H21 : eq (MEnc N0 L0) N
H19 : eq K0 K
H18 : eq M0 M'
H22 : synthesis h K L0
H20 : synthesis h M' N0
M0,N0,K0,L0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
L : Msg
H14 : eq M (MEnc M' K)
M',K : Msg
H13 : g M N
M,N : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
forall _ : synthesis h (inv K) (inv L), eq L L0
+++++
intro.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
exists N0.
split.
cut (L = L0).
unfold le_h in H1.
unfold inclusion in H1.
generalize (H1 (inv K) (inv L) H15).
intro.

*****
H23 : synthesis h (inv K) (inv L)
H21 : eq (MEnc N0 L0) N
H19 : eq K0 K
H18 : eq M0 M'
H22 : synthesis h K L0
H20 : synthesis h M' N0
M0,N0,K0,L0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
L : Msg
H14 : eq M (MEnc M' K)
M',K : Msg
H13 : g M N
M,N : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
eq L L0
+++++
elim H11.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
exists N0.
split.
cut (L = L0).
unfold le_h in H1.
unfold inclusion in H1.
generalize (H1 (inv K) (inv L) H15).
intro.
elim H11.

*****
H23 : synthesis h (inv K) (inv L)
H21 : eq (MEnc N0 L0) N
H19 : eq K0 K
H18 : eq M0 M'
H22 : synthesis h K L0
H20 : synthesis h M' N0
M0,N0,K0,L0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
L : Msg
H14 : eq M (MEnc M' K)
M',K : Msg
H13 : g M N
M,N : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
forall (_ : enc_analysis_left h) (_ : injective_inv_left h), eq L L0
+++++
intros.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
exists N0.
split.
cut (L = L0).
unfold le_h in H1.
unfold inclusion in H1.
generalize (H1 (inv K) (inv L) H15).
intro.
elim H11.
intros.

*****
H25 : injective_inv_left h
H24 : enc_analysis_left h
H23 : synthesis h (inv K) (inv L)
H21 : eq (MEnc N0 L0) N
H19 : eq K0 K
H18 : eq M0 M'
H22 : synthesis h K L0
H20 : synthesis h M' N0
M0,N0,K0,L0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
L : Msg
H14 : eq M (MEnc M' K)
M',K : Msg
H13 : g M N
M,N : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
eq L L0
+++++
generalize (inj_inv_left_syn h H4 H10 H6 H8 H25).
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
exists N0.
split.
cut (L = L0).
unfold le_h in H1.
unfold inclusion in H1.
generalize (H1 (inv K) (inv L) H15).
intro.
elim H11.
intros.
generalize (inj_inv_left_syn h H4 H10 H6 H8 H25).

*****
H25 : injective_inv_left h
H24 : enc_analysis_left h
H23 : synthesis h (inv K) (inv L)
H21 : eq (MEnc N0 L0) N
H19 : eq K0 K
H18 : eq M0 M'
H22 : synthesis h K L0
H20 : synthesis h M' N0
M0,N0,K0,L0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
L : Msg
H14 : eq M (MEnc M' K)
M',K : Msg
H13 : g M N
M,N : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
forall _ : injective_inv_left (synthesis h), eq L L0
+++++
unfold injective_inv_left in |- *.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
exists N0.
split.
cut (L = L0).
unfold le_h in H1.
unfold inclusion in H1.
generalize (H1 (inv K) (inv L) H15).
intro.
elim H11.
intros.
generalize (inj_inv_left_syn h H4 H10 H6 H8 H25).
unfold injective_inv_left in |- *.

*****
H25 : injective_inv_left h
H24 : enc_analysis_left h
H23 : synthesis h (inv K) (inv L)
H21 : eq (MEnc N0 L0) N
H19 : eq K0 K
H18 : eq M0 M'
H22 : synthesis h K L0
H20 : synthesis h M' N0
M0,N0,K0,L0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
L : Msg
H14 : eq M (MEnc M' K)
M',K : Msg
H13 : g M N
M,N : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
forall _ : forall (M N : Msg) (_ : synthesis h M N) (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M' (inv M)), eq N' (inv N), eq L L0
+++++
intros.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
exists N0.
split.
cut (L = L0).
unfold le_h in H1.
unfold inclusion in H1.
generalize (H1 (inv K) (inv L) H15).
intro.
elim H11.
intros.
generalize (inj_inv_left_syn h H4 H10 H6 H8 H25).
unfold injective_inv_left in |- *.
intros.

*****
H26 : forall (M N : Msg) (_ : synthesis h M N) (M' N' : Msg)\n (_ : synthesis h M' N') (_ : eq M' (inv M)), eq N' (inv N)
H25 : injective_inv_left h
H24 : enc_analysis_left h
H23 : synthesis h (inv K) (inv L)
H21 : eq (MEnc N0 L0) N
H19 : eq K0 K
H18 : eq M0 M'
H22 : synthesis h K L0
H20 : synthesis h M' N0
M0,N0,K0,L0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
L : Msg
H14 : eq M (MEnc M' K)
M',K : Msg
H13 : g M N
M,N : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
eq L L0
+++++
generalize (H26 K L0 H22 (inv K) (inv L) H23).
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
exists N0.
split.
cut (L = L0).
unfold le_h in H1.
unfold inclusion in H1.
generalize (H1 (inv K) (inv L) H15).
intro.
elim H11.
intros.
generalize (inj_inv_left_syn h H4 H10 H6 H8 H25).
unfold injective_inv_left in |- *.
intros.
generalize (H26 K L0 H22 (inv K) (inv L) H23).

*****
H26 : forall (M N : Msg) (_ : synthesis h M N) (M' N' : Msg)\n (_ : synthesis h M' N') (_ : eq M' (inv M)), eq N' (inv N)
H25 : injective_inv_left h
H24 : enc_analysis_left h
H23 : synthesis h (inv K) (inv L)
H21 : eq (MEnc N0 L0) N
H19 : eq K0 K
H18 : eq M0 M'
H22 : synthesis h K L0
H20 : synthesis h M' N0
M0,N0,K0,L0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
L : Msg
H14 : eq M (MEnc M' K)
M',K : Msg
H13 : g M N
M,N : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
forall _ : forall _ : eq (inv K) (inv K), eq (inv L) (inv L0), eq L L0
+++++
intros.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
exists N0.
split.
cut (L = L0).
unfold le_h in H1.
unfold inclusion in H1.
generalize (H1 (inv K) (inv L) H15).
intro.
elim H11.
intros.
generalize (inj_inv_left_syn h H4 H10 H6 H8 H25).
unfold injective_inv_left in |- *.
intros.
generalize (H26 K L0 H22 (inv K) (inv L) H23).
intros.

*****
H27 : forall _ : eq (inv K) (inv K), eq (inv L) (inv L0)
H26 : forall (M N : Msg) (_ : synthesis h M N) (M' N' : Msg)\n (_ : synthesis h M' N') (_ : eq M' (inv M)), eq N' (inv N)
H25 : injective_inv_left h
H24 : enc_analysis_left h
H23 : synthesis h (inv K) (inv L)
H21 : eq (MEnc N0 L0) N
H19 : eq K0 K
H18 : eq M0 M'
H22 : synthesis h K L0
H20 : synthesis h M' N0
M0,N0,K0,L0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
L : Msg
H14 : eq M (MEnc M' K)
M',K : Msg
H13 : g M N
M,N : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
eq L L0
+++++
cut (inv K = inv K).
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
exists N0.
split.
cut (L = L0).
unfold le_h in H1.
unfold inclusion in H1.
generalize (H1 (inv K) (inv L) H15).
intro.
elim H11.
intros.
generalize (inj_inv_left_syn h H4 H10 H6 H8 H25).
unfold injective_inv_left in |- *.
intros.
generalize (H26 K L0 H22 (inv K) (inv L) H23).
intros.
cut (inv K = inv K).

*****
H27 : forall _ : eq (inv K) (inv K), eq (inv L) (inv L0)
H26 : forall (M N : Msg) (_ : synthesis h M N) (M' N' : Msg)\n (_ : synthesis h M' N') (_ : eq M' (inv M)), eq N' (inv N)
H25 : injective_inv_left h
H24 : enc_analysis_left h
H23 : synthesis h (inv K) (inv L)
H21 : eq (MEnc N0 L0) N
H19 : eq K0 K
H18 : eq M0 M'
H22 : synthesis h K L0
H20 : synthesis h M' N0
M0,N0,K0,L0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
L : Msg
H14 : eq M (MEnc M' K)
M',K : Msg
H13 : g M N
M,N : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
forall _ : eq (inv K) (inv K), eq L L0
+++++
trivial.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
exists N0.
split.
cut (L = L0).
unfold le_h in H1.
unfold inclusion in H1.
generalize (H1 (inv K) (inv L) H15).
intro.
elim H11.
intros.
generalize (inj_inv_left_syn h H4 H10 H6 H8 H25).
unfold injective_inv_left in |- *.
intros.
generalize (H26 K L0 H22 (inv K) (inv L) H23).
intros.
cut (inv K = inv K).
trivial.

*****
H27 : forall _ : eq (inv K) (inv K), eq (inv L) (inv L0)
H26 : forall (M N : Msg) (_ : synthesis h M N) (M' N' : Msg)\n (_ : synthesis h M' N') (_ : eq M' (inv M)), eq N' (inv N)
H25 : injective_inv_left h
H24 : enc_analysis_left h
H23 : synthesis h (inv K) (inv L)
H21 : eq (MEnc N0 L0) N
H19 : eq K0 K
H18 : eq M0 M'
H22 : synthesis h K L0
H20 : synthesis h M' N0
M0,N0,K0,L0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
L : Msg
H14 : eq M (MEnc M' K)
M',K : Msg
H13 : g M N
M,N : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
forall _ : eq (inv K) (inv K), eq L L0
+++++
intro.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
exists N0.
split.
cut (L = L0).
unfold le_h in H1.
unfold inclusion in H1.
generalize (H1 (inv K) (inv L) H15).
intro.
elim H11.
intros.
generalize (inj_inv_left_syn h H4 H10 H6 H8 H25).
unfold injective_inv_left in |- *.
intros.
generalize (H26 K L0 H22 (inv K) (inv L) H23).
intros.
cut (inv K = inv K).
trivial.
intro.

*****
H28 : eq (inv K) (inv K)
H27 : forall _ : eq (inv K) (inv K), eq (inv L) (inv L0)
H26 : forall (M N : Msg) (_ : synthesis h M N) (M' N' : Msg)\n (_ : synthesis h M' N') (_ : eq M' (inv M)), eq N' (inv N)
H25 : injective_inv_left h
H24 : enc_analysis_left h
H23 : synthesis h (inv K) (inv L)
H21 : eq (MEnc N0 L0) N
H19 : eq K0 K
H18 : eq M0 M'
H22 : synthesis h K L0
H20 : synthesis h M' N0
M0,N0,K0,L0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
L : Msg
H14 : eq M (MEnc M' K)
M',K : Msg
H13 : g M N
M,N : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
eq L L0
+++++
generalize (H27 H28).
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
exists N0.
split.
cut (L = L0).
unfold le_h in H1.
unfold inclusion in H1.
generalize (H1 (inv K) (inv L) H15).
intro.
elim H11.
intros.
generalize (inj_inv_left_syn h H4 H10 H6 H8 H25).
unfold injective_inv_left in |- *.
intros.
generalize (H26 K L0 H22 (inv K) (inv L) H23).
intros.
cut (inv K = inv K).
trivial.
intro.
generalize (H27 H28).

*****
H28 : eq (inv K) (inv K)
H27 : forall _ : eq (inv K) (inv K), eq (inv L) (inv L0)
H26 : forall (M N : Msg) (_ : synthesis h M N) (M' N' : Msg)\n (_ : synthesis h M' N') (_ : eq M' (inv M)), eq N' (inv N)
H25 : injective_inv_left h
H24 : enc_analysis_left h
H23 : synthesis h (inv K) (inv L)
H21 : eq (MEnc N0 L0) N
H19 : eq K0 K
H18 : eq M0 M'
H22 : synthesis h K L0
H20 : synthesis h M' N0
M0,N0,K0,L0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
L : Msg
H14 : eq M (MEnc M' K)
M',K : Msg
H13 : g M N
M,N : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
forall _ : eq (inv L) (inv L0), eq L L0
+++++
intro.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
exists N0.
split.
cut (L = L0).
unfold le_h in H1.
unfold inclusion in H1.
generalize (H1 (inv K) (inv L) H15).
intro.
elim H11.
intros.
generalize (inj_inv_left_syn h H4 H10 H6 H8 H25).
unfold injective_inv_left in |- *.
intros.
generalize (H26 K L0 H22 (inv K) (inv L) H23).
intros.
cut (inv K = inv K).
trivial.
intro.
generalize (H27 H28).
intro.

*****
H29 : eq (inv L) (inv L0)
H28 : eq (inv K) (inv K)
H27 : forall _ : eq (inv K) (inv K), eq (inv L) (inv L0)
H26 : forall (M N : Msg) (_ : synthesis h M N) (M' N' : Msg)\n (_ : synthesis h M' N') (_ : eq M' (inv M)), eq N' (inv N)
H25 : injective_inv_left h
H24 : enc_analysis_left h
H23 : synthesis h (inv K) (inv L)
H21 : eq (MEnc N0 L0) N
H19 : eq K0 K
H18 : eq M0 M'
H22 : synthesis h K L0
H20 : synthesis h M' N0
M0,N0,K0,L0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
L : Msg
H14 : eq M (MEnc M' K)
M',K : Msg
H13 : g M N
M,N : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
eq L L0
+++++
cut (inv (inv L) = inv (inv L0)).
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
exists N0.
split.
cut (L = L0).
unfold le_h in H1.
unfold inclusion in H1.
generalize (H1 (inv K) (inv L) H15).
intro.
elim H11.
intros.
generalize (inj_inv_left_syn h H4 H10 H6 H8 H25).
unfold injective_inv_left in |- *.
intros.
generalize (H26 K L0 H22 (inv K) (inv L) H23).
intros.
cut (inv K = inv K).
trivial.
intro.
generalize (H27 H28).
intro.
cut (inv (inv L) = inv (inv L0)).

*****
H29 : eq (inv L) (inv L0)
H28 : eq (inv K) (inv K)
H27 : forall _ : eq (inv K) (inv K), eq (inv L) (inv L0)
H26 : forall (M N : Msg) (_ : synthesis h M N) (M' N' : Msg)\n (_ : synthesis h M' N') (_ : eq M' (inv M)), eq N' (inv N)
H25 : injective_inv_left h
H24 : enc_analysis_left h
H23 : synthesis h (inv K) (inv L)
H21 : eq (MEnc N0 L0) N
H19 : eq K0 K
H18 : eq M0 M'
H22 : synthesis h K L0
H20 : synthesis h M' N0
M0,N0,K0,L0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
L : Msg
H14 : eq M (MEnc M' K)
M',K : Msg
H13 : g M N
M,N : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
forall _ : eq (inv (inv L)) (inv (inv L0)), eq L L0
+++++
rewrite inv_invol.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
exists N0.
split.
cut (L = L0).
unfold le_h in H1.
unfold inclusion in H1.
generalize (H1 (inv K) (inv L) H15).
intro.
elim H11.
intros.
generalize (inj_inv_left_syn h H4 H10 H6 H8 H25).
unfold injective_inv_left in |- *.
intros.
generalize (H26 K L0 H22 (inv K) (inv L) H23).
intros.
cut (inv K = inv K).
trivial.
intro.
generalize (H27 H28).
intro.
cut (inv (inv L) = inv (inv L0)).
rewrite inv_invol.

*****
H29 : eq (inv L) (inv L0)
H28 : eq (inv K) (inv K)
H27 : forall _ : eq (inv K) (inv K), eq (inv L) (inv L0)
H26 : forall (M N : Msg) (_ : synthesis h M N) (M' N' : Msg)\n (_ : synthesis h M' N') (_ : eq M' (inv M)), eq N' (inv N)
H25 : injective_inv_left h
H24 : enc_analysis_left h
H23 : synthesis h (inv K) (inv L)
H21 : eq (MEnc N0 L0) N
H19 : eq K0 K
H18 : eq M0 M'
H22 : synthesis h K L0
H20 : synthesis h M' N0
M0,N0,K0,L0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
L : Msg
H14 : eq M (MEnc M' K)
M',K : Msg
H13 : g M N
M,N : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
forall _ : eq L (inv (inv L0)), eq L L0
+++++
rewrite inv_invol.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
exists N0.
split.
cut (L = L0).
unfold le_h in H1.
unfold inclusion in H1.
generalize (H1 (inv K) (inv L) H15).
intro.
elim H11.
intros.
generalize (inj_inv_left_syn h H4 H10 H6 H8 H25).
unfold injective_inv_left in |- *.
intros.
generalize (H26 K L0 H22 (inv K) (inv L) H23).
intros.
cut (inv K = inv K).
trivial.
intro.
generalize (H27 H28).
intro.
cut (inv (inv L) = inv (inv L0)).
rewrite inv_invol.
rewrite inv_invol.

*****
H29 : eq (inv L) (inv L0)
H28 : eq (inv K) (inv K)
H27 : forall _ : eq (inv K) (inv K), eq (inv L) (inv L0)
H26 : forall (M N : Msg) (_ : synthesis h M N) (M' N' : Msg)\n (_ : synthesis h M' N') (_ : eq M' (inv M)), eq N' (inv N)
H25 : injective_inv_left h
H24 : enc_analysis_left h
H23 : synthesis h (inv K) (inv L)
H21 : eq (MEnc N0 L0) N
H19 : eq K0 K
H18 : eq M0 M'
H22 : synthesis h K L0
H20 : synthesis h M' N0
M0,N0,K0,L0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
L : Msg
H14 : eq M (MEnc M' K)
M',K : Msg
H13 : g M N
M,N : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
forall _ : eq L L0, eq L L0
+++++
trivial.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
exists N0.
split.
cut (L = L0).
unfold le_h in H1.
unfold inclusion in H1.
generalize (H1 (inv K) (inv L) H15).
intro.
elim H11.
intros.
generalize (inj_inv_left_syn h H4 H10 H6 H8 H25).
unfold injective_inv_left in |- *.
intros.
generalize (H26 K L0 H22 (inv K) (inv L) H23).
intros.
cut (inv K = inv K).
trivial.
intro.
generalize (H27 H28).
intro.
cut (inv (inv L) = inv (inv L0)).

*****
H29 : eq (inv L) (inv L0)
H28 : eq (inv K) (inv K)
H27 : forall _ : eq (inv K) (inv K), eq (inv L) (inv L0)
H26 : forall (M N : Msg) (_ : synthesis h M N) (M' N' : Msg)\n (_ : synthesis h M' N') (_ : eq M' (inv M)), eq N' (inv N)
H25 : injective_inv_left h
H24 : enc_analysis_left h
H23 : synthesis h (inv K) (inv L)
H21 : eq (MEnc N0 L0) N
H19 : eq K0 K
H18 : eq M0 M'
H22 : synthesis h K L0
H20 : synthesis h M' N0
M0,N0,K0,L0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
L : Msg
H14 : eq M (MEnc M' K)
M',K : Msg
H13 : g M N
M,N : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
eq (inv (inv L)) (inv (inv L0))
+++++
rewrite H29.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
exists N0.
split.
cut (L = L0).
unfold le_h in H1.
unfold inclusion in H1.
generalize (H1 (inv K) (inv L) H15).
intro.
elim H11.
intros.
generalize (inj_inv_left_syn h H4 H10 H6 H8 H25).
unfold injective_inv_left in |- *.
intros.
generalize (H26 K L0 H22 (inv K) (inv L) H23).
intros.
cut (inv K = inv K).
trivial.
intro.
generalize (H27 H28).
intro.
cut (inv (inv L) = inv (inv L0)).
rewrite H29.

*****
H29 : eq (inv L) (inv L0)
H28 : eq (inv K) (inv K)
H27 : forall _ : eq (inv K) (inv K), eq (inv L) (inv L0)
H26 : forall (M N : Msg) (_ : synthesis h M N) (M' N' : Msg)\n (_ : synthesis h M' N') (_ : eq M' (inv M)), eq N' (inv N)
H25 : injective_inv_left h
H24 : enc_analysis_left h
H23 : synthesis h (inv K) (inv L)
H21 : eq (MEnc N0 L0) N
H19 : eq K0 K
H18 : eq M0 M'
H22 : synthesis h K L0
H20 : synthesis h M' N0
M0,N0,K0,L0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
L : Msg
H14 : eq M (MEnc M' K)
M',K : Msg
H13 : g M N
M,N : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
eq (inv (inv L0)) (inv (inv L0))
+++++
trivial.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
exists N0.
split.
cut (L = L0).
unfold le_h in H1.
unfold inclusion in H1.
generalize (H1 (inv K) (inv L) H15).
intro.
elim H11.
intros.
generalize (inj_inv_left_syn h H4 H10 H6 H8 H25).
unfold injective_inv_left in |- *.
intros.
generalize (H26 K L0 H22 (inv K) (inv L) H23).
intros.
cut (inv K = inv K).

*****
H27 : forall _ : eq (inv K) (inv K), eq (inv L) (inv L0)
H26 : forall (M N : Msg) (_ : synthesis h M N) (M' N' : Msg)\n (_ : synthesis h M' N') (_ : eq M' (inv M)), eq N' (inv N)
H25 : injective_inv_left h
H24 : enc_analysis_left h
H23 : synthesis h (inv K) (inv L)
H21 : eq (MEnc N0 L0) N
H19 : eq K0 K
H18 : eq M0 M'
H22 : synthesis h K L0
H20 : synthesis h M' N0
M0,N0,K0,L0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
L : Msg
H14 : eq M (MEnc M' K)
M',K : Msg
H13 : g M N
M,N : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
eq (inv K) (inv K)
+++++
trivial.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
exists N0.
split.

*****
H21 : eq (MEnc N0 L0) N
H19 : eq K0 K
H18 : eq M0 M'
H22 : synthesis h K L0
H20 : synthesis h M' N0
M0,N0,K0,L0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
L : Msg
H14 : eq M (MEnc M' K)
M',K : Msg
H13 : g M N
M,N : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
synthesis g M' N0
+++++
generalize H.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
exists N0.
split.
generalize H.

*****
H21 : eq (MEnc N0 L0) N
H19 : eq K0 K
H18 : eq M0 M'
H22 : synthesis h K L0
H20 : synthesis h M' N0
M0,N0,K0,L0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
L : Msg
H14 : eq M (MEnc M' K)
M',K : Msg
H13 : g M N
M,N : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
forall _ : is_irreducible g, synthesis g M' N0
+++++
unfold is_irreducible in |- *.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
exists N0.
split.
generalize H.
unfold is_irreducible in |- *.

*****
H21 : eq (MEnc N0 L0) N
H19 : eq K0 K
H18 : eq M0 M'
H22 : synthesis h K L0
H20 : synthesis h M' N0
M0,N0,K0,L0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
L : Msg
H14 : eq M (MEnc M' K)
M',K : Msg
H13 : g M N
M,N : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
forall _ : equal g (irreducible g), synthesis g M' N0
+++++
unfold equal in |- *.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
exists N0.
split.
generalize H.
unfold is_irreducible in |- *.
unfold equal in |- *.

*****
H21 : eq (MEnc N0 L0) N
H19 : eq K0 K
H18 : eq M0 M'
H22 : synthesis h K L0
H20 : synthesis h M' N0
M0,N0,K0,L0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
L : Msg
H14 : eq M (MEnc M' K)
M',K : Msg
H13 : g M N
M,N : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
forall _ : and (inclusion g (irreducible g)) (inclusion (irreducible g) g), synthesis g M' N0
+++++
intro.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
exists N0.
split.
generalize H.
unfold is_irreducible in |- *.
unfold equal in |- *.
intro.

*****
H23 : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
H21 : eq (MEnc N0 L0) N
H19 : eq K0 K
H18 : eq M0 M'
H22 : synthesis h K L0
H20 : synthesis h M' N0
M0,N0,K0,L0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
L : Msg
H14 : eq M (MEnc M' K)
M',K : Msg
H13 : g M N
M,N : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
synthesis g M' N0
+++++
elim H23.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
exists N0.
split.
generalize H.
unfold is_irreducible in |- *.
unfold equal in |- *.
intro.
elim H23.

*****
H23 : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
H21 : eq (MEnc N0 L0) N
H19 : eq K0 K
H18 : eq M0 M'
H22 : synthesis h K L0
H20 : synthesis h M' N0
M0,N0,K0,L0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
L : Msg
H14 : eq M (MEnc M' K)
M',K : Msg
H13 : g M N
M,N : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
forall (_ : inclusion g (irreducible g)) (_ : inclusion (irreducible g) g), synthesis g M' N0
+++++
intros.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
exists N0.
split.
generalize H.
unfold is_irreducible in |- *.
unfold equal in |- *.
intro.
elim H23.
intros.

*****
H25 : inclusion (irreducible g) g
H24 : inclusion g (irreducible g)
H23 : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
H21 : eq (MEnc N0 L0) N
H19 : eq K0 K
H18 : eq M0 M'
H22 : synthesis h K L0
H20 : synthesis h M' N0
M0,N0,K0,L0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
L : Msg
H14 : eq M (MEnc M' K)
M',K : Msg
H13 : g M N
M,N : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
synthesis g M' N0
+++++
rewrite H14 in H13.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
exists N0.
split.
generalize H.
unfold is_irreducible in |- *.
unfold equal in |- *.
intro.
elim H23.
intros.
rewrite H14 in H13.

*****
H25 : inclusion (irreducible g) g
H24 : inclusion g (irreducible g)
H23 : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
H21 : eq (MEnc N0 L0) N
H19 : eq K0 K
H18 : eq M0 M'
H22 : synthesis h K L0
H20 : synthesis h M' N0
M0,N0,K0,L0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
L : Msg
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) N
M,N,M',K : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
synthesis g M' N0
+++++
rewrite <- H21 in H13.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
exists N0.
split.
generalize H.
unfold is_irreducible in |- *.
unfold equal in |- *.
intro.
elim H23.
intros.
rewrite H14 in H13.
rewrite <- H21 in H13.

*****
H25 : inclusion (irreducible g) g
H24 : inclusion g (irreducible g)
H23 : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
H21 : eq (MEnc N0 L0) N
H19 : eq K0 K
H18 : eq M0 M'
H22 : synthesis h K L0
H20 : synthesis h M' N0
M0,K0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
L : Msg
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N0 L0)
M,N,M',K,N0,L0 : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
synthesis g M' N0
+++++
generalize (irreducible_enc g).
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
exists N0.
split.
generalize H.
unfold is_irreducible in |- *.
unfold equal in |- *.
intro.
elim H23.
intros.
rewrite H14 in H13.
rewrite <- H21 in H13.
generalize (irreducible_enc g).

*****
H25 : inclusion (irreducible g) g
H24 : inclusion g (irreducible g)
H23 : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
H21 : eq (MEnc N0 L0) N
H19 : eq K0 K
H18 : eq M0 M'
H22 : synthesis h K L0
H20 : synthesis h M' N0
M0,K0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
L : Msg
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N0 L0)
M,N,M',K,N0,L0 : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
forall _ : forall M N K L : Msg, iff (irreducible g (MEnc M K) (MEnc N L)) (and (analysis_def g (MEnc M K) (MEnc N L)) (or (not (synthesis (analysis_def g) M N)) (not (synthesis (analysis_def g) K L)))), synthesis g M' N0
+++++
intros.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
exists N0.
split.
generalize H.
unfold is_irreducible in |- *.
unfold equal in |- *.
intro.
elim H23.
intros.
rewrite H14 in H13.
rewrite <- H21 in H13.
generalize (irreducible_enc g).
intros.

*****
H26 : forall M N K L : Msg,\niff (irreducible g (MEnc M K) (MEnc N L))\n (and (analysis_def g (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def g) M N))\n (not (synthesis (analysis_def g) K L))))
H25 : inclusion (irreducible g) g
H24 : inclusion g (irreducible g)
H23 : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
H21 : eq (MEnc N0 L0) N
H19 : eq K0 K
H18 : eq M0 M'
H22 : synthesis h K L0
H20 : synthesis h M' N0
M0,K0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
L : Msg
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N0 L0)
M,N,M',K,N0,L0 : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
synthesis g M' N0
+++++
elim (H26 M' N0 K L0).
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
exists N0.
split.
generalize H.
unfold is_irreducible in |- *.
unfold equal in |- *.
intro.
elim H23.
intros.
rewrite H14 in H13.
rewrite <- H21 in H13.
generalize (irreducible_enc g).
intros.
elim (H26 M' N0 K L0).

*****
H26 : forall M N K L : Msg,\niff (irreducible g (MEnc M K) (MEnc N L))\n (and (analysis_def g (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def g) M N))\n (not (synthesis (analysis_def g) K L))))
H25 : inclusion (irreducible g) g
H24 : inclusion g (irreducible g)
H23 : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
H21 : eq (MEnc N0 L0) N
H19 : eq K0 K
H18 : eq M0 M'
H22 : synthesis h K L0
H20 : synthesis h M' N0
M0,K0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
L : Msg
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N0 L0)
M,N,M',K,N0,L0 : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
forall (_ : forall _ : irreducible g (MEnc M' K) (MEnc N0 L0), and (analysis_def g (MEnc M' K) (MEnc N0 L0)) (or (not (synthesis (analysis_def g) M' N0)) (not (synthesis (analysis_def g) K L0)))) (_ : forall _ : and (analysis_def g (MEnc M' K) (MEnc N0 L0)) (or (not (synthesis (analysis_def g) M' N0)) (not (synthesis (analysis_def g) K L0))), irreducible g (MEnc M' K) (MEnc N0 L0)), synthesis g M' N0
+++++
intros.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
exists N0.
split.
generalize H.
unfold is_irreducible in |- *.
unfold equal in |- *.
intro.
elim H23.
intros.
rewrite H14 in H13.
rewrite <- H21 in H13.
generalize (irreducible_enc g).
intros.
elim (H26 M' N0 K L0).
intros.

*****
H28 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))),\nirreducible g (MEnc M' K) (MEnc N0 L0)
H27 : forall _ : irreducible g (MEnc M' K) (MEnc N0 L0),\nand (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0)))
H26 : forall M N K L : Msg,\niff (irreducible g (MEnc M K) (MEnc N L))\n (and (analysis_def g (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def g) M N))\n (not (synthesis (analysis_def g) K L))))
H25 : inclusion (irreducible g) g
H24 : inclusion g (irreducible g)
H23 : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
H21 : eq (MEnc N0 L0) N
H19 : eq K0 K
H18 : eq M0 M'
H22 : synthesis h K L0
H20 : synthesis h M' N0
M0,K0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
L : Msg
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N0 L0)
M,N,M',K,N0,L0 : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
synthesis g M' N0
+++++
unfold is_irreducible in H.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
exists N0.
split.
generalize H.
unfold is_irreducible in |- *.
unfold equal in |- *.
intro.
elim H23.
intros.
rewrite H14 in H13.
rewrite <- H21 in H13.
generalize (irreducible_enc g).
intros.
elim (H26 M' N0 K L0).
intros.
unfold is_irreducible in H.

*****
H28 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))),\nirreducible g (MEnc M' K) (MEnc N0 L0)
H27 : forall _ : irreducible g (MEnc M' K) (MEnc N0 L0),\nand (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0)))
H26 : forall M N K L : Msg,\niff (irreducible g (MEnc M K) (MEnc N L))\n (and (analysis_def g (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def g) M N))\n (not (synthesis (analysis_def g) K L))))
H25 : inclusion (irreducible g) g
H24 : inclusion g (irreducible g)
H23 : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
H21 : eq (MEnc N0 L0) N
H19 : eq K0 K
H18 : eq M0 M'
H22 : synthesis h K L0
H20 : synthesis h M' N0
M0,K0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
L : Msg
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N0 L0)
M,N,M',K,N0,L0 : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : equal g (irreducible g)
g,h : hedge
*****
synthesis g M' N0
+++++
unfold equal in H.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
exists N0.
split.
generalize H.
unfold is_irreducible in |- *.
unfold equal in |- *.
intro.
elim H23.
intros.
rewrite H14 in H13.
rewrite <- H21 in H13.
generalize (irreducible_enc g).
intros.
elim (H26 M' N0 K L0).
intros.
unfold is_irreducible in H.
unfold equal in H.

*****
H28 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))),\nirreducible g (MEnc M' K) (MEnc N0 L0)
H27 : forall _ : irreducible g (MEnc M' K) (MEnc N0 L0),\nand (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0)))
H26 : forall M N K L : Msg,\niff (irreducible g (MEnc M K) (MEnc N L))\n (and (analysis_def g (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def g) M N))\n (not (synthesis (analysis_def g) K L))))
H25 : inclusion (irreducible g) g
H24 : inclusion g (irreducible g)
H23 : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
H21 : eq (MEnc N0 L0) N
H19 : eq K0 K
H18 : eq M0 M'
H22 : synthesis h K L0
H20 : synthesis h M' N0
M0,K0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
L : Msg
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N0 L0)
M,N,M',K,N0,L0 : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
synthesis g M' N0
+++++
elim H.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
exists N0.
split.
generalize H.
unfold is_irreducible in |- *.
unfold equal in |- *.
intro.
elim H23.
intros.
rewrite H14 in H13.
rewrite <- H21 in H13.
generalize (irreducible_enc g).
intros.
elim (H26 M' N0 K L0).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.

*****
H28 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))),\nirreducible g (MEnc M' K) (MEnc N0 L0)
H27 : forall _ : irreducible g (MEnc M' K) (MEnc N0 L0),\nand (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0)))
H26 : forall M N K L : Msg,\niff (irreducible g (MEnc M K) (MEnc N L))\n (and (analysis_def g (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def g) M N))\n (not (synthesis (analysis_def g) K L))))
H25 : inclusion (irreducible g) g
H24 : inclusion g (irreducible g)
H23 : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
H21 : eq (MEnc N0 L0) N
H19 : eq K0 K
H18 : eq M0 M'
H22 : synthesis h K L0
H20 : synthesis h M' N0
M0,K0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
L : Msg
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N0 L0)
M,N,M',K,N0,L0 : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
forall (_ : inclusion g (irreducible g)) (_ : inclusion (irreducible g) g), synthesis g M' N0
+++++
unfold inclusion in |- *.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
exists N0.
split.
generalize H.
unfold is_irreducible in |- *.
unfold equal in |- *.
intro.
elim H23.
intros.
rewrite H14 in H13.
rewrite <- H21 in H13.
generalize (irreducible_enc g).
intros.
elim (H26 M' N0 K L0).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.

*****
H28 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))),\nirreducible g (MEnc M' K) (MEnc N0 L0)
H27 : forall _ : irreducible g (MEnc M' K) (MEnc N0 L0),\nand (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0)))
H26 : forall M N K L : Msg,\niff (irreducible g (MEnc M K) (MEnc N L))\n (and (analysis_def g (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def g) M N))\n (not (synthesis (analysis_def g) K L))))
H25 : inclusion (irreducible g) g
H24 : inclusion g (irreducible g)
H23 : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
H21 : eq (MEnc N0 L0) N
H19 : eq K0 K
H18 : eq M0 M'
H22 : synthesis h K L0
H20 : synthesis h M' N0
M0,K0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
L : Msg
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N0 L0)
M,N,M',K,N0,L0 : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
forall (_ : forall (M N : Msg) (_ : g M N), irreducible g M N) (_ : forall (M N : Msg) (_ : irreducible g M N), g M N), synthesis g M' N0
+++++
intros.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
exists N0.
split.
generalize H.
unfold is_irreducible in |- *.
unfold equal in |- *.
intro.
elim H23.
intros.
rewrite H14 in H13.
rewrite <- H21 in H13.
generalize (irreducible_enc g).
intros.
elim (H26 M' N0 K L0).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.

*****
H30 : forall (M N : Msg) (_ : irreducible g M N), g M N
H29 : forall (M N : Msg) (_ : g M N), irreducible g M N
H28 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))),\nirreducible g (MEnc M' K) (MEnc N0 L0)
H27 : forall _ : irreducible g (MEnc M' K) (MEnc N0 L0),\nand (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0)))
H26 : forall M N K L : Msg,\niff (irreducible g (MEnc M K) (MEnc N L))\n (and (analysis_def g (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def g) M N))\n (not (synthesis (analysis_def g) K L))))
H25 : inclusion (irreducible g) g
H24 : inclusion g (irreducible g)
H23 : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
H21 : eq (MEnc N0 L0) N
H19 : eq K0 K
H18 : eq M0 M'
H22 : synthesis h K L0
H20 : synthesis h M' N0
M0,K0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
L : Msg
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N0 L0)
M,N,M',K,N0,L0 : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
synthesis g M' N0
+++++
elim (H27 (H29 (MEnc M' K) (MEnc N0 L0) H13)).
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
exists N0.
split.
generalize H.
unfold is_irreducible in |- *.
unfold equal in |- *.
intro.
elim H23.
intros.
rewrite H14 in H13.
rewrite <- H21 in H13.
generalize (irreducible_enc g).
intros.
elim (H26 M' N0 K L0).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
elim (H27 (H29 (MEnc M' K) (MEnc N0 L0) H13)).

*****
H30 : forall (M N : Msg) (_ : irreducible g M N), g M N
H29 : forall (M N : Msg) (_ : g M N), irreducible g M N
H28 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))),\nirreducible g (MEnc M' K) (MEnc N0 L0)
H27 : forall _ : irreducible g (MEnc M' K) (MEnc N0 L0),\nand (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0)))
H26 : forall M N K L : Msg,\niff (irreducible g (MEnc M K) (MEnc N L))\n (and (analysis_def g (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def g) M N))\n (not (synthesis (analysis_def g) K L))))
H25 : inclusion (irreducible g) g
H24 : inclusion g (irreducible g)
H23 : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
H21 : eq (MEnc N0 L0) N
H19 : eq K0 K
H18 : eq M0 M'
H22 : synthesis h K L0
H20 : synthesis h M' N0
M0,K0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
L : Msg
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N0 L0)
M,N,M',K,N0,L0 : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
forall (_ : analysis_def g (MEnc M' K) (MEnc N0 L0)) (_ : or (not (synthesis (analysis_def g) M' N0)) (not (synthesis (analysis_def g) K L0))), synthesis g M' N0
+++++
intros.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
exists N0.
split.
generalize H.
unfold is_irreducible in |- *.
unfold equal in |- *.
intro.
elim H23.
intros.
rewrite H14 in H13.
rewrite <- H21 in H13.
generalize (irreducible_enc g).
intros.
elim (H26 M' N0 K L0).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
elim (H27 (H29 (MEnc M' K) (MEnc N0 L0) H13)).
intros.

*****
H32 : or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))
H31 : analysis_def g (MEnc M' K) (MEnc N0 L0)
H30 : forall (M N : Msg) (_ : irreducible g M N), g M N
H29 : forall (M N : Msg) (_ : g M N), irreducible g M N
H28 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))),\nirreducible g (MEnc M' K) (MEnc N0 L0)
H27 : forall _ : irreducible g (MEnc M' K) (MEnc N0 L0),\nand (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0)))
H26 : forall M N K L : Msg,\niff (irreducible g (MEnc M K) (MEnc N L))\n (and (analysis_def g (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def g) M N))\n (not (synthesis (analysis_def g) K L))))
H25 : inclusion (irreducible g) g
H24 : inclusion g (irreducible g)
H23 : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
H21 : eq (MEnc N0 L0) N
H19 : eq K0 K
H18 : eq M0 M'
H22 : synthesis h K L0
H20 : synthesis h M' N0
M0,K0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
L : Msg
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N0 L0)
M,N,M',K,N0,L0 : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
synthesis g M' N0
+++++
fold (inclusion (irreducible g) g) in H30.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
exists N0.
split.
generalize H.
unfold is_irreducible in |- *.
unfold equal in |- *.
intro.
elim H23.
intros.
rewrite H14 in H13.
rewrite <- H21 in H13.
generalize (irreducible_enc g).
intros.
elim (H26 M' N0 K L0).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
elim (H27 (H29 (MEnc M' K) (MEnc N0 L0) H13)).
intros.
fold (inclusion (irreducible g) g) in H30.

*****
H32 : or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))
H31 : analysis_def g (MEnc M' K) (MEnc N0 L0)
H30 : inclusion (irreducible g) g
H29 : forall (M N : Msg) (_ : g M N), irreducible g M N
H28 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))),\nirreducible g (MEnc M' K) (MEnc N0 L0)
H27 : forall _ : irreducible g (MEnc M' K) (MEnc N0 L0),\nand (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0)))
H26 : forall M N K L : Msg,\niff (irreducible g (MEnc M K) (MEnc N L))\n (and (analysis_def g (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def g) M N))\n (not (synthesis (analysis_def g) K L))))
H25 : inclusion (irreducible g) g
H24 : inclusion g (irreducible g)
H23 : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
H21 : eq (MEnc N0 L0) N
H19 : eq K0 K
H18 : eq M0 M'
H22 : synthesis h K L0
H20 : synthesis h M' N0
M0,K0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
L : Msg
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N0 L0)
M,N,M',K,N0,L0 : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
synthesis g M' N0
+++++
generalize (inclusion_impl_le_h (irreducible g) g H30).
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
exists N0.
split.
generalize H.
unfold is_irreducible in |- *.
unfold equal in |- *.
intro.
elim H23.
intros.
rewrite H14 in H13.
rewrite <- H21 in H13.
generalize (irreducible_enc g).
intros.
elim (H26 M' N0 K L0).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
elim (H27 (H29 (MEnc M' K) (MEnc N0 L0) H13)).
intros.
fold (inclusion (irreducible g) g) in H30.
generalize (inclusion_impl_le_h (irreducible g) g H30).

*****
H32 : or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))
H31 : analysis_def g (MEnc M' K) (MEnc N0 L0)
H30 : inclusion (irreducible g) g
H29 : forall (M N : Msg) (_ : g M N), irreducible g M N
H28 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))),\nirreducible g (MEnc M' K) (MEnc N0 L0)
H27 : forall _ : irreducible g (MEnc M' K) (MEnc N0 L0),\nand (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0)))
H26 : forall M N K L : Msg,\niff (irreducible g (MEnc M K) (MEnc N L))\n (and (analysis_def g (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def g) M N))\n (not (synthesis (analysis_def g) K L))))
H25 : inclusion (irreducible g) g
H24 : inclusion g (irreducible g)
H23 : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
H21 : eq (MEnc N0 L0) N
H19 : eq K0 K
H18 : eq M0 M'
H22 : synthesis h K L0
H20 : synthesis h M' N0
M0,K0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
L : Msg
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N0 L0)
M,N,M',K,N0,L0 : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
forall _ : le_h (irreducible g) g, synthesis g M' N0
+++++
unfold le_h in |- *.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
exists N0.
split.
generalize H.
unfold is_irreducible in |- *.
unfold equal in |- *.
intro.
elim H23.
intros.
rewrite H14 in H13.
rewrite <- H21 in H13.
generalize (irreducible_enc g).
intros.
elim (H26 M' N0 K L0).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
elim (H27 (H29 (MEnc M' K) (MEnc N0 L0) H13)).
intros.
fold (inclusion (irreducible g) g) in H30.
generalize (inclusion_impl_le_h (irreducible g) g H30).
unfold le_h in |- *.

*****
H32 : or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))
H31 : analysis_def g (MEnc M' K) (MEnc N0 L0)
H30 : inclusion (irreducible g) g
H29 : forall (M N : Msg) (_ : g M N), irreducible g M N
H28 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))),\nirreducible g (MEnc M' K) (MEnc N0 L0)
H27 : forall _ : irreducible g (MEnc M' K) (MEnc N0 L0),\nand (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0)))
H26 : forall M N K L : Msg,\niff (irreducible g (MEnc M K) (MEnc N L))\n (and (analysis_def g (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def g) M N))\n (not (synthesis (analysis_def g) K L))))
H25 : inclusion (irreducible g) g
H24 : inclusion g (irreducible g)
H23 : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
H21 : eq (MEnc N0 L0) N
H19 : eq K0 K
H18 : eq M0 M'
H22 : synthesis h K L0
H20 : synthesis h M' N0
M0,K0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
L : Msg
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N0 L0)
M,N,M',K,N0,L0 : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
forall _ : inclusion (synthesis (irreducible g)) (synthesis g), synthesis g M' N0
+++++
unfold inclusion in |- *.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
exists N0.
split.
generalize H.
unfold is_irreducible in |- *.
unfold equal in |- *.
intro.
elim H23.
intros.
rewrite H14 in H13.
rewrite <- H21 in H13.
generalize (irreducible_enc g).
intros.
elim (H26 M' N0 K L0).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
elim (H27 (H29 (MEnc M' K) (MEnc N0 L0) H13)).
intros.
fold (inclusion (irreducible g) g) in H30.
generalize (inclusion_impl_le_h (irreducible g) g H30).
unfold le_h in |- *.
unfold inclusion in |- *.

*****
H32 : or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))
H31 : analysis_def g (MEnc M' K) (MEnc N0 L0)
H30 : inclusion (irreducible g) g
H29 : forall (M N : Msg) (_ : g M N), irreducible g M N
H28 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))),\nirreducible g (MEnc M' K) (MEnc N0 L0)
H27 : forall _ : irreducible g (MEnc M' K) (MEnc N0 L0),\nand (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0)))
H26 : forall M N K L : Msg,\niff (irreducible g (MEnc M K) (MEnc N L))\n (and (analysis_def g (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def g) M N))\n (not (synthesis (analysis_def g) K L))))
H25 : inclusion (irreducible g) g
H24 : inclusion g (irreducible g)
H23 : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
H21 : eq (MEnc N0 L0) N
H19 : eq K0 K
H18 : eq M0 M'
H22 : synthesis h K L0
H20 : synthesis h M' N0
M0,K0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
L : Msg
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N0 L0)
M,N,M',K,N0,L0 : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
forall _ : forall (M N : Msg) (_ : synthesis (irreducible g) M N), synthesis g M N, synthesis g M' N0
+++++
intros.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
exists N0.
split.
generalize H.
unfold is_irreducible in |- *.
unfold equal in |- *.
intro.
elim H23.
intros.
rewrite H14 in H13.
rewrite <- H21 in H13.
generalize (irreducible_enc g).
intros.
elim (H26 M' N0 K L0).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
elim (H27 (H29 (MEnc M' K) (MEnc N0 L0) H13)).
intros.
fold (inclusion (irreducible g) g) in H30.
generalize (inclusion_impl_le_h (irreducible g) g H30).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.

*****
H33 : forall (M N : Msg) (_ : synthesis (irreducible g) M N), synthesis g M N
H32 : or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))
H31 : analysis_def g (MEnc M' K) (MEnc N0 L0)
H30 : inclusion (irreducible g) g
H29 : forall (M N : Msg) (_ : g M N), irreducible g M N
H28 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))),\nirreducible g (MEnc M' K) (MEnc N0 L0)
H27 : forall _ : irreducible g (MEnc M' K) (MEnc N0 L0),\nand (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0)))
H26 : forall M N K L : Msg,\niff (irreducible g (MEnc M K) (MEnc N L))\n (and (analysis_def g (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def g) M N))\n (not (synthesis (analysis_def g) K L))))
H25 : inclusion (irreducible g) g
H24 : inclusion g (irreducible g)
H23 : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
H21 : eq (MEnc N0 L0) N
H19 : eq K0 K
H18 : eq M0 M'
H22 : synthesis h K L0
H20 : synthesis h M' N0
M0,K0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
L : Msg
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N0 L0)
M,N,M',K,N0,L0 : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
synthesis g M' N0
+++++
apply H33.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
exists N0.
split.
generalize H.
unfold is_irreducible in |- *.
unfold equal in |- *.
intro.
elim H23.
intros.
rewrite H14 in H13.
rewrite <- H21 in H13.
generalize (irreducible_enc g).
intros.
elim (H26 M' N0 K L0).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
elim (H27 (H29 (MEnc M' K) (MEnc N0 L0) H13)).
intros.
fold (inclusion (irreducible g) g) in H30.
generalize (inclusion_impl_le_h (irreducible g) g H30).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
apply H33.

*****
H33 : forall (M N : Msg) (_ : synthesis (irreducible g) M N), synthesis g M N
H32 : or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))
H31 : analysis_def g (MEnc M' K) (MEnc N0 L0)
H30 : inclusion (irreducible g) g
H29 : forall (M N : Msg) (_ : g M N), irreducible g M N
H28 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))),\nirreducible g (MEnc M' K) (MEnc N0 L0)
H27 : forall _ : irreducible g (MEnc M' K) (MEnc N0 L0),\nand (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0)))
H26 : forall M N K L : Msg,\niff (irreducible g (MEnc M K) (MEnc N L))\n (and (analysis_def g (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def g) M N))\n (not (synthesis (analysis_def g) K L))))
H25 : inclusion (irreducible g) g
H24 : inclusion g (irreducible g)
H23 : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
H21 : eq (MEnc N0 L0) N
H19 : eq K0 K
H18 : eq M0 M'
H22 : synthesis h K L0
H20 : synthesis h M' N0
M0,K0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
L : Msg
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N0 L0)
M,N,M',K,N0,L0 : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
synthesis (irreducible g) M' N0
+++++
generalize (h_le_h_ana_h g).
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
exists N0.
split.
generalize H.
unfold is_irreducible in |- *.
unfold equal in |- *.
intro.
elim H23.
intros.
rewrite H14 in H13.
rewrite <- H21 in H13.
generalize (irreducible_enc g).
intros.
elim (H26 M' N0 K L0).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
elim (H27 (H29 (MEnc M' K) (MEnc N0 L0) H13)).
intros.
fold (inclusion (irreducible g) g) in H30.
generalize (inclusion_impl_le_h (irreducible g) g H30).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
apply H33.
generalize (h_le_h_ana_h g).

*****
H33 : forall (M N : Msg) (_ : synthesis (irreducible g) M N), synthesis g M N
H32 : or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))
H31 : analysis_def g (MEnc M' K) (MEnc N0 L0)
H30 : inclusion (irreducible g) g
H29 : forall (M N : Msg) (_ : g M N), irreducible g M N
H28 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))),\nirreducible g (MEnc M' K) (MEnc N0 L0)
H27 : forall _ : irreducible g (MEnc M' K) (MEnc N0 L0),\nand (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0)))
H26 : forall M N K L : Msg,\niff (irreducible g (MEnc M K) (MEnc N L))\n (and (analysis_def g (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def g) M N))\n (not (synthesis (analysis_def g) K L))))
H25 : inclusion (irreducible g) g
H24 : inclusion g (irreducible g)
H23 : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
H21 : eq (MEnc N0 L0) N
H19 : eq K0 K
H18 : eq M0 M'
H22 : synthesis h K L0
H20 : synthesis h M' N0
M0,K0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
L : Msg
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N0 L0)
M,N,M',K,N0,L0 : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
forall _ : le_h g (analysis_def g), synthesis (irreducible g) M' N0
+++++
unfold le_h in |- *.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
exists N0.
split.
generalize H.
unfold is_irreducible in |- *.
unfold equal in |- *.
intro.
elim H23.
intros.
rewrite H14 in H13.
rewrite <- H21 in H13.
generalize (irreducible_enc g).
intros.
elim (H26 M' N0 K L0).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
elim (H27 (H29 (MEnc M' K) (MEnc N0 L0) H13)).
intros.
fold (inclusion (irreducible g) g) in H30.
generalize (inclusion_impl_le_h (irreducible g) g H30).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
apply H33.
generalize (h_le_h_ana_h g).
unfold le_h in |- *.

*****
H33 : forall (M N : Msg) (_ : synthesis (irreducible g) M N), synthesis g M N
H32 : or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))
H31 : analysis_def g (MEnc M' K) (MEnc N0 L0)
H30 : inclusion (irreducible g) g
H29 : forall (M N : Msg) (_ : g M N), irreducible g M N
H28 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))),\nirreducible g (MEnc M' K) (MEnc N0 L0)
H27 : forall _ : irreducible g (MEnc M' K) (MEnc N0 L0),\nand (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0)))
H26 : forall M N K L : Msg,\niff (irreducible g (MEnc M K) (MEnc N L))\n (and (analysis_def g (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def g) M N))\n (not (synthesis (analysis_def g) K L))))
H25 : inclusion (irreducible g) g
H24 : inclusion g (irreducible g)
H23 : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
H21 : eq (MEnc N0 L0) N
H19 : eq K0 K
H18 : eq M0 M'
H22 : synthesis h K L0
H20 : synthesis h M' N0
M0,K0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
L : Msg
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N0 L0)
M,N,M',K,N0,L0 : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
forall _ : inclusion (synthesis g) (synthesis (analysis_def g)), synthesis (irreducible g) M' N0
+++++
unfold inclusion in |- *.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
exists N0.
split.
generalize H.
unfold is_irreducible in |- *.
unfold equal in |- *.
intro.
elim H23.
intros.
rewrite H14 in H13.
rewrite <- H21 in H13.
generalize (irreducible_enc g).
intros.
elim (H26 M' N0 K L0).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
elim (H27 (H29 (MEnc M' K) (MEnc N0 L0) H13)).
intros.
fold (inclusion (irreducible g) g) in H30.
generalize (inclusion_impl_le_h (irreducible g) g H30).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
apply H33.
generalize (h_le_h_ana_h g).
unfold le_h in |- *.
unfold inclusion in |- *.

*****
H33 : forall (M N : Msg) (_ : synthesis (irreducible g) M N), synthesis g M N
H32 : or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))
H31 : analysis_def g (MEnc M' K) (MEnc N0 L0)
H30 : inclusion (irreducible g) g
H29 : forall (M N : Msg) (_ : g M N), irreducible g M N
H28 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))),\nirreducible g (MEnc M' K) (MEnc N0 L0)
H27 : forall _ : irreducible g (MEnc M' K) (MEnc N0 L0),\nand (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0)))
H26 : forall M N K L : Msg,\niff (irreducible g (MEnc M K) (MEnc N L))\n (and (analysis_def g (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def g) M N))\n (not (synthesis (analysis_def g) K L))))
H25 : inclusion (irreducible g) g
H24 : inclusion g (irreducible g)
H23 : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
H21 : eq (MEnc N0 L0) N
H19 : eq K0 K
H18 : eq M0 M'
H22 : synthesis h K L0
H20 : synthesis h M' N0
M0,K0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
L : Msg
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N0 L0)
M,N,M',K,N0,L0 : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
forall _ : forall (M N : Msg) (_ : synthesis g M N), synthesis (analysis_def g) M N, synthesis (irreducible g) M' N0
+++++
intros.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
exists N0.
split.
generalize H.
unfold is_irreducible in |- *.
unfold equal in |- *.
intro.
elim H23.
intros.
rewrite H14 in H13.
rewrite <- H21 in H13.
generalize (irreducible_enc g).
intros.
elim (H26 M' N0 K L0).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
elim (H27 (H29 (MEnc M' K) (MEnc N0 L0) H13)).
intros.
fold (inclusion (irreducible g) g) in H30.
generalize (inclusion_impl_le_h (irreducible g) g H30).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
apply H33.
generalize (h_le_h_ana_h g).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.

*****
H34 : forall (M N : Msg) (_ : synthesis g M N),\nsynthesis (analysis_def g) M N
H33 : forall (M N : Msg) (_ : synthesis (irreducible g) M N), synthesis g M N
H32 : or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))
H31 : analysis_def g (MEnc M' K) (MEnc N0 L0)
H30 : inclusion (irreducible g) g
H29 : forall (M N : Msg) (_ : g M N), irreducible g M N
H28 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))),\nirreducible g (MEnc M' K) (MEnc N0 L0)
H27 : forall _ : irreducible g (MEnc M' K) (MEnc N0 L0),\nand (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0)))
H26 : forall M N K L : Msg,\niff (irreducible g (MEnc M K) (MEnc N L))\n (and (analysis_def g (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def g) M N))\n (not (synthesis (analysis_def g) K L))))
H25 : inclusion (irreducible g) g
H24 : inclusion g (irreducible g)
H23 : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
H21 : eq (MEnc N0 L0) N
H19 : eq K0 K
H18 : eq M0 M'
H22 : synthesis h K L0
H20 : synthesis h M' N0
M0,K0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
L : Msg
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N0 L0)
M,N,M',K,N0,L0 : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
synthesis (irreducible g) M' N0
+++++
generalize (ana_h_equiv_irr_h g).
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
exists N0.
split.
generalize H.
unfold is_irreducible in |- *.
unfold equal in |- *.
intro.
elim H23.
intros.
rewrite H14 in H13.
rewrite <- H21 in H13.
generalize (irreducible_enc g).
intros.
elim (H26 M' N0 K L0).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
elim (H27 (H29 (MEnc M' K) (MEnc N0 L0) H13)).
intros.
fold (inclusion (irreducible g) g) in H30.
generalize (inclusion_impl_le_h (irreducible g) g H30).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
apply H33.
generalize (h_le_h_ana_h g).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize (ana_h_equiv_irr_h g).

*****
H34 : forall (M N : Msg) (_ : synthesis g M N),\nsynthesis (analysis_def g) M N
H33 : forall (M N : Msg) (_ : synthesis (irreducible g) M N), synthesis g M N
H32 : or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))
H31 : analysis_def g (MEnc M' K) (MEnc N0 L0)
H30 : inclusion (irreducible g) g
H29 : forall (M N : Msg) (_ : g M N), irreducible g M N
H28 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))),\nirreducible g (MEnc M' K) (MEnc N0 L0)
H27 : forall _ : irreducible g (MEnc M' K) (MEnc N0 L0),\nand (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0)))
H26 : forall M N K L : Msg,\niff (irreducible g (MEnc M K) (MEnc N L))\n (and (analysis_def g (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def g) M N))\n (not (synthesis (analysis_def g) K L))))
H25 : inclusion (irreducible g) g
H24 : inclusion g (irreducible g)
H23 : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
H21 : eq (MEnc N0 L0) N
H19 : eq K0 K
H18 : eq M0 M'
H22 : synthesis h K L0
H20 : synthesis h M' N0
M0,K0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
L : Msg
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N0 L0)
M,N,M',K,N0,L0 : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
forall _ : equiv_h (analysis_def g) (irreducible g), synthesis (irreducible g) M' N0
+++++
unfold equiv_h in |- *.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
exists N0.
split.
generalize H.
unfold is_irreducible in |- *.
unfold equal in |- *.
intro.
elim H23.
intros.
rewrite H14 in H13.
rewrite <- H21 in H13.
generalize (irreducible_enc g).
intros.
elim (H26 M' N0 K L0).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
elim (H27 (H29 (MEnc M' K) (MEnc N0 L0) H13)).
intros.
fold (inclusion (irreducible g) g) in H30.
generalize (inclusion_impl_le_h (irreducible g) g H30).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
apply H33.
generalize (h_le_h_ana_h g).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize (ana_h_equiv_irr_h g).
unfold equiv_h in |- *.

*****
H34 : forall (M N : Msg) (_ : synthesis g M N),\nsynthesis (analysis_def g) M N
H33 : forall (M N : Msg) (_ : synthesis (irreducible g) M N), synthesis g M N
H32 : or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))
H31 : analysis_def g (MEnc M' K) (MEnc N0 L0)
H30 : inclusion (irreducible g) g
H29 : forall (M N : Msg) (_ : g M N), irreducible g M N
H28 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))),\nirreducible g (MEnc M' K) (MEnc N0 L0)
H27 : forall _ : irreducible g (MEnc M' K) (MEnc N0 L0),\nand (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0)))
H26 : forall M N K L : Msg,\niff (irreducible g (MEnc M K) (MEnc N L))\n (and (analysis_def g (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def g) M N))\n (not (synthesis (analysis_def g) K L))))
H25 : inclusion (irreducible g) g
H24 : inclusion g (irreducible g)
H23 : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
H21 : eq (MEnc N0 L0) N
H19 : eq K0 K
H18 : eq M0 M'
H22 : synthesis h K L0
H20 : synthesis h M' N0
M0,K0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
L : Msg
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N0 L0)
M,N,M',K,N0,L0 : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
forall _ : and (le_h (analysis_def g) (irreducible g)) (le_h (irreducible g) (analysis_def g)), synthesis (irreducible g) M' N0
+++++
intro.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
exists N0.
split.
generalize H.
unfold is_irreducible in |- *.
unfold equal in |- *.
intro.
elim H23.
intros.
rewrite H14 in H13.
rewrite <- H21 in H13.
generalize (irreducible_enc g).
intros.
elim (H26 M' N0 K L0).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
elim (H27 (H29 (MEnc M' K) (MEnc N0 L0) H13)).
intros.
fold (inclusion (irreducible g) g) in H30.
generalize (inclusion_impl_le_h (irreducible g) g H30).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
apply H33.
generalize (h_le_h_ana_h g).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize (ana_h_equiv_irr_h g).
unfold equiv_h in |- *.
intro.

*****
H35 : and (le_h (analysis_def g) (irreducible g))\n (le_h (irreducible g) (analysis_def g))
H34 : forall (M N : Msg) (_ : synthesis g M N),\nsynthesis (analysis_def g) M N
H33 : forall (M N : Msg) (_ : synthesis (irreducible g) M N), synthesis g M N
H32 : or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))
H31 : analysis_def g (MEnc M' K) (MEnc N0 L0)
H30 : inclusion (irreducible g) g
H29 : forall (M N : Msg) (_ : g M N), irreducible g M N
H28 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))),\nirreducible g (MEnc M' K) (MEnc N0 L0)
H27 : forall _ : irreducible g (MEnc M' K) (MEnc N0 L0),\nand (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0)))
H26 : forall M N K L : Msg,\niff (irreducible g (MEnc M K) (MEnc N L))\n (and (analysis_def g (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def g) M N))\n (not (synthesis (analysis_def g) K L))))
H25 : inclusion (irreducible g) g
H24 : inclusion g (irreducible g)
H23 : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
H21 : eq (MEnc N0 L0) N
H19 : eq K0 K
H18 : eq M0 M'
H22 : synthesis h K L0
H20 : synthesis h M' N0
M0,K0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
L : Msg
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N0 L0)
M,N,M',K,N0,L0 : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
synthesis (irreducible g) M' N0
+++++
elim H35.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
exists N0.
split.
generalize H.
unfold is_irreducible in |- *.
unfold equal in |- *.
intro.
elim H23.
intros.
rewrite H14 in H13.
rewrite <- H21 in H13.
generalize (irreducible_enc g).
intros.
elim (H26 M' N0 K L0).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
elim (H27 (H29 (MEnc M' K) (MEnc N0 L0) H13)).
intros.
fold (inclusion (irreducible g) g) in H30.
generalize (inclusion_impl_le_h (irreducible g) g H30).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
apply H33.
generalize (h_le_h_ana_h g).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize (ana_h_equiv_irr_h g).
unfold equiv_h in |- *.
intro.
elim H35.

*****
H35 : and (le_h (analysis_def g) (irreducible g))\n (le_h (irreducible g) (analysis_def g))
H34 : forall (M N : Msg) (_ : synthesis g M N),\nsynthesis (analysis_def g) M N
H33 : forall (M N : Msg) (_ : synthesis (irreducible g) M N), synthesis g M N
H32 : or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))
H31 : analysis_def g (MEnc M' K) (MEnc N0 L0)
H30 : inclusion (irreducible g) g
H29 : forall (M N : Msg) (_ : g M N), irreducible g M N
H28 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))),\nirreducible g (MEnc M' K) (MEnc N0 L0)
H27 : forall _ : irreducible g (MEnc M' K) (MEnc N0 L0),\nand (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0)))
H26 : forall M N K L : Msg,\niff (irreducible g (MEnc M K) (MEnc N L))\n (and (analysis_def g (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def g) M N))\n (not (synthesis (analysis_def g) K L))))
H25 : inclusion (irreducible g) g
H24 : inclusion g (irreducible g)
H23 : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
H21 : eq (MEnc N0 L0) N
H19 : eq K0 K
H18 : eq M0 M'
H22 : synthesis h K L0
H20 : synthesis h M' N0
M0,K0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
L : Msg
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N0 L0)
M,N,M',K,N0,L0 : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
forall (_ : le_h (analysis_def g) (irreducible g)) (_ : le_h (irreducible g) (analysis_def g)), synthesis (irreducible g) M' N0
+++++
unfold le_h in |- *.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
exists N0.
split.
generalize H.
unfold is_irreducible in |- *.
unfold equal in |- *.
intro.
elim H23.
intros.
rewrite H14 in H13.
rewrite <- H21 in H13.
generalize (irreducible_enc g).
intros.
elim (H26 M' N0 K L0).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
elim (H27 (H29 (MEnc M' K) (MEnc N0 L0) H13)).
intros.
fold (inclusion (irreducible g) g) in H30.
generalize (inclusion_impl_le_h (irreducible g) g H30).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
apply H33.
generalize (h_le_h_ana_h g).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize (ana_h_equiv_irr_h g).
unfold equiv_h in |- *.
intro.
elim H35.
unfold le_h in |- *.

*****
H35 : and (le_h (analysis_def g) (irreducible g))\n (le_h (irreducible g) (analysis_def g))
H34 : forall (M N : Msg) (_ : synthesis g M N),\nsynthesis (analysis_def g) M N
H33 : forall (M N : Msg) (_ : synthesis (irreducible g) M N), synthesis g M N
H32 : or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))
H31 : analysis_def g (MEnc M' K) (MEnc N0 L0)
H30 : inclusion (irreducible g) g
H29 : forall (M N : Msg) (_ : g M N), irreducible g M N
H28 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))),\nirreducible g (MEnc M' K) (MEnc N0 L0)
H27 : forall _ : irreducible g (MEnc M' K) (MEnc N0 L0),\nand (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0)))
H26 : forall M N K L : Msg,\niff (irreducible g (MEnc M K) (MEnc N L))\n (and (analysis_def g (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def g) M N))\n (not (synthesis (analysis_def g) K L))))
H25 : inclusion (irreducible g) g
H24 : inclusion g (irreducible g)
H23 : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
H21 : eq (MEnc N0 L0) N
H19 : eq K0 K
H18 : eq M0 M'
H22 : synthesis h K L0
H20 : synthesis h M' N0
M0,K0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
L : Msg
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N0 L0)
M,N,M',K,N0,L0 : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
forall (_ : inclusion (synthesis (analysis_def g)) (synthesis (irreducible g))) (_ : inclusion (synthesis (irreducible g)) (synthesis (analysis_def g))), synthesis (irreducible g) M' N0
+++++
unfold inclusion in |- *.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
exists N0.
split.
generalize H.
unfold is_irreducible in |- *.
unfold equal in |- *.
intro.
elim H23.
intros.
rewrite H14 in H13.
rewrite <- H21 in H13.
generalize (irreducible_enc g).
intros.
elim (H26 M' N0 K L0).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
elim (H27 (H29 (MEnc M' K) (MEnc N0 L0) H13)).
intros.
fold (inclusion (irreducible g) g) in H30.
generalize (inclusion_impl_le_h (irreducible g) g H30).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
apply H33.
generalize (h_le_h_ana_h g).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize (ana_h_equiv_irr_h g).
unfold equiv_h in |- *.
intro.
elim H35.
unfold le_h in |- *.
unfold inclusion in |- *.

*****
H35 : and (le_h (analysis_def g) (irreducible g))\n (le_h (irreducible g) (analysis_def g))
H34 : forall (M N : Msg) (_ : synthesis g M N),\nsynthesis (analysis_def g) M N
H33 : forall (M N : Msg) (_ : synthesis (irreducible g) M N), synthesis g M N
H32 : or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))
H31 : analysis_def g (MEnc M' K) (MEnc N0 L0)
H30 : inclusion (irreducible g) g
H29 : forall (M N : Msg) (_ : g M N), irreducible g M N
H28 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))),\nirreducible g (MEnc M' K) (MEnc N0 L0)
H27 : forall _ : irreducible g (MEnc M' K) (MEnc N0 L0),\nand (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0)))
H26 : forall M N K L : Msg,\niff (irreducible g (MEnc M K) (MEnc N L))\n (and (analysis_def g (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def g) M N))\n (not (synthesis (analysis_def g) K L))))
H25 : inclusion (irreducible g) g
H24 : inclusion g (irreducible g)
H23 : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
H21 : eq (MEnc N0 L0) N
H19 : eq K0 K
H18 : eq M0 M'
H22 : synthesis h K L0
H20 : synthesis h M' N0
M0,K0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
L : Msg
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N0 L0)
M,N,M',K,N0,L0 : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
forall (_ : forall (M N : Msg) (_ : synthesis (analysis_def g) M N), synthesis (irreducible g) M N) (_ : forall (M N : Msg) (_ : synthesis (irreducible g) M N), synthesis (analysis_def g) M N), synthesis (irreducible g) M' N0
+++++
intros.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
exists N0.
split.
generalize H.
unfold is_irreducible in |- *.
unfold equal in |- *.
intro.
elim H23.
intros.
rewrite H14 in H13.
rewrite <- H21 in H13.
generalize (irreducible_enc g).
intros.
elim (H26 M' N0 K L0).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
elim (H27 (H29 (MEnc M' K) (MEnc N0 L0) H13)).
intros.
fold (inclusion (irreducible g) g) in H30.
generalize (inclusion_impl_le_h (irreducible g) g H30).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
apply H33.
generalize (h_le_h_ana_h g).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize (ana_h_equiv_irr_h g).
unfold equiv_h in |- *.
intro.
elim H35.
unfold le_h in |- *.
unfold inclusion in |- *.
intros.

*****
H37 : forall (M N : Msg) (_ : synthesis (irreducible g) M N),\nsynthesis (analysis_def g) M N
H36 : forall (M N : Msg) (_ : synthesis (analysis_def g) M N),\nsynthesis (irreducible g) M N
H35 : and (le_h (analysis_def g) (irreducible g))\n (le_h (irreducible g) (analysis_def g))
H34 : forall (M N : Msg) (_ : synthesis g M N),\nsynthesis (analysis_def g) M N
H33 : forall (M N : Msg) (_ : synthesis (irreducible g) M N), synthesis g M N
H32 : or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))
H31 : analysis_def g (MEnc M' K) (MEnc N0 L0)
H30 : inclusion (irreducible g) g
H29 : forall (M N : Msg) (_ : g M N), irreducible g M N
H28 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))),\nirreducible g (MEnc M' K) (MEnc N0 L0)
H27 : forall _ : irreducible g (MEnc M' K) (MEnc N0 L0),\nand (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0)))
H26 : forall M N K L : Msg,\niff (irreducible g (MEnc M K) (MEnc N L))\n (and (analysis_def g (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def g) M N))\n (not (synthesis (analysis_def g) K L))))
H25 : inclusion (irreducible g) g
H24 : inclusion g (irreducible g)
H23 : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
H21 : eq (MEnc N0 L0) N
H19 : eq K0 K
H18 : eq M0 M'
H22 : synthesis h K L0
H20 : synthesis h M' N0
M0,K0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
L : Msg
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N0 L0)
M,N,M',K,N0,L0 : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
synthesis (irreducible g) M' N0
+++++
apply H36.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
exists N0.
split.
generalize H.
unfold is_irreducible in |- *.
unfold equal in |- *.
intro.
elim H23.
intros.
rewrite H14 in H13.
rewrite <- H21 in H13.
generalize (irreducible_enc g).
intros.
elim (H26 M' N0 K L0).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
elim (H27 (H29 (MEnc M' K) (MEnc N0 L0) H13)).
intros.
fold (inclusion (irreducible g) g) in H30.
generalize (inclusion_impl_le_h (irreducible g) g H30).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
apply H33.
generalize (h_le_h_ana_h g).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize (ana_h_equiv_irr_h g).
unfold equiv_h in |- *.
intro.
elim H35.
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
apply H36.

*****
H37 : forall (M N : Msg) (_ : synthesis (irreducible g) M N),\nsynthesis (analysis_def g) M N
H36 : forall (M N : Msg) (_ : synthesis (analysis_def g) M N),\nsynthesis (irreducible g) M N
H35 : and (le_h (analysis_def g) (irreducible g))\n (le_h (irreducible g) (analysis_def g))
H34 : forall (M N : Msg) (_ : synthesis g M N),\nsynthesis (analysis_def g) M N
H33 : forall (M N : Msg) (_ : synthesis (irreducible g) M N), synthesis g M N
H32 : or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))
H31 : analysis_def g (MEnc M' K) (MEnc N0 L0)
H30 : inclusion (irreducible g) g
H29 : forall (M N : Msg) (_ : g M N), irreducible g M N
H28 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))),\nirreducible g (MEnc M' K) (MEnc N0 L0)
H27 : forall _ : irreducible g (MEnc M' K) (MEnc N0 L0),\nand (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0)))
H26 : forall M N K L : Msg,\niff (irreducible g (MEnc M K) (MEnc N L))\n (and (analysis_def g (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def g) M N))\n (not (synthesis (analysis_def g) K L))))
H25 : inclusion (irreducible g) g
H24 : inclusion g (irreducible g)
H23 : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
H21 : eq (MEnc N0 L0) N
H19 : eq K0 K
H18 : eq M0 M'
H22 : synthesis h K L0
H20 : synthesis h M' N0
M0,K0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
L : Msg
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N0 L0)
M,N,M',K,N0,L0 : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
synthesis (analysis_def g) M' N0
+++++
apply SynInc.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
exists N0.
split.
generalize H.
unfold is_irreducible in |- *.
unfold equal in |- *.
intro.
elim H23.
intros.
rewrite H14 in H13.
rewrite <- H21 in H13.
generalize (irreducible_enc g).
intros.
elim (H26 M' N0 K L0).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
elim (H27 (H29 (MEnc M' K) (MEnc N0 L0) H13)).
intros.
fold (inclusion (irreducible g) g) in H30.
generalize (inclusion_impl_le_h (irreducible g) g H30).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
apply H33.
generalize (h_le_h_ana_h g).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize (ana_h_equiv_irr_h g).
unfold equiv_h in |- *.
intro.
elim H35.
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
apply H36.
apply SynInc.

*****
H37 : forall (M N : Msg) (_ : synthesis (irreducible g) M N),\nsynthesis (analysis_def g) M N
H36 : forall (M N : Msg) (_ : synthesis (analysis_def g) M N),\nsynthesis (irreducible g) M N
H35 : and (le_h (analysis_def g) (irreducible g))\n (le_h (irreducible g) (analysis_def g))
H34 : forall (M N : Msg) (_ : synthesis g M N),\nsynthesis (analysis_def g) M N
H33 : forall (M N : Msg) (_ : synthesis (irreducible g) M N), synthesis g M N
H32 : or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))
H31 : analysis_def g (MEnc M' K) (MEnc N0 L0)
H30 : inclusion (irreducible g) g
H29 : forall (M N : Msg) (_ : g M N), irreducible g M N
H28 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))),\nirreducible g (MEnc M' K) (MEnc N0 L0)
H27 : forall _ : irreducible g (MEnc M' K) (MEnc N0 L0),\nand (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0)))
H26 : forall M N K L : Msg,\niff (irreducible g (MEnc M K) (MEnc N L))\n (and (analysis_def g (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def g) M N))\n (not (synthesis (analysis_def g) K L))))
H25 : inclusion (irreducible g) g
H24 : inclusion g (irreducible g)
H23 : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
H21 : eq (MEnc N0 L0) N
H19 : eq K0 K
H18 : eq M0 M'
H22 : synthesis h K L0
H20 : synthesis h M' N0
M0,K0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
L : Msg
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N0 L0)
M,N,M',K,N0,L0 : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
analysis_def g M' N0
+++++
generalize (analysis_is_analysis g).
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
exists N0.
split.
generalize H.
unfold is_irreducible in |- *.
unfold equal in |- *.
intro.
elim H23.
intros.
rewrite H14 in H13.
rewrite <- H21 in H13.
generalize (irreducible_enc g).
intros.
elim (H26 M' N0 K L0).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
elim (H27 (H29 (MEnc M' K) (MEnc N0 L0) H13)).
intros.
fold (inclusion (irreducible g) g) in H30.
generalize (inclusion_impl_le_h (irreducible g) g H30).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
apply H33.
generalize (h_le_h_ana_h g).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize (ana_h_equiv_irr_h g).
unfold equiv_h in |- *.
intro.
elim H35.
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
apply H36.
apply SynInc.
generalize (analysis_is_analysis g).

*****
H37 : forall (M N : Msg) (_ : synthesis (irreducible g) M N),\nsynthesis (analysis_def g) M N
H36 : forall (M N : Msg) (_ : synthesis (analysis_def g) M N),\nsynthesis (irreducible g) M N
H35 : and (le_h (analysis_def g) (irreducible g))\n (le_h (irreducible g) (analysis_def g))
H34 : forall (M N : Msg) (_ : synthesis g M N),\nsynthesis (analysis_def g) M N
H33 : forall (M N : Msg) (_ : synthesis (irreducible g) M N), synthesis g M N
H32 : or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))
H31 : analysis_def g (MEnc M' K) (MEnc N0 L0)
H30 : inclusion (irreducible g) g
H29 : forall (M N : Msg) (_ : g M N), irreducible g M N
H28 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))),\nirreducible g (MEnc M' K) (MEnc N0 L0)
H27 : forall _ : irreducible g (MEnc M' K) (MEnc N0 L0),\nand (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0)))
H26 : forall M N K L : Msg,\niff (irreducible g (MEnc M K) (MEnc N L))\n (and (analysis_def g (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def g) M N))\n (not (synthesis (analysis_def g) K L))))
H25 : inclusion (irreducible g) g
H24 : inclusion g (irreducible g)
H23 : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
H21 : eq (MEnc N0 L0) N
H19 : eq K0 K
H18 : eq M0 M'
H22 : synthesis h K L0
H20 : synthesis h M' N0
M0,K0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
L : Msg
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N0 L0)
M,N,M',K,N0,L0 : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
forall _ : is_analysis g (analysis_def g), analysis_def g M' N0
+++++
unfold is_analysis in |- *.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
exists N0.
split.
generalize H.
unfold is_irreducible in |- *.
unfold equal in |- *.
intro.
elim H23.
intros.
rewrite H14 in H13.
rewrite <- H21 in H13.
generalize (irreducible_enc g).
intros.
elim (H26 M' N0 K L0).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
elim (H27 (H29 (MEnc M' K) (MEnc N0 L0) H13)).
intros.
fold (inclusion (irreducible g) g) in H30.
generalize (inclusion_impl_le_h (irreducible g) g H30).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
apply H33.
generalize (h_le_h_ana_h g).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize (ana_h_equiv_irr_h g).
unfold equiv_h in |- *.
intro.
elim H35.
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
apply H36.
apply SynInc.
generalize (analysis_is_analysis g).
unfold is_analysis in |- *.

*****
H37 : forall (M N : Msg) (_ : synthesis (irreducible g) M N),\nsynthesis (analysis_def g) M N
H36 : forall (M N : Msg) (_ : synthesis (analysis_def g) M N),\nsynthesis (irreducible g) M N
H35 : and (le_h (analysis_def g) (irreducible g))\n (le_h (irreducible g) (analysis_def g))
H34 : forall (M N : Msg) (_ : synthesis g M N),\nsynthesis (analysis_def g) M N
H33 : forall (M N : Msg) (_ : synthesis (irreducible g) M N), synthesis g M N
H32 : or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))
H31 : analysis_def g (MEnc M' K) (MEnc N0 L0)
H30 : inclusion (irreducible g) g
H29 : forall (M N : Msg) (_ : g M N), irreducible g M N
H28 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))),\nirreducible g (MEnc M' K) (MEnc N0 L0)
H27 : forall _ : irreducible g (MEnc M' K) (MEnc N0 L0),\nand (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0)))
H26 : forall M N K L : Msg,\niff (irreducible g (MEnc M K) (MEnc N L))\n (and (analysis_def g (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def g) M N))\n (not (synthesis (analysis_def g) K L))))
H25 : inclusion (irreducible g) g
H24 : inclusion g (irreducible g)
H23 : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
H21 : eq (MEnc N0 L0) N
H19 : eq K0 K
H18 : eq M0 M'
H22 : synthesis h K L0
H20 : synthesis h M' N0
M0,K0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
L : Msg
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N0 L0)
M,N,M',K,N0,L0 : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
forall _ : and (analysis_cond g (analysis_def g)) (forall (h' : hedge) (_ : analysis_cond g h'), inclusion (analysis_def g) h'), analysis_def g M' N0
+++++
unfold analysis_cond in |- *.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
exists N0.
split.
generalize H.
unfold is_irreducible in |- *.
unfold equal in |- *.
intro.
elim H23.
intros.
rewrite H14 in H13.
rewrite <- H21 in H13.
generalize (irreducible_enc g).
intros.
elim (H26 M' N0 K L0).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
elim (H27 (H29 (MEnc M' K) (MEnc N0 L0) H13)).
intros.
fold (inclusion (irreducible g) g) in H30.
generalize (inclusion_impl_le_h (irreducible g) g H30).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
apply H33.
generalize (h_le_h_ana_h g).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize (ana_h_equiv_irr_h g).
unfold equiv_h in |- *.
intro.
elim H35.
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
apply H36.
apply SynInc.
generalize (analysis_is_analysis g).
unfold is_analysis in |- *.
unfold analysis_cond in |- *.

*****
H37 : forall (M N : Msg) (_ : synthesis (irreducible g) M N),\nsynthesis (analysis_def g) M N
H36 : forall (M N : Msg) (_ : synthesis (analysis_def g) M N),\nsynthesis (irreducible g) M N
H35 : and (le_h (analysis_def g) (irreducible g))\n (le_h (irreducible g) (analysis_def g))
H34 : forall (M N : Msg) (_ : synthesis g M N),\nsynthesis (analysis_def g) M N
H33 : forall (M N : Msg) (_ : synthesis (irreducible g) M N), synthesis g M N
H32 : or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))
H31 : analysis_def g (MEnc M' K) (MEnc N0 L0)
H30 : inclusion (irreducible g) g
H29 : forall (M N : Msg) (_ : g M N), irreducible g M N
H28 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))),\nirreducible g (MEnc M' K) (MEnc N0 L0)
H27 : forall _ : irreducible g (MEnc M' K) (MEnc N0 L0),\nand (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0)))
H26 : forall M N K L : Msg,\niff (irreducible g (MEnc M K) (MEnc N L))\n (and (analysis_def g (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def g) M N))\n (not (synthesis (analysis_def g) K L))))
H25 : inclusion (irreducible g) g
H24 : inclusion g (irreducible g)
H23 : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
H21 : eq (MEnc N0 L0) N
H19 : eq K0 K
H18 : eq M0 M'
H22 : synthesis h K L0
H20 : synthesis h M' N0
M0,K0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
L : Msg
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N0 L0)
M,N,M',K,N0,L0 : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
forall _ : and (and (inclusion g (analysis_def g)) (stable_analysis (analysis_def g))) (forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')), inclusion (analysis_def g) h'), analysis_def g M' N0
+++++
intros.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
exists N0.
split.
generalize H.
unfold is_irreducible in |- *.
unfold equal in |- *.
intro.
elim H23.
intros.
rewrite H14 in H13.
rewrite <- H21 in H13.
generalize (irreducible_enc g).
intros.
elim (H26 M' N0 K L0).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
elim (H27 (H29 (MEnc M' K) (MEnc N0 L0) H13)).
intros.
fold (inclusion (irreducible g) g) in H30.
generalize (inclusion_impl_le_h (irreducible g) g H30).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
apply H33.
generalize (h_le_h_ana_h g).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize (ana_h_equiv_irr_h g).
unfold equiv_h in |- *.
intro.
elim H35.
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
apply H36.
apply SynInc.
generalize (analysis_is_analysis g).
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.

*****
H38 : and\n (and (inclusion g (analysis_def g))\n (stable_analysis (analysis_def g)))\n (forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\n inclusion (analysis_def g) h')
H37 : forall (M N : Msg) (_ : synthesis (irreducible g) M N),\nsynthesis (analysis_def g) M N
H36 : forall (M N : Msg) (_ : synthesis (analysis_def g) M N),\nsynthesis (irreducible g) M N
H35 : and (le_h (analysis_def g) (irreducible g))\n (le_h (irreducible g) (analysis_def g))
H34 : forall (M N : Msg) (_ : synthesis g M N),\nsynthesis (analysis_def g) M N
H33 : forall (M N : Msg) (_ : synthesis (irreducible g) M N), synthesis g M N
H32 : or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))
H31 : analysis_def g (MEnc M' K) (MEnc N0 L0)
H30 : inclusion (irreducible g) g
H29 : forall (M N : Msg) (_ : g M N), irreducible g M N
H28 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))),\nirreducible g (MEnc M' K) (MEnc N0 L0)
H27 : forall _ : irreducible g (MEnc M' K) (MEnc N0 L0),\nand (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0)))
H26 : forall M N K L : Msg,\niff (irreducible g (MEnc M K) (MEnc N L))\n (and (analysis_def g (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def g) M N))\n (not (synthesis (analysis_def g) K L))))
H25 : inclusion (irreducible g) g
H24 : inclusion g (irreducible g)
H23 : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
H21 : eq (MEnc N0 L0) N
H19 : eq K0 K
H18 : eq M0 M'
H22 : synthesis h K L0
H20 : synthesis h M' N0
M0,K0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
L : Msg
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N0 L0)
M,N,M',K,N0,L0 : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
analysis_def g M' N0
+++++
elim H38.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
exists N0.
split.
generalize H.
unfold is_irreducible in |- *.
unfold equal in |- *.
intro.
elim H23.
intros.
rewrite H14 in H13.
rewrite <- H21 in H13.
generalize (irreducible_enc g).
intros.
elim (H26 M' N0 K L0).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
elim (H27 (H29 (MEnc M' K) (MEnc N0 L0) H13)).
intros.
fold (inclusion (irreducible g) g) in H30.
generalize (inclusion_impl_le_h (irreducible g) g H30).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
apply H33.
generalize (h_le_h_ana_h g).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize (ana_h_equiv_irr_h g).
unfold equiv_h in |- *.
intro.
elim H35.
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
apply H36.
apply SynInc.
generalize (analysis_is_analysis g).
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.
elim H38.

*****
H38 : and\n (and (inclusion g (analysis_def g))\n (stable_analysis (analysis_def g)))\n (forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\n inclusion (analysis_def g) h')
H37 : forall (M N : Msg) (_ : synthesis (irreducible g) M N),\nsynthesis (analysis_def g) M N
H36 : forall (M N : Msg) (_ : synthesis (analysis_def g) M N),\nsynthesis (irreducible g) M N
H35 : and (le_h (analysis_def g) (irreducible g))\n (le_h (irreducible g) (analysis_def g))
H34 : forall (M N : Msg) (_ : synthesis g M N),\nsynthesis (analysis_def g) M N
H33 : forall (M N : Msg) (_ : synthesis (irreducible g) M N), synthesis g M N
H32 : or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))
H31 : analysis_def g (MEnc M' K) (MEnc N0 L0)
H30 : inclusion (irreducible g) g
H29 : forall (M N : Msg) (_ : g M N), irreducible g M N
H28 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))),\nirreducible g (MEnc M' K) (MEnc N0 L0)
H27 : forall _ : irreducible g (MEnc M' K) (MEnc N0 L0),\nand (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0)))
H26 : forall M N K L : Msg,\niff (irreducible g (MEnc M K) (MEnc N L))\n (and (analysis_def g (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def g) M N))\n (not (synthesis (analysis_def g) K L))))
H25 : inclusion (irreducible g) g
H24 : inclusion g (irreducible g)
H23 : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
H21 : eq (MEnc N0 L0) N
H19 : eq K0 K
H18 : eq M0 M'
H22 : synthesis h K L0
H20 : synthesis h M' N0
M0,K0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
L : Msg
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N0 L0)
M,N,M',K,N0,L0 : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
forall (_ : and (inclusion g (analysis_def g)) (stable_analysis (analysis_def g))) (_ : forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')), inclusion (analysis_def g) h'), analysis_def g M' N0
+++++
intros.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
exists N0.
split.
generalize H.
unfold is_irreducible in |- *.
unfold equal in |- *.
intro.
elim H23.
intros.
rewrite H14 in H13.
rewrite <- H21 in H13.
generalize (irreducible_enc g).
intros.
elim (H26 M' N0 K L0).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
elim (H27 (H29 (MEnc M' K) (MEnc N0 L0) H13)).
intros.
fold (inclusion (irreducible g) g) in H30.
generalize (inclusion_impl_le_h (irreducible g) g H30).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
apply H33.
generalize (h_le_h_ana_h g).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize (ana_h_equiv_irr_h g).
unfold equiv_h in |- *.
intro.
elim H35.
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
apply H36.
apply SynInc.
generalize (analysis_is_analysis g).
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.
elim H38.
intros.

*****
H40 : forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\ninclusion (analysis_def g) h'
H39 : and (inclusion g (analysis_def g)) (stable_analysis (analysis_def g))
H38 : and\n (and (inclusion g (analysis_def g))\n (stable_analysis (analysis_def g)))\n (forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\n inclusion (analysis_def g) h')
H37 : forall (M N : Msg) (_ : synthesis (irreducible g) M N),\nsynthesis (analysis_def g) M N
H36 : forall (M N : Msg) (_ : synthesis (analysis_def g) M N),\nsynthesis (irreducible g) M N
H35 : and (le_h (analysis_def g) (irreducible g))\n (le_h (irreducible g) (analysis_def g))
H34 : forall (M N : Msg) (_ : synthesis g M N),\nsynthesis (analysis_def g) M N
H33 : forall (M N : Msg) (_ : synthesis (irreducible g) M N), synthesis g M N
H32 : or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))
H31 : analysis_def g (MEnc M' K) (MEnc N0 L0)
H30 : inclusion (irreducible g) g
H29 : forall (M N : Msg) (_ : g M N), irreducible g M N
H28 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))),\nirreducible g (MEnc M' K) (MEnc N0 L0)
H27 : forall _ : irreducible g (MEnc M' K) (MEnc N0 L0),\nand (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0)))
H26 : forall M N K L : Msg,\niff (irreducible g (MEnc M K) (MEnc N L))\n (and (analysis_def g (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def g) M N))\n (not (synthesis (analysis_def g) K L))))
H25 : inclusion (irreducible g) g
H24 : inclusion g (irreducible g)
H23 : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
H21 : eq (MEnc N0 L0) N
H19 : eq K0 K
H18 : eq M0 M'
H22 : synthesis h K L0
H20 : synthesis h M' N0
M0,K0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
L : Msg
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N0 L0)
M,N,M',K,N0,L0 : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
analysis_def g M' N0
+++++
elim H39.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
exists N0.
split.
generalize H.
unfold is_irreducible in |- *.
unfold equal in |- *.
intro.
elim H23.
intros.
rewrite H14 in H13.
rewrite <- H21 in H13.
generalize (irreducible_enc g).
intros.
elim (H26 M' N0 K L0).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
elim (H27 (H29 (MEnc M' K) (MEnc N0 L0) H13)).
intros.
fold (inclusion (irreducible g) g) in H30.
generalize (inclusion_impl_le_h (irreducible g) g H30).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
apply H33.
generalize (h_le_h_ana_h g).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize (ana_h_equiv_irr_h g).
unfold equiv_h in |- *.
intro.
elim H35.
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
apply H36.
apply SynInc.
generalize (analysis_is_analysis g).
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.
elim H38.
intros.
elim H39.

*****
H40 : forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\ninclusion (analysis_def g) h'
H39 : and (inclusion g (analysis_def g)) (stable_analysis (analysis_def g))
H38 : and\n (and (inclusion g (analysis_def g))\n (stable_analysis (analysis_def g)))\n (forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\n inclusion (analysis_def g) h')
H37 : forall (M N : Msg) (_ : synthesis (irreducible g) M N),\nsynthesis (analysis_def g) M N
H36 : forall (M N : Msg) (_ : synthesis (analysis_def g) M N),\nsynthesis (irreducible g) M N
H35 : and (le_h (analysis_def g) (irreducible g))\n (le_h (irreducible g) (analysis_def g))
H34 : forall (M N : Msg) (_ : synthesis g M N),\nsynthesis (analysis_def g) M N
H33 : forall (M N : Msg) (_ : synthesis (irreducible g) M N), synthesis g M N
H32 : or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))
H31 : analysis_def g (MEnc M' K) (MEnc N0 L0)
H30 : inclusion (irreducible g) g
H29 : forall (M N : Msg) (_ : g M N), irreducible g M N
H28 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))),\nirreducible g (MEnc M' K) (MEnc N0 L0)
H27 : forall _ : irreducible g (MEnc M' K) (MEnc N0 L0),\nand (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0)))
H26 : forall M N K L : Msg,\niff (irreducible g (MEnc M K) (MEnc N L))\n (and (analysis_def g (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def g) M N))\n (not (synthesis (analysis_def g) K L))))
H25 : inclusion (irreducible g) g
H24 : inclusion g (irreducible g)
H23 : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
H21 : eq (MEnc N0 L0) N
H19 : eq K0 K
H18 : eq M0 M'
H22 : synthesis h K L0
H20 : synthesis h M' N0
M0,K0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
L : Msg
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N0 L0)
M,N,M',K,N0,L0 : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
forall (_ : inclusion g (analysis_def g)) (_ : stable_analysis (analysis_def g)), analysis_def g M' N0
+++++
unfold stable_analysis in |- *.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
exists N0.
split.
generalize H.
unfold is_irreducible in |- *.
unfold equal in |- *.
intro.
elim H23.
intros.
rewrite H14 in H13.
rewrite <- H21 in H13.
generalize (irreducible_enc g).
intros.
elim (H26 M' N0 K L0).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
elim (H27 (H29 (MEnc M' K) (MEnc N0 L0) H13)).
intros.
fold (inclusion (irreducible g) g) in H30.
generalize (inclusion_impl_le_h (irreducible g) g H30).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
apply H33.
generalize (h_le_h_ana_h g).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize (ana_h_equiv_irr_h g).
unfold equiv_h in |- *.
intro.
elim H35.
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
apply H36.
apply SynInc.
generalize (analysis_is_analysis g).
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.
elim H38.
intros.
elim H39.
unfold stable_analysis in |- *.

*****
H40 : forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\ninclusion (analysis_def g) h'
H39 : and (inclusion g (analysis_def g)) (stable_analysis (analysis_def g))
H38 : and\n (and (inclusion g (analysis_def g))\n (stable_analysis (analysis_def g)))\n (forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\n inclusion (analysis_def g) h')
H37 : forall (M N : Msg) (_ : synthesis (irreducible g) M N),\nsynthesis (analysis_def g) M N
H36 : forall (M N : Msg) (_ : synthesis (analysis_def g) M N),\nsynthesis (irreducible g) M N
H35 : and (le_h (analysis_def g) (irreducible g))\n (le_h (irreducible g) (analysis_def g))
H34 : forall (M N : Msg) (_ : synthesis g M N),\nsynthesis (analysis_def g) M N
H33 : forall (M N : Msg) (_ : synthesis (irreducible g) M N), synthesis g M N
H32 : or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))
H31 : analysis_def g (MEnc M' K) (MEnc N0 L0)
H30 : inclusion (irreducible g) g
H29 : forall (M N : Msg) (_ : g M N), irreducible g M N
H28 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))),\nirreducible g (MEnc M' K) (MEnc N0 L0)
H27 : forall _ : irreducible g (MEnc M' K) (MEnc N0 L0),\nand (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0)))
H26 : forall M N K L : Msg,\niff (irreducible g (MEnc M K) (MEnc N L))\n (and (analysis_def g (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def g) M N))\n (not (synthesis (analysis_def g) K L))))
H25 : inclusion (irreducible g) g
H24 : inclusion g (irreducible g)
H23 : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
H21 : eq (MEnc N0 L0) N
H19 : eq K0 K
H18 : eq M0 M'
H22 : synthesis h K L0
H20 : synthesis h M' N0
M0,K0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
L : Msg
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N0 L0)
M,N,M',K,N0,L0 : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
forall (_ : inclusion g (analysis_def g)) (_ : inclusion (analysis (analysis_def g)) (analysis_def g)), analysis_def g M' N0
+++++
unfold inclusion in |- *.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
exists N0.
split.
generalize H.
unfold is_irreducible in |- *.
unfold equal in |- *.
intro.
elim H23.
intros.
rewrite H14 in H13.
rewrite <- H21 in H13.
generalize (irreducible_enc g).
intros.
elim (H26 M' N0 K L0).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
elim (H27 (H29 (MEnc M' K) (MEnc N0 L0) H13)).
intros.
fold (inclusion (irreducible g) g) in H30.
generalize (inclusion_impl_le_h (irreducible g) g H30).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
apply H33.
generalize (h_le_h_ana_h g).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize (ana_h_equiv_irr_h g).
unfold equiv_h in |- *.
intro.
elim H35.
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
apply H36.
apply SynInc.
generalize (analysis_is_analysis g).
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.
elim H38.
intros.
elim H39.
unfold stable_analysis in |- *.
unfold inclusion in |- *.

*****
H40 : forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\ninclusion (analysis_def g) h'
H39 : and (inclusion g (analysis_def g)) (stable_analysis (analysis_def g))
H38 : and\n (and (inclusion g (analysis_def g))\n (stable_analysis (analysis_def g)))\n (forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\n inclusion (analysis_def g) h')
H37 : forall (M N : Msg) (_ : synthesis (irreducible g) M N),\nsynthesis (analysis_def g) M N
H36 : forall (M N : Msg) (_ : synthesis (analysis_def g) M N),\nsynthesis (irreducible g) M N
H35 : and (le_h (analysis_def g) (irreducible g))\n (le_h (irreducible g) (analysis_def g))
H34 : forall (M N : Msg) (_ : synthesis g M N),\nsynthesis (analysis_def g) M N
H33 : forall (M N : Msg) (_ : synthesis (irreducible g) M N), synthesis g M N
H32 : or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))
H31 : analysis_def g (MEnc M' K) (MEnc N0 L0)
H30 : inclusion (irreducible g) g
H29 : forall (M N : Msg) (_ : g M N), irreducible g M N
H28 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))),\nirreducible g (MEnc M' K) (MEnc N0 L0)
H27 : forall _ : irreducible g (MEnc M' K) (MEnc N0 L0),\nand (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0)))
H26 : forall M N K L : Msg,\niff (irreducible g (MEnc M K) (MEnc N L))\n (and (analysis_def g (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def g) M N))\n (not (synthesis (analysis_def g) K L))))
H25 : inclusion (irreducible g) g
H24 : inclusion g (irreducible g)
H23 : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
H21 : eq (MEnc N0 L0) N
H19 : eq K0 K
H18 : eq M0 M'
H22 : synthesis h K L0
H20 : synthesis h M' N0
M0,K0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
L : Msg
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N0 L0)
M,N,M',K,N0,L0 : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
forall (_ : forall (M N : Msg) (_ : g M N), analysis_def g M N) (_ : forall (M N : Msg) (_ : analysis (analysis_def g) M N), analysis_def g M N), analysis_def g M' N0
+++++
intros.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
exists N0.
split.
generalize H.
unfold is_irreducible in |- *.
unfold equal in |- *.
intro.
elim H23.
intros.
rewrite H14 in H13.
rewrite <- H21 in H13.
generalize (irreducible_enc g).
intros.
elim (H26 M' N0 K L0).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
elim (H27 (H29 (MEnc M' K) (MEnc N0 L0) H13)).
intros.
fold (inclusion (irreducible g) g) in H30.
generalize (inclusion_impl_le_h (irreducible g) g H30).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
apply H33.
generalize (h_le_h_ana_h g).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize (ana_h_equiv_irr_h g).
unfold equiv_h in |- *.
intro.
elim H35.
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
apply H36.
apply SynInc.
generalize (analysis_is_analysis g).
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.
elim H38.
intros.
elim H39.
unfold stable_analysis in |- *.
unfold inclusion in |- *.
intros.

*****
H42 : forall (M N : Msg) (_ : analysis (analysis_def g) M N),\nanalysis_def g M N
H41 : forall (M N : Msg) (_ : g M N), analysis_def g M N
H40 : forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\ninclusion (analysis_def g) h'
H39 : and (inclusion g (analysis_def g)) (stable_analysis (analysis_def g))
H38 : and\n (and (inclusion g (analysis_def g))\n (stable_analysis (analysis_def g)))\n (forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\n inclusion (analysis_def g) h')
H37 : forall (M N : Msg) (_ : synthesis (irreducible g) M N),\nsynthesis (analysis_def g) M N
H36 : forall (M N : Msg) (_ : synthesis (analysis_def g) M N),\nsynthesis (irreducible g) M N
H35 : and (le_h (analysis_def g) (irreducible g))\n (le_h (irreducible g) (analysis_def g))
H34 : forall (M N : Msg) (_ : synthesis g M N),\nsynthesis (analysis_def g) M N
H33 : forall (M N : Msg) (_ : synthesis (irreducible g) M N), synthesis g M N
H32 : or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))
H31 : analysis_def g (MEnc M' K) (MEnc N0 L0)
H30 : inclusion (irreducible g) g
H29 : forall (M N : Msg) (_ : g M N), irreducible g M N
H28 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))),\nirreducible g (MEnc M' K) (MEnc N0 L0)
H27 : forall _ : irreducible g (MEnc M' K) (MEnc N0 L0),\nand (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0)))
H26 : forall M N K L : Msg,\niff (irreducible g (MEnc M K) (MEnc N L))\n (and (analysis_def g (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def g) M N))\n (not (synthesis (analysis_def g) K L))))
H25 : inclusion (irreducible g) g
H24 : inclusion g (irreducible g)
H23 : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
H21 : eq (MEnc N0 L0) N
H19 : eq K0 K
H18 : eq M0 M'
H22 : synthesis h K L0
H20 : synthesis h M' N0
M0,K0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
L : Msg
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N0 L0)
M,N,M',K,N0,L0 : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
analysis_def g M' N0
+++++
apply H42.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
exists N0.
split.
generalize H.
unfold is_irreducible in |- *.
unfold equal in |- *.
intro.
elim H23.
intros.
rewrite H14 in H13.
rewrite <- H21 in H13.
generalize (irreducible_enc g).
intros.
elim (H26 M' N0 K L0).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
elim (H27 (H29 (MEnc M' K) (MEnc N0 L0) H13)).
intros.
fold (inclusion (irreducible g) g) in H30.
generalize (inclusion_impl_le_h (irreducible g) g H30).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
apply H33.
generalize (h_le_h_ana_h g).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize (ana_h_equiv_irr_h g).
unfold equiv_h in |- *.
intro.
elim H35.
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
apply H36.
apply SynInc.
generalize (analysis_is_analysis g).
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.
elim H38.
intros.
elim H39.
unfold stable_analysis in |- *.
unfold inclusion in |- *.
intros.
apply H42.

*****
H42 : forall (M N : Msg) (_ : analysis (analysis_def g) M N),\nanalysis_def g M N
H41 : forall (M N : Msg) (_ : g M N), analysis_def g M N
H40 : forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\ninclusion (analysis_def g) h'
H39 : and (inclusion g (analysis_def g)) (stable_analysis (analysis_def g))
H38 : and\n (and (inclusion g (analysis_def g))\n (stable_analysis (analysis_def g)))\n (forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\n inclusion (analysis_def g) h')
H37 : forall (M N : Msg) (_ : synthesis (irreducible g) M N),\nsynthesis (analysis_def g) M N
H36 : forall (M N : Msg) (_ : synthesis (analysis_def g) M N),\nsynthesis (irreducible g) M N
H35 : and (le_h (analysis_def g) (irreducible g))\n (le_h (irreducible g) (analysis_def g))
H34 : forall (M N : Msg) (_ : synthesis g M N),\nsynthesis (analysis_def g) M N
H33 : forall (M N : Msg) (_ : synthesis (irreducible g) M N), synthesis g M N
H32 : or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))
H31 : analysis_def g (MEnc M' K) (MEnc N0 L0)
H30 : inclusion (irreducible g) g
H29 : forall (M N : Msg) (_ : g M N), irreducible g M N
H28 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))),\nirreducible g (MEnc M' K) (MEnc N0 L0)
H27 : forall _ : irreducible g (MEnc M' K) (MEnc N0 L0),\nand (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0)))
H26 : forall M N K L : Msg,\niff (irreducible g (MEnc M K) (MEnc N L))\n (and (analysis_def g (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def g) M N))\n (not (synthesis (analysis_def g) K L))))
H25 : inclusion (irreducible g) g
H24 : inclusion g (irreducible g)
H23 : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
H21 : eq (MEnc N0 L0) N
H19 : eq K0 K
H18 : eq M0 M'
H22 : synthesis h K L0
H20 : synthesis h M' N0
M0,K0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
L : Msg
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N0 L0)
M,N,M',K,N0,L0 : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
analysis (analysis_def g) M' N0
+++++
apply (AnaDec (analysis_def g) M' N0 K L0).
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
exists N0.
split.
generalize H.
unfold is_irreducible in |- *.
unfold equal in |- *.
intro.
elim H23.
intros.
rewrite H14 in H13.
rewrite <- H21 in H13.
generalize (irreducible_enc g).
intros.
elim (H26 M' N0 K L0).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
elim (H27 (H29 (MEnc M' K) (MEnc N0 L0) H13)).
intros.
fold (inclusion (irreducible g) g) in H30.
generalize (inclusion_impl_le_h (irreducible g) g H30).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
apply H33.
generalize (h_le_h_ana_h g).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize (ana_h_equiv_irr_h g).
unfold equiv_h in |- *.
intro.
elim H35.
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
apply H36.
apply SynInc.
generalize (analysis_is_analysis g).
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.
elim H38.
intros.
elim H39.
unfold stable_analysis in |- *.
unfold inclusion in |- *.
intros.
apply H42.
apply (AnaDec (analysis_def g) M' N0 K L0).

*****
H42 : forall (M N : Msg) (_ : analysis (analysis_def g) M N),\nanalysis_def g M N
H41 : forall (M N : Msg) (_ : g M N), analysis_def g M N
H40 : forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\ninclusion (analysis_def g) h'
H39 : and (inclusion g (analysis_def g)) (stable_analysis (analysis_def g))
H38 : and\n (and (inclusion g (analysis_def g))\n (stable_analysis (analysis_def g)))\n (forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\n inclusion (analysis_def g) h')
H37 : forall (M N : Msg) (_ : synthesis (irreducible g) M N),\nsynthesis (analysis_def g) M N
H36 : forall (M N : Msg) (_ : synthesis (analysis_def g) M N),\nsynthesis (irreducible g) M N
H35 : and (le_h (analysis_def g) (irreducible g))\n (le_h (irreducible g) (analysis_def g))
H34 : forall (M N : Msg) (_ : synthesis g M N),\nsynthesis (analysis_def g) M N
H33 : forall (M N : Msg) (_ : synthesis (irreducible g) M N), synthesis g M N
H32 : or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))
H31 : analysis_def g (MEnc M' K) (MEnc N0 L0)
H30 : inclusion (irreducible g) g
H29 : forall (M N : Msg) (_ : g M N), irreducible g M N
H28 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))),\nirreducible g (MEnc M' K) (MEnc N0 L0)
H27 : forall _ : irreducible g (MEnc M' K) (MEnc N0 L0),\nand (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0)))
H26 : forall M N K L : Msg,\niff (irreducible g (MEnc M K) (MEnc N L))\n (and (analysis_def g (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def g) M N))\n (not (synthesis (analysis_def g) K L))))
H25 : inclusion (irreducible g) g
H24 : inclusion g (irreducible g)
H23 : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
H21 : eq (MEnc N0 L0) N
H19 : eq K0 K
H18 : eq M0 M'
H22 : synthesis h K L0
H20 : synthesis h M' N0
M0,K0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
L : Msg
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N0 L0)
M,N,M',K,N0,L0 : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
analysis (analysis_def g) (MEnc M' K) (MEnc N0 L0)
+++++
apply AnaInc.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
exists N0.
split.
generalize H.
unfold is_irreducible in |- *.
unfold equal in |- *.
intro.
elim H23.
intros.
rewrite H14 in H13.
rewrite <- H21 in H13.
generalize (irreducible_enc g).
intros.
elim (H26 M' N0 K L0).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
elim (H27 (H29 (MEnc M' K) (MEnc N0 L0) H13)).
intros.
fold (inclusion (irreducible g) g) in H30.
generalize (inclusion_impl_le_h (irreducible g) g H30).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
apply H33.
generalize (h_le_h_ana_h g).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize (ana_h_equiv_irr_h g).
unfold equiv_h in |- *.
intro.
elim H35.
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
apply H36.
apply SynInc.
generalize (analysis_is_analysis g).
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.
elim H38.
intros.
elim H39.
unfold stable_analysis in |- *.
unfold inclusion in |- *.
intros.
apply H42.
apply (AnaDec (analysis_def g) M' N0 K L0).
apply AnaInc.

*****
H42 : forall (M N : Msg) (_ : analysis (analysis_def g) M N),\nanalysis_def g M N
H41 : forall (M N : Msg) (_ : g M N), analysis_def g M N
H40 : forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\ninclusion (analysis_def g) h'
H39 : and (inclusion g (analysis_def g)) (stable_analysis (analysis_def g))
H38 : and\n (and (inclusion g (analysis_def g))\n (stable_analysis (analysis_def g)))\n (forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\n inclusion (analysis_def g) h')
H37 : forall (M N : Msg) (_ : synthesis (irreducible g) M N),\nsynthesis (analysis_def g) M N
H36 : forall (M N : Msg) (_ : synthesis (analysis_def g) M N),\nsynthesis (irreducible g) M N
H35 : and (le_h (analysis_def g) (irreducible g))\n (le_h (irreducible g) (analysis_def g))
H34 : forall (M N : Msg) (_ : synthesis g M N),\nsynthesis (analysis_def g) M N
H33 : forall (M N : Msg) (_ : synthesis (irreducible g) M N), synthesis g M N
H32 : or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))
H31 : analysis_def g (MEnc M' K) (MEnc N0 L0)
H30 : inclusion (irreducible g) g
H29 : forall (M N : Msg) (_ : g M N), irreducible g M N
H28 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))),\nirreducible g (MEnc M' K) (MEnc N0 L0)
H27 : forall _ : irreducible g (MEnc M' K) (MEnc N0 L0),\nand (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0)))
H26 : forall M N K L : Msg,\niff (irreducible g (MEnc M K) (MEnc N L))\n (and (analysis_def g (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def g) M N))\n (not (synthesis (analysis_def g) K L))))
H25 : inclusion (irreducible g) g
H24 : inclusion g (irreducible g)
H23 : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
H21 : eq (MEnc N0 L0) N
H19 : eq K0 K
H18 : eq M0 M'
H22 : synthesis h K L0
H20 : synthesis h M' N0
M0,K0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
L : Msg
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N0 L0)
M,N,M',K,N0,L0 : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
analysis_def g (MEnc M' K) (MEnc N0 L0)
+++++
trivial.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
exists N0.
split.
generalize H.
unfold is_irreducible in |- *.
unfold equal in |- *.
intro.
elim H23.
intros.
rewrite H14 in H13.
rewrite <- H21 in H13.
generalize (irreducible_enc g).
intros.
elim (H26 M' N0 K L0).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
elim (H27 (H29 (MEnc M' K) (MEnc N0 L0) H13)).
intros.
fold (inclusion (irreducible g) g) in H30.
generalize (inclusion_impl_le_h (irreducible g) g H30).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
apply H33.
generalize (h_le_h_ana_h g).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize (ana_h_equiv_irr_h g).
unfold equiv_h in |- *.
intro.
elim H35.
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
apply H36.
apply SynInc.
generalize (analysis_is_analysis g).
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.
elim H38.
intros.
elim H39.
unfold stable_analysis in |- *.
unfold inclusion in |- *.
intros.
apply H42.
apply (AnaDec (analysis_def g) M' N0 K L0).

*****
H42 : forall (M N : Msg) (_ : analysis (analysis_def g) M N),\nanalysis_def g M N
H41 : forall (M N : Msg) (_ : g M N), analysis_def g M N
H40 : forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\ninclusion (analysis_def g) h'
H39 : and (inclusion g (analysis_def g)) (stable_analysis (analysis_def g))
H38 : and\n (and (inclusion g (analysis_def g))\n (stable_analysis (analysis_def g)))\n (forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\n inclusion (analysis_def g) h')
H37 : forall (M N : Msg) (_ : synthesis (irreducible g) M N),\nsynthesis (analysis_def g) M N
H36 : forall (M N : Msg) (_ : synthesis (analysis_def g) M N),\nsynthesis (irreducible g) M N
H35 : and (le_h (analysis_def g) (irreducible g))\n (le_h (irreducible g) (analysis_def g))
H34 : forall (M N : Msg) (_ : synthesis g M N),\nsynthesis (analysis_def g) M N
H33 : forall (M N : Msg) (_ : synthesis (irreducible g) M N), synthesis g M N
H32 : or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))
H31 : analysis_def g (MEnc M' K) (MEnc N0 L0)
H30 : inclusion (irreducible g) g
H29 : forall (M N : Msg) (_ : g M N), irreducible g M N
H28 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))),\nirreducible g (MEnc M' K) (MEnc N0 L0)
H27 : forall _ : irreducible g (MEnc M' K) (MEnc N0 L0),\nand (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0)))
H26 : forall M N K L : Msg,\niff (irreducible g (MEnc M K) (MEnc N L))\n (and (analysis_def g (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def g) M N))\n (not (synthesis (analysis_def g) K L))))
H25 : inclusion (irreducible g) g
H24 : inclusion g (irreducible g)
H23 : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
H21 : eq (MEnc N0 L0) N
H19 : eq K0 K
H18 : eq M0 M'
H22 : synthesis h K L0
H20 : synthesis h M' N0
M0,K0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
L : Msg
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N0 L0)
M,N,M',K,N0,L0 : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
synthesis (analysis_def g) (inv K) (inv L0)
+++++
apply H37.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
exists N0.
split.
generalize H.
unfold is_irreducible in |- *.
unfold equal in |- *.
intro.
elim H23.
intros.
rewrite H14 in H13.
rewrite <- H21 in H13.
generalize (irreducible_enc g).
intros.
elim (H26 M' N0 K L0).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
elim (H27 (H29 (MEnc M' K) (MEnc N0 L0) H13)).
intros.
fold (inclusion (irreducible g) g) in H30.
generalize (inclusion_impl_le_h (irreducible g) g H30).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
apply H33.
generalize (h_le_h_ana_h g).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize (ana_h_equiv_irr_h g).
unfold equiv_h in |- *.
intro.
elim H35.
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
apply H36.
apply SynInc.
generalize (analysis_is_analysis g).
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.
elim H38.
intros.
elim H39.
unfold stable_analysis in |- *.
unfold inclusion in |- *.
intros.
apply H42.
apply (AnaDec (analysis_def g) M' N0 K L0).
apply H37.

*****
H42 : forall (M N : Msg) (_ : analysis (analysis_def g) M N),\nanalysis_def g M N
H41 : forall (M N : Msg) (_ : g M N), analysis_def g M N
H40 : forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\ninclusion (analysis_def g) h'
H39 : and (inclusion g (analysis_def g)) (stable_analysis (analysis_def g))
H38 : and\n (and (inclusion g (analysis_def g))\n (stable_analysis (analysis_def g)))\n (forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\n inclusion (analysis_def g) h')
H37 : forall (M N : Msg) (_ : synthesis (irreducible g) M N),\nsynthesis (analysis_def g) M N
H36 : forall (M N : Msg) (_ : synthesis (analysis_def g) M N),\nsynthesis (irreducible g) M N
H35 : and (le_h (analysis_def g) (irreducible g))\n (le_h (irreducible g) (analysis_def g))
H34 : forall (M N : Msg) (_ : synthesis g M N),\nsynthesis (analysis_def g) M N
H33 : forall (M N : Msg) (_ : synthesis (irreducible g) M N), synthesis g M N
H32 : or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))
H31 : analysis_def g (MEnc M' K) (MEnc N0 L0)
H30 : inclusion (irreducible g) g
H29 : forall (M N : Msg) (_ : g M N), irreducible g M N
H28 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))),\nirreducible g (MEnc M' K) (MEnc N0 L0)
H27 : forall _ : irreducible g (MEnc M' K) (MEnc N0 L0),\nand (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0)))
H26 : forall M N K L : Msg,\niff (irreducible g (MEnc M K) (MEnc N L))\n (and (analysis_def g (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def g) M N))\n (not (synthesis (analysis_def g) K L))))
H25 : inclusion (irreducible g) g
H24 : inclusion g (irreducible g)
H23 : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
H21 : eq (MEnc N0 L0) N
H19 : eq K0 K
H18 : eq M0 M'
H22 : synthesis h K L0
H20 : synthesis h M' N0
M0,K0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
L : Msg
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N0 L0)
M,N,M',K,N0,L0 : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
synthesis (irreducible g) (inv K) (inv L0)
+++++
fold (inclusion g (irreducible g)) in H29.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
exists N0.
split.
generalize H.
unfold is_irreducible in |- *.
unfold equal in |- *.
intro.
elim H23.
intros.
rewrite H14 in H13.
rewrite <- H21 in H13.
generalize (irreducible_enc g).
intros.
elim (H26 M' N0 K L0).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
elim (H27 (H29 (MEnc M' K) (MEnc N0 L0) H13)).
intros.
fold (inclusion (irreducible g) g) in H30.
generalize (inclusion_impl_le_h (irreducible g) g H30).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
apply H33.
generalize (h_le_h_ana_h g).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize (ana_h_equiv_irr_h g).
unfold equiv_h in |- *.
intro.
elim H35.
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
apply H36.
apply SynInc.
generalize (analysis_is_analysis g).
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.
elim H38.
intros.
elim H39.
unfold stable_analysis in |- *.
unfold inclusion in |- *.
intros.
apply H42.
apply (AnaDec (analysis_def g) M' N0 K L0).
apply H37.
fold (inclusion g (irreducible g)) in H29.

*****
H42 : forall (M N : Msg) (_ : analysis (analysis_def g) M N),\nanalysis_def g M N
H41 : forall (M N : Msg) (_ : g M N), analysis_def g M N
H40 : forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\ninclusion (analysis_def g) h'
H39 : and (inclusion g (analysis_def g)) (stable_analysis (analysis_def g))
H38 : and\n (and (inclusion g (analysis_def g))\n (stable_analysis (analysis_def g)))\n (forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\n inclusion (analysis_def g) h')
H37 : forall (M N : Msg) (_ : synthesis (irreducible g) M N),\nsynthesis (analysis_def g) M N
H36 : forall (M N : Msg) (_ : synthesis (analysis_def g) M N),\nsynthesis (irreducible g) M N
H35 : and (le_h (analysis_def g) (irreducible g))\n (le_h (irreducible g) (analysis_def g))
H34 : forall (M N : Msg) (_ : synthesis g M N),\nsynthesis (analysis_def g) M N
H33 : forall (M N : Msg) (_ : synthesis (irreducible g) M N), synthesis g M N
H32 : or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))
H31 : analysis_def g (MEnc M' K) (MEnc N0 L0)
H30 : inclusion (irreducible g) g
H29 : inclusion g (irreducible g)
H28 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))),\nirreducible g (MEnc M' K) (MEnc N0 L0)
H27 : forall _ : irreducible g (MEnc M' K) (MEnc N0 L0),\nand (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0)))
H26 : forall M N K L : Msg,\niff (irreducible g (MEnc M K) (MEnc N L))\n (and (analysis_def g (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def g) M N))\n (not (synthesis (analysis_def g) K L))))
H25 : inclusion (irreducible g) g
H24 : inclusion g (irreducible g)
H23 : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
H21 : eq (MEnc N0 L0) N
H19 : eq K0 K
H18 : eq M0 M'
H22 : synthesis h K L0
H20 : synthesis h M' N0
M0,K0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
L : Msg
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N0 L0)
M,N,M',K,N0,L0 : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
synthesis (irreducible g) (inv K) (inv L0)
+++++
generalize (inclusion_impl_le_h g (irreducible g) H29).
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
exists N0.
split.
generalize H.
unfold is_irreducible in |- *.
unfold equal in |- *.
intro.
elim H23.
intros.
rewrite H14 in H13.
rewrite <- H21 in H13.
generalize (irreducible_enc g).
intros.
elim (H26 M' N0 K L0).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
elim (H27 (H29 (MEnc M' K) (MEnc N0 L0) H13)).
intros.
fold (inclusion (irreducible g) g) in H30.
generalize (inclusion_impl_le_h (irreducible g) g H30).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
apply H33.
generalize (h_le_h_ana_h g).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize (ana_h_equiv_irr_h g).
unfold equiv_h in |- *.
intro.
elim H35.
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
apply H36.
apply SynInc.
generalize (analysis_is_analysis g).
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.
elim H38.
intros.
elim H39.
unfold stable_analysis in |- *.
unfold inclusion in |- *.
intros.
apply H42.
apply (AnaDec (analysis_def g) M' N0 K L0).
apply H37.
fold (inclusion g (irreducible g)) in H29.
generalize (inclusion_impl_le_h g (irreducible g) H29).

*****
H42 : forall (M N : Msg) (_ : analysis (analysis_def g) M N),\nanalysis_def g M N
H41 : forall (M N : Msg) (_ : g M N), analysis_def g M N
H40 : forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\ninclusion (analysis_def g) h'
H39 : and (inclusion g (analysis_def g)) (stable_analysis (analysis_def g))
H38 : and\n (and (inclusion g (analysis_def g))\n (stable_analysis (analysis_def g)))\n (forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\n inclusion (analysis_def g) h')
H37 : forall (M N : Msg) (_ : synthesis (irreducible g) M N),\nsynthesis (analysis_def g) M N
H36 : forall (M N : Msg) (_ : synthesis (analysis_def g) M N),\nsynthesis (irreducible g) M N
H35 : and (le_h (analysis_def g) (irreducible g))\n (le_h (irreducible g) (analysis_def g))
H34 : forall (M N : Msg) (_ : synthesis g M N),\nsynthesis (analysis_def g) M N
H33 : forall (M N : Msg) (_ : synthesis (irreducible g) M N), synthesis g M N
H32 : or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))
H31 : analysis_def g (MEnc M' K) (MEnc N0 L0)
H30 : inclusion (irreducible g) g
H29 : inclusion g (irreducible g)
H28 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))),\nirreducible g (MEnc M' K) (MEnc N0 L0)
H27 : forall _ : irreducible g (MEnc M' K) (MEnc N0 L0),\nand (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0)))
H26 : forall M N K L : Msg,\niff (irreducible g (MEnc M K) (MEnc N L))\n (and (analysis_def g (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def g) M N))\n (not (synthesis (analysis_def g) K L))))
H25 : inclusion (irreducible g) g
H24 : inclusion g (irreducible g)
H23 : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
H21 : eq (MEnc N0 L0) N
H19 : eq K0 K
H18 : eq M0 M'
H22 : synthesis h K L0
H20 : synthesis h M' N0
M0,K0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
L : Msg
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N0 L0)
M,N,M',K,N0,L0 : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
forall _ : le_h g (irreducible g), synthesis (irreducible g) (inv K) (inv L0)
+++++
unfold le_h in |- *.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
exists N0.
split.
generalize H.
unfold is_irreducible in |- *.
unfold equal in |- *.
intro.
elim H23.
intros.
rewrite H14 in H13.
rewrite <- H21 in H13.
generalize (irreducible_enc g).
intros.
elim (H26 M' N0 K L0).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
elim (H27 (H29 (MEnc M' K) (MEnc N0 L0) H13)).
intros.
fold (inclusion (irreducible g) g) in H30.
generalize (inclusion_impl_le_h (irreducible g) g H30).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
apply H33.
generalize (h_le_h_ana_h g).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize (ana_h_equiv_irr_h g).
unfold equiv_h in |- *.
intro.
elim H35.
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
apply H36.
apply SynInc.
generalize (analysis_is_analysis g).
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.
elim H38.
intros.
elim H39.
unfold stable_analysis in |- *.
unfold inclusion in |- *.
intros.
apply H42.
apply (AnaDec (analysis_def g) M' N0 K L0).
apply H37.
fold (inclusion g (irreducible g)) in H29.
generalize (inclusion_impl_le_h g (irreducible g) H29).
unfold le_h in |- *.

*****
H42 : forall (M N : Msg) (_ : analysis (analysis_def g) M N),\nanalysis_def g M N
H41 : forall (M N : Msg) (_ : g M N), analysis_def g M N
H40 : forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\ninclusion (analysis_def g) h'
H39 : and (inclusion g (analysis_def g)) (stable_analysis (analysis_def g))
H38 : and\n (and (inclusion g (analysis_def g))\n (stable_analysis (analysis_def g)))\n (forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\n inclusion (analysis_def g) h')
H37 : forall (M N : Msg) (_ : synthesis (irreducible g) M N),\nsynthesis (analysis_def g) M N
H36 : forall (M N : Msg) (_ : synthesis (analysis_def g) M N),\nsynthesis (irreducible g) M N
H35 : and (le_h (analysis_def g) (irreducible g))\n (le_h (irreducible g) (analysis_def g))
H34 : forall (M N : Msg) (_ : synthesis g M N),\nsynthesis (analysis_def g) M N
H33 : forall (M N : Msg) (_ : synthesis (irreducible g) M N), synthesis g M N
H32 : or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))
H31 : analysis_def g (MEnc M' K) (MEnc N0 L0)
H30 : inclusion (irreducible g) g
H29 : inclusion g (irreducible g)
H28 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))),\nirreducible g (MEnc M' K) (MEnc N0 L0)
H27 : forall _ : irreducible g (MEnc M' K) (MEnc N0 L0),\nand (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0)))
H26 : forall M N K L : Msg,\niff (irreducible g (MEnc M K) (MEnc N L))\n (and (analysis_def g (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def g) M N))\n (not (synthesis (analysis_def g) K L))))
H25 : inclusion (irreducible g) g
H24 : inclusion g (irreducible g)
H23 : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
H21 : eq (MEnc N0 L0) N
H19 : eq K0 K
H18 : eq M0 M'
H22 : synthesis h K L0
H20 : synthesis h M' N0
M0,K0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
L : Msg
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N0 L0)
M,N,M',K,N0,L0 : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
forall _ : inclusion (synthesis g) (synthesis (irreducible g)), synthesis (irreducible g) (inv K) (inv L0)
+++++
unfold inclusion in |- *.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
exists N0.
split.
generalize H.
unfold is_irreducible in |- *.
unfold equal in |- *.
intro.
elim H23.
intros.
rewrite H14 in H13.
rewrite <- H21 in H13.
generalize (irreducible_enc g).
intros.
elim (H26 M' N0 K L0).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
elim (H27 (H29 (MEnc M' K) (MEnc N0 L0) H13)).
intros.
fold (inclusion (irreducible g) g) in H30.
generalize (inclusion_impl_le_h (irreducible g) g H30).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
apply H33.
generalize (h_le_h_ana_h g).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize (ana_h_equiv_irr_h g).
unfold equiv_h in |- *.
intro.
elim H35.
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
apply H36.
apply SynInc.
generalize (analysis_is_analysis g).
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.
elim H38.
intros.
elim H39.
unfold stable_analysis in |- *.
unfold inclusion in |- *.
intros.
apply H42.
apply (AnaDec (analysis_def g) M' N0 K L0).
apply H37.
fold (inclusion g (irreducible g)) in H29.
generalize (inclusion_impl_le_h g (irreducible g) H29).
unfold le_h in |- *.
unfold inclusion in |- *.

*****
H42 : forall (M N : Msg) (_ : analysis (analysis_def g) M N),\nanalysis_def g M N
H41 : forall (M N : Msg) (_ : g M N), analysis_def g M N
H40 : forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\ninclusion (analysis_def g) h'
H39 : and (inclusion g (analysis_def g)) (stable_analysis (analysis_def g))
H38 : and\n (and (inclusion g (analysis_def g))\n (stable_analysis (analysis_def g)))\n (forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\n inclusion (analysis_def g) h')
H37 : forall (M N : Msg) (_ : synthesis (irreducible g) M N),\nsynthesis (analysis_def g) M N
H36 : forall (M N : Msg) (_ : synthesis (analysis_def g) M N),\nsynthesis (irreducible g) M N
H35 : and (le_h (analysis_def g) (irreducible g))\n (le_h (irreducible g) (analysis_def g))
H34 : forall (M N : Msg) (_ : synthesis g M N),\nsynthesis (analysis_def g) M N
H33 : forall (M N : Msg) (_ : synthesis (irreducible g) M N), synthesis g M N
H32 : or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))
H31 : analysis_def g (MEnc M' K) (MEnc N0 L0)
H30 : inclusion (irreducible g) g
H29 : inclusion g (irreducible g)
H28 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))),\nirreducible g (MEnc M' K) (MEnc N0 L0)
H27 : forall _ : irreducible g (MEnc M' K) (MEnc N0 L0),\nand (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0)))
H26 : forall M N K L : Msg,\niff (irreducible g (MEnc M K) (MEnc N L))\n (and (analysis_def g (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def g) M N))\n (not (synthesis (analysis_def g) K L))))
H25 : inclusion (irreducible g) g
H24 : inclusion g (irreducible g)
H23 : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
H21 : eq (MEnc N0 L0) N
H19 : eq K0 K
H18 : eq M0 M'
H22 : synthesis h K L0
H20 : synthesis h M' N0
M0,K0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
L : Msg
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N0 L0)
M,N,M',K,N0,L0 : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
forall _ : forall (M N : Msg) (_ : synthesis g M N), synthesis (irreducible g) M N, synthesis (irreducible g) (inv K) (inv L0)
+++++
intros.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
exists N0.
split.
generalize H.
unfold is_irreducible in |- *.
unfold equal in |- *.
intro.
elim H23.
intros.
rewrite H14 in H13.
rewrite <- H21 in H13.
generalize (irreducible_enc g).
intros.
elim (H26 M' N0 K L0).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
elim (H27 (H29 (MEnc M' K) (MEnc N0 L0) H13)).
intros.
fold (inclusion (irreducible g) g) in H30.
generalize (inclusion_impl_le_h (irreducible g) g H30).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
apply H33.
generalize (h_le_h_ana_h g).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize (ana_h_equiv_irr_h g).
unfold equiv_h in |- *.
intro.
elim H35.
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
apply H36.
apply SynInc.
generalize (analysis_is_analysis g).
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.
elim H38.
intros.
elim H39.
unfold stable_analysis in |- *.
unfold inclusion in |- *.
intros.
apply H42.
apply (AnaDec (analysis_def g) M' N0 K L0).
apply H37.
fold (inclusion g (irreducible g)) in H29.
generalize (inclusion_impl_le_h g (irreducible g) H29).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.

*****
H43 : forall (M N : Msg) (_ : synthesis g M N), synthesis (irreducible g) M N
H42 : forall (M N : Msg) (_ : analysis (analysis_def g) M N),\nanalysis_def g M N
H41 : forall (M N : Msg) (_ : g M N), analysis_def g M N
H40 : forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\ninclusion (analysis_def g) h'
H39 : and (inclusion g (analysis_def g)) (stable_analysis (analysis_def g))
H38 : and\n (and (inclusion g (analysis_def g))\n (stable_analysis (analysis_def g)))\n (forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\n inclusion (analysis_def g) h')
H37 : forall (M N : Msg) (_ : synthesis (irreducible g) M N),\nsynthesis (analysis_def g) M N
H36 : forall (M N : Msg) (_ : synthesis (analysis_def g) M N),\nsynthesis (irreducible g) M N
H35 : and (le_h (analysis_def g) (irreducible g))\n (le_h (irreducible g) (analysis_def g))
H34 : forall (M N : Msg) (_ : synthesis g M N),\nsynthesis (analysis_def g) M N
H33 : forall (M N : Msg) (_ : synthesis (irreducible g) M N), synthesis g M N
H32 : or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))
H31 : analysis_def g (MEnc M' K) (MEnc N0 L0)
H30 : inclusion (irreducible g) g
H29 : inclusion g (irreducible g)
H28 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))),\nirreducible g (MEnc M' K) (MEnc N0 L0)
H27 : forall _ : irreducible g (MEnc M' K) (MEnc N0 L0),\nand (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0)))
H26 : forall M N K L : Msg,\niff (irreducible g (MEnc M K) (MEnc N L))\n (and (analysis_def g (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def g) M N))\n (not (synthesis (analysis_def g) K L))))
H25 : inclusion (irreducible g) g
H24 : inclusion g (irreducible g)
H23 : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
H21 : eq (MEnc N0 L0) N
H19 : eq K0 K
H18 : eq M0 M'
H22 : synthesis h K L0
H20 : synthesis h M' N0
M0,K0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
L : Msg
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N0 L0)
M,N,M',K,N0,L0 : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
synthesis (irreducible g) (inv K) (inv L0)
+++++
apply H43.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
exists N0.
split.
generalize H.
unfold is_irreducible in |- *.
unfold equal in |- *.
intro.
elim H23.
intros.
rewrite H14 in H13.
rewrite <- H21 in H13.
generalize (irreducible_enc g).
intros.
elim (H26 M' N0 K L0).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
elim (H27 (H29 (MEnc M' K) (MEnc N0 L0) H13)).
intros.
fold (inclusion (irreducible g) g) in H30.
generalize (inclusion_impl_le_h (irreducible g) g H30).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
apply H33.
generalize (h_le_h_ana_h g).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize (ana_h_equiv_irr_h g).
unfold equiv_h in |- *.
intro.
elim H35.
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
apply H36.
apply SynInc.
generalize (analysis_is_analysis g).
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.
elim H38.
intros.
elim H39.
unfold stable_analysis in |- *.
unfold inclusion in |- *.
intros.
apply H42.
apply (AnaDec (analysis_def g) M' N0 K L0).
apply H37.
fold (inclusion g (irreducible g)) in H29.
generalize (inclusion_impl_le_h g (irreducible g) H29).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
apply H43.

*****
H43 : forall (M N : Msg) (_ : synthesis g M N), synthesis (irreducible g) M N
H42 : forall (M N : Msg) (_ : analysis (analysis_def g) M N),\nanalysis_def g M N
H41 : forall (M N : Msg) (_ : g M N), analysis_def g M N
H40 : forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\ninclusion (analysis_def g) h'
H39 : and (inclusion g (analysis_def g)) (stable_analysis (analysis_def g))
H38 : and\n (and (inclusion g (analysis_def g))\n (stable_analysis (analysis_def g)))\n (forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\n inclusion (analysis_def g) h')
H37 : forall (M N : Msg) (_ : synthesis (irreducible g) M N),\nsynthesis (analysis_def g) M N
H36 : forall (M N : Msg) (_ : synthesis (analysis_def g) M N),\nsynthesis (irreducible g) M N
H35 : and (le_h (analysis_def g) (irreducible g))\n (le_h (irreducible g) (analysis_def g))
H34 : forall (M N : Msg) (_ : synthesis g M N),\nsynthesis (analysis_def g) M N
H33 : forall (M N : Msg) (_ : synthesis (irreducible g) M N), synthesis g M N
H32 : or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))
H31 : analysis_def g (MEnc M' K) (MEnc N0 L0)
H30 : inclusion (irreducible g) g
H29 : inclusion g (irreducible g)
H28 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))),\nirreducible g (MEnc M' K) (MEnc N0 L0)
H27 : forall _ : irreducible g (MEnc M' K) (MEnc N0 L0),\nand (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0)))
H26 : forall M N K L : Msg,\niff (irreducible g (MEnc M K) (MEnc N L))\n (and (analysis_def g (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def g) M N))\n (not (synthesis (analysis_def g) K L))))
H25 : inclusion (irreducible g) g
H24 : inclusion g (irreducible g)
H23 : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
H21 : eq (MEnc N0 L0) N
H19 : eq K0 K
H18 : eq M0 M'
H22 : synthesis h K L0
H20 : synthesis h M' N0
M0,K0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
L : Msg
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N0 L0)
M,N,M',K,N0,L0 : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
synthesis g (inv K) (inv L0)
+++++
cut (L = L0).
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
exists N0.
split.
generalize H.
unfold is_irreducible in |- *.
unfold equal in |- *.
intro.
elim H23.
intros.
rewrite H14 in H13.
rewrite <- H21 in H13.
generalize (irreducible_enc g).
intros.
elim (H26 M' N0 K L0).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
elim (H27 (H29 (MEnc M' K) (MEnc N0 L0) H13)).
intros.
fold (inclusion (irreducible g) g) in H30.
generalize (inclusion_impl_le_h (irreducible g) g H30).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
apply H33.
generalize (h_le_h_ana_h g).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize (ana_h_equiv_irr_h g).
unfold equiv_h in |- *.
intro.
elim H35.
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
apply H36.
apply SynInc.
generalize (analysis_is_analysis g).
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.
elim H38.
intros.
elim H39.
unfold stable_analysis in |- *.
unfold inclusion in |- *.
intros.
apply H42.
apply (AnaDec (analysis_def g) M' N0 K L0).
apply H37.
fold (inclusion g (irreducible g)) in H29.
generalize (inclusion_impl_le_h g (irreducible g) H29).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
apply H43.
cut (L = L0).

*****
H43 : forall (M N : Msg) (_ : synthesis g M N), synthesis (irreducible g) M N
H42 : forall (M N : Msg) (_ : analysis (analysis_def g) M N),\nanalysis_def g M N
H41 : forall (M N : Msg) (_ : g M N), analysis_def g M N
H40 : forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\ninclusion (analysis_def g) h'
H39 : and (inclusion g (analysis_def g)) (stable_analysis (analysis_def g))
H38 : and\n (and (inclusion g (analysis_def g))\n (stable_analysis (analysis_def g)))\n (forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\n inclusion (analysis_def g) h')
H37 : forall (M N : Msg) (_ : synthesis (irreducible g) M N),\nsynthesis (analysis_def g) M N
H36 : forall (M N : Msg) (_ : synthesis (analysis_def g) M N),\nsynthesis (irreducible g) M N
H35 : and (le_h (analysis_def g) (irreducible g))\n (le_h (irreducible g) (analysis_def g))
H34 : forall (M N : Msg) (_ : synthesis g M N),\nsynthesis (analysis_def g) M N
H33 : forall (M N : Msg) (_ : synthesis (irreducible g) M N), synthesis g M N
H32 : or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))
H31 : analysis_def g (MEnc M' K) (MEnc N0 L0)
H30 : inclusion (irreducible g) g
H29 : inclusion g (irreducible g)
H28 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))),\nirreducible g (MEnc M' K) (MEnc N0 L0)
H27 : forall _ : irreducible g (MEnc M' K) (MEnc N0 L0),\nand (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0)))
H26 : forall M N K L : Msg,\niff (irreducible g (MEnc M K) (MEnc N L))\n (and (analysis_def g (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def g) M N))\n (not (synthesis (analysis_def g) K L))))
H25 : inclusion (irreducible g) g
H24 : inclusion g (irreducible g)
H23 : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
H21 : eq (MEnc N0 L0) N
H19 : eq K0 K
H18 : eq M0 M'
H22 : synthesis h K L0
H20 : synthesis h M' N0
M0,K0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
L : Msg
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N0 L0)
M,N,M',K,N0,L0 : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
forall _ : eq L L0, synthesis g (inv K) (inv L0)
+++++
intro.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
exists N0.
split.
generalize H.
unfold is_irreducible in |- *.
unfold equal in |- *.
intro.
elim H23.
intros.
rewrite H14 in H13.
rewrite <- H21 in H13.
generalize (irreducible_enc g).
intros.
elim (H26 M' N0 K L0).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
elim (H27 (H29 (MEnc M' K) (MEnc N0 L0) H13)).
intros.
fold (inclusion (irreducible g) g) in H30.
generalize (inclusion_impl_le_h (irreducible g) g H30).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
apply H33.
generalize (h_le_h_ana_h g).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize (ana_h_equiv_irr_h g).
unfold equiv_h in |- *.
intro.
elim H35.
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
apply H36.
apply SynInc.
generalize (analysis_is_analysis g).
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.
elim H38.
intros.
elim H39.
unfold stable_analysis in |- *.
unfold inclusion in |- *.
intros.
apply H42.
apply (AnaDec (analysis_def g) M' N0 K L0).
apply H37.
fold (inclusion g (irreducible g)) in H29.
generalize (inclusion_impl_le_h g (irreducible g) H29).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
apply H43.
cut (L = L0).
intro.

*****
H44 : eq L L0
H43 : forall (M N : Msg) (_ : synthesis g M N), synthesis (irreducible g) M N
H42 : forall (M N : Msg) (_ : analysis (analysis_def g) M N),\nanalysis_def g M N
H41 : forall (M N : Msg) (_ : g M N), analysis_def g M N
H40 : forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\ninclusion (analysis_def g) h'
H39 : and (inclusion g (analysis_def g)) (stable_analysis (analysis_def g))
H38 : and\n (and (inclusion g (analysis_def g))\n (stable_analysis (analysis_def g)))\n (forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\n inclusion (analysis_def g) h')
H37 : forall (M N : Msg) (_ : synthesis (irreducible g) M N),\nsynthesis (analysis_def g) M N
H36 : forall (M N : Msg) (_ : synthesis (analysis_def g) M N),\nsynthesis (irreducible g) M N
H35 : and (le_h (analysis_def g) (irreducible g))\n (le_h (irreducible g) (analysis_def g))
H34 : forall (M N : Msg) (_ : synthesis g M N),\nsynthesis (analysis_def g) M N
H33 : forall (M N : Msg) (_ : synthesis (irreducible g) M N), synthesis g M N
H32 : or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))
H31 : analysis_def g (MEnc M' K) (MEnc N0 L0)
H30 : inclusion (irreducible g) g
H29 : inclusion g (irreducible g)
H28 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))),\nirreducible g (MEnc M' K) (MEnc N0 L0)
H27 : forall _ : irreducible g (MEnc M' K) (MEnc N0 L0),\nand (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0)))
H26 : forall M N K L : Msg,\niff (irreducible g (MEnc M K) (MEnc N L))\n (and (analysis_def g (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def g) M N))\n (not (synthesis (analysis_def g) K L))))
H25 : inclusion (irreducible g) g
H24 : inclusion g (irreducible g)
H23 : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
H21 : eq (MEnc N0 L0) N
H19 : eq K0 K
H18 : eq M0 M'
H22 : synthesis h K L0
H20 : synthesis h M' N0
M0,K0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
L : Msg
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N0 L0)
M,N,M',K,N0,L0 : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
synthesis g (inv K) (inv L0)
+++++
rewrite <- H44.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
exists N0.
split.
generalize H.
unfold is_irreducible in |- *.
unfold equal in |- *.
intro.
elim H23.
intros.
rewrite H14 in H13.
rewrite <- H21 in H13.
generalize (irreducible_enc g).
intros.
elim (H26 M' N0 K L0).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
elim (H27 (H29 (MEnc M' K) (MEnc N0 L0) H13)).
intros.
fold (inclusion (irreducible g) g) in H30.
generalize (inclusion_impl_le_h (irreducible g) g H30).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
apply H33.
generalize (h_le_h_ana_h g).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize (ana_h_equiv_irr_h g).
unfold equiv_h in |- *.
intro.
elim H35.
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
apply H36.
apply SynInc.
generalize (analysis_is_analysis g).
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.
elim H38.
intros.
elim H39.
unfold stable_analysis in |- *.
unfold inclusion in |- *.
intros.
apply H42.
apply (AnaDec (analysis_def g) M' N0 K L0).
apply H37.
fold (inclusion g (irreducible g)) in H29.
generalize (inclusion_impl_le_h g (irreducible g) H29).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
apply H43.
cut (L = L0).
intro.
rewrite <- H44.

*****
H44 : eq L L0
H43 : forall (M N : Msg) (_ : synthesis g M N), synthesis (irreducible g) M N
H42 : forall (M N : Msg) (_ : analysis (analysis_def g) M N),\nanalysis_def g M N
H41 : forall (M N : Msg) (_ : g M N), analysis_def g M N
H40 : forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\ninclusion (analysis_def g) h'
H39 : and (inclusion g (analysis_def g)) (stable_analysis (analysis_def g))
H38 : and\n (and (inclusion g (analysis_def g))\n (stable_analysis (analysis_def g)))\n (forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\n inclusion (analysis_def g) h')
H37 : forall (M N : Msg) (_ : synthesis (irreducible g) M N),\nsynthesis (analysis_def g) M N
H36 : forall (M N : Msg) (_ : synthesis (analysis_def g) M N),\nsynthesis (irreducible g) M N
H35 : and (le_h (analysis_def g) (irreducible g))\n (le_h (irreducible g) (analysis_def g))
H34 : forall (M N : Msg) (_ : synthesis g M N),\nsynthesis (analysis_def g) M N
H33 : forall (M N : Msg) (_ : synthesis (irreducible g) M N), synthesis g M N
H32 : or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))
H31 : analysis_def g (MEnc M' K) (MEnc N0 L0)
H30 : inclusion (irreducible g) g
H29 : inclusion g (irreducible g)
H28 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))),\nirreducible g (MEnc M' K) (MEnc N0 L0)
H27 : forall _ : irreducible g (MEnc M' K) (MEnc N0 L0),\nand (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0)))
H26 : forall M N K L : Msg,\niff (irreducible g (MEnc M K) (MEnc N L))\n (and (analysis_def g (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def g) M N))\n (not (synthesis (analysis_def g) K L))))
H25 : inclusion (irreducible g) g
H24 : inclusion g (irreducible g)
H23 : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
H21 : eq (MEnc N0 L0) N
H19 : eq K0 K
H18 : eq M0 M'
H22 : synthesis h K L0
H20 : synthesis h M' N0
M0,K0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
L : Msg
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N0 L0)
M,N,M',K,N0,L0 : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
synthesis g (inv K) (inv L)
+++++
trivial.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
exists N0.
split.
generalize H.
unfold is_irreducible in |- *.
unfold equal in |- *.
intro.
elim H23.
intros.
rewrite H14 in H13.
rewrite <- H21 in H13.
generalize (irreducible_enc g).
intros.
elim (H26 M' N0 K L0).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
elim (H27 (H29 (MEnc M' K) (MEnc N0 L0) H13)).
intros.
fold (inclusion (irreducible g) g) in H30.
generalize (inclusion_impl_le_h (irreducible g) g H30).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
apply H33.
generalize (h_le_h_ana_h g).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize (ana_h_equiv_irr_h g).
unfold equiv_h in |- *.
intro.
elim H35.
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
apply H36.
apply SynInc.
generalize (analysis_is_analysis g).
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.
elim H38.
intros.
elim H39.
unfold stable_analysis in |- *.
unfold inclusion in |- *.
intros.
apply H42.
apply (AnaDec (analysis_def g) M' N0 K L0).
apply H37.
fold (inclusion g (irreducible g)) in H29.
generalize (inclusion_impl_le_h g (irreducible g) H29).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
apply H43.
cut (L = L0).

*****
H43 : forall (M N : Msg) (_ : synthesis g M N), synthesis (irreducible g) M N
H42 : forall (M N : Msg) (_ : analysis (analysis_def g) M N),\nanalysis_def g M N
H41 : forall (M N : Msg) (_ : g M N), analysis_def g M N
H40 : forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\ninclusion (analysis_def g) h'
H39 : and (inclusion g (analysis_def g)) (stable_analysis (analysis_def g))
H38 : and\n (and (inclusion g (analysis_def g))\n (stable_analysis (analysis_def g)))\n (forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\n inclusion (analysis_def g) h')
H37 : forall (M N : Msg) (_ : synthesis (irreducible g) M N),\nsynthesis (analysis_def g) M N
H36 : forall (M N : Msg) (_ : synthesis (analysis_def g) M N),\nsynthesis (irreducible g) M N
H35 : and (le_h (analysis_def g) (irreducible g))\n (le_h (irreducible g) (analysis_def g))
H34 : forall (M N : Msg) (_ : synthesis g M N),\nsynthesis (analysis_def g) M N
H33 : forall (M N : Msg) (_ : synthesis (irreducible g) M N), synthesis g M N
H32 : or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))
H31 : analysis_def g (MEnc M' K) (MEnc N0 L0)
H30 : inclusion (irreducible g) g
H29 : inclusion g (irreducible g)
H28 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))),\nirreducible g (MEnc M' K) (MEnc N0 L0)
H27 : forall _ : irreducible g (MEnc M' K) (MEnc N0 L0),\nand (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0)))
H26 : forall M N K L : Msg,\niff (irreducible g (MEnc M K) (MEnc N L))\n (and (analysis_def g (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def g) M N))\n (not (synthesis (analysis_def g) K L))))
H25 : inclusion (irreducible g) g
H24 : inclusion g (irreducible g)
H23 : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
H21 : eq (MEnc N0 L0) N
H19 : eq K0 K
H18 : eq M0 M'
H22 : synthesis h K L0
H20 : synthesis h M' N0
M0,K0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
L : Msg
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N0 L0)
M,N,M',K,N0,L0 : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
eq L L0
+++++
generalize H1.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
exists N0.
split.
generalize H.
unfold is_irreducible in |- *.
unfold equal in |- *.
intro.
elim H23.
intros.
rewrite H14 in H13.
rewrite <- H21 in H13.
generalize (irreducible_enc g).
intros.
elim (H26 M' N0 K L0).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
elim (H27 (H29 (MEnc M' K) (MEnc N0 L0) H13)).
intros.
fold (inclusion (irreducible g) g) in H30.
generalize (inclusion_impl_le_h (irreducible g) g H30).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
apply H33.
generalize (h_le_h_ana_h g).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize (ana_h_equiv_irr_h g).
unfold equiv_h in |- *.
intro.
elim H35.
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
apply H36.
apply SynInc.
generalize (analysis_is_analysis g).
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.
elim H38.
intros.
elim H39.
unfold stable_analysis in |- *.
unfold inclusion in |- *.
intros.
apply H42.
apply (AnaDec (analysis_def g) M' N0 K L0).
apply H37.
fold (inclusion g (irreducible g)) in H29.
generalize (inclusion_impl_le_h g (irreducible g) H29).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
apply H43.
cut (L = L0).
generalize H1.

*****
H43 : forall (M N : Msg) (_ : synthesis g M N), synthesis (irreducible g) M N
H42 : forall (M N : Msg) (_ : analysis (analysis_def g) M N),\nanalysis_def g M N
H41 : forall (M N : Msg) (_ : g M N), analysis_def g M N
H40 : forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\ninclusion (analysis_def g) h'
H39 : and (inclusion g (analysis_def g)) (stable_analysis (analysis_def g))
H38 : and\n (and (inclusion g (analysis_def g))\n (stable_analysis (analysis_def g)))\n (forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\n inclusion (analysis_def g) h')
H37 : forall (M N : Msg) (_ : synthesis (irreducible g) M N),\nsynthesis (analysis_def g) M N
H36 : forall (M N : Msg) (_ : synthesis (analysis_def g) M N),\nsynthesis (irreducible g) M N
H35 : and (le_h (analysis_def g) (irreducible g))\n (le_h (irreducible g) (analysis_def g))
H34 : forall (M N : Msg) (_ : synthesis g M N),\nsynthesis (analysis_def g) M N
H33 : forall (M N : Msg) (_ : synthesis (irreducible g) M N), synthesis g M N
H32 : or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))
H31 : analysis_def g (MEnc M' K) (MEnc N0 L0)
H30 : inclusion (irreducible g) g
H29 : inclusion g (irreducible g)
H28 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))),\nirreducible g (MEnc M' K) (MEnc N0 L0)
H27 : forall _ : irreducible g (MEnc M' K) (MEnc N0 L0),\nand (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0)))
H26 : forall M N K L : Msg,\niff (irreducible g (MEnc M K) (MEnc N L))\n (and (analysis_def g (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def g) M N))\n (not (synthesis (analysis_def g) K L))))
H25 : inclusion (irreducible g) g
H24 : inclusion g (irreducible g)
H23 : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
H21 : eq (MEnc N0 L0) N
H19 : eq K0 K
H18 : eq M0 M'
H22 : synthesis h K L0
H20 : synthesis h M' N0
M0,K0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
L : Msg
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N0 L0)
M,N,M',K,N0,L0 : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
forall _ : le_h g h, eq L L0
+++++
unfold le_h in |- *.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
exists N0.
split.
generalize H.
unfold is_irreducible in |- *.
unfold equal in |- *.
intro.
elim H23.
intros.
rewrite H14 in H13.
rewrite <- H21 in H13.
generalize (irreducible_enc g).
intros.
elim (H26 M' N0 K L0).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
elim (H27 (H29 (MEnc M' K) (MEnc N0 L0) H13)).
intros.
fold (inclusion (irreducible g) g) in H30.
generalize (inclusion_impl_le_h (irreducible g) g H30).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
apply H33.
generalize (h_le_h_ana_h g).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize (ana_h_equiv_irr_h g).
unfold equiv_h in |- *.
intro.
elim H35.
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
apply H36.
apply SynInc.
generalize (analysis_is_analysis g).
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.
elim H38.
intros.
elim H39.
unfold stable_analysis in |- *.
unfold inclusion in |- *.
intros.
apply H42.
apply (AnaDec (analysis_def g) M' N0 K L0).
apply H37.
fold (inclusion g (irreducible g)) in H29.
generalize (inclusion_impl_le_h g (irreducible g) H29).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
apply H43.
cut (L = L0).
generalize H1.
unfold le_h in |- *.

*****
H43 : forall (M N : Msg) (_ : synthesis g M N), synthesis (irreducible g) M N
H42 : forall (M N : Msg) (_ : analysis (analysis_def g) M N),\nanalysis_def g M N
H41 : forall (M N : Msg) (_ : g M N), analysis_def g M N
H40 : forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\ninclusion (analysis_def g) h'
H39 : and (inclusion g (analysis_def g)) (stable_analysis (analysis_def g))
H38 : and\n (and (inclusion g (analysis_def g))\n (stable_analysis (analysis_def g)))\n (forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\n inclusion (analysis_def g) h')
H37 : forall (M N : Msg) (_ : synthesis (irreducible g) M N),\nsynthesis (analysis_def g) M N
H36 : forall (M N : Msg) (_ : synthesis (analysis_def g) M N),\nsynthesis (irreducible g) M N
H35 : and (le_h (analysis_def g) (irreducible g))\n (le_h (irreducible g) (analysis_def g))
H34 : forall (M N : Msg) (_ : synthesis g M N),\nsynthesis (analysis_def g) M N
H33 : forall (M N : Msg) (_ : synthesis (irreducible g) M N), synthesis g M N
H32 : or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))
H31 : analysis_def g (MEnc M' K) (MEnc N0 L0)
H30 : inclusion (irreducible g) g
H29 : inclusion g (irreducible g)
H28 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))),\nirreducible g (MEnc M' K) (MEnc N0 L0)
H27 : forall _ : irreducible g (MEnc M' K) (MEnc N0 L0),\nand (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0)))
H26 : forall M N K L : Msg,\niff (irreducible g (MEnc M K) (MEnc N L))\n (and (analysis_def g (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def g) M N))\n (not (synthesis (analysis_def g) K L))))
H25 : inclusion (irreducible g) g
H24 : inclusion g (irreducible g)
H23 : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
H21 : eq (MEnc N0 L0) N
H19 : eq K0 K
H18 : eq M0 M'
H22 : synthesis h K L0
H20 : synthesis h M' N0
M0,K0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
L : Msg
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N0 L0)
M,N,M',K,N0,L0 : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
forall _ : inclusion (synthesis g) (synthesis h), eq L L0
+++++
unfold inclusion in |- *.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
exists N0.
split.
generalize H.
unfold is_irreducible in |- *.
unfold equal in |- *.
intro.
elim H23.
intros.
rewrite H14 in H13.
rewrite <- H21 in H13.
generalize (irreducible_enc g).
intros.
elim (H26 M' N0 K L0).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
elim (H27 (H29 (MEnc M' K) (MEnc N0 L0) H13)).
intros.
fold (inclusion (irreducible g) g) in H30.
generalize (inclusion_impl_le_h (irreducible g) g H30).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
apply H33.
generalize (h_le_h_ana_h g).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize (ana_h_equiv_irr_h g).
unfold equiv_h in |- *.
intro.
elim H35.
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
apply H36.
apply SynInc.
generalize (analysis_is_analysis g).
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.
elim H38.
intros.
elim H39.
unfold stable_analysis in |- *.
unfold inclusion in |- *.
intros.
apply H42.
apply (AnaDec (analysis_def g) M' N0 K L0).
apply H37.
fold (inclusion g (irreducible g)) in H29.
generalize (inclusion_impl_le_h g (irreducible g) H29).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
apply H43.
cut (L = L0).
generalize H1.
unfold le_h in |- *.
unfold inclusion in |- *.

*****
H43 : forall (M N : Msg) (_ : synthesis g M N), synthesis (irreducible g) M N
H42 : forall (M N : Msg) (_ : analysis (analysis_def g) M N),\nanalysis_def g M N
H41 : forall (M N : Msg) (_ : g M N), analysis_def g M N
H40 : forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\ninclusion (analysis_def g) h'
H39 : and (inclusion g (analysis_def g)) (stable_analysis (analysis_def g))
H38 : and\n (and (inclusion g (analysis_def g))\n (stable_analysis (analysis_def g)))\n (forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\n inclusion (analysis_def g) h')
H37 : forall (M N : Msg) (_ : synthesis (irreducible g) M N),\nsynthesis (analysis_def g) M N
H36 : forall (M N : Msg) (_ : synthesis (analysis_def g) M N),\nsynthesis (irreducible g) M N
H35 : and (le_h (analysis_def g) (irreducible g))\n (le_h (irreducible g) (analysis_def g))
H34 : forall (M N : Msg) (_ : synthesis g M N),\nsynthesis (analysis_def g) M N
H33 : forall (M N : Msg) (_ : synthesis (irreducible g) M N), synthesis g M N
H32 : or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))
H31 : analysis_def g (MEnc M' K) (MEnc N0 L0)
H30 : inclusion (irreducible g) g
H29 : inclusion g (irreducible g)
H28 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))),\nirreducible g (MEnc M' K) (MEnc N0 L0)
H27 : forall _ : irreducible g (MEnc M' K) (MEnc N0 L0),\nand (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0)))
H26 : forall M N K L : Msg,\niff (irreducible g (MEnc M K) (MEnc N L))\n (and (analysis_def g (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def g) M N))\n (not (synthesis (analysis_def g) K L))))
H25 : inclusion (irreducible g) g
H24 : inclusion g (irreducible g)
H23 : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
H21 : eq (MEnc N0 L0) N
H19 : eq K0 K
H18 : eq M0 M'
H22 : synthesis h K L0
H20 : synthesis h M' N0
M0,K0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
L : Msg
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N0 L0)
M,N,M',K,N0,L0 : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
forall _ : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N, eq L L0
+++++
intros.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
exists N0.
split.
generalize H.
unfold is_irreducible in |- *.
unfold equal in |- *.
intro.
elim H23.
intros.
rewrite H14 in H13.
rewrite <- H21 in H13.
generalize (irreducible_enc g).
intros.
elim (H26 M' N0 K L0).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
elim (H27 (H29 (MEnc M' K) (MEnc N0 L0) H13)).
intros.
fold (inclusion (irreducible g) g) in H30.
generalize (inclusion_impl_le_h (irreducible g) g H30).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
apply H33.
generalize (h_le_h_ana_h g).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize (ana_h_equiv_irr_h g).
unfold equiv_h in |- *.
intro.
elim H35.
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
apply H36.
apply SynInc.
generalize (analysis_is_analysis g).
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.
elim H38.
intros.
elim H39.
unfold stable_analysis in |- *.
unfold inclusion in |- *.
intros.
apply H42.
apply (AnaDec (analysis_def g) M' N0 K L0).
apply H37.
fold (inclusion g (irreducible g)) in H29.
generalize (inclusion_impl_le_h g (irreducible g) H29).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
apply H43.
cut (L = L0).
generalize H1.
unfold le_h in |- *.
unfold inclusion in |- *.
intros.

*****
H44 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H43 : forall (M N : Msg) (_ : synthesis g M N), synthesis (irreducible g) M N
H42 : forall (M N : Msg) (_ : analysis (analysis_def g) M N),\nanalysis_def g M N
H41 : forall (M N : Msg) (_ : g M N), analysis_def g M N
H40 : forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\ninclusion (analysis_def g) h'
H39 : and (inclusion g (analysis_def g)) (stable_analysis (analysis_def g))
H38 : and\n (and (inclusion g (analysis_def g))\n (stable_analysis (analysis_def g)))\n (forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\n inclusion (analysis_def g) h')
H37 : forall (M N : Msg) (_ : synthesis (irreducible g) M N),\nsynthesis (analysis_def g) M N
H36 : forall (M N : Msg) (_ : synthesis (analysis_def g) M N),\nsynthesis (irreducible g) M N
H35 : and (le_h (analysis_def g) (irreducible g))\n (le_h (irreducible g) (analysis_def g))
H34 : forall (M N : Msg) (_ : synthesis g M N),\nsynthesis (analysis_def g) M N
H33 : forall (M N : Msg) (_ : synthesis (irreducible g) M N), synthesis g M N
H32 : or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))
H31 : analysis_def g (MEnc M' K) (MEnc N0 L0)
H30 : inclusion (irreducible g) g
H29 : inclusion g (irreducible g)
H28 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))),\nirreducible g (MEnc M' K) (MEnc N0 L0)
H27 : forall _ : irreducible g (MEnc M' K) (MEnc N0 L0),\nand (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0)))
H26 : forall M N K L : Msg,\niff (irreducible g (MEnc M K) (MEnc N L))\n (and (analysis_def g (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def g) M N))\n (not (synthesis (analysis_def g) K L))))
H25 : inclusion (irreducible g) g
H24 : inclusion g (irreducible g)
H23 : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
H21 : eq (MEnc N0 L0) N
H19 : eq K0 K
H18 : eq M0 M'
H22 : synthesis h K L0
H20 : synthesis h M' N0
M0,K0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
L : Msg
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N0 L0)
M,N,M',K,N0,L0 : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
eq L L0
+++++
generalize (H44 (inv K) (inv L) H15).
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
exists N0.
split.
generalize H.
unfold is_irreducible in |- *.
unfold equal in |- *.
intro.
elim H23.
intros.
rewrite H14 in H13.
rewrite <- H21 in H13.
generalize (irreducible_enc g).
intros.
elim (H26 M' N0 K L0).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
elim (H27 (H29 (MEnc M' K) (MEnc N0 L0) H13)).
intros.
fold (inclusion (irreducible g) g) in H30.
generalize (inclusion_impl_le_h (irreducible g) g H30).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
apply H33.
generalize (h_le_h_ana_h g).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize (ana_h_equiv_irr_h g).
unfold equiv_h in |- *.
intro.
elim H35.
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
apply H36.
apply SynInc.
generalize (analysis_is_analysis g).
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.
elim H38.
intros.
elim H39.
unfold stable_analysis in |- *.
unfold inclusion in |- *.
intros.
apply H42.
apply (AnaDec (analysis_def g) M' N0 K L0).
apply H37.
fold (inclusion g (irreducible g)) in H29.
generalize (inclusion_impl_le_h g (irreducible g) H29).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
apply H43.
cut (L = L0).
generalize H1.
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize (H44 (inv K) (inv L) H15).

*****
H44 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H43 : forall (M N : Msg) (_ : synthesis g M N), synthesis (irreducible g) M N
H42 : forall (M N : Msg) (_ : analysis (analysis_def g) M N),\nanalysis_def g M N
H41 : forall (M N : Msg) (_ : g M N), analysis_def g M N
H40 : forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\ninclusion (analysis_def g) h'
H39 : and (inclusion g (analysis_def g)) (stable_analysis (analysis_def g))
H38 : and\n (and (inclusion g (analysis_def g))\n (stable_analysis (analysis_def g)))\n (forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\n inclusion (analysis_def g) h')
H37 : forall (M N : Msg) (_ : synthesis (irreducible g) M N),\nsynthesis (analysis_def g) M N
H36 : forall (M N : Msg) (_ : synthesis (analysis_def g) M N),\nsynthesis (irreducible g) M N
H35 : and (le_h (analysis_def g) (irreducible g))\n (le_h (irreducible g) (analysis_def g))
H34 : forall (M N : Msg) (_ : synthesis g M N),\nsynthesis (analysis_def g) M N
H33 : forall (M N : Msg) (_ : synthesis (irreducible g) M N), synthesis g M N
H32 : or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))
H31 : analysis_def g (MEnc M' K) (MEnc N0 L0)
H30 : inclusion (irreducible g) g
H29 : inclusion g (irreducible g)
H28 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))),\nirreducible g (MEnc M' K) (MEnc N0 L0)
H27 : forall _ : irreducible g (MEnc M' K) (MEnc N0 L0),\nand (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0)))
H26 : forall M N K L : Msg,\niff (irreducible g (MEnc M K) (MEnc N L))\n (and (analysis_def g (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def g) M N))\n (not (synthesis (analysis_def g) K L))))
H25 : inclusion (irreducible g) g
H24 : inclusion g (irreducible g)
H23 : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
H21 : eq (MEnc N0 L0) N
H19 : eq K0 K
H18 : eq M0 M'
H22 : synthesis h K L0
H20 : synthesis h M' N0
M0,K0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
L : Msg
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N0 L0)
M,N,M',K,N0,L0 : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
forall _ : synthesis h (inv K) (inv L), eq L L0
+++++
intro.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
exists N0.
split.
generalize H.
unfold is_irreducible in |- *.
unfold equal in |- *.
intro.
elim H23.
intros.
rewrite H14 in H13.
rewrite <- H21 in H13.
generalize (irreducible_enc g).
intros.
elim (H26 M' N0 K L0).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
elim (H27 (H29 (MEnc M' K) (MEnc N0 L0) H13)).
intros.
fold (inclusion (irreducible g) g) in H30.
generalize (inclusion_impl_le_h (irreducible g) g H30).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
apply H33.
generalize (h_le_h_ana_h g).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize (ana_h_equiv_irr_h g).
unfold equiv_h in |- *.
intro.
elim H35.
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
apply H36.
apply SynInc.
generalize (analysis_is_analysis g).
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.
elim H38.
intros.
elim H39.
unfold stable_analysis in |- *.
unfold inclusion in |- *.
intros.
apply H42.
apply (AnaDec (analysis_def g) M' N0 K L0).
apply H37.
fold (inclusion g (irreducible g)) in H29.
generalize (inclusion_impl_le_h g (irreducible g) H29).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
apply H43.
cut (L = L0).
generalize H1.
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize (H44 (inv K) (inv L) H15).
intro.

*****
H45 : synthesis h (inv K) (inv L)
H44 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H43 : forall (M N : Msg) (_ : synthesis g M N), synthesis (irreducible g) M N
H42 : forall (M N : Msg) (_ : analysis (analysis_def g) M N),\nanalysis_def g M N
H41 : forall (M N : Msg) (_ : g M N), analysis_def g M N
H40 : forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\ninclusion (analysis_def g) h'
H39 : and (inclusion g (analysis_def g)) (stable_analysis (analysis_def g))
H38 : and\n (and (inclusion g (analysis_def g))\n (stable_analysis (analysis_def g)))\n (forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\n inclusion (analysis_def g) h')
H37 : forall (M N : Msg) (_ : synthesis (irreducible g) M N),\nsynthesis (analysis_def g) M N
H36 : forall (M N : Msg) (_ : synthesis (analysis_def g) M N),\nsynthesis (irreducible g) M N
H35 : and (le_h (analysis_def g) (irreducible g))\n (le_h (irreducible g) (analysis_def g))
H34 : forall (M N : Msg) (_ : synthesis g M N),\nsynthesis (analysis_def g) M N
H33 : forall (M N : Msg) (_ : synthesis (irreducible g) M N), synthesis g M N
H32 : or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))
H31 : analysis_def g (MEnc M' K) (MEnc N0 L0)
H30 : inclusion (irreducible g) g
H29 : inclusion g (irreducible g)
H28 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))),\nirreducible g (MEnc M' K) (MEnc N0 L0)
H27 : forall _ : irreducible g (MEnc M' K) (MEnc N0 L0),\nand (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0)))
H26 : forall M N K L : Msg,\niff (irreducible g (MEnc M K) (MEnc N L))\n (and (analysis_def g (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def g) M N))\n (not (synthesis (analysis_def g) K L))))
H25 : inclusion (irreducible g) g
H24 : inclusion g (irreducible g)
H23 : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
H21 : eq (MEnc N0 L0) N
H19 : eq K0 K
H18 : eq M0 M'
H22 : synthesis h K L0
H20 : synthesis h M' N0
M0,K0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
L : Msg
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N0 L0)
M,N,M',K,N0,L0 : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
eq L L0
+++++
elim H11.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
exists N0.
split.
generalize H.
unfold is_irreducible in |- *.
unfold equal in |- *.
intro.
elim H23.
intros.
rewrite H14 in H13.
rewrite <- H21 in H13.
generalize (irreducible_enc g).
intros.
elim (H26 M' N0 K L0).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
elim (H27 (H29 (MEnc M' K) (MEnc N0 L0) H13)).
intros.
fold (inclusion (irreducible g) g) in H30.
generalize (inclusion_impl_le_h (irreducible g) g H30).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
apply H33.
generalize (h_le_h_ana_h g).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize (ana_h_equiv_irr_h g).
unfold equiv_h in |- *.
intro.
elim H35.
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
apply H36.
apply SynInc.
generalize (analysis_is_analysis g).
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.
elim H38.
intros.
elim H39.
unfold stable_analysis in |- *.
unfold inclusion in |- *.
intros.
apply H42.
apply (AnaDec (analysis_def g) M' N0 K L0).
apply H37.
fold (inclusion g (irreducible g)) in H29.
generalize (inclusion_impl_le_h g (irreducible g) H29).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
apply H43.
cut (L = L0).
generalize H1.
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize (H44 (inv K) (inv L) H15).
intro.
elim H11.

*****
H45 : synthesis h (inv K) (inv L)
H44 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H43 : forall (M N : Msg) (_ : synthesis g M N), synthesis (irreducible g) M N
H42 : forall (M N : Msg) (_ : analysis (analysis_def g) M N),\nanalysis_def g M N
H41 : forall (M N : Msg) (_ : g M N), analysis_def g M N
H40 : forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\ninclusion (analysis_def g) h'
H39 : and (inclusion g (analysis_def g)) (stable_analysis (analysis_def g))
H38 : and\n (and (inclusion g (analysis_def g))\n (stable_analysis (analysis_def g)))\n (forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\n inclusion (analysis_def g) h')
H37 : forall (M N : Msg) (_ : synthesis (irreducible g) M N),\nsynthesis (analysis_def g) M N
H36 : forall (M N : Msg) (_ : synthesis (analysis_def g) M N),\nsynthesis (irreducible g) M N
H35 : and (le_h (analysis_def g) (irreducible g))\n (le_h (irreducible g) (analysis_def g))
H34 : forall (M N : Msg) (_ : synthesis g M N),\nsynthesis (analysis_def g) M N
H33 : forall (M N : Msg) (_ : synthesis (irreducible g) M N), synthesis g M N
H32 : or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))
H31 : analysis_def g (MEnc M' K) (MEnc N0 L0)
H30 : inclusion (irreducible g) g
H29 : inclusion g (irreducible g)
H28 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))),\nirreducible g (MEnc M' K) (MEnc N0 L0)
H27 : forall _ : irreducible g (MEnc M' K) (MEnc N0 L0),\nand (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0)))
H26 : forall M N K L : Msg,\niff (irreducible g (MEnc M K) (MEnc N L))\n (and (analysis_def g (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def g) M N))\n (not (synthesis (analysis_def g) K L))))
H25 : inclusion (irreducible g) g
H24 : inclusion g (irreducible g)
H23 : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
H21 : eq (MEnc N0 L0) N
H19 : eq K0 K
H18 : eq M0 M'
H22 : synthesis h K L0
H20 : synthesis h M' N0
M0,K0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
L : Msg
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N0 L0)
M,N,M',K,N0,L0 : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
forall (_ : enc_analysis_left h) (_ : injective_inv_left h), eq L L0
+++++
intros.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
exists N0.
split.
generalize H.
unfold is_irreducible in |- *.
unfold equal in |- *.
intro.
elim H23.
intros.
rewrite H14 in H13.
rewrite <- H21 in H13.
generalize (irreducible_enc g).
intros.
elim (H26 M' N0 K L0).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
elim (H27 (H29 (MEnc M' K) (MEnc N0 L0) H13)).
intros.
fold (inclusion (irreducible g) g) in H30.
generalize (inclusion_impl_le_h (irreducible g) g H30).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
apply H33.
generalize (h_le_h_ana_h g).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize (ana_h_equiv_irr_h g).
unfold equiv_h in |- *.
intro.
elim H35.
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
apply H36.
apply SynInc.
generalize (analysis_is_analysis g).
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.
elim H38.
intros.
elim H39.
unfold stable_analysis in |- *.
unfold inclusion in |- *.
intros.
apply H42.
apply (AnaDec (analysis_def g) M' N0 K L0).
apply H37.
fold (inclusion g (irreducible g)) in H29.
generalize (inclusion_impl_le_h g (irreducible g) H29).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
apply H43.
cut (L = L0).
generalize H1.
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize (H44 (inv K) (inv L) H15).
intro.
elim H11.
intros.

*****
H47 : injective_inv_left h
H46 : enc_analysis_left h
H45 : synthesis h (inv K) (inv L)
H44 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H43 : forall (M N : Msg) (_ : synthesis g M N), synthesis (irreducible g) M N
H42 : forall (M N : Msg) (_ : analysis (analysis_def g) M N),\nanalysis_def g M N
H41 : forall (M N : Msg) (_ : g M N), analysis_def g M N
H40 : forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\ninclusion (analysis_def g) h'
H39 : and (inclusion g (analysis_def g)) (stable_analysis (analysis_def g))
H38 : and\n (and (inclusion g (analysis_def g))\n (stable_analysis (analysis_def g)))\n (forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\n inclusion (analysis_def g) h')
H37 : forall (M N : Msg) (_ : synthesis (irreducible g) M N),\nsynthesis (analysis_def g) M N
H36 : forall (M N : Msg) (_ : synthesis (analysis_def g) M N),\nsynthesis (irreducible g) M N
H35 : and (le_h (analysis_def g) (irreducible g))\n (le_h (irreducible g) (analysis_def g))
H34 : forall (M N : Msg) (_ : synthesis g M N),\nsynthesis (analysis_def g) M N
H33 : forall (M N : Msg) (_ : synthesis (irreducible g) M N), synthesis g M N
H32 : or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))
H31 : analysis_def g (MEnc M' K) (MEnc N0 L0)
H30 : inclusion (irreducible g) g
H29 : inclusion g (irreducible g)
H28 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))),\nirreducible g (MEnc M' K) (MEnc N0 L0)
H27 : forall _ : irreducible g (MEnc M' K) (MEnc N0 L0),\nand (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0)))
H26 : forall M N K L : Msg,\niff (irreducible g (MEnc M K) (MEnc N L))\n (and (analysis_def g (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def g) M N))\n (not (synthesis (analysis_def g) K L))))
H25 : inclusion (irreducible g) g
H24 : inclusion g (irreducible g)
H23 : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
H21 : eq (MEnc N0 L0) N
H19 : eq K0 K
H18 : eq M0 M'
H22 : synthesis h K L0
H20 : synthesis h M' N0
M0,K0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
L : Msg
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N0 L0)
M,N,M',K,N0,L0 : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
eq L L0
+++++
generalize (inj_inv_left_syn h H4 H10 H6 H8 H47).
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
exists N0.
split.
generalize H.
unfold is_irreducible in |- *.
unfold equal in |- *.
intro.
elim H23.
intros.
rewrite H14 in H13.
rewrite <- H21 in H13.
generalize (irreducible_enc g).
intros.
elim (H26 M' N0 K L0).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
elim (H27 (H29 (MEnc M' K) (MEnc N0 L0) H13)).
intros.
fold (inclusion (irreducible g) g) in H30.
generalize (inclusion_impl_le_h (irreducible g) g H30).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
apply H33.
generalize (h_le_h_ana_h g).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize (ana_h_equiv_irr_h g).
unfold equiv_h in |- *.
intro.
elim H35.
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
apply H36.
apply SynInc.
generalize (analysis_is_analysis g).
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.
elim H38.
intros.
elim H39.
unfold stable_analysis in |- *.
unfold inclusion in |- *.
intros.
apply H42.
apply (AnaDec (analysis_def g) M' N0 K L0).
apply H37.
fold (inclusion g (irreducible g)) in H29.
generalize (inclusion_impl_le_h g (irreducible g) H29).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
apply H43.
cut (L = L0).
generalize H1.
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize (H44 (inv K) (inv L) H15).
intro.
elim H11.
intros.
generalize (inj_inv_left_syn h H4 H10 H6 H8 H47).

*****
H47 : injective_inv_left h
H46 : enc_analysis_left h
H45 : synthesis h (inv K) (inv L)
H44 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H43 : forall (M N : Msg) (_ : synthesis g M N), synthesis (irreducible g) M N
H42 : forall (M N : Msg) (_ : analysis (analysis_def g) M N),\nanalysis_def g M N
H41 : forall (M N : Msg) (_ : g M N), analysis_def g M N
H40 : forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\ninclusion (analysis_def g) h'
H39 : and (inclusion g (analysis_def g)) (stable_analysis (analysis_def g))
H38 : and\n (and (inclusion g (analysis_def g))\n (stable_analysis (analysis_def g)))\n (forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\n inclusion (analysis_def g) h')
H37 : forall (M N : Msg) (_ : synthesis (irreducible g) M N),\nsynthesis (analysis_def g) M N
H36 : forall (M N : Msg) (_ : synthesis (analysis_def g) M N),\nsynthesis (irreducible g) M N
H35 : and (le_h (analysis_def g) (irreducible g))\n (le_h (irreducible g) (analysis_def g))
H34 : forall (M N : Msg) (_ : synthesis g M N),\nsynthesis (analysis_def g) M N
H33 : forall (M N : Msg) (_ : synthesis (irreducible g) M N), synthesis g M N
H32 : or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))
H31 : analysis_def g (MEnc M' K) (MEnc N0 L0)
H30 : inclusion (irreducible g) g
H29 : inclusion g (irreducible g)
H28 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))),\nirreducible g (MEnc M' K) (MEnc N0 L0)
H27 : forall _ : irreducible g (MEnc M' K) (MEnc N0 L0),\nand (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0)))
H26 : forall M N K L : Msg,\niff (irreducible g (MEnc M K) (MEnc N L))\n (and (analysis_def g (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def g) M N))\n (not (synthesis (analysis_def g) K L))))
H25 : inclusion (irreducible g) g
H24 : inclusion g (irreducible g)
H23 : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
H21 : eq (MEnc N0 L0) N
H19 : eq K0 K
H18 : eq M0 M'
H22 : synthesis h K L0
H20 : synthesis h M' N0
M0,K0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
L : Msg
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N0 L0)
M,N,M',K,N0,L0 : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
forall _ : injective_inv_left (synthesis h), eq L L0
+++++
unfold injective_inv_left in |- *.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
exists N0.
split.
generalize H.
unfold is_irreducible in |- *.
unfold equal in |- *.
intro.
elim H23.
intros.
rewrite H14 in H13.
rewrite <- H21 in H13.
generalize (irreducible_enc g).
intros.
elim (H26 M' N0 K L0).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
elim (H27 (H29 (MEnc M' K) (MEnc N0 L0) H13)).
intros.
fold (inclusion (irreducible g) g) in H30.
generalize (inclusion_impl_le_h (irreducible g) g H30).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
apply H33.
generalize (h_le_h_ana_h g).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize (ana_h_equiv_irr_h g).
unfold equiv_h in |- *.
intro.
elim H35.
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
apply H36.
apply SynInc.
generalize (analysis_is_analysis g).
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.
elim H38.
intros.
elim H39.
unfold stable_analysis in |- *.
unfold inclusion in |- *.
intros.
apply H42.
apply (AnaDec (analysis_def g) M' N0 K L0).
apply H37.
fold (inclusion g (irreducible g)) in H29.
generalize (inclusion_impl_le_h g (irreducible g) H29).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
apply H43.
cut (L = L0).
generalize H1.
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize (H44 (inv K) (inv L) H15).
intro.
elim H11.
intros.
generalize (inj_inv_left_syn h H4 H10 H6 H8 H47).
unfold injective_inv_left in |- *.

*****
H47 : injective_inv_left h
H46 : enc_analysis_left h
H45 : synthesis h (inv K) (inv L)
H44 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H43 : forall (M N : Msg) (_ : synthesis g M N), synthesis (irreducible g) M N
H42 : forall (M N : Msg) (_ : analysis (analysis_def g) M N),\nanalysis_def g M N
H41 : forall (M N : Msg) (_ : g M N), analysis_def g M N
H40 : forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\ninclusion (analysis_def g) h'
H39 : and (inclusion g (analysis_def g)) (stable_analysis (analysis_def g))
H38 : and\n (and (inclusion g (analysis_def g))\n (stable_analysis (analysis_def g)))\n (forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\n inclusion (analysis_def g) h')
H37 : forall (M N : Msg) (_ : synthesis (irreducible g) M N),\nsynthesis (analysis_def g) M N
H36 : forall (M N : Msg) (_ : synthesis (analysis_def g) M N),\nsynthesis (irreducible g) M N
H35 : and (le_h (analysis_def g) (irreducible g))\n (le_h (irreducible g) (analysis_def g))
H34 : forall (M N : Msg) (_ : synthesis g M N),\nsynthesis (analysis_def g) M N
H33 : forall (M N : Msg) (_ : synthesis (irreducible g) M N), synthesis g M N
H32 : or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))
H31 : analysis_def g (MEnc M' K) (MEnc N0 L0)
H30 : inclusion (irreducible g) g
H29 : inclusion g (irreducible g)
H28 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))),\nirreducible g (MEnc M' K) (MEnc N0 L0)
H27 : forall _ : irreducible g (MEnc M' K) (MEnc N0 L0),\nand (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0)))
H26 : forall M N K L : Msg,\niff (irreducible g (MEnc M K) (MEnc N L))\n (and (analysis_def g (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def g) M N))\n (not (synthesis (analysis_def g) K L))))
H25 : inclusion (irreducible g) g
H24 : inclusion g (irreducible g)
H23 : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
H21 : eq (MEnc N0 L0) N
H19 : eq K0 K
H18 : eq M0 M'
H22 : synthesis h K L0
H20 : synthesis h M' N0
M0,K0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
L : Msg
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N0 L0)
M,N,M',K,N0,L0 : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
forall _ : forall (M N : Msg) (_ : synthesis h M N) (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M' (inv M)), eq N' (inv N), eq L L0
+++++
intros.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
exists N0.
split.
generalize H.
unfold is_irreducible in |- *.
unfold equal in |- *.
intro.
elim H23.
intros.
rewrite H14 in H13.
rewrite <- H21 in H13.
generalize (irreducible_enc g).
intros.
elim (H26 M' N0 K L0).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
elim (H27 (H29 (MEnc M' K) (MEnc N0 L0) H13)).
intros.
fold (inclusion (irreducible g) g) in H30.
generalize (inclusion_impl_le_h (irreducible g) g H30).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
apply H33.
generalize (h_le_h_ana_h g).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize (ana_h_equiv_irr_h g).
unfold equiv_h in |- *.
intro.
elim H35.
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
apply H36.
apply SynInc.
generalize (analysis_is_analysis g).
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.
elim H38.
intros.
elim H39.
unfold stable_analysis in |- *.
unfold inclusion in |- *.
intros.
apply H42.
apply (AnaDec (analysis_def g) M' N0 K L0).
apply H37.
fold (inclusion g (irreducible g)) in H29.
generalize (inclusion_impl_le_h g (irreducible g) H29).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
apply H43.
cut (L = L0).
generalize H1.
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize (H44 (inv K) (inv L) H15).
intro.
elim H11.
intros.
generalize (inj_inv_left_syn h H4 H10 H6 H8 H47).
unfold injective_inv_left in |- *.
intros.

*****
H48 : forall (M N : Msg) (_ : synthesis h M N) (M' N' : Msg)\n (_ : synthesis h M' N') (_ : eq M' (inv M)), eq N' (inv N)
H47 : injective_inv_left h
H46 : enc_analysis_left h
H45 : synthesis h (inv K) (inv L)
H44 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H43 : forall (M N : Msg) (_ : synthesis g M N), synthesis (irreducible g) M N
H42 : forall (M N : Msg) (_ : analysis (analysis_def g) M N),\nanalysis_def g M N
H41 : forall (M N : Msg) (_ : g M N), analysis_def g M N
H40 : forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\ninclusion (analysis_def g) h'
H39 : and (inclusion g (analysis_def g)) (stable_analysis (analysis_def g))
H38 : and\n (and (inclusion g (analysis_def g))\n (stable_analysis (analysis_def g)))\n (forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\n inclusion (analysis_def g) h')
H37 : forall (M N : Msg) (_ : synthesis (irreducible g) M N),\nsynthesis (analysis_def g) M N
H36 : forall (M N : Msg) (_ : synthesis (analysis_def g) M N),\nsynthesis (irreducible g) M N
H35 : and (le_h (analysis_def g) (irreducible g))\n (le_h (irreducible g) (analysis_def g))
H34 : forall (M N : Msg) (_ : synthesis g M N),\nsynthesis (analysis_def g) M N
H33 : forall (M N : Msg) (_ : synthesis (irreducible g) M N), synthesis g M N
H32 : or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))
H31 : analysis_def g (MEnc M' K) (MEnc N0 L0)
H30 : inclusion (irreducible g) g
H29 : inclusion g (irreducible g)
H28 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))),\nirreducible g (MEnc M' K) (MEnc N0 L0)
H27 : forall _ : irreducible g (MEnc M' K) (MEnc N0 L0),\nand (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0)))
H26 : forall M N K L : Msg,\niff (irreducible g (MEnc M K) (MEnc N L))\n (and (analysis_def g (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def g) M N))\n (not (synthesis (analysis_def g) K L))))
H25 : inclusion (irreducible g) g
H24 : inclusion g (irreducible g)
H23 : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
H21 : eq (MEnc N0 L0) N
H19 : eq K0 K
H18 : eq M0 M'
H22 : synthesis h K L0
H20 : synthesis h M' N0
M0,K0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
L : Msg
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N0 L0)
M,N,M',K,N0,L0 : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
eq L L0
+++++
generalize (H48 K L0 H22 (inv K) (inv L) H45).
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
exists N0.
split.
generalize H.
unfold is_irreducible in |- *.
unfold equal in |- *.
intro.
elim H23.
intros.
rewrite H14 in H13.
rewrite <- H21 in H13.
generalize (irreducible_enc g).
intros.
elim (H26 M' N0 K L0).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
elim (H27 (H29 (MEnc M' K) (MEnc N0 L0) H13)).
intros.
fold (inclusion (irreducible g) g) in H30.
generalize (inclusion_impl_le_h (irreducible g) g H30).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
apply H33.
generalize (h_le_h_ana_h g).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize (ana_h_equiv_irr_h g).
unfold equiv_h in |- *.
intro.
elim H35.
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
apply H36.
apply SynInc.
generalize (analysis_is_analysis g).
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.
elim H38.
intros.
elim H39.
unfold stable_analysis in |- *.
unfold inclusion in |- *.
intros.
apply H42.
apply (AnaDec (analysis_def g) M' N0 K L0).
apply H37.
fold (inclusion g (irreducible g)) in H29.
generalize (inclusion_impl_le_h g (irreducible g) H29).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
apply H43.
cut (L = L0).
generalize H1.
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize (H44 (inv K) (inv L) H15).
intro.
elim H11.
intros.
generalize (inj_inv_left_syn h H4 H10 H6 H8 H47).
unfold injective_inv_left in |- *.
intros.
generalize (H48 K L0 H22 (inv K) (inv L) H45).

*****
H48 : forall (M N : Msg) (_ : synthesis h M N) (M' N' : Msg)\n (_ : synthesis h M' N') (_ : eq M' (inv M)), eq N' (inv N)
H47 : injective_inv_left h
H46 : enc_analysis_left h
H45 : synthesis h (inv K) (inv L)
H44 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H43 : forall (M N : Msg) (_ : synthesis g M N), synthesis (irreducible g) M N
H42 : forall (M N : Msg) (_ : analysis (analysis_def g) M N),\nanalysis_def g M N
H41 : forall (M N : Msg) (_ : g M N), analysis_def g M N
H40 : forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\ninclusion (analysis_def g) h'
H39 : and (inclusion g (analysis_def g)) (stable_analysis (analysis_def g))
H38 : and\n (and (inclusion g (analysis_def g))\n (stable_analysis (analysis_def g)))\n (forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\n inclusion (analysis_def g) h')
H37 : forall (M N : Msg) (_ : synthesis (irreducible g) M N),\nsynthesis (analysis_def g) M N
H36 : forall (M N : Msg) (_ : synthesis (analysis_def g) M N),\nsynthesis (irreducible g) M N
H35 : and (le_h (analysis_def g) (irreducible g))\n (le_h (irreducible g) (analysis_def g))
H34 : forall (M N : Msg) (_ : synthesis g M N),\nsynthesis (analysis_def g) M N
H33 : forall (M N : Msg) (_ : synthesis (irreducible g) M N), synthesis g M N
H32 : or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))
H31 : analysis_def g (MEnc M' K) (MEnc N0 L0)
H30 : inclusion (irreducible g) g
H29 : inclusion g (irreducible g)
H28 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))),\nirreducible g (MEnc M' K) (MEnc N0 L0)
H27 : forall _ : irreducible g (MEnc M' K) (MEnc N0 L0),\nand (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0)))
H26 : forall M N K L : Msg,\niff (irreducible g (MEnc M K) (MEnc N L))\n (and (analysis_def g (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def g) M N))\n (not (synthesis (analysis_def g) K L))))
H25 : inclusion (irreducible g) g
H24 : inclusion g (irreducible g)
H23 : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
H21 : eq (MEnc N0 L0) N
H19 : eq K0 K
H18 : eq M0 M'
H22 : synthesis h K L0
H20 : synthesis h M' N0
M0,K0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
L : Msg
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N0 L0)
M,N,M',K,N0,L0 : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
forall _ : forall _ : eq (inv K) (inv K), eq (inv L) (inv L0), eq L L0
+++++
intros.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
exists N0.
split.
generalize H.
unfold is_irreducible in |- *.
unfold equal in |- *.
intro.
elim H23.
intros.
rewrite H14 in H13.
rewrite <- H21 in H13.
generalize (irreducible_enc g).
intros.
elim (H26 M' N0 K L0).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
elim (H27 (H29 (MEnc M' K) (MEnc N0 L0) H13)).
intros.
fold (inclusion (irreducible g) g) in H30.
generalize (inclusion_impl_le_h (irreducible g) g H30).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
apply H33.
generalize (h_le_h_ana_h g).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize (ana_h_equiv_irr_h g).
unfold equiv_h in |- *.
intro.
elim H35.
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
apply H36.
apply SynInc.
generalize (analysis_is_analysis g).
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.
elim H38.
intros.
elim H39.
unfold stable_analysis in |- *.
unfold inclusion in |- *.
intros.
apply H42.
apply (AnaDec (analysis_def g) M' N0 K L0).
apply H37.
fold (inclusion g (irreducible g)) in H29.
generalize (inclusion_impl_le_h g (irreducible g) H29).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
apply H43.
cut (L = L0).
generalize H1.
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize (H44 (inv K) (inv L) H15).
intro.
elim H11.
intros.
generalize (inj_inv_left_syn h H4 H10 H6 H8 H47).
unfold injective_inv_left in |- *.
intros.
generalize (H48 K L0 H22 (inv K) (inv L) H45).
intros.

*****
H49 : forall _ : eq (inv K) (inv K), eq (inv L) (inv L0)
H48 : forall (M N : Msg) (_ : synthesis h M N) (M' N' : Msg)\n (_ : synthesis h M' N') (_ : eq M' (inv M)), eq N' (inv N)
H47 : injective_inv_left h
H46 : enc_analysis_left h
H45 : synthesis h (inv K) (inv L)
H44 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H43 : forall (M N : Msg) (_ : synthesis g M N), synthesis (irreducible g) M N
H42 : forall (M N : Msg) (_ : analysis (analysis_def g) M N),\nanalysis_def g M N
H41 : forall (M N : Msg) (_ : g M N), analysis_def g M N
H40 : forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\ninclusion (analysis_def g) h'
H39 : and (inclusion g (analysis_def g)) (stable_analysis (analysis_def g))
H38 : and\n (and (inclusion g (analysis_def g))\n (stable_analysis (analysis_def g)))\n (forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\n inclusion (analysis_def g) h')
H37 : forall (M N : Msg) (_ : synthesis (irreducible g) M N),\nsynthesis (analysis_def g) M N
H36 : forall (M N : Msg) (_ : synthesis (analysis_def g) M N),\nsynthesis (irreducible g) M N
H35 : and (le_h (analysis_def g) (irreducible g))\n (le_h (irreducible g) (analysis_def g))
H34 : forall (M N : Msg) (_ : synthesis g M N),\nsynthesis (analysis_def g) M N
H33 : forall (M N : Msg) (_ : synthesis (irreducible g) M N), synthesis g M N
H32 : or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))
H31 : analysis_def g (MEnc M' K) (MEnc N0 L0)
H30 : inclusion (irreducible g) g
H29 : inclusion g (irreducible g)
H28 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))),\nirreducible g (MEnc M' K) (MEnc N0 L0)
H27 : forall _ : irreducible g (MEnc M' K) (MEnc N0 L0),\nand (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0)))
H26 : forall M N K L : Msg,\niff (irreducible g (MEnc M K) (MEnc N L))\n (and (analysis_def g (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def g) M N))\n (not (synthesis (analysis_def g) K L))))
H25 : inclusion (irreducible g) g
H24 : inclusion g (irreducible g)
H23 : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
H21 : eq (MEnc N0 L0) N
H19 : eq K0 K
H18 : eq M0 M'
H22 : synthesis h K L0
H20 : synthesis h M' N0
M0,K0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
L : Msg
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N0 L0)
M,N,M',K,N0,L0 : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
eq L L0
+++++
cut (inv K = inv K).
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
exists N0.
split.
generalize H.
unfold is_irreducible in |- *.
unfold equal in |- *.
intro.
elim H23.
intros.
rewrite H14 in H13.
rewrite <- H21 in H13.
generalize (irreducible_enc g).
intros.
elim (H26 M' N0 K L0).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
elim (H27 (H29 (MEnc M' K) (MEnc N0 L0) H13)).
intros.
fold (inclusion (irreducible g) g) in H30.
generalize (inclusion_impl_le_h (irreducible g) g H30).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
apply H33.
generalize (h_le_h_ana_h g).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize (ana_h_equiv_irr_h g).
unfold equiv_h in |- *.
intro.
elim H35.
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
apply H36.
apply SynInc.
generalize (analysis_is_analysis g).
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.
elim H38.
intros.
elim H39.
unfold stable_analysis in |- *.
unfold inclusion in |- *.
intros.
apply H42.
apply (AnaDec (analysis_def g) M' N0 K L0).
apply H37.
fold (inclusion g (irreducible g)) in H29.
generalize (inclusion_impl_le_h g (irreducible g) H29).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
apply H43.
cut (L = L0).
generalize H1.
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize (H44 (inv K) (inv L) H15).
intro.
elim H11.
intros.
generalize (inj_inv_left_syn h H4 H10 H6 H8 H47).
unfold injective_inv_left in |- *.
intros.
generalize (H48 K L0 H22 (inv K) (inv L) H45).
intros.
cut (inv K = inv K).

*****
H49 : forall _ : eq (inv K) (inv K), eq (inv L) (inv L0)
H48 : forall (M N : Msg) (_ : synthesis h M N) (M' N' : Msg)\n (_ : synthesis h M' N') (_ : eq M' (inv M)), eq N' (inv N)
H47 : injective_inv_left h
H46 : enc_analysis_left h
H45 : synthesis h (inv K) (inv L)
H44 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H43 : forall (M N : Msg) (_ : synthesis g M N), synthesis (irreducible g) M N
H42 : forall (M N : Msg) (_ : analysis (analysis_def g) M N),\nanalysis_def g M N
H41 : forall (M N : Msg) (_ : g M N), analysis_def g M N
H40 : forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\ninclusion (analysis_def g) h'
H39 : and (inclusion g (analysis_def g)) (stable_analysis (analysis_def g))
H38 : and\n (and (inclusion g (analysis_def g))\n (stable_analysis (analysis_def g)))\n (forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\n inclusion (analysis_def g) h')
H37 : forall (M N : Msg) (_ : synthesis (irreducible g) M N),\nsynthesis (analysis_def g) M N
H36 : forall (M N : Msg) (_ : synthesis (analysis_def g) M N),\nsynthesis (irreducible g) M N
H35 : and (le_h (analysis_def g) (irreducible g))\n (le_h (irreducible g) (analysis_def g))
H34 : forall (M N : Msg) (_ : synthesis g M N),\nsynthesis (analysis_def g) M N
H33 : forall (M N : Msg) (_ : synthesis (irreducible g) M N), synthesis g M N
H32 : or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))
H31 : analysis_def g (MEnc M' K) (MEnc N0 L0)
H30 : inclusion (irreducible g) g
H29 : inclusion g (irreducible g)
H28 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))),\nirreducible g (MEnc M' K) (MEnc N0 L0)
H27 : forall _ : irreducible g (MEnc M' K) (MEnc N0 L0),\nand (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0)))
H26 : forall M N K L : Msg,\niff (irreducible g (MEnc M K) (MEnc N L))\n (and (analysis_def g (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def g) M N))\n (not (synthesis (analysis_def g) K L))))
H25 : inclusion (irreducible g) g
H24 : inclusion g (irreducible g)
H23 : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
H21 : eq (MEnc N0 L0) N
H19 : eq K0 K
H18 : eq M0 M'
H22 : synthesis h K L0
H20 : synthesis h M' N0
M0,K0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
L : Msg
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N0 L0)
M,N,M',K,N0,L0 : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
forall _ : eq (inv K) (inv K), eq L L0
+++++
trivial.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
exists N0.
split.
generalize H.
unfold is_irreducible in |- *.
unfold equal in |- *.
intro.
elim H23.
intros.
rewrite H14 in H13.
rewrite <- H21 in H13.
generalize (irreducible_enc g).
intros.
elim (H26 M' N0 K L0).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
elim (H27 (H29 (MEnc M' K) (MEnc N0 L0) H13)).
intros.
fold (inclusion (irreducible g) g) in H30.
generalize (inclusion_impl_le_h (irreducible g) g H30).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
apply H33.
generalize (h_le_h_ana_h g).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize (ana_h_equiv_irr_h g).
unfold equiv_h in |- *.
intro.
elim H35.
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
apply H36.
apply SynInc.
generalize (analysis_is_analysis g).
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.
elim H38.
intros.
elim H39.
unfold stable_analysis in |- *.
unfold inclusion in |- *.
intros.
apply H42.
apply (AnaDec (analysis_def g) M' N0 K L0).
apply H37.
fold (inclusion g (irreducible g)) in H29.
generalize (inclusion_impl_le_h g (irreducible g) H29).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
apply H43.
cut (L = L0).
generalize H1.
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize (H44 (inv K) (inv L) H15).
intro.
elim H11.
intros.
generalize (inj_inv_left_syn h H4 H10 H6 H8 H47).
unfold injective_inv_left in |- *.
intros.
generalize (H48 K L0 H22 (inv K) (inv L) H45).
intros.
cut (inv K = inv K).
trivial.

*****
H49 : forall _ : eq (inv K) (inv K), eq (inv L) (inv L0)
H48 : forall (M N : Msg) (_ : synthesis h M N) (M' N' : Msg)\n (_ : synthesis h M' N') (_ : eq M' (inv M)), eq N' (inv N)
H47 : injective_inv_left h
H46 : enc_analysis_left h
H45 : synthesis h (inv K) (inv L)
H44 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H43 : forall (M N : Msg) (_ : synthesis g M N), synthesis (irreducible g) M N
H42 : forall (M N : Msg) (_ : analysis (analysis_def g) M N),\nanalysis_def g M N
H41 : forall (M N : Msg) (_ : g M N), analysis_def g M N
H40 : forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\ninclusion (analysis_def g) h'
H39 : and (inclusion g (analysis_def g)) (stable_analysis (analysis_def g))
H38 : and\n (and (inclusion g (analysis_def g))\n (stable_analysis (analysis_def g)))\n (forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\n inclusion (analysis_def g) h')
H37 : forall (M N : Msg) (_ : synthesis (irreducible g) M N),\nsynthesis (analysis_def g) M N
H36 : forall (M N : Msg) (_ : synthesis (analysis_def g) M N),\nsynthesis (irreducible g) M N
H35 : and (le_h (analysis_def g) (irreducible g))\n (le_h (irreducible g) (analysis_def g))
H34 : forall (M N : Msg) (_ : synthesis g M N),\nsynthesis (analysis_def g) M N
H33 : forall (M N : Msg) (_ : synthesis (irreducible g) M N), synthesis g M N
H32 : or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))
H31 : analysis_def g (MEnc M' K) (MEnc N0 L0)
H30 : inclusion (irreducible g) g
H29 : inclusion g (irreducible g)
H28 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))),\nirreducible g (MEnc M' K) (MEnc N0 L0)
H27 : forall _ : irreducible g (MEnc M' K) (MEnc N0 L0),\nand (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0)))
H26 : forall M N K L : Msg,\niff (irreducible g (MEnc M K) (MEnc N L))\n (and (analysis_def g (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def g) M N))\n (not (synthesis (analysis_def g) K L))))
H25 : inclusion (irreducible g) g
H24 : inclusion g (irreducible g)
H23 : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
H21 : eq (MEnc N0 L0) N
H19 : eq K0 K
H18 : eq M0 M'
H22 : synthesis h K L0
H20 : synthesis h M' N0
M0,K0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
L : Msg
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N0 L0)
M,N,M',K,N0,L0 : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
forall _ : eq (inv K) (inv K), eq L L0
+++++
intro.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
exists N0.
split.
generalize H.
unfold is_irreducible in |- *.
unfold equal in |- *.
intro.
elim H23.
intros.
rewrite H14 in H13.
rewrite <- H21 in H13.
generalize (irreducible_enc g).
intros.
elim (H26 M' N0 K L0).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
elim (H27 (H29 (MEnc M' K) (MEnc N0 L0) H13)).
intros.
fold (inclusion (irreducible g) g) in H30.
generalize (inclusion_impl_le_h (irreducible g) g H30).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
apply H33.
generalize (h_le_h_ana_h g).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize (ana_h_equiv_irr_h g).
unfold equiv_h in |- *.
intro.
elim H35.
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
apply H36.
apply SynInc.
generalize (analysis_is_analysis g).
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.
elim H38.
intros.
elim H39.
unfold stable_analysis in |- *.
unfold inclusion in |- *.
intros.
apply H42.
apply (AnaDec (analysis_def g) M' N0 K L0).
apply H37.
fold (inclusion g (irreducible g)) in H29.
generalize (inclusion_impl_le_h g (irreducible g) H29).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
apply H43.
cut (L = L0).
generalize H1.
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize (H44 (inv K) (inv L) H15).
intro.
elim H11.
intros.
generalize (inj_inv_left_syn h H4 H10 H6 H8 H47).
unfold injective_inv_left in |- *.
intros.
generalize (H48 K L0 H22 (inv K) (inv L) H45).
intros.
cut (inv K = inv K).
trivial.
intro.

*****
H50 : eq (inv K) (inv K)
H49 : forall _ : eq (inv K) (inv K), eq (inv L) (inv L0)
H48 : forall (M N : Msg) (_ : synthesis h M N) (M' N' : Msg)\n (_ : synthesis h M' N') (_ : eq M' (inv M)), eq N' (inv N)
H47 : injective_inv_left h
H46 : enc_analysis_left h
H45 : synthesis h (inv K) (inv L)
H44 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H43 : forall (M N : Msg) (_ : synthesis g M N), synthesis (irreducible g) M N
H42 : forall (M N : Msg) (_ : analysis (analysis_def g) M N),\nanalysis_def g M N
H41 : forall (M N : Msg) (_ : g M N), analysis_def g M N
H40 : forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\ninclusion (analysis_def g) h'
H39 : and (inclusion g (analysis_def g)) (stable_analysis (analysis_def g))
H38 : and\n (and (inclusion g (analysis_def g))\n (stable_analysis (analysis_def g)))\n (forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\n inclusion (analysis_def g) h')
H37 : forall (M N : Msg) (_ : synthesis (irreducible g) M N),\nsynthesis (analysis_def g) M N
H36 : forall (M N : Msg) (_ : synthesis (analysis_def g) M N),\nsynthesis (irreducible g) M N
H35 : and (le_h (analysis_def g) (irreducible g))\n (le_h (irreducible g) (analysis_def g))
H34 : forall (M N : Msg) (_ : synthesis g M N),\nsynthesis (analysis_def g) M N
H33 : forall (M N : Msg) (_ : synthesis (irreducible g) M N), synthesis g M N
H32 : or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))
H31 : analysis_def g (MEnc M' K) (MEnc N0 L0)
H30 : inclusion (irreducible g) g
H29 : inclusion g (irreducible g)
H28 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))),\nirreducible g (MEnc M' K) (MEnc N0 L0)
H27 : forall _ : irreducible g (MEnc M' K) (MEnc N0 L0),\nand (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0)))
H26 : forall M N K L : Msg,\niff (irreducible g (MEnc M K) (MEnc N L))\n (and (analysis_def g (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def g) M N))\n (not (synthesis (analysis_def g) K L))))
H25 : inclusion (irreducible g) g
H24 : inclusion g (irreducible g)
H23 : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
H21 : eq (MEnc N0 L0) N
H19 : eq K0 K
H18 : eq M0 M'
H22 : synthesis h K L0
H20 : synthesis h M' N0
M0,K0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
L : Msg
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N0 L0)
M,N,M',K,N0,L0 : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
eq L L0
+++++
generalize (H49 H50).
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
exists N0.
split.
generalize H.
unfold is_irreducible in |- *.
unfold equal in |- *.
intro.
elim H23.
intros.
rewrite H14 in H13.
rewrite <- H21 in H13.
generalize (irreducible_enc g).
intros.
elim (H26 M' N0 K L0).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
elim (H27 (H29 (MEnc M' K) (MEnc N0 L0) H13)).
intros.
fold (inclusion (irreducible g) g) in H30.
generalize (inclusion_impl_le_h (irreducible g) g H30).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
apply H33.
generalize (h_le_h_ana_h g).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize (ana_h_equiv_irr_h g).
unfold equiv_h in |- *.
intro.
elim H35.
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
apply H36.
apply SynInc.
generalize (analysis_is_analysis g).
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.
elim H38.
intros.
elim H39.
unfold stable_analysis in |- *.
unfold inclusion in |- *.
intros.
apply H42.
apply (AnaDec (analysis_def g) M' N0 K L0).
apply H37.
fold (inclusion g (irreducible g)) in H29.
generalize (inclusion_impl_le_h g (irreducible g) H29).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
apply H43.
cut (L = L0).
generalize H1.
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize (H44 (inv K) (inv L) H15).
intro.
elim H11.
intros.
generalize (inj_inv_left_syn h H4 H10 H6 H8 H47).
unfold injective_inv_left in |- *.
intros.
generalize (H48 K L0 H22 (inv K) (inv L) H45).
intros.
cut (inv K = inv K).
trivial.
intro.
generalize (H49 H50).

*****
H50 : eq (inv K) (inv K)
H49 : forall _ : eq (inv K) (inv K), eq (inv L) (inv L0)
H48 : forall (M N : Msg) (_ : synthesis h M N) (M' N' : Msg)\n (_ : synthesis h M' N') (_ : eq M' (inv M)), eq N' (inv N)
H47 : injective_inv_left h
H46 : enc_analysis_left h
H45 : synthesis h (inv K) (inv L)
H44 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H43 : forall (M N : Msg) (_ : synthesis g M N), synthesis (irreducible g) M N
H42 : forall (M N : Msg) (_ : analysis (analysis_def g) M N),\nanalysis_def g M N
H41 : forall (M N : Msg) (_ : g M N), analysis_def g M N
H40 : forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\ninclusion (analysis_def g) h'
H39 : and (inclusion g (analysis_def g)) (stable_analysis (analysis_def g))
H38 : and\n (and (inclusion g (analysis_def g))\n (stable_analysis (analysis_def g)))\n (forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\n inclusion (analysis_def g) h')
H37 : forall (M N : Msg) (_ : synthesis (irreducible g) M N),\nsynthesis (analysis_def g) M N
H36 : forall (M N : Msg) (_ : synthesis (analysis_def g) M N),\nsynthesis (irreducible g) M N
H35 : and (le_h (analysis_def g) (irreducible g))\n (le_h (irreducible g) (analysis_def g))
H34 : forall (M N : Msg) (_ : synthesis g M N),\nsynthesis (analysis_def g) M N
H33 : forall (M N : Msg) (_ : synthesis (irreducible g) M N), synthesis g M N
H32 : or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))
H31 : analysis_def g (MEnc M' K) (MEnc N0 L0)
H30 : inclusion (irreducible g) g
H29 : inclusion g (irreducible g)
H28 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))),\nirreducible g (MEnc M' K) (MEnc N0 L0)
H27 : forall _ : irreducible g (MEnc M' K) (MEnc N0 L0),\nand (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0)))
H26 : forall M N K L : Msg,\niff (irreducible g (MEnc M K) (MEnc N L))\n (and (analysis_def g (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def g) M N))\n (not (synthesis (analysis_def g) K L))))
H25 : inclusion (irreducible g) g
H24 : inclusion g (irreducible g)
H23 : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
H21 : eq (MEnc N0 L0) N
H19 : eq K0 K
H18 : eq M0 M'
H22 : synthesis h K L0
H20 : synthesis h M' N0
M0,K0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
L : Msg
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N0 L0)
M,N,M',K,N0,L0 : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
forall _ : eq (inv L) (inv L0), eq L L0
+++++
intro.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
exists N0.
split.
generalize H.
unfold is_irreducible in |- *.
unfold equal in |- *.
intro.
elim H23.
intros.
rewrite H14 in H13.
rewrite <- H21 in H13.
generalize (irreducible_enc g).
intros.
elim (H26 M' N0 K L0).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
elim (H27 (H29 (MEnc M' K) (MEnc N0 L0) H13)).
intros.
fold (inclusion (irreducible g) g) in H30.
generalize (inclusion_impl_le_h (irreducible g) g H30).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
apply H33.
generalize (h_le_h_ana_h g).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize (ana_h_equiv_irr_h g).
unfold equiv_h in |- *.
intro.
elim H35.
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
apply H36.
apply SynInc.
generalize (analysis_is_analysis g).
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.
elim H38.
intros.
elim H39.
unfold stable_analysis in |- *.
unfold inclusion in |- *.
intros.
apply H42.
apply (AnaDec (analysis_def g) M' N0 K L0).
apply H37.
fold (inclusion g (irreducible g)) in H29.
generalize (inclusion_impl_le_h g (irreducible g) H29).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
apply H43.
cut (L = L0).
generalize H1.
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize (H44 (inv K) (inv L) H15).
intro.
elim H11.
intros.
generalize (inj_inv_left_syn h H4 H10 H6 H8 H47).
unfold injective_inv_left in |- *.
intros.
generalize (H48 K L0 H22 (inv K) (inv L) H45).
intros.
cut (inv K = inv K).
trivial.
intro.
generalize (H49 H50).
intro.

*****
H51 : eq (inv L) (inv L0)
H50 : eq (inv K) (inv K)
H49 : forall _ : eq (inv K) (inv K), eq (inv L) (inv L0)
H48 : forall (M N : Msg) (_ : synthesis h M N) (M' N' : Msg)\n (_ : synthesis h M' N') (_ : eq M' (inv M)), eq N' (inv N)
H47 : injective_inv_left h
H46 : enc_analysis_left h
H45 : synthesis h (inv K) (inv L)
H44 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H43 : forall (M N : Msg) (_ : synthesis g M N), synthesis (irreducible g) M N
H42 : forall (M N : Msg) (_ : analysis (analysis_def g) M N),\nanalysis_def g M N
H41 : forall (M N : Msg) (_ : g M N), analysis_def g M N
H40 : forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\ninclusion (analysis_def g) h'
H39 : and (inclusion g (analysis_def g)) (stable_analysis (analysis_def g))
H38 : and\n (and (inclusion g (analysis_def g))\n (stable_analysis (analysis_def g)))\n (forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\n inclusion (analysis_def g) h')
H37 : forall (M N : Msg) (_ : synthesis (irreducible g) M N),\nsynthesis (analysis_def g) M N
H36 : forall (M N : Msg) (_ : synthesis (analysis_def g) M N),\nsynthesis (irreducible g) M N
H35 : and (le_h (analysis_def g) (irreducible g))\n (le_h (irreducible g) (analysis_def g))
H34 : forall (M N : Msg) (_ : synthesis g M N),\nsynthesis (analysis_def g) M N
H33 : forall (M N : Msg) (_ : synthesis (irreducible g) M N), synthesis g M N
H32 : or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))
H31 : analysis_def g (MEnc M' K) (MEnc N0 L0)
H30 : inclusion (irreducible g) g
H29 : inclusion g (irreducible g)
H28 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))),\nirreducible g (MEnc M' K) (MEnc N0 L0)
H27 : forall _ : irreducible g (MEnc M' K) (MEnc N0 L0),\nand (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0)))
H26 : forall M N K L : Msg,\niff (irreducible g (MEnc M K) (MEnc N L))\n (and (analysis_def g (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def g) M N))\n (not (synthesis (analysis_def g) K L))))
H25 : inclusion (irreducible g) g
H24 : inclusion g (irreducible g)
H23 : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
H21 : eq (MEnc N0 L0) N
H19 : eq K0 K
H18 : eq M0 M'
H22 : synthesis h K L0
H20 : synthesis h M' N0
M0,K0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
L : Msg
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N0 L0)
M,N,M',K,N0,L0 : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
eq L L0
+++++
rewrite <- inv_invol.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
exists N0.
split.
generalize H.
unfold is_irreducible in |- *.
unfold equal in |- *.
intro.
elim H23.
intros.
rewrite H14 in H13.
rewrite <- H21 in H13.
generalize (irreducible_enc g).
intros.
elim (H26 M' N0 K L0).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
elim (H27 (H29 (MEnc M' K) (MEnc N0 L0) H13)).
intros.
fold (inclusion (irreducible g) g) in H30.
generalize (inclusion_impl_le_h (irreducible g) g H30).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
apply H33.
generalize (h_le_h_ana_h g).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize (ana_h_equiv_irr_h g).
unfold equiv_h in |- *.
intro.
elim H35.
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
apply H36.
apply SynInc.
generalize (analysis_is_analysis g).
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.
elim H38.
intros.
elim H39.
unfold stable_analysis in |- *.
unfold inclusion in |- *.
intros.
apply H42.
apply (AnaDec (analysis_def g) M' N0 K L0).
apply H37.
fold (inclusion g (irreducible g)) in H29.
generalize (inclusion_impl_le_h g (irreducible g) H29).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
apply H43.
cut (L = L0).
generalize H1.
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize (H44 (inv K) (inv L) H15).
intro.
elim H11.
intros.
generalize (inj_inv_left_syn h H4 H10 H6 H8 H47).
unfold injective_inv_left in |- *.
intros.
generalize (H48 K L0 H22 (inv K) (inv L) H45).
intros.
cut (inv K = inv K).
trivial.
intro.
generalize (H49 H50).
intro.
rewrite <- inv_invol.

*****
H51 : eq (inv L) (inv L0)
H50 : eq (inv K) (inv K)
H49 : forall _ : eq (inv K) (inv K), eq (inv L) (inv L0)
H48 : forall (M N : Msg) (_ : synthesis h M N) (M' N' : Msg)\n (_ : synthesis h M' N') (_ : eq M' (inv M)), eq N' (inv N)
H47 : injective_inv_left h
H46 : enc_analysis_left h
H45 : synthesis h (inv K) (inv L)
H44 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H43 : forall (M N : Msg) (_ : synthesis g M N), synthesis (irreducible g) M N
H42 : forall (M N : Msg) (_ : analysis (analysis_def g) M N),\nanalysis_def g M N
H41 : forall (M N : Msg) (_ : g M N), analysis_def g M N
H40 : forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\ninclusion (analysis_def g) h'
H39 : and (inclusion g (analysis_def g)) (stable_analysis (analysis_def g))
H38 : and\n (and (inclusion g (analysis_def g))\n (stable_analysis (analysis_def g)))\n (forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\n inclusion (analysis_def g) h')
H37 : forall (M N : Msg) (_ : synthesis (irreducible g) M N),\nsynthesis (analysis_def g) M N
H36 : forall (M N : Msg) (_ : synthesis (analysis_def g) M N),\nsynthesis (irreducible g) M N
H35 : and (le_h (analysis_def g) (irreducible g))\n (le_h (irreducible g) (analysis_def g))
H34 : forall (M N : Msg) (_ : synthesis g M N),\nsynthesis (analysis_def g) M N
H33 : forall (M N : Msg) (_ : synthesis (irreducible g) M N), synthesis g M N
H32 : or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))
H31 : analysis_def g (MEnc M' K) (MEnc N0 L0)
H30 : inclusion (irreducible g) g
H29 : inclusion g (irreducible g)
H28 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))),\nirreducible g (MEnc M' K) (MEnc N0 L0)
H27 : forall _ : irreducible g (MEnc M' K) (MEnc N0 L0),\nand (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0)))
H26 : forall M N K L : Msg,\niff (irreducible g (MEnc M K) (MEnc N L))\n (and (analysis_def g (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def g) M N))\n (not (synthesis (analysis_def g) K L))))
H25 : inclusion (irreducible g) g
H24 : inclusion g (irreducible g)
H23 : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
H21 : eq (MEnc N0 L0) N
H19 : eq K0 K
H18 : eq M0 M'
H22 : synthesis h K L0
H20 : synthesis h M' N0
M0,K0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
L : Msg
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N0 L0)
M,N,M',K,N0,L0 : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
eq L (inv (inv L0))
+++++
rewrite <- H51.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
exists N0.
split.
generalize H.
unfold is_irreducible in |- *.
unfold equal in |- *.
intro.
elim H23.
intros.
rewrite H14 in H13.
rewrite <- H21 in H13.
generalize (irreducible_enc g).
intros.
elim (H26 M' N0 K L0).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
elim (H27 (H29 (MEnc M' K) (MEnc N0 L0) H13)).
intros.
fold (inclusion (irreducible g) g) in H30.
generalize (inclusion_impl_le_h (irreducible g) g H30).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
apply H33.
generalize (h_le_h_ana_h g).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize (ana_h_equiv_irr_h g).
unfold equiv_h in |- *.
intro.
elim H35.
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
apply H36.
apply SynInc.
generalize (analysis_is_analysis g).
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.
elim H38.
intros.
elim H39.
unfold stable_analysis in |- *.
unfold inclusion in |- *.
intros.
apply H42.
apply (AnaDec (analysis_def g) M' N0 K L0).
apply H37.
fold (inclusion g (irreducible g)) in H29.
generalize (inclusion_impl_le_h g (irreducible g) H29).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
apply H43.
cut (L = L0).
generalize H1.
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize (H44 (inv K) (inv L) H15).
intro.
elim H11.
intros.
generalize (inj_inv_left_syn h H4 H10 H6 H8 H47).
unfold injective_inv_left in |- *.
intros.
generalize (H48 K L0 H22 (inv K) (inv L) H45).
intros.
cut (inv K = inv K).
trivial.
intro.
generalize (H49 H50).
intro.
rewrite <- inv_invol.
rewrite <- H51.

*****
H51 : eq (inv L) (inv L0)
H50 : eq (inv K) (inv K)
H49 : forall _ : eq (inv K) (inv K), eq (inv L) (inv L0)
H48 : forall (M N : Msg) (_ : synthesis h M N) (M' N' : Msg)\n (_ : synthesis h M' N') (_ : eq M' (inv M)), eq N' (inv N)
H47 : injective_inv_left h
H46 : enc_analysis_left h
H45 : synthesis h (inv K) (inv L)
H44 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H43 : forall (M N : Msg) (_ : synthesis g M N), synthesis (irreducible g) M N
H42 : forall (M N : Msg) (_ : analysis (analysis_def g) M N),\nanalysis_def g M N
H41 : forall (M N : Msg) (_ : g M N), analysis_def g M N
H40 : forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\ninclusion (analysis_def g) h'
H39 : and (inclusion g (analysis_def g)) (stable_analysis (analysis_def g))
H38 : and\n (and (inclusion g (analysis_def g))\n (stable_analysis (analysis_def g)))\n (forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\n inclusion (analysis_def g) h')
H37 : forall (M N : Msg) (_ : synthesis (irreducible g) M N),\nsynthesis (analysis_def g) M N
H36 : forall (M N : Msg) (_ : synthesis (analysis_def g) M N),\nsynthesis (irreducible g) M N
H35 : and (le_h (analysis_def g) (irreducible g))\n (le_h (irreducible g) (analysis_def g))
H34 : forall (M N : Msg) (_ : synthesis g M N),\nsynthesis (analysis_def g) M N
H33 : forall (M N : Msg) (_ : synthesis (irreducible g) M N), synthesis g M N
H32 : or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))
H31 : analysis_def g (MEnc M' K) (MEnc N0 L0)
H30 : inclusion (irreducible g) g
H29 : inclusion g (irreducible g)
H28 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))),\nirreducible g (MEnc M' K) (MEnc N0 L0)
H27 : forall _ : irreducible g (MEnc M' K) (MEnc N0 L0),\nand (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0)))
H26 : forall M N K L : Msg,\niff (irreducible g (MEnc M K) (MEnc N L))\n (and (analysis_def g (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def g) M N))\n (not (synthesis (analysis_def g) K L))))
H25 : inclusion (irreducible g) g
H24 : inclusion g (irreducible g)
H23 : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
H21 : eq (MEnc N0 L0) N
H19 : eq K0 K
H18 : eq M0 M'
H22 : synthesis h K L0
H20 : synthesis h M' N0
M0,K0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
L : Msg
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N0 L0)
M,N,M',K,N0,L0 : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
eq L (inv (inv L))
+++++
symmetry in |- *.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
exists N0.
split.
generalize H.
unfold is_irreducible in |- *.
unfold equal in |- *.
intro.
elim H23.
intros.
rewrite H14 in H13.
rewrite <- H21 in H13.
generalize (irreducible_enc g).
intros.
elim (H26 M' N0 K L0).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
elim (H27 (H29 (MEnc M' K) (MEnc N0 L0) H13)).
intros.
fold (inclusion (irreducible g) g) in H30.
generalize (inclusion_impl_le_h (irreducible g) g H30).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
apply H33.
generalize (h_le_h_ana_h g).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize (ana_h_equiv_irr_h g).
unfold equiv_h in |- *.
intro.
elim H35.
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
apply H36.
apply SynInc.
generalize (analysis_is_analysis g).
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.
elim H38.
intros.
elim H39.
unfold stable_analysis in |- *.
unfold inclusion in |- *.
intros.
apply H42.
apply (AnaDec (analysis_def g) M' N0 K L0).
apply H37.
fold (inclusion g (irreducible g)) in H29.
generalize (inclusion_impl_le_h g (irreducible g) H29).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
apply H43.
cut (L = L0).
generalize H1.
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize (H44 (inv K) (inv L) H15).
intro.
elim H11.
intros.
generalize (inj_inv_left_syn h H4 H10 H6 H8 H47).
unfold injective_inv_left in |- *.
intros.
generalize (H48 K L0 H22 (inv K) (inv L) H45).
intros.
cut (inv K = inv K).
trivial.
intro.
generalize (H49 H50).
intro.
rewrite <- inv_invol.
rewrite <- H51.
symmetry in |- *.

*****
H51 : eq (inv L) (inv L0)
H50 : eq (inv K) (inv K)
H49 : forall _ : eq (inv K) (inv K), eq (inv L) (inv L0)
H48 : forall (M N : Msg) (_ : synthesis h M N) (M' N' : Msg)\n (_ : synthesis h M' N') (_ : eq M' (inv M)), eq N' (inv N)
H47 : injective_inv_left h
H46 : enc_analysis_left h
H45 : synthesis h (inv K) (inv L)
H44 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H43 : forall (M N : Msg) (_ : synthesis g M N), synthesis (irreducible g) M N
H42 : forall (M N : Msg) (_ : analysis (analysis_def g) M N),\nanalysis_def g M N
H41 : forall (M N : Msg) (_ : g M N), analysis_def g M N
H40 : forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\ninclusion (analysis_def g) h'
H39 : and (inclusion g (analysis_def g)) (stable_analysis (analysis_def g))
H38 : and\n (and (inclusion g (analysis_def g))\n (stable_analysis (analysis_def g)))\n (forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\n inclusion (analysis_def g) h')
H37 : forall (M N : Msg) (_ : synthesis (irreducible g) M N),\nsynthesis (analysis_def g) M N
H36 : forall (M N : Msg) (_ : synthesis (analysis_def g) M N),\nsynthesis (irreducible g) M N
H35 : and (le_h (analysis_def g) (irreducible g))\n (le_h (irreducible g) (analysis_def g))
H34 : forall (M N : Msg) (_ : synthesis g M N),\nsynthesis (analysis_def g) M N
H33 : forall (M N : Msg) (_ : synthesis (irreducible g) M N), synthesis g M N
H32 : or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))
H31 : analysis_def g (MEnc M' K) (MEnc N0 L0)
H30 : inclusion (irreducible g) g
H29 : inclusion g (irreducible g)
H28 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))),\nirreducible g (MEnc M' K) (MEnc N0 L0)
H27 : forall _ : irreducible g (MEnc M' K) (MEnc N0 L0),\nand (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0)))
H26 : forall M N K L : Msg,\niff (irreducible g (MEnc M K) (MEnc N L))\n (and (analysis_def g (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def g) M N))\n (not (synthesis (analysis_def g) K L))))
H25 : inclusion (irreducible g) g
H24 : inclusion g (irreducible g)
H23 : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
H21 : eq (MEnc N0 L0) N
H19 : eq K0 K
H18 : eq M0 M'
H22 : synthesis h K L0
H20 : synthesis h M' N0
M0,K0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
L : Msg
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N0 L0)
M,N,M',K,N0,L0 : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
eq (inv (inv L)) L
+++++
apply inv_invol.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.
split.
split.
split.
split.
unfold enc_analysis_left in |- *.
intros.
generalize (le_h_impl_incl_syn g h H1).
unfold inclusion in |- *.
intro.
generalize (H16 M N H13).
rewrite H14.
intro.
inversion H17.
exists N0.
split.
generalize H.
unfold is_irreducible in |- *.
unfold equal in |- *.
intro.
elim H23.
intros.
rewrite H14 in H13.
rewrite <- H21 in H13.
generalize (irreducible_enc g).
intros.
elim (H26 M' N0 K L0).
intros.
unfold is_irreducible in H.
unfold equal in H.
elim H.
unfold inclusion in |- *.
intros.
elim (H27 (H29 (MEnc M' K) (MEnc N0 L0) H13)).
intros.
fold (inclusion (irreducible g) g) in H30.
generalize (inclusion_impl_le_h (irreducible g) g H30).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
apply H33.
generalize (h_le_h_ana_h g).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize (ana_h_equiv_irr_h g).
unfold equiv_h in |- *.
intro.
elim H35.
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
apply H36.
apply SynInc.
generalize (analysis_is_analysis g).
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.
elim H38.
intros.
elim H39.
unfold stable_analysis in |- *.
unfold inclusion in |- *.
intros.
apply H42.
apply (AnaDec (analysis_def g) M' N0 K L0).
apply H37.
fold (inclusion g (irreducible g)) in H29.
generalize (inclusion_impl_le_h g (irreducible g) H29).
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
apply H43.
cut (L = L0).
generalize H1.
unfold le_h in |- *.
unfold inclusion in |- *.
intros.
generalize (H44 (inv K) (inv L) H15).
intro.
elim H11.
intros.
generalize (inj_inv_left_syn h H4 H10 H6 H8 H47).
unfold injective_inv_left in |- *.
intros.
generalize (H48 K L0 H22 (inv K) (inv L) H45).
intros.
cut (inv K = inv K).

*****
H49 : forall _ : eq (inv K) (inv K), eq (inv L) (inv L0)
H48 : forall (M N : Msg) (_ : synthesis h M N) (M' N' : Msg)\n (_ : synthesis h M' N') (_ : eq M' (inv M)), eq N' (inv N)
H47 : injective_inv_left h
H46 : enc_analysis_left h
H45 : synthesis h (inv K) (inv L)
H44 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H43 : forall (M N : Msg) (_ : synthesis g M N), synthesis (irreducible g) M N
H42 : forall (M N : Msg) (_ : analysis (analysis_def g) M N),\nanalysis_def g M N
H41 : forall (M N : Msg) (_ : g M N), analysis_def g M N
H40 : forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\ninclusion (analysis_def g) h'
H39 : and (inclusion g (analysis_def g)) (stable_analysis (analysis_def g))
H38 : and\n (and (inclusion g (analysis_def g))\n (stable_analysis (analysis_def g)))\n (forall (h' : hedge) (_ : and (inclusion g h') (stable_analysis h')),\n inclusion (analysis_def g) h')
H37 : forall (M N : Msg) (_ : synthesis (irreducible g) M N),\nsynthesis (analysis_def g) M N
H36 : forall (M N : Msg) (_ : synthesis (analysis_def g) M N),\nsynthesis (irreducible g) M N
H35 : and (le_h (analysis_def g) (irreducible g))\n (le_h (irreducible g) (analysis_def g))
H34 : forall (M N : Msg) (_ : synthesis g M N),\nsynthesis (analysis_def g) M N
H33 : forall (M N : Msg) (_ : synthesis (irreducible g) M N), synthesis g M N
H32 : or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))
H31 : analysis_def g (MEnc M' K) (MEnc N0 L0)
H30 : inclusion (irreducible g) g
H29 : inclusion g (irreducible g)
H28 : forall\n _ : and (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0))),\nirreducible g (MEnc M' K) (MEnc N0 L0)
H27 : forall _ : irreducible g (MEnc M' K) (MEnc N0 L0),\nand (analysis_def g (MEnc M' K) (MEnc N0 L0))\n (or (not (synthesis (analysis_def g) M' N0))\n (not (synthesis (analysis_def g) K L0)))
H26 : forall M N K L : Msg,\niff (irreducible g (MEnc M K) (MEnc N L))\n (and (analysis_def g (MEnc M K) (MEnc N L))\n (or (not (synthesis (analysis_def g) M N))\n (not (synthesis (analysis_def g) K L))))
H25 : inclusion (irreducible g) g
H24 : inclusion g (irreducible g)
H23 : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
H21 : eq (MEnc N0 L0) N
H19 : eq K0 K
H18 : eq M0 M'
H22 : synthesis h K L0
H20 : synthesis h M' N0
M0,K0 : Msg
H17 : synthesis h (MEnc M' K) N
H16 : forall (M N : Msg) (_ : g M N), synthesis h M N
H15 : synthesis g (inv K) (inv L)
L : Msg
H14 : eq M (MEnc M' K)
H13 : g (MEnc M' K) (MEnc N0 L0)
M,N,M',K,N0,L0 : Msg
H12 : injective_left (synthesis h)
H11 : and (enc_analysis_left h) (injective_inv_left h)
H10 : enc_synthesis_left h
H9 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H8 : pair_free_left h
H7 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H6 : op_synthesis_left h
H5 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H4 : injective_left h
H3 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H2 : name_left_name h
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : and (inclusion g (irreducible g)) (inclusion (irreducible g) g)
g,h : hedge
*****
eq (inv K) (inv K)
+++++
trivial.
-----
Lemma irr_le_h_left_consistent_impl_left_consistent_weak : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> weak_left_consistent g.
unfold is_left_consistent in |- *.
unfold weak_left_consistent in |- *.
intros.
elim H0.
intros.
elim H3.
intros.
elim H5.
intros.
elim H7.
intros.
elim H9.
intros.
generalize (inj_left_syn h H4 H10 H6 H8).
intro.
split.

*****

*****

+++++
Qed.
-----
Lemma weak_left_consistent_inj_inv_left_iff_left_consistent :\n forall h : hedge,\n weak_left_consistent h /\ injective_inv_left h <-> is_left_consistent h.
-----
Lemma weak_left_consistent_inj_inv_left_iff_left_consistent : forall h : hedge, weak_left_consistent h /\\ injective_inv_left h <-> is_left_consistent h.

*****

*****
forall h : hedge, iff (and (weak_left_consistent h) (injective_inv_left h)) (is_left_consistent h)
+++++
unfold weak_left_consistent in |- *.
-----
Lemma weak_left_consistent_inj_inv_left_iff_left_consistent : forall h : hedge, weak_left_consistent h /\\ injective_inv_left h <-> is_left_consistent h.
unfold weak_left_consistent in |- *.

*****

*****
forall h : hedge, iff (and (and (name_left_name h) (and (injective_left h) (and (op_synthesis_left h) (and (pair_free_left h) (and (enc_synthesis_left h) (enc_analysis_left h)))))) (injective_inv_left h)) (is_left_consistent h)
+++++
unfold is_left_consistent in |- *.
-----
Lemma weak_left_consistent_inj_inv_left_iff_left_consistent : forall h : hedge, weak_left_consistent h /\\ injective_inv_left h <-> is_left_consistent h.
unfold weak_left_consistent in |- *.
unfold is_left_consistent in |- *.

*****

*****
forall h : hedge, iff (and (and (name_left_name h) (and (injective_left h) (and (op_synthesis_left h) (and (pair_free_left h) (and (enc_synthesis_left h) (enc_analysis_left h)))))) (injective_inv_left h)) (and (name_left_name h) (and (injective_left h) (and (op_synthesis_left h) (and (pair_free_left h) (and (enc_synthesis_left h) (and (enc_analysis_left h) (injective_inv_left h)))))))
+++++
tauto.
-----
Lemma weak_left_consistent_inj_inv_left_iff_left_consistent : forall h : hedge, weak_left_consistent h /\\ injective_inv_left h <-> is_left_consistent h.
unfold weak_left_consistent in |- *.
unfold is_left_consistent in |- *.
tauto.

*****

*****

+++++
Qed.
-----
Theorem irr_le_h_left_consistent_impl_left_consistent :\n forall g h : hedge,\n is_irreducible g -> is_left_consistent h -> le_h g h -> is_left_consistent g.
-----
Theorem irr_le_h_left_consistent_impl_left_consistent : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> is_left_consistent g.

*****

*****
forall (g h : hedge) (_ : is_irreducible g) (_ : is_left_consistent h) (_ : le_h g h), is_left_consistent g
+++++
intros.
-----
Theorem irr_le_h_left_consistent_impl_left_consistent : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> is_left_consistent g.
intros.

*****
H1 : le_h g h
H0 : is_left_consistent h
H : is_irreducible g
g,h : hedge
*****
is_left_consistent g
+++++
generalize (irr_le_h_left_consistent_impl_left_consistent_weak g h H H0 H1).
-----
Theorem irr_le_h_left_consistent_impl_left_consistent : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> is_left_consistent g.
intros.
generalize (irr_le_h_left_consistent_impl_left_consistent_weak g h H H0 H1).

*****
H1 : le_h g h
H0 : is_left_consistent h
H : is_irreducible g
g,h : hedge
*****
forall _ : weak_left_consistent g, is_left_consistent g
+++++
intro.
-----
Theorem irr_le_h_left_consistent_impl_left_consistent : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> is_left_consistent g.
intros.
generalize (irr_le_h_left_consistent_impl_left_consistent_weak g h H H0 H1).
intro.

*****
H2 : weak_left_consistent g
H1 : le_h g h
H0 : is_left_consistent h
H : is_irreducible g
g,h : hedge
*****
is_left_consistent g
+++++
elim (weak_left_consistent_inj_inv_left_iff_left_consistent g).
-----
Theorem irr_le_h_left_consistent_impl_left_consistent : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> is_left_consistent g.
intros.
generalize (irr_le_h_left_consistent_impl_left_consistent_weak g h H H0 H1).
intro.
elim (weak_left_consistent_inj_inv_left_iff_left_consistent g).

*****
H2 : weak_left_consistent g
H1 : le_h g h
H0 : is_left_consistent h
H : is_irreducible g
g,h : hedge
*****
forall (_ : forall _ : and (weak_left_consistent g) (injective_inv_left g), is_left_consistent g) (_ : forall _ : is_left_consistent g, and (weak_left_consistent g) (injective_inv_left g)), is_left_consistent g
+++++
intros.
-----
Theorem irr_le_h_left_consistent_impl_left_consistent : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> is_left_consistent g.
intros.
generalize (irr_le_h_left_consistent_impl_left_consistent_weak g h H H0 H1).
intro.
elim (weak_left_consistent_inj_inv_left_iff_left_consistent g).
intros.

*****
H4 : forall _ : is_left_consistent g,\nand (weak_left_consistent g) (injective_inv_left g)
H3 : forall _ : and (weak_left_consistent g) (injective_inv_left g),\nis_left_consistent g
H2 : weak_left_consistent g
H1 : le_h g h
H0 : is_left_consistent h
H : is_irreducible g
g,h : hedge
*****
is_left_consistent g
+++++
apply H3.
-----
Theorem irr_le_h_left_consistent_impl_left_consistent : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> is_left_consistent g.
intros.
generalize (irr_le_h_left_consistent_impl_left_consistent_weak g h H H0 H1).
intro.
elim (weak_left_consistent_inj_inv_left_iff_left_consistent g).
intros.
apply H3.

*****
H4 : forall _ : is_left_consistent g,\nand (weak_left_consistent g) (injective_inv_left g)
H3 : forall _ : and (weak_left_consistent g) (injective_inv_left g),\nis_left_consistent g
H2 : weak_left_consistent g
H1 : le_h g h
H0 : is_left_consistent h
H : is_irreducible g
g,h : hedge
*****
and (weak_left_consistent g) (injective_inv_left g)
+++++
split.
-----
Theorem irr_le_h_left_consistent_impl_left_consistent : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> is_left_consistent g.
intros.
generalize (irr_le_h_left_consistent_impl_left_consistent_weak g h H H0 H1).
intro.
elim (weak_left_consistent_inj_inv_left_iff_left_consistent g).
intros.
apply H3.
split.

*****
H4 : forall _ : is_left_consistent g,\nand (weak_left_consistent g) (injective_inv_left g)
H3 : forall _ : and (weak_left_consistent g) (injective_inv_left g),\nis_left_consistent g
H2 : weak_left_consistent g
H1 : le_h g h
H0 : is_left_consistent h
H : is_irreducible g
g,h : hedge
*****
weak_left_consistent g
+++++
trivial.
-----
Theorem irr_le_h_left_consistent_impl_left_consistent : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> is_left_consistent g.
intros.
generalize (irr_le_h_left_consistent_impl_left_consistent_weak g h H H0 H1).
intro.
elim (weak_left_consistent_inj_inv_left_iff_left_consistent g).
intros.
apply H3.
split.

*****
H4 : forall _ : is_left_consistent g,\nand (weak_left_consistent g) (injective_inv_left g)
H3 : forall _ : and (weak_left_consistent g) (injective_inv_left g),\nis_left_consistent g
H2 : weak_left_consistent g
H1 : le_h g h
H0 : is_left_consistent h
H : is_irreducible g
g,h : hedge
*****
injective_inv_left g
+++++
trivial.
-----
Theorem irr_le_h_left_consistent_impl_left_consistent : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> is_left_consistent g.
intros.
generalize (irr_le_h_left_consistent_impl_left_consistent_weak g h H H0 H1).
intro.
elim (weak_left_consistent_inj_inv_left_iff_left_consistent g).
intros.
apply H3.
split.
trivial.

*****
H4 : forall _ : is_left_consistent g,\nand (weak_left_consistent g) (injective_inv_left g)
H3 : forall _ : and (weak_left_consistent g) (injective_inv_left g),\nis_left_consistent g
H2 : weak_left_consistent g
H1 : le_h g h
H0 : is_left_consistent h
H : is_irreducible g
g,h : hedge
*****
injective_inv_left g
+++++
unfold injective_inv_left in |- *.
-----
Theorem irr_le_h_left_consistent_impl_left_consistent : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> is_left_consistent g.
intros.
generalize (irr_le_h_left_consistent_impl_left_consistent_weak g h H H0 H1).
intro.
elim (weak_left_consistent_inj_inv_left_iff_left_consistent g).
intros.
apply H3.
split.
trivial.
unfold injective_inv_left in |- *.

*****
H4 : forall _ : is_left_consistent g,\nand (weak_left_consistent g) (injective_inv_left g)
H3 : forall _ : and (weak_left_consistent g) (injective_inv_left g),\nis_left_consistent g
H2 : weak_left_consistent g
H1 : le_h g h
H0 : is_left_consistent h
H : is_irreducible g
g,h : hedge
*****
forall (M N : Msg) (_ : g M N) (M' N' : Msg) (_ : g M' N') (_ : eq M' (inv M)), eq N' (inv N)
+++++
intros.
-----
Theorem irr_le_h_left_consistent_impl_left_consistent : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> is_left_consistent g.
intros.
generalize (irr_le_h_left_consistent_impl_left_consistent_weak g h H H0 H1).
intro.
elim (weak_left_consistent_inj_inv_left_iff_left_consistent g).
intros.
apply H3.
split.
trivial.
unfold injective_inv_left in |- *.
intros.

*****
H7 : eq M' (inv M)
H6 : g M' N'
M',N' : Msg
H5 : g M N
M,N : Msg
H4 : forall _ : is_left_consistent g,\nand (weak_left_consistent g) (injective_inv_left g)
H3 : forall _ : and (weak_left_consistent g) (injective_inv_left g),\nis_left_consistent g
H2 : weak_left_consistent g
H1 : le_h g h
H0 : is_left_consistent h
H : is_irreducible g
g,h : hedge
*****
eq N' (inv N)
+++++
unfold is_left_consistent in H0.
-----
Theorem irr_le_h_left_consistent_impl_left_consistent : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> is_left_consistent g.
intros.
generalize (irr_le_h_left_consistent_impl_left_consistent_weak g h H H0 H1).
intro.
elim (weak_left_consistent_inj_inv_left_iff_left_consistent g).
intros.
apply H3.
split.
trivial.
unfold injective_inv_left in |- *.
intros.
unfold is_left_consistent in H0.

*****
H7 : eq M' (inv M)
H6 : g M' N'
M',N' : Msg
H5 : g M N
M,N : Msg
H4 : forall _ : is_left_consistent g,\nand (weak_left_consistent g) (injective_inv_left g)
H3 : forall _ : and (weak_left_consistent g) (injective_inv_left g),\nis_left_consistent g
H2 : weak_left_consistent g
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
eq N' (inv N)
+++++
elim H0.
-----
Theorem irr_le_h_left_consistent_impl_left_consistent : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> is_left_consistent g.
intros.
generalize (irr_le_h_left_consistent_impl_left_consistent_weak g h H H0 H1).
intro.
elim (weak_left_consistent_inj_inv_left_iff_left_consistent g).
intros.
apply H3.
split.
trivial.
unfold injective_inv_left in |- *.
intros.
unfold is_left_consistent in H0.
elim H0.

*****
H7 : eq M' (inv M)
H6 : g M' N'
M',N' : Msg
H5 : g M N
M,N : Msg
H4 : forall _ : is_left_consistent g,\nand (weak_left_consistent g) (injective_inv_left g)
H3 : forall _ : and (weak_left_consistent g) (injective_inv_left g),\nis_left_consistent g
H2 : weak_left_consistent g
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
forall (_ : name_left_name h) (_ : and (injective_left h) (and (op_synthesis_left h) (and (pair_free_left h) (and (enc_synthesis_left h) (and (enc_analysis_left h) (injective_inv_left h)))))), eq N' (inv N)
+++++
intros.
-----
Theorem irr_le_h_left_consistent_impl_left_consistent : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> is_left_consistent g.
intros.
generalize (irr_le_h_left_consistent_impl_left_consistent_weak g h H H0 H1).
intro.
elim (weak_left_consistent_inj_inv_left_iff_left_consistent g).
intros.
apply H3.
split.
trivial.
unfold injective_inv_left in |- *.
intros.
unfold is_left_consistent in H0.
elim H0.
intros.

*****
H9 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H8 : name_left_name h
H7 : eq M' (inv M)
H6 : g M' N'
M',N' : Msg
H5 : g M N
M,N : Msg
H4 : forall _ : is_left_consistent g,\nand (weak_left_consistent g) (injective_inv_left g)
H3 : forall _ : and (weak_left_consistent g) (injective_inv_left g),\nis_left_consistent g
H2 : weak_left_consistent g
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
eq N' (inv N)
+++++
elim H9.
-----
Theorem irr_le_h_left_consistent_impl_left_consistent : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> is_left_consistent g.
intros.
generalize (irr_le_h_left_consistent_impl_left_consistent_weak g h H H0 H1).
intro.
elim (weak_left_consistent_inj_inv_left_iff_left_consistent g).
intros.
apply H3.
split.
trivial.
unfold injective_inv_left in |- *.
intros.
unfold is_left_consistent in H0.
elim H0.
intros.
elim H9.

*****
H9 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H8 : name_left_name h
H7 : eq M' (inv M)
H6 : g M' N'
M',N' : Msg
H5 : g M N
M,N : Msg
H4 : forall _ : is_left_consistent g,\nand (weak_left_consistent g) (injective_inv_left g)
H3 : forall _ : and (weak_left_consistent g) (injective_inv_left g),\nis_left_consistent g
H2 : weak_left_consistent g
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
forall (_ : injective_left h) (_ : and (op_synthesis_left h) (and (pair_free_left h) (and (enc_synthesis_left h) (and (enc_analysis_left h) (injective_inv_left h))))), eq N' (inv N)
+++++
intros.
-----
Theorem irr_le_h_left_consistent_impl_left_consistent : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> is_left_consistent g.
intros.
generalize (irr_le_h_left_consistent_impl_left_consistent_weak g h H H0 H1).
intro.
elim (weak_left_consistent_inj_inv_left_iff_left_consistent g).
intros.
apply H3.
split.
trivial.
unfold injective_inv_left in |- *.
intros.
unfold is_left_consistent in H0.
elim H0.
intros.
elim H9.
intros.

*****
H11 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H10 : injective_left h
H9 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H8 : name_left_name h
H7 : eq M' (inv M)
H6 : g M' N'
M',N' : Msg
H5 : g M N
M,N : Msg
H4 : forall _ : is_left_consistent g,\nand (weak_left_consistent g) (injective_inv_left g)
H3 : forall _ : and (weak_left_consistent g) (injective_inv_left g),\nis_left_consistent g
H2 : weak_left_consistent g
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
eq N' (inv N)
+++++
elim H11.
-----
Theorem irr_le_h_left_consistent_impl_left_consistent : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> is_left_consistent g.
intros.
generalize (irr_le_h_left_consistent_impl_left_consistent_weak g h H H0 H1).
intro.
elim (weak_left_consistent_inj_inv_left_iff_left_consistent g).
intros.
apply H3.
split.
trivial.
unfold injective_inv_left in |- *.
intros.
unfold is_left_consistent in H0.
elim H0.
intros.
elim H9.
intros.
elim H11.

*****
H11 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H10 : injective_left h
H9 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H8 : name_left_name h
H7 : eq M' (inv M)
H6 : g M' N'
M',N' : Msg
H5 : g M N
M,N : Msg
H4 : forall _ : is_left_consistent g,\nand (weak_left_consistent g) (injective_inv_left g)
H3 : forall _ : and (weak_left_consistent g) (injective_inv_left g),\nis_left_consistent g
H2 : weak_left_consistent g
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
forall (_ : op_synthesis_left h) (_ : and (pair_free_left h) (and (enc_synthesis_left h) (and (enc_analysis_left h) (injective_inv_left h)))), eq N' (inv N)
+++++
intros.
-----
Theorem irr_le_h_left_consistent_impl_left_consistent : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> is_left_consistent g.
intros.
generalize (irr_le_h_left_consistent_impl_left_consistent_weak g h H H0 H1).
intro.
elim (weak_left_consistent_inj_inv_left_iff_left_consistent g).
intros.
apply H3.
split.
trivial.
unfold injective_inv_left in |- *.
intros.
unfold is_left_consistent in H0.
elim H0.
intros.
elim H9.
intros.
elim H11.
intros.

*****
H13 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H12 : op_synthesis_left h
H11 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H10 : injective_left h
H9 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H8 : name_left_name h
H7 : eq M' (inv M)
H6 : g M' N'
M',N' : Msg
H5 : g M N
M,N : Msg
H4 : forall _ : is_left_consistent g,\nand (weak_left_consistent g) (injective_inv_left g)
H3 : forall _ : and (weak_left_consistent g) (injective_inv_left g),\nis_left_consistent g
H2 : weak_left_consistent g
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
eq N' (inv N)
+++++
elim H13.
-----
Theorem irr_le_h_left_consistent_impl_left_consistent : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> is_left_consistent g.
intros.
generalize (irr_le_h_left_consistent_impl_left_consistent_weak g h H H0 H1).
intro.
elim (weak_left_consistent_inj_inv_left_iff_left_consistent g).
intros.
apply H3.
split.
trivial.
unfold injective_inv_left in |- *.
intros.
unfold is_left_consistent in H0.
elim H0.
intros.
elim H9.
intros.
elim H11.
intros.
elim H13.

*****
H13 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H12 : op_synthesis_left h
H11 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H10 : injective_left h
H9 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H8 : name_left_name h
H7 : eq M' (inv M)
H6 : g M' N'
M',N' : Msg
H5 : g M N
M,N : Msg
H4 : forall _ : is_left_consistent g,\nand (weak_left_consistent g) (injective_inv_left g)
H3 : forall _ : and (weak_left_consistent g) (injective_inv_left g),\nis_left_consistent g
H2 : weak_left_consistent g
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
forall (_ : pair_free_left h) (_ : and (enc_synthesis_left h) (and (enc_analysis_left h) (injective_inv_left h))), eq N' (inv N)
+++++
intros.
-----
Theorem irr_le_h_left_consistent_impl_left_consistent : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> is_left_consistent g.
intros.
generalize (irr_le_h_left_consistent_impl_left_consistent_weak g h H H0 H1).
intro.
elim (weak_left_consistent_inj_inv_left_iff_left_consistent g).
intros.
apply H3.
split.
trivial.
unfold injective_inv_left in |- *.
intros.
unfold is_left_consistent in H0.
elim H0.
intros.
elim H9.
intros.
elim H11.
intros.
elim H13.
intros.

*****
H15 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H14 : pair_free_left h
H13 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H12 : op_synthesis_left h
H11 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H10 : injective_left h
H9 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H8 : name_left_name h
H7 : eq M' (inv M)
H6 : g M' N'
M',N' : Msg
H5 : g M N
M,N : Msg
H4 : forall _ : is_left_consistent g,\nand (weak_left_consistent g) (injective_inv_left g)
H3 : forall _ : and (weak_left_consistent g) (injective_inv_left g),\nis_left_consistent g
H2 : weak_left_consistent g
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
eq N' (inv N)
+++++
elim H15.
-----
Theorem irr_le_h_left_consistent_impl_left_consistent : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> is_left_consistent g.
intros.
generalize (irr_le_h_left_consistent_impl_left_consistent_weak g h H H0 H1).
intro.
elim (weak_left_consistent_inj_inv_left_iff_left_consistent g).
intros.
apply H3.
split.
trivial.
unfold injective_inv_left in |- *.
intros.
unfold is_left_consistent in H0.
elim H0.
intros.
elim H9.
intros.
elim H11.
intros.
elim H13.
intros.
elim H15.

*****
H15 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H14 : pair_free_left h
H13 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H12 : op_synthesis_left h
H11 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H10 : injective_left h
H9 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H8 : name_left_name h
H7 : eq M' (inv M)
H6 : g M' N'
M',N' : Msg
H5 : g M N
M,N : Msg
H4 : forall _ : is_left_consistent g,\nand (weak_left_consistent g) (injective_inv_left g)
H3 : forall _ : and (weak_left_consistent g) (injective_inv_left g),\nis_left_consistent g
H2 : weak_left_consistent g
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
forall (_ : enc_synthesis_left h) (_ : and (enc_analysis_left h) (injective_inv_left h)), eq N' (inv N)
+++++
intros.
-----
Theorem irr_le_h_left_consistent_impl_left_consistent : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> is_left_consistent g.
intros.
generalize (irr_le_h_left_consistent_impl_left_consistent_weak g h H H0 H1).
intro.
elim (weak_left_consistent_inj_inv_left_iff_left_consistent g).
intros.
apply H3.
split.
trivial.
unfold injective_inv_left in |- *.
intros.
unfold is_left_consistent in H0.
elim H0.
intros.
elim H9.
intros.
elim H11.
intros.
elim H13.
intros.
elim H15.
intros.

*****
H17 : and (enc_analysis_left h) (injective_inv_left h)
H16 : enc_synthesis_left h
H15 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H14 : pair_free_left h
H13 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H12 : op_synthesis_left h
H11 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H10 : injective_left h
H9 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H8 : name_left_name h
H7 : eq M' (inv M)
H6 : g M' N'
M',N' : Msg
H5 : g M N
M,N : Msg
H4 : forall _ : is_left_consistent g,\nand (weak_left_consistent g) (injective_inv_left g)
H3 : forall _ : and (weak_left_consistent g) (injective_inv_left g),\nis_left_consistent g
H2 : weak_left_consistent g
H1 : le_h g h
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
eq N' (inv N)
+++++
unfold le_h in H1.
-----
Theorem irr_le_h_left_consistent_impl_left_consistent : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> is_left_consistent g.
intros.
generalize (irr_le_h_left_consistent_impl_left_consistent_weak g h H H0 H1).
intro.
elim (weak_left_consistent_inj_inv_left_iff_left_consistent g).
intros.
apply H3.
split.
trivial.
unfold injective_inv_left in |- *.
intros.
unfold is_left_consistent in H0.
elim H0.
intros.
elim H9.
intros.
elim H11.
intros.
elim H13.
intros.
elim H15.
intros.
unfold le_h in H1.

*****
H17 : and (enc_analysis_left h) (injective_inv_left h)
H16 : enc_synthesis_left h
H15 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H14 : pair_free_left h
H13 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H12 : op_synthesis_left h
H11 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H10 : injective_left h
H9 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H8 : name_left_name h
H7 : eq M' (inv M)
H6 : g M' N'
M',N' : Msg
H5 : g M N
M,N : Msg
H4 : forall _ : is_left_consistent g,\nand (weak_left_consistent g) (injective_inv_left g)
H3 : forall _ : and (weak_left_consistent g) (injective_inv_left g),\nis_left_consistent g
H2 : weak_left_consistent g
H1 : inclusion (synthesis g) (synthesis h)
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
eq N' (inv N)
+++++
unfold inclusion in H1.
-----
Theorem irr_le_h_left_consistent_impl_left_consistent : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> is_left_consistent g.
intros.
generalize (irr_le_h_left_consistent_impl_left_consistent_weak g h H H0 H1).
intro.
elim (weak_left_consistent_inj_inv_left_iff_left_consistent g).
intros.
apply H3.
split.
trivial.
unfold injective_inv_left in |- *.
intros.
unfold is_left_consistent in H0.
elim H0.
intros.
elim H9.
intros.
elim H11.
intros.
elim H13.
intros.
elim H15.
intros.
unfold le_h in H1.
unfold inclusion in H1.

*****
H17 : and (enc_analysis_left h) (injective_inv_left h)
H16 : enc_synthesis_left h
H15 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H14 : pair_free_left h
H13 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H12 : op_synthesis_left h
H11 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H10 : injective_left h
H9 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H8 : name_left_name h
H7 : eq M' (inv M)
H6 : g M' N'
M',N' : Msg
H5 : g M N
M,N : Msg
H4 : forall _ : is_left_consistent g,\nand (weak_left_consistent g) (injective_inv_left g)
H3 : forall _ : and (weak_left_consistent g) (injective_inv_left g),\nis_left_consistent g
H2 : weak_left_consistent g
H1 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
eq N' (inv N)
+++++
generalize (H1 M N (SynInc g M N H5)).
-----
Theorem irr_le_h_left_consistent_impl_left_consistent : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> is_left_consistent g.
intros.
generalize (irr_le_h_left_consistent_impl_left_consistent_weak g h H H0 H1).
intro.
elim (weak_left_consistent_inj_inv_left_iff_left_consistent g).
intros.
apply H3.
split.
trivial.
unfold injective_inv_left in |- *.
intros.
unfold is_left_consistent in H0.
elim H0.
intros.
elim H9.
intros.
elim H11.
intros.
elim H13.
intros.
elim H15.
intros.
unfold le_h in H1.
unfold inclusion in H1.
generalize (H1 M N (SynInc g M N H5)).

*****
H17 : and (enc_analysis_left h) (injective_inv_left h)
H16 : enc_synthesis_left h
H15 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H14 : pair_free_left h
H13 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H12 : op_synthesis_left h
H11 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H10 : injective_left h
H9 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H8 : name_left_name h
H7 : eq M' (inv M)
H6 : g M' N'
M',N' : Msg
H5 : g M N
M,N : Msg
H4 : forall _ : is_left_consistent g,\nand (weak_left_consistent g) (injective_inv_left g)
H3 : forall _ : and (weak_left_consistent g) (injective_inv_left g),\nis_left_consistent g
H2 : weak_left_consistent g
H1 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
forall _ : synthesis h M N, eq N' (inv N)
+++++
intro.
-----
Theorem irr_le_h_left_consistent_impl_left_consistent : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> is_left_consistent g.
intros.
generalize (irr_le_h_left_consistent_impl_left_consistent_weak g h H H0 H1).
intro.
elim (weak_left_consistent_inj_inv_left_iff_left_consistent g).
intros.
apply H3.
split.
trivial.
unfold injective_inv_left in |- *.
intros.
unfold is_left_consistent in H0.
elim H0.
intros.
elim H9.
intros.
elim H11.
intros.
elim H13.
intros.
elim H15.
intros.
unfold le_h in H1.
unfold inclusion in H1.
generalize (H1 M N (SynInc g M N H5)).
intro.

*****
H18 : synthesis h M N
H17 : and (enc_analysis_left h) (injective_inv_left h)
H16 : enc_synthesis_left h
H15 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H14 : pair_free_left h
H13 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H12 : op_synthesis_left h
H11 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H10 : injective_left h
H9 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H8 : name_left_name h
H7 : eq M' (inv M)
H6 : g M' N'
M',N' : Msg
H5 : g M N
M,N : Msg
H4 : forall _ : is_left_consistent g,\nand (weak_left_consistent g) (injective_inv_left g)
H3 : forall _ : and (weak_left_consistent g) (injective_inv_left g),\nis_left_consistent g
H2 : weak_left_consistent g
H1 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
eq N' (inv N)
+++++
generalize (H1 M' N' (SynInc g M' N' H6)).
-----
Theorem irr_le_h_left_consistent_impl_left_consistent : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> is_left_consistent g.
intros.
generalize (irr_le_h_left_consistent_impl_left_consistent_weak g h H H0 H1).
intro.
elim (weak_left_consistent_inj_inv_left_iff_left_consistent g).
intros.
apply H3.
split.
trivial.
unfold injective_inv_left in |- *.
intros.
unfold is_left_consistent in H0.
elim H0.
intros.
elim H9.
intros.
elim H11.
intros.
elim H13.
intros.
elim H15.
intros.
unfold le_h in H1.
unfold inclusion in H1.
generalize (H1 M N (SynInc g M N H5)).
intro.
generalize (H1 M' N' (SynInc g M' N' H6)).

*****
H18 : synthesis h M N
H17 : and (enc_analysis_left h) (injective_inv_left h)
H16 : enc_synthesis_left h
H15 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H14 : pair_free_left h
H13 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H12 : op_synthesis_left h
H11 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H10 : injective_left h
H9 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H8 : name_left_name h
H7 : eq M' (inv M)
H6 : g M' N'
M',N' : Msg
H5 : g M N
M,N : Msg
H4 : forall _ : is_left_consistent g,\nand (weak_left_consistent g) (injective_inv_left g)
H3 : forall _ : and (weak_left_consistent g) (injective_inv_left g),\nis_left_consistent g
H2 : weak_left_consistent g
H1 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
forall _ : synthesis h M' N', eq N' (inv N)
+++++
intro.
-----
Theorem irr_le_h_left_consistent_impl_left_consistent : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> is_left_consistent g.
intros.
generalize (irr_le_h_left_consistent_impl_left_consistent_weak g h H H0 H1).
intro.
elim (weak_left_consistent_inj_inv_left_iff_left_consistent g).
intros.
apply H3.
split.
trivial.
unfold injective_inv_left in |- *.
intros.
unfold is_left_consistent in H0.
elim H0.
intros.
elim H9.
intros.
elim H11.
intros.
elim H13.
intros.
elim H15.
intros.
unfold le_h in H1.
unfold inclusion in H1.
generalize (H1 M N (SynInc g M N H5)).
intro.
generalize (H1 M' N' (SynInc g M' N' H6)).
intro.

*****
H19 : synthesis h M' N'
H18 : synthesis h M N
H17 : and (enc_analysis_left h) (injective_inv_left h)
H16 : enc_synthesis_left h
H15 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H14 : pair_free_left h
H13 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H12 : op_synthesis_left h
H11 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H10 : injective_left h
H9 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H8 : name_left_name h
H7 : eq M' (inv M)
H6 : g M' N'
M',N' : Msg
H5 : g M N
M,N : Msg
H4 : forall _ : is_left_consistent g,\nand (weak_left_consistent g) (injective_inv_left g)
H3 : forall _ : and (weak_left_consistent g) (injective_inv_left g),\nis_left_consistent g
H2 : weak_left_consistent g
H1 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
eq N' (inv N)
+++++
elim H17.
-----
Theorem irr_le_h_left_consistent_impl_left_consistent : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> is_left_consistent g.
intros.
generalize (irr_le_h_left_consistent_impl_left_consistent_weak g h H H0 H1).
intro.
elim (weak_left_consistent_inj_inv_left_iff_left_consistent g).
intros.
apply H3.
split.
trivial.
unfold injective_inv_left in |- *.
intros.
unfold is_left_consistent in H0.
elim H0.
intros.
elim H9.
intros.
elim H11.
intros.
elim H13.
intros.
elim H15.
intros.
unfold le_h in H1.
unfold inclusion in H1.
generalize (H1 M N (SynInc g M N H5)).
intro.
generalize (H1 M' N' (SynInc g M' N' H6)).
intro.
elim H17.

*****
H19 : synthesis h M' N'
H18 : synthesis h M N
H17 : and (enc_analysis_left h) (injective_inv_left h)
H16 : enc_synthesis_left h
H15 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H14 : pair_free_left h
H13 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H12 : op_synthesis_left h
H11 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H10 : injective_left h
H9 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H8 : name_left_name h
H7 : eq M' (inv M)
H6 : g M' N'
M',N' : Msg
H5 : g M N
M,N : Msg
H4 : forall _ : is_left_consistent g,\nand (weak_left_consistent g) (injective_inv_left g)
H3 : forall _ : and (weak_left_consistent g) (injective_inv_left g),\nis_left_consistent g
H2 : weak_left_consistent g
H1 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
forall (_ : enc_analysis_left h) (_ : injective_inv_left h), eq N' (inv N)
+++++
intros.
-----
Theorem irr_le_h_left_consistent_impl_left_consistent : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> is_left_consistent g.
intros.
generalize (irr_le_h_left_consistent_impl_left_consistent_weak g h H H0 H1).
intro.
elim (weak_left_consistent_inj_inv_left_iff_left_consistent g).
intros.
apply H3.
split.
trivial.
unfold injective_inv_left in |- *.
intros.
unfold is_left_consistent in H0.
elim H0.
intros.
elim H9.
intros.
elim H11.
intros.
elim H13.
intros.
elim H15.
intros.
unfold le_h in H1.
unfold inclusion in H1.
generalize (H1 M N (SynInc g M N H5)).
intro.
generalize (H1 M' N' (SynInc g M' N' H6)).
intro.
elim H17.
intros.

*****
H21 : injective_inv_left h
H20 : enc_analysis_left h
H19 : synthesis h M' N'
H18 : synthesis h M N
H17 : and (enc_analysis_left h) (injective_inv_left h)
H16 : enc_synthesis_left h
H15 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H14 : pair_free_left h
H13 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H12 : op_synthesis_left h
H11 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H10 : injective_left h
H9 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H8 : name_left_name h
H7 : eq M' (inv M)
H6 : g M' N'
M',N' : Msg
H5 : g M N
M,N : Msg
H4 : forall _ : is_left_consistent g,\nand (weak_left_consistent g) (injective_inv_left g)
H3 : forall _ : and (weak_left_consistent g) (injective_inv_left g),\nis_left_consistent g
H2 : weak_left_consistent g
H1 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
eq N' (inv N)
+++++
generalize (inj_inv_left_syn h H10 H16 H12 H14 H21).
-----
Theorem irr_le_h_left_consistent_impl_left_consistent : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> is_left_consistent g.
intros.
generalize (irr_le_h_left_consistent_impl_left_consistent_weak g h H H0 H1).
intro.
elim (weak_left_consistent_inj_inv_left_iff_left_consistent g).
intros.
apply H3.
split.
trivial.
unfold injective_inv_left in |- *.
intros.
unfold is_left_consistent in H0.
elim H0.
intros.
elim H9.
intros.
elim H11.
intros.
elim H13.
intros.
elim H15.
intros.
unfold le_h in H1.
unfold inclusion in H1.
generalize (H1 M N (SynInc g M N H5)).
intro.
generalize (H1 M' N' (SynInc g M' N' H6)).
intro.
elim H17.
intros.
generalize (inj_inv_left_syn h H10 H16 H12 H14 H21).

*****
H21 : injective_inv_left h
H20 : enc_analysis_left h
H19 : synthesis h M' N'
H18 : synthesis h M N
H17 : and (enc_analysis_left h) (injective_inv_left h)
H16 : enc_synthesis_left h
H15 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H14 : pair_free_left h
H13 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H12 : op_synthesis_left h
H11 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H10 : injective_left h
H9 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H8 : name_left_name h
H7 : eq M' (inv M)
H6 : g M' N'
M',N' : Msg
H5 : g M N
M,N : Msg
H4 : forall _ : is_left_consistent g,\nand (weak_left_consistent g) (injective_inv_left g)
H3 : forall _ : and (weak_left_consistent g) (injective_inv_left g),\nis_left_consistent g
H2 : weak_left_consistent g
H1 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
forall _ : injective_inv_left (synthesis h), eq N' (inv N)
+++++
unfold injective_inv_left in |- *.
-----
Theorem irr_le_h_left_consistent_impl_left_consistent : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> is_left_consistent g.
intros.
generalize (irr_le_h_left_consistent_impl_left_consistent_weak g h H H0 H1).
intro.
elim (weak_left_consistent_inj_inv_left_iff_left_consistent g).
intros.
apply H3.
split.
trivial.
unfold injective_inv_left in |- *.
intros.
unfold is_left_consistent in H0.
elim H0.
intros.
elim H9.
intros.
elim H11.
intros.
elim H13.
intros.
elim H15.
intros.
unfold le_h in H1.
unfold inclusion in H1.
generalize (H1 M N (SynInc g M N H5)).
intro.
generalize (H1 M' N' (SynInc g M' N' H6)).
intro.
elim H17.
intros.
generalize (inj_inv_left_syn h H10 H16 H12 H14 H21).
unfold injective_inv_left in |- *.

*****
H21 : injective_inv_left h
H20 : enc_analysis_left h
H19 : synthesis h M' N'
H18 : synthesis h M N
H17 : and (enc_analysis_left h) (injective_inv_left h)
H16 : enc_synthesis_left h
H15 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H14 : pair_free_left h
H13 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H12 : op_synthesis_left h
H11 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H10 : injective_left h
H9 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H8 : name_left_name h
H7 : eq M' (inv M)
H6 : g M' N'
M',N' : Msg
H5 : g M N
M,N : Msg
H4 : forall _ : is_left_consistent g,\nand (weak_left_consistent g) (injective_inv_left g)
H3 : forall _ : and (weak_left_consistent g) (injective_inv_left g),\nis_left_consistent g
H2 : weak_left_consistent g
H1 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
forall _ : forall (M N : Msg) (_ : synthesis h M N) (M' N' : Msg) (_ : synthesis h M' N') (_ : eq M' (inv M)), eq N' (inv N), eq N' (inv N)
+++++
intros.
-----
Theorem irr_le_h_left_consistent_impl_left_consistent : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> is_left_consistent g.
intros.
generalize (irr_le_h_left_consistent_impl_left_consistent_weak g h H H0 H1).
intro.
elim (weak_left_consistent_inj_inv_left_iff_left_consistent g).
intros.
apply H3.
split.
trivial.
unfold injective_inv_left in |- *.
intros.
unfold is_left_consistent in H0.
elim H0.
intros.
elim H9.
intros.
elim H11.
intros.
elim H13.
intros.
elim H15.
intros.
unfold le_h in H1.
unfold inclusion in H1.
generalize (H1 M N (SynInc g M N H5)).
intro.
generalize (H1 M' N' (SynInc g M' N' H6)).
intro.
elim H17.
intros.
generalize (inj_inv_left_syn h H10 H16 H12 H14 H21).
unfold injective_inv_left in |- *.
intros.

*****
H22 : forall (M N : Msg) (_ : synthesis h M N) (M' N' : Msg)\n (_ : synthesis h M' N') (_ : eq M' (inv M)), eq N' (inv N)
H21 : injective_inv_left h
H20 : enc_analysis_left h
H19 : synthesis h M' N'
H18 : synthesis h M N
H17 : and (enc_analysis_left h) (injective_inv_left h)
H16 : enc_synthesis_left h
H15 : and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))
H14 : pair_free_left h
H13 : and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))
H12 : op_synthesis_left h
H11 : and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))
H10 : injective_left h
H9 : and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h)))))
H8 : name_left_name h
H7 : eq M' (inv M)
H6 : g M' N'
M',N' : Msg
H5 : g M N
M,N : Msg
H4 : forall _ : is_left_consistent g,\nand (weak_left_consistent g) (injective_inv_left g)
H3 : forall _ : and (weak_left_consistent g) (injective_inv_left g),\nis_left_consistent g
H2 : weak_left_consistent g
H1 : forall (M N : Msg) (_ : synthesis g M N), synthesis h M N
H0 : and (name_left_name h)\n (and (injective_left h)\n (and (op_synthesis_left h)\n (and (pair_free_left h)\n (and (enc_synthesis_left h)\n (and (enc_analysis_left h) (injective_inv_left h))))))
H : is_irreducible g
g,h : hedge
*****
eq N' (inv N)
+++++
apply (H22 M N H18 M' N' H19 H7).
-----
Theorem irr_le_h_left_consistent_impl_left_consistent : forall g h : hedge, is_irreducible g -> is_left_consistent h -> le_h g h -> is_left_consistent g.
intros.
generalize (irr_le_h_left_consistent_impl_left_consistent_weak g h H H0 H1).
intro.
elim (weak_left_consistent_inj_inv_left_iff_left_consistent g).
intros.
apply H3.
split.

*****

*****

+++++
Qed.
-----
Lemma reduce_transpose_transpose_reduce :\n forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).

*****

*****
forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h))
+++++
unfold equal in |- *.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.

*****

*****
forall h : hedge, and (inclusion (reduce (transpose h)) (transpose (reduce h))) (inclusion (transpose (reduce h)) (reduce (transpose h)))
+++++
split.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.

*****
h : hedge
*****
inclusion (reduce (transpose h)) (transpose (reduce h))
+++++
unfold inclusion in |- *.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.

*****
h : hedge
*****
forall (M N : Msg) (_ : reduce (transpose h) M N), transpose (reduce h) M N
+++++
unfold transpose in |- *.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
unfold transpose in |- *.

*****
h : hedge
*****
forall (M N : Msg) (_ : reduce (fun M0 N0 : Msg => h N0 M0) M N), reduce h N M
+++++
intros M N.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
unfold transpose in |- *.
intros M N.

*****
M,N : Msg
h : hedge
*****
forall _ : reduce (fun M N : Msg => h N M) M N, reduce h N M
+++++
unfold reduce in |- *.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
unfold transpose in |- *.
intros M N.
unfold reduce in |- *.

*****
M,N : Msg
h : hedge
*****
forall _ : and (h N M) match M with | MNam _ => True | MEnc M' K => match N with | MEnc N' L => or (not (synthesis (fun M N : Msg => h N M) M' N')) (not (synthesis (fun M N : Msg => h N M) K L)) | _ => True end | MPair M1 M2 => match N with | MPair N1 N2 => or (not (synthesis (fun M N : Msg => h N M) M1 N1)) (not (synthesis (fun M N : Msg => h N M) M2 N2)) | _ => True end | Mop opM M' => match N with | Mop opN N' => or (not (eq opM opN)) (not (synthesis (fun M N : Msg => h N M) M' N')) | _ => True end end, and (h N M) match N with | MNam _ => True | MEnc M' K => match M with | MEnc N' L => or (not (synthesis h M' N')) (not (synthesis h K L)) | _ => True end | MPair M1 M2 => match M with | MPair N1 N2 => or (not (synthesis h M1 N1)) (not (synthesis h M2 N2)) | _ => True end | Mop opM M' => match M with | Mop opN N' => or (not (eq opM opN)) (not (synthesis h M' N')) | _ => True end end
+++++
intro.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
unfold transpose in |- *.
intros M N.
unfold reduce in |- *.
intro.

*****
H : and (h N M)\n match M with\n | MNam _ => True\n | MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
and (h N M) match N with | MNam _ => True | MEnc M' K => match M with | MEnc N' L => or (not (synthesis h M' N')) (not (synthesis h K L)) | _ => True end | MPair M1 M2 => match M with | MPair N1 N2 => or (not (synthesis h M1 N1)) (not (synthesis h M2 N2)) | _ => True end | Mop opM M' => match M with | Mop opN N' => or (not (eq opM opN)) (not (synthesis h M' N')) | _ => True end end
+++++
elim H.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
unfold transpose in |- *.
intros M N.
unfold reduce in |- *.
intro.
elim H.

*****
H : and (h N M)\n match M with\n | MNam _ => True\n | MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
forall (_ : h N M) (_ : match M with | MNam _ => True | MEnc M' K => match N with | MEnc N' L => or (not (synthesis (fun M N : Msg => h N M) M' N')) (not (synthesis (fun M N : Msg => h N M) K L)) | _ => True end | MPair M1 M2 => match N with | MPair N1 N2 => or (not (synthesis (fun M N : Msg => h N M) M1 N1)) (not (synthesis (fun M N : Msg => h N M) M2 N2)) | _ => True end | Mop opM M' => match N with | Mop opN N' => or (not (eq opM opN)) (not (synthesis (fun M N : Msg => h N M) M' N')) | _ => True end end), and (h N M) match N with | MNam _ => True | MEnc M' K => match M with | MEnc N' L => or (not (synthesis h M' N')) (not (synthesis h K L)) | _ => True end | MPair M1 M2 => match M with | MPair N1 N2 => or (not (synthesis h M1 N1)) (not (synthesis h M2 N2)) | _ => True end | Mop opM M' => match M with | Mop opN N' => or (not (eq opM opN)) (not (synthesis h M' N')) | _ => True end end
+++++
split.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
unfold transpose in |- *.
intros M N.
unfold reduce in |- *.
intro.
elim H.
split.

*****
H1 : match M with\n| MNam _ => True\n| MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n| MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n| Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\nend
H0 : h N M
H : and (h N M)\n match M with\n | MNam _ => True\n | MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
h N M
+++++
trivial.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
unfold transpose in |- *.
intros M N.
unfold reduce in |- *.
intro.
elim H.
split.

*****
H1 : match M with\n| MNam _ => True\n| MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n| MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n| Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\nend
H0 : h N M
H : and (h N M)\n match M with\n | MNam _ => True\n | MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
match N with | MNam _ => True | MEnc M' K => match M with | MEnc N' L => or (not (synthesis h M' N')) (not (synthesis h K L)) | _ => True end | MPair M1 M2 => match M with | MPair N1 N2 => or (not (synthesis h M1 N1)) (not (synthesis h M2 N2)) | _ => True end | Mop opM M' => match M with | Mop opN N' => or (not (eq opM opN)) (not (synthesis h M' N')) | _ => True end end
+++++
generalize H1.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
unfold transpose in |- *.
intros M N.
unfold reduce in |- *.
intro.
elim H.
split.
generalize H1.

*****
H1 : match M with\n| MNam _ => True\n| MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n| MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n| Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\nend
H0 : h N M
H : and (h N M)\n match M with\n | MNam _ => True\n | MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
forall _ : match M with | MNam _ => True | MEnc M' K => match N with | MEnc N' L => or (not (synthesis (fun M N : Msg => h N M) M' N')) (not (synthesis (fun M N : Msg => h N M) K L)) | _ => True end | MPair M1 M2 => match N with | MPair N1 N2 => or (not (synthesis (fun M N : Msg => h N M) M1 N1)) (not (synthesis (fun M N : Msg => h N M) M2 N2)) | _ => True end | Mop opM M' => match N with | Mop opN N' => or (not (eq opM opN)) (not (synthesis (fun M N : Msg => h N M) M' N')) | _ => True end end, match N with | MNam _ => True | MEnc M' K => match M with | MEnc N' L => or (not (synthesis h M' N')) (not (synthesis h K L)) | _ => True end | MPair M1 M2 => match M with | MPair N1 N2 => or (not (synthesis h M1 N1)) (not (synthesis h M2 N2)) | _ => True end | Mop opM M' => match M with | Mop opN N' => or (not (eq opM opN)) (not (synthesis h M' N')) | _ => True end end
+++++
case M.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
unfold transpose in |- *.
intros M N.
unfold reduce in |- *.
intro.
elim H.
split.
generalize H1.
case M.

*****
H1 : match M with\n| MNam _ => True\n| MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n| MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n| Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\nend
H0 : h N M
H : and (h N M)\n match M with\n | MNam _ => True\n | MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
forall (_ : Nam) (_ : True), match N with | MNam _ | _ => True end
+++++
try tauto.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
unfold transpose in |- *.
intros M N.
unfold reduce in |- *.
intro.
elim H.
split.
generalize H1.
case M.
try tauto.

*****
H1 : match M with\n| MNam _ => True\n| MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n| MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n| Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\nend
H0 : h N M
H : and (h N M)\n match M with\n | MNam _ => True\n | MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
forall (_ : Nam) (_ : True), match N with | MNam _ | _ => True end
+++++
case N.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
unfold transpose in |- *.
intros M N.
unfold reduce in |- *.
intro.
elim H.
split.
generalize H1.
case M.
try tauto.
case N.

*****
H1 : match M with\n| MNam _ => True\n| MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n| MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n| Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\nend
H0 : h N M
H : and (h N M)\n match M with\n | MNam _ => True\n | MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
forall (_ : Nam) (_ : Nam) (_ : True), True
+++++
try tauto.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
unfold transpose in |- *.
intros M N.
unfold reduce in |- *.
intro.
elim H.
split.
generalize H1.
case M.
try tauto.
case N.

*****
H1 : match M with\n| MNam _ => True\n| MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n| MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n| Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\nend
H0 : h N M
H : and (h N M)\n match M with\n | MNam _ => True\n | MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
forall (_ : Msg) (_ : Msg) (_ : Nam) (_ : True), True
+++++
try tauto.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
unfold transpose in |- *.
intros M N.
unfold reduce in |- *.
intro.
elim H.
split.
generalize H1.
case M.
try tauto.
case N.

*****
H1 : match M with\n| MNam _ => True\n| MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n| MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n| Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\nend
H0 : h N M
H : and (h N M)\n match M with\n | MNam _ => True\n | MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
forall (_ : Msg) (_ : Msg) (_ : Nam) (_ : True), True
+++++
try tauto.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
unfold transpose in |- *.
intros M N.
unfold reduce in |- *.
intro.
elim H.
split.
generalize H1.
case M.
try tauto.
case N.

*****
H1 : match M with\n| MNam _ => True\n| MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n| MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n| Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\nend
H0 : h N M
H : and (h N M)\n match M with\n | MNam _ => True\n | MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
forall (_ : op) (_ : Msg) (_ : Nam) (_ : True), True
+++++
try tauto.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
unfold transpose in |- *.
intros M N.
unfold reduce in |- *.
intro.
elim H.
split.
generalize H1.
case M.

*****
H1 : match M with\n| MNam _ => True\n| MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n| MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n| Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\nend
H0 : h N M
H : and (h N M)\n match M with\n | MNam _ => True\n | MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
forall (m m0 : Msg) (_ : match N with | MEnc N' L => or (not (synthesis (fun M N : Msg => h N M) m N')) (not (synthesis (fun M N : Msg => h N M) m0 L)) | _ => True end), match N with | MEnc M' K => or (not (synthesis h M' m)) (not (synthesis h K m0)) | _ => True end
+++++
try tauto.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
unfold transpose in |- *.
intros M N.
unfold reduce in |- *.
intro.
elim H.
split.
generalize H1.
case M.
try tauto.

*****
H1 : match M with\n| MNam _ => True\n| MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n| MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n| Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\nend
H0 : h N M
H : and (h N M)\n match M with\n | MNam _ => True\n | MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
forall (m m0 : Msg) (_ : match N with | MEnc N' L => or (not (synthesis (fun M N : Msg => h N M) m N')) (not (synthesis (fun M N : Msg => h N M) m0 L)) | _ => True end), match N with | MEnc M' K => or (not (synthesis h M' m)) (not (synthesis h K m0)) | _ => True end
+++++
case N.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
unfold transpose in |- *.
intros M N.
unfold reduce in |- *.
intro.
elim H.
split.
generalize H1.
case M.
try tauto.
case N.

*****
H1 : match M with\n| MNam _ => True\n| MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n| MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n| Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\nend
H0 : h N M
H : and (h N M)\n match M with\n | MNam _ => True\n | MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
forall (_ : Nam) (_ : Msg) (_ : Msg) (_ : True), True
+++++
try tauto.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
unfold transpose in |- *.
intros M N.
unfold reduce in |- *.
intro.
elim H.
split.
generalize H1.
case M.
try tauto.
case N.

*****
H1 : match M with\n| MNam _ => True\n| MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n| MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n| Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\nend
H0 : h N M
H : and (h N M)\n match M with\n | MNam _ => True\n | MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
forall (m m0 m1 m2 : Msg) (_ : or (not (synthesis (fun M N : Msg => h N M) m1 m)) (not (synthesis (fun M N : Msg => h N M) m2 m0))), or (not (synthesis h m m1)) (not (synthesis h m0 m2))
+++++
try tauto.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
unfold transpose in |- *.
intros M N.
unfold reduce in |- *.
intro.
elim H.
split.
generalize H1.
case M.
try tauto.
case N.
try tauto.

*****
H1 : match M with\n| MNam _ => True\n| MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n| MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n| Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\nend
H0 : h N M
H : and (h N M)\n match M with\n | MNam _ => True\n | MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
forall (m m0 m1 m2 : Msg) (_ : or (not (synthesis (fun M N : Msg => h N M) m1 m)) (not (synthesis (fun M N : Msg => h N M) m2 m0))), or (not (synthesis h m m1)) (not (synthesis h m0 m2))
+++++
fold (transpose h) in |- *.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
unfold transpose in |- *.
intros M N.
unfold reduce in |- *.
intro.
elim H.
split.
generalize H1.
case M.
try tauto.
case N.
try tauto.
fold (transpose h) in |- *.

*****
H1 : match M with\n| MNam _ => True\n| MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n| MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n| Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\nend
H0 : h N M
H : and (h N M)\n match M with\n | MNam _ => True\n | MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
forall (m m0 m1 m2 : Msg) (_ : or (not (synthesis (transpose h) m1 m)) (not (synthesis (transpose h) m2 m0))), or (not (synthesis h m m1)) (not (synthesis h m0 m2))
+++++
intros.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
unfold transpose in |- *.
intros M N.
unfold reduce in |- *.
intro.
elim H.
split.
generalize H1.
case M.
try tauto.
case N.
try tauto.
fold (transpose h) in |- *.
intros.

*****
H2 : or (not (synthesis (transpose h) m1 m))\n (not (synthesis (transpose h) m2 m0))
m,m0,m1,m2 : Msg
H1 : match M with\n| MNam _ => True\n| MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n| MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n| Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\nend
H0 : h N M
H : and (h N M)\n match M with\n | MNam _ => True\n | MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
or (not (synthesis h m m1)) (not (synthesis h m0 m2))
+++++
case H2.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
unfold transpose in |- *.
intros M N.
unfold reduce in |- *.
intro.
elim H.
split.
generalize H1.
case M.
try tauto.
case N.
try tauto.
fold (transpose h) in |- *.
intros.
case H2.

*****
H2 : or (not (synthesis (transpose h) m1 m))\n (not (synthesis (transpose h) m2 m0))
m,m0,m1,m2 : Msg
H1 : match M with\n| MNam _ => True\n| MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n| MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n| Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\nend
H0 : h N M
H : and (h N M)\n match M with\n | MNam _ => True\n | MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
forall _ : not (synthesis (transpose h) m1 m), or (not (synthesis h m m1)) (not (synthesis h m0 m2))
+++++
intro.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
unfold transpose in |- *.
intros M N.
unfold reduce in |- *.
intro.
elim H.
split.
generalize H1.
case M.
try tauto.
case N.
try tauto.
fold (transpose h) in |- *.
intros.
case H2.
intro.

*****
H3 : not (synthesis (transpose h) m1 m)
H2 : or (not (synthesis (transpose h) m1 m))\n (not (synthesis (transpose h) m2 m0))
m,m0,m1,m2 : Msg
H1 : match M with\n| MNam _ => True\n| MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n| MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n| Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\nend
H0 : h N M
H : and (h N M)\n match M with\n | MNam _ => True\n | MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
or (not (synthesis h m m1)) (not (synthesis h m0 m2))
+++++
left.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
unfold transpose in |- *.
intros M N.
unfold reduce in |- *.
intro.
elim H.
split.
generalize H1.
case M.
try tauto.
case N.
try tauto.
fold (transpose h) in |- *.
intros.
case H2.
intro.
left.

*****
H3 : not (synthesis (transpose h) m1 m)
H2 : or (not (synthesis (transpose h) m1 m))\n (not (synthesis (transpose h) m2 m0))
m,m0,m1,m2 : Msg
H1 : match M with\n| MNam _ => True\n| MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n| MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n| Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\nend
H0 : h N M
H : and (h N M)\n match M with\n | MNam _ => True\n | MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
not (synthesis h m m1)
+++++
red in |- *.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
unfold transpose in |- *.
intros M N.
unfold reduce in |- *.
intro.
elim H.
split.
generalize H1.
case M.
try tauto.
case N.
try tauto.
fold (transpose h) in |- *.
intros.
case H2.
intro.
left.
red in |- *.

*****
H3 : not (synthesis (transpose h) m1 m)
H2 : or (not (synthesis (transpose h) m1 m))\n (not (synthesis (transpose h) m2 m0))
m,m0,m1,m2 : Msg
H1 : match M with\n| MNam _ => True\n| MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n| MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n| Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\nend
H0 : h N M
H : and (h N M)\n match M with\n | MNam _ => True\n | MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
forall _ : synthesis h m m1, False
+++++
intro.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
unfold transpose in |- *.
intros M N.
unfold reduce in |- *.
intro.
elim H.
split.
generalize H1.
case M.
try tauto.
case N.
try tauto.
fold (transpose h) in |- *.
intros.
case H2.
intro.
left.
red in |- *.
intro.

*****
H4 : synthesis h m m1
H3 : not (synthesis (transpose h) m1 m)
H2 : or (not (synthesis (transpose h) m1 m))\n (not (synthesis (transpose h) m2 m0))
m,m0,m1,m2 : Msg
H1 : match M with\n| MNam _ => True\n| MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n| MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n| Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\nend
H0 : h N M
H : and (h N M)\n match M with\n | MNam _ => True\n | MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
False
+++++
apply H3.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
unfold transpose in |- *.
intros M N.
unfold reduce in |- *.
intro.
elim H.
split.
generalize H1.
case M.
try tauto.
case N.
try tauto.
fold (transpose h) in |- *.
intros.
case H2.
intro.
left.
red in |- *.
intro.
apply H3.

*****
H4 : synthesis h m m1
H3 : not (synthesis (transpose h) m1 m)
H2 : or (not (synthesis (transpose h) m1 m))\n (not (synthesis (transpose h) m2 m0))
m,m0,m1,m2 : Msg
H1 : match M with\n| MNam _ => True\n| MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n| MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n| Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\nend
H0 : h N M
H : and (h N M)\n match M with\n | MNam _ => True\n | MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
synthesis (transpose h) m1 m
+++++
generalize (synthesis_transpose_transpose_synthesis h).
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
unfold transpose in |- *.
intros M N.
unfold reduce in |- *.
intro.
elim H.
split.
generalize H1.
case M.
try tauto.
case N.
try tauto.
fold (transpose h) in |- *.
intros.
case H2.
intro.
left.
red in |- *.
intro.
apply H3.
generalize (synthesis_transpose_transpose_synthesis h).

*****
H4 : synthesis h m m1
H3 : not (synthesis (transpose h) m1 m)
H2 : or (not (synthesis (transpose h) m1 m))\n (not (synthesis (transpose h) m2 m0))
m,m0,m1,m2 : Msg
H1 : match M with\n| MNam _ => True\n| MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n| MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n| Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\nend
H0 : h N M
H : and (h N M)\n match M with\n | MNam _ => True\n | MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
forall _ : equal (synthesis (transpose h)) (transpose (synthesis h)), synthesis (transpose h) m1 m
+++++
unfold equal in |- *.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
unfold transpose in |- *.
intros M N.
unfold reduce in |- *.
intro.
elim H.
split.
generalize H1.
case M.
try tauto.
case N.
try tauto.
fold (transpose h) in |- *.
intros.
case H2.
intro.
left.
red in |- *.
intro.
apply H3.
generalize (synthesis_transpose_transpose_synthesis h).
unfold equal in |- *.

*****
H4 : synthesis h m m1
H3 : not (synthesis (transpose h) m1 m)
H2 : or (not (synthesis (transpose h) m1 m))\n (not (synthesis (transpose h) m2 m0))
m,m0,m1,m2 : Msg
H1 : match M with\n| MNam _ => True\n| MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n| MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n| Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\nend
H0 : h N M
H : and (h N M)\n match M with\n | MNam _ => True\n | MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
forall _ : and (inclusion (synthesis (transpose h)) (transpose (synthesis h))) (inclusion (transpose (synthesis h)) (synthesis (transpose h))), synthesis (transpose h) m1 m
+++++
unfold inclusion in |- *.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
unfold transpose in |- *.
intros M N.
unfold reduce in |- *.
intro.
elim H.
split.
generalize H1.
case M.
try tauto.
case N.
try tauto.
fold (transpose h) in |- *.
intros.
case H2.
intro.
left.
red in |- *.
intro.
apply H3.
generalize (synthesis_transpose_transpose_synthesis h).
unfold equal in |- *.
unfold inclusion in |- *.

*****
H4 : synthesis h m m1
H3 : not (synthesis (transpose h) m1 m)
H2 : or (not (synthesis (transpose h) m1 m))\n (not (synthesis (transpose h) m2 m0))
m,m0,m1,m2 : Msg
H1 : match M with\n| MNam _ => True\n| MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n| MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n| Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\nend
H0 : h N M
H : and (h N M)\n match M with\n | MNam _ => True\n | MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
forall _ : and (forall (M N : Msg) (_ : synthesis (transpose h) M N), transpose (synthesis h) M N) (forall (M N : Msg) (_ : transpose (synthesis h) M N), synthesis (transpose h) M N), synthesis (transpose h) m1 m
+++++
intros.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
unfold transpose in |- *.
intros M N.
unfold reduce in |- *.
intro.
elim H.
split.
generalize H1.
case M.
try tauto.
case N.
try tauto.
fold (transpose h) in |- *.
intros.
case H2.
intro.
left.
red in |- *.
intro.
apply H3.
generalize (synthesis_transpose_transpose_synthesis h).
unfold equal in |- *.
unfold inclusion in |- *.
intros.

*****
H5 : and\n (forall (M N : Msg) (_ : synthesis (transpose h) M N),\n transpose (synthesis h) M N)\n (forall (M N : Msg) (_ : transpose (synthesis h) M N),\n synthesis (transpose h) M N)
H4 : synthesis h m m1
H3 : not (synthesis (transpose h) m1 m)
H2 : or (not (synthesis (transpose h) m1 m))\n (not (synthesis (transpose h) m2 m0))
m,m0,m1,m2 : Msg
H1 : match M with\n| MNam _ => True\n| MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n| MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n| Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\nend
H0 : h N M
H : and (h N M)\n match M with\n | MNam _ => True\n | MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
synthesis (transpose h) m1 m
+++++
elim H5.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
unfold transpose in |- *.
intros M N.
unfold reduce in |- *.
intro.
elim H.
split.
generalize H1.
case M.
try tauto.
case N.
try tauto.
fold (transpose h) in |- *.
intros.
case H2.
intro.
left.
red in |- *.
intro.
apply H3.
generalize (synthesis_transpose_transpose_synthesis h).
unfold equal in |- *.
unfold inclusion in |- *.
intros.
elim H5.

*****
H5 : and\n (forall (M N : Msg) (_ : synthesis (transpose h) M N),\n transpose (synthesis h) M N)\n (forall (M N : Msg) (_ : transpose (synthesis h) M N),\n synthesis (transpose h) M N)
H4 : synthesis h m m1
H3 : not (synthesis (transpose h) m1 m)
H2 : or (not (synthesis (transpose h) m1 m))\n (not (synthesis (transpose h) m2 m0))
m,m0,m1,m2 : Msg
H1 : match M with\n| MNam _ => True\n| MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n| MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n| Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\nend
H0 : h N M
H : and (h N M)\n match M with\n | MNam _ => True\n | MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
forall (_ : forall (M N : Msg) (_ : synthesis (transpose h) M N), transpose (synthesis h) M N) (_ : forall (M N : Msg) (_ : transpose (synthesis h) M N), synthesis (transpose h) M N), synthesis (transpose h) m1 m
+++++
intros.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
unfold transpose in |- *.
intros M N.
unfold reduce in |- *.
intro.
elim H.
split.
generalize H1.
case M.
try tauto.
case N.
try tauto.
fold (transpose h) in |- *.
intros.
case H2.
intro.
left.
red in |- *.
intro.
apply H3.
generalize (synthesis_transpose_transpose_synthesis h).
unfold equal in |- *.
unfold inclusion in |- *.
intros.
elim H5.
intros.

*****
H7 : forall (M N : Msg) (_ : transpose (synthesis h) M N),\nsynthesis (transpose h) M N
H6 : forall (M N : Msg) (_ : synthesis (transpose h) M N),\ntranspose (synthesis h) M N
H5 : and\n (forall (M N : Msg) (_ : synthesis (transpose h) M N),\n transpose (synthesis h) M N)\n (forall (M N : Msg) (_ : transpose (synthesis h) M N),\n synthesis (transpose h) M N)
H4 : synthesis h m m1
H3 : not (synthesis (transpose h) m1 m)
H2 : or (not (synthesis (transpose h) m1 m))\n (not (synthesis (transpose h) m2 m0))
m,m0,m1,m2 : Msg
H1 : match M with\n| MNam _ => True\n| MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n| MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n| Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\nend
H0 : h N M
H : and (h N M)\n match M with\n | MNam _ => True\n | MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
synthesis (transpose h) m1 m
+++++
apply H7.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
unfold transpose in |- *.
intros M N.
unfold reduce in |- *.
intro.
elim H.
split.
generalize H1.
case M.
try tauto.
case N.
try tauto.
fold (transpose h) in |- *.
intros.
case H2.
intro.
left.
red in |- *.
intro.
apply H3.
generalize (synthesis_transpose_transpose_synthesis h).
unfold equal in |- *.
unfold inclusion in |- *.
intros.
elim H5.
intros.
apply H7.

*****
H7 : forall (M N : Msg) (_ : transpose (synthesis h) M N),\nsynthesis (transpose h) M N
H6 : forall (M N : Msg) (_ : synthesis (transpose h) M N),\ntranspose (synthesis h) M N
H5 : and\n (forall (M N : Msg) (_ : synthesis (transpose h) M N),\n transpose (synthesis h) M N)\n (forall (M N : Msg) (_ : transpose (synthesis h) M N),\n synthesis (transpose h) M N)
H4 : synthesis h m m1
H3 : not (synthesis (transpose h) m1 m)
H2 : or (not (synthesis (transpose h) m1 m))\n (not (synthesis (transpose h) m2 m0))
m,m0,m1,m2 : Msg
H1 : match M with\n| MNam _ => True\n| MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n| MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n| Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\nend
H0 : h N M
H : and (h N M)\n match M with\n | MNam _ => True\n | MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
transpose (synthesis h) m1 m
+++++
unfold transpose in |- *.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
unfold transpose in |- *.
intros M N.
unfold reduce in |- *.
intro.
elim H.
split.
generalize H1.
case M.
try tauto.
case N.
try tauto.
fold (transpose h) in |- *.
intros.
case H2.
intro.
left.
red in |- *.
intro.
apply H3.
generalize (synthesis_transpose_transpose_synthesis h).
unfold equal in |- *.
unfold inclusion in |- *.
intros.
elim H5.
intros.
apply H7.
unfold transpose in |- *.

*****
H7 : forall (M N : Msg) (_ : transpose (synthesis h) M N),\nsynthesis (transpose h) M N
H6 : forall (M N : Msg) (_ : synthesis (transpose h) M N),\ntranspose (synthesis h) M N
H5 : and\n (forall (M N : Msg) (_ : synthesis (transpose h) M N),\n transpose (synthesis h) M N)\n (forall (M N : Msg) (_ : transpose (synthesis h) M N),\n synthesis (transpose h) M N)
H4 : synthesis h m m1
H3 : not (synthesis (transpose h) m1 m)
H2 : or (not (synthesis (transpose h) m1 m))\n (not (synthesis (transpose h) m2 m0))
m,m0,m1,m2 : Msg
H1 : match M with\n| MNam _ => True\n| MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n| MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n| Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\nend
H0 : h N M
H : and (h N M)\n match M with\n | MNam _ => True\n | MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
synthesis h m m1
+++++
trivial.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
unfold transpose in |- *.
intros M N.
unfold reduce in |- *.
intro.
elim H.
split.
generalize H1.
case M.
try tauto.
case N.
try tauto.
fold (transpose h) in |- *.
intros.
case H2.

*****
H2 : or (not (synthesis (transpose h) m1 m))\n (not (synthesis (transpose h) m2 m0))
m,m0,m1,m2 : Msg
H1 : match M with\n| MNam _ => True\n| MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n| MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n| Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\nend
H0 : h N M
H : and (h N M)\n match M with\n | MNam _ => True\n | MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
forall _ : not (synthesis (transpose h) m2 m0), or (not (synthesis h m m1)) (not (synthesis h m0 m2))
+++++
right.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
unfold transpose in |- *.
intros M N.
unfold reduce in |- *.
intro.
elim H.
split.
generalize H1.
case M.
try tauto.
case N.
try tauto.
fold (transpose h) in |- *.
intros.
case H2.
right.

*****
H3 : not (synthesis (transpose h) m2 m0)
H2 : or (not (synthesis (transpose h) m1 m))\n (not (synthesis (transpose h) m2 m0))
m,m0,m1,m2 : Msg
H1 : match M with\n| MNam _ => True\n| MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n| MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n| Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\nend
H0 : h N M
H : and (h N M)\n match M with\n | MNam _ => True\n | MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
not (synthesis h m0 m2)
+++++
red in |- *.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
unfold transpose in |- *.
intros M N.
unfold reduce in |- *.
intro.
elim H.
split.
generalize H1.
case M.
try tauto.
case N.
try tauto.
fold (transpose h) in |- *.
intros.
case H2.
right.
red in |- *.

*****
H3 : not (synthesis (transpose h) m2 m0)
H2 : or (not (synthesis (transpose h) m1 m))\n (not (synthesis (transpose h) m2 m0))
m,m0,m1,m2 : Msg
H1 : match M with\n| MNam _ => True\n| MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n| MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n| Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\nend
H0 : h N M
H : and (h N M)\n match M with\n | MNam _ => True\n | MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
forall _ : synthesis h m0 m2, False
+++++
intro.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
unfold transpose in |- *.
intros M N.
unfold reduce in |- *.
intro.
elim H.
split.
generalize H1.
case M.
try tauto.
case N.
try tauto.
fold (transpose h) in |- *.
intros.
case H2.
right.
red in |- *.
intro.

*****
H4 : synthesis h m0 m2
H3 : not (synthesis (transpose h) m2 m0)
H2 : or (not (synthesis (transpose h) m1 m))\n (not (synthesis (transpose h) m2 m0))
m,m0,m1,m2 : Msg
H1 : match M with\n| MNam _ => True\n| MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n| MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n| Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\nend
H0 : h N M
H : and (h N M)\n match M with\n | MNam _ => True\n | MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
False
+++++
apply H3.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
unfold transpose in |- *.
intros M N.
unfold reduce in |- *.
intro.
elim H.
split.
generalize H1.
case M.
try tauto.
case N.
try tauto.
fold (transpose h) in |- *.
intros.
case H2.
right.
red in |- *.
intro.
apply H3.

*****
H4 : synthesis h m0 m2
H3 : not (synthesis (transpose h) m2 m0)
H2 : or (not (synthesis (transpose h) m1 m))\n (not (synthesis (transpose h) m2 m0))
m,m0,m1,m2 : Msg
H1 : match M with\n| MNam _ => True\n| MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n| MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n| Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\nend
H0 : h N M
H : and (h N M)\n match M with\n | MNam _ => True\n | MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
synthesis (transpose h) m2 m0
+++++
generalize (synthesis_transpose_transpose_synthesis h).
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
unfold transpose in |- *.
intros M N.
unfold reduce in |- *.
intro.
elim H.
split.
generalize H1.
case M.
try tauto.
case N.
try tauto.
fold (transpose h) in |- *.
intros.
case H2.
right.
red in |- *.
intro.
apply H3.
generalize (synthesis_transpose_transpose_synthesis h).

*****
H4 : synthesis h m0 m2
H3 : not (synthesis (transpose h) m2 m0)
H2 : or (not (synthesis (transpose h) m1 m))\n (not (synthesis (transpose h) m2 m0))
m,m0,m1,m2 : Msg
H1 : match M with\n| MNam _ => True\n| MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n| MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n| Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\nend
H0 : h N M
H : and (h N M)\n match M with\n | MNam _ => True\n | MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
forall _ : equal (synthesis (transpose h)) (transpose (synthesis h)), synthesis (transpose h) m2 m0
+++++
unfold equal in |- *.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
unfold transpose in |- *.
intros M N.
unfold reduce in |- *.
intro.
elim H.
split.
generalize H1.
case M.
try tauto.
case N.
try tauto.
fold (transpose h) in |- *.
intros.
case H2.
right.
red in |- *.
intro.
apply H3.
generalize (synthesis_transpose_transpose_synthesis h).
unfold equal in |- *.

*****
H4 : synthesis h m0 m2
H3 : not (synthesis (transpose h) m2 m0)
H2 : or (not (synthesis (transpose h) m1 m))\n (not (synthesis (transpose h) m2 m0))
m,m0,m1,m2 : Msg
H1 : match M with\n| MNam _ => True\n| MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n| MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n| Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\nend
H0 : h N M
H : and (h N M)\n match M with\n | MNam _ => True\n | MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
forall _ : and (inclusion (synthesis (transpose h)) (transpose (synthesis h))) (inclusion (transpose (synthesis h)) (synthesis (transpose h))), synthesis (transpose h) m2 m0
+++++
unfold inclusion in |- *.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
unfold transpose in |- *.
intros M N.
unfold reduce in |- *.
intro.
elim H.
split.
generalize H1.
case M.
try tauto.
case N.
try tauto.
fold (transpose h) in |- *.
intros.
case H2.
right.
red in |- *.
intro.
apply H3.
generalize (synthesis_transpose_transpose_synthesis h).
unfold equal in |- *.
unfold inclusion in |- *.

*****
H4 : synthesis h m0 m2
H3 : not (synthesis (transpose h) m2 m0)
H2 : or (not (synthesis (transpose h) m1 m))\n (not (synthesis (transpose h) m2 m0))
m,m0,m1,m2 : Msg
H1 : match M with\n| MNam _ => True\n| MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n| MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n| Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\nend
H0 : h N M
H : and (h N M)\n match M with\n | MNam _ => True\n | MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
forall _ : and (forall (M N : Msg) (_ : synthesis (transpose h) M N), transpose (synthesis h) M N) (forall (M N : Msg) (_ : transpose (synthesis h) M N), synthesis (transpose h) M N), synthesis (transpose h) m2 m0
+++++
intro.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
unfold transpose in |- *.
intros M N.
unfold reduce in |- *.
intro.
elim H.
split.
generalize H1.
case M.
try tauto.
case N.
try tauto.
fold (transpose h) in |- *.
intros.
case H2.
right.
red in |- *.
intro.
apply H3.
generalize (synthesis_transpose_transpose_synthesis h).
unfold equal in |- *.
unfold inclusion in |- *.
intro.

*****
H5 : and\n (forall (M N : Msg) (_ : synthesis (transpose h) M N),\n transpose (synthesis h) M N)\n (forall (M N : Msg) (_ : transpose (synthesis h) M N),\n synthesis (transpose h) M N)
H4 : synthesis h m0 m2
H3 : not (synthesis (transpose h) m2 m0)
H2 : or (not (synthesis (transpose h) m1 m))\n (not (synthesis (transpose h) m2 m0))
m,m0,m1,m2 : Msg
H1 : match M with\n| MNam _ => True\n| MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n| MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n| Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\nend
H0 : h N M
H : and (h N M)\n match M with\n | MNam _ => True\n | MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
synthesis (transpose h) m2 m0
+++++
elim H5.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
unfold transpose in |- *.
intros M N.
unfold reduce in |- *.
intro.
elim H.
split.
generalize H1.
case M.
try tauto.
case N.
try tauto.
fold (transpose h) in |- *.
intros.
case H2.
right.
red in |- *.
intro.
apply H3.
generalize (synthesis_transpose_transpose_synthesis h).
unfold equal in |- *.
unfold inclusion in |- *.
intro.
elim H5.

*****
H5 : and\n (forall (M N : Msg) (_ : synthesis (transpose h) M N),\n transpose (synthesis h) M N)\n (forall (M N : Msg) (_ : transpose (synthesis h) M N),\n synthesis (transpose h) M N)
H4 : synthesis h m0 m2
H3 : not (synthesis (transpose h) m2 m0)
H2 : or (not (synthesis (transpose h) m1 m))\n (not (synthesis (transpose h) m2 m0))
m,m0,m1,m2 : Msg
H1 : match M with\n| MNam _ => True\n| MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n| MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n| Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\nend
H0 : h N M
H : and (h N M)\n match M with\n | MNam _ => True\n | MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
forall (_ : forall (M N : Msg) (_ : synthesis (transpose h) M N), transpose (synthesis h) M N) (_ : forall (M N : Msg) (_ : transpose (synthesis h) M N), synthesis (transpose h) M N), synthesis (transpose h) m2 m0
+++++
intros.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
unfold transpose in |- *.
intros M N.
unfold reduce in |- *.
intro.
elim H.
split.
generalize H1.
case M.
try tauto.
case N.
try tauto.
fold (transpose h) in |- *.
intros.
case H2.
right.
red in |- *.
intro.
apply H3.
generalize (synthesis_transpose_transpose_synthesis h).
unfold equal in |- *.
unfold inclusion in |- *.
intro.
elim H5.
intros.

*****
H7 : forall (M N : Msg) (_ : transpose (synthesis h) M N),\nsynthesis (transpose h) M N
H6 : forall (M N : Msg) (_ : synthesis (transpose h) M N),\ntranspose (synthesis h) M N
H5 : and\n (forall (M N : Msg) (_ : synthesis (transpose h) M N),\n transpose (synthesis h) M N)\n (forall (M N : Msg) (_ : transpose (synthesis h) M N),\n synthesis (transpose h) M N)
H4 : synthesis h m0 m2
H3 : not (synthesis (transpose h) m2 m0)
H2 : or (not (synthesis (transpose h) m1 m))\n (not (synthesis (transpose h) m2 m0))
m,m0,m1,m2 : Msg
H1 : match M with\n| MNam _ => True\n| MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n| MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n| Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\nend
H0 : h N M
H : and (h N M)\n match M with\n | MNam _ => True\n | MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
synthesis (transpose h) m2 m0
+++++
apply H7.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
unfold transpose in |- *.
intros M N.
unfold reduce in |- *.
intro.
elim H.
split.
generalize H1.
case M.
try tauto.
case N.
try tauto.
fold (transpose h) in |- *.
intros.
case H2.
right.
red in |- *.
intro.
apply H3.
generalize (synthesis_transpose_transpose_synthesis h).
unfold equal in |- *.
unfold inclusion in |- *.
intro.
elim H5.
intros.
apply H7.

*****
H7 : forall (M N : Msg) (_ : transpose (synthesis h) M N),\nsynthesis (transpose h) M N
H6 : forall (M N : Msg) (_ : synthesis (transpose h) M N),\ntranspose (synthesis h) M N
H5 : and\n (forall (M N : Msg) (_ : synthesis (transpose h) M N),\n transpose (synthesis h) M N)\n (forall (M N : Msg) (_ : transpose (synthesis h) M N),\n synthesis (transpose h) M N)
H4 : synthesis h m0 m2
H3 : not (synthesis (transpose h) m2 m0)
H2 : or (not (synthesis (transpose h) m1 m))\n (not (synthesis (transpose h) m2 m0))
m,m0,m1,m2 : Msg
H1 : match M with\n| MNam _ => True\n| MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n| MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n| Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\nend
H0 : h N M
H : and (h N M)\n match M with\n | MNam _ => True\n | MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
transpose (synthesis h) m2 m0
+++++
unfold transpose in |- *.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
unfold transpose in |- *.
intros M N.
unfold reduce in |- *.
intro.
elim H.
split.
generalize H1.
case M.
try tauto.
case N.
try tauto.
fold (transpose h) in |- *.
intros.
case H2.
right.
red in |- *.
intro.
apply H3.
generalize (synthesis_transpose_transpose_synthesis h).
unfold equal in |- *.
unfold inclusion in |- *.
intro.
elim H5.
intros.
apply H7.
unfold transpose in |- *.

*****
H7 : forall (M N : Msg) (_ : transpose (synthesis h) M N),\nsynthesis (transpose h) M N
H6 : forall (M N : Msg) (_ : synthesis (transpose h) M N),\ntranspose (synthesis h) M N
H5 : and\n (forall (M N : Msg) (_ : synthesis (transpose h) M N),\n transpose (synthesis h) M N)\n (forall (M N : Msg) (_ : transpose (synthesis h) M N),\n synthesis (transpose h) M N)
H4 : synthesis h m0 m2
H3 : not (synthesis (transpose h) m2 m0)
H2 : or (not (synthesis (transpose h) m1 m))\n (not (synthesis (transpose h) m2 m0))
m,m0,m1,m2 : Msg
H1 : match M with\n| MNam _ => True\n| MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n| MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n| Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\nend
H0 : h N M
H : and (h N M)\n match M with\n | MNam _ => True\n | MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
synthesis h m0 m2
+++++
trivial.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
unfold transpose in |- *.
intros M N.
unfold reduce in |- *.
intro.
elim H.
split.
generalize H1.
case M.
try tauto.
case N.

*****
H1 : match M with\n| MNam _ => True\n| MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n| MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n| Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\nend
H0 : h N M
H : and (h N M)\n match M with\n | MNam _ => True\n | MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
forall (_ : Msg) (_ : Msg) (_ : Msg) (_ : Msg) (_ : True), True
+++++
try tauto.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
unfold transpose in |- *.
intros M N.
unfold reduce in |- *.
intro.
elim H.
split.
generalize H1.
case M.
try tauto.
case N.

*****
H1 : match M with\n| MNam _ => True\n| MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n| MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n| Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\nend
H0 : h N M
H : and (h N M)\n match M with\n | MNam _ => True\n | MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
forall (_ : op) (_ : Msg) (_ : Msg) (_ : Msg) (_ : True), True
+++++
try tauto.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
unfold transpose in |- *.
intros M N.
unfold reduce in |- *.
intro.
elim H.
split.
generalize H1.
case M.

*****
H1 : match M with\n| MNam _ => True\n| MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n| MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n| Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\nend
H0 : h N M
H : and (h N M)\n match M with\n | MNam _ => True\n | MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
forall (m m0 : Msg) (_ : match N with | MPair N1 N2 => or (not (synthesis (fun M N : Msg => h N M) m N1)) (not (synthesis (fun M N : Msg => h N M) m0 N2)) | _ => True end), match N with | MPair M1 M2 => or (not (synthesis h M1 m)) (not (synthesis h M2 m0)) | _ => True end
+++++
try tauto.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
unfold transpose in |- *.
intros M N.
unfold reduce in |- *.
intro.
elim H.
split.
generalize H1.
case M.
try tauto.

*****
H1 : match M with\n| MNam _ => True\n| MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n| MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n| Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\nend
H0 : h N M
H : and (h N M)\n match M with\n | MNam _ => True\n | MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
forall (m m0 : Msg) (_ : match N with | MPair N1 N2 => or (not (synthesis (fun M N : Msg => h N M) m N1)) (not (synthesis (fun M N : Msg => h N M) m0 N2)) | _ => True end), match N with | MPair M1 M2 => or (not (synthesis h M1 m)) (not (synthesis h M2 m0)) | _ => True end
+++++
case N.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
unfold transpose in |- *.
intros M N.
unfold reduce in |- *.
intro.
elim H.
split.
generalize H1.
case M.
try tauto.
case N.

*****
H1 : match M with\n| MNam _ => True\n| MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n| MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n| Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\nend
H0 : h N M
H : and (h N M)\n match M with\n | MNam _ => True\n | MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
forall (_ : Nam) (_ : Msg) (_ : Msg) (_ : True), True
+++++
try tauto.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
unfold transpose in |- *.
intros M N.
unfold reduce in |- *.
intro.
elim H.
split.
generalize H1.
case M.
try tauto.
case N.

*****
H1 : match M with\n| MNam _ => True\n| MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n| MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n| Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\nend
H0 : h N M
H : and (h N M)\n match M with\n | MNam _ => True\n | MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
forall (_ : Msg) (_ : Msg) (_ : Msg) (_ : Msg) (_ : True), True
+++++
try tauto.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
unfold transpose in |- *.
intros M N.
unfold reduce in |- *.
intro.
elim H.
split.
generalize H1.
case M.
try tauto.
case N.

*****
H1 : match M with\n| MNam _ => True\n| MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n| MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n| Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\nend
H0 : h N M
H : and (h N M)\n match M with\n | MNam _ => True\n | MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
forall (m m0 m1 m2 : Msg) (_ : or (not (synthesis (fun M N : Msg => h N M) m1 m)) (not (synthesis (fun M N : Msg => h N M) m2 m0))), or (not (synthesis h m m1)) (not (synthesis h m0 m2))
+++++
try tauto.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
unfold transpose in |- *.
intros M N.
unfold reduce in |- *.
intro.
elim H.
split.
generalize H1.
case M.
try tauto.
case N.
try tauto.

*****
H1 : match M with\n| MNam _ => True\n| MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n| MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n| Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\nend
H0 : h N M
H : and (h N M)\n match M with\n | MNam _ => True\n | MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
forall (m m0 m1 m2 : Msg) (_ : or (not (synthesis (fun M N : Msg => h N M) m1 m)) (not (synthesis (fun M N : Msg => h N M) m2 m0))), or (not (synthesis h m m1)) (not (synthesis h m0 m2))
+++++
intros.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
unfold transpose in |- *.
intros M N.
unfold reduce in |- *.
intro.
elim H.
split.
generalize H1.
case M.
try tauto.
case N.
try tauto.
intros.

*****
H2 : or (not (synthesis (fun M N : Msg => h N M) m1 m))\n (not (synthesis (fun M N : Msg => h N M) m2 m0))
m,m0,m1,m2 : Msg
H1 : match M with\n| MNam _ => True\n| MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n| MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n| Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\nend
H0 : h N M
H : and (h N M)\n match M with\n | MNam _ => True\n | MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
or (not (synthesis h m m1)) (not (synthesis h m0 m2))
+++++
case H2.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
unfold transpose in |- *.
intros M N.
unfold reduce in |- *.
intro.
elim H.
split.
generalize H1.
case M.
try tauto.
case N.
try tauto.
intros.
case H2.

*****
H2 : or (not (synthesis (fun M N : Msg => h N M) m1 m))\n (not (synthesis (fun M N : Msg => h N M) m2 m0))
m,m0,m1,m2 : Msg
H1 : match M with\n| MNam _ => True\n| MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n| MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n| Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\nend
H0 : h N M
H : and (h N M)\n match M with\n | MNam _ => True\n | MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
forall _ : not (synthesis (fun M N : Msg => h N M) m1 m), or (not (synthesis h m m1)) (not (synthesis h m0 m2))
+++++
left.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
unfold transpose in |- *.
intros M N.
unfold reduce in |- *.
intro.
elim H.
split.
generalize H1.
case M.
try tauto.
case N.
try tauto.
intros.
case H2.
left.

*****
H3 : not (synthesis (fun M N : Msg => h N M) m1 m)
H2 : or (not (synthesis (fun M N : Msg => h N M) m1 m))\n (not (synthesis (fun M N : Msg => h N M) m2 m0))
m,m0,m1,m2 : Msg
H1 : match M with\n| MNam _ => True\n| MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n| MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n| Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\nend
H0 : h N M
H : and (h N M)\n match M with\n | MNam _ => True\n | MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
not (synthesis h m m1)
+++++
red in |- *.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
unfold transpose in |- *.
intros M N.
unfold reduce in |- *.
intro.
elim H.
split.
generalize H1.
case M.
try tauto.
case N.
try tauto.
intros.
case H2.
left.
red in |- *.

*****
H3 : not (synthesis (fun M N : Msg => h N M) m1 m)
H2 : or (not (synthesis (fun M N : Msg => h N M) m1 m))\n (not (synthesis (fun M N : Msg => h N M) m2 m0))
m,m0,m1,m2 : Msg
H1 : match M with\n| MNam _ => True\n| MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n| MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n| Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\nend
H0 : h N M
H : and (h N M)\n match M with\n | MNam _ => True\n | MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
forall _ : synthesis h m m1, False
+++++
intro.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
unfold transpose in |- *.
intros M N.
unfold reduce in |- *.
intro.
elim H.
split.
generalize H1.
case M.
try tauto.
case N.
try tauto.
intros.
case H2.
left.
red in |- *.
intro.

*****
H4 : synthesis h m m1
H3 : not (synthesis (fun M N : Msg => h N M) m1 m)
H2 : or (not (synthesis (fun M N : Msg => h N M) m1 m))\n (not (synthesis (fun M N : Msg => h N M) m2 m0))
m,m0,m1,m2 : Msg
H1 : match M with\n| MNam _ => True\n| MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n| MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n| Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\nend
H0 : h N M
H : and (h N M)\n match M with\n | MNam _ => True\n | MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
False
+++++
generalize (synthesis_transpose_transpose_synthesis h).
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
unfold transpose in |- *.
intros M N.
unfold reduce in |- *.
intro.
elim H.
split.
generalize H1.
case M.
try tauto.
case N.
try tauto.
intros.
case H2.
left.
red in |- *.
intro.
generalize (synthesis_transpose_transpose_synthesis h).

*****
H4 : synthesis h m m1
H3 : not (synthesis (fun M N : Msg => h N M) m1 m)
H2 : or (not (synthesis (fun M N : Msg => h N M) m1 m))\n (not (synthesis (fun M N : Msg => h N M) m2 m0))
m,m0,m1,m2 : Msg
H1 : match M with\n| MNam _ => True\n| MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n| MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n| Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\nend
H0 : h N M
H : and (h N M)\n match M with\n | MNam _ => True\n | MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
forall _ : equal (synthesis (transpose h)) (transpose (synthesis h)), False
+++++
unfold equal in |- *.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
unfold transpose in |- *.
intros M N.
unfold reduce in |- *.
intro.
elim H.
split.
generalize H1.
case M.
try tauto.
case N.
try tauto.
intros.
case H2.
left.
red in |- *.
intro.
generalize (synthesis_transpose_transpose_synthesis h).
unfold equal in |- *.

*****
H4 : synthesis h m m1
H3 : not (synthesis (fun M N : Msg => h N M) m1 m)
H2 : or (not (synthesis (fun M N : Msg => h N M) m1 m))\n (not (synthesis (fun M N : Msg => h N M) m2 m0))
m,m0,m1,m2 : Msg
H1 : match M with\n| MNam _ => True\n| MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n| MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n| Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\nend
H0 : h N M
H : and (h N M)\n match M with\n | MNam _ => True\n | MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
forall _ : and (inclusion (synthesis (transpose h)) (transpose (synthesis h))) (inclusion (transpose (synthesis h)) (synthesis (transpose h))), False
+++++
unfold inclusion in |- *.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
unfold transpose in |- *.
intros M N.
unfold reduce in |- *.
intro.
elim H.
split.
generalize H1.
case M.
try tauto.
case N.
try tauto.
intros.
case H2.
left.
red in |- *.
intro.
generalize (synthesis_transpose_transpose_synthesis h).
unfold equal in |- *.
unfold inclusion in |- *.

*****
H4 : synthesis h m m1
H3 : not (synthesis (fun M N : Msg => h N M) m1 m)
H2 : or (not (synthesis (fun M N : Msg => h N M) m1 m))\n (not (synthesis (fun M N : Msg => h N M) m2 m0))
m,m0,m1,m2 : Msg
H1 : match M with\n| MNam _ => True\n| MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n| MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n| Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\nend
H0 : h N M
H : and (h N M)\n match M with\n | MNam _ => True\n | MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
forall _ : and (forall (M N : Msg) (_ : synthesis (transpose h) M N), transpose (synthesis h) M N) (forall (M N : Msg) (_ : transpose (synthesis h) M N), synthesis (transpose h) M N), False
+++++
intro.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
unfold transpose in |- *.
intros M N.
unfold reduce in |- *.
intro.
elim H.
split.
generalize H1.
case M.
try tauto.
case N.
try tauto.
intros.
case H2.
left.
red in |- *.
intro.
generalize (synthesis_transpose_transpose_synthesis h).
unfold equal in |- *.
unfold inclusion in |- *.
intro.

*****
H5 : and\n (forall (M N : Msg) (_ : synthesis (transpose h) M N),\n transpose (synthesis h) M N)\n (forall (M N : Msg) (_ : transpose (synthesis h) M N),\n synthesis (transpose h) M N)
H4 : synthesis h m m1
H3 : not (synthesis (fun M N : Msg => h N M) m1 m)
H2 : or (not (synthesis (fun M N : Msg => h N M) m1 m))\n (not (synthesis (fun M N : Msg => h N M) m2 m0))
m,m0,m1,m2 : Msg
H1 : match M with\n| MNam _ => True\n| MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n| MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n| Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\nend
H0 : h N M
H : and (h N M)\n match M with\n | MNam _ => True\n | MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
False
+++++
elim H5.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
unfold transpose in |- *.
intros M N.
unfold reduce in |- *.
intro.
elim H.
split.
generalize H1.
case M.
try tauto.
case N.
try tauto.
intros.
case H2.
left.
red in |- *.
intro.
generalize (synthesis_transpose_transpose_synthesis h).
unfold equal in |- *.
unfold inclusion in |- *.
intro.
elim H5.

*****
H5 : and\n (forall (M N : Msg) (_ : synthesis (transpose h) M N),\n transpose (synthesis h) M N)\n (forall (M N : Msg) (_ : transpose (synthesis h) M N),\n synthesis (transpose h) M N)
H4 : synthesis h m m1
H3 : not (synthesis (fun M N : Msg => h N M) m1 m)
H2 : or (not (synthesis (fun M N : Msg => h N M) m1 m))\n (not (synthesis (fun M N : Msg => h N M) m2 m0))
m,m0,m1,m2 : Msg
H1 : match M with\n| MNam _ => True\n| MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n| MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n| Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\nend
H0 : h N M
H : and (h N M)\n match M with\n | MNam _ => True\n | MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
forall (_ : forall (M N : Msg) (_ : synthesis (transpose h) M N), transpose (synthesis h) M N) (_ : forall (M N : Msg) (_ : transpose (synthesis h) M N), synthesis (transpose h) M N), False
+++++
intros.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
unfold transpose in |- *.
intros M N.
unfold reduce in |- *.
intro.
elim H.
split.
generalize H1.
case M.
try tauto.
case N.
try tauto.
intros.
case H2.
left.
red in |- *.
intro.
generalize (synthesis_transpose_transpose_synthesis h).
unfold equal in |- *.
unfold inclusion in |- *.
intro.
elim H5.
intros.

*****
H7 : forall (M N : Msg) (_ : transpose (synthesis h) M N),\nsynthesis (transpose h) M N
H6 : forall (M N : Msg) (_ : synthesis (transpose h) M N),\ntranspose (synthesis h) M N
H5 : and\n (forall (M N : Msg) (_ : synthesis (transpose h) M N),\n transpose (synthesis h) M N)\n (forall (M N : Msg) (_ : transpose (synthesis h) M N),\n synthesis (transpose h) M N)
H4 : synthesis h m m1
H3 : not (synthesis (fun M N : Msg => h N M) m1 m)
H2 : or (not (synthesis (fun M N : Msg => h N M) m1 m))\n (not (synthesis (fun M N : Msg => h N M) m2 m0))
m,m0,m1,m2 : Msg
H1 : match M with\n| MNam _ => True\n| MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n| MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n| Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\nend
H0 : h N M
H : and (h N M)\n match M with\n | MNam _ => True\n | MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
False
+++++
apply H3.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
unfold transpose in |- *.
intros M N.
unfold reduce in |- *.
intro.
elim H.
split.
generalize H1.
case M.
try tauto.
case N.
try tauto.
intros.
case H2.
left.
red in |- *.
intro.
generalize (synthesis_transpose_transpose_synthesis h).
unfold equal in |- *.
unfold inclusion in |- *.
intro.
elim H5.
intros.
apply H3.

*****
H7 : forall (M N : Msg) (_ : transpose (synthesis h) M N),\nsynthesis (transpose h) M N
H6 : forall (M N : Msg) (_ : synthesis (transpose h) M N),\ntranspose (synthesis h) M N
H5 : and\n (forall (M N : Msg) (_ : synthesis (transpose h) M N),\n transpose (synthesis h) M N)\n (forall (M N : Msg) (_ : transpose (synthesis h) M N),\n synthesis (transpose h) M N)
H4 : synthesis h m m1
H3 : not (synthesis (fun M N : Msg => h N M) m1 m)
H2 : or (not (synthesis (fun M N : Msg => h N M) m1 m))\n (not (synthesis (fun M N : Msg => h N M) m2 m0))
m,m0,m1,m2 : Msg
H1 : match M with\n| MNam _ => True\n| MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n| MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n| Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\nend
H0 : h N M
H : and (h N M)\n match M with\n | MNam _ => True\n | MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
synthesis (fun M N : Msg => h N M) m1 m
+++++
apply H7.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
unfold transpose in |- *.
intros M N.
unfold reduce in |- *.
intro.
elim H.
split.
generalize H1.
case M.
try tauto.
case N.
try tauto.
intros.
case H2.
left.
red in |- *.
intro.
generalize (synthesis_transpose_transpose_synthesis h).
unfold equal in |- *.
unfold inclusion in |- *.
intro.
elim H5.
intros.
apply H3.
apply H7.

*****
H7 : forall (M N : Msg) (_ : transpose (synthesis h) M N),\nsynthesis (transpose h) M N
H6 : forall (M N : Msg) (_ : synthesis (transpose h) M N),\ntranspose (synthesis h) M N
H5 : and\n (forall (M N : Msg) (_ : synthesis (transpose h) M N),\n transpose (synthesis h) M N)\n (forall (M N : Msg) (_ : transpose (synthesis h) M N),\n synthesis (transpose h) M N)
H4 : synthesis h m m1
H3 : not (synthesis (fun M N : Msg => h N M) m1 m)
H2 : or (not (synthesis (fun M N : Msg => h N M) m1 m))\n (not (synthesis (fun M N : Msg => h N M) m2 m0))
m,m0,m1,m2 : Msg
H1 : match M with\n| MNam _ => True\n| MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n| MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n| Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\nend
H0 : h N M
H : and (h N M)\n match M with\n | MNam _ => True\n | MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
transpose (synthesis h) m1 m
+++++
unfold transpose in |- *.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
unfold transpose in |- *.
intros M N.
unfold reduce in |- *.
intro.
elim H.
split.
generalize H1.
case M.
try tauto.
case N.
try tauto.
intros.
case H2.
left.
red in |- *.
intro.
generalize (synthesis_transpose_transpose_synthesis h).
unfold equal in |- *.
unfold inclusion in |- *.
intro.
elim H5.
intros.
apply H3.
apply H7.
unfold transpose in |- *.

*****
H7 : forall (M N : Msg) (_ : transpose (synthesis h) M N),\nsynthesis (transpose h) M N
H6 : forall (M N : Msg) (_ : synthesis (transpose h) M N),\ntranspose (synthesis h) M N
H5 : and\n (forall (M N : Msg) (_ : synthesis (transpose h) M N),\n transpose (synthesis h) M N)\n (forall (M N : Msg) (_ : transpose (synthesis h) M N),\n synthesis (transpose h) M N)
H4 : synthesis h m m1
H3 : not (synthesis (fun M N : Msg => h N M) m1 m)
H2 : or (not (synthesis (fun M N : Msg => h N M) m1 m))\n (not (synthesis (fun M N : Msg => h N M) m2 m0))
m,m0,m1,m2 : Msg
H1 : match M with\n| MNam _ => True\n| MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n| MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n| Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\nend
H0 : h N M
H : and (h N M)\n match M with\n | MNam _ => True\n | MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
synthesis h m m1
+++++
trivial.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
unfold transpose in |- *.
intros M N.
unfold reduce in |- *.
intro.
elim H.
split.
generalize H1.
case M.
try tauto.
case N.
try tauto.
intros.
case H2.

*****
H2 : or (not (synthesis (fun M N : Msg => h N M) m1 m))\n (not (synthesis (fun M N : Msg => h N M) m2 m0))
m,m0,m1,m2 : Msg
H1 : match M with\n| MNam _ => True\n| MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n| MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n| Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\nend
H0 : h N M
H : and (h N M)\n match M with\n | MNam _ => True\n | MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
forall _ : not (synthesis (fun M N : Msg => h N M) m2 m0), or (not (synthesis h m m1)) (not (synthesis h m0 m2))
+++++
intro.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
unfold transpose in |- *.
intros M N.
unfold reduce in |- *.
intro.
elim H.
split.
generalize H1.
case M.
try tauto.
case N.
try tauto.
intros.
case H2.
intro.

*****
H3 : not (synthesis (fun M N : Msg => h N M) m2 m0)
H2 : or (not (synthesis (fun M N : Msg => h N M) m1 m))\n (not (synthesis (fun M N : Msg => h N M) m2 m0))
m,m0,m1,m2 : Msg
H1 : match M with\n| MNam _ => True\n| MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n| MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n| Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\nend
H0 : h N M
H : and (h N M)\n match M with\n | MNam _ => True\n | MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
or (not (synthesis h m m1)) (not (synthesis h m0 m2))
+++++
right.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
unfold transpose in |- *.
intros M N.
unfold reduce in |- *.
intro.
elim H.
split.
generalize H1.
case M.
try tauto.
case N.
try tauto.
intros.
case H2.
intro.
right.

*****
H3 : not (synthesis (fun M N : Msg => h N M) m2 m0)
H2 : or (not (synthesis (fun M N : Msg => h N M) m1 m))\n (not (synthesis (fun M N : Msg => h N M) m2 m0))
m,m0,m1,m2 : Msg
H1 : match M with\n| MNam _ => True\n| MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n| MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n| Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\nend
H0 : h N M
H : and (h N M)\n match M with\n | MNam _ => True\n | MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
not (synthesis h m0 m2)
+++++
red in |- *.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
unfold transpose in |- *.
intros M N.
unfold reduce in |- *.
intro.
elim H.
split.
generalize H1.
case M.
try tauto.
case N.
try tauto.
intros.
case H2.
intro.
right.
red in |- *.

*****
H3 : not (synthesis (fun M N : Msg => h N M) m2 m0)
H2 : or (not (synthesis (fun M N : Msg => h N M) m1 m))\n (not (synthesis (fun M N : Msg => h N M) m2 m0))
m,m0,m1,m2 : Msg
H1 : match M with\n| MNam _ => True\n| MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n| MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n| Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\nend
H0 : h N M
H : and (h N M)\n match M with\n | MNam _ => True\n | MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
forall _ : synthesis h m0 m2, False
+++++
intro.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
unfold transpose in |- *.
intros M N.
unfold reduce in |- *.
intro.
elim H.
split.
generalize H1.
case M.
try tauto.
case N.
try tauto.
intros.
case H2.
intro.
right.
red in |- *.
intro.

*****
H4 : synthesis h m0 m2
H3 : not (synthesis (fun M N : Msg => h N M) m2 m0)
H2 : or (not (synthesis (fun M N : Msg => h N M) m1 m))\n (not (synthesis (fun M N : Msg => h N M) m2 m0))
m,m0,m1,m2 : Msg
H1 : match M with\n| MNam _ => True\n| MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n| MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n| Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\nend
H0 : h N M
H : and (h N M)\n match M with\n | MNam _ => True\n | MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
False
+++++
apply H3.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
unfold transpose in |- *.
intros M N.
unfold reduce in |- *.
intro.
elim H.
split.
generalize H1.
case M.
try tauto.
case N.
try tauto.
intros.
case H2.
intro.
right.
red in |- *.
intro.
apply H3.

*****
H4 : synthesis h m0 m2
H3 : not (synthesis (fun M N : Msg => h N M) m2 m0)
H2 : or (not (synthesis (fun M N : Msg => h N M) m1 m))\n (not (synthesis (fun M N : Msg => h N M) m2 m0))
m,m0,m1,m2 : Msg
H1 : match M with\n| MNam _ => True\n| MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n| MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n| Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\nend
H0 : h N M
H : and (h N M)\n match M with\n | MNam _ => True\n | MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
synthesis (fun M N : Msg => h N M) m2 m0
+++++
generalize (synthesis_transpose_transpose_synthesis h).
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
unfold transpose in |- *.
intros M N.
unfold reduce in |- *.
intro.
elim H.
split.
generalize H1.
case M.
try tauto.
case N.
try tauto.
intros.
case H2.
intro.
right.
red in |- *.
intro.
apply H3.
generalize (synthesis_transpose_transpose_synthesis h).

*****
H4 : synthesis h m0 m2
H3 : not (synthesis (fun M N : Msg => h N M) m2 m0)
H2 : or (not (synthesis (fun M N : Msg => h N M) m1 m))\n (not (synthesis (fun M N : Msg => h N M) m2 m0))
m,m0,m1,m2 : Msg
H1 : match M with\n| MNam _ => True\n| MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n| MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n| Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\nend
H0 : h N M
H : and (h N M)\n match M with\n | MNam _ => True\n | MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
forall _ : equal (synthesis (transpose h)) (transpose (synthesis h)), synthesis (fun M N : Msg => h N M) m2 m0
+++++
unfold equal in |- *.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
unfold transpose in |- *.
intros M N.
unfold reduce in |- *.
intro.
elim H.
split.
generalize H1.
case M.
try tauto.
case N.
try tauto.
intros.
case H2.
intro.
right.
red in |- *.
intro.
apply H3.
generalize (synthesis_transpose_transpose_synthesis h).
unfold equal in |- *.

*****
H4 : synthesis h m0 m2
H3 : not (synthesis (fun M N : Msg => h N M) m2 m0)
H2 : or (not (synthesis (fun M N : Msg => h N M) m1 m))\n (not (synthesis (fun M N : Msg => h N M) m2 m0))
m,m0,m1,m2 : Msg
H1 : match M with\n| MNam _ => True\n| MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n| MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n| Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\nend
H0 : h N M
H : and (h N M)\n match M with\n | MNam _ => True\n | MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
forall _ : and (inclusion (synthesis (transpose h)) (transpose (synthesis h))) (inclusion (transpose (synthesis h)) (synthesis (transpose h))), synthesis (fun M N : Msg => h N M) m2 m0
+++++
unfold inclusion in |- *.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
unfold transpose in |- *.
intros M N.
unfold reduce in |- *.
intro.
elim H.
split.
generalize H1.
case M.
try tauto.
case N.
try tauto.
intros.
case H2.
intro.
right.
red in |- *.
intro.
apply H3.
generalize (synthesis_transpose_transpose_synthesis h).
unfold equal in |- *.
unfold inclusion in |- *.

*****
H4 : synthesis h m0 m2
H3 : not (synthesis (fun M N : Msg => h N M) m2 m0)
H2 : or (not (synthesis (fun M N : Msg => h N M) m1 m))\n (not (synthesis (fun M N : Msg => h N M) m2 m0))
m,m0,m1,m2 : Msg
H1 : match M with\n| MNam _ => True\n| MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n| MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n| Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\nend
H0 : h N M
H : and (h N M)\n match M with\n | MNam _ => True\n | MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
forall _ : and (forall (M N : Msg) (_ : synthesis (transpose h) M N), transpose (synthesis h) M N) (forall (M N : Msg) (_ : transpose (synthesis h) M N), synthesis (transpose h) M N), synthesis (fun M N : Msg => h N M) m2 m0
+++++
intro.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
unfold transpose in |- *.
intros M N.
unfold reduce in |- *.
intro.
elim H.
split.
generalize H1.
case M.
try tauto.
case N.
try tauto.
intros.
case H2.
intro.
right.
red in |- *.
intro.
apply H3.
generalize (synthesis_transpose_transpose_synthesis h).
unfold equal in |- *.
unfold inclusion in |- *.
intro.

*****
H5 : and\n (forall (M N : Msg) (_ : synthesis (transpose h) M N),\n transpose (synthesis h) M N)\n (forall (M N : Msg) (_ : transpose (synthesis h) M N),\n synthesis (transpose h) M N)
H4 : synthesis h m0 m2
H3 : not (synthesis (fun M N : Msg => h N M) m2 m0)
H2 : or (not (synthesis (fun M N : Msg => h N M) m1 m))\n (not (synthesis (fun M N : Msg => h N M) m2 m0))
m,m0,m1,m2 : Msg
H1 : match M with\n| MNam _ => True\n| MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n| MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n| Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\nend
H0 : h N M
H : and (h N M)\n match M with\n | MNam _ => True\n | MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
synthesis (fun M N : Msg => h N M) m2 m0
+++++
elim H5.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
unfold transpose in |- *.
intros M N.
unfold reduce in |- *.
intro.
elim H.
split.
generalize H1.
case M.
try tauto.
case N.
try tauto.
intros.
case H2.
intro.
right.
red in |- *.
intro.
apply H3.
generalize (synthesis_transpose_transpose_synthesis h).
unfold equal in |- *.
unfold inclusion in |- *.
intro.
elim H5.

*****
H5 : and\n (forall (M N : Msg) (_ : synthesis (transpose h) M N),\n transpose (synthesis h) M N)\n (forall (M N : Msg) (_ : transpose (synthesis h) M N),\n synthesis (transpose h) M N)
H4 : synthesis h m0 m2
H3 : not (synthesis (fun M N : Msg => h N M) m2 m0)
H2 : or (not (synthesis (fun M N : Msg => h N M) m1 m))\n (not (synthesis (fun M N : Msg => h N M) m2 m0))
m,m0,m1,m2 : Msg
H1 : match M with\n| MNam _ => True\n| MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n| MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n| Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\nend
H0 : h N M
H : and (h N M)\n match M with\n | MNam _ => True\n | MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
forall (_ : forall (M N : Msg) (_ : synthesis (transpose h) M N), transpose (synthesis h) M N) (_ : forall (M N : Msg) (_ : transpose (synthesis h) M N), synthesis (transpose h) M N), synthesis (fun M N : Msg => h N M) m2 m0
+++++
intros.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
unfold transpose in |- *.
intros M N.
unfold reduce in |- *.
intro.
elim H.
split.
generalize H1.
case M.
try tauto.
case N.
try tauto.
intros.
case H2.
intro.
right.
red in |- *.
intro.
apply H3.
generalize (synthesis_transpose_transpose_synthesis h).
unfold equal in |- *.
unfold inclusion in |- *.
intro.
elim H5.
intros.

*****
H7 : forall (M N : Msg) (_ : transpose (synthesis h) M N),\nsynthesis (transpose h) M N
H6 : forall (M N : Msg) (_ : synthesis (transpose h) M N),\ntranspose (synthesis h) M N
H5 : and\n (forall (M N : Msg) (_ : synthesis (transpose h) M N),\n transpose (synthesis h) M N)\n (forall (M N : Msg) (_ : transpose (synthesis h) M N),\n synthesis (transpose h) M N)
H4 : synthesis h m0 m2
H3 : not (synthesis (fun M N : Msg => h N M) m2 m0)
H2 : or (not (synthesis (fun M N : Msg => h N M) m1 m))\n (not (synthesis (fun M N : Msg => h N M) m2 m0))
m,m0,m1,m2 : Msg
H1 : match M with\n| MNam _ => True\n| MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n| MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n| Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\nend
H0 : h N M
H : and (h N M)\n match M with\n | MNam _ => True\n | MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
synthesis (fun M N : Msg => h N M) m2 m0
+++++
apply H7.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
unfold transpose in |- *.
intros M N.
unfold reduce in |- *.
intro.
elim H.
split.
generalize H1.
case M.
try tauto.
case N.
try tauto.
intros.
case H2.
intro.
right.
red in |- *.
intro.
apply H3.
generalize (synthesis_transpose_transpose_synthesis h).
unfold equal in |- *.
unfold inclusion in |- *.
intro.
elim H5.
intros.
apply H7.

*****
H7 : forall (M N : Msg) (_ : transpose (synthesis h) M N),\nsynthesis (transpose h) M N
H6 : forall (M N : Msg) (_ : synthesis (transpose h) M N),\ntranspose (synthesis h) M N
H5 : and\n (forall (M N : Msg) (_ : synthesis (transpose h) M N),\n transpose (synthesis h) M N)\n (forall (M N : Msg) (_ : transpose (synthesis h) M N),\n synthesis (transpose h) M N)
H4 : synthesis h m0 m2
H3 : not (synthesis (fun M N : Msg => h N M) m2 m0)
H2 : or (not (synthesis (fun M N : Msg => h N M) m1 m))\n (not (synthesis (fun M N : Msg => h N M) m2 m0))
m,m0,m1,m2 : Msg
H1 : match M with\n| MNam _ => True\n| MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n| MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n| Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\nend
H0 : h N M
H : and (h N M)\n match M with\n | MNam _ => True\n | MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
transpose (synthesis h) m2 m0
+++++
unfold transpose in |- *.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
unfold transpose in |- *.
intros M N.
unfold reduce in |- *.
intro.
elim H.
split.
generalize H1.
case M.
try tauto.
case N.
try tauto.
intros.
case H2.
intro.
right.
red in |- *.
intro.
apply H3.
generalize (synthesis_transpose_transpose_synthesis h).
unfold equal in |- *.
unfold inclusion in |- *.
intro.
elim H5.
intros.
apply H7.
unfold transpose in |- *.

*****
H7 : forall (M N : Msg) (_ : transpose (synthesis h) M N),\nsynthesis (transpose h) M N
H6 : forall (M N : Msg) (_ : synthesis (transpose h) M N),\ntranspose (synthesis h) M N
H5 : and\n (forall (M N : Msg) (_ : synthesis (transpose h) M N),\n transpose (synthesis h) M N)\n (forall (M N : Msg) (_ : transpose (synthesis h) M N),\n synthesis (transpose h) M N)
H4 : synthesis h m0 m2
H3 : not (synthesis (fun M N : Msg => h N M) m2 m0)
H2 : or (not (synthesis (fun M N : Msg => h N M) m1 m))\n (not (synthesis (fun M N : Msg => h N M) m2 m0))
m,m0,m1,m2 : Msg
H1 : match M with\n| MNam _ => True\n| MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n| MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n| Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\nend
H0 : h N M
H : and (h N M)\n match M with\n | MNam _ => True\n | MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
synthesis h m0 m2
+++++
trivial.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
unfold transpose in |- *.
intros M N.
unfold reduce in |- *.
intro.
elim H.
split.
generalize H1.
case M.
try tauto.
case N.

*****
H1 : match M with\n| MNam _ => True\n| MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n| MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n| Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\nend
H0 : h N M
H : and (h N M)\n match M with\n | MNam _ => True\n | MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
forall (_ : op) (_ : Msg) (_ : Msg) (_ : Msg) (_ : True), True
+++++
try tauto.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
unfold transpose in |- *.
intros M N.
unfold reduce in |- *.
intro.
elim H.
split.
generalize H1.
case M.

*****
H1 : match M with\n| MNam _ => True\n| MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n| MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n| Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\nend
H0 : h N M
H : and (h N M)\n match M with\n | MNam _ => True\n | MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
forall (o : op) (m : Msg) (_ : match N with | Mop opN N' => or (not (eq o opN)) (not (synthesis (fun M N : Msg => h N M) m N')) | _ => True end), match N with | Mop opM M' => or (not (eq opM o)) (not (synthesis h M' m)) | _ => True end
+++++
try tauto.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
unfold transpose in |- *.
intros M N.
unfold reduce in |- *.
intro.
elim H.
split.
generalize H1.
case M.
try tauto.

*****
H1 : match M with\n| MNam _ => True\n| MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n| MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n| Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\nend
H0 : h N M
H : and (h N M)\n match M with\n | MNam _ => True\n | MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
forall (o : op) (m : Msg) (_ : match N with | Mop opN N' => or (not (eq o opN)) (not (synthesis (fun M N : Msg => h N M) m N')) | _ => True end), match N with | Mop opM M' => or (not (eq opM o)) (not (synthesis h M' m)) | _ => True end
+++++
case N.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
unfold transpose in |- *.
intros M N.
unfold reduce in |- *.
intro.
elim H.
split.
generalize H1.
case M.
try tauto.
case N.

*****
H1 : match M with\n| MNam _ => True\n| MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n| MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n| Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\nend
H0 : h N M
H : and (h N M)\n match M with\n | MNam _ => True\n | MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
forall (_ : Nam) (_ : op) (_ : Msg) (_ : True), True
+++++
try tauto.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
unfold transpose in |- *.
intros M N.
unfold reduce in |- *.
intro.
elim H.
split.
generalize H1.
case M.
try tauto.
case N.

*****
H1 : match M with\n| MNam _ => True\n| MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n| MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n| Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\nend
H0 : h N M
H : and (h N M)\n match M with\n | MNam _ => True\n | MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
forall (_ : Msg) (_ : Msg) (_ : op) (_ : Msg) (_ : True), True
+++++
try tauto.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
unfold transpose in |- *.
intros M N.
unfold reduce in |- *.
intro.
elim H.
split.
generalize H1.
case M.
try tauto.
case N.

*****
H1 : match M with\n| MNam _ => True\n| MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n| MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n| Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\nend
H0 : h N M
H : and (h N M)\n match M with\n | MNam _ => True\n | MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
forall (_ : Msg) (_ : Msg) (_ : op) (_ : Msg) (_ : True), True
+++++
try tauto.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
unfold transpose in |- *.
intros M N.
unfold reduce in |- *.
intro.
elim H.
split.
generalize H1.
case M.
try tauto.
case N.

*****
H1 : match M with\n| MNam _ => True\n| MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n| MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n| Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\nend
H0 : h N M
H : and (h N M)\n match M with\n | MNam _ => True\n | MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
forall (o : op) (m : Msg) (o0 : op) (m0 : Msg) (_ : or (not (eq o0 o)) (not (synthesis (fun M N : Msg => h N M) m0 m))), or (not (eq o o0)) (not (synthesis h m m0))
+++++
try tauto.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
unfold transpose in |- *.
intros M N.
unfold reduce in |- *.
intro.
elim H.
split.
generalize H1.
case M.
try tauto.
case N.
try tauto.

*****
H1 : match M with\n| MNam _ => True\n| MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n| MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n| Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\nend
H0 : h N M
H : and (h N M)\n match M with\n | MNam _ => True\n | MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
forall (o : op) (m : Msg) (o0 : op) (m0 : Msg) (_ : or (not (eq o0 o)) (not (synthesis (fun M N : Msg => h N M) m0 m))), or (not (eq o o0)) (not (synthesis h m m0))
+++++
intros.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
unfold transpose in |- *.
intros M N.
unfold reduce in |- *.
intro.
elim H.
split.
generalize H1.
case M.
try tauto.
case N.
try tauto.
intros.

*****
H2 : or (not (eq o0 o)) (not (synthesis (fun M N : Msg => h N M) m0 m))
m0 : Msg
o0 : op
m : Msg
o : op
H1 : match M with\n| MNam _ => True\n| MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n| MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n| Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\nend
H0 : h N M
H : and (h N M)\n match M with\n | MNam _ => True\n | MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
or (not (eq o o0)) (not (synthesis h m m0))
+++++
case H2.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
unfold transpose in |- *.
intros M N.
unfold reduce in |- *.
intro.
elim H.
split.
generalize H1.
case M.
try tauto.
case N.
try tauto.
intros.
case H2.

*****
H2 : or (not (eq o0 o)) (not (synthesis (fun M N : Msg => h N M) m0 m))
m0 : Msg
o0 : op
m : Msg
o : op
H1 : match M with\n| MNam _ => True\n| MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n| MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n| Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\nend
H0 : h N M
H : and (h N M)\n match M with\n | MNam _ => True\n | MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
forall _ : not (eq o0 o), or (not (eq o o0)) (not (synthesis h m m0))
+++++
left.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
unfold transpose in |- *.
intros M N.
unfold reduce in |- *.
intro.
elim H.
split.
generalize H1.
case M.
try tauto.
case N.
try tauto.
intros.
case H2.
left.

*****
H3 : not (eq o0 o)
H2 : or (not (eq o0 o)) (not (synthesis (fun M N : Msg => h N M) m0 m))
m0 : Msg
o0 : op
m : Msg
o : op
H1 : match M with\n| MNam _ => True\n| MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n| MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n| Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\nend
H0 : h N M
H : and (h N M)\n match M with\n | MNam _ => True\n | MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
not (eq o o0)
+++++
red in |- *.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
unfold transpose in |- *.
intros M N.
unfold reduce in |- *.
intro.
elim H.
split.
generalize H1.
case M.
try tauto.
case N.
try tauto.
intros.
case H2.
left.
red in |- *.

*****
H3 : not (eq o0 o)
H2 : or (not (eq o0 o)) (not (synthesis (fun M N : Msg => h N M) m0 m))
m0 : Msg
o0 : op
m : Msg
o : op
H1 : match M with\n| MNam _ => True\n| MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n| MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n| Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\nend
H0 : h N M
H : and (h N M)\n match M with\n | MNam _ => True\n | MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
forall _ : eq o o0, False
+++++
intro.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
unfold transpose in |- *.
intros M N.
unfold reduce in |- *.
intro.
elim H.
split.
generalize H1.
case M.
try tauto.
case N.
try tauto.
intros.
case H2.
left.
red in |- *.
intro.

*****
H4 : eq o o0
H3 : not (eq o0 o)
H2 : or (not (eq o0 o)) (not (synthesis (fun M N : Msg => h N M) m0 m))
m0 : Msg
o0 : op
m : Msg
o : op
H1 : match M with\n| MNam _ => True\n| MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n| MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n| Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\nend
H0 : h N M
H : and (h N M)\n match M with\n | MNam _ => True\n | MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
False
+++++
apply H3.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
unfold transpose in |- *.
intros M N.
unfold reduce in |- *.
intro.
elim H.
split.
generalize H1.
case M.
try tauto.
case N.
try tauto.
intros.
case H2.
left.
red in |- *.
intro.
apply H3.

*****
H4 : eq o o0
H3 : not (eq o0 o)
H2 : or (not (eq o0 o)) (not (synthesis (fun M N : Msg => h N M) m0 m))
m0 : Msg
o0 : op
m : Msg
o : op
H1 : match M with\n| MNam _ => True\n| MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n| MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n| Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\nend
H0 : h N M
H : and (h N M)\n match M with\n | MNam _ => True\n | MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
eq o0 o
+++++
rewrite H4.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
unfold transpose in |- *.
intros M N.
unfold reduce in |- *.
intro.
elim H.
split.
generalize H1.
case M.
try tauto.
case N.
try tauto.
intros.
case H2.
left.
red in |- *.
intro.
apply H3.
rewrite H4.

*****
H4 : eq o o0
H3 : not (eq o0 o)
H2 : or (not (eq o0 o)) (not (synthesis (fun M N : Msg => h N M) m0 m))
m0 : Msg
o0 : op
m : Msg
o : op
H1 : match M with\n| MNam _ => True\n| MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n| MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n| Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\nend
H0 : h N M
H : and (h N M)\n match M with\n | MNam _ => True\n | MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
eq o0 o0
+++++
trivial.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
unfold transpose in |- *.
intros M N.
unfold reduce in |- *.
intro.
elim H.
split.
generalize H1.
case M.
try tauto.
case N.
try tauto.
intros.
case H2.

*****
H2 : or (not (eq o0 o)) (not (synthesis (fun M N : Msg => h N M) m0 m))
m0 : Msg
o0 : op
m : Msg
o : op
H1 : match M with\n| MNam _ => True\n| MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n| MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n| Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\nend
H0 : h N M
H : and (h N M)\n match M with\n | MNam _ => True\n | MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
forall _ : not (synthesis (fun M N : Msg => h N M) m0 m), or (not (eq o o0)) (not (synthesis h m m0))
+++++
right.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
unfold transpose in |- *.
intros M N.
unfold reduce in |- *.
intro.
elim H.
split.
generalize H1.
case M.
try tauto.
case N.
try tauto.
intros.
case H2.
right.

*****
H3 : not (synthesis (fun M N : Msg => h N M) m0 m)
H2 : or (not (eq o0 o)) (not (synthesis (fun M N : Msg => h N M) m0 m))
m0 : Msg
o0 : op
m : Msg
o : op
H1 : match M with\n| MNam _ => True\n| MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n| MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n| Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\nend
H0 : h N M
H : and (h N M)\n match M with\n | MNam _ => True\n | MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
not (synthesis h m m0)
+++++
red in |- *.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
unfold transpose in |- *.
intros M N.
unfold reduce in |- *.
intro.
elim H.
split.
generalize H1.
case M.
try tauto.
case N.
try tauto.
intros.
case H2.
right.
red in |- *.

*****
H3 : not (synthesis (fun M N : Msg => h N M) m0 m)
H2 : or (not (eq o0 o)) (not (synthesis (fun M N : Msg => h N M) m0 m))
m0 : Msg
o0 : op
m : Msg
o : op
H1 : match M with\n| MNam _ => True\n| MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n| MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n| Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\nend
H0 : h N M
H : and (h N M)\n match M with\n | MNam _ => True\n | MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
forall _ : synthesis h m m0, False
+++++
intro.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
unfold transpose in |- *.
intros M N.
unfold reduce in |- *.
intro.
elim H.
split.
generalize H1.
case M.
try tauto.
case N.
try tauto.
intros.
case H2.
right.
red in |- *.
intro.

*****
H4 : synthesis h m m0
H3 : not (synthesis (fun M N : Msg => h N M) m0 m)
H2 : or (not (eq o0 o)) (not (synthesis (fun M N : Msg => h N M) m0 m))
m0 : Msg
o0 : op
m : Msg
o : op
H1 : match M with\n| MNam _ => True\n| MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n| MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n| Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\nend
H0 : h N M
H : and (h N M)\n match M with\n | MNam _ => True\n | MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
False
+++++
apply H3.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
unfold transpose in |- *.
intros M N.
unfold reduce in |- *.
intro.
elim H.
split.
generalize H1.
case M.
try tauto.
case N.
try tauto.
intros.
case H2.
right.
red in |- *.
intro.
apply H3.

*****
H4 : synthesis h m m0
H3 : not (synthesis (fun M N : Msg => h N M) m0 m)
H2 : or (not (eq o0 o)) (not (synthesis (fun M N : Msg => h N M) m0 m))
m0 : Msg
o0 : op
m : Msg
o : op
H1 : match M with\n| MNam _ => True\n| MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n| MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n| Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\nend
H0 : h N M
H : and (h N M)\n match M with\n | MNam _ => True\n | MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
synthesis (fun M N : Msg => h N M) m0 m
+++++
generalize (synthesis_transpose_transpose_synthesis h).
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
unfold transpose in |- *.
intros M N.
unfold reduce in |- *.
intro.
elim H.
split.
generalize H1.
case M.
try tauto.
case N.
try tauto.
intros.
case H2.
right.
red in |- *.
intro.
apply H3.
generalize (synthesis_transpose_transpose_synthesis h).

*****
H4 : synthesis h m m0
H3 : not (synthesis (fun M N : Msg => h N M) m0 m)
H2 : or (not (eq o0 o)) (not (synthesis (fun M N : Msg => h N M) m0 m))
m0 : Msg
o0 : op
m : Msg
o : op
H1 : match M with\n| MNam _ => True\n| MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n| MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n| Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\nend
H0 : h N M
H : and (h N M)\n match M with\n | MNam _ => True\n | MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
forall _ : equal (synthesis (transpose h)) (transpose (synthesis h)), synthesis (fun M N : Msg => h N M) m0 m
+++++
unfold equal in |- *.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
unfold transpose in |- *.
intros M N.
unfold reduce in |- *.
intro.
elim H.
split.
generalize H1.
case M.
try tauto.
case N.
try tauto.
intros.
case H2.
right.
red in |- *.
intro.
apply H3.
generalize (synthesis_transpose_transpose_synthesis h).
unfold equal in |- *.

*****
H4 : synthesis h m m0
H3 : not (synthesis (fun M N : Msg => h N M) m0 m)
H2 : or (not (eq o0 o)) (not (synthesis (fun M N : Msg => h N M) m0 m))
m0 : Msg
o0 : op
m : Msg
o : op
H1 : match M with\n| MNam _ => True\n| MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n| MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n| Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\nend
H0 : h N M
H : and (h N M)\n match M with\n | MNam _ => True\n | MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
forall _ : and (inclusion (synthesis (transpose h)) (transpose (synthesis h))) (inclusion (transpose (synthesis h)) (synthesis (transpose h))), synthesis (fun M N : Msg => h N M) m0 m
+++++
unfold inclusion in |- *.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
unfold transpose in |- *.
intros M N.
unfold reduce in |- *.
intro.
elim H.
split.
generalize H1.
case M.
try tauto.
case N.
try tauto.
intros.
case H2.
right.
red in |- *.
intro.
apply H3.
generalize (synthesis_transpose_transpose_synthesis h).
unfold equal in |- *.
unfold inclusion in |- *.

*****
H4 : synthesis h m m0
H3 : not (synthesis (fun M N : Msg => h N M) m0 m)
H2 : or (not (eq o0 o)) (not (synthesis (fun M N : Msg => h N M) m0 m))
m0 : Msg
o0 : op
m : Msg
o : op
H1 : match M with\n| MNam _ => True\n| MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n| MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n| Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\nend
H0 : h N M
H : and (h N M)\n match M with\n | MNam _ => True\n | MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
forall _ : and (forall (M N : Msg) (_ : synthesis (transpose h) M N), transpose (synthesis h) M N) (forall (M N : Msg) (_ : transpose (synthesis h) M N), synthesis (transpose h) M N), synthesis (fun M N : Msg => h N M) m0 m
+++++
intro.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
unfold transpose in |- *.
intros M N.
unfold reduce in |- *.
intro.
elim H.
split.
generalize H1.
case M.
try tauto.
case N.
try tauto.
intros.
case H2.
right.
red in |- *.
intro.
apply H3.
generalize (synthesis_transpose_transpose_synthesis h).
unfold equal in |- *.
unfold inclusion in |- *.
intro.

*****
H5 : and\n (forall (M N : Msg) (_ : synthesis (transpose h) M N),\n transpose (synthesis h) M N)\n (forall (M N : Msg) (_ : transpose (synthesis h) M N),\n synthesis (transpose h) M N)
H4 : synthesis h m m0
H3 : not (synthesis (fun M N : Msg => h N M) m0 m)
H2 : or (not (eq o0 o)) (not (synthesis (fun M N : Msg => h N M) m0 m))
m0 : Msg
o0 : op
m : Msg
o : op
H1 : match M with\n| MNam _ => True\n| MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n| MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n| Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\nend
H0 : h N M
H : and (h N M)\n match M with\n | MNam _ => True\n | MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
synthesis (fun M N : Msg => h N M) m0 m
+++++
elim H5.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
unfold transpose in |- *.
intros M N.
unfold reduce in |- *.
intro.
elim H.
split.
generalize H1.
case M.
try tauto.
case N.
try tauto.
intros.
case H2.
right.
red in |- *.
intro.
apply H3.
generalize (synthesis_transpose_transpose_synthesis h).
unfold equal in |- *.
unfold inclusion in |- *.
intro.
elim H5.

*****
H5 : and\n (forall (M N : Msg) (_ : synthesis (transpose h) M N),\n transpose (synthesis h) M N)\n (forall (M N : Msg) (_ : transpose (synthesis h) M N),\n synthesis (transpose h) M N)
H4 : synthesis h m m0
H3 : not (synthesis (fun M N : Msg => h N M) m0 m)
H2 : or (not (eq o0 o)) (not (synthesis (fun M N : Msg => h N M) m0 m))
m0 : Msg
o0 : op
m : Msg
o : op
H1 : match M with\n| MNam _ => True\n| MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n| MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n| Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\nend
H0 : h N M
H : and (h N M)\n match M with\n | MNam _ => True\n | MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
forall (_ : forall (M N : Msg) (_ : synthesis (transpose h) M N), transpose (synthesis h) M N) (_ : forall (M N : Msg) (_ : transpose (synthesis h) M N), synthesis (transpose h) M N), synthesis (fun M N : Msg => h N M) m0 m
+++++
intros.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
unfold transpose in |- *.
intros M N.
unfold reduce in |- *.
intro.
elim H.
split.
generalize H1.
case M.
try tauto.
case N.
try tauto.
intros.
case H2.
right.
red in |- *.
intro.
apply H3.
generalize (synthesis_transpose_transpose_synthesis h).
unfold equal in |- *.
unfold inclusion in |- *.
intro.
elim H5.
intros.

*****
H7 : forall (M N : Msg) (_ : transpose (synthesis h) M N),\nsynthesis (transpose h) M N
H6 : forall (M N : Msg) (_ : synthesis (transpose h) M N),\ntranspose (synthesis h) M N
H5 : and\n (forall (M N : Msg) (_ : synthesis (transpose h) M N),\n transpose (synthesis h) M N)\n (forall (M N : Msg) (_ : transpose (synthesis h) M N),\n synthesis (transpose h) M N)
H4 : synthesis h m m0
H3 : not (synthesis (fun M N : Msg => h N M) m0 m)
H2 : or (not (eq o0 o)) (not (synthesis (fun M N : Msg => h N M) m0 m))
m0 : Msg
o0 : op
m : Msg
o : op
H1 : match M with\n| MNam _ => True\n| MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n| MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n| Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\nend
H0 : h N M
H : and (h N M)\n match M with\n | MNam _ => True\n | MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
synthesis (fun M N : Msg => h N M) m0 m
+++++
apply H7.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
unfold transpose in |- *.
intros M N.
unfold reduce in |- *.
intro.
elim H.
split.
generalize H1.
case M.
try tauto.
case N.
try tauto.
intros.
case H2.
right.
red in |- *.
intro.
apply H3.
generalize (synthesis_transpose_transpose_synthesis h).
unfold equal in |- *.
unfold inclusion in |- *.
intro.
elim H5.
intros.
apply H7.

*****
H7 : forall (M N : Msg) (_ : transpose (synthesis h) M N),\nsynthesis (transpose h) M N
H6 : forall (M N : Msg) (_ : synthesis (transpose h) M N),\ntranspose (synthesis h) M N
H5 : and\n (forall (M N : Msg) (_ : synthesis (transpose h) M N),\n transpose (synthesis h) M N)\n (forall (M N : Msg) (_ : transpose (synthesis h) M N),\n synthesis (transpose h) M N)
H4 : synthesis h m m0
H3 : not (synthesis (fun M N : Msg => h N M) m0 m)
H2 : or (not (eq o0 o)) (not (synthesis (fun M N : Msg => h N M) m0 m))
m0 : Msg
o0 : op
m : Msg
o : op
H1 : match M with\n| MNam _ => True\n| MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n| MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n| Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\nend
H0 : h N M
H : and (h N M)\n match M with\n | MNam _ => True\n | MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
transpose (synthesis h) m0 m
+++++
unfold transpose in |- *.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
unfold transpose in |- *.
intros M N.
unfold reduce in |- *.
intro.
elim H.
split.
generalize H1.
case M.
try tauto.
case N.
try tauto.
intros.
case H2.
right.
red in |- *.
intro.
apply H3.
generalize (synthesis_transpose_transpose_synthesis h).
unfold equal in |- *.
unfold inclusion in |- *.
intro.
elim H5.
intros.
apply H7.
unfold transpose in |- *.

*****
H7 : forall (M N : Msg) (_ : transpose (synthesis h) M N),\nsynthesis (transpose h) M N
H6 : forall (M N : Msg) (_ : synthesis (transpose h) M N),\ntranspose (synthesis h) M N
H5 : and\n (forall (M N : Msg) (_ : synthesis (transpose h) M N),\n transpose (synthesis h) M N)\n (forall (M N : Msg) (_ : transpose (synthesis h) M N),\n synthesis (transpose h) M N)
H4 : synthesis h m m0
H3 : not (synthesis (fun M N : Msg => h N M) m0 m)
H2 : or (not (eq o0 o)) (not (synthesis (fun M N : Msg => h N M) m0 m))
m0 : Msg
o0 : op
m : Msg
o : op
H1 : match M with\n| MNam _ => True\n| MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n| MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n| Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\nend
H0 : h N M
H : and (h N M)\n match M with\n | MNam _ => True\n | MEnc M' K =>\n match N with\n | MEnc N' L =>\n or (not (synthesis (fun M N : Msg => h N M) M' N'))\n (not (synthesis (fun M N : Msg => h N M) K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match N with\n | MPair N1 N2 =>\n or (not (synthesis (fun M N : Msg => h N M) M1 N1))\n (not (synthesis (fun M N : Msg => h N M) M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match N with\n | Mop opN N' =>\n or (not (eq opM opN))\n (not (synthesis (fun M N : Msg => h N M) M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
synthesis h m m0
+++++
trivial.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.

*****
h : hedge
*****
inclusion (transpose (reduce h)) (reduce (transpose h))
+++++
unfold inclusion in |- *.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.

*****
h : hedge
*****
forall (M N : Msg) (_ : transpose (reduce h) M N), reduce (transpose h) M N
+++++
intros M N.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
intros M N.

*****
M,N : Msg
h : hedge
*****
forall _ : transpose (reduce h) M N, reduce (transpose h) M N
+++++
unfold transpose in |- *.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
intros M N.
unfold transpose in |- *.

*****
M,N : Msg
h : hedge
*****
forall _ : reduce h N M, reduce (fun M N : Msg => h N M) M N
+++++
unfold reduce in |- *.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
intros M N.
unfold transpose in |- *.
unfold reduce in |- *.

*****
M,N : Msg
h : hedge
*****
forall _ : and (h N M) match N with | MNam _ => True | MEnc M' K => match M with | MEnc N' L => or (not (synthesis h M' N')) (not (synthesis h K L)) | _ => True end | MPair M1 M2 => match M with | MPair N1 N2 => or (not (synthesis h M1 N1)) (not (synthesis h M2 N2)) | _ => True end | Mop opM M' => match M with | Mop opN N' => or (not (eq opM opN)) (not (synthesis h M' N')) | _ => True end end, and (h N M) match M with | MNam _ => True | MEnc M' K => match N with | MEnc N' L => or (not (synthesis (fun M N : Msg => h N M) M' N')) (not (synthesis (fun M N : Msg => h N M) K L)) | _ => True end | MPair M1 M2 => match N with | MPair N1 N2 => or (not (synthesis (fun M N : Msg => h N M) M1 N1)) (not (synthesis (fun M N : Msg => h N M) M2 N2)) | _ => True end | Mop opM M' => match N with | Mop opN N' => or (not (eq opM opN)) (not (synthesis (fun M N : Msg => h N M) M' N')) | _ => True end end
+++++
split.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
intros M N.
unfold transpose in |- *.
unfold reduce in |- *.
split.

*****
H : and (h N M)\n match N with\n | MNam _ => True\n | MEnc M' K =>\n match M with\n | MEnc N' L =>\n or (not (synthesis h M' N')) (not (synthesis h K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match M with\n | MPair N1 N2 =>\n or (not (synthesis h M1 N1)) (not (synthesis h M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match M with\n | Mop opN N' => or (not (eq opM opN)) (not (synthesis h M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
h N M
+++++
try tauto.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
intros M N.
unfold transpose in |- *.
unfold reduce in |- *.
split.

*****
H : and (h N M)\n match N with\n | MNam _ => True\n | MEnc M' K =>\n match M with\n | MEnc N' L =>\n or (not (synthesis h M' N')) (not (synthesis h K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match M with\n | MPair N1 N2 =>\n or (not (synthesis h M1 N1)) (not (synthesis h M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match M with\n | Mop opN N' => or (not (eq opM opN)) (not (synthesis h M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
match M with | MNam _ => True | MEnc M' K => match N with | MEnc N' L => or (not (synthesis (fun M N : Msg => h N M) M' N')) (not (synthesis (fun M N : Msg => h N M) K L)) | _ => True end | MPair M1 M2 => match N with | MPair N1 N2 => or (not (synthesis (fun M N : Msg => h N M) M1 N1)) (not (synthesis (fun M N : Msg => h N M) M2 N2)) | _ => True end | Mop opM M' => match N with | Mop opN N' => or (not (eq opM opN)) (not (synthesis (fun M N : Msg => h N M) M' N')) | _ => True end end
+++++
try tauto.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
intros M N.
unfold transpose in |- *.
unfold reduce in |- *.
split.
try tauto.

*****
H : and (h N M)\n match N with\n | MNam _ => True\n | MEnc M' K =>\n match M with\n | MEnc N' L =>\n or (not (synthesis h M' N')) (not (synthesis h K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match M with\n | MPair N1 N2 =>\n or (not (synthesis h M1 N1)) (not (synthesis h M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match M with\n | Mop opN N' => or (not (eq opM opN)) (not (synthesis h M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
match M with | MNam _ => True | MEnc M' K => match N with | MEnc N' L => or (not (synthesis (fun M N : Msg => h N M) M' N')) (not (synthesis (fun M N : Msg => h N M) K L)) | _ => True end | MPair M1 M2 => match N with | MPair N1 N2 => or (not (synthesis (fun M N : Msg => h N M) M1 N1)) (not (synthesis (fun M N : Msg => h N M) M2 N2)) | _ => True end | Mop opM M' => match N with | Mop opN N' => or (not (eq opM opN)) (not (synthesis (fun M N : Msg => h N M) M' N')) | _ => True end end
+++++
elim H.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
intros M N.
unfold transpose in |- *.
unfold reduce in |- *.
split.
try tauto.
elim H.

*****
H : and (h N M)\n match N with\n | MNam _ => True\n | MEnc M' K =>\n match M with\n | MEnc N' L =>\n or (not (synthesis h M' N')) (not (synthesis h K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match M with\n | MPair N1 N2 =>\n or (not (synthesis h M1 N1)) (not (synthesis h M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match M with\n | Mop opN N' => or (not (eq opM opN)) (not (synthesis h M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
forall (_ : h N M) (_ : match N with | MNam _ => True | MEnc M' K => match M with | MEnc N' L => or (not (synthesis h M' N')) (not (synthesis h K L)) | _ => True end | MPair M1 M2 => match M with | MPair N1 N2 => or (not (synthesis h M1 N1)) (not (synthesis h M2 N2)) | _ => True end | Mop opM M' => match M with | Mop opN N' => or (not (eq opM opN)) (not (synthesis h M' N')) | _ => True end end), match M with | MNam _ => True | MEnc M' K => match N with | MEnc N' L => or (not (synthesis (fun M N : Msg => h N M) M' N')) (not (synthesis (fun M N : Msg => h N M) K L)) | _ => True end | MPair M1 M2 => match N with | MPair N1 N2 => or (not (synthesis (fun M N : Msg => h N M) M1 N1)) (not (synthesis (fun M N : Msg => h N M) M2 N2)) | _ => True end | Mop opM M' => match N with | Mop opN N' => or (not (eq opM opN)) (not (synthesis (fun M N : Msg => h N M) M' N')) | _ => True end end
+++++
intro.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
intros M N.
unfold transpose in |- *.
unfold reduce in |- *.
split.
try tauto.
elim H.
intro.

*****
H0 : h N M
H : and (h N M)\n match N with\n | MNam _ => True\n | MEnc M' K =>\n match M with\n | MEnc N' L =>\n or (not (synthesis h M' N')) (not (synthesis h K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match M with\n | MPair N1 N2 =>\n or (not (synthesis h M1 N1)) (not (synthesis h M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match M with\n | Mop opN N' => or (not (eq opM opN)) (not (synthesis h M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
forall _ : match N with | MNam _ => True | MEnc M' K => match M with | MEnc N' L => or (not (synthesis h M' N')) (not (synthesis h K L)) | _ => True end | MPair M1 M2 => match M with | MPair N1 N2 => or (not (synthesis h M1 N1)) (not (synthesis h M2 N2)) | _ => True end | Mop opM M' => match M with | Mop opN N' => or (not (eq opM opN)) (not (synthesis h M' N')) | _ => True end end, match M with | MNam _ => True | MEnc M' K => match N with | MEnc N' L => or (not (synthesis (fun M N : Msg => h N M) M' N')) (not (synthesis (fun M N : Msg => h N M) K L)) | _ => True end | MPair M1 M2 => match N with | MPair N1 N2 => or (not (synthesis (fun M N : Msg => h N M) M1 N1)) (not (synthesis (fun M N : Msg => h N M) M2 N2)) | _ => True end | Mop opM M' => match N with | Mop opN N' => or (not (eq opM opN)) (not (synthesis (fun M N : Msg => h N M) M' N')) | _ => True end end
+++++
generalize (synthesis_transpose_transpose_synthesis h).
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
intros M N.
unfold transpose in |- *.
unfold reduce in |- *.
split.
try tauto.
elim H.
intro.
generalize (synthesis_transpose_transpose_synthesis h).

*****
H0 : h N M
H : and (h N M)\n match N with\n | MNam _ => True\n | MEnc M' K =>\n match M with\n | MEnc N' L =>\n or (not (synthesis h M' N')) (not (synthesis h K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match M with\n | MPair N1 N2 =>\n or (not (synthesis h M1 N1)) (not (synthesis h M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match M with\n | Mop opN N' => or (not (eq opM opN)) (not (synthesis h M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
forall (_ : equal (synthesis (transpose h)) (transpose (synthesis h))) (_ : match N with | MNam _ => True | MEnc M' K => match M with | MEnc N' L => or (not (synthesis h M' N')) (not (synthesis h K L)) | _ => True end | MPair M1 M2 => match M with | MPair N1 N2 => or (not (synthesis h M1 N1)) (not (synthesis h M2 N2)) | _ => True end | Mop opM M' => match M with | Mop opN N' => or (not (eq opM opN)) (not (synthesis h M' N')) | _ => True end end), match M with | MNam _ => True | MEnc M' K => match N with | MEnc N' L => or (not (synthesis (fun M N : Msg => h N M) M' N')) (not (synthesis (fun M N : Msg => h N M) K L)) | _ => True end | MPair M1 M2 => match N with | MPair N1 N2 => or (not (synthesis (fun M N : Msg => h N M) M1 N1)) (not (synthesis (fun M N : Msg => h N M) M2 N2)) | _ => True end | Mop opM M' => match N with | Mop opN N' => or (not (eq opM opN)) (not (synthesis (fun M N : Msg => h N M) M' N')) | _ => True end end
+++++
unfold equal in |- *.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
intros M N.
unfold transpose in |- *.
unfold reduce in |- *.
split.
try tauto.
elim H.
intro.
generalize (synthesis_transpose_transpose_synthesis h).
unfold equal in |- *.

*****
H0 : h N M
H : and (h N M)\n match N with\n | MNam _ => True\n | MEnc M' K =>\n match M with\n | MEnc N' L =>\n or (not (synthesis h M' N')) (not (synthesis h K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match M with\n | MPair N1 N2 =>\n or (not (synthesis h M1 N1)) (not (synthesis h M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match M with\n | Mop opN N' => or (not (eq opM opN)) (not (synthesis h M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
forall (_ : and (inclusion (synthesis (transpose h)) (transpose (synthesis h))) (inclusion (transpose (synthesis h)) (synthesis (transpose h)))) (_ : match N with | MNam _ => True | MEnc M' K => match M with | MEnc N' L => or (not (synthesis h M' N')) (not (synthesis h K L)) | _ => True end | MPair M1 M2 => match M with | MPair N1 N2 => or (not (synthesis h M1 N1)) (not (synthesis h M2 N2)) | _ => True end | Mop opM M' => match M with | Mop opN N' => or (not (eq opM opN)) (not (synthesis h M' N')) | _ => True end end), match M with | MNam _ => True | MEnc M' K => match N with | MEnc N' L => or (not (synthesis (fun M N : Msg => h N M) M' N')) (not (synthesis (fun M N : Msg => h N M) K L)) | _ => True end | MPair M1 M2 => match N with | MPair N1 N2 => or (not (synthesis (fun M N : Msg => h N M) M1 N1)) (not (synthesis (fun M N : Msg => h N M) M2 N2)) | _ => True end | Mop opM M' => match N with | Mop opN N' => or (not (eq opM opN)) (not (synthesis (fun M N : Msg => h N M) M' N')) | _ => True end end
+++++
unfold inclusion in |- *.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
intros M N.
unfold transpose in |- *.
unfold reduce in |- *.
split.
try tauto.
elim H.
intro.
generalize (synthesis_transpose_transpose_synthesis h).
unfold equal in |- *.
unfold inclusion in |- *.

*****
H0 : h N M
H : and (h N M)\n match N with\n | MNam _ => True\n | MEnc M' K =>\n match M with\n | MEnc N' L =>\n or (not (synthesis h M' N')) (not (synthesis h K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match M with\n | MPair N1 N2 =>\n or (not (synthesis h M1 N1)) (not (synthesis h M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match M with\n | Mop opN N' => or (not (eq opM opN)) (not (synthesis h M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
forall (_ : and (forall (M N : Msg) (_ : synthesis (transpose h) M N), transpose (synthesis h) M N) (forall (M N : Msg) (_ : transpose (synthesis h) M N), synthesis (transpose h) M N)) (_ : match N with | MNam _ => True | MEnc M' K => match M with | MEnc N' L => or (not (synthesis h M' N')) (not (synthesis h K L)) | _ => True end | MPair M1 M2 => match M with | MPair N1 N2 => or (not (synthesis h M1 N1)) (not (synthesis h M2 N2)) | _ => True end | Mop opM M' => match M with | Mop opN N' => or (not (eq opM opN)) (not (synthesis h M' N')) | _ => True end end), match M with | MNam _ => True | MEnc M' K => match N with | MEnc N' L => or (not (synthesis (fun M N : Msg => h N M) M' N')) (not (synthesis (fun M N : Msg => h N M) K L)) | _ => True end | MPair M1 M2 => match N with | MPair N1 N2 => or (not (synthesis (fun M N : Msg => h N M) M1 N1)) (not (synthesis (fun M N : Msg => h N M) M2 N2)) | _ => True end | Mop opM M' => match N with | Mop opN N' => or (not (eq opM opN)) (not (synthesis (fun M N : Msg => h N M) M' N')) | _ => True end end
+++++
intro.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
intros M N.
unfold transpose in |- *.
unfold reduce in |- *.
split.
try tauto.
elim H.
intro.
generalize (synthesis_transpose_transpose_synthesis h).
unfold equal in |- *.
unfold inclusion in |- *.
intro.

*****
H1 : and\n (forall (M N : Msg) (_ : synthesis (transpose h) M N),\n transpose (synthesis h) M N)\n (forall (M N : Msg) (_ : transpose (synthesis h) M N),\n synthesis (transpose h) M N)
H0 : h N M
H : and (h N M)\n match N with\n | MNam _ => True\n | MEnc M' K =>\n match M with\n | MEnc N' L =>\n or (not (synthesis h M' N')) (not (synthesis h K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match M with\n | MPair N1 N2 =>\n or (not (synthesis h M1 N1)) (not (synthesis h M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match M with\n | Mop opN N' => or (not (eq opM opN)) (not (synthesis h M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
forall _ : match N with | MNam _ => True | MEnc M' K => match M with | MEnc N' L => or (not (synthesis h M' N')) (not (synthesis h K L)) | _ => True end | MPair M1 M2 => match M with | MPair N1 N2 => or (not (synthesis h M1 N1)) (not (synthesis h M2 N2)) | _ => True end | Mop opM M' => match M with | Mop opN N' => or (not (eq opM opN)) (not (synthesis h M' N')) | _ => True end end, match M with | MNam _ => True | MEnc M' K => match N with | MEnc N' L => or (not (synthesis (fun M N : Msg => h N M) M' N')) (not (synthesis (fun M N : Msg => h N M) K L)) | _ => True end | MPair M1 M2 => match N with | MPair N1 N2 => or (not (synthesis (fun M N : Msg => h N M) M1 N1)) (not (synthesis (fun M N : Msg => h N M) M2 N2)) | _ => True end | Mop opM M' => match N with | Mop opN N' => or (not (eq opM opN)) (not (synthesis (fun M N : Msg => h N M) M' N')) | _ => True end end
+++++
elim H1.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
intros M N.
unfold transpose in |- *.
unfold reduce in |- *.
split.
try tauto.
elim H.
intro.
generalize (synthesis_transpose_transpose_synthesis h).
unfold equal in |- *.
unfold inclusion in |- *.
intro.
elim H1.

*****
H1 : and\n (forall (M N : Msg) (_ : synthesis (transpose h) M N),\n transpose (synthesis h) M N)\n (forall (M N : Msg) (_ : transpose (synthesis h) M N),\n synthesis (transpose h) M N)
H0 : h N M
H : and (h N M)\n match N with\n | MNam _ => True\n | MEnc M' K =>\n match M with\n | MEnc N' L =>\n or (not (synthesis h M' N')) (not (synthesis h K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match M with\n | MPair N1 N2 =>\n or (not (synthesis h M1 N1)) (not (synthesis h M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match M with\n | Mop opN N' => or (not (eq opM opN)) (not (synthesis h M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
forall (_ : forall (M N : Msg) (_ : synthesis (transpose h) M N), transpose (synthesis h) M N) (_ : forall (M N : Msg) (_ : transpose (synthesis h) M N), synthesis (transpose h) M N) (_ : match N with | MNam _ => True | MEnc M' K => match M with | MEnc N' L => or (not (synthesis h M' N')) (not (synthesis h K L)) | _ => True end | MPair M1 M2 => match M with | MPair N1 N2 => or (not (synthesis h M1 N1)) (not (synthesis h M2 N2)) | _ => True end | Mop opM M' => match M with | Mop opN N' => or (not (eq opM opN)) (not (synthesis h M' N')) | _ => True end end), match M with | MNam _ => True | MEnc M' K => match N with | MEnc N' L => or (not (synthesis (fun M N : Msg => h N M) M' N')) (not (synthesis (fun M N : Msg => h N M) K L)) | _ => True end | MPair M1 M2 => match N with | MPair N1 N2 => or (not (synthesis (fun M N : Msg => h N M) M1 N1)) (not (synthesis (fun M N : Msg => h N M) M2 N2)) | _ => True end | Mop opM M' => match N with | Mop opN N' => or (not (eq opM opN)) (not (synthesis (fun M N : Msg => h N M) M' N')) | _ => True end end
+++++
intro.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
intros M N.
unfold transpose in |- *.
unfold reduce in |- *.
split.
try tauto.
elim H.
intro.
generalize (synthesis_transpose_transpose_synthesis h).
unfold equal in |- *.
unfold inclusion in |- *.
intro.
elim H1.
intro.

*****
H2 : forall (M N : Msg) (_ : synthesis (transpose h) M N),\ntranspose (synthesis h) M N
H1 : and\n (forall (M N : Msg) (_ : synthesis (transpose h) M N),\n transpose (synthesis h) M N)\n (forall (M N : Msg) (_ : transpose (synthesis h) M N),\n synthesis (transpose h) M N)
H0 : h N M
H : and (h N M)\n match N with\n | MNam _ => True\n | MEnc M' K =>\n match M with\n | MEnc N' L =>\n or (not (synthesis h M' N')) (not (synthesis h K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match M with\n | MPair N1 N2 =>\n or (not (synthesis h M1 N1)) (not (synthesis h M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match M with\n | Mop opN N' => or (not (eq opM opN)) (not (synthesis h M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
forall (_ : forall (M N : Msg) (_ : transpose (synthesis h) M N), synthesis (transpose h) M N) (_ : match N with | MNam _ => True | MEnc M' K => match M with | MEnc N' L => or (not (synthesis h M' N')) (not (synthesis h K L)) | _ => True end | MPair M1 M2 => match M with | MPair N1 N2 => or (not (synthesis h M1 N1)) (not (synthesis h M2 N2)) | _ => True end | Mop opM M' => match M with | Mop opN N' => or (not (eq opM opN)) (not (synthesis h M' N')) | _ => True end end), match M with | MNam _ => True | MEnc M' K => match N with | MEnc N' L => or (not (synthesis (fun M N : Msg => h N M) M' N')) (not (synthesis (fun M N : Msg => h N M) K L)) | _ => True end | MPair M1 M2 => match N with | MPair N1 N2 => or (not (synthesis (fun M N : Msg => h N M) M1 N1)) (not (synthesis (fun M N : Msg => h N M) M2 N2)) | _ => True end | Mop opM M' => match N with | Mop opN N' => or (not (eq opM opN)) (not (synthesis (fun M N : Msg => h N M) M' N')) | _ => True end end
+++++
intro.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
intros M N.
unfold transpose in |- *.
unfold reduce in |- *.
split.
try tauto.
elim H.
intro.
generalize (synthesis_transpose_transpose_synthesis h).
unfold equal in |- *.
unfold inclusion in |- *.
intro.
elim H1.
intro.
intro.

*****
H3 : forall (M N : Msg) (_ : transpose (synthesis h) M N),\nsynthesis (transpose h) M N
H2 : forall (M N : Msg) (_ : synthesis (transpose h) M N),\ntranspose (synthesis h) M N
H1 : and\n (forall (M N : Msg) (_ : synthesis (transpose h) M N),\n transpose (synthesis h) M N)\n (forall (M N : Msg) (_ : transpose (synthesis h) M N),\n synthesis (transpose h) M N)
H0 : h N M
H : and (h N M)\n match N with\n | MNam _ => True\n | MEnc M' K =>\n match M with\n | MEnc N' L =>\n or (not (synthesis h M' N')) (not (synthesis h K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match M with\n | MPair N1 N2 =>\n or (not (synthesis h M1 N1)) (not (synthesis h M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match M with\n | Mop opN N' => or (not (eq opM opN)) (not (synthesis h M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
forall _ : match N with | MNam _ => True | MEnc M' K => match M with | MEnc N' L => or (not (synthesis h M' N')) (not (synthesis h K L)) | _ => True end | MPair M1 M2 => match M with | MPair N1 N2 => or (not (synthesis h M1 N1)) (not (synthesis h M2 N2)) | _ => True end | Mop opM M' => match M with | Mop opN N' => or (not (eq opM opN)) (not (synthesis h M' N')) | _ => True end end, match M with | MNam _ => True | MEnc M' K => match N with | MEnc N' L => or (not (synthesis (fun M N : Msg => h N M) M' N')) (not (synthesis (fun M N : Msg => h N M) K L)) | _ => True end | MPair M1 M2 => match N with | MPair N1 N2 => or (not (synthesis (fun M N : Msg => h N M) M1 N1)) (not (synthesis (fun M N : Msg => h N M) M2 N2)) | _ => True end | Mop opM M' => match N with | Mop opN N' => or (not (eq opM opN)) (not (synthesis (fun M N : Msg => h N M) M' N')) | _ => True end end
+++++
unfold transpose in H2.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
intros M N.
unfold transpose in |- *.
unfold reduce in |- *.
split.
try tauto.
elim H.
intro.
generalize (synthesis_transpose_transpose_synthesis h).
unfold equal in |- *.
unfold inclusion in |- *.
intro.
elim H1.
intro.
intro.
unfold transpose in H2.

*****
H3 : forall (M N : Msg) (_ : transpose (synthesis h) M N),\nsynthesis (transpose h) M N
H2 : forall (M N : Msg) (_ : synthesis (fun M0 N0 : Msg => h N0 M0) M N),\nsynthesis h N M
H1 : and\n (forall (M N : Msg) (_ : synthesis (transpose h) M N),\n transpose (synthesis h) M N)\n (forall (M N : Msg) (_ : transpose (synthesis h) M N),\n synthesis (transpose h) M N)
H0 : h N M
H : and (h N M)\n match N with\n | MNam _ => True\n | MEnc M' K =>\n match M with\n | MEnc N' L =>\n or (not (synthesis h M' N')) (not (synthesis h K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match M with\n | MPair N1 N2 =>\n or (not (synthesis h M1 N1)) (not (synthesis h M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match M with\n | Mop opN N' => or (not (eq opM opN)) (not (synthesis h M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
forall _ : match N with | MNam _ => True | MEnc M' K => match M with | MEnc N' L => or (not (synthesis h M' N')) (not (synthesis h K L)) | _ => True end | MPair M1 M2 => match M with | MPair N1 N2 => or (not (synthesis h M1 N1)) (not (synthesis h M2 N2)) | _ => True end | Mop opM M' => match M with | Mop opN N' => or (not (eq opM opN)) (not (synthesis h M' N')) | _ => True end end, match M with | MNam _ => True | MEnc M' K => match N with | MEnc N' L => or (not (synthesis (fun M N : Msg => h N M) M' N')) (not (synthesis (fun M N : Msg => h N M) K L)) | _ => True end | MPair M1 M2 => match N with | MPair N1 N2 => or (not (synthesis (fun M N : Msg => h N M) M1 N1)) (not (synthesis (fun M N : Msg => h N M) M2 N2)) | _ => True end | Mop opM M' => match N with | Mop opN N' => or (not (eq opM opN)) (not (synthesis (fun M N : Msg => h N M) M' N')) | _ => True end end
+++++
case N.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
intros M N.
unfold transpose in |- *.
unfold reduce in |- *.
split.
try tauto.
elim H.
intro.
generalize (synthesis_transpose_transpose_synthesis h).
unfold equal in |- *.
unfold inclusion in |- *.
intro.
elim H1.
intro.
intro.
unfold transpose in H2.
case N.

*****
H3 : forall (M N : Msg) (_ : transpose (synthesis h) M N),\nsynthesis (transpose h) M N
H2 : forall (M N : Msg) (_ : synthesis (fun M0 N0 : Msg => h N0 M0) M N),\nsynthesis h N M
H1 : and\n (forall (M N : Msg) (_ : synthesis (transpose h) M N),\n transpose (synthesis h) M N)\n (forall (M N : Msg) (_ : transpose (synthesis h) M N),\n synthesis (transpose h) M N)
H0 : h N M
H : and (h N M)\n match N with\n | MNam _ => True\n | MEnc M' K =>\n match M with\n | MEnc N' L =>\n or (not (synthesis h M' N')) (not (synthesis h K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match M with\n | MPair N1 N2 =>\n or (not (synthesis h M1 N1)) (not (synthesis h M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match M with\n | Mop opN N' => or (not (eq opM opN)) (not (synthesis h M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
forall (_ : Nam) (_ : True), match M with | MNam _ | _ => True end
+++++
try tauto.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
intros M N.
unfold transpose in |- *.
unfold reduce in |- *.
split.
try tauto.
elim H.
intro.
generalize (synthesis_transpose_transpose_synthesis h).
unfold equal in |- *.
unfold inclusion in |- *.
intro.
elim H1.
intro.
intro.
unfold transpose in H2.
case N.
try tauto.

*****
H3 : forall (M N : Msg) (_ : transpose (synthesis h) M N),\nsynthesis (transpose h) M N
H2 : forall (M N : Msg) (_ : synthesis (fun M0 N0 : Msg => h N0 M0) M N),\nsynthesis h N M
H1 : and\n (forall (M N : Msg) (_ : synthesis (transpose h) M N),\n transpose (synthesis h) M N)\n (forall (M N : Msg) (_ : transpose (synthesis h) M N),\n synthesis (transpose h) M N)
H0 : h N M
H : and (h N M)\n match N with\n | MNam _ => True\n | MEnc M' K =>\n match M with\n | MEnc N' L =>\n or (not (synthesis h M' N')) (not (synthesis h K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match M with\n | MPair N1 N2 =>\n or (not (synthesis h M1 N1)) (not (synthesis h M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match M with\n | Mop opN N' => or (not (eq opM opN)) (not (synthesis h M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
forall (_ : Nam) (_ : True), match M with | MNam _ | _ => True end
+++++
case M.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
intros M N.
unfold transpose in |- *.
unfold reduce in |- *.
split.
try tauto.
elim H.
intro.
generalize (synthesis_transpose_transpose_synthesis h).
unfold equal in |- *.
unfold inclusion in |- *.
intro.
elim H1.
intro.
intro.
unfold transpose in H2.
case N.
try tauto.
case M.

*****
H3 : forall (M N : Msg) (_ : transpose (synthesis h) M N),\nsynthesis (transpose h) M N
H2 : forall (M N : Msg) (_ : synthesis (fun M0 N0 : Msg => h N0 M0) M N),\nsynthesis h N M
H1 : and\n (forall (M N : Msg) (_ : synthesis (transpose h) M N),\n transpose (synthesis h) M N)\n (forall (M N : Msg) (_ : transpose (synthesis h) M N),\n synthesis (transpose h) M N)
H0 : h N M
H : and (h N M)\n match N with\n | MNam _ => True\n | MEnc M' K =>\n match M with\n | MEnc N' L =>\n or (not (synthesis h M' N')) (not (synthesis h K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match M with\n | MPair N1 N2 =>\n or (not (synthesis h M1 N1)) (not (synthesis h M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match M with\n | Mop opN N' => or (not (eq opM opN)) (not (synthesis h M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
forall (_ : Nam) (_ : Nam) (_ : True), True
+++++
try tauto.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
intros M N.
unfold transpose in |- *.
unfold reduce in |- *.
split.
try tauto.
elim H.
intro.
generalize (synthesis_transpose_transpose_synthesis h).
unfold equal in |- *.
unfold inclusion in |- *.
intro.
elim H1.
intro.
intro.
unfold transpose in H2.
case N.
try tauto.
case M.

*****
H3 : forall (M N : Msg) (_ : transpose (synthesis h) M N),\nsynthesis (transpose h) M N
H2 : forall (M N : Msg) (_ : synthesis (fun M0 N0 : Msg => h N0 M0) M N),\nsynthesis h N M
H1 : and\n (forall (M N : Msg) (_ : synthesis (transpose h) M N),\n transpose (synthesis h) M N)\n (forall (M N : Msg) (_ : transpose (synthesis h) M N),\n synthesis (transpose h) M N)
H0 : h N M
H : and (h N M)\n match N with\n | MNam _ => True\n | MEnc M' K =>\n match M with\n | MEnc N' L =>\n or (not (synthesis h M' N')) (not (synthesis h K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match M with\n | MPair N1 N2 =>\n or (not (synthesis h M1 N1)) (not (synthesis h M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match M with\n | Mop opN N' => or (not (eq opM opN)) (not (synthesis h M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
forall (_ : Msg) (_ : Msg) (_ : Nam) (_ : True), True
+++++
try tauto.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
intros M N.
unfold transpose in |- *.
unfold reduce in |- *.
split.
try tauto.
elim H.
intro.
generalize (synthesis_transpose_transpose_synthesis h).
unfold equal in |- *.
unfold inclusion in |- *.
intro.
elim H1.
intro.
intro.
unfold transpose in H2.
case N.
try tauto.
case M.

*****
H3 : forall (M N : Msg) (_ : transpose (synthesis h) M N),\nsynthesis (transpose h) M N
H2 : forall (M N : Msg) (_ : synthesis (fun M0 N0 : Msg => h N0 M0) M N),\nsynthesis h N M
H1 : and\n (forall (M N : Msg) (_ : synthesis (transpose h) M N),\n transpose (synthesis h) M N)\n (forall (M N : Msg) (_ : transpose (synthesis h) M N),\n synthesis (transpose h) M N)
H0 : h N M
H : and (h N M)\n match N with\n | MNam _ => True\n | MEnc M' K =>\n match M with\n | MEnc N' L =>\n or (not (synthesis h M' N')) (not (synthesis h K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match M with\n | MPair N1 N2 =>\n or (not (synthesis h M1 N1)) (not (synthesis h M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match M with\n | Mop opN N' => or (not (eq opM opN)) (not (synthesis h M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
forall (_ : Msg) (_ : Msg) (_ : Nam) (_ : True), True
+++++
try tauto.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
intros M N.
unfold transpose in |- *.
unfold reduce in |- *.
split.
try tauto.
elim H.
intro.
generalize (synthesis_transpose_transpose_synthesis h).
unfold equal in |- *.
unfold inclusion in |- *.
intro.
elim H1.
intro.
intro.
unfold transpose in H2.
case N.
try tauto.
case M.

*****
H3 : forall (M N : Msg) (_ : transpose (synthesis h) M N),\nsynthesis (transpose h) M N
H2 : forall (M N : Msg) (_ : synthesis (fun M0 N0 : Msg => h N0 M0) M N),\nsynthesis h N M
H1 : and\n (forall (M N : Msg) (_ : synthesis (transpose h) M N),\n transpose (synthesis h) M N)\n (forall (M N : Msg) (_ : transpose (synthesis h) M N),\n synthesis (transpose h) M N)
H0 : h N M
H : and (h N M)\n match N with\n | MNam _ => True\n | MEnc M' K =>\n match M with\n | MEnc N' L =>\n or (not (synthesis h M' N')) (not (synthesis h K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match M with\n | MPair N1 N2 =>\n or (not (synthesis h M1 N1)) (not (synthesis h M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match M with\n | Mop opN N' => or (not (eq opM opN)) (not (synthesis h M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
forall (_ : op) (_ : Msg) (_ : Nam) (_ : True), True
+++++
try tauto.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
intros M N.
unfold transpose in |- *.
unfold reduce in |- *.
split.
try tauto.
elim H.
intro.
generalize (synthesis_transpose_transpose_synthesis h).
unfold equal in |- *.
unfold inclusion in |- *.
intro.
elim H1.
intro.
intro.
unfold transpose in H2.
case N.

*****
H3 : forall (M N : Msg) (_ : transpose (synthesis h) M N),\nsynthesis (transpose h) M N
H2 : forall (M N : Msg) (_ : synthesis (fun M0 N0 : Msg => h N0 M0) M N),\nsynthesis h N M
H1 : and\n (forall (M N : Msg) (_ : synthesis (transpose h) M N),\n transpose (synthesis h) M N)\n (forall (M N : Msg) (_ : transpose (synthesis h) M N),\n synthesis (transpose h) M N)
H0 : h N M
H : and (h N M)\n match N with\n | MNam _ => True\n | MEnc M' K =>\n match M with\n | MEnc N' L =>\n or (not (synthesis h M' N')) (not (synthesis h K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match M with\n | MPair N1 N2 =>\n or (not (synthesis h M1 N1)) (not (synthesis h M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match M with\n | Mop opN N' => or (not (eq opM opN)) (not (synthesis h M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
forall (m m0 : Msg) (_ : match M with | MEnc N' L => or (not (synthesis h m N')) (not (synthesis h m0 L)) | _ => True end), match M with | MEnc M' K => or (not (synthesis (fun M N : Msg => h N M) M' m)) (not (synthesis (fun M N : Msg => h N M) K m0)) | _ => True end
+++++
try tauto.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
intros M N.
unfold transpose in |- *.
unfold reduce in |- *.
split.
try tauto.
elim H.
intro.
generalize (synthesis_transpose_transpose_synthesis h).
unfold equal in |- *.
unfold inclusion in |- *.
intro.
elim H1.
intro.
intro.
unfold transpose in H2.
case N.
try tauto.

*****
H3 : forall (M N : Msg) (_ : transpose (synthesis h) M N),\nsynthesis (transpose h) M N
H2 : forall (M N : Msg) (_ : synthesis (fun M0 N0 : Msg => h N0 M0) M N),\nsynthesis h N M
H1 : and\n (forall (M N : Msg) (_ : synthesis (transpose h) M N),\n transpose (synthesis h) M N)\n (forall (M N : Msg) (_ : transpose (synthesis h) M N),\n synthesis (transpose h) M N)
H0 : h N M
H : and (h N M)\n match N with\n | MNam _ => True\n | MEnc M' K =>\n match M with\n | MEnc N' L =>\n or (not (synthesis h M' N')) (not (synthesis h K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match M with\n | MPair N1 N2 =>\n or (not (synthesis h M1 N1)) (not (synthesis h M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match M with\n | Mop opN N' => or (not (eq opM opN)) (not (synthesis h M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
forall (m m0 : Msg) (_ : match M with | MEnc N' L => or (not (synthesis h m N')) (not (synthesis h m0 L)) | _ => True end), match M with | MEnc M' K => or (not (synthesis (fun M N : Msg => h N M) M' m)) (not (synthesis (fun M N : Msg => h N M) K m0)) | _ => True end
+++++
case M.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
intros M N.
unfold transpose in |- *.
unfold reduce in |- *.
split.
try tauto.
elim H.
intro.
generalize (synthesis_transpose_transpose_synthesis h).
unfold equal in |- *.
unfold inclusion in |- *.
intro.
elim H1.
intro.
intro.
unfold transpose in H2.
case N.
try tauto.
case M.

*****
H3 : forall (M N : Msg) (_ : transpose (synthesis h) M N),\nsynthesis (transpose h) M N
H2 : forall (M N : Msg) (_ : synthesis (fun M0 N0 : Msg => h N0 M0) M N),\nsynthesis h N M
H1 : and\n (forall (M N : Msg) (_ : synthesis (transpose h) M N),\n transpose (synthesis h) M N)\n (forall (M N : Msg) (_ : transpose (synthesis h) M N),\n synthesis (transpose h) M N)
H0 : h N M
H : and (h N M)\n match N with\n | MNam _ => True\n | MEnc M' K =>\n match M with\n | MEnc N' L =>\n or (not (synthesis h M' N')) (not (synthesis h K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match M with\n | MPair N1 N2 =>\n or (not (synthesis h M1 N1)) (not (synthesis h M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match M with\n | Mop opN N' => or (not (eq opM opN)) (not (synthesis h M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
forall (_ : Nam) (_ : Msg) (_ : Msg) (_ : True), True
+++++
try tauto.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
intros M N.
unfold transpose in |- *.
unfold reduce in |- *.
split.
try tauto.
elim H.
intro.
generalize (synthesis_transpose_transpose_synthesis h).
unfold equal in |- *.
unfold inclusion in |- *.
intro.
elim H1.
intro.
intro.
unfold transpose in H2.
case N.
try tauto.
case M.

*****
H3 : forall (M N : Msg) (_ : transpose (synthesis h) M N),\nsynthesis (transpose h) M N
H2 : forall (M N : Msg) (_ : synthesis (fun M0 N0 : Msg => h N0 M0) M N),\nsynthesis h N M
H1 : and\n (forall (M N : Msg) (_ : synthesis (transpose h) M N),\n transpose (synthesis h) M N)\n (forall (M N : Msg) (_ : transpose (synthesis h) M N),\n synthesis (transpose h) M N)
H0 : h N M
H : and (h N M)\n match N with\n | MNam _ => True\n | MEnc M' K =>\n match M with\n | MEnc N' L =>\n or (not (synthesis h M' N')) (not (synthesis h K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match M with\n | MPair N1 N2 =>\n or (not (synthesis h M1 N1)) (not (synthesis h M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match M with\n | Mop opN N' => or (not (eq opM opN)) (not (synthesis h M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
forall (m m0 m1 m2 : Msg) (_ : or (not (synthesis h m1 m)) (not (synthesis h m2 m0))), or (not (synthesis (fun M N : Msg => h N M) m m1)) (not (synthesis (fun M N : Msg => h N M) m0 m2))
+++++
try tauto.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
intros M N.
unfold transpose in |- *.
unfold reduce in |- *.
split.
try tauto.
elim H.
intro.
generalize (synthesis_transpose_transpose_synthesis h).
unfold equal in |- *.
unfold inclusion in |- *.
intro.
elim H1.
intro.
intro.
unfold transpose in H2.
case N.
try tauto.
case M.
try tauto.

*****
H3 : forall (M N : Msg) (_ : transpose (synthesis h) M N),\nsynthesis (transpose h) M N
H2 : forall (M N : Msg) (_ : synthesis (fun M0 N0 : Msg => h N0 M0) M N),\nsynthesis h N M
H1 : and\n (forall (M N : Msg) (_ : synthesis (transpose h) M N),\n transpose (synthesis h) M N)\n (forall (M N : Msg) (_ : transpose (synthesis h) M N),\n synthesis (transpose h) M N)
H0 : h N M
H : and (h N M)\n match N with\n | MNam _ => True\n | MEnc M' K =>\n match M with\n | MEnc N' L =>\n or (not (synthesis h M' N')) (not (synthesis h K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match M with\n | MPair N1 N2 =>\n or (not (synthesis h M1 N1)) (not (synthesis h M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match M with\n | Mop opN N' => or (not (eq opM opN)) (not (synthesis h M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
forall (m m0 m1 m2 : Msg) (_ : or (not (synthesis h m1 m)) (not (synthesis h m2 m0))), or (not (synthesis (fun M N : Msg => h N M) m m1)) (not (synthesis (fun M N : Msg => h N M) m0 m2))
+++++
intros.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
intros M N.
unfold transpose in |- *.
unfold reduce in |- *.
split.
try tauto.
elim H.
intro.
generalize (synthesis_transpose_transpose_synthesis h).
unfold equal in |- *.
unfold inclusion in |- *.
intro.
elim H1.
intro.
intro.
unfold transpose in H2.
case N.
try tauto.
case M.
try tauto.
intros.

*****
H4 : or (not (synthesis h m1 m)) (not (synthesis h m2 m0))
m,m0,m1,m2 : Msg
H3 : forall (M N : Msg) (_ : transpose (synthesis h) M N),\nsynthesis (transpose h) M N
H2 : forall (M N : Msg) (_ : synthesis (fun M0 N0 : Msg => h N0 M0) M N),\nsynthesis h N M
H1 : and\n (forall (M N : Msg) (_ : synthesis (transpose h) M N),\n transpose (synthesis h) M N)\n (forall (M N : Msg) (_ : transpose (synthesis h) M N),\n synthesis (transpose h) M N)
H0 : h N M
H : and (h N M)\n match N with\n | MNam _ => True\n | MEnc M' K =>\n match M with\n | MEnc N' L =>\n or (not (synthesis h M' N')) (not (synthesis h K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match M with\n | MPair N1 N2 =>\n or (not (synthesis h M1 N1)) (not (synthesis h M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match M with\n | Mop opN N' => or (not (eq opM opN)) (not (synthesis h M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
or (not (synthesis (fun M N : Msg => h N M) m m1)) (not (synthesis (fun M N : Msg => h N M) m0 m2))
+++++
case H4.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
intros M N.
unfold transpose in |- *.
unfold reduce in |- *.
split.
try tauto.
elim H.
intro.
generalize (synthesis_transpose_transpose_synthesis h).
unfold equal in |- *.
unfold inclusion in |- *.
intro.
elim H1.
intro.
intro.
unfold transpose in H2.
case N.
try tauto.
case M.
try tauto.
intros.
case H4.

*****
H4 : or (not (synthesis h m1 m)) (not (synthesis h m2 m0))
m,m0,m1,m2 : Msg
H3 : forall (M N : Msg) (_ : transpose (synthesis h) M N),\nsynthesis (transpose h) M N
H2 : forall (M N : Msg) (_ : synthesis (fun M0 N0 : Msg => h N0 M0) M N),\nsynthesis h N M
H1 : and\n (forall (M N : Msg) (_ : synthesis (transpose h) M N),\n transpose (synthesis h) M N)\n (forall (M N : Msg) (_ : transpose (synthesis h) M N),\n synthesis (transpose h) M N)
H0 : h N M
H : and (h N M)\n match N with\n | MNam _ => True\n | MEnc M' K =>\n match M with\n | MEnc N' L =>\n or (not (synthesis h M' N')) (not (synthesis h K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match M with\n | MPair N1 N2 =>\n or (not (synthesis h M1 N1)) (not (synthesis h M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match M with\n | Mop opN N' => or (not (eq opM opN)) (not (synthesis h M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
forall _ : not (synthesis h m1 m), or (not (synthesis (fun M N : Msg => h N M) m m1)) (not (synthesis (fun M N : Msg => h N M) m0 m2))
+++++
left.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
intros M N.
unfold transpose in |- *.
unfold reduce in |- *.
split.
try tauto.
elim H.
intro.
generalize (synthesis_transpose_transpose_synthesis h).
unfold equal in |- *.
unfold inclusion in |- *.
intro.
elim H1.
intro.
intro.
unfold transpose in H2.
case N.
try tauto.
case M.
try tauto.
intros.
case H4.
left.

*****
H5 : not (synthesis h m1 m)
H4 : or (not (synthesis h m1 m)) (not (synthesis h m2 m0))
m,m0,m1,m2 : Msg
H3 : forall (M N : Msg) (_ : transpose (synthesis h) M N),\nsynthesis (transpose h) M N
H2 : forall (M N : Msg) (_ : synthesis (fun M0 N0 : Msg => h N0 M0) M N),\nsynthesis h N M
H1 : and\n (forall (M N : Msg) (_ : synthesis (transpose h) M N),\n transpose (synthesis h) M N)\n (forall (M N : Msg) (_ : transpose (synthesis h) M N),\n synthesis (transpose h) M N)
H0 : h N M
H : and (h N M)\n match N with\n | MNam _ => True\n | MEnc M' K =>\n match M with\n | MEnc N' L =>\n or (not (synthesis h M' N')) (not (synthesis h K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match M with\n | MPair N1 N2 =>\n or (not (synthesis h M1 N1)) (not (synthesis h M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match M with\n | Mop opN N' => or (not (eq opM opN)) (not (synthesis h M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
not (synthesis (fun M N : Msg => h N M) m m1)
+++++
red in |- *.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
intros M N.
unfold transpose in |- *.
unfold reduce in |- *.
split.
try tauto.
elim H.
intro.
generalize (synthesis_transpose_transpose_synthesis h).
unfold equal in |- *.
unfold inclusion in |- *.
intro.
elim H1.
intro.
intro.
unfold transpose in H2.
case N.
try tauto.
case M.
try tauto.
intros.
case H4.
left.
red in |- *.

*****
H5 : not (synthesis h m1 m)
H4 : or (not (synthesis h m1 m)) (not (synthesis h m2 m0))
m,m0,m1,m2 : Msg
H3 : forall (M N : Msg) (_ : transpose (synthesis h) M N),\nsynthesis (transpose h) M N
H2 : forall (M N : Msg) (_ : synthesis (fun M0 N0 : Msg => h N0 M0) M N),\nsynthesis h N M
H1 : and\n (forall (M N : Msg) (_ : synthesis (transpose h) M N),\n transpose (synthesis h) M N)\n (forall (M N : Msg) (_ : transpose (synthesis h) M N),\n synthesis (transpose h) M N)
H0 : h N M
H : and (h N M)\n match N with\n | MNam _ => True\n | MEnc M' K =>\n match M with\n | MEnc N' L =>\n or (not (synthesis h M' N')) (not (synthesis h K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match M with\n | MPair N1 N2 =>\n or (not (synthesis h M1 N1)) (not (synthesis h M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match M with\n | Mop opN N' => or (not (eq opM opN)) (not (synthesis h M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
forall _ : synthesis (fun M N : Msg => h N M) m m1, False
+++++
intro.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
intros M N.
unfold transpose in |- *.
unfold reduce in |- *.
split.
try tauto.
elim H.
intro.
generalize (synthesis_transpose_transpose_synthesis h).
unfold equal in |- *.
unfold inclusion in |- *.
intro.
elim H1.
intro.
intro.
unfold transpose in H2.
case N.
try tauto.
case M.
try tauto.
intros.
case H4.
left.
red in |- *.
intro.

*****
H6 : synthesis (fun M N : Msg => h N M) m m1
H5 : not (synthesis h m1 m)
H4 : or (not (synthesis h m1 m)) (not (synthesis h m2 m0))
m,m0,m1,m2 : Msg
H3 : forall (M N : Msg) (_ : transpose (synthesis h) M N),\nsynthesis (transpose h) M N
H2 : forall (M N : Msg) (_ : synthesis (fun M0 N0 : Msg => h N0 M0) M N),\nsynthesis h N M
H1 : and\n (forall (M N : Msg) (_ : synthesis (transpose h) M N),\n transpose (synthesis h) M N)\n (forall (M N : Msg) (_ : transpose (synthesis h) M N),\n synthesis (transpose h) M N)
H0 : h N M
H : and (h N M)\n match N with\n | MNam _ => True\n | MEnc M' K =>\n match M with\n | MEnc N' L =>\n or (not (synthesis h M' N')) (not (synthesis h K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match M with\n | MPair N1 N2 =>\n or (not (synthesis h M1 N1)) (not (synthesis h M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match M with\n | Mop opN N' => or (not (eq opM opN)) (not (synthesis h M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
False
+++++
apply H5.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
intros M N.
unfold transpose in |- *.
unfold reduce in |- *.
split.
try tauto.
elim H.
intro.
generalize (synthesis_transpose_transpose_synthesis h).
unfold equal in |- *.
unfold inclusion in |- *.
intro.
elim H1.
intro.
intro.
unfold transpose in H2.
case N.
try tauto.
case M.
try tauto.
intros.
case H4.
left.
red in |- *.
intro.
apply H5.

*****
H6 : synthesis (fun M N : Msg => h N M) m m1
H5 : not (synthesis h m1 m)
H4 : or (not (synthesis h m1 m)) (not (synthesis h m2 m0))
m,m0,m1,m2 : Msg
H3 : forall (M N : Msg) (_ : transpose (synthesis h) M N),\nsynthesis (transpose h) M N
H2 : forall (M N : Msg) (_ : synthesis (fun M0 N0 : Msg => h N0 M0) M N),\nsynthesis h N M
H1 : and\n (forall (M N : Msg) (_ : synthesis (transpose h) M N),\n transpose (synthesis h) M N)\n (forall (M N : Msg) (_ : transpose (synthesis h) M N),\n synthesis (transpose h) M N)
H0 : h N M
H : and (h N M)\n match N with\n | MNam _ => True\n | MEnc M' K =>\n match M with\n | MEnc N' L =>\n or (not (synthesis h M' N')) (not (synthesis h K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match M with\n | MPair N1 N2 =>\n or (not (synthesis h M1 N1)) (not (synthesis h M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match M with\n | Mop opN N' => or (not (eq opM opN)) (not (synthesis h M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
synthesis h m1 m
+++++
apply H2.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
intros M N.
unfold transpose in |- *.
unfold reduce in |- *.
split.
try tauto.
elim H.
intro.
generalize (synthesis_transpose_transpose_synthesis h).
unfold equal in |- *.
unfold inclusion in |- *.
intro.
elim H1.
intro.
intro.
unfold transpose in H2.
case N.
try tauto.
case M.
try tauto.
intros.
case H4.
left.
red in |- *.
intro.
apply H5.
apply H2.

*****
H6 : synthesis (fun M N : Msg => h N M) m m1
H5 : not (synthesis h m1 m)
H4 : or (not (synthesis h m1 m)) (not (synthesis h m2 m0))
m,m0,m1,m2 : Msg
H3 : forall (M N : Msg) (_ : transpose (synthesis h) M N),\nsynthesis (transpose h) M N
H2 : forall (M N : Msg) (_ : synthesis (fun M0 N0 : Msg => h N0 M0) M N),\nsynthesis h N M
H1 : and\n (forall (M N : Msg) (_ : synthesis (transpose h) M N),\n transpose (synthesis h) M N)\n (forall (M N : Msg) (_ : transpose (synthesis h) M N),\n synthesis (transpose h) M N)
H0 : h N M
H : and (h N M)\n match N with\n | MNam _ => True\n | MEnc M' K =>\n match M with\n | MEnc N' L =>\n or (not (synthesis h M' N')) (not (synthesis h K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match M with\n | MPair N1 N2 =>\n or (not (synthesis h M1 N1)) (not (synthesis h M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match M with\n | Mop opN N' => or (not (eq opM opN)) (not (synthesis h M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
synthesis (fun M N : Msg => h N M) m m1
+++++
trivial.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
intros M N.
unfold transpose in |- *.
unfold reduce in |- *.
split.
try tauto.
elim H.
intro.
generalize (synthesis_transpose_transpose_synthesis h).
unfold equal in |- *.
unfold inclusion in |- *.
intro.
elim H1.
intro.
intro.
unfold transpose in H2.
case N.
try tauto.
case M.
try tauto.
intros.
case H4.

*****
H4 : or (not (synthesis h m1 m)) (not (synthesis h m2 m0))
m,m0,m1,m2 : Msg
H3 : forall (M N : Msg) (_ : transpose (synthesis h) M N),\nsynthesis (transpose h) M N
H2 : forall (M N : Msg) (_ : synthesis (fun M0 N0 : Msg => h N0 M0) M N),\nsynthesis h N M
H1 : and\n (forall (M N : Msg) (_ : synthesis (transpose h) M N),\n transpose (synthesis h) M N)\n (forall (M N : Msg) (_ : transpose (synthesis h) M N),\n synthesis (transpose h) M N)
H0 : h N M
H : and (h N M)\n match N with\n | MNam _ => True\n | MEnc M' K =>\n match M with\n | MEnc N' L =>\n or (not (synthesis h M' N')) (not (synthesis h K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match M with\n | MPair N1 N2 =>\n or (not (synthesis h M1 N1)) (not (synthesis h M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match M with\n | Mop opN N' => or (not (eq opM opN)) (not (synthesis h M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
forall _ : not (synthesis h m2 m0), or (not (synthesis (fun M N : Msg => h N M) m m1)) (not (synthesis (fun M N : Msg => h N M) m0 m2))
+++++
right.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
intros M N.
unfold transpose in |- *.
unfold reduce in |- *.
split.
try tauto.
elim H.
intro.
generalize (synthesis_transpose_transpose_synthesis h).
unfold equal in |- *.
unfold inclusion in |- *.
intro.
elim H1.
intro.
intro.
unfold transpose in H2.
case N.
try tauto.
case M.
try tauto.
intros.
case H4.
right.

*****
H5 : not (synthesis h m2 m0)
H4 : or (not (synthesis h m1 m)) (not (synthesis h m2 m0))
m,m0,m1,m2 : Msg
H3 : forall (M N : Msg) (_ : transpose (synthesis h) M N),\nsynthesis (transpose h) M N
H2 : forall (M N : Msg) (_ : synthesis (fun M0 N0 : Msg => h N0 M0) M N),\nsynthesis h N M
H1 : and\n (forall (M N : Msg) (_ : synthesis (transpose h) M N),\n transpose (synthesis h) M N)\n (forall (M N : Msg) (_ : transpose (synthesis h) M N),\n synthesis (transpose h) M N)
H0 : h N M
H : and (h N M)\n match N with\n | MNam _ => True\n | MEnc M' K =>\n match M with\n | MEnc N' L =>\n or (not (synthesis h M' N')) (not (synthesis h K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match M with\n | MPair N1 N2 =>\n or (not (synthesis h M1 N1)) (not (synthesis h M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match M with\n | Mop opN N' => or (not (eq opM opN)) (not (synthesis h M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
not (synthesis (fun M N : Msg => h N M) m0 m2)
+++++
red in |- *.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
intros M N.
unfold transpose in |- *.
unfold reduce in |- *.
split.
try tauto.
elim H.
intro.
generalize (synthesis_transpose_transpose_synthesis h).
unfold equal in |- *.
unfold inclusion in |- *.
intro.
elim H1.
intro.
intro.
unfold transpose in H2.
case N.
try tauto.
case M.
try tauto.
intros.
case H4.
right.
red in |- *.

*****
H5 : not (synthesis h m2 m0)
H4 : or (not (synthesis h m1 m)) (not (synthesis h m2 m0))
m,m0,m1,m2 : Msg
H3 : forall (M N : Msg) (_ : transpose (synthesis h) M N),\nsynthesis (transpose h) M N
H2 : forall (M N : Msg) (_ : synthesis (fun M0 N0 : Msg => h N0 M0) M N),\nsynthesis h N M
H1 : and\n (forall (M N : Msg) (_ : synthesis (transpose h) M N),\n transpose (synthesis h) M N)\n (forall (M N : Msg) (_ : transpose (synthesis h) M N),\n synthesis (transpose h) M N)
H0 : h N M
H : and (h N M)\n match N with\n | MNam _ => True\n | MEnc M' K =>\n match M with\n | MEnc N' L =>\n or (not (synthesis h M' N')) (not (synthesis h K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match M with\n | MPair N1 N2 =>\n or (not (synthesis h M1 N1)) (not (synthesis h M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match M with\n | Mop opN N' => or (not (eq opM opN)) (not (synthesis h M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
forall _ : synthesis (fun M N : Msg => h N M) m0 m2, False
+++++
intro.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
intros M N.
unfold transpose in |- *.
unfold reduce in |- *.
split.
try tauto.
elim H.
intro.
generalize (synthesis_transpose_transpose_synthesis h).
unfold equal in |- *.
unfold inclusion in |- *.
intro.
elim H1.
intro.
intro.
unfold transpose in H2.
case N.
try tauto.
case M.
try tauto.
intros.
case H4.
right.
red in |- *.
intro.

*****
H6 : synthesis (fun M N : Msg => h N M) m0 m2
H5 : not (synthesis h m2 m0)
H4 : or (not (synthesis h m1 m)) (not (synthesis h m2 m0))
m,m0,m1,m2 : Msg
H3 : forall (M N : Msg) (_ : transpose (synthesis h) M N),\nsynthesis (transpose h) M N
H2 : forall (M N : Msg) (_ : synthesis (fun M0 N0 : Msg => h N0 M0) M N),\nsynthesis h N M
H1 : and\n (forall (M N : Msg) (_ : synthesis (transpose h) M N),\n transpose (synthesis h) M N)\n (forall (M N : Msg) (_ : transpose (synthesis h) M N),\n synthesis (transpose h) M N)
H0 : h N M
H : and (h N M)\n match N with\n | MNam _ => True\n | MEnc M' K =>\n match M with\n | MEnc N' L =>\n or (not (synthesis h M' N')) (not (synthesis h K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match M with\n | MPair N1 N2 =>\n or (not (synthesis h M1 N1)) (not (synthesis h M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match M with\n | Mop opN N' => or (not (eq opM opN)) (not (synthesis h M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
False
+++++
apply H5.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
intros M N.
unfold transpose in |- *.
unfold reduce in |- *.
split.
try tauto.
elim H.
intro.
generalize (synthesis_transpose_transpose_synthesis h).
unfold equal in |- *.
unfold inclusion in |- *.
intro.
elim H1.
intro.
intro.
unfold transpose in H2.
case N.
try tauto.
case M.
try tauto.
intros.
case H4.
right.
red in |- *.
intro.
apply H5.

*****
H6 : synthesis (fun M N : Msg => h N M) m0 m2
H5 : not (synthesis h m2 m0)
H4 : or (not (synthesis h m1 m)) (not (synthesis h m2 m0))
m,m0,m1,m2 : Msg
H3 : forall (M N : Msg) (_ : transpose (synthesis h) M N),\nsynthesis (transpose h) M N
H2 : forall (M N : Msg) (_ : synthesis (fun M0 N0 : Msg => h N0 M0) M N),\nsynthesis h N M
H1 : and\n (forall (M N : Msg) (_ : synthesis (transpose h) M N),\n transpose (synthesis h) M N)\n (forall (M N : Msg) (_ : transpose (synthesis h) M N),\n synthesis (transpose h) M N)
H0 : h N M
H : and (h N M)\n match N with\n | MNam _ => True\n | MEnc M' K =>\n match M with\n | MEnc N' L =>\n or (not (synthesis h M' N')) (not (synthesis h K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match M with\n | MPair N1 N2 =>\n or (not (synthesis h M1 N1)) (not (synthesis h M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match M with\n | Mop opN N' => or (not (eq opM opN)) (not (synthesis h M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
synthesis h m2 m0
+++++
auto.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
intros M N.
unfold transpose in |- *.
unfold reduce in |- *.
split.
try tauto.
elim H.
intro.
generalize (synthesis_transpose_transpose_synthesis h).
unfold equal in |- *.
unfold inclusion in |- *.
intro.
elim H1.
intro.
intro.
unfold transpose in H2.
case N.
try tauto.
case M.

*****
H3 : forall (M N : Msg) (_ : transpose (synthesis h) M N),\nsynthesis (transpose h) M N
H2 : forall (M N : Msg) (_ : synthesis (fun M0 N0 : Msg => h N0 M0) M N),\nsynthesis h N M
H1 : and\n (forall (M N : Msg) (_ : synthesis (transpose h) M N),\n transpose (synthesis h) M N)\n (forall (M N : Msg) (_ : transpose (synthesis h) M N),\n synthesis (transpose h) M N)
H0 : h N M
H : and (h N M)\n match N with\n | MNam _ => True\n | MEnc M' K =>\n match M with\n | MEnc N' L =>\n or (not (synthesis h M' N')) (not (synthesis h K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match M with\n | MPair N1 N2 =>\n or (not (synthesis h M1 N1)) (not (synthesis h M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match M with\n | Mop opN N' => or (not (eq opM opN)) (not (synthesis h M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
forall (_ : Msg) (_ : Msg) (_ : Msg) (_ : Msg) (_ : True), True
+++++
try tauto.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
intros M N.
unfold transpose in |- *.
unfold reduce in |- *.
split.
try tauto.
elim H.
intro.
generalize (synthesis_transpose_transpose_synthesis h).
unfold equal in |- *.
unfold inclusion in |- *.
intro.
elim H1.
intro.
intro.
unfold transpose in H2.
case N.
try tauto.
case M.

*****
H3 : forall (M N : Msg) (_ : transpose (synthesis h) M N),\nsynthesis (transpose h) M N
H2 : forall (M N : Msg) (_ : synthesis (fun M0 N0 : Msg => h N0 M0) M N),\nsynthesis h N M
H1 : and\n (forall (M N : Msg) (_ : synthesis (transpose h) M N),\n transpose (synthesis h) M N)\n (forall (M N : Msg) (_ : transpose (synthesis h) M N),\n synthesis (transpose h) M N)
H0 : h N M
H : and (h N M)\n match N with\n | MNam _ => True\n | MEnc M' K =>\n match M with\n | MEnc N' L =>\n or (not (synthesis h M' N')) (not (synthesis h K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match M with\n | MPair N1 N2 =>\n or (not (synthesis h M1 N1)) (not (synthesis h M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match M with\n | Mop opN N' => or (not (eq opM opN)) (not (synthesis h M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
forall (_ : op) (_ : Msg) (_ : Msg) (_ : Msg) (_ : True), True
+++++
try tauto.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
intros M N.
unfold transpose in |- *.
unfold reduce in |- *.
split.
try tauto.
elim H.
intro.
generalize (synthesis_transpose_transpose_synthesis h).
unfold equal in |- *.
unfold inclusion in |- *.
intro.
elim H1.
intro.
intro.
unfold transpose in H2.
case N.

*****
H3 : forall (M N : Msg) (_ : transpose (synthesis h) M N),\nsynthesis (transpose h) M N
H2 : forall (M N : Msg) (_ : synthesis (fun M0 N0 : Msg => h N0 M0) M N),\nsynthesis h N M
H1 : and\n (forall (M N : Msg) (_ : synthesis (transpose h) M N),\n transpose (synthesis h) M N)\n (forall (M N : Msg) (_ : transpose (synthesis h) M N),\n synthesis (transpose h) M N)
H0 : h N M
H : and (h N M)\n match N with\n | MNam _ => True\n | MEnc M' K =>\n match M with\n | MEnc N' L =>\n or (not (synthesis h M' N')) (not (synthesis h K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match M with\n | MPair N1 N2 =>\n or (not (synthesis h M1 N1)) (not (synthesis h M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match M with\n | Mop opN N' => or (not (eq opM opN)) (not (synthesis h M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
forall (m m0 : Msg) (_ : match M with | MPair N1 N2 => or (not (synthesis h m N1)) (not (synthesis h m0 N2)) | _ => True end), match M with | MPair M1 M2 => or (not (synthesis (fun M N : Msg => h N M) M1 m)) (not (synthesis (fun M N : Msg => h N M) M2 m0)) | _ => True end
+++++
try tauto.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
intros M N.
unfold transpose in |- *.
unfold reduce in |- *.
split.
try tauto.
elim H.
intro.
generalize (synthesis_transpose_transpose_synthesis h).
unfold equal in |- *.
unfold inclusion in |- *.
intro.
elim H1.
intro.
intro.
unfold transpose in H2.
case N.
try tauto.

*****
H3 : forall (M N : Msg) (_ : transpose (synthesis h) M N),\nsynthesis (transpose h) M N
H2 : forall (M N : Msg) (_ : synthesis (fun M0 N0 : Msg => h N0 M0) M N),\nsynthesis h N M
H1 : and\n (forall (M N : Msg) (_ : synthesis (transpose h) M N),\n transpose (synthesis h) M N)\n (forall (M N : Msg) (_ : transpose (synthesis h) M N),\n synthesis (transpose h) M N)
H0 : h N M
H : and (h N M)\n match N with\n | MNam _ => True\n | MEnc M' K =>\n match M with\n | MEnc N' L =>\n or (not (synthesis h M' N')) (not (synthesis h K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match M with\n | MPair N1 N2 =>\n or (not (synthesis h M1 N1)) (not (synthesis h M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match M with\n | Mop opN N' => or (not (eq opM opN)) (not (synthesis h M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
forall (m m0 : Msg) (_ : match M with | MPair N1 N2 => or (not (synthesis h m N1)) (not (synthesis h m0 N2)) | _ => True end), match M with | MPair M1 M2 => or (not (synthesis (fun M N : Msg => h N M) M1 m)) (not (synthesis (fun M N : Msg => h N M) M2 m0)) | _ => True end
+++++
case M.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
intros M N.
unfold transpose in |- *.
unfold reduce in |- *.
split.
try tauto.
elim H.
intro.
generalize (synthesis_transpose_transpose_synthesis h).
unfold equal in |- *.
unfold inclusion in |- *.
intro.
elim H1.
intro.
intro.
unfold transpose in H2.
case N.
try tauto.
case M.

*****
H3 : forall (M N : Msg) (_ : transpose (synthesis h) M N),\nsynthesis (transpose h) M N
H2 : forall (M N : Msg) (_ : synthesis (fun M0 N0 : Msg => h N0 M0) M N),\nsynthesis h N M
H1 : and\n (forall (M N : Msg) (_ : synthesis (transpose h) M N),\n transpose (synthesis h) M N)\n (forall (M N : Msg) (_ : transpose (synthesis h) M N),\n synthesis (transpose h) M N)
H0 : h N M
H : and (h N M)\n match N with\n | MNam _ => True\n | MEnc M' K =>\n match M with\n | MEnc N' L =>\n or (not (synthesis h M' N')) (not (synthesis h K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match M with\n | MPair N1 N2 =>\n or (not (synthesis h M1 N1)) (not (synthesis h M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match M with\n | Mop opN N' => or (not (eq opM opN)) (not (synthesis h M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
forall (_ : Nam) (_ : Msg) (_ : Msg) (_ : True), True
+++++
try tauto.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
intros M N.
unfold transpose in |- *.
unfold reduce in |- *.
split.
try tauto.
elim H.
intro.
generalize (synthesis_transpose_transpose_synthesis h).
unfold equal in |- *.
unfold inclusion in |- *.
intro.
elim H1.
intro.
intro.
unfold transpose in H2.
case N.
try tauto.
case M.

*****
H3 : forall (M N : Msg) (_ : transpose (synthesis h) M N),\nsynthesis (transpose h) M N
H2 : forall (M N : Msg) (_ : synthesis (fun M0 N0 : Msg => h N0 M0) M N),\nsynthesis h N M
H1 : and\n (forall (M N : Msg) (_ : synthesis (transpose h) M N),\n transpose (synthesis h) M N)\n (forall (M N : Msg) (_ : transpose (synthesis h) M N),\n synthesis (transpose h) M N)
H0 : h N M
H : and (h N M)\n match N with\n | MNam _ => True\n | MEnc M' K =>\n match M with\n | MEnc N' L =>\n or (not (synthesis h M' N')) (not (synthesis h K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match M with\n | MPair N1 N2 =>\n or (not (synthesis h M1 N1)) (not (synthesis h M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match M with\n | Mop opN N' => or (not (eq opM opN)) (not (synthesis h M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
forall (_ : Msg) (_ : Msg) (_ : Msg) (_ : Msg) (_ : True), True
+++++
try tauto.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
intros M N.
unfold transpose in |- *.
unfold reduce in |- *.
split.
try tauto.
elim H.
intro.
generalize (synthesis_transpose_transpose_synthesis h).
unfold equal in |- *.
unfold inclusion in |- *.
intro.
elim H1.
intro.
intro.
unfold transpose in H2.
case N.
try tauto.
case M.

*****
H3 : forall (M N : Msg) (_ : transpose (synthesis h) M N),\nsynthesis (transpose h) M N
H2 : forall (M N : Msg) (_ : synthesis (fun M0 N0 : Msg => h N0 M0) M N),\nsynthesis h N M
H1 : and\n (forall (M N : Msg) (_ : synthesis (transpose h) M N),\n transpose (synthesis h) M N)\n (forall (M N : Msg) (_ : transpose (synthesis h) M N),\n synthesis (transpose h) M N)
H0 : h N M
H : and (h N M)\n match N with\n | MNam _ => True\n | MEnc M' K =>\n match M with\n | MEnc N' L =>\n or (not (synthesis h M' N')) (not (synthesis h K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match M with\n | MPair N1 N2 =>\n or (not (synthesis h M1 N1)) (not (synthesis h M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match M with\n | Mop opN N' => or (not (eq opM opN)) (not (synthesis h M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
forall (m m0 m1 m2 : Msg) (_ : or (not (synthesis h m1 m)) (not (synthesis h m2 m0))), or (not (synthesis (fun M N : Msg => h N M) m m1)) (not (synthesis (fun M N : Msg => h N M) m0 m2))
+++++
try tauto.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
intros M N.
unfold transpose in |- *.
unfold reduce in |- *.
split.
try tauto.
elim H.
intro.
generalize (synthesis_transpose_transpose_synthesis h).
unfold equal in |- *.
unfold inclusion in |- *.
intro.
elim H1.
intro.
intro.
unfold transpose in H2.
case N.
try tauto.
case M.
try tauto.

*****
H3 : forall (M N : Msg) (_ : transpose (synthesis h) M N),\nsynthesis (transpose h) M N
H2 : forall (M N : Msg) (_ : synthesis (fun M0 N0 : Msg => h N0 M0) M N),\nsynthesis h N M
H1 : and\n (forall (M N : Msg) (_ : synthesis (transpose h) M N),\n transpose (synthesis h) M N)\n (forall (M N : Msg) (_ : transpose (synthesis h) M N),\n synthesis (transpose h) M N)
H0 : h N M
H : and (h N M)\n match N with\n | MNam _ => True\n | MEnc M' K =>\n match M with\n | MEnc N' L =>\n or (not (synthesis h M' N')) (not (synthesis h K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match M with\n | MPair N1 N2 =>\n or (not (synthesis h M1 N1)) (not (synthesis h M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match M with\n | Mop opN N' => or (not (eq opM opN)) (not (synthesis h M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
forall (m m0 m1 m2 : Msg) (_ : or (not (synthesis h m1 m)) (not (synthesis h m2 m0))), or (not (synthesis (fun M N : Msg => h N M) m m1)) (not (synthesis (fun M N : Msg => h N M) m0 m2))
+++++
intros.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
intros M N.
unfold transpose in |- *.
unfold reduce in |- *.
split.
try tauto.
elim H.
intro.
generalize (synthesis_transpose_transpose_synthesis h).
unfold equal in |- *.
unfold inclusion in |- *.
intro.
elim H1.
intro.
intro.
unfold transpose in H2.
case N.
try tauto.
case M.
try tauto.
intros.

*****
H4 : or (not (synthesis h m1 m)) (not (synthesis h m2 m0))
m,m0,m1,m2 : Msg
H3 : forall (M N : Msg) (_ : transpose (synthesis h) M N),\nsynthesis (transpose h) M N
H2 : forall (M N : Msg) (_ : synthesis (fun M0 N0 : Msg => h N0 M0) M N),\nsynthesis h N M
H1 : and\n (forall (M N : Msg) (_ : synthesis (transpose h) M N),\n transpose (synthesis h) M N)\n (forall (M N : Msg) (_ : transpose (synthesis h) M N),\n synthesis (transpose h) M N)
H0 : h N M
H : and (h N M)\n match N with\n | MNam _ => True\n | MEnc M' K =>\n match M with\n | MEnc N' L =>\n or (not (synthesis h M' N')) (not (synthesis h K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match M with\n | MPair N1 N2 =>\n or (not (synthesis h M1 N1)) (not (synthesis h M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match M with\n | Mop opN N' => or (not (eq opM opN)) (not (synthesis h M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
or (not (synthesis (fun M N : Msg => h N M) m m1)) (not (synthesis (fun M N : Msg => h N M) m0 m2))
+++++
case H4.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
intros M N.
unfold transpose in |- *.
unfold reduce in |- *.
split.
try tauto.
elim H.
intro.
generalize (synthesis_transpose_transpose_synthesis h).
unfold equal in |- *.
unfold inclusion in |- *.
intro.
elim H1.
intro.
intro.
unfold transpose in H2.
case N.
try tauto.
case M.
try tauto.
intros.
case H4.

*****
H4 : or (not (synthesis h m1 m)) (not (synthesis h m2 m0))
m,m0,m1,m2 : Msg
H3 : forall (M N : Msg) (_ : transpose (synthesis h) M N),\nsynthesis (transpose h) M N
H2 : forall (M N : Msg) (_ : synthesis (fun M0 N0 : Msg => h N0 M0) M N),\nsynthesis h N M
H1 : and\n (forall (M N : Msg) (_ : synthesis (transpose h) M N),\n transpose (synthesis h) M N)\n (forall (M N : Msg) (_ : transpose (synthesis h) M N),\n synthesis (transpose h) M N)
H0 : h N M
H : and (h N M)\n match N with\n | MNam _ => True\n | MEnc M' K =>\n match M with\n | MEnc N' L =>\n or (not (synthesis h M' N')) (not (synthesis h K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match M with\n | MPair N1 N2 =>\n or (not (synthesis h M1 N1)) (not (synthesis h M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match M with\n | Mop opN N' => or (not (eq opM opN)) (not (synthesis h M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
forall _ : not (synthesis h m1 m), or (not (synthesis (fun M N : Msg => h N M) m m1)) (not (synthesis (fun M N : Msg => h N M) m0 m2))
+++++
left.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
intros M N.
unfold transpose in |- *.
unfold reduce in |- *.
split.
try tauto.
elim H.
intro.
generalize (synthesis_transpose_transpose_synthesis h).
unfold equal in |- *.
unfold inclusion in |- *.
intro.
elim H1.
intro.
intro.
unfold transpose in H2.
case N.
try tauto.
case M.
try tauto.
intros.
case H4.
left.

*****
H5 : not (synthesis h m1 m)
H4 : or (not (synthesis h m1 m)) (not (synthesis h m2 m0))
m,m0,m1,m2 : Msg
H3 : forall (M N : Msg) (_ : transpose (synthesis h) M N),\nsynthesis (transpose h) M N
H2 : forall (M N : Msg) (_ : synthesis (fun M0 N0 : Msg => h N0 M0) M N),\nsynthesis h N M
H1 : and\n (forall (M N : Msg) (_ : synthesis (transpose h) M N),\n transpose (synthesis h) M N)\n (forall (M N : Msg) (_ : transpose (synthesis h) M N),\n synthesis (transpose h) M N)
H0 : h N M
H : and (h N M)\n match N with\n | MNam _ => True\n | MEnc M' K =>\n match M with\n | MEnc N' L =>\n or (not (synthesis h M' N')) (not (synthesis h K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match M with\n | MPair N1 N2 =>\n or (not (synthesis h M1 N1)) (not (synthesis h M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match M with\n | Mop opN N' => or (not (eq opM opN)) (not (synthesis h M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
not (synthesis (fun M N : Msg => h N M) m m1)
+++++
red in |- *.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
intros M N.
unfold transpose in |- *.
unfold reduce in |- *.
split.
try tauto.
elim H.
intro.
generalize (synthesis_transpose_transpose_synthesis h).
unfold equal in |- *.
unfold inclusion in |- *.
intro.
elim H1.
intro.
intro.
unfold transpose in H2.
case N.
try tauto.
case M.
try tauto.
intros.
case H4.
left.
red in |- *.

*****
H5 : not (synthesis h m1 m)
H4 : or (not (synthesis h m1 m)) (not (synthesis h m2 m0))
m,m0,m1,m2 : Msg
H3 : forall (M N : Msg) (_ : transpose (synthesis h) M N),\nsynthesis (transpose h) M N
H2 : forall (M N : Msg) (_ : synthesis (fun M0 N0 : Msg => h N0 M0) M N),\nsynthesis h N M
H1 : and\n (forall (M N : Msg) (_ : synthesis (transpose h) M N),\n transpose (synthesis h) M N)\n (forall (M N : Msg) (_ : transpose (synthesis h) M N),\n synthesis (transpose h) M N)
H0 : h N M
H : and (h N M)\n match N with\n | MNam _ => True\n | MEnc M' K =>\n match M with\n | MEnc N' L =>\n or (not (synthesis h M' N')) (not (synthesis h K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match M with\n | MPair N1 N2 =>\n or (not (synthesis h M1 N1)) (not (synthesis h M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match M with\n | Mop opN N' => or (not (eq opM opN)) (not (synthesis h M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
forall _ : synthesis (fun M N : Msg => h N M) m m1, False
+++++
intro.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
intros M N.
unfold transpose in |- *.
unfold reduce in |- *.
split.
try tauto.
elim H.
intro.
generalize (synthesis_transpose_transpose_synthesis h).
unfold equal in |- *.
unfold inclusion in |- *.
intro.
elim H1.
intro.
intro.
unfold transpose in H2.
case N.
try tauto.
case M.
try tauto.
intros.
case H4.
left.
red in |- *.
intro.

*****
H6 : synthesis (fun M N : Msg => h N M) m m1
H5 : not (synthesis h m1 m)
H4 : or (not (synthesis h m1 m)) (not (synthesis h m2 m0))
m,m0,m1,m2 : Msg
H3 : forall (M N : Msg) (_ : transpose (synthesis h) M N),\nsynthesis (transpose h) M N
H2 : forall (M N : Msg) (_ : synthesis (fun M0 N0 : Msg => h N0 M0) M N),\nsynthesis h N M
H1 : and\n (forall (M N : Msg) (_ : synthesis (transpose h) M N),\n transpose (synthesis h) M N)\n (forall (M N : Msg) (_ : transpose (synthesis h) M N),\n synthesis (transpose h) M N)
H0 : h N M
H : and (h N M)\n match N with\n | MNam _ => True\n | MEnc M' K =>\n match M with\n | MEnc N' L =>\n or (not (synthesis h M' N')) (not (synthesis h K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match M with\n | MPair N1 N2 =>\n or (not (synthesis h M1 N1)) (not (synthesis h M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match M with\n | Mop opN N' => or (not (eq opM opN)) (not (synthesis h M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
False
+++++
apply H5.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
intros M N.
unfold transpose in |- *.
unfold reduce in |- *.
split.
try tauto.
elim H.
intro.
generalize (synthesis_transpose_transpose_synthesis h).
unfold equal in |- *.
unfold inclusion in |- *.
intro.
elim H1.
intro.
intro.
unfold transpose in H2.
case N.
try tauto.
case M.
try tauto.
intros.
case H4.
left.
red in |- *.
intro.
apply H5.

*****
H6 : synthesis (fun M N : Msg => h N M) m m1
H5 : not (synthesis h m1 m)
H4 : or (not (synthesis h m1 m)) (not (synthesis h m2 m0))
m,m0,m1,m2 : Msg
H3 : forall (M N : Msg) (_ : transpose (synthesis h) M N),\nsynthesis (transpose h) M N
H2 : forall (M N : Msg) (_ : synthesis (fun M0 N0 : Msg => h N0 M0) M N),\nsynthesis h N M
H1 : and\n (forall (M N : Msg) (_ : synthesis (transpose h) M N),\n transpose (synthesis h) M N)\n (forall (M N : Msg) (_ : transpose (synthesis h) M N),\n synthesis (transpose h) M N)
H0 : h N M
H : and (h N M)\n match N with\n | MNam _ => True\n | MEnc M' K =>\n match M with\n | MEnc N' L =>\n or (not (synthesis h M' N')) (not (synthesis h K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match M with\n | MPair N1 N2 =>\n or (not (synthesis h M1 N1)) (not (synthesis h M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match M with\n | Mop opN N' => or (not (eq opM opN)) (not (synthesis h M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
synthesis h m1 m
+++++
auto.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
intros M N.
unfold transpose in |- *.
unfold reduce in |- *.
split.
try tauto.
elim H.
intro.
generalize (synthesis_transpose_transpose_synthesis h).
unfold equal in |- *.
unfold inclusion in |- *.
intro.
elim H1.
intro.
intro.
unfold transpose in H2.
case N.
try tauto.
case M.
try tauto.
intros.
case H4.

*****
H4 : or (not (synthesis h m1 m)) (not (synthesis h m2 m0))
m,m0,m1,m2 : Msg
H3 : forall (M N : Msg) (_ : transpose (synthesis h) M N),\nsynthesis (transpose h) M N
H2 : forall (M N : Msg) (_ : synthesis (fun M0 N0 : Msg => h N0 M0) M N),\nsynthesis h N M
H1 : and\n (forall (M N : Msg) (_ : synthesis (transpose h) M N),\n transpose (synthesis h) M N)\n (forall (M N : Msg) (_ : transpose (synthesis h) M N),\n synthesis (transpose h) M N)
H0 : h N M
H : and (h N M)\n match N with\n | MNam _ => True\n | MEnc M' K =>\n match M with\n | MEnc N' L =>\n or (not (synthesis h M' N')) (not (synthesis h K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match M with\n | MPair N1 N2 =>\n or (not (synthesis h M1 N1)) (not (synthesis h M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match M with\n | Mop opN N' => or (not (eq opM opN)) (not (synthesis h M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
forall _ : not (synthesis h m2 m0), or (not (synthesis (fun M N : Msg => h N M) m m1)) (not (synthesis (fun M N : Msg => h N M) m0 m2))
+++++
right.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
intros M N.
unfold transpose in |- *.
unfold reduce in |- *.
split.
try tauto.
elim H.
intro.
generalize (synthesis_transpose_transpose_synthesis h).
unfold equal in |- *.
unfold inclusion in |- *.
intro.
elim H1.
intro.
intro.
unfold transpose in H2.
case N.
try tauto.
case M.
try tauto.
intros.
case H4.
right.

*****
H5 : not (synthesis h m2 m0)
H4 : or (not (synthesis h m1 m)) (not (synthesis h m2 m0))
m,m0,m1,m2 : Msg
H3 : forall (M N : Msg) (_ : transpose (synthesis h) M N),\nsynthesis (transpose h) M N
H2 : forall (M N : Msg) (_ : synthesis (fun M0 N0 : Msg => h N0 M0) M N),\nsynthesis h N M
H1 : and\n (forall (M N : Msg) (_ : synthesis (transpose h) M N),\n transpose (synthesis h) M N)\n (forall (M N : Msg) (_ : transpose (synthesis h) M N),\n synthesis (transpose h) M N)
H0 : h N M
H : and (h N M)\n match N with\n | MNam _ => True\n | MEnc M' K =>\n match M with\n | MEnc N' L =>\n or (not (synthesis h M' N')) (not (synthesis h K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match M with\n | MPair N1 N2 =>\n or (not (synthesis h M1 N1)) (not (synthesis h M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match M with\n | Mop opN N' => or (not (eq opM opN)) (not (synthesis h M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
not (synthesis (fun M N : Msg => h N M) m0 m2)
+++++
red in |- *.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
intros M N.
unfold transpose in |- *.
unfold reduce in |- *.
split.
try tauto.
elim H.
intro.
generalize (synthesis_transpose_transpose_synthesis h).
unfold equal in |- *.
unfold inclusion in |- *.
intro.
elim H1.
intro.
intro.
unfold transpose in H2.
case N.
try tauto.
case M.
try tauto.
intros.
case H4.
right.
red in |- *.

*****
H5 : not (synthesis h m2 m0)
H4 : or (not (synthesis h m1 m)) (not (synthesis h m2 m0))
m,m0,m1,m2 : Msg
H3 : forall (M N : Msg) (_ : transpose (synthesis h) M N),\nsynthesis (transpose h) M N
H2 : forall (M N : Msg) (_ : synthesis (fun M0 N0 : Msg => h N0 M0) M N),\nsynthesis h N M
H1 : and\n (forall (M N : Msg) (_ : synthesis (transpose h) M N),\n transpose (synthesis h) M N)\n (forall (M N : Msg) (_ : transpose (synthesis h) M N),\n synthesis (transpose h) M N)
H0 : h N M
H : and (h N M)\n match N with\n | MNam _ => True\n | MEnc M' K =>\n match M with\n | MEnc N' L =>\n or (not (synthesis h M' N')) (not (synthesis h K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match M with\n | MPair N1 N2 =>\n or (not (synthesis h M1 N1)) (not (synthesis h M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match M with\n | Mop opN N' => or (not (eq opM opN)) (not (synthesis h M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
forall _ : synthesis (fun M N : Msg => h N M) m0 m2, False
+++++
intro.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
intros M N.
unfold transpose in |- *.
unfold reduce in |- *.
split.
try tauto.
elim H.
intro.
generalize (synthesis_transpose_transpose_synthesis h).
unfold equal in |- *.
unfold inclusion in |- *.
intro.
elim H1.
intro.
intro.
unfold transpose in H2.
case N.
try tauto.
case M.
try tauto.
intros.
case H4.
right.
red in |- *.
intro.

*****
H6 : synthesis (fun M N : Msg => h N M) m0 m2
H5 : not (synthesis h m2 m0)
H4 : or (not (synthesis h m1 m)) (not (synthesis h m2 m0))
m,m0,m1,m2 : Msg
H3 : forall (M N : Msg) (_ : transpose (synthesis h) M N),\nsynthesis (transpose h) M N
H2 : forall (M N : Msg) (_ : synthesis (fun M0 N0 : Msg => h N0 M0) M N),\nsynthesis h N M
H1 : and\n (forall (M N : Msg) (_ : synthesis (transpose h) M N),\n transpose (synthesis h) M N)\n (forall (M N : Msg) (_ : transpose (synthesis h) M N),\n synthesis (transpose h) M N)
H0 : h N M
H : and (h N M)\n match N with\n | MNam _ => True\n | MEnc M' K =>\n match M with\n | MEnc N' L =>\n or (not (synthesis h M' N')) (not (synthesis h K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match M with\n | MPair N1 N2 =>\n or (not (synthesis h M1 N1)) (not (synthesis h M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match M with\n | Mop opN N' => or (not (eq opM opN)) (not (synthesis h M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
False
+++++
apply H5.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
intros M N.
unfold transpose in |- *.
unfold reduce in |- *.
split.
try tauto.
elim H.
intro.
generalize (synthesis_transpose_transpose_synthesis h).
unfold equal in |- *.
unfold inclusion in |- *.
intro.
elim H1.
intro.
intro.
unfold transpose in H2.
case N.
try tauto.
case M.
try tauto.
intros.
case H4.
right.
red in |- *.
intro.
apply H5.

*****
H6 : synthesis (fun M N : Msg => h N M) m0 m2
H5 : not (synthesis h m2 m0)
H4 : or (not (synthesis h m1 m)) (not (synthesis h m2 m0))
m,m0,m1,m2 : Msg
H3 : forall (M N : Msg) (_ : transpose (synthesis h) M N),\nsynthesis (transpose h) M N
H2 : forall (M N : Msg) (_ : synthesis (fun M0 N0 : Msg => h N0 M0) M N),\nsynthesis h N M
H1 : and\n (forall (M N : Msg) (_ : synthesis (transpose h) M N),\n transpose (synthesis h) M N)\n (forall (M N : Msg) (_ : transpose (synthesis h) M N),\n synthesis (transpose h) M N)
H0 : h N M
H : and (h N M)\n match N with\n | MNam _ => True\n | MEnc M' K =>\n match M with\n | MEnc N' L =>\n or (not (synthesis h M' N')) (not (synthesis h K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match M with\n | MPair N1 N2 =>\n or (not (synthesis h M1 N1)) (not (synthesis h M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match M with\n | Mop opN N' => or (not (eq opM opN)) (not (synthesis h M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
synthesis h m2 m0
+++++
auto.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
intros M N.
unfold transpose in |- *.
unfold reduce in |- *.
split.
try tauto.
elim H.
intro.
generalize (synthesis_transpose_transpose_synthesis h).
unfold equal in |- *.
unfold inclusion in |- *.
intro.
elim H1.
intro.
intro.
unfold transpose in H2.
case N.
try tauto.
case M.

*****
H3 : forall (M N : Msg) (_ : transpose (synthesis h) M N),\nsynthesis (transpose h) M N
H2 : forall (M N : Msg) (_ : synthesis (fun M0 N0 : Msg => h N0 M0) M N),\nsynthesis h N M
H1 : and\n (forall (M N : Msg) (_ : synthesis (transpose h) M N),\n transpose (synthesis h) M N)\n (forall (M N : Msg) (_ : transpose (synthesis h) M N),\n synthesis (transpose h) M N)
H0 : h N M
H : and (h N M)\n match N with\n | MNam _ => True\n | MEnc M' K =>\n match M with\n | MEnc N' L =>\n or (not (synthesis h M' N')) (not (synthesis h K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match M with\n | MPair N1 N2 =>\n or (not (synthesis h M1 N1)) (not (synthesis h M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match M with\n | Mop opN N' => or (not (eq opM opN)) (not (synthesis h M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
forall (_ : op) (_ : Msg) (_ : Msg) (_ : Msg) (_ : True), True
+++++
try tauto.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
intros M N.
unfold transpose in |- *.
unfold reduce in |- *.
split.
try tauto.
elim H.
intro.
generalize (synthesis_transpose_transpose_synthesis h).
unfold equal in |- *.
unfold inclusion in |- *.
intro.
elim H1.
intro.
intro.
unfold transpose in H2.
case N.

*****
H3 : forall (M N : Msg) (_ : transpose (synthesis h) M N),\nsynthesis (transpose h) M N
H2 : forall (M N : Msg) (_ : synthesis (fun M0 N0 : Msg => h N0 M0) M N),\nsynthesis h N M
H1 : and\n (forall (M N : Msg) (_ : synthesis (transpose h) M N),\n transpose (synthesis h) M N)\n (forall (M N : Msg) (_ : transpose (synthesis h) M N),\n synthesis (transpose h) M N)
H0 : h N M
H : and (h N M)\n match N with\n | MNam _ => True\n | MEnc M' K =>\n match M with\n | MEnc N' L =>\n or (not (synthesis h M' N')) (not (synthesis h K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match M with\n | MPair N1 N2 =>\n or (not (synthesis h M1 N1)) (not (synthesis h M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match M with\n | Mop opN N' => or (not (eq opM opN)) (not (synthesis h M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
forall (o : op) (m : Msg) (_ : match M with | Mop opN N' => or (not (eq o opN)) (not (synthesis h m N')) | _ => True end), match M with | Mop opM M' => or (not (eq opM o)) (not (synthesis (fun M N : Msg => h N M) M' m)) | _ => True end
+++++
try tauto.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
intros M N.
unfold transpose in |- *.
unfold reduce in |- *.
split.
try tauto.
elim H.
intro.
generalize (synthesis_transpose_transpose_synthesis h).
unfold equal in |- *.
unfold inclusion in |- *.
intro.
elim H1.
intro.
intro.
unfold transpose in H2.
case N.
try tauto.

*****
H3 : forall (M N : Msg) (_ : transpose (synthesis h) M N),\nsynthesis (transpose h) M N
H2 : forall (M N : Msg) (_ : synthesis (fun M0 N0 : Msg => h N0 M0) M N),\nsynthesis h N M
H1 : and\n (forall (M N : Msg) (_ : synthesis (transpose h) M N),\n transpose (synthesis h) M N)\n (forall (M N : Msg) (_ : transpose (synthesis h) M N),\n synthesis (transpose h) M N)
H0 : h N M
H : and (h N M)\n match N with\n | MNam _ => True\n | MEnc M' K =>\n match M with\n | MEnc N' L =>\n or (not (synthesis h M' N')) (not (synthesis h K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match M with\n | MPair N1 N2 =>\n or (not (synthesis h M1 N1)) (not (synthesis h M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match M with\n | Mop opN N' => or (not (eq opM opN)) (not (synthesis h M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
forall (o : op) (m : Msg) (_ : match M with | Mop opN N' => or (not (eq o opN)) (not (synthesis h m N')) | _ => True end), match M with | Mop opM M' => or (not (eq opM o)) (not (synthesis (fun M N : Msg => h N M) M' m)) | _ => True end
+++++
case M.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
intros M N.
unfold transpose in |- *.
unfold reduce in |- *.
split.
try tauto.
elim H.
intro.
generalize (synthesis_transpose_transpose_synthesis h).
unfold equal in |- *.
unfold inclusion in |- *.
intro.
elim H1.
intro.
intro.
unfold transpose in H2.
case N.
try tauto.
case M.

*****
H3 : forall (M N : Msg) (_ : transpose (synthesis h) M N),\nsynthesis (transpose h) M N
H2 : forall (M N : Msg) (_ : synthesis (fun M0 N0 : Msg => h N0 M0) M N),\nsynthesis h N M
H1 : and\n (forall (M N : Msg) (_ : synthesis (transpose h) M N),\n transpose (synthesis h) M N)\n (forall (M N : Msg) (_ : transpose (synthesis h) M N),\n synthesis (transpose h) M N)
H0 : h N M
H : and (h N M)\n match N with\n | MNam _ => True\n | MEnc M' K =>\n match M with\n | MEnc N' L =>\n or (not (synthesis h M' N')) (not (synthesis h K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match M with\n | MPair N1 N2 =>\n or (not (synthesis h M1 N1)) (not (synthesis h M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match M with\n | Mop opN N' => or (not (eq opM opN)) (not (synthesis h M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
forall (_ : Nam) (_ : op) (_ : Msg) (_ : True), True
+++++
try tauto.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
intros M N.
unfold transpose in |- *.
unfold reduce in |- *.
split.
try tauto.
elim H.
intro.
generalize (synthesis_transpose_transpose_synthesis h).
unfold equal in |- *.
unfold inclusion in |- *.
intro.
elim H1.
intro.
intro.
unfold transpose in H2.
case N.
try tauto.
case M.

*****
H3 : forall (M N : Msg) (_ : transpose (synthesis h) M N),\nsynthesis (transpose h) M N
H2 : forall (M N : Msg) (_ : synthesis (fun M0 N0 : Msg => h N0 M0) M N),\nsynthesis h N M
H1 : and\n (forall (M N : Msg) (_ : synthesis (transpose h) M N),\n transpose (synthesis h) M N)\n (forall (M N : Msg) (_ : transpose (synthesis h) M N),\n synthesis (transpose h) M N)
H0 : h N M
H : and (h N M)\n match N with\n | MNam _ => True\n | MEnc M' K =>\n match M with\n | MEnc N' L =>\n or (not (synthesis h M' N')) (not (synthesis h K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match M with\n | MPair N1 N2 =>\n or (not (synthesis h M1 N1)) (not (synthesis h M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match M with\n | Mop opN N' => or (not (eq opM opN)) (not (synthesis h M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
forall (_ : Msg) (_ : Msg) (_ : op) (_ : Msg) (_ : True), True
+++++
try tauto.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
intros M N.
unfold transpose in |- *.
unfold reduce in |- *.
split.
try tauto.
elim H.
intro.
generalize (synthesis_transpose_transpose_synthesis h).
unfold equal in |- *.
unfold inclusion in |- *.
intro.
elim H1.
intro.
intro.
unfold transpose in H2.
case N.
try tauto.
case M.

*****
H3 : forall (M N : Msg) (_ : transpose (synthesis h) M N),\nsynthesis (transpose h) M N
H2 : forall (M N : Msg) (_ : synthesis (fun M0 N0 : Msg => h N0 M0) M N),\nsynthesis h N M
H1 : and\n (forall (M N : Msg) (_ : synthesis (transpose h) M N),\n transpose (synthesis h) M N)\n (forall (M N : Msg) (_ : transpose (synthesis h) M N),\n synthesis (transpose h) M N)
H0 : h N M
H : and (h N M)\n match N with\n | MNam _ => True\n | MEnc M' K =>\n match M with\n | MEnc N' L =>\n or (not (synthesis h M' N')) (not (synthesis h K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match M with\n | MPair N1 N2 =>\n or (not (synthesis h M1 N1)) (not (synthesis h M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match M with\n | Mop opN N' => or (not (eq opM opN)) (not (synthesis h M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
forall (_ : Msg) (_ : Msg) (_ : op) (_ : Msg) (_ : True), True
+++++
try tauto.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
intros M N.
unfold transpose in |- *.
unfold reduce in |- *.
split.
try tauto.
elim H.
intro.
generalize (synthesis_transpose_transpose_synthesis h).
unfold equal in |- *.
unfold inclusion in |- *.
intro.
elim H1.
intro.
intro.
unfold transpose in H2.
case N.
try tauto.
case M.

*****
H3 : forall (M N : Msg) (_ : transpose (synthesis h) M N),\nsynthesis (transpose h) M N
H2 : forall (M N : Msg) (_ : synthesis (fun M0 N0 : Msg => h N0 M0) M N),\nsynthesis h N M
H1 : and\n (forall (M N : Msg) (_ : synthesis (transpose h) M N),\n transpose (synthesis h) M N)\n (forall (M N : Msg) (_ : transpose (synthesis h) M N),\n synthesis (transpose h) M N)
H0 : h N M
H : and (h N M)\n match N with\n | MNam _ => True\n | MEnc M' K =>\n match M with\n | MEnc N' L =>\n or (not (synthesis h M' N')) (not (synthesis h K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match M with\n | MPair N1 N2 =>\n or (not (synthesis h M1 N1)) (not (synthesis h M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match M with\n | Mop opN N' => or (not (eq opM opN)) (not (synthesis h M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
forall (o : op) (m : Msg) (o0 : op) (m0 : Msg) (_ : or (not (eq o0 o)) (not (synthesis h m0 m))), or (not (eq o o0)) (not (synthesis (fun M N : Msg => h N M) m m0))
+++++
try tauto.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
intros M N.
unfold transpose in |- *.
unfold reduce in |- *.
split.
try tauto.
elim H.
intro.
generalize (synthesis_transpose_transpose_synthesis h).
unfold equal in |- *.
unfold inclusion in |- *.
intro.
elim H1.
intro.
intro.
unfold transpose in H2.
case N.
try tauto.
case M.
try tauto.

*****
H3 : forall (M N : Msg) (_ : transpose (synthesis h) M N),\nsynthesis (transpose h) M N
H2 : forall (M N : Msg) (_ : synthesis (fun M0 N0 : Msg => h N0 M0) M N),\nsynthesis h N M
H1 : and\n (forall (M N : Msg) (_ : synthesis (transpose h) M N),\n transpose (synthesis h) M N)\n (forall (M N : Msg) (_ : transpose (synthesis h) M N),\n synthesis (transpose h) M N)
H0 : h N M
H : and (h N M)\n match N with\n | MNam _ => True\n | MEnc M' K =>\n match M with\n | MEnc N' L =>\n or (not (synthesis h M' N')) (not (synthesis h K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match M with\n | MPair N1 N2 =>\n or (not (synthesis h M1 N1)) (not (synthesis h M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match M with\n | Mop opN N' => or (not (eq opM opN)) (not (synthesis h M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
forall (o : op) (m : Msg) (o0 : op) (m0 : Msg) (_ : or (not (eq o0 o)) (not (synthesis h m0 m))), or (not (eq o o0)) (not (synthesis (fun M N : Msg => h N M) m m0))
+++++
intros.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
intros M N.
unfold transpose in |- *.
unfold reduce in |- *.
split.
try tauto.
elim H.
intro.
generalize (synthesis_transpose_transpose_synthesis h).
unfold equal in |- *.
unfold inclusion in |- *.
intro.
elim H1.
intro.
intro.
unfold transpose in H2.
case N.
try tauto.
case M.
try tauto.
intros.

*****
H4 : or (not (eq o0 o)) (not (synthesis h m0 m))
m0 : Msg
o0 : op
m : Msg
o : op
H3 : forall (M N : Msg) (_ : transpose (synthesis h) M N),\nsynthesis (transpose h) M N
H2 : forall (M N : Msg) (_ : synthesis (fun M0 N0 : Msg => h N0 M0) M N),\nsynthesis h N M
H1 : and\n (forall (M N : Msg) (_ : synthesis (transpose h) M N),\n transpose (synthesis h) M N)\n (forall (M N : Msg) (_ : transpose (synthesis h) M N),\n synthesis (transpose h) M N)
H0 : h N M
H : and (h N M)\n match N with\n | MNam _ => True\n | MEnc M' K =>\n match M with\n | MEnc N' L =>\n or (not (synthesis h M' N')) (not (synthesis h K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match M with\n | MPair N1 N2 =>\n or (not (synthesis h M1 N1)) (not (synthesis h M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match M with\n | Mop opN N' => or (not (eq opM opN)) (not (synthesis h M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
or (not (eq o o0)) (not (synthesis (fun M N : Msg => h N M) m m0))
+++++
case H4.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
intros M N.
unfold transpose in |- *.
unfold reduce in |- *.
split.
try tauto.
elim H.
intro.
generalize (synthesis_transpose_transpose_synthesis h).
unfold equal in |- *.
unfold inclusion in |- *.
intro.
elim H1.
intro.
intro.
unfold transpose in H2.
case N.
try tauto.
case M.
try tauto.
intros.
case H4.

*****
H4 : or (not (eq o0 o)) (not (synthesis h m0 m))
m0 : Msg
o0 : op
m : Msg
o : op
H3 : forall (M N : Msg) (_ : transpose (synthesis h) M N),\nsynthesis (transpose h) M N
H2 : forall (M N : Msg) (_ : synthesis (fun M0 N0 : Msg => h N0 M0) M N),\nsynthesis h N M
H1 : and\n (forall (M N : Msg) (_ : synthesis (transpose h) M N),\n transpose (synthesis h) M N)\n (forall (M N : Msg) (_ : transpose (synthesis h) M N),\n synthesis (transpose h) M N)
H0 : h N M
H : and (h N M)\n match N with\n | MNam _ => True\n | MEnc M' K =>\n match M with\n | MEnc N' L =>\n or (not (synthesis h M' N')) (not (synthesis h K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match M with\n | MPair N1 N2 =>\n or (not (synthesis h M1 N1)) (not (synthesis h M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match M with\n | Mop opN N' => or (not (eq opM opN)) (not (synthesis h M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
forall _ : not (eq o0 o), or (not (eq o o0)) (not (synthesis (fun M N : Msg => h N M) m m0))
+++++
left.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
intros M N.
unfold transpose in |- *.
unfold reduce in |- *.
split.
try tauto.
elim H.
intro.
generalize (synthesis_transpose_transpose_synthesis h).
unfold equal in |- *.
unfold inclusion in |- *.
intro.
elim H1.
intro.
intro.
unfold transpose in H2.
case N.
try tauto.
case M.
try tauto.
intros.
case H4.
left.

*****
H5 : not (eq o0 o)
H4 : or (not (eq o0 o)) (not (synthesis h m0 m))
m0 : Msg
o0 : op
m : Msg
o : op
H3 : forall (M N : Msg) (_ : transpose (synthesis h) M N),\nsynthesis (transpose h) M N
H2 : forall (M N : Msg) (_ : synthesis (fun M0 N0 : Msg => h N0 M0) M N),\nsynthesis h N M
H1 : and\n (forall (M N : Msg) (_ : synthesis (transpose h) M N),\n transpose (synthesis h) M N)\n (forall (M N : Msg) (_ : transpose (synthesis h) M N),\n synthesis (transpose h) M N)
H0 : h N M
H : and (h N M)\n match N with\n | MNam _ => True\n | MEnc M' K =>\n match M with\n | MEnc N' L =>\n or (not (synthesis h M' N')) (not (synthesis h K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match M with\n | MPair N1 N2 =>\n or (not (synthesis h M1 N1)) (not (synthesis h M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match M with\n | Mop opN N' => or (not (eq opM opN)) (not (synthesis h M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
not (eq o o0)
+++++
auto.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
intros M N.
unfold transpose in |- *.
unfold reduce in |- *.
split.
try tauto.
elim H.
intro.
generalize (synthesis_transpose_transpose_synthesis h).
unfold equal in |- *.
unfold inclusion in |- *.
intro.
elim H1.
intro.
intro.
unfold transpose in H2.
case N.
try tauto.
case M.
try tauto.
intros.
case H4.

*****
H4 : or (not (eq o0 o)) (not (synthesis h m0 m))
m0 : Msg
o0 : op
m : Msg
o : op
H3 : forall (M N : Msg) (_ : transpose (synthesis h) M N),\nsynthesis (transpose h) M N
H2 : forall (M N : Msg) (_ : synthesis (fun M0 N0 : Msg => h N0 M0) M N),\nsynthesis h N M
H1 : and\n (forall (M N : Msg) (_ : synthesis (transpose h) M N),\n transpose (synthesis h) M N)\n (forall (M N : Msg) (_ : transpose (synthesis h) M N),\n synthesis (transpose h) M N)
H0 : h N M
H : and (h N M)\n match N with\n | MNam _ => True\n | MEnc M' K =>\n match M with\n | MEnc N' L =>\n or (not (synthesis h M' N')) (not (synthesis h K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match M with\n | MPair N1 N2 =>\n or (not (synthesis h M1 N1)) (not (synthesis h M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match M with\n | Mop opN N' => or (not (eq opM opN)) (not (synthesis h M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
forall _ : not (synthesis h m0 m), or (not (eq o o0)) (not (synthesis (fun M N : Msg => h N M) m m0))
+++++
right.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
intros M N.
unfold transpose in |- *.
unfold reduce in |- *.
split.
try tauto.
elim H.
intro.
generalize (synthesis_transpose_transpose_synthesis h).
unfold equal in |- *.
unfold inclusion in |- *.
intro.
elim H1.
intro.
intro.
unfold transpose in H2.
case N.
try tauto.
case M.
try tauto.
intros.
case H4.
right.

*****
H5 : not (synthesis h m0 m)
H4 : or (not (eq o0 o)) (not (synthesis h m0 m))
m0 : Msg
o0 : op
m : Msg
o : op
H3 : forall (M N : Msg) (_ : transpose (synthesis h) M N),\nsynthesis (transpose h) M N
H2 : forall (M N : Msg) (_ : synthesis (fun M0 N0 : Msg => h N0 M0) M N),\nsynthesis h N M
H1 : and\n (forall (M N : Msg) (_ : synthesis (transpose h) M N),\n transpose (synthesis h) M N)\n (forall (M N : Msg) (_ : transpose (synthesis h) M N),\n synthesis (transpose h) M N)
H0 : h N M
H : and (h N M)\n match N with\n | MNam _ => True\n | MEnc M' K =>\n match M with\n | MEnc N' L =>\n or (not (synthesis h M' N')) (not (synthesis h K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match M with\n | MPair N1 N2 =>\n or (not (synthesis h M1 N1)) (not (synthesis h M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match M with\n | Mop opN N' => or (not (eq opM opN)) (not (synthesis h M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
not (synthesis (fun M N : Msg => h N M) m m0)
+++++
red in |- *.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
intros M N.
unfold transpose in |- *.
unfold reduce in |- *.
split.
try tauto.
elim H.
intro.
generalize (synthesis_transpose_transpose_synthesis h).
unfold equal in |- *.
unfold inclusion in |- *.
intro.
elim H1.
intro.
intro.
unfold transpose in H2.
case N.
try tauto.
case M.
try tauto.
intros.
case H4.
right.
red in |- *.

*****
H5 : not (synthesis h m0 m)
H4 : or (not (eq o0 o)) (not (synthesis h m0 m))
m0 : Msg
o0 : op
m : Msg
o : op
H3 : forall (M N : Msg) (_ : transpose (synthesis h) M N),\nsynthesis (transpose h) M N
H2 : forall (M N : Msg) (_ : synthesis (fun M0 N0 : Msg => h N0 M0) M N),\nsynthesis h N M
H1 : and\n (forall (M N : Msg) (_ : synthesis (transpose h) M N),\n transpose (synthesis h) M N)\n (forall (M N : Msg) (_ : transpose (synthesis h) M N),\n synthesis (transpose h) M N)
H0 : h N M
H : and (h N M)\n match N with\n | MNam _ => True\n | MEnc M' K =>\n match M with\n | MEnc N' L =>\n or (not (synthesis h M' N')) (not (synthesis h K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match M with\n | MPair N1 N2 =>\n or (not (synthesis h M1 N1)) (not (synthesis h M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match M with\n | Mop opN N' => or (not (eq opM opN)) (not (synthesis h M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
forall _ : synthesis (fun M N : Msg => h N M) m m0, False
+++++
intro.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
intros M N.
unfold transpose in |- *.
unfold reduce in |- *.
split.
try tauto.
elim H.
intro.
generalize (synthesis_transpose_transpose_synthesis h).
unfold equal in |- *.
unfold inclusion in |- *.
intro.
elim H1.
intro.
intro.
unfold transpose in H2.
case N.
try tauto.
case M.
try tauto.
intros.
case H4.
right.
red in |- *.
intro.

*****
H6 : synthesis (fun M N : Msg => h N M) m m0
H5 : not (synthesis h m0 m)
H4 : or (not (eq o0 o)) (not (synthesis h m0 m))
m0 : Msg
o0 : op
m : Msg
o : op
H3 : forall (M N : Msg) (_ : transpose (synthesis h) M N),\nsynthesis (transpose h) M N
H2 : forall (M N : Msg) (_ : synthesis (fun M0 N0 : Msg => h N0 M0) M N),\nsynthesis h N M
H1 : and\n (forall (M N : Msg) (_ : synthesis (transpose h) M N),\n transpose (synthesis h) M N)\n (forall (M N : Msg) (_ : transpose (synthesis h) M N),\n synthesis (transpose h) M N)
H0 : h N M
H : and (h N M)\n match N with\n | MNam _ => True\n | MEnc M' K =>\n match M with\n | MEnc N' L =>\n or (not (synthesis h M' N')) (not (synthesis h K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match M with\n | MPair N1 N2 =>\n or (not (synthesis h M1 N1)) (not (synthesis h M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match M with\n | Mop opN N' => or (not (eq opM opN)) (not (synthesis h M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
False
+++++
apply H5.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.
unfold inclusion in |- *.
intros M N.
unfold transpose in |- *.
unfold reduce in |- *.
split.
try tauto.
elim H.
intro.
generalize (synthesis_transpose_transpose_synthesis h).
unfold equal in |- *.
unfold inclusion in |- *.
intro.
elim H1.
intro.
intro.
unfold transpose in H2.
case N.
try tauto.
case M.
try tauto.
intros.
case H4.
right.
red in |- *.
intro.
apply H5.

*****
H6 : synthesis (fun M N : Msg => h N M) m m0
H5 : not (synthesis h m0 m)
H4 : or (not (eq o0 o)) (not (synthesis h m0 m))
m0 : Msg
o0 : op
m : Msg
o : op
H3 : forall (M N : Msg) (_ : transpose (synthesis h) M N),\nsynthesis (transpose h) M N
H2 : forall (M N : Msg) (_ : synthesis (fun M0 N0 : Msg => h N0 M0) M N),\nsynthesis h N M
H1 : and\n (forall (M N : Msg) (_ : synthesis (transpose h) M N),\n transpose (synthesis h) M N)\n (forall (M N : Msg) (_ : transpose (synthesis h) M N),\n synthesis (transpose h) M N)
H0 : h N M
H : and (h N M)\n match N with\n | MNam _ => True\n | MEnc M' K =>\n match M with\n | MEnc N' L =>\n or (not (synthesis h M' N')) (not (synthesis h K L))\n | _ => True\n end\n | MPair M1 M2 =>\n match M with\n | MPair N1 N2 =>\n or (not (synthesis h M1 N1)) (not (synthesis h M2 N2))\n | _ => True\n end\n | Mop opM M' =>\n match M with\n | Mop opN N' => or (not (eq opM opN)) (not (synthesis h M' N'))\n | _ => True\n end\n end
M,N : Msg
h : hedge
*****
synthesis h m0 m
+++++
auto.
-----
Lemma reduce_transpose_transpose_reduce : forall h : hedge, equal (reduce (transpose h)) (transpose (reduce h)).
unfold equal in |- *.
split.

*****

*****

+++++
Qed.
-----
Lemma analysis_transpose_transpose_analysis :\n forall h : hedge, equal (analysis (transpose h)) (transpose (analysis h)).
-----
Lemma analysis_transpose_transpose_analysis : forall h : hedge, equal (analysis (transpose h)) (transpose (analysis h)).

*****

*****
forall h : hedge, equal (analysis (transpose h)) (transpose (analysis h))
+++++
unfold equal in |- *.
-----
Lemma analysis_transpose_transpose_analysis : forall h : hedge, equal (analysis (transpose h)) (transpose (analysis h)).
unfold equal in |- *.

*****

*****
forall h : hedge, and (inclusion (analysis (transpose h)) (transpose (analysis h))) (inclusion (transpose (analysis h)) (analysis (transpose h)))
+++++
unfold inclusion in |- *.
-----
Lemma analysis_transpose_transpose_analysis : forall h : hedge, equal (analysis (transpose h)) (transpose (analysis h)).
unfold equal in |- *.
unfold inclusion in |- *.

*****

*****
forall h : hedge, and (forall (M N : Msg) (_ : analysis (transpose h) M N), transpose (analysis h) M N) (forall (M N : Msg) (_ : transpose (analysis h) M N), analysis (transpose h) M N)
+++++
intros.
-----
Lemma analysis_transpose_transpose_analysis : forall h : hedge, equal (analysis (transpose h)) (transpose (analysis h)).
unfold equal in |- *.
unfold inclusion in |- *.
intros.

*****
h : hedge
*****
and (forall (M N : Msg) (_ : analysis (transpose h) M N), transpose (analysis h) M N) (forall (M N : Msg) (_ : transpose (analysis h) M N), analysis (transpose h) M N)
+++++
unfold transpose in |- *.
-----
Lemma analysis_transpose_transpose_analysis : forall h : hedge, equal (analysis (transpose h)) (transpose (analysis h)).
unfold equal in |- *.
unfold inclusion in |- *.
intros.
unfold transpose in |- *.

*****
h : hedge
*****
and (forall (M N : Msg) (_ : analysis (fun M0 N0 : Msg => h N0 M0) M N), analysis h N M) (forall (M N : Msg) (_ : analysis h N M), analysis (fun M0 N0 : Msg => h N0 M0) M N)
+++++
split.
-----
Lemma analysis_transpose_transpose_analysis : forall h : hedge, equal (analysis (transpose h)) (transpose (analysis h)).
unfold equal in |- *.
unfold inclusion in |- *.
intros.
unfold transpose in |- *.
split.

*****
h : hedge
*****
forall (M N : Msg) (_ : analysis (fun M0 N0 : Msg => h N0 M0) M N), analysis h N M
+++++
intros M N.
-----
Lemma analysis_transpose_transpose_analysis : forall h : hedge, equal (analysis (transpose h)) (transpose (analysis h)).
unfold equal in |- *.
unfold inclusion in |- *.
intros.
unfold transpose in |- *.
split.
intros M N.

*****
M,N : Msg
h : hedge
*****
forall _ : analysis (fun M N : Msg => h N M) M N, analysis h N M
+++++
intro.
-----
Lemma analysis_transpose_transpose_analysis : forall h : hedge, equal (analysis (transpose h)) (transpose (analysis h)).
unfold equal in |- *.
unfold inclusion in |- *.
intros.
unfold transpose in |- *.
split.
intros M N.
intro.

*****
H : analysis (fun M N : Msg => h N M) M N
M,N : Msg
h : hedge
*****
analysis h N M
+++++
induction H as [M N H| M1 M2 N1 N2 H HrecH| M1 M2 N1 N2 H HrecH| M N K L H HrecH H0].
-----
Lemma analysis_transpose_transpose_analysis : forall h : hedge, equal (analysis (transpose h)) (transpose (analysis h)).
unfold equal in |- *.
unfold inclusion in |- *.
intros.
unfold transpose in |- *.
split.
intros M N.
intro.
induction H as [M N H| M1 M2 N1 N2 H HrecH| M1 M2 N1 N2 H HrecH| M N K L H HrecH H0].

*****
H : h N M
M,N : Msg
h : hedge
*****
analysis h N M
+++++
apply AnaInc.
-----
Lemma analysis_transpose_transpose_analysis : forall h : hedge, equal (analysis (transpose h)) (transpose (analysis h)).
unfold equal in |- *.
unfold inclusion in |- *.
intros.
unfold transpose in |- *.
split.
intros M N.
intro.
induction H as [M N H| M1 M2 N1 N2 H HrecH| M1 M2 N1 N2 H HrecH| M N K L H HrecH H0].
apply AnaInc.

*****
H : h N M
M,N : Msg
h : hedge
*****
h N M
+++++
trivial.
-----
Lemma analysis_transpose_transpose_analysis : forall h : hedge, equal (analysis (transpose h)) (transpose (analysis h)).
unfold equal in |- *.
unfold inclusion in |- *.
intros.
unfold transpose in |- *.
split.
intros M N.
intro.
induction H as [M N H| M1 M2 N1 N2 H HrecH| M1 M2 N1 N2 H HrecH| M N K L H HrecH H0].

*****
HrecH : analysis h (MPair N1 N2) (MPair M1 M2)
H : analysis (fun M N : Msg => h N M) (MPair M1 M2) (MPair N1 N2)
M1,M2,N1,N2 : Msg
h : hedge
*****
analysis h N1 M1
+++++
apply (AnaSplitL h N1 N2 M1 M2).
-----
Lemma analysis_transpose_transpose_analysis : forall h : hedge, equal (analysis (transpose h)) (transpose (analysis h)).
unfold equal in |- *.
unfold inclusion in |- *.
intros.
unfold transpose in |- *.
split.
intros M N.
intro.
induction H as [M N H| M1 M2 N1 N2 H HrecH| M1 M2 N1 N2 H HrecH| M N K L H HrecH H0].
apply (AnaSplitL h N1 N2 M1 M2).

*****
HrecH : analysis h (MPair N1 N2) (MPair M1 M2)
H : analysis (fun M N : Msg => h N M) (MPair M1 M2) (MPair N1 N2)
M1,M2,N1,N2 : Msg
h : hedge
*****
analysis h (MPair N1 N2) (MPair M1 M2)
+++++
trivial.
-----
Lemma analysis_transpose_transpose_analysis : forall h : hedge, equal (analysis (transpose h)) (transpose (analysis h)).
unfold equal in |- *.
unfold inclusion in |- *.
intros.
unfold transpose in |- *.
split.
intros M N.
intro.
induction H as [M N H| M1 M2 N1 N2 H HrecH| M1 M2 N1 N2 H HrecH| M N K L H HrecH H0].

*****
HrecH : analysis h (MPair N1 N2) (MPair M1 M2)
H : analysis (fun M N : Msg => h N M) (MPair M1 M2) (MPair N1 N2)
M1,M2,N1,N2 : Msg
h : hedge
*****
analysis h N2 M2
+++++
apply (AnaSplitR h N1 N2 M1 M2).
-----
Lemma analysis_transpose_transpose_analysis : forall h : hedge, equal (analysis (transpose h)) (transpose (analysis h)).
unfold equal in |- *.
unfold inclusion in |- *.
intros.
unfold transpose in |- *.
split.
intros M N.
intro.
induction H as [M N H| M1 M2 N1 N2 H HrecH| M1 M2 N1 N2 H HrecH| M N K L H HrecH H0].
apply (AnaSplitR h N1 N2 M1 M2).

*****
HrecH : analysis h (MPair N1 N2) (MPair M1 M2)
H : analysis (fun M N : Msg => h N M) (MPair M1 M2) (MPair N1 N2)
M1,M2,N1,N2 : Msg
h : hedge
*****
analysis h (MPair N1 N2) (MPair M1 M2)
+++++
trivial.
-----
Lemma analysis_transpose_transpose_analysis : forall h : hedge, equal (analysis (transpose h)) (transpose (analysis h)).
unfold equal in |- *.
unfold inclusion in |- *.
intros.
unfold transpose in |- *.
split.
intros M N.
intro.
induction H as [M N H| M1 M2 N1 N2 H HrecH| M1 M2 N1 N2 H HrecH| M N K L H HrecH H0].

*****
HrecH : analysis h (MEnc N L) (MEnc M K)
H0 : synthesis (fun M N : Msg => h N M) (inv K) (inv L)
H : analysis (fun M N : Msg => h N M) (MEnc M K) (MEnc N L)
M,N,K,L : Msg
h : hedge
*****
analysis h N M
+++++
apply (AnaDec h N M L K).
-----
Lemma analysis_transpose_transpose_analysis : forall h : hedge, equal (analysis (transpose h)) (transpose (analysis h)).
unfold equal in |- *.
unfold inclusion in |- *.
intros.
unfold transpose in |- *.
split.
intros M N.
intro.
induction H as [M N H| M1 M2 N1 N2 H HrecH| M1 M2 N1 N2 H HrecH| M N K L H HrecH H0].
apply (AnaDec h N M L K).

*****
HrecH : analysis h (MEnc N L) (MEnc M K)
H0 : synthesis (fun M N : Msg => h N M) (inv K) (inv L)
H : analysis (fun M N : Msg => h N M) (MEnc M K) (MEnc N L)
M,N,K,L : Msg
h : hedge
*****
analysis h (MEnc N L) (MEnc M K)
+++++
trivial.
-----
Lemma analysis_transpose_transpose_analysis : forall h : hedge, equal (analysis (transpose h)) (transpose (analysis h)).
unfold equal in |- *.
unfold inclusion in |- *.
intros.
unfold transpose in |- *.
split.
intros M N.
intro.
induction H as [M N H| M1 M2 N1 N2 H HrecH| M1 M2 N1 N2 H HrecH| M N K L H HrecH H0].
apply (AnaDec h N M L K).

*****
HrecH : analysis h (MEnc N L) (MEnc M K)
H0 : synthesis (fun M N : Msg => h N M) (inv K) (inv L)
H : analysis (fun M N : Msg => h N M) (MEnc M K) (MEnc N L)
M,N,K,L : Msg
h : hedge
*****
synthesis h (inv L) (inv K)
+++++
generalize (synthesis_transpose_transpose_synthesis h).
-----
Lemma analysis_transpose_transpose_analysis : forall h : hedge, equal (analysis (transpose h)) (transpose (analysis h)).
unfold equal in |- *.
unfold inclusion in |- *.
intros.
unfold transpose in |- *.
split.
intros M N.
intro.
induction H as [M N H| M1 M2 N1 N2 H HrecH| M1 M2 N1 N2 H HrecH| M N K L H HrecH H0].
apply (AnaDec h N M L K).
generalize (synthesis_transpose_transpose_synthesis h).

*****
HrecH : analysis h (MEnc N L) (MEnc M K)
H0 : synthesis (fun M N : Msg => h N M) (inv K) (inv L)
H : analysis (fun M N : Msg => h N M) (MEnc M K) (MEnc N L)
M,N,K,L : Msg
h : hedge
*****
forall _ : equal (synthesis (transpose h)) (transpose (synthesis h)), synthesis h (inv L) (inv K)
+++++
unfold equal in |- *.
-----
Lemma analysis_transpose_transpose_analysis : forall h : hedge, equal (analysis (transpose h)) (transpose (analysis h)).
unfold equal in |- *.
unfold inclusion in |- *.
intros.
unfold transpose in |- *.
split.
intros M N.
intro.
induction H as [M N H| M1 M2 N1 N2 H HrecH| M1 M2 N1 N2 H HrecH| M N K L H HrecH H0].
apply (AnaDec h N M L K).
generalize (synthesis_transpose_transpose_synthesis h).
unfold equal in |- *.

*****
HrecH : analysis h (MEnc N L) (MEnc M K)
H0 : synthesis (fun M N : Msg => h N M) (inv K) (inv L)
H : analysis (fun M N : Msg => h N M) (MEnc M K) (MEnc N L)
M,N,K,L : Msg
h : hedge
*****
forall _ : and (inclusion (synthesis (transpose h)) (transpose (synthesis h))) (inclusion (transpose (synthesis h)) (synthesis (transpose h))), synthesis h (inv L) (inv K)
+++++
unfold inclusion in |- *.
-----
Lemma analysis_transpose_transpose_analysis : forall h : hedge, equal (analysis (transpose h)) (transpose (analysis h)).
unfold equal in |- *.
unfold inclusion in |- *.
intros.
unfold transpose in |- *.
split.
intros M N.
intro.
induction H as [M N H| M1 M2 N1 N2 H HrecH| M1 M2 N1 N2 H HrecH| M N K L H HrecH H0].
apply (AnaDec h N M L K).
generalize (synthesis_transpose_transpose_synthesis h).
unfold equal in |- *.
unfold inclusion in |- *.

*****
HrecH : analysis h (MEnc N L) (MEnc M K)
H0 : synthesis (fun M N : Msg => h N M) (inv K) (inv L)
H : analysis (fun M N : Msg => h N M) (MEnc M K) (MEnc N L)
M,N,K,L : Msg
h : hedge
*****
forall _ : and (forall (M N : Msg) (_ : synthesis (transpose h) M N), transpose (synthesis h) M N) (forall (M N : Msg) (_ : transpose (synthesis h) M N), synthesis (transpose h) M N), synthesis h (inv L) (inv K)
+++++
intros.
-----
Lemma analysis_transpose_transpose_analysis : forall h : hedge, equal (analysis (transpose h)) (transpose (analysis h)).
unfold equal in |- *.
unfold inclusion in |- *.
intros.
unfold transpose in |- *.
split.
intros M N.
intro.
induction H as [M N H| M1 M2 N1 N2 H HrecH| M1 M2 N1 N2 H HrecH| M N K L H HrecH H0].
apply (AnaDec h N M L K).
generalize (synthesis_transpose_transpose_synthesis h).
unfold equal in |- *.
unfold inclusion in |- *.
intros.

*****
H1 : and\n (forall (M N : Msg) (_ : synthesis (transpose h) M N),\n transpose (synthesis h) M N)\n (forall (M N : Msg) (_ : transpose (synthesis h) M N),\n synthesis (transpose h) M N)
HrecH : analysis h (MEnc N L) (MEnc M K)
H0 : synthesis (fun M N : Msg => h N M) (inv K) (inv L)
H : analysis (fun M N : Msg => h N M) (MEnc M K) (MEnc N L)
M,N,K,L : Msg
h : hedge
*****
synthesis h (inv L) (inv K)
+++++
elim H1.
-----
Lemma analysis_transpose_transpose_analysis : forall h : hedge, equal (analysis (transpose h)) (transpose (analysis h)).
unfold equal in |- *.
unfold inclusion in |- *.
intros.
unfold transpose in |- *.
split.
intros M N.
intro.
induction H as [M N H| M1 M2 N1 N2 H HrecH| M1 M2 N1 N2 H HrecH| M N K L H HrecH H0].
apply (AnaDec h N M L K).
generalize (synthesis_transpose_transpose_synthesis h).
unfold equal in |- *.
unfold inclusion in |- *.
intros.
elim H1.

*****
H1 : and\n (forall (M N : Msg) (_ : synthesis (transpose h) M N),\n transpose (synthesis h) M N)\n (forall (M N : Msg) (_ : transpose (synthesis h) M N),\n synthesis (transpose h) M N)
HrecH : analysis h (MEnc N L) (MEnc M K)
H0 : synthesis (fun M N : Msg => h N M) (inv K) (inv L)
H : analysis (fun M N : Msg => h N M) (MEnc M K) (MEnc N L)
M,N,K,L : Msg
h : hedge
*****
forall (_ : forall (M N : Msg) (_ : synthesis (transpose h) M N), transpose (synthesis h) M N) (_ : forall (M N : Msg) (_ : transpose (synthesis h) M N), synthesis (transpose h) M N), synthesis h (inv L) (inv K)
+++++
intros.
-----
Lemma analysis_transpose_transpose_analysis : forall h : hedge, equal (analysis (transpose h)) (transpose (analysis h)).
unfold equal in |- *.
unfold inclusion in |- *.
intros.
unfold transpose in |- *.
split.
intros M N.
intro.
induction H as [M N H| M1 M2 N1 N2 H HrecH| M1 M2 N1 N2 H HrecH| M N K L H HrecH H0].
apply (AnaDec h N M L K).
generalize (synthesis_transpose_transpose_synthesis h).
unfold equal in |- *.
unfold inclusion in |- *.
intros.
elim H1.
intros.

*****
H3 : forall (M N : Msg) (_ : transpose (synthesis h) M N),\nsynthesis (transpose h) M N
H2 : forall (M N : Msg) (_ : synthesis (transpose h) M N),\ntranspose (synthesis h) M N
H1 : and\n (forall (M N : Msg) (_ : synthesis (transpose h) M N),\n transpose (synthesis h) M N)\n (forall (M N : Msg) (_ : transpose (synthesis h) M N),\n synthesis (transpose h) M N)
HrecH : analysis h (MEnc N L) (MEnc M K)
H0 : synthesis (fun M N : Msg => h N M) (inv K) (inv L)
H : analysis (fun M N : Msg => h N M) (MEnc M K) (MEnc N L)
M,N,K,L : Msg
h : hedge
*****
synthesis h (inv L) (inv K)
+++++
unfold transpose in H2.
-----
Lemma analysis_transpose_transpose_analysis : forall h : hedge, equal (analysis (transpose h)) (transpose (analysis h)).
unfold equal in |- *.
unfold inclusion in |- *.
intros.
unfold transpose in |- *.
split.
intros M N.
intro.
induction H as [M N H| M1 M2 N1 N2 H HrecH| M1 M2 N1 N2 H HrecH| M N K L H HrecH H0].
apply (AnaDec h N M L K).
generalize (synthesis_transpose_transpose_synthesis h).
unfold equal in |- *.
unfold inclusion in |- *.
intros.
elim H1.
intros.
unfold transpose in H2.

*****
H3 : forall (M N : Msg) (_ : transpose (synthesis h) M N),\nsynthesis (transpose h) M N
H2 : forall (M N : Msg) (_ : synthesis (fun M0 N0 : Msg => h N0 M0) M N),\nsynthesis h N M
H1 : and\n (forall (M N : Msg) (_ : synthesis (transpose h) M N),\n transpose (synthesis h) M N)\n (forall (M N : Msg) (_ : transpose (synthesis h) M N),\n synthesis (transpose h) M N)
HrecH : analysis h (MEnc N L) (MEnc M K)
H0 : synthesis (fun M N : Msg => h N M) (inv K) (inv L)
H : analysis (fun M N : Msg => h N M) (MEnc M K) (MEnc N L)
M,N,K,L : Msg
h : hedge
*****
synthesis h (inv L) (inv K)
+++++
auto.
-----
Lemma analysis_transpose_transpose_analysis : forall h : hedge, equal (analysis (transpose h)) (transpose (analysis h)).
unfold equal in |- *.
unfold inclusion in |- *.
intros.
unfold transpose in |- *.
split.

*****
h : hedge
*****
forall (M N : Msg) (_ : analysis h N M), analysis (fun M0 N0 : Msg => h N0 M0) M N
+++++
intros M N.
-----
Lemma analysis_transpose_transpose_analysis : forall h : hedge, equal (analysis (transpose h)) (transpose (analysis h)).
unfold equal in |- *.
unfold inclusion in |- *.
intros.
unfold transpose in |- *.
split.
intros M N.

*****
M,N : Msg
h : hedge
*****
forall _ : analysis h N M, analysis (fun M N : Msg => h N M) M N
+++++
intro.
-----
Lemma analysis_transpose_transpose_analysis : forall h : hedge, equal (analysis (transpose h)) (transpose (analysis h)).
unfold equal in |- *.
unfold inclusion in |- *.
intros.
unfold transpose in |- *.
split.
intros M N.
intro.

*****
H : analysis h N M
M,N : Msg
h : hedge
*****
analysis (fun M N : Msg => h N M) M N
+++++
induction H as [M N H| M1 M2 N1 N2 H HrecH| M1 M2 N1 N2 H HrecH| M N K L H HrecH H0].
-----
Lemma analysis_transpose_transpose_analysis : forall h : hedge, equal (analysis (transpose h)) (transpose (analysis h)).
unfold equal in |- *.
unfold inclusion in |- *.
intros.
unfold transpose in |- *.
split.
intros M N.
intro.
induction H as [M N H| M1 M2 N1 N2 H HrecH| M1 M2 N1 N2 H HrecH| M N K L H HrecH H0].

*****
H : h M N
M,N : Msg
h : hedge
*****
analysis (fun M N : Msg => h N M) N M
+++++
apply AnaInc.
-----
Lemma analysis_transpose_transpose_analysis : forall h : hedge, equal (analysis (transpose h)) (transpose (analysis h)).
unfold equal in |- *.
unfold inclusion in |- *.
intros.
unfold transpose in |- *.
split.
intros M N.
intro.
induction H as [M N H| M1 M2 N1 N2 H HrecH| M1 M2 N1 N2 H HrecH| M N K L H HrecH H0].
apply AnaInc.

*****
H : h M N
M,N : Msg
h : hedge
*****
h M N
+++++
trivial.
-----
Lemma analysis_transpose_transpose_analysis : forall h : hedge, equal (analysis (transpose h)) (transpose (analysis h)).
unfold equal in |- *.
unfold inclusion in |- *.
intros.
unfold transpose in |- *.
split.
intros M N.
intro.
induction H as [M N H| M1 M2 N1 N2 H HrecH| M1 M2 N1 N2 H HrecH| M N K L H HrecH H0].

*****
HrecH : analysis (fun M N : Msg => h N M) (MPair N1 N2) (MPair M1 M2)
H : analysis h (MPair M1 M2) (MPair N1 N2)
M1,M2,N1,N2 : Msg
h : hedge
*****
analysis (fun M N : Msg => h N M) N1 M1
+++++
apply (AnaSplitL (fun M N : Msg => h N M) N1 N2 M1 M2).
-----
Lemma analysis_transpose_transpose_analysis : forall h : hedge, equal (analysis (transpose h)) (transpose (analysis h)).
unfold equal in |- *.
unfold inclusion in |- *.
intros.
unfold transpose in |- *.
split.
intros M N.
intro.
induction H as [M N H| M1 M2 N1 N2 H HrecH| M1 M2 N1 N2 H HrecH| M N K L H HrecH H0].
apply (AnaSplitL (fun M N : Msg => h N M) N1 N2 M1 M2).

*****
HrecH : analysis (fun M N : Msg => h N M) (MPair N1 N2) (MPair M1 M2)
H : analysis h (MPair M1 M2) (MPair N1 N2)
M1,M2,N1,N2 : Msg
h : hedge
*****
analysis (fun M N : Msg => h N M) (MPair N1 N2) (MPair M1 M2)
+++++
trivial.
-----
Lemma analysis_transpose_transpose_analysis : forall h : hedge, equal (analysis (transpose h)) (transpose (analysis h)).
unfold equal in |- *.
unfold inclusion in |- *.
intros.
unfold transpose in |- *.
split.
intros M N.
intro.
induction H as [M N H| M1 M2 N1 N2 H HrecH| M1 M2 N1 N2 H HrecH| M N K L H HrecH H0].

*****
HrecH : analysis (fun M N : Msg => h N M) (MPair N1 N2) (MPair M1 M2)
H : analysis h (MPair M1 M2) (MPair N1 N2)
M1,M2,N1,N2 : Msg
h : hedge
*****
analysis (fun M N : Msg => h N M) N2 M2
+++++
apply (AnaSplitR (fun M N : Msg => h N M) N1 N2 M1 M2).
-----
Lemma analysis_transpose_transpose_analysis : forall h : hedge, equal (analysis (transpose h)) (transpose (analysis h)).
unfold equal in |- *.
unfold inclusion in |- *.
intros.
unfold transpose in |- *.
split.
intros M N.
intro.
induction H as [M N H| M1 M2 N1 N2 H HrecH| M1 M2 N1 N2 H HrecH| M N K L H HrecH H0].
apply (AnaSplitR (fun M N : Msg => h N M) N1 N2 M1 M2).

*****
HrecH : analysis (fun M N : Msg => h N M) (MPair N1 N2) (MPair M1 M2)
H : analysis h (MPair M1 M2) (MPair N1 N2)
M1,M2,N1,N2 : Msg
h : hedge
*****
analysis (fun M N : Msg => h N M) (MPair N1 N2) (MPair M1 M2)
+++++
trivial.
-----
Lemma analysis_transpose_transpose_analysis : forall h : hedge, equal (analysis (transpose h)) (transpose (analysis h)).
unfold equal in |- *.
unfold inclusion in |- *.
intros.
unfold transpose in |- *.
split.
intros M N.
intro.
induction H as [M N H| M1 M2 N1 N2 H HrecH| M1 M2 N1 N2 H HrecH| M N K L H HrecH H0].

*****
HrecH : analysis (fun M N : Msg => h N M) (MEnc N L) (MEnc M K)
H0 : synthesis h (inv K) (inv L)
H : analysis h (MEnc M K) (MEnc N L)
M,N,K,L : Msg
h : hedge
*****
analysis (fun M N : Msg => h N M) N M
+++++
apply (AnaDec (fun M N : Msg => h N M) N M L K).
-----
Lemma analysis_transpose_transpose_analysis : forall h : hedge, equal (analysis (transpose h)) (transpose (analysis h)).
unfold equal in |- *.
unfold inclusion in |- *.
intros.
unfold transpose in |- *.
split.
intros M N.
intro.
induction H as [M N H| M1 M2 N1 N2 H HrecH| M1 M2 N1 N2 H HrecH| M N K L H HrecH H0].
apply (AnaDec (fun M N : Msg => h N M) N M L K).

*****
HrecH : analysis (fun M N : Msg => h N M) (MEnc N L) (MEnc M K)
H0 : synthesis h (inv K) (inv L)
H : analysis h (MEnc M K) (MEnc N L)
M,N,K,L : Msg
h : hedge
*****
analysis (fun M N : Msg => h N M) (MEnc N L) (MEnc M K)
+++++
trivial.
-----
Lemma analysis_transpose_transpose_analysis : forall h : hedge, equal (analysis (transpose h)) (transpose (analysis h)).
unfold equal in |- *.
unfold inclusion in |- *.
intros.
unfold transpose in |- *.
split.
intros M N.
intro.
induction H as [M N H| M1 M2 N1 N2 H HrecH| M1 M2 N1 N2 H HrecH| M N K L H HrecH H0].
apply (AnaDec (fun M N : Msg => h N M) N M L K).

*****
HrecH : analysis (fun M N : Msg => h N M) (MEnc N L) (MEnc M K)
H0 : synthesis h (inv K) (inv L)
H : analysis h (MEnc M K) (MEnc N L)
M,N,K,L : Msg
h : hedge
*****
synthesis (fun M N : Msg => h N M) (inv L) (inv K)
+++++
trivial.
-----
Lemma analysis_transpose_transpose_analysis : forall h : hedge, equal (analysis (transpose h)) (transpose (analysis h)).
unfold equal in |- *.
unfold inclusion in |- *.
intros.
unfold transpose in |- *.
split.
intros M N.
intro.
induction H as [M N H| M1 M2 N1 N2 H HrecH| M1 M2 N1 N2 H HrecH| M N K L H HrecH H0].
apply (AnaDec (fun M N : Msg => h N M) N M L K).
trivial.

*****
HrecH : analysis (fun M N : Msg => h N M) (MEnc N L) (MEnc M K)
H0 : synthesis h (inv K) (inv L)
H : analysis h (MEnc M K) (MEnc N L)
M,N,K,L : Msg
h : hedge
*****
synthesis (fun M N : Msg => h N M) (inv L) (inv K)
+++++
generalize (synthesis_transpose_transpose_synthesis h).
-----
Lemma analysis_transpose_transpose_analysis : forall h : hedge, equal (analysis (transpose h)) (transpose (analysis h)).
unfold equal in |- *.
unfold inclusion in |- *.
intros.
unfold transpose in |- *.
split.
intros M N.
intro.
induction H as [M N H| M1 M2 N1 N2 H HrecH| M1 M2 N1 N2 H HrecH| M N K L H HrecH H0].
apply (AnaDec (fun M N : Msg => h N M) N M L K).
trivial.
generalize (synthesis_transpose_transpose_synthesis h).

*****
HrecH : analysis (fun M N : Msg => h N M) (MEnc N L) (MEnc M K)
H0 : synthesis h (inv K) (inv L)
H : analysis h (MEnc M K) (MEnc N L)
M,N,K,L : Msg
h : hedge
*****
forall _ : equal (synthesis (transpose h)) (transpose (synthesis h)), synthesis (fun M N : Msg => h N M) (inv L) (inv K)
+++++
unfold equal in |- *.
-----
Lemma analysis_transpose_transpose_analysis : forall h : hedge, equal (analysis (transpose h)) (transpose (analysis h)).
unfold equal in |- *.
unfold inclusion in |- *.
intros.
unfold transpose in |- *.
split.
intros M N.
intro.
induction H as [M N H| M1 M2 N1 N2 H HrecH| M1 M2 N1 N2 H HrecH| M N K L H HrecH H0].
apply (AnaDec (fun M N : Msg => h N M) N M L K).
trivial.
generalize (synthesis_transpose_transpose_synthesis h).
unfold equal in |- *.

*****
HrecH : analysis (fun M N : Msg => h N M) (MEnc N L) (MEnc M K)
H0 : synthesis h (inv K) (inv L)
H : analysis h (MEnc M K) (MEnc N L)
M,N,K,L : Msg
h : hedge
*****
forall _ : and (inclusion (synthesis (transpose h)) (transpose (synthesis h))) (inclusion (transpose (synthesis h)) (synthesis (transpose h))), synthesis (fun M N : Msg => h N M) (inv L) (inv K)
+++++
unfold inclusion in |- *.
-----
Lemma analysis_transpose_transpose_analysis : forall h : hedge, equal (analysis (transpose h)) (transpose (analysis h)).
unfold equal in |- *.
unfold inclusion in |- *.
intros.
unfold transpose in |- *.
split.
intros M N.
intro.
induction H as [M N H| M1 M2 N1 N2 H HrecH| M1 M2 N1 N2 H HrecH| M N K L H HrecH H0].
apply (AnaDec (fun M N : Msg => h N M) N M L K).
trivial.
generalize (synthesis_transpose_transpose_synthesis h).
unfold equal in |- *.
unfold inclusion in |- *.

*****
HrecH : analysis (fun M N : Msg => h N M) (MEnc N L) (MEnc M K)
H0 : synthesis h (inv K) (inv L)
H : analysis h (MEnc M K) (MEnc N L)
M,N,K,L : Msg
h : hedge
*****
forall _ : and (forall (M N : Msg) (_ : synthesis (transpose h) M N), transpose (synthesis h) M N) (forall (M N : Msg) (_ : transpose (synthesis h) M N), synthesis (transpose h) M N), synthesis (fun M N : Msg => h N M) (inv L) (inv K)
+++++
intro.
-----
Lemma analysis_transpose_transpose_analysis : forall h : hedge, equal (analysis (transpose h)) (transpose (analysis h)).
unfold equal in |- *.
unfold inclusion in |- *.
intros.
unfold transpose in |- *.
split.
intros M N.
intro.
induction H as [M N H| M1 M2 N1 N2 H HrecH| M1 M2 N1 N2 H HrecH| M N K L H HrecH H0].
apply (AnaDec (fun M N : Msg => h N M) N M L K).
trivial.
generalize (synthesis_transpose_transpose_synthesis h).
unfold equal in |- *.
unfold inclusion in |- *.
intro.

*****
H1 : and\n (forall (M N : Msg) (_ : synthesis (transpose h) M N),\n transpose (synthesis h) M N)\n (forall (M N : Msg) (_ : transpose (synthesis h) M N),\n synthesis (transpose h) M N)
HrecH : analysis (fun M N : Msg => h N M) (MEnc N L) (MEnc M K)
H0 : synthesis h (inv K) (inv L)
H : analysis h (MEnc M K) (MEnc N L)
M,N,K,L : Msg
h : hedge
*****
synthesis (fun M N : Msg => h N M) (inv L) (inv K)
+++++
elim H1.
-----
Lemma analysis_transpose_transpose_analysis : forall h : hedge, equal (analysis (transpose h)) (transpose (analysis h)).
unfold equal in |- *.
unfold inclusion in |- *.
intros.
unfold transpose in |- *.
split.
intros M N.
intro.
induction H as [M N H| M1 M2 N1 N2 H HrecH| M1 M2 N1 N2 H HrecH| M N K L H HrecH H0].
apply (AnaDec (fun M N : Msg => h N M) N M L K).
trivial.
generalize (synthesis_transpose_transpose_synthesis h).
unfold equal in |- *.
unfold inclusion in |- *.
intro.
elim H1.

*****
H1 : and\n (forall (M N : Msg) (_ : synthesis (transpose h) M N),\n transpose (synthesis h) M N)\n (forall (M N : Msg) (_ : transpose (synthesis h) M N),\n synthesis (transpose h) M N)
HrecH : analysis (fun M N : Msg => h N M) (MEnc N L) (MEnc M K)
H0 : synthesis h (inv K) (inv L)
H : analysis h (MEnc M K) (MEnc N L)
M,N,K,L : Msg
h : hedge
*****
forall (_ : forall (M N : Msg) (_ : synthesis (transpose h) M N), transpose (synthesis h) M N) (_ : forall (M N : Msg) (_ : transpose (synthesis h) M N), synthesis (transpose h) M N), synthesis (fun M N : Msg => h N M) (inv L) (inv K)
+++++
intros.
-----
Lemma analysis_transpose_transpose_analysis : forall h : hedge, equal (analysis (transpose h)) (transpose (analysis h)).
unfold equal in |- *.
unfold inclusion in |- *.
intros.
unfold transpose in |- *.
split.
intros M N.
intro.
induction H as [M N H| M1 M2 N1 N2 H HrecH| M1 M2 N1 N2 H HrecH| M N K L H HrecH H0].
apply (AnaDec (fun M N : Msg => h N M) N M L K).
trivial.
generalize (synthesis_transpose_transpose_synthesis h).
unfold equal in |- *.
unfold inclusion in |- *.
intro.
elim H1.
intros.

*****
H3 : forall (M N : Msg) (_ : transpose (synthesis h) M N),\nsynthesis (transpose h) M N
H2 : forall (M N : Msg) (_ : synthesis (transpose h) M N),\ntranspose (synthesis h) M N
H1 : and\n (forall (M N : Msg) (_ : synthesis (transpose h) M N),\n transpose (synthesis h) M N)\n (forall (M N : Msg) (_ : transpose (synthesis h) M N),\n synthesis (transpose h) M N)
HrecH : analysis (fun M N : Msg => h N M) (MEnc N L) (MEnc M K)
H0 : synthesis h (inv K) (inv L)
H : analysis h (MEnc M K) (MEnc N L)
M,N,K,L : Msg
h : hedge
*****
synthesis (fun M N : Msg => h N M) (inv L) (inv K)
+++++
unfold transpose in H3.
-----
Lemma analysis_transpose_transpose_analysis : forall h : hedge, equal (analysis (transpose h)) (transpose (analysis h)).
unfold equal in |- *.
unfold inclusion in |- *.
intros.
unfold transpose in |- *.
split.
intros M N.
intro.
induction H as [M N H| M1 M2 N1 N2 H HrecH| M1 M2 N1 N2 H HrecH| M N K L H HrecH H0].
apply (AnaDec (fun M N : Msg => h N M) N M L K).
trivial.
generalize (synthesis_transpose_transpose_synthesis h).
unfold equal in |- *.
unfold inclusion in |- *.
intro.
elim H1.
intros.
unfold transpose in H3.

*****
H3 : forall (M N : Msg) (_ : synthesis h N M),\nsynthesis (fun M0 N0 : Msg => h N0 M0) M N
H2 : forall (M N : Msg) (_ : synthesis (transpose h) M N),\ntranspose (synthesis h) M N
H1 : and\n (forall (M N : Msg) (_ : synthesis (transpose h) M N),\n transpose (synthesis h) M N)\n (forall (M N : Msg) (_ : transpose (synthesis h) M N),\n synthesis (transpose h) M N)
HrecH : analysis (fun M N : Msg => h N M) (MEnc N L) (MEnc M K)
H0 : synthesis h (inv K) (inv L)
H : analysis h (MEnc M K) (MEnc N L)
M,N,K,L : Msg
h : hedge
*****
synthesis (fun M N : Msg => h N M) (inv L) (inv K)
+++++
auto.
-----
Lemma analysis_transpose_transpose_analysis : forall h : hedge, equal (analysis (transpose h)) (transpose (analysis h)).
unfold equal in |- *.
unfold inclusion in |- *.
intros.
unfold transpose in |- *.
split.

*****

*****

+++++
Qed.
-----
Lemma stable_impl_transpose_stable :\n forall h : hedge, stable_analysis h -> stable_analysis (transpose h).
-----
Lemma stable_impl_transpose_stable : forall h : hedge, stable_analysis h -> stable_analysis (transpose h).

*****

*****
forall (h : hedge) (_ : stable_analysis h), stable_analysis (transpose h)
+++++
unfold stable_analysis in |- *.
-----
Lemma stable_impl_transpose_stable : forall h : hedge, stable_analysis h -> stable_analysis (transpose h).
unfold stable_analysis in |- *.

*****

*****
forall (h : hedge) (_ : inclusion (analysis h) h), inclusion (analysis (transpose h)) (transpose h)
+++++
unfold inclusion in |- *.
-----
Lemma stable_impl_transpose_stable : forall h : hedge, stable_analysis h -> stable_analysis (transpose h).
unfold stable_analysis in |- *.
unfold inclusion in |- *.

*****

*****
forall (h : hedge) (_ : forall (M N : Msg) (_ : analysis h M N), h M N) (M N : Msg) (_ : analysis (transpose h) M N), transpose h M N
+++++
intros.
-----
Lemma stable_impl_transpose_stable : forall h : hedge, stable_analysis h -> stable_analysis (transpose h).
unfold stable_analysis in |- *.
unfold inclusion in |- *.
intros.

*****
H0 : analysis (transpose h) M N
M,N : Msg
H : forall (M N : Msg) (_ : analysis h M N), h M N
h : hedge
*****
transpose h M N
+++++
generalize (analysis_transpose_transpose_analysis h).
-----
Lemma stable_impl_transpose_stable : forall h : hedge, stable_analysis h -> stable_analysis (transpose h).
unfold stable_analysis in |- *.
unfold inclusion in |- *.
intros.
generalize (analysis_transpose_transpose_analysis h).

*****
H0 : analysis (transpose h) M N
M,N : Msg
H : forall (M N : Msg) (_ : analysis h M N), h M N
h : hedge
*****
forall _ : equal (analysis (transpose h)) (transpose (analysis h)), transpose h M N
+++++
unfold equal in |- *.
-----
Lemma stable_impl_transpose_stable : forall h : hedge, stable_analysis h -> stable_analysis (transpose h).
unfold stable_analysis in |- *.
unfold inclusion in |- *.
intros.
generalize (analysis_transpose_transpose_analysis h).
unfold equal in |- *.

*****
H0 : analysis (transpose h) M N
M,N : Msg
H : forall (M N : Msg) (_ : analysis h M N), h M N
h : hedge
*****
forall _ : and (inclusion (analysis (transpose h)) (transpose (analysis h))) (inclusion (transpose (analysis h)) (analysis (transpose h))), transpose h M N
+++++
intro.
-----
Lemma stable_impl_transpose_stable : forall h : hedge, stable_analysis h -> stable_analysis (transpose h).
unfold stable_analysis in |- *.
unfold inclusion in |- *.
intros.
generalize (analysis_transpose_transpose_analysis h).
unfold equal in |- *.
intro.

*****
H1 : and (inclusion (analysis (transpose h)) (transpose (analysis h)))\n (inclusion (transpose (analysis h)) (analysis (transpose h)))
H0 : analysis (transpose h) M N
M,N : Msg
H : forall (M N : Msg) (_ : analysis h M N), h M N
h : hedge
*****
transpose h M N
+++++
elim H1.
-----
Lemma stable_impl_transpose_stable : forall h : hedge, stable_analysis h -> stable_analysis (transpose h).
unfold stable_analysis in |- *.
unfold inclusion in |- *.
intros.
generalize (analysis_transpose_transpose_analysis h).
unfold equal in |- *.
intro.
elim H1.

*****
H1 : and (inclusion (analysis (transpose h)) (transpose (analysis h)))\n (inclusion (transpose (analysis h)) (analysis (transpose h)))
H0 : analysis (transpose h) M N
M,N : Msg
H : forall (M N : Msg) (_ : analysis h M N), h M N
h : hedge
*****
forall (_ : inclusion (analysis (transpose h)) (transpose (analysis h))) (_ : inclusion (transpose (analysis h)) (analysis (transpose h))), transpose h M N
+++++
unfold inclusion in |- *.
-----
Lemma stable_impl_transpose_stable : forall h : hedge, stable_analysis h -> stable_analysis (transpose h).
unfold stable_analysis in |- *.
unfold inclusion in |- *.
intros.
generalize (analysis_transpose_transpose_analysis h).
unfold equal in |- *.
intro.
elim H1.
unfold inclusion in |- *.

*****
H1 : and (inclusion (analysis (transpose h)) (transpose (analysis h)))\n (inclusion (transpose (analysis h)) (analysis (transpose h)))
H0 : analysis (transpose h) M N
M,N : Msg
H : forall (M N : Msg) (_ : analysis h M N), h M N
h : hedge
*****
forall (_ : forall (M N : Msg) (_ : analysis (transpose h) M N), transpose (analysis h) M N) (_ : forall (M N : Msg) (_ : transpose (analysis h) M N), analysis (transpose h) M N), transpose h M N
+++++
intros.
-----
Lemma stable_impl_transpose_stable : forall h : hedge, stable_analysis h -> stable_analysis (transpose h).
unfold stable_analysis in |- *.
unfold inclusion in |- *.
intros.
generalize (analysis_transpose_transpose_analysis h).
unfold equal in |- *.
intro.
elim H1.
unfold inclusion in |- *.
intros.

*****
H3 : forall (M N : Msg) (_ : transpose (analysis h) M N),\nanalysis (transpose h) M N
H2 : forall (M N : Msg) (_ : analysis (transpose h) M N),\ntranspose (analysis h) M N
H1 : and (inclusion (analysis (transpose h)) (transpose (analysis h)))\n (inclusion (transpose (analysis h)) (analysis (transpose h)))
H0 : analysis (transpose h) M N
M,N : Msg
H : forall (M N : Msg) (_ : analysis h M N), h M N
h : hedge
*****
transpose h M N
+++++
generalize (H2 M N H0).
-----
Lemma stable_impl_transpose_stable : forall h : hedge, stable_analysis h -> stable_analysis (transpose h).
unfold stable_analysis in |- *.
unfold inclusion in |- *.
intros.
generalize (analysis_transpose_transpose_analysis h).
unfold equal in |- *.
intro.
elim H1.
unfold inclusion in |- *.
intros.
generalize (H2 M N H0).

*****
H3 : forall (M N : Msg) (_ : transpose (analysis h) M N),\nanalysis (transpose h) M N
H2 : forall (M N : Msg) (_ : analysis (transpose h) M N),\ntranspose (analysis h) M N
H1 : and (inclusion (analysis (transpose h)) (transpose (analysis h)))\n (inclusion (transpose (analysis h)) (analysis (transpose h)))
H0 : analysis (transpose h) M N
M,N : Msg
H : forall (M N : Msg) (_ : analysis h M N), h M N
h : hedge
*****
forall _ : transpose (analysis h) M N, transpose h M N
+++++
unfold transpose in |- *.
-----
Lemma stable_impl_transpose_stable : forall h : hedge, stable_analysis h -> stable_analysis (transpose h).
unfold stable_analysis in |- *.
unfold inclusion in |- *.
intros.
generalize (analysis_transpose_transpose_analysis h).
unfold equal in |- *.
intro.
elim H1.
unfold inclusion in |- *.
intros.
generalize (H2 M N H0).
unfold transpose in |- *.

*****
H3 : forall (M N : Msg) (_ : transpose (analysis h) M N),\nanalysis (transpose h) M N
H2 : forall (M N : Msg) (_ : analysis (transpose h) M N),\ntranspose (analysis h) M N
H1 : and (inclusion (analysis (transpose h)) (transpose (analysis h)))\n (inclusion (transpose (analysis h)) (analysis (transpose h)))
H0 : analysis (transpose h) M N
M,N : Msg
H : forall (M N : Msg) (_ : analysis h M N), h M N
h : hedge
*****
forall _ : analysis h N M, h N M
+++++
auto.
-----
Lemma stable_impl_transpose_stable : forall h : hedge, stable_analysis h -> stable_analysis (transpose h).
unfold stable_analysis in |- *.
unfold inclusion in |- *.
intros.
generalize (analysis_transpose_transpose_analysis h).
unfold equal in |- *.
intro.
elim H1.
unfold inclusion in |- *.
intros.
generalize (H2 M N H0).
unfold transpose in |- *.
auto.

*****

*****

+++++
Qed.
-----
Lemma ana_transpose_incl_transpose_ana :\n forall h : hedge,\n inclusion (analysis_def (transpose h)) (transpose (analysis_def h)).
-----
Lemma ana_transpose_incl_transpose_ana : forall h : hedge, inclusion (analysis_def (transpose h)) (transpose (analysis_def h)).

*****

*****
forall h : hedge, inclusion (analysis_def (transpose h)) (transpose (analysis_def h))
+++++
intro.
-----
Lemma ana_transpose_incl_transpose_ana : forall h : hedge, inclusion (analysis_def (transpose h)) (transpose (analysis_def h)).
intro.

*****
h : hedge
*****
inclusion (analysis_def (transpose h)) (transpose (analysis_def h))
+++++
generalize (analysis_is_analysis (transpose h)).
-----
Lemma ana_transpose_incl_transpose_ana : forall h : hedge, inclusion (analysis_def (transpose h)) (transpose (analysis_def h)).
intro.
generalize (analysis_is_analysis (transpose h)).

*****
h : hedge
*****
forall _ : is_analysis (transpose h) (analysis_def (transpose h)), inclusion (analysis_def (transpose h)) (transpose (analysis_def h))
+++++
generalize (analysis_is_analysis h).
-----
Lemma ana_transpose_incl_transpose_ana : forall h : hedge, inclusion (analysis_def (transpose h)) (transpose (analysis_def h)).
intro.
generalize (analysis_is_analysis (transpose h)).
generalize (analysis_is_analysis h).

*****
h : hedge
*****
forall (_ : is_analysis h (analysis_def h)) (_ : is_analysis (transpose h) (analysis_def (transpose h))), inclusion (analysis_def (transpose h)) (transpose (analysis_def h))
+++++
unfold is_analysis in |- *.
-----
Lemma ana_transpose_incl_transpose_ana : forall h : hedge, inclusion (analysis_def (transpose h)) (transpose (analysis_def h)).
intro.
generalize (analysis_is_analysis (transpose h)).
generalize (analysis_is_analysis h).
unfold is_analysis in |- *.

*****
h : hedge
*****
forall (_ : and (analysis_cond h (analysis_def h)) (forall (h' : hedge) (_ : analysis_cond h h'), inclusion (analysis_def h) h')) (_ : and (analysis_cond (transpose h) (analysis_def (transpose h))) (forall (h' : hedge) (_ : analysis_cond (transpose h) h'), inclusion (analysis_def (transpose h)) h')), inclusion (analysis_def (transpose h)) (transpose (analysis_def h))
+++++
unfold analysis_cond in |- *.
-----
Lemma ana_transpose_incl_transpose_ana : forall h : hedge, inclusion (analysis_def (transpose h)) (transpose (analysis_def h)).
intro.
generalize (analysis_is_analysis (transpose h)).
generalize (analysis_is_analysis h).
unfold is_analysis in |- *.
unfold analysis_cond in |- *.

*****
h : hedge
*****
forall (_ : and (and (inclusion h (analysis_def h)) (stable_analysis (analysis_def h))) (forall (h' : hedge) (_ : and (inclusion h h') (stable_analysis h')), inclusion (analysis_def h) h')) (_ : and (and (inclusion (transpose h) (analysis_def (transpose h))) (stable_analysis (analysis_def (transpose h)))) (forall (h' : hedge) (_ : and (inclusion (transpose h) h') (stable_analysis h')), inclusion (analysis_def (transpose h)) h')), inclusion (analysis_def (transpose h)) (transpose (analysis_def h))
+++++
intros.
-----
Lemma ana_transpose_incl_transpose_ana : forall h : hedge, inclusion (analysis_def (transpose h)) (transpose (analysis_def h)).
intro.
generalize (analysis_is_analysis (transpose h)).
generalize (analysis_is_analysis h).
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.

*****
H0 : and\n (and (inclusion (transpose h) (analysis_def (transpose h)))\n (stable_analysis (analysis_def (transpose h))))\n (forall (h' : hedge)\n (_ : and (inclusion (transpose h) h') (stable_analysis h')),\n inclusion (analysis_def (transpose h)) h')
H : and\n (and (inclusion h (analysis_def h))\n (stable_analysis (analysis_def h)))\n (forall (h' : hedge) (_ : and (inclusion h h') (stable_analysis h')),\n inclusion (analysis_def h) h')
h : hedge
*****
inclusion (analysis_def (transpose h)) (transpose (analysis_def h))
+++++
elim H0.
-----
Lemma ana_transpose_incl_transpose_ana : forall h : hedge, inclusion (analysis_def (transpose h)) (transpose (analysis_def h)).
intro.
generalize (analysis_is_analysis (transpose h)).
generalize (analysis_is_analysis h).
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.
elim H0.

*****
H0 : and\n (and (inclusion (transpose h) (analysis_def (transpose h)))\n (stable_analysis (analysis_def (transpose h))))\n (forall (h' : hedge)\n (_ : and (inclusion (transpose h) h') (stable_analysis h')),\n inclusion (analysis_def (transpose h)) h')
H : and\n (and (inclusion h (analysis_def h))\n (stable_analysis (analysis_def h)))\n (forall (h' : hedge) (_ : and (inclusion h h') (stable_analysis h')),\n inclusion (analysis_def h) h')
h : hedge
*****
forall (_ : and (inclusion (transpose h) (analysis_def (transpose h))) (stable_analysis (analysis_def (transpose h)))) (_ : forall (h' : hedge) (_ : and (inclusion (transpose h) h') (stable_analysis h')), inclusion (analysis_def (transpose h)) h'), inclusion (analysis_def (transpose h)) (transpose (analysis_def h))
+++++
intros.
-----
Lemma ana_transpose_incl_transpose_ana : forall h : hedge, inclusion (analysis_def (transpose h)) (transpose (analysis_def h)).
intro.
generalize (analysis_is_analysis (transpose h)).
generalize (analysis_is_analysis h).
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.
elim H0.
intros.

*****
H2 : forall (h' : hedge)\n (_ : and (inclusion (transpose h) h') (stable_analysis h')),\ninclusion (analysis_def (transpose h)) h'
H1 : and (inclusion (transpose h) (analysis_def (transpose h)))\n (stable_analysis (analysis_def (transpose h)))
H0 : and\n (and (inclusion (transpose h) (analysis_def (transpose h)))\n (stable_analysis (analysis_def (transpose h))))\n (forall (h' : hedge)\n (_ : and (inclusion (transpose h) h') (stable_analysis h')),\n inclusion (analysis_def (transpose h)) h')
H : and\n (and (inclusion h (analysis_def h))\n (stable_analysis (analysis_def h)))\n (forall (h' : hedge) (_ : and (inclusion h h') (stable_analysis h')),\n inclusion (analysis_def h) h')
h : hedge
*****
inclusion (analysis_def (transpose h)) (transpose (analysis_def h))
+++++
apply H2.
-----
Lemma ana_transpose_incl_transpose_ana : forall h : hedge, inclusion (analysis_def (transpose h)) (transpose (analysis_def h)).
intro.
generalize (analysis_is_analysis (transpose h)).
generalize (analysis_is_analysis h).
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.
elim H0.
intros.
apply H2.

*****
H2 : forall (h' : hedge)\n (_ : and (inclusion (transpose h) h') (stable_analysis h')),\ninclusion (analysis_def (transpose h)) h'
H1 : and (inclusion (transpose h) (analysis_def (transpose h)))\n (stable_analysis (analysis_def (transpose h)))
H0 : and\n (and (inclusion (transpose h) (analysis_def (transpose h)))\n (stable_analysis (analysis_def (transpose h))))\n (forall (h' : hedge)\n (_ : and (inclusion (transpose h) h') (stable_analysis h')),\n inclusion (analysis_def (transpose h)) h')
H : and\n (and (inclusion h (analysis_def h))\n (stable_analysis (analysis_def h)))\n (forall (h' : hedge) (_ : and (inclusion h h') (stable_analysis h')),\n inclusion (analysis_def h) h')
h : hedge
*****
and (inclusion (transpose h) (transpose (analysis_def h))) (stable_analysis (transpose (analysis_def h)))
+++++
split.
-----
Lemma ana_transpose_incl_transpose_ana : forall h : hedge, inclusion (analysis_def (transpose h)) (transpose (analysis_def h)).
intro.
generalize (analysis_is_analysis (transpose h)).
generalize (analysis_is_analysis h).
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.
elim H0.
intros.
apply H2.
split.

*****
H2 : forall (h' : hedge)\n (_ : and (inclusion (transpose h) h') (stable_analysis h')),\ninclusion (analysis_def (transpose h)) h'
H1 : and (inclusion (transpose h) (analysis_def (transpose h)))\n (stable_analysis (analysis_def (transpose h)))
H0 : and\n (and (inclusion (transpose h) (analysis_def (transpose h)))\n (stable_analysis (analysis_def (transpose h))))\n (forall (h' : hedge)\n (_ : and (inclusion (transpose h) h') (stable_analysis h')),\n inclusion (analysis_def (transpose h)) h')
H : and\n (and (inclusion h (analysis_def h))\n (stable_analysis (analysis_def h)))\n (forall (h' : hedge) (_ : and (inclusion h h') (stable_analysis h')),\n inclusion (analysis_def h) h')
h : hedge
*****
inclusion (transpose h) (transpose (analysis_def h))
+++++
unfold inclusion in |- *.
-----
Lemma ana_transpose_incl_transpose_ana : forall h : hedge, inclusion (analysis_def (transpose h)) (transpose (analysis_def h)).
intro.
generalize (analysis_is_analysis (transpose h)).
generalize (analysis_is_analysis h).
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.
elim H0.
intros.
apply H2.
split.
unfold inclusion in |- *.

*****
H2 : forall (h' : hedge)\n (_ : and (inclusion (transpose h) h') (stable_analysis h')),\ninclusion (analysis_def (transpose h)) h'
H1 : and (inclusion (transpose h) (analysis_def (transpose h)))\n (stable_analysis (analysis_def (transpose h)))
H0 : and\n (and (inclusion (transpose h) (analysis_def (transpose h)))\n (stable_analysis (analysis_def (transpose h))))\n (forall (h' : hedge)\n (_ : and (inclusion (transpose h) h') (stable_analysis h')),\n inclusion (analysis_def (transpose h)) h')
H : and\n (and (inclusion h (analysis_def h))\n (stable_analysis (analysis_def h)))\n (forall (h' : hedge) (_ : and (inclusion h h') (stable_analysis h')),\n inclusion (analysis_def h) h')
h : hedge
*****
forall (M N : Msg) (_ : transpose h M N), transpose (analysis_def h) M N
+++++
unfold transpose in |- *.
-----
Lemma ana_transpose_incl_transpose_ana : forall h : hedge, inclusion (analysis_def (transpose h)) (transpose (analysis_def h)).
intro.
generalize (analysis_is_analysis (transpose h)).
generalize (analysis_is_analysis h).
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.
elim H0.
intros.
apply H2.
split.
unfold inclusion in |- *.
unfold transpose in |- *.

*****
H2 : forall (h' : hedge)\n (_ : and (inclusion (transpose h) h') (stable_analysis h')),\ninclusion (analysis_def (transpose h)) h'
H1 : and (inclusion (transpose h) (analysis_def (transpose h)))\n (stable_analysis (analysis_def (transpose h)))
H0 : and\n (and (inclusion (transpose h) (analysis_def (transpose h)))\n (stable_analysis (analysis_def (transpose h))))\n (forall (h' : hedge)\n (_ : and (inclusion (transpose h) h') (stable_analysis h')),\n inclusion (analysis_def (transpose h)) h')
H : and\n (and (inclusion h (analysis_def h))\n (stable_analysis (analysis_def h)))\n (forall (h' : hedge) (_ : and (inclusion h h') (stable_analysis h')),\n inclusion (analysis_def h) h')
h : hedge
*****
forall (M N : Msg) (_ : h N M), analysis_def h N M
+++++
intros.
-----
Lemma ana_transpose_incl_transpose_ana : forall h : hedge, inclusion (analysis_def (transpose h)) (transpose (analysis_def h)).
intro.
generalize (analysis_is_analysis (transpose h)).
generalize (analysis_is_analysis h).
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.
elim H0.
intros.
apply H2.
split.
unfold inclusion in |- *.
unfold transpose in |- *.
intros.

*****
H3 : h N M
M,N : Msg
H2 : forall (h' : hedge)\n (_ : and (inclusion (transpose h) h') (stable_analysis h')),\ninclusion (analysis_def (transpose h)) h'
H1 : and (inclusion (transpose h) (analysis_def (transpose h)))\n (stable_analysis (analysis_def (transpose h)))
H0 : and\n (and (inclusion (transpose h) (analysis_def (transpose h)))\n (stable_analysis (analysis_def (transpose h))))\n (forall (h' : hedge)\n (_ : and (inclusion (transpose h) h') (stable_analysis h')),\n inclusion (analysis_def (transpose h)) h')
H : and\n (and (inclusion h (analysis_def h))\n (stable_analysis (analysis_def h)))\n (forall (h' : hedge) (_ : and (inclusion h h') (stable_analysis h')),\n inclusion (analysis_def h) h')
h : hedge
*****
analysis_def h N M
+++++
elim H.
-----
Lemma ana_transpose_incl_transpose_ana : forall h : hedge, inclusion (analysis_def (transpose h)) (transpose (analysis_def h)).
intro.
generalize (analysis_is_analysis (transpose h)).
generalize (analysis_is_analysis h).
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.
elim H0.
intros.
apply H2.
split.
unfold inclusion in |- *.
unfold transpose in |- *.
intros.
elim H.

*****
H3 : h N M
M,N : Msg
H2 : forall (h' : hedge)\n (_ : and (inclusion (transpose h) h') (stable_analysis h')),\ninclusion (analysis_def (transpose h)) h'
H1 : and (inclusion (transpose h) (analysis_def (transpose h)))\n (stable_analysis (analysis_def (transpose h)))
H0 : and\n (and (inclusion (transpose h) (analysis_def (transpose h)))\n (stable_analysis (analysis_def (transpose h))))\n (forall (h' : hedge)\n (_ : and (inclusion (transpose h) h') (stable_analysis h')),\n inclusion (analysis_def (transpose h)) h')
H : and\n (and (inclusion h (analysis_def h))\n (stable_analysis (analysis_def h)))\n (forall (h' : hedge) (_ : and (inclusion h h') (stable_analysis h')),\n inclusion (analysis_def h) h')
h : hedge
*****
forall (_ : and (inclusion h (analysis_def h)) (stable_analysis (analysis_def h))) (_ : forall (h' : hedge) (_ : and (inclusion h h') (stable_analysis h')), inclusion (analysis_def h) h'), analysis_def h N M
+++++
intros.
-----
Lemma ana_transpose_incl_transpose_ana : forall h : hedge, inclusion (analysis_def (transpose h)) (transpose (analysis_def h)).
intro.
generalize (analysis_is_analysis (transpose h)).
generalize (analysis_is_analysis h).
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.
elim H0.
intros.
apply H2.
split.
unfold inclusion in |- *.
unfold transpose in |- *.
intros.
elim H.
intros.

*****
H5 : forall (h' : hedge) (_ : and (inclusion h h') (stable_analysis h')),\ninclusion (analysis_def h) h'
H4 : and (inclusion h (analysis_def h)) (stable_analysis (analysis_def h))
H3 : h N M
M,N : Msg
H2 : forall (h' : hedge)\n (_ : and (inclusion (transpose h) h') (stable_analysis h')),\ninclusion (analysis_def (transpose h)) h'
H1 : and (inclusion (transpose h) (analysis_def (transpose h)))\n (stable_analysis (analysis_def (transpose h)))
H0 : and\n (and (inclusion (transpose h) (analysis_def (transpose h)))\n (stable_analysis (analysis_def (transpose h))))\n (forall (h' : hedge)\n (_ : and (inclusion (transpose h) h') (stable_analysis h')),\n inclusion (analysis_def (transpose h)) h')
H : and\n (and (inclusion h (analysis_def h))\n (stable_analysis (analysis_def h)))\n (forall (h' : hedge) (_ : and (inclusion h h') (stable_analysis h')),\n inclusion (analysis_def h) h')
h : hedge
*****
analysis_def h N M
+++++
elim H4.
-----
Lemma ana_transpose_incl_transpose_ana : forall h : hedge, inclusion (analysis_def (transpose h)) (transpose (analysis_def h)).
intro.
generalize (analysis_is_analysis (transpose h)).
generalize (analysis_is_analysis h).
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.
elim H0.
intros.
apply H2.
split.
unfold inclusion in |- *.
unfold transpose in |- *.
intros.
elim H.
intros.
elim H4.

*****
H5 : forall (h' : hedge) (_ : and (inclusion h h') (stable_analysis h')),\ninclusion (analysis_def h) h'
H4 : and (inclusion h (analysis_def h)) (stable_analysis (analysis_def h))
H3 : h N M
M,N : Msg
H2 : forall (h' : hedge)\n (_ : and (inclusion (transpose h) h') (stable_analysis h')),\ninclusion (analysis_def (transpose h)) h'
H1 : and (inclusion (transpose h) (analysis_def (transpose h)))\n (stable_analysis (analysis_def (transpose h)))
H0 : and\n (and (inclusion (transpose h) (analysis_def (transpose h)))\n (stable_analysis (analysis_def (transpose h))))\n (forall (h' : hedge)\n (_ : and (inclusion (transpose h) h') (stable_analysis h')),\n inclusion (analysis_def (transpose h)) h')
H : and\n (and (inclusion h (analysis_def h))\n (stable_analysis (analysis_def h)))\n (forall (h' : hedge) (_ : and (inclusion h h') (stable_analysis h')),\n inclusion (analysis_def h) h')
h : hedge
*****
forall (_ : inclusion h (analysis_def h)) (_ : stable_analysis (analysis_def h)), analysis_def h N M
+++++
unfold inclusion in |- *.
-----
Lemma ana_transpose_incl_transpose_ana : forall h : hedge, inclusion (analysis_def (transpose h)) (transpose (analysis_def h)).
intro.
generalize (analysis_is_analysis (transpose h)).
generalize (analysis_is_analysis h).
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.
elim H0.
intros.
apply H2.
split.
unfold inclusion in |- *.
unfold transpose in |- *.
intros.
elim H.
intros.
elim H4.
unfold inclusion in |- *.

*****
H5 : forall (h' : hedge) (_ : and (inclusion h h') (stable_analysis h')),\ninclusion (analysis_def h) h'
H4 : and (inclusion h (analysis_def h)) (stable_analysis (analysis_def h))
H3 : h N M
M,N : Msg
H2 : forall (h' : hedge)\n (_ : and (inclusion (transpose h) h') (stable_analysis h')),\ninclusion (analysis_def (transpose h)) h'
H1 : and (inclusion (transpose h) (analysis_def (transpose h)))\n (stable_analysis (analysis_def (transpose h)))
H0 : and\n (and (inclusion (transpose h) (analysis_def (transpose h)))\n (stable_analysis (analysis_def (transpose h))))\n (forall (h' : hedge)\n (_ : and (inclusion (transpose h) h') (stable_analysis h')),\n inclusion (analysis_def (transpose h)) h')
H : and\n (and (inclusion h (analysis_def h))\n (stable_analysis (analysis_def h)))\n (forall (h' : hedge) (_ : and (inclusion h h') (stable_analysis h')),\n inclusion (analysis_def h) h')
h : hedge
*****
forall (_ : forall (M N : Msg) (_ : h M N), analysis_def h M N) (_ : stable_analysis (analysis_def h)), analysis_def h N M
+++++
auto.
-----
Lemma ana_transpose_incl_transpose_ana : forall h : hedge, inclusion (analysis_def (transpose h)) (transpose (analysis_def h)).
intro.
generalize (analysis_is_analysis (transpose h)).
generalize (analysis_is_analysis h).
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.
elim H0.
intros.
apply H2.
split.

*****
H2 : forall (h' : hedge)\n (_ : and (inclusion (transpose h) h') (stable_analysis h')),\ninclusion (analysis_def (transpose h)) h'
H1 : and (inclusion (transpose h) (analysis_def (transpose h)))\n (stable_analysis (analysis_def (transpose h)))
H0 : and\n (and (inclusion (transpose h) (analysis_def (transpose h)))\n (stable_analysis (analysis_def (transpose h))))\n (forall (h' : hedge)\n (_ : and (inclusion (transpose h) h') (stable_analysis h')),\n inclusion (analysis_def (transpose h)) h')
H : and\n (and (inclusion h (analysis_def h))\n (stable_analysis (analysis_def h)))\n (forall (h' : hedge) (_ : and (inclusion h h') (stable_analysis h')),\n inclusion (analysis_def h) h')
h : hedge
*****
stable_analysis (transpose (analysis_def h))
+++++
apply stable_impl_transpose_stable.
-----
Lemma ana_transpose_incl_transpose_ana : forall h : hedge, inclusion (analysis_def (transpose h)) (transpose (analysis_def h)).
intro.
generalize (analysis_is_analysis (transpose h)).
generalize (analysis_is_analysis h).
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.
elim H0.
intros.
apply H2.
split.
apply stable_impl_transpose_stable.

*****
H2 : forall (h' : hedge)\n (_ : and (inclusion (transpose h) h') (stable_analysis h')),\ninclusion (analysis_def (transpose h)) h'
H1 : and (inclusion (transpose h) (analysis_def (transpose h)))\n (stable_analysis (analysis_def (transpose h)))
H0 : and\n (and (inclusion (transpose h) (analysis_def (transpose h)))\n (stable_analysis (analysis_def (transpose h))))\n (forall (h' : hedge)\n (_ : and (inclusion (transpose h) h') (stable_analysis h')),\n inclusion (analysis_def (transpose h)) h')
H : and\n (and (inclusion h (analysis_def h))\n (stable_analysis (analysis_def h)))\n (forall (h' : hedge) (_ : and (inclusion h h') (stable_analysis h')),\n inclusion (analysis_def h) h')
h : hedge
*****
stable_analysis (analysis_def h)
+++++
tauto.
-----
Lemma ana_transpose_incl_transpose_ana : forall h : hedge, inclusion (analysis_def (transpose h)) (transpose (analysis_def h)).
intro.
generalize (analysis_is_analysis (transpose h)).
generalize (analysis_is_analysis h).
unfold is_analysis in |- *.
unfold analysis_cond in |- *.
intros.
elim H0.
intros.
apply H2.
split.

*****

*****

+++++
Qed.
-----
Lemma transpose_ana_transpose_incl_ana :\n forall h : hedge,\n inclusion (transpose (analysis_def (transpose h))) (analysis_def h).
-----
Lemma transpose_ana_transpose_incl_ana : forall h : hedge, inclusion (transpose (analysis_def (transpose h))) (analysis_def h).

*****

*****
forall h : hedge, inclusion (transpose (analysis_def (transpose h))) (analysis_def h)
+++++
intro.
-----
Lemma transpose_ana_transpose_incl_ana : forall h : hedge, inclusion (transpose (analysis_def (transpose h))) (analysis_def h).
intro.

*****
h : hedge
*****
inclusion (transpose (analysis_def (transpose h))) (analysis_def h)
+++++
apply inclusion_trans with (transpose (transpose (analysis_def h))).
-----
Lemma transpose_ana_transpose_incl_ana : forall h : hedge, inclusion (transpose (analysis_def (transpose h))) (analysis_def h).
intro.
apply inclusion_trans with (transpose (transpose (analysis_def h))).

*****
h : hedge
*****
inclusion (transpose (analysis_def (transpose h))) (transpose (transpose (analysis_def h)))
+++++
apply inclusion_transpose_inclusion.
-----
Lemma transpose_ana_transpose_incl_ana : forall h : hedge, inclusion (transpose (analysis_def (transpose h))) (analysis_def h).
intro.
apply inclusion_trans with (transpose (transpose (analysis_def h))).
apply inclusion_transpose_inclusion.

*****
h : hedge
*****
inclusion (analysis_def (transpose h)) (transpose (analysis_def h))
+++++
apply ana_transpose_incl_transpose_ana.
-----
Lemma transpose_ana_transpose_incl_ana : forall h : hedge, inclusion (transpose (analysis_def (transpose h))) (analysis_def h).
intro.
apply inclusion_trans with (transpose (transpose (analysis_def h))).

*****
h : hedge
*****
inclusion (transpose (transpose (analysis_def h))) (analysis_def h)
+++++
generalize (transpose_invol (analysis_def h)).
-----
Lemma transpose_ana_transpose_incl_ana : forall h : hedge, inclusion (transpose (analysis_def (transpose h))) (analysis_def h).
intro.
apply inclusion_trans with (transpose (transpose (analysis_def h))).
generalize (transpose_invol (analysis_def h)).

*****
h : hedge
*****
forall _ : equal (analysis_def h) (transpose (transpose (analysis_def h))), inclusion (transpose (transpose (analysis_def h))) (analysis_def h)
+++++
unfold equal in |- *.
-----
Lemma transpose_ana_transpose_incl_ana : forall h : hedge, inclusion (transpose (analysis_def (transpose h))) (analysis_def h).
intro.
apply inclusion_trans with (transpose (transpose (analysis_def h))).
generalize (transpose_invol (analysis_def h)).
unfold equal in |- *.

*****
h : hedge
*****
forall _ : and (inclusion (analysis_def h) (transpose (transpose (analysis_def h)))) (inclusion (transpose (transpose (analysis_def h))) (analysis_def h)), inclusion (transpose (transpose (analysis_def h))) (analysis_def h)
+++++
tauto.
-----
Lemma transpose_ana_transpose_incl_ana : forall h : hedge, inclusion (transpose (analysis_def (transpose h))) (analysis_def h).
intro.
apply inclusion_trans with (transpose (transpose (analysis_def h))).

*****

*****

+++++
Qed.
-----
Lemma ana_incl_transpose_ana_transpose :\n forall h : hedge,\n inclusion (analysis_def h) (transpose (analysis_def (transpose h))).
-----
Lemma ana_incl_transpose_ana_transpose : forall h : hedge, inclusion (analysis_def h) (transpose (analysis_def (transpose h))).

*****

*****
forall h : hedge, inclusion (analysis_def h) (transpose (analysis_def (transpose h)))
+++++
intro.
-----
Lemma ana_incl_transpose_ana_transpose : forall h : hedge, inclusion (analysis_def h) (transpose (analysis_def (transpose h))).
intro.

*****
h : hedge
*****
inclusion (analysis_def h) (transpose (analysis_def (transpose h)))
+++++
generalize (analysis_is_analysis h).
-----
Lemma ana_incl_transpose_ana_transpose : forall h : hedge, inclusion (analysis_def h) (transpose (analysis_def (transpose h))).
intro.
generalize (analysis_is_analysis h).

*****
h : hedge
*****
forall _ : is_analysis h (analysis_def h), inclusion (analysis_def h) (transpose (analysis_def (transpose h)))
+++++
unfold is_analysis in |- *.
-----
Lemma ana_incl_transpose_ana_transpose : forall h : hedge, inclusion (analysis_def h) (transpose (analysis_def (transpose h))).
intro.
generalize (analysis_is_analysis h).
unfold is_analysis in |- *.

*****
h : hedge
*****
forall _ : and (analysis_cond h (analysis_def h)) (forall (h' : hedge) (_ : analysis_cond h h'), inclusion (analysis_def h) h'), inclusion (analysis_def h) (transpose (analysis_def (transpose h)))
+++++
intro.
-----
Lemma ana_incl_transpose_ana_transpose : forall h : hedge, inclusion (analysis_def h) (transpose (analysis_def (transpose h))).
intro.
generalize (analysis_is_analysis h).
unfold is_analysis in |- *.
intro.

*****
H : and (analysis_cond h (analysis_def h))\n (forall (h' : hedge) (_ : analysis_cond h h'),\n inclusion (analysis_def h) h')
h : hedge
*****
inclusion (analysis_def h) (transpose (analysis_def (transpose h)))
+++++
elim H.
-----
Lemma ana_incl_transpose_ana_transpose : forall h : hedge, inclusion (analysis_def h) (transpose (analysis_def (transpose h))).
intro.
generalize (analysis_is_analysis h).
unfold is_analysis in |- *.
intro.
elim H.

*****
H : and (analysis_cond h (analysis_def h))\n (forall (h' : hedge) (_ : analysis_cond h h'),\n inclusion (analysis_def h) h')
h : hedge
*****
forall (_ : analysis_cond h (analysis_def h)) (_ : forall (h' : hedge) (_ : analysis_cond h h'), inclusion (analysis_def h) h'), inclusion (analysis_def h) (transpose (analysis_def (transpose h)))
+++++
intros.
-----
Lemma ana_incl_transpose_ana_transpose : forall h : hedge, inclusion (analysis_def h) (transpose (analysis_def (transpose h))).
intro.
generalize (analysis_is_analysis h).
unfold is_analysis in |- *.
intro.
elim H.
intros.

*****
H1 : forall (h' : hedge) (_ : analysis_cond h h'),\ninclusion (analysis_def h) h'
H0 : analysis_cond h (analysis_def h)
H : and (analysis_cond h (analysis_def h))\n (forall (h' : hedge) (_ : analysis_cond h h'),\n inclusion (analysis_def h) h')
h : hedge
*****
inclusion (analysis_def h) (transpose (analysis_def (transpose h)))
+++++
apply H1.
-----
Lemma ana_incl_transpose_ana_transpose : forall h : hedge, inclusion (analysis_def h) (transpose (analysis_def (transpose h))).
intro.
generalize (analysis_is_analysis h).
unfold is_analysis in |- *.
intro.
elim H.
intros.
apply H1.

*****
H1 : forall (h' : hedge) (_ : analysis_cond h h'),\ninclusion (analysis_def h) h'
H0 : analysis_cond h (analysis_def h)
H : and (analysis_cond h (analysis_def h))\n (forall (h' : hedge) (_ : analysis_cond h h'),\n inclusion (analysis_def h) h')
h : hedge
*****
analysis_cond h (transpose (analysis_def (transpose h)))
+++++
unfold analysis_cond in |- *.
-----
Lemma ana_incl_transpose_ana_transpose : forall h : hedge, inclusion (analysis_def h) (transpose (analysis_def (transpose h))).
intro.
generalize (analysis_is_analysis h).
unfold is_analysis in |- *.
intro.
elim H.
intros.
apply H1.
unfold analysis_cond in |- *.

*****
H1 : forall (h' : hedge) (_ : analysis_cond h h'),\ninclusion (analysis_def h) h'
H0 : analysis_cond h (analysis_def h)
H : and (analysis_cond h (analysis_def h))\n (forall (h' : hedge) (_ : analysis_cond h h'),\n inclusion (analysis_def h) h')
h : hedge
*****
and (inclusion h (transpose (analysis_def (transpose h)))) (stable_analysis (transpose (analysis_def (transpose h))))
+++++
generalize (analysis_is_analysis (transpose h)).
-----
Lemma ana_incl_transpose_ana_transpose : forall h : hedge, inclusion (analysis_def h) (transpose (analysis_def (transpose h))).
intro.
generalize (analysis_is_analysis h).
unfold is_analysis in |- *.
intro.
elim H.
intros.
apply H1.
unfold analysis_cond in |- *.
generalize (analysis_is_analysis (transpose h)).

*****
H1 : forall (h' : hedge) (_ : analysis_cond h h'),\ninclusion (analysis_def h) h'
H0 : analysis_cond h (analysis_def h)
H : and (analysis_cond h (analysis_def h))\n (forall (h' : hedge) (_ : analysis_cond h h'),\n inclusion (analysis_def h) h')
h : hedge
*****
forall _ : is_analysis (transpose h) (analysis_def (transpose h)), and (inclusion h (transpose (analysis_def (transpose h)))) (stable_analysis (transpose (analysis_def (transpose h))))
+++++
unfold is_analysis in |- *.
-----
Lemma ana_incl_transpose_ana_transpose : forall h : hedge, inclusion (analysis_def h) (transpose (analysis_def (transpose h))).
intro.
generalize (analysis_is_analysis h).
unfold is_analysis in |- *.
intro.
elim H.
intros.
apply H1.
unfold analysis_cond in |- *.
generalize (analysis_is_analysis (transpose h)).
unfold is_analysis in |- *.

*****
H1 : forall (h' : hedge) (_ : analysis_cond h h'),\ninclusion (analysis_def h) h'
H0 : analysis_cond h (analysis_def h)
H : and (analysis_cond h (analysis_def h))\n (forall (h' : hedge) (_ : analysis_cond h h'),\n inclusion (analysis_def h) h')
h : hedge
*****
forall _ : and (analysis_cond (transpose h) (analysis_def (transpose h))) (forall (h' : hedge) (_ : analysis_cond (transpose h) h'), inclusion (analysis_def (transpose h)) h'), and (inclusion h (transpose (analysis_def (transpose h)))) (stable_analysis (transpose (analysis_def (transpose h))))
+++++
intros.
-----
Lemma ana_incl_transpose_ana_transpose : forall h : hedge, inclusion (analysis_def h) (transpose (analysis_def (transpose h))).
intro.
generalize (analysis_is_analysis h).
unfold is_analysis in |- *.
intro.
elim H.
intros.
apply H1.
unfold analysis_cond in |- *.
generalize (analysis_is_analysis (transpose h)).
unfold is_analysis in |- *.
intros.

*****
H2 : and (analysis_cond (transpose h) (analysis_def (transpose h)))\n (forall (h' : hedge) (_ : analysis_cond (transpose h) h'),\n inclusion (analysis_def (transpose h)) h')
H1 : forall (h' : hedge) (_ : analysis_cond h h'),\ninclusion (analysis_def h) h'
H0 : analysis_cond h (analysis_def h)
H : and (analysis_cond h (analysis_def h))\n (forall (h' : hedge) (_ : analysis_cond h h'),\n inclusion (analysis_def h) h')
h : hedge
*****
and (inclusion h (transpose (analysis_def (transpose h)))) (stable_analysis (transpose (analysis_def (transpose h))))
+++++
elim H2.
-----
Lemma ana_incl_transpose_ana_transpose : forall h : hedge, inclusion (analysis_def h) (transpose (analysis_def (transpose h))).
intro.
generalize (analysis_is_analysis h).
unfold is_analysis in |- *.
intro.
elim H.
intros.
apply H1.
unfold analysis_cond in |- *.
generalize (analysis_is_analysis (transpose h)).
unfold is_analysis in |- *.
intros.
elim H2.

*****
H2 : and (analysis_cond (transpose h) (analysis_def (transpose h)))\n (forall (h' : hedge) (_ : analysis_cond (transpose h) h'),\n inclusion (analysis_def (transpose h)) h')
H1 : forall (h' : hedge) (_ : analysis_cond h h'),\ninclusion (analysis_def h) h'
H0 : analysis_cond h (analysis_def h)
H : and (analysis_cond h (analysis_def h))\n (forall (h' : hedge) (_ : analysis_cond h h'),\n inclusion (analysis_def h) h')
h : hedge
*****
forall (_ : analysis_cond (transpose h) (analysis_def (transpose h))) (_ : forall (h' : hedge) (_ : analysis_cond (transpose h) h'), inclusion (analysis_def (transpose h)) h'), and (inclusion h (transpose (analysis_def (transpose h)))) (stable_analysis (transpose (analysis_def (transpose h))))
+++++
unfold analysis_cond in |- *.
-----
Lemma ana_incl_transpose_ana_transpose : forall h : hedge, inclusion (analysis_def h) (transpose (analysis_def (transpose h))).
intro.
generalize (analysis_is_analysis h).
unfold is_analysis in |- *.
intro.
elim H.
intros.
apply H1.
unfold analysis_cond in |- *.
generalize (analysis_is_analysis (transpose h)).
unfold is_analysis in |- *.
intros.
elim H2.
unfold analysis_cond in |- *.

*****
H2 : and (analysis_cond (transpose h) (analysis_def (transpose h)))\n (forall (h' : hedge) (_ : analysis_cond (transpose h) h'),\n inclusion (analysis_def (transpose h)) h')
H1 : forall (h' : hedge) (_ : analysis_cond h h'),\ninclusion (analysis_def h) h'
H0 : analysis_cond h (analysis_def h)
H : and (analysis_cond h (analysis_def h))\n (forall (h' : hedge) (_ : analysis_cond h h'),\n inclusion (analysis_def h) h')
h : hedge
*****
forall (_ : and (inclusion (transpose h) (analysis_def (transpose h))) (stable_analysis (analysis_def (transpose h)))) (_ : forall (h' : hedge) (_ : and (inclusion (transpose h) h') (stable_analysis h')), inclusion (analysis_def (transpose h)) h'), and (inclusion h (transpose (analysis_def (transpose h)))) (stable_analysis (transpose (analysis_def (transpose h))))
+++++
intros.
-----
Lemma ana_incl_transpose_ana_transpose : forall h : hedge, inclusion (analysis_def h) (transpose (analysis_def (transpose h))).
intro.
generalize (analysis_is_analysis h).
unfold is_analysis in |- *.
intro.
elim H.
intros.
apply H1.
unfold analysis_cond in |- *.
generalize (analysis_is_analysis (transpose h)).
unfold is_analysis in |- *.
intros.
elim H2.
unfold analysis_cond in |- *.
intros.

*****
H4 : forall (h' : hedge)\n (_ : and (inclusion (transpose h) h') (stable_analysis h')),\ninclusion (analysis_def (transpose h)) h'
H3 : and (inclusion (transpose h) (analysis_def (transpose h)))\n (stable_analysis (analysis_def (transpose h)))
H2 : and (analysis_cond (transpose h) (analysis_def (transpose h)))\n (forall (h' : hedge) (_ : analysis_cond (transpose h) h'),\n inclusion (analysis_def (transpose h)) h')
H1 : forall (h' : hedge) (_ : analysis_cond h h'),\ninclusion (analysis_def h) h'
H0 : analysis_cond h (analysis_def h)
H : and (analysis_cond h (analysis_def h))\n (forall (h' : hedge) (_ : analysis_cond h h'),\n inclusion (analysis_def h) h')
h : hedge
*****
and (inclusion h (transpose (analysis_def (transpose h)))) (stable_analysis (transpose (analysis_def (transpose h))))
+++++
elim H3.
-----
Lemma ana_incl_transpose_ana_transpose : forall h : hedge, inclusion (analysis_def h) (transpose (analysis_def (transpose h))).
intro.
generalize (analysis_is_analysis h).
unfold is_analysis in |- *.
intro.
elim H.
intros.
apply H1.
unfold analysis_cond in |- *.
generalize (analysis_is_analysis (transpose h)).
unfold is_analysis in |- *.
intros.
elim H2.
unfold analysis_cond in |- *.
intros.
elim H3.

*****
H4 : forall (h' : hedge)\n (_ : and (inclusion (transpose h) h') (stable_analysis h')),\ninclusion (analysis_def (transpose h)) h'
H3 : and (inclusion (transpose h) (analysis_def (transpose h)))\n (stable_analysis (analysis_def (transpose h)))
H2 : and (analysis_cond (transpose h) (analysis_def (transpose h)))\n (forall (h' : hedge) (_ : analysis_cond (transpose h) h'),\n inclusion (analysis_def (transpose h)) h')
H1 : forall (h' : hedge) (_ : analysis_cond h h'),\ninclusion (analysis_def h) h'
H0 : analysis_cond h (analysis_def h)
H : and (analysis_cond h (analysis_def h))\n (forall (h' : hedge) (_ : analysis_cond h h'),\n inclusion (analysis_def h) h')
h : hedge
*****
forall (_ : inclusion (transpose h) (analysis_def (transpose h))) (_ : stable_analysis (analysis_def (transpose h))), and (inclusion h (transpose (analysis_def (transpose h)))) (stable_analysis (transpose (analysis_def (transpose h))))
+++++
unfold inclusion in |- *.
-----
Lemma ana_incl_transpose_ana_transpose : forall h : hedge, inclusion (analysis_def h) (transpose (analysis_def (transpose h))).
intro.
generalize (analysis_is_analysis h).
unfold is_analysis in |- *.
intro.
elim H.
intros.
apply H1.
unfold analysis_cond in |- *.
generalize (analysis_is_analysis (transpose h)).
unfold is_analysis in |- *.
intros.
elim H2.
unfold analysis_cond in |- *.
intros.
elim H3.
unfold inclusion in |- *.

*****
H4 : forall (h' : hedge)\n (_ : and (inclusion (transpose h) h') (stable_analysis h')),\ninclusion (analysis_def (transpose h)) h'
H3 : and (inclusion (transpose h) (analysis_def (transpose h)))\n (stable_analysis (analysis_def (transpose h)))
H2 : and (analysis_cond (transpose h) (analysis_def (transpose h)))\n (forall (h' : hedge) (_ : analysis_cond (transpose h) h'),\n inclusion (analysis_def (transpose h)) h')
H1 : forall (h' : hedge) (_ : analysis_cond h h'),\ninclusion (analysis_def h) h'
H0 : analysis_cond h (analysis_def h)
H : and (analysis_cond h (analysis_def h))\n (forall (h' : hedge) (_ : analysis_cond h h'),\n inclusion (analysis_def h) h')
h : hedge
*****
forall (_ : forall (M N : Msg) (_ : transpose h M N), analysis_def (transpose h) M N) (_ : stable_analysis (analysis_def (transpose h))), and (forall (M N : Msg) (_ : h M N), transpose (analysis_def (transpose h)) M N) (stable_analysis (transpose (analysis_def (transpose h))))
+++++
intros.
-----
Lemma ana_incl_transpose_ana_transpose : forall h : hedge, inclusion (analysis_def h) (transpose (analysis_def (transpose h))).
intro.
generalize (analysis_is_analysis h).
unfold is_analysis in |- *.
intro.
elim H.
intros.
apply H1.
unfold analysis_cond in |- *.
generalize (analysis_is_analysis (transpose h)).
unfold is_analysis in |- *.
intros.
elim H2.
unfold analysis_cond in |- *.
intros.
elim H3.
unfold inclusion in |- *.
intros.

*****
H6 : stable_analysis (analysis_def (transpose h))
H5 : forall (M N : Msg) (_ : transpose h M N),\nanalysis_def (transpose h) M N
H4 : forall (h' : hedge)\n (_ : and (inclusion (transpose h) h') (stable_analysis h')),\ninclusion (analysis_def (transpose h)) h'
H3 : and (inclusion (transpose h) (analysis_def (transpose h)))\n (stable_analysis (analysis_def (transpose h)))
H2 : and (analysis_cond (transpose h) (analysis_def (transpose h)))\n (forall (h' : hedge) (_ : analysis_cond (transpose h) h'),\n inclusion (analysis_def (transpose h)) h')
H1 : forall (h' : hedge) (_ : analysis_cond h h'),\ninclusion (analysis_def h) h'
H0 : analysis_cond h (analysis_def h)
H : and (analysis_cond h (analysis_def h))\n (forall (h' : hedge) (_ : analysis_cond h h'),\n inclusion (analysis_def h) h')
h : hedge
*****
and (forall (M N : Msg) (_ : h M N), transpose (analysis_def (transpose h)) M N) (stable_analysis (transpose (analysis_def (transpose h))))
+++++
split.
-----
Lemma ana_incl_transpose_ana_transpose : forall h : hedge, inclusion (analysis_def h) (transpose (analysis_def (transpose h))).
intro.
generalize (analysis_is_analysis h).
unfold is_analysis in |- *.
intro.
elim H.
intros.
apply H1.
unfold analysis_cond in |- *.
generalize (analysis_is_analysis (transpose h)).
unfold is_analysis in |- *.
intros.
elim H2.
unfold analysis_cond in |- *.
intros.
elim H3.
unfold inclusion in |- *.
intros.
split.

*****
H6 : stable_analysis (analysis_def (transpose h))
H5 : forall (M N : Msg) (_ : transpose h M N),\nanalysis_def (transpose h) M N
H4 : forall (h' : hedge)\n (_ : and (inclusion (transpose h) h') (stable_analysis h')),\ninclusion (analysis_def (transpose h)) h'
H3 : and (inclusion (transpose h) (analysis_def (transpose h)))\n (stable_analysis (analysis_def (transpose h)))
H2 : and (analysis_cond (transpose h) (analysis_def (transpose h)))\n (forall (h' : hedge) (_ : analysis_cond (transpose h) h'),\n inclusion (analysis_def (transpose h)) h')
H1 : forall (h' : hedge) (_ : analysis_cond h h'),\ninclusion (analysis_def h) h'
H0 : analysis_cond h (analysis_def h)
H : and (analysis_cond h (analysis_def h))\n (forall (h' : hedge) (_ : analysis_cond h h'),\n inclusion (analysis_def h) h')
h : hedge
*****
forall (M N : Msg) (_ : h M N), transpose (analysis_def (transpose h)) M N
+++++
unfold transpose in |- *.
-----
Lemma ana_incl_transpose_ana_transpose : forall h : hedge, inclusion (analysis_def h) (transpose (analysis_def (transpose h))).
intro.
generalize (analysis_is_analysis h).
unfold is_analysis in |- *.
intro.
elim H.
intros.
apply H1.
unfold analysis_cond in |- *.
generalize (analysis_is_analysis (transpose h)).
unfold is_analysis in |- *.
intros.
elim H2.
unfold analysis_cond in |- *.
intros.
elim H3.
unfold inclusion in |- *.
intros.
split.
unfold transpose in |- *.

*****
H6 : stable_analysis (analysis_def (transpose h))
H5 : forall (M N : Msg) (_ : transpose h M N),\nanalysis_def (transpose h) M N
H4 : forall (h' : hedge)\n (_ : and (inclusion (transpose h) h') (stable_analysis h')),\ninclusion (analysis_def (transpose h)) h'
H3 : and (inclusion (transpose h) (analysis_def (transpose h)))\n (stable_analysis (analysis_def (transpose h)))
H2 : and (analysis_cond (transpose h) (analysis_def (transpose h)))\n (forall (h' : hedge) (_ : analysis_cond (transpose h) h'),\n inclusion (analysis_def (transpose h)) h')
H1 : forall (h' : hedge) (_ : analysis_cond h h'),\ninclusion (analysis_def h) h'
H0 : analysis_cond h (analysis_def h)
H : and (analysis_cond h (analysis_def h))\n (forall (h' : hedge) (_ : analysis_cond h h'),\n inclusion (analysis_def h) h')
h : hedge
*****
forall (M N : Msg) (_ : h M N), analysis_def (fun M0 N0 : Msg => h N0 M0) N M
+++++
unfold transpose in H5.
-----
Lemma ana_incl_transpose_ana_transpose : forall h : hedge, inclusion (analysis_def h) (transpose (analysis_def (transpose h))).
intro.
generalize (analysis_is_analysis h).
unfold is_analysis in |- *.
intro.
elim H.
intros.
apply H1.
unfold analysis_cond in |- *.
generalize (analysis_is_analysis (transpose h)).
unfold is_analysis in |- *.
intros.
elim H2.
unfold analysis_cond in |- *.
intros.
elim H3.
unfold inclusion in |- *.
intros.
split.
unfold transpose in |- *.
unfold transpose in H5.

*****
H6 : stable_analysis (analysis_def (transpose h))
H5 : forall (M N : Msg) (_ : h N M),\nanalysis_def (fun M0 N0 : Msg => h N0 M0) M N
H4 : forall (h' : hedge)\n (_ : and (inclusion (transpose h) h') (stable_analysis h')),\ninclusion (analysis_def (transpose h)) h'
H3 : and (inclusion (transpose h) (analysis_def (transpose h)))\n (stable_analysis (analysis_def (transpose h)))
H2 : and (analysis_cond (transpose h) (analysis_def (transpose h)))\n (forall (h' : hedge) (_ : analysis_cond (transpose h) h'),\n inclusion (analysis_def (transpose h)) h')
H1 : forall (h' : hedge) (_ : analysis_cond h h'),\ninclusion (analysis_def h) h'
H0 : analysis_cond h (analysis_def h)
H : and (analysis_cond h (analysis_def h))\n (forall (h' : hedge) (_ : analysis_cond h h'),\n inclusion (analysis_def h) h')
h : hedge
*****
forall (M N : Msg) (_ : h M N), analysis_def (fun M0 N0 : Msg => h N0 M0) N M
+++++
intros.
-----
Lemma ana_incl_transpose_ana_transpose : forall h : hedge, inclusion (analysis_def h) (transpose (analysis_def (transpose h))).
intro.
generalize (analysis_is_analysis h).
unfold is_analysis in |- *.
intro.
elim H.
intros.
apply H1.
unfold analysis_cond in |- *.
generalize (analysis_is_analysis (transpose h)).
unfold is_analysis in |- *.
intros.
elim H2.
unfold analysis_cond in |- *.
intros.
elim H3.
unfold inclusion in |- *.
intros.
split.
unfold transpose in |- *.
unfold transpose in H5.
intros.

*****
H7 : h M N
M,N : Msg
H6 : stable_analysis (analysis_def (transpose h))
H5 : forall (M N : Msg) (_ : h N M),\nanalysis_def (fun M0 N0 : Msg => h N0 M0) M N
H4 : forall (h' : hedge)\n (_ : and (inclusion (transpose h) h') (stable_analysis h')),\ninclusion (analysis_def (transpose h)) h'
H3 : and (inclusion (transpose h) (analysis_def (transpose h)))\n (stable_analysis (analysis_def (transpose h)))
H2 : and (analysis_cond (transpose h) (analysis_def (transpose h)))\n (forall (h' : hedge) (_ : analysis_cond (transpose h) h'),\n inclusion (analysis_def (transpose h)) h')
H1 : forall (h' : hedge) (_ : analysis_cond h h'),\ninclusion (analysis_def h) h'
H0 : analysis_cond h (analysis_def h)
H : and (analysis_cond h (analysis_def h))\n (forall (h' : hedge) (_ : analysis_cond h h'),\n inclusion (analysis_def h) h')
h : hedge
*****
analysis_def (fun M N : Msg => h N M) N M
+++++
apply H5.
-----
Lemma ana_incl_transpose_ana_transpose : forall h : hedge, inclusion (analysis_def h) (transpose (analysis_def (transpose h))).
intro.
generalize (analysis_is_analysis h).
unfold is_analysis in |- *.
intro.
elim H.
intros.
apply H1.
unfold analysis_cond in |- *.
generalize (analysis_is_analysis (transpose h)).
unfold is_analysis in |- *.
intros.
elim H2.
unfold analysis_cond in |- *.
intros.
elim H3.
unfold inclusion in |- *.
intros.
split.
unfold transpose in |- *.
unfold transpose in H5.
intros.
apply H5.

*****
H7 : h M N
M,N : Msg
H6 : stable_analysis (analysis_def (transpose h))
H5 : forall (M N : Msg) (_ : h N M),\nanalysis_def (fun M0 N0 : Msg => h N0 M0) M N
H4 : forall (h' : hedge)\n (_ : and (inclusion (transpose h) h') (stable_analysis h')),\ninclusion (analysis_def (transpose h)) h'
H3 : and (inclusion (transpose h) (analysis_def (transpose h)))\n (stable_analysis (analysis_def (transpose h)))
H2 : and (analysis_cond (transpose h) (analysis_def (transpose h)))\n (forall (h' : hedge) (_ : analysis_cond (transpose h) h'),\n inclusion (analysis_def (transpose h)) h')
H1 : forall (h' : hedge) (_ : analysis_cond h h'),\ninclusion (analysis_def h) h'
H0 : analysis_cond h (analysis_def h)
H : and (analysis_cond h (analysis_def h))\n (forall (h' : hedge) (_ : analysis_cond h h'),\n inclusion (analysis_def h) h')
h : hedge
*****
h M N
+++++
trivial.
-----
Lemma ana_incl_transpose_ana_transpose : forall h : hedge, inclusion (analysis_def h) (transpose (analysis_def (transpose h))).
intro.
generalize (analysis_is_analysis h).
unfold is_analysis in |- *.
intro.
elim H.
intros.
apply H1.
unfold analysis_cond in |- *.
generalize (analysis_is_analysis (transpose h)).
unfold is_analysis in |- *.
intros.
elim H2.
unfold analysis_cond in |- *.
intros.
elim H3.
unfold inclusion in |- *.
intros.
split.

*****
H6 : stable_analysis (analysis_def (transpose h))
H5 : forall (M N : Msg) (_ : transpose h M N),\nanalysis_def (transpose h) M N
H4 : forall (h' : hedge)\n (_ : and (inclusion (transpose h) h') (stable_analysis h')),\ninclusion (analysis_def (transpose h)) h'
H3 : and (inclusion (transpose h) (analysis_def (transpose h)))\n (stable_analysis (analysis_def (transpose h)))
H2 : and (analysis_cond (transpose h) (analysis_def (transpose h)))\n (forall (h' : hedge) (_ : analysis_cond (transpose h) h'),\n inclusion (analysis_def (transpose h)) h')
H1 : forall (h' : hedge) (_ : analysis_cond h h'),\ninclusion (analysis_def h) h'
H0 : analysis_cond h (analysis_def h)
H : and (analysis_cond h (analysis_def h))\n (forall (h' : hedge) (_ : analysis_cond h h'),\n inclusion (analysis_def h) h')
h : hedge
*****
stable_analysis (transpose (analysis_def (transpose h)))
+++++
apply stable_impl_transpose_stable.
-----
Lemma ana_incl_transpose_ana_transpose : forall h : hedge, inclusion (analysis_def h) (transpose (analysis_def (transpose h))).
intro.
generalize (analysis_is_analysis h).
unfold is_analysis in |- *.
intro.
elim H.
intros.
apply H1.
unfold analysis_cond in |- *.
generalize (analysis_is_analysis (transpose h)).
unfold is_analysis in |- *.
intros.
elim H2.
unfold analysis_cond in |- *.
intros.
elim H3.
unfold inclusion in |- *.
intros.
split.
apply stable_impl_transpose_stable.

*****
H6 : stable_analysis (analysis_def (transpose h))
H5 : forall (M N : Msg) (_ : transpose h M N),\nanalysis_def (transpose h) M N
H4 : forall (h' : hedge)\n (_ : and (inclusion (transpose h) h') (stable_analysis h')),\ninclusion (analysis_def (transpose h)) h'
H3 : and (inclusion (transpose h) (analysis_def (transpose h)))\n (stable_analysis (analysis_def (transpose h)))
H2 : and (analysis_cond (transpose h) (analysis_def (transpose h)))\n (forall (h' : hedge) (_ : analysis_cond (transpose h) h'),\n inclusion (analysis_def (transpose h)) h')
H1 : forall (h' : hedge) (_ : analysis_cond h h'),\ninclusion (analysis_def h) h'
H0 : analysis_cond h (analysis_def h)
H : and (analysis_cond h (analysis_def h))\n (forall (h' : hedge) (_ : analysis_cond h h'),\n inclusion (analysis_def h) h')
h : hedge
*****
stable_analysis (analysis_def (transpose h))
+++++
trivial.
-----
Lemma ana_incl_transpose_ana_transpose : forall h : hedge, inclusion (analysis_def h) (transpose (analysis_def (transpose h))).
intro.
generalize (analysis_is_analysis h).
unfold is_analysis in |- *.
intro.
elim H.
intros.
apply H1.
unfold analysis_cond in |- *.
generalize (analysis_is_analysis (transpose h)).
unfold is_analysis in |- *.
intros.
elim H2.
unfold analysis_cond in |- *.
intros.
elim H3.
unfold inclusion in |- *.
intros.
split.

*****

*****

+++++
Qed.
-----
Lemma ana_transpose_transpose_ana :\n forall h : hedge,\n equal (analysis_def (transpose h)) (transpose (analysis_def h)).
-----
Lemma ana_transpose_transpose_ana : forall h : hedge, equal (analysis_def (transpose h)) (transpose (analysis_def h)).

*****

*****
forall h : hedge, equal (analysis_def (transpose h)) (transpose (analysis_def h))
+++++
unfold equal in |- *.
-----
Lemma ana_transpose_transpose_ana : forall h : hedge, equal (analysis_def (transpose h)) (transpose (analysis_def h)).
unfold equal in |- *.

*****

*****
forall h : hedge, and (inclusion (analysis_def (transpose h)) (transpose (analysis_def h))) (inclusion (transpose (analysis_def h)) (analysis_def (transpose h)))
+++++
split.
-----
Lemma ana_transpose_transpose_ana : forall h : hedge, equal (analysis_def (transpose h)) (transpose (analysis_def h)).
unfold equal in |- *.
split.

*****
h : hedge
*****
inclusion (analysis_def (transpose h)) (transpose (analysis_def h))
+++++
apply ana_transpose_incl_transpose_ana.
-----
Lemma ana_transpose_transpose_ana : forall h : hedge, equal (analysis_def (transpose h)) (transpose (analysis_def h)).
unfold equal in |- *.
split.

*****
h : hedge
*****
inclusion (transpose (analysis_def h)) (analysis_def (transpose h))
+++++
apply inclusion_trans with (transpose (transpose (analysis_def (transpose h)))).
-----
Lemma ana_transpose_transpose_ana : forall h : hedge, equal (analysis_def (transpose h)) (transpose (analysis_def h)).
unfold equal in |- *.
split.
apply inclusion_trans with (transpose (transpose (analysis_def (transpose h)))).

*****
h : hedge
*****
inclusion (transpose (analysis_def h)) (transpose (transpose (analysis_def (transpose h))))
+++++
apply inclusion_transpose_inclusion.
-----
Lemma ana_transpose_transpose_ana : forall h : hedge, equal (analysis_def (transpose h)) (transpose (analysis_def h)).
unfold equal in |- *.
split.
apply inclusion_trans with (transpose (transpose (analysis_def (transpose h)))).
apply inclusion_transpose_inclusion.

*****
h : hedge
*****
inclusion (analysis_def h) (transpose (analysis_def (transpose h)))
+++++
apply ana_incl_transpose_ana_transpose.
-----
Lemma ana_transpose_transpose_ana : forall h : hedge, equal (analysis_def (transpose h)) (transpose (analysis_def h)).
unfold equal in |- *.
split.
apply inclusion_trans with (transpose (transpose (analysis_def (transpose h)))).

*****
h : hedge
*****
inclusion (transpose (transpose (analysis_def (transpose h)))) (analysis_def (transpose h))
+++++
generalize (transpose_invol (analysis_def (transpose h))).
-----
Lemma ana_transpose_transpose_ana : forall h : hedge, equal (analysis_def (transpose h)) (transpose (analysis_def h)).
unfold equal in |- *.
split.
apply inclusion_trans with (transpose (transpose (analysis_def (transpose h)))).
generalize (transpose_invol (analysis_def (transpose h))).

*****
h : hedge
*****
forall _ : equal (analysis_def (transpose h)) (transpose (transpose (analysis_def (transpose h)))), inclusion (transpose (transpose (analysis_def (transpose h)))) (analysis_def (transpose h))
+++++
unfold equal in |- *.
-----
Lemma ana_transpose_transpose_ana : forall h : hedge, equal (analysis_def (transpose h)) (transpose (analysis_def h)).
unfold equal in |- *.
split.
apply inclusion_trans with (transpose (transpose (analysis_def (transpose h)))).
generalize (transpose_invol (analysis_def (transpose h))).
unfold equal in |- *.

*****
h : hedge
*****
forall _ : and (inclusion (analysis_def (transpose h)) (transpose (transpose (analysis_def (transpose h))))) (inclusion (transpose (transpose (analysis_def (transpose h)))) (analysis_def (transpose h))), inclusion (transpose (transpose (analysis_def (transpose h)))) (analysis_def (transpose h))
+++++
tauto.
-----
Lemma ana_transpose_transpose_ana : forall h : hedge, equal (analysis_def (transpose h)) (transpose (analysis_def h)).
unfold equal in |- *.
split.

*****

*****

+++++
Qed.
-----
Lemma irr_transpose_transpose_irr :\n forall h : hedge,\n equal (irreducible (transpose h)) (transpose (irreducible h)).
-----
Lemma irr_transpose_transpose_irr : forall h : hedge, equal (irreducible (transpose h)) (transpose (irreducible h)).

*****

*****
forall h : hedge, equal (irreducible (transpose h)) (transpose (irreducible h))
+++++
unfold irreducible in |- *.
-----
Lemma irr_transpose_transpose_irr : forall h : hedge, equal (irreducible (transpose h)) (transpose (irreducible h)).
unfold irreducible in |- *.

*****

*****
forall h : hedge, equal (reduce (analysis_def (transpose h))) (transpose (reduce (analysis_def h)))
+++++
intro.
-----
Lemma irr_transpose_transpose_irr : forall h : hedge, equal (irreducible (transpose h)) (transpose (irreducible h)).
unfold irreducible in |- *.
intro.

*****
h : hedge
*****
equal (reduce (analysis_def (transpose h))) (transpose (reduce (analysis_def h)))
+++++
apply equal_trans with (reduce (transpose (analysis_def h))).
-----
Lemma irr_transpose_transpose_irr : forall h : hedge, equal (irreducible (transpose h)) (transpose (irreducible h)).
unfold irreducible in |- *.
intro.
apply equal_trans with (reduce (transpose (analysis_def h))).

*****
h : hedge
*****
equal (reduce (analysis_def (transpose h))) (reduce (transpose (analysis_def h)))
+++++
apply equal_reduce_equal.
-----
Lemma irr_transpose_transpose_irr : forall h : hedge, equal (irreducible (transpose h)) (transpose (irreducible h)).
unfold irreducible in |- *.
intro.
apply equal_trans with (reduce (transpose (analysis_def h))).
apply equal_reduce_equal.

*****
h : hedge
*****
equal (analysis_def (transpose h)) (transpose (analysis_def h))
+++++
apply ana_transpose_transpose_ana.
-----
Lemma irr_transpose_transpose_irr : forall h : hedge, equal (irreducible (transpose h)) (transpose (irreducible h)).
unfold irreducible in |- *.
intro.
apply equal_trans with (reduce (transpose (analysis_def h))).

*****
h : hedge
*****
equal (reduce (transpose (analysis_def h))) (transpose (reduce (analysis_def h)))
+++++
apply reduce_transpose_transpose_reduce.
-----
Lemma irr_transpose_transpose_irr : forall h : hedge, equal (irreducible (transpose h)) (transpose (irreducible h)).
unfold irreducible in |- *.
intro.
apply equal_trans with (reduce (transpose (analysis_def h))).

*****

*****

+++++
Qed.
-----
Lemma is_irreducible_transpose_is_irreducible :\n forall h : hedge, is_irreducible h -> is_irreducible (transpose h).
-----
Lemma is_irreducible_transpose_is_irreducible : forall h : hedge, is_irreducible h -> is_irreducible (transpose h).

*****

*****
forall (h : hedge) (_ : is_irreducible h), is_irreducible (transpose h)
+++++
unfold is_irreducible in |- *.
-----
Lemma is_irreducible_transpose_is_irreducible : forall h : hedge, is_irreducible h -> is_irreducible (transpose h).
unfold is_irreducible in |- *.

*****

*****
forall (h : hedge) (_ : equal h (irreducible h)), equal (transpose h) (irreducible (transpose h))
+++++
intros.
-----
Lemma is_irreducible_transpose_is_irreducible : forall h : hedge, is_irreducible h -> is_irreducible (transpose h).
unfold is_irreducible in |- *.
intros.

*****
H : equal h (irreducible h)
h : hedge
*****
equal (transpose h) (irreducible (transpose h))
+++++
apply equal_trans with (transpose (irreducible h)).
-----
Lemma is_irreducible_transpose_is_irreducible : forall h : hedge, is_irreducible h -> is_irreducible (transpose h).
unfold is_irreducible in |- *.
intros.
apply equal_trans with (transpose (irreducible h)).

*****
H : equal h (irreducible h)
h : hedge
*****
equal (transpose h) (transpose (irreducible h))
+++++
apply equal_transpose_equal.
-----
Lemma is_irreducible_transpose_is_irreducible : forall h : hedge, is_irreducible h -> is_irreducible (transpose h).
unfold is_irreducible in |- *.
intros.
apply equal_trans with (transpose (irreducible h)).
apply equal_transpose_equal.

*****
H : equal h (irreducible h)
h : hedge
*****
equal h (irreducible h)
+++++
trivial.
-----
Lemma is_irreducible_transpose_is_irreducible : forall h : hedge, is_irreducible h -> is_irreducible (transpose h).
unfold is_irreducible in |- *.
intros.
apply equal_trans with (transpose (irreducible h)).

*****
H : equal h (irreducible h)
h : hedge
*****
equal (transpose (irreducible h)) (irreducible (transpose h))
+++++
apply equal_sym.
-----
Lemma is_irreducible_transpose_is_irreducible : forall h : hedge, is_irreducible h -> is_irreducible (transpose h).
unfold is_irreducible in |- *.
intros.
apply equal_trans with (transpose (irreducible h)).
apply equal_sym.

*****
H : equal h (irreducible h)
h : hedge
*****
equal (irreducible (transpose h)) (transpose (irreducible h))
+++++
apply irr_transpose_transpose_irr.
-----
Lemma is_irreducible_transpose_is_irreducible : forall h : hedge, is_irreducible h -> is_irreducible (transpose h).
unfold is_irreducible in |- *.
intros.
apply equal_trans with (transpose (irreducible h)).

*****

*****

+++++
Qed.
-----
Theorem irr_le_h_consistent_impl_consistent :\n forall g h : hedge,\n is_irreducible g -> is_consistent h -> le_h g h -> is_consistent g.
-----
Theorem irr_le_h_consistent_impl_consistent : forall g h : hedge, is_irreducible g -> is_consistent h -> le_h g h -> is_consistent g.

*****

*****
forall (g h : hedge) (_ : is_irreducible g) (_ : is_consistent h) (_ : le_h g h), is_consistent g
+++++
unfold is_consistent in |- *.
-----
Theorem irr_le_h_consistent_impl_consistent : forall g h : hedge, is_irreducible g -> is_consistent h -> le_h g h -> is_consistent g.
unfold is_consistent in |- *.

*****

*****
forall (g h : hedge) (_ : is_irreducible g) (_ : and (is_left_consistent h) (is_left_consistent (transpose h))) (_ : le_h g h), and (is_left_consistent g) (is_left_consistent (transpose g))
+++++
intros.
-----
Theorem irr_le_h_consistent_impl_consistent : forall g h : hedge, is_irreducible g -> is_consistent h -> le_h g h -> is_consistent g.
unfold is_consistent in |- *.
intros.

*****
H1 : le_h g h
H0 : and (is_left_consistent h) (is_left_consistent (transpose h))
H : is_irreducible g
g,h : hedge
*****
and (is_left_consistent g) (is_left_consistent (transpose g))
+++++
split.
-----
Theorem irr_le_h_consistent_impl_consistent : forall g h : hedge, is_irreducible g -> is_consistent h -> le_h g h -> is_consistent g.
unfold is_consistent in |- *.
intros.
split.

*****
H1 : le_h g h
H0 : and (is_left_consistent h) (is_left_consistent (transpose h))
H : is_irreducible g
g,h : hedge
*****
is_left_consistent g
+++++
apply irr_le_h_left_consistent_impl_left_consistent with h.
-----
Theorem irr_le_h_consistent_impl_consistent : forall g h : hedge, is_irreducible g -> is_consistent h -> le_h g h -> is_consistent g.
unfold is_consistent in |- *.
intros.
split.
apply irr_le_h_left_consistent_impl_left_consistent with h.

*****
H1 : le_h g h
H0 : and (is_left_consistent h) (is_left_consistent (transpose h))
H : is_irreducible g
g,h : hedge
*****
is_irreducible g
+++++
tauto.
-----
Theorem irr_le_h_consistent_impl_consistent : forall g h : hedge, is_irreducible g -> is_consistent h -> le_h g h -> is_consistent g.
unfold is_consistent in |- *.
intros.
split.
apply irr_le_h_left_consistent_impl_left_consistent with h.

*****
H1 : le_h g h
H0 : and (is_left_consistent h) (is_left_consistent (transpose h))
H : is_irreducible g
g,h : hedge
*****
is_left_consistent h
+++++
tauto.
-----
Theorem irr_le_h_consistent_impl_consistent : forall g h : hedge, is_irreducible g -> is_consistent h -> le_h g h -> is_consistent g.
unfold is_consistent in |- *.
intros.
split.
apply irr_le_h_left_consistent_impl_left_consistent with h.

*****
H1 : le_h g h
H0 : and (is_left_consistent h) (is_left_consistent (transpose h))
H : is_irreducible g
g,h : hedge
*****
le_h g h
+++++
tauto.
-----
Theorem irr_le_h_consistent_impl_consistent : forall g h : hedge, is_irreducible g -> is_consistent h -> le_h g h -> is_consistent g.
unfold is_consistent in |- *.
intros.
split.

*****
H1 : le_h g h
H0 : and (is_left_consistent h) (is_left_consistent (transpose h))
H : is_irreducible g
g,h : hedge
*****
is_left_consistent (transpose g)
+++++
apply irr_le_h_left_consistent_impl_left_consistent with (transpose h).
-----
Theorem irr_le_h_consistent_impl_consistent : forall g h : hedge, is_irreducible g -> is_consistent h -> le_h g h -> is_consistent g.
unfold is_consistent in |- *.
intros.
split.
apply irr_le_h_left_consistent_impl_left_consistent with (transpose h).

*****
H1 : le_h g h
H0 : and (is_left_consistent h) (is_left_consistent (transpose h))
H : is_irreducible g
g,h : hedge
*****
is_irreducible (transpose g)
+++++
apply is_irreducible_transpose_is_irreducible.
-----
Theorem irr_le_h_consistent_impl_consistent : forall g h : hedge, is_irreducible g -> is_consistent h -> le_h g h -> is_consistent g.
unfold is_consistent in |- *.
intros.
split.
apply irr_le_h_left_consistent_impl_left_consistent with (transpose h).
apply is_irreducible_transpose_is_irreducible.

*****
H1 : le_h g h
H0 : and (is_left_consistent h) (is_left_consistent (transpose h))
H : is_irreducible g
g,h : hedge
*****
is_irreducible g
+++++
trivial.
-----
Theorem irr_le_h_consistent_impl_consistent : forall g h : hedge, is_irreducible g -> is_consistent h -> le_h g h -> is_consistent g.
unfold is_consistent in |- *.
intros.
split.
apply irr_le_h_left_consistent_impl_left_consistent with (transpose h).

*****
H1 : le_h g h
H0 : and (is_left_consistent h) (is_left_consistent (transpose h))
H : is_irreducible g
g,h : hedge
*****
is_left_consistent (transpose h)
+++++
tauto.
-----
Theorem irr_le_h_consistent_impl_consistent : forall g h : hedge, is_irreducible g -> is_consistent h -> le_h g h -> is_consistent g.
unfold is_consistent in |- *.
intros.
split.
apply irr_le_h_left_consistent_impl_left_consistent with (transpose h).

*****
H1 : le_h g h
H0 : and (is_left_consistent h) (is_left_consistent (transpose h))
H : is_irreducible g
g,h : hedge
*****
le_h (transpose g) (transpose h)
+++++
apply le_h_transpose_le_h.
-----
Theorem irr_le_h_consistent_impl_consistent : forall g h : hedge, is_irreducible g -> is_consistent h -> le_h g h -> is_consistent g.
unfold is_consistent in |- *.
intros.
split.
apply irr_le_h_left_consistent_impl_left_consistent with (transpose h).
apply le_h_transpose_le_h.

*****
H1 : le_h g h
H0 : and (is_left_consistent h) (is_left_consistent (transpose h))
H : is_irreducible g
g,h : hedge
*****
le_h g h
+++++
trivial.
-----
Theorem irr_le_h_consistent_impl_consistent : forall g h : hedge, is_irreducible g -> is_consistent h -> le_h g h -> is_consistent g.
unfold is_consistent in |- *.
intros.
split.

*****

*****

+++++
Qed.
-----
