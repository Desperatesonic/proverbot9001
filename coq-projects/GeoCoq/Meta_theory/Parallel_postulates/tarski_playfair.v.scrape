Require Import GeoCoq.Axioms.parallel_postulates.
-----
Require Import GeoCoq.Tarski_dev.Ch12_parallel.
-----
Section tarski_playfair.
-----
Context `{TnEQD:Tarski_neutral_dimensionless_with_decidable_point_equality}.
-----
Lemma tarski_s_euclid_implies_playfair :\n tarski_s_parallel_postulate ->\n playfair_s_postulate.
-----
Lemma tarski_s_euclid_implies_playfair : tarski_s_parallel_postulate -> playfair_s_postulate.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : tarski_s_parallel_postulate, playfair_s_postulate
+++++
Proof.
-----
Lemma tarski_s_euclid_implies_playfair : tarski_s_parallel_postulate -> playfair_s_postulate.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : tarski_s_parallel_postulate, playfair_s_postulate
+++++
assert (HAux: tarski_s_parallel_postulate -> forall A1 A2 B1 B2 C1 C2 P, ~ Col P A1 A2 -> Par A1 A2 B1 B2 -> Col P B1 B2 -> Par A1 A2 C1 C2 -> Col P C1 C2 -> Col C1 B1 B2 /\ Col C2 B1 B2).
-----
Lemma tarski_s_euclid_implies_playfair : tarski_s_parallel_postulate -> playfair_s_postulate.
Proof.
assert (HAux: tarski_s_parallel_postulate -> forall A1 A2 B1 B2 C1 C2 P, ~ Col P A1 A2 -> Par A1 A2 B1 B2 -> Col P B1 B2 -> Par A1 A2 C1 C2 -> Col P C1 C2 -> Col C1 B1 B2 /\\ Col C2 B1 B2).

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (_ : tarski_s_parallel_postulate) (A1 A2 B1 B2 C1 C2 P : Tpoint) (_ : not (Col P A1 A2)) (_ : Par A1 A2 B1 B2) (_ : Col P B1 B2) (_ : Par A1 A2 C1 C2) (_ : Col P C1 C2), and (Col C1 B1 B2) (Col C2 B1 B2)
+++++
intros HTE; intros.
-----
Lemma tarski_s_euclid_implies_playfair : tarski_s_parallel_postulate -> playfair_s_postulate.
Proof.
assert (HAux: tarski_s_parallel_postulate -> forall A1 A2 B1 B2 C1 C2 P, ~ Col P A1 A2 -> Par A1 A2 B1 B2 -> Col P B1 B2 -> Par A1 A2 C1 C2 -> Col P C1 C2 -> Col C1 B1 B2 /\\ Col C2 B1 B2).
intros HTE; intros.

*****
H3 : Col P C1 C2
H2 : Par A1 A2 C1 C2
H1 : Col P B1 B2
H0 : Par A1 A2 B1 B2
H : not (Col P A1 A2)
A1,A2,B1,B2,C1,C2,P : Tpoint
HTE : tarski_s_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Col C1 B1 B2) (Col C2 B1 B2)
+++++
apply par_distincts in H0.
-----
Lemma tarski_s_euclid_implies_playfair : tarski_s_parallel_postulate -> playfair_s_postulate.
Proof.
assert (HAux: tarski_s_parallel_postulate -> forall A1 A2 B1 B2 C1 C2 P, ~ Col P A1 A2 -> Par A1 A2 B1 B2 -> Col P B1 B2 -> Par A1 A2 C1 C2 -> Col P C1 C2 -> Col C1 B1 B2 /\\ Col C2 B1 B2).
intros HTE; intros.
apply par_distincts in H0.

*****
H3 : Col P C1 C2
H2 : Par A1 A2 C1 C2
H1 : Col P B1 B2
H0 : and (Par A1 A2 B1 B2) (and (not (eq A1 A2)) (not (eq B1 B2)))
H : not (Col P A1 A2)
A1,A2,B1,B2,C1,C2,P : Tpoint
HTE : tarski_s_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Col C1 B1 B2) (Col C2 B1 B2)
+++++
apply par_distincts in H2.
-----
Lemma tarski_s_euclid_implies_playfair : tarski_s_parallel_postulate -> playfair_s_postulate.
Proof.
assert (HAux: tarski_s_parallel_postulate -> forall A1 A2 B1 B2 C1 C2 P, ~ Col P A1 A2 -> Par A1 A2 B1 B2 -> Col P B1 B2 -> Par A1 A2 C1 C2 -> Col P C1 C2 -> Col C1 B1 B2 /\\ Col C2 B1 B2).
intros HTE; intros.
apply par_distincts in H0.
apply par_distincts in H2.

*****
H3 : Col P C1 C2
H2 : and (Par A1 A2 C1 C2) (and (not (eq A1 A2)) (not (eq C1 C2)))
H1 : Col P B1 B2
H0 : and (Par A1 A2 B1 B2) (and (not (eq A1 A2)) (not (eq B1 B2)))
H : not (Col P A1 A2)
A1,A2,B1,B2,C1,C2,P : Tpoint
HTE : tarski_s_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Col C1 B1 B2) (Col C2 B1 B2)
+++++
spliter.
-----
Lemma tarski_s_euclid_implies_playfair : tarski_s_parallel_postulate -> playfair_s_postulate.
Proof.
assert (HAux: tarski_s_parallel_postulate -> forall A1 A2 B1 B2 C1 C2 P, ~ Col P A1 A2 -> Par A1 A2 B1 B2 -> Col P B1 B2 -> Par A1 A2 C1 C2 -> Col P C1 C2 -> Col C1 B1 B2 /\\ Col C2 B1 B2).
intros HTE; intros.
apply par_distincts in H0.
apply par_distincts in H2.
spliter.

*****
H3 : Col P C1 C2
H5 : not (eq C1 C2)
H4 : not (eq A1 A2)
H2 : Par A1 A2 C1 C2
H1 : Col P B1 B2
H7 : not (eq B1 B2)
H6 : not (eq A1 A2)
H0 : Par A1 A2 B1 B2
H : not (Col P A1 A2)
A1,A2,B1,B2,C1,C2,P : Tpoint
HTE : tarski_s_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Col C1 B1 B2) (Col C2 B1 B2)
+++++
assert(HPar1 : Par_strict A1 A2 B1 B2) by (apply (par_not_col_strict _ _ _ _ P); Col; intro; apply H; Col).
-----
Lemma tarski_s_euclid_implies_playfair : tarski_s_parallel_postulate -> playfair_s_postulate.
Proof.
assert (HAux: tarski_s_parallel_postulate -> forall A1 A2 B1 B2 C1 C2 P, ~ Col P A1 A2 -> Par A1 A2 B1 B2 -> Col P B1 B2 -> Par A1 A2 C1 C2 -> Col P C1 C2 -> Col C1 B1 B2 /\\ Col C2 B1 B2).
intros HTE; intros.
apply par_distincts in H0.
apply par_distincts in H2.
spliter.
assert(HPar1 : Par_strict A1 A2 B1 B2) by (apply (par_not_col_strict _ _ _ _ P); Col; intro; apply H; Col).

*****
HPar1 : Par_strict A1 A2 B1 B2
H3 : Col P C1 C2
H5 : not (eq C1 C2)
H4 : not (eq A1 A2)
H2 : Par A1 A2 C1 C2
H1 : Col P B1 B2
H7 : not (eq B1 B2)
H6 : not (eq A1 A2)
H0 : Par A1 A2 B1 B2
H : not (Col P A1 A2)
A1,A2,B1,B2,C1,C2,P : Tpoint
HTE : tarski_s_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Col C1 B1 B2) (Col C2 B1 B2)
+++++
assert(HPar2 : Par_strict A1 A2 C1 C2) by (apply (par_not_col_strict _ _ _ _ P); Col; intro; apply H; Col).
-----
Lemma tarski_s_euclid_implies_playfair : tarski_s_parallel_postulate -> playfair_s_postulate.
Proof.
assert (HAux: tarski_s_parallel_postulate -> forall A1 A2 B1 B2 C1 C2 P, ~ Col P A1 A2 -> Par A1 A2 B1 B2 -> Col P B1 B2 -> Par A1 A2 C1 C2 -> Col P C1 C2 -> Col C1 B1 B2 /\\ Col C2 B1 B2).
intros HTE; intros.
apply par_distincts in H0.
apply par_distincts in H2.
spliter.
assert(HPar1 : Par_strict A1 A2 B1 B2) by (apply (par_not_col_strict _ _ _ _ P); Col; intro; apply H; Col).
assert(HPar2 : Par_strict A1 A2 C1 C2) by (apply (par_not_col_strict _ _ _ _ P); Col; intro; apply H; Col).

*****
HPar2 : Par_strict A1 A2 C1 C2
HPar1 : Par_strict A1 A2 B1 B2
H3 : Col P C1 C2
H5 : not (eq C1 C2)
H4 : not (eq A1 A2)
H2 : Par A1 A2 C1 C2
H1 : Col P B1 B2
H7 : not (eq B1 B2)
H6 : not (eq A1 A2)
H0 : Par A1 A2 B1 B2
H : not (Col P A1 A2)
A1,A2,B1,B2,C1,C2,P : Tpoint
HTE : tarski_s_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Col C1 B1 B2) (Col C2 B1 B2)
+++++
elim (line_dec B1 B2 C1 C2); intro HLine.
-----
Lemma tarski_s_euclid_implies_playfair : tarski_s_parallel_postulate -> playfair_s_postulate.
Proof.
assert (HAux: tarski_s_parallel_postulate -> forall A1 A2 B1 B2 C1 C2 P, ~ Col P A1 A2 -> Par A1 A2 B1 B2 -> Col P B1 B2 -> Par A1 A2 C1 C2 -> Col P C1 C2 -> Col C1 B1 B2 /\\ Col C2 B1 B2).
intros HTE; intros.
apply par_distincts in H0.
apply par_distincts in H2.
spliter.
assert(HPar1 : Par_strict A1 A2 B1 B2) by (apply (par_not_col_strict _ _ _ _ P); Col; intro; apply H; Col).
assert(HPar2 : Par_strict A1 A2 C1 C2) by (apply (par_not_col_strict _ _ _ _ P); Col; intro; apply H; Col).
elim (line_dec B1 B2 C1 C2); intro HLine.

*****
HLine : and (Col C1 B1 B2) (Col C2 B1 B2)
HPar2 : Par_strict A1 A2 C1 C2
HPar1 : Par_strict A1 A2 B1 B2
H3 : Col P C1 C2
H5 : not (eq C1 C2)
H4 : not (eq A1 A2)
H2 : Par A1 A2 C1 C2
H1 : Col P B1 B2
H7 : not (eq B1 B2)
H6 : not (eq A1 A2)
H0 : Par A1 A2 B1 B2
H : not (Col P A1 A2)
A1,A2,B1,B2,C1,C2,P : Tpoint
HTE : tarski_s_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Col C1 B1 B2) (Col C2 B1 B2)
+++++
assumption.
-----
Lemma tarski_s_euclid_implies_playfair : tarski_s_parallel_postulate -> playfair_s_postulate.
Proof.
assert (HAux: tarski_s_parallel_postulate -> forall A1 A2 B1 B2 C1 C2 P, ~ Col P A1 A2 -> Par A1 A2 B1 B2 -> Col P B1 B2 -> Par A1 A2 C1 C2 -> Col P C1 C2 -> Col C1 B1 B2 /\\ Col C2 B1 B2).
intros HTE; intros.
apply par_distincts in H0.
apply par_distincts in H2.
spliter.
assert(HPar1 : Par_strict A1 A2 B1 B2) by (apply (par_not_col_strict _ _ _ _ P); Col; intro; apply H; Col).
assert(HPar2 : Par_strict A1 A2 C1 C2) by (apply (par_not_col_strict _ _ _ _ P); Col; intro; apply H; Col).
elim (line_dec B1 B2 C1 C2); intro HLine.
assumption.

*****
HLine : not (and (Col C1 B1 B2) (Col C2 B1 B2))
HPar2 : Par_strict A1 A2 C1 C2
HPar1 : Par_strict A1 A2 B1 B2
H3 : Col P C1 C2
H5 : not (eq C1 C2)
H4 : not (eq A1 A2)
H2 : Par A1 A2 C1 C2
H1 : Col P B1 B2
H7 : not (eq B1 B2)
H6 : not (eq A1 A2)
H0 : Par A1 A2 B1 B2
H : not (Col P A1 A2)
A1,A2,B1,B2,C1,C2,P : Tpoint
HTE : tarski_s_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Col C1 B1 B2) (Col C2 B1 B2)
+++++
assert (HLineNew : ~ Col C1 B1 B2 \/ ~ Col C2 B1 B2) by (induction (col_dec C1 B1 B2); induction (col_dec C2 B1 B2);tauto).
-----
Lemma tarski_s_euclid_implies_playfair : tarski_s_parallel_postulate -> playfair_s_postulate.
Proof.
assert (HAux: tarski_s_parallel_postulate -> forall A1 A2 B1 B2 C1 C2 P, ~ Col P A1 A2 -> Par A1 A2 B1 B2 -> Col P B1 B2 -> Par A1 A2 C1 C2 -> Col P C1 C2 -> Col C1 B1 B2 /\\ Col C2 B1 B2).
intros HTE; intros.
apply par_distincts in H0.
apply par_distincts in H2.
spliter.
assert(HPar1 : Par_strict A1 A2 B1 B2) by (apply (par_not_col_strict _ _ _ _ P); Col; intro; apply H; Col).
assert(HPar2 : Par_strict A1 A2 C1 C2) by (apply (par_not_col_strict _ _ _ _ P); Col; intro; apply H; Col).
elim (line_dec B1 B2 C1 C2); intro HLine.
assumption.
assert (HLineNew : ~ Col C1 B1 B2 \\/ ~ Col C2 B1 B2) by (induction (col_dec C1 B1 B2); induction (col_dec C2 B1 B2);tauto).

*****
HLineNew : or (not (Col C1 B1 B2)) (not (Col C2 B1 B2))
HLine : not (and (Col C1 B1 B2) (Col C2 B1 B2))
HPar2 : Par_strict A1 A2 C1 C2
HPar1 : Par_strict A1 A2 B1 B2
H3 : Col P C1 C2
H5 : not (eq C1 C2)
H4 : not (eq A1 A2)
H2 : Par A1 A2 C1 C2
H1 : Col P B1 B2
H7 : not (eq B1 B2)
H6 : not (eq A1 A2)
H0 : Par A1 A2 B1 B2
H : not (Col P A1 A2)
A1,A2,B1,B2,C1,C2,P : Tpoint
HTE : tarski_s_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Col C1 B1 B2) (Col C2 B1 B2)
+++++
clear HLine; rename HLineNew into HLine.
-----
Lemma tarski_s_euclid_implies_playfair : tarski_s_parallel_postulate -> playfair_s_postulate.
Proof.
assert (HAux: tarski_s_parallel_postulate -> forall A1 A2 B1 B2 C1 C2 P, ~ Col P A1 A2 -> Par A1 A2 B1 B2 -> Col P B1 B2 -> Par A1 A2 C1 C2 -> Col P C1 C2 -> Col C1 B1 B2 /\\ Col C2 B1 B2).
intros HTE; intros.
apply par_distincts in H0.
apply par_distincts in H2.
spliter.
assert(HPar1 : Par_strict A1 A2 B1 B2) by (apply (par_not_col_strict _ _ _ _ P); Col; intro; apply H; Col).
assert(HPar2 : Par_strict A1 A2 C1 C2) by (apply (par_not_col_strict _ _ _ _ P); Col; intro; apply H; Col).
elim (line_dec B1 B2 C1 C2); intro HLine.
assumption.
assert (HLineNew : ~ Col C1 B1 B2 \\/ ~ Col C2 B1 B2) by (induction (col_dec C1 B1 B2); induction (col_dec C2 B1 B2);tauto).
clear HLine; rename HLineNew into HLine.

*****
HLine : or (not (Col C1 B1 B2)) (not (Col C2 B1 B2))
HPar2 : Par_strict A1 A2 C1 C2
HPar1 : Par_strict A1 A2 B1 B2
H3 : Col P C1 C2
H5 : not (eq C1 C2)
H4 : not (eq A1 A2)
H2 : Par A1 A2 C1 C2
H1 : Col P B1 B2
H7 : not (eq B1 B2)
H6 : not (eq A1 A2)
H0 : Par A1 A2 B1 B2
H : not (Col P A1 A2)
A1,A2,B1,B2,C1,C2,P : Tpoint
HTE : tarski_s_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Col C1 B1 B2) (Col C2 B1 B2)
+++++
assert(HC' : exists C', Col C1 C2 C' /\ TS B1 B2 A1 C').
-----
Lemma tarski_s_euclid_implies_playfair : tarski_s_parallel_postulate -> playfair_s_postulate.
Proof.
assert (HAux: tarski_s_parallel_postulate -> forall A1 A2 B1 B2 C1 C2 P, ~ Col P A1 A2 -> Par A1 A2 B1 B2 -> Col P B1 B2 -> Par A1 A2 C1 C2 -> Col P C1 C2 -> Col C1 B1 B2 /\\ Col C2 B1 B2).
intros HTE; intros.
apply par_distincts in H0.
apply par_distincts in H2.
spliter.
assert(HPar1 : Par_strict A1 A2 B1 B2) by (apply (par_not_col_strict _ _ _ _ P); Col; intro; apply H; Col).
assert(HPar2 : Par_strict A1 A2 C1 C2) by (apply (par_not_col_strict _ _ _ _ P); Col; intro; apply H; Col).
elim (line_dec B1 B2 C1 C2); intro HLine.
assumption.
assert (HLineNew : ~ Col C1 B1 B2 \\/ ~ Col C2 B1 B2) by (induction (col_dec C1 B1 B2); induction (col_dec C2 B1 B2);tauto).
clear HLine; rename HLineNew into HLine.
assert(HC' : exists C', Col C1 C2 C' /\\ TS B1 B2 A1 C').

*****
HLine : or (not (Col C1 B1 B2)) (not (Col C2 B1 B2))
HPar2 : Par_strict A1 A2 C1 C2
HPar1 : Par_strict A1 A2 B1 B2
H3 : Col P C1 C2
H5 : not (eq C1 C2)
H4 : not (eq A1 A2)
H2 : Par A1 A2 C1 C2
H1 : Col P B1 B2
H7 : not (eq B1 B2)
H6 : not (eq A1 A2)
H0 : Par A1 A2 B1 B2
H : not (Col P A1 A2)
A1,A2,B1,B2,C1,C2,P : Tpoint
HTE : tarski_s_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun C' : Tpoint => and (Col C1 C2 C') (TS B1 B2 A1 C'))
+++++
assert (Coplanar A1 A2 P A1) by (exists A1; left; split; Col).
-----
Lemma tarski_s_euclid_implies_playfair : tarski_s_parallel_postulate -> playfair_s_postulate.
Proof.
assert (HAux: tarski_s_parallel_postulate -> forall A1 A2 B1 B2 C1 C2 P, ~ Col P A1 A2 -> Par A1 A2 B1 B2 -> Col P B1 B2 -> Par A1 A2 C1 C2 -> Col P C1 C2 -> Col C1 B1 B2 /\\ Col C2 B1 B2).
intros HTE; intros.
apply par_distincts in H0.
apply par_distincts in H2.
spliter.
assert(HPar1 : Par_strict A1 A2 B1 B2) by (apply (par_not_col_strict _ _ _ _ P); Col; intro; apply H; Col).
assert(HPar2 : Par_strict A1 A2 C1 C2) by (apply (par_not_col_strict _ _ _ _ P); Col; intro; apply H; Col).
elim (line_dec B1 B2 C1 C2); intro HLine.
assumption.
assert (HLineNew : ~ Col C1 B1 B2 \\/ ~ Col C2 B1 B2) by (induction (col_dec C1 B1 B2); induction (col_dec C2 B1 B2);tauto).
clear HLine; rename HLineNew into HLine.
assert(HC' : exists C', Col C1 C2 C' /\\ TS B1 B2 A1 C').
assert (Coplanar A1 A2 P A1) by (exists A1; left; split; Col).

*****
H8 : Coplanar A1 A2 P A1
HLine : or (not (Col C1 B1 B2)) (not (Col C2 B1 B2))
HPar2 : Par_strict A1 A2 C1 C2
HPar1 : Par_strict A1 A2 B1 B2
H3 : Col P C1 C2
H5 : not (eq C1 C2)
H4 : not (eq A1 A2)
H2 : Par A1 A2 C1 C2
H1 : Col P B1 B2
H7 : not (eq B1 B2)
H6 : not (eq A1 A2)
H0 : Par A1 A2 B1 B2
H : not (Col P A1 A2)
A1,A2,B1,B2,C1,C2,P : Tpoint
HTE : tarski_s_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun C' : Tpoint => and (Col C1 C2 C') (TS B1 B2 A1 C'))
+++++
apply par__coplanar in H0.
-----
Lemma tarski_s_euclid_implies_playfair : tarski_s_parallel_postulate -> playfair_s_postulate.
Proof.
assert (HAux: tarski_s_parallel_postulate -> forall A1 A2 B1 B2 C1 C2 P, ~ Col P A1 A2 -> Par A1 A2 B1 B2 -> Col P B1 B2 -> Par A1 A2 C1 C2 -> Col P C1 C2 -> Col C1 B1 B2 /\\ Col C2 B1 B2).
intros HTE; intros.
apply par_distincts in H0.
apply par_distincts in H2.
spliter.
assert(HPar1 : Par_strict A1 A2 B1 B2) by (apply (par_not_col_strict _ _ _ _ P); Col; intro; apply H; Col).
assert(HPar2 : Par_strict A1 A2 C1 C2) by (apply (par_not_col_strict _ _ _ _ P); Col; intro; apply H; Col).
elim (line_dec B1 B2 C1 C2); intro HLine.
assumption.
assert (HLineNew : ~ Col C1 B1 B2 \\/ ~ Col C2 B1 B2) by (induction (col_dec C1 B1 B2); induction (col_dec C2 B1 B2);tauto).
clear HLine; rename HLineNew into HLine.
assert(HC' : exists C', Col C1 C2 C' /\\ TS B1 B2 A1 C').
assert (Coplanar A1 A2 P A1) by (exists A1; left; split; Col).
apply par__coplanar in H0.

*****
H8 : Coplanar A1 A2 P A1
HLine : or (not (Col C1 B1 B2)) (not (Col C2 B1 B2))
HPar2 : Par_strict A1 A2 C1 C2
HPar1 : Par_strict A1 A2 B1 B2
H3 : Col P C1 C2
H5 : not (eq C1 C2)
H4 : not (eq A1 A2)
H2 : Par A1 A2 C1 C2
H1 : Col P B1 B2
H7 : not (eq B1 B2)
H6 : not (eq A1 A2)
H0 : Coplanar A1 A2 B1 B2
H : not (Col P A1 A2)
A1,A2,B1,B2,C1,C2,P : Tpoint
HTE : tarski_s_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun C' : Tpoint => and (Col C1 C2 C') (TS B1 B2 A1 C'))
+++++
apply par__coplanar in H2.
-----
Lemma tarski_s_euclid_implies_playfair : tarski_s_parallel_postulate -> playfair_s_postulate.
Proof.
assert (HAux: tarski_s_parallel_postulate -> forall A1 A2 B1 B2 C1 C2 P, ~ Col P A1 A2 -> Par A1 A2 B1 B2 -> Col P B1 B2 -> Par A1 A2 C1 C2 -> Col P C1 C2 -> Col C1 B1 B2 /\\ Col C2 B1 B2).
intros HTE; intros.
apply par_distincts in H0.
apply par_distincts in H2.
spliter.
assert(HPar1 : Par_strict A1 A2 B1 B2) by (apply (par_not_col_strict _ _ _ _ P); Col; intro; apply H; Col).
assert(HPar2 : Par_strict A1 A2 C1 C2) by (apply (par_not_col_strict _ _ _ _ P); Col; intro; apply H; Col).
elim (line_dec B1 B2 C1 C2); intro HLine.
assumption.
assert (HLineNew : ~ Col C1 B1 B2 \\/ ~ Col C2 B1 B2) by (induction (col_dec C1 B1 B2); induction (col_dec C2 B1 B2);tauto).
clear HLine; rename HLineNew into HLine.
assert(HC' : exists C', Col C1 C2 C' /\\ TS B1 B2 A1 C').
assert (Coplanar A1 A2 P A1) by (exists A1; left; split; Col).
apply par__coplanar in H0.
apply par__coplanar in H2.

*****
H8 : Coplanar A1 A2 P A1
HLine : or (not (Col C1 B1 B2)) (not (Col C2 B1 B2))
HPar2 : Par_strict A1 A2 C1 C2
HPar1 : Par_strict A1 A2 B1 B2
H3 : Col P C1 C2
H5 : not (eq C1 C2)
H4 : not (eq A1 A2)
H2 : Coplanar A1 A2 C1 C2
H1 : Col P B1 B2
H7 : not (eq B1 B2)
H6 : not (eq A1 A2)
H0 : Coplanar A1 A2 B1 B2
H : not (Col P A1 A2)
A1,A2,B1,B2,C1,C2,P : Tpoint
HTE : tarski_s_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun C' : Tpoint => and (Col C1 C2 C') (TS B1 B2 A1 C'))
+++++
assert (Coplanar A1 A2 P B1) by (apply coplanar_perm_1, col_cop__cop with B2; Col).
-----
Lemma tarski_s_euclid_implies_playfair : tarski_s_parallel_postulate -> playfair_s_postulate.
Proof.
assert (HAux: tarski_s_parallel_postulate -> forall A1 A2 B1 B2 C1 C2 P, ~ Col P A1 A2 -> Par A1 A2 B1 B2 -> Col P B1 B2 -> Par A1 A2 C1 C2 -> Col P C1 C2 -> Col C1 B1 B2 /\\ Col C2 B1 B2).
intros HTE; intros.
apply par_distincts in H0.
apply par_distincts in H2.
spliter.
assert(HPar1 : Par_strict A1 A2 B1 B2) by (apply (par_not_col_strict _ _ _ _ P); Col; intro; apply H; Col).
assert(HPar2 : Par_strict A1 A2 C1 C2) by (apply (par_not_col_strict _ _ _ _ P); Col; intro; apply H; Col).
elim (line_dec B1 B2 C1 C2); intro HLine.
assumption.
assert (HLineNew : ~ Col C1 B1 B2 \\/ ~ Col C2 B1 B2) by (induction (col_dec C1 B1 B2); induction (col_dec C2 B1 B2);tauto).
clear HLine; rename HLineNew into HLine.
assert(HC' : exists C', Col C1 C2 C' /\\ TS B1 B2 A1 C').
assert (Coplanar A1 A2 P A1) by (exists A1; left; split; Col).
apply par__coplanar in H0.
apply par__coplanar in H2.
assert (Coplanar A1 A2 P B1) by (apply coplanar_perm_1, col_cop__cop with B2; Col).

*****
H9 : Coplanar A1 A2 P B1
H8 : Coplanar A1 A2 P A1
HLine : or (not (Col C1 B1 B2)) (not (Col C2 B1 B2))
HPar2 : Par_strict A1 A2 C1 C2
HPar1 : Par_strict A1 A2 B1 B2
H3 : Col P C1 C2
H5 : not (eq C1 C2)
H4 : not (eq A1 A2)
H2 : Coplanar A1 A2 C1 C2
H1 : Col P B1 B2
H7 : not (eq B1 B2)
H6 : not (eq A1 A2)
H0 : Coplanar A1 A2 B1 B2
H : not (Col P A1 A2)
A1,A2,B1,B2,C1,C2,P : Tpoint
HTE : tarski_s_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun C' : Tpoint => and (Col C1 C2 C') (TS B1 B2 A1 C'))
+++++
assert (Coplanar A1 A2 P B2) by (apply coplanar_perm_1, col_cop__cop with B1; Col; Cop).
-----
Lemma tarski_s_euclid_implies_playfair : tarski_s_parallel_postulate -> playfair_s_postulate.
Proof.
assert (HAux: tarski_s_parallel_postulate -> forall A1 A2 B1 B2 C1 C2 P, ~ Col P A1 A2 -> Par A1 A2 B1 B2 -> Col P B1 B2 -> Par A1 A2 C1 C2 -> Col P C1 C2 -> Col C1 B1 B2 /\\ Col C2 B1 B2).
intros HTE; intros.
apply par_distincts in H0.
apply par_distincts in H2.
spliter.
assert(HPar1 : Par_strict A1 A2 B1 B2) by (apply (par_not_col_strict _ _ _ _ P); Col; intro; apply H; Col).
assert(HPar2 : Par_strict A1 A2 C1 C2) by (apply (par_not_col_strict _ _ _ _ P); Col; intro; apply H; Col).
elim (line_dec B1 B2 C1 C2); intro HLine.
assumption.
assert (HLineNew : ~ Col C1 B1 B2 \\/ ~ Col C2 B1 B2) by (induction (col_dec C1 B1 B2); induction (col_dec C2 B1 B2);tauto).
clear HLine; rename HLineNew into HLine.
assert(HC' : exists C', Col C1 C2 C' /\\ TS B1 B2 A1 C').
assert (Coplanar A1 A2 P A1) by (exists A1; left; split; Col).
apply par__coplanar in H0.
apply par__coplanar in H2.
assert (Coplanar A1 A2 P B1) by (apply coplanar_perm_1, col_cop__cop with B2; Col).
assert (Coplanar A1 A2 P B2) by (apply coplanar_perm_1, col_cop__cop with B1; Col; Cop).

*****
H10 : Coplanar A1 A2 P B2
H9 : Coplanar A1 A2 P B1
H8 : Coplanar A1 A2 P A1
HLine : or (not (Col C1 B1 B2)) (not (Col C2 B1 B2))
HPar2 : Par_strict A1 A2 C1 C2
HPar1 : Par_strict A1 A2 B1 B2
H3 : Col P C1 C2
H5 : not (eq C1 C2)
H4 : not (eq A1 A2)
H2 : Coplanar A1 A2 C1 C2
H1 : Col P B1 B2
H7 : not (eq B1 B2)
H6 : not (eq A1 A2)
H0 : Coplanar A1 A2 B1 B2
H : not (Col P A1 A2)
A1,A2,B1,B2,C1,C2,P : Tpoint
HTE : tarski_s_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun C' : Tpoint => and (Col C1 C2 C') (TS B1 B2 A1 C'))
+++++
assert (Coplanar A1 A2 P C1) by (apply coplanar_perm_1, col_cop__cop with C2; Col).
-----
Lemma tarski_s_euclid_implies_playfair : tarski_s_parallel_postulate -> playfair_s_postulate.
Proof.
assert (HAux: tarski_s_parallel_postulate -> forall A1 A2 B1 B2 C1 C2 P, ~ Col P A1 A2 -> Par A1 A2 B1 B2 -> Col P B1 B2 -> Par A1 A2 C1 C2 -> Col P C1 C2 -> Col C1 B1 B2 /\\ Col C2 B1 B2).
intros HTE; intros.
apply par_distincts in H0.
apply par_distincts in H2.
spliter.
assert(HPar1 : Par_strict A1 A2 B1 B2) by (apply (par_not_col_strict _ _ _ _ P); Col; intro; apply H; Col).
assert(HPar2 : Par_strict A1 A2 C1 C2) by (apply (par_not_col_strict _ _ _ _ P); Col; intro; apply H; Col).
elim (line_dec B1 B2 C1 C2); intro HLine.
assumption.
assert (HLineNew : ~ Col C1 B1 B2 \\/ ~ Col C2 B1 B2) by (induction (col_dec C1 B1 B2); induction (col_dec C2 B1 B2);tauto).
clear HLine; rename HLineNew into HLine.
assert(HC' : exists C', Col C1 C2 C' /\\ TS B1 B2 A1 C').
assert (Coplanar A1 A2 P A1) by (exists A1; left; split; Col).
apply par__coplanar in H0.
apply par__coplanar in H2.
assert (Coplanar A1 A2 P B1) by (apply coplanar_perm_1, col_cop__cop with B2; Col).
assert (Coplanar A1 A2 P B2) by (apply coplanar_perm_1, col_cop__cop with B1; Col; Cop).
assert (Coplanar A1 A2 P C1) by (apply coplanar_perm_1, col_cop__cop with C2; Col).

*****
H11 : Coplanar A1 A2 P C1
H10 : Coplanar A1 A2 P B2
H9 : Coplanar A1 A2 P B1
H8 : Coplanar A1 A2 P A1
HLine : or (not (Col C1 B1 B2)) (not (Col C2 B1 B2))
HPar2 : Par_strict A1 A2 C1 C2
HPar1 : Par_strict A1 A2 B1 B2
H3 : Col P C1 C2
H5 : not (eq C1 C2)
H4 : not (eq A1 A2)
H2 : Coplanar A1 A2 C1 C2
H1 : Col P B1 B2
H7 : not (eq B1 B2)
H6 : not (eq A1 A2)
H0 : Coplanar A1 A2 B1 B2
H : not (Col P A1 A2)
A1,A2,B1,B2,C1,C2,P : Tpoint
HTE : tarski_s_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun C' : Tpoint => and (Col C1 C2 C') (TS B1 B2 A1 C'))
+++++
assert (Coplanar A1 A2 P C2) by (apply coplanar_perm_1, col_cop__cop with C1; Col; Cop).
-----
Lemma tarski_s_euclid_implies_playfair : tarski_s_parallel_postulate -> playfair_s_postulate.
Proof.
assert (HAux: tarski_s_parallel_postulate -> forall A1 A2 B1 B2 C1 C2 P, ~ Col P A1 A2 -> Par A1 A2 B1 B2 -> Col P B1 B2 -> Par A1 A2 C1 C2 -> Col P C1 C2 -> Col C1 B1 B2 /\\ Col C2 B1 B2).
intros HTE; intros.
apply par_distincts in H0.
apply par_distincts in H2.
spliter.
assert(HPar1 : Par_strict A1 A2 B1 B2) by (apply (par_not_col_strict _ _ _ _ P); Col; intro; apply H; Col).
assert(HPar2 : Par_strict A1 A2 C1 C2) by (apply (par_not_col_strict _ _ _ _ P); Col; intro; apply H; Col).
elim (line_dec B1 B2 C1 C2); intro HLine.
assumption.
assert (HLineNew : ~ Col C1 B1 B2 \\/ ~ Col C2 B1 B2) by (induction (col_dec C1 B1 B2); induction (col_dec C2 B1 B2);tauto).
clear HLine; rename HLineNew into HLine.
assert(HC' : exists C', Col C1 C2 C' /\\ TS B1 B2 A1 C').
assert (Coplanar A1 A2 P A1) by (exists A1; left; split; Col).
apply par__coplanar in H0.
apply par__coplanar in H2.
assert (Coplanar A1 A2 P B1) by (apply coplanar_perm_1, col_cop__cop with B2; Col).
assert (Coplanar A1 A2 P B2) by (apply coplanar_perm_1, col_cop__cop with B1; Col; Cop).
assert (Coplanar A1 A2 P C1) by (apply coplanar_perm_1, col_cop__cop with C2; Col).
assert (Coplanar A1 A2 P C2) by (apply coplanar_perm_1, col_cop__cop with C1; Col; Cop).

*****
H12 : Coplanar A1 A2 P C2
H11 : Coplanar A1 A2 P C1
H10 : Coplanar A1 A2 P B2
H9 : Coplanar A1 A2 P B1
H8 : Coplanar A1 A2 P A1
HLine : or (not (Col C1 B1 B2)) (not (Col C2 B1 B2))
HPar2 : Par_strict A1 A2 C1 C2
HPar1 : Par_strict A1 A2 B1 B2
H3 : Col P C1 C2
H5 : not (eq C1 C2)
H4 : not (eq A1 A2)
H2 : Coplanar A1 A2 C1 C2
H1 : Col P B1 B2
H7 : not (eq B1 B2)
H6 : not (eq A1 A2)
H0 : Coplanar A1 A2 B1 B2
H : not (Col P A1 A2)
A1,A2,B1,B2,C1,C2,P : Tpoint
HTE : tarski_s_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun C' : Tpoint => and (Col C1 C2 C') (TS B1 B2 A1 C'))
+++++
elim HLine; clear HLine; intro HNC; [destruct (cop_not_par_other_side B1 B2 C1 C2 P A1) as [C' [HCol HTS]]| destruct (cop_not_par_other_side B1 B2 C2 C1 P A1) as [C' [HCol HTS]]]; try exists C'; Col; try (intro; apply HPar1; exists A1; Col); apply coplanar_pseudo_trans with A1 A2 P; Col.
-----
Lemma tarski_s_euclid_implies_playfair : tarski_s_parallel_postulate -> playfair_s_postulate.
Proof.
assert (HAux: tarski_s_parallel_postulate -> forall A1 A2 B1 B2 C1 C2 P, ~ Col P A1 A2 -> Par A1 A2 B1 B2 -> Col P B1 B2 -> Par A1 A2 C1 C2 -> Col P C1 C2 -> Col C1 B1 B2 /\\ Col C2 B1 B2).
intros HTE; intros.
apply par_distincts in H0.
apply par_distincts in H2.
spliter.
assert(HPar1 : Par_strict A1 A2 B1 B2) by (apply (par_not_col_strict _ _ _ _ P); Col; intro; apply H; Col).
assert(HPar2 : Par_strict A1 A2 C1 C2) by (apply (par_not_col_strict _ _ _ _ P); Col; intro; apply H; Col).
elim (line_dec B1 B2 C1 C2); intro HLine.
assumption.
assert (HLineNew : ~ Col C1 B1 B2 \\/ ~ Col C2 B1 B2) by (induction (col_dec C1 B1 B2); induction (col_dec C2 B1 B2);tauto).
clear HLine; rename HLineNew into HLine.
assert(HC' : exists C', Col C1 C2 C' /\\ TS B1 B2 A1 C').

*****
HC' : ex (fun C' : Tpoint => and (Col C1 C2 C') (TS B1 B2 A1 C'))
HLine : or (not (Col C1 B1 B2)) (not (Col C2 B1 B2))
HPar2 : Par_strict A1 A2 C1 C2
HPar1 : Par_strict A1 A2 B1 B2
H3 : Col P C1 C2
H5 : not (eq C1 C2)
H4 : not (eq A1 A2)
H2 : Par A1 A2 C1 C2
H1 : Col P B1 B2
H7 : not (eq B1 B2)
H6 : not (eq A1 A2)
H0 : Par A1 A2 B1 B2
H : not (Col P A1 A2)
A1,A2,B1,B2,C1,C2,P : Tpoint
HTE : tarski_s_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Col C1 B1 B2) (Col C2 B1 B2)
+++++
ex_and HC' C'.
-----
Lemma tarski_s_euclid_implies_playfair : tarski_s_parallel_postulate -> playfair_s_postulate.
Proof.
assert (HAux: tarski_s_parallel_postulate -> forall A1 A2 B1 B2 C1 C2 P, ~ Col P A1 A2 -> Par A1 A2 B1 B2 -> Col P B1 B2 -> Par A1 A2 C1 C2 -> Col P C1 C2 -> Col C1 B1 B2 /\\ Col C2 B1 B2).
intros HTE; intros.
apply par_distincts in H0.
apply par_distincts in H2.
spliter.
assert(HPar1 : Par_strict A1 A2 B1 B2) by (apply (par_not_col_strict _ _ _ _ P); Col; intro; apply H; Col).
assert(HPar2 : Par_strict A1 A2 C1 C2) by (apply (par_not_col_strict _ _ _ _ P); Col; intro; apply H; Col).
elim (line_dec B1 B2 C1 C2); intro HLine.
assumption.
assert (HLineNew : ~ Col C1 B1 B2 \\/ ~ Col C2 B1 B2) by (induction (col_dec C1 B1 B2); induction (col_dec C2 B1 B2);tauto).
clear HLine; rename HLineNew into HLine.
assert(HC' : exists C', Col C1 C2 C' /\\ TS B1 B2 A1 C').
ex_and HC' C'.

*****
H9 : TS B1 B2 A1 C'
H8 : Col C1 C2 C'
C' : Tpoint
HLine : or (not (Col C1 B1 B2)) (not (Col C2 B1 B2))
HPar2 : Par_strict A1 A2 C1 C2
HPar1 : Par_strict A1 A2 B1 B2
H3 : Col P C1 C2
H5 : not (eq C1 C2)
H4 : not (eq A1 A2)
H2 : Par A1 A2 C1 C2
H1 : Col P B1 B2
H7 : not (eq B1 B2)
H6 : not (eq A1 A2)
H0 : Par A1 A2 B1 B2
H : not (Col P A1 A2)
A1,A2,B1,B2,C1,C2,P : Tpoint
HTE : tarski_s_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Col C1 B1 B2) (Col C2 B1 B2)
+++++
unfold TS in H9.
-----
Lemma tarski_s_euclid_implies_playfair : tarski_s_parallel_postulate -> playfair_s_postulate.
Proof.
assert (HAux: tarski_s_parallel_postulate -> forall A1 A2 B1 B2 C1 C2 P, ~ Col P A1 A2 -> Par A1 A2 B1 B2 -> Col P B1 B2 -> Par A1 A2 C1 C2 -> Col P C1 C2 -> Col C1 B1 B2 /\\ Col C2 B1 B2).
intros HTE; intros.
apply par_distincts in H0.
apply par_distincts in H2.
spliter.
assert(HPar1 : Par_strict A1 A2 B1 B2) by (apply (par_not_col_strict _ _ _ _ P); Col; intro; apply H; Col).
assert(HPar2 : Par_strict A1 A2 C1 C2) by (apply (par_not_col_strict _ _ _ _ P); Col; intro; apply H; Col).
elim (line_dec B1 B2 C1 C2); intro HLine.
assumption.
assert (HLineNew : ~ Col C1 B1 B2 \\/ ~ Col C2 B1 B2) by (induction (col_dec C1 B1 B2); induction (col_dec C2 B1 B2);tauto).
clear HLine; rename HLineNew into HLine.
assert(HC' : exists C', Col C1 C2 C' /\\ TS B1 B2 A1 C').
ex_and HC' C'.
unfold TS in H9.

*****
H9 : and (not (Col A1 B1 B2))\n (and (not (Col C' B1 B2))\n (ex (fun T : Tpoint => and (Col T B1 B2) (Bet A1 T C'))))
H8 : Col C1 C2 C'
C' : Tpoint
HLine : or (not (Col C1 B1 B2)) (not (Col C2 B1 B2))
HPar2 : Par_strict A1 A2 C1 C2
HPar1 : Par_strict A1 A2 B1 B2
H3 : Col P C1 C2
H5 : not (eq C1 C2)
H4 : not (eq A1 A2)
H2 : Par A1 A2 C1 C2
H1 : Col P B1 B2
H7 : not (eq B1 B2)
H6 : not (eq A1 A2)
H0 : Par A1 A2 B1 B2
H : not (Col P A1 A2)
A1,A2,B1,B2,C1,C2,P : Tpoint
HTE : tarski_s_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Col C1 B1 B2) (Col C2 B1 B2)
+++++
assert (~ Col A1 B1 B2) by (spliter; auto).
-----
Lemma tarski_s_euclid_implies_playfair : tarski_s_parallel_postulate -> playfair_s_postulate.
Proof.
assert (HAux: tarski_s_parallel_postulate -> forall A1 A2 B1 B2 C1 C2 P, ~ Col P A1 A2 -> Par A1 A2 B1 B2 -> Col P B1 B2 -> Par A1 A2 C1 C2 -> Col P C1 C2 -> Col C1 B1 B2 /\\ Col C2 B1 B2).
intros HTE; intros.
apply par_distincts in H0.
apply par_distincts in H2.
spliter.
assert(HPar1 : Par_strict A1 A2 B1 B2) by (apply (par_not_col_strict _ _ _ _ P); Col; intro; apply H; Col).
assert(HPar2 : Par_strict A1 A2 C1 C2) by (apply (par_not_col_strict _ _ _ _ P); Col; intro; apply H; Col).
elim (line_dec B1 B2 C1 C2); intro HLine.
assumption.
assert (HLineNew : ~ Col C1 B1 B2 \\/ ~ Col C2 B1 B2) by (induction (col_dec C1 B1 B2); induction (col_dec C2 B1 B2);tauto).
clear HLine; rename HLineNew into HLine.
assert(HC' : exists C', Col C1 C2 C' /\\ TS B1 B2 A1 C').
ex_and HC' C'.
unfold TS in H9.
assert (~ Col A1 B1 B2) by (spliter; auto).

*****
H10 : not (Col A1 B1 B2)
H9 : and (not (Col A1 B1 B2))\n (and (not (Col C' B1 B2))\n (ex (fun T : Tpoint => and (Col T B1 B2) (Bet A1 T C'))))
H8 : Col C1 C2 C'
C' : Tpoint
HLine : or (not (Col C1 B1 B2)) (not (Col C2 B1 B2))
HPar2 : Par_strict A1 A2 C1 C2
HPar1 : Par_strict A1 A2 B1 B2
H3 : Col P C1 C2
H5 : not (eq C1 C2)
H4 : not (eq A1 A2)
H2 : Par A1 A2 C1 C2
H1 : Col P B1 B2
H7 : not (eq B1 B2)
H6 : not (eq A1 A2)
H0 : Par A1 A2 B1 B2
H : not (Col P A1 A2)
A1,A2,B1,B2,C1,C2,P : Tpoint
HTE : tarski_s_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Col C1 B1 B2) (Col C2 B1 B2)
+++++
spliter.
-----
Lemma tarski_s_euclid_implies_playfair : tarski_s_parallel_postulate -> playfair_s_postulate.
Proof.
assert (HAux: tarski_s_parallel_postulate -> forall A1 A2 B1 B2 C1 C2 P, ~ Col P A1 A2 -> Par A1 A2 B1 B2 -> Col P B1 B2 -> Par A1 A2 C1 C2 -> Col P C1 C2 -> Col C1 B1 B2 /\\ Col C2 B1 B2).
intros HTE; intros.
apply par_distincts in H0.
apply par_distincts in H2.
spliter.
assert(HPar1 : Par_strict A1 A2 B1 B2) by (apply (par_not_col_strict _ _ _ _ P); Col; intro; apply H; Col).
assert(HPar2 : Par_strict A1 A2 C1 C2) by (apply (par_not_col_strict _ _ _ _ P); Col; intro; apply H; Col).
elim (line_dec B1 B2 C1 C2); intro HLine.
assumption.
assert (HLineNew : ~ Col C1 B1 B2 \\/ ~ Col C2 B1 B2) by (induction (col_dec C1 B1 B2); induction (col_dec C2 B1 B2);tauto).
clear HLine; rename HLineNew into HLine.
assert(HC' : exists C', Col C1 C2 C' /\\ TS B1 B2 A1 C').
ex_and HC' C'.
unfold TS in H9.
assert (~ Col A1 B1 B2) by (spliter; auto).
spliter.

*****
H10 : not (Col A1 B1 B2)
H12 : ex (fun T : Tpoint => and (Col T B1 B2) (Bet A1 T C'))
H11 : not (Col C' B1 B2)
H9 : not (Col A1 B1 B2)
H8 : Col C1 C2 C'
C' : Tpoint
HLine : or (not (Col C1 B1 B2)) (not (Col C2 B1 B2))
HPar2 : Par_strict A1 A2 C1 C2
HPar1 : Par_strict A1 A2 B1 B2
H3 : Col P C1 C2
H5 : not (eq C1 C2)
H4 : not (eq A1 A2)
H2 : Par A1 A2 C1 C2
H1 : Col P B1 B2
H7 : not (eq B1 B2)
H6 : not (eq A1 A2)
H0 : Par A1 A2 B1 B2
H : not (Col P A1 A2)
A1,A2,B1,B2,C1,C2,P : Tpoint
HTE : tarski_s_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Col C1 B1 B2) (Col C2 B1 B2)
+++++
ex_and H12 B.
-----
Lemma tarski_s_euclid_implies_playfair : tarski_s_parallel_postulate -> playfair_s_postulate.
Proof.
assert (HAux: tarski_s_parallel_postulate -> forall A1 A2 B1 B2 C1 C2 P, ~ Col P A1 A2 -> Par A1 A2 B1 B2 -> Col P B1 B2 -> Par A1 A2 C1 C2 -> Col P C1 C2 -> Col C1 B1 B2 /\\ Col C2 B1 B2).
intros HTE; intros.
apply par_distincts in H0.
apply par_distincts in H2.
spliter.
assert(HPar1 : Par_strict A1 A2 B1 B2) by (apply (par_not_col_strict _ _ _ _ P); Col; intro; apply H; Col).
assert(HPar2 : Par_strict A1 A2 C1 C2) by (apply (par_not_col_strict _ _ _ _ P); Col; intro; apply H; Col).
elim (line_dec B1 B2 C1 C2); intro HLine.
assumption.
assert (HLineNew : ~ Col C1 B1 B2 \\/ ~ Col C2 B1 B2) by (induction (col_dec C1 B1 B2); induction (col_dec C2 B1 B2);tauto).
clear HLine; rename HLineNew into HLine.
assert(HC' : exists C', Col C1 C2 C' /\\ TS B1 B2 A1 C').
ex_and HC' C'.
unfold TS in H9.
assert (~ Col A1 B1 B2) by (spliter; auto).
spliter.
ex_and H12 B.

*****
H13 : Bet A1 B C'
H12 : Col B B1 B2
B : Tpoint
H10 : not (Col A1 B1 B2)
H11 : not (Col C' B1 B2)
H9 : not (Col A1 B1 B2)
H8 : Col C1 C2 C'
C' : Tpoint
HLine : or (not (Col C1 B1 B2)) (not (Col C2 B1 B2))
HPar2 : Par_strict A1 A2 C1 C2
HPar1 : Par_strict A1 A2 B1 B2
H3 : Col P C1 C2
H5 : not (eq C1 C2)
H4 : not (eq A1 A2)
H2 : Par A1 A2 C1 C2
H1 : Col P B1 B2
H7 : not (eq B1 B2)
H6 : not (eq A1 A2)
H0 : Par A1 A2 B1 B2
H : not (Col P A1 A2)
A1,A2,B1,B2,C1,C2,P : Tpoint
HTE : tarski_s_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Col C1 B1 B2) (Col C2 B1 B2)
+++++
double C' P C.
-----
Lemma tarski_s_euclid_implies_playfair : tarski_s_parallel_postulate -> playfair_s_postulate.
Proof.
assert (HAux: tarski_s_parallel_postulate -> forall A1 A2 B1 B2 C1 C2 P, ~ Col P A1 A2 -> Par A1 A2 B1 B2 -> Col P B1 B2 -> Par A1 A2 C1 C2 -> Col P C1 C2 -> Col C1 B1 B2 /\\ Col C2 B1 B2).
intros HTE; intros.
apply par_distincts in H0.
apply par_distincts in H2.
spliter.
assert(HPar1 : Par_strict A1 A2 B1 B2) by (apply (par_not_col_strict _ _ _ _ P); Col; intro; apply H; Col).
assert(HPar2 : Par_strict A1 A2 C1 C2) by (apply (par_not_col_strict _ _ _ _ P); Col; intro; apply H; Col).
elim (line_dec B1 B2 C1 C2); intro HLine.
assumption.
assert (HLineNew : ~ Col C1 B1 B2 \\/ ~ Col C2 B1 B2) by (induction (col_dec C1 B1 B2); induction (col_dec C2 B1 B2);tauto).
clear HLine; rename HLineNew into HLine.
assert(HC' : exists C', Col C1 C2 C' /\\ TS B1 B2 A1 C').
ex_and HC' C'.
unfold TS in H9.
assert (~ Col A1 B1 B2) by (spliter; auto).
spliter.
ex_and H12 B.
double C' P C.

*****
H14 : Midpoint P C' C
C : Tpoint
H13 : Bet A1 B C'
H12 : Col B B1 B2
B : Tpoint
H10 : not (Col A1 B1 B2)
H11 : not (Col C' B1 B2)
H9 : not (Col A1 B1 B2)
H8 : Col C1 C2 C'
C' : Tpoint
HLine : or (not (Col C1 B1 B2)) (not (Col C2 B1 B2))
HPar2 : Par_strict A1 A2 C1 C2
HPar1 : Par_strict A1 A2 B1 B2
H3 : Col P C1 C2
H5 : not (eq C1 C2)
H4 : not (eq A1 A2)
H2 : Par A1 A2 C1 C2
H1 : Col P B1 B2
H7 : not (eq B1 B2)
H6 : not (eq A1 A2)
H0 : Par A1 A2 B1 B2
H : not (Col P A1 A2)
A1,A2,B1,B2,C1,C2,P : Tpoint
HTE : tarski_s_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Col C1 B1 B2) (Col C2 B1 B2)
+++++
unfold Midpoint in H14.
-----
Lemma tarski_s_euclid_implies_playfair : tarski_s_parallel_postulate -> playfair_s_postulate.
Proof.
assert (HAux: tarski_s_parallel_postulate -> forall A1 A2 B1 B2 C1 C2 P, ~ Col P A1 A2 -> Par A1 A2 B1 B2 -> Col P B1 B2 -> Par A1 A2 C1 C2 -> Col P C1 C2 -> Col C1 B1 B2 /\\ Col C2 B1 B2).
intros HTE; intros.
apply par_distincts in H0.
apply par_distincts in H2.
spliter.
assert(HPar1 : Par_strict A1 A2 B1 B2) by (apply (par_not_col_strict _ _ _ _ P); Col; intro; apply H; Col).
assert(HPar2 : Par_strict A1 A2 C1 C2) by (apply (par_not_col_strict _ _ _ _ P); Col; intro; apply H; Col).
elim (line_dec B1 B2 C1 C2); intro HLine.
assumption.
assert (HLineNew : ~ Col C1 B1 B2 \\/ ~ Col C2 B1 B2) by (induction (col_dec C1 B1 B2); induction (col_dec C2 B1 B2);tauto).
clear HLine; rename HLineNew into HLine.
assert(HC' : exists C', Col C1 C2 C' /\\ TS B1 B2 A1 C').
ex_and HC' C'.
unfold TS in H9.
assert (~ Col A1 B1 B2) by (spliter; auto).
spliter.
ex_and H12 B.
double C' P C.
unfold Midpoint in H14.

*****
H14 : and (Bet C' P C) (Cong C' P P C)
C : Tpoint
H13 : Bet A1 B C'
H12 : Col B B1 B2
B : Tpoint
H10 : not (Col A1 B1 B2)
H11 : not (Col C' B1 B2)
H9 : not (Col A1 B1 B2)
H8 : Col C1 C2 C'
C' : Tpoint
HLine : or (not (Col C1 B1 B2)) (not (Col C2 B1 B2))
HPar2 : Par_strict A1 A2 C1 C2
HPar1 : Par_strict A1 A2 B1 B2
H3 : Col P C1 C2
H5 : not (eq C1 C2)
H4 : not (eq A1 A2)
H2 : Par A1 A2 C1 C2
H1 : Col P B1 B2
H7 : not (eq B1 B2)
H6 : not (eq A1 A2)
H0 : Par A1 A2 B1 B2
H : not (Col P A1 A2)
A1,A2,B1,B2,C1,C2,P : Tpoint
HTE : tarski_s_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Col C1 B1 B2) (Col C2 B1 B2)
+++++
spliter.
-----
Lemma tarski_s_euclid_implies_playfair : tarski_s_parallel_postulate -> playfair_s_postulate.
Proof.
assert (HAux: tarski_s_parallel_postulate -> forall A1 A2 B1 B2 C1 C2 P, ~ Col P A1 A2 -> Par A1 A2 B1 B2 -> Col P B1 B2 -> Par A1 A2 C1 C2 -> Col P C1 C2 -> Col C1 B1 B2 /\\ Col C2 B1 B2).
intros HTE; intros.
apply par_distincts in H0.
apply par_distincts in H2.
spliter.
assert(HPar1 : Par_strict A1 A2 B1 B2) by (apply (par_not_col_strict _ _ _ _ P); Col; intro; apply H; Col).
assert(HPar2 : Par_strict A1 A2 C1 C2) by (apply (par_not_col_strict _ _ _ _ P); Col; intro; apply H; Col).
elim (line_dec B1 B2 C1 C2); intro HLine.
assumption.
assert (HLineNew : ~ Col C1 B1 B2 \\/ ~ Col C2 B1 B2) by (induction (col_dec C1 B1 B2); induction (col_dec C2 B1 B2);tauto).
clear HLine; rename HLineNew into HLine.
assert(HC' : exists C', Col C1 C2 C' /\\ TS B1 B2 A1 C').
ex_and HC' C'.
unfold TS in H9.
assert (~ Col A1 B1 B2) by (spliter; auto).
spliter.
ex_and H12 B.
double C' P C.
unfold Midpoint in H14.
spliter.

*****
H15 : Cong C' P P C
H14 : Bet C' P C
C : Tpoint
H13 : Bet A1 B C'
H12 : Col B B1 B2
B : Tpoint
H10 : not (Col A1 B1 B2)
H11 : not (Col C' B1 B2)
H9 : not (Col A1 B1 B2)
H8 : Col C1 C2 C'
C' : Tpoint
HLine : or (not (Col C1 B1 B2)) (not (Col C2 B1 B2))
HPar2 : Par_strict A1 A2 C1 C2
HPar1 : Par_strict A1 A2 B1 B2
H3 : Col P C1 C2
H5 : not (eq C1 C2)
H4 : not (eq A1 A2)
H2 : Par A1 A2 C1 C2
H1 : Col P B1 B2
H7 : not (eq B1 B2)
H6 : not (eq A1 A2)
H0 : Par A1 A2 B1 B2
H : not (Col P A1 A2)
A1,A2,B1,B2,C1,C2,P : Tpoint
HTE : tarski_s_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Col C1 B1 B2) (Col C2 B1 B2)
+++++
assert(HD : exists D, Bet B D C /\ Bet P D A1) by (apply inner_pasch with C'; Between).
-----
Lemma tarski_s_euclid_implies_playfair : tarski_s_parallel_postulate -> playfair_s_postulate.
Proof.
assert (HAux: tarski_s_parallel_postulate -> forall A1 A2 B1 B2 C1 C2 P, ~ Col P A1 A2 -> Par A1 A2 B1 B2 -> Col P B1 B2 -> Par A1 A2 C1 C2 -> Col P C1 C2 -> Col C1 B1 B2 /\\ Col C2 B1 B2).
intros HTE; intros.
apply par_distincts in H0.
apply par_distincts in H2.
spliter.
assert(HPar1 : Par_strict A1 A2 B1 B2) by (apply (par_not_col_strict _ _ _ _ P); Col; intro; apply H; Col).
assert(HPar2 : Par_strict A1 A2 C1 C2) by (apply (par_not_col_strict _ _ _ _ P); Col; intro; apply H; Col).
elim (line_dec B1 B2 C1 C2); intro HLine.
assumption.
assert (HLineNew : ~ Col C1 B1 B2 \\/ ~ Col C2 B1 B2) by (induction (col_dec C1 B1 B2); induction (col_dec C2 B1 B2);tauto).
clear HLine; rename HLineNew into HLine.
assert(HC' : exists C', Col C1 C2 C' /\\ TS B1 B2 A1 C').
ex_and HC' C'.
unfold TS in H9.
assert (~ Col A1 B1 B2) by (spliter; auto).
spliter.
ex_and H12 B.
double C' P C.
unfold Midpoint in H14.
spliter.
assert(HD : exists D, Bet B D C /\\ Bet P D A1) by (apply inner_pasch with C'; Between).

*****
HD : ex (fun D : Tpoint => and (Bet B D C) (Bet P D A1))
H15 : Cong C' P P C
H14 : Bet C' P C
C : Tpoint
H13 : Bet A1 B C'
H12 : Col B B1 B2
B : Tpoint
H10 : not (Col A1 B1 B2)
H11 : not (Col C' B1 B2)
H9 : not (Col A1 B1 B2)
H8 : Col C1 C2 C'
C' : Tpoint
HLine : or (not (Col C1 B1 B2)) (not (Col C2 B1 B2))
HPar2 : Par_strict A1 A2 C1 C2
HPar1 : Par_strict A1 A2 B1 B2
H3 : Col P C1 C2
H5 : not (eq C1 C2)
H4 : not (eq A1 A2)
H2 : Par A1 A2 C1 C2
H1 : Col P B1 B2
H7 : not (eq B1 B2)
H6 : not (eq A1 A2)
H0 : Par A1 A2 B1 B2
H : not (Col P A1 A2)
A1,A2,B1,B2,C1,C2,P : Tpoint
HTE : tarski_s_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Col C1 B1 B2) (Col C2 B1 B2)
+++++
ex_and HD D.
-----
Lemma tarski_s_euclid_implies_playfair : tarski_s_parallel_postulate -> playfair_s_postulate.
Proof.
assert (HAux: tarski_s_parallel_postulate -> forall A1 A2 B1 B2 C1 C2 P, ~ Col P A1 A2 -> Par A1 A2 B1 B2 -> Col P B1 B2 -> Par A1 A2 C1 C2 -> Col P C1 C2 -> Col C1 B1 B2 /\\ Col C2 B1 B2).
intros HTE; intros.
apply par_distincts in H0.
apply par_distincts in H2.
spliter.
assert(HPar1 : Par_strict A1 A2 B1 B2) by (apply (par_not_col_strict _ _ _ _ P); Col; intro; apply H; Col).
assert(HPar2 : Par_strict A1 A2 C1 C2) by (apply (par_not_col_strict _ _ _ _ P); Col; intro; apply H; Col).
elim (line_dec B1 B2 C1 C2); intro HLine.
assumption.
assert (HLineNew : ~ Col C1 B1 B2 \\/ ~ Col C2 B1 B2) by (induction (col_dec C1 B1 B2); induction (col_dec C2 B1 B2);tauto).
clear HLine; rename HLineNew into HLine.
assert(HC' : exists C', Col C1 C2 C' /\\ TS B1 B2 A1 C').
ex_and HC' C'.
unfold TS in H9.
assert (~ Col A1 B1 B2) by (spliter; auto).
spliter.
ex_and H12 B.
double C' P C.
unfold Midpoint in H14.
spliter.
assert(HD : exists D, Bet B D C /\\ Bet P D A1) by (apply inner_pasch with C'; Between).
ex_and HD D.

*****
H17 : Bet P D A1
H16 : Bet B D C
D : Tpoint
H15 : Cong C' P P C
H14 : Bet C' P C
C : Tpoint
H13 : Bet A1 B C'
H12 : Col B B1 B2
B : Tpoint
H10 : not (Col A1 B1 B2)
H11 : not (Col C' B1 B2)
H9 : not (Col A1 B1 B2)
H8 : Col C1 C2 C'
C' : Tpoint
HLine : or (not (Col C1 B1 B2)) (not (Col C2 B1 B2))
HPar2 : Par_strict A1 A2 C1 C2
HPar1 : Par_strict A1 A2 B1 B2
H3 : Col P C1 C2
H5 : not (eq C1 C2)
H4 : not (eq A1 A2)
H2 : Par A1 A2 C1 C2
H1 : Col P B1 B2
H7 : not (eq B1 B2)
H6 : not (eq A1 A2)
H0 : Par A1 A2 B1 B2
H : not (Col P A1 A2)
A1,A2,B1,B2,C1,C2,P : Tpoint
HTE : tarski_s_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Col C1 B1 B2) (Col C2 B1 B2)
+++++
assert(C' <> P) by (intro; subst C'; contradiction).
-----
Lemma tarski_s_euclid_implies_playfair : tarski_s_parallel_postulate -> playfair_s_postulate.
Proof.
assert (HAux: tarski_s_parallel_postulate -> forall A1 A2 B1 B2 C1 C2 P, ~ Col P A1 A2 -> Par A1 A2 B1 B2 -> Col P B1 B2 -> Par A1 A2 C1 C2 -> Col P C1 C2 -> Col C1 B1 B2 /\\ Col C2 B1 B2).
intros HTE; intros.
apply par_distincts in H0.
apply par_distincts in H2.
spliter.
assert(HPar1 : Par_strict A1 A2 B1 B2) by (apply (par_not_col_strict _ _ _ _ P); Col; intro; apply H; Col).
assert(HPar2 : Par_strict A1 A2 C1 C2) by (apply (par_not_col_strict _ _ _ _ P); Col; intro; apply H; Col).
elim (line_dec B1 B2 C1 C2); intro HLine.
assumption.
assert (HLineNew : ~ Col C1 B1 B2 \\/ ~ Col C2 B1 B2) by (induction (col_dec C1 B1 B2); induction (col_dec C2 B1 B2);tauto).
clear HLine; rename HLineNew into HLine.
assert(HC' : exists C', Col C1 C2 C' /\\ TS B1 B2 A1 C').
ex_and HC' C'.
unfold TS in H9.
assert (~ Col A1 B1 B2) by (spliter; auto).
spliter.
ex_and H12 B.
double C' P C.
unfold Midpoint in H14.
spliter.
assert(HD : exists D, Bet B D C /\\ Bet P D A1) by (apply inner_pasch with C'; Between).
ex_and HD D.
assert(C' <> P) by (intro; subst C'; contradiction).

*****
H18 : not (eq C' P)
H17 : Bet P D A1
H16 : Bet B D C
D : Tpoint
H15 : Cong C' P P C
H14 : Bet C' P C
C : Tpoint
H13 : Bet A1 B C'
H12 : Col B B1 B2
B : Tpoint
H10 : not (Col A1 B1 B2)
H11 : not (Col C' B1 B2)
H9 : not (Col A1 B1 B2)
H8 : Col C1 C2 C'
C' : Tpoint
HLine : or (not (Col C1 B1 B2)) (not (Col C2 B1 B2))
HPar2 : Par_strict A1 A2 C1 C2
HPar1 : Par_strict A1 A2 B1 B2
H3 : Col P C1 C2
H5 : not (eq C1 C2)
H4 : not (eq A1 A2)
H2 : Par A1 A2 C1 C2
H1 : Col P B1 B2
H7 : not (eq B1 B2)
H6 : not (eq A1 A2)
H0 : Par A1 A2 B1 B2
H : not (Col P A1 A2)
A1,A2,B1,B2,C1,C2,P : Tpoint
HTE : tarski_s_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Col C1 B1 B2) (Col C2 B1 B2)
+++++
assert (Par A1 A2 C' P) by (apply par_col2_par with C1 C2; Col).
-----
Lemma tarski_s_euclid_implies_playfair : tarski_s_parallel_postulate -> playfair_s_postulate.
Proof.
assert (HAux: tarski_s_parallel_postulate -> forall A1 A2 B1 B2 C1 C2 P, ~ Col P A1 A2 -> Par A1 A2 B1 B2 -> Col P B1 B2 -> Par A1 A2 C1 C2 -> Col P C1 C2 -> Col C1 B1 B2 /\\ Col C2 B1 B2).
intros HTE; intros.
apply par_distincts in H0.
apply par_distincts in H2.
spliter.
assert(HPar1 : Par_strict A1 A2 B1 B2) by (apply (par_not_col_strict _ _ _ _ P); Col; intro; apply H; Col).
assert(HPar2 : Par_strict A1 A2 C1 C2) by (apply (par_not_col_strict _ _ _ _ P); Col; intro; apply H; Col).
elim (line_dec B1 B2 C1 C2); intro HLine.
assumption.
assert (HLineNew : ~ Col C1 B1 B2 \\/ ~ Col C2 B1 B2) by (induction (col_dec C1 B1 B2); induction (col_dec C2 B1 B2);tauto).
clear HLine; rename HLineNew into HLine.
assert(HC' : exists C', Col C1 C2 C' /\\ TS B1 B2 A1 C').
ex_and HC' C'.
unfold TS in H9.
assert (~ Col A1 B1 B2) by (spliter; auto).
spliter.
ex_and H12 B.
double C' P C.
unfold Midpoint in H14.
spliter.
assert(HD : exists D, Bet B D C /\\ Bet P D A1) by (apply inner_pasch with C'; Between).
ex_and HD D.
assert(C' <> P) by (intro; subst C'; contradiction).
assert (Par A1 A2 C' P) by (apply par_col2_par with C1 C2; Col).

*****
H19 : Par A1 A2 C' P
H18 : not (eq C' P)
H17 : Bet P D A1
H16 : Bet B D C
D : Tpoint
H15 : Cong C' P P C
H14 : Bet C' P C
C : Tpoint
H13 : Bet A1 B C'
H12 : Col B B1 B2
B : Tpoint
H10 : not (Col A1 B1 B2)
H11 : not (Col C' B1 B2)
H9 : not (Col A1 B1 B2)
H8 : Col C1 C2 C'
C' : Tpoint
HLine : or (not (Col C1 B1 B2)) (not (Col C2 B1 B2))
HPar2 : Par_strict A1 A2 C1 C2
HPar1 : Par_strict A1 A2 B1 B2
H3 : Col P C1 C2
H5 : not (eq C1 C2)
H4 : not (eq A1 A2)
H2 : Par A1 A2 C1 C2
H1 : Col P B1 B2
H7 : not (eq B1 B2)
H6 : not (eq A1 A2)
H0 : Par A1 A2 B1 B2
H : not (Col P A1 A2)
A1,A2,B1,B2,C1,C2,P : Tpoint
HTE : tarski_s_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Col C1 B1 B2) (Col C2 B1 B2)
+++++
assert(HPar3 : Par_strict A1 A2 C' P) by (apply (par_not_col_strict _ _ _ _ P); Col).
-----
Lemma tarski_s_euclid_implies_playfair : tarski_s_parallel_postulate -> playfair_s_postulate.
Proof.
assert (HAux: tarski_s_parallel_postulate -> forall A1 A2 B1 B2 C1 C2 P, ~ Col P A1 A2 -> Par A1 A2 B1 B2 -> Col P B1 B2 -> Par A1 A2 C1 C2 -> Col P C1 C2 -> Col C1 B1 B2 /\\ Col C2 B1 B2).
intros HTE; intros.
apply par_distincts in H0.
apply par_distincts in H2.
spliter.
assert(HPar1 : Par_strict A1 A2 B1 B2) by (apply (par_not_col_strict _ _ _ _ P); Col; intro; apply H; Col).
assert(HPar2 : Par_strict A1 A2 C1 C2) by (apply (par_not_col_strict _ _ _ _ P); Col; intro; apply H; Col).
elim (line_dec B1 B2 C1 C2); intro HLine.
assumption.
assert (HLineNew : ~ Col C1 B1 B2 \\/ ~ Col C2 B1 B2) by (induction (col_dec C1 B1 B2); induction (col_dec C2 B1 B2);tauto).
clear HLine; rename HLineNew into HLine.
assert(HC' : exists C', Col C1 C2 C' /\\ TS B1 B2 A1 C').
ex_and HC' C'.
unfold TS in H9.
assert (~ Col A1 B1 B2) by (spliter; auto).
spliter.
ex_and H12 B.
double C' P C.
unfold Midpoint in H14.
spliter.
assert(HD : exists D, Bet B D C /\\ Bet P D A1) by (apply inner_pasch with C'; Between).
ex_and HD D.
assert(C' <> P) by (intro; subst C'; contradiction).
assert (Par A1 A2 C' P) by (apply par_col2_par with C1 C2; Col).
assert(HPar3 : Par_strict A1 A2 C' P) by (apply (par_not_col_strict _ _ _ _ P); Col).

*****
HPar3 : Par_strict A1 A2 C' P
H19 : Par A1 A2 C' P
H18 : not (eq C' P)
H17 : Bet P D A1
H16 : Bet B D C
D : Tpoint
H15 : Cong C' P P C
H14 : Bet C' P C
C : Tpoint
H13 : Bet A1 B C'
H12 : Col B B1 B2
B : Tpoint
H10 : not (Col A1 B1 B2)
H11 : not (Col C' B1 B2)
H9 : not (Col A1 B1 B2)
H8 : Col C1 C2 C'
C' : Tpoint
HLine : or (not (Col C1 B1 B2)) (not (Col C2 B1 B2))
HPar2 : Par_strict A1 A2 C1 C2
HPar1 : Par_strict A1 A2 B1 B2
H3 : Col P C1 C2
H5 : not (eq C1 C2)
H4 : not (eq A1 A2)
H2 : Par A1 A2 C1 C2
H1 : Col P B1 B2
H7 : not (eq B1 B2)
H6 : not (eq A1 A2)
H0 : Par A1 A2 B1 B2
H : not (Col P A1 A2)
A1,A2,B1,B2,C1,C2,P : Tpoint
HTE : tarski_s_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Col C1 B1 B2) (Col C2 B1 B2)
+++++
assert(B <> P).
-----
Lemma tarski_s_euclid_implies_playfair : tarski_s_parallel_postulate -> playfair_s_postulate.
Proof.
assert (HAux: tarski_s_parallel_postulate -> forall A1 A2 B1 B2 C1 C2 P, ~ Col P A1 A2 -> Par A1 A2 B1 B2 -> Col P B1 B2 -> Par A1 A2 C1 C2 -> Col P C1 C2 -> Col C1 B1 B2 /\\ Col C2 B1 B2).
intros HTE; intros.
apply par_distincts in H0.
apply par_distincts in H2.
spliter.
assert(HPar1 : Par_strict A1 A2 B1 B2) by (apply (par_not_col_strict _ _ _ _ P); Col; intro; apply H; Col).
assert(HPar2 : Par_strict A1 A2 C1 C2) by (apply (par_not_col_strict _ _ _ _ P); Col; intro; apply H; Col).
elim (line_dec B1 B2 C1 C2); intro HLine.
assumption.
assert (HLineNew : ~ Col C1 B1 B2 \\/ ~ Col C2 B1 B2) by (induction (col_dec C1 B1 B2); induction (col_dec C2 B1 B2);tauto).
clear HLine; rename HLineNew into HLine.
assert(HC' : exists C', Col C1 C2 C' /\\ TS B1 B2 A1 C').
ex_and HC' C'.
unfold TS in H9.
assert (~ Col A1 B1 B2) by (spliter; auto).
spliter.
ex_and H12 B.
double C' P C.
unfold Midpoint in H14.
spliter.
assert(HD : exists D, Bet B D C /\\ Bet P D A1) by (apply inner_pasch with C'; Between).
ex_and HD D.
assert(C' <> P) by (intro; subst C'; contradiction).
assert (Par A1 A2 C' P) by (apply par_col2_par with C1 C2; Col).
assert(HPar3 : Par_strict A1 A2 C' P) by (apply (par_not_col_strict _ _ _ _ P); Col).
assert(B <> P).

*****
HPar3 : Par_strict A1 A2 C' P
H19 : Par A1 A2 C' P
H18 : not (eq C' P)
H17 : Bet P D A1
H16 : Bet B D C
D : Tpoint
H15 : Cong C' P P C
H14 : Bet C' P C
C : Tpoint
H13 : Bet A1 B C'
H12 : Col B B1 B2
B : Tpoint
H10 : not (Col A1 B1 B2)
H11 : not (Col C' B1 B2)
H9 : not (Col A1 B1 B2)
H8 : Col C1 C2 C'
C' : Tpoint
HLine : or (not (Col C1 B1 B2)) (not (Col C2 B1 B2))
HPar2 : Par_strict A1 A2 C1 C2
HPar1 : Par_strict A1 A2 B1 B2
H3 : Col P C1 C2
H5 : not (eq C1 C2)
H4 : not (eq A1 A2)
H2 : Par A1 A2 C1 C2
H1 : Col P B1 B2
H7 : not (eq B1 B2)
H6 : not (eq A1 A2)
H0 : Par A1 A2 B1 B2
H : not (Col P A1 A2)
A1,A2,B1,B2,C1,C2,P : Tpoint
HTE : tarski_s_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq B P)
+++++
intro.
-----
Lemma tarski_s_euclid_implies_playfair : tarski_s_parallel_postulate -> playfair_s_postulate.
Proof.
assert (HAux: tarski_s_parallel_postulate -> forall A1 A2 B1 B2 C1 C2 P, ~ Col P A1 A2 -> Par A1 A2 B1 B2 -> Col P B1 B2 -> Par A1 A2 C1 C2 -> Col P C1 C2 -> Col C1 B1 B2 /\\ Col C2 B1 B2).
intros HTE; intros.
apply par_distincts in H0.
apply par_distincts in H2.
spliter.
assert(HPar1 : Par_strict A1 A2 B1 B2) by (apply (par_not_col_strict _ _ _ _ P); Col; intro; apply H; Col).
assert(HPar2 : Par_strict A1 A2 C1 C2) by (apply (par_not_col_strict _ _ _ _ P); Col; intro; apply H; Col).
elim (line_dec B1 B2 C1 C2); intro HLine.
assumption.
assert (HLineNew : ~ Col C1 B1 B2 \\/ ~ Col C2 B1 B2) by (induction (col_dec C1 B1 B2); induction (col_dec C2 B1 B2);tauto).
clear HLine; rename HLineNew into HLine.
assert(HC' : exists C', Col C1 C2 C' /\\ TS B1 B2 A1 C').
ex_and HC' C'.
unfold TS in H9.
assert (~ Col A1 B1 B2) by (spliter; auto).
spliter.
ex_and H12 B.
double C' P C.
unfold Midpoint in H14.
spliter.
assert(HD : exists D, Bet B D C /\\ Bet P D A1) by (apply inner_pasch with C'; Between).
ex_and HD D.
assert(C' <> P) by (intro; subst C'; contradiction).
assert (Par A1 A2 C' P) by (apply par_col2_par with C1 C2; Col).
assert(HPar3 : Par_strict A1 A2 C' P) by (apply (par_not_col_strict _ _ _ _ P); Col).
assert(B <> P).
intro.

*****
H20 : eq B P
HPar3 : Par_strict A1 A2 C' P
H19 : Par A1 A2 C' P
H18 : not (eq C' P)
H17 : Bet P D A1
H16 : Bet B D C
D : Tpoint
H15 : Cong C' P P C
H14 : Bet C' P C
C : Tpoint
H13 : Bet A1 B C'
H12 : Col B B1 B2
B : Tpoint
H10 : not (Col A1 B1 B2)
H11 : not (Col C' B1 B2)
H9 : not (Col A1 B1 B2)
H8 : Col C1 C2 C'
C' : Tpoint
HLine : or (not (Col C1 B1 B2)) (not (Col C2 B1 B2))
HPar2 : Par_strict A1 A2 C1 C2
HPar1 : Par_strict A1 A2 B1 B2
H3 : Col P C1 C2
H5 : not (eq C1 C2)
H4 : not (eq A1 A2)
H2 : Par A1 A2 C1 C2
H1 : Col P B1 B2
H7 : not (eq B1 B2)
H6 : not (eq A1 A2)
H0 : Par A1 A2 B1 B2
H : not (Col P A1 A2)
A1,A2,B1,B2,C1,C2,P : Tpoint
HTE : tarski_s_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
subst B.
-----
Lemma tarski_s_euclid_implies_playfair : tarski_s_parallel_postulate -> playfair_s_postulate.
Proof.
assert (HAux: tarski_s_parallel_postulate -> forall A1 A2 B1 B2 C1 C2 P, ~ Col P A1 A2 -> Par A1 A2 B1 B2 -> Col P B1 B2 -> Par A1 A2 C1 C2 -> Col P C1 C2 -> Col C1 B1 B2 /\\ Col C2 B1 B2).
intros HTE; intros.
apply par_distincts in H0.
apply par_distincts in H2.
spliter.
assert(HPar1 : Par_strict A1 A2 B1 B2) by (apply (par_not_col_strict _ _ _ _ P); Col; intro; apply H; Col).
assert(HPar2 : Par_strict A1 A2 C1 C2) by (apply (par_not_col_strict _ _ _ _ P); Col; intro; apply H; Col).
elim (line_dec B1 B2 C1 C2); intro HLine.
assumption.
assert (HLineNew : ~ Col C1 B1 B2 \\/ ~ Col C2 B1 B2) by (induction (col_dec C1 B1 B2); induction (col_dec C2 B1 B2);tauto).
clear HLine; rename HLineNew into HLine.
assert(HC' : exists C', Col C1 C2 C' /\\ TS B1 B2 A1 C').
ex_and HC' C'.
unfold TS in H9.
assert (~ Col A1 B1 B2) by (spliter; auto).
spliter.
ex_and H12 B.
double C' P C.
unfold Midpoint in H14.
spliter.
assert(HD : exists D, Bet B D C /\\ Bet P D A1) by (apply inner_pasch with C'; Between).
ex_and HD D.
assert(C' <> P) by (intro; subst C'; contradiction).
assert (Par A1 A2 C' P) by (apply par_col2_par with C1 C2; Col).
assert(HPar3 : Par_strict A1 A2 C' P) by (apply (par_not_col_strict _ _ _ _ P); Col).
assert(B <> P).
intro.
subst B.

*****
HPar3 : Par_strict A1 A2 C' P
H19 : Par A1 A2 C' P
H18 : not (eq C' P)
H17 : Bet P D A1
H16 : Bet P D C
D : Tpoint
H15 : Cong C' P P C
H14 : Bet C' P C
C : Tpoint
H12 : Col P B1 B2
H13 : Bet A1 P C'
H10 : not (Col A1 B1 B2)
H11 : not (Col C' B1 B2)
H9 : not (Col A1 B1 B2)
H8 : Col C1 C2 C'
C' : Tpoint
HLine : or (not (Col C1 B1 B2)) (not (Col C2 B1 B2))
HPar2 : Par_strict A1 A2 C1 C2
HPar1 : Par_strict A1 A2 B1 B2
H3 : Col P C1 C2
H5 : not (eq C1 C2)
H4 : not (eq A1 A2)
H2 : Par A1 A2 C1 C2
H1 : Col P B1 B2
H7 : not (eq B1 B2)
H6 : not (eq A1 A2)
H0 : Par A1 A2 B1 B2
H : not (Col P A1 A2)
A1,A2,B1,B2,C1,C2,P : Tpoint
HTE : tarski_s_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
apply (par_not_col _ _ _ _ A1) in HPar3.
-----
Lemma tarski_s_euclid_implies_playfair : tarski_s_parallel_postulate -> playfair_s_postulate.
Proof.
assert (HAux: tarski_s_parallel_postulate -> forall A1 A2 B1 B2 C1 C2 P, ~ Col P A1 A2 -> Par A1 A2 B1 B2 -> Col P B1 B2 -> Par A1 A2 C1 C2 -> Col P C1 C2 -> Col C1 B1 B2 /\\ Col C2 B1 B2).
intros HTE; intros.
apply par_distincts in H0.
apply par_distincts in H2.
spliter.
assert(HPar1 : Par_strict A1 A2 B1 B2) by (apply (par_not_col_strict _ _ _ _ P); Col; intro; apply H; Col).
assert(HPar2 : Par_strict A1 A2 C1 C2) by (apply (par_not_col_strict _ _ _ _ P); Col; intro; apply H; Col).
elim (line_dec B1 B2 C1 C2); intro HLine.
assumption.
assert (HLineNew : ~ Col C1 B1 B2 \\/ ~ Col C2 B1 B2) by (induction (col_dec C1 B1 B2); induction (col_dec C2 B1 B2);tauto).
clear HLine; rename HLineNew into HLine.
assert(HC' : exists C', Col C1 C2 C' /\\ TS B1 B2 A1 C').
ex_and HC' C'.
unfold TS in H9.
assert (~ Col A1 B1 B2) by (spliter; auto).
spliter.
ex_and H12 B.
double C' P C.
unfold Midpoint in H14.
spliter.
assert(HD : exists D, Bet B D C /\\ Bet P D A1) by (apply inner_pasch with C'; Between).
ex_and HD D.
assert(C' <> P) by (intro; subst C'; contradiction).
assert (Par A1 A2 C' P) by (apply par_col2_par with C1 C2; Col).
assert(HPar3 : Par_strict A1 A2 C' P) by (apply (par_not_col_strict _ _ _ _ P); Col).
assert(B <> P).
intro.
subst B.
apply (par_not_col _ _ _ _ A1) in HPar3.

*****
HPar3 : not (Col A1 C' P)
H19 : Par A1 A2 C' P
H18 : not (eq C' P)
H17 : Bet P D A1
H16 : Bet P D C
D : Tpoint
H15 : Cong C' P P C
H14 : Bet C' P C
C : Tpoint
H12 : Col P B1 B2
H13 : Bet A1 P C'
H10 : not (Col A1 B1 B2)
H11 : not (Col C' B1 B2)
H9 : not (Col A1 B1 B2)
H8 : Col C1 C2 C'
C' : Tpoint
HLine : or (not (Col C1 B1 B2)) (not (Col C2 B1 B2))
HPar2 : Par_strict A1 A2 C1 C2
HPar1 : Par_strict A1 A2 B1 B2
H3 : Col P C1 C2
H5 : not (eq C1 C2)
H4 : not (eq A1 A2)
H2 : Par A1 A2 C1 C2
H1 : Col P B1 B2
H7 : not (eq B1 B2)
H6 : not (eq A1 A2)
H0 : Par A1 A2 B1 B2
H : not (Col P A1 A2)
A1,A2,B1,B2,C1,C2,P : Tpoint
HTE : tarski_s_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
apply HPar3; Col.
-----
Lemma tarski_s_euclid_implies_playfair : tarski_s_parallel_postulate -> playfair_s_postulate.
Proof.
assert (HAux: tarski_s_parallel_postulate -> forall A1 A2 B1 B2 C1 C2 P, ~ Col P A1 A2 -> Par A1 A2 B1 B2 -> Col P B1 B2 -> Par A1 A2 C1 C2 -> Col P C1 C2 -> Col C1 B1 B2 /\\ Col C2 B1 B2).
intros HTE; intros.
apply par_distincts in H0.
apply par_distincts in H2.
spliter.
assert(HPar1 : Par_strict A1 A2 B1 B2) by (apply (par_not_col_strict _ _ _ _ P); Col; intro; apply H; Col).
assert(HPar2 : Par_strict A1 A2 C1 C2) by (apply (par_not_col_strict _ _ _ _ P); Col; intro; apply H; Col).
elim (line_dec B1 B2 C1 C2); intro HLine.
assumption.
assert (HLineNew : ~ Col C1 B1 B2 \\/ ~ Col C2 B1 B2) by (induction (col_dec C1 B1 B2); induction (col_dec C2 B1 B2);tauto).
clear HLine; rename HLineNew into HLine.
assert(HC' : exists C', Col C1 C2 C' /\\ TS B1 B2 A1 C').
ex_and HC' C'.
unfold TS in H9.
assert (~ Col A1 B1 B2) by (spliter; auto).
spliter.
ex_and H12 B.
double C' P C.
unfold Midpoint in H14.
spliter.
assert(HD : exists D, Bet B D C /\\ Bet P D A1) by (apply inner_pasch with C'; Between).
ex_and HD D.
assert(C' <> P) by (intro; subst C'; contradiction).
assert (Par A1 A2 C' P) by (apply par_col2_par with C1 C2; Col).
assert(HPar3 : Par_strict A1 A2 C' P) by (apply (par_not_col_strict _ _ _ _ P); Col).
assert(B <> P).
intro.
subst B.
apply (par_not_col _ _ _ _ A1) in HPar3.
apply HPar3; Col.

*****
HPar3 : Par_strict A1 A2 C' P
H19 : Par A1 A2 C' P
H18 : not (eq C' P)
H17 : Bet P D A1
H16 : Bet P D C
D : Tpoint
H15 : Cong C' P P C
H14 : Bet C' P C
C : Tpoint
H12 : Col P B1 B2
H13 : Bet A1 P C'
H10 : not (Col A1 B1 B2)
H11 : not (Col C' B1 B2)
H9 : not (Col A1 B1 B2)
H8 : Col C1 C2 C'
C' : Tpoint
HLine : or (not (Col C1 B1 B2)) (not (Col C2 B1 B2))
HPar2 : Par_strict A1 A2 C1 C2
HPar1 : Par_strict A1 A2 B1 B2
H3 : Col P C1 C2
H5 : not (eq C1 C2)
H4 : not (eq A1 A2)
H2 : Par A1 A2 C1 C2
H1 : Col P B1 B2
H7 : not (eq B1 B2)
H6 : not (eq A1 A2)
H0 : Par A1 A2 B1 B2
H : not (Col P A1 A2)
A1,A2,B1,B2,C1,C2,P : Tpoint
HTE : tarski_s_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col A1 A1 A2
+++++
Col.
-----
Lemma tarski_s_euclid_implies_playfair : tarski_s_parallel_postulate -> playfair_s_postulate.
Proof.
assert (HAux: tarski_s_parallel_postulate -> forall A1 A2 B1 B2 C1 C2 P, ~ Col P A1 A2 -> Par A1 A2 B1 B2 -> Col P B1 B2 -> Par A1 A2 C1 C2 -> Col P C1 C2 -> Col C1 B1 B2 /\\ Col C2 B1 B2).
intros HTE; intros.
apply par_distincts in H0.
apply par_distincts in H2.
spliter.
assert(HPar1 : Par_strict A1 A2 B1 B2) by (apply (par_not_col_strict _ _ _ _ P); Col; intro; apply H; Col).
assert(HPar2 : Par_strict A1 A2 C1 C2) by (apply (par_not_col_strict _ _ _ _ P); Col; intro; apply H; Col).
elim (line_dec B1 B2 C1 C2); intro HLine.
assumption.
assert (HLineNew : ~ Col C1 B1 B2 \\/ ~ Col C2 B1 B2) by (induction (col_dec C1 B1 B2); induction (col_dec C2 B1 B2);tauto).
clear HLine; rename HLineNew into HLine.
assert(HC' : exists C', Col C1 C2 C' /\\ TS B1 B2 A1 C').
ex_and HC' C'.
unfold TS in H9.
assert (~ Col A1 B1 B2) by (spliter; auto).
spliter.
ex_and H12 B.
double C' P C.
unfold Midpoint in H14.
spliter.
assert(HD : exists D, Bet B D C /\\ Bet P D A1) by (apply inner_pasch with C'; Between).
ex_and HD D.
assert(C' <> P) by (intro; subst C'; contradiction).
assert (Par A1 A2 C' P) by (apply par_col2_par with C1 C2; Col).
assert(HPar3 : Par_strict A1 A2 C' P) by (apply (par_not_col_strict _ _ _ _ P); Col).
assert(B <> P).
intro.
subst B.
apply (par_not_col _ _ _ _ A1) in HPar3.
apply HPar3; Col.
Col.

*****
H20 : not (eq B P)
HPar3 : Par_strict A1 A2 C' P
H19 : Par A1 A2 C' P
H18 : not (eq C' P)
H17 : Bet P D A1
H16 : Bet B D C
D : Tpoint
H15 : Cong C' P P C
H14 : Bet C' P C
C : Tpoint
H13 : Bet A1 B C'
H12 : Col B B1 B2
B : Tpoint
H10 : not (Col A1 B1 B2)
H11 : not (Col C' B1 B2)
H9 : not (Col A1 B1 B2)
H8 : Col C1 C2 C'
C' : Tpoint
HLine : or (not (Col C1 B1 B2)) (not (Col C2 B1 B2))
HPar2 : Par_strict A1 A2 C1 C2
HPar1 : Par_strict A1 A2 B1 B2
H3 : Col P C1 C2
H5 : not (eq C1 C2)
H4 : not (eq A1 A2)
H2 : Par A1 A2 C1 C2
H1 : Col P B1 B2
H7 : not (eq B1 B2)
H6 : not (eq A1 A2)
H0 : Par A1 A2 B1 B2
H : not (Col P A1 A2)
A1,A2,B1,B2,C1,C2,P : Tpoint
HTE : tarski_s_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Col C1 B1 B2) (Col C2 B1 B2)
+++++
assert(P <> C).
-----
Lemma tarski_s_euclid_implies_playfair : tarski_s_parallel_postulate -> playfair_s_postulate.
Proof.
assert (HAux: tarski_s_parallel_postulate -> forall A1 A2 B1 B2 C1 C2 P, ~ Col P A1 A2 -> Par A1 A2 B1 B2 -> Col P B1 B2 -> Par A1 A2 C1 C2 -> Col P C1 C2 -> Col C1 B1 B2 /\\ Col C2 B1 B2).
intros HTE; intros.
apply par_distincts in H0.
apply par_distincts in H2.
spliter.
assert(HPar1 : Par_strict A1 A2 B1 B2) by (apply (par_not_col_strict _ _ _ _ P); Col; intro; apply H; Col).
assert(HPar2 : Par_strict A1 A2 C1 C2) by (apply (par_not_col_strict _ _ _ _ P); Col; intro; apply H; Col).
elim (line_dec B1 B2 C1 C2); intro HLine.
assumption.
assert (HLineNew : ~ Col C1 B1 B2 \\/ ~ Col C2 B1 B2) by (induction (col_dec C1 B1 B2); induction (col_dec C2 B1 B2);tauto).
clear HLine; rename HLineNew into HLine.
assert(HC' : exists C', Col C1 C2 C' /\\ TS B1 B2 A1 C').
ex_and HC' C'.
unfold TS in H9.
assert (~ Col A1 B1 B2) by (spliter; auto).
spliter.
ex_and H12 B.
double C' P C.
unfold Midpoint in H14.
spliter.
assert(HD : exists D, Bet B D C /\\ Bet P D A1) by (apply inner_pasch with C'; Between).
ex_and HD D.
assert(C' <> P) by (intro; subst C'; contradiction).
assert (Par A1 A2 C' P) by (apply par_col2_par with C1 C2; Col).
assert(HPar3 : Par_strict A1 A2 C' P) by (apply (par_not_col_strict _ _ _ _ P); Col).
assert(B <> P).
intro.
subst B.
apply (par_not_col _ _ _ _ A1) in HPar3.
apply HPar3; Col.
Col.
assert(P <> C).

*****
H20 : not (eq B P)
HPar3 : Par_strict A1 A2 C' P
H19 : Par A1 A2 C' P
H18 : not (eq C' P)
H17 : Bet P D A1
H16 : Bet B D C
D : Tpoint
H15 : Cong C' P P C
H14 : Bet C' P C
C : Tpoint
H13 : Bet A1 B C'
H12 : Col B B1 B2
B : Tpoint
H10 : not (Col A1 B1 B2)
H11 : not (Col C' B1 B2)
H9 : not (Col A1 B1 B2)
H8 : Col C1 C2 C'
C' : Tpoint
HLine : or (not (Col C1 B1 B2)) (not (Col C2 B1 B2))
HPar2 : Par_strict A1 A2 C1 C2
HPar1 : Par_strict A1 A2 B1 B2
H3 : Col P C1 C2
H5 : not (eq C1 C2)
H4 : not (eq A1 A2)
H2 : Par A1 A2 C1 C2
H1 : Col P B1 B2
H7 : not (eq B1 B2)
H6 : not (eq A1 A2)
H0 : Par A1 A2 B1 B2
H : not (Col P A1 A2)
A1,A2,B1,B2,C1,C2,P : Tpoint
HTE : tarski_s_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq P C)
+++++
intro.
-----
Lemma tarski_s_euclid_implies_playfair : tarski_s_parallel_postulate -> playfair_s_postulate.
Proof.
assert (HAux: tarski_s_parallel_postulate -> forall A1 A2 B1 B2 C1 C2 P, ~ Col P A1 A2 -> Par A1 A2 B1 B2 -> Col P B1 B2 -> Par A1 A2 C1 C2 -> Col P C1 C2 -> Col C1 B1 B2 /\\ Col C2 B1 B2).
intros HTE; intros.
apply par_distincts in H0.
apply par_distincts in H2.
spliter.
assert(HPar1 : Par_strict A1 A2 B1 B2) by (apply (par_not_col_strict _ _ _ _ P); Col; intro; apply H; Col).
assert(HPar2 : Par_strict A1 A2 C1 C2) by (apply (par_not_col_strict _ _ _ _ P); Col; intro; apply H; Col).
elim (line_dec B1 B2 C1 C2); intro HLine.
assumption.
assert (HLineNew : ~ Col C1 B1 B2 \\/ ~ Col C2 B1 B2) by (induction (col_dec C1 B1 B2); induction (col_dec C2 B1 B2);tauto).
clear HLine; rename HLineNew into HLine.
assert(HC' : exists C', Col C1 C2 C' /\\ TS B1 B2 A1 C').
ex_and HC' C'.
unfold TS in H9.
assert (~ Col A1 B1 B2) by (spliter; auto).
spliter.
ex_and H12 B.
double C' P C.
unfold Midpoint in H14.
spliter.
assert(HD : exists D, Bet B D C /\\ Bet P D A1) by (apply inner_pasch with C'; Between).
ex_and HD D.
assert(C' <> P) by (intro; subst C'; contradiction).
assert (Par A1 A2 C' P) by (apply par_col2_par with C1 C2; Col).
assert(HPar3 : Par_strict A1 A2 C' P) by (apply (par_not_col_strict _ _ _ _ P); Col).
assert(B <> P).
intro.
subst B.
apply (par_not_col _ _ _ _ A1) in HPar3.
apply HPar3; Col.
Col.
assert(P <> C).
intro.

*****
H21 : eq P C
H20 : not (eq B P)
HPar3 : Par_strict A1 A2 C' P
H19 : Par A1 A2 C' P
H18 : not (eq C' P)
H17 : Bet P D A1
H16 : Bet B D C
D : Tpoint
H15 : Cong C' P P C
H14 : Bet C' P C
C : Tpoint
H13 : Bet A1 B C'
H12 : Col B B1 B2
B : Tpoint
H10 : not (Col A1 B1 B2)
H11 : not (Col C' B1 B2)
H9 : not (Col A1 B1 B2)
H8 : Col C1 C2 C'
C' : Tpoint
HLine : or (not (Col C1 B1 B2)) (not (Col C2 B1 B2))
HPar2 : Par_strict A1 A2 C1 C2
HPar1 : Par_strict A1 A2 B1 B2
H3 : Col P C1 C2
H5 : not (eq C1 C2)
H4 : not (eq A1 A2)
H2 : Par A1 A2 C1 C2
H1 : Col P B1 B2
H7 : not (eq B1 B2)
H6 : not (eq A1 A2)
H0 : Par A1 A2 B1 B2
H : not (Col P A1 A2)
A1,A2,B1,B2,C1,C2,P : Tpoint
HTE : tarski_s_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
treat_equalities.
-----
Lemma tarski_s_euclid_implies_playfair : tarski_s_parallel_postulate -> playfair_s_postulate.
Proof.
assert (HAux: tarski_s_parallel_postulate -> forall A1 A2 B1 B2 C1 C2 P, ~ Col P A1 A2 -> Par A1 A2 B1 B2 -> Col P B1 B2 -> Par A1 A2 C1 C2 -> Col P C1 C2 -> Col C1 B1 B2 /\\ Col C2 B1 B2).
intros HTE; intros.
apply par_distincts in H0.
apply par_distincts in H2.
spliter.
assert(HPar1 : Par_strict A1 A2 B1 B2) by (apply (par_not_col_strict _ _ _ _ P); Col; intro; apply H; Col).
assert(HPar2 : Par_strict A1 A2 C1 C2) by (apply (par_not_col_strict _ _ _ _ P); Col; intro; apply H; Col).
elim (line_dec B1 B2 C1 C2); intro HLine.
assumption.
assert (HLineNew : ~ Col C1 B1 B2 \\/ ~ Col C2 B1 B2) by (induction (col_dec C1 B1 B2); induction (col_dec C2 B1 B2);tauto).
clear HLine; rename HLineNew into HLine.
assert(HC' : exists C', Col C1 C2 C' /\\ TS B1 B2 A1 C').
ex_and HC' C'.
unfold TS in H9.
assert (~ Col A1 B1 B2) by (spliter; auto).
spliter.
ex_and H12 B.
double C' P C.
unfold Midpoint in H14.
spliter.
assert(HD : exists D, Bet B D C /\\ Bet P D A1) by (apply inner_pasch with C'; Between).
ex_and HD D.
assert(C' <> P) by (intro; subst C'; contradiction).
assert (Par A1 A2 C' P) by (apply par_col2_par with C1 C2; Col).
assert(HPar3 : Par_strict A1 A2 C' P) by (apply (par_not_col_strict _ _ _ _ P); Col).
assert(B <> P).
intro.
subst B.
apply (par_not_col _ _ _ _ A1) in HPar3.
apply HPar3; Col.
Col.
assert(P <> C).
intro.
treat_equalities.

*****
H16 : Bet B D C'
H17 : Bet C' D A1
H18 : not (eq C' C')
H19 : Par A1 A2 C' C'
HPar3 : Par_strict A1 A2 C' C'
H20 : not (eq B C')
D : Tpoint
H13 : Bet A1 B C'
H12 : Col B B1 B2
B : Tpoint
H11 : not (Col C' B1 B2)
H9 : not (Col A1 B1 B2)
HLine : or (not (Col C1 B1 B2)) (not (Col C2 B1 B2))
HPar2 : Par_strict A1 A2 C1 C2
HPar1 : Par_strict A1 A2 B1 B2
H3 : Col C' C1 C2
H5 : not (eq C1 C2)
H2 : Par A1 A2 C1 C2
H1 : Col C' B1 B2
H7 : not (eq B1 B2)
H6 : not (eq A1 A2)
H0 : Par A1 A2 B1 B2
H : not (Col C' A1 A2)
A1,A2,B1,B2,C1,C2,C' : Tpoint
HTE : tarski_s_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
absurde.
-----
Lemma tarski_s_euclid_implies_playfair : tarski_s_parallel_postulate -> playfair_s_postulate.
Proof.
assert (HAux: tarski_s_parallel_postulate -> forall A1 A2 B1 B2 C1 C2 P, ~ Col P A1 A2 -> Par A1 A2 B1 B2 -> Col P B1 B2 -> Par A1 A2 C1 C2 -> Col P C1 C2 -> Col C1 B1 B2 /\\ Col C2 B1 B2).
intros HTE; intros.
apply par_distincts in H0.
apply par_distincts in H2.
spliter.
assert(HPar1 : Par_strict A1 A2 B1 B2) by (apply (par_not_col_strict _ _ _ _ P); Col; intro; apply H; Col).
assert(HPar2 : Par_strict A1 A2 C1 C2) by (apply (par_not_col_strict _ _ _ _ P); Col; intro; apply H; Col).
elim (line_dec B1 B2 C1 C2); intro HLine.
assumption.
assert (HLineNew : ~ Col C1 B1 B2 \\/ ~ Col C2 B1 B2) by (induction (col_dec C1 B1 B2); induction (col_dec C2 B1 B2);tauto).
clear HLine; rename HLineNew into HLine.
assert(HC' : exists C', Col C1 C2 C' /\\ TS B1 B2 A1 C').
ex_and HC' C'.
unfold TS in H9.
assert (~ Col A1 B1 B2) by (spliter; auto).
spliter.
ex_and H12 B.
double C' P C.
unfold Midpoint in H14.
spliter.
assert(HD : exists D, Bet B D C /\\ Bet P D A1) by (apply inner_pasch with C'; Between).
ex_and HD D.
assert(C' <> P) by (intro; subst C'; contradiction).
assert (Par A1 A2 C' P) by (apply par_col2_par with C1 C2; Col).
assert(HPar3 : Par_strict A1 A2 C' P) by (apply (par_not_col_strict _ _ _ _ P); Col).
assert(B <> P).
intro.
subst B.
apply (par_not_col _ _ _ _ A1) in HPar3.
apply HPar3; Col.
Col.
assert(P <> C).
intro.
treat_equalities.
absurde.

*****
H21 : not (eq P C)
H20 : not (eq B P)
HPar3 : Par_strict A1 A2 C' P
H19 : Par A1 A2 C' P
H18 : not (eq C' P)
H17 : Bet P D A1
H16 : Bet B D C
D : Tpoint
H15 : Cong C' P P C
H14 : Bet C' P C
C : Tpoint
H13 : Bet A1 B C'
H12 : Col B B1 B2
B : Tpoint
H10 : not (Col A1 B1 B2)
H11 : not (Col C' B1 B2)
H9 : not (Col A1 B1 B2)
H8 : Col C1 C2 C'
C' : Tpoint
HLine : or (not (Col C1 B1 B2)) (not (Col C2 B1 B2))
HPar2 : Par_strict A1 A2 C1 C2
HPar1 : Par_strict A1 A2 B1 B2
H3 : Col P C1 C2
H5 : not (eq C1 C2)
H4 : not (eq A1 A2)
H2 : Par A1 A2 C1 C2
H1 : Col P B1 B2
H7 : not (eq B1 B2)
H6 : not (eq A1 A2)
H0 : Par A1 A2 B1 B2
H : not (Col P A1 A2)
A1,A2,B1,B2,C1,C2,P : Tpoint
HTE : tarski_s_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Col C1 B1 B2) (Col C2 B1 B2)
+++++
assert(Col B P B1) by ColR.
-----
Lemma tarski_s_euclid_implies_playfair : tarski_s_parallel_postulate -> playfair_s_postulate.
Proof.
assert (HAux: tarski_s_parallel_postulate -> forall A1 A2 B1 B2 C1 C2 P, ~ Col P A1 A2 -> Par A1 A2 B1 B2 -> Col P B1 B2 -> Par A1 A2 C1 C2 -> Col P C1 C2 -> Col C1 B1 B2 /\\ Col C2 B1 B2).
intros HTE; intros.
apply par_distincts in H0.
apply par_distincts in H2.
spliter.
assert(HPar1 : Par_strict A1 A2 B1 B2) by (apply (par_not_col_strict _ _ _ _ P); Col; intro; apply H; Col).
assert(HPar2 : Par_strict A1 A2 C1 C2) by (apply (par_not_col_strict _ _ _ _ P); Col; intro; apply H; Col).
elim (line_dec B1 B2 C1 C2); intro HLine.
assumption.
assert (HLineNew : ~ Col C1 B1 B2 \\/ ~ Col C2 B1 B2) by (induction (col_dec C1 B1 B2); induction (col_dec C2 B1 B2);tauto).
clear HLine; rename HLineNew into HLine.
assert(HC' : exists C', Col C1 C2 C' /\\ TS B1 B2 A1 C').
ex_and HC' C'.
unfold TS in H9.
assert (~ Col A1 B1 B2) by (spliter; auto).
spliter.
ex_and H12 B.
double C' P C.
unfold Midpoint in H14.
spliter.
assert(HD : exists D, Bet B D C /\\ Bet P D A1) by (apply inner_pasch with C'; Between).
ex_and HD D.
assert(C' <> P) by (intro; subst C'; contradiction).
assert (Par A1 A2 C' P) by (apply par_col2_par with C1 C2; Col).
assert(HPar3 : Par_strict A1 A2 C' P) by (apply (par_not_col_strict _ _ _ _ P); Col).
assert(B <> P).
intro.
subst B.
apply (par_not_col _ _ _ _ A1) in HPar3.
apply HPar3; Col.
Col.
assert(P <> C).
intro.
treat_equalities.
absurde.
assert(Col B P B1) by ColR.

*****
H22 : Col B P B1
H21 : not (eq P C)
H20 : not (eq B P)
HPar3 : Par_strict A1 A2 C' P
H19 : Par A1 A2 C' P
H18 : not (eq C' P)
H17 : Bet P D A1
H16 : Bet B D C
D : Tpoint
H15 : Cong C' P P C
H14 : Bet C' P C
C : Tpoint
H13 : Bet A1 B C'
H12 : Col B B1 B2
B : Tpoint
H10 : not (Col A1 B1 B2)
H11 : not (Col C' B1 B2)
H9 : not (Col A1 B1 B2)
H8 : Col C1 C2 C'
C' : Tpoint
HLine : or (not (Col C1 B1 B2)) (not (Col C2 B1 B2))
HPar2 : Par_strict A1 A2 C1 C2
HPar1 : Par_strict A1 A2 B1 B2
H3 : Col P C1 C2
H5 : not (eq C1 C2)
H4 : not (eq A1 A2)
H2 : Par A1 A2 C1 C2
H1 : Col P B1 B2
H7 : not (eq B1 B2)
H6 : not (eq A1 A2)
H0 : Par A1 A2 B1 B2
H : not (Col P A1 A2)
A1,A2,B1,B2,C1,C2,P : Tpoint
HTE : tarski_s_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Col C1 B1 B2) (Col C2 B1 B2)
+++++
assert(Col B P B2) by ColR.
-----
Lemma tarski_s_euclid_implies_playfair : tarski_s_parallel_postulate -> playfair_s_postulate.
Proof.
assert (HAux: tarski_s_parallel_postulate -> forall A1 A2 B1 B2 C1 C2 P, ~ Col P A1 A2 -> Par A1 A2 B1 B2 -> Col P B1 B2 -> Par A1 A2 C1 C2 -> Col P C1 C2 -> Col C1 B1 B2 /\\ Col C2 B1 B2).
intros HTE; intros.
apply par_distincts in H0.
apply par_distincts in H2.
spliter.
assert(HPar1 : Par_strict A1 A2 B1 B2) by (apply (par_not_col_strict _ _ _ _ P); Col; intro; apply H; Col).
assert(HPar2 : Par_strict A1 A2 C1 C2) by (apply (par_not_col_strict _ _ _ _ P); Col; intro; apply H; Col).
elim (line_dec B1 B2 C1 C2); intro HLine.
assumption.
assert (HLineNew : ~ Col C1 B1 B2 \\/ ~ Col C2 B1 B2) by (induction (col_dec C1 B1 B2); induction (col_dec C2 B1 B2);tauto).
clear HLine; rename HLineNew into HLine.
assert(HC' : exists C', Col C1 C2 C' /\\ TS B1 B2 A1 C').
ex_and HC' C'.
unfold TS in H9.
assert (~ Col A1 B1 B2) by (spliter; auto).
spliter.
ex_and H12 B.
double C' P C.
unfold Midpoint in H14.
spliter.
assert(HD : exists D, Bet B D C /\\ Bet P D A1) by (apply inner_pasch with C'; Between).
ex_and HD D.
assert(C' <> P) by (intro; subst C'; contradiction).
assert (Par A1 A2 C' P) by (apply par_col2_par with C1 C2; Col).
assert(HPar3 : Par_strict A1 A2 C' P) by (apply (par_not_col_strict _ _ _ _ P); Col).
assert(B <> P).
intro.
subst B.
apply (par_not_col _ _ _ _ A1) in HPar3.
apply HPar3; Col.
Col.
assert(P <> C).
intro.
treat_equalities.
absurde.
assert(Col B P B1) by ColR.
assert(Col B P B2) by ColR.

*****
H23 : Col B P B2
H22 : Col B P B1
H21 : not (eq P C)
H20 : not (eq B P)
HPar3 : Par_strict A1 A2 C' P
H19 : Par A1 A2 C' P
H18 : not (eq C' P)
H17 : Bet P D A1
H16 : Bet B D C
D : Tpoint
H15 : Cong C' P P C
H14 : Bet C' P C
C : Tpoint
H13 : Bet A1 B C'
H12 : Col B B1 B2
B : Tpoint
H10 : not (Col A1 B1 B2)
H11 : not (Col C' B1 B2)
H9 : not (Col A1 B1 B2)
H8 : Col C1 C2 C'
C' : Tpoint
HLine : or (not (Col C1 B1 B2)) (not (Col C2 B1 B2))
HPar2 : Par_strict A1 A2 C1 C2
HPar1 : Par_strict A1 A2 B1 B2
H3 : Col P C1 C2
H5 : not (eq C1 C2)
H4 : not (eq A1 A2)
H2 : Par A1 A2 C1 C2
H1 : Col P B1 B2
H7 : not (eq B1 B2)
H6 : not (eq A1 A2)
H0 : Par A1 A2 B1 B2
H : not (Col P A1 A2)
A1,A2,B1,B2,C1,C2,P : Tpoint
HTE : tarski_s_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Col C1 B1 B2) (Col C2 B1 B2)
+++++
assert(Col C' P C1) by ColR.
-----
Lemma tarski_s_euclid_implies_playfair : tarski_s_parallel_postulate -> playfair_s_postulate.
Proof.
assert (HAux: tarski_s_parallel_postulate -> forall A1 A2 B1 B2 C1 C2 P, ~ Col P A1 A2 -> Par A1 A2 B1 B2 -> Col P B1 B2 -> Par A1 A2 C1 C2 -> Col P C1 C2 -> Col C1 B1 B2 /\\ Col C2 B1 B2).
intros HTE; intros.
apply par_distincts in H0.
apply par_distincts in H2.
spliter.
assert(HPar1 : Par_strict A1 A2 B1 B2) by (apply (par_not_col_strict _ _ _ _ P); Col; intro; apply H; Col).
assert(HPar2 : Par_strict A1 A2 C1 C2) by (apply (par_not_col_strict _ _ _ _ P); Col; intro; apply H; Col).
elim (line_dec B1 B2 C1 C2); intro HLine.
assumption.
assert (HLineNew : ~ Col C1 B1 B2 \\/ ~ Col C2 B1 B2) by (induction (col_dec C1 B1 B2); induction (col_dec C2 B1 B2);tauto).
clear HLine; rename HLineNew into HLine.
assert(HC' : exists C', Col C1 C2 C' /\\ TS B1 B2 A1 C').
ex_and HC' C'.
unfold TS in H9.
assert (~ Col A1 B1 B2) by (spliter; auto).
spliter.
ex_and H12 B.
double C' P C.
unfold Midpoint in H14.
spliter.
assert(HD : exists D, Bet B D C /\\ Bet P D A1) by (apply inner_pasch with C'; Between).
ex_and HD D.
assert(C' <> P) by (intro; subst C'; contradiction).
assert (Par A1 A2 C' P) by (apply par_col2_par with C1 C2; Col).
assert(HPar3 : Par_strict A1 A2 C' P) by (apply (par_not_col_strict _ _ _ _ P); Col).
assert(B <> P).
intro.
subst B.
apply (par_not_col _ _ _ _ A1) in HPar3.
apply HPar3; Col.
Col.
assert(P <> C).
intro.
treat_equalities.
absurde.
assert(Col B P B1) by ColR.
assert(Col B P B2) by ColR.
assert(Col C' P C1) by ColR.

*****
H24 : Col C' P C1
H23 : Col B P B2
H22 : Col B P B1
H21 : not (eq P C)
H20 : not (eq B P)
HPar3 : Par_strict A1 A2 C' P
H19 : Par A1 A2 C' P
H18 : not (eq C' P)
H17 : Bet P D A1
H16 : Bet B D C
D : Tpoint
H15 : Cong C' P P C
H14 : Bet C' P C
C : Tpoint
H13 : Bet A1 B C'
H12 : Col B B1 B2
B : Tpoint
H10 : not (Col A1 B1 B2)
H11 : not (Col C' B1 B2)
H9 : not (Col A1 B1 B2)
H8 : Col C1 C2 C'
C' : Tpoint
HLine : or (not (Col C1 B1 B2)) (not (Col C2 B1 B2))
HPar2 : Par_strict A1 A2 C1 C2
HPar1 : Par_strict A1 A2 B1 B2
H3 : Col P C1 C2
H5 : not (eq C1 C2)
H4 : not (eq A1 A2)
H2 : Par A1 A2 C1 C2
H1 : Col P B1 B2
H7 : not (eq B1 B2)
H6 : not (eq A1 A2)
H0 : Par A1 A2 B1 B2
H : not (Col P A1 A2)
A1,A2,B1,B2,C1,C2,P : Tpoint
HTE : tarski_s_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Col C1 B1 B2) (Col C2 B1 B2)
+++++
assert(Col C P C1) by (assert_cols;ColR).
-----
Lemma tarski_s_euclid_implies_playfair : tarski_s_parallel_postulate -> playfair_s_postulate.
Proof.
assert (HAux: tarski_s_parallel_postulate -> forall A1 A2 B1 B2 C1 C2 P, ~ Col P A1 A2 -> Par A1 A2 B1 B2 -> Col P B1 B2 -> Par A1 A2 C1 C2 -> Col P C1 C2 -> Col C1 B1 B2 /\\ Col C2 B1 B2).
intros HTE; intros.
apply par_distincts in H0.
apply par_distincts in H2.
spliter.
assert(HPar1 : Par_strict A1 A2 B1 B2) by (apply (par_not_col_strict _ _ _ _ P); Col; intro; apply H; Col).
assert(HPar2 : Par_strict A1 A2 C1 C2) by (apply (par_not_col_strict _ _ _ _ P); Col; intro; apply H; Col).
elim (line_dec B1 B2 C1 C2); intro HLine.
assumption.
assert (HLineNew : ~ Col C1 B1 B2 \\/ ~ Col C2 B1 B2) by (induction (col_dec C1 B1 B2); induction (col_dec C2 B1 B2);tauto).
clear HLine; rename HLineNew into HLine.
assert(HC' : exists C', Col C1 C2 C' /\\ TS B1 B2 A1 C').
ex_and HC' C'.
unfold TS in H9.
assert (~ Col A1 B1 B2) by (spliter; auto).
spliter.
ex_and H12 B.
double C' P C.
unfold Midpoint in H14.
spliter.
assert(HD : exists D, Bet B D C /\\ Bet P D A1) by (apply inner_pasch with C'; Between).
ex_and HD D.
assert(C' <> P) by (intro; subst C'; contradiction).
assert (Par A1 A2 C' P) by (apply par_col2_par with C1 C2; Col).
assert(HPar3 : Par_strict A1 A2 C' P) by (apply (par_not_col_strict _ _ _ _ P); Col).
assert(B <> P).
intro.
subst B.
apply (par_not_col _ _ _ _ A1) in HPar3.
apply HPar3; Col.
Col.
assert(P <> C).
intro.
treat_equalities.
absurde.
assert(Col B P B1) by ColR.
assert(Col B P B2) by ColR.
assert(Col C' P C1) by ColR.
assert(Col C P C1) by (assert_cols;ColR).

*****
H25 : Col C P C1
H24 : Col C' P C1
H23 : Col B P B2
H22 : Col B P B1
H21 : not (eq P C)
H20 : not (eq B P)
HPar3 : Par_strict A1 A2 C' P
H19 : Par A1 A2 C' P
H18 : not (eq C' P)
H17 : Bet P D A1
H16 : Bet B D C
D : Tpoint
H15 : Cong C' P P C
H14 : Bet C' P C
C : Tpoint
H13 : Bet A1 B C'
H12 : Col B B1 B2
B : Tpoint
H10 : not (Col A1 B1 B2)
H11 : not (Col C' B1 B2)
H9 : not (Col A1 B1 B2)
H8 : Col C1 C2 C'
C' : Tpoint
HLine : or (not (Col C1 B1 B2)) (not (Col C2 B1 B2))
HPar2 : Par_strict A1 A2 C1 C2
HPar1 : Par_strict A1 A2 B1 B2
H3 : Col P C1 C2
H5 : not (eq C1 C2)
H4 : not (eq A1 A2)
H2 : Par A1 A2 C1 C2
H1 : Col P B1 B2
H7 : not (eq B1 B2)
H6 : not (eq A1 A2)
H0 : Par A1 A2 B1 B2
H : not (Col P A1 A2)
A1,A2,B1,B2,C1,C2,P : Tpoint
HTE : tarski_s_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Col C1 B1 B2) (Col C2 B1 B2)
+++++
assert(Col C' P C2) by ColR.
-----
Lemma tarski_s_euclid_implies_playfair : tarski_s_parallel_postulate -> playfair_s_postulate.
Proof.
assert (HAux: tarski_s_parallel_postulate -> forall A1 A2 B1 B2 C1 C2 P, ~ Col P A1 A2 -> Par A1 A2 B1 B2 -> Col P B1 B2 -> Par A1 A2 C1 C2 -> Col P C1 C2 -> Col C1 B1 B2 /\\ Col C2 B1 B2).
intros HTE; intros.
apply par_distincts in H0.
apply par_distincts in H2.
spliter.
assert(HPar1 : Par_strict A1 A2 B1 B2) by (apply (par_not_col_strict _ _ _ _ P); Col; intro; apply H; Col).
assert(HPar2 : Par_strict A1 A2 C1 C2) by (apply (par_not_col_strict _ _ _ _ P); Col; intro; apply H; Col).
elim (line_dec B1 B2 C1 C2); intro HLine.
assumption.
assert (HLineNew : ~ Col C1 B1 B2 \\/ ~ Col C2 B1 B2) by (induction (col_dec C1 B1 B2); induction (col_dec C2 B1 B2);tauto).
clear HLine; rename HLineNew into HLine.
assert(HC' : exists C', Col C1 C2 C' /\\ TS B1 B2 A1 C').
ex_and HC' C'.
unfold TS in H9.
assert (~ Col A1 B1 B2) by (spliter; auto).
spliter.
ex_and H12 B.
double C' P C.
unfold Midpoint in H14.
spliter.
assert(HD : exists D, Bet B D C /\\ Bet P D A1) by (apply inner_pasch with C'; Between).
ex_and HD D.
assert(C' <> P) by (intro; subst C'; contradiction).
assert (Par A1 A2 C' P) by (apply par_col2_par with C1 C2; Col).
assert(HPar3 : Par_strict A1 A2 C' P) by (apply (par_not_col_strict _ _ _ _ P); Col).
assert(B <> P).
intro.
subst B.
apply (par_not_col _ _ _ _ A1) in HPar3.
apply HPar3; Col.
Col.
assert(P <> C).
intro.
treat_equalities.
absurde.
assert(Col B P B1) by ColR.
assert(Col B P B2) by ColR.
assert(Col C' P C1) by ColR.
assert(Col C P C1) by (assert_cols;ColR).
assert(Col C' P C2) by ColR.

*****
H26 : Col C' P C2
H25 : Col C P C1
H24 : Col C' P C1
H23 : Col B P B2
H22 : Col B P B1
H21 : not (eq P C)
H20 : not (eq B P)
HPar3 : Par_strict A1 A2 C' P
H19 : Par A1 A2 C' P
H18 : not (eq C' P)
H17 : Bet P D A1
H16 : Bet B D C
D : Tpoint
H15 : Cong C' P P C
H14 : Bet C' P C
C : Tpoint
H13 : Bet A1 B C'
H12 : Col B B1 B2
B : Tpoint
H10 : not (Col A1 B1 B2)
H11 : not (Col C' B1 B2)
H9 : not (Col A1 B1 B2)
H8 : Col C1 C2 C'
C' : Tpoint
HLine : or (not (Col C1 B1 B2)) (not (Col C2 B1 B2))
HPar2 : Par_strict A1 A2 C1 C2
HPar1 : Par_strict A1 A2 B1 B2
H3 : Col P C1 C2
H5 : not (eq C1 C2)
H4 : not (eq A1 A2)
H2 : Par A1 A2 C1 C2
H1 : Col P B1 B2
H7 : not (eq B1 B2)
H6 : not (eq A1 A2)
H0 : Par A1 A2 B1 B2
H : not (Col P A1 A2)
A1,A2,B1,B2,C1,C2,P : Tpoint
HTE : tarski_s_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Col C1 B1 B2) (Col C2 B1 B2)
+++++
assert(Col C P C2) by (assert_cols;ColR).
-----
Lemma tarski_s_euclid_implies_playfair : tarski_s_parallel_postulate -> playfair_s_postulate.
Proof.
assert (HAux: tarski_s_parallel_postulate -> forall A1 A2 B1 B2 C1 C2 P, ~ Col P A1 A2 -> Par A1 A2 B1 B2 -> Col P B1 B2 -> Par A1 A2 C1 C2 -> Col P C1 C2 -> Col C1 B1 B2 /\\ Col C2 B1 B2).
intros HTE; intros.
apply par_distincts in H0.
apply par_distincts in H2.
spliter.
assert(HPar1 : Par_strict A1 A2 B1 B2) by (apply (par_not_col_strict _ _ _ _ P); Col; intro; apply H; Col).
assert(HPar2 : Par_strict A1 A2 C1 C2) by (apply (par_not_col_strict _ _ _ _ P); Col; intro; apply H; Col).
elim (line_dec B1 B2 C1 C2); intro HLine.
assumption.
assert (HLineNew : ~ Col C1 B1 B2 \\/ ~ Col C2 B1 B2) by (induction (col_dec C1 B1 B2); induction (col_dec C2 B1 B2);tauto).
clear HLine; rename HLineNew into HLine.
assert(HC' : exists C', Col C1 C2 C' /\\ TS B1 B2 A1 C').
ex_and HC' C'.
unfold TS in H9.
assert (~ Col A1 B1 B2) by (spliter; auto).
spliter.
ex_and H12 B.
double C' P C.
unfold Midpoint in H14.
spliter.
assert(HD : exists D, Bet B D C /\\ Bet P D A1) by (apply inner_pasch with C'; Between).
ex_and HD D.
assert(C' <> P) by (intro; subst C'; contradiction).
assert (Par A1 A2 C' P) by (apply par_col2_par with C1 C2; Col).
assert(HPar3 : Par_strict A1 A2 C' P) by (apply (par_not_col_strict _ _ _ _ P); Col).
assert(B <> P).
intro.
subst B.
apply (par_not_col _ _ _ _ A1) in HPar3.
apply HPar3; Col.
Col.
assert(P <> C).
intro.
treat_equalities.
absurde.
assert(Col B P B1) by ColR.
assert(Col B P B2) by ColR.
assert(Col C' P C1) by ColR.
assert(Col C P C1) by (assert_cols;ColR).
assert(Col C' P C2) by ColR.
assert(Col C P C2) by (assert_cols;ColR).

*****
H27 : Col C P C2
H26 : Col C' P C2
H25 : Col C P C1
H24 : Col C' P C1
H23 : Col B P B2
H22 : Col B P B1
H21 : not (eq P C)
H20 : not (eq B P)
HPar3 : Par_strict A1 A2 C' P
H19 : Par A1 A2 C' P
H18 : not (eq C' P)
H17 : Bet P D A1
H16 : Bet B D C
D : Tpoint
H15 : Cong C' P P C
H14 : Bet C' P C
C : Tpoint
H13 : Bet A1 B C'
H12 : Col B B1 B2
B : Tpoint
H10 : not (Col A1 B1 B2)
H11 : not (Col C' B1 B2)
H9 : not (Col A1 B1 B2)
H8 : Col C1 C2 C'
C' : Tpoint
HLine : or (not (Col C1 B1 B2)) (not (Col C2 B1 B2))
HPar2 : Par_strict A1 A2 C1 C2
HPar1 : Par_strict A1 A2 B1 B2
H3 : Col P C1 C2
H5 : not (eq C1 C2)
H4 : not (eq A1 A2)
H2 : Par A1 A2 C1 C2
H1 : Col P B1 B2
H7 : not (eq B1 B2)
H6 : not (eq A1 A2)
H0 : Par A1 A2 B1 B2
H : not (Col P A1 A2)
A1,A2,B1,B2,C1,C2,P : Tpoint
HTE : tarski_s_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Col C1 B1 B2) (Col C2 B1 B2)
+++++
assert(~Col B P C) by (intro;apply H11;assert_cols;ColR).
-----
Lemma tarski_s_euclid_implies_playfair : tarski_s_parallel_postulate -> playfair_s_postulate.
Proof.
assert (HAux: tarski_s_parallel_postulate -> forall A1 A2 B1 B2 C1 C2 P, ~ Col P A1 A2 -> Par A1 A2 B1 B2 -> Col P B1 B2 -> Par A1 A2 C1 C2 -> Col P C1 C2 -> Col C1 B1 B2 /\\ Col C2 B1 B2).
intros HTE; intros.
apply par_distincts in H0.
apply par_distincts in H2.
spliter.
assert(HPar1 : Par_strict A1 A2 B1 B2) by (apply (par_not_col_strict _ _ _ _ P); Col; intro; apply H; Col).
assert(HPar2 : Par_strict A1 A2 C1 C2) by (apply (par_not_col_strict _ _ _ _ P); Col; intro; apply H; Col).
elim (line_dec B1 B2 C1 C2); intro HLine.
assumption.
assert (HLineNew : ~ Col C1 B1 B2 \\/ ~ Col C2 B1 B2) by (induction (col_dec C1 B1 B2); induction (col_dec C2 B1 B2);tauto).
clear HLine; rename HLineNew into HLine.
assert(HC' : exists C', Col C1 C2 C' /\\ TS B1 B2 A1 C').
ex_and HC' C'.
unfold TS in H9.
assert (~ Col A1 B1 B2) by (spliter; auto).
spliter.
ex_and H12 B.
double C' P C.
unfold Midpoint in H14.
spliter.
assert(HD : exists D, Bet B D C /\\ Bet P D A1) by (apply inner_pasch with C'; Between).
ex_and HD D.
assert(C' <> P) by (intro; subst C'; contradiction).
assert (Par A1 A2 C' P) by (apply par_col2_par with C1 C2; Col).
assert(HPar3 : Par_strict A1 A2 C' P) by (apply (par_not_col_strict _ _ _ _ P); Col).
assert(B <> P).
intro.
subst B.
apply (par_not_col _ _ _ _ A1) in HPar3.
apply HPar3; Col.
Col.
assert(P <> C).
intro.
treat_equalities.
absurde.
assert(Col B P B1) by ColR.
assert(Col B P B2) by ColR.
assert(Col C' P C1) by ColR.
assert(Col C P C1) by (assert_cols;ColR).
assert(Col C' P C2) by ColR.
assert(Col C P C2) by (assert_cols;ColR).
assert(~Col B P C) by (intro;apply H11;assert_cols;ColR).

*****
H28 : not (Col B P C)
H27 : Col C P C2
H26 : Col C' P C2
H25 : Col C P C1
H24 : Col C' P C1
H23 : Col B P B2
H22 : Col B P B1
H21 : not (eq P C)
H20 : not (eq B P)
HPar3 : Par_strict A1 A2 C' P
H19 : Par A1 A2 C' P
H18 : not (eq C' P)
H17 : Bet P D A1
H16 : Bet B D C
D : Tpoint
H15 : Cong C' P P C
H14 : Bet C' P C
C : Tpoint
H13 : Bet A1 B C'
H12 : Col B B1 B2
B : Tpoint
H10 : not (Col A1 B1 B2)
H11 : not (Col C' B1 B2)
H9 : not (Col A1 B1 B2)
H8 : Col C1 C2 C'
C' : Tpoint
HLine : or (not (Col C1 B1 B2)) (not (Col C2 B1 B2))
HPar2 : Par_strict A1 A2 C1 C2
HPar1 : Par_strict A1 A2 B1 B2
H3 : Col P C1 C2
H5 : not (eq C1 C2)
H4 : not (eq A1 A2)
H2 : Par A1 A2 C1 C2
H1 : Col P B1 B2
H7 : not (eq B1 B2)
H6 : not (eq A1 A2)
H0 : Par A1 A2 B1 B2
H : not (Col P A1 A2)
A1,A2,B1,B2,C1,C2,P : Tpoint
HTE : tarski_s_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Col C1 B1 B2) (Col C2 B1 B2)
+++++
assert(P <> D) by (intro; subst D; apply bet_col in H16; contradiction).
-----
Lemma tarski_s_euclid_implies_playfair : tarski_s_parallel_postulate -> playfair_s_postulate.
Proof.
assert (HAux: tarski_s_parallel_postulate -> forall A1 A2 B1 B2 C1 C2 P, ~ Col P A1 A2 -> Par A1 A2 B1 B2 -> Col P B1 B2 -> Par A1 A2 C1 C2 -> Col P C1 C2 -> Col C1 B1 B2 /\\ Col C2 B1 B2).
intros HTE; intros.
apply par_distincts in H0.
apply par_distincts in H2.
spliter.
assert(HPar1 : Par_strict A1 A2 B1 B2) by (apply (par_not_col_strict _ _ _ _ P); Col; intro; apply H; Col).
assert(HPar2 : Par_strict A1 A2 C1 C2) by (apply (par_not_col_strict _ _ _ _ P); Col; intro; apply H; Col).
elim (line_dec B1 B2 C1 C2); intro HLine.
assumption.
assert (HLineNew : ~ Col C1 B1 B2 \\/ ~ Col C2 B1 B2) by (induction (col_dec C1 B1 B2); induction (col_dec C2 B1 B2);tauto).
clear HLine; rename HLineNew into HLine.
assert(HC' : exists C', Col C1 C2 C' /\\ TS B1 B2 A1 C').
ex_and HC' C'.
unfold TS in H9.
assert (~ Col A1 B1 B2) by (spliter; auto).
spliter.
ex_and H12 B.
double C' P C.
unfold Midpoint in H14.
spliter.
assert(HD : exists D, Bet B D C /\\ Bet P D A1) by (apply inner_pasch with C'; Between).
ex_and HD D.
assert(C' <> P) by (intro; subst C'; contradiction).
assert (Par A1 A2 C' P) by (apply par_col2_par with C1 C2; Col).
assert(HPar3 : Par_strict A1 A2 C' P) by (apply (par_not_col_strict _ _ _ _ P); Col).
assert(B <> P).
intro.
subst B.
apply (par_not_col _ _ _ _ A1) in HPar3.
apply HPar3; Col.
Col.
assert(P <> C).
intro.
treat_equalities.
absurde.
assert(Col B P B1) by ColR.
assert(Col B P B2) by ColR.
assert(Col C' P C1) by ColR.
assert(Col C P C1) by (assert_cols;ColR).
assert(Col C' P C2) by ColR.
assert(Col C P C2) by (assert_cols;ColR).
assert(~Col B P C) by (intro;apply H11;assert_cols;ColR).
assert(P <> D) by (intro; subst D; apply bet_col in H16; contradiction).

*****
H29 : not (eq P D)
H28 : not (Col B P C)
H27 : Col C P C2
H26 : Col C' P C2
H25 : Col C P C1
H24 : Col C' P C1
H23 : Col B P B2
H22 : Col B P B1
H21 : not (eq P C)
H20 : not (eq B P)
HPar3 : Par_strict A1 A2 C' P
H19 : Par A1 A2 C' P
H18 : not (eq C' P)
H17 : Bet P D A1
H16 : Bet B D C
D : Tpoint
H15 : Cong C' P P C
H14 : Bet C' P C
C : Tpoint
H13 : Bet A1 B C'
H12 : Col B B1 B2
B : Tpoint
H10 : not (Col A1 B1 B2)
H11 : not (Col C' B1 B2)
H9 : not (Col A1 B1 B2)
H8 : Col C1 C2 C'
C' : Tpoint
HLine : or (not (Col C1 B1 B2)) (not (Col C2 B1 B2))
HPar2 : Par_strict A1 A2 C1 C2
HPar1 : Par_strict A1 A2 B1 B2
H3 : Col P C1 C2
H5 : not (eq C1 C2)
H4 : not (eq A1 A2)
H2 : Par A1 A2 C1 C2
H1 : Col P B1 B2
H7 : not (eq B1 B2)
H6 : not (eq A1 A2)
H0 : Par A1 A2 B1 B2
H : not (Col P A1 A2)
A1,A2,B1,B2,C1,C2,P : Tpoint
HTE : tarski_s_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Col C1 B1 B2) (Col C2 B1 B2)
+++++
assert(HE := HTE P B C D A1 H17 H16 H29).
-----
Lemma tarski_s_euclid_implies_playfair : tarski_s_parallel_postulate -> playfair_s_postulate.
Proof.
assert (HAux: tarski_s_parallel_postulate -> forall A1 A2 B1 B2 C1 C2 P, ~ Col P A1 A2 -> Par A1 A2 B1 B2 -> Col P B1 B2 -> Par A1 A2 C1 C2 -> Col P C1 C2 -> Col C1 B1 B2 /\\ Col C2 B1 B2).
intros HTE; intros.
apply par_distincts in H0.
apply par_distincts in H2.
spliter.
assert(HPar1 : Par_strict A1 A2 B1 B2) by (apply (par_not_col_strict _ _ _ _ P); Col; intro; apply H; Col).
assert(HPar2 : Par_strict A1 A2 C1 C2) by (apply (par_not_col_strict _ _ _ _ P); Col; intro; apply H; Col).
elim (line_dec B1 B2 C1 C2); intro HLine.
assumption.
assert (HLineNew : ~ Col C1 B1 B2 \\/ ~ Col C2 B1 B2) by (induction (col_dec C1 B1 B2); induction (col_dec C2 B1 B2);tauto).
clear HLine; rename HLineNew into HLine.
assert(HC' : exists C', Col C1 C2 C' /\\ TS B1 B2 A1 C').
ex_and HC' C'.
unfold TS in H9.
assert (~ Col A1 B1 B2) by (spliter; auto).
spliter.
ex_and H12 B.
double C' P C.
unfold Midpoint in H14.
spliter.
assert(HD : exists D, Bet B D C /\\ Bet P D A1) by (apply inner_pasch with C'; Between).
ex_and HD D.
assert(C' <> P) by (intro; subst C'; contradiction).
assert (Par A1 A2 C' P) by (apply par_col2_par with C1 C2; Col).
assert(HPar3 : Par_strict A1 A2 C' P) by (apply (par_not_col_strict _ _ _ _ P); Col).
assert(B <> P).
intro.
subst B.
apply (par_not_col _ _ _ _ A1) in HPar3.
apply HPar3; Col.
Col.
assert(P <> C).
intro.
treat_equalities.
absurde.
assert(Col B P B1) by ColR.
assert(Col B P B2) by ColR.
assert(Col C' P C1) by ColR.
assert(Col C P C1) by (assert_cols;ColR).
assert(Col C' P C2) by ColR.
assert(Col C P C2) by (assert_cols;ColR).
assert(~Col B P C) by (intro;apply H11;assert_cols;ColR).
assert(P <> D) by (intro; subst D; apply bet_col in H16; contradiction).
assert(HE := HTE P B C D A1 H17 H16 H29).

*****
HE : ex\n (fun X : Tpoint =>\n ex\n (fun Y : Tpoint => and (Bet P B X) (and (Bet P C Y) (Bet X A1 Y))))
H29 : not (eq P D)
H28 : not (Col B P C)
H27 : Col C P C2
H26 : Col C' P C2
H25 : Col C P C1
H24 : Col C' P C1
H23 : Col B P B2
H22 : Col B P B1
H21 : not (eq P C)
H20 : not (eq B P)
HPar3 : Par_strict A1 A2 C' P
H19 : Par A1 A2 C' P
H18 : not (eq C' P)
H17 : Bet P D A1
H16 : Bet B D C
D : Tpoint
H15 : Cong C' P P C
H14 : Bet C' P C
C : Tpoint
H13 : Bet A1 B C'
H12 : Col B B1 B2
B : Tpoint
H10 : not (Col A1 B1 B2)
H11 : not (Col C' B1 B2)
H9 : not (Col A1 B1 B2)
H8 : Col C1 C2 C'
C' : Tpoint
HLine : or (not (Col C1 B1 B2)) (not (Col C2 B1 B2))
HPar2 : Par_strict A1 A2 C1 C2
HPar1 : Par_strict A1 A2 B1 B2
H3 : Col P C1 C2
H5 : not (eq C1 C2)
H4 : not (eq A1 A2)
H2 : Par A1 A2 C1 C2
H1 : Col P B1 B2
H7 : not (eq B1 B2)
H6 : not (eq A1 A2)
H0 : Par A1 A2 B1 B2
H : not (Col P A1 A2)
A1,A2,B1,B2,C1,C2,P : Tpoint
HTE : tarski_s_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Col C1 B1 B2) (Col C2 B1 B2)
+++++
ex_and HE X; ex_and H30 Y.
-----
Lemma tarski_s_euclid_implies_playfair : tarski_s_parallel_postulate -> playfair_s_postulate.
Proof.
assert (HAux: tarski_s_parallel_postulate -> forall A1 A2 B1 B2 C1 C2 P, ~ Col P A1 A2 -> Par A1 A2 B1 B2 -> Col P B1 B2 -> Par A1 A2 C1 C2 -> Col P C1 C2 -> Col C1 B1 B2 /\\ Col C2 B1 B2).
intros HTE; intros.
apply par_distincts in H0.
apply par_distincts in H2.
spliter.
assert(HPar1 : Par_strict A1 A2 B1 B2) by (apply (par_not_col_strict _ _ _ _ P); Col; intro; apply H; Col).
assert(HPar2 : Par_strict A1 A2 C1 C2) by (apply (par_not_col_strict _ _ _ _ P); Col; intro; apply H; Col).
elim (line_dec B1 B2 C1 C2); intro HLine.
assumption.
assert (HLineNew : ~ Col C1 B1 B2 \\/ ~ Col C2 B1 B2) by (induction (col_dec C1 B1 B2); induction (col_dec C2 B1 B2);tauto).
clear HLine; rename HLineNew into HLine.
assert(HC' : exists C', Col C1 C2 C' /\\ TS B1 B2 A1 C').
ex_and HC' C'.
unfold TS in H9.
assert (~ Col A1 B1 B2) by (spliter; auto).
spliter.
ex_and H12 B.
double C' P C.
unfold Midpoint in H14.
spliter.
assert(HD : exists D, Bet B D C /\\ Bet P D A1) by (apply inner_pasch with C'; Between).
ex_and HD D.
assert(C' <> P) by (intro; subst C'; contradiction).
assert (Par A1 A2 C' P) by (apply par_col2_par with C1 C2; Col).
assert(HPar3 : Par_strict A1 A2 C' P) by (apply (par_not_col_strict _ _ _ _ P); Col).
assert(B <> P).
intro.
subst B.
apply (par_not_col _ _ _ _ A1) in HPar3.
apply HPar3; Col.
Col.
assert(P <> C).
intro.
treat_equalities.
absurde.
assert(Col B P B1) by ColR.
assert(Col B P B2) by ColR.
assert(Col C' P C1) by ColR.
assert(Col C P C1) by (assert_cols;ColR).
assert(Col C' P C2) by ColR.
assert(Col C P C2) by (assert_cols;ColR).
assert(~Col B P C) by (intro;apply H11;assert_cols;ColR).
assert(P <> D) by (intro; subst D; apply bet_col in H16; contradiction).
assert(HE := HTE P B C D A1 H17 H16 H29).
ex_and HE X; ex_and H30 Y.

*****
H32 : Bet X A1 Y
H31 : Bet P C Y
H30 : Bet P B X
X,Y : Tpoint
H29 : not (eq P D)
H28 : not (Col B P C)
H27 : Col C P C2
H26 : Col C' P C2
H25 : Col C P C1
H24 : Col C' P C1
H23 : Col B P B2
H22 : Col B P B1
H21 : not (eq P C)
H20 : not (eq B P)
HPar3 : Par_strict A1 A2 C' P
H19 : Par A1 A2 C' P
H18 : not (eq C' P)
H17 : Bet P D A1
H16 : Bet B D C
D : Tpoint
H15 : Cong C' P P C
H14 : Bet C' P C
C : Tpoint
H13 : Bet A1 B C'
H12 : Col B B1 B2
B : Tpoint
H10 : not (Col A1 B1 B2)
H11 : not (Col C' B1 B2)
H9 : not (Col A1 B1 B2)
H8 : Col C1 C2 C'
C' : Tpoint
HLine : or (not (Col C1 B1 B2)) (not (Col C2 B1 B2))
HPar2 : Par_strict A1 A2 C1 C2
HPar1 : Par_strict A1 A2 B1 B2
H3 : Col P C1 C2
H5 : not (eq C1 C2)
H4 : not (eq A1 A2)
H2 : Par A1 A2 C1 C2
H1 : Col P B1 B2
H7 : not (eq B1 B2)
H6 : not (eq A1 A2)
H0 : Par A1 A2 B1 B2
H : not (Col P A1 A2)
A1,A2,B1,B2,C1,C2,P : Tpoint
HTE : tarski_s_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Col C1 B1 B2) (Col C2 B1 B2)
+++++
assert(Hx := l12_6 A1 A2 P X).
-----
Lemma tarski_s_euclid_implies_playfair : tarski_s_parallel_postulate -> playfair_s_postulate.
Proof.
assert (HAux: tarski_s_parallel_postulate -> forall A1 A2 B1 B2 C1 C2 P, ~ Col P A1 A2 -> Par A1 A2 B1 B2 -> Col P B1 B2 -> Par A1 A2 C1 C2 -> Col P C1 C2 -> Col C1 B1 B2 /\\ Col C2 B1 B2).
intros HTE; intros.
apply par_distincts in H0.
apply par_distincts in H2.
spliter.
assert(HPar1 : Par_strict A1 A2 B1 B2) by (apply (par_not_col_strict _ _ _ _ P); Col; intro; apply H; Col).
assert(HPar2 : Par_strict A1 A2 C1 C2) by (apply (par_not_col_strict _ _ _ _ P); Col; intro; apply H; Col).
elim (line_dec B1 B2 C1 C2); intro HLine.
assumption.
assert (HLineNew : ~ Col C1 B1 B2 \\/ ~ Col C2 B1 B2) by (induction (col_dec C1 B1 B2); induction (col_dec C2 B1 B2);tauto).
clear HLine; rename HLineNew into HLine.
assert(HC' : exists C', Col C1 C2 C' /\\ TS B1 B2 A1 C').
ex_and HC' C'.
unfold TS in H9.
assert (~ Col A1 B1 B2) by (spliter; auto).
spliter.
ex_and H12 B.
double C' P C.
unfold Midpoint in H14.
spliter.
assert(HD : exists D, Bet B D C /\\ Bet P D A1) by (apply inner_pasch with C'; Between).
ex_and HD D.
assert(C' <> P) by (intro; subst C'; contradiction).
assert (Par A1 A2 C' P) by (apply par_col2_par with C1 C2; Col).
assert(HPar3 : Par_strict A1 A2 C' P) by (apply (par_not_col_strict _ _ _ _ P); Col).
assert(B <> P).
intro.
subst B.
apply (par_not_col _ _ _ _ A1) in HPar3.
apply HPar3; Col.
Col.
assert(P <> C).
intro.
treat_equalities.
absurde.
assert(Col B P B1) by ColR.
assert(Col B P B2) by ColR.
assert(Col C' P C1) by ColR.
assert(Col C P C1) by (assert_cols;ColR).
assert(Col C' P C2) by ColR.
assert(Col C P C2) by (assert_cols;ColR).
assert(~Col B P C) by (intro;apply H11;assert_cols;ColR).
assert(P <> D) by (intro; subst D; apply bet_col in H16; contradiction).
assert(HE := HTE P B C D A1 H17 H16 H29).
ex_and HE X; ex_and H30 Y.
assert(Hx := l12_6 A1 A2 P X).

*****
Hx : forall _ : Par_strict A1 A2 P X, OS A1 A2 P X
H32 : Bet X A1 Y
H31 : Bet P C Y
H30 : Bet P B X
X,Y : Tpoint
H29 : not (eq P D)
H28 : not (Col B P C)
H27 : Col C P C2
H26 : Col C' P C2
H25 : Col C P C1
H24 : Col C' P C1
H23 : Col B P B2
H22 : Col B P B1
H21 : not (eq P C)
H20 : not (eq B P)
HPar3 : Par_strict A1 A2 C' P
H19 : Par A1 A2 C' P
H18 : not (eq C' P)
H17 : Bet P D A1
H16 : Bet B D C
D : Tpoint
H15 : Cong C' P P C
H14 : Bet C' P C
C : Tpoint
H13 : Bet A1 B C'
H12 : Col B B1 B2
B : Tpoint
H10 : not (Col A1 B1 B2)
H11 : not (Col C' B1 B2)
H9 : not (Col A1 B1 B2)
H8 : Col C1 C2 C'
C' : Tpoint
HLine : or (not (Col C1 B1 B2)) (not (Col C2 B1 B2))
HPar2 : Par_strict A1 A2 C1 C2
HPar1 : Par_strict A1 A2 B1 B2
H3 : Col P C1 C2
H5 : not (eq C1 C2)
H4 : not (eq A1 A2)
H2 : Par A1 A2 C1 C2
H1 : Col P B1 B2
H7 : not (eq B1 B2)
H6 : not (eq A1 A2)
H0 : Par A1 A2 B1 B2
H : not (Col P A1 A2)
A1,A2,B1,B2,C1,C2,P : Tpoint
HTE : tarski_s_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Col C1 B1 B2) (Col C2 B1 B2)
+++++
assert (P<>X) by (intro;treat_equalities;intuition).
-----
Lemma tarski_s_euclid_implies_playfair : tarski_s_parallel_postulate -> playfair_s_postulate.
Proof.
assert (HAux: tarski_s_parallel_postulate -> forall A1 A2 B1 B2 C1 C2 P, ~ Col P A1 A2 -> Par A1 A2 B1 B2 -> Col P B1 B2 -> Par A1 A2 C1 C2 -> Col P C1 C2 -> Col C1 B1 B2 /\\ Col C2 B1 B2).
intros HTE; intros.
apply par_distincts in H0.
apply par_distincts in H2.
spliter.
assert(HPar1 : Par_strict A1 A2 B1 B2) by (apply (par_not_col_strict _ _ _ _ P); Col; intro; apply H; Col).
assert(HPar2 : Par_strict A1 A2 C1 C2) by (apply (par_not_col_strict _ _ _ _ P); Col; intro; apply H; Col).
elim (line_dec B1 B2 C1 C2); intro HLine.
assumption.
assert (HLineNew : ~ Col C1 B1 B2 \\/ ~ Col C2 B1 B2) by (induction (col_dec C1 B1 B2); induction (col_dec C2 B1 B2);tauto).
clear HLine; rename HLineNew into HLine.
assert(HC' : exists C', Col C1 C2 C' /\\ TS B1 B2 A1 C').
ex_and HC' C'.
unfold TS in H9.
assert (~ Col A1 B1 B2) by (spliter; auto).
spliter.
ex_and H12 B.
double C' P C.
unfold Midpoint in H14.
spliter.
assert(HD : exists D, Bet B D C /\\ Bet P D A1) by (apply inner_pasch with C'; Between).
ex_and HD D.
assert(C' <> P) by (intro; subst C'; contradiction).
assert (Par A1 A2 C' P) by (apply par_col2_par with C1 C2; Col).
assert(HPar3 : Par_strict A1 A2 C' P) by (apply (par_not_col_strict _ _ _ _ P); Col).
assert(B <> P).
intro.
subst B.
apply (par_not_col _ _ _ _ A1) in HPar3.
apply HPar3; Col.
Col.
assert(P <> C).
intro.
treat_equalities.
absurde.
assert(Col B P B1) by ColR.
assert(Col B P B2) by ColR.
assert(Col C' P C1) by ColR.
assert(Col C P C1) by (assert_cols;ColR).
assert(Col C' P C2) by ColR.
assert(Col C P C2) by (assert_cols;ColR).
assert(~Col B P C) by (intro;apply H11;assert_cols;ColR).
assert(P <> D) by (intro; subst D; apply bet_col in H16; contradiction).
assert(HE := HTE P B C D A1 H17 H16 H29).
ex_and HE X; ex_and H30 Y.
assert(Hx := l12_6 A1 A2 P X).
assert (P<>X) by (intro;treat_equalities;intuition).

*****
H33 : not (eq P X)
Hx : forall _ : Par_strict A1 A2 P X, OS A1 A2 P X
H32 : Bet X A1 Y
H31 : Bet P C Y
H30 : Bet P B X
X,Y : Tpoint
H29 : not (eq P D)
H28 : not (Col B P C)
H27 : Col C P C2
H26 : Col C' P C2
H25 : Col C P C1
H24 : Col C' P C1
H23 : Col B P B2
H22 : Col B P B1
H21 : not (eq P C)
H20 : not (eq B P)
HPar3 : Par_strict A1 A2 C' P
H19 : Par A1 A2 C' P
H18 : not (eq C' P)
H17 : Bet P D A1
H16 : Bet B D C
D : Tpoint
H15 : Cong C' P P C
H14 : Bet C' P C
C : Tpoint
H13 : Bet A1 B C'
H12 : Col B B1 B2
B : Tpoint
H10 : not (Col A1 B1 B2)
H11 : not (Col C' B1 B2)
H9 : not (Col A1 B1 B2)
H8 : Col C1 C2 C'
C' : Tpoint
HLine : or (not (Col C1 B1 B2)) (not (Col C2 B1 B2))
HPar2 : Par_strict A1 A2 C1 C2
HPar1 : Par_strict A1 A2 B1 B2
H3 : Col P C1 C2
H5 : not (eq C1 C2)
H4 : not (eq A1 A2)
H2 : Par A1 A2 C1 C2
H1 : Col P B1 B2
H7 : not (eq B1 B2)
H6 : not (eq A1 A2)
H0 : Par A1 A2 B1 B2
H : not (Col P A1 A2)
A1,A2,B1,B2,C1,C2,P : Tpoint
HTE : tarski_s_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Col C1 B1 B2) (Col C2 B1 B2)
+++++
assert(Par_strict A1 A2 P X) by (apply (par_strict_col2_par_strict _ _ B1 B2); Col; apply col3 with B P; Col).
-----
Lemma tarski_s_euclid_implies_playfair : tarski_s_parallel_postulate -> playfair_s_postulate.
Proof.
assert (HAux: tarski_s_parallel_postulate -> forall A1 A2 B1 B2 C1 C2 P, ~ Col P A1 A2 -> Par A1 A2 B1 B2 -> Col P B1 B2 -> Par A1 A2 C1 C2 -> Col P C1 C2 -> Col C1 B1 B2 /\\ Col C2 B1 B2).
intros HTE; intros.
apply par_distincts in H0.
apply par_distincts in H2.
spliter.
assert(HPar1 : Par_strict A1 A2 B1 B2) by (apply (par_not_col_strict _ _ _ _ P); Col; intro; apply H; Col).
assert(HPar2 : Par_strict A1 A2 C1 C2) by (apply (par_not_col_strict _ _ _ _ P); Col; intro; apply H; Col).
elim (line_dec B1 B2 C1 C2); intro HLine.
assumption.
assert (HLineNew : ~ Col C1 B1 B2 \\/ ~ Col C2 B1 B2) by (induction (col_dec C1 B1 B2); induction (col_dec C2 B1 B2);tauto).
clear HLine; rename HLineNew into HLine.
assert(HC' : exists C', Col C1 C2 C' /\\ TS B1 B2 A1 C').
ex_and HC' C'.
unfold TS in H9.
assert (~ Col A1 B1 B2) by (spliter; auto).
spliter.
ex_and H12 B.
double C' P C.
unfold Midpoint in H14.
spliter.
assert(HD : exists D, Bet B D C /\\ Bet P D A1) by (apply inner_pasch with C'; Between).
ex_and HD D.
assert(C' <> P) by (intro; subst C'; contradiction).
assert (Par A1 A2 C' P) by (apply par_col2_par with C1 C2; Col).
assert(HPar3 : Par_strict A1 A2 C' P) by (apply (par_not_col_strict _ _ _ _ P); Col).
assert(B <> P).
intro.
subst B.
apply (par_not_col _ _ _ _ A1) in HPar3.
apply HPar3; Col.
Col.
assert(P <> C).
intro.
treat_equalities.
absurde.
assert(Col B P B1) by ColR.
assert(Col B P B2) by ColR.
assert(Col C' P C1) by ColR.
assert(Col C P C1) by (assert_cols;ColR).
assert(Col C' P C2) by ColR.
assert(Col C P C2) by (assert_cols;ColR).
assert(~Col B P C) by (intro;apply H11;assert_cols;ColR).
assert(P <> D) by (intro; subst D; apply bet_col in H16; contradiction).
assert(HE := HTE P B C D A1 H17 H16 H29).
ex_and HE X; ex_and H30 Y.
assert(Hx := l12_6 A1 A2 P X).
assert (P<>X) by (intro;treat_equalities;intuition).
assert(Par_strict A1 A2 P X) by (apply (par_strict_col2_par_strict _ _ B1 B2); Col; apply col3 with B P; Col).

*****
H34 : Par_strict A1 A2 P X
H33 : not (eq P X)
Hx : forall _ : Par_strict A1 A2 P X, OS A1 A2 P X
H32 : Bet X A1 Y
H31 : Bet P C Y
H30 : Bet P B X
X,Y : Tpoint
H29 : not (eq P D)
H28 : not (Col B P C)
H27 : Col C P C2
H26 : Col C' P C2
H25 : Col C P C1
H24 : Col C' P C1
H23 : Col B P B2
H22 : Col B P B1
H21 : not (eq P C)
H20 : not (eq B P)
HPar3 : Par_strict A1 A2 C' P
H19 : Par A1 A2 C' P
H18 : not (eq C' P)
H17 : Bet P D A1
H16 : Bet B D C
D : Tpoint
H15 : Cong C' P P C
H14 : Bet C' P C
C : Tpoint
H13 : Bet A1 B C'
H12 : Col B B1 B2
B : Tpoint
H10 : not (Col A1 B1 B2)
H11 : not (Col C' B1 B2)
H9 : not (Col A1 B1 B2)
H8 : Col C1 C2 C'
C' : Tpoint
HLine : or (not (Col C1 B1 B2)) (not (Col C2 B1 B2))
HPar2 : Par_strict A1 A2 C1 C2
HPar1 : Par_strict A1 A2 B1 B2
H3 : Col P C1 C2
H5 : not (eq C1 C2)
H4 : not (eq A1 A2)
H2 : Par A1 A2 C1 C2
H1 : Col P B1 B2
H7 : not (eq B1 B2)
H6 : not (eq A1 A2)
H0 : Par A1 A2 B1 B2
H : not (Col P A1 A2)
A1,A2,B1,B2,C1,C2,P : Tpoint
HTE : tarski_s_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Col C1 B1 B2) (Col C2 B1 B2)
+++++
apply Hx in H34.
-----
Lemma tarski_s_euclid_implies_playfair : tarski_s_parallel_postulate -> playfair_s_postulate.
Proof.
assert (HAux: tarski_s_parallel_postulate -> forall A1 A2 B1 B2 C1 C2 P, ~ Col P A1 A2 -> Par A1 A2 B1 B2 -> Col P B1 B2 -> Par A1 A2 C1 C2 -> Col P C1 C2 -> Col C1 B1 B2 /\\ Col C2 B1 B2).
intros HTE; intros.
apply par_distincts in H0.
apply par_distincts in H2.
spliter.
assert(HPar1 : Par_strict A1 A2 B1 B2) by (apply (par_not_col_strict _ _ _ _ P); Col; intro; apply H; Col).
assert(HPar2 : Par_strict A1 A2 C1 C2) by (apply (par_not_col_strict _ _ _ _ P); Col; intro; apply H; Col).
elim (line_dec B1 B2 C1 C2); intro HLine.
assumption.
assert (HLineNew : ~ Col C1 B1 B2 \\/ ~ Col C2 B1 B2) by (induction (col_dec C1 B1 B2); induction (col_dec C2 B1 B2);tauto).
clear HLine; rename HLineNew into HLine.
assert(HC' : exists C', Col C1 C2 C' /\\ TS B1 B2 A1 C').
ex_and HC' C'.
unfold TS in H9.
assert (~ Col A1 B1 B2) by (spliter; auto).
spliter.
ex_and H12 B.
double C' P C.
unfold Midpoint in H14.
spliter.
assert(HD : exists D, Bet B D C /\\ Bet P D A1) by (apply inner_pasch with C'; Between).
ex_and HD D.
assert(C' <> P) by (intro; subst C'; contradiction).
assert (Par A1 A2 C' P) by (apply par_col2_par with C1 C2; Col).
assert(HPar3 : Par_strict A1 A2 C' P) by (apply (par_not_col_strict _ _ _ _ P); Col).
assert(B <> P).
intro.
subst B.
apply (par_not_col _ _ _ _ A1) in HPar3.
apply HPar3; Col.
Col.
assert(P <> C).
intro.
treat_equalities.
absurde.
assert(Col B P B1) by ColR.
assert(Col B P B2) by ColR.
assert(Col C' P C1) by ColR.
assert(Col C P C1) by (assert_cols;ColR).
assert(Col C' P C2) by ColR.
assert(Col C P C2) by (assert_cols;ColR).
assert(~Col B P C) by (intro;apply H11;assert_cols;ColR).
assert(P <> D) by (intro; subst D; apply bet_col in H16; contradiction).
assert(HE := HTE P B C D A1 H17 H16 H29).
ex_and HE X; ex_and H30 Y.
assert(Hx := l12_6 A1 A2 P X).
assert (P<>X) by (intro;treat_equalities;intuition).
assert(Par_strict A1 A2 P X) by (apply (par_strict_col2_par_strict _ _ B1 B2); Col; apply col3 with B P; Col).
apply Hx in H34.

*****
H34 : OS A1 A2 P X
H33 : not (eq P X)
Hx : forall _ : Par_strict A1 A2 P X, OS A1 A2 P X
H32 : Bet X A1 Y
H31 : Bet P C Y
H30 : Bet P B X
X,Y : Tpoint
H29 : not (eq P D)
H28 : not (Col B P C)
H27 : Col C P C2
H26 : Col C' P C2
H25 : Col C P C1
H24 : Col C' P C1
H23 : Col B P B2
H22 : Col B P B1
H21 : not (eq P C)
H20 : not (eq B P)
HPar3 : Par_strict A1 A2 C' P
H19 : Par A1 A2 C' P
H18 : not (eq C' P)
H17 : Bet P D A1
H16 : Bet B D C
D : Tpoint
H15 : Cong C' P P C
H14 : Bet C' P C
C : Tpoint
H13 : Bet A1 B C'
H12 : Col B B1 B2
B : Tpoint
H10 : not (Col A1 B1 B2)
H11 : not (Col C' B1 B2)
H9 : not (Col A1 B1 B2)
H8 : Col C1 C2 C'
C' : Tpoint
HLine : or (not (Col C1 B1 B2)) (not (Col C2 B1 B2))
HPar2 : Par_strict A1 A2 C1 C2
HPar1 : Par_strict A1 A2 B1 B2
H3 : Col P C1 C2
H5 : not (eq C1 C2)
H4 : not (eq A1 A2)
H2 : Par A1 A2 C1 C2
H1 : Col P B1 B2
H7 : not (eq B1 B2)
H6 : not (eq A1 A2)
H0 : Par A1 A2 B1 B2
H : not (Col P A1 A2)
A1,A2,B1,B2,C1,C2,P : Tpoint
HTE : tarski_s_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Col C1 B1 B2) (Col C2 B1 B2)
+++++
assert(Hy := l12_6 A1 A2 P Y).
-----
Lemma tarski_s_euclid_implies_playfair : tarski_s_parallel_postulate -> playfair_s_postulate.
Proof.
assert (HAux: tarski_s_parallel_postulate -> forall A1 A2 B1 B2 C1 C2 P, ~ Col P A1 A2 -> Par A1 A2 B1 B2 -> Col P B1 B2 -> Par A1 A2 C1 C2 -> Col P C1 C2 -> Col C1 B1 B2 /\\ Col C2 B1 B2).
intros HTE; intros.
apply par_distincts in H0.
apply par_distincts in H2.
spliter.
assert(HPar1 : Par_strict A1 A2 B1 B2) by (apply (par_not_col_strict _ _ _ _ P); Col; intro; apply H; Col).
assert(HPar2 : Par_strict A1 A2 C1 C2) by (apply (par_not_col_strict _ _ _ _ P); Col; intro; apply H; Col).
elim (line_dec B1 B2 C1 C2); intro HLine.
assumption.
assert (HLineNew : ~ Col C1 B1 B2 \\/ ~ Col C2 B1 B2) by (induction (col_dec C1 B1 B2); induction (col_dec C2 B1 B2);tauto).
clear HLine; rename HLineNew into HLine.
assert(HC' : exists C', Col C1 C2 C' /\\ TS B1 B2 A1 C').
ex_and HC' C'.
unfold TS in H9.
assert (~ Col A1 B1 B2) by (spliter; auto).
spliter.
ex_and H12 B.
double C' P C.
unfold Midpoint in H14.
spliter.
assert(HD : exists D, Bet B D C /\\ Bet P D A1) by (apply inner_pasch with C'; Between).
ex_and HD D.
assert(C' <> P) by (intro; subst C'; contradiction).
assert (Par A1 A2 C' P) by (apply par_col2_par with C1 C2; Col).
assert(HPar3 : Par_strict A1 A2 C' P) by (apply (par_not_col_strict _ _ _ _ P); Col).
assert(B <> P).
intro.
subst B.
apply (par_not_col _ _ _ _ A1) in HPar3.
apply HPar3; Col.
Col.
assert(P <> C).
intro.
treat_equalities.
absurde.
assert(Col B P B1) by ColR.
assert(Col B P B2) by ColR.
assert(Col C' P C1) by ColR.
assert(Col C P C1) by (assert_cols;ColR).
assert(Col C' P C2) by ColR.
assert(Col C P C2) by (assert_cols;ColR).
assert(~Col B P C) by (intro;apply H11;assert_cols;ColR).
assert(P <> D) by (intro; subst D; apply bet_col in H16; contradiction).
assert(HE := HTE P B C D A1 H17 H16 H29).
ex_and HE X; ex_and H30 Y.
assert(Hx := l12_6 A1 A2 P X).
assert (P<>X) by (intro;treat_equalities;intuition).
assert(Par_strict A1 A2 P X) by (apply (par_strict_col2_par_strict _ _ B1 B2); Col; apply col3 with B P; Col).
apply Hx in H34.
assert(Hy := l12_6 A1 A2 P Y).

*****
Hy : forall _ : Par_strict A1 A2 P Y, OS A1 A2 P Y
H34 : OS A1 A2 P X
H33 : not (eq P X)
Hx : forall _ : Par_strict A1 A2 P X, OS A1 A2 P X
H32 : Bet X A1 Y
H31 : Bet P C Y
H30 : Bet P B X
X,Y : Tpoint
H29 : not (eq P D)
H28 : not (Col B P C)
H27 : Col C P C2
H26 : Col C' P C2
H25 : Col C P C1
H24 : Col C' P C1
H23 : Col B P B2
H22 : Col B P B1
H21 : not (eq P C)
H20 : not (eq B P)
HPar3 : Par_strict A1 A2 C' P
H19 : Par A1 A2 C' P
H18 : not (eq C' P)
H17 : Bet P D A1
H16 : Bet B D C
D : Tpoint
H15 : Cong C' P P C
H14 : Bet C' P C
C : Tpoint
H13 : Bet A1 B C'
H12 : Col B B1 B2
B : Tpoint
H10 : not (Col A1 B1 B2)
H11 : not (Col C' B1 B2)
H9 : not (Col A1 B1 B2)
H8 : Col C1 C2 C'
C' : Tpoint
HLine : or (not (Col C1 B1 B2)) (not (Col C2 B1 B2))
HPar2 : Par_strict A1 A2 C1 C2
HPar1 : Par_strict A1 A2 B1 B2
H3 : Col P C1 C2
H5 : not (eq C1 C2)
H4 : not (eq A1 A2)
H2 : Par A1 A2 C1 C2
H1 : Col P B1 B2
H7 : not (eq B1 B2)
H6 : not (eq A1 A2)
H0 : Par A1 A2 B1 B2
H : not (Col P A1 A2)
A1,A2,B1,B2,C1,C2,P : Tpoint
HTE : tarski_s_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Col C1 B1 B2) (Col C2 B1 B2)
+++++
assert (P<>Y) by (intro;treat_equalities;intuition).
-----
Lemma tarski_s_euclid_implies_playfair : tarski_s_parallel_postulate -> playfair_s_postulate.
Proof.
assert (HAux: tarski_s_parallel_postulate -> forall A1 A2 B1 B2 C1 C2 P, ~ Col P A1 A2 -> Par A1 A2 B1 B2 -> Col P B1 B2 -> Par A1 A2 C1 C2 -> Col P C1 C2 -> Col C1 B1 B2 /\\ Col C2 B1 B2).
intros HTE; intros.
apply par_distincts in H0.
apply par_distincts in H2.
spliter.
assert(HPar1 : Par_strict A1 A2 B1 B2) by (apply (par_not_col_strict _ _ _ _ P); Col; intro; apply H; Col).
assert(HPar2 : Par_strict A1 A2 C1 C2) by (apply (par_not_col_strict _ _ _ _ P); Col; intro; apply H; Col).
elim (line_dec B1 B2 C1 C2); intro HLine.
assumption.
assert (HLineNew : ~ Col C1 B1 B2 \\/ ~ Col C2 B1 B2) by (induction (col_dec C1 B1 B2); induction (col_dec C2 B1 B2);tauto).
clear HLine; rename HLineNew into HLine.
assert(HC' : exists C', Col C1 C2 C' /\\ TS B1 B2 A1 C').
ex_and HC' C'.
unfold TS in H9.
assert (~ Col A1 B1 B2) by (spliter; auto).
spliter.
ex_and H12 B.
double C' P C.
unfold Midpoint in H14.
spliter.
assert(HD : exists D, Bet B D C /\\ Bet P D A1) by (apply inner_pasch with C'; Between).
ex_and HD D.
assert(C' <> P) by (intro; subst C'; contradiction).
assert (Par A1 A2 C' P) by (apply par_col2_par with C1 C2; Col).
assert(HPar3 : Par_strict A1 A2 C' P) by (apply (par_not_col_strict _ _ _ _ P); Col).
assert(B <> P).
intro.
subst B.
apply (par_not_col _ _ _ _ A1) in HPar3.
apply HPar3; Col.
Col.
assert(P <> C).
intro.
treat_equalities.
absurde.
assert(Col B P B1) by ColR.
assert(Col B P B2) by ColR.
assert(Col C' P C1) by ColR.
assert(Col C P C1) by (assert_cols;ColR).
assert(Col C' P C2) by ColR.
assert(Col C P C2) by (assert_cols;ColR).
assert(~Col B P C) by (intro;apply H11;assert_cols;ColR).
assert(P <> D) by (intro; subst D; apply bet_col in H16; contradiction).
assert(HE := HTE P B C D A1 H17 H16 H29).
ex_and HE X; ex_and H30 Y.
assert(Hx := l12_6 A1 A2 P X).
assert (P<>X) by (intro;treat_equalities;intuition).
assert(Par_strict A1 A2 P X) by (apply (par_strict_col2_par_strict _ _ B1 B2); Col; apply col3 with B P; Col).
apply Hx in H34.
assert(Hy := l12_6 A1 A2 P Y).
assert (P<>Y) by (intro;treat_equalities;intuition).

*****
H35 : not (eq P Y)
Hy : forall _ : Par_strict A1 A2 P Y, OS A1 A2 P Y
H34 : OS A1 A2 P X
H33 : not (eq P X)
Hx : forall _ : Par_strict A1 A2 P X, OS A1 A2 P X
H32 : Bet X A1 Y
H31 : Bet P C Y
H30 : Bet P B X
X,Y : Tpoint
H29 : not (eq P D)
H28 : not (Col B P C)
H27 : Col C P C2
H26 : Col C' P C2
H25 : Col C P C1
H24 : Col C' P C1
H23 : Col B P B2
H22 : Col B P B1
H21 : not (eq P C)
H20 : not (eq B P)
HPar3 : Par_strict A1 A2 C' P
H19 : Par A1 A2 C' P
H18 : not (eq C' P)
H17 : Bet P D A1
H16 : Bet B D C
D : Tpoint
H15 : Cong C' P P C
H14 : Bet C' P C
C : Tpoint
H13 : Bet A1 B C'
H12 : Col B B1 B2
B : Tpoint
H10 : not (Col A1 B1 B2)
H11 : not (Col C' B1 B2)
H9 : not (Col A1 B1 B2)
H8 : Col C1 C2 C'
C' : Tpoint
HLine : or (not (Col C1 B1 B2)) (not (Col C2 B1 B2))
HPar2 : Par_strict A1 A2 C1 C2
HPar1 : Par_strict A1 A2 B1 B2
H3 : Col P C1 C2
H5 : not (eq C1 C2)
H4 : not (eq A1 A2)
H2 : Par A1 A2 C1 C2
H1 : Col P B1 B2
H7 : not (eq B1 B2)
H6 : not (eq A1 A2)
H0 : Par A1 A2 B1 B2
H : not (Col P A1 A2)
A1,A2,B1,B2,C1,C2,P : Tpoint
HTE : tarski_s_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Col C1 B1 B2) (Col C2 B1 B2)
+++++
assert(HPar4 : Par_strict A1 A2 P Y) by (apply (par_strict_col2_par_strict _ _ C1 C2); Col; apply (col3 C P); Col).
-----
Lemma tarski_s_euclid_implies_playfair : tarski_s_parallel_postulate -> playfair_s_postulate.
Proof.
assert (HAux: tarski_s_parallel_postulate -> forall A1 A2 B1 B2 C1 C2 P, ~ Col P A1 A2 -> Par A1 A2 B1 B2 -> Col P B1 B2 -> Par A1 A2 C1 C2 -> Col P C1 C2 -> Col C1 B1 B2 /\\ Col C2 B1 B2).
intros HTE; intros.
apply par_distincts in H0.
apply par_distincts in H2.
spliter.
assert(HPar1 : Par_strict A1 A2 B1 B2) by (apply (par_not_col_strict _ _ _ _ P); Col; intro; apply H; Col).
assert(HPar2 : Par_strict A1 A2 C1 C2) by (apply (par_not_col_strict _ _ _ _ P); Col; intro; apply H; Col).
elim (line_dec B1 B2 C1 C2); intro HLine.
assumption.
assert (HLineNew : ~ Col C1 B1 B2 \\/ ~ Col C2 B1 B2) by (induction (col_dec C1 B1 B2); induction (col_dec C2 B1 B2);tauto).
clear HLine; rename HLineNew into HLine.
assert(HC' : exists C', Col C1 C2 C' /\\ TS B1 B2 A1 C').
ex_and HC' C'.
unfold TS in H9.
assert (~ Col A1 B1 B2) by (spliter; auto).
spliter.
ex_and H12 B.
double C' P C.
unfold Midpoint in H14.
spliter.
assert(HD : exists D, Bet B D C /\\ Bet P D A1) by (apply inner_pasch with C'; Between).
ex_and HD D.
assert(C' <> P) by (intro; subst C'; contradiction).
assert (Par A1 A2 C' P) by (apply par_col2_par with C1 C2; Col).
assert(HPar3 : Par_strict A1 A2 C' P) by (apply (par_not_col_strict _ _ _ _ P); Col).
assert(B <> P).
intro.
subst B.
apply (par_not_col _ _ _ _ A1) in HPar3.
apply HPar3; Col.
Col.
assert(P <> C).
intro.
treat_equalities.
absurde.
assert(Col B P B1) by ColR.
assert(Col B P B2) by ColR.
assert(Col C' P C1) by ColR.
assert(Col C P C1) by (assert_cols;ColR).
assert(Col C' P C2) by ColR.
assert(Col C P C2) by (assert_cols;ColR).
assert(~Col B P C) by (intro;apply H11;assert_cols;ColR).
assert(P <> D) by (intro; subst D; apply bet_col in H16; contradiction).
assert(HE := HTE P B C D A1 H17 H16 H29).
ex_and HE X; ex_and H30 Y.
assert(Hx := l12_6 A1 A2 P X).
assert (P<>X) by (intro;treat_equalities;intuition).
assert(Par_strict A1 A2 P X) by (apply (par_strict_col2_par_strict _ _ B1 B2); Col; apply col3 with B P; Col).
apply Hx in H34.
assert(Hy := l12_6 A1 A2 P Y).
assert (P<>Y) by (intro;treat_equalities;intuition).
assert(HPar4 : Par_strict A1 A2 P Y) by (apply (par_strict_col2_par_strict _ _ C1 C2); Col; apply (col3 C P); Col).

*****
HPar4 : Par_strict A1 A2 P Y
H35 : not (eq P Y)
Hy : forall _ : Par_strict A1 A2 P Y, OS A1 A2 P Y
H34 : OS A1 A2 P X
H33 : not (eq P X)
Hx : forall _ : Par_strict A1 A2 P X, OS A1 A2 P X
H32 : Bet X A1 Y
H31 : Bet P C Y
H30 : Bet P B X
X,Y : Tpoint
H29 : not (eq P D)
H28 : not (Col B P C)
H27 : Col C P C2
H26 : Col C' P C2
H25 : Col C P C1
H24 : Col C' P C1
H23 : Col B P B2
H22 : Col B P B1
H21 : not (eq P C)
H20 : not (eq B P)
HPar3 : Par_strict A1 A2 C' P
H19 : Par A1 A2 C' P
H18 : not (eq C' P)
H17 : Bet P D A1
H16 : Bet B D C
D : Tpoint
H15 : Cong C' P P C
H14 : Bet C' P C
C : Tpoint
H13 : Bet A1 B C'
H12 : Col B B1 B2
B : Tpoint
H10 : not (Col A1 B1 B2)
H11 : not (Col C' B1 B2)
H9 : not (Col A1 B1 B2)
H8 : Col C1 C2 C'
C' : Tpoint
HLine : or (not (Col C1 B1 B2)) (not (Col C2 B1 B2))
HPar2 : Par_strict A1 A2 C1 C2
HPar1 : Par_strict A1 A2 B1 B2
H3 : Col P C1 C2
H5 : not (eq C1 C2)
H4 : not (eq A1 A2)
H2 : Par A1 A2 C1 C2
H1 : Col P B1 B2
H7 : not (eq B1 B2)
H6 : not (eq A1 A2)
H0 : Par A1 A2 B1 B2
H : not (Col P A1 A2)
A1,A2,B1,B2,C1,C2,P : Tpoint
HTE : tarski_s_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Col C1 B1 B2) (Col C2 B1 B2)
+++++
apply Hy in HPar4.
-----
Lemma tarski_s_euclid_implies_playfair : tarski_s_parallel_postulate -> playfair_s_postulate.
Proof.
assert (HAux: tarski_s_parallel_postulate -> forall A1 A2 B1 B2 C1 C2 P, ~ Col P A1 A2 -> Par A1 A2 B1 B2 -> Col P B1 B2 -> Par A1 A2 C1 C2 -> Col P C1 C2 -> Col C1 B1 B2 /\\ Col C2 B1 B2).
intros HTE; intros.
apply par_distincts in H0.
apply par_distincts in H2.
spliter.
assert(HPar1 : Par_strict A1 A2 B1 B2) by (apply (par_not_col_strict _ _ _ _ P); Col; intro; apply H; Col).
assert(HPar2 : Par_strict A1 A2 C1 C2) by (apply (par_not_col_strict _ _ _ _ P); Col; intro; apply H; Col).
elim (line_dec B1 B2 C1 C2); intro HLine.
assumption.
assert (HLineNew : ~ Col C1 B1 B2 \\/ ~ Col C2 B1 B2) by (induction (col_dec C1 B1 B2); induction (col_dec C2 B1 B2);tauto).
clear HLine; rename HLineNew into HLine.
assert(HC' : exists C', Col C1 C2 C' /\\ TS B1 B2 A1 C').
ex_and HC' C'.
unfold TS in H9.
assert (~ Col A1 B1 B2) by (spliter; auto).
spliter.
ex_and H12 B.
double C' P C.
unfold Midpoint in H14.
spliter.
assert(HD : exists D, Bet B D C /\\ Bet P D A1) by (apply inner_pasch with C'; Between).
ex_and HD D.
assert(C' <> P) by (intro; subst C'; contradiction).
assert (Par A1 A2 C' P) by (apply par_col2_par with C1 C2; Col).
assert(HPar3 : Par_strict A1 A2 C' P) by (apply (par_not_col_strict _ _ _ _ P); Col).
assert(B <> P).
intro.
subst B.
apply (par_not_col _ _ _ _ A1) in HPar3.
apply HPar3; Col.
Col.
assert(P <> C).
intro.
treat_equalities.
absurde.
assert(Col B P B1) by ColR.
assert(Col B P B2) by ColR.
assert(Col C' P C1) by ColR.
assert(Col C P C1) by (assert_cols;ColR).
assert(Col C' P C2) by ColR.
assert(Col C P C2) by (assert_cols;ColR).
assert(~Col B P C) by (intro;apply H11;assert_cols;ColR).
assert(P <> D) by (intro; subst D; apply bet_col in H16; contradiction).
assert(HE := HTE P B C D A1 H17 H16 H29).
ex_and HE X; ex_and H30 Y.
assert(Hx := l12_6 A1 A2 P X).
assert (P<>X) by (intro;treat_equalities;intuition).
assert(Par_strict A1 A2 P X) by (apply (par_strict_col2_par_strict _ _ B1 B2); Col; apply col3 with B P; Col).
apply Hx in H34.
assert(Hy := l12_6 A1 A2 P Y).
assert (P<>Y) by (intro;treat_equalities;intuition).
assert(HPar4 : Par_strict A1 A2 P Y) by (apply (par_strict_col2_par_strict _ _ C1 C2); Col; apply (col3 C P); Col).
apply Hy in HPar4.

*****
HPar4 : OS A1 A2 P Y
H35 : not (eq P Y)
Hy : forall _ : Par_strict A1 A2 P Y, OS A1 A2 P Y
H34 : OS A1 A2 P X
H33 : not (eq P X)
Hx : forall _ : Par_strict A1 A2 P X, OS A1 A2 P X
H32 : Bet X A1 Y
H31 : Bet P C Y
H30 : Bet P B X
X,Y : Tpoint
H29 : not (eq P D)
H28 : not (Col B P C)
H27 : Col C P C2
H26 : Col C' P C2
H25 : Col C P C1
H24 : Col C' P C1
H23 : Col B P B2
H22 : Col B P B1
H21 : not (eq P C)
H20 : not (eq B P)
HPar3 : Par_strict A1 A2 C' P
H19 : Par A1 A2 C' P
H18 : not (eq C' P)
H17 : Bet P D A1
H16 : Bet B D C
D : Tpoint
H15 : Cong C' P P C
H14 : Bet C' P C
C : Tpoint
H13 : Bet A1 B C'
H12 : Col B B1 B2
B : Tpoint
H10 : not (Col A1 B1 B2)
H11 : not (Col C' B1 B2)
H9 : not (Col A1 B1 B2)
H8 : Col C1 C2 C'
C' : Tpoint
HLine : or (not (Col C1 B1 B2)) (not (Col C2 B1 B2))
HPar2 : Par_strict A1 A2 C1 C2
HPar1 : Par_strict A1 A2 B1 B2
H3 : Col P C1 C2
H5 : not (eq C1 C2)
H4 : not (eq A1 A2)
H2 : Par A1 A2 C1 C2
H1 : Col P B1 B2
H7 : not (eq B1 B2)
H6 : not (eq A1 A2)
H0 : Par A1 A2 B1 B2
H : not (Col P A1 A2)
A1,A2,B1,B2,C1,C2,P : Tpoint
HTE : tarski_s_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Col C1 B1 B2) (Col C2 B1 B2)
+++++
assert(HOS : OS A1 A2 X Y) by (apply one_side_transitivity with P; try assumption; unfold OS in *; ex_and H34 Z; exists Z; split; assumption).
-----
Lemma tarski_s_euclid_implies_playfair : tarski_s_parallel_postulate -> playfair_s_postulate.
Proof.
assert (HAux: tarski_s_parallel_postulate -> forall A1 A2 B1 B2 C1 C2 P, ~ Col P A1 A2 -> Par A1 A2 B1 B2 -> Col P B1 B2 -> Par A1 A2 C1 C2 -> Col P C1 C2 -> Col C1 B1 B2 /\\ Col C2 B1 B2).
intros HTE; intros.
apply par_distincts in H0.
apply par_distincts in H2.
spliter.
assert(HPar1 : Par_strict A1 A2 B1 B2) by (apply (par_not_col_strict _ _ _ _ P); Col; intro; apply H; Col).
assert(HPar2 : Par_strict A1 A2 C1 C2) by (apply (par_not_col_strict _ _ _ _ P); Col; intro; apply H; Col).
elim (line_dec B1 B2 C1 C2); intro HLine.
assumption.
assert (HLineNew : ~ Col C1 B1 B2 \\/ ~ Col C2 B1 B2) by (induction (col_dec C1 B1 B2); induction (col_dec C2 B1 B2);tauto).
clear HLine; rename HLineNew into HLine.
assert(HC' : exists C', Col C1 C2 C' /\\ TS B1 B2 A1 C').
ex_and HC' C'.
unfold TS in H9.
assert (~ Col A1 B1 B2) by (spliter; auto).
spliter.
ex_and H12 B.
double C' P C.
unfold Midpoint in H14.
spliter.
assert(HD : exists D, Bet B D C /\\ Bet P D A1) by (apply inner_pasch with C'; Between).
ex_and HD D.
assert(C' <> P) by (intro; subst C'; contradiction).
assert (Par A1 A2 C' P) by (apply par_col2_par with C1 C2; Col).
assert(HPar3 : Par_strict A1 A2 C' P) by (apply (par_not_col_strict _ _ _ _ P); Col).
assert(B <> P).
intro.
subst B.
apply (par_not_col _ _ _ _ A1) in HPar3.
apply HPar3; Col.
Col.
assert(P <> C).
intro.
treat_equalities.
absurde.
assert(Col B P B1) by ColR.
assert(Col B P B2) by ColR.
assert(Col C' P C1) by ColR.
assert(Col C P C1) by (assert_cols;ColR).
assert(Col C' P C2) by ColR.
assert(Col C P C2) by (assert_cols;ColR).
assert(~Col B P C) by (intro;apply H11;assert_cols;ColR).
assert(P <> D) by (intro; subst D; apply bet_col in H16; contradiction).
assert(HE := HTE P B C D A1 H17 H16 H29).
ex_and HE X; ex_and H30 Y.
assert(Hx := l12_6 A1 A2 P X).
assert (P<>X) by (intro;treat_equalities;intuition).
assert(Par_strict A1 A2 P X) by (apply (par_strict_col2_par_strict _ _ B1 B2); Col; apply col3 with B P; Col).
apply Hx in H34.
assert(Hy := l12_6 A1 A2 P Y).
assert (P<>Y) by (intro;treat_equalities;intuition).
assert(HPar4 : Par_strict A1 A2 P Y) by (apply (par_strict_col2_par_strict _ _ C1 C2); Col; apply (col3 C P); Col).
apply Hy in HPar4.
assert(HOS : OS A1 A2 X Y) by (apply one_side_transitivity with P; try assumption; unfold OS in *; ex_and H34 Z; exists Z; split; assumption).

*****
HOS : OS A1 A2 X Y
HPar4 : OS A1 A2 P Y
H35 : not (eq P Y)
Hy : forall _ : Par_strict A1 A2 P Y, OS A1 A2 P Y
H34 : OS A1 A2 P X
H33 : not (eq P X)
Hx : forall _ : Par_strict A1 A2 P X, OS A1 A2 P X
H32 : Bet X A1 Y
H31 : Bet P C Y
H30 : Bet P B X
X,Y : Tpoint
H29 : not (eq P D)
H28 : not (Col B P C)
H27 : Col C P C2
H26 : Col C' P C2
H25 : Col C P C1
H24 : Col C' P C1
H23 : Col B P B2
H22 : Col B P B1
H21 : not (eq P C)
H20 : not (eq B P)
HPar3 : Par_strict A1 A2 C' P
H19 : Par A1 A2 C' P
H18 : not (eq C' P)
H17 : Bet P D A1
H16 : Bet B D C
D : Tpoint
H15 : Cong C' P P C
H14 : Bet C' P C
C : Tpoint
H13 : Bet A1 B C'
H12 : Col B B1 B2
B : Tpoint
H10 : not (Col A1 B1 B2)
H11 : not (Col C' B1 B2)
H9 : not (Col A1 B1 B2)
H8 : Col C1 C2 C'
C' : Tpoint
HLine : or (not (Col C1 B1 B2)) (not (Col C2 B1 B2))
HPar2 : Par_strict A1 A2 C1 C2
HPar1 : Par_strict A1 A2 B1 B2
H3 : Col P C1 C2
H5 : not (eq C1 C2)
H4 : not (eq A1 A2)
H2 : Par A1 A2 C1 C2
H1 : Col P B1 B2
H7 : not (eq B1 B2)
H6 : not (eq A1 A2)
H0 : Par A1 A2 B1 B2
H : not (Col P A1 A2)
A1,A2,B1,B2,C1,C2,P : Tpoint
HTE : tarski_s_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Col C1 B1 B2) (Col C2 B1 B2)
+++++
assert(Ho := HOS).
-----
Lemma tarski_s_euclid_implies_playfair : tarski_s_parallel_postulate -> playfair_s_postulate.
Proof.
assert (HAux: tarski_s_parallel_postulate -> forall A1 A2 B1 B2 C1 C2 P, ~ Col P A1 A2 -> Par A1 A2 B1 B2 -> Col P B1 B2 -> Par A1 A2 C1 C2 -> Col P C1 C2 -> Col C1 B1 B2 /\\ Col C2 B1 B2).
intros HTE; intros.
apply par_distincts in H0.
apply par_distincts in H2.
spliter.
assert(HPar1 : Par_strict A1 A2 B1 B2) by (apply (par_not_col_strict _ _ _ _ P); Col; intro; apply H; Col).
assert(HPar2 : Par_strict A1 A2 C1 C2) by (apply (par_not_col_strict _ _ _ _ P); Col; intro; apply H; Col).
elim (line_dec B1 B2 C1 C2); intro HLine.
assumption.
assert (HLineNew : ~ Col C1 B1 B2 \\/ ~ Col C2 B1 B2) by (induction (col_dec C1 B1 B2); induction (col_dec C2 B1 B2);tauto).
clear HLine; rename HLineNew into HLine.
assert(HC' : exists C', Col C1 C2 C' /\\ TS B1 B2 A1 C').
ex_and HC' C'.
unfold TS in H9.
assert (~ Col A1 B1 B2) by (spliter; auto).
spliter.
ex_and H12 B.
double C' P C.
unfold Midpoint in H14.
spliter.
assert(HD : exists D, Bet B D C /\\ Bet P D A1) by (apply inner_pasch with C'; Between).
ex_and HD D.
assert(C' <> P) by (intro; subst C'; contradiction).
assert (Par A1 A2 C' P) by (apply par_col2_par with C1 C2; Col).
assert(HPar3 : Par_strict A1 A2 C' P) by (apply (par_not_col_strict _ _ _ _ P); Col).
assert(B <> P).
intro.
subst B.
apply (par_not_col _ _ _ _ A1) in HPar3.
apply HPar3; Col.
Col.
assert(P <> C).
intro.
treat_equalities.
absurde.
assert(Col B P B1) by ColR.
assert(Col B P B2) by ColR.
assert(Col C' P C1) by ColR.
assert(Col C P C1) by (assert_cols;ColR).
assert(Col C' P C2) by ColR.
assert(Col C P C2) by (assert_cols;ColR).
assert(~Col B P C) by (intro;apply H11;assert_cols;ColR).
assert(P <> D) by (intro; subst D; apply bet_col in H16; contradiction).
assert(HE := HTE P B C D A1 H17 H16 H29).
ex_and HE X; ex_and H30 Y.
assert(Hx := l12_6 A1 A2 P X).
assert (P<>X) by (intro;treat_equalities;intuition).
assert(Par_strict A1 A2 P X) by (apply (par_strict_col2_par_strict _ _ B1 B2); Col; apply col3 with B P; Col).
apply Hx in H34.
assert(Hy := l12_6 A1 A2 P Y).
assert (P<>Y) by (intro;treat_equalities;intuition).
assert(HPar4 : Par_strict A1 A2 P Y) by (apply (par_strict_col2_par_strict _ _ C1 C2); Col; apply (col3 C P); Col).
apply Hy in HPar4.
assert(HOS : OS A1 A2 X Y) by (apply one_side_transitivity with P; try assumption; unfold OS in *; ex_and H34 Z; exists Z; split; assumption).
assert(Ho := HOS).

*****
HOS,Ho : OS A1 A2 X Y
HPar4 : OS A1 A2 P Y
H35 : not (eq P Y)
Hy : forall _ : Par_strict A1 A2 P Y, OS A1 A2 P Y
H34 : OS A1 A2 P X
H33 : not (eq P X)
Hx : forall _ : Par_strict A1 A2 P X, OS A1 A2 P X
H32 : Bet X A1 Y
H31 : Bet P C Y
H30 : Bet P B X
X,Y : Tpoint
H29 : not (eq P D)
H28 : not (Col B P C)
H27 : Col C P C2
H26 : Col C' P C2
H25 : Col C P C1
H24 : Col C' P C1
H23 : Col B P B2
H22 : Col B P B1
H21 : not (eq P C)
H20 : not (eq B P)
HPar3 : Par_strict A1 A2 C' P
H19 : Par A1 A2 C' P
H18 : not (eq C' P)
H17 : Bet P D A1
H16 : Bet B D C
D : Tpoint
H15 : Cong C' P P C
H14 : Bet C' P C
C : Tpoint
H13 : Bet A1 B C'
H12 : Col B B1 B2
B : Tpoint
H10 : not (Col A1 B1 B2)
H11 : not (Col C' B1 B2)
H9 : not (Col A1 B1 B2)
H8 : Col C1 C2 C'
C' : Tpoint
HLine : or (not (Col C1 B1 B2)) (not (Col C2 B1 B2))
HPar2 : Par_strict A1 A2 C1 C2
HPar1 : Par_strict A1 A2 B1 B2
H3 : Col P C1 C2
H5 : not (eq C1 C2)
H4 : not (eq A1 A2)
H2 : Par A1 A2 C1 C2
H1 : Col P B1 B2
H7 : not (eq B1 B2)
H6 : not (eq A1 A2)
H0 : Par A1 A2 B1 B2
H : not (Col P A1 A2)
A1,A2,B1,B2,C1,C2,P : Tpoint
HTE : tarski_s_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Col C1 B1 B2) (Col C2 B1 B2)
+++++
unfold OS in HOS.
-----
Lemma tarski_s_euclid_implies_playfair : tarski_s_parallel_postulate -> playfair_s_postulate.
Proof.
assert (HAux: tarski_s_parallel_postulate -> forall A1 A2 B1 B2 C1 C2 P, ~ Col P A1 A2 -> Par A1 A2 B1 B2 -> Col P B1 B2 -> Par A1 A2 C1 C2 -> Col P C1 C2 -> Col C1 B1 B2 /\\ Col C2 B1 B2).
intros HTE; intros.
apply par_distincts in H0.
apply par_distincts in H2.
spliter.
assert(HPar1 : Par_strict A1 A2 B1 B2) by (apply (par_not_col_strict _ _ _ _ P); Col; intro; apply H; Col).
assert(HPar2 : Par_strict A1 A2 C1 C2) by (apply (par_not_col_strict _ _ _ _ P); Col; intro; apply H; Col).
elim (line_dec B1 B2 C1 C2); intro HLine.
assumption.
assert (HLineNew : ~ Col C1 B1 B2 \\/ ~ Col C2 B1 B2) by (induction (col_dec C1 B1 B2); induction (col_dec C2 B1 B2);tauto).
clear HLine; rename HLineNew into HLine.
assert(HC' : exists C', Col C1 C2 C' /\\ TS B1 B2 A1 C').
ex_and HC' C'.
unfold TS in H9.
assert (~ Col A1 B1 B2) by (spliter; auto).
spliter.
ex_and H12 B.
double C' P C.
unfold Midpoint in H14.
spliter.
assert(HD : exists D, Bet B D C /\\ Bet P D A1) by (apply inner_pasch with C'; Between).
ex_and HD D.
assert(C' <> P) by (intro; subst C'; contradiction).
assert (Par A1 A2 C' P) by (apply par_col2_par with C1 C2; Col).
assert(HPar3 : Par_strict A1 A2 C' P) by (apply (par_not_col_strict _ _ _ _ P); Col).
assert(B <> P).
intro.
subst B.
apply (par_not_col _ _ _ _ A1) in HPar3.
apply HPar3; Col.
Col.
assert(P <> C).
intro.
treat_equalities.
absurde.
assert(Col B P B1) by ColR.
assert(Col B P B2) by ColR.
assert(Col C' P C1) by ColR.
assert(Col C P C1) by (assert_cols;ColR).
assert(Col C' P C2) by ColR.
assert(Col C P C2) by (assert_cols;ColR).
assert(~Col B P C) by (intro;apply H11;assert_cols;ColR).
assert(P <> D) by (intro; subst D; apply bet_col in H16; contradiction).
assert(HE := HTE P B C D A1 H17 H16 H29).
ex_and HE X; ex_and H30 Y.
assert(Hx := l12_6 A1 A2 P X).
assert (P<>X) by (intro;treat_equalities;intuition).
assert(Par_strict A1 A2 P X) by (apply (par_strict_col2_par_strict _ _ B1 B2); Col; apply col3 with B P; Col).
apply Hx in H34.
assert(Hy := l12_6 A1 A2 P Y).
assert (P<>Y) by (intro;treat_equalities;intuition).
assert(HPar4 : Par_strict A1 A2 P Y) by (apply (par_strict_col2_par_strict _ _ C1 C2); Col; apply (col3 C P); Col).
apply Hy in HPar4.
assert(HOS : OS A1 A2 X Y) by (apply one_side_transitivity with P; try assumption; unfold OS in *; ex_and H34 Z; exists Z; split; assumption).
assert(Ho := HOS).
unfold OS in HOS.

*****
Ho : OS A1 A2 X Y
HOS : ex (fun R : Tpoint => and (TS A1 A2 X R) (TS A1 A2 Y R))
HPar4 : OS A1 A2 P Y
H35 : not (eq P Y)
Hy : forall _ : Par_strict A1 A2 P Y, OS A1 A2 P Y
H34 : OS A1 A2 P X
H33 : not (eq P X)
Hx : forall _ : Par_strict A1 A2 P X, OS A1 A2 P X
H32 : Bet X A1 Y
H31 : Bet P C Y
H30 : Bet P B X
X,Y : Tpoint
H29 : not (eq P D)
H28 : not (Col B P C)
H27 : Col C P C2
H26 : Col C' P C2
H25 : Col C P C1
H24 : Col C' P C1
H23 : Col B P B2
H22 : Col B P B1
H21 : not (eq P C)
H20 : not (eq B P)
HPar3 : Par_strict A1 A2 C' P
H19 : Par A1 A2 C' P
H18 : not (eq C' P)
H17 : Bet P D A1
H16 : Bet B D C
D : Tpoint
H15 : Cong C' P P C
H14 : Bet C' P C
C : Tpoint
H13 : Bet A1 B C'
H12 : Col B B1 B2
B : Tpoint
H10 : not (Col A1 B1 B2)
H11 : not (Col C' B1 B2)
H9 : not (Col A1 B1 B2)
H8 : Col C1 C2 C'
C' : Tpoint
HLine : or (not (Col C1 B1 B2)) (not (Col C2 B1 B2))
HPar2 : Par_strict A1 A2 C1 C2
HPar1 : Par_strict A1 A2 B1 B2
H3 : Col P C1 C2
H5 : not (eq C1 C2)
H4 : not (eq A1 A2)
H2 : Par A1 A2 C1 C2
H1 : Col P B1 B2
H7 : not (eq B1 B2)
H6 : not (eq A1 A2)
H0 : Par A1 A2 B1 B2
H : not (Col P A1 A2)
A1,A2,B1,B2,C1,C2,P : Tpoint
HTE : tarski_s_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Col C1 B1 B2) (Col C2 B1 B2)
+++++
ex_and HOS Z.
-----
Lemma tarski_s_euclid_implies_playfair : tarski_s_parallel_postulate -> playfair_s_postulate.
Proof.
assert (HAux: tarski_s_parallel_postulate -> forall A1 A2 B1 B2 C1 C2 P, ~ Col P A1 A2 -> Par A1 A2 B1 B2 -> Col P B1 B2 -> Par A1 A2 C1 C2 -> Col P C1 C2 -> Col C1 B1 B2 /\\ Col C2 B1 B2).
intros HTE; intros.
apply par_distincts in H0.
apply par_distincts in H2.
spliter.
assert(HPar1 : Par_strict A1 A2 B1 B2) by (apply (par_not_col_strict _ _ _ _ P); Col; intro; apply H; Col).
assert(HPar2 : Par_strict A1 A2 C1 C2) by (apply (par_not_col_strict _ _ _ _ P); Col; intro; apply H; Col).
elim (line_dec B1 B2 C1 C2); intro HLine.
assumption.
assert (HLineNew : ~ Col C1 B1 B2 \\/ ~ Col C2 B1 B2) by (induction (col_dec C1 B1 B2); induction (col_dec C2 B1 B2);tauto).
clear HLine; rename HLineNew into HLine.
assert(HC' : exists C', Col C1 C2 C' /\\ TS B1 B2 A1 C').
ex_and HC' C'.
unfold TS in H9.
assert (~ Col A1 B1 B2) by (spliter; auto).
spliter.
ex_and H12 B.
double C' P C.
unfold Midpoint in H14.
spliter.
assert(HD : exists D, Bet B D C /\\ Bet P D A1) by (apply inner_pasch with C'; Between).
ex_and HD D.
assert(C' <> P) by (intro; subst C'; contradiction).
assert (Par A1 A2 C' P) by (apply par_col2_par with C1 C2; Col).
assert(HPar3 : Par_strict A1 A2 C' P) by (apply (par_not_col_strict _ _ _ _ P); Col).
assert(B <> P).
intro.
subst B.
apply (par_not_col _ _ _ _ A1) in HPar3.
apply HPar3; Col.
Col.
assert(P <> C).
intro.
treat_equalities.
absurde.
assert(Col B P B1) by ColR.
assert(Col B P B2) by ColR.
assert(Col C' P C1) by ColR.
assert(Col C P C1) by (assert_cols;ColR).
assert(Col C' P C2) by ColR.
assert(Col C P C2) by (assert_cols;ColR).
assert(~Col B P C) by (intro;apply H11;assert_cols;ColR).
assert(P <> D) by (intro; subst D; apply bet_col in H16; contradiction).
assert(HE := HTE P B C D A1 H17 H16 H29).
ex_and HE X; ex_and H30 Y.
assert(Hx := l12_6 A1 A2 P X).
assert (P<>X) by (intro;treat_equalities;intuition).
assert(Par_strict A1 A2 P X) by (apply (par_strict_col2_par_strict _ _ B1 B2); Col; apply col3 with B P; Col).
apply Hx in H34.
assert(Hy := l12_6 A1 A2 P Y).
assert (P<>Y) by (intro;treat_equalities;intuition).
assert(HPar4 : Par_strict A1 A2 P Y) by (apply (par_strict_col2_par_strict _ _ C1 C2); Col; apply (col3 C P); Col).
apply Hy in HPar4.
assert(HOS : OS A1 A2 X Y) by (apply one_side_transitivity with P; try assumption; unfold OS in *; ex_and H34 Z; exists Z; split; assumption).
assert(Ho := HOS).
unfold OS in HOS.
ex_and HOS Z.

*****
H37 : TS A1 A2 Y Z
H36 : TS A1 A2 X Z
Z : Tpoint
Ho : OS A1 A2 X Y
HPar4 : OS A1 A2 P Y
H35 : not (eq P Y)
Hy : forall _ : Par_strict A1 A2 P Y, OS A1 A2 P Y
H34 : OS A1 A2 P X
H33 : not (eq P X)
Hx : forall _ : Par_strict A1 A2 P X, OS A1 A2 P X
H32 : Bet X A1 Y
H31 : Bet P C Y
H30 : Bet P B X
X,Y : Tpoint
H29 : not (eq P D)
H28 : not (Col B P C)
H27 : Col C P C2
H26 : Col C' P C2
H25 : Col C P C1
H24 : Col C' P C1
H23 : Col B P B2
H22 : Col B P B1
H21 : not (eq P C)
H20 : not (eq B P)
HPar3 : Par_strict A1 A2 C' P
H19 : Par A1 A2 C' P
H18 : not (eq C' P)
H17 : Bet P D A1
H16 : Bet B D C
D : Tpoint
H15 : Cong C' P P C
H14 : Bet C' P C
C : Tpoint
H13 : Bet A1 B C'
H12 : Col B B1 B2
B : Tpoint
H10 : not (Col A1 B1 B2)
H11 : not (Col C' B1 B2)
H9 : not (Col A1 B1 B2)
H8 : Col C1 C2 C'
C' : Tpoint
HLine : or (not (Col C1 B1 B2)) (not (Col C2 B1 B2))
HPar2 : Par_strict A1 A2 C1 C2
HPar1 : Par_strict A1 A2 B1 B2
H3 : Col P C1 C2
H5 : not (eq C1 C2)
H4 : not (eq A1 A2)
H2 : Par A1 A2 C1 C2
H1 : Col P B1 B2
H7 : not (eq B1 B2)
H6 : not (eq A1 A2)
H0 : Par A1 A2 B1 B2
H : not (Col P A1 A2)
A1,A2,B1,B2,C1,C2,P : Tpoint
HTE : tarski_s_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Col C1 B1 B2) (Col C2 B1 B2)
+++++
unfold TS in H36.
-----
Lemma tarski_s_euclid_implies_playfair : tarski_s_parallel_postulate -> playfair_s_postulate.
Proof.
assert (HAux: tarski_s_parallel_postulate -> forall A1 A2 B1 B2 C1 C2 P, ~ Col P A1 A2 -> Par A1 A2 B1 B2 -> Col P B1 B2 -> Par A1 A2 C1 C2 -> Col P C1 C2 -> Col C1 B1 B2 /\\ Col C2 B1 B2).
intros HTE; intros.
apply par_distincts in H0.
apply par_distincts in H2.
spliter.
assert(HPar1 : Par_strict A1 A2 B1 B2) by (apply (par_not_col_strict _ _ _ _ P); Col; intro; apply H; Col).
assert(HPar2 : Par_strict A1 A2 C1 C2) by (apply (par_not_col_strict _ _ _ _ P); Col; intro; apply H; Col).
elim (line_dec B1 B2 C1 C2); intro HLine.
assumption.
assert (HLineNew : ~ Col C1 B1 B2 \\/ ~ Col C2 B1 B2) by (induction (col_dec C1 B1 B2); induction (col_dec C2 B1 B2);tauto).
clear HLine; rename HLineNew into HLine.
assert(HC' : exists C', Col C1 C2 C' /\\ TS B1 B2 A1 C').
ex_and HC' C'.
unfold TS in H9.
assert (~ Col A1 B1 B2) by (spliter; auto).
spliter.
ex_and H12 B.
double C' P C.
unfold Midpoint in H14.
spliter.
assert(HD : exists D, Bet B D C /\\ Bet P D A1) by (apply inner_pasch with C'; Between).
ex_and HD D.
assert(C' <> P) by (intro; subst C'; contradiction).
assert (Par A1 A2 C' P) by (apply par_col2_par with C1 C2; Col).
assert(HPar3 : Par_strict A1 A2 C' P) by (apply (par_not_col_strict _ _ _ _ P); Col).
assert(B <> P).
intro.
subst B.
apply (par_not_col _ _ _ _ A1) in HPar3.
apply HPar3; Col.
Col.
assert(P <> C).
intro.
treat_equalities.
absurde.
assert(Col B P B1) by ColR.
assert(Col B P B2) by ColR.
assert(Col C' P C1) by ColR.
assert(Col C P C1) by (assert_cols;ColR).
assert(Col C' P C2) by ColR.
assert(Col C P C2) by (assert_cols;ColR).
assert(~Col B P C) by (intro;apply H11;assert_cols;ColR).
assert(P <> D) by (intro; subst D; apply bet_col in H16; contradiction).
assert(HE := HTE P B C D A1 H17 H16 H29).
ex_and HE X; ex_and H30 Y.
assert(Hx := l12_6 A1 A2 P X).
assert (P<>X) by (intro;treat_equalities;intuition).
assert(Par_strict A1 A2 P X) by (apply (par_strict_col2_par_strict _ _ B1 B2); Col; apply col3 with B P; Col).
apply Hx in H34.
assert(Hy := l12_6 A1 A2 P Y).
assert (P<>Y) by (intro;treat_equalities;intuition).
assert(HPar4 : Par_strict A1 A2 P Y) by (apply (par_strict_col2_par_strict _ _ C1 C2); Col; apply (col3 C P); Col).
apply Hy in HPar4.
assert(HOS : OS A1 A2 X Y) by (apply one_side_transitivity with P; try assumption; unfold OS in *; ex_and H34 Z; exists Z; split; assumption).
assert(Ho := HOS).
unfold OS in HOS.
ex_and HOS Z.
unfold TS in H36.

*****
H37 : TS A1 A2 Y Z
H36 : and (not (Col X A1 A2))\n (and (not (Col Z A1 A2))\n (ex (fun T : Tpoint => and (Col T A1 A2) (Bet X T Z))))
Z : Tpoint
Ho : OS A1 A2 X Y
HPar4 : OS A1 A2 P Y
H35 : not (eq P Y)
Hy : forall _ : Par_strict A1 A2 P Y, OS A1 A2 P Y
H34 : OS A1 A2 P X
H33 : not (eq P X)
Hx : forall _ : Par_strict A1 A2 P X, OS A1 A2 P X
H32 : Bet X A1 Y
H31 : Bet P C Y
H30 : Bet P B X
X,Y : Tpoint
H29 : not (eq P D)
H28 : not (Col B P C)
H27 : Col C P C2
H26 : Col C' P C2
H25 : Col C P C1
H24 : Col C' P C1
H23 : Col B P B2
H22 : Col B P B1
H21 : not (eq P C)
H20 : not (eq B P)
HPar3 : Par_strict A1 A2 C' P
H19 : Par A1 A2 C' P
H18 : not (eq C' P)
H17 : Bet P D A1
H16 : Bet B D C
D : Tpoint
H15 : Cong C' P P C
H14 : Bet C' P C
C : Tpoint
H13 : Bet A1 B C'
H12 : Col B B1 B2
B : Tpoint
H10 : not (Col A1 B1 B2)
H11 : not (Col C' B1 B2)
H9 : not (Col A1 B1 B2)
H8 : Col C1 C2 C'
C' : Tpoint
HLine : or (not (Col C1 B1 B2)) (not (Col C2 B1 B2))
HPar2 : Par_strict A1 A2 C1 C2
HPar1 : Par_strict A1 A2 B1 B2
H3 : Col P C1 C2
H5 : not (eq C1 C2)
H4 : not (eq A1 A2)
H2 : Par A1 A2 C1 C2
H1 : Col P B1 B2
H7 : not (eq B1 B2)
H6 : not (eq A1 A2)
H0 : Par A1 A2 B1 B2
H : not (Col P A1 A2)
A1,A2,B1,B2,C1,C2,P : Tpoint
HTE : tarski_s_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Col C1 B1 B2) (Col C2 B1 B2)
+++++
unfold TS in H37.
-----
Lemma tarski_s_euclid_implies_playfair : tarski_s_parallel_postulate -> playfair_s_postulate.
Proof.
assert (HAux: tarski_s_parallel_postulate -> forall A1 A2 B1 B2 C1 C2 P, ~ Col P A1 A2 -> Par A1 A2 B1 B2 -> Col P B1 B2 -> Par A1 A2 C1 C2 -> Col P C1 C2 -> Col C1 B1 B2 /\\ Col C2 B1 B2).
intros HTE; intros.
apply par_distincts in H0.
apply par_distincts in H2.
spliter.
assert(HPar1 : Par_strict A1 A2 B1 B2) by (apply (par_not_col_strict _ _ _ _ P); Col; intro; apply H; Col).
assert(HPar2 : Par_strict A1 A2 C1 C2) by (apply (par_not_col_strict _ _ _ _ P); Col; intro; apply H; Col).
elim (line_dec B1 B2 C1 C2); intro HLine.
assumption.
assert (HLineNew : ~ Col C1 B1 B2 \\/ ~ Col C2 B1 B2) by (induction (col_dec C1 B1 B2); induction (col_dec C2 B1 B2);tauto).
clear HLine; rename HLineNew into HLine.
assert(HC' : exists C', Col C1 C2 C' /\\ TS B1 B2 A1 C').
ex_and HC' C'.
unfold TS in H9.
assert (~ Col A1 B1 B2) by (spliter; auto).
spliter.
ex_and H12 B.
double C' P C.
unfold Midpoint in H14.
spliter.
assert(HD : exists D, Bet B D C /\\ Bet P D A1) by (apply inner_pasch with C'; Between).
ex_and HD D.
assert(C' <> P) by (intro; subst C'; contradiction).
assert (Par A1 A2 C' P) by (apply par_col2_par with C1 C2; Col).
assert(HPar3 : Par_strict A1 A2 C' P) by (apply (par_not_col_strict _ _ _ _ P); Col).
assert(B <> P).
intro.
subst B.
apply (par_not_col _ _ _ _ A1) in HPar3.
apply HPar3; Col.
Col.
assert(P <> C).
intro.
treat_equalities.
absurde.
assert(Col B P B1) by ColR.
assert(Col B P B2) by ColR.
assert(Col C' P C1) by ColR.
assert(Col C P C1) by (assert_cols;ColR).
assert(Col C' P C2) by ColR.
assert(Col C P C2) by (assert_cols;ColR).
assert(~Col B P C) by (intro;apply H11;assert_cols;ColR).
assert(P <> D) by (intro; subst D; apply bet_col in H16; contradiction).
assert(HE := HTE P B C D A1 H17 H16 H29).
ex_and HE X; ex_and H30 Y.
assert(Hx := l12_6 A1 A2 P X).
assert (P<>X) by (intro;treat_equalities;intuition).
assert(Par_strict A1 A2 P X) by (apply (par_strict_col2_par_strict _ _ B1 B2); Col; apply col3 with B P; Col).
apply Hx in H34.
assert(Hy := l12_6 A1 A2 P Y).
assert (P<>Y) by (intro;treat_equalities;intuition).
assert(HPar4 : Par_strict A1 A2 P Y) by (apply (par_strict_col2_par_strict _ _ C1 C2); Col; apply (col3 C P); Col).
apply Hy in HPar4.
assert(HOS : OS A1 A2 X Y) by (apply one_side_transitivity with P; try assumption; unfold OS in *; ex_and H34 Z; exists Z; split; assumption).
assert(Ho := HOS).
unfold OS in HOS.
ex_and HOS Z.
unfold TS in H36.
unfold TS in H37.

*****
H37 : and (not (Col Y A1 A2))\n (and (not (Col Z A1 A2))\n (ex (fun T : Tpoint => and (Col T A1 A2) (Bet Y T Z))))
H36 : and (not (Col X A1 A2))\n (and (not (Col Z A1 A2))\n (ex (fun T : Tpoint => and (Col T A1 A2) (Bet X T Z))))
Z : Tpoint
Ho : OS A1 A2 X Y
HPar4 : OS A1 A2 P Y
H35 : not (eq P Y)
Hy : forall _ : Par_strict A1 A2 P Y, OS A1 A2 P Y
H34 : OS A1 A2 P X
H33 : not (eq P X)
Hx : forall _ : Par_strict A1 A2 P X, OS A1 A2 P X
H32 : Bet X A1 Y
H31 : Bet P C Y
H30 : Bet P B X
X,Y : Tpoint
H29 : not (eq P D)
H28 : not (Col B P C)
H27 : Col C P C2
H26 : Col C' P C2
H25 : Col C P C1
H24 : Col C' P C1
H23 : Col B P B2
H22 : Col B P B1
H21 : not (eq P C)
H20 : not (eq B P)
HPar3 : Par_strict A1 A2 C' P
H19 : Par A1 A2 C' P
H18 : not (eq C' P)
H17 : Bet P D A1
H16 : Bet B D C
D : Tpoint
H15 : Cong C' P P C
H14 : Bet C' P C
C : Tpoint
H13 : Bet A1 B C'
H12 : Col B B1 B2
B : Tpoint
H10 : not (Col A1 B1 B2)
H11 : not (Col C' B1 B2)
H9 : not (Col A1 B1 B2)
H8 : Col C1 C2 C'
C' : Tpoint
HLine : or (not (Col C1 B1 B2)) (not (Col C2 B1 B2))
HPar2 : Par_strict A1 A2 C1 C2
HPar1 : Par_strict A1 A2 B1 B2
H3 : Col P C1 C2
H5 : not (eq C1 C2)
H4 : not (eq A1 A2)
H2 : Par A1 A2 C1 C2
H1 : Col P B1 B2
H7 : not (eq B1 B2)
H6 : not (eq A1 A2)
H0 : Par A1 A2 B1 B2
H : not (Col P A1 A2)
A1,A2,B1,B2,C1,C2,P : Tpoint
HTE : tarski_s_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Col C1 B1 B2) (Col C2 B1 B2)
+++++
spliter.
-----
Lemma tarski_s_euclid_implies_playfair : tarski_s_parallel_postulate -> playfair_s_postulate.
Proof.
assert (HAux: tarski_s_parallel_postulate -> forall A1 A2 B1 B2 C1 C2 P, ~ Col P A1 A2 -> Par A1 A2 B1 B2 -> Col P B1 B2 -> Par A1 A2 C1 C2 -> Col P C1 C2 -> Col C1 B1 B2 /\\ Col C2 B1 B2).
intros HTE; intros.
apply par_distincts in H0.
apply par_distincts in H2.
spliter.
assert(HPar1 : Par_strict A1 A2 B1 B2) by (apply (par_not_col_strict _ _ _ _ P); Col; intro; apply H; Col).
assert(HPar2 : Par_strict A1 A2 C1 C2) by (apply (par_not_col_strict _ _ _ _ P); Col; intro; apply H; Col).
elim (line_dec B1 B2 C1 C2); intro HLine.
assumption.
assert (HLineNew : ~ Col C1 B1 B2 \\/ ~ Col C2 B1 B2) by (induction (col_dec C1 B1 B2); induction (col_dec C2 B1 B2);tauto).
clear HLine; rename HLineNew into HLine.
assert(HC' : exists C', Col C1 C2 C' /\\ TS B1 B2 A1 C').
ex_and HC' C'.
unfold TS in H9.
assert (~ Col A1 B1 B2) by (spliter; auto).
spliter.
ex_and H12 B.
double C' P C.
unfold Midpoint in H14.
spliter.
assert(HD : exists D, Bet B D C /\\ Bet P D A1) by (apply inner_pasch with C'; Between).
ex_and HD D.
assert(C' <> P) by (intro; subst C'; contradiction).
assert (Par A1 A2 C' P) by (apply par_col2_par with C1 C2; Col).
assert(HPar3 : Par_strict A1 A2 C' P) by (apply (par_not_col_strict _ _ _ _ P); Col).
assert(B <> P).
intro.
subst B.
apply (par_not_col _ _ _ _ A1) in HPar3.
apply HPar3; Col.
Col.
assert(P <> C).
intro.
treat_equalities.
absurde.
assert(Col B P B1) by ColR.
assert(Col B P B2) by ColR.
assert(Col C' P C1) by ColR.
assert(Col C P C1) by (assert_cols;ColR).
assert(Col C' P C2) by ColR.
assert(Col C P C2) by (assert_cols;ColR).
assert(~Col B P C) by (intro;apply H11;assert_cols;ColR).
assert(P <> D) by (intro; subst D; apply bet_col in H16; contradiction).
assert(HE := HTE P B C D A1 H17 H16 H29).
ex_and HE X; ex_and H30 Y.
assert(Hx := l12_6 A1 A2 P X).
assert (P<>X) by (intro;treat_equalities;intuition).
assert(Par_strict A1 A2 P X) by (apply (par_strict_col2_par_strict _ _ B1 B2); Col; apply col3 with B P; Col).
apply Hx in H34.
assert(Hy := l12_6 A1 A2 P Y).
assert (P<>Y) by (intro;treat_equalities;intuition).
assert(HPar4 : Par_strict A1 A2 P Y) by (apply (par_strict_col2_par_strict _ _ C1 C2); Col; apply (col3 C P); Col).
apply Hy in HPar4.
assert(HOS : OS A1 A2 X Y) by (apply one_side_transitivity with P; try assumption; unfold OS in *; ex_and H34 Z; exists Z; split; assumption).
assert(Ho := HOS).
unfold OS in HOS.
ex_and HOS Z.
unfold TS in H36.
unfold TS in H37.
spliter.

*****
H39 : ex (fun T : Tpoint => and (Col T A1 A2) (Bet Y T Z))
H38 : not (Col Z A1 A2)
H37 : not (Col Y A1 A2)
H41 : ex (fun T : Tpoint => and (Col T A1 A2) (Bet X T Z))
H40 : not (Col Z A1 A2)
H36 : not (Col X A1 A2)
Z : Tpoint
Ho : OS A1 A2 X Y
HPar4 : OS A1 A2 P Y
H35 : not (eq P Y)
Hy : forall _ : Par_strict A1 A2 P Y, OS A1 A2 P Y
H34 : OS A1 A2 P X
H33 : not (eq P X)
Hx : forall _ : Par_strict A1 A2 P X, OS A1 A2 P X
H32 : Bet X A1 Y
H31 : Bet P C Y
H30 : Bet P B X
X,Y : Tpoint
H29 : not (eq P D)
H28 : not (Col B P C)
H27 : Col C P C2
H26 : Col C' P C2
H25 : Col C P C1
H24 : Col C' P C1
H23 : Col B P B2
H22 : Col B P B1
H21 : not (eq P C)
H20 : not (eq B P)
HPar3 : Par_strict A1 A2 C' P
H19 : Par A1 A2 C' P
H18 : not (eq C' P)
H17 : Bet P D A1
H16 : Bet B D C
D : Tpoint
H15 : Cong C' P P C
H14 : Bet C' P C
C : Tpoint
H13 : Bet A1 B C'
H12 : Col B B1 B2
B : Tpoint
H10 : not (Col A1 B1 B2)
H11 : not (Col C' B1 B2)
H9 : not (Col A1 B1 B2)
H8 : Col C1 C2 C'
C' : Tpoint
HLine : or (not (Col C1 B1 B2)) (not (Col C2 B1 B2))
HPar2 : Par_strict A1 A2 C1 C2
HPar1 : Par_strict A1 A2 B1 B2
H3 : Col P C1 C2
H5 : not (eq C1 C2)
H4 : not (eq A1 A2)
H2 : Par A1 A2 C1 C2
H1 : Col P B1 B2
H7 : not (eq B1 B2)
H6 : not (eq A1 A2)
H0 : Par A1 A2 B1 B2
H : not (Col P A1 A2)
A1,A2,B1,B2,C1,C2,P : Tpoint
HTE : tarski_s_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Col C1 B1 B2) (Col C2 B1 B2)
+++++
assert(HTS : TS A1 A2 X Y) by (unfold TS; repeat split; try assumption; exists A1; split; Col).
-----
Lemma tarski_s_euclid_implies_playfair : tarski_s_parallel_postulate -> playfair_s_postulate.
Proof.
assert (HAux: tarski_s_parallel_postulate -> forall A1 A2 B1 B2 C1 C2 P, ~ Col P A1 A2 -> Par A1 A2 B1 B2 -> Col P B1 B2 -> Par A1 A2 C1 C2 -> Col P C1 C2 -> Col C1 B1 B2 /\\ Col C2 B1 B2).
intros HTE; intros.
apply par_distincts in H0.
apply par_distincts in H2.
spliter.
assert(HPar1 : Par_strict A1 A2 B1 B2) by (apply (par_not_col_strict _ _ _ _ P); Col; intro; apply H; Col).
assert(HPar2 : Par_strict A1 A2 C1 C2) by (apply (par_not_col_strict _ _ _ _ P); Col; intro; apply H; Col).
elim (line_dec B1 B2 C1 C2); intro HLine.
assumption.
assert (HLineNew : ~ Col C1 B1 B2 \\/ ~ Col C2 B1 B2) by (induction (col_dec C1 B1 B2); induction (col_dec C2 B1 B2);tauto).
clear HLine; rename HLineNew into HLine.
assert(HC' : exists C', Col C1 C2 C' /\\ TS B1 B2 A1 C').
ex_and HC' C'.
unfold TS in H9.
assert (~ Col A1 B1 B2) by (spliter; auto).
spliter.
ex_and H12 B.
double C' P C.
unfold Midpoint in H14.
spliter.
assert(HD : exists D, Bet B D C /\\ Bet P D A1) by (apply inner_pasch with C'; Between).
ex_and HD D.
assert(C' <> P) by (intro; subst C'; contradiction).
assert (Par A1 A2 C' P) by (apply par_col2_par with C1 C2; Col).
assert(HPar3 : Par_strict A1 A2 C' P) by (apply (par_not_col_strict _ _ _ _ P); Col).
assert(B <> P).
intro.
subst B.
apply (par_not_col _ _ _ _ A1) in HPar3.
apply HPar3; Col.
Col.
assert(P <> C).
intro.
treat_equalities.
absurde.
assert(Col B P B1) by ColR.
assert(Col B P B2) by ColR.
assert(Col C' P C1) by ColR.
assert(Col C P C1) by (assert_cols;ColR).
assert(Col C' P C2) by ColR.
assert(Col C P C2) by (assert_cols;ColR).
assert(~Col B P C) by (intro;apply H11;assert_cols;ColR).
assert(P <> D) by (intro; subst D; apply bet_col in H16; contradiction).
assert(HE := HTE P B C D A1 H17 H16 H29).
ex_and HE X; ex_and H30 Y.
assert(Hx := l12_6 A1 A2 P X).
assert (P<>X) by (intro;treat_equalities;intuition).
assert(Par_strict A1 A2 P X) by (apply (par_strict_col2_par_strict _ _ B1 B2); Col; apply col3 with B P; Col).
apply Hx in H34.
assert(Hy := l12_6 A1 A2 P Y).
assert (P<>Y) by (intro;treat_equalities;intuition).
assert(HPar4 : Par_strict A1 A2 P Y) by (apply (par_strict_col2_par_strict _ _ C1 C2); Col; apply (col3 C P); Col).
apply Hy in HPar4.
assert(HOS : OS A1 A2 X Y) by (apply one_side_transitivity with P; try assumption; unfold OS in *; ex_and H34 Z; exists Z; split; assumption).
assert(Ho := HOS).
unfold OS in HOS.
ex_and HOS Z.
unfold TS in H36.
unfold TS in H37.
spliter.
assert(HTS : TS A1 A2 X Y) by (unfold TS; repeat split; try assumption; exists A1; split; Col).

*****
HTS : TS A1 A2 X Y
H39 : ex (fun T : Tpoint => and (Col T A1 A2) (Bet Y T Z))
H38 : not (Col Z A1 A2)
H37 : not (Col Y A1 A2)
H41 : ex (fun T : Tpoint => and (Col T A1 A2) (Bet X T Z))
H40 : not (Col Z A1 A2)
H36 : not (Col X A1 A2)
Z : Tpoint
Ho : OS A1 A2 X Y
HPar4 : OS A1 A2 P Y
H35 : not (eq P Y)
Hy : forall _ : Par_strict A1 A2 P Y, OS A1 A2 P Y
H34 : OS A1 A2 P X
H33 : not (eq P X)
Hx : forall _ : Par_strict A1 A2 P X, OS A1 A2 P X
H32 : Bet X A1 Y
H31 : Bet P C Y
H30 : Bet P B X
X,Y : Tpoint
H29 : not (eq P D)
H28 : not (Col B P C)
H27 : Col C P C2
H26 : Col C' P C2
H25 : Col C P C1
H24 : Col C' P C1
H23 : Col B P B2
H22 : Col B P B1
H21 : not (eq P C)
H20 : not (eq B P)
HPar3 : Par_strict A1 A2 C' P
H19 : Par A1 A2 C' P
H18 : not (eq C' P)
H17 : Bet P D A1
H16 : Bet B D C
D : Tpoint
H15 : Cong C' P P C
H14 : Bet C' P C
C : Tpoint
H13 : Bet A1 B C'
H12 : Col B B1 B2
B : Tpoint
H10 : not (Col A1 B1 B2)
H11 : not (Col C' B1 B2)
H9 : not (Col A1 B1 B2)
H8 : Col C1 C2 C'
C' : Tpoint
HLine : or (not (Col C1 B1 B2)) (not (Col C2 B1 B2))
HPar2 : Par_strict A1 A2 C1 C2
HPar1 : Par_strict A1 A2 B1 B2
H3 : Col P C1 C2
H5 : not (eq C1 C2)
H4 : not (eq A1 A2)
H2 : Par A1 A2 C1 C2
H1 : Col P B1 B2
H7 : not (eq B1 B2)
H6 : not (eq A1 A2)
H0 : Par A1 A2 B1 B2
H : not (Col P A1 A2)
A1,A2,B1,B2,C1,C2,P : Tpoint
HTE : tarski_s_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Col C1 B1 B2) (Col C2 B1 B2)
+++++
apply l9_9 in HTS.
-----
Lemma tarski_s_euclid_implies_playfair : tarski_s_parallel_postulate -> playfair_s_postulate.
Proof.
assert (HAux: tarski_s_parallel_postulate -> forall A1 A2 B1 B2 C1 C2 P, ~ Col P A1 A2 -> Par A1 A2 B1 B2 -> Col P B1 B2 -> Par A1 A2 C1 C2 -> Col P C1 C2 -> Col C1 B1 B2 /\\ Col C2 B1 B2).
intros HTE; intros.
apply par_distincts in H0.
apply par_distincts in H2.
spliter.
assert(HPar1 : Par_strict A1 A2 B1 B2) by (apply (par_not_col_strict _ _ _ _ P); Col; intro; apply H; Col).
assert(HPar2 : Par_strict A1 A2 C1 C2) by (apply (par_not_col_strict _ _ _ _ P); Col; intro; apply H; Col).
elim (line_dec B1 B2 C1 C2); intro HLine.
assumption.
assert (HLineNew : ~ Col C1 B1 B2 \\/ ~ Col C2 B1 B2) by (induction (col_dec C1 B1 B2); induction (col_dec C2 B1 B2);tauto).
clear HLine; rename HLineNew into HLine.
assert(HC' : exists C', Col C1 C2 C' /\\ TS B1 B2 A1 C').
ex_and HC' C'.
unfold TS in H9.
assert (~ Col A1 B1 B2) by (spliter; auto).
spliter.
ex_and H12 B.
double C' P C.
unfold Midpoint in H14.
spliter.
assert(HD : exists D, Bet B D C /\\ Bet P D A1) by (apply inner_pasch with C'; Between).
ex_and HD D.
assert(C' <> P) by (intro; subst C'; contradiction).
assert (Par A1 A2 C' P) by (apply par_col2_par with C1 C2; Col).
assert(HPar3 : Par_strict A1 A2 C' P) by (apply (par_not_col_strict _ _ _ _ P); Col).
assert(B <> P).
intro.
subst B.
apply (par_not_col _ _ _ _ A1) in HPar3.
apply HPar3; Col.
Col.
assert(P <> C).
intro.
treat_equalities.
absurde.
assert(Col B P B1) by ColR.
assert(Col B P B2) by ColR.
assert(Col C' P C1) by ColR.
assert(Col C P C1) by (assert_cols;ColR).
assert(Col C' P C2) by ColR.
assert(Col C P C2) by (assert_cols;ColR).
assert(~Col B P C) by (intro;apply H11;assert_cols;ColR).
assert(P <> D) by (intro; subst D; apply bet_col in H16; contradiction).
assert(HE := HTE P B C D A1 H17 H16 H29).
ex_and HE X; ex_and H30 Y.
assert(Hx := l12_6 A1 A2 P X).
assert (P<>X) by (intro;treat_equalities;intuition).
assert(Par_strict A1 A2 P X) by (apply (par_strict_col2_par_strict _ _ B1 B2); Col; apply col3 with B P; Col).
apply Hx in H34.
assert(Hy := l12_6 A1 A2 P Y).
assert (P<>Y) by (intro;treat_equalities;intuition).
assert(HPar4 : Par_strict A1 A2 P Y) by (apply (par_strict_col2_par_strict _ _ C1 C2); Col; apply (col3 C P); Col).
apply Hy in HPar4.
assert(HOS : OS A1 A2 X Y) by (apply one_side_transitivity with P; try assumption; unfold OS in *; ex_and H34 Z; exists Z; split; assumption).
assert(Ho := HOS).
unfold OS in HOS.
ex_and HOS Z.
unfold TS in H36.
unfold TS in H37.
spliter.
assert(HTS : TS A1 A2 X Y) by (unfold TS; repeat split; try assumption; exists A1; split; Col).
apply l9_9 in HTS.

*****
HTS : not (OS A1 A2 X Y)
H39 : ex (fun T : Tpoint => and (Col T A1 A2) (Bet Y T Z))
H38 : not (Col Z A1 A2)
H37 : not (Col Y A1 A2)
H41 : ex (fun T : Tpoint => and (Col T A1 A2) (Bet X T Z))
H40 : not (Col Z A1 A2)
H36 : not (Col X A1 A2)
Z : Tpoint
Ho : OS A1 A2 X Y
HPar4 : OS A1 A2 P Y
H35 : not (eq P Y)
Hy : forall _ : Par_strict A1 A2 P Y, OS A1 A2 P Y
H34 : OS A1 A2 P X
H33 : not (eq P X)
Hx : forall _ : Par_strict A1 A2 P X, OS A1 A2 P X
H32 : Bet X A1 Y
H31 : Bet P C Y
H30 : Bet P B X
X,Y : Tpoint
H29 : not (eq P D)
H28 : not (Col B P C)
H27 : Col C P C2
H26 : Col C' P C2
H25 : Col C P C1
H24 : Col C' P C1
H23 : Col B P B2
H22 : Col B P B1
H21 : not (eq P C)
H20 : not (eq B P)
HPar3 : Par_strict A1 A2 C' P
H19 : Par A1 A2 C' P
H18 : not (eq C' P)
H17 : Bet P D A1
H16 : Bet B D C
D : Tpoint
H15 : Cong C' P P C
H14 : Bet C' P C
C : Tpoint
H13 : Bet A1 B C'
H12 : Col B B1 B2
B : Tpoint
H10 : not (Col A1 B1 B2)
H11 : not (Col C' B1 B2)
H9 : not (Col A1 B1 B2)
H8 : Col C1 C2 C'
C' : Tpoint
HLine : or (not (Col C1 B1 B2)) (not (Col C2 B1 B2))
HPar2 : Par_strict A1 A2 C1 C2
HPar1 : Par_strict A1 A2 B1 B2
H3 : Col P C1 C2
H5 : not (eq C1 C2)
H4 : not (eq A1 A2)
H2 : Par A1 A2 C1 C2
H1 : Col P B1 B2
H7 : not (eq B1 B2)
H6 : not (eq A1 A2)
H0 : Par A1 A2 B1 B2
H : not (Col P A1 A2)
A1,A2,B1,B2,C1,C2,P : Tpoint
HTE : tarski_s_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Col C1 B1 B2) (Col C2 B1 B2)
+++++
contradiction.
-----
Lemma tarski_s_euclid_implies_playfair : tarski_s_parallel_postulate -> playfair_s_postulate.
Proof.
assert (HAux: tarski_s_parallel_postulate -> forall A1 A2 B1 B2 C1 C2 P, ~ Col P A1 A2 -> Par A1 A2 B1 B2 -> Col P B1 B2 -> Par A1 A2 C1 C2 -> Col P C1 C2 -> Col C1 B1 B2 /\\ Col C2 B1 B2).

*****
HAux : forall (_ : tarski_s_parallel_postulate) (A1 A2 B1 B2 C1 C2 P : Tpoint)\n (_ : not (Col P A1 A2)) (_ : Par A1 A2 B1 B2) (_ : Col P B1 B2)\n (_ : Par A1 A2 C1 C2) (_ : Col P C1 C2),\nand (Col C1 B1 B2) (Col C2 B1 B2)
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : tarski_s_parallel_postulate, playfair_s_postulate
+++++
intros HTE A1; intros.
-----
Lemma tarski_s_euclid_implies_playfair : tarski_s_parallel_postulate -> playfair_s_postulate.
Proof.
assert (HAux: tarski_s_parallel_postulate -> forall A1 A2 B1 B2 C1 C2 P, ~ Col P A1 A2 -> Par A1 A2 B1 B2 -> Col P B1 B2 -> Par A1 A2 C1 C2 -> Col P C1 C2 -> Col C1 B1 B2 /\\ Col C2 B1 B2).
intros HTE A1; intros.

*****
H2 : Col P C1 C2
H1 : Par A1 A2 C1 C2
H0 : Col P B1 B2
H : Par A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,P : Tpoint
HTE : tarski_s_parallel_postulate
HAux : forall (_ : tarski_s_parallel_postulate) (A1 A2 B1 B2 C1 C2 P : Tpoint)\n (_ : not (Col P A1 A2)) (_ : Par A1 A2 B1 B2) (_ : Col P B1 B2)\n (_ : Par A1 A2 C1 C2) (_ : Col P C1 C2),\nand (Col C1 B1 B2) (Col C2 B1 B2)
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Col C1 B1 B2) (Col C2 B1 B2)
+++++
assert( A1 <> A2 /\ B1 <> B2) by (apply par_distinct;auto).
-----
Lemma tarski_s_euclid_implies_playfair : tarski_s_parallel_postulate -> playfair_s_postulate.
Proof.
assert (HAux: tarski_s_parallel_postulate -> forall A1 A2 B1 B2 C1 C2 P, ~ Col P A1 A2 -> Par A1 A2 B1 B2 -> Col P B1 B2 -> Par A1 A2 C1 C2 -> Col P C1 C2 -> Col C1 B1 B2 /\\ Col C2 B1 B2).
intros HTE A1; intros.
assert( A1 <> A2 /\\ B1 <> B2) by (apply par_distinct;auto).

*****
H3 : and (not (eq A1 A2)) (not (eq B1 B2))
H2 : Col P C1 C2
H1 : Par A1 A2 C1 C2
H0 : Col P B1 B2
H : Par A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,P : Tpoint
HTE : tarski_s_parallel_postulate
HAux : forall (_ : tarski_s_parallel_postulate) (A1 A2 B1 B2 C1 C2 P : Tpoint)\n (_ : not (Col P A1 A2)) (_ : Par A1 A2 B1 B2) (_ : Col P B1 B2)\n (_ : Par A1 A2 C1 C2) (_ : Col P C1 C2),\nand (Col C1 B1 B2) (Col C2 B1 B2)
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Col C1 B1 B2) (Col C2 B1 B2)
+++++
assert( A1 <> A2 /\ C1 <> C2) by (apply par_distinct;auto).
-----
Lemma tarski_s_euclid_implies_playfair : tarski_s_parallel_postulate -> playfair_s_postulate.
Proof.
assert (HAux: tarski_s_parallel_postulate -> forall A1 A2 B1 B2 C1 C2 P, ~ Col P A1 A2 -> Par A1 A2 B1 B2 -> Col P B1 B2 -> Par A1 A2 C1 C2 -> Col P C1 C2 -> Col C1 B1 B2 /\\ Col C2 B1 B2).
intros HTE A1; intros.
assert( A1 <> A2 /\\ B1 <> B2) by (apply par_distinct;auto).
assert( A1 <> A2 /\\ C1 <> C2) by (apply par_distinct;auto).

*****
H4 : and (not (eq A1 A2)) (not (eq C1 C2))
H3 : and (not (eq A1 A2)) (not (eq B1 B2))
H2 : Col P C1 C2
H1 : Par A1 A2 C1 C2
H0 : Col P B1 B2
H : Par A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,P : Tpoint
HTE : tarski_s_parallel_postulate
HAux : forall (_ : tarski_s_parallel_postulate) (A1 A2 B1 B2 C1 C2 P : Tpoint)\n (_ : not (Col P A1 A2)) (_ : Par A1 A2 B1 B2) (_ : Col P B1 B2)\n (_ : Par A1 A2 C1 C2) (_ : Col P C1 C2),\nand (Col C1 B1 B2) (Col C2 B1 B2)
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Col C1 B1 B2) (Col C2 B1 B2)
+++++
spliter.
-----
Lemma tarski_s_euclid_implies_playfair : tarski_s_parallel_postulate -> playfair_s_postulate.
Proof.
assert (HAux: tarski_s_parallel_postulate -> forall A1 A2 B1 B2 C1 C2 P, ~ Col P A1 A2 -> Par A1 A2 B1 B2 -> Col P B1 B2 -> Par A1 A2 C1 C2 -> Col P C1 C2 -> Col C1 B1 B2 /\\ Col C2 B1 B2).
intros HTE A1; intros.
assert( A1 <> A2 /\\ B1 <> B2) by (apply par_distinct;auto).
assert( A1 <> A2 /\\ C1 <> C2) by (apply par_distinct;auto).
spliter.

*****
H5 : not (eq C1 C2)
H4 : not (eq A1 A2)
H6 : not (eq B1 B2)
H3 : not (eq A1 A2)
H2 : Col P C1 C2
H1 : Par A1 A2 C1 C2
H0 : Col P B1 B2
H : Par A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,P : Tpoint
HTE : tarski_s_parallel_postulate
HAux : forall (_ : tarski_s_parallel_postulate) (A1 A2 B1 B2 C1 C2 P : Tpoint)\n (_ : not (Col P A1 A2)) (_ : Par A1 A2 B1 B2) (_ : Col P B1 B2)\n (_ : Par A1 A2 C1 C2) (_ : Col P C1 C2),\nand (Col C1 B1 B2) (Col C2 B1 B2)
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Col C1 B1 B2) (Col C2 B1 B2)
+++++
clear H4.
-----
Lemma tarski_s_euclid_implies_playfair : tarski_s_parallel_postulate -> playfair_s_postulate.
Proof.
assert (HAux: tarski_s_parallel_postulate -> forall A1 A2 B1 B2 C1 C2 P, ~ Col P A1 A2 -> Par A1 A2 B1 B2 -> Col P B1 B2 -> Par A1 A2 C1 C2 -> Col P C1 C2 -> Col C1 B1 B2 /\\ Col C2 B1 B2).
intros HTE A1; intros.
assert( A1 <> A2 /\\ B1 <> B2) by (apply par_distinct;auto).
assert( A1 <> A2 /\\ C1 <> C2) by (apply par_distinct;auto).
spliter.
clear H4.

*****
H5 : not (eq C1 C2)
H6 : not (eq B1 B2)
H3 : not (eq A1 A2)
H2 : Col P C1 C2
H1 : Par A1 A2 C1 C2
H0 : Col P B1 B2
H : Par A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,P : Tpoint
HTE : tarski_s_parallel_postulate
HAux : forall (_ : tarski_s_parallel_postulate) (A1 A2 B1 B2 C1 C2 P : Tpoint)\n (_ : not (Col P A1 A2)) (_ : Par A1 A2 B1 B2) (_ : Col P B1 B2)\n (_ : Par A1 A2 C1 C2) (_ : Col P C1 C2),\nand (Col C1 B1 B2) (Col C2 B1 B2)
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Col C1 B1 B2) (Col C2 B1 B2)
+++++
induction(col_dec P A1 A2).
-----
Lemma tarski_s_euclid_implies_playfair : tarski_s_parallel_postulate -> playfair_s_postulate.
Proof.
assert (HAux: tarski_s_parallel_postulate -> forall A1 A2 B1 B2 C1 C2 P, ~ Col P A1 A2 -> Par A1 A2 B1 B2 -> Col P B1 B2 -> Par A1 A2 C1 C2 -> Col P C1 C2 -> Col C1 B1 B2 /\\ Col C2 B1 B2).
intros HTE A1; intros.
assert( A1 <> A2 /\\ B1 <> B2) by (apply par_distinct;auto).
assert( A1 <> A2 /\\ C1 <> C2) by (apply par_distinct;auto).
spliter.
clear H4.
induction(col_dec P A1 A2).

*****
H4 : Col P A1 A2
H5 : not (eq C1 C2)
H6 : not (eq B1 B2)
H3 : not (eq A1 A2)
H2 : Col P C1 C2
H1 : Par A1 A2 C1 C2
H0 : Col P B1 B2
H : Par A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,P : Tpoint
HTE : tarski_s_parallel_postulate
HAux : forall (_ : tarski_s_parallel_postulate) (A1 A2 B1 B2 C1 C2 P : Tpoint)\n (_ : not (Col P A1 A2)) (_ : Par A1 A2 B1 B2) (_ : Col P B1 B2)\n (_ : Par A1 A2 C1 C2) (_ : Col P C1 C2),\nand (Col C1 B1 B2) (Col C2 B1 B2)
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Col C1 B1 B2) (Col C2 B1 B2)
+++++
induction H.
-----
Lemma tarski_s_euclid_implies_playfair : tarski_s_parallel_postulate -> playfair_s_postulate.
Proof.
assert (HAux: tarski_s_parallel_postulate -> forall A1 A2 B1 B2 C1 C2 P, ~ Col P A1 A2 -> Par A1 A2 B1 B2 -> Col P B1 B2 -> Par A1 A2 C1 C2 -> Col P C1 C2 -> Col C1 B1 B2 /\\ Col C2 B1 B2).
intros HTE A1; intros.
assert( A1 <> A2 /\\ B1 <> B2) by (apply par_distinct;auto).
assert( A1 <> A2 /\\ C1 <> C2) by (apply par_distinct;auto).
spliter.
clear H4.
induction(col_dec P A1 A2).
induction H.

*****
H4 : Col P A1 A2
H5 : not (eq C1 C2)
H6 : not (eq B1 B2)
H3 : not (eq A1 A2)
H2 : Col P C1 C2
H1 : Par A1 A2 C1 C2
H0 : Col P B1 B2
H : Par_strict A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,P : Tpoint
HTE : tarski_s_parallel_postulate
HAux : forall (_ : tarski_s_parallel_postulate) (A1 A2 B1 B2 C1 C2 P : Tpoint)\n (_ : not (Col P A1 A2)) (_ : Par A1 A2 B1 B2) (_ : Col P B1 B2)\n (_ : Par A1 A2 C1 C2) (_ : Col P C1 C2),\nand (Col C1 B1 B2) (Col C2 B1 B2)
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Col C1 B1 B2) (Col C2 B1 B2)
+++++
exfalso.
-----
Lemma tarski_s_euclid_implies_playfair : tarski_s_parallel_postulate -> playfair_s_postulate.
Proof.
assert (HAux: tarski_s_parallel_postulate -> forall A1 A2 B1 B2 C1 C2 P, ~ Col P A1 A2 -> Par A1 A2 B1 B2 -> Col P B1 B2 -> Par A1 A2 C1 C2 -> Col P C1 C2 -> Col C1 B1 B2 /\\ Col C2 B1 B2).
intros HTE A1; intros.
assert( A1 <> A2 /\\ B1 <> B2) by (apply par_distinct;auto).
assert( A1 <> A2 /\\ C1 <> C2) by (apply par_distinct;auto).
spliter.
clear H4.
induction(col_dec P A1 A2).
induction H.
exfalso.

*****
H4 : Col P A1 A2
H5 : not (eq C1 C2)
H6 : not (eq B1 B2)
H3 : not (eq A1 A2)
H2 : Col P C1 C2
H1 : Par A1 A2 C1 C2
H0 : Col P B1 B2
H : Par_strict A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,P : Tpoint
HTE : tarski_s_parallel_postulate
HAux : forall (_ : tarski_s_parallel_postulate) (A1 A2 B1 B2 C1 C2 P : Tpoint)\n (_ : not (Col P A1 A2)) (_ : Par A1 A2 B1 B2) (_ : Col P B1 B2)\n (_ : Par A1 A2 C1 C2) (_ : Col P C1 C2),\nand (Col C1 B1 B2) (Col C2 B1 B2)
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
apply H.
-----
Lemma tarski_s_euclid_implies_playfair : tarski_s_parallel_postulate -> playfair_s_postulate.
Proof.
assert (HAux: tarski_s_parallel_postulate -> forall A1 A2 B1 B2 C1 C2 P, ~ Col P A1 A2 -> Par A1 A2 B1 B2 -> Col P B1 B2 -> Par A1 A2 C1 C2 -> Col P C1 C2 -> Col C1 B1 B2 /\\ Col C2 B1 B2).
intros HTE A1; intros.
assert( A1 <> A2 /\\ B1 <> B2) by (apply par_distinct;auto).
assert( A1 <> A2 /\\ C1 <> C2) by (apply par_distinct;auto).
spliter.
clear H4.
induction(col_dec P A1 A2).
induction H.
exfalso.
apply H.

*****
H4 : Col P A1 A2
H5 : not (eq C1 C2)
H6 : not (eq B1 B2)
H3 : not (eq A1 A2)
H2 : Col P C1 C2
H1 : Par A1 A2 C1 C2
H0 : Col P B1 B2
H : Par_strict A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,P : Tpoint
HTE : tarski_s_parallel_postulate
HAux : forall (_ : tarski_s_parallel_postulate) (A1 A2 B1 B2 C1 C2 P : Tpoint)\n (_ : not (Col P A1 A2)) (_ : Par A1 A2 B1 B2) (_ : Col P B1 B2)\n (_ : Par A1 A2 C1 C2) (_ : Col P C1 C2),\nand (Col C1 B1 B2) (Col C2 B1 B2)
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => and (Col X A1 A2) (Col X B1 B2))
+++++
exists P.
-----
Lemma tarski_s_euclid_implies_playfair : tarski_s_parallel_postulate -> playfair_s_postulate.
Proof.
assert (HAux: tarski_s_parallel_postulate -> forall A1 A2 B1 B2 C1 C2 P, ~ Col P A1 A2 -> Par A1 A2 B1 B2 -> Col P B1 B2 -> Par A1 A2 C1 C2 -> Col P C1 C2 -> Col C1 B1 B2 /\\ Col C2 B1 B2).
intros HTE A1; intros.
assert( A1 <> A2 /\\ B1 <> B2) by (apply par_distinct;auto).
assert( A1 <> A2 /\\ C1 <> C2) by (apply par_distinct;auto).
spliter.
clear H4.
induction(col_dec P A1 A2).
induction H.
exfalso.
apply H.
exists P.

*****
H4 : Col P A1 A2
H5 : not (eq C1 C2)
H6 : not (eq B1 B2)
H3 : not (eq A1 A2)
H2 : Col P C1 C2
H1 : Par A1 A2 C1 C2
H0 : Col P B1 B2
H : Par_strict A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,P : Tpoint
HTE : tarski_s_parallel_postulate
HAux : forall (_ : tarski_s_parallel_postulate) (A1 A2 B1 B2 C1 C2 P : Tpoint)\n (_ : not (Col P A1 A2)) (_ : Par A1 A2 B1 B2) (_ : Col P B1 B2)\n (_ : Par A1 A2 C1 C2) (_ : Col P C1 C2),\nand (Col C1 B1 B2) (Col C2 B1 B2)
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Col P A1 A2) (Col P B1 B2)
+++++
split; Col.
-----
Lemma tarski_s_euclid_implies_playfair : tarski_s_parallel_postulate -> playfair_s_postulate.
Proof.
assert (HAux: tarski_s_parallel_postulate -> forall A1 A2 B1 B2 C1 C2 P, ~ Col P A1 A2 -> Par A1 A2 B1 B2 -> Col P B1 B2 -> Par A1 A2 C1 C2 -> Col P C1 C2 -> Col C1 B1 B2 /\\ Col C2 B1 B2).
intros HTE A1; intros.
assert( A1 <> A2 /\\ B1 <> B2) by (apply par_distinct;auto).
assert( A1 <> A2 /\\ C1 <> C2) by (apply par_distinct;auto).
spliter.
clear H4.
induction(col_dec P A1 A2).
induction H.
exfalso.
apply H.
exists P.
split; Col.

*****
H4 : Col P A1 A2
H5 : not (eq C1 C2)
H6 : not (eq B1 B2)
H3 : not (eq A1 A2)
H2 : Col P C1 C2
H1 : Par A1 A2 C1 C2
H0 : Col P B1 B2
H : and (not (eq A1 A2))\n (and (not (eq B1 B2)) (and (Col A1 B1 B2) (Col A2 B1 B2)))
A1,A2,B1,B2,C1,C2,P : Tpoint
HTE : tarski_s_parallel_postulate
HAux : forall (_ : tarski_s_parallel_postulate) (A1 A2 B1 B2 C1 C2 P : Tpoint)\n (_ : not (Col P A1 A2)) (_ : Par A1 A2 B1 B2) (_ : Col P B1 B2)\n (_ : Par A1 A2 C1 C2) (_ : Col P C1 C2),\nand (Col C1 B1 B2) (Col C2 B1 B2)
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Col C1 B1 B2) (Col C2 B1 B2)
+++++
induction H1.
-----
Lemma tarski_s_euclid_implies_playfair : tarski_s_parallel_postulate -> playfair_s_postulate.
Proof.
assert (HAux: tarski_s_parallel_postulate -> forall A1 A2 B1 B2 C1 C2 P, ~ Col P A1 A2 -> Par A1 A2 B1 B2 -> Col P B1 B2 -> Par A1 A2 C1 C2 -> Col P C1 C2 -> Col C1 B1 B2 /\\ Col C2 B1 B2).
intros HTE A1; intros.
assert( A1 <> A2 /\\ B1 <> B2) by (apply par_distinct;auto).
assert( A1 <> A2 /\\ C1 <> C2) by (apply par_distinct;auto).
spliter.
clear H4.
induction(col_dec P A1 A2).
induction H.
exfalso.
apply H.
exists P.
split; Col.
induction H1.

*****
H4 : Col P A1 A2
H5 : not (eq C1 C2)
H6 : not (eq B1 B2)
H3 : not (eq A1 A2)
H2 : Col P C1 C2
H1 : Par_strict A1 A2 C1 C2
H0 : Col P B1 B2
H : and (not (eq A1 A2))\n (and (not (eq B1 B2)) (and (Col A1 B1 B2) (Col A2 B1 B2)))
A1,A2,B1,B2,C1,C2,P : Tpoint
HTE : tarski_s_parallel_postulate
HAux : forall (_ : tarski_s_parallel_postulate) (A1 A2 B1 B2 C1 C2 P : Tpoint)\n (_ : not (Col P A1 A2)) (_ : Par A1 A2 B1 B2) (_ : Col P B1 B2)\n (_ : Par A1 A2 C1 C2) (_ : Col P C1 C2),\nand (Col C1 B1 B2) (Col C2 B1 B2)
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Col C1 B1 B2) (Col C2 B1 B2)
+++++
exfalso.
-----
Lemma tarski_s_euclid_implies_playfair : tarski_s_parallel_postulate -> playfair_s_postulate.
Proof.
assert (HAux: tarski_s_parallel_postulate -> forall A1 A2 B1 B2 C1 C2 P, ~ Col P A1 A2 -> Par A1 A2 B1 B2 -> Col P B1 B2 -> Par A1 A2 C1 C2 -> Col P C1 C2 -> Col C1 B1 B2 /\\ Col C2 B1 B2).
intros HTE A1; intros.
assert( A1 <> A2 /\\ B1 <> B2) by (apply par_distinct;auto).
assert( A1 <> A2 /\\ C1 <> C2) by (apply par_distinct;auto).
spliter.
clear H4.
induction(col_dec P A1 A2).
induction H.
exfalso.
apply H.
exists P.
split; Col.
induction H1.
exfalso.

*****
H4 : Col P A1 A2
H5 : not (eq C1 C2)
H6 : not (eq B1 B2)
H3 : not (eq A1 A2)
H2 : Col P C1 C2
H1 : Par_strict A1 A2 C1 C2
H0 : Col P B1 B2
H : and (not (eq A1 A2))\n (and (not (eq B1 B2)) (and (Col A1 B1 B2) (Col A2 B1 B2)))
A1,A2,B1,B2,C1,C2,P : Tpoint
HTE : tarski_s_parallel_postulate
HAux : forall (_ : tarski_s_parallel_postulate) (A1 A2 B1 B2 C1 C2 P : Tpoint)\n (_ : not (Col P A1 A2)) (_ : Par A1 A2 B1 B2) (_ : Col P B1 B2)\n (_ : Par A1 A2 C1 C2) (_ : Col P C1 C2),\nand (Col C1 B1 B2) (Col C2 B1 B2)
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
apply H1.
-----
Lemma tarski_s_euclid_implies_playfair : tarski_s_parallel_postulate -> playfair_s_postulate.
Proof.
assert (HAux: tarski_s_parallel_postulate -> forall A1 A2 B1 B2 C1 C2 P, ~ Col P A1 A2 -> Par A1 A2 B1 B2 -> Col P B1 B2 -> Par A1 A2 C1 C2 -> Col P C1 C2 -> Col C1 B1 B2 /\\ Col C2 B1 B2).
intros HTE A1; intros.
assert( A1 <> A2 /\\ B1 <> B2) by (apply par_distinct;auto).
assert( A1 <> A2 /\\ C1 <> C2) by (apply par_distinct;auto).
spliter.
clear H4.
induction(col_dec P A1 A2).
induction H.
exfalso.
apply H.
exists P.
split; Col.
induction H1.
exfalso.
apply H1.

*****
H4 : Col P A1 A2
H5 : not (eq C1 C2)
H6 : not (eq B1 B2)
H3 : not (eq A1 A2)
H2 : Col P C1 C2
H1 : Par_strict A1 A2 C1 C2
H0 : Col P B1 B2
H : and (not (eq A1 A2))\n (and (not (eq B1 B2)) (and (Col A1 B1 B2) (Col A2 B1 B2)))
A1,A2,B1,B2,C1,C2,P : Tpoint
HTE : tarski_s_parallel_postulate
HAux : forall (_ : tarski_s_parallel_postulate) (A1 A2 B1 B2 C1 C2 P : Tpoint)\n (_ : not (Col P A1 A2)) (_ : Par A1 A2 B1 B2) (_ : Col P B1 B2)\n (_ : Par A1 A2 C1 C2) (_ : Col P C1 C2),\nand (Col C1 B1 B2) (Col C2 B1 B2)
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => and (Col X A1 A2) (Col X C1 C2))
+++++
exists P.
-----
Lemma tarski_s_euclid_implies_playfair : tarski_s_parallel_postulate -> playfair_s_postulate.
Proof.
assert (HAux: tarski_s_parallel_postulate -> forall A1 A2 B1 B2 C1 C2 P, ~ Col P A1 A2 -> Par A1 A2 B1 B2 -> Col P B1 B2 -> Par A1 A2 C1 C2 -> Col P C1 C2 -> Col C1 B1 B2 /\\ Col C2 B1 B2).
intros HTE A1; intros.
assert( A1 <> A2 /\\ B1 <> B2) by (apply par_distinct;auto).
assert( A1 <> A2 /\\ C1 <> C2) by (apply par_distinct;auto).
spliter.
clear H4.
induction(col_dec P A1 A2).
induction H.
exfalso.
apply H.
exists P.
split; Col.
induction H1.
exfalso.
apply H1.
exists P.

*****
H4 : Col P A1 A2
H5 : not (eq C1 C2)
H6 : not (eq B1 B2)
H3 : not (eq A1 A2)
H2 : Col P C1 C2
H1 : Par_strict A1 A2 C1 C2
H0 : Col P B1 B2
H : and (not (eq A1 A2))\n (and (not (eq B1 B2)) (and (Col A1 B1 B2) (Col A2 B1 B2)))
A1,A2,B1,B2,C1,C2,P : Tpoint
HTE : tarski_s_parallel_postulate
HAux : forall (_ : tarski_s_parallel_postulate) (A1 A2 B1 B2 C1 C2 P : Tpoint)\n (_ : not (Col P A1 A2)) (_ : Par A1 A2 B1 B2) (_ : Col P B1 B2)\n (_ : Par A1 A2 C1 C2) (_ : Col P C1 C2),\nand (Col C1 B1 B2) (Col C2 B1 B2)
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Col P A1 A2) (Col P C1 C2)
+++++
split; Col.
-----
Lemma tarski_s_euclid_implies_playfair : tarski_s_parallel_postulate -> playfair_s_postulate.
Proof.
assert (HAux: tarski_s_parallel_postulate -> forall A1 A2 B1 B2 C1 C2 P, ~ Col P A1 A2 -> Par A1 A2 B1 B2 -> Col P B1 B2 -> Par A1 A2 C1 C2 -> Col P C1 C2 -> Col C1 B1 B2 /\\ Col C2 B1 B2).
intros HTE A1; intros.
assert( A1 <> A2 /\\ B1 <> B2) by (apply par_distinct;auto).
assert( A1 <> A2 /\\ C1 <> C2) by (apply par_distinct;auto).
spliter.
clear H4.
induction(col_dec P A1 A2).
induction H.
exfalso.
apply H.
exists P.
split; Col.
induction H1.
exfalso.
apply H1.
exists P.
split; Col.

*****
H4 : Col P A1 A2
H5 : not (eq C1 C2)
H6 : not (eq B1 B2)
H3 : not (eq A1 A2)
H2 : Col P C1 C2
H1 : and (not (eq A1 A2))\n (and (not (eq C1 C2)) (and (Col A1 C1 C2) (Col A2 C1 C2)))
H0 : Col P B1 B2
H : and (not (eq A1 A2))\n (and (not (eq B1 B2)) (and (Col A1 B1 B2) (Col A2 B1 B2)))
A1,A2,B1,B2,C1,C2,P : Tpoint
HTE : tarski_s_parallel_postulate
HAux : forall (_ : tarski_s_parallel_postulate) (A1 A2 B1 B2 C1 C2 P : Tpoint)\n (_ : not (Col P A1 A2)) (_ : Par A1 A2 B1 B2) (_ : Col P B1 B2)\n (_ : Par A1 A2 C1 C2) (_ : Col P C1 C2),\nand (Col C1 B1 B2) (Col C2 B1 B2)
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Col C1 B1 B2) (Col C2 B1 B2)
+++++
spliter.
-----
Lemma tarski_s_euclid_implies_playfair : tarski_s_parallel_postulate -> playfair_s_postulate.
Proof.
assert (HAux: tarski_s_parallel_postulate -> forall A1 A2 B1 B2 C1 C2 P, ~ Col P A1 A2 -> Par A1 A2 B1 B2 -> Col P B1 B2 -> Par A1 A2 C1 C2 -> Col P C1 C2 -> Col C1 B1 B2 /\\ Col C2 B1 B2).
intros HTE A1; intros.
assert( A1 <> A2 /\\ B1 <> B2) by (apply par_distinct;auto).
assert( A1 <> A2 /\\ C1 <> C2) by (apply par_distinct;auto).
spliter.
clear H4.
induction(col_dec P A1 A2).
induction H.
exfalso.
apply H.
exists P.
split; Col.
induction H1.
exfalso.
apply H1.
exists P.
split; Col.
spliter.

*****
H4 : Col P A1 A2
H5 : not (eq C1 C2)
H6 : not (eq B1 B2)
H3 : not (eq A1 A2)
H2 : Col P C1 C2
H9 : Col A2 C1 C2
H8 : Col A1 C1 C2
H7 : not (eq C1 C2)
H1 : not (eq A1 A2)
H0 : Col P B1 B2
H12 : Col A2 B1 B2
H11 : Col A1 B1 B2
H10 : not (eq B1 B2)
H : not (eq A1 A2)
A1,A2,B1,B2,C1,C2,P : Tpoint
HTE : tarski_s_parallel_postulate
HAux : forall (_ : tarski_s_parallel_postulate) (A1 A2 B1 B2 C1 C2 P : Tpoint)\n (_ : not (Col P A1 A2)) (_ : Par A1 A2 B1 B2) (_ : Col P B1 B2)\n (_ : Par A1 A2 C1 C2) (_ : Col P C1 C2),\nand (Col C1 B1 B2) (Col C2 B1 B2)
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Col C1 B1 B2) (Col C2 B1 B2)
+++++
split;ColR.
-----
Lemma tarski_s_euclid_implies_playfair : tarski_s_parallel_postulate -> playfair_s_postulate.
Proof.
assert (HAux: tarski_s_parallel_postulate -> forall A1 A2 B1 B2 C1 C2 P, ~ Col P A1 A2 -> Par A1 A2 B1 B2 -> Col P B1 B2 -> Par A1 A2 C1 C2 -> Col P C1 C2 -> Col C1 B1 B2 /\\ Col C2 B1 B2).
intros HTE A1; intros.
assert( A1 <> A2 /\\ B1 <> B2) by (apply par_distinct;auto).
assert( A1 <> A2 /\\ C1 <> C2) by (apply par_distinct;auto).
spliter.
clear H4.
induction(col_dec P A1 A2).
induction H.
exfalso.
apply H.
exists P.
split; Col.
induction H1.
exfalso.
apply H1.
exists P.
split; Col.
spliter.
split;ColR.

*****
H4 : not (Col P A1 A2)
H5 : not (eq C1 C2)
H6 : not (eq B1 B2)
H3 : not (eq A1 A2)
H2 : Col P C1 C2
H1 : Par A1 A2 C1 C2
H0 : Col P B1 B2
H : Par A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,P : Tpoint
HTE : tarski_s_parallel_postulate
HAux : forall (_ : tarski_s_parallel_postulate) (A1 A2 B1 B2 C1 C2 P : Tpoint)\n (_ : not (Col P A1 A2)) (_ : Par A1 A2 B1 B2) (_ : Col P B1 B2)\n (_ : Par A1 A2 C1 C2) (_ : Col P C1 C2),\nand (Col C1 B1 B2) (Col C2 B1 B2)
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Col C1 B1 B2) (Col C2 B1 B2)
+++++
apply (HAux HTE A1 A2 _ _ _ _ P); auto.
-----
Lemma tarski_s_euclid_implies_playfair : tarski_s_parallel_postulate -> playfair_s_postulate.
Proof.
assert (HAux: tarski_s_parallel_postulate -> forall A1 A2 B1 B2 C1 C2 P, ~ Col P A1 A2 -> Par A1 A2 B1 B2 -> Col P B1 B2 -> Par A1 A2 C1 C2 -> Col P C1 C2 -> Col C1 B1 B2 /\\ Col C2 B1 B2).
intros HTE A1; intros.
assert( A1 <> A2 /\\ B1 <> B2) by (apply par_distinct;auto).
assert( A1 <> A2 /\\ C1 <> C2) by (apply par_distinct;auto).
spliter.
clear H4.
induction(col_dec P A1 A2).
induction H.
exfalso.
apply H.
exists P.
split; Col.
induction H1.
exfalso.
apply H1.
exists P.
split; Col.
spliter.
split;ColR.
apply (HAux HTE A1 A2 _ _ _ _ P); auto.

*****

*****

+++++
Qed.
-----
End tarski_playfair.
-----
