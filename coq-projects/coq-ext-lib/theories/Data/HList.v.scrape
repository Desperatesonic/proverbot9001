Require Import Coq.Lists.List.
-----
From Coq Require Import Relations.
-----
From Coq Require Import RelationClasses.
-----
Require Import ExtLib.Core.Type.
-----
Require Import ExtLib.Core.RelDec.
-----
Require Import ExtLib.Structures.Proper.
-----
Require Import ExtLib.Data.SigT.
-----
Require Import ExtLib.Data.Member.
-----
Require Import ExtLib.Data.ListNth.
-----
Require Import ExtLib.Data.Option.
-----
Require Import ExtLib.Tactics.
-----
Require Import Coq.Classes.Morphisms.
-----
Set Implicit Arguments.
-----
Set Strict Implicit.
-----
Set Asymmetric Patterns.
-----
Set Universe Polymorphism.
-----
Set Printing Universes.
-----
Lemma app_ass_trans@{X}\n: forall {T : Type@{X} } (a b c : list T), (a ++ b) ++ c = a ++ b ++ c.
-----
Lemma app_ass_trans@{X} : forall {T : Type@{X} } (a b c : list T), (a ++ b) ++ c = a ++ b ++ c.

*****

*****
forall (T : Type@{X}) (a b c : list T), eq (app (app a b) c) (app a (app b c))
+++++
Proof.
-----
Lemma app_ass_trans@{X} : forall {T : Type@{X} } (a b c : list T), (a ++ b) ++ c = a ++ b ++ c.
Proof.

*****

*****
forall (T : Type@{X}) (a b c : list T), eq (app (app a b) c) (app a (app b c))
+++++
induction a.
-----
Lemma app_ass_trans@{X} : forall {T : Type@{X} } (a b c : list T), (a ++ b) ++ c = a ++ b ++ c.
Proof.
induction a.

*****
T : Type@{X}
*****
forall b c : list T, eq (app (app nil b) c) (app nil (app b c))
+++++
simpl.
-----
Lemma app_ass_trans@{X} : forall {T : Type@{X} } (a b c : list T), (a ++ b) ++ c = a ++ b ++ c.
Proof.
induction a.
simpl.

*****
T : Type@{X}
*****
forall b c : list T, eq (app b c) (app b c)
+++++
reflexivity.
-----
Lemma app_ass_trans@{X} : forall {T : Type@{X} } (a b c : list T), (a ++ b) ++ c = a ++ b ++ c.
Proof.
induction a.

*****
IHa : forall b c : list T, eq (app (app a0 b) c) (app a0 (app b c))
a0 : list T
a : T
T : Type@{X}
*****
forall b c : list T, eq (app (app (cons a a0) b) c) (app (cons a a0) (app b c))
+++++
simpl.
-----
Lemma app_ass_trans@{X} : forall {T : Type@{X} } (a b c : list T), (a ++ b) ++ c = a ++ b ++ c.
Proof.
induction a.
simpl.

*****
IHa : forall b c : list T, eq (app (app a0 b) c) (app a0 (app b c))
a0 : list T
a : T
T : Type@{X}
*****
forall b c : list T, eq (cons a (app (app a0 b) c)) (cons a (app a0 (app b c)))
+++++
intros.
-----
Lemma app_ass_trans@{X} : forall {T : Type@{X} } (a b c : list T), (a ++ b) ++ c = a ++ b ++ c.
Proof.
induction a.
simpl.
intros.

*****
b,c : list T
IHa : forall b c : list T, eq (app (app a0 b) c) (app a0 (app b c))
a0 : list T
a : T
T : Type@{X}
*****
eq (cons a (app (app a0 b) c)) (cons a (app a0 (app b c)))
+++++
destruct (IHa b c).
-----
Lemma app_ass_trans@{X} : forall {T : Type@{X} } (a b c : list T), (a ++ b) ++ c = a ++ b ++ c.
Proof.
induction a.
simpl.
intros.
destruct (IHa b c).

*****
b,c : list T
IHa : forall b c : list T, eq (app (app a0 b) c) (app a0 (app b c))
a0 : list T
a : T
T : Type@{X}
*****
eq (cons a (app (app a0 b) c)) (cons a (app (app a0 b) c))
+++++
reflexivity.
-----
Lemma app_ass_trans@{X} : forall {T : Type@{X} } (a b c : list T), (a ++ b) ++ c = a ++ b ++ c.
Proof.
induction a.

*****

*****

+++++
Defined.
-----
Lemma app_nil_r_trans : forall {T : Type} (a : list T), a ++ nil = a.
-----
Lemma app_nil_r_trans : forall {T : Type} (a : list T), a ++ nil = a.

*****

*****
forall (T : Type@{SerTop.2}) (a : list T), eq (app a nil) a
+++++
Proof.
-----
Lemma app_nil_r_trans : forall {T : Type} (a : list T), a ++ nil = a.
Proof.

*****

*****
forall (T : Type@{SerTop.2}) (a : list T), eq (app a nil) a
+++++
induction a.
-----
Lemma app_nil_r_trans : forall {T : Type} (a : list T), a ++ nil = a.
Proof.
induction a.

*****
T : Type@{SerTop\.2}
*****
eq (app nil nil) nil
+++++
simpl.
-----
Lemma app_nil_r_trans : forall {T : Type} (a : list T), a ++ nil = a.
Proof.
induction a.
simpl.

*****
T : Type@{SerTop\.2}
*****
eq nil nil
+++++
reflexivity.
-----
Lemma app_nil_r_trans : forall {T : Type} (a : list T), a ++ nil = a.
Proof.
induction a.

*****
IHa : eq (app a0 nil) a0
a0 : list T
a : T
T : Type@{SerTop\.2}
*****
eq (app (cons a a0) nil) (cons a a0)
+++++
simpl.
-----
Lemma app_nil_r_trans : forall {T : Type} (a : list T), a ++ nil = a.
Proof.
induction a.
simpl.

*****
IHa : eq (app a0 nil) a0
a0 : list T
a : T
T : Type@{SerTop\.2}
*****
eq (cons a (app a0 nil)) (cons a a0)
+++++
refine match IHa in _ = X return _ = _ :: X with | eq_refl => eq_refl end.
-----
Lemma app_nil_r_trans : forall {T : Type} (a : list T), a ++ nil = a.
Proof.
induction a.

*****

*****

+++++
Defined.
-----
Monomorphic Universe hlist_large.
-----
Section hlist.
-----
Polymorphic Universe Ui Uv.
-----
Context {iT : Type@{Ui}}.
-----
Variable F : iT -> Type@{Uv}.
-----
Inductive hlist : list iT -> Type :=\n  | Hnil  : hlist nil\n  | Hcons : forall l ls, F l -> hlist ls -> hlist (l :: ls).
-----
Definition hlist_hd {a b} (hl : hlist (a :: b)) : F a :=\n    match hl in hlist x return match x return Type@{Uv} with\n                               | nil => unit\n                               | l :: _ => F l\n                               end with\n    | Hnil => tt\n    | Hcons _ _ x _ => x\n    end.
-----
Definition hlist_tl {a b} (hl : hlist (a :: b)) : hlist b :=\n    match hl in hlist x return match x return Type@{hlist_large} with\n                                 | nil => unit\n                                 | _ :: ls => hlist ls\n                               end with\n      | Hnil => tt\n      | Hcons _ _ _ x => x\n    end.
-----
Lemma hlist_eta : forall ls (h : hlist ls),\n    h = match ls as ls return hlist ls -> hlist ls with\n        | nil => fun _ => Hnil\n        | a :: b => fun h => Hcons (hlist_hd h) (hlist_tl h)\n        end h.
-----
Lemma hlist_eta : forall ls (h : hlist ls), h = match ls as ls return hlist ls -> hlist ls with | nil => fun _ => Hnil | a :: b => fun h => Hcons (hlist_hd h) (hlist_tl h) end h.

*****
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall (ls : list iT) (h : hlist ls), eq h (match ls as ls0 return (forall _ : hlist ls0, hlist ls0) with | nil => fun _ : hlist nil => Hnil | cons a b => fun h0 : hlist (cons a b) => Hcons (hlist_hd h0) (hlist_tl h0) end h)
+++++
Proof.
-----
Lemma hlist_eta : forall ls (h : hlist ls), h = match ls as ls return hlist ls -> hlist ls with | nil => fun _ => Hnil | a :: b => fun h => Hcons (hlist_hd h) (hlist_tl h) end h.
Proof.

*****
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall (ls : list iT) (h : hlist ls), eq h (match ls as ls0 return (forall _ : hlist ls0, hlist ls0) with | nil => fun _ : hlist nil => Hnil | cons a b => fun h0 : hlist (cons a b) => Hcons (hlist_hd h0) (hlist_tl h0) end h)
+++++
intros.
-----
Lemma hlist_eta : forall ls (h : hlist ls), h = match ls as ls return hlist ls -> hlist ls with | nil => fun _ => Hnil | a :: b => fun h => Hcons (hlist_hd h) (hlist_tl h) end h.
Proof.
intros.

*****
h : hlist ls
ls : list iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
eq h (match ls return (forall _ : hlist ls, hlist ls) with | nil => fun _ : hlist nil => Hnil | cons a b => fun h : hlist (cons a b) => Hcons (hlist_hd h) (hlist_tl h) end h)
+++++
destruct h.
-----
Lemma hlist_eta : forall ls (h : hlist ls), h = match ls as ls return hlist ls -> hlist ls with | nil => fun _ => Hnil | a :: b => fun h => Hcons (hlist_hd h) (hlist_tl h) end h.
Proof.
intros.
destruct h.

*****
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
eq Hnil Hnil
+++++
auto.
-----
Lemma hlist_eta : forall ls (h : hlist ls), h = match ls as ls return hlist ls -> hlist ls with | nil => fun _ => Hnil | a :: b => fun h => Hcons (hlist_hd h) (hlist_tl h) end h.
Proof.
intros.
destruct h.

*****
h : hlist ls
f : F l
ls : list iT
l : iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
eq (Hcons f h) (Hcons (hlist_hd (Hcons f h)) (hlist_tl (Hcons f h)))
+++++
auto.
-----
Lemma hlist_eta : forall ls (h : hlist ls), h = match ls as ls return hlist ls -> hlist ls with | nil => fun _ => Hnil | a :: b => fun h => Hcons (hlist_hd h) (hlist_tl h) end h.
Proof.
intros.
destruct h.

*****

*****

+++++
Qed.
-----
Fixpoint hlist_app ll lr (h : hlist ll) : hlist lr -> hlist (ll ++ lr) :=\n    match h in hlist ll return hlist lr -> hlist (ll ++ lr) with\n    | Hnil => fun x => x\n    | Hcons _ _ hd tl => fun r => Hcons hd (hlist_app tl r)\n    end.
-----
Lemma hlist_app_nil_r\n  : forall ls (h : hlist ls),\n      hlist_app h Hnil =\n      match eq_sym (app_nil_r_trans ls) in _ = t return hlist t with\n      | eq_refl => h\n      end.
-----
Lemma hlist_app_nil_r : forall ls (h : hlist ls), hlist_app h Hnil = match eq_sym (app_nil_r_trans ls) in _ = t return hlist t with | eq_refl => h end.

*****
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall (ls : list iT) (h : hlist ls), eq (hlist_app h Hnil) match eq_sym (app_nil_r_trans@{Ui} ls) in (eq _ t) return (hlist t) with | eq_refl => h end
+++++
Proof.
-----
Lemma hlist_app_nil_r : forall ls (h : hlist ls), hlist_app h Hnil = match eq_sym (app_nil_r_trans ls) in _ = t return hlist t with | eq_refl => h end.
Proof.

*****
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall (ls : list iT) (h : hlist ls), eq (hlist_app h Hnil) match eq_sym (app_nil_r_trans@{Ui} ls) in (eq _ t) return (hlist t) with | eq_refl => h end
+++++
induction h.
-----
Lemma hlist_app_nil_r : forall ls (h : hlist ls), hlist_app h Hnil = match eq_sym (app_nil_r_trans ls) in _ = t return hlist t with | eq_refl => h end.
Proof.
induction h.

*****
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
eq (hlist_app Hnil Hnil) match eq_sym (app_nil_r_trans@{Ui} nil) in (eq _ t) return (hlist t) with | eq_refl => Hnil end
+++++
simpl.
-----
Lemma hlist_app_nil_r : forall ls (h : hlist ls), hlist_app h Hnil = match eq_sym (app_nil_r_trans ls) in _ = t return hlist t with | eq_refl => h end.
Proof.
induction h.
simpl.

*****
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
eq Hnil Hnil
+++++
intros.
-----
Lemma hlist_app_nil_r : forall ls (h : hlist ls), hlist_app h Hnil = match eq_sym (app_nil_r_trans ls) in _ = t return hlist t with | eq_refl => h end.
Proof.
induction h.
simpl.
intros.

*****
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
eq Hnil Hnil
+++++
auto.
-----
Lemma hlist_app_nil_r : forall ls (h : hlist ls), hlist_app h Hnil = match eq_sym (app_nil_r_trans ls) in _ = t return hlist t with | eq_refl => h end.
Proof.
induction h.

*****
IHh : eq (hlist_app h Hnil)\n match\n eq_sym (app_nil_r_trans@{Ui} ls) in (eq _ t) return (hlist t)\n with\n | eq_refl => h\n end
h : hlist ls
f : F l
ls : list iT
l : iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
eq (hlist_app (Hcons f h) Hnil) match eq_sym (app_nil_r_trans@{Ui} (cons l ls)) in (eq _ t) return (hlist t) with | eq_refl => Hcons f h end
+++++
simpl.
-----
Lemma hlist_app_nil_r : forall ls (h : hlist ls), hlist_app h Hnil = match eq_sym (app_nil_r_trans ls) in _ = t return hlist t with | eq_refl => h end.
Proof.
induction h.
simpl.

*****
IHh : eq (hlist_app h Hnil)\n match\n eq_sym (app_nil_r_trans@{Ui} ls) in (eq _ t) return (hlist t)\n with\n | eq_refl => h\n end
h : hlist ls
f : F l
ls : list iT
l : iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
eq (Hcons f (hlist_app h Hnil)) match eq_sym match app_nil_r_trans@{Ui} ls in (eq _ X) return (eq (cons l (app ls nil)) (cons l X)) with | eq_refl => eq_refl end in (eq _ t) return (hlist t) with | eq_refl => Hcons f h end
+++++
intros.
-----
Lemma hlist_app_nil_r : forall ls (h : hlist ls), hlist_app h Hnil = match eq_sym (app_nil_r_trans ls) in _ = t return hlist t with | eq_refl => h end.
Proof.
induction h.
simpl.
intros.

*****
IHh : eq (hlist_app h Hnil)\n match\n eq_sym (app_nil_r_trans@{Ui} ls) in (eq _ t) return (hlist t)\n with\n | eq_refl => h\n end
h : hlist ls
f : F l
ls : list iT
l : iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
eq (Hcons f (hlist_app h Hnil)) match eq_sym match app_nil_r_trans@{Ui} ls in (eq _ X) return (eq (cons l (app ls nil)) (cons l X)) with | eq_refl => eq_refl end in (eq _ t) return (hlist t) with | eq_refl => Hcons f h end
+++++
auto.
-----
Lemma hlist_app_nil_r : forall ls (h : hlist ls), hlist_app h Hnil = match eq_sym (app_nil_r_trans ls) in _ = t return hlist t with | eq_refl => h end.
Proof.
induction h.
simpl.
intros.
auto.

*****
IHh : eq (hlist_app h Hnil)\n match\n eq_sym (app_nil_r_trans@{Ui} ls) in (eq _ t) return (hlist t)\n with\n | eq_refl => h\n end
h : hlist ls
f : F l
ls : list iT
l : iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
eq (Hcons f (hlist_app h Hnil)) match eq_sym match app_nil_r_trans@{Ui} ls in (eq _ X) return (eq (cons l (app ls nil)) (cons l X)) with | eq_refl => eq_refl end in (eq _ t) return (hlist t) with | eq_refl => Hcons f h end
+++++
rewrite IHh at 1.
-----
Lemma hlist_app_nil_r : forall ls (h : hlist ls), hlist_app h Hnil = match eq_sym (app_nil_r_trans ls) in _ = t return hlist t with | eq_refl => h end.
Proof.
induction h.
simpl.
intros.
auto.
rewrite IHh at 1.

*****
IHh : eq (hlist_app h Hnil)\n match\n eq_sym (app_nil_r_trans@{Ui} ls) in (eq _ t) return (hlist t)\n with\n | eq_refl => h\n end
h : hlist ls
f : F l
ls : list iT
l : iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
eq (Hcons f match eq_sym (app_nil_r_trans@{Ui} ls) in (eq _ t) return (hlist t) with | eq_refl => h end) match eq_sym match app_nil_r_trans@{Ui} ls in (eq _ X) return (eq (cons l (app ls nil)) (cons l X)) with | eq_refl => eq_refl end in (eq _ t) return (hlist t) with | eq_refl => Hcons f h end
+++++
unfold eq_trans.
-----
Lemma hlist_app_nil_r : forall ls (h : hlist ls), hlist_app h Hnil = match eq_sym (app_nil_r_trans ls) in _ = t return hlist t with | eq_refl => h end.
Proof.
induction h.
simpl.
intros.
auto.
rewrite IHh at 1.
unfold eq_trans.

*****
IHh : eq (hlist_app h Hnil)\n match\n eq_sym (app_nil_r_trans@{Ui} ls) in (eq _ t) return (hlist t)\n with\n | eq_refl => h\n end
h : hlist ls
f : F l
ls : list iT
l : iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
eq (Hcons f match eq_sym (app_nil_r_trans@{Ui} ls) in (eq _ t) return (hlist t) with | eq_refl => h end) match eq_sym match app_nil_r_trans@{Ui} ls in (eq _ X) return (eq (cons l (app ls nil)) (cons l X)) with | eq_refl => eq_refl end in (eq _ t) return (hlist t) with | eq_refl => Hcons f h end
+++++
unfold f_equal.
-----
Lemma hlist_app_nil_r : forall ls (h : hlist ls), hlist_app h Hnil = match eq_sym (app_nil_r_trans ls) in _ = t return hlist t with | eq_refl => h end.
Proof.
induction h.
simpl.
intros.
auto.
rewrite IHh at 1.
unfold eq_trans.
unfold f_equal.

*****
IHh : eq (hlist_app h Hnil)\n match\n eq_sym (app_nil_r_trans@{Ui} ls) in (eq _ t) return (hlist t)\n with\n | eq_refl => h\n end
h : hlist ls
f : F l
ls : list iT
l : iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
eq (Hcons f match eq_sym (app_nil_r_trans@{Ui} ls) in (eq _ t) return (hlist t) with | eq_refl => h end) match eq_sym match app_nil_r_trans@{Ui} ls in (eq _ X) return (eq (cons l (app ls nil)) (cons l X)) with | eq_refl => eq_refl end in (eq _ t) return (hlist t) with | eq_refl => Hcons f h end
+++++
unfold eq_sym.
-----
Lemma hlist_app_nil_r : forall ls (h : hlist ls), hlist_app h Hnil = match eq_sym (app_nil_r_trans ls) in _ = t return hlist t with | eq_refl => h end.
Proof.
induction h.
simpl.
intros.
auto.
rewrite IHh at 1.
unfold eq_trans.
unfold f_equal.
unfold eq_sym.

*****
IHh : eq (hlist_app h Hnil)\n match\n eq_sym (app_nil_r_trans@{Ui} ls) in (eq _ t) return (hlist t)\n with\n | eq_refl => h\n end
h : hlist ls
f : F l
ls : list iT
l : iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
eq (Hcons f match match app_nil_r_trans@{Ui} ls in (eq _ y) return (eq y (app ls nil)) with | eq_refl => eq_refl end in (eq _ t) return (hlist t) with | eq_refl => h end) match match match app_nil_r_trans@{Ui} ls in (eq _ X) return (eq (cons l (app ls nil)) (cons l X)) with | eq_refl => eq_refl end in (eq _ y) return (eq y (cons l (app ls nil))) with | eq_refl => eq_refl end in (eq _ t) return (hlist t) with | eq_refl => Hcons f h end
+++++
clear.
-----
Lemma hlist_app_nil_r : forall ls (h : hlist ls), hlist_app h Hnil = match eq_sym (app_nil_r_trans ls) in _ = t return hlist t with | eq_refl => h end.
Proof.
induction h.
simpl.
intros.
auto.
rewrite IHh at 1.
unfold eq_trans.
unfold f_equal.
unfold eq_sym.
clear.

*****
h : hlist ls
f : F l
ls : list iT
l : iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
eq (Hcons f match match app_nil_r_trans@{Ui} ls in (eq _ y) return (eq y (app ls nil)) with | eq_refl => eq_refl end in (eq _ t) return (hlist t) with | eq_refl => h end) match match match app_nil_r_trans@{Ui} ls in (eq _ X) return (eq (cons l (app ls nil)) (cons l X)) with | eq_refl => eq_refl end in (eq _ y) return (eq y (cons l (app ls nil))) with | eq_refl => eq_refl end in (eq _ t) return (hlist t) with | eq_refl => Hcons f h end
+++++
revert h.
-----
Lemma hlist_app_nil_r : forall ls (h : hlist ls), hlist_app h Hnil = match eq_sym (app_nil_r_trans ls) in _ = t return hlist t with | eq_refl => h end.
Proof.
induction h.
simpl.
intros.
auto.
rewrite IHh at 1.
unfold eq_trans.
unfold f_equal.
unfold eq_sym.
clear.
revert h.

*****
f : F l
ls : list iT
l : iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall h : hlist ls, eq (Hcons f match match app_nil_r_trans@{Ui} ls in (eq _ y) return (eq y (app ls nil)) with | eq_refl => eq_refl end in (eq _ t) return (hlist t) with | eq_refl => h end) match match match app_nil_r_trans@{Ui} ls in (eq _ X) return (eq (cons l (app ls nil)) (cons l X)) with | eq_refl => eq_refl end in (eq _ y) return (eq y (cons l (app ls nil))) with | eq_refl => eq_refl end in (eq _ t) return (hlist t) with | eq_refl => Hcons f h end
+++++
generalize dependent (app_nil_r_trans ls).
-----
Lemma hlist_app_nil_r : forall ls (h : hlist ls), hlist_app h Hnil = match eq_sym (app_nil_r_trans ls) in _ = t return hlist t with | eq_refl => h end.
Proof.
induction h.
simpl.
intros.
auto.
rewrite IHh at 1.
unfold eq_trans.
unfold f_equal.
unfold eq_sym.
clear.
revert h.
generalize dependent (app_nil_r_trans ls).

*****
f : F l
ls : list iT
l : iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall (e : eq (app ls nil) ls) (h : hlist ls), eq (Hcons f match match e in (eq _ y) return (eq y (app ls nil)) with | eq_refl => eq_refl end in (eq _ t) return (hlist t) with | eq_refl => h end) match match match e in (eq _ X) return (eq (cons l (app ls nil)) (cons l X)) with | eq_refl => eq_refl end in (eq _ y) return (eq y (cons l (app ls nil))) with | eq_refl => eq_refl end in (eq _ t) return (hlist t) with | eq_refl => Hcons f h end
+++++
destruct e.
-----
Lemma hlist_app_nil_r : forall ls (h : hlist ls), hlist_app h Hnil = match eq_sym (app_nil_r_trans ls) in _ = t return hlist t with | eq_refl => h end.
Proof.
induction h.
simpl.
intros.
auto.
rewrite IHh at 1.
unfold eq_trans.
unfold f_equal.
unfold eq_sym.
clear.
revert h.
generalize dependent (app_nil_r_trans ls).
destruct e.

*****
f : F l
ls : list iT
l : iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall h : hlist (app ls nil), eq (Hcons f h) (Hcons f h)
+++++
reflexivity.
-----
Lemma hlist_app_nil_r : forall ls (h : hlist ls), hlist_app h Hnil = match eq_sym (app_nil_r_trans ls) in _ = t return hlist t with | eq_refl => h end.
Proof.
induction h.

*****

*****

+++++
Qed.
-----
Fixpoint hlist_rev' ls ls' (h : hlist ls) : hlist ls' -> hlist (rev ls ++ ls') :=\n    match h in hlist ls return hlist ls' -> hlist (rev ls ++ ls') with\n    | Hnil => fun h => h\n    | Hcons l ls0 x h' => fun hacc =>\n      match app_ass_trans (rev ls0) (l :: nil) ls' in _ = t\n            return hlist t -> hlist _\n      with\n      | eq_refl => fun x => x\n      end (@hlist_rev' _ (l :: ls') h' (Hcons x hacc))\n    end.
-----
Definition hlist_rev ls (h : hlist ls) : hlist (rev ls) :=\n    match app_nil_r_trans (rev ls) in _ = t return hlist t with\n      | eq_refl => hlist_rev' h Hnil\n    end.
-----
Lemma hlist_rev_nil : hlist_rev Hnil = Hnil.
-----
Lemma hlist_rev_nil : hlist_rev Hnil = Hnil.

*****
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
eq (hlist_rev Hnil) Hnil
+++++
Proof.
-----
Lemma hlist_rev_nil : hlist_rev Hnil = Hnil.
Proof.

*****
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
eq (hlist_rev Hnil) Hnil
+++++
reflexivity.
-----
Lemma hlist_rev_nil : hlist_rev Hnil = Hnil.
Proof.
reflexivity.

*****

*****

+++++
Qed.
-----
Section equiv.
-----
Variable eqv : forall x, relation (F x).
-----
Inductive equiv_hlist : forall ls, hlist ls -> hlist ls -> Prop :=\n    | hlist_eqv_nil : equiv_hlist Hnil Hnil\n    | hlist_eqv_cons : forall l ls x y h1 h2, eqv x y -> equiv_hlist h1 h2 ->\n      @equiv_hlist (l :: ls) (Hcons x h1) (Hcons y h2).
-----
Global Instance Reflexive_equiv_hlist (R : forall t, Reflexive (@eqv t)) ls\n    : Reflexive (@equiv_hlist ls).
-----
Global Instance Reflexive_equiv_hlist (R : forall t, Reflexive (@eqv t)) ls : Reflexive (@equiv_hlist ls).

*****
ls : list iT
R : forall t : iT, Reflexive (eqv (x:=t))
eqv : forall x : iT, relation (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
Reflexive (equiv_hlist (ls:=ls))
+++++
Proof.
-----
Global Instance Reflexive_equiv_hlist (R : forall t, Reflexive (@eqv t)) ls : Reflexive (@equiv_hlist ls).
Proof.

*****
ls : list iT
R : forall t : iT, Reflexive (eqv (x:=t))
eqv : forall x : iT, relation (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
Reflexive (equiv_hlist (ls:=ls))
+++++
red.
-----
Global Instance Reflexive_equiv_hlist (R : forall t, Reflexive (@eqv t)) ls : Reflexive (@equiv_hlist ls).
Proof.
red.

*****
ls : list iT
R : forall t : iT, Reflexive (eqv (x:=t))
eqv : forall x : iT, relation (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall x : hlist ls, equiv_hlist x x
+++++
induction x.
-----
Global Instance Reflexive_equiv_hlist (R : forall t, Reflexive (@eqv t)) ls : Reflexive (@equiv_hlist ls).
Proof.
red.
induction x.

*****
R : forall t : iT, Reflexive (eqv (x:=t))
eqv : forall x : iT, relation (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
equiv_hlist Hnil Hnil
+++++
constructor.
-----
Global Instance Reflexive_equiv_hlist (R : forall t, Reflexive (@eqv t)) ls : Reflexive (@equiv_hlist ls).
Proof.
red.
induction x.

*****
IHx : equiv_hlist x x
x : hlist ls
f : F l
ls : list iT
l : iT
R : forall t : iT, Reflexive (eqv (x:=t))
eqv : forall x : iT, relation (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
equiv_hlist (Hcons f x) (Hcons f x)
+++++
constructor.
-----
Global Instance Reflexive_equiv_hlist (R : forall t, Reflexive (@eqv t)) ls : Reflexive (@equiv_hlist ls).
Proof.
red.
induction x.
constructor.

*****
IHx : equiv_hlist x x
x : hlist ls
f : F l
ls : list iT
l : iT
R : forall t : iT, Reflexive (eqv (x:=t))
eqv : forall x : iT, relation (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
eqv f f
+++++
auto.
-----
Global Instance Reflexive_equiv_hlist (R : forall t, Reflexive (@eqv t)) ls : Reflexive (@equiv_hlist ls).
Proof.
red.
induction x.
constructor.
auto.

*****
IHx : equiv_hlist x x
x : hlist ls
f : F l
ls : list iT
l : iT
R : forall t : iT, Reflexive (eqv (x:=t))
eqv : forall x : iT, relation (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
eqv f f
+++++
reflexivity.
-----
Global Instance Reflexive_equiv_hlist (R : forall t, Reflexive (@eqv t)) ls : Reflexive (@equiv_hlist ls).
Proof.
red.
induction x.
constructor.

*****
IHx : equiv_hlist x x
x : hlist ls
f : F l
ls : list iT
l : iT
R : forall t : iT, Reflexive (eqv (x:=t))
eqv : forall x : iT, relation (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
equiv_hlist x x
+++++
auto.
-----
Global Instance Reflexive_equiv_hlist (R : forall t, Reflexive (@eqv t)) ls : Reflexive (@equiv_hlist ls).
Proof.
red.
induction x.

*****

*****

+++++
Qed.
-----
Global Instance Symmetric_equiv_hlist (R : forall t, Symmetric (@eqv t)) ls\n    : Symmetric (@equiv_hlist ls).
-----
Global Instance Symmetric_equiv_hlist (R : forall t, Symmetric (@eqv t)) ls : Symmetric (@equiv_hlist ls).

*****
ls : list iT
R : forall t : iT, Symmetric (eqv (x:=t))
eqv : forall x : iT, relation (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
Symmetric (equiv_hlist (ls:=ls))
+++++
Proof.
-----
Global Instance Symmetric_equiv_hlist (R : forall t, Symmetric (@eqv t)) ls : Symmetric (@equiv_hlist ls).
Proof.

*****
ls : list iT
R : forall t : iT, Symmetric (eqv (x:=t))
eqv : forall x : iT, relation (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
Symmetric (equiv_hlist (ls:=ls))
+++++
red.
-----
Global Instance Symmetric_equiv_hlist (R : forall t, Symmetric (@eqv t)) ls : Symmetric (@equiv_hlist ls).
Proof.
red.

*****
ls : list iT
R : forall t : iT, Symmetric (eqv (x:=t))
eqv : forall x : iT, relation (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall (x y : hlist ls) (_ : equiv_hlist x y), equiv_hlist y x
+++++
induction 1.
-----
Global Instance Symmetric_equiv_hlist (R : forall t, Symmetric (@eqv t)) ls : Symmetric (@equiv_hlist ls).
Proof.
red.
induction 1.

*****
R : forall t : iT, Symmetric (eqv (x:=t))
eqv : forall x : iT, relation (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
equiv_hlist Hnil Hnil
+++++
constructor.
-----
Global Instance Symmetric_equiv_hlist (R : forall t, Symmetric (@eqv t)) ls : Symmetric (@equiv_hlist ls).
Proof.
red.
induction 1.

*****
IHequiv_hlist : equiv_hlist h2 h1
H0 : equiv_hlist h1 h2
H : eqv x y
h1,h2 : hlist ls
x,y : F l
ls : list iT
l : iT
R : forall t : iT, Symmetric (eqv (x:=t))
eqv : forall x : iT, relation (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
equiv_hlist (Hcons y h2) (Hcons x h1)
+++++
constructor.
-----
Global Instance Symmetric_equiv_hlist (R : forall t, Symmetric (@eqv t)) ls : Symmetric (@equiv_hlist ls).
Proof.
red.
induction 1.
constructor.

*****
IHequiv_hlist : equiv_hlist h2 h1
H0 : equiv_hlist h1 h2
H : eqv x y
h1,h2 : hlist ls
x,y : F l
ls : list iT
l : iT
R : forall t : iT, Symmetric (eqv (x:=t))
eqv : forall x : iT, relation (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
eqv y x
+++++
symmetry.
-----
Global Instance Symmetric_equiv_hlist (R : forall t, Symmetric (@eqv t)) ls : Symmetric (@equiv_hlist ls).
Proof.
red.
induction 1.
constructor.
symmetry.

*****
IHequiv_hlist : equiv_hlist h2 h1
H0 : equiv_hlist h1 h2
H : eqv x y
h1,h2 : hlist ls
x,y : F l
ls : list iT
l : iT
R : forall t : iT, Symmetric (eqv (x:=t))
eqv : forall x : iT, relation (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
eqv x y
+++++
assumption.
-----
Global Instance Symmetric_equiv_hlist (R : forall t, Symmetric (@eqv t)) ls : Symmetric (@equiv_hlist ls).
Proof.
red.
induction 1.
constructor.

*****
IHequiv_hlist : equiv_hlist h2 h1
H0 : equiv_hlist h1 h2
H : eqv x y
h1,h2 : hlist ls
x,y : F l
ls : list iT
l : iT
R : forall t : iT, Symmetric (eqv (x:=t))
eqv : forall x : iT, relation (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
equiv_hlist h2 h1
+++++
auto.
-----
Global Instance Symmetric_equiv_hlist (R : forall t, Symmetric (@eqv t)) ls : Symmetric (@equiv_hlist ls).
Proof.
red.
induction 1.

*****

*****

+++++
Qed.
-----
Global Instance Transitive_equiv_hlist (R : forall t, Transitive (@eqv t)) ls\n    : Transitive (@equiv_hlist ls).
-----
Global Instance Transitive_equiv_hlist (R : forall t, Transitive (@eqv t)) ls : Transitive (@equiv_hlist ls).

*****
ls : list iT
R : forall t : iT, Transitive (eqv (x:=t))
eqv : forall x : iT, relation (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
Transitive (equiv_hlist (ls:=ls))
+++++
Proof.
-----
Global Instance Transitive_equiv_hlist (R : forall t, Transitive (@eqv t)) ls : Transitive (@equiv_hlist ls).
Proof.

*****
ls : list iT
R : forall t : iT, Transitive (eqv (x:=t))
eqv : forall x : iT, relation (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
Transitive (equiv_hlist (ls:=ls))
+++++
red.
-----
Global Instance Transitive_equiv_hlist (R : forall t, Transitive (@eqv t)) ls : Transitive (@equiv_hlist ls).
Proof.
red.

*****
ls : list iT
R : forall t : iT, Transitive (eqv (x:=t))
eqv : forall x : iT, relation (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall (x y z : hlist ls) (_ : equiv_hlist x y) (_ : equiv_hlist y z), equiv_hlist x z
+++++
induction 1.
-----
Global Instance Transitive_equiv_hlist (R : forall t, Transitive (@eqv t)) ls : Transitive (@equiv_hlist ls).
Proof.
red.
induction 1.

*****
z : hlist nil
R : forall t : iT, Transitive (eqv (x:=t))
eqv : forall x : iT, relation (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall _ : equiv_hlist Hnil z, equiv_hlist Hnil z
+++++
intro.
-----
Global Instance Transitive_equiv_hlist (R : forall t, Transitive (@eqv t)) ls : Transitive (@equiv_hlist ls).
Proof.
red.
induction 1.
intro.

*****
H : equiv_hlist Hnil z
z : hlist nil
R : forall t : iT, Transitive (eqv (x:=t))
eqv : forall x : iT, relation (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
equiv_hlist Hnil z
+++++
assumption.
-----
Global Instance Transitive_equiv_hlist (R : forall t, Transitive (@eqv t)) ls : Transitive (@equiv_hlist ls).
Proof.
red.
induction 1.

*****
IHequiv_hlist : forall (z : hlist ls) (_ : equiv_hlist h2 z), equiv_hlist h1 z
H0 : equiv_hlist h1 h2
H : eqv x y
h1,h2 : hlist ls
x,y : F l
z : hlist (cons l ls)
ls : list iT
l : iT
R : forall t : iT, Transitive (eqv (x:=t))
eqv : forall x : iT, relation (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall _ : equiv_hlist (Hcons y h2) z, equiv_hlist (Hcons x h1) z
+++++
rewrite (hlist_eta z).
-----
Global Instance Transitive_equiv_hlist (R : forall t, Transitive (@eqv t)) ls : Transitive (@equiv_hlist ls).
Proof.
red.
induction 1.
rewrite (hlist_eta z).

*****
IHequiv_hlist : forall (z : hlist ls) (_ : equiv_hlist h2 z), equiv_hlist h1 z
H0 : equiv_hlist h1 h2
H : eqv x y
h1,h2 : hlist ls
x,y : F l
z : hlist (cons l ls)
ls : list iT
l : iT
R : forall t : iT, Transitive (eqv (x:=t))
eqv : forall x : iT, relation (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall _ : equiv_hlist (Hcons y h2) (Hcons (hlist_hd z) (hlist_tl z)), equiv_hlist (Hcons x h1) (Hcons (hlist_hd z) (hlist_tl z))
+++++
refine (fun H' => match H' in @equiv_hlist ls X Y return match ls as ls return hlist ls -> hlist ls -> Prop with | nil => fun _ _ : hlist nil => True | l :: ls => fun (X Y : hlist (l :: ls)) => forall Z x xs, eqv (hlist_hd Z) (hlist_hd X) -> equiv_hlist xs (hlist_tl X) -> (forall z : hlist ls, equiv_hlist (hlist_tl X) z -> equiv_hlist (hlist_tl Z) z) -> @equiv_hlist (l :: ls) Z Y end X Y with | hlist_eqv_nil => I | hlist_eqv_cons l ls x y h1 h2 pf pf' => _ end (Hcons x h1) x _ H H0 (@IHequiv_hlist)).
-----
Global Instance Transitive_equiv_hlist (R : forall t, Transitive (@eqv t)) ls : Transitive (@equiv_hlist ls).
Proof.
red.
induction 1.
rewrite (hlist_eta z).
refine (fun H' => match H' in @equiv_hlist ls X Y return match ls as ls return hlist ls -> hlist ls -> Prop with | nil => fun _ _ : hlist nil => True | l :: ls => fun (X Y : hlist (l :: ls)) => forall Z x xs, eqv (hlist_hd Z) (hlist_hd X) -> equiv_hlist xs (hlist_tl X) -> (forall z : hlist ls, equiv_hlist (hlist_tl X) z -> equiv_hlist (hlist_tl Z) z) -> @equiv_hlist (l :: ls) Z Y end X Y with | hlist_eqv_nil => I | hlist_eqv_cons l ls x y h1 h2 pf pf' => _ end (Hcons x h1) x _ H H0 (@IHequiv_hlist)).

*****
pf' : equiv_hlist h1 h2
pf : eqv x y
h1,h2 : hlist ls
x,y : F l
ls : list iT
l : iT
H' : equiv_hlist (Hcons y0 h4) (Hcons (hlist_hd z) (hlist_tl z))
IHequiv_hlist : forall (z : hlist ls0) (_ : equiv_hlist h4 z), equiv_hlist h3 z
H0 : equiv_hlist h3 h4
H : eqv x0 y0
h3,h4 : hlist ls0
x0,y0 : F l0
z : hlist (cons l0 ls0)
ls0 : list iT
l0 : iT
R : forall t : iT, Transitive (eqv (x:=t))
eqv : forall x : iT, relation (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall (Z : hlist (cons l ls)) (_ : F l) (xs : hlist ls) (_ : eqv (hlist_hd Z) (hlist_hd (Hcons x h1))) (_ : equiv_hlist xs (hlist_tl (Hcons x h1))) (_ : forall (z : hlist ls) (_ : equiv_hlist (hlist_tl (Hcons x h1)) z), equiv_hlist (hlist_tl Z) z), equiv_hlist Z (Hcons y h2)
+++++
intros.
-----
Global Instance Transitive_equiv_hlist (R : forall t, Transitive (@eqv t)) ls : Transitive (@equiv_hlist ls).
Proof.
red.
induction 1.
rewrite (hlist_eta z).
refine (fun H' => match H' in @equiv_hlist ls X Y return match ls as ls return hlist ls -> hlist ls -> Prop with | nil => fun _ _ : hlist nil => True | l :: ls => fun (X Y : hlist (l :: ls)) => forall Z x xs, eqv (hlist_hd Z) (hlist_hd X) -> equiv_hlist xs (hlist_tl X) -> (forall z : hlist ls, equiv_hlist (hlist_tl X) z -> equiv_hlist (hlist_tl Z) z) -> @equiv_hlist (l :: ls) Z Y end X Y with | hlist_eqv_nil => I | hlist_eqv_cons l ls x y h1 h2 pf pf' => _ end (Hcons x h1) x _ H H0 (@IHequiv_hlist)).
intros.

*****
H3 : forall (z : hlist ls) (_ : equiv_hlist (hlist_tl (Hcons x h1)) z),\nequiv_hlist (hlist_tl Z) z
H2 : equiv_hlist xs (hlist_tl (Hcons x h1))
H1 : eqv (hlist_hd Z) (hlist_hd (Hcons x h1))
xs : hlist ls
x1 : F l
Z : hlist (cons l ls)
pf' : equiv_hlist h1 h2
pf : eqv x y
h1,h2 : hlist ls
x,y : F l
ls : list iT
l : iT
H' : equiv_hlist (Hcons y0 h4) (Hcons (hlist_hd z) (hlist_tl z))
IHequiv_hlist : forall (z : hlist ls0) (_ : equiv_hlist h4 z), equiv_hlist h3 z
H0 : equiv_hlist h3 h4
H : eqv x0 y0
h3,h4 : hlist ls0
x0,y0 : F l0
z : hlist (cons l0 ls0)
ls0 : list iT
l0 : iT
R : forall t : iT, Transitive (eqv (x:=t))
eqv : forall x : iT, relation (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
equiv_hlist Z (Hcons y h2)
+++++
rewrite (hlist_eta Z).
-----
Global Instance Transitive_equiv_hlist (R : forall t, Transitive (@eqv t)) ls : Transitive (@equiv_hlist ls).
Proof.
red.
induction 1.
rewrite (hlist_eta z).
refine (fun H' => match H' in @equiv_hlist ls X Y return match ls as ls return hlist ls -> hlist ls -> Prop with | nil => fun _ _ : hlist nil => True | l :: ls => fun (X Y : hlist (l :: ls)) => forall Z x xs, eqv (hlist_hd Z) (hlist_hd X) -> equiv_hlist xs (hlist_tl X) -> (forall z : hlist ls, equiv_hlist (hlist_tl X) z -> equiv_hlist (hlist_tl Z) z) -> @equiv_hlist (l :: ls) Z Y end X Y with | hlist_eqv_nil => I | hlist_eqv_cons l ls x y h1 h2 pf pf' => _ end (Hcons x h1) x _ H H0 (@IHequiv_hlist)).
intros.
rewrite (hlist_eta Z).

*****
H3 : forall (z : hlist ls) (_ : equiv_hlist (hlist_tl (Hcons x h1)) z),\nequiv_hlist (hlist_tl Z) z
H2 : equiv_hlist xs (hlist_tl (Hcons x h1))
H1 : eqv (hlist_hd Z) (hlist_hd (Hcons x h1))
xs : hlist ls
x1 : F l
Z : hlist (cons l ls)
pf' : equiv_hlist h1 h2
pf : eqv x y
h1,h2 : hlist ls
x,y : F l
ls : list iT
l : iT
H' : equiv_hlist (Hcons y0 h4) (Hcons (hlist_hd z) (hlist_tl z))
IHequiv_hlist : forall (z : hlist ls0) (_ : equiv_hlist h4 z), equiv_hlist h3 z
H0 : equiv_hlist h3 h4
H : eqv x0 y0
h3,h4 : hlist ls0
x0,y0 : F l0
z : hlist (cons l0 ls0)
ls0 : list iT
l0 : iT
R : forall t : iT, Transitive (eqv (x:=t))
eqv : forall x : iT, relation (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
equiv_hlist (Hcons (hlist_hd Z) (hlist_tl Z)) (Hcons y h2)
+++++
constructor.
-----
Global Instance Transitive_equiv_hlist (R : forall t, Transitive (@eqv t)) ls : Transitive (@equiv_hlist ls).
Proof.
red.
induction 1.
rewrite (hlist_eta z).
refine (fun H' => match H' in @equiv_hlist ls X Y return match ls as ls return hlist ls -> hlist ls -> Prop with | nil => fun _ _ : hlist nil => True | l :: ls => fun (X Y : hlist (l :: ls)) => forall Z x xs, eqv (hlist_hd Z) (hlist_hd X) -> equiv_hlist xs (hlist_tl X) -> (forall z : hlist ls, equiv_hlist (hlist_tl X) z -> equiv_hlist (hlist_tl Z) z) -> @equiv_hlist (l :: ls) Z Y end X Y with | hlist_eqv_nil => I | hlist_eqv_cons l ls x y h1 h2 pf pf' => _ end (Hcons x h1) x _ H H0 (@IHequiv_hlist)).
intros.
rewrite (hlist_eta Z).
constructor.

*****
H3 : forall (z : hlist ls) (_ : equiv_hlist (hlist_tl (Hcons x h1)) z),\nequiv_hlist (hlist_tl Z) z
H2 : equiv_hlist xs (hlist_tl (Hcons x h1))
H1 : eqv (hlist_hd Z) (hlist_hd (Hcons x h1))
xs : hlist ls
x1 : F l
Z : hlist (cons l ls)
pf' : equiv_hlist h1 h2
pf : eqv x y
h1,h2 : hlist ls
x,y : F l
ls : list iT
l : iT
H' : equiv_hlist (Hcons y0 h4) (Hcons (hlist_hd z) (hlist_tl z))
IHequiv_hlist : forall (z : hlist ls0) (_ : equiv_hlist h4 z), equiv_hlist h3 z
H0 : equiv_hlist h3 h4
H : eqv x0 y0
h3,h4 : hlist ls0
x0,y0 : F l0
z : hlist (cons l0 ls0)
ls0 : list iT
l0 : iT
R : forall t : iT, Transitive (eqv (x:=t))
eqv : forall x : iT, relation (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
eqv (hlist_hd Z) y
+++++
simpl in *.
-----
Global Instance Transitive_equiv_hlist (R : forall t, Transitive (@eqv t)) ls : Transitive (@equiv_hlist ls).
Proof.
red.
induction 1.
rewrite (hlist_eta z).
refine (fun H' => match H' in @equiv_hlist ls X Y return match ls as ls return hlist ls -> hlist ls -> Prop with | nil => fun _ _ : hlist nil => True | l :: ls => fun (X Y : hlist (l :: ls)) => forall Z x xs, eqv (hlist_hd Z) (hlist_hd X) -> equiv_hlist xs (hlist_tl X) -> (forall z : hlist ls, equiv_hlist (hlist_tl X) z -> equiv_hlist (hlist_tl Z) z) -> @equiv_hlist (l :: ls) Z Y end X Y with | hlist_eqv_nil => I | hlist_eqv_cons l ls x y h1 h2 pf pf' => _ end (Hcons x h1) x _ H H0 (@IHequiv_hlist)).
intros.
rewrite (hlist_eta Z).
constructor.
simpl in *.

*****
H3 : forall (z : hlist ls) (_ : equiv_hlist h1 z),\nequiv_hlist (hlist_tl Z) z
H2 : equiv_hlist xs h1
H1 : eqv (hlist_hd Z) x
xs : hlist ls
x1 : F l
Z : hlist (cons l ls)
pf' : equiv_hlist h1 h2
pf : eqv x y
h1,h2 : hlist ls
x,y : F l
ls : list iT
l : iT
H' : equiv_hlist (Hcons y0 h4) (Hcons (hlist_hd z) (hlist_tl z))
IHequiv_hlist : forall (z : hlist ls0) (_ : equiv_hlist h4 z), equiv_hlist h3 z
H0 : equiv_hlist h3 h4
H : eqv x0 y0
h3,h4 : hlist ls0
x0,y0 : F l0
z : hlist (cons l0 ls0)
ls0 : list iT
l0 : iT
R : forall t : iT, Transitive (eqv (x:=t))
eqv : forall x : iT, relation (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
eqv (hlist_hd Z) y
+++++
etransitivity.
-----
Global Instance Transitive_equiv_hlist (R : forall t, Transitive (@eqv t)) ls : Transitive (@equiv_hlist ls).
Proof.
red.
induction 1.
rewrite (hlist_eta z).
refine (fun H' => match H' in @equiv_hlist ls X Y return match ls as ls return hlist ls -> hlist ls -> Prop with | nil => fun _ _ : hlist nil => True | l :: ls => fun (X Y : hlist (l :: ls)) => forall Z x xs, eqv (hlist_hd Z) (hlist_hd X) -> equiv_hlist xs (hlist_tl X) -> (forall z : hlist ls, equiv_hlist (hlist_tl X) z -> equiv_hlist (hlist_tl Z) z) -> @equiv_hlist (l :: ls) Z Y end X Y with | hlist_eqv_nil => I | hlist_eqv_cons l ls x y h1 h2 pf pf' => _ end (Hcons x h1) x _ H H0 (@IHequiv_hlist)).
intros.
rewrite (hlist_eta Z).
constructor.
simpl in *.
etransitivity.

*****
H3 : forall (z : hlist ls) (_ : equiv_hlist h1 z),\nequiv_hlist (hlist_tl Z) z
H2 : equiv_hlist xs h1
H1 : eqv (hlist_hd Z) x
xs : hlist ls
x1 : F l
Z : hlist (cons l ls)
pf' : equiv_hlist h1 h2
pf : eqv x y
h1,h2 : hlist ls
x,y : F l
ls : list iT
l : iT
H' : equiv_hlist (Hcons y0 h4) (Hcons (hlist_hd z) (hlist_tl z))
IHequiv_hlist : forall (z : hlist ls0) (_ : equiv_hlist h4 z), equiv_hlist h3 z
H0 : equiv_hlist h3 h4
H : eqv x0 y0
h3,h4 : hlist ls0
x0,y0 : F l0
z : hlist (cons l0 ls0)
ls0 : list iT
l0 : iT
R : forall t : iT, Transitive (eqv (x:=t))
eqv : forall x : iT, relation (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
eqv (hlist_hd Z) ?y
+++++
eassumption.
-----
Global Instance Transitive_equiv_hlist (R : forall t, Transitive (@eqv t)) ls : Transitive (@equiv_hlist ls).
Proof.
red.
induction 1.
rewrite (hlist_eta z).
refine (fun H' => match H' in @equiv_hlist ls X Y return match ls as ls return hlist ls -> hlist ls -> Prop with | nil => fun _ _ : hlist nil => True | l :: ls => fun (X Y : hlist (l :: ls)) => forall Z x xs, eqv (hlist_hd Z) (hlist_hd X) -> equiv_hlist xs (hlist_tl X) -> (forall z : hlist ls, equiv_hlist (hlist_tl X) z -> equiv_hlist (hlist_tl Z) z) -> @equiv_hlist (l :: ls) Z Y end X Y with | hlist_eqv_nil => I | hlist_eqv_cons l ls x y h1 h2 pf pf' => _ end (Hcons x h1) x _ H H0 (@IHequiv_hlist)).
intros.
rewrite (hlist_eta Z).
constructor.
simpl in *.
etransitivity.

*****
H3 : forall (z : hlist ls) (_ : equiv_hlist h1 z),\nequiv_hlist (hlist_tl Z) z
H2 : equiv_hlist xs h1
H1 : eqv (hlist_hd Z) x
xs : hlist ls
x1 : F l
Z : hlist (cons l ls)
pf' : equiv_hlist h1 h2
pf : eqv x y
h1,h2 : hlist ls
x,y : F l
ls : list iT
l : iT
H' : equiv_hlist (Hcons y0 h4) (Hcons (hlist_hd z) (hlist_tl z))
IHequiv_hlist : forall (z : hlist ls0) (_ : equiv_hlist h4 z), equiv_hlist h3 z
H0 : equiv_hlist h3 h4
H : eqv x0 y0
h3,h4 : hlist ls0
x0,y0 : F l0
z : hlist (cons l0 ls0)
ls0 : list iT
l0 : iT
R : forall t : iT, Transitive (eqv (x:=t))
eqv : forall x : iT, relation (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
eqv x y
+++++
eassumption.
-----
Global Instance Transitive_equiv_hlist (R : forall t, Transitive (@eqv t)) ls : Transitive (@equiv_hlist ls).
Proof.
red.
induction 1.
rewrite (hlist_eta z).
refine (fun H' => match H' in @equiv_hlist ls X Y return match ls as ls return hlist ls -> hlist ls -> Prop with | nil => fun _ _ : hlist nil => True | l :: ls => fun (X Y : hlist (l :: ls)) => forall Z x xs, eqv (hlist_hd Z) (hlist_hd X) -> equiv_hlist xs (hlist_tl X) -> (forall z : hlist ls, equiv_hlist (hlist_tl X) z -> equiv_hlist (hlist_tl Z) z) -> @equiv_hlist (l :: ls) Z Y end X Y with | hlist_eqv_nil => I | hlist_eqv_cons l ls x y h1 h2 pf pf' => _ end (Hcons x h1) x _ H H0 (@IHequiv_hlist)).
intros.
rewrite (hlist_eta Z).
constructor.

*****
H3 : forall (z : hlist ls) (_ : equiv_hlist (hlist_tl (Hcons x h1)) z),\nequiv_hlist (hlist_tl Z) z
H2 : equiv_hlist xs (hlist_tl (Hcons x h1))
H1 : eqv (hlist_hd Z) (hlist_hd (Hcons x h1))
xs : hlist ls
x1 : F l
Z : hlist (cons l ls)
pf' : equiv_hlist h1 h2
pf : eqv x y
h1,h2 : hlist ls
x,y : F l
ls : list iT
l : iT
H' : equiv_hlist (Hcons y0 h4) (Hcons (hlist_hd z) (hlist_tl z))
IHequiv_hlist : forall (z : hlist ls0) (_ : equiv_hlist h4 z), equiv_hlist h3 z
H0 : equiv_hlist h3 h4
H : eqv x0 y0
h3,h4 : hlist ls0
x0,y0 : F l0
z : hlist (cons l0 ls0)
ls0 : list iT
l0 : iT
R : forall t : iT, Transitive (eqv (x:=t))
eqv : forall x : iT, relation (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
equiv_hlist (hlist_tl Z) h2
+++++
eapply H3.
-----
Global Instance Transitive_equiv_hlist (R : forall t, Transitive (@eqv t)) ls : Transitive (@equiv_hlist ls).
Proof.
red.
induction 1.
rewrite (hlist_eta z).
refine (fun H' => match H' in @equiv_hlist ls X Y return match ls as ls return hlist ls -> hlist ls -> Prop with | nil => fun _ _ : hlist nil => True | l :: ls => fun (X Y : hlist (l :: ls)) => forall Z x xs, eqv (hlist_hd Z) (hlist_hd X) -> equiv_hlist xs (hlist_tl X) -> (forall z : hlist ls, equiv_hlist (hlist_tl X) z -> equiv_hlist (hlist_tl Z) z) -> @equiv_hlist (l :: ls) Z Y end X Y with | hlist_eqv_nil => I | hlist_eqv_cons l ls x y h1 h2 pf pf' => _ end (Hcons x h1) x _ H H0 (@IHequiv_hlist)).
intros.
rewrite (hlist_eta Z).
constructor.
eapply H3.

*****
H3 : forall (z : hlist ls) (_ : equiv_hlist (hlist_tl (Hcons x h1)) z),\nequiv_hlist (hlist_tl Z) z
H2 : equiv_hlist xs (hlist_tl (Hcons x h1))
H1 : eqv (hlist_hd Z) (hlist_hd (Hcons x h1))
xs : hlist ls
x1 : F l
Z : hlist (cons l ls)
pf' : equiv_hlist h1 h2
pf : eqv x y
h1,h2 : hlist ls
x,y : F l
ls : list iT
l : iT
H' : equiv_hlist (Hcons y0 h4) (Hcons (hlist_hd z) (hlist_tl z))
IHequiv_hlist : forall (z : hlist ls0) (_ : equiv_hlist h4 z), equiv_hlist h3 z
H0 : equiv_hlist h3 h4
H : eqv x0 y0
h3,h4 : hlist ls0
x0,y0 : F l0
z : hlist (cons l0 ls0)
ls0 : list iT
l0 : iT
R : forall t : iT, Transitive (eqv (x:=t))
eqv : forall x : iT, relation (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
equiv_hlist (hlist_tl (Hcons x h1)) h2
+++++
simpl in *.
-----
Global Instance Transitive_equiv_hlist (R : forall t, Transitive (@eqv t)) ls : Transitive (@equiv_hlist ls).
Proof.
red.
induction 1.
rewrite (hlist_eta z).
refine (fun H' => match H' in @equiv_hlist ls X Y return match ls as ls return hlist ls -> hlist ls -> Prop with | nil => fun _ _ : hlist nil => True | l :: ls => fun (X Y : hlist (l :: ls)) => forall Z x xs, eqv (hlist_hd Z) (hlist_hd X) -> equiv_hlist xs (hlist_tl X) -> (forall z : hlist ls, equiv_hlist (hlist_tl X) z -> equiv_hlist (hlist_tl Z) z) -> @equiv_hlist (l :: ls) Z Y end X Y with | hlist_eqv_nil => I | hlist_eqv_cons l ls x y h1 h2 pf pf' => _ end (Hcons x h1) x _ H H0 (@IHequiv_hlist)).
intros.
rewrite (hlist_eta Z).
constructor.
eapply H3.
simpl in *.

*****
H3 : forall (z : hlist ls) (_ : equiv_hlist h1 z),\nequiv_hlist (hlist_tl Z) z
H2 : equiv_hlist xs h1
H1 : eqv (hlist_hd Z) x
xs : hlist ls
x1 : F l
Z : hlist (cons l ls)
pf' : equiv_hlist h1 h2
pf : eqv x y
h1,h2 : hlist ls
x,y : F l
ls : list iT
l : iT
H' : equiv_hlist (Hcons y0 h4) (Hcons (hlist_hd z) (hlist_tl z))
IHequiv_hlist : forall (z : hlist ls0) (_ : equiv_hlist h4 z), equiv_hlist h3 z
H0 : equiv_hlist h3 h4
H : eqv x0 y0
h3,h4 : hlist ls0
x0,y0 : F l0
z : hlist (cons l0 ls0)
ls0 : list iT
l0 : iT
R : forall t : iT, Transitive (eqv (x:=t))
eqv : forall x : iT, relation (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
equiv_hlist h1 h2
+++++
eassumption.
-----
Global Instance Transitive_equiv_hlist (R : forall t, Transitive (@eqv t)) ls : Transitive (@equiv_hlist ls).
Proof.
red.
induction 1.

*****

*****

+++++
Qed.
-----
Lemma equiv_hlist_Hcons\n    : forall ls i a b (c : hlist ls) d,\n        equiv_hlist (Hcons a c) (@Hcons i ls b d) ->\n        (@eqv i a b /\ equiv_hlist c d).
-----
Lemma equiv_hlist_Hcons : forall ls i a b (c : hlist ls) d, equiv_hlist (Hcons a c) (@Hcons i ls b d) -> (@eqv i a b /\\ equiv_hlist c d).

*****
eqv : forall x : iT, relation (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall (ls : list iT) (i : iT) (a b : F i) (c d : hlist ls) (_ : equiv_hlist (Hcons a c) (Hcons b d)), and (eqv a b) (equiv_hlist c d)
+++++
Proof.
-----
Lemma equiv_hlist_Hcons : forall ls i a b (c : hlist ls) d, equiv_hlist (Hcons a c) (@Hcons i ls b d) -> (@eqv i a b /\\ equiv_hlist c d).
Proof.

*****
eqv : forall x : iT, relation (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall (ls : list iT) (i : iT) (a b : F i) (c d : hlist ls) (_ : equiv_hlist (Hcons a c) (Hcons b d)), and (eqv a b) (equiv_hlist c d)
+++++
clear.
-----
Lemma equiv_hlist_Hcons : forall ls i a b (c : hlist ls) d, equiv_hlist (Hcons a c) (@Hcons i ls b d) -> (@eqv i a b /\\ equiv_hlist c d).
Proof.
clear.

*****
eqv : forall x : iT, relation (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall (ls : list iT) (i : iT) (a b : F i) (c d : hlist ls) (_ : equiv_hlist (Hcons a c) (Hcons b d)), and (eqv a b) (equiv_hlist c d)
+++++
intros.
-----
Lemma equiv_hlist_Hcons : forall ls i a b (c : hlist ls) d, equiv_hlist (Hcons a c) (@Hcons i ls b d) -> (@eqv i a b /\\ equiv_hlist c d).
Proof.
clear.
intros.

*****
H : equiv_hlist (Hcons a c) (Hcons b d)
c,d : hlist ls
a,b : F i
i : iT
ls : list iT
eqv : forall x : iT, relation (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
and (eqv a b) (equiv_hlist c d)
+++++
refine match H in @equiv_hlist ls' l r return match ls' as ls' return hlist ls' -> hlist ls' -> _ with | nil => fun _ _ => True | l :: ls => fun l r => eqv (hlist_hd l) (hlist_hd r) /\ equiv_hlist (hlist_tl l) (hlist_tl r) end l r with | hlist_eqv_nil => I | hlist_eqv_cons _ _ _ _ _ _ pf pf' => conj pf pf' end.
-----
Lemma equiv_hlist_Hcons : forall ls i a b (c : hlist ls) d, equiv_hlist (Hcons a c) (@Hcons i ls b d) -> (@eqv i a b /\\ equiv_hlist c d).
Proof.
clear.
intros.
refine match H in @equiv_hlist ls' l r return match ls' as ls' return hlist ls' -> hlist ls' -> _ with | nil => fun _ _ => True | l :: ls => fun l r => eqv (hlist_hd l) (hlist_hd r) /\\ equiv_hlist (hlist_tl l) (hlist_tl r) end l r with | hlist_eqv_nil => I | hlist_eqv_cons _ _ _ _ _ _ pf pf' => conj pf pf' end.

*****

*****

+++++
Defined.
-----
Lemma equiv_hlist_app\n    : forall a b (c c' : hlist a)  (d d' : hlist b),\n        (equiv_hlist c c' /\ equiv_hlist d d')\n        <->\n        equiv_hlist (hlist_app c d) (hlist_app c' d').
-----
Lemma equiv_hlist_app : forall a b (c c' : hlist a) (d d' : hlist b), (equiv_hlist c c' /\\ equiv_hlist d d') <-> equiv_hlist (hlist_app c d) (hlist_app c' d').

*****
eqv : forall x : iT, relation (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall (a b : list iT) (c c' : hlist a) (d d' : hlist b), iff (and (equiv_hlist c c') (equiv_hlist d d')) (equiv_hlist (hlist_app c d) (hlist_app c' d'))
+++++
Proof.
-----
Lemma equiv_hlist_app : forall a b (c c' : hlist a) (d d' : hlist b), (equiv_hlist c c' /\\ equiv_hlist d d') <-> equiv_hlist (hlist_app c d) (hlist_app c' d').
Proof.

*****
eqv : forall x : iT, relation (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall (a b : list iT) (c c' : hlist a) (d d' : hlist b), iff (and (equiv_hlist c c') (equiv_hlist d d')) (equiv_hlist (hlist_app c d) (hlist_app c' d'))
+++++
clear.
-----
Lemma equiv_hlist_app : forall a b (c c' : hlist a) (d d' : hlist b), (equiv_hlist c c' /\\ equiv_hlist d d') <-> equiv_hlist (hlist_app c d) (hlist_app c' d').
Proof.
clear.

*****
eqv : forall x : iT, relation (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall (a b : list iT) (c c' : hlist a) (d d' : hlist b), iff (and (equiv_hlist c c') (equiv_hlist d d')) (equiv_hlist (hlist_app c d) (hlist_app c' d'))
+++++
split.
-----
Lemma equiv_hlist_app : forall a b (c c' : hlist a) (d d' : hlist b), (equiv_hlist c c' /\\ equiv_hlist d d') <-> equiv_hlist (hlist_app c d) (hlist_app c' d').
Proof.
clear.
split.

*****
d,d' : hlist b
c,c' : hlist a
a,b : list iT
eqv : forall x : iT, relation (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall _ : and (equiv_hlist c c') (equiv_hlist d d'), equiv_hlist (hlist_app c d) (hlist_app c' d')
+++++
destruct 1.
-----
Lemma equiv_hlist_app : forall a b (c c' : hlist a) (d d' : hlist b), (equiv_hlist c c' /\\ equiv_hlist d d') <-> equiv_hlist (hlist_app c d) (hlist_app c' d').
Proof.
clear.
split.
destruct 1.

*****
H0 : equiv_hlist d d'
H : equiv_hlist c c'
d,d' : hlist b
c,c' : hlist a
a,b : list iT
eqv : forall x : iT, relation (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
equiv_hlist (hlist_app c d) (hlist_app c' d')
+++++
induction H.
-----
Lemma equiv_hlist_app : forall a b (c c' : hlist a) (d d' : hlist b), (equiv_hlist c c' /\\ equiv_hlist d d') <-> equiv_hlist (hlist_app c d) (hlist_app c' d').
Proof.
clear.
split.
destruct 1.
induction H.

*****
H0 : equiv_hlist d d'
d,d' : hlist b
b : list iT
eqv : forall x : iT, relation (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
equiv_hlist (hlist_app Hnil d) (hlist_app Hnil d')
+++++
assumption.
-----
Lemma equiv_hlist_app : forall a b (c c' : hlist a) (d d' : hlist b), (equiv_hlist c c' /\\ equiv_hlist d d') <-> equiv_hlist (hlist_app c d) (hlist_app c' d').
Proof.
clear.
split.
destruct 1.
induction H.

*****
IHequiv_hlist : equiv_hlist (hlist_app h1 d) (hlist_app h2 d')
H0 : equiv_hlist d d'
H1 : equiv_hlist h1 h2
H : eqv x y
h1,h2 : hlist ls
x,y : F l
ls : list iT
l : iT
d,d' : hlist b
b : list iT
eqv : forall x : iT, relation (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
equiv_hlist (hlist_app (Hcons x h1) d) (hlist_app (Hcons y h2) d')
+++++
simpl.
-----
Lemma equiv_hlist_app : forall a b (c c' : hlist a) (d d' : hlist b), (equiv_hlist c c' /\\ equiv_hlist d d') <-> equiv_hlist (hlist_app c d) (hlist_app c' d').
Proof.
clear.
split.
destruct 1.
induction H.
simpl.

*****
IHequiv_hlist : equiv_hlist (hlist_app h1 d) (hlist_app h2 d')
H0 : equiv_hlist d d'
H1 : equiv_hlist h1 h2
H : eqv x y
h1,h2 : hlist ls
x,y : F l
ls : list iT
l : iT
d,d' : hlist b
b : list iT
eqv : forall x : iT, relation (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
equiv_hlist (Hcons x (hlist_app h1 d)) (Hcons y (hlist_app h2 d'))
+++++
constructor.
-----
Lemma equiv_hlist_app : forall a b (c c' : hlist a) (d d' : hlist b), (equiv_hlist c c' /\\ equiv_hlist d d') <-> equiv_hlist (hlist_app c d) (hlist_app c' d').
Proof.
clear.
split.
destruct 1.
induction H.
simpl.
constructor.

*****
IHequiv_hlist : equiv_hlist (hlist_app h1 d) (hlist_app h2 d')
H0 : equiv_hlist d d'
H1 : equiv_hlist h1 h2
H : eqv x y
h1,h2 : hlist ls
x,y : F l
ls : list iT
l : iT
d,d' : hlist b
b : list iT
eqv : forall x : iT, relation (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
eqv x y
+++++
auto.
-----
Lemma equiv_hlist_app : forall a b (c c' : hlist a) (d d' : hlist b), (equiv_hlist c c' /\\ equiv_hlist d d') <-> equiv_hlist (hlist_app c d) (hlist_app c' d').
Proof.
clear.
split.
destruct 1.
induction H.
simpl.
constructor.

*****
IHequiv_hlist : equiv_hlist (hlist_app h1 d) (hlist_app h2 d')
H0 : equiv_hlist d d'
H1 : equiv_hlist h1 h2
H : eqv x y
h1,h2 : hlist ls
x,y : F l
ls : list iT
l : iT
d,d' : hlist b
b : list iT
eqv : forall x : iT, relation (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
equiv_hlist (hlist_app h1 d) (hlist_app h2 d')
+++++
auto.
-----
Lemma equiv_hlist_app : forall a b (c c' : hlist a) (d d' : hlist b), (equiv_hlist c c' /\\ equiv_hlist d d') <-> equiv_hlist (hlist_app c d) (hlist_app c' d').
Proof.
clear.
split.

*****
d,d' : hlist b
c,c' : hlist a
a,b : list iT
eqv : forall x : iT, relation (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall _ : equiv_hlist (hlist_app c d) (hlist_app c' d'), and (equiv_hlist c c') (equiv_hlist d d')
+++++
induction c.
-----
Lemma equiv_hlist_app : forall a b (c c' : hlist a) (d d' : hlist b), (equiv_hlist c c' /\\ equiv_hlist d d') <-> equiv_hlist (hlist_app c d) (hlist_app c' d').
Proof.
clear.
split.
induction c.

*****
d,d' : hlist b
c' : hlist nil
b : list iT
eqv : forall x : iT, relation (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall _ : equiv_hlist (hlist_app Hnil d) (hlist_app c' d'), and (equiv_hlist Hnil c') (equiv_hlist d d')
+++++
rewrite (hlist_eta c').
-----
Lemma equiv_hlist_app : forall a b (c c' : hlist a) (d d' : hlist b), (equiv_hlist c c' /\\ equiv_hlist d d') <-> equiv_hlist (hlist_app c d) (hlist_app c' d').
Proof.
clear.
split.
induction c.
rewrite (hlist_eta c').

*****
d,d' : hlist b
c' : hlist nil
b : list iT
eqv : forall x : iT, relation (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall _ : equiv_hlist (hlist_app Hnil d) (hlist_app Hnil d'), and (equiv_hlist Hnil Hnil) (equiv_hlist d d')
+++++
simpl.
-----
Lemma equiv_hlist_app : forall a b (c c' : hlist a) (d d' : hlist b), (equiv_hlist c c' /\\ equiv_hlist d d') <-> equiv_hlist (hlist_app c d) (hlist_app c' d').
Proof.
clear.
split.
induction c.
rewrite (hlist_eta c').
simpl.

*****
d,d' : hlist b
c' : hlist nil
b : list iT
eqv : forall x : iT, relation (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall _ : equiv_hlist d d', and (equiv_hlist Hnil Hnil) (equiv_hlist d d')
+++++
intros.
-----
Lemma equiv_hlist_app : forall a b (c c' : hlist a) (d d' : hlist b), (equiv_hlist c c' /\\ equiv_hlist d d') <-> equiv_hlist (hlist_app c d) (hlist_app c' d').
Proof.
clear.
split.
induction c.
rewrite (hlist_eta c').
simpl.
intros.

*****
H : equiv_hlist d d'
d,d' : hlist b
c' : hlist nil
b : list iT
eqv : forall x : iT, relation (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
and (equiv_hlist Hnil Hnil) (equiv_hlist d d')
+++++
split.
-----
Lemma equiv_hlist_app : forall a b (c c' : hlist a) (d d' : hlist b), (equiv_hlist c c' /\\ equiv_hlist d d') <-> equiv_hlist (hlist_app c d) (hlist_app c' d').
Proof.
clear.
split.
induction c.
rewrite (hlist_eta c').
simpl.
intros.
split.

*****
H : equiv_hlist d d'
d,d' : hlist b
c' : hlist nil
b : list iT
eqv : forall x : iT, relation (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
equiv_hlist Hnil Hnil
+++++
auto.
-----
Lemma equiv_hlist_app : forall a b (c c' : hlist a) (d d' : hlist b), (equiv_hlist c c' /\\ equiv_hlist d d') <-> equiv_hlist (hlist_app c d) (hlist_app c' d').
Proof.
clear.
split.
induction c.
rewrite (hlist_eta c').
simpl.
intros.
split.
auto.

*****
H : equiv_hlist d d'
d,d' : hlist b
c' : hlist nil
b : list iT
eqv : forall x : iT, relation (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
equiv_hlist Hnil Hnil
+++++
constructor.
-----
Lemma equiv_hlist_app : forall a b (c c' : hlist a) (d d' : hlist b), (equiv_hlist c c' /\\ equiv_hlist d d') <-> equiv_hlist (hlist_app c d) (hlist_app c' d').
Proof.
clear.
split.
induction c.
rewrite (hlist_eta c').
simpl.
intros.
split.

*****
H : equiv_hlist d d'
d,d' : hlist b
c' : hlist nil
b : list iT
eqv : forall x : iT, relation (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
equiv_hlist d d'
+++++
auto.
-----
Lemma equiv_hlist_app : forall a b (c c' : hlist a) (d d' : hlist b), (equiv_hlist c c' /\\ equiv_hlist d d') <-> equiv_hlist (hlist_app c d) (hlist_app c' d').
Proof.
clear.
split.
induction c.

*****
IHc : forall (c' : hlist ls)\n (_ : equiv_hlist (hlist_app c d) (hlist_app c' d')),\nand (equiv_hlist c c') (equiv_hlist d d')
d,d' : hlist b
c' : hlist (cons l ls)
c : hlist ls
f : F l
ls : list iT
l : iT
b : list iT
eqv : forall x : iT, relation (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall _ : equiv_hlist (hlist_app (Hcons f c) d) (hlist_app c' d'), and (equiv_hlist (Hcons f c) c') (equiv_hlist d d')
+++++
rewrite (hlist_eta c').
-----
Lemma equiv_hlist_app : forall a b (c c' : hlist a) (d d' : hlist b), (equiv_hlist c c' /\\ equiv_hlist d d') <-> equiv_hlist (hlist_app c d) (hlist_app c' d').
Proof.
clear.
split.
induction c.
rewrite (hlist_eta c').

*****
IHc : forall (c' : hlist ls)\n (_ : equiv_hlist (hlist_app c d) (hlist_app c' d')),\nand (equiv_hlist c c') (equiv_hlist d d')
d,d' : hlist b
c' : hlist (cons l ls)
c : hlist ls
f : F l
ls : list iT
l : iT
b : list iT
eqv : forall x : iT, relation (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall _ : equiv_hlist (hlist_app (Hcons f c) d) (hlist_app (Hcons (hlist_hd c') (hlist_tl c')) d'), and (equiv_hlist (Hcons f c) (Hcons (hlist_hd c') (hlist_tl c'))) (equiv_hlist d d')
+++++
simpl.
-----
Lemma equiv_hlist_app : forall a b (c c' : hlist a) (d d' : hlist b), (equiv_hlist c c' /\\ equiv_hlist d d') <-> equiv_hlist (hlist_app c d) (hlist_app c' d').
Proof.
clear.
split.
induction c.
rewrite (hlist_eta c').
simpl.

*****
IHc : forall (c' : hlist ls)\n (_ : equiv_hlist (hlist_app c d) (hlist_app c' d')),\nand (equiv_hlist c c') (equiv_hlist d d')
d,d' : hlist b
c' : hlist (cons l ls)
c : hlist ls
f : F l
ls : list iT
l : iT
b : list iT
eqv : forall x : iT, relation (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall _ : equiv_hlist (Hcons f (hlist_app c d)) (Hcons (hlist_hd c') (hlist_app (hlist_tl c') d')), and (equiv_hlist (Hcons f c) (Hcons (hlist_hd c') (hlist_tl c'))) (equiv_hlist d d')
+++++
specialize (IHc (hlist_tl c')).
-----
Lemma equiv_hlist_app : forall a b (c c' : hlist a) (d d' : hlist b), (equiv_hlist c c' /\\ equiv_hlist d d') <-> equiv_hlist (hlist_app c d) (hlist_app c' d').
Proof.
clear.
split.
induction c.
rewrite (hlist_eta c').
simpl.
specialize (IHc (hlist_tl c')).

*****
IHc : forall _ : equiv_hlist (hlist_app c d) (hlist_app (hlist_tl c') d'),\nand (equiv_hlist c (hlist_tl c')) (equiv_hlist d d')
d,d' : hlist b
c' : hlist (cons l ls)
c : hlist ls
f : F l
ls : list iT
l : iT
b : list iT
eqv : forall x : iT, relation (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall _ : equiv_hlist (Hcons f (hlist_app c d)) (Hcons (hlist_hd c') (hlist_app (hlist_tl c') d')), and (equiv_hlist (Hcons f c) (Hcons (hlist_hd c') (hlist_tl c'))) (equiv_hlist d d')
+++++
intro.
-----
Lemma equiv_hlist_app : forall a b (c c' : hlist a) (d d' : hlist b), (equiv_hlist c c' /\\ equiv_hlist d d') <-> equiv_hlist (hlist_app c d) (hlist_app c' d').
Proof.
clear.
split.
induction c.
rewrite (hlist_eta c').
simpl.
specialize (IHc (hlist_tl c')).
intro.

*****
H : equiv_hlist (Hcons f (hlist_app c d))\n (Hcons (hlist_hd c') (hlist_app (hlist_tl c') d'))
IHc : forall _ : equiv_hlist (hlist_app c d) (hlist_app (hlist_tl c') d'),\nand (equiv_hlist c (hlist_tl c')) (equiv_hlist d d')
d,d' : hlist b
c' : hlist (cons l ls)
c : hlist ls
f : F l
ls : list iT
l : iT
b : list iT
eqv : forall x : iT, relation (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
and (equiv_hlist (Hcons f c) (Hcons (hlist_hd c') (hlist_tl c'))) (equiv_hlist d d')
+++++
eapply equiv_hlist_Hcons in H.
-----
Lemma equiv_hlist_app : forall a b (c c' : hlist a) (d d' : hlist b), (equiv_hlist c c' /\\ equiv_hlist d d') <-> equiv_hlist (hlist_app c d) (hlist_app c' d').
Proof.
clear.
split.
induction c.
rewrite (hlist_eta c').
simpl.
specialize (IHc (hlist_tl c')).
intro.
eapply equiv_hlist_Hcons in H.

*****
H : and (eqv f (hlist_hd c'))\n (equiv_hlist (hlist_app c d) (hlist_app (hlist_tl c') d'))
IHc : forall _ : equiv_hlist (hlist_app c d) (hlist_app (hlist_tl c') d'),\nand (equiv_hlist c (hlist_tl c')) (equiv_hlist d d')
d,d' : hlist b
c' : hlist (cons l ls)
c : hlist ls
f : F l
ls : list iT
l : iT
b : list iT
eqv : forall x : iT, relation (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
and (equiv_hlist (Hcons f c) (Hcons (hlist_hd c') (hlist_tl c'))) (equiv_hlist d d')
+++++
intuition.
-----
Lemma equiv_hlist_app : forall a b (c c' : hlist a) (d d' : hlist b), (equiv_hlist c c' /\\ equiv_hlist d d') <-> equiv_hlist (hlist_app c d) (hlist_app c' d').
Proof.
clear.
split.
induction c.
rewrite (hlist_eta c').
simpl.
specialize (IHc (hlist_tl c')).
intro.
eapply equiv_hlist_Hcons in H.
intuition.

*****
H3 : equiv_hlist d d'
H2 : equiv_hlist c (hlist_tl c')
H1 : equiv_hlist (hlist_app c d) (hlist_app (hlist_tl c') d')
H0 : eqv f (hlist_hd c')
d,d' : hlist b
c' : hlist (cons l ls)
c : hlist ls
f : F l
ls : list iT
l : iT
b : list iT
eqv : forall x : iT, relation (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
equiv_hlist (Hcons f c) (Hcons (hlist_hd c') (hlist_tl c'))
+++++
constructor.
-----
Lemma equiv_hlist_app : forall a b (c c' : hlist a) (d d' : hlist b), (equiv_hlist c c' /\\ equiv_hlist d d') <-> equiv_hlist (hlist_app c d) (hlist_app c' d').
Proof.
clear.
split.
induction c.
rewrite (hlist_eta c').
simpl.
specialize (IHc (hlist_tl c')).
intro.
eapply equiv_hlist_Hcons in H.
intuition.
constructor.

*****
H3 : equiv_hlist d d'
H2 : equiv_hlist c (hlist_tl c')
H1 : equiv_hlist (hlist_app c d) (hlist_app (hlist_tl c') d')
H0 : eqv f (hlist_hd c')
d,d' : hlist b
c' : hlist (cons l ls)
c : hlist ls
f : F l
ls : list iT
l : iT
b : list iT
eqv : forall x : iT, relation (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
eqv f (hlist_hd c')
+++++
auto.
-----
Lemma equiv_hlist_app : forall a b (c c' : hlist a) (d d' : hlist b), (equiv_hlist c c' /\\ equiv_hlist d d') <-> equiv_hlist (hlist_app c d) (hlist_app c' d').
Proof.
clear.
split.
induction c.
rewrite (hlist_eta c').
simpl.
specialize (IHc (hlist_tl c')).
intro.
eapply equiv_hlist_Hcons in H.
intuition.
constructor.

*****
H3 : equiv_hlist d d'
H2 : equiv_hlist c (hlist_tl c')
H1 : equiv_hlist (hlist_app c d) (hlist_app (hlist_tl c') d')
H0 : eqv f (hlist_hd c')
d,d' : hlist b
c' : hlist (cons l ls)
c : hlist ls
f : F l
ls : list iT
l : iT
b : list iT
eqv : forall x : iT, relation (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
equiv_hlist c (hlist_tl c')
+++++
auto.
-----
Lemma equiv_hlist_app : forall a b (c c' : hlist a) (d d' : hlist b), (equiv_hlist c c' /\\ equiv_hlist d d') <-> equiv_hlist (hlist_app c d) (hlist_app c' d').
Proof.
clear.
split.

*****

*****

+++++
Qed.
-----
Global Instance Injection_equiv_hlist_cons ls i a b (c : hlist ls) d\n    : Injective (equiv_hlist (Hcons a c) (@Hcons i ls b d)) :=\n    { result := @eqv i a b /\ equiv_hlist c d\n    ; injection := @equiv_hlist_Hcons _ _ _ _ _ _ }.
-----
Global Instance Injection_equiv_hlist_app a b (c c' : hlist a) (d d' : hlist b)\n    : Injective (equiv_hlist (hlist_app c d) (hlist_app c' d')) :=\n    { result := equiv_hlist c c' /\ equiv_hlist d d'\n    ; injection := fun x => proj2 (@equiv_hlist_app _ _ _ _ _ _) x }.
-----
End equiv.
-----
Lemma hlist_nil_eta : forall (h : hlist nil), h = Hnil.
-----
Lemma hlist_nil_eta : forall (h : hlist nil), h = Hnil.

*****
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall h : hlist nil, eq h Hnil
+++++
Proof.
-----
Lemma hlist_nil_eta : forall (h : hlist nil), h = Hnil.
Proof.

*****
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall h : hlist nil, eq h Hnil
+++++
intros.
-----
Lemma hlist_nil_eta : forall (h : hlist nil), h = Hnil.
Proof.
intros.

*****
h : hlist nil
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
eq h Hnil
+++++
rewrite (hlist_eta h).
-----
Lemma hlist_nil_eta : forall (h : hlist nil), h = Hnil.
Proof.
intros.
rewrite (hlist_eta h).

*****
h : hlist nil
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
eq Hnil Hnil
+++++
reflexivity.
-----
Lemma hlist_nil_eta : forall (h : hlist nil), h = Hnil.
Proof.
intros.
rewrite (hlist_eta h).
reflexivity.

*****

*****

+++++
Qed.
-----
Lemma hlist_cons_eta : forall a b (h : hlist (a :: b)),\n    h = Hcons (hlist_hd h) (hlist_tl h).
-----
Lemma hlist_cons_eta : forall a b (h : hlist (a :: b)), h = Hcons (hlist_hd h) (hlist_tl h).

*****
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall (a : iT) (b : list iT) (h : hlist (cons a b)), eq h (Hcons (hlist_hd h) (hlist_tl h))
+++++
Proof.
-----
Lemma hlist_cons_eta : forall a b (h : hlist (a :: b)), h = Hcons (hlist_hd h) (hlist_tl h).
Proof.

*****
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall (a : iT) (b : list iT) (h : hlist (cons a b)), eq h (Hcons (hlist_hd h) (hlist_tl h))
+++++
intros.
-----
Lemma hlist_cons_eta : forall a b (h : hlist (a :: b)), h = Hcons (hlist_hd h) (hlist_tl h).
Proof.
intros.

*****
h : hlist (cons a b)
b : list iT
a : iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
eq h (Hcons (hlist_hd h) (hlist_tl h))
+++++
rewrite (hlist_eta h).
-----
Lemma hlist_cons_eta : forall a b (h : hlist (a :: b)), h = Hcons (hlist_hd h) (hlist_tl h).
Proof.
intros.
rewrite (hlist_eta h).

*****
h : hlist (cons a b)
b : list iT
a : iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
eq (Hcons (hlist_hd h) (hlist_tl h)) (Hcons (hlist_hd (Hcons (hlist_hd h) (hlist_tl h))) (hlist_tl (Hcons (hlist_hd h) (hlist_tl h))))
+++++
reflexivity.
-----
Lemma hlist_cons_eta : forall a b (h : hlist (a :: b)), h = Hcons (hlist_hd h) (hlist_tl h).
Proof.
intros.
rewrite (hlist_eta h).
reflexivity.

*****

*****

+++++
Qed.
-----
Lemma Hcons_inv\n  : forall l ls a b c d,\n      @eq (hlist (l :: ls)) (Hcons a b) (Hcons c d) ->\n      a = c /\ b = d.
-----
Lemma Hcons_inv : forall l ls a b c d, @eq (hlist (l :: ls)) (Hcons a b) (Hcons c d) -> a = c /\\ b = d.

*****
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall (l : iT) (ls : list iT) (a : F l) (b : hlist ls) (c : F l) (d : hlist ls) (_ : eq (Hcons a b) (Hcons c d)), and (eq a c) (eq b d)
+++++
Proof.
-----
Lemma Hcons_inv : forall l ls a b c d, @eq (hlist (l :: ls)) (Hcons a b) (Hcons c d) -> a = c /\\ b = d.
Proof.

*****
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall (l : iT) (ls : list iT) (a : F l) (b : hlist ls) (c : F l) (d : hlist ls) (_ : eq (Hcons a b) (Hcons c d)), and (eq a c) (eq b d)
+++++
intros.
-----
Lemma Hcons_inv : forall l ls a b c d, @eq (hlist (l :: ls)) (Hcons a b) (Hcons c d) -> a = c /\\ b = d.
Proof.
intros.

*****
H : eq (Hcons a b) (Hcons c d)
d : hlist ls
c : F l
b : hlist ls
a : F l
ls : list iT
l : iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
and (eq a c) (eq b d)
+++++
refine ( match H as K in _ = Z return match Z in hlist LS return match LS with | nil => Prop | l :: ls => F l -> hlist ls -> Prop end with | Hcons X Y x y => fun a b => a = x /\ b = y | Hnil => True end a b with | eq_refl => conj eq_refl eq_refl end).
-----
Lemma Hcons_inv : forall l ls a b c d, @eq (hlist (l :: ls)) (Hcons a b) (Hcons c d) -> a = c /\\ b = d.
Proof.
intros.
refine ( match H as K in _ = Z return match Z in hlist LS return match LS with | nil => Prop | l :: ls => F l -> hlist ls -> Prop end with | Hcons X Y x y => fun a b => a = x /\\ b = y | Hnil => True end a b with | eq_refl => conj eq_refl eq_refl end).

*****

*****

+++++
Qed.
-----
Global Instance Injection_hlist_cons ls t (a : F t) (b : hlist ls) c d\n  : Injective (Hcons a b = Hcons c d) :=\n    { result := a = c /\ b = d\n    ; injection := @Hcons_inv t ls a b c d\n    }.
-----
Theorem equiv_eq_eq : forall ls (x y : hlist ls),\n                          equiv_hlist (fun x => @eq _) x y <-> x = y.
-----
Theorem equiv_eq_eq : forall ls (x y : hlist ls), equiv_hlist (fun x => @eq _) x y <-> x = y.

*****
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall (ls : list iT) (x y : hlist ls), iff (equiv_hlist (fun x0 : iT => eq) x y) (eq x y)
+++++
Proof.
-----
Theorem equiv_eq_eq : forall ls (x y : hlist ls), equiv_hlist (fun x => @eq _) x y <-> x = y.
Proof.

*****
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall (ls : list iT) (x y : hlist ls), iff (equiv_hlist (fun x0 : iT => eq) x y) (eq x y)
+++++
induction x.
-----
Theorem equiv_eq_eq : forall ls (x y : hlist ls), equiv_hlist (fun x => @eq _) x y <-> x = y.
Proof.
induction x.

*****
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall y : hlist nil, iff (equiv_hlist (fun x : iT => eq) Hnil y) (eq Hnil y)
+++++
simpl.
-----
Theorem equiv_eq_eq : forall ls (x y : hlist ls), equiv_hlist (fun x => @eq _) x y <-> x = y.
Proof.
induction x.
simpl.

*****
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall y : hlist nil, iff (equiv_hlist (fun x : iT => eq) Hnil y) (eq Hnil y)
+++++
intros.
-----
Theorem equiv_eq_eq : forall ls (x y : hlist ls), equiv_hlist (fun x => @eq _) x y <-> x = y.
Proof.
induction x.
simpl.
intros.

*****
y : hlist nil
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
iff (equiv_hlist (fun x : iT => eq) Hnil y) (eq Hnil y)
+++++
split.
-----
Theorem equiv_eq_eq : forall ls (x y : hlist ls), equiv_hlist (fun x => @eq _) x y <-> x = y.
Proof.
induction x.
simpl.
intros.
split.

*****
y : hlist nil
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall _ : equiv_hlist (fun x : iT => eq) Hnil y, eq Hnil y
+++++
inversion 1.
-----
Theorem equiv_eq_eq : forall ls (x y : hlist ls), equiv_hlist (fun x => @eq _) x y <-> x = y.
Proof.
induction x.
simpl.
intros.
split.
inversion 1.

*****
H0 : eq (existT (fun x : list iT => hlist x) nil Hnil)\n (existT (fun x : list iT => hlist x) nil y)
H : equiv_hlist (fun x : iT => eq) Hnil y
y : hlist nil
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
eq Hnil y
+++++
rewrite hlist_nil_eta.
-----
Theorem equiv_eq_eq : forall ls (x y : hlist ls), equiv_hlist (fun x => @eq _) x y <-> x = y.
Proof.
induction x.
simpl.
intros.
split.
inversion 1.
rewrite hlist_nil_eta.

*****
H0 : eq (existT (fun x : list iT => hlist x) nil Hnil)\n (existT (fun x : list iT => hlist x) nil y)
H : equiv_hlist (fun x : iT => eq) Hnil y
y : hlist nil
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
eq Hnil Hnil
+++++
reflexivity.
-----
Theorem equiv_eq_eq : forall ls (x y : hlist ls), equiv_hlist (fun x => @eq _) x y <-> x = y.
Proof.
induction x.
simpl.
intros.
split.

*****
y : hlist nil
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall _ : eq Hnil y, equiv_hlist (fun x : iT => eq) Hnil y
+++++
intros.
-----
Theorem equiv_eq_eq : forall ls (x y : hlist ls), equiv_hlist (fun x => @eq _) x y <-> x = y.
Proof.
induction x.
simpl.
intros.
split.
intros.

*****
H : eq Hnil y
y : hlist nil
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
equiv_hlist (fun x : iT => eq) Hnil y
+++++
subst.
-----
Theorem equiv_eq_eq : forall ls (x y : hlist ls), equiv_hlist (fun x => @eq _) x y <-> x = y.
Proof.
induction x.
simpl.
intros.
split.
intros.
subst.

*****
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
equiv_hlist (fun x : iT => eq) Hnil Hnil
+++++
constructor.
-----
Theorem equiv_eq_eq : forall ls (x y : hlist ls), equiv_hlist (fun x => @eq _) x y <-> x = y.
Proof.
induction x.

*****
IHx : forall y : hlist ls, iff (equiv_hlist (fun x : iT => eq) x y) (eq x y)
x : hlist ls
f : F l
ls : list iT
l : iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall y : hlist (cons l ls), iff (equiv_hlist (fun x : iT => eq) (Hcons f x) y) (eq (Hcons f x) y)
+++++
simpl.
-----
Theorem equiv_eq_eq : forall ls (x y : hlist ls), equiv_hlist (fun x => @eq _) x y <-> x = y.
Proof.
induction x.
simpl.

*****
IHx : forall y : hlist ls, iff (equiv_hlist (fun x : iT => eq) x y) (eq x y)
x : hlist ls
f : F l
ls : list iT
l : iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall y : hlist (cons l ls), iff (equiv_hlist (fun x : iT => eq) (Hcons f x) y) (eq (Hcons f x) y)
+++++
intros.
-----
Theorem equiv_eq_eq : forall ls (x y : hlist ls), equiv_hlist (fun x => @eq _) x y <-> x = y.
Proof.
induction x.
simpl.
intros.

*****
y : hlist (cons l ls)
IHx : forall y : hlist ls, iff (equiv_hlist (fun x : iT => eq) x y) (eq x y)
x : hlist ls
f : F l
ls : list iT
l : iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
iff (equiv_hlist (fun x : iT => eq) (Hcons f x) y) (eq (Hcons f x) y)
+++++
split.
-----
Theorem equiv_eq_eq : forall ls (x y : hlist ls), equiv_hlist (fun x => @eq _) x y <-> x = y.
Proof.
induction x.
simpl.
intros.
split.

*****
y : hlist (cons l ls)
IHx : forall y : hlist ls, iff (equiv_hlist (fun x : iT => eq) x y) (eq x y)
x : hlist ls
f : F l
ls : list iT
l : iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall _ : equiv_hlist (fun x : iT => eq) (Hcons f x) y, eq (Hcons f x) y
+++++
intro.
-----
Theorem equiv_eq_eq : forall ls (x y : hlist ls), equiv_hlist (fun x => @eq _) x y <-> x = y.
Proof.
induction x.
simpl.
intros.
split.
intro.

*****
H : equiv_hlist (fun x : iT => eq) (Hcons f x) y
y : hlist (cons l ls)
IHx : forall y : hlist ls, iff (equiv_hlist (fun x : iT => eq) x y) (eq x y)
x : hlist ls
f : F l
ls : list iT
l : iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
eq (Hcons f x) y
+++++
rewrite (hlist_eta y).
-----
Theorem equiv_eq_eq : forall ls (x y : hlist ls), equiv_hlist (fun x => @eq _) x y <-> x = y.
Proof.
induction x.
simpl.
intros.
split.
intro.
rewrite (hlist_eta y).

*****
H : equiv_hlist (fun x : iT => eq) (Hcons f x) y
y : hlist (cons l ls)
IHx : forall y : hlist ls, iff (equiv_hlist (fun x : iT => eq) x y) (eq x y)
x : hlist ls
f : F l
ls : list iT
l : iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
eq (Hcons f x) (Hcons (hlist_hd y) (hlist_tl y))
+++++
specialize (IHx (hlist_tl y)).
-----
Theorem equiv_eq_eq : forall ls (x y : hlist ls), equiv_hlist (fun x => @eq _) x y <-> x = y.
Proof.
induction x.
simpl.
intros.
split.
intro.
rewrite (hlist_eta y).
specialize (IHx (hlist_tl y)).

*****
H : equiv_hlist (fun x : iT => eq) (Hcons f x) y
IHx : iff (equiv_hlist (fun x : iT => eq) x (hlist_tl y)) (eq x (hlist_tl y))
y : hlist (cons l ls)
x : hlist ls
f : F l
ls : list iT
l : iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
eq (Hcons f x) (Hcons (hlist_hd y) (hlist_tl y))
+++++
refine (match H in @equiv_hlist _ LS X Y return match X in hlist LS return F match LS with | nil => l | l :: _ => l end -> hlist match LS with | nil => ls | _ :: ls => ls end -> Prop with | Hnil => fun _ _ => True | Hcons a b c d => fun x y => (equiv_hlist (fun x0 : iT => eq) d y <-> d = y) -> @Hcons a b c d = Hcons x y end (match LS as LS return hlist LS -> F match LS with | nil => l | l :: _ => l end with | nil => fun _ => f | l :: ls => hlist_hd end Y) (match LS as LS return hlist LS -> hlist match LS with | nil => ls | _ :: ls => ls end with | nil => fun _ => x | l :: ls => hlist_tl end Y) with | hlist_eqv_nil => I | hlist_eqv_cons l ls x y h1 h2 pf1 pf2 => _ end IHx).
-----
Theorem equiv_eq_eq : forall ls (x y : hlist ls), equiv_hlist (fun x => @eq _) x y <-> x = y.
Proof.
induction x.
simpl.
intros.
split.
intro.
rewrite (hlist_eta y).
specialize (IHx (hlist_tl y)).
refine (match H in @equiv_hlist _ LS X Y return match X in hlist LS return F match LS with | nil => l | l :: _ => l end -> hlist match LS with | nil => ls | _ :: ls => ls end -> Prop with | Hnil => fun _ _ => True | Hcons a b c d => fun x y => (equiv_hlist (fun x0 : iT => eq) d y <-> d = y) -> @Hcons a b c d = Hcons x y end (match LS as LS return hlist LS -> F match LS with | nil => l | l :: _ => l end with | nil => fun _ => f | l :: ls => hlist_hd end Y) (match LS as LS return hlist LS -> hlist match LS with | nil => ls | _ :: ls => ls end with | nil => fun _ => x | l :: ls => hlist_tl end Y) with | hlist_eqv_nil => I | hlist_eqv_cons l ls x y h1 h2 pf1 pf2 => _ end IHx).

*****
pf2 : equiv_hlist (fun x : iT => eq) h1 h2
pf1 : eq x y
h1,h2 : hlist ls
x,y : F l
ls : list iT
l : iT
H : equiv_hlist (fun x : iT => eq) (Hcons f x0) y0
IHx : iff (equiv_hlist (fun x : iT => eq) x0 (hlist_tl y0))\n (eq x0 (hlist_tl y0))
y0 : hlist (cons l0 ls0)
x0 : hlist ls0
f : F l0
ls0 : list iT
l0 : iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall _ : iff (equiv_hlist (fun x0 : iT => eq) h1 (hlist_tl (Hcons y h2))) (eq h1 (hlist_tl (Hcons y h2))), eq (Hcons x h1) (Hcons (hlist_hd (Hcons y h2)) (hlist_tl (Hcons y h2)))
+++++
simpl.
-----
Theorem equiv_eq_eq : forall ls (x y : hlist ls), equiv_hlist (fun x => @eq _) x y <-> x = y.
Proof.
induction x.
simpl.
intros.
split.
intro.
rewrite (hlist_eta y).
specialize (IHx (hlist_tl y)).
refine (match H in @equiv_hlist _ LS X Y return match X in hlist LS return F match LS with | nil => l | l :: _ => l end -> hlist match LS with | nil => ls | _ :: ls => ls end -> Prop with | Hnil => fun _ _ => True | Hcons a b c d => fun x y => (equiv_hlist (fun x0 : iT => eq) d y <-> d = y) -> @Hcons a b c d = Hcons x y end (match LS as LS return hlist LS -> F match LS with | nil => l | l :: _ => l end with | nil => fun _ => f | l :: ls => hlist_hd end Y) (match LS as LS return hlist LS -> hlist match LS with | nil => ls | _ :: ls => ls end with | nil => fun _ => x | l :: ls => hlist_tl end Y) with | hlist_eqv_nil => I | hlist_eqv_cons l ls x y h1 h2 pf1 pf2 => _ end IHx).
simpl.

*****
pf2 : equiv_hlist (fun x : iT => eq) h1 h2
pf1 : eq x y
h1,h2 : hlist ls
x,y : F l
ls : list iT
l : iT
H : equiv_hlist (fun x : iT => eq) (Hcons f x0) y0
IHx : iff (equiv_hlist (fun x : iT => eq) x0 (hlist_tl y0))\n (eq x0 (hlist_tl y0))
y0 : hlist (cons l0 ls0)
x0 : hlist ls0
f : F l0
ls0 : list iT
l0 : iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall _ : iff (equiv_hlist (fun x0 : iT => eq) h1 h2) (eq h1 h2), eq (Hcons x h1) (Hcons y h2)
+++++
subst.
-----
Theorem equiv_eq_eq : forall ls (x y : hlist ls), equiv_hlist (fun x => @eq _) x y <-> x = y.
Proof.
induction x.
simpl.
intros.
split.
intro.
rewrite (hlist_eta y).
specialize (IHx (hlist_tl y)).
refine (match H in @equiv_hlist _ LS X Y return match X in hlist LS return F match LS with | nil => l | l :: _ => l end -> hlist match LS with | nil => ls | _ :: ls => ls end -> Prop with | Hnil => fun _ _ => True | Hcons a b c d => fun x y => (equiv_hlist (fun x0 : iT => eq) d y <-> d = y) -> @Hcons a b c d = Hcons x y end (match LS as LS return hlist LS -> F match LS with | nil => l | l :: _ => l end with | nil => fun _ => f | l :: ls => hlist_hd end Y) (match LS as LS return hlist LS -> hlist match LS with | nil => ls | _ :: ls => ls end with | nil => fun _ => x | l :: ls => hlist_tl end Y) with | hlist_eqv_nil => I | hlist_eqv_cons l ls x y h1 h2 pf1 pf2 => _ end IHx).
simpl.
subst.

*****
pf2 : equiv_hlist (fun x : iT => eq) h1 h2
h1,h2 : hlist ls
y : F l
ls : list iT
l : iT
H : equiv_hlist (fun x : iT => eq) (Hcons f x0) y0
IHx : iff (equiv_hlist (fun x : iT => eq) x0 (hlist_tl y0))\n (eq x0 (hlist_tl y0))
y0 : hlist (cons l0 ls0)
x0 : hlist ls0
f : F l0
ls0 : list iT
l0 : iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall _ : iff (equiv_hlist (fun x0 : iT => eq) h1 h2) (eq h1 h2), eq (Hcons y h1) (Hcons y h2)
+++++
intros.
-----
Theorem equiv_eq_eq : forall ls (x y : hlist ls), equiv_hlist (fun x => @eq _) x y <-> x = y.
Proof.
induction x.
simpl.
intros.
split.
intro.
rewrite (hlist_eta y).
specialize (IHx (hlist_tl y)).
refine (match H in @equiv_hlist _ LS X Y return match X in hlist LS return F match LS with | nil => l | l :: _ => l end -> hlist match LS with | nil => ls | _ :: ls => ls end -> Prop with | Hnil => fun _ _ => True | Hcons a b c d => fun x y => (equiv_hlist (fun x0 : iT => eq) d y <-> d = y) -> @Hcons a b c d = Hcons x y end (match LS as LS return hlist LS -> F match LS with | nil => l | l :: _ => l end with | nil => fun _ => f | l :: ls => hlist_hd end Y) (match LS as LS return hlist LS -> hlist match LS with | nil => ls | _ :: ls => ls end with | nil => fun _ => x | l :: ls => hlist_tl end Y) with | hlist_eqv_nil => I | hlist_eqv_cons l ls x y h1 h2 pf1 pf2 => _ end IHx).
simpl.
subst.
intros.

*****
H0 : iff (equiv_hlist (fun x0 : iT => eq) h1 h2) (eq h1 h2)
pf2 : equiv_hlist (fun x : iT => eq) h1 h2
h1,h2 : hlist ls
y : F l
ls : list iT
l : iT
H : equiv_hlist (fun x : iT => eq) (Hcons f x0) y0
IHx : iff (equiv_hlist (fun x : iT => eq) x0 (hlist_tl y0))\n (eq x0 (hlist_tl y0))
y0 : hlist (cons l0 ls0)
x0 : hlist ls0
f : F l0
ls0 : list iT
l0 : iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
eq (Hcons y h1) (Hcons y h2)
+++++
f_equal.
-----
Theorem equiv_eq_eq : forall ls (x y : hlist ls), equiv_hlist (fun x => @eq _) x y <-> x = y.
Proof.
induction x.
simpl.
intros.
split.
intro.
rewrite (hlist_eta y).
specialize (IHx (hlist_tl y)).
refine (match H in @equiv_hlist _ LS X Y return match X in hlist LS return F match LS with | nil => l | l :: _ => l end -> hlist match LS with | nil => ls | _ :: ls => ls end -> Prop with | Hnil => fun _ _ => True | Hcons a b c d => fun x y => (equiv_hlist (fun x0 : iT => eq) d y <-> d = y) -> @Hcons a b c d = Hcons x y end (match LS as LS return hlist LS -> F match LS with | nil => l | l :: _ => l end with | nil => fun _ => f | l :: ls => hlist_hd end Y) (match LS as LS return hlist LS -> hlist match LS with | nil => ls | _ :: ls => ls end with | nil => fun _ => x | l :: ls => hlist_tl end Y) with | hlist_eqv_nil => I | hlist_eqv_cons l ls x y h1 h2 pf1 pf2 => _ end IHx).
simpl.
subst.
intros.
f_equal.

*****
H0 : iff (equiv_hlist (fun x0 : iT => eq) h1 h2) (eq h1 h2)
pf2 : equiv_hlist (fun x : iT => eq) h1 h2
h1,h2 : hlist ls
y : F l
ls : list iT
l : iT
H : equiv_hlist (fun x : iT => eq) (Hcons f x0) y0
IHx : iff (equiv_hlist (fun x : iT => eq) x0 (hlist_tl y0))\n (eq x0 (hlist_tl y0))
y0 : hlist (cons l0 ls0)
x0 : hlist ls0
f : F l0
ls0 : list iT
l0 : iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
eq h1 h2
+++++
apply H0.
-----
Theorem equiv_eq_eq : forall ls (x y : hlist ls), equiv_hlist (fun x => @eq _) x y <-> x = y.
Proof.
induction x.
simpl.
intros.
split.
intro.
rewrite (hlist_eta y).
specialize (IHx (hlist_tl y)).
refine (match H in @equiv_hlist _ LS X Y return match X in hlist LS return F match LS with | nil => l | l :: _ => l end -> hlist match LS with | nil => ls | _ :: ls => ls end -> Prop with | Hnil => fun _ _ => True | Hcons a b c d => fun x y => (equiv_hlist (fun x0 : iT => eq) d y <-> d = y) -> @Hcons a b c d = Hcons x y end (match LS as LS return hlist LS -> F match LS with | nil => l | l :: _ => l end with | nil => fun _ => f | l :: ls => hlist_hd end Y) (match LS as LS return hlist LS -> hlist match LS with | nil => ls | _ :: ls => ls end with | nil => fun _ => x | l :: ls => hlist_tl end Y) with | hlist_eqv_nil => I | hlist_eqv_cons l ls x y h1 h2 pf1 pf2 => _ end IHx).
simpl.
subst.
intros.
f_equal.
apply H0.

*****
H0 : iff (equiv_hlist (fun x0 : iT => eq) h1 h2) (eq h1 h2)
pf2 : equiv_hlist (fun x : iT => eq) h1 h2
h1,h2 : hlist ls
y : F l
ls : list iT
l : iT
H : equiv_hlist (fun x : iT => eq) (Hcons f x0) y0
IHx : iff (equiv_hlist (fun x : iT => eq) x0 (hlist_tl y0))\n (eq x0 (hlist_tl y0))
y0 : hlist (cons l0 ls0)
x0 : hlist ls0
f : F l0
ls0 : list iT
l0 : iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
equiv_hlist (fun x0 : iT => eq) h1 h2
+++++
assumption.
-----
Theorem equiv_eq_eq : forall ls (x y : hlist ls), equiv_hlist (fun x => @eq _) x y <-> x = y.
Proof.
induction x.
simpl.
intros.
split.

*****
y : hlist (cons l ls)
IHx : forall y : hlist ls, iff (equiv_hlist (fun x : iT => eq) x y) (eq x y)
x : hlist ls
f : F l
ls : list iT
l : iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall _ : eq (Hcons f x) y, equiv_hlist (fun x : iT => eq) (Hcons f x) y
+++++
intros.
-----
Theorem equiv_eq_eq : forall ls (x y : hlist ls), equiv_hlist (fun x => @eq _) x y <-> x = y.
Proof.
induction x.
simpl.
intros.
split.
intros.

*****
H : eq (Hcons f x) y
y : hlist (cons l ls)
IHx : forall y : hlist ls, iff (equiv_hlist (fun x : iT => eq) x y) (eq x y)
x : hlist ls
f : F l
ls : list iT
l : iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
equiv_hlist (fun x : iT => eq) (Hcons f x) y
+++++
subst.
-----
Theorem equiv_eq_eq : forall ls (x y : hlist ls), equiv_hlist (fun x => @eq _) x y <-> x = y.
Proof.
induction x.
simpl.
intros.
split.
intros.
subst.

*****
IHx : forall y : hlist ls, iff (equiv_hlist (fun x : iT => eq) x y) (eq x y)
x : hlist ls
f : F l
ls : list iT
l : iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
equiv_hlist (fun x : iT => eq) (Hcons f x) (Hcons f x)
+++++
constructor.
-----
Theorem equiv_eq_eq : forall ls (x y : hlist ls), equiv_hlist (fun x => @eq _) x y <-> x = y.
Proof.
induction x.
simpl.
intros.
split.
intros.
subst.
constructor.

*****
IHx : forall y : hlist ls, iff (equiv_hlist (fun x : iT => eq) x y) (eq x y)
x : hlist ls
f : F l
ls : list iT
l : iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
eq f f
+++++
auto.
-----
Theorem equiv_eq_eq : forall ls (x y : hlist ls), equiv_hlist (fun x => @eq _) x y <-> x = y.
Proof.
induction x.
simpl.
intros.
split.
intros.
subst.
constructor.

*****
IHx : forall y : hlist ls, iff (equiv_hlist (fun x : iT => eq) x y) (eq x y)
x : hlist ls
f : F l
ls : list iT
l : iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
equiv_hlist (fun x : iT => eq) x x
+++++
auto.
-----
Theorem equiv_eq_eq : forall ls (x y : hlist ls), equiv_hlist (fun x => @eq _) x y <-> x = y.
Proof.
induction x.
simpl.
intros.
split.
intros.
subst.
constructor.
auto.

*****
IHx : forall y : hlist ls, iff (equiv_hlist (fun x : iT => eq) x y) (eq x y)
x : hlist ls
f : F l
ls : list iT
l : iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
equiv_hlist (fun x : iT => eq) x x
+++++
reflexivity.
-----
Theorem equiv_eq_eq : forall ls (x y : hlist ls), equiv_hlist (fun x => @eq _) x y <-> x = y.
Proof.
induction x.

*****

*****

+++++
Qed.
-----
Fixpoint hlist_get ls a (m : member a ls) : hlist ls -> F a :=\n    match m in member _ ls return hlist ls -> F a with\n      | MZ _ => hlist_hd\n      | MN _ _ r => fun hl => hlist_get r (hlist_tl hl)\n    end.
-----
Fixpoint hlist_nth_error {ls} (hs : hlist ls) (n : nat)\n    : option (match nth_error ls n with\n                | None => unit\n                | Some x => F x\n              end) :=\n    match hs in hlist ls return option (match nth_error ls n with\n                                          | None => unit\n                                          | Some x => F x\n                                        end)\n      with\n      | Hnil => None\n      | Hcons l ls h hs =>\n        match n as n return option (match nth_error (l :: ls) n with\n                                      | None => unit\n                                      | Some x => F x\n                                    end)\n          with\n          | 0 => Some h\n          | S n => hlist_nth_error hs n\n        end\n    end.
-----
Polymorphic Fixpoint hlist_nth ls (h : hlist ls) (n : nat) :\n    match nth_error ls n return Type with\n      | None => unit\n      | Some t => F t\n    end :=\n    match h in hlist ls , n as n\n      return match nth_error ls n with\n               | None => unit\n               | Some t => F t\n             end\n      with\n      | Hnil , 0 => tt\n      | Hnil , S _ => tt\n      | Hcons _ _ x _ , 0 => x\n      | Hcons _ _ _ h , S n => hlist_nth h n\n    end.
-----
Fixpoint nth_error_hlist_nth ls (n : nat)\n  : option (hlist ls -> match nth_error ls n with\n                          | None => Empty_set\n                          | Some x => F x\n                        end) :=\n    match ls as ls\n          return option (hlist ls -> match nth_error ls n with\n                                       | None => Empty_set\n                                       | Some x => F x\n                                     end)\n    with\n      | nil => None\n      | l :: ls =>\n        match n as n\n              return option (hlist (l :: ls) -> match nth_error (l :: ls) n with\n                                                  | None => Empty_set\n                                                  | Some x => F x\n                                                end)\n        with\n          | 0 => Some hlist_hd\n          | S n =>\n            match nth_error_hlist_nth ls n with\n              | None => None\n              | Some f => Some (fun h => f (hlist_tl h))\n            end\n        end\n    end.
-----
Definition cast1 T l\n  : forall (l' : list T) n v,\n      nth_error l n = Some v -> Some v = nth_error (l ++ l') n.
-----
Definition cast1 T l : forall (l' : list T) n v, nth_error l n = Some v -> Some v = nth_error (l ++ l') n.

*****
l : list T
T : Type@{SerTop\.138}
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall (l' : list T) (n : nat) (v : T) (_ : eq (nth_error l n) (Some v)), eq (Some v) (nth_error (app l l') n)
+++++
Proof.
-----
Definition cast1 T l : forall (l' : list T) n v, nth_error l n = Some v -> Some v = nth_error (l ++ l') n.
Proof.

*****
l : list T
T : Type@{SerTop\.138}
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall (l' : list T) (n : nat) (v : T) (_ : eq (nth_error l n) (Some v)), eq (Some v) (nth_error (app l l') n)
+++++
induction l.
-----
Definition cast1 T l : forall (l' : list T) n v, nth_error l n = Some v -> Some v = nth_error (l ++ l') n.
Proof.
induction l.

*****
T : Type@{SerTop\.138}
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall (l' : list T) (n : nat) (v : T) (_ : eq (nth_error nil n) (Some v)), eq (Some v) (nth_error (app nil l') n)
+++++
intros.
-----
Definition cast1 T l : forall (l' : list T) n v, nth_error l n = Some v -> Some v = nth_error (l ++ l') n.
Proof.
induction l.
intros.

*****
H : eq (nth_error nil n) (Some v)
v : T
n : nat
l' : list T
T : Type@{SerTop\.138}
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
eq (Some v) (nth_error (app nil l') n)
+++++
exfalso.
-----
Definition cast1 T l : forall (l' : list T) n v, nth_error l n = Some v -> Some v = nth_error (l ++ l') n.
Proof.
induction l.
intros.
exfalso.

*****
H : eq (nth_error nil n) (Some v)
v : T
n : nat
l' : list T
T : Type@{SerTop\.138}
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
False
+++++
destruct n.
-----
Definition cast1 T l : forall (l' : list T) n v, nth_error l n = Some v -> Some v = nth_error (l ++ l') n.
Proof.
induction l.
intros.
exfalso.
destruct n.

*****
H : eq (nth_error nil O) (Some v)
v : T
l' : list T
T : Type@{SerTop\.138}
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
False
+++++
inversion H.
-----
Definition cast1 T l : forall (l' : list T) n v, nth_error l n = Some v -> Some v = nth_error (l ++ l') n.
Proof.
induction l.
intros.
exfalso.
destruct n.

*****
H : eq (nth_error nil (S n)) (Some v)
v : T
n : nat
l' : list T
T : Type@{SerTop\.138}
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
False
+++++
inversion H.
-----
Definition cast1 T l : forall (l' : list T) n v, nth_error l n = Some v -> Some v = nth_error (l ++ l') n.
Proof.
induction l.

*****
IHl : forall (l' : list T) (n : nat) (v : T)\n (_ : eq (nth_error l n) (Some v)),\neq (Some v) (nth_error (app l l') n)
l : list T
a : T
T : Type@{SerTop\.138}
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall (l' : list T) (n : nat) (v : T) (_ : eq (nth_error (cons a l) n) (Some v)), eq (Some v) (nth_error (app (cons a l) l') n)
+++++
destruct n.
-----
Definition cast1 T l : forall (l' : list T) n v, nth_error l n = Some v -> Some v = nth_error (l ++ l') n.
Proof.
induction l.
destruct n.

*****
l' : list T
IHl : forall (l' : list T) (n : nat) (v : T)\n (_ : eq (nth_error l n) (Some v)),\neq (Some v) (nth_error (app l l') n)
l : list T
a : T
T : Type@{SerTop\.138}
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall (v : T) (_ : eq (nth_error (cons a l) O) (Some v)), eq (Some v) (nth_error (app (cons a l) l') O)
+++++
simpl.
-----
Definition cast1 T l : forall (l' : list T) n v, nth_error l n = Some v -> Some v = nth_error (l ++ l') n.
Proof.
induction l.
destruct n.
simpl.

*****
l' : list T
IHl : forall (l' : list T) (n : nat) (v : T)\n (_ : eq (nth_error l n) (Some v)),\neq (Some v) (nth_error (app l l') n)
l : list T
a : T
T : Type@{SerTop\.138}
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall (v : T) (_ : eq (Some a) (Some v)), eq (Some v) (Some a)
+++++
intros.
-----
Definition cast1 T l : forall (l' : list T) n v, nth_error l n = Some v -> Some v = nth_error (l ++ l') n.
Proof.
induction l.
destruct n.
simpl.
intros.

*****
H : eq (Some a) (Some v)
v : T
l' : list T
IHl : forall (l' : list T) (n : nat) (v : T)\n (_ : eq (nth_error l n) (Some v)),\neq (Some v) (nth_error (app l l') n)
l : list T
a : T
T : Type@{SerTop\.138}
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
eq (Some v) (Some a)
+++++
auto.
-----
Definition cast1 T l : forall (l' : list T) n v, nth_error l n = Some v -> Some v = nth_error (l ++ l') n.
Proof.
induction l.
destruct n.

*****
n : nat
l' : list T
IHl : forall (l' : list T) (n : nat) (v : T)\n (_ : eq (nth_error l n) (Some v)),\neq (Some v) (nth_error (app l l') n)
l : list T
a : T
T : Type@{SerTop\.138}
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall (v : T) (_ : eq (nth_error (cons a l) (S n)) (Some v)), eq (Some v) (nth_error (app (cons a l) l') (S n))
+++++
simpl.
-----
Definition cast1 T l : forall (l' : list T) n v, nth_error l n = Some v -> Some v = nth_error (l ++ l') n.
Proof.
induction l.
destruct n.
simpl.

*****
n : nat
l' : list T
IHl : forall (l' : list T) (n : nat) (v : T)\n (_ : eq (nth_error l n) (Some v)),\neq (Some v) (nth_error (app l l') n)
l : list T
a : T
T : Type@{SerTop\.138}
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall (v : T) (_ : eq (nth_error l n) (Some v)), eq (Some v) (nth_error (app l l') n)
+++++
intros.
-----
Definition cast1 T l : forall (l' : list T) n v, nth_error l n = Some v -> Some v = nth_error (l ++ l') n.
Proof.
induction l.
destruct n.
simpl.
intros.

*****
H : eq (nth_error l n) (Some v)
v : T
n : nat
l' : list T
IHl : forall (l' : list T) (n : nat) (v : T)\n (_ : eq (nth_error l n) (Some v)),\neq (Some v) (nth_error (app l l') n)
l : list T
a : T
T : Type@{SerTop\.138}
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
eq (Some v) (nth_error (app l l') n)
+++++
auto.
-----
Definition cast1 T l : forall (l' : list T) n v, nth_error l n = Some v -> Some v = nth_error (l ++ l') n.
Proof.
induction l.

*****

*****

+++++
Defined.
-----
Definition cast2 T l\n  : forall (l' : list T) n,\n      nth_error l n = None ->\n      nth_error l' (n - length l) = nth_error (l ++ l') n.
-----
Definition cast2 T l : forall (l' : list T) n, nth_error l n = None -> nth_error l' (n - length l) = nth_error (l ++ l') n.

*****
l : list T
T : Type@{SerTop\.146}
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall (l' : list T) (n : nat) (_ : eq (nth_error l n) None), eq (nth_error l' (Nat.sub n (length l))) (nth_error (app l l') n)
+++++
Proof.
-----
Definition cast2 T l : forall (l' : list T) n, nth_error l n = None -> nth_error l' (n - length l) = nth_error (l ++ l') n.
Proof.

*****
l : list T
T : Type@{SerTop\.146}
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall (l' : list T) (n : nat) (_ : eq (nth_error l n) None), eq (nth_error l' (Nat.sub n (length l))) (nth_error (app l l') n)
+++++
induction l.
-----
Definition cast2 T l : forall (l' : list T) n, nth_error l n = None -> nth_error l' (n - length l) = nth_error (l ++ l') n.
Proof.
induction l.

*****
T : Type@{SerTop\.146}
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall (l' : list T) (n : nat) (_ : eq (nth_error nil n) None), eq (nth_error l' (Nat.sub n (length nil))) (nth_error (app nil l') n)
+++++
simpl.
-----
Definition cast2 T l : forall (l' : list T) n, nth_error l n = None -> nth_error l' (n - length l) = nth_error (l ++ l') n.
Proof.
induction l.
simpl.

*****
T : Type@{SerTop\.146}
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall (l' : list T) (n : nat) (_ : eq (nth_error nil n) None), eq (nth_error l' (Nat.sub n O)) (nth_error l' n)
+++++
destruct n.
-----
Definition cast2 T l : forall (l' : list T) n, nth_error l n = None -> nth_error l' (n - length l) = nth_error (l ++ l') n.
Proof.
induction l.
simpl.
destruct n.

*****
l' : list T
T : Type@{SerTop\.146}
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall _ : eq (nth_error nil O) None, eq (nth_error l' (Nat.sub O O)) (nth_error l' O)
+++++
simpl.
-----
Definition cast2 T l : forall (l' : list T) n, nth_error l n = None -> nth_error l' (n - length l) = nth_error (l ++ l') n.
Proof.
induction l.
simpl.
destruct n.
simpl.

*****
l' : list T
T : Type@{SerTop\.146}
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall _ : eq None None, eq match l' with | nil => None | cons x _ => Some x end match l' with | nil => None | cons x _ => Some x end
+++++
auto.
-----
Definition cast2 T l : forall (l' : list T) n, nth_error l n = None -> nth_error l' (n - length l) = nth_error (l ++ l') n.
Proof.
induction l.
simpl.
destruct n.

*****
n : nat
l' : list T
T : Type@{SerTop\.146}
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall _ : eq (nth_error nil (S n)) None, eq (nth_error l' (Nat.sub (S n) O)) (nth_error l' (S n))
+++++
simpl.
-----
Definition cast2 T l : forall (l' : list T) n, nth_error l n = None -> nth_error l' (n - length l) = nth_error (l ++ l') n.
Proof.
induction l.
simpl.
destruct n.
simpl.

*****
n : nat
l' : list T
T : Type@{SerTop\.146}
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall _ : eq None None, eq match l' with | nil => None | cons _ l => nth_error l n end match l' with | nil => None | cons _ l => nth_error l n end
+++++
auto.
-----
Definition cast2 T l : forall (l' : list T) n, nth_error l n = None -> nth_error l' (n - length l) = nth_error (l ++ l') n.
Proof.
induction l.

*****
IHl : forall (l' : list T) (n : nat) (_ : eq (nth_error l n) None),\neq (nth_error l' (Nat.sub n (length l))) (nth_error (app l l') n)
l : list T
a : T
T : Type@{SerTop\.146}
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall (l' : list T) (n : nat) (_ : eq (nth_error (cons a l) n) None), eq (nth_error l' (Nat.sub n (length (cons a l)))) (nth_error (app (cons a l) l') n)
+++++
simpl.
-----
Definition cast2 T l : forall (l' : list T) n, nth_error l n = None -> nth_error l' (n - length l) = nth_error (l ++ l') n.
Proof.
induction l.
simpl.

*****
IHl : forall (l' : list T) (n : nat) (_ : eq (nth_error l n) None),\neq (nth_error l' (Nat.sub n (length l))) (nth_error (app l l') n)
l : list T
a : T
T : Type@{SerTop\.146}
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall (l' : list T) (n : nat) (_ : eq (nth_error (cons a l) n) None), eq (nth_error l' (Nat.sub n (S (length l)))) (nth_error (cons a (app l l')) n)
+++++
destruct n.
-----
Definition cast2 T l : forall (l' : list T) n, nth_error l n = None -> nth_error l' (n - length l) = nth_error (l ++ l') n.
Proof.
induction l.
simpl.
destruct n.

*****
l' : list T
IHl : forall (l' : list T) (n : nat) (_ : eq (nth_error l n) None),\neq (nth_error l' (Nat.sub n (length l))) (nth_error (app l l') n)
l : list T
a : T
T : Type@{SerTop\.146}
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall _ : eq (nth_error (cons a l) O) None, eq (nth_error l' (Nat.sub O (S (length l)))) (nth_error (cons a (app l l')) O)
+++++
simpl.
-----
Definition cast2 T l : forall (l' : list T) n, nth_error l n = None -> nth_error l' (n - length l) = nth_error (l ++ l') n.
Proof.
induction l.
simpl.
destruct n.
simpl.

*****
l' : list T
IHl : forall (l' : list T) (n : nat) (_ : eq (nth_error l n) None),\neq (nth_error l' (Nat.sub n (length l))) (nth_error (app l l') n)
l : list T
a : T
T : Type@{SerTop\.146}
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall _ : eq (Some a) None, eq match l' with | nil => None | cons x _ => Some x end (Some a)
+++++
auto.
-----
Definition cast2 T l : forall (l' : list T) n, nth_error l n = None -> nth_error l' (n - length l) = nth_error (l ++ l') n.
Proof.
induction l.
simpl.
destruct n.
simpl.
auto.

*****
l' : list T
IHl : forall (l' : list T) (n : nat) (_ : eq (nth_error l n) None),\neq (nth_error l' (Nat.sub n (length l))) (nth_error (app l l') n)
l : list T
a : T
T : Type@{SerTop\.146}
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall _ : eq (Some a) None, eq match l' with | nil => None | cons x _ => Some x end (Some a)
+++++
inversion 1.
-----
Definition cast2 T l : forall (l' : list T) n, nth_error l n = None -> nth_error l' (n - length l) = nth_error (l ++ l') n.
Proof.
induction l.
simpl.
destruct n.

*****
n : nat
l' : list T
IHl : forall (l' : list T) (n : nat) (_ : eq (nth_error l n) None),\neq (nth_error l' (Nat.sub n (length l))) (nth_error (app l l') n)
l : list T
a : T
T : Type@{SerTop\.146}
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall _ : eq (nth_error (cons a l) (S n)) None, eq (nth_error l' (Nat.sub (S n) (S (length l)))) (nth_error (cons a (app l l')) (S n))
+++++
simpl.
-----
Definition cast2 T l : forall (l' : list T) n, nth_error l n = None -> nth_error l' (n - length l) = nth_error (l ++ l') n.
Proof.
induction l.
simpl.
destruct n.
simpl.

*****
n : nat
l' : list T
IHl : forall (l' : list T) (n : nat) (_ : eq (nth_error l n) None),\neq (nth_error l' (Nat.sub n (length l))) (nth_error (app l l') n)
l : list T
a : T
T : Type@{SerTop\.146}
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall _ : eq (nth_error l n) None, eq (nth_error l' (Nat.sub n (length l))) (nth_error (app l l') n)
+++++
auto.
-----
Definition cast2 T l : forall (l' : list T) n, nth_error l n = None -> nth_error l' (n - length l) = nth_error (l ++ l') n.
Proof.
induction l.

*****

*****

+++++
Defined.
-----
Theorem hlist_nth_hlist_app\n  : forall l l' (h : hlist l) (h' : hlist l') n,\n    hlist_nth (hlist_app h h') n =\n    match nth_error l n as k\n      return nth_error l n = k ->\n      match nth_error (l ++ l') n return Type with\n        | None => unit\n        | Some t => F t\n      end\n    with\n      | Some _ => fun pf =>\n        match\n          cast1 _ _ _ pf in _ = z ,\n          eq_sym pf in _ = w\n          return match w return Type with\n                   | None => unit\n                   | Some t => F t\n                 end ->\n                 match z return Type with\n                   | None => unit\n                   | Some t => F t\n                 end\n        with\n          | eq_refl , eq_refl => fun x => x\n        end (hlist_nth h n)\n      | None => fun pf =>\n        match cast2 _ _ _ pf in _ = z\n          return match z with\n                   | Some t => F t\n                   | None => unit\n                 end\n        with\n          | eq_refl => hlist_nth h' (n - length l)\n        end\n    end eq_refl.
-----
Theorem hlist_nth_hlist_app : forall l l' (h : hlist l) (h' : hlist l') n, hlist_nth (hlist_app h h') n = match nth_error l n as k return nth_error l n = k -> match nth_error (l ++ l') n return Type with | None => unit | Some t => F t end with | Some _ => fun pf => match cast1 _ _ _ pf in _ = z , eq_sym pf in _ = w return match w return Type with | None => unit | Some t => F t end -> match z return Type with | None => unit | Some t => F t end with | eq_refl , eq_refl => fun x => x end (hlist_nth h n) | None => fun pf => match cast2 _ _ _ pf in _ = z return match z with | Some t => F t | None => unit end with | eq_refl => hlist_nth h' (n - length l) end end eq_refl.

*****
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall (l l' : list iT) (h : hlist l) (h' : hlist l') (n : nat), eq (hlist_nth@{SerTop.155} (hlist_app h h') n) (match nth_error l n as k return (forall _ : eq (nth_error l n) k, match nth_error (app l l') n with | Some t => F t | None => unit end) with | Some i => fun pf : eq (nth_error l n) (Some i) => match cast1@{Ui} l l' n pf in (eq _ z) return (forall _ : match nth_error l n with | Some t => F t | None => unit end, match z with | Some t => F t | None => unit end) with | eq_refl => match eq_sym pf in (eq _ w) return (forall _ : match w with | Some t => F t | None => unit end, F i) with | eq_refl => fun x : match Some i with | Some t => F t | None => unit end => x end end (hlist_nth@{SerTop.159} h n) | None => fun pf : eq (nth_error l n) None => match cast2@{Ui} l l' n pf in (eq _ z) return match z with | Some t => F t | None => unit end with | eq_refl => hlist_nth@{SerTop.155} h' (Nat.sub n (length l)) end end eq_refl)
+++++
Proof.
-----
Theorem hlist_nth_hlist_app : forall l l' (h : hlist l) (h' : hlist l') n, hlist_nth (hlist_app h h') n = match nth_error l n as k return nth_error l n = k -> match nth_error (l ++ l') n return Type with | None => unit | Some t => F t end with | Some _ => fun pf => match cast1 _ _ _ pf in _ = z , eq_sym pf in _ = w return match w return Type with | None => unit | Some t => F t end -> match z return Type with | None => unit | Some t => F t end with | eq_refl , eq_refl => fun x => x end (hlist_nth h n) | None => fun pf => match cast2 _ _ _ pf in _ = z return match z with | Some t => F t | None => unit end with | eq_refl => hlist_nth h' (n - length l) end end eq_refl.
Proof.

*****
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall (l l' : list iT) (h : hlist l) (h' : hlist l') (n : nat), eq (hlist_nth@{SerTop.155} (hlist_app h h') n) (match nth_error l n as k return (forall _ : eq (nth_error l n) k, match nth_error (app l l') n with | Some t => F t | None => unit end) with | Some i => fun pf : eq (nth_error l n) (Some i) => match cast1@{Ui} l l' n pf in (eq _ z) return (forall _ : match nth_error l n with | Some t => F t | None => unit end, match z with | Some t => F t | None => unit end) with | eq_refl => match eq_sym pf in (eq _ w) return (forall _ : match w with | Some t => F t | None => unit end, F i) with | eq_refl => fun x : match Some i with | Some t => F t | None => unit end => x end end (hlist_nth@{SerTop.159} h n) | None => fun pf : eq (nth_error l n) None => match cast2@{Ui} l l' n pf in (eq _ z) return match z with | Some t => F t | None => unit end with | eq_refl => hlist_nth@{SerTop.155} h' (Nat.sub n (length l)) end end eq_refl)
+++++
induction h.
-----
Theorem hlist_nth_hlist_app : forall l l' (h : hlist l) (h' : hlist l') n, hlist_nth (hlist_app h h') n = match nth_error l n as k return nth_error l n = k -> match nth_error (l ++ l') n return Type with | None => unit | Some t => F t end with | Some _ => fun pf => match cast1 _ _ _ pf in _ = z , eq_sym pf in _ = w return match w return Type with | None => unit | Some t => F t end -> match z return Type with | None => unit | Some t => F t end with | eq_refl , eq_refl => fun x => x end (hlist_nth h n) | None => fun pf => match cast2 _ _ _ pf in _ = z return match z with | Some t => F t | None => unit end with | eq_refl => hlist_nth h' (n - length l) end end eq_refl.
Proof.
induction h.

*****
l' : list iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall (h' : hlist l') (n : nat), eq (hlist_nth@{SerTop.155} (hlist_app Hnil h') n) (match nth_error nil n as k return (forall _ : eq (nth_error nil n) k, match nth_error (app nil l') n with | Some t => F t | None => unit end) with | Some i => fun pf : eq (nth_error nil n) (Some i) => match cast1@{Ui} nil l' n pf in (eq _ z) return (forall _ : match nth_error nil n with | Some t => F t | None => unit end, match z with | Some t => F t | None => unit end) with | eq_refl => match eq_sym pf in (eq _ w) return (forall _ : match w with | Some t => F t | None => unit end, F i) with | eq_refl => fun x : F i => x end end (hlist_nth@{SerTop.159} Hnil n) | None => fun pf : eq (nth_error nil n) None => match cast2@{Ui} nil l' n pf in (eq _ z) return match z with | Some t => F t | None => unit end with | eq_refl => hlist_nth@{SerTop.155} h' (Nat.sub n (length nil)) end end eq_refl)
+++++
simpl.
-----
Theorem hlist_nth_hlist_app : forall l l' (h : hlist l) (h' : hlist l') n, hlist_nth (hlist_app h h') n = match nth_error l n as k return nth_error l n = k -> match nth_error (l ++ l') n return Type with | None => unit | Some t => F t end with | Some _ => fun pf => match cast1 _ _ _ pf in _ = z , eq_sym pf in _ = w return match w return Type with | None => unit | Some t => F t end -> match z return Type with | None => unit | Some t => F t end with | eq_refl , eq_refl => fun x => x end (hlist_nth h n) | None => fun pf => match cast2 _ _ _ pf in _ = z return match z with | Some t => F t | None => unit end with | eq_refl => hlist_nth h' (n - length l) end end eq_refl.
Proof.
induction h.
simpl.

*****
l' : list iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall (h' : hlist l') (n : nat), eq (hlist_nth@{SerTop.155} h' n) (match nth_error nil n as k return (forall _ : eq (nth_error nil n) k, match nth_error l' n with | Some t => F t | None => unit end) with | Some i => fun pf : eq (nth_error nil n) (Some i) => match False_ind (eq (Some i) (nth_error l' n)) (match n as n0 return (forall _ : eq (nth_error nil n0) (Some i), False) with | O | _ => fun H : eq None (Some i) => match H in (eq _ y) return (forall _ : eq y (Some i), False) with | eq_refl => fun H0 : eq None (Some i) => False_ind False (eq_ind None (fun e : option iT => match e with | Some _ => False | None => True end) I (Some i) H0) end eq_refl end pf) in (eq _ z) return (forall _ : match nth_error nil n with | Some t => F t | None => unit end, match z with | Some t => F t | None => unit end) with | eq_refl => match eq_sym pf in (eq _ w) return (forall _ : match w with | Some t => F t | None => unit end, F i) with | eq_refl => fun x : F i => x end end match n as n0 return match nth_error nil n0 with | Some t => F t | None => unit end with | O | _ => tt end | None => fun pf : eq (nth_error nil n) None => match match n as n0 return (forall _ : eq (nth_error nil n0) None, eq (nth_error l' (Nat.sub n0 O)) (nth_error l' n0)) with | O => fun _ : eq None None => eq_refl | S n0 => fun _ : eq None None => eq_refl end pf in (eq _ z) return match z with | Some t => F t | None => unit end with | eq_refl => hlist_nth@{SerTop.155} h' (Nat.sub n O) end end eq_refl)
+++++
intros.
-----
Theorem hlist_nth_hlist_app : forall l l' (h : hlist l) (h' : hlist l') n, hlist_nth (hlist_app h h') n = match nth_error l n as k return nth_error l n = k -> match nth_error (l ++ l') n return Type with | None => unit | Some t => F t end with | Some _ => fun pf => match cast1 _ _ _ pf in _ = z , eq_sym pf in _ = w return match w return Type with | None => unit | Some t => F t end -> match z return Type with | None => unit | Some t => F t end with | eq_refl , eq_refl => fun x => x end (hlist_nth h n) | None => fun pf => match cast2 _ _ _ pf in _ = z return match z with | Some t => F t | None => unit end with | eq_refl => hlist_nth h' (n - length l) end end eq_refl.
Proof.
induction h.
simpl.
intros.

*****
n : nat
h' : hlist l'
l' : list iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
eq (hlist_nth@{SerTop.155} h' n) (match nth_error nil n as k return (forall _ : eq (nth_error nil n) k, match nth_error l' n with | Some t => F t | None => unit end) with | Some i => fun pf : eq (nth_error nil n) (Some i) => match False_ind (eq (Some i) (nth_error l' n)) (match n return (forall _ : eq (nth_error nil n) (Some i), False) with | O | _ => fun H : eq None (Some i) => match H in (eq _ y) return (forall _ : eq y (Some i), False) with | eq_refl => fun H0 : eq None (Some i) => False_ind False (eq_ind None (fun e : option iT => match e with | Some _ => False | None => True end) I (Some i) H0) end eq_refl end pf) in (eq _ z) return (forall _ : match nth_error nil n with | Some t => F t | None => unit end, match z with | Some t => F t | None => unit end) with | eq_refl => match eq_sym pf in (eq _ w) return (forall _ : match w with | Some t => F t | None => unit end, F i) with | eq_refl => fun x : F i => x end end match n return match nth_error nil n with | Some t => F t | None => unit end with | O | _ => tt end | None => fun pf : eq (nth_error nil n) None => match match n return (forall _ : eq (nth_error nil n) None, eq (nth_error l' (Nat.sub n O)) (nth_error l' n)) with | O => fun _ : eq None None => eq_refl | S n => fun _ : eq None None => eq_refl end pf in (eq _ z) return match z with | Some t => F t | None => unit end with | eq_refl => hlist_nth@{SerTop.155} h' (Nat.sub n O) end end eq_refl)
+++++
destruct n.
-----
Theorem hlist_nth_hlist_app : forall l l' (h : hlist l) (h' : hlist l') n, hlist_nth (hlist_app h h') n = match nth_error l n as k return nth_error l n = k -> match nth_error (l ++ l') n return Type with | None => unit | Some t => F t end with | Some _ => fun pf => match cast1 _ _ _ pf in _ = z , eq_sym pf in _ = w return match w return Type with | None => unit | Some t => F t end -> match z return Type with | None => unit | Some t => F t end with | eq_refl , eq_refl => fun x => x end (hlist_nth h n) | None => fun pf => match cast2 _ _ _ pf in _ = z return match z with | Some t => F t | None => unit end with | eq_refl => hlist_nth h' (n - length l) end end eq_refl.
Proof.
induction h.
simpl.
intros.
destruct n.

*****
h' : hlist l'
l' : list iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
eq (hlist_nth@{SerTop.155} h' O) (match nth_error nil O as k return (forall _ : eq (nth_error nil O) k, match nth_error l' O with | Some t => F t | None => unit end) with | Some i => fun pf : eq (nth_error nil O) (Some i) => match False_ind (eq (Some i) (nth_error l' O)) (match pf in (eq _ y) return (forall _ : eq y (Some i), False) with | eq_refl => fun H0 : eq None (Some i) => False_ind False (eq_ind None (fun e : option iT => match e with | Some _ => False | None => True end) I (Some i) H0) end eq_refl) in (eq _ z) return (forall _ : match nth_error nil O with | Some t => F t | None => unit end, match z with | Some t => F t | None => unit end) with | eq_refl => match eq_sym pf in (eq _ w) return (forall _ : match w with | Some t => F t | None => unit end, F i) with | eq_refl => fun x : F i => x end end tt | None => fun _ : eq (nth_error nil O) None => hlist_nth@{SerTop.155} h' (Nat.sub O O) end eq_refl)
+++++
simpl in *.
-----
Theorem hlist_nth_hlist_app : forall l l' (h : hlist l) (h' : hlist l') n, hlist_nth (hlist_app h h') n = match nth_error l n as k return nth_error l n = k -> match nth_error (l ++ l') n return Type with | None => unit | Some t => F t end with | Some _ => fun pf => match cast1 _ _ _ pf in _ = z , eq_sym pf in _ = w return match w return Type with | None => unit | Some t => F t end -> match z return Type with | None => unit | Some t => F t end with | eq_refl , eq_refl => fun x => x end (hlist_nth h n) | None => fun pf => match cast2 _ _ _ pf in _ = z return match z with | Some t => F t | None => unit end with | eq_refl => hlist_nth h' (n - length l) end end eq_refl.
Proof.
induction h.
simpl.
intros.
destruct n.
simpl in *.

*****
h' : hlist l'
l' : list iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
eq (hlist_nth@{SerTop.155} h' O) (hlist_nth@{SerTop.155} h' O)
+++++
reflexivity.
-----
Theorem hlist_nth_hlist_app : forall l l' (h : hlist l) (h' : hlist l') n, hlist_nth (hlist_app h h') n = match nth_error l n as k return nth_error l n = k -> match nth_error (l ++ l') n return Type with | None => unit | Some t => F t end with | Some _ => fun pf => match cast1 _ _ _ pf in _ = z , eq_sym pf in _ = w return match w return Type with | None => unit | Some t => F t end -> match z return Type with | None => unit | Some t => F t end with | eq_refl , eq_refl => fun x => x end (hlist_nth h n) | None => fun pf => match cast2 _ _ _ pf in _ = z return match z with | Some t => F t | None => unit end with | eq_refl => hlist_nth h' (n - length l) end end eq_refl.
Proof.
induction h.
simpl.
intros.
destruct n.

*****
n : nat
h' : hlist l'
l' : list iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
eq (hlist_nth@{SerTop.155} h' (S n)) (match nth_error nil (S n) as k return (forall _ : eq (nth_error nil (S n)) k, match nth_error l' (S n) with | Some t => F t | None => unit end) with | Some i => fun pf : eq (nth_error nil (S n)) (Some i) => match False_ind (eq (Some i) (nth_error l' (S n))) (match pf in (eq _ y) return (forall _ : eq y (Some i), False) with | eq_refl => fun H0 : eq None (Some i) => False_ind False (eq_ind None (fun e : option iT => match e with | Some _ => False | None => True end) I (Some i) H0) end eq_refl) in (eq _ z) return (forall _ : match nth_error nil (S n) with | Some t => F t | None => unit end, match z with | Some t => F t | None => unit end) with | eq_refl => match eq_sym pf in (eq _ w) return (forall _ : match w with | Some t => F t | None => unit end, F i) with | eq_refl => fun x : F i => x end end tt | None => fun _ : eq (nth_error nil (S n)) None => hlist_nth@{SerTop.155} h' (Nat.sub (S n) O) end eq_refl)
+++++
simpl in *.
-----
Theorem hlist_nth_hlist_app : forall l l' (h : hlist l) (h' : hlist l') n, hlist_nth (hlist_app h h') n = match nth_error l n as k return nth_error l n = k -> match nth_error (l ++ l') n return Type with | None => unit | Some t => F t end with | Some _ => fun pf => match cast1 _ _ _ pf in _ = z , eq_sym pf in _ = w return match w return Type with | None => unit | Some t => F t end -> match z return Type with | None => unit | Some t => F t end with | eq_refl , eq_refl => fun x => x end (hlist_nth h n) | None => fun pf => match cast2 _ _ _ pf in _ = z return match z with | Some t => F t | None => unit end with | eq_refl => hlist_nth h' (n - length l) end end eq_refl.
Proof.
induction h.
simpl.
intros.
destruct n.
simpl in *.

*****
n : nat
h' : hlist l'
l' : list iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
eq (hlist_nth@{SerTop.155} h' (S n)) (hlist_nth@{SerTop.155} h' (S n))
+++++
reflexivity.
-----
Theorem hlist_nth_hlist_app : forall l l' (h : hlist l) (h' : hlist l') n, hlist_nth (hlist_app h h') n = match nth_error l n as k return nth_error l n = k -> match nth_error (l ++ l') n return Type with | None => unit | Some t => F t end with | Some _ => fun pf => match cast1 _ _ _ pf in _ = z , eq_sym pf in _ = w return match w return Type with | None => unit | Some t => F t end -> match z return Type with | None => unit | Some t => F t end with | eq_refl , eq_refl => fun x => x end (hlist_nth h n) | None => fun pf => match cast2 _ _ _ pf in _ = z return match z with | Some t => F t | None => unit end with | eq_refl => hlist_nth h' (n - length l) end end eq_refl.
Proof.
induction h.

*****
IHh : forall (h' : hlist l') (n : nat),\neq (hlist_nth@{SerTop.155} (hlist_app h h') n)\n (match\n nth_error ls n as k\n return\n (forall _ : eq (nth_error ls n) k,\n match nth_error (app ls l') n with\n | Some t => F t\n | None => unit\n end)\n with\n | Some i =>\n fun pf : eq (nth_error ls n) (Some i) =>\n match\n cast1@{Ui} ls l' n pf in (eq _ z)\n return\n (forall\n _ : match nth_error ls n with\n | Some t => F t\n | None => unit\n end, match z with\n | Some t => F t\n | None => unit\n end)\n with\n | eq_refl =>\n match\n eq_sym pf in (eq _ w)\n return\n (forall\n _ : match w with\n | Some t => F t\n | None => unit\n end, F i)\n with\n | eq_refl => fun x : F i => x\n end\n end (hlist_nth@{SerTop.159} h n)\n | None =>\n fun pf : eq (nth_error ls n) None =>\n match\n cast2@{Ui} ls l' n pf in (eq _ z)\n return match z with\n | Some t => F t\n | None => unit\n end\n with\n | eq_refl => hlist_nth@{SerTop.155} h' (Nat.sub n (length ls))\n end\n end eq_refl)
h : hlist ls
f : F l
ls : list iT
l : iT
l' : list iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall (h' : hlist l') (n : nat), eq (hlist_nth@{SerTop.155} (hlist_app (Hcons f h) h') n) (match nth_error (cons l ls) n as k return (forall _ : eq (nth_error (cons l ls) n) k, match nth_error (app (cons l ls) l') n with | Some t => F t | None => unit end) with | Some i => fun pf : eq (nth_error (cons l ls) n) (Some i) => match cast1@{Ui} (cons l ls) l' n pf in (eq _ z) return (forall _ : match nth_error (cons l ls) n with | Some t => F t | None => unit end, match z with | Some t => F t | None => unit end) with | eq_refl => match eq_sym pf in (eq _ w) return (forall _ : match w with | Some t => F t | None => unit end, F i) with | eq_refl => fun x : F i => x end end (hlist_nth@{SerTop.159} (Hcons f h) n) | None => fun pf : eq (nth_error (cons l ls) n) None => match cast2@{Ui} (cons l ls) l' n pf in (eq _ z) return match z with | Some t => F t | None => unit end with | eq_refl => hlist_nth@{SerTop.155} h' (Nat.sub n (length (cons l ls))) end end eq_refl)
+++++
simpl.
-----
Theorem hlist_nth_hlist_app : forall l l' (h : hlist l) (h' : hlist l') n, hlist_nth (hlist_app h h') n = match nth_error l n as k return nth_error l n = k -> match nth_error (l ++ l') n return Type with | None => unit | Some t => F t end with | Some _ => fun pf => match cast1 _ _ _ pf in _ = z , eq_sym pf in _ = w return match w return Type with | None => unit | Some t => F t end -> match z return Type with | None => unit | Some t => F t end with | eq_refl , eq_refl => fun x => x end (hlist_nth h n) | None => fun pf => match cast2 _ _ _ pf in _ = z return match z with | Some t => F t | None => unit end with | eq_refl => hlist_nth h' (n - length l) end end eq_refl.
Proof.
induction h.
simpl.

*****
IHh : forall (h' : hlist l') (n : nat),\neq (hlist_nth@{SerTop.155} (hlist_app h h') n)\n (match\n nth_error ls n as k\n return\n (forall _ : eq (nth_error ls n) k,\n match nth_error (app ls l') n with\n | Some t => F t\n | None => unit\n end)\n with\n | Some i =>\n fun pf : eq (nth_error ls n) (Some i) =>\n match\n cast1@{Ui} ls l' n pf in (eq _ z)\n return\n (forall\n _ : match nth_error ls n with\n | Some t => F t\n | None => unit\n end, match z with\n | Some t => F t\n | None => unit\n end)\n with\n | eq_refl =>\n match\n eq_sym pf in (eq _ w)\n return\n (forall\n _ : match w with\n | Some t => F t\n | None => unit\n end, F i)\n with\n | eq_refl => fun x : F i => x\n end\n end (hlist_nth@{SerTop.159} h n)\n | None =>\n fun pf : eq (nth_error ls n) None =>\n match\n cast2@{Ui} ls l' n pf in (eq _ z)\n return match z with\n | Some t => F t\n | None => unit\n end\n with\n | eq_refl => hlist_nth@{SerTop.155} h' (Nat.sub n (length ls))\n end\n end eq_refl)
h : hlist ls
f : F l
ls : list iT
l : iT
l' : list iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall (h' : hlist l') (n : nat), eq match n as n0 return match nth_error (cons l (app ls l')) n0 with | Some t => F t | None => unit end with | O => f | S n0 => hlist_nth@{SerTop.155} (hlist_app h h') n0 end (match nth_error (cons l ls) n as k return (forall _ : eq (nth_error (cons l ls) n) k, match nth_error (cons l (app ls l')) n with | Some t => F t | None => unit end) with | Some i => fun pf : eq (nth_error (cons l ls) n) (Some i) => match match n as n0 return (forall (v : iT) (_ : eq (nth_error (cons l ls) n0) (Some v)), eq (Some v) (nth_error (cons l (app ls l')) n0)) with | O => fun (v : iT) (H : eq (Some l) (Some v)) => eq_sym H | S n0 => fun (v : iT) (H : eq (nth_error ls n0) (Some v)) => cast1@{Ui} ls l' n0 H end i pf in (eq _ z) return (forall _ : match nth_error (cons l ls) n with | Some t => F t | None => unit end, match z with | Some t => F t | None => unit end) with | eq_refl => match eq_sym pf in (eq _ w) return (forall _ : match w with | Some t => F t | None => unit end, F i) with | eq_refl => fun x : F i => x end end match n as n0 return match nth_error (cons l ls) n0 with | Some t => F t | None => unit end with | O => f | S n0 => hlist_nth@{SerTop.159} h n0 end | None => fun pf : eq (nth_error (cons l ls) n) None => match match n as n0 return (forall _ : eq (nth_error (cons l ls) n0) None, eq (nth_error l' (Nat.sub n0 (S (length ls)))) (nth_error (cons l (app ls l')) n0)) with | O => fun H : eq (Some l) None => match H in (eq _ y) return (forall _ : eq y None, eq match l' with | nil => None | cons x _ => Some x end (Some l)) with | eq_refl => fun H0 : eq (Some l) None => False_ind (eq match l' with | nil => None | cons x _ => Some x end (Some l)) (eq_ind (Some l) (fun e : option iT => match e with | Some _ => True | None => False end) I None H0) end eq_refl | S n0 => fun H : eq (nth_error ls n0) None => cast2@{Ui} ls l' n0 H end pf in (eq _ z) return match z with | Some t => F t | None => unit end with | eq_refl => hlist_nth@{SerTop.155} h' (Nat.sub n (S (length ls))) end end eq_refl)
+++++
intros.
-----
Theorem hlist_nth_hlist_app : forall l l' (h : hlist l) (h' : hlist l') n, hlist_nth (hlist_app h h') n = match nth_error l n as k return nth_error l n = k -> match nth_error (l ++ l') n return Type with | None => unit | Some t => F t end with | Some _ => fun pf => match cast1 _ _ _ pf in _ = z , eq_sym pf in _ = w return match w return Type with | None => unit | Some t => F t end -> match z return Type with | None => unit | Some t => F t end with | eq_refl , eq_refl => fun x => x end (hlist_nth h n) | None => fun pf => match cast2 _ _ _ pf in _ = z return match z with | Some t => F t | None => unit end with | eq_refl => hlist_nth h' (n - length l) end end eq_refl.
Proof.
induction h.
simpl.
intros.

*****
n : nat
h' : hlist l'
IHh : forall (h' : hlist l') (n : nat),\neq (hlist_nth@{SerTop.155} (hlist_app h h') n)\n (match\n nth_error ls n as k\n return\n (forall _ : eq (nth_error ls n) k,\n match nth_error (app ls l') n with\n | Some t => F t\n | None => unit\n end)\n with\n | Some i =>\n fun pf : eq (nth_error ls n) (Some i) =>\n match\n cast1@{Ui} ls l' n pf in (eq _ z)\n return\n (forall\n _ : match nth_error ls n with\n | Some t => F t\n | None => unit\n end, match z with\n | Some t => F t\n | None => unit\n end)\n with\n | eq_refl =>\n match\n eq_sym pf in (eq _ w)\n return\n (forall\n _ : match w with\n | Some t => F t\n | None => unit\n end, F i)\n with\n | eq_refl => fun x : F i => x\n end\n end (hlist_nth@{SerTop.159} h n)\n | None =>\n fun pf : eq (nth_error ls n) None =>\n match\n cast2@{Ui} ls l' n pf in (eq _ z)\n return match z with\n | Some t => F t\n | None => unit\n end\n with\n | eq_refl => hlist_nth@{SerTop.155} h' (Nat.sub n (length ls))\n end\n end eq_refl)
h : hlist ls
f : F l
ls : list iT
l : iT
l' : list iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
eq match n return match nth_error (cons l (app ls l')) n with | Some t => F t | None => unit end with | O => f | S n => hlist_nth@{SerTop.155} (hlist_app h h') n end (match nth_error (cons l ls) n as k return (forall _ : eq (nth_error (cons l ls) n) k, match nth_error (cons l (app ls l')) n with | Some t => F t | None => unit end) with | Some i => fun pf : eq (nth_error (cons l ls) n) (Some i) => match match n return (forall (v : iT) (_ : eq (nth_error (cons l ls) n) (Some v)), eq (Some v) (nth_error (cons l (app ls l')) n)) with | O => fun (v : iT) (H : eq (Some l) (Some v)) => eq_sym H | S n => fun (v : iT) (H : eq (nth_error ls n) (Some v)) => cast1@{Ui} ls l' n H end i pf in (eq _ z) return (forall _ : match nth_error (cons l ls) n with | Some t => F t | None => unit end, match z with | Some t => F t | None => unit end) with | eq_refl => match eq_sym pf in (eq _ w) return (forall _ : match w with | Some t => F t | None => unit end, F i) with | eq_refl => fun x : F i => x end end match n return match nth_error (cons l ls) n with | Some t => F t | None => unit end with | O => f | S n => hlist_nth@{SerTop.159} h n end | None => fun pf : eq (nth_error (cons l ls) n) None => match match n return (forall _ : eq (nth_error (cons l ls) n) None, eq (nth_error l' (Nat.sub n (S (length ls)))) (nth_error (cons l (app ls l')) n)) with | O => fun H : eq (Some l) None => match H in (eq _ y) return (forall _ : eq y None, eq match l' with | nil => None | cons x _ => Some x end (Some l)) with | eq_refl => fun H0 : eq (Some l) None => False_ind (eq match l' with | nil => None | cons x _ => Some x end (Some l)) (eq_ind (Some l) (fun e : option iT => match e with | Some _ => True | None => False end) I None H0) end eq_refl | S n => fun H : eq (nth_error ls n) None => cast2@{Ui} ls l' n H end pf in (eq _ z) return match z with | Some t => F t | None => unit end with | eq_refl => hlist_nth@{SerTop.155} h' (Nat.sub n (S (length ls))) end end eq_refl)
+++++
destruct n.
-----
Theorem hlist_nth_hlist_app : forall l l' (h : hlist l) (h' : hlist l') n, hlist_nth (hlist_app h h') n = match nth_error l n as k return nth_error l n = k -> match nth_error (l ++ l') n return Type with | None => unit | Some t => F t end with | Some _ => fun pf => match cast1 _ _ _ pf in _ = z , eq_sym pf in _ = w return match w return Type with | None => unit | Some t => F t end -> match z return Type with | None => unit | Some t => F t end with | eq_refl , eq_refl => fun x => x end (hlist_nth h n) | None => fun pf => match cast2 _ _ _ pf in _ = z return match z with | Some t => F t | None => unit end with | eq_refl => hlist_nth h' (n - length l) end end eq_refl.
Proof.
induction h.
simpl.
intros.
destruct n.

*****
h' : hlist l'
IHh : forall (h' : hlist l') (n : nat),\neq (hlist_nth@{SerTop.155} (hlist_app h h') n)\n (match\n nth_error ls n as k\n return\n (forall _ : eq (nth_error ls n) k,\n match nth_error (app ls l') n with\n | Some t => F t\n | None => unit\n end)\n with\n | Some i =>\n fun pf : eq (nth_error ls n) (Some i) =>\n match\n cast1@{Ui} ls l' n pf in (eq _ z)\n return\n (forall\n _ : match nth_error ls n with\n | Some t => F t\n | None => unit\n end, match z with\n | Some t => F t\n | None => unit\n end)\n with\n | eq_refl =>\n match\n eq_sym pf in (eq _ w)\n return\n (forall\n _ : match w with\n | Some t => F t\n | None => unit\n end, F i)\n with\n | eq_refl => fun x : F i => x\n end\n end (hlist_nth@{SerTop.159} h n)\n | None =>\n fun pf : eq (nth_error ls n) None =>\n match\n cast2@{Ui} ls l' n pf in (eq _ z)\n return match z with\n | Some t => F t\n | None => unit\n end\n with\n | eq_refl => hlist_nth@{SerTop.155} h' (Nat.sub n (length ls))\n end\n end eq_refl)
h : hlist ls
f : F l
ls : list iT
l : iT
l' : list iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
eq f (match nth_error (cons l ls) O as k return (forall _ : eq (nth_error (cons l ls) O) k, match nth_error (cons l (app ls l')) O with | Some t => F t | None => unit end) with | Some i => fun pf : eq (nth_error (cons l ls) O) (Some i) => match eq_sym pf in (eq _ z) return (forall _ : match nth_error (cons l ls) O with | Some t => F t | None => unit end, match z with | Some t => F t | None => unit end) with | eq_refl => match eq_sym pf in (eq _ w) return (forall _ : match w with | Some t => F t | None => unit end, F i) with | eq_refl => fun x : F i => x end end f | None => fun pf : eq (nth_error (cons l ls) O) None => match match pf in (eq _ y) return (forall _ : eq y None, eq match l' with | nil => None | cons x _ => Some x end (Some l)) with | eq_refl => fun H0 : eq (Some l) None => False_ind (eq match l' with | nil => None | cons x _ => Some x end (Some l)) (eq_ind (Some l) (fun e : option iT => match e with | Some _ => True | None => False end) I None H0) end eq_refl in (eq _ z) return match z with | Some t => F t | None => unit end with | eq_refl => hlist_nth@{SerTop.155} h' (Nat.sub O (S (length ls))) end end eq_refl)
+++++
simpl.
-----
Theorem hlist_nth_hlist_app : forall l l' (h : hlist l) (h' : hlist l') n, hlist_nth (hlist_app h h') n = match nth_error l n as k return nth_error l n = k -> match nth_error (l ++ l') n return Type with | None => unit | Some t => F t end with | Some _ => fun pf => match cast1 _ _ _ pf in _ = z , eq_sym pf in _ = w return match w return Type with | None => unit | Some t => F t end -> match z return Type with | None => unit | Some t => F t end with | eq_refl , eq_refl => fun x => x end (hlist_nth h n) | None => fun pf => match cast2 _ _ _ pf in _ = z return match z with | Some t => F t | None => unit end with | eq_refl => hlist_nth h' (n - length l) end end eq_refl.
Proof.
induction h.
simpl.
intros.
destruct n.
simpl.

*****
h' : hlist l'
IHh : forall (h' : hlist l') (n : nat),\neq (hlist_nth@{SerTop.155} (hlist_app h h') n)\n (match\n nth_error ls n as k\n return\n (forall _ : eq (nth_error ls n) k,\n match nth_error (app ls l') n with\n | Some t => F t\n | None => unit\n end)\n with\n | Some i =>\n fun pf : eq (nth_error ls n) (Some i) =>\n match\n cast1@{Ui} ls l' n pf in (eq _ z)\n return\n (forall\n _ : match nth_error ls n with\n | Some t => F t\n | None => unit\n end, match z with\n | Some t => F t\n | None => unit\n end)\n with\n | eq_refl =>\n match\n eq_sym pf in (eq _ w)\n return\n (forall\n _ : match w with\n | Some t => F t\n | None => unit\n end, F i)\n with\n | eq_refl => fun x : F i => x\n end\n end (hlist_nth@{SerTop.159} h n)\n | None =>\n fun pf : eq (nth_error ls n) None =>\n match\n cast2@{Ui} ls l' n pf in (eq _ z)\n return match z with\n | Some t => F t\n | None => unit\n end\n with\n | eq_refl => hlist_nth@{SerTop.155} h' (Nat.sub n (length ls))\n end\n end eq_refl)
h : hlist ls
f : F l
ls : list iT
l : iT
l' : list iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
eq f f
+++++
reflexivity.
-----
Theorem hlist_nth_hlist_app : forall l l' (h : hlist l) (h' : hlist l') n, hlist_nth (hlist_app h h') n = match nth_error l n as k return nth_error l n = k -> match nth_error (l ++ l') n return Type with | None => unit | Some t => F t end with | Some _ => fun pf => match cast1 _ _ _ pf in _ = z , eq_sym pf in _ = w return match w return Type with | None => unit | Some t => F t end -> match z return Type with | None => unit | Some t => F t end with | eq_refl , eq_refl => fun x => x end (hlist_nth h n) | None => fun pf => match cast2 _ _ _ pf in _ = z return match z with | Some t => F t | None => unit end with | eq_refl => hlist_nth h' (n - length l) end end eq_refl.
Proof.
induction h.
simpl.
intros.
destruct n.

*****
n : nat
h' : hlist l'
IHh : forall (h' : hlist l') (n : nat),\neq (hlist_nth@{SerTop.155} (hlist_app h h') n)\n (match\n nth_error ls n as k\n return\n (forall _ : eq (nth_error ls n) k,\n match nth_error (app ls l') n with\n | Some t => F t\n | None => unit\n end)\n with\n | Some i =>\n fun pf : eq (nth_error ls n) (Some i) =>\n match\n cast1@{Ui} ls l' n pf in (eq _ z)\n return\n (forall\n _ : match nth_error ls n with\n | Some t => F t\n | None => unit\n end, match z with\n | Some t => F t\n | None => unit\n end)\n with\n | eq_refl =>\n match\n eq_sym pf in (eq _ w)\n return\n (forall\n _ : match w with\n | Some t => F t\n | None => unit\n end, F i)\n with\n | eq_refl => fun x : F i => x\n end\n end (hlist_nth@{SerTop.159} h n)\n | None =>\n fun pf : eq (nth_error ls n) None =>\n match\n cast2@{Ui} ls l' n pf in (eq _ z)\n return match z with\n | Some t => F t\n | None => unit\n end\n with\n | eq_refl => hlist_nth@{SerTop.155} h' (Nat.sub n (length ls))\n end\n end eq_refl)
h : hlist ls
f : F l
ls : list iT
l : iT
l' : list iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
eq (hlist_nth@{SerTop.155} (hlist_app h h') n) (match nth_error (cons l ls) (S n) as k return (forall _ : eq (nth_error (cons l ls) (S n)) k, match nth_error (cons l (app ls l')) (S n) with | Some t => F t | None => unit end) with | Some i => fun pf : eq (nth_error (cons l ls) (S n)) (Some i) => match cast1@{Ui} ls l' n pf in (eq _ z) return (forall _ : match nth_error (cons l ls) (S n) with | Some t => F t | None => unit end, match z with | Some t => F t | None => unit end) with | eq_refl => match eq_sym pf in (eq _ w) return (forall _ : match w with | Some t => F t | None => unit end, F i) with | eq_refl => fun x : F i => x end end (hlist_nth@{SerTop.159} h n) | None => fun pf : eq (nth_error (cons l ls) (S n)) None => match cast2@{Ui} ls l' n pf in (eq _ z) return match z with | Some t => F t | None => unit end with | eq_refl => hlist_nth@{SerTop.155} h' (Nat.sub (S n) (S (length ls))) end end eq_refl)
+++++
simpl.
-----
Theorem hlist_nth_hlist_app : forall l l' (h : hlist l) (h' : hlist l') n, hlist_nth (hlist_app h h') n = match nth_error l n as k return nth_error l n = k -> match nth_error (l ++ l') n return Type with | None => unit | Some t => F t end with | Some _ => fun pf => match cast1 _ _ _ pf in _ = z , eq_sym pf in _ = w return match w return Type with | None => unit | Some t => F t end -> match z return Type with | None => unit | Some t => F t end with | eq_refl , eq_refl => fun x => x end (hlist_nth h n) | None => fun pf => match cast2 _ _ _ pf in _ = z return match z with | Some t => F t | None => unit end with | eq_refl => hlist_nth h' (n - length l) end end eq_refl.
Proof.
induction h.
simpl.
intros.
destruct n.
simpl.

*****
n : nat
h' : hlist l'
IHh : forall (h' : hlist l') (n : nat),\neq (hlist_nth@{SerTop.155} (hlist_app h h') n)\n (match\n nth_error ls n as k\n return\n (forall _ : eq (nth_error ls n) k,\n match nth_error (app ls l') n with\n | Some t => F t\n | None => unit\n end)\n with\n | Some i =>\n fun pf : eq (nth_error ls n) (Some i) =>\n match\n cast1@{Ui} ls l' n pf in (eq _ z)\n return\n (forall\n _ : match nth_error ls n with\n | Some t => F t\n | None => unit\n end, match z with\n | Some t => F t\n | None => unit\n end)\n with\n | eq_refl =>\n match\n eq_sym pf in (eq _ w)\n return\n (forall\n _ : match w with\n | Some t => F t\n | None => unit\n end, F i)\n with\n | eq_refl => fun x : F i => x\n end\n end (hlist_nth@{SerTop.159} h n)\n | None =>\n fun pf : eq (nth_error ls n) None =>\n match\n cast2@{Ui} ls l' n pf in (eq _ z)\n return match z with\n | Some t => F t\n | None => unit\n end\n with\n | eq_refl => hlist_nth@{SerTop.155} h' (Nat.sub n (length ls))\n end\n end eq_refl)
h : hlist ls
f : F l
ls : list iT
l : iT
l' : list iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
eq (hlist_nth@{SerTop.155} (hlist_app h h') n) (match nth_error ls n as k return (forall _ : eq (nth_error ls n) k, match nth_error (app ls l') n with | Some t => F t | None => unit end) with | Some i => fun pf : eq (nth_error ls n) (Some i) => match cast1@{Ui} ls l' n pf in (eq _ z) return (forall _ : match nth_error ls n with | Some t => F t | None => unit end, match z with | Some t => F t | None => unit end) with | eq_refl => match eq_sym pf in (eq _ w) return (forall _ : match w with | Some t => F t | None => unit end, F i) with | eq_refl => fun x : F i => x end end (hlist_nth@{SerTop.159} h n) | None => fun pf : eq (nth_error ls n) None => match cast2@{Ui} ls l' n pf in (eq _ z) return match z with | Some t => F t | None => unit end with | eq_refl => hlist_nth@{SerTop.155} h' (Nat.sub n (length ls)) end end eq_refl)
+++++
rewrite IHh.
-----
Theorem hlist_nth_hlist_app : forall l l' (h : hlist l) (h' : hlist l') n, hlist_nth (hlist_app h h') n = match nth_error l n as k return nth_error l n = k -> match nth_error (l ++ l') n return Type with | None => unit | Some t => F t end with | Some _ => fun pf => match cast1 _ _ _ pf in _ = z , eq_sym pf in _ = w return match w return Type with | None => unit | Some t => F t end -> match z return Type with | None => unit | Some t => F t end with | eq_refl , eq_refl => fun x => x end (hlist_nth h n) | None => fun pf => match cast2 _ _ _ pf in _ = z return match z with | Some t => F t | None => unit end with | eq_refl => hlist_nth h' (n - length l) end end eq_refl.
Proof.
induction h.
simpl.
intros.
destruct n.
simpl.
rewrite IHh.

*****
n : nat
h' : hlist l'
IHh : forall (h' : hlist l') (n : nat),\neq (hlist_nth@{SerTop.155} (hlist_app h h') n)\n (match\n nth_error ls n as k\n return\n (forall _ : eq (nth_error ls n) k,\n match nth_error (app ls l') n with\n | Some t => F t\n | None => unit\n end)\n with\n | Some i =>\n fun pf : eq (nth_error ls n) (Some i) =>\n match\n cast1@{Ui} ls l' n pf in (eq _ z)\n return\n (forall\n _ : match nth_error ls n with\n | Some t => F t\n | None => unit\n end, match z with\n | Some t => F t\n | None => unit\n end)\n with\n | eq_refl =>\n match\n eq_sym pf in (eq _ w)\n return\n (forall\n _ : match w with\n | Some t => F t\n | None => unit\n end, F i)\n with\n | eq_refl => fun x : F i => x\n end\n end (hlist_nth@{SerTop.159} h n)\n | None =>\n fun pf : eq (nth_error ls n) None =>\n match\n cast2@{Ui} ls l' n pf in (eq _ z)\n return match z with\n | Some t => F t\n | None => unit\n end\n with\n | eq_refl => hlist_nth@{SerTop.155} h' (Nat.sub n (length ls))\n end\n end eq_refl)
h : hlist ls
f : F l
ls : list iT
l : iT
l' : list iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
eq (match nth_error ls n as k return (forall _ : eq (nth_error ls n) k, match nth_error (app ls l') n with | Some t => F t | None => unit end) with | Some i => fun pf : eq (nth_error ls n) (Some i) => match cast1@{Ui} ls l' n pf in (eq _ z) return (forall _ : match nth_error ls n with | Some t => F t | None => unit end, match z with | Some t => F t | None => unit end) with | eq_refl => match eq_sym pf in (eq _ w) return (forall _ : match w with | Some t => F t | None => unit end, F i) with | eq_refl => fun x : F i => x end end (hlist_nth@{SerTop.159} h n) | None => fun pf : eq (nth_error ls n) None => match cast2@{Ui} ls l' n pf in (eq _ z) return match z with | Some t => F t | None => unit end with | eq_refl => hlist_nth@{SerTop.155} h' (Nat.sub n (length ls)) end end eq_refl) (match nth_error ls n as k return (forall _ : eq (nth_error ls n) k, match nth_error (app ls l') n with | Some t => F t | None => unit end) with | Some i => fun pf : eq (nth_error ls n) (Some i) => match cast1@{Ui} ls l' n pf in (eq _ z) return (forall _ : match nth_error ls n with | Some t => F t | None => unit end, match z with | Some t => F t | None => unit end) with | eq_refl => match eq_sym pf in (eq _ w) return (forall _ : match w with | Some t => F t | None => unit end, F i) with | eq_refl => fun x : F i => x end end (hlist_nth@{SerTop.159} h n) | None => fun pf : eq (nth_error ls n) None => match cast2@{Ui} ls l' n pf in (eq _ z) return match z with | Some t => F t | None => unit end with | eq_refl => hlist_nth@{SerTop.155} h' (Nat.sub n (length ls)) end end eq_refl)
+++++
reflexivity.
-----
Theorem hlist_nth_hlist_app : forall l l' (h : hlist l) (h' : hlist l') n, hlist_nth (hlist_app h h') n = match nth_error l n as k return nth_error l n = k -> match nth_error (l ++ l') n return Type with | None => unit | Some t => F t end with | Some _ => fun pf => match cast1 _ _ _ pf in _ = z , eq_sym pf in _ = w return match w return Type with | None => unit | Some t => F t end -> match z return Type with | None => unit | Some t => F t end with | eq_refl , eq_refl => fun x => x end (hlist_nth h n) | None => fun pf => match cast2 _ _ _ pf in _ = z return match z with | Some t => F t | None => unit end with | eq_refl => hlist_nth h' (n - length l) end end eq_refl.
Proof.
induction h.

*****

*****

+++++
Qed.
-----
Section type.
-----
Variable eqv : forall x, type (F x).
-----
Global Instance type_hlist (ls : list iT): type (hlist ls) :=\n    { equal := @equiv_hlist (fun x => @equal _ (eqv x)) ls\n    ; proper :=\n      (fix recur ls (h : hlist ls) : Prop :=\n        match h with\n          | Hnil => True\n          | Hcons _ _ x y => proper x /\ recur _ y\n        end) ls\n    }.
-----
Variable eqvOk : forall x, typeOk (eqv x).
-----
Global Instance typeOk_hlist (ls : list iT): typeOk (type_hlist ls).
-----
Global Instance typeOk_hlist (ls : list iT): typeOk (type_hlist ls).

*****
ls : list iT
eqvOk : forall x : iT, typeOk@{Uv} (eqv x)
eqv : forall x : iT, type@{Uv} (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
typeOk@{SerTop.178} (type_hlist@{SerTop.178} ls)
+++++
Proof.
-----
Global Instance typeOk_hlist (ls : list iT): typeOk (type_hlist ls).
Proof.

*****
ls : list iT
eqvOk : forall x : iT, typeOk@{Uv} (eqv x)
eqv : forall x : iT, type@{Uv} (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
typeOk@{SerTop.178} (type_hlist@{SerTop.178} ls)
+++++
constructor.
-----
Global Instance typeOk_hlist (ls : list iT): typeOk (type_hlist ls).
Proof.
constructor.

*****
ls : list iT
eqvOk : forall x : iT, typeOk@{Uv} (eqv x)
eqv : forall x : iT, type@{Uv} (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall (x y : hlist ls) (_ : equal@{SerTop.178} x y), and (proper@{SerTop.178} x) (proper@{SerTop.178} y)
+++++
induction ls.
-----
Global Instance typeOk_hlist (ls : list iT): typeOk (type_hlist ls).
Proof.
constructor.
induction ls.

*****
eqvOk : forall x : iT, typeOk@{Uv} (eqv x)
eqv : forall x : iT, type@{Uv} (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall (x y : hlist nil) (_ : equal@{SerTop.178} x y), and (proper@{SerTop.178} x) (proper@{SerTop.178} y)
+++++
intros.
-----
Global Instance typeOk_hlist (ls : list iT): typeOk (type_hlist ls).
Proof.
constructor.
induction ls.
intros.

*****
H : equal@{SerTop.178} x y
x,y : hlist nil
eqvOk : forall x : iT, typeOk@{Uv} (eqv x)
eqv : forall x : iT, type@{Uv} (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
and (proper@{SerTop.178} x) (proper@{SerTop.178} y)
+++++
rewrite (hlist_eta x) in *.
-----
Global Instance typeOk_hlist (ls : list iT): typeOk (type_hlist ls).
Proof.
constructor.
induction ls.
intros.
rewrite (hlist_eta x) in *.

*****
H : equal@{SerTop.178} Hnil y
x,y : hlist nil
eqvOk : forall x : iT, typeOk@{Uv} (eqv x)
eqv : forall x : iT, type@{Uv} (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
and (proper@{SerTop.178} Hnil) (proper@{SerTop.178} y)
+++++
rewrite (hlist_eta y) in *.
-----
Global Instance typeOk_hlist (ls : list iT): typeOk (type_hlist ls).
Proof.
constructor.
induction ls.
intros.
rewrite (hlist_eta x) in *.
rewrite (hlist_eta y) in *.

*****
H : equal@{SerTop.178} Hnil Hnil
x,y : hlist nil
eqvOk : forall x : iT, typeOk@{Uv} (eqv x)
eqv : forall x : iT, type@{Uv} (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
and (proper@{SerTop.178} Hnil) (proper@{SerTop.178} Hnil)
+++++
clear.
-----
Global Instance typeOk_hlist (ls : list iT): typeOk (type_hlist ls).
Proof.
constructor.
induction ls.
intros.
rewrite (hlist_eta x) in *.
rewrite (hlist_eta y) in *.
clear.

*****
eqv : forall x : iT, type@{Uv} (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
and (proper@{SerTop.178} Hnil) (proper@{SerTop.178} Hnil)
+++++
compute.
-----
Global Instance typeOk_hlist (ls : list iT): typeOk (type_hlist ls).
Proof.
constructor.
induction ls.
intros.
rewrite (hlist_eta x) in *.
rewrite (hlist_eta y) in *.
clear.
compute.

*****
eqv : forall x : iT, type@{Uv} (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
and True True
+++++
auto.
-----
Global Instance typeOk_hlist (ls : list iT): typeOk (type_hlist ls).
Proof.
constructor.
induction ls.

*****
IHls : forall (x y : hlist ls) (_ : equal@{SerTop.178} x y),\nand (proper@{SerTop.178} x) (proper@{SerTop.178} y)
ls : list iT
a : iT
eqvOk : forall x : iT, typeOk@{Uv} (eqv x)
eqv : forall x : iT, type@{Uv} (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall (x y : hlist (cons a ls)) (_ : equal@{SerTop.178} x y), and (proper@{SerTop.178} x) (proper@{SerTop.178} y)
+++++
intros.
-----
Global Instance typeOk_hlist (ls : list iT): typeOk (type_hlist ls).
Proof.
constructor.
induction ls.
intros.

*****
H : equal@{SerTop.178} x y
x,y : hlist (cons a ls)
IHls : forall (x y : hlist ls) (_ : equal@{SerTop.178} x y),\nand (proper@{SerTop.178} x) (proper@{SerTop.178} y)
ls : list iT
a : iT
eqvOk : forall x : iT, typeOk@{Uv} (eqv x)
eqv : forall x : iT, type@{Uv} (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
and (proper@{SerTop.178} x) (proper@{SerTop.178} y)
+++++
rewrite (hlist_eta x) in *.
-----
Global Instance typeOk_hlist (ls : list iT): typeOk (type_hlist ls).
Proof.
constructor.
induction ls.
intros.
rewrite (hlist_eta x) in *.

*****
H : equal@{SerTop.178} (Hcons (hlist_hd x) (hlist_tl x)) y
x,y : hlist (cons a ls)
IHls : forall (x y : hlist ls) (_ : equal@{SerTop.178} x y),\nand (proper@{SerTop.178} x) (proper@{SerTop.178} y)
ls : list iT
a : iT
eqvOk : forall x : iT, typeOk@{Uv} (eqv x)
eqv : forall x : iT, type@{Uv} (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
and (proper@{SerTop.178} (Hcons (hlist_hd x) (hlist_tl x))) (proper@{SerTop.178} y)
+++++
rewrite (hlist_eta y) in *.
-----
Global Instance typeOk_hlist (ls : list iT): typeOk (type_hlist ls).
Proof.
constructor.
induction ls.
intros.
rewrite (hlist_eta x) in *.
rewrite (hlist_eta y) in *.

*****
H : equal@{SerTop.178} (Hcons (hlist_hd x) (hlist_tl x))\n (Hcons (hlist_hd y) (hlist_tl y))
x,y : hlist (cons a ls)
IHls : forall (x y : hlist ls) (_ : equal@{SerTop.178} x y),\nand (proper@{SerTop.178} x) (proper@{SerTop.178} y)
ls : list iT
a : iT
eqvOk : forall x : iT, typeOk@{Uv} (eqv x)
eqv : forall x : iT, type@{Uv} (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
and (proper@{SerTop.178} (Hcons (hlist_hd x) (hlist_tl x))) (proper@{SerTop.178} (Hcons (hlist_hd y) (hlist_tl y)))
+++++
simpl in H.
-----
Global Instance typeOk_hlist (ls : list iT): typeOk (type_hlist ls).
Proof.
constructor.
induction ls.
intros.
rewrite (hlist_eta x) in *.
rewrite (hlist_eta y) in *.
simpl in H.

*****
H : equiv_hlist (fun x : iT => equal@{Uv})\n (Hcons (hlist_hd x) (hlist_tl x)) (Hcons (hlist_hd y) (hlist_tl y))
x,y : hlist (cons a ls)
IHls : forall (x y : hlist ls) (_ : equal@{SerTop.178} x y),\nand (proper@{SerTop.178} x) (proper@{SerTop.178} y)
ls : list iT
a : iT
eqvOk : forall x : iT, typeOk@{Uv} (eqv x)
eqv : forall x : iT, type@{Uv} (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
and (proper@{SerTop.178} (Hcons (hlist_hd x) (hlist_tl x))) (proper@{SerTop.178} (Hcons (hlist_hd y) (hlist_tl y)))
+++++
inv_all.
-----
Global Instance typeOk_hlist (ls : list iT): typeOk (type_hlist ls).
Proof.
constructor.
induction ls.
intros.
rewrite (hlist_eta x) in *.
rewrite (hlist_eta y) in *.
simpl in H.
inv_all.

*****
H1 : equiv_hlist (fun x : iT => equal@{Uv}) (hlist_tl x) (hlist_tl y)
H0 : equal@{Uv} (hlist_hd x) (hlist_hd y)
x,y : hlist (cons a ls)
IHls : forall (x y : hlist ls) (_ : equal@{SerTop.178} x y),\nand (proper@{SerTop.178} x) (proper@{SerTop.178} y)
ls : list iT
a : iT
eqvOk : forall x : iT, typeOk@{Uv} (eqv x)
eqv : forall x : iT, type@{Uv} (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
and (proper@{SerTop.178} (Hcons (hlist_hd x) (hlist_tl x))) (proper@{SerTop.178} (Hcons (hlist_hd y) (hlist_tl y)))
+++++
eapply IHls in H1.
-----
Global Instance typeOk_hlist (ls : list iT): typeOk (type_hlist ls).
Proof.
constructor.
induction ls.
intros.
rewrite (hlist_eta x) in *.
rewrite (hlist_eta y) in *.
simpl in H.
inv_all.
eapply IHls in H1.

*****
H1 : and (proper@{SerTop.178} (hlist_tl x))\n (proper@{SerTop.178} (hlist_tl y))
H0 : equal@{Uv} (hlist_hd x) (hlist_hd y)
x,y : hlist (cons a ls)
IHls : forall (x y : hlist ls) (_ : equal@{SerTop.178} x y),\nand (proper@{SerTop.178} x) (proper@{SerTop.178} y)
ls : list iT
a : iT
eqvOk : forall x : iT, typeOk@{Uv} (eqv x)
eqv : forall x : iT, type@{Uv} (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
and (proper@{SerTop.178} (Hcons (hlist_hd x) (hlist_tl x))) (proper@{SerTop.178} (Hcons (hlist_hd y) (hlist_tl y)))
+++++
eapply only_proper in H0.
-----
Global Instance typeOk_hlist (ls : list iT): typeOk (type_hlist ls).
Proof.
constructor.
induction ls.
intros.
rewrite (hlist_eta x) in *.
rewrite (hlist_eta y) in *.
simpl in H.
inv_all.
eapply IHls in H1.
eapply only_proper in H0.

*****
H1 : and (proper@{SerTop.178} (hlist_tl x))\n (proper@{SerTop.178} (hlist_tl y))
H0 : and (proper@{Uv} (hlist_hd x)) (proper@{Uv} (hlist_hd y))
x,y : hlist (cons a ls)
IHls : forall (x y : hlist ls) (_ : equal@{SerTop.178} x y),\nand (proper@{SerTop.178} x) (proper@{SerTop.178} y)
ls : list iT
a : iT
eqvOk : forall x : iT, typeOk@{Uv} (eqv x)
eqv : forall x : iT, type@{Uv} (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
and (proper@{SerTop.178} (Hcons (hlist_hd x) (hlist_tl x))) (proper@{SerTop.178} (Hcons (hlist_hd y) (hlist_tl y)))
+++++
eauto.
-----
Global Instance typeOk_hlist (ls : list iT): typeOk (type_hlist ls).
Proof.
constructor.
induction ls.
intros.
rewrite (hlist_eta x) in *.
rewrite (hlist_eta y) in *.
simpl in H.
inv_all.
eapply IHls in H1.
eapply only_proper in H0.
eauto.

*****
H1 : and (proper@{SerTop.178} (hlist_tl x))\n (proper@{SerTop.178} (hlist_tl y))
H0 : and (proper@{Uv} (hlist_hd x)) (proper@{Uv} (hlist_hd y))
x,y : hlist (cons a ls)
IHls : forall (x y : hlist ls) (_ : equal@{SerTop.178} x y),\nand (proper@{SerTop.178} x) (proper@{SerTop.178} y)
ls : list iT
a : iT
eqvOk : forall x : iT, typeOk@{Uv} (eqv x)
eqv : forall x : iT, type@{Uv} (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
and (proper@{SerTop.178} (Hcons (hlist_hd x) (hlist_tl x))) (proper@{SerTop.178} (Hcons (hlist_hd y) (hlist_tl y)))
+++++
simpl.
-----
Global Instance typeOk_hlist (ls : list iT): typeOk (type_hlist ls).
Proof.
constructor.
induction ls.
intros.
rewrite (hlist_eta x) in *.
rewrite (hlist_eta y) in *.
simpl in H.
inv_all.
eapply IHls in H1.
eapply only_proper in H0.
eauto.
simpl.

*****
H1 : and (proper@{SerTop.178} (hlist_tl x))\n (proper@{SerTop.178} (hlist_tl y))
H0 : and (proper@{Uv} (hlist_hd x)) (proper@{Uv} (hlist_hd y))
x,y : hlist (cons a ls)
IHls : forall (x y : hlist ls) (_ : equal@{SerTop.178} x y),\nand (proper@{SerTop.178} x) (proper@{SerTop.178} y)
ls : list iT
a : iT
eqvOk : forall x : iT, typeOk@{Uv} (eqv x)
eqv : forall x : iT, type@{Uv} (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
and (and (proper@{Uv} (hlist_hd x)) ((fix recur (ls : list iT) (h : hlist ls) {struct h} : Prop := match h with | Hnil => True | @Hcons l ls0 x y => and (proper@{Uv} x) (recur ls0 y) end) ls (hlist_tl x))) (and (proper@{Uv} (hlist_hd y)) ((fix recur (ls : list iT) (h : hlist ls) {struct h} : Prop := match h with | Hnil => True | @Hcons l ls0 x y => and (proper@{Uv} x) (recur ls0 y) end) ls (hlist_tl y)))
+++++
tauto.
-----
Global Instance typeOk_hlist (ls : list iT): typeOk (type_hlist ls).
Proof.
constructor.
induction ls.
intros.
rewrite (hlist_eta x) in *.
rewrite (hlist_eta y) in *.
simpl in H.
inv_all.
eapply IHls in H1.
eapply only_proper in H0.

*****
H1 : and (proper@{SerTop.178} (hlist_tl x))\n (proper@{SerTop.178} (hlist_tl y))
H0 : equal@{Uv} (hlist_hd x) (hlist_hd y)
x,y : hlist (cons a ls)
IHls : forall (x y : hlist ls) (_ : equal@{SerTop.178} x y),\nand (proper@{SerTop.178} x) (proper@{SerTop.178} y)
ls : list iT
a : iT
eqvOk : forall x : iT, typeOk@{Uv} (eqv x)
eqv : forall x : iT, type@{Uv} (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
typeOk@{Uv} (eqv a)
+++++
eauto.
-----
Global Instance typeOk_hlist (ls : list iT): typeOk (type_hlist ls).
Proof.
constructor.

*****
ls : list iT
eqvOk : forall x : iT, typeOk@{Uv} (eqv x)
eqv : forall x : iT, type@{Uv} (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
PReflexive proper@{SerTop.178} equal@{SerTop.178}
+++++
intro.
-----
Global Instance typeOk_hlist (ls : list iT): typeOk (type_hlist ls).
Proof.
constructor.
intro.

*****
x : hlist ls
ls : list iT
eqvOk : forall x : iT, typeOk@{Uv} (eqv x)
eqv : forall x : iT, type@{Uv} (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall _ : proper@{SerTop.178} x, equal@{SerTop.178} x x
+++++
induction ls.
-----
Global Instance typeOk_hlist (ls : list iT): typeOk (type_hlist ls).
Proof.
constructor.
intro.
induction ls.

*****
x : hlist nil
eqvOk : forall x : iT, typeOk@{Uv} (eqv x)
eqv : forall x : iT, type@{Uv} (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall _ : proper@{SerTop.178} x, equal@{SerTop.178} x x
+++++
simpl.
-----
Global Instance typeOk_hlist (ls : list iT): typeOk (type_hlist ls).
Proof.
constructor.
intro.
induction ls.
simpl.

*****
x : hlist nil
eqvOk : forall x : iT, typeOk@{Uv} (eqv x)
eqv : forall x : iT, type@{Uv} (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall _ : (fix recur (ls : list iT) (h : hlist ls) {struct h} : Prop := match h with | Hnil => True | @Hcons l ls0 x y => and (proper@{Uv} x) (recur ls0 y) end) nil x, equiv_hlist (fun x : iT => equal@{Uv}) x x
+++++
rewrite (hlist_eta x).
-----
Global Instance typeOk_hlist (ls : list iT): typeOk (type_hlist ls).
Proof.
constructor.
intro.
induction ls.
simpl.
rewrite (hlist_eta x).

*****
x : hlist nil
eqvOk : forall x : iT, typeOk@{Uv} (eqv x)
eqv : forall x : iT, type@{Uv} (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall _ : True, equiv_hlist (fun x : iT => equal@{Uv}) Hnil Hnil
+++++
intros.
-----
Global Instance typeOk_hlist (ls : list iT): typeOk (type_hlist ls).
Proof.
constructor.
intro.
induction ls.
simpl.
rewrite (hlist_eta x).
intros.

*****
H : True
x : hlist nil
eqvOk : forall x : iT, typeOk@{Uv} (eqv x)
eqv : forall x : iT, type@{Uv} (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
equiv_hlist (fun x : iT => equal@{Uv}) Hnil Hnil
+++++
constructor.
-----
Global Instance typeOk_hlist (ls : list iT): typeOk (type_hlist ls).
Proof.
constructor.
intro.
induction ls.

*****
IHls : forall (x : hlist ls) (_ : proper@{SerTop.178} x),\nequal@{SerTop.178} x x
x : hlist (cons a ls)
ls : list iT
a : iT
eqvOk : forall x : iT, typeOk@{Uv} (eqv x)
eqv : forall x : iT, type@{Uv} (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall _ : proper@{SerTop.178} x, equal@{SerTop.178} x x
+++++
simpl.
-----
Global Instance typeOk_hlist (ls : list iT): typeOk (type_hlist ls).
Proof.
constructor.
intro.
induction ls.
simpl.

*****
IHls : forall (x : hlist ls) (_ : proper@{SerTop.178} x),\nequal@{SerTop.178} x x
x : hlist (cons a ls)
ls : list iT
a : iT
eqvOk : forall x : iT, typeOk@{Uv} (eqv x)
eqv : forall x : iT, type@{Uv} (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall _ : (fix recur (ls : list iT) (h : hlist ls) {struct h} : Prop := match h with | Hnil => True | @Hcons l ls0 x y => and (proper@{Uv} x) (recur ls0 y) end) (cons a ls) x, equiv_hlist (fun x : iT => equal@{Uv}) x x
+++++
rewrite (hlist_eta x).
-----
Global Instance typeOk_hlist (ls : list iT): typeOk (type_hlist ls).
Proof.
constructor.
intro.
induction ls.
simpl.
rewrite (hlist_eta x).

*****
IHls : forall (x : hlist ls) (_ : proper@{SerTop.178} x),\nequal@{SerTop.178} x x
x : hlist (cons a ls)
ls : list iT
a : iT
eqvOk : forall x : iT, typeOk@{Uv} (eqv x)
eqv : forall x : iT, type@{Uv} (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall _ : and (proper@{Uv} (hlist_hd x)) ((fix recur (ls : list iT) (h : hlist ls) {struct h} : Prop := match h with | Hnil => True | @Hcons l ls0 x y => and (proper@{Uv} x) (recur ls0 y) end) ls (hlist_tl x)), equiv_hlist (fun x : iT => equal@{Uv}) (Hcons (hlist_hd x) (hlist_tl x)) (Hcons (hlist_hd x) (hlist_tl x))
+++++
intros.
-----
Global Instance typeOk_hlist (ls : list iT): typeOk (type_hlist ls).
Proof.
constructor.
intro.
induction ls.
simpl.
rewrite (hlist_eta x).
intros.

*****
H : and (proper@{Uv} (hlist_hd x))\n ((fix recur (ls : list iT) (h : hlist ls) {struct h} : Prop :=\n match h with\n | Hnil => True\n | @Hcons l ls0 x y => and (proper@{Uv} x) (recur ls0 y)\n end) ls (hlist_tl x))
IHls : forall (x : hlist ls) (_ : proper@{SerTop.178} x),\nequal@{SerTop.178} x x
x : hlist (cons a ls)
ls : list iT
a : iT
eqvOk : forall x : iT, typeOk@{Uv} (eqv x)
eqv : forall x : iT, type@{Uv} (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
equiv_hlist (fun x : iT => equal@{Uv}) (Hcons (hlist_hd x) (hlist_tl x)) (Hcons (hlist_hd x) (hlist_tl x))
+++++
intuition.
-----
Global Instance typeOk_hlist (ls : list iT): typeOk (type_hlist ls).
Proof.
constructor.
intro.
induction ls.
simpl.
rewrite (hlist_eta x).
intros.
intuition.

*****
H1 : (fix recur (ls : list iT) (h : hlist ls) {struct h} : Prop :=\n match h with\n | Hnil => True\n | @Hcons l ls0 x y => and (proper@{Uv} x) (recur ls0 y)\n end) ls (hlist_tl x)
H0 : proper@{Uv} (hlist_hd x)
IHls : forall (x : hlist ls) (_ : proper@{SerTop.178} x),\nequal@{SerTop.178} x x
x : hlist (cons a ls)
ls : list iT
a : iT
eqvOk : forall x : iT, typeOk@{Uv} (eqv x)
eqv : forall x : iT, type@{Uv} (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
equiv_hlist (fun x : iT => equal@{Uv}) (Hcons (hlist_hd x) (hlist_tl x)) (Hcons (hlist_hd x) (hlist_tl x))
+++++
constructor.
-----
Global Instance typeOk_hlist (ls : list iT): typeOk (type_hlist ls).
Proof.
constructor.
intro.
induction ls.
simpl.
rewrite (hlist_eta x).
intros.
intuition.
constructor.

*****
H1 : (fix recur (ls : list iT) (h : hlist ls) {struct h} : Prop :=\n match h with\n | Hnil => True\n | @Hcons l ls0 x y => and (proper@{Uv} x) (recur ls0 y)\n end) ls (hlist_tl x)
H0 : proper@{Uv} (hlist_hd x)
IHls : forall (x : hlist ls) (_ : proper@{SerTop.178} x),\nequal@{SerTop.178} x x
x : hlist (cons a ls)
ls : list iT
a : iT
eqvOk : forall x : iT, typeOk@{Uv} (eqv x)
eqv : forall x : iT, type@{Uv} (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
equal@{Uv} (hlist_hd x) (hlist_hd x)
+++++
eapply preflexive.
-----
Global Instance typeOk_hlist (ls : list iT): typeOk (type_hlist ls).
Proof.
constructor.
intro.
induction ls.
simpl.
rewrite (hlist_eta x).
intros.
intuition.
constructor.
eapply preflexive.

*****
H1 : (fix recur (ls : list iT) (h : hlist ls) {struct h} : Prop :=\n match h with\n | Hnil => True\n | @Hcons l ls0 x y => and (proper@{Uv} x) (recur ls0 y)\n end) ls (hlist_tl x)
H0 : proper@{Uv} (hlist_hd x)
IHls : forall (x : hlist ls) (_ : proper@{SerTop.178} x),\nequal@{SerTop.178} x x
x : hlist (cons a ls)
ls : list iT
a : iT
eqvOk : forall x : iT, typeOk@{Uv} (eqv x)
eqv : forall x : iT, type@{Uv} (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
PReflexive ?wf equal@{Uv}
+++++
idtac.
-----
Global Instance typeOk_hlist (ls : list iT): typeOk (type_hlist ls).
Proof.
constructor.
intro.
induction ls.
simpl.
rewrite (hlist_eta x).
intros.
intuition.
constructor.
eapply preflexive.
idtac.

*****
H1 : (fix recur (ls : list iT) (h : hlist ls) {struct h} : Prop :=\n match h with\n | Hnil => True\n | @Hcons l ls0 x y => and (proper@{Uv} x) (recur ls0 y)\n end) ls (hlist_tl x)
H0 : proper@{Uv} (hlist_hd x)
IHls : forall (x : hlist ls) (_ : proper@{SerTop.178} x),\nequal@{SerTop.178} x x
x : hlist (cons a ls)
ls : list iT
a : iT
eqvOk : forall x : iT, typeOk@{Uv} (eqv x)
eqv : forall x : iT, type@{Uv} (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
PReflexive ?wf equal@{Uv}
+++++
eauto with typeclass_instances.
-----
Global Instance typeOk_hlist (ls : list iT): typeOk (type_hlist ls).
Proof.
constructor.
intro.
induction ls.
simpl.
rewrite (hlist_eta x).
intros.
intuition.
constructor.
eapply preflexive.

*****
H1 : (fix recur (ls : list iT) (h : hlist ls) {struct h} : Prop :=\n match h with\n | Hnil => True\n | @Hcons l ls0 x y => and (proper@{Uv} x) (recur ls0 y)\n end) ls (hlist_tl x)
H0 : proper@{Uv} (hlist_hd x)
IHls : forall (x : hlist ls) (_ : proper@{SerTop.178} x),\nequal@{SerTop.178} x x
x : hlist (cons a ls)
ls : list iT
a : iT
eqvOk : forall x : iT, typeOk@{Uv} (eqv x)
eqv : forall x : iT, type@{Uv} (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
proper@{Uv} (hlist_hd x)
+++++
eauto with typeclass_instances.
-----
Global Instance typeOk_hlist (ls : list iT): typeOk (type_hlist ls).
Proof.
constructor.
intro.
induction ls.
simpl.
rewrite (hlist_eta x).
intros.
intuition.
constructor.

*****
H1 : (fix recur (ls : list iT) (h : hlist ls) {struct h} : Prop :=\n match h with\n | Hnil => True\n | @Hcons l ls0 x y => and (proper@{Uv} x) (recur ls0 y)\n end) ls (hlist_tl x)
H0 : proper@{Uv} (hlist_hd x)
IHls : forall (x : hlist ls) (_ : proper@{SerTop.178} x),\nequal@{SerTop.178} x x
x : hlist (cons a ls)
ls : list iT
a : iT
eqvOk : forall x : iT, typeOk@{Uv} (eqv x)
eqv : forall x : iT, type@{Uv} (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
equiv_hlist (fun x : iT => equal@{Uv}) (hlist_tl x) (hlist_tl x)
+++++
eapply IHls.
-----
Global Instance typeOk_hlist (ls : list iT): typeOk (type_hlist ls).
Proof.
constructor.
intro.
induction ls.
simpl.
rewrite (hlist_eta x).
intros.
intuition.
constructor.
eapply IHls.

*****
H1 : (fix recur (ls : list iT) (h : hlist ls) {struct h} : Prop :=\n match h with\n | Hnil => True\n | @Hcons l ls0 x y => and (proper@{Uv} x) (recur ls0 y)\n end) ls (hlist_tl x)
H0 : proper@{Uv} (hlist_hd x)
IHls : forall (x : hlist ls) (_ : proper@{SerTop.178} x),\nequal@{SerTop.178} x x
x : hlist (cons a ls)
ls : list iT
a : iT
eqvOk : forall x : iT, typeOk@{Uv} (eqv x)
eqv : forall x : iT, type@{Uv} (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
proper@{SerTop.178} (hlist_tl x)
+++++
eauto.
-----
Global Instance typeOk_hlist (ls : list iT): typeOk (type_hlist ls).
Proof.
constructor.

*****
ls : list iT
eqvOk : forall x : iT, typeOk@{Uv} (eqv x)
eqv : forall x : iT, type@{Uv} (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
Symmetric equal@{SerTop.178}
+++++
red.
-----
Global Instance typeOk_hlist (ls : list iT): typeOk (type_hlist ls).
Proof.
constructor.
red.

*****
ls : list iT
eqvOk : forall x : iT, typeOk@{Uv} (eqv x)
eqv : forall x : iT, type@{Uv} (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall (x y : hlist ls) (_ : equal@{SerTop.178} x y), equal@{SerTop.178} y x
+++++
induction 1.
-----
Global Instance typeOk_hlist (ls : list iT): typeOk (type_hlist ls).
Proof.
constructor.
red.
induction 1.

*****
eqvOk : forall x : iT, typeOk@{Uv} (eqv x)
eqv : forall x : iT, type@{Uv} (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
equal@{SerTop.178} Hnil Hnil
+++++
constructor.
-----
Global Instance typeOk_hlist (ls : list iT): typeOk (type_hlist ls).
Proof.
constructor.
red.
induction 1.

*****
IHequiv_hlist : equal@{SerTop.178} h2 h1
H0 : equiv_hlist (fun x : iT => equal@{Uv}) h1 h2
H : equal@{Uv} x y
h1,h2 : hlist ls
x,y : F l
ls : list iT
l : iT
eqvOk : forall x : iT, typeOk@{Uv} (eqv x)
eqv : forall x : iT, type@{Uv} (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
equal@{SerTop.178} (Hcons y h2) (Hcons x h1)
+++++
constructor.
-----
Global Instance typeOk_hlist (ls : list iT): typeOk (type_hlist ls).
Proof.
constructor.
red.
induction 1.
constructor.

*****
IHequiv_hlist : equal@{SerTop.178} h2 h1
H0 : equiv_hlist (fun x : iT => equal@{Uv}) h1 h2
H : equal@{Uv} x y
h1,h2 : hlist ls
x,y : F l
ls : list iT
l : iT
eqvOk : forall x : iT, typeOk@{Uv} (eqv x)
eqv : forall x : iT, type@{Uv} (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
equal@{Uv} y x
+++++
symmetry.
-----
Global Instance typeOk_hlist (ls : list iT): typeOk (type_hlist ls).
Proof.
constructor.
red.
induction 1.
constructor.
symmetry.

*****
IHequiv_hlist : equal@{SerTop.178} h2 h1
H0 : equiv_hlist (fun x : iT => equal@{Uv}) h1 h2
H : equal@{Uv} x y
h1,h2 : hlist ls
x,y : F l
ls : list iT
l : iT
eqvOk : forall x : iT, typeOk@{Uv} (eqv x)
eqv : forall x : iT, type@{Uv} (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
equal@{Uv} x y
+++++
assumption.
-----
Global Instance typeOk_hlist (ls : list iT): typeOk (type_hlist ls).
Proof.
constructor.
red.
induction 1.
constructor.

*****
IHequiv_hlist : equal@{SerTop.178} h2 h1
H0 : equiv_hlist (fun x : iT => equal@{Uv}) h1 h2
H : equal@{Uv} x y
h1,h2 : hlist ls
x,y : F l
ls : list iT
l : iT
eqvOk : forall x : iT, typeOk@{Uv} (eqv x)
eqv : forall x : iT, type@{Uv} (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
equiv_hlist (fun x : iT => equal@{Uv}) h2 h1
+++++
assumption.
-----
Global Instance typeOk_hlist (ls : list iT): typeOk (type_hlist ls).
Proof.
constructor.

*****
ls : list iT
eqvOk : forall x : iT, typeOk@{Uv} (eqv x)
eqv : forall x : iT, type@{Uv} (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
Transitive equal@{SerTop.178}
+++++
red.
-----
Global Instance typeOk_hlist (ls : list iT): typeOk (type_hlist ls).
Proof.
constructor.
red.

*****
ls : list iT
eqvOk : forall x : iT, typeOk@{Uv} (eqv x)
eqv : forall x : iT, type@{Uv} (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall (x y z : hlist ls) (_ : equal@{SerTop.178} x y) (_ : equal@{SerTop.178} y z), equal@{SerTop.178} x z
+++++
induction 1.
-----
Global Instance typeOk_hlist (ls : list iT): typeOk (type_hlist ls).
Proof.
constructor.
red.
induction 1.

*****
z : hlist nil
eqvOk : forall x : iT, typeOk@{Uv} (eqv x)
eqv : forall x : iT, type@{Uv} (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall _ : equal@{SerTop.178} Hnil z, equal@{SerTop.178} Hnil z
+++++
auto.
-----
Global Instance typeOk_hlist (ls : list iT): typeOk (type_hlist ls).
Proof.
constructor.
red.
induction 1.

*****
IHequiv_hlist : forall (z : hlist ls) (_ : equal@{SerTop.178} h2 z),\nequal@{SerTop.178} h1 z
H0 : equiv_hlist (fun x : iT => equal@{Uv}) h1 h2
H : equal@{Uv} x y
h1,h2 : hlist ls
x,y : F l
z : hlist (cons l ls)
ls : list iT
l : iT
eqvOk : forall x : iT, typeOk@{Uv} (eqv x)
eqv : forall x : iT, type@{Uv} (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall _ : equal@{SerTop.178} (Hcons y h2) z, equal@{SerTop.178} (Hcons x h1) z
+++++
intro H1.
-----
Global Instance typeOk_hlist (ls : list iT): typeOk (type_hlist ls).
Proof.
constructor.
red.
induction 1.
intro H1.

*****
H1 : equal@{SerTop.178} (Hcons y h2) z
IHequiv_hlist : forall (z : hlist ls) (_ : equal@{SerTop.178} h2 z),\nequal@{SerTop.178} h1 z
H0 : equiv_hlist (fun x : iT => equal@{Uv}) h1 h2
H : equal@{Uv} x y
h1,h2 : hlist ls
x,y : F l
z : hlist (cons l ls)
ls : list iT
l : iT
eqvOk : forall x : iT, typeOk@{Uv} (eqv x)
eqv : forall x : iT, type@{Uv} (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
equal@{SerTop.178} (Hcons x h1) z
+++++
etransitivity.
-----
Global Instance typeOk_hlist (ls : list iT): typeOk (type_hlist ls).
Proof.
constructor.
red.
induction 1.
intro H1.
etransitivity.

*****
H1 : equal@{SerTop.178} (Hcons y h2) z
IHequiv_hlist : forall (z : hlist ls) (_ : equal@{SerTop.178} h2 z),\nequal@{SerTop.178} h1 z
H0 : equiv_hlist (fun x : iT => equal@{Uv}) h1 h2
H : equal@{Uv} x y
h1,h2 : hlist ls
x,y : F l
z : hlist (cons l ls)
ls : list iT
l : iT
eqvOk : forall x : iT, typeOk@{Uv} (eqv x)
eqv : forall x : iT, type@{Uv} (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
equal@{SerTop.178} (Hcons x h1) ?y
+++++
idtac.
-----
Global Instance typeOk_hlist (ls : list iT): typeOk (type_hlist ls).
Proof.
constructor.
red.
induction 1.
intro H1.
etransitivity.
idtac.

*****
H1 : equal@{SerTop.178} (Hcons y h2) z
IHequiv_hlist : forall (z : hlist ls) (_ : equal@{SerTop.178} h2 z),\nequal@{SerTop.178} h1 z
H0 : equiv_hlist (fun x : iT => equal@{Uv}) h1 h2
H : equal@{Uv} x y
h1,h2 : hlist ls
x,y : F l
z : hlist (cons l ls)
ls : list iT
l : iT
eqvOk : forall x : iT, typeOk@{Uv} (eqv x)
eqv : forall x : iT, type@{Uv} (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
equal@{SerTop.178} (Hcons x h1) ?y
+++++
constructor.
-----
Global Instance typeOk_hlist (ls : list iT): typeOk (type_hlist ls).
Proof.
constructor.
red.
induction 1.
intro H1.
etransitivity.
idtac.
constructor.

*****
H1 : equal@{SerTop.178} (Hcons y h2) z
IHequiv_hlist : forall (z : hlist ls) (_ : equal@{SerTop.178} h2 z),\nequal@{SerTop.178} h1 z
H0 : equiv_hlist (fun x : iT => equal@{Uv}) h1 h2
H : equal@{Uv} x y
h1,h2 : hlist ls
x,y : F l
z : hlist (cons l ls)
ls : list iT
l : iT
eqvOk : forall x : iT, typeOk@{Uv} (eqv x)
eqv : forall x : iT, type@{Uv} (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
equal@{Uv} x ?Goal0
+++++
eauto.
-----
Global Instance typeOk_hlist (ls : list iT): typeOk (type_hlist ls).
Proof.
constructor.
red.
induction 1.
intro H1.
etransitivity.
idtac.
constructor.

*****
H1 : equal@{SerTop.178} (Hcons y h2) z
IHequiv_hlist : forall (z : hlist ls) (_ : equal@{SerTop.178} h2 z),\nequal@{SerTop.178} h1 z
H0 : equiv_hlist (fun x : iT => equal@{Uv}) h1 h2
H : equal@{Uv} x y
h1,h2 : hlist ls
x,y : F l
z : hlist (cons l ls)
ls : list iT
l : iT
eqvOk : forall x : iT, typeOk@{Uv} (eqv x)
eqv : forall x : iT, type@{Uv} (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
equiv_hlist (fun x : iT => equal@{Uv}) h1 ?Goal1
+++++
eauto.
-----
Global Instance typeOk_hlist (ls : list iT): typeOk (type_hlist ls).
Proof.
constructor.
red.
induction 1.
intro H1.
etransitivity.

*****
H1 : equal@{SerTop.178} (Hcons y h2) z
IHequiv_hlist : forall (z : hlist ls) (_ : equal@{SerTop.178} h2 z),\nequal@{SerTop.178} h1 z
H0 : equiv_hlist (fun x : iT => equal@{Uv}) h1 h2
H : equal@{Uv} x y
h1,h2 : hlist ls
x,y : F l
z : hlist (cons l ls)
ls : list iT
l : iT
eqvOk : forall x : iT, typeOk@{Uv} (eqv x)
eqv : forall x : iT, type@{Uv} (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
equal@{SerTop.178} (Hcons y h2) z
+++++
eassumption.
-----
Global Instance typeOk_hlist (ls : list iT): typeOk (type_hlist ls).
Proof.
constructor.

*****

*****

+++++
Qed.
-----
Global Instance proper_hlist_app l l' : proper (@hlist_app l l').
-----
Global Instance proper_hlist_app l l' : proper (@hlist_app l l').

*****
l,l' : list iT
eqvOk : forall x : iT, typeOk@{Uv} (eqv x)
eqv : forall x : iT, type@{Uv} (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
proper@{SerTop.207} (hlist_app (lr:=l'))
+++++
Proof.
-----
Global Instance proper_hlist_app l l' : proper (@hlist_app l l').
Proof.

*****
l,l' : list iT
eqvOk : forall x : iT, typeOk@{Uv} (eqv x)
eqv : forall x : iT, type@{Uv} (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
proper@{SerTop.207} (hlist_app (lr:=l'))
+++++
do 6 red.
-----
Global Instance proper_hlist_app l l' : proper (@hlist_app l l').
Proof.
do 6 red.

*****
l,l' : list iT
eqvOk : forall x : iT, typeOk@{Uv} (eqv x)
eqv : forall x : iT, type@{Uv} (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall (x y : hlist l) (_ : equal@{SerTop.207} x y) (x0 y0 : hlist l') (_ : equal@{SerTop.207} x0 y0), equal@{SerTop.207} (hlist_app x x0) (hlist_app y y0)
+++++
induction 1.
-----
Global Instance proper_hlist_app l l' : proper (@hlist_app l l').
Proof.
do 6 red.
induction 1.

*****
l' : list iT
eqvOk : forall x : iT, typeOk@{Uv} (eqv x)
eqv : forall x : iT, type@{Uv} (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall (x y : hlist l') (_ : equal@{SerTop.207} x y), equal@{SerTop.207} (hlist_app Hnil x) (hlist_app Hnil y)
+++++
simpl.
-----
Global Instance proper_hlist_app l l' : proper (@hlist_app l l').
Proof.
do 6 red.
induction 1.
simpl.

*****
l' : list iT
eqvOk : forall x : iT, typeOk@{Uv} (eqv x)
eqv : forall x : iT, type@{Uv} (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall (x y : hlist l') (_ : equiv_hlist (fun x0 : iT => equal@{Uv}) x y), equiv_hlist (fun x0 : iT => equal@{Uv}) x y
+++++
auto.
-----
Global Instance proper_hlist_app l l' : proper (@hlist_app l l').
Proof.
do 6 red.
induction 1.

*****
IHequiv_hlist : forall (x y : hlist l') (_ : equal@{SerTop.207} x y),\nequal@{SerTop.207} (hlist_app h1 x) (hlist_app h2 y)
H0 : equiv_hlist (fun x : iT => equal@{Uv}) h1 h2
H : equal@{Uv} x y
h1,h2 : hlist ls
x,y : F l
ls : list iT
l : iT
l' : list iT
eqvOk : forall x : iT, typeOk@{Uv} (eqv x)
eqv : forall x : iT, type@{Uv} (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall (x0 y0 : hlist l') (_ : equal@{SerTop.207} x0 y0), equal@{SerTop.207} (hlist_app (Hcons x h1) x0) (hlist_app (Hcons y h2) y0)
+++++
simpl.
-----
Global Instance proper_hlist_app l l' : proper (@hlist_app l l').
Proof.
do 6 red.
induction 1.
simpl.

*****
IHequiv_hlist : forall (x y : hlist l') (_ : equal@{SerTop.207} x y),\nequal@{SerTop.207} (hlist_app h1 x) (hlist_app h2 y)
H0 : equiv_hlist (fun x : iT => equal@{Uv}) h1 h2
H : equal@{Uv} x y
h1,h2 : hlist ls
x,y : F l
ls : list iT
l : iT
l' : list iT
eqvOk : forall x : iT, typeOk@{Uv} (eqv x)
eqv : forall x : iT, type@{Uv} (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall (x0 y0 : hlist l') (_ : equiv_hlist (fun x : iT => equal@{Uv}) x0 y0), equiv_hlist (fun x : iT => equal@{Uv}) (Hcons x (hlist_app h1 x0)) (Hcons y (hlist_app h2 y0))
+++++
auto.
-----
Global Instance proper_hlist_app l l' : proper (@hlist_app l l').
Proof.
do 6 red.
induction 1.
simpl.
auto.

*****
IHequiv_hlist : forall (x y : hlist l') (_ : equal@{SerTop.207} x y),\nequal@{SerTop.207} (hlist_app h1 x) (hlist_app h2 y)
H0 : equiv_hlist (fun x : iT => equal@{Uv}) h1 h2
H : equal@{Uv} x y
h1,h2 : hlist ls
x,y : F l
ls : list iT
l : iT
l' : list iT
eqvOk : forall x : iT, typeOk@{Uv} (eqv x)
eqv : forall x : iT, type@{Uv} (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall (x0 y0 : hlist l') (_ : equiv_hlist (fun x : iT => equal@{Uv}) x0 y0), equiv_hlist (fun x : iT => equal@{Uv}) (Hcons x (hlist_app h1 x0)) (Hcons y (hlist_app h2 y0))
+++++
intros.
-----
Global Instance proper_hlist_app l l' : proper (@hlist_app l l').
Proof.
do 6 red.
induction 1.
simpl.
auto.
intros.

*****
H1 : equiv_hlist (fun x : iT => equal@{Uv}) x0 y0
x0,y0 : hlist l'
IHequiv_hlist : forall (x y : hlist l') (_ : equal@{SerTop.207} x y),\nequal@{SerTop.207} (hlist_app h1 x) (hlist_app h2 y)
H0 : equiv_hlist (fun x : iT => equal@{Uv}) h1 h2
H : equal@{Uv} x y
h1,h2 : hlist ls
x,y : F l
ls : list iT
l : iT
l' : list iT
eqvOk : forall x : iT, typeOk@{Uv} (eqv x)
eqv : forall x : iT, type@{Uv} (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
equiv_hlist (fun x : iT => equal@{Uv}) (Hcons x (hlist_app h1 x0)) (Hcons y (hlist_app h2 y0))
+++++
constructor.
-----
Global Instance proper_hlist_app l l' : proper (@hlist_app l l').
Proof.
do 6 red.
induction 1.
simpl.
auto.
intros.
constructor.

*****
H1 : equiv_hlist (fun x : iT => equal@{Uv}) x0 y0
x0,y0 : hlist l'
IHequiv_hlist : forall (x y : hlist l') (_ : equal@{SerTop.207} x y),\nequal@{SerTop.207} (hlist_app h1 x) (hlist_app h2 y)
H0 : equiv_hlist (fun x : iT => equal@{Uv}) h1 h2
H : equal@{Uv} x y
h1,h2 : hlist ls
x,y : F l
ls : list iT
l : iT
l' : list iT
eqvOk : forall x : iT, typeOk@{Uv} (eqv x)
eqv : forall x : iT, type@{Uv} (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
equal@{Uv} x y
+++++
eauto.
-----
Global Instance proper_hlist_app l l' : proper (@hlist_app l l').
Proof.
do 6 red.
induction 1.
simpl.
auto.
intros.
constructor.

*****
H1 : equiv_hlist (fun x : iT => equal@{Uv}) x0 y0
x0,y0 : hlist l'
IHequiv_hlist : forall (x y : hlist l') (_ : equal@{SerTop.207} x y),\nequal@{SerTop.207} (hlist_app h1 x) (hlist_app h2 y)
H0 : equiv_hlist (fun x : iT => equal@{Uv}) h1 h2
H : equal@{Uv} x y
h1,h2 : hlist ls
x,y : F l
ls : list iT
l : iT
l' : list iT
eqvOk : forall x : iT, typeOk@{Uv} (eqv x)
eqv : forall x : iT, type@{Uv} (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
equiv_hlist (fun x : iT => equal@{Uv}) (hlist_app h1 x0) (hlist_app h2 y0)
+++++
eauto.
-----
Global Instance proper_hlist_app l l' : proper (@hlist_app l l').
Proof.
do 6 red.
induction 1.
simpl.
auto.
intros.
constructor.
eauto.

*****
H1 : equiv_hlist (fun x : iT => equal@{Uv}) x0 y0
x0,y0 : hlist l'
IHequiv_hlist : forall (x y : hlist l') (_ : equal@{SerTop.207} x y),\nequal@{SerTop.207} (hlist_app h1 x) (hlist_app h2 y)
H0 : equiv_hlist (fun x : iT => equal@{Uv}) h1 h2
H : equal@{Uv} x y
h1,h2 : hlist ls
x,y : F l
ls : list iT
l : iT
l' : list iT
eqvOk : forall x : iT, typeOk@{Uv} (eqv x)
eqv : forall x : iT, type@{Uv} (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
equiv_hlist (fun x : iT => equal@{Uv}) (hlist_app h1 x0) (hlist_app h2 y0)
+++++
eapply IHequiv_hlist.
-----
Global Instance proper_hlist_app l l' : proper (@hlist_app l l').
Proof.
do 6 red.
induction 1.
simpl.
auto.
intros.
constructor.
eauto.
eapply IHequiv_hlist.

*****
H1 : equiv_hlist (fun x : iT => equal@{Uv}) x0 y0
x0,y0 : hlist l'
IHequiv_hlist : forall (x y : hlist l') (_ : equal@{SerTop.207} x y),\nequal@{SerTop.207} (hlist_app h1 x) (hlist_app h2 y)
H0 : equiv_hlist (fun x : iT => equal@{Uv}) h1 h2
H : equal@{Uv} x y
h1,h2 : hlist ls
x,y : F l
ls : list iT
l : iT
l' : list iT
eqvOk : forall x : iT, typeOk@{Uv} (eqv x)
eqv : forall x : iT, type@{Uv} (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
equal@{SerTop.207} x0 y0
+++++
exact H1.
-----
Global Instance proper_hlist_app l l' : proper (@hlist_app l l').
Proof.
do 6 red.
induction 1.

*****

*****

+++++
Qed.
-----
Lemma hlist_app_assoc : forall ls ls' ls''\n                                 (a : hlist ls) (b : hlist ls') (c : hlist ls''),\n      hlist_app (hlist_app a b) c =\n      match eq_sym (app_ass_trans ls ls' ls'') in _ = t return hlist t with\n        | eq_refl => hlist_app a (hlist_app b c)\n      end.
-----
Lemma hlist_app_assoc : forall ls ls' ls'' (a : hlist ls) (b : hlist ls') (c : hlist ls''), hlist_app (hlist_app a b) c = match eq_sym (app_ass_trans ls ls' ls'') in _ = t return hlist t with | eq_refl => hlist_app a (hlist_app b c) end.

*****
eqvOk : forall x : iT, typeOk@{Uv} (eqv x)
eqv : forall x : iT, type@{Uv} (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall (ls ls' ls'' : list iT) (a : hlist ls) (b : hlist ls') (c : hlist ls''), eq (hlist_app (hlist_app a b) c) match eq_sym (app_ass_trans@{Ui} ls ls' ls'') in (eq _ t) return (hlist t) with | eq_refl => hlist_app a (hlist_app b c) end
+++++
Proof.
-----
Lemma hlist_app_assoc : forall ls ls' ls'' (a : hlist ls) (b : hlist ls') (c : hlist ls''), hlist_app (hlist_app a b) c = match eq_sym (app_ass_trans ls ls' ls'') in _ = t return hlist t with | eq_refl => hlist_app a (hlist_app b c) end.
Proof.

*****
eqvOk : forall x : iT, typeOk@{Uv} (eqv x)
eqv : forall x : iT, type@{Uv} (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall (ls ls' ls'' : list iT) (a : hlist ls) (b : hlist ls') (c : hlist ls''), eq (hlist_app (hlist_app a b) c) match eq_sym (app_ass_trans@{Ui} ls ls' ls'') in (eq _ t) return (hlist t) with | eq_refl => hlist_app a (hlist_app b c) end
+++++
intros ls ls' ls''.
-----
Lemma hlist_app_assoc : forall ls ls' ls'' (a : hlist ls) (b : hlist ls') (c : hlist ls''), hlist_app (hlist_app a b) c = match eq_sym (app_ass_trans ls ls' ls'') in _ = t return hlist t with | eq_refl => hlist_app a (hlist_app b c) end.
Proof.
intros ls ls' ls''.

*****
ls,ls',ls'' : list iT
eqvOk : forall x : iT, typeOk@{Uv} (eqv x)
eqv : forall x : iT, type@{Uv} (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall (a : hlist ls) (b : hlist ls') (c : hlist ls''), eq (hlist_app (hlist_app a b) c) match eq_sym (app_ass_trans@{Ui} ls ls' ls'') in (eq _ t) return (hlist t) with | eq_refl => hlist_app a (hlist_app b c) end
+++++
generalize (eq_sym (app_assoc_reverse ls ls' ls'')).
-----
Lemma hlist_app_assoc : forall ls ls' ls'' (a : hlist ls) (b : hlist ls') (c : hlist ls''), hlist_app (hlist_app a b) c = match eq_sym (app_ass_trans ls ls' ls'') in _ = t return hlist t with | eq_refl => hlist_app a (hlist_app b c) end.
Proof.
intros ls ls' ls''.
generalize (eq_sym (app_assoc_reverse ls ls' ls'')).

*****
ls,ls',ls'' : list iT
eqvOk : forall x : iT, typeOk@{Uv} (eqv x)
eqv : forall x : iT, type@{Uv} (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall (_ : eq (app ls (app ls' ls'')) (app (app ls ls') ls'')) (a : hlist ls) (b : hlist ls') (c : hlist ls''), eq (hlist_app (hlist_app a b) c) match eq_sym (app_ass_trans@{Ui} ls ls' ls'') in (eq _ t) return (hlist t) with | eq_refl => hlist_app a (hlist_app b c) end
+++++
induction ls.
-----
Lemma hlist_app_assoc : forall ls ls' ls'' (a : hlist ls) (b : hlist ls') (c : hlist ls''), hlist_app (hlist_app a b) c = match eq_sym (app_ass_trans ls ls' ls'') in _ = t return hlist t with | eq_refl => hlist_app a (hlist_app b c) end.
Proof.
intros ls ls' ls''.
generalize (eq_sym (app_assoc_reverse ls ls' ls'')).
induction ls.

*****
ls',ls'' : list iT
eqvOk : forall x : iT, typeOk@{Uv} (eqv x)
eqv : forall x : iT, type@{Uv} (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall (_ : eq (app nil (app ls' ls'')) (app (app nil ls') ls'')) (a : hlist nil) (b : hlist ls') (c : hlist ls''), eq (hlist_app (hlist_app a b) c) match eq_sym (app_ass_trans@{Ui} nil ls' ls'') in (eq _ t) return (hlist t) with | eq_refl => hlist_app a (hlist_app b c) end
+++++
simpl.
-----
Lemma hlist_app_assoc : forall ls ls' ls'' (a : hlist ls) (b : hlist ls') (c : hlist ls''), hlist_app (hlist_app a b) c = match eq_sym (app_ass_trans ls ls' ls'') in _ = t return hlist t with | eq_refl => hlist_app a (hlist_app b c) end.
Proof.
intros ls ls' ls''.
generalize (eq_sym (app_assoc_reverse ls ls' ls'')).
induction ls.
simpl.

*****
ls',ls'' : list iT
eqvOk : forall x : iT, typeOk@{Uv} (eqv x)
eqv : forall x : iT, type@{Uv} (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall (_ : eq (app ls' ls'') (app ls' ls'')) (a : hlist nil) (b : hlist ls') (c : hlist ls''), eq (hlist_app (hlist_app a b) c) (hlist_app a (hlist_app b c))
+++++
intros.
-----
Lemma hlist_app_assoc : forall ls ls' ls'' (a : hlist ls) (b : hlist ls') (c : hlist ls''), hlist_app (hlist_app a b) c = match eq_sym (app_ass_trans ls ls' ls'') in _ = t return hlist t with | eq_refl => hlist_app a (hlist_app b c) end.
Proof.
intros ls ls' ls''.
generalize (eq_sym (app_assoc_reverse ls ls' ls'')).
induction ls.
simpl.
intros.

*****
c : hlist ls''
b : hlist ls'
a : hlist nil
H : eq (app ls' ls'') (app ls' ls'')
ls',ls'' : list iT
eqvOk : forall x : iT, typeOk@{Uv} (eqv x)
eqv : forall x : iT, type@{Uv} (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
eq (hlist_app (hlist_app a b) c) (hlist_app a (hlist_app b c))
+++++
rewrite (hlist_eta a).
-----
Lemma hlist_app_assoc : forall ls ls' ls'' (a : hlist ls) (b : hlist ls') (c : hlist ls''), hlist_app (hlist_app a b) c = match eq_sym (app_ass_trans ls ls' ls'') in _ = t return hlist t with | eq_refl => hlist_app a (hlist_app b c) end.
Proof.
intros ls ls' ls''.
generalize (eq_sym (app_assoc_reverse ls ls' ls'')).
induction ls.
simpl.
intros.
rewrite (hlist_eta a).

*****
c : hlist ls''
b : hlist ls'
a : hlist nil
H : eq (app ls' ls'') (app ls' ls'')
ls',ls'' : list iT
eqvOk : forall x : iT, typeOk@{Uv} (eqv x)
eqv : forall x : iT, type@{Uv} (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
eq (hlist_app (hlist_app Hnil b) c) (hlist_app Hnil (hlist_app b c))
+++++
simpl.
-----
Lemma hlist_app_assoc : forall ls ls' ls'' (a : hlist ls) (b : hlist ls') (c : hlist ls''), hlist_app (hlist_app a b) c = match eq_sym (app_ass_trans ls ls' ls'') in _ = t return hlist t with | eq_refl => hlist_app a (hlist_app b c) end.
Proof.
intros ls ls' ls''.
generalize (eq_sym (app_assoc_reverse ls ls' ls'')).
induction ls.
simpl.
intros.
rewrite (hlist_eta a).
simpl.

*****
c : hlist ls''
b : hlist ls'
a : hlist nil
H : eq (app ls' ls'') (app ls' ls'')
ls',ls'' : list iT
eqvOk : forall x : iT, typeOk@{Uv} (eqv x)
eqv : forall x : iT, type@{Uv} (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
eq (hlist_app b c) (hlist_app b c)
+++++
reflexivity.
-----
Lemma hlist_app_assoc : forall ls ls' ls'' (a : hlist ls) (b : hlist ls') (c : hlist ls''), hlist_app (hlist_app a b) c = match eq_sym (app_ass_trans ls ls' ls'') in _ = t return hlist t with | eq_refl => hlist_app a (hlist_app b c) end.
Proof.
intros ls ls' ls''.
generalize (eq_sym (app_assoc_reverse ls ls' ls'')).
induction ls.

*****
IHls : forall (_ : eq (app ls (app ls' ls'')) (app (app ls ls') ls''))\n (a : hlist ls) (b : hlist ls') (c : hlist ls''),\neq (hlist_app (hlist_app a b) c)\n match\n eq_sym (app_ass_trans@{Ui} ls ls' ls'') in (eq _ t)\n return (hlist t)\n with\n | eq_refl => hlist_app a (hlist_app b c)\n end
ls,ls',ls'' : list iT
a : iT
eqvOk : forall x : iT, typeOk@{Uv} (eqv x)
eqv : forall x : iT, type@{Uv} (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall (_ : eq (app (cons a ls) (app ls' ls'')) (app (app (cons a ls) ls') ls'')) (a0 : hlist (cons a ls)) (b : hlist ls') (c : hlist ls''), eq (hlist_app (hlist_app a0 b) c) match eq_sym (app_ass_trans@{Ui} (cons a ls) ls' ls'') in (eq _ t) return (hlist t) with | eq_refl => hlist_app a0 (hlist_app b c) end
+++++
simpl.
-----
Lemma hlist_app_assoc : forall ls ls' ls'' (a : hlist ls) (b : hlist ls') (c : hlist ls''), hlist_app (hlist_app a b) c = match eq_sym (app_ass_trans ls ls' ls'') in _ = t return hlist t with | eq_refl => hlist_app a (hlist_app b c) end.
Proof.
intros ls ls' ls''.
generalize (eq_sym (app_assoc_reverse ls ls' ls'')).
induction ls.
simpl.

*****
IHls : forall (_ : eq (app ls (app ls' ls'')) (app (app ls ls') ls''))\n (a : hlist ls) (b : hlist ls') (c : hlist ls''),\neq (hlist_app (hlist_app a b) c)\n match\n eq_sym (app_ass_trans@{Ui} ls ls' ls'') in (eq _ t)\n return (hlist t)\n with\n | eq_refl => hlist_app a (hlist_app b c)\n end
ls,ls',ls'' : list iT
a : iT
eqvOk : forall x : iT, typeOk@{Uv} (eqv x)
eqv : forall x : iT, type@{Uv} (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall (_ : eq (cons a (app ls (app ls' ls''))) (cons a (app (app ls ls') ls''))) (a0 : hlist (cons a ls)) (b : hlist ls') (c : hlist ls''), eq (hlist_app (hlist_app a0 b) c) match eq_sym match app_ass_trans@{Ui} ls ls' ls'' in (eq _ y) return (eq (cons a (app (app ls ls') ls'')) (cons a y)) with | eq_refl => eq_refl end in (eq _ t) return (hlist t) with | eq_refl => hlist_app a0 (hlist_app b c) end
+++++
intros.
-----
Lemma hlist_app_assoc : forall ls ls' ls'' (a : hlist ls) (b : hlist ls') (c : hlist ls''), hlist_app (hlist_app a b) c = match eq_sym (app_ass_trans ls ls' ls'') in _ = t return hlist t with | eq_refl => hlist_app a (hlist_app b c) end.
Proof.
intros ls ls' ls''.
generalize (eq_sym (app_assoc_reverse ls ls' ls'')).
induction ls.
simpl.
intros.

*****
c : hlist ls''
b : hlist ls'
a0 : hlist (cons a ls)
H : eq (cons a (app ls (app ls' ls''))) (cons a (app (app ls ls') ls''))
IHls : forall (_ : eq (app ls (app ls' ls'')) (app (app ls ls') ls''))\n (a : hlist ls) (b : hlist ls') (c : hlist ls''),\neq (hlist_app (hlist_app a b) c)\n match\n eq_sym (app_ass_trans@{Ui} ls ls' ls'') in (eq _ t)\n return (hlist t)\n with\n | eq_refl => hlist_app a (hlist_app b c)\n end
ls,ls',ls'' : list iT
a : iT
eqvOk : forall x : iT, typeOk@{Uv} (eqv x)
eqv : forall x : iT, type@{Uv} (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
eq (hlist_app (hlist_app a0 b) c) match eq_sym match app_ass_trans@{Ui} ls ls' ls'' in (eq _ y) return (eq (cons a (app (app ls ls') ls'')) (cons a y)) with | eq_refl => eq_refl end in (eq _ t) return (hlist t) with | eq_refl => hlist_app a0 (hlist_app b c) end
+++++
rewrite (hlist_eta a0).
-----
Lemma hlist_app_assoc : forall ls ls' ls'' (a : hlist ls) (b : hlist ls') (c : hlist ls''), hlist_app (hlist_app a b) c = match eq_sym (app_ass_trans ls ls' ls'') in _ = t return hlist t with | eq_refl => hlist_app a (hlist_app b c) end.
Proof.
intros ls ls' ls''.
generalize (eq_sym (app_assoc_reverse ls ls' ls'')).
induction ls.
simpl.
intros.
rewrite (hlist_eta a0).

*****
c : hlist ls''
b : hlist ls'
a0 : hlist (cons a ls)
H : eq (cons a (app ls (app ls' ls''))) (cons a (app (app ls ls') ls''))
IHls : forall (_ : eq (app ls (app ls' ls'')) (app (app ls ls') ls''))\n (a : hlist ls) (b : hlist ls') (c : hlist ls''),\neq (hlist_app (hlist_app a b) c)\n match\n eq_sym (app_ass_trans@{Ui} ls ls' ls'') in (eq _ t)\n return (hlist t)\n with\n | eq_refl => hlist_app a (hlist_app b c)\n end
ls,ls',ls'' : list iT
a : iT
eqvOk : forall x : iT, typeOk@{Uv} (eqv x)
eqv : forall x : iT, type@{Uv} (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
eq (hlist_app (hlist_app (Hcons (hlist_hd a0) (hlist_tl a0)) b) c) match eq_sym match app_ass_trans@{Ui} ls ls' ls'' in (eq _ y) return (eq (cons a (app (app ls ls') ls'')) (cons a y)) with | eq_refl => eq_refl end in (eq _ t) return (hlist t) with | eq_refl => hlist_app (Hcons (hlist_hd a0) (hlist_tl a0)) (hlist_app b c) end
+++++
simpl.
-----
Lemma hlist_app_assoc : forall ls ls' ls'' (a : hlist ls) (b : hlist ls') (c : hlist ls''), hlist_app (hlist_app a b) c = match eq_sym (app_ass_trans ls ls' ls'') in _ = t return hlist t with | eq_refl => hlist_app a (hlist_app b c) end.
Proof.
intros ls ls' ls''.
generalize (eq_sym (app_assoc_reverse ls ls' ls'')).
induction ls.
simpl.
intros.
rewrite (hlist_eta a0).
simpl.

*****
c : hlist ls''
b : hlist ls'
a0 : hlist (cons a ls)
H : eq (cons a (app ls (app ls' ls''))) (cons a (app (app ls ls') ls''))
IHls : forall (_ : eq (app ls (app ls' ls'')) (app (app ls ls') ls''))\n (a : hlist ls) (b : hlist ls') (c : hlist ls''),\neq (hlist_app (hlist_app a b) c)\n match\n eq_sym (app_ass_trans@{Ui} ls ls' ls'') in (eq _ t)\n return (hlist t)\n with\n | eq_refl => hlist_app a (hlist_app b c)\n end
ls,ls',ls'' : list iT
a : iT
eqvOk : forall x : iT, typeOk@{Uv} (eqv x)
eqv : forall x : iT, type@{Uv} (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
eq (Hcons (hlist_hd a0) (hlist_app (hlist_app (hlist_tl a0) b) c)) match eq_sym match app_ass_trans@{Ui} ls ls' ls'' in (eq _ y) return (eq (cons a (app (app ls ls') ls'')) (cons a y)) with | eq_refl => eq_refl end in (eq _ t) return (hlist t) with | eq_refl => Hcons (hlist_hd a0) (hlist_app (hlist_tl a0) (hlist_app b c)) end
+++++
inversion H.
-----
Lemma hlist_app_assoc : forall ls ls' ls'' (a : hlist ls) (b : hlist ls') (c : hlist ls''), hlist_app (hlist_app a b) c = match eq_sym (app_ass_trans ls ls' ls'') in _ = t return hlist t with | eq_refl => hlist_app a (hlist_app b c) end.
Proof.
intros ls ls' ls''.
generalize (eq_sym (app_assoc_reverse ls ls' ls'')).
induction ls.
simpl.
intros.
rewrite (hlist_eta a0).
simpl.
inversion H.

*****
H1 : eq (app ls (app ls' ls'')) (app (app ls ls') ls'')
c : hlist ls''
b : hlist ls'
a0 : hlist (cons a ls)
H : eq (cons a (app ls (app ls' ls''))) (cons a (app (app ls ls') ls''))
IHls : forall (_ : eq (app ls (app ls' ls'')) (app (app ls ls') ls''))\n (a : hlist ls) (b : hlist ls') (c : hlist ls''),\neq (hlist_app (hlist_app a b) c)\n match\n eq_sym (app_ass_trans@{Ui} ls ls' ls'') in (eq _ t)\n return (hlist t)\n with\n | eq_refl => hlist_app a (hlist_app b c)\n end
ls,ls',ls'' : list iT
a : iT
eqvOk : forall x : iT, typeOk@{Uv} (eqv x)
eqv : forall x : iT, type@{Uv} (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
eq (Hcons (hlist_hd a0) (hlist_app (hlist_app (hlist_tl a0) b) c)) match eq_sym match app_ass_trans@{Ui} ls ls' ls'' in (eq _ y) return (eq (cons a (app (app ls ls') ls'')) (cons a y)) with | eq_refl => eq_refl end in (eq _ t) return (hlist t) with | eq_refl => Hcons (hlist_hd a0) (hlist_app (hlist_tl a0) (hlist_app b c)) end
+++++
erewrite (IHls H1).
-----
Lemma hlist_app_assoc : forall ls ls' ls'' (a : hlist ls) (b : hlist ls') (c : hlist ls''), hlist_app (hlist_app a b) c = match eq_sym (app_ass_trans ls ls' ls'') in _ = t return hlist t with | eq_refl => hlist_app a (hlist_app b c) end.
Proof.
intros ls ls' ls''.
generalize (eq_sym (app_assoc_reverse ls ls' ls'')).
induction ls.
simpl.
intros.
rewrite (hlist_eta a0).
simpl.
inversion H.
erewrite (IHls H1).

*****
H1 : eq (app ls (app ls' ls'')) (app (app ls ls') ls'')
c : hlist ls''
b : hlist ls'
a0 : hlist (cons a ls)
H : eq (cons a (app ls (app ls' ls''))) (cons a (app (app ls ls') ls''))
IHls : forall (_ : eq (app ls (app ls' ls'')) (app (app ls ls') ls''))\n (a : hlist ls) (b : hlist ls') (c : hlist ls''),\neq (hlist_app (hlist_app a b) c)\n match\n eq_sym (app_ass_trans@{Ui} ls ls' ls'') in (eq _ t)\n return (hlist t)\n with\n | eq_refl => hlist_app a (hlist_app b c)\n end
ls,ls',ls'' : list iT
a : iT
eqvOk : forall x : iT, typeOk@{Uv} (eqv x)
eqv : forall x : iT, type@{Uv} (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
eq (Hcons (hlist_hd a0) match eq_sym (app_ass_trans@{Ui} ls ls' ls'') in (eq _ t) return (hlist t) with | eq_refl => hlist_app (hlist_tl a0) (hlist_app b c) end) match eq_sym match app_ass_trans@{Ui} ls ls' ls'' in (eq _ y) return (eq (cons a (app (app ls ls') ls'')) (cons a y)) with | eq_refl => eq_refl end in (eq _ t) return (hlist t) with | eq_refl => Hcons (hlist_hd a0) (hlist_app (hlist_tl a0) (hlist_app b c)) end
+++++
unfold f_equal.
-----
Lemma hlist_app_assoc : forall ls ls' ls'' (a : hlist ls) (b : hlist ls') (c : hlist ls''), hlist_app (hlist_app a b) c = match eq_sym (app_ass_trans ls ls' ls'') in _ = t return hlist t with | eq_refl => hlist_app a (hlist_app b c) end.
Proof.
intros ls ls' ls''.
generalize (eq_sym (app_assoc_reverse ls ls' ls'')).
induction ls.
simpl.
intros.
rewrite (hlist_eta a0).
simpl.
inversion H.
erewrite (IHls H1).
unfold f_equal.

*****
H1 : eq (app ls (app ls' ls'')) (app (app ls ls') ls'')
c : hlist ls''
b : hlist ls'
a0 : hlist (cons a ls)
H : eq (cons a (app ls (app ls' ls''))) (cons a (app (app ls ls') ls''))
IHls : forall (_ : eq (app ls (app ls' ls'')) (app (app ls ls') ls''))\n (a : hlist ls) (b : hlist ls') (c : hlist ls''),\neq (hlist_app (hlist_app a b) c)\n match\n eq_sym (app_ass_trans@{Ui} ls ls' ls'') in (eq _ t)\n return (hlist t)\n with\n | eq_refl => hlist_app a (hlist_app b c)\n end
ls,ls',ls'' : list iT
a : iT
eqvOk : forall x : iT, typeOk@{Uv} (eqv x)
eqv : forall x : iT, type@{Uv} (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
eq (Hcons (hlist_hd a0) match eq_sym (app_ass_trans@{Ui} ls ls' ls'') in (eq _ t) return (hlist t) with | eq_refl => hlist_app (hlist_tl a0) (hlist_app b c) end) match eq_sym match app_ass_trans@{Ui} ls ls' ls'' in (eq _ y) return (eq (cons a (app (app ls ls') ls'')) (cons a y)) with | eq_refl => eq_refl end in (eq _ t) return (hlist t) with | eq_refl => Hcons (hlist_hd a0) (hlist_app (hlist_tl a0) (hlist_app b c)) end
+++++
unfold eq_trans.
-----
Lemma hlist_app_assoc : forall ls ls' ls'' (a : hlist ls) (b : hlist ls') (c : hlist ls''), hlist_app (hlist_app a b) c = match eq_sym (app_ass_trans ls ls' ls'') in _ = t return hlist t with | eq_refl => hlist_app a (hlist_app b c) end.
Proof.
intros ls ls' ls''.
generalize (eq_sym (app_assoc_reverse ls ls' ls'')).
induction ls.
simpl.
intros.
rewrite (hlist_eta a0).
simpl.
inversion H.
erewrite (IHls H1).
unfold f_equal.
unfold eq_trans.

*****
H1 : eq (app ls (app ls' ls'')) (app (app ls ls') ls'')
c : hlist ls''
b : hlist ls'
a0 : hlist (cons a ls)
H : eq (cons a (app ls (app ls' ls''))) (cons a (app (app ls ls') ls''))
IHls : forall (_ : eq (app ls (app ls' ls'')) (app (app ls ls') ls''))\n (a : hlist ls) (b : hlist ls') (c : hlist ls''),\neq (hlist_app (hlist_app a b) c)\n match\n eq_sym (app_ass_trans@{Ui} ls ls' ls'') in (eq _ t)\n return (hlist t)\n with\n | eq_refl => hlist_app a (hlist_app b c)\n end
ls,ls',ls'' : list iT
a : iT
eqvOk : forall x : iT, typeOk@{Uv} (eqv x)
eqv : forall x : iT, type@{Uv} (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
eq (Hcons (hlist_hd a0) match eq_sym (app_ass_trans@{Ui} ls ls' ls'') in (eq _ t) return (hlist t) with | eq_refl => hlist_app (hlist_tl a0) (hlist_app b c) end) match eq_sym match app_ass_trans@{Ui} ls ls' ls'' in (eq _ y) return (eq (cons a (app (app ls ls') ls'')) (cons a y)) with | eq_refl => eq_refl end in (eq _ t) return (hlist t) with | eq_refl => Hcons (hlist_hd a0) (hlist_app (hlist_tl a0) (hlist_app b c)) end
+++++
unfold eq_sym.
-----
Lemma hlist_app_assoc : forall ls ls' ls'' (a : hlist ls) (b : hlist ls') (c : hlist ls''), hlist_app (hlist_app a b) c = match eq_sym (app_ass_trans ls ls' ls'') in _ = t return hlist t with | eq_refl => hlist_app a (hlist_app b c) end.
Proof.
intros ls ls' ls''.
generalize (eq_sym (app_assoc_reverse ls ls' ls'')).
induction ls.
simpl.
intros.
rewrite (hlist_eta a0).
simpl.
inversion H.
erewrite (IHls H1).
unfold f_equal.
unfold eq_trans.
unfold eq_sym.

*****
H1 : eq (app ls (app ls' ls'')) (app (app ls ls') ls'')
c : hlist ls''
b : hlist ls'
a0 : hlist (cons a ls)
H : eq (cons a (app ls (app ls' ls''))) (cons a (app (app ls ls') ls''))
IHls : forall (_ : eq (app ls (app ls' ls'')) (app (app ls ls') ls''))\n (a : hlist ls) (b : hlist ls') (c : hlist ls''),\neq (hlist_app (hlist_app a b) c)\n match\n eq_sym (app_ass_trans@{Ui} ls ls' ls'') in (eq _ t)\n return (hlist t)\n with\n | eq_refl => hlist_app a (hlist_app b c)\n end
ls,ls',ls'' : list iT
a : iT
eqvOk : forall x : iT, typeOk@{Uv} (eqv x)
eqv : forall x : iT, type@{Uv} (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
eq (Hcons (hlist_hd a0) match match app_ass_trans@{Ui} ls ls' ls'' in (eq _ y) return (eq y (app (app ls ls') ls'')) with | eq_refl => eq_refl end in (eq _ t) return (hlist t) with | eq_refl => hlist_app (hlist_tl a0) (hlist_app b c) end) match match match app_ass_trans@{Ui} ls ls' ls'' in (eq _ y) return (eq (cons a (app (app ls ls') ls'')) (cons a y)) with | eq_refl => eq_refl end in (eq _ y) return (eq y (cons a (app (app ls ls') ls''))) with | eq_refl => eq_refl end in (eq _ t) return (hlist t) with | eq_refl => Hcons (hlist_hd a0) (hlist_app (hlist_tl a0) (hlist_app b c)) end
+++++
generalize (app_ass_trans ls ls' ls'').
-----
Lemma hlist_app_assoc : forall ls ls' ls'' (a : hlist ls) (b : hlist ls') (c : hlist ls''), hlist_app (hlist_app a b) c = match eq_sym (app_ass_trans ls ls' ls'') in _ = t return hlist t with | eq_refl => hlist_app a (hlist_app b c) end.
Proof.
intros ls ls' ls''.
generalize (eq_sym (app_assoc_reverse ls ls' ls'')).
induction ls.
simpl.
intros.
rewrite (hlist_eta a0).
simpl.
inversion H.
erewrite (IHls H1).
unfold f_equal.
unfold eq_trans.
unfold eq_sym.
generalize (app_ass_trans ls ls' ls'').

*****
H1 : eq (app ls (app ls' ls'')) (app (app ls ls') ls'')
c : hlist ls''
b : hlist ls'
a0 : hlist (cons a ls)
H : eq (cons a (app ls (app ls' ls''))) (cons a (app (app ls ls') ls''))
IHls : forall (_ : eq (app ls (app ls' ls'')) (app (app ls ls') ls''))\n (a : hlist ls) (b : hlist ls') (c : hlist ls''),\neq (hlist_app (hlist_app a b) c)\n match\n eq_sym (app_ass_trans@{Ui} ls ls' ls'') in (eq _ t)\n return (hlist t)\n with\n | eq_refl => hlist_app a (hlist_app b c)\n end
ls,ls',ls'' : list iT
a : iT
eqvOk : forall x : iT, typeOk@{Uv} (eqv x)
eqv : forall x : iT, type@{Uv} (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall e : eq (app (app ls ls') ls'') (app ls (app ls' ls'')), eq (Hcons (hlist_hd a0) match match e in (eq _ y) return (eq y (app (app ls ls') ls'')) with | eq_refl => eq_refl end in (eq _ t) return (hlist t) with | eq_refl => hlist_app (hlist_tl a0) (hlist_app b c) end) match match match e in (eq _ y) return (eq (cons a (app (app ls ls') ls'')) (cons a y)) with | eq_refl => eq_refl end in (eq _ y) return (eq y (cons a (app (app ls ls') ls''))) with | eq_refl => eq_refl end in (eq _ t) return (hlist t) with | eq_refl => Hcons (hlist_hd a0) (hlist_app (hlist_tl a0) (hlist_app b c)) end
+++++
rewrite <- H1.
-----
Lemma hlist_app_assoc : forall ls ls' ls'' (a : hlist ls) (b : hlist ls') (c : hlist ls''), hlist_app (hlist_app a b) c = match eq_sym (app_ass_trans ls ls' ls'') in _ = t return hlist t with | eq_refl => hlist_app a (hlist_app b c) end.
Proof.
intros ls ls' ls''.
generalize (eq_sym (app_assoc_reverse ls ls' ls'')).
induction ls.
simpl.
intros.
rewrite (hlist_eta a0).
simpl.
inversion H.
erewrite (IHls H1).
unfold f_equal.
unfold eq_trans.
unfold eq_sym.
generalize (app_ass_trans ls ls' ls'').
rewrite <- H1.

*****
H1 : eq (app ls (app ls' ls'')) (app (app ls ls') ls'')
c : hlist ls''
b : hlist ls'
a0 : hlist (cons a ls)
H : eq (cons a (app ls (app ls' ls''))) (cons a (app (app ls ls') ls''))
IHls : forall (_ : eq (app ls (app ls' ls'')) (app (app ls ls') ls''))\n (a : hlist ls) (b : hlist ls') (c : hlist ls''),\neq (hlist_app (hlist_app a b) c)\n match\n eq_sym (app_ass_trans@{Ui} ls ls' ls'') in (eq _ t)\n return (hlist t)\n with\n | eq_refl => hlist_app a (hlist_app b c)\n end
ls,ls',ls'' : list iT
a : iT
eqvOk : forall x : iT, typeOk@{Uv} (eqv x)
eqv : forall x : iT, type@{Uv} (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall e : eq (app ls (app ls' ls'')) (app ls (app ls' ls'')), eq (Hcons (hlist_hd a0) match match e in (eq _ y) return (eq y (app ls (app ls' ls''))) with | eq_refl => eq_refl end in (eq _ t) return (hlist t) with | eq_refl => hlist_app (hlist_tl a0) (hlist_app b c) end) match match match e in (eq _ y) return (eq (cons a (app ls (app ls' ls''))) (cons a y)) with | eq_refl => eq_refl end in (eq _ y) return (eq y (cons a (app ls (app ls' ls'')))) with | eq_refl => eq_refl end in (eq _ t) return (hlist t) with | eq_refl => Hcons (hlist_hd a0) (hlist_app (hlist_tl a0) (hlist_app b c)) end
+++++
clear.
-----
Lemma hlist_app_assoc : forall ls ls' ls'' (a : hlist ls) (b : hlist ls') (c : hlist ls''), hlist_app (hlist_app a b) c = match eq_sym (app_ass_trans ls ls' ls'') in _ = t return hlist t with | eq_refl => hlist_app a (hlist_app b c) end.
Proof.
intros ls ls' ls''.
generalize (eq_sym (app_assoc_reverse ls ls' ls'')).
induction ls.
simpl.
intros.
rewrite (hlist_eta a0).
simpl.
inversion H.
erewrite (IHls H1).
unfold f_equal.
unfold eq_trans.
unfold eq_sym.
generalize (app_ass_trans ls ls' ls'').
rewrite <- H1.
clear.

*****
c : hlist ls''
b : hlist ls'
a0 : hlist (cons a ls)
ls,ls',ls'' : list iT
a : iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall e : eq (app ls (app ls' ls'')) (app ls (app ls' ls'')), eq (Hcons (hlist_hd a0) match match e in (eq _ y) return (eq y (app ls (app ls' ls''))) with | eq_refl => eq_refl end in (eq _ t) return (hlist t) with | eq_refl => hlist_app (hlist_tl a0) (hlist_app b c) end) match match match e in (eq _ y) return (eq (cons a (app ls (app ls' ls''))) (cons a y)) with | eq_refl => eq_refl end in (eq _ y) return (eq y (cons a (app ls (app ls' ls'')))) with | eq_refl => eq_refl end in (eq _ t) return (hlist t) with | eq_refl => Hcons (hlist_hd a0) (hlist_app (hlist_tl a0) (hlist_app b c)) end
+++++
intro.
-----
Lemma hlist_app_assoc : forall ls ls' ls'' (a : hlist ls) (b : hlist ls') (c : hlist ls''), hlist_app (hlist_app a b) c = match eq_sym (app_ass_trans ls ls' ls'') in _ = t return hlist t with | eq_refl => hlist_app a (hlist_app b c) end.
Proof.
intros ls ls' ls''.
generalize (eq_sym (app_assoc_reverse ls ls' ls'')).
induction ls.
simpl.
intros.
rewrite (hlist_eta a0).
simpl.
inversion H.
erewrite (IHls H1).
unfold f_equal.
unfold eq_trans.
unfold eq_sym.
generalize (app_ass_trans ls ls' ls'').
rewrite <- H1.
clear.
intro.

*****
e : eq (app ls (app ls' ls'')) (app ls (app ls' ls''))
c : hlist ls''
b : hlist ls'
a0 : hlist (cons a ls)
ls,ls',ls'' : list iT
a : iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
eq (Hcons (hlist_hd a0) match match e in (eq _ y) return (eq y (app ls (app ls' ls''))) with | eq_refl => eq_refl end in (eq _ t) return (hlist t) with | eq_refl => hlist_app (hlist_tl a0) (hlist_app b c) end) match match match e in (eq _ y) return (eq (cons a (app ls (app ls' ls''))) (cons a y)) with | eq_refl => eq_refl end in (eq _ y) return (eq y (cons a (app ls (app ls' ls'')))) with | eq_refl => eq_refl end in (eq _ t) return (hlist t) with | eq_refl => Hcons (hlist_hd a0) (hlist_app (hlist_tl a0) (hlist_app b c)) end
+++++
generalize dependent (hlist_app (hlist_tl a0) (hlist_app b c)).
-----
Lemma hlist_app_assoc : forall ls ls' ls'' (a : hlist ls) (b : hlist ls') (c : hlist ls''), hlist_app (hlist_app a b) c = match eq_sym (app_ass_trans ls ls' ls'') in _ = t return hlist t with | eq_refl => hlist_app a (hlist_app b c) end.
Proof.
intros ls ls' ls''.
generalize (eq_sym (app_assoc_reverse ls ls' ls'')).
induction ls.
simpl.
intros.
rewrite (hlist_eta a0).
simpl.
inversion H.
erewrite (IHls H1).
unfold f_equal.
unfold eq_trans.
unfold eq_sym.
generalize (app_ass_trans ls ls' ls'').
rewrite <- H1.
clear.
intro.
generalize dependent (hlist_app (hlist_tl a0) (hlist_app b c)).

*****
e : eq (app ls (app ls' ls'')) (app ls (app ls' ls''))
c : hlist ls''
b : hlist ls'
a0 : hlist (cons a ls)
ls,ls',ls'' : list iT
a : iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall h : hlist (app ls (app ls' ls'')), eq (Hcons (hlist_hd a0) match match e in (eq _ y) return (eq y (app ls (app ls' ls''))) with | eq_refl => eq_refl end in (eq _ t) return (hlist t) with | eq_refl => h end) match match match e in (eq _ y) return (eq (cons a (app ls (app ls' ls''))) (cons a y)) with | eq_refl => eq_refl end in (eq _ y) return (eq y (cons a (app ls (app ls' ls'')))) with | eq_refl => eq_refl end in (eq _ t) return (hlist t) with | eq_refl => Hcons (hlist_hd a0) h end
+++++
destruct e.
-----
Lemma hlist_app_assoc : forall ls ls' ls'' (a : hlist ls) (b : hlist ls') (c : hlist ls''), hlist_app (hlist_app a b) c = match eq_sym (app_ass_trans ls ls' ls'') in _ = t return hlist t with | eq_refl => hlist_app a (hlist_app b c) end.
Proof.
intros ls ls' ls''.
generalize (eq_sym (app_assoc_reverse ls ls' ls'')).
induction ls.
simpl.
intros.
rewrite (hlist_eta a0).
simpl.
inversion H.
erewrite (IHls H1).
unfold f_equal.
unfold eq_trans.
unfold eq_sym.
generalize (app_ass_trans ls ls' ls'').
rewrite <- H1.
clear.
intro.
generalize dependent (hlist_app (hlist_tl a0) (hlist_app b c)).
destruct e.

*****
c : hlist ls''
b : hlist ls'
a0 : hlist (cons a ls)
ls,ls',ls'' : list iT
a : iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall h : hlist (app ls (app ls' ls'')), eq (Hcons (hlist_hd a0) h) (Hcons (hlist_hd a0) h)
+++++
reflexivity.
-----
Lemma hlist_app_assoc : forall ls ls' ls'' (a : hlist ls) (b : hlist ls') (c : hlist ls''), hlist_app (hlist_app a b) c = match eq_sym (app_ass_trans ls ls' ls'') in _ = t return hlist t with | eq_refl => hlist_app a (hlist_app b c) end.
Proof.
intros ls ls' ls''.
generalize (eq_sym (app_assoc_reverse ls ls' ls'')).
induction ls.

*****

*****

+++++
Qed.
-----
Lemma hlist_app_assoc'\n      : forall (ls ls' ls'' : list iT)\n               (a : hlist ls) (b : hlist ls') (c : hlist ls''),\n        hlist_app a (hlist_app b c) =\n        match\n          app_ass_trans ls ls' ls'' in (_ = t) return (hlist t)\n        with\n        | eq_refl => hlist_app (hlist_app a b) c\n        end.
-----
Lemma hlist_app_assoc' : forall (ls ls' ls'' : list iT) (a : hlist ls) (b : hlist ls') (c : hlist ls''), hlist_app a (hlist_app b c) = match app_ass_trans ls ls' ls'' in (_ = t) return (hlist t) with | eq_refl => hlist_app (hlist_app a b) c end.

*****
eqvOk : forall x : iT, typeOk@{Uv} (eqv x)
eqv : forall x : iT, type@{Uv} (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall (ls ls' ls'' : list iT) (a : hlist ls) (b : hlist ls') (c : hlist ls''), eq (hlist_app a (hlist_app b c)) match app_ass_trans@{Ui} ls ls' ls'' in (eq _ t) return (hlist t) with | eq_refl => hlist_app (hlist_app a b) c end
+++++
Proof.
-----
Lemma hlist_app_assoc' : forall (ls ls' ls'' : list iT) (a : hlist ls) (b : hlist ls') (c : hlist ls''), hlist_app a (hlist_app b c) = match app_ass_trans ls ls' ls'' in (_ = t) return (hlist t) with | eq_refl => hlist_app (hlist_app a b) c end.
Proof.

*****
eqvOk : forall x : iT, typeOk@{Uv} (eqv x)
eqv : forall x : iT, type@{Uv} (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall (ls ls' ls'' : list iT) (a : hlist ls) (b : hlist ls') (c : hlist ls''), eq (hlist_app a (hlist_app b c)) match app_ass_trans@{Ui} ls ls' ls'' in (eq _ t) return (hlist t) with | eq_refl => hlist_app (hlist_app a b) c end
+++++
clear.
-----
Lemma hlist_app_assoc' : forall (ls ls' ls'' : list iT) (a : hlist ls) (b : hlist ls') (c : hlist ls''), hlist_app a (hlist_app b c) = match app_ass_trans ls ls' ls'' in (_ = t) return (hlist t) with | eq_refl => hlist_app (hlist_app a b) c end.
Proof.
clear.

*****
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall (ls ls' ls'' : list iT) (a : hlist ls) (b : hlist ls') (c : hlist ls''), eq (hlist_app a (hlist_app b c)) match app_ass_trans@{Ui} ls ls' ls'' in (eq _ t) return (hlist t) with | eq_refl => hlist_app (hlist_app a b) c end
+++++
intros.
-----
Lemma hlist_app_assoc' : forall (ls ls' ls'' : list iT) (a : hlist ls) (b : hlist ls') (c : hlist ls''), hlist_app a (hlist_app b c) = match app_ass_trans ls ls' ls'' in (_ = t) return (hlist t) with | eq_refl => hlist_app (hlist_app a b) c end.
Proof.
clear.
intros.

*****
c : hlist ls''
b : hlist ls'
a : hlist ls
ls,ls',ls'' : list iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
eq (hlist_app a (hlist_app b c)) match app_ass_trans@{Ui} ls ls' ls'' in (eq _ t) return (hlist t) with | eq_refl => hlist_app (hlist_app a b) c end
+++++
generalize (hlist_app_assoc a b c).
-----
Lemma hlist_app_assoc' : forall (ls ls' ls'' : list iT) (a : hlist ls) (b : hlist ls') (c : hlist ls''), hlist_app a (hlist_app b c) = match app_ass_trans ls ls' ls'' in (_ = t) return (hlist t) with | eq_refl => hlist_app (hlist_app a b) c end.
Proof.
clear.
intros.
generalize (hlist_app_assoc a b c).

*****
c : hlist ls''
b : hlist ls'
a : hlist ls
ls,ls',ls'' : list iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall _ : eq (hlist_app (hlist_app a b) c) match eq_sym (app_ass_trans@{Ui} ls ls' ls'') in (eq _ t) return (hlist t) with | eq_refl => hlist_app a (hlist_app b c) end, eq (hlist_app a (hlist_app b c)) match app_ass_trans@{Ui} ls ls' ls'' in (eq _ t) return (hlist t) with | eq_refl => hlist_app (hlist_app a b) c end
+++++
generalize (hlist_app (hlist_app a b) c).
-----
Lemma hlist_app_assoc' : forall (ls ls' ls'' : list iT) (a : hlist ls) (b : hlist ls') (c : hlist ls''), hlist_app a (hlist_app b c) = match app_ass_trans ls ls' ls'' in (_ = t) return (hlist t) with | eq_refl => hlist_app (hlist_app a b) c end.
Proof.
clear.
intros.
generalize (hlist_app_assoc a b c).
generalize (hlist_app (hlist_app a b) c).

*****
c : hlist ls''
b : hlist ls'
a : hlist ls
ls,ls',ls'' : list iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall (h : hlist (app (app ls ls') ls'')) (_ : eq h match eq_sym (app_ass_trans@{Ui} ls ls' ls'') in (eq _ t) return (hlist t) with | eq_refl => hlist_app a (hlist_app b c) end), eq (hlist_app a (hlist_app b c)) match app_ass_trans@{Ui} ls ls' ls'' in (eq _ t) return (hlist t) with | eq_refl => h end
+++++
generalize (hlist_app a (hlist_app b c)).
-----
Lemma hlist_app_assoc' : forall (ls ls' ls'' : list iT) (a : hlist ls) (b : hlist ls') (c : hlist ls''), hlist_app a (hlist_app b c) = match app_ass_trans ls ls' ls'' in (_ = t) return (hlist t) with | eq_refl => hlist_app (hlist_app a b) c end.
Proof.
clear.
intros.
generalize (hlist_app_assoc a b c).
generalize (hlist_app (hlist_app a b) c).
generalize (hlist_app a (hlist_app b c)).

*****
c : hlist ls''
b : hlist ls'
a : hlist ls
ls,ls',ls'' : list iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall (h : hlist (app ls (app ls' ls''))) (h0 : hlist (app (app ls ls') ls'')) (_ : eq h0 match eq_sym (app_ass_trans@{Ui} ls ls' ls'') in (eq _ t) return (hlist t) with | eq_refl => h end), eq h match app_ass_trans@{Ui} ls ls' ls'' in (eq _ t) return (hlist t) with | eq_refl => h0 end
+++++
destruct (app_ass_trans ls ls' ls'').
-----
Lemma hlist_app_assoc' : forall (ls ls' ls'' : list iT) (a : hlist ls) (b : hlist ls') (c : hlist ls''), hlist_app a (hlist_app b c) = match app_ass_trans ls ls' ls'' in (_ = t) return (hlist t) with | eq_refl => hlist_app (hlist_app a b) c end.
Proof.
clear.
intros.
generalize (hlist_app_assoc a b c).
generalize (hlist_app (hlist_app a b) c).
generalize (hlist_app a (hlist_app b c)).
destruct (app_ass_trans ls ls' ls'').

*****
c : hlist ls''
b : hlist ls'
a : hlist ls
ls,ls',ls'' : list iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall (h h0 : hlist (app (app ls ls') ls'')) (_ : eq h0 match eq_sym eq_refl in (eq _ t) return (hlist t) with | eq_refl => h end), eq h h0
+++++
simpl.
-----
Lemma hlist_app_assoc' : forall (ls ls' ls'' : list iT) (a : hlist ls) (b : hlist ls') (c : hlist ls''), hlist_app a (hlist_app b c) = match app_ass_trans ls ls' ls'' in (_ = t) return (hlist t) with | eq_refl => hlist_app (hlist_app a b) c end.
Proof.
clear.
intros.
generalize (hlist_app_assoc a b c).
generalize (hlist_app (hlist_app a b) c).
generalize (hlist_app a (hlist_app b c)).
destruct (app_ass_trans ls ls' ls'').
simpl.

*****
c : hlist ls''
b : hlist ls'
a : hlist ls
ls,ls',ls'' : list iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall (h h0 : hlist (app (app ls ls') ls'')) (_ : eq h0 h), eq h h0
+++++
auto.
-----
Lemma hlist_app_assoc' : forall (ls ls' ls'' : list iT) (a : hlist ls) (b : hlist ls') (c : hlist ls''), hlist_app a (hlist_app b c) = match app_ass_trans ls ls' ls'' in (_ = t) return (hlist t) with | eq_refl => hlist_app (hlist_app a b) c end.
Proof.
clear.
intros.
generalize (hlist_app_assoc a b c).
generalize (hlist_app (hlist_app a b) c).
generalize (hlist_app a (hlist_app b c)).
destruct (app_ass_trans ls ls' ls'').
simpl.
auto.

*****

*****

+++++
Qed.
-----
Fixpoint hlist_split ls ls' : hlist (ls ++ ls') -> hlist ls * hlist ls' :=\n      match ls as ls return hlist (ls ++ ls') -> hlist ls * hlist ls' with\n        | nil => fun h => (Hnil, h)\n        | l :: ls => fun h =>\n                       let (a,b) := @hlist_split ls ls' (hlist_tl h) in\n                       (Hcons (hlist_hd h) a, b)\n      end.
-----
Lemma hlist_app_hlist_split : forall ls' ls (h : hlist (ls ++ ls')),\n      hlist_app (fst (hlist_split ls ls' h)) (snd (hlist_split ls ls' h)) = h.
-----
Lemma hlist_app_hlist_split : forall ls' ls (h : hlist (ls ++ ls')), hlist_app (fst (hlist_split ls ls' h)) (snd (hlist_split ls ls' h)) = h.

*****
eqvOk : forall x : iT, typeOk@{Uv} (eqv x)
eqv : forall x : iT, type@{Uv} (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall (ls' ls : list iT) (h : hlist (app ls ls')), eq (hlist_app (fst (hlist_split ls ls' h)) (snd (hlist_split ls ls' h))) h
+++++
Proof.
-----
Lemma hlist_app_hlist_split : forall ls' ls (h : hlist (ls ++ ls')), hlist_app (fst (hlist_split ls ls' h)) (snd (hlist_split ls ls' h)) = h.
Proof.

*****
eqvOk : forall x : iT, typeOk@{Uv} (eqv x)
eqv : forall x : iT, type@{Uv} (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall (ls' ls : list iT) (h : hlist (app ls ls')), eq (hlist_app (fst (hlist_split ls ls' h)) (snd (hlist_split ls ls' h))) h
+++++
induction ls.
-----
Lemma hlist_app_hlist_split : forall ls' ls (h : hlist (ls ++ ls')), hlist_app (fst (hlist_split ls ls' h)) (snd (hlist_split ls ls' h)) = h.
Proof.
induction ls.

*****
ls' : list iT
eqvOk : forall x : iT, typeOk@{Uv} (eqv x)
eqv : forall x : iT, type@{Uv} (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall h : hlist (app nil ls'), eq (hlist_app (fst (hlist_split nil ls' h)) (snd (hlist_split nil ls' h))) h
+++++
simpl.
-----
Lemma hlist_app_hlist_split : forall ls' ls (h : hlist (ls ++ ls')), hlist_app (fst (hlist_split ls ls' h)) (snd (hlist_split ls ls' h)) = h.
Proof.
induction ls.
simpl.

*****
ls' : list iT
eqvOk : forall x : iT, typeOk@{Uv} (eqv x)
eqv : forall x : iT, type@{Uv} (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall h : hlist ls', eq h h
+++++
intros.
-----
Lemma hlist_app_hlist_split : forall ls' ls (h : hlist (ls ++ ls')), hlist_app (fst (hlist_split ls ls' h)) (snd (hlist_split ls ls' h)) = h.
Proof.
induction ls.
simpl.
intros.

*****
h : hlist ls'
ls' : list iT
eqvOk : forall x : iT, typeOk@{Uv} (eqv x)
eqv : forall x : iT, type@{Uv} (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
eq h h
+++++
auto.
-----
Lemma hlist_app_hlist_split : forall ls' ls (h : hlist (ls ++ ls')), hlist_app (fst (hlist_split ls ls' h)) (snd (hlist_split ls ls' h)) = h.
Proof.
induction ls.

*****
IHls : forall h : hlist (app ls ls'),\neq\n (hlist_app (fst (hlist_split ls ls' h)) (snd (hlist_split ls ls' h)))\n h
ls : list iT
a : iT
ls' : list iT
eqvOk : forall x : iT, typeOk@{Uv} (eqv x)
eqv : forall x : iT, type@{Uv} (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall h : hlist (app (cons a ls) ls'), eq (hlist_app (fst (hlist_split (cons a ls) ls' h)) (snd (hlist_split (cons a ls) ls' h))) h
+++++
simpl.
-----
Lemma hlist_app_hlist_split : forall ls' ls (h : hlist (ls ++ ls')), hlist_app (fst (hlist_split ls ls' h)) (snd (hlist_split ls ls' h)) = h.
Proof.
induction ls.
simpl.

*****
IHls : forall h : hlist (app ls ls'),\neq\n (hlist_app (fst (hlist_split ls ls' h)) (snd (hlist_split ls ls' h)))\n h
ls : list iT
a : iT
ls' : list iT
eqvOk : forall x : iT, typeOk@{Uv} (eqv x)
eqv : forall x : iT, type@{Uv} (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall h : hlist (cons a (app ls ls')), eq (hlist_app (fst (let (a0, b) := hlist_split ls ls' (hlist_tl h) in pair (Hcons (hlist_hd h) a0) b)) (snd (let (a0, b) := hlist_split ls ls' (hlist_tl h) in pair (Hcons (hlist_hd h) a0) b))) h
+++++
intros.
-----
Lemma hlist_app_hlist_split : forall ls' ls (h : hlist (ls ++ ls')), hlist_app (fst (hlist_split ls ls' h)) (snd (hlist_split ls ls' h)) = h.
Proof.
induction ls.
simpl.
intros.

*****
h : hlist (cons a (app ls ls'))
IHls : forall h : hlist (app ls ls'),\neq\n (hlist_app (fst (hlist_split ls ls' h)) (snd (hlist_split ls ls' h)))\n h
ls : list iT
a : iT
ls' : list iT
eqvOk : forall x : iT, typeOk@{Uv} (eqv x)
eqv : forall x : iT, type@{Uv} (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
eq (hlist_app (fst (let (a0, b) := hlist_split ls ls' (hlist_tl h) in pair (Hcons (hlist_hd h) a0) b)) (snd (let (a0, b) := hlist_split ls ls' (hlist_tl h) in pair (Hcons (hlist_hd h) a0) b))) h
+++++
auto.
-----
Lemma hlist_app_hlist_split : forall ls' ls (h : hlist (ls ++ ls')), hlist_app (fst (hlist_split ls ls' h)) (snd (hlist_split ls ls' h)) = h.
Proof.
induction ls.
simpl.
intros.
auto.

*****
h : hlist (cons a (app ls ls'))
IHls : forall h : hlist (app ls ls'),\neq\n (hlist_app (fst (hlist_split ls ls' h)) (snd (hlist_split ls ls' h)))\n h
ls : list iT
a : iT
ls' : list iT
eqvOk : forall x : iT, typeOk@{Uv} (eqv x)
eqv : forall x : iT, type@{Uv} (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
eq (hlist_app (fst (let (a0, b) := hlist_split ls ls' (hlist_tl h) in pair (Hcons (hlist_hd h) a0) b)) (snd (let (a0, b) := hlist_split ls ls' (hlist_tl h) in pair (Hcons (hlist_hd h) a0) b))) h
+++++
rewrite (hlist_eta h).
-----
Lemma hlist_app_hlist_split : forall ls' ls (h : hlist (ls ++ ls')), hlist_app (fst (hlist_split ls ls' h)) (snd (hlist_split ls ls' h)) = h.
Proof.
induction ls.
simpl.
intros.
auto.
rewrite (hlist_eta h).

*****
h : hlist (cons a (app ls ls'))
IHls : forall h : hlist (app ls ls'),\neq\n (hlist_app (fst (hlist_split ls ls' h)) (snd (hlist_split ls ls' h)))\n h
ls : list iT
a : iT
ls' : list iT
eqvOk : forall x : iT, typeOk@{Uv} (eqv x)
eqv : forall x : iT, type@{Uv} (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
eq (hlist_app (fst (let (a0, b) := hlist_split ls ls' (hlist_tl (Hcons (hlist_hd h) (hlist_tl h))) in pair (Hcons (hlist_hd (Hcons (hlist_hd h) (hlist_tl h))) a0) b)) (snd (let (a0, b) := hlist_split ls ls' (hlist_tl (Hcons (hlist_hd h) (hlist_tl h))) in pair (Hcons (hlist_hd (Hcons (hlist_hd h) (hlist_tl h))) a0) b))) (Hcons (hlist_hd h) (hlist_tl h))
+++++
simpl.
-----
Lemma hlist_app_hlist_split : forall ls' ls (h : hlist (ls ++ ls')), hlist_app (fst (hlist_split ls ls' h)) (snd (hlist_split ls ls' h)) = h.
Proof.
induction ls.
simpl.
intros.
auto.
rewrite (hlist_eta h).
simpl.

*****
h : hlist (cons a (app ls ls'))
IHls : forall h : hlist (app ls ls'),\neq\n (hlist_app (fst (hlist_split ls ls' h)) (snd (hlist_split ls ls' h)))\n h
ls : list iT
a : iT
ls' : list iT
eqvOk : forall x : iT, typeOk@{Uv} (eqv x)
eqv : forall x : iT, type@{Uv} (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
eq (hlist_app (fst (let (a0, b) := hlist_split ls ls' (hlist_tl h) in pair (Hcons (hlist_hd h) a0) b)) (snd (let (a0, b) := hlist_split ls ls' (hlist_tl h) in pair (Hcons (hlist_hd h) a0) b))) (Hcons (hlist_hd h) (hlist_tl h))
+++++
specialize (IHls (hlist_tl h)).
-----
Lemma hlist_app_hlist_split : forall ls' ls (h : hlist (ls ++ ls')), hlist_app (fst (hlist_split ls ls' h)) (snd (hlist_split ls ls' h)) = h.
Proof.
induction ls.
simpl.
intros.
auto.
rewrite (hlist_eta h).
simpl.
specialize (IHls (hlist_tl h)).

*****
IHls : eq\n (hlist_app (fst (hlist_split ls ls' (hlist_tl h)))\n (snd (hlist_split ls ls' (hlist_tl h)))) (hlist_tl h)
h : hlist (cons a (app ls ls'))
ls : list iT
a : iT
ls' : list iT
eqvOk : forall x : iT, typeOk@{Uv} (eqv x)
eqv : forall x : iT, type@{Uv} (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
eq (hlist_app (fst (let (a0, b) := hlist_split ls ls' (hlist_tl h) in pair (Hcons (hlist_hd h) a0) b)) (snd (let (a0, b) := hlist_split ls ls' (hlist_tl h) in pair (Hcons (hlist_hd h) a0) b))) (Hcons (hlist_hd h) (hlist_tl h))
+++++
destruct (hlist_split ls ls' (hlist_tl h)).
-----
Lemma hlist_app_hlist_split : forall ls' ls (h : hlist (ls ++ ls')), hlist_app (fst (hlist_split ls ls' h)) (snd (hlist_split ls ls' h)) = h.
Proof.
induction ls.
simpl.
intros.
auto.
rewrite (hlist_eta h).
simpl.
specialize (IHls (hlist_tl h)).
destruct (hlist_split ls ls' (hlist_tl h)).

*****
IHls : eq (hlist_app (fst (pair h0 h1)) (snd (pair h0 h1))) (hlist_tl h)
h1 : hlist ls'
h0 : hlist ls
h : hlist (cons a (app ls ls'))
ls : list iT
a : iT
ls' : list iT
eqvOk : forall x : iT, typeOk@{Uv} (eqv x)
eqv : forall x : iT, type@{Uv} (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
eq (hlist_app (fst (pair (Hcons (hlist_hd h) h0) h1)) (snd (pair (Hcons (hlist_hd h) h0) h1))) (Hcons (hlist_hd h) (hlist_tl h))
+++++
simpl in *.
-----
Lemma hlist_app_hlist_split : forall ls' ls (h : hlist (ls ++ ls')), hlist_app (fst (hlist_split ls ls' h)) (snd (hlist_split ls ls' h)) = h.
Proof.
induction ls.
simpl.
intros.
auto.
rewrite (hlist_eta h).
simpl.
specialize (IHls (hlist_tl h)).
destruct (hlist_split ls ls' (hlist_tl h)).
simpl in *.

*****
IHls : eq (hlist_app h0 h1) (hlist_tl h)
h1 : hlist ls'
h0 : hlist ls
h : hlist (cons a (app ls ls'))
ls : list iT
a : iT
ls' : list iT
eqvOk : forall x : iT, typeOk@{Uv} (eqv x)
eqv : forall x : iT, type@{Uv} (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
eq (Hcons (hlist_hd h) (hlist_app h0 h1)) (Hcons (hlist_hd h) (hlist_tl h))
+++++
auto.
-----
Lemma hlist_app_hlist_split : forall ls' ls (h : hlist (ls ++ ls')), hlist_app (fst (hlist_split ls ls' h)) (snd (hlist_split ls ls' h)) = h.
Proof.
induction ls.
simpl.
intros.
auto.
rewrite (hlist_eta h).
simpl.
specialize (IHls (hlist_tl h)).
destruct (hlist_split ls ls' (hlist_tl h)).
simpl in *.
auto.

*****
IHls : eq (hlist_app h0 h1) (hlist_tl h)
h1 : hlist ls'
h0 : hlist ls
h : hlist (cons a (app ls ls'))
ls : list iT
a : iT
ls' : list iT
eqvOk : forall x : iT, typeOk@{Uv} (eqv x)
eqv : forall x : iT, type@{Uv} (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
eq (Hcons (hlist_hd h) (hlist_app h0 h1)) (Hcons (hlist_hd h) (hlist_tl h))
+++++
f_equal.
-----
Lemma hlist_app_hlist_split : forall ls' ls (h : hlist (ls ++ ls')), hlist_app (fst (hlist_split ls ls' h)) (snd (hlist_split ls ls' h)) = h.
Proof.
induction ls.
simpl.
intros.
auto.
rewrite (hlist_eta h).
simpl.
specialize (IHls (hlist_tl h)).
destruct (hlist_split ls ls' (hlist_tl h)).
simpl in *.
auto.
f_equal.

*****
IHls : eq (hlist_app h0 h1) (hlist_tl h)
h1 : hlist ls'
h0 : hlist ls
h : hlist (cons a (app ls ls'))
ls : list iT
a : iT
ls' : list iT
eqvOk : forall x : iT, typeOk@{Uv} (eqv x)
eqv : forall x : iT, type@{Uv} (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
eq (hlist_app h0 h1) (hlist_tl h)
+++++
auto.
-----
Lemma hlist_app_hlist_split : forall ls' ls (h : hlist (ls ++ ls')), hlist_app (fst (hlist_split ls ls' h)) (snd (hlist_split ls ls' h)) = h.
Proof.
induction ls.

*****

*****

+++++
Qed.
-----
Lemma hlist_split_hlist_app : forall ls' ls (h : hlist ls) (h' : hlist ls'),\n      hlist_split _ _ (hlist_app h h') = (h,h').
-----
Lemma hlist_split_hlist_app : forall ls' ls (h : hlist ls) (h' : hlist ls'), hlist_split _ _ (hlist_app h h') = (h,h').

*****
eqvOk : forall x : iT, typeOk@{Uv} (eqv x)
eqv : forall x : iT, type@{Uv} (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall (ls' ls : list iT) (h : hlist ls) (h' : hlist ls'), eq (hlist_split ls ls' (hlist_app h h')) (pair h h')
+++++
Proof.
-----
Lemma hlist_split_hlist_app : forall ls' ls (h : hlist ls) (h' : hlist ls'), hlist_split _ _ (hlist_app h h') = (h,h').
Proof.

*****
eqvOk : forall x : iT, typeOk@{Uv} (eqv x)
eqv : forall x : iT, type@{Uv} (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall (ls' ls : list iT) (h : hlist ls) (h' : hlist ls'), eq (hlist_split ls ls' (hlist_app h h')) (pair h h')
+++++
induction ls.
-----
Lemma hlist_split_hlist_app : forall ls' ls (h : hlist ls) (h' : hlist ls'), hlist_split _ _ (hlist_app h h') = (h,h').
Proof.
induction ls.

*****
ls' : list iT
eqvOk : forall x : iT, typeOk@{Uv} (eqv x)
eqv : forall x : iT, type@{Uv} (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall (h : hlist nil) (h' : hlist ls'), eq (hlist_split nil ls' (hlist_app h h')) (pair h h')
+++++
simpl.
-----
Lemma hlist_split_hlist_app : forall ls' ls (h : hlist ls) (h' : hlist ls'), hlist_split _ _ (hlist_app h h') = (h,h').
Proof.
induction ls.
simpl.

*****
ls' : list iT
eqvOk : forall x : iT, typeOk@{Uv} (eqv x)
eqv : forall x : iT, type@{Uv} (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall (h : hlist nil) (h' : hlist ls'), eq (pair Hnil (hlist_app h h')) (pair h h')
+++++
intros.
-----
Lemma hlist_split_hlist_app : forall ls' ls (h : hlist ls) (h' : hlist ls'), hlist_split _ _ (hlist_app h h') = (h,h').
Proof.
induction ls.
simpl.
intros.

*****
h' : hlist ls'
h : hlist nil
ls' : list iT
eqvOk : forall x : iT, typeOk@{Uv} (eqv x)
eqv : forall x : iT, type@{Uv} (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
eq (pair Hnil (hlist_app h h')) (pair h h')
+++++
rewrite (hlist_eta h).
-----
Lemma hlist_split_hlist_app : forall ls' ls (h : hlist ls) (h' : hlist ls'), hlist_split _ _ (hlist_app h h') = (h,h').
Proof.
induction ls.
simpl.
intros.
rewrite (hlist_eta h).

*****
h' : hlist ls'
h : hlist nil
ls' : list iT
eqvOk : forall x : iT, typeOk@{Uv} (eqv x)
eqv : forall x : iT, type@{Uv} (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
eq (pair Hnil (hlist_app Hnil h')) (pair Hnil h')
+++++
simpl.
-----
Lemma hlist_split_hlist_app : forall ls' ls (h : hlist ls) (h' : hlist ls'), hlist_split _ _ (hlist_app h h') = (h,h').
Proof.
induction ls.
simpl.
intros.
rewrite (hlist_eta h).
simpl.

*****
h' : hlist ls'
h : hlist nil
ls' : list iT
eqvOk : forall x : iT, typeOk@{Uv} (eqv x)
eqv : forall x : iT, type@{Uv} (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
eq (pair Hnil h') (pair Hnil h')
+++++
auto.
-----
Lemma hlist_split_hlist_app : forall ls' ls (h : hlist ls) (h' : hlist ls'), hlist_split _ _ (hlist_app h h') = (h,h').
Proof.
induction ls.

*****
IHls : forall (h : hlist ls) (h' : hlist ls'),\neq (hlist_split ls ls' (hlist_app h h')) (pair h h')
ls : list iT
a : iT
ls' : list iT
eqvOk : forall x : iT, typeOk@{Uv} (eqv x)
eqv : forall x : iT, type@{Uv} (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall (h : hlist (cons a ls)) (h' : hlist ls'), eq (hlist_split (cons a ls) ls' (hlist_app h h')) (pair h h')
+++++
simpl.
-----
Lemma hlist_split_hlist_app : forall ls' ls (h : hlist ls) (h' : hlist ls'), hlist_split _ _ (hlist_app h h') = (h,h').
Proof.
induction ls.
simpl.

*****
IHls : forall (h : hlist ls) (h' : hlist ls'),\neq (hlist_split ls ls' (hlist_app h h')) (pair h h')
ls : list iT
a : iT
ls' : list iT
eqvOk : forall x : iT, typeOk@{Uv} (eqv x)
eqv : forall x : iT, type@{Uv} (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall (h : hlist (cons a ls)) (h' : hlist ls'), eq (let (a0, b) := hlist_split ls ls' (hlist_tl (hlist_app h h')) in pair (Hcons (hlist_hd (hlist_app h h')) a0) b) (pair h h')
+++++
intros.
-----
Lemma hlist_split_hlist_app : forall ls' ls (h : hlist ls) (h' : hlist ls'), hlist_split _ _ (hlist_app h h') = (h,h').
Proof.
induction ls.
simpl.
intros.

*****
h' : hlist ls'
h : hlist (cons a ls)
IHls : forall (h : hlist ls) (h' : hlist ls'),\neq (hlist_split ls ls' (hlist_app h h')) (pair h h')
ls : list iT
a : iT
ls' : list iT
eqvOk : forall x : iT, typeOk@{Uv} (eqv x)
eqv : forall x : iT, type@{Uv} (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
eq (let (a0, b) := hlist_split ls ls' (hlist_tl (hlist_app h h')) in pair (Hcons (hlist_hd (hlist_app h h')) a0) b) (pair h h')
+++++
rewrite (hlist_eta h).
-----
Lemma hlist_split_hlist_app : forall ls' ls (h : hlist ls) (h' : hlist ls'), hlist_split _ _ (hlist_app h h') = (h,h').
Proof.
induction ls.
simpl.
intros.
rewrite (hlist_eta h).

*****
h' : hlist ls'
h : hlist (cons a ls)
IHls : forall (h : hlist ls) (h' : hlist ls'),\neq (hlist_split ls ls' (hlist_app h h')) (pair h h')
ls : list iT
a : iT
ls' : list iT
eqvOk : forall x : iT, typeOk@{Uv} (eqv x)
eqv : forall x : iT, type@{Uv} (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
eq (let (a0, b) := hlist_split ls ls' (hlist_tl (hlist_app (Hcons (hlist_hd h) (hlist_tl h)) h')) in pair (Hcons (hlist_hd (hlist_app (Hcons (hlist_hd h) (hlist_tl h)) h')) a0) b) (pair (Hcons (hlist_hd h) (hlist_tl h)) h')
+++++
simpl.
-----
Lemma hlist_split_hlist_app : forall ls' ls (h : hlist ls) (h' : hlist ls'), hlist_split _ _ (hlist_app h h') = (h,h').
Proof.
induction ls.
simpl.
intros.
rewrite (hlist_eta h).
simpl.

*****
h' : hlist ls'
h : hlist (cons a ls)
IHls : forall (h : hlist ls) (h' : hlist ls'),\neq (hlist_split ls ls' (hlist_app h h')) (pair h h')
ls : list iT
a : iT
ls' : list iT
eqvOk : forall x : iT, typeOk@{Uv} (eqv x)
eqv : forall x : iT, type@{Uv} (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
eq (let (a0, b) := hlist_split ls ls' (hlist_app (hlist_tl h) h') in pair (Hcons (hlist_hd h) a0) b) (pair (Hcons (hlist_hd h) (hlist_tl h)) h')
+++++
rewrite IHls.
-----
Lemma hlist_split_hlist_app : forall ls' ls (h : hlist ls) (h' : hlist ls'), hlist_split _ _ (hlist_app h h') = (h,h').
Proof.
induction ls.
simpl.
intros.
rewrite (hlist_eta h).
simpl.
rewrite IHls.

*****
h' : hlist ls'
h : hlist (cons a ls)
IHls : forall (h : hlist ls) (h' : hlist ls'),\neq (hlist_split ls ls' (hlist_app h h')) (pair h h')
ls : list iT
a : iT
ls' : list iT
eqvOk : forall x : iT, typeOk@{Uv} (eqv x)
eqv : forall x : iT, type@{Uv} (F x)
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
eq (pair (Hcons (hlist_hd h) (hlist_tl h)) h') (pair (Hcons (hlist_hd h) (hlist_tl h)) h')
+++++
reflexivity.
-----
Lemma hlist_split_hlist_app : forall ls' ls (h : hlist ls) (h' : hlist ls'), hlist_split _ _ (hlist_app h h') = (h,h').
Proof.
induction ls.

*****

*****

+++++
Qed.
-----
End type.
-----
Lemma hlist_hd_fst_hlist_split\n  : forall t (xs ys : list _) (h : hlist (t :: xs ++ ys)),\n      hlist_hd (fst (hlist_split (t :: xs) ys h)) = hlist_hd h.
-----
Lemma hlist_hd_fst_hlist_split : forall t (xs ys : list _) (h : hlist (t :: xs ++ ys)), hlist_hd (fst (hlist_split (t :: xs) ys h)) = hlist_hd h.

*****
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall (t : iT) (xs ys : list iT) (h : hlist (cons t (app xs ys))), eq (hlist_hd (fst (hlist_split (cons t xs) ys h))) (hlist_hd h)
+++++
Proof.
-----
Lemma hlist_hd_fst_hlist_split : forall t (xs ys : list _) (h : hlist (t :: xs ++ ys)), hlist_hd (fst (hlist_split (t :: xs) ys h)) = hlist_hd h.
Proof.

*****
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall (t : iT) (xs ys : list iT) (h : hlist (cons t (app xs ys))), eq (hlist_hd (fst (hlist_split (cons t xs) ys h))) (hlist_hd h)
+++++
simpl.
-----
Lemma hlist_hd_fst_hlist_split : forall t (xs ys : list _) (h : hlist (t :: xs ++ ys)), hlist_hd (fst (hlist_split (t :: xs) ys h)) = hlist_hd h.
Proof.
simpl.

*****
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall (t : iT) (xs ys : list iT) (h : hlist (cons t (app xs ys))), eq (hlist_hd (fst (let (a, b) := hlist_split xs ys (hlist_tl h) in pair (Hcons (hlist_hd h) a) b))) (hlist_hd h)
+++++
intros.
-----
Lemma hlist_hd_fst_hlist_split : forall t (xs ys : list _) (h : hlist (t :: xs ++ ys)), hlist_hd (fst (hlist_split (t :: xs) ys h)) = hlist_hd h.
Proof.
simpl.
intros.

*****
h : hlist (cons t (app xs ys))
xs,ys : list iT
t : iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
eq (hlist_hd (fst (let (a, b) := hlist_split xs ys (hlist_tl h) in pair (Hcons (hlist_hd h) a) b))) (hlist_hd h)
+++++
match goal with | |- context [ match ?X with _ => _ end ] => destruct X end.
-----
Lemma hlist_hd_fst_hlist_split : forall t (xs ys : list _) (h : hlist (t :: xs ++ ys)), hlist_hd (fst (hlist_split (t :: xs) ys h)) = hlist_hd h.
Proof.
simpl.
intros.
match goal with | |- context [ match ?X with _ => _ end ] => destruct X end.

*****
h1 : hlist ys
h0 : hlist xs
h : hlist (cons t (app xs ys))
xs,ys : list iT
t : iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
eq (hlist_hd (fst (pair (Hcons (hlist_hd h) h0) h1))) (hlist_hd h)
+++++
reflexivity.
-----
Lemma hlist_hd_fst_hlist_split : forall t (xs ys : list _) (h : hlist (t :: xs ++ ys)), hlist_hd (fst (hlist_split (t :: xs) ys h)) = hlist_hd h.
Proof.
simpl.
intros.
match goal with | |- context [ match ?X with _ => _ end ] => destruct X end.
reflexivity.

*****

*****

+++++
Qed.
-----
Lemma hlist_tl_fst_hlist_split\n  : forall t (xs ys : list _) (h : hlist (t :: xs ++ ys)),\n      hlist_tl (fst (hlist_split (t :: xs) ys h)) =\n      fst (hlist_split xs ys (hlist_tl h)).
-----
Lemma hlist_tl_fst_hlist_split : forall t (xs ys : list _) (h : hlist (t :: xs ++ ys)), hlist_tl (fst (hlist_split (t :: xs) ys h)) = fst (hlist_split xs ys (hlist_tl h)).

*****
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall (t : iT) (xs ys : list iT) (h : hlist (cons t (app xs ys))), eq (hlist_tl (fst (hlist_split (cons t xs) ys h))) (fst (hlist_split xs ys (hlist_tl h)))
+++++
Proof.
-----
Lemma hlist_tl_fst_hlist_split : forall t (xs ys : list _) (h : hlist (t :: xs ++ ys)), hlist_tl (fst (hlist_split (t :: xs) ys h)) = fst (hlist_split xs ys (hlist_tl h)).
Proof.

*****
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall (t : iT) (xs ys : list iT) (h : hlist (cons t (app xs ys))), eq (hlist_tl (fst (hlist_split (cons t xs) ys h))) (fst (hlist_split xs ys (hlist_tl h)))
+++++
simpl.
-----
Lemma hlist_tl_fst_hlist_split : forall t (xs ys : list _) (h : hlist (t :: xs ++ ys)), hlist_tl (fst (hlist_split (t :: xs) ys h)) = fst (hlist_split xs ys (hlist_tl h)).
Proof.
simpl.

*****
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall (t : iT) (xs ys : list iT) (h : hlist (cons t (app xs ys))), eq (hlist_tl (fst (let (a, b) := hlist_split xs ys (hlist_tl h) in pair (Hcons (hlist_hd h) a) b))) (fst (hlist_split xs ys (hlist_tl h)))
+++++
intros.
-----
Lemma hlist_tl_fst_hlist_split : forall t (xs ys : list _) (h : hlist (t :: xs ++ ys)), hlist_tl (fst (hlist_split (t :: xs) ys h)) = fst (hlist_split xs ys (hlist_tl h)).
Proof.
simpl.
intros.

*****
h : hlist (cons t (app xs ys))
xs,ys : list iT
t : iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
eq (hlist_tl (fst (let (a, b) := hlist_split xs ys (hlist_tl h) in pair (Hcons (hlist_hd h) a) b))) (fst (hlist_split xs ys (hlist_tl h)))
+++++
match goal with | |- context [ match ?X with _ => _ end ] => remember X end.
-----
Lemma hlist_tl_fst_hlist_split : forall t (xs ys : list _) (h : hlist (t :: xs ++ ys)), hlist_tl (fst (hlist_split (t :: xs) ys h)) = fst (hlist_split xs ys (hlist_tl h)).
Proof.
simpl.
intros.
match goal with | |- context [ match ?X with _ => _ end ] => remember X end.

*****
Heqp : eq p (hlist_split xs ys (hlist_tl h))
p : prod (hlist xs) (hlist ys)
h : hlist (cons t (app xs ys))
xs,ys : list iT
t : iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
eq (hlist_tl (fst (let (a, b) := p in pair (Hcons (hlist_hd h) a) b))) (fst (hlist_split xs ys (hlist_tl h)))
+++++
destruct p.
-----
Lemma hlist_tl_fst_hlist_split : forall t (xs ys : list _) (h : hlist (t :: xs ++ ys)), hlist_tl (fst (hlist_split (t :: xs) ys h)) = fst (hlist_split xs ys (hlist_tl h)).
Proof.
simpl.
intros.
match goal with | |- context [ match ?X with _ => _ end ] => remember X end.
destruct p.

*****
Heqp : eq (pair h0 h1) (hlist_split xs ys (hlist_tl h))
h1 : hlist ys
h0 : hlist xs
h : hlist (cons t (app xs ys))
xs,ys : list iT
t : iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
eq (hlist_tl (fst (pair (Hcons (hlist_hd h) h0) h1))) (fst (hlist_split xs ys (hlist_tl h)))
+++++
simpl.
-----
Lemma hlist_tl_fst_hlist_split : forall t (xs ys : list _) (h : hlist (t :: xs ++ ys)), hlist_tl (fst (hlist_split (t :: xs) ys h)) = fst (hlist_split xs ys (hlist_tl h)).
Proof.
simpl.
intros.
match goal with | |- context [ match ?X with _ => _ end ] => remember X end.
destruct p.
simpl.

*****
Heqp : eq (pair h0 h1) (hlist_split xs ys (hlist_tl h))
h1 : hlist ys
h0 : hlist xs
h : hlist (cons t (app xs ys))
xs,ys : list iT
t : iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
eq h0 (fst (hlist_split xs ys (hlist_tl h)))
+++++
change h0 with (fst (h0, h1)).
-----
Lemma hlist_tl_fst_hlist_split : forall t (xs ys : list _) (h : hlist (t :: xs ++ ys)), hlist_tl (fst (hlist_split (t :: xs) ys h)) = fst (hlist_split xs ys (hlist_tl h)).
Proof.
simpl.
intros.
match goal with | |- context [ match ?X with _ => _ end ] => remember X end.
destruct p.
simpl.
change h0 with (fst (h0, h1)).

*****
Heqp : eq (pair h0 h1) (hlist_split xs ys (hlist_tl h))
h1 : hlist ys
h0 : hlist xs
h : hlist (cons t (app xs ys))
xs,ys : list iT
t : iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
eq (fst (pair h0 h1)) (fst (hlist_split xs ys (hlist_tl h)))
+++++
f_equal.
-----
Lemma hlist_tl_fst_hlist_split : forall t (xs ys : list _) (h : hlist (t :: xs ++ ys)), hlist_tl (fst (hlist_split (t :: xs) ys h)) = fst (hlist_split xs ys (hlist_tl h)).
Proof.
simpl.
intros.
match goal with | |- context [ match ?X with _ => _ end ] => remember X end.
destruct p.
simpl.
change h0 with (fst (h0, h1)).
f_equal.

*****
Heqp : eq (pair h0 h1) (hlist_split xs ys (hlist_tl h))
h1 : hlist ys
h0 : hlist xs
h : hlist (cons t (app xs ys))
xs,ys : list iT
t : iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
eq (pair h0 h1) (hlist_split xs ys (hlist_tl h))
+++++
trivial.
-----
Lemma hlist_tl_fst_hlist_split : forall t (xs ys : list _) (h : hlist (t :: xs ++ ys)), hlist_tl (fst (hlist_split (t :: xs) ys h)) = fst (hlist_split xs ys (hlist_tl h)).
Proof.
simpl.
intros.
match goal with | |- context [ match ?X with _ => _ end ] => remember X end.
destruct p.
simpl.
change h0 with (fst (h0, h1)).
f_equal.
trivial.

*****

*****

+++++
Qed.
-----
Lemma hlist_tl_snd_hlist_split\n  : forall t (xs ys : list _) (h : hlist (t :: xs ++ ys)),\n      snd (hlist_split xs ys (hlist_tl h)) =\n      snd (hlist_split (t :: xs) ys h).
-----
Lemma hlist_tl_snd_hlist_split : forall t (xs ys : list _) (h : hlist (t :: xs ++ ys)), snd (hlist_split xs ys (hlist_tl h)) = snd (hlist_split (t :: xs) ys h).

*****
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall (t : iT) (xs ys : list iT) (h : hlist (cons t (app xs ys))), eq (snd (hlist_split xs ys (hlist_tl h))) (snd (hlist_split (cons t xs) ys h))
+++++
Proof.
-----
Lemma hlist_tl_snd_hlist_split : forall t (xs ys : list _) (h : hlist (t :: xs ++ ys)), snd (hlist_split xs ys (hlist_tl h)) = snd (hlist_split (t :: xs) ys h).
Proof.

*****
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall (t : iT) (xs ys : list iT) (h : hlist (cons t (app xs ys))), eq (snd (hlist_split xs ys (hlist_tl h))) (snd (hlist_split (cons t xs) ys h))
+++++
simpl.
-----
Lemma hlist_tl_snd_hlist_split : forall t (xs ys : list _) (h : hlist (t :: xs ++ ys)), snd (hlist_split xs ys (hlist_tl h)) = snd (hlist_split (t :: xs) ys h).
Proof.
simpl.

*****
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall (t : iT) (xs ys : list iT) (h : hlist (cons t (app xs ys))), eq (snd (hlist_split xs ys (hlist_tl h))) (snd (let (a, b) := hlist_split xs ys (hlist_tl h) in pair (Hcons (hlist_hd h) a) b))
+++++
intros.
-----
Lemma hlist_tl_snd_hlist_split : forall t (xs ys : list _) (h : hlist (t :: xs ++ ys)), snd (hlist_split xs ys (hlist_tl h)) = snd (hlist_split (t :: xs) ys h).
Proof.
simpl.
intros.

*****
h : hlist (cons t (app xs ys))
xs,ys : list iT
t : iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
eq (snd (hlist_split xs ys (hlist_tl h))) (snd (let (a, b) := hlist_split xs ys (hlist_tl h) in pair (Hcons (hlist_hd h) a) b))
+++++
match goal with | |- context [ match ?X with _ => _ end ] => remember X end.
-----
Lemma hlist_tl_snd_hlist_split : forall t (xs ys : list _) (h : hlist (t :: xs ++ ys)), snd (hlist_split xs ys (hlist_tl h)) = snd (hlist_split (t :: xs) ys h).
Proof.
simpl.
intros.
match goal with | |- context [ match ?X with _ => _ end ] => remember X end.

*****
Heqp : eq p (hlist_split xs ys (hlist_tl h))
p : prod (hlist xs) (hlist ys)
h : hlist (cons t (app xs ys))
xs,ys : list iT
t : iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
eq (snd (hlist_split xs ys (hlist_tl h))) (snd (let (a, b) := p in pair (Hcons (hlist_hd h) a) b))
+++++
destruct p.
-----
Lemma hlist_tl_snd_hlist_split : forall t (xs ys : list _) (h : hlist (t :: xs ++ ys)), snd (hlist_split xs ys (hlist_tl h)) = snd (hlist_split (t :: xs) ys h).
Proof.
simpl.
intros.
match goal with | |- context [ match ?X with _ => _ end ] => remember X end.
destruct p.

*****
Heqp : eq (pair h0 h1) (hlist_split xs ys (hlist_tl h))
h1 : hlist ys
h0 : hlist xs
h : hlist (cons t (app xs ys))
xs,ys : list iT
t : iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
eq (snd (hlist_split xs ys (hlist_tl h))) (snd (pair (Hcons (hlist_hd h) h0) h1))
+++++
simpl.
-----
Lemma hlist_tl_snd_hlist_split : forall t (xs ys : list _) (h : hlist (t :: xs ++ ys)), snd (hlist_split xs ys (hlist_tl h)) = snd (hlist_split (t :: xs) ys h).
Proof.
simpl.
intros.
match goal with | |- context [ match ?X with _ => _ end ] => remember X end.
destruct p.
simpl.

*****
Heqp : eq (pair h0 h1) (hlist_split xs ys (hlist_tl h))
h1 : hlist ys
h0 : hlist xs
h : hlist (cons t (app xs ys))
xs,ys : list iT
t : iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
eq (snd (hlist_split xs ys (hlist_tl h))) h1
+++++
change h1 with (snd (h0, h1)).
-----
Lemma hlist_tl_snd_hlist_split : forall t (xs ys : list _) (h : hlist (t :: xs ++ ys)), snd (hlist_split xs ys (hlist_tl h)) = snd (hlist_split (t :: xs) ys h).
Proof.
simpl.
intros.
match goal with | |- context [ match ?X with _ => _ end ] => remember X end.
destruct p.
simpl.
change h1 with (snd (h0, h1)).

*****
Heqp : eq (pair h0 h1) (hlist_split xs ys (hlist_tl h))
h1 : hlist ys
h0 : hlist xs
h : hlist (cons t (app xs ys))
xs,ys : list iT
t : iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
eq (snd (hlist_split xs ys (hlist_tl h))) (snd (pair h0 h1))
+++++
rewrite Heqp.
-----
Lemma hlist_tl_snd_hlist_split : forall t (xs ys : list _) (h : hlist (t :: xs ++ ys)), snd (hlist_split xs ys (hlist_tl h)) = snd (hlist_split (t :: xs) ys h).
Proof.
simpl.
intros.
match goal with | |- context [ match ?X with _ => _ end ] => remember X end.
destruct p.
simpl.
change h1 with (snd (h0, h1)).
rewrite Heqp.

*****
Heqp : eq (pair h0 h1) (hlist_split xs ys (hlist_tl h))
h1 : hlist ys
h0 : hlist xs
h : hlist (cons t (app xs ys))
xs,ys : list iT
t : iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
eq (snd (hlist_split xs ys (hlist_tl h))) (snd (hlist_split xs ys (hlist_tl h)))
+++++
reflexivity.
-----
Lemma hlist_tl_snd_hlist_split : forall t (xs ys : list _) (h : hlist (t :: xs ++ ys)), snd (hlist_split xs ys (hlist_tl h)) = snd (hlist_split (t :: xs) ys h).
Proof.
simpl.
intros.
match goal with | |- context [ match ?X with _ => _ end ] => remember X end.
destruct p.
simpl.
change h1 with (snd (h0, h1)).
rewrite Heqp.
reflexivity.

*****

*****

+++++
Qed.
-----
Polymorphic Fixpoint nth_error_get_hlist_nth (ls : list iT) (n : nat) {struct ls} :\n    option {t : iT & hlist ls -> F t} :=\n    match\n      ls as ls0\n      return option {t : iT & hlist ls0 -> F t}\n    with\n      | nil => None\n      | l :: ls0 =>\n        match\n          n as n0\n          return option {t : iT & hlist (l :: ls0) -> F t}\n        with\n          | 0 =>\n            Some (@existT _ (fun t => hlist (l :: ls0) -> F t)\n                          l (@hlist_hd _ _))\n          | S n0 =>\n            match nth_error_get_hlist_nth ls0 n0 with\n              | Some (existT x f) =>\n                Some (@existT _ (fun t => hlist _ -> F t)\n                              x (fun h : hlist (l :: ls0) => f (hlist_tl h)))\n              | None => None\n            end\n        end\n    end.
-----
Theorem nth_error_get_hlist_nth_Some\n    : forall ls n s,\n      nth_error_get_hlist_nth ls n = Some s ->\n      exists pf : nth_error ls n = Some (projT1 s),\n      forall h, projT2 s h = match pf in _ = t\n                                   return match t return Type with\n                                            | Some t => F t\n                                            | None => unit\n                                          end\n                             with\n                               | eq_refl => hlist_nth h n\n                             end.
-----
Theorem nth_error_get_hlist_nth_Some : forall ls n s, nth_error_get_hlist_nth ls n = Some s -> exists pf : nth_error ls n = Some (projT1 s), forall h, projT2 s h = match pf in _ = t return match t return Type with | Some t => F t | None => unit end with | eq_refl => hlist_nth h n end.

*****
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall (ls : list iT) (n : nat) (s : sigT (fun t : iT => forall _ : hlist ls, F t)) (_ : eq (nth_error_get_hlist_nth ls n) (Some s)), ex (fun pf : eq (nth_error ls n) (Some (projT1 s)) => forall h : hlist ls, eq (projT2 s h) match pf in (eq _ t) return match t with | Some t0 => F t0 | None => unit end with | eq_refl => hlist_nth@{SerTop.270} h n end)
+++++
Proof.
-----
Theorem nth_error_get_hlist_nth_Some : forall ls n s, nth_error_get_hlist_nth ls n = Some s -> exists pf : nth_error ls n = Some (projT1 s), forall h, projT2 s h = match pf in _ = t return match t return Type with | Some t => F t | None => unit end with | eq_refl => hlist_nth h n end.
Proof.

*****
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall (ls : list iT) (n : nat) (s : sigT (fun t : iT => forall _ : hlist ls, F t)) (_ : eq (nth_error_get_hlist_nth ls n) (Some s)), ex (fun pf : eq (nth_error ls n) (Some (projT1 s)) => forall h : hlist ls, eq (projT2 s h) match pf in (eq _ t) return match t with | Some t0 => F t0 | None => unit end with | eq_refl => hlist_nth@{SerTop.270} h n end)
+++++
induction ls.
-----
Theorem nth_error_get_hlist_nth_Some : forall ls n s, nth_error_get_hlist_nth ls n = Some s -> exists pf : nth_error ls n = Some (projT1 s), forall h, projT2 s h = match pf in _ = t return match t return Type with | Some t => F t | None => unit end with | eq_refl => hlist_nth h n end.
Proof.
induction ls.

*****
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall (n : nat) (s : sigT (fun t : iT => forall _ : hlist nil, F t)) (_ : eq (nth_error_get_hlist_nth nil n) (Some s)), ex (fun pf : eq (nth_error nil n) (Some (projT1 s)) => forall h : hlist nil, eq (projT2 s h) match pf in (eq _ t) return match t with | Some t0 => F t0 | None => unit end with | eq_refl => hlist_nth@{SerTop.270} h n end)
+++++
simpl.
-----
Theorem nth_error_get_hlist_nth_Some : forall ls n s, nth_error_get_hlist_nth ls n = Some s -> exists pf : nth_error ls n = Some (projT1 s), forall h, projT2 s h = match pf in _ = t return match t return Type with | Some t => F t | None => unit end with | eq_refl => hlist_nth h n end.
Proof.
induction ls.
simpl.

*****
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall (n : nat) (s : sigT (fun t : iT => forall _ : hlist nil, F t)) (_ : eq None (Some s)), ex (fun pf : eq (nth_error nil n) (Some (projT1 s)) => forall h : hlist nil, eq (projT2 s h) match pf in (eq _ t) return match t with | Some t0 => F t0 | None => unit end with | eq_refl => hlist_nth@{SerTop.270} h n end)
+++++
intros.
-----
Theorem nth_error_get_hlist_nth_Some : forall ls n s, nth_error_get_hlist_nth ls n = Some s -> exists pf : nth_error ls n = Some (projT1 s), forall h, projT2 s h = match pf in _ = t return match t return Type with | Some t => F t | None => unit end with | eq_refl => hlist_nth h n end.
Proof.
induction ls.
simpl.
intros.

*****
H : eq None (Some s)
s : sigT (fun t : iT => forall _ : hlist nil, F t)
n : nat
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
ex (fun pf : eq (nth_error nil n) (Some (projT1 s)) => forall h : hlist nil, eq (projT2 s h) match pf in (eq _ t) return match t with | Some t0 => F t0 | None => unit end with | eq_refl => hlist_nth@{SerTop.270} h n end)
+++++
try congruence.
-----
Theorem nth_error_get_hlist_nth_Some : forall ls n s, nth_error_get_hlist_nth ls n = Some s -> exists pf : nth_error ls n = Some (projT1 s), forall h, projT2 s h = match pf in _ = t return match t return Type with | Some t => F t | None => unit end with | eq_refl => hlist_nth h n end.
Proof.
induction ls.

*****
IHls : forall (n : nat) (s : sigT (fun t : iT => forall _ : hlist ls, F t))\n (_ : eq (nth_error_get_hlist_nth ls n) (Some s)),\nex\n (fun pf : eq (nth_error ls n) (Some (projT1 s)) =>\n forall h : hlist ls,\n eq (projT2 s h)\n match\n pf in (eq _ t)\n return match t with\n | Some t0 => F t0\n | None => unit\n end\n with\n | eq_refl => hlist_nth@{SerTop.270} h n\n end)
ls : list iT
a : iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall (n : nat) (s : sigT (fun t : iT => forall _ : hlist (cons a ls), F t)) (_ : eq (nth_error_get_hlist_nth (cons a ls) n) (Some s)), ex (fun pf : eq (nth_error (cons a ls) n) (Some (projT1 s)) => forall h : hlist (cons a ls), eq (projT2 s h) match pf in (eq _ t) return match t with | Some t0 => F t0 | None => unit end with | eq_refl => hlist_nth@{SerTop.270} h n end)
+++++
simpl.
-----
Theorem nth_error_get_hlist_nth_Some : forall ls n s, nth_error_get_hlist_nth ls n = Some s -> exists pf : nth_error ls n = Some (projT1 s), forall h, projT2 s h = match pf in _ = t return match t return Type with | Some t => F t | None => unit end with | eq_refl => hlist_nth h n end.
Proof.
induction ls.
simpl.

*****
IHls : forall (n : nat) (s : sigT (fun t : iT => forall _ : hlist ls, F t))\n (_ : eq (nth_error_get_hlist_nth ls n) (Some s)),\nex\n (fun pf : eq (nth_error ls n) (Some (projT1 s)) =>\n forall h : hlist ls,\n eq (projT2 s h)\n match\n pf in (eq _ t)\n return match t with\n | Some t0 => F t0\n | None => unit\n end\n with\n | eq_refl => hlist_nth@{SerTop.270} h n\n end)
ls : list iT
a : iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall (n : nat) (s : sigT (fun t : iT => forall _ : hlist (cons a ls), F t)) (_ : eq match n with | O => Some (existT (fun t : iT => forall _ : hlist (cons a ls), F t) a hlist_hd) | S n0 => match nth_error_get_hlist_nth ls n0 with | Some (@existT _ _ x f) => Some (existT (fun t : iT => forall _ : hlist (cons a ls), F t) x (fun h : hlist (cons a ls) => f (hlist_tl h))) | None => None end end (Some s)), ex (fun pf : eq (nth_error (cons a ls) n) (Some (projT1 s)) => forall h : hlist (cons a ls), eq (projT2 s h) match pf in (eq _ t) return match t with | Some t0 => F t0 | None => unit end with | eq_refl => hlist_nth@{SerTop.270} h n end)
+++++
intros.
-----
Theorem nth_error_get_hlist_nth_Some : forall ls n s, nth_error_get_hlist_nth ls n = Some s -> exists pf : nth_error ls n = Some (projT1 s), forall h, projT2 s h = match pf in _ = t return match t return Type with | Some t => F t | None => unit end with | eq_refl => hlist_nth h n end.
Proof.
induction ls.
simpl.
intros.

*****
H : eq\n match n with\n | O =>\n Some\n (existT (fun t : iT => forall _ : hlist (cons a ls), F t) a\n hlist_hd)\n | S n0 =>\n match nth_error_get_hlist_nth ls n0 with\n | Some (@existT _ _ x f) =>\n Some\n (existT (fun t : iT => forall _ : hlist (cons a ls), F t) x\n (fun h : hlist (cons a ls) => f (hlist_tl h)))\n | None => None\n end\n end (Some s)
s : sigT (fun t : iT => forall _ : hlist (cons a ls), F t)
n : nat
IHls : forall (n : nat) (s : sigT (fun t : iT => forall _ : hlist ls, F t))\n (_ : eq (nth_error_get_hlist_nth ls n) (Some s)),\nex\n (fun pf : eq (nth_error ls n) (Some (projT1 s)) =>\n forall h : hlist ls,\n eq (projT2 s h)\n match\n pf in (eq _ t)\n return match t with\n | Some t0 => F t0\n | None => unit\n end\n with\n | eq_refl => hlist_nth@{SerTop.270} h n\n end)
ls : list iT
a : iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
ex (fun pf : eq (nth_error (cons a ls) n) (Some (projT1 s)) => forall h : hlist (cons a ls), eq (projT2 s h) match pf in (eq _ t) return match t with | Some t0 => F t0 | None => unit end with | eq_refl => hlist_nth@{SerTop.270} h n end)
+++++
try congruence.
-----
Theorem nth_error_get_hlist_nth_Some : forall ls n s, nth_error_get_hlist_nth ls n = Some s -> exists pf : nth_error ls n = Some (projT1 s), forall h, projT2 s h = match pf in _ = t return match t return Type with | Some t => F t | None => unit end with | eq_refl => hlist_nth h n end.
Proof.
induction ls.
simpl.
intros.
try congruence.

*****
H : eq\n match n with\n | O =>\n Some\n (existT (fun t : iT => forall _ : hlist (cons a ls), F t) a\n hlist_hd)\n | S n0 =>\n match nth_error_get_hlist_nth ls n0 with\n | Some (@existT _ _ x f) =>\n Some\n (existT (fun t : iT => forall _ : hlist (cons a ls), F t) x\n (fun h : hlist (cons a ls) => f (hlist_tl h)))\n | None => None\n end\n end (Some s)
s : sigT (fun t : iT => forall _ : hlist (cons a ls), F t)
n : nat
IHls : forall (n : nat) (s : sigT (fun t : iT => forall _ : hlist ls, F t))\n (_ : eq (nth_error_get_hlist_nth ls n) (Some s)),\nex\n (fun pf : eq (nth_error ls n) (Some (projT1 s)) =>\n forall h : hlist ls,\n eq (projT2 s h)\n match\n pf in (eq _ t)\n return match t with\n | Some t0 => F t0\n | None => unit\n end\n with\n | eq_refl => hlist_nth@{SerTop.270} h n\n end)
ls : list iT
a : iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
ex (fun pf : eq (nth_error (cons a ls) n) (Some (projT1 s)) => forall h : hlist (cons a ls), eq (projT2 s h) match pf in (eq _ t) return match t with | Some t0 => F t0 | None => unit end with | eq_refl => hlist_nth@{SerTop.270} h n end)
+++++
destruct n.
-----
Theorem nth_error_get_hlist_nth_Some : forall ls n s, nth_error_get_hlist_nth ls n = Some s -> exists pf : nth_error ls n = Some (projT1 s), forall h, projT2 s h = match pf in _ = t return match t return Type with | Some t => F t | None => unit end with | eq_refl => hlist_nth h n end.
Proof.
induction ls.
simpl.
intros.
try congruence.
destruct n.

*****
H : eq\n (Some\n (existT (fun t : iT => forall _ : hlist (cons a ls), F t) a\n hlist_hd)) (Some s)
s : sigT (fun t : iT => forall _ : hlist (cons a ls), F t)
IHls : forall (n : nat) (s : sigT (fun t : iT => forall _ : hlist ls, F t))\n (_ : eq (nth_error_get_hlist_nth ls n) (Some s)),\nex\n (fun pf : eq (nth_error ls n) (Some (projT1 s)) =>\n forall h : hlist ls,\n eq (projT2 s h)\n match\n pf in (eq _ t)\n return match t with\n | Some t0 => F t0\n | None => unit\n end\n with\n | eq_refl => hlist_nth@{SerTop.270} h n\n end)
ls : list iT
a : iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
ex (fun pf : eq (nth_error (cons a ls) O) (Some (projT1 s)) => forall h : hlist (cons a ls), eq (projT2 s h) match pf in (eq _ t) return match t with | Some t0 => F t0 | None => unit end with | eq_refl => hlist_nth@{SerTop.270} h O end)
+++++
inv_all.
-----
Theorem nth_error_get_hlist_nth_Some : forall ls n s, nth_error_get_hlist_nth ls n = Some s -> exists pf : nth_error ls n = Some (projT1 s), forall h, projT2 s h = match pf in _ = t return match t return Type with | Some t => F t | None => unit end with | eq_refl => hlist_nth h n end.
Proof.
induction ls.
simpl.
intros.
try congruence.
destruct n.
inv_all.

*****
H : eq\n (existT (fun t : iT => forall _ : hlist (cons a ls), F t) a hlist_hd)\n s
s : sigT (fun t : iT => forall _ : hlist (cons a ls), F t)
IHls : forall (n : nat) (s : sigT (fun t : iT => forall _ : hlist ls, F t))\n (_ : eq (nth_error_get_hlist_nth ls n) (Some s)),\nex\n (fun pf : eq (nth_error ls n) (Some (projT1 s)) =>\n forall h : hlist ls,\n eq (projT2 s h)\n match\n pf in (eq _ t)\n return match t with\n | Some t0 => F t0\n | None => unit\n end\n with\n | eq_refl => hlist_nth@{SerTop.270} h n\n end)
ls : list iT
a : iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
ex (fun pf : eq (nth_error (cons a ls) O) (Some (projT1 s)) => forall h : hlist (cons a ls), eq (projT2 s h) match pf in (eq _ t) return match t with | Some t0 => F t0 | None => unit end with | eq_refl => hlist_nth@{SerTop.270} h O end)
+++++
subst.
-----
Theorem nth_error_get_hlist_nth_Some : forall ls n s, nth_error_get_hlist_nth ls n = Some s -> exists pf : nth_error ls n = Some (projT1 s), forall h, projT2 s h = match pf in _ = t return match t return Type with | Some t => F t | None => unit end with | eq_refl => hlist_nth h n end.
Proof.
induction ls.
simpl.
intros.
try congruence.
destruct n.
inv_all.
subst.

*****
IHls : forall (n : nat) (s : sigT (fun t : iT => forall _ : hlist ls, F t))\n (_ : eq (nth_error_get_hlist_nth ls n) (Some s)),\nex\n (fun pf : eq (nth_error ls n) (Some (projT1 s)) =>\n forall h : hlist ls,\n eq (projT2 s h)\n match\n pf in (eq _ t)\n return match t with\n | Some t0 => F t0\n | None => unit\n end\n with\n | eq_refl => hlist_nth@{SerTop.270} h n\n end)
ls : list iT
a : iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
ex (fun pf : eq (nth_error (cons a ls) O) (Some (projT1 (existT (fun t : iT => forall _ : hlist (cons a ls), F t) a hlist_hd))) => forall h : hlist (cons a ls), eq (projT2 (existT (fun t : iT => forall _ : hlist (cons a ls), F t) a hlist_hd) h) match pf in (eq _ t) return match t with | Some t0 => F t0 | None => unit end with | eq_refl => hlist_nth@{SerTop.270} h O end)
+++++
simpl.
-----
Theorem nth_error_get_hlist_nth_Some : forall ls n s, nth_error_get_hlist_nth ls n = Some s -> exists pf : nth_error ls n = Some (projT1 s), forall h, projT2 s h = match pf in _ = t return match t return Type with | Some t => F t | None => unit end with | eq_refl => hlist_nth h n end.
Proof.
induction ls.
simpl.
intros.
try congruence.
destruct n.
inv_all.
subst.
simpl.

*****
IHls : forall (n : nat) (s : sigT (fun t : iT => forall _ : hlist ls, F t))\n (_ : eq (nth_error_get_hlist_nth ls n) (Some s)),\nex\n (fun pf : eq (nth_error ls n) (Some (projT1 s)) =>\n forall h : hlist ls,\n eq (projT2 s h)\n match\n pf in (eq _ t)\n return match t with\n | Some t0 => F t0\n | None => unit\n end\n with\n | eq_refl => hlist_nth@{SerTop.270} h n\n end)
ls : list iT
a : iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
ex (fun pf : eq (Some a) (Some a) => forall h : hlist (cons a ls), eq (hlist_hd h) match pf in (eq _ t) return match t with | Some t0 => F t0 | None => unit end with | eq_refl => hlist_nth@{SerTop.270} h O end)
+++++
exists (eq_refl).
-----
Theorem nth_error_get_hlist_nth_Some : forall ls n s, nth_error_get_hlist_nth ls n = Some s -> exists pf : nth_error ls n = Some (projT1 s), forall h, projT2 s h = match pf in _ = t return match t return Type with | Some t => F t | None => unit end with | eq_refl => hlist_nth h n end.
Proof.
induction ls.
simpl.
intros.
try congruence.
destruct n.
inv_all.
subst.
simpl.
exists (eq_refl).

*****
IHls : forall (n : nat) (s : sigT (fun t : iT => forall _ : hlist ls, F t))\n (_ : eq (nth_error_get_hlist_nth ls n) (Some s)),\nex\n (fun pf : eq (nth_error ls n) (Some (projT1 s)) =>\n forall h : hlist ls,\n eq (projT2 s h)\n match\n pf in (eq _ t)\n return match t with\n | Some t0 => F t0\n | None => unit\n end\n with\n | eq_refl => hlist_nth@{SerTop.270} h n\n end)
ls : list iT
a : iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall h : hlist (cons a ls), eq (hlist_hd h) (hlist_nth@{SerTop.270} h O)
+++++
intros.
-----
Theorem nth_error_get_hlist_nth_Some : forall ls n s, nth_error_get_hlist_nth ls n = Some s -> exists pf : nth_error ls n = Some (projT1 s), forall h, projT2 s h = match pf in _ = t return match t return Type with | Some t => F t | None => unit end with | eq_refl => hlist_nth h n end.
Proof.
induction ls.
simpl.
intros.
try congruence.
destruct n.
inv_all.
subst.
simpl.
exists (eq_refl).
intros.

*****
h : hlist (cons a ls)
IHls : forall (n : nat) (s : sigT (fun t : iT => forall _ : hlist ls, F t))\n (_ : eq (nth_error_get_hlist_nth ls n) (Some s)),\nex\n (fun pf : eq (nth_error ls n) (Some (projT1 s)) =>\n forall h : hlist ls,\n eq (projT2 s h)\n match\n pf in (eq _ t)\n return match t with\n | Some t0 => F t0\n | None => unit\n end\n with\n | eq_refl => hlist_nth@{SerTop.270} h n\n end)
ls : list iT
a : iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
eq (hlist_hd h) (hlist_nth@{SerTop.270} h O)
+++++
rewrite (hlist_eta h).
-----
Theorem nth_error_get_hlist_nth_Some : forall ls n s, nth_error_get_hlist_nth ls n = Some s -> exists pf : nth_error ls n = Some (projT1 s), forall h, projT2 s h = match pf in _ = t return match t return Type with | Some t => F t | None => unit end with | eq_refl => hlist_nth h n end.
Proof.
induction ls.
simpl.
intros.
try congruence.
destruct n.
inv_all.
subst.
simpl.
exists (eq_refl).
intros.
rewrite (hlist_eta h).

*****
h : hlist (cons a ls)
IHls : forall (n : nat) (s : sigT (fun t : iT => forall _ : hlist ls, F t))\n (_ : eq (nth_error_get_hlist_nth ls n) (Some s)),\nex\n (fun pf : eq (nth_error ls n) (Some (projT1 s)) =>\n forall h : hlist ls,\n eq (projT2 s h)\n match\n pf in (eq _ t)\n return match t with\n | Some t0 => F t0\n | None => unit\n end\n with\n | eq_refl => hlist_nth@{SerTop.270} h n\n end)
ls : list iT
a : iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
eq (hlist_hd (Hcons (hlist_hd h) (hlist_tl h))) (hlist_nth@{SerTop.270} (Hcons (hlist_hd h) (hlist_tl h)) O)
+++++
reflexivity.
-----
Theorem nth_error_get_hlist_nth_Some : forall ls n s, nth_error_get_hlist_nth ls n = Some s -> exists pf : nth_error ls n = Some (projT1 s), forall h, projT2 s h = match pf in _ = t return match t return Type with | Some t => F t | None => unit end with | eq_refl => hlist_nth h n end.
Proof.
induction ls.
simpl.
intros.
try congruence.
destruct n.

*****
H : eq\n match nth_error_get_hlist_nth ls n with\n | Some (@existT _ _ x f) =>\n Some\n (existT (fun t : iT => forall _ : hlist (cons a ls), F t) x\n (fun h : hlist (cons a ls) => f (hlist_tl h)))\n | None => None\n end (Some s)
s : sigT (fun t : iT => forall _ : hlist (cons a ls), F t)
n : nat
IHls : forall (n : nat) (s : sigT (fun t : iT => forall _ : hlist ls, F t))\n (_ : eq (nth_error_get_hlist_nth ls n) (Some s)),\nex\n (fun pf : eq (nth_error ls n) (Some (projT1 s)) =>\n forall h : hlist ls,\n eq (projT2 s h)\n match\n pf in (eq _ t)\n return match t with\n | Some t0 => F t0\n | None => unit\n end\n with\n | eq_refl => hlist_nth@{SerTop.270} h n\n end)
ls : list iT
a : iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
ex (fun pf : eq (nth_error (cons a ls) (S n)) (Some (projT1 s)) => forall h : hlist (cons a ls), eq (projT2 s h) match pf in (eq _ t) return match t with | Some t0 => F t0 | None => unit end with | eq_refl => hlist_nth@{SerTop.270} h (S n) end)
+++++
forward.
-----
Theorem nth_error_get_hlist_nth_Some : forall ls n s, nth_error_get_hlist_nth ls n = Some s -> exists pf : nth_error ls n = Some (projT1 s), forall h, projT2 s h = match pf in _ = t return match t return Type with | Some t => F t | None => unit end with | eq_refl => hlist_nth h n end.
Proof.
induction ls.
simpl.
intros.
try congruence.
destruct n.
forward.

*****
H1 : eq\n (Some\n (existT (fun t : iT => forall _ : hlist (cons a ls), F t) x\n (fun h : hlist (cons a ls) => f (hlist_tl h)))) \n (Some s)
H0 : eq (nth_error_get_hlist_nth ls n)\n (Some (existT (fun t : iT => forall _ : hlist ls, F t) x f))
H : eq s0 (existT (fun t : iT => forall _ : hlist ls, F t) x f)
f : forall _ : hlist ls, F x
x : iT
s0 : sigT (fun t : iT => forall _ : hlist ls, F t)
s : sigT (fun t : iT => forall _ : hlist (cons a ls), F t)
n : nat
IHls : forall (n : nat) (s : sigT (fun t : iT => forall _ : hlist ls, F t))\n (_ : eq (nth_error_get_hlist_nth ls n) (Some s)),\nex\n (fun pf : eq (nth_error ls n) (Some (projT1 s)) =>\n forall h : hlist ls,\n eq (projT2 s h)\n match\n pf in (eq _ t)\n return match t with\n | Some t0 => F t0\n | None => unit\n end\n with\n | eq_refl => hlist_nth@{SerTop.270} h n\n end)
ls : list iT
a : iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
ex (fun pf : eq (nth_error (cons a ls) (S n)) (Some (projT1 s)) => forall h : hlist (cons a ls), eq (projT2 s h) match pf in (eq _ t) return match t with | Some t0 => F t0 | None => unit end with | eq_refl => hlist_nth@{SerTop.270} h (S n) end)
+++++
inv_all.
-----
Theorem nth_error_get_hlist_nth_Some : forall ls n s, nth_error_get_hlist_nth ls n = Some s -> exists pf : nth_error ls n = Some (projT1 s), forall h, projT2 s h = match pf in _ = t return match t return Type with | Some t => F t | None => unit end with | eq_refl => hlist_nth h n end.
Proof.
induction ls.
simpl.
intros.
try congruence.
destruct n.
forward.
inv_all.

*****
H1 : eq\n (existT (fun t : iT => forall _ : hlist (cons a ls), F t) x\n (fun h : hlist (cons a ls) => f (hlist_tl h))) s
H0 : eq (nth_error_get_hlist_nth ls n)\n (Some (existT (fun t : iT => forall _ : hlist ls, F t) x f))
H : eq s0 (existT (fun t : iT => forall _ : hlist ls, F t) x f)
f : forall _ : hlist ls, F x
x : iT
s0 : sigT (fun t : iT => forall _ : hlist ls, F t)
s : sigT (fun t : iT => forall _ : hlist (cons a ls), F t)
n : nat
IHls : forall (n : nat) (s : sigT (fun t : iT => forall _ : hlist ls, F t))\n (_ : eq (nth_error_get_hlist_nth ls n) (Some s)),\nex\n (fun pf : eq (nth_error ls n) (Some (projT1 s)) =>\n forall h : hlist ls,\n eq (projT2 s h)\n match\n pf in (eq _ t)\n return match t with\n | Some t0 => F t0\n | None => unit\n end\n with\n | eq_refl => hlist_nth@{SerTop.270} h n\n end)
ls : list iT
a : iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
ex (fun pf : eq (nth_error (cons a ls) (S n)) (Some (projT1 s)) => forall h : hlist (cons a ls), eq (projT2 s h) match pf in (eq _ t) return match t with | Some t0 => F t0 | None => unit end with | eq_refl => hlist_nth@{SerTop.270} h (S n) end)
+++++
subst.
-----
Theorem nth_error_get_hlist_nth_Some : forall ls n s, nth_error_get_hlist_nth ls n = Some s -> exists pf : nth_error ls n = Some (projT1 s), forall h, projT2 s h = match pf in _ = t return match t return Type with | Some t => F t | None => unit end with | eq_refl => hlist_nth h n end.
Proof.
induction ls.
simpl.
intros.
try congruence.
destruct n.
forward.
inv_all.
subst.

*****
H0 : eq (nth_error_get_hlist_nth ls n)\n (Some (existT (fun t : iT => forall _ : hlist ls, F t) x f))
f : forall _ : hlist ls, F x
x : iT
n : nat
IHls : forall (n : nat) (s : sigT (fun t : iT => forall _ : hlist ls, F t))\n (_ : eq (nth_error_get_hlist_nth ls n) (Some s)),\nex\n (fun pf : eq (nth_error ls n) (Some (projT1 s)) =>\n forall h : hlist ls,\n eq (projT2 s h)\n match\n pf in (eq _ t)\n return match t with\n | Some t0 => F t0\n | None => unit\n end\n with\n | eq_refl => hlist_nth@{SerTop.270} h n\n end)
ls : list iT
a : iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
ex (fun pf : eq (nth_error (cons a ls) (S n)) (Some (projT1 (existT (fun t : iT => forall _ : hlist (cons a ls), F t) x (fun h : hlist (cons a ls) => f (hlist_tl h))))) => forall h : hlist (cons a ls), eq (projT2 (existT (fun t : iT => forall _ : hlist (cons a ls), F t) x (fun h0 : hlist (cons a ls) => f (hlist_tl h0))) h) match pf in (eq _ t) return match t with | Some t0 => F t0 | None => unit end with | eq_refl => hlist_nth@{SerTop.270} h (S n) end)
+++++
destruct (IHls _ _ H0).
-----
Theorem nth_error_get_hlist_nth_Some : forall ls n s, nth_error_get_hlist_nth ls n = Some s -> exists pf : nth_error ls n = Some (projT1 s), forall h, projT2 s h = match pf in _ = t return match t return Type with | Some t => F t | None => unit end with | eq_refl => hlist_nth h n end.
Proof.
induction ls.
simpl.
intros.
try congruence.
destruct n.
forward.
inv_all.
subst.
destruct (IHls _ _ H0).

*****
H : forall h : hlist ls,\neq (projT2 (existT (fun t : iT => forall _ : hlist ls, F t) x f) h)\n match\n x0 in (eq _ t)\n return match t with\n | Some t0 => F t0\n | None => unit\n end\n with\n | eq_refl => hlist_nth@{SerTop.270} h n\n end
x0 : eq (nth_error ls n)\n (Some (projT1 (existT (fun t : iT => forall _ : hlist ls, F t) x f)))
H0 : eq (nth_error_get_hlist_nth ls n)\n (Some (existT (fun t : iT => forall _ : hlist ls, F t) x f))
f : forall _ : hlist ls, F x
x : iT
n : nat
IHls : forall (n : nat) (s : sigT (fun t : iT => forall _ : hlist ls, F t))\n (_ : eq (nth_error_get_hlist_nth ls n) (Some s)),\nex\n (fun pf : eq (nth_error ls n) (Some (projT1 s)) =>\n forall h : hlist ls,\n eq (projT2 s h)\n match\n pf in (eq _ t)\n return match t with\n | Some t0 => F t0\n | None => unit\n end\n with\n | eq_refl => hlist_nth@{SerTop.270} h n\n end)
ls : list iT
a : iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
ex (fun pf : eq (nth_error (cons a ls) (S n)) (Some (projT1 (existT (fun t : iT => forall _ : hlist (cons a ls), F t) x (fun h : hlist (cons a ls) => f (hlist_tl h))))) => forall h : hlist (cons a ls), eq (projT2 (existT (fun t : iT => forall _ : hlist (cons a ls), F t) x (fun h0 : hlist (cons a ls) => f (hlist_tl h0))) h) match pf in (eq _ t) return match t with | Some t0 => F t0 | None => unit end with | eq_refl => hlist_nth@{SerTop.270} h (S n) end)
+++++
clear IHls.
-----
Theorem nth_error_get_hlist_nth_Some : forall ls n s, nth_error_get_hlist_nth ls n = Some s -> exists pf : nth_error ls n = Some (projT1 s), forall h, projT2 s h = match pf in _ = t return match t return Type with | Some t => F t | None => unit end with | eq_refl => hlist_nth h n end.
Proof.
induction ls.
simpl.
intros.
try congruence.
destruct n.
forward.
inv_all.
subst.
destruct (IHls _ _ H0).
clear IHls.

*****
H : forall h : hlist ls,\neq (projT2 (existT (fun t : iT => forall _ : hlist ls, F t) x f) h)\n match\n x0 in (eq _ t)\n return match t with\n | Some t0 => F t0\n | None => unit\n end\n with\n | eq_refl => hlist_nth@{SerTop.270} h n\n end
x0 : eq (nth_error ls n)\n (Some (projT1 (existT (fun t : iT => forall _ : hlist ls, F t) x f)))
H0 : eq (nth_error_get_hlist_nth ls n)\n (Some (existT (fun t : iT => forall _ : hlist ls, F t) x f))
f : forall _ : hlist ls, F x
x : iT
n : nat
ls : list iT
a : iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
ex (fun pf : eq (nth_error (cons a ls) (S n)) (Some (projT1 (existT (fun t : iT => forall _ : hlist (cons a ls), F t) x (fun h : hlist (cons a ls) => f (hlist_tl h))))) => forall h : hlist (cons a ls), eq (projT2 (existT (fun t : iT => forall _ : hlist (cons a ls), F t) x (fun h0 : hlist (cons a ls) => f (hlist_tl h0))) h) match pf in (eq _ t) return match t with | Some t0 => F t0 | None => unit end with | eq_refl => hlist_nth@{SerTop.270} h (S n) end)
+++++
simpl in *.
-----
Theorem nth_error_get_hlist_nth_Some : forall ls n s, nth_error_get_hlist_nth ls n = Some s -> exists pf : nth_error ls n = Some (projT1 s), forall h, projT2 s h = match pf in _ = t return match t return Type with | Some t => F t | None => unit end with | eq_refl => hlist_nth h n end.
Proof.
induction ls.
simpl.
intros.
try congruence.
destruct n.
forward.
inv_all.
subst.
destruct (IHls _ _ H0).
clear IHls.
simpl in *.

*****
H : forall h : hlist ls,\neq (f h)\n match\n x0 in (eq _ t)\n return match t with\n | Some t0 => F t0\n | None => unit\n end\n with\n | eq_refl => hlist_nth@{SerTop.270} h n\n end
x0 : eq (nth_error ls n) (Some x)
H0 : eq (nth_error_get_hlist_nth ls n)\n (Some (existT (fun t : iT => forall _ : hlist ls, F t) x f))
f : forall _ : hlist ls, F x
x : iT
n : nat
ls : list iT
a : iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
ex (fun pf : eq (nth_error ls n) (Some x) => forall h : hlist (cons a ls), eq (f (hlist_tl h)) match pf in (eq _ t) return match t with | Some t0 => F t0 | None => unit end with | eq_refl => hlist_nth@{SerTop.270} h (S n) end)
+++++
exists x0.
-----
Theorem nth_error_get_hlist_nth_Some : forall ls n s, nth_error_get_hlist_nth ls n = Some s -> exists pf : nth_error ls n = Some (projT1 s), forall h, projT2 s h = match pf in _ = t return match t return Type with | Some t => F t | None => unit end with | eq_refl => hlist_nth h n end.
Proof.
induction ls.
simpl.
intros.
try congruence.
destruct n.
forward.
inv_all.
subst.
destruct (IHls _ _ H0).
clear IHls.
simpl in *.
exists x0.

*****
H : forall h : hlist ls,\neq (f h)\n match\n x0 in (eq _ t)\n return match t with\n | Some t0 => F t0\n | None => unit\n end\n with\n | eq_refl => hlist_nth@{SerTop.270} h n\n end
x0 : eq (nth_error ls n) (Some x)
H0 : eq (nth_error_get_hlist_nth ls n)\n (Some (existT (fun t : iT => forall _ : hlist ls, F t) x f))
f : forall _ : hlist ls, F x
x : iT
n : nat
ls : list iT
a : iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall h : hlist (cons a ls), eq (f (hlist_tl h)) match x0 in (eq _ t) return match t with | Some t0 => F t0 | None => unit end with | eq_refl => hlist_nth@{SerTop.270} h (S n) end
+++++
intros.
-----
Theorem nth_error_get_hlist_nth_Some : forall ls n s, nth_error_get_hlist_nth ls n = Some s -> exists pf : nth_error ls n = Some (projT1 s), forall h, projT2 s h = match pf in _ = t return match t return Type with | Some t => F t | None => unit end with | eq_refl => hlist_nth h n end.
Proof.
induction ls.
simpl.
intros.
try congruence.
destruct n.
forward.
inv_all.
subst.
destruct (IHls _ _ H0).
clear IHls.
simpl in *.
exists x0.
intros.

*****
h : hlist (cons a ls)
H : forall h : hlist ls,\neq (f h)\n match\n x0 in (eq _ t)\n return match t with\n | Some t0 => F t0\n | None => unit\n end\n with\n | eq_refl => hlist_nth@{SerTop.270} h n\n end
x0 : eq (nth_error ls n) (Some x)
H0 : eq (nth_error_get_hlist_nth ls n)\n (Some (existT (fun t : iT => forall _ : hlist ls, F t) x f))
f : forall _ : hlist ls, F x
x : iT
n : nat
ls : list iT
a : iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
eq (f (hlist_tl h)) match x0 in (eq _ t) return match t with | Some t0 => F t0 | None => unit end with | eq_refl => hlist_nth@{SerTop.270} h (S n) end
+++++
rewrite (hlist_eta h).
-----
Theorem nth_error_get_hlist_nth_Some : forall ls n s, nth_error_get_hlist_nth ls n = Some s -> exists pf : nth_error ls n = Some (projT1 s), forall h, projT2 s h = match pf in _ = t return match t return Type with | Some t => F t | None => unit end with | eq_refl => hlist_nth h n end.
Proof.
induction ls.
simpl.
intros.
try congruence.
destruct n.
forward.
inv_all.
subst.
destruct (IHls _ _ H0).
clear IHls.
simpl in *.
exists x0.
intros.
rewrite (hlist_eta h).

*****
h : hlist (cons a ls)
H : forall h : hlist ls,\neq (f h)\n match\n x0 in (eq _ t)\n return match t with\n | Some t0 => F t0\n | None => unit\n end\n with\n | eq_refl => hlist_nth@{SerTop.270} h n\n end
x0 : eq (nth_error ls n) (Some x)
H0 : eq (nth_error_get_hlist_nth ls n)\n (Some (existT (fun t : iT => forall _ : hlist ls, F t) x f))
f : forall _ : hlist ls, F x
x : iT
n : nat
ls : list iT
a : iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
eq (f (hlist_tl (Hcons (hlist_hd h) (hlist_tl h)))) match x0 in (eq _ t) return match t with | Some t0 => F t0 | None => unit end with | eq_refl => hlist_nth@{SerTop.270} (Hcons (hlist_hd h) (hlist_tl h)) (S n) end
+++++
simpl.
-----
Theorem nth_error_get_hlist_nth_Some : forall ls n s, nth_error_get_hlist_nth ls n = Some s -> exists pf : nth_error ls n = Some (projT1 s), forall h, projT2 s h = match pf in _ = t return match t return Type with | Some t => F t | None => unit end with | eq_refl => hlist_nth h n end.
Proof.
induction ls.
simpl.
intros.
try congruence.
destruct n.
forward.
inv_all.
subst.
destruct (IHls _ _ H0).
clear IHls.
simpl in *.
exists x0.
intros.
rewrite (hlist_eta h).
simpl.

*****
h : hlist (cons a ls)
H : forall h : hlist ls,\neq (f h)\n match\n x0 in (eq _ t)\n return match t with\n | Some t0 => F t0\n | None => unit\n end\n with\n | eq_refl => hlist_nth@{SerTop.270} h n\n end
x0 : eq (nth_error ls n) (Some x)
H0 : eq (nth_error_get_hlist_nth ls n)\n (Some (existT (fun t : iT => forall _ : hlist ls, F t) x f))
f : forall _ : hlist ls, F x
x : iT
n : nat
ls : list iT
a : iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
eq (f (hlist_tl h)) match x0 in (eq _ t) return match t with | Some t0 => F t0 | None => unit end with | eq_refl => hlist_nth@{SerTop.270} (hlist_tl h) n end
+++++
auto.
-----
Theorem nth_error_get_hlist_nth_Some : forall ls n s, nth_error_get_hlist_nth ls n = Some s -> exists pf : nth_error ls n = Some (projT1 s), forall h, projT2 s h = match pf in _ = t return match t return Type with | Some t => F t | None => unit end with | eq_refl => hlist_nth h n end.
Proof.
induction ls.

*****

*****

+++++
Qed.
-----
Theorem nth_error_get_hlist_nth_None\n  : forall ls n,\n      nth_error_get_hlist_nth ls n = None <->\n      nth_error ls n = None.
-----
Theorem nth_error_get_hlist_nth_None : forall ls n, nth_error_get_hlist_nth ls n = None <-> nth_error ls n = None.

*****
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall (ls : list iT) (n : nat), iff (eq (nth_error_get_hlist_nth ls n) None) (eq (nth_error ls n) None)
+++++
Proof.
-----
Theorem nth_error_get_hlist_nth_None : forall ls n, nth_error_get_hlist_nth ls n = None <-> nth_error ls n = None.
Proof.

*****
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall (ls : list iT) (n : nat), iff (eq (nth_error_get_hlist_nth ls n) None) (eq (nth_error ls n) None)
+++++
induction ls.
-----
Theorem nth_error_get_hlist_nth_None : forall ls n, nth_error_get_hlist_nth ls n = None <-> nth_error ls n = None.
Proof.
induction ls.

*****
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall n : nat, iff (eq (nth_error_get_hlist_nth nil n) None) (eq (nth_error nil n) None)
+++++
simpl.
-----
Theorem nth_error_get_hlist_nth_None : forall ls n, nth_error_get_hlist_nth ls n = None <-> nth_error ls n = None.
Proof.
induction ls.
simpl.

*****
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall n : nat, iff (eq None None) (eq (nth_error nil n) None)
+++++
intros.
-----
Theorem nth_error_get_hlist_nth_None : forall ls n, nth_error_get_hlist_nth ls n = None <-> nth_error ls n = None.
Proof.
induction ls.
simpl.
intros.

*****
n : nat
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
iff (eq None None) (eq (nth_error nil n) None)
+++++
try congruence.
-----
Theorem nth_error_get_hlist_nth_None : forall ls n, nth_error_get_hlist_nth ls n = None <-> nth_error ls n = None.
Proof.
induction ls.
simpl.
intros.
try congruence.

*****
n : nat
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
iff (eq None None) (eq (nth_error nil n) None)
+++++
destruct n.
-----
Theorem nth_error_get_hlist_nth_None : forall ls n, nth_error_get_hlist_nth ls n = None <-> nth_error ls n = None.
Proof.
induction ls.
simpl.
intros.
try congruence.
destruct n.

*****
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
iff (eq None None) (eq (nth_error nil O) None)
+++++
intuition.
-----
Theorem nth_error_get_hlist_nth_None : forall ls n, nth_error_get_hlist_nth ls n = None <-> nth_error ls n = None.
Proof.
induction ls.
simpl.
intros.
try congruence.
destruct n.

*****
n : nat
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
iff (eq None None) (eq (nth_error nil (S n)) None)
+++++
intuition.
-----
Theorem nth_error_get_hlist_nth_None : forall ls n, nth_error_get_hlist_nth ls n = None <-> nth_error ls n = None.
Proof.
induction ls.

*****
IHls : forall n : nat,\niff (eq (nth_error_get_hlist_nth ls n) None) (eq (nth_error ls n) None)
ls : list iT
a : iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall n : nat, iff (eq (nth_error_get_hlist_nth (cons a ls) n) None) (eq (nth_error (cons a ls) n) None)
+++++
simpl.
-----
Theorem nth_error_get_hlist_nth_None : forall ls n, nth_error_get_hlist_nth ls n = None <-> nth_error ls n = None.
Proof.
induction ls.
simpl.

*****
IHls : forall n : nat,\niff (eq (nth_error_get_hlist_nth ls n) None) (eq (nth_error ls n) None)
ls : list iT
a : iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall n : nat, iff (eq match n with | O => Some (existT (fun t : iT => forall _ : hlist (cons a ls), F t) a hlist_hd) | S n0 => match nth_error_get_hlist_nth ls n0 with | Some (@existT _ _ x f) => Some (existT (fun t : iT => forall _ : hlist (cons a ls), F t) x (fun h : hlist (cons a ls) => f (hlist_tl h))) | None => None end end None) (eq (nth_error (cons a ls) n) None)
+++++
intros.
-----
Theorem nth_error_get_hlist_nth_None : forall ls n, nth_error_get_hlist_nth ls n = None <-> nth_error ls n = None.
Proof.
induction ls.
simpl.
intros.

*****
n : nat
IHls : forall n : nat,\niff (eq (nth_error_get_hlist_nth ls n) None) (eq (nth_error ls n) None)
ls : list iT
a : iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
iff (eq match n with | O => Some (existT (fun t : iT => forall _ : hlist (cons a ls), F t) a hlist_hd) | S n0 => match nth_error_get_hlist_nth ls n0 with | Some (@existT _ _ x f) => Some (existT (fun t : iT => forall _ : hlist (cons a ls), F t) x (fun h : hlist (cons a ls) => f (hlist_tl h))) | None => None end end None) (eq (nth_error (cons a ls) n) None)
+++++
try congruence.
-----
Theorem nth_error_get_hlist_nth_None : forall ls n, nth_error_get_hlist_nth ls n = None <-> nth_error ls n = None.
Proof.
induction ls.
simpl.
intros.
try congruence.

*****
n : nat
IHls : forall n : nat,\niff (eq (nth_error_get_hlist_nth ls n) None) (eq (nth_error ls n) None)
ls : list iT
a : iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
iff (eq match n with | O => Some (existT (fun t : iT => forall _ : hlist (cons a ls), F t) a hlist_hd) | S n0 => match nth_error_get_hlist_nth ls n0 with | Some (@existT _ _ x f) => Some (existT (fun t : iT => forall _ : hlist (cons a ls), F t) x (fun h : hlist (cons a ls) => f (hlist_tl h))) | None => None end end None) (eq (nth_error (cons a ls) n) None)
+++++
destruct n.
-----
Theorem nth_error_get_hlist_nth_None : forall ls n, nth_error_get_hlist_nth ls n = None <-> nth_error ls n = None.
Proof.
induction ls.
simpl.
intros.
try congruence.
destruct n.

*****
IHls : forall n : nat,\niff (eq (nth_error_get_hlist_nth ls n) None) (eq (nth_error ls n) None)
ls : list iT
a : iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
iff (eq (Some (existT (fun t : iT => forall _ : hlist (cons a ls), F t) a hlist_hd)) None) (eq (nth_error (cons a ls) O) None)
+++++
simpl.
-----
Theorem nth_error_get_hlist_nth_None : forall ls n, nth_error_get_hlist_nth ls n = None <-> nth_error ls n = None.
Proof.
induction ls.
simpl.
intros.
try congruence.
destruct n.
simpl.

*****
IHls : forall n : nat,\niff (eq (nth_error_get_hlist_nth ls n) None) (eq (nth_error ls n) None)
ls : list iT
a : iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
iff (eq (Some (existT (fun t : iT => forall _ : hlist (cons a ls), F t) a hlist_hd)) None) (eq (Some a) None)
+++++
try solve [ intuition congruence ].
-----
Theorem nth_error_get_hlist_nth_None : forall ls n, nth_error_get_hlist_nth ls n = None <-> nth_error ls n = None.
Proof.
induction ls.
simpl.
intros.
try congruence.
destruct n.

*****
n : nat
IHls : forall n : nat,\niff (eq (nth_error_get_hlist_nth ls n) None) (eq (nth_error ls n) None)
ls : list iT
a : iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
iff (eq match nth_error_get_hlist_nth ls n with | Some (@existT _ _ x f) => Some (existT (fun t : iT => forall _ : hlist (cons a ls), F t) x (fun h : hlist (cons a ls) => f (hlist_tl h))) | None => None end None) (eq (nth_error (cons a ls) (S n)) None)
+++++
simpl.
-----
Theorem nth_error_get_hlist_nth_None : forall ls n, nth_error_get_hlist_nth ls n = None <-> nth_error ls n = None.
Proof.
induction ls.
simpl.
intros.
try congruence.
destruct n.
simpl.

*****
n : nat
IHls : forall n : nat,\niff (eq (nth_error_get_hlist_nth ls n) None) (eq (nth_error ls n) None)
ls : list iT
a : iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
iff (eq match nth_error_get_hlist_nth ls n with | Some (@existT _ _ x f) => Some (existT (fun t : iT => forall _ : hlist (cons a ls), F t) x (fun h : hlist (cons a ls) => f (hlist_tl h))) | None => None end None) (eq (nth_error ls n) None)
+++++
try solve [ intuition congruence ].
-----
Theorem nth_error_get_hlist_nth_None : forall ls n, nth_error_get_hlist_nth ls n = None <-> nth_error ls n = None.
Proof.
induction ls.
simpl.
intros.
try congruence.
destruct n.
simpl.
try solve [ intuition congruence ].

*****
n : nat
IHls : forall n : nat,\niff (eq (nth_error_get_hlist_nth ls n) None) (eq (nth_error ls n) None)
ls : list iT
a : iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
iff (eq match nth_error_get_hlist_nth ls n with | Some (@existT _ _ x f) => Some (existT (fun t : iT => forall _ : hlist (cons a ls), F t) x (fun h : hlist (cons a ls) => f (hlist_tl h))) | None => None end None) (eq (nth_error ls n) None)
+++++
specialize (IHls n).
-----
Theorem nth_error_get_hlist_nth_None : forall ls n, nth_error_get_hlist_nth ls n = None <-> nth_error ls n = None.
Proof.
induction ls.
simpl.
intros.
try congruence.
destruct n.
simpl.
try solve [ intuition congruence ].
specialize (IHls n).

*****
IHls : iff (eq (nth_error_get_hlist_nth ls n) None) (eq (nth_error ls n) None)
n : nat
ls : list iT
a : iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
iff (eq match nth_error_get_hlist_nth ls n with | Some (@existT _ _ x f) => Some (existT (fun t : iT => forall _ : hlist (cons a ls), F t) x (fun h : hlist (cons a ls) => f (hlist_tl h))) | None => None end None) (eq (nth_error ls n) None)
+++++
forward.
-----
Theorem nth_error_get_hlist_nth_None : forall ls n, nth_error_get_hlist_nth ls n = None <-> nth_error ls n = None.
Proof.
induction ls.

*****

*****

+++++
Qed.
-----
Lemma nth_error_get_hlist_nth_weaken\n  : forall ls ls' n x,\n      nth_error_get_hlist_nth ls n = Some x ->\n      exists z,\n        nth_error_get_hlist_nth (ls ++ ls') n =\n        Some (@existT iT (fun t => hlist (ls ++ ls') -> F t) (projT1 x) z)\n        /\ forall h h', projT2 x h = z (hlist_app h h').
-----
Lemma nth_error_get_hlist_nth_weaken : forall ls ls' n x, nth_error_get_hlist_nth ls n = Some x -> exists z, nth_error_get_hlist_nth (ls ++ ls') n = Some (@existT iT (fun t => hlist (ls ++ ls') -> F t) (projT1 x) z) /\\ forall h h', projT2 x h = z (hlist_app h h').

*****
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall (ls ls' : list iT) (n : nat) (x : sigT (fun t : iT => forall _ : hlist ls, F t)) (_ : eq (nth_error_get_hlist_nth ls n) (Some x)), ex (fun z : forall _ : hlist (app ls ls'), F (projT1 x) => and (eq (nth_error_get_hlist_nth (app ls ls') n) (Some (existT (fun t : iT => forall _ : hlist (app ls ls'), F t) (projT1 x) z))) (forall (h : hlist ls) (h' : hlist ls'), eq (projT2 x h) (z (hlist_app h h'))))
+++++
Proof.
-----
Lemma nth_error_get_hlist_nth_weaken : forall ls ls' n x, nth_error_get_hlist_nth ls n = Some x -> exists z, nth_error_get_hlist_nth (ls ++ ls') n = Some (@existT iT (fun t => hlist (ls ++ ls') -> F t) (projT1 x) z) /\\ forall h h', projT2 x h = z (hlist_app h h').
Proof.

*****
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall (ls ls' : list iT) (n : nat) (x : sigT (fun t : iT => forall _ : hlist ls, F t)) (_ : eq (nth_error_get_hlist_nth ls n) (Some x)), ex (fun z : forall _ : hlist (app ls ls'), F (projT1 x) => and (eq (nth_error_get_hlist_nth (app ls ls') n) (Some (existT (fun t : iT => forall _ : hlist (app ls ls'), F t) (projT1 x) z))) (forall (h : hlist ls) (h' : hlist ls'), eq (projT2 x h) (z (hlist_app h h'))))
+++++
intros ls ls'.
-----
Lemma nth_error_get_hlist_nth_weaken : forall ls ls' n x, nth_error_get_hlist_nth ls n = Some x -> exists z, nth_error_get_hlist_nth (ls ++ ls') n = Some (@existT iT (fun t => hlist (ls ++ ls') -> F t) (projT1 x) z) /\\ forall h h', projT2 x h = z (hlist_app h h').
Proof.
intros ls ls'.

*****
ls,ls' : list iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall (n : nat) (x : sigT (fun t : iT => forall _ : hlist ls, F t)) (_ : eq (nth_error_get_hlist_nth ls n) (Some x)), ex (fun z : forall _ : hlist (app ls ls'), F (projT1 x) => and (eq (nth_error_get_hlist_nth (app ls ls') n) (Some (existT (fun t : iT => forall _ : hlist (app ls ls'), F t) (projT1 x) z))) (forall (h : hlist ls) (h' : hlist ls'), eq (projT2 x h) (z (hlist_app h h'))))
+++++
revert ls.
-----
Lemma nth_error_get_hlist_nth_weaken : forall ls ls' n x, nth_error_get_hlist_nth ls n = Some x -> exists z, nth_error_get_hlist_nth (ls ++ ls') n = Some (@existT iT (fun t => hlist (ls ++ ls') -> F t) (projT1 x) z) /\\ forall h h', projT2 x h = z (hlist_app h h').
Proof.
intros ls ls'.
revert ls.

*****
ls' : list iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall (ls : list iT) (n : nat) (x : sigT (fun t : iT => forall _ : hlist ls, F t)) (_ : eq (nth_error_get_hlist_nth ls n) (Some x)), ex (fun z : forall _ : hlist (app ls ls'), F (projT1 x) => and (eq (nth_error_get_hlist_nth (app ls ls') n) (Some (existT (fun t : iT => forall _ : hlist (app ls ls'), F t) (projT1 x) z))) (forall (h : hlist ls) (h' : hlist ls'), eq (projT2 x h) (z (hlist_app h h'))))
+++++
induction ls.
-----
Lemma nth_error_get_hlist_nth_weaken : forall ls ls' n x, nth_error_get_hlist_nth ls n = Some x -> exists z, nth_error_get_hlist_nth (ls ++ ls') n = Some (@existT iT (fun t => hlist (ls ++ ls') -> F t) (projT1 x) z) /\\ forall h h', projT2 x h = z (hlist_app h h').
Proof.
intros ls ls'.
revert ls.
induction ls.

*****
ls' : list iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall (n : nat) (x : sigT (fun t : iT => forall _ : hlist nil, F t)) (_ : eq (nth_error_get_hlist_nth nil n) (Some x)), ex (fun z : forall _ : hlist (app nil ls'), F (projT1 x) => and (eq (nth_error_get_hlist_nth (app nil ls') n) (Some (existT (fun t : iT => forall _ : hlist (app nil ls'), F t) (projT1 x) z))) (forall (h : hlist nil) (h' : hlist ls'), eq (projT2 x h) (z (hlist_app h h'))))
+++++
simpl.
-----
Lemma nth_error_get_hlist_nth_weaken : forall ls ls' n x, nth_error_get_hlist_nth ls n = Some x -> exists z, nth_error_get_hlist_nth (ls ++ ls') n = Some (@existT iT (fun t => hlist (ls ++ ls') -> F t) (projT1 x) z) /\\ forall h h', projT2 x h = z (hlist_app h h').
Proof.
intros ls ls'.
revert ls.
induction ls.
simpl.

*****
ls' : list iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall (n : nat) (x : sigT (fun t : iT => forall _ : hlist nil, F t)) (_ : eq None (Some x)), ex (fun z : forall _ : hlist ls', F (projT1 x) => and (eq (nth_error_get_hlist_nth ls' n) (Some (existT (fun t : iT => forall _ : hlist ls', F t) (projT1 x) z))) (forall (h : hlist nil) (h' : hlist ls'), eq (projT2 x h) (z (hlist_app h h'))))
+++++
intros.
-----
Lemma nth_error_get_hlist_nth_weaken : forall ls ls' n x, nth_error_get_hlist_nth ls n = Some x -> exists z, nth_error_get_hlist_nth (ls ++ ls') n = Some (@existT iT (fun t => hlist (ls ++ ls') -> F t) (projT1 x) z) /\\ forall h h', projT2 x h = z (hlist_app h h').
Proof.
intros ls ls'.
revert ls.
induction ls.
simpl.
intros.

*****
H : eq None (Some x)
x : sigT (fun t : iT => forall _ : hlist nil, F t)
n : nat
ls' : list iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
ex (fun z : forall _ : hlist ls', F (projT1 x) => and (eq (nth_error_get_hlist_nth ls' n) (Some (existT (fun t : iT => forall _ : hlist ls', F t) (projT1 x) z))) (forall (h : hlist nil) (h' : hlist ls'), eq (projT2 x h) (z (hlist_app h h'))))
+++++
try congruence.
-----
Lemma nth_error_get_hlist_nth_weaken : forall ls ls' n x, nth_error_get_hlist_nth ls n = Some x -> exists z, nth_error_get_hlist_nth (ls ++ ls') n = Some (@existT iT (fun t => hlist (ls ++ ls') -> F t) (projT1 x) z) /\\ forall h h', projT2 x h = z (hlist_app h h').
Proof.
intros ls ls'.
revert ls.
induction ls.

*****
IHls : forall (n : nat) (x : sigT (fun t : iT => forall _ : hlist ls, F t))\n (_ : eq (nth_error_get_hlist_nth ls n) (Some x)),\nex\n (fun z : forall _ : hlist (app ls ls'), F (projT1 x) =>\n and\n (eq (nth_error_get_hlist_nth (app ls ls') n)\n (Some\n (existT (fun t : iT => forall _ : hlist (app ls ls'), F t)\n (projT1 x) z)))\n (forall (h : hlist ls) (h' : hlist ls'),\n eq (projT2 x h) (z (hlist_app h h'))))
ls : list iT
a : iT
ls' : list iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall (n : nat) (x : sigT (fun t : iT => forall _ : hlist (cons a ls), F t)) (_ : eq (nth_error_get_hlist_nth (cons a ls) n) (Some x)), ex (fun z : forall _ : hlist (app (cons a ls) ls'), F (projT1 x) => and (eq (nth_error_get_hlist_nth (app (cons a ls) ls') n) (Some (existT (fun t : iT => forall _ : hlist (app (cons a ls) ls'), F t) (projT1 x) z))) (forall (h : hlist (cons a ls)) (h' : hlist ls'), eq (projT2 x h) (z (hlist_app h h'))))
+++++
simpl.
-----
Lemma nth_error_get_hlist_nth_weaken : forall ls ls' n x, nth_error_get_hlist_nth ls n = Some x -> exists z, nth_error_get_hlist_nth (ls ++ ls') n = Some (@existT iT (fun t => hlist (ls ++ ls') -> F t) (projT1 x) z) /\\ forall h h', projT2 x h = z (hlist_app h h').
Proof.
intros ls ls'.
revert ls.
induction ls.
simpl.

*****
IHls : forall (n : nat) (x : sigT (fun t : iT => forall _ : hlist ls, F t))\n (_ : eq (nth_error_get_hlist_nth ls n) (Some x)),\nex\n (fun z : forall _ : hlist (app ls ls'), F (projT1 x) =>\n and\n (eq (nth_error_get_hlist_nth (app ls ls') n)\n (Some\n (existT (fun t : iT => forall _ : hlist (app ls ls'), F t)\n (projT1 x) z)))\n (forall (h : hlist ls) (h' : hlist ls'),\n eq (projT2 x h) (z (hlist_app h h'))))
ls : list iT
a : iT
ls' : list iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall (n : nat) (x : sigT (fun t : iT => forall _ : hlist (cons a ls), F t)) (_ : eq match n with | O => Some (existT (fun t : iT => forall _ : hlist (cons a ls), F t) a hlist_hd) | S n0 => match nth_error_get_hlist_nth ls n0 with | Some (@existT _ _ x0 f) => Some (existT (fun t : iT => forall _ : hlist (cons a ls), F t) x0 (fun h : hlist (cons a ls) => f (hlist_tl h))) | None => None end end (Some x)), ex (fun z : forall _ : hlist (cons a (app ls ls')), F (projT1 x) => and (eq match n with | O => Some (existT (fun t : iT => forall _ : hlist (cons a (app ls ls')), F t) a hlist_hd) | S n0 => match nth_error_get_hlist_nth (app ls ls') n0 with | Some (@existT _ _ x0 f) => Some (existT (fun t : iT => forall _ : hlist (cons a (app ls ls')), F t) x0 (fun h : hlist (cons a (app ls ls')) => f (hlist_tl h))) | None => None end end (Some (existT (fun t : iT => forall _ : hlist (cons a (app ls ls')), F t) (projT1 x) z))) (forall (h : hlist (cons a ls)) (h' : hlist ls'), eq (projT2 x h) (z (hlist_app h h'))))
+++++
intros.
-----
Lemma nth_error_get_hlist_nth_weaken : forall ls ls' n x, nth_error_get_hlist_nth ls n = Some x -> exists z, nth_error_get_hlist_nth (ls ++ ls') n = Some (@existT iT (fun t => hlist (ls ++ ls') -> F t) (projT1 x) z) /\\ forall h h', projT2 x h = z (hlist_app h h').
Proof.
intros ls ls'.
revert ls.
induction ls.
simpl.
intros.

*****
H : eq\n match n with\n | O =>\n Some\n (existT (fun t : iT => forall _ : hlist (cons a ls), F t) a\n hlist_hd)\n | S n0 =>\n match nth_error_get_hlist_nth ls n0 with\n | Some (@existT _ _ x f) =>\n Some\n (existT (fun t : iT => forall _ : hlist (cons a ls), F t) x\n (fun h : hlist (cons a ls) => f (hlist_tl h)))\n | None => None\n end\n end (Some x)
x : sigT (fun t : iT => forall _ : hlist (cons a ls), F t)
n : nat
IHls : forall (n : nat) (x : sigT (fun t : iT => forall _ : hlist ls, F t))\n (_ : eq (nth_error_get_hlist_nth ls n) (Some x)),\nex\n (fun z : forall _ : hlist (app ls ls'), F (projT1 x) =>\n and\n (eq (nth_error_get_hlist_nth (app ls ls') n)\n (Some\n (existT (fun t : iT => forall _ : hlist (app ls ls'), F t)\n (projT1 x) z)))\n (forall (h : hlist ls) (h' : hlist ls'),\n eq (projT2 x h) (z (hlist_app h h'))))
ls : list iT
a : iT
ls' : list iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
ex (fun z : forall _ : hlist (cons a (app ls ls')), F (projT1 x) => and (eq match n with | O => Some (existT (fun t : iT => forall _ : hlist (cons a (app ls ls')), F t) a hlist_hd) | S n0 => match nth_error_get_hlist_nth (app ls ls') n0 with | Some (@existT _ _ x f) => Some (existT (fun t : iT => forall _ : hlist (cons a (app ls ls')), F t) x (fun h : hlist (cons a (app ls ls')) => f (hlist_tl h))) | None => None end end (Some (existT (fun t : iT => forall _ : hlist (cons a (app ls ls')), F t) (projT1 x) z))) (forall (h : hlist (cons a ls)) (h' : hlist ls'), eq (projT2 x h) (z (hlist_app h h'))))
+++++
try congruence.
-----
Lemma nth_error_get_hlist_nth_weaken : forall ls ls' n x, nth_error_get_hlist_nth ls n = Some x -> exists z, nth_error_get_hlist_nth (ls ++ ls') n = Some (@existT iT (fun t => hlist (ls ++ ls') -> F t) (projT1 x) z) /\\ forall h h', projT2 x h = z (hlist_app h h').
Proof.
intros ls ls'.
revert ls.
induction ls.
simpl.
intros.
try congruence.

*****
H : eq\n match n with\n | O =>\n Some\n (existT (fun t : iT => forall _ : hlist (cons a ls), F t) a\n hlist_hd)\n | S n0 =>\n match nth_error_get_hlist_nth ls n0 with\n | Some (@existT _ _ x f) =>\n Some\n (existT (fun t : iT => forall _ : hlist (cons a ls), F t) x\n (fun h : hlist (cons a ls) => f (hlist_tl h)))\n | None => None\n end\n end (Some x)
x : sigT (fun t : iT => forall _ : hlist (cons a ls), F t)
n : nat
IHls : forall (n : nat) (x : sigT (fun t : iT => forall _ : hlist ls, F t))\n (_ : eq (nth_error_get_hlist_nth ls n) (Some x)),\nex\n (fun z : forall _ : hlist (app ls ls'), F (projT1 x) =>\n and\n (eq (nth_error_get_hlist_nth (app ls ls') n)\n (Some\n (existT (fun t : iT => forall _ : hlist (app ls ls'), F t)\n (projT1 x) z)))\n (forall (h : hlist ls) (h' : hlist ls'),\n eq (projT2 x h) (z (hlist_app h h'))))
ls : list iT
a : iT
ls' : list iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
ex (fun z : forall _ : hlist (cons a (app ls ls')), F (projT1 x) => and (eq match n with | O => Some (existT (fun t : iT => forall _ : hlist (cons a (app ls ls')), F t) a hlist_hd) | S n0 => match nth_error_get_hlist_nth (app ls ls') n0 with | Some (@existT _ _ x f) => Some (existT (fun t : iT => forall _ : hlist (cons a (app ls ls')), F t) x (fun h : hlist (cons a (app ls ls')) => f (hlist_tl h))) | None => None end end (Some (existT (fun t : iT => forall _ : hlist (cons a (app ls ls')), F t) (projT1 x) z))) (forall (h : hlist (cons a ls)) (h' : hlist ls'), eq (projT2 x h) (z (hlist_app h h'))))
+++++
destruct n.
-----
Lemma nth_error_get_hlist_nth_weaken : forall ls ls' n x, nth_error_get_hlist_nth ls n = Some x -> exists z, nth_error_get_hlist_nth (ls ++ ls') n = Some (@existT iT (fun t => hlist (ls ++ ls') -> F t) (projT1 x) z) /\\ forall h h', projT2 x h = z (hlist_app h h').
Proof.
intros ls ls'.
revert ls.
induction ls.
simpl.
intros.
try congruence.
destruct n.

*****
H : eq\n (Some\n (existT (fun t : iT => forall _ : hlist (cons a ls), F t) a\n hlist_hd)) (Some x)
x : sigT (fun t : iT => forall _ : hlist (cons a ls), F t)
IHls : forall (n : nat) (x : sigT (fun t : iT => forall _ : hlist ls, F t))\n (_ : eq (nth_error_get_hlist_nth ls n) (Some x)),\nex\n (fun z : forall _ : hlist (app ls ls'), F (projT1 x) =>\n and\n (eq (nth_error_get_hlist_nth (app ls ls') n)\n (Some\n (existT (fun t : iT => forall _ : hlist (app ls ls'), F t)\n (projT1 x) z)))\n (forall (h : hlist ls) (h' : hlist ls'),\n eq (projT2 x h) (z (hlist_app h h'))))
ls : list iT
a : iT
ls' : list iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
ex (fun z : forall _ : hlist (cons a (app ls ls')), F (projT1 x) => and (eq (Some (existT (fun t : iT => forall _ : hlist (cons a (app ls ls')), F t) a hlist_hd)) (Some (existT (fun t : iT => forall _ : hlist (cons a (app ls ls')), F t) (projT1 x) z))) (forall (h : hlist (cons a ls)) (h' : hlist ls'), eq (projT2 x h) (z (hlist_app h h'))))
+++++
inv_all.
-----
Lemma nth_error_get_hlist_nth_weaken : forall ls ls' n x, nth_error_get_hlist_nth ls n = Some x -> exists z, nth_error_get_hlist_nth (ls ++ ls') n = Some (@existT iT (fun t => hlist (ls ++ ls') -> F t) (projT1 x) z) /\\ forall h h', projT2 x h = z (hlist_app h h').
Proof.
intros ls ls'.
revert ls.
induction ls.
simpl.
intros.
try congruence.
destruct n.
inv_all.

*****
H : eq\n (existT (fun t : iT => forall _ : hlist (cons a ls), F t) a hlist_hd)\n x
x : sigT (fun t : iT => forall _ : hlist (cons a ls), F t)
IHls : forall (n : nat) (x : sigT (fun t : iT => forall _ : hlist ls, F t))\n (_ : eq (nth_error_get_hlist_nth ls n) (Some x)),\nex\n (fun z : forall _ : hlist (app ls ls'), F (projT1 x) =>\n and\n (eq (nth_error_get_hlist_nth (app ls ls') n)\n (Some\n (existT (fun t : iT => forall _ : hlist (app ls ls'), F t)\n (projT1 x) z)))\n (forall (h : hlist ls) (h' : hlist ls'),\n eq (projT2 x h) (z (hlist_app h h'))))
ls : list iT
a : iT
ls' : list iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
ex (fun z : forall _ : hlist (cons a (app ls ls')), F (projT1 x) => and (eq (Some (existT (fun t : iT => forall _ : hlist (cons a (app ls ls')), F t) a hlist_hd)) (Some (existT (fun t : iT => forall _ : hlist (cons a (app ls ls')), F t) (projT1 x) z))) (forall (h : hlist (cons a ls)) (h' : hlist ls'), eq (projT2 x h) (z (hlist_app h h'))))
+++++
subst.
-----
Lemma nth_error_get_hlist_nth_weaken : forall ls ls' n x, nth_error_get_hlist_nth ls n = Some x -> exists z, nth_error_get_hlist_nth (ls ++ ls') n = Some (@existT iT (fun t => hlist (ls ++ ls') -> F t) (projT1 x) z) /\\ forall h h', projT2 x h = z (hlist_app h h').
Proof.
intros ls ls'.
revert ls.
induction ls.
simpl.
intros.
try congruence.
destruct n.
inv_all.
subst.

*****
IHls : forall (n : nat) (x : sigT (fun t : iT => forall _ : hlist ls, F t))\n (_ : eq (nth_error_get_hlist_nth ls n) (Some x)),\nex\n (fun z : forall _ : hlist (app ls ls'), F (projT1 x) =>\n and\n (eq (nth_error_get_hlist_nth (app ls ls') n)\n (Some\n (existT (fun t : iT => forall _ : hlist (app ls ls'), F t)\n (projT1 x) z)))\n (forall (h : hlist ls) (h' : hlist ls'),\n eq (projT2 x h) (z (hlist_app h h'))))
ls : list iT
a : iT
ls' : list iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
ex (fun z : forall _ : hlist (cons a (app ls ls')), F (projT1 (existT (fun t : iT => forall _ : hlist (cons a ls), F t) a hlist_hd)) => and (eq (Some (existT (fun t : iT => forall _ : hlist (cons a (app ls ls')), F t) a hlist_hd)) (Some (existT (fun t : iT => forall _ : hlist (cons a (app ls ls')), F t) (projT1 (existT (fun t : iT => forall _ : hlist (cons a ls), F t) a hlist_hd)) z))) (forall (h : hlist (cons a ls)) (h' : hlist ls'), eq (projT2 (existT (fun t : iT => forall _ : hlist (cons a ls), F t) a hlist_hd) h) (z (hlist_app h h'))))
+++++
simpl.
-----
Lemma nth_error_get_hlist_nth_weaken : forall ls ls' n x, nth_error_get_hlist_nth ls n = Some x -> exists z, nth_error_get_hlist_nth (ls ++ ls') n = Some (@existT iT (fun t => hlist (ls ++ ls') -> F t) (projT1 x) z) /\\ forall h h', projT2 x h = z (hlist_app h h').
Proof.
intros ls ls'.
revert ls.
induction ls.
simpl.
intros.
try congruence.
destruct n.
inv_all.
subst.
simpl.

*****
IHls : forall (n : nat) (x : sigT (fun t : iT => forall _ : hlist ls, F t))\n (_ : eq (nth_error_get_hlist_nth ls n) (Some x)),\nex\n (fun z : forall _ : hlist (app ls ls'), F (projT1 x) =>\n and\n (eq (nth_error_get_hlist_nth (app ls ls') n)\n (Some\n (existT (fun t : iT => forall _ : hlist (app ls ls'), F t)\n (projT1 x) z)))\n (forall (h : hlist ls) (h' : hlist ls'),\n eq (projT2 x h) (z (hlist_app h h'))))
ls : list iT
a : iT
ls' : list iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
ex (fun z : forall _ : hlist (cons a (app ls ls')), F a => and (eq (Some (existT (fun t : iT => forall _ : hlist (cons a (app ls ls')), F t) a hlist_hd)) (Some (existT (fun t : iT => forall _ : hlist (cons a (app ls ls')), F t) a z))) (forall (h : hlist (cons a ls)) (h' : hlist ls'), eq (hlist_hd h) (z (hlist_app h h'))))
+++++
eexists.
-----
Lemma nth_error_get_hlist_nth_weaken : forall ls ls' n x, nth_error_get_hlist_nth ls n = Some x -> exists z, nth_error_get_hlist_nth (ls ++ ls') n = Some (@existT iT (fun t => hlist (ls ++ ls') -> F t) (projT1 x) z) /\\ forall h h', projT2 x h = z (hlist_app h h').
Proof.
intros ls ls'.
revert ls.
induction ls.
simpl.
intros.
try congruence.
destruct n.
inv_all.
subst.
simpl.
eexists.

*****
IHls : forall (n : nat) (x : sigT (fun t : iT => forall _ : hlist ls, F t))\n (_ : eq (nth_error_get_hlist_nth ls n) (Some x)),\nex\n (fun z : forall _ : hlist (app ls ls'), F (projT1 x) =>\n and\n (eq (nth_error_get_hlist_nth (app ls ls') n)\n (Some\n (existT (fun t : iT => forall _ : hlist (app ls ls'), F t)\n (projT1 x) z)))\n (forall (h : hlist ls) (h' : hlist ls'),\n eq (projT2 x h) (z (hlist_app h h'))))
ls : list iT
a : iT
ls' : list iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
and (eq (Some (existT (fun t : iT => forall _ : hlist (cons a (app ls ls')), F t) a hlist_hd)) (Some (existT (fun t : iT => forall _ : hlist (cons a (app ls ls')), F t) a ?z))) (forall (h : hlist (cons a ls)) (h' : hlist ls'), eq (hlist_hd h) (?z (hlist_app h h')))
+++++
split.
-----
Lemma nth_error_get_hlist_nth_weaken : forall ls ls' n x, nth_error_get_hlist_nth ls n = Some x -> exists z, nth_error_get_hlist_nth (ls ++ ls') n = Some (@existT iT (fun t => hlist (ls ++ ls') -> F t) (projT1 x) z) /\\ forall h h', projT2 x h = z (hlist_app h h').
Proof.
intros ls ls'.
revert ls.
induction ls.
simpl.
intros.
try congruence.
destruct n.
inv_all.
subst.
simpl.
eexists.
split.

*****
IHls : forall (n : nat) (x : sigT (fun t : iT => forall _ : hlist ls, F t))\n (_ : eq (nth_error_get_hlist_nth ls n) (Some x)),\nex\n (fun z : forall _ : hlist (app ls ls'), F (projT1 x) =>\n and\n (eq (nth_error_get_hlist_nth (app ls ls') n)\n (Some\n (existT (fun t : iT => forall _ : hlist (app ls ls'), F t)\n (projT1 x) z)))\n (forall (h : hlist ls) (h' : hlist ls'),\n eq (projT2 x h) (z (hlist_app h h'))))
ls : list iT
a : iT
ls' : list iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
eq (Some (existT (fun t : iT => forall _ : hlist (cons a (app ls ls')), F t) a hlist_hd)) (Some (existT (fun t : iT => forall _ : hlist (cons a (app ls ls')), F t) a ?z))
+++++
eauto.
-----
Lemma nth_error_get_hlist_nth_weaken : forall ls ls' n x, nth_error_get_hlist_nth ls n = Some x -> exists z, nth_error_get_hlist_nth (ls ++ ls') n = Some (@existT iT (fun t => hlist (ls ++ ls') -> F t) (projT1 x) z) /\\ forall h h', projT2 x h = z (hlist_app h h').
Proof.
intros ls ls'.
revert ls.
induction ls.
simpl.
intros.
try congruence.
destruct n.
inv_all.
subst.
simpl.
eexists.
split.

*****
IHls : forall (n : nat) (x : sigT (fun t : iT => forall _ : hlist ls, F t))\n (_ : eq (nth_error_get_hlist_nth ls n) (Some x)),\nex\n (fun z : forall _ : hlist (app ls ls'), F (projT1 x) =>\n and\n (eq (nth_error_get_hlist_nth (app ls ls') n)\n (Some\n (existT (fun t : iT => forall _ : hlist (app ls ls'), F t)\n (projT1 x) z)))\n (forall (h : hlist ls) (h' : hlist ls'),\n eq (projT2 x h) (z (hlist_app h h'))))
ls : list iT
a : iT
ls' : list iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall (h : hlist (cons a ls)) (h' : hlist ls'), eq (hlist_hd h) (hlist_hd (hlist_app h h'))
+++++
eauto.
-----
Lemma nth_error_get_hlist_nth_weaken : forall ls ls' n x, nth_error_get_hlist_nth ls n = Some x -> exists z, nth_error_get_hlist_nth (ls ++ ls') n = Some (@existT iT (fun t => hlist (ls ++ ls') -> F t) (projT1 x) z) /\\ forall h h', projT2 x h = z (hlist_app h h').
Proof.
intros ls ls'.
revert ls.
induction ls.
simpl.
intros.
try congruence.
destruct n.
inv_all.
subst.
simpl.
eexists.
split.
eauto.

*****
IHls : forall (n : nat) (x : sigT (fun t : iT => forall _ : hlist ls, F t))\n (_ : eq (nth_error_get_hlist_nth ls n) (Some x)),\nex\n (fun z : forall _ : hlist (app ls ls'), F (projT1 x) =>\n and\n (eq (nth_error_get_hlist_nth (app ls ls') n)\n (Some\n (existT (fun t : iT => forall _ : hlist (app ls ls'), F t)\n (projT1 x) z)))\n (forall (h : hlist ls) (h' : hlist ls'),\n eq (projT2 x h) (z (hlist_app h h'))))
ls : list iT
a : iT
ls' : list iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall (h : hlist (cons a ls)) (h' : hlist ls'), eq (hlist_hd h) (hlist_hd (hlist_app h h'))
+++++
intros.
-----
Lemma nth_error_get_hlist_nth_weaken : forall ls ls' n x, nth_error_get_hlist_nth ls n = Some x -> exists z, nth_error_get_hlist_nth (ls ++ ls') n = Some (@existT iT (fun t => hlist (ls ++ ls') -> F t) (projT1 x) z) /\\ forall h h', projT2 x h = z (hlist_app h h').
Proof.
intros ls ls'.
revert ls.
induction ls.
simpl.
intros.
try congruence.
destruct n.
inv_all.
subst.
simpl.
eexists.
split.
eauto.
intros.

*****
h' : hlist ls'
h : hlist (cons a ls)
IHls : forall (n : nat) (x : sigT (fun t : iT => forall _ : hlist ls, F t))\n (_ : eq (nth_error_get_hlist_nth ls n) (Some x)),\nex\n (fun z : forall _ : hlist (app ls ls'), F (projT1 x) =>\n and\n (eq (nth_error_get_hlist_nth (app ls ls') n)\n (Some\n (existT (fun t : iT => forall _ : hlist (app ls ls'), F t)\n (projT1 x) z)))\n (forall (h : hlist ls) (h' : hlist ls'),\n eq (projT2 x h) (z (hlist_app h h'))))
ls : list iT
a : iT
ls' : list iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
eq (hlist_hd h) (hlist_hd (hlist_app h h'))
+++++
rewrite (hlist_eta h).
-----
Lemma nth_error_get_hlist_nth_weaken : forall ls ls' n x, nth_error_get_hlist_nth ls n = Some x -> exists z, nth_error_get_hlist_nth (ls ++ ls') n = Some (@existT iT (fun t => hlist (ls ++ ls') -> F t) (projT1 x) z) /\\ forall h h', projT2 x h = z (hlist_app h h').
Proof.
intros ls ls'.
revert ls.
induction ls.
simpl.
intros.
try congruence.
destruct n.
inv_all.
subst.
simpl.
eexists.
split.
eauto.
intros.
rewrite (hlist_eta h).

*****
h' : hlist ls'
h : hlist (cons a ls)
IHls : forall (n : nat) (x : sigT (fun t : iT => forall _ : hlist ls, F t))\n (_ : eq (nth_error_get_hlist_nth ls n) (Some x)),\nex\n (fun z : forall _ : hlist (app ls ls'), F (projT1 x) =>\n and\n (eq (nth_error_get_hlist_nth (app ls ls') n)\n (Some\n (existT (fun t : iT => forall _ : hlist (app ls ls'), F t)\n (projT1 x) z)))\n (forall (h : hlist ls) (h' : hlist ls'),\n eq (projT2 x h) (z (hlist_app h h'))))
ls : list iT
a : iT
ls' : list iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
eq (hlist_hd (Hcons (hlist_hd h) (hlist_tl h))) (hlist_hd (hlist_app (Hcons (hlist_hd h) (hlist_tl h)) h'))
+++++
reflexivity.
-----
Lemma nth_error_get_hlist_nth_weaken : forall ls ls' n x, nth_error_get_hlist_nth ls n = Some x -> exists z, nth_error_get_hlist_nth (ls ++ ls') n = Some (@existT iT (fun t => hlist (ls ++ ls') -> F t) (projT1 x) z) /\\ forall h h', projT2 x h = z (hlist_app h h').
Proof.
intros ls ls'.
revert ls.
induction ls.
simpl.
intros.
try congruence.
destruct n.

*****
H : eq\n match nth_error_get_hlist_nth ls n with\n | Some (@existT _ _ x f) =>\n Some\n (existT (fun t : iT => forall _ : hlist (cons a ls), F t) x\n (fun h : hlist (cons a ls) => f (hlist_tl h)))\n | None => None\n end (Some x)
x : sigT (fun t : iT => forall _ : hlist (cons a ls), F t)
n : nat
IHls : forall (n : nat) (x : sigT (fun t : iT => forall _ : hlist ls, F t))\n (_ : eq (nth_error_get_hlist_nth ls n) (Some x)),\nex\n (fun z : forall _ : hlist (app ls ls'), F (projT1 x) =>\n and\n (eq (nth_error_get_hlist_nth (app ls ls') n)\n (Some\n (existT (fun t : iT => forall _ : hlist (app ls ls'), F t)\n (projT1 x) z)))\n (forall (h : hlist ls) (h' : hlist ls'),\n eq (projT2 x h) (z (hlist_app h h'))))
ls : list iT
a : iT
ls' : list iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
ex (fun z : forall _ : hlist (cons a (app ls ls')), F (projT1 x) => and (eq match nth_error_get_hlist_nth (app ls ls') n with | Some (@existT _ _ x f) => Some (existT (fun t : iT => forall _ : hlist (cons a (app ls ls')), F t) x (fun h : hlist (cons a (app ls ls')) => f (hlist_tl h))) | None => None end (Some (existT (fun t : iT => forall _ : hlist (cons a (app ls ls')), F t) (projT1 x) z))) (forall (h : hlist (cons a ls)) (h' : hlist ls'), eq (projT2 x h) (z (hlist_app h h'))))
+++++
inv_all.
-----
Lemma nth_error_get_hlist_nth_weaken : forall ls ls' n x, nth_error_get_hlist_nth ls n = Some x -> exists z, nth_error_get_hlist_nth (ls ++ ls') n = Some (@existT iT (fun t => hlist (ls ++ ls') -> F t) (projT1 x) z) /\\ forall h h', projT2 x h = z (hlist_app h h').
Proof.
intros ls ls'.
revert ls.
induction ls.
simpl.
intros.
try congruence.
destruct n.
inv_all.

*****
H : eq\n match nth_error_get_hlist_nth ls n with\n | Some (@existT _ _ x f) =>\n Some\n (existT (fun t : iT => forall _ : hlist (cons a ls), F t) x\n (fun h : hlist (cons a ls) => f (hlist_tl h)))\n | None => None\n end (Some x)
x : sigT (fun t : iT => forall _ : hlist (cons a ls), F t)
n : nat
IHls : forall (n : nat) (x : sigT (fun t : iT => forall _ : hlist ls, F t))\n (_ : eq (nth_error_get_hlist_nth ls n) (Some x)),\nex\n (fun z : forall _ : hlist (app ls ls'), F (projT1 x) =>\n and\n (eq (nth_error_get_hlist_nth (app ls ls') n)\n (Some\n (existT (fun t : iT => forall _ : hlist (app ls ls'), F t)\n (projT1 x) z)))\n (forall (h : hlist ls) (h' : hlist ls'),\n eq (projT2 x h) (z (hlist_app h h'))))
ls : list iT
a : iT
ls' : list iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
ex (fun z : forall _ : hlist (cons a (app ls ls')), F (projT1 x) => and (eq match nth_error_get_hlist_nth (app ls ls') n with | Some (@existT _ _ x f) => Some (existT (fun t : iT => forall _ : hlist (cons a (app ls ls')), F t) x (fun h : hlist (cons a (app ls ls')) => f (hlist_tl h))) | None => None end (Some (existT (fun t : iT => forall _ : hlist (cons a (app ls ls')), F t) (projT1 x) z))) (forall (h : hlist (cons a ls)) (h' : hlist ls'), eq (projT2 x h) (z (hlist_app h h'))))
+++++
subst.
-----
Lemma nth_error_get_hlist_nth_weaken : forall ls ls' n x, nth_error_get_hlist_nth ls n = Some x -> exists z, nth_error_get_hlist_nth (ls ++ ls') n = Some (@existT iT (fun t => hlist (ls ++ ls') -> F t) (projT1 x) z) /\\ forall h h', projT2 x h = z (hlist_app h h').
Proof.
intros ls ls'.
revert ls.
induction ls.
simpl.
intros.
try congruence.
destruct n.
inv_all.
subst.

*****
H : eq\n match nth_error_get_hlist_nth ls n with\n | Some (@existT _ _ x f) =>\n Some\n (existT (fun t : iT => forall _ : hlist (cons a ls), F t) x\n (fun h : hlist (cons a ls) => f (hlist_tl h)))\n | None => None\n end (Some x)
x : sigT (fun t : iT => forall _ : hlist (cons a ls), F t)
n : nat
IHls : forall (n : nat) (x : sigT (fun t : iT => forall _ : hlist ls, F t))\n (_ : eq (nth_error_get_hlist_nth ls n) (Some x)),\nex\n (fun z : forall _ : hlist (app ls ls'), F (projT1 x) =>\n and\n (eq (nth_error_get_hlist_nth (app ls ls') n)\n (Some\n (existT (fun t : iT => forall _ : hlist (app ls ls'), F t)\n (projT1 x) z)))\n (forall (h : hlist ls) (h' : hlist ls'),\n eq (projT2 x h) (z (hlist_app h h'))))
ls : list iT
a : iT
ls' : list iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
ex (fun z : forall _ : hlist (cons a (app ls ls')), F (projT1 x) => and (eq match nth_error_get_hlist_nth (app ls ls') n with | Some (@existT _ _ x f) => Some (existT (fun t : iT => forall _ : hlist (cons a (app ls ls')), F t) x (fun h : hlist (cons a (app ls ls')) => f (hlist_tl h))) | None => None end (Some (existT (fun t : iT => forall _ : hlist (cons a (app ls ls')), F t) (projT1 x) z))) (forall (h : hlist (cons a ls)) (h' : hlist ls'), eq (projT2 x h) (z (hlist_app h h'))))
+++++
forward.
-----
Lemma nth_error_get_hlist_nth_weaken : forall ls ls' n x, nth_error_get_hlist_nth ls n = Some x -> exists z, nth_error_get_hlist_nth (ls ++ ls') n = Some (@existT iT (fun t => hlist (ls ++ ls') -> F t) (projT1 x) z) /\\ forall h h', projT2 x h = z (hlist_app h h').
Proof.
intros ls ls'.
revert ls.
induction ls.
simpl.
intros.
try congruence.
destruct n.
inv_all.
subst.
forward.

*****
H1 : eq\n (Some\n (existT (fun t : iT => forall _ : hlist (cons a ls), F t) x0\n (fun h : hlist (cons a ls) => f (hlist_tl h)))) \n (Some x)
H0 : eq (nth_error_get_hlist_nth ls n)\n (Some (existT (fun t : iT => forall _ : hlist ls, F t) x0 f))
H : eq s (existT (fun t : iT => forall _ : hlist ls, F t) x0 f)
f : forall _ : hlist ls, F x0
x0 : iT
s : sigT (fun t : iT => forall _ : hlist ls, F t)
x : sigT (fun t : iT => forall _ : hlist (cons a ls), F t)
n : nat
IHls : forall (n : nat) (x : sigT (fun t : iT => forall _ : hlist ls, F t))\n (_ : eq (nth_error_get_hlist_nth ls n) (Some x)),\nex\n (fun z : forall _ : hlist (app ls ls'), F (projT1 x) =>\n and\n (eq (nth_error_get_hlist_nth (app ls ls') n)\n (Some\n (existT (fun t : iT => forall _ : hlist (app ls ls'), F t)\n (projT1 x) z)))\n (forall (h : hlist ls) (h' : hlist ls'),\n eq (projT2 x h) (z (hlist_app h h'))))
ls : list iT
a : iT
ls' : list iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
ex (fun z : forall _ : hlist (cons a (app ls ls')), F (projT1 x) => and (eq match nth_error_get_hlist_nth (app ls ls') n with | Some (@existT _ _ x f) => Some (existT (fun t : iT => forall _ : hlist (cons a (app ls ls')), F t) x (fun h : hlist (cons a (app ls ls')) => f (hlist_tl h))) | None => None end (Some (existT (fun t : iT => forall _ : hlist (cons a (app ls ls')), F t) (projT1 x) z))) (forall (h : hlist (cons a ls)) (h' : hlist ls'), eq (projT2 x h) (z (hlist_app h h'))))
+++++
inv_all.
-----
Lemma nth_error_get_hlist_nth_weaken : forall ls ls' n x, nth_error_get_hlist_nth ls n = Some x -> exists z, nth_error_get_hlist_nth (ls ++ ls') n = Some (@existT iT (fun t => hlist (ls ++ ls') -> F t) (projT1 x) z) /\\ forall h h', projT2 x h = z (hlist_app h h').
Proof.
intros ls ls'.
revert ls.
induction ls.
simpl.
intros.
try congruence.
destruct n.
inv_all.
subst.
forward.
inv_all.

*****
H1 : eq\n (existT (fun t : iT => forall _ : hlist (cons a ls), F t) x0\n (fun h : hlist (cons a ls) => f (hlist_tl h))) x
H0 : eq (nth_error_get_hlist_nth ls n)\n (Some (existT (fun t : iT => forall _ : hlist ls, F t) x0 f))
H : eq s (existT (fun t : iT => forall _ : hlist ls, F t) x0 f)
f : forall _ : hlist ls, F x0
x0 : iT
s : sigT (fun t : iT => forall _ : hlist ls, F t)
x : sigT (fun t : iT => forall _ : hlist (cons a ls), F t)
n : nat
IHls : forall (n : nat) (x : sigT (fun t : iT => forall _ : hlist ls, F t))\n (_ : eq (nth_error_get_hlist_nth ls n) (Some x)),\nex\n (fun z : forall _ : hlist (app ls ls'), F (projT1 x) =>\n and\n (eq (nth_error_get_hlist_nth (app ls ls') n)\n (Some\n (existT (fun t : iT => forall _ : hlist (app ls ls'), F t)\n (projT1 x) z)))\n (forall (h : hlist ls) (h' : hlist ls'),\n eq (projT2 x h) (z (hlist_app h h'))))
ls : list iT
a : iT
ls' : list iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
ex (fun z : forall _ : hlist (cons a (app ls ls')), F (projT1 x) => and (eq match nth_error_get_hlist_nth (app ls ls') n with | Some (@existT _ _ x f) => Some (existT (fun t : iT => forall _ : hlist (cons a (app ls ls')), F t) x (fun h : hlist (cons a (app ls ls')) => f (hlist_tl h))) | None => None end (Some (existT (fun t : iT => forall _ : hlist (cons a (app ls ls')), F t) (projT1 x) z))) (forall (h : hlist (cons a ls)) (h' : hlist ls'), eq (projT2 x h) (z (hlist_app h h'))))
+++++
subst.
-----
Lemma nth_error_get_hlist_nth_weaken : forall ls ls' n x, nth_error_get_hlist_nth ls n = Some x -> exists z, nth_error_get_hlist_nth (ls ++ ls') n = Some (@existT iT (fun t => hlist (ls ++ ls') -> F t) (projT1 x) z) /\\ forall h h', projT2 x h = z (hlist_app h h').
Proof.
intros ls ls'.
revert ls.
induction ls.
simpl.
intros.
try congruence.
destruct n.
inv_all.
subst.
forward.
inv_all.
subst.

*****
H0 : eq (nth_error_get_hlist_nth ls n)\n (Some (existT (fun t : iT => forall _ : hlist ls, F t) x0 f))
f : forall _ : hlist ls, F x0
x0 : iT
n : nat
IHls : forall (n : nat) (x : sigT (fun t : iT => forall _ : hlist ls, F t))\n (_ : eq (nth_error_get_hlist_nth ls n) (Some x)),\nex\n (fun z : forall _ : hlist (app ls ls'), F (projT1 x) =>\n and\n (eq (nth_error_get_hlist_nth (app ls ls') n)\n (Some\n (existT (fun t : iT => forall _ : hlist (app ls ls'), F t)\n (projT1 x) z)))\n (forall (h : hlist ls) (h' : hlist ls'),\n eq (projT2 x h) (z (hlist_app h h'))))
ls : list iT
a : iT
ls' : list iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
ex (fun z : forall _ : hlist (cons a (app ls ls')), F (projT1 (existT (fun t : iT => forall _ : hlist (cons a ls), F t) x0 (fun h : hlist (cons a ls) => f (hlist_tl h)))) => and (eq match nth_error_get_hlist_nth (app ls ls') n with | Some (@existT _ _ x f) => Some (existT (fun t : iT => forall _ : hlist (cons a (app ls ls')), F t) x (fun h : hlist (cons a (app ls ls')) => f (hlist_tl h))) | None => None end (Some (existT (fun t : iT => forall _ : hlist (cons a (app ls ls')), F t) (projT1 (existT (fun t : iT => forall _ : hlist (cons a ls), F t) x0 (fun h : hlist (cons a ls) => f (hlist_tl h)))) z))) (forall (h : hlist (cons a ls)) (h' : hlist ls'), eq (projT2 (existT (fun t : iT => forall _ : hlist (cons a ls), F t) x0 (fun h0 : hlist (cons a ls) => f (hlist_tl h0))) h) (z (hlist_app h h'))))
+++++
simpl.
-----
Lemma nth_error_get_hlist_nth_weaken : forall ls ls' n x, nth_error_get_hlist_nth ls n = Some x -> exists z, nth_error_get_hlist_nth (ls ++ ls') n = Some (@existT iT (fun t => hlist (ls ++ ls') -> F t) (projT1 x) z) /\\ forall h h', projT2 x h = z (hlist_app h h').
Proof.
intros ls ls'.
revert ls.
induction ls.
simpl.
intros.
try congruence.
destruct n.
inv_all.
subst.
forward.
inv_all.
subst.
simpl.

*****
H0 : eq (nth_error_get_hlist_nth ls n)\n (Some (existT (fun t : iT => forall _ : hlist ls, F t) x0 f))
f : forall _ : hlist ls, F x0
x0 : iT
n : nat
IHls : forall (n : nat) (x : sigT (fun t : iT => forall _ : hlist ls, F t))\n (_ : eq (nth_error_get_hlist_nth ls n) (Some x)),\nex\n (fun z : forall _ : hlist (app ls ls'), F (projT1 x) =>\n and\n (eq (nth_error_get_hlist_nth (app ls ls') n)\n (Some\n (existT (fun t : iT => forall _ : hlist (app ls ls'), F t)\n (projT1 x) z)))\n (forall (h : hlist ls) (h' : hlist ls'),\n eq (projT2 x h) (z (hlist_app h h'))))
ls : list iT
a : iT
ls' : list iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
ex (fun z : forall _ : hlist (cons a (app ls ls')), F x0 => and (eq match nth_error_get_hlist_nth (app ls ls') n with | Some (@existT _ _ x f) => Some (existT (fun t : iT => forall _ : hlist (cons a (app ls ls')), F t) x (fun h : hlist (cons a (app ls ls')) => f (hlist_tl h))) | None => None end (Some (existT (fun t : iT => forall _ : hlist (cons a (app ls ls')), F t) x0 z))) (forall (h : hlist (cons a ls)) (h' : hlist ls'), eq (f (hlist_tl h)) (z (hlist_app h h'))))
+++++
apply IHls in H0.
-----
Lemma nth_error_get_hlist_nth_weaken : forall ls ls' n x, nth_error_get_hlist_nth ls n = Some x -> exists z, nth_error_get_hlist_nth (ls ++ ls') n = Some (@existT iT (fun t => hlist (ls ++ ls') -> F t) (projT1 x) z) /\\ forall h h', projT2 x h = z (hlist_app h h').
Proof.
intros ls ls'.
revert ls.
induction ls.
simpl.
intros.
try congruence.
destruct n.
inv_all.
subst.
forward.
inv_all.
subst.
simpl.
apply IHls in H0.

*****
H0 : ex\n (fun\n z : forall _ : hlist (app ls ls'),\n F\n (projT1\n (existT (fun t : iT => forall _ : hlist ls, F t) x0 f))\n =>\n and\n (eq (nth_error_get_hlist_nth (app ls ls') n)\n (Some\n (existT (fun t : iT => forall _ : hlist (app ls ls'), F t)\n (projT1\n (existT (fun t : iT => forall _ : hlist ls, F t) x0 f))\n z)))\n (forall (h : hlist ls) (h' : hlist ls'),\n eq\n (projT2 (existT (fun t : iT => forall _ : hlist ls, F t) x0 f)\n h) (z (hlist_app h h'))))
f : forall _ : hlist ls, F x0
x0 : iT
n : nat
IHls : forall (n : nat) (x : sigT (fun t : iT => forall _ : hlist ls, F t))\n (_ : eq (nth_error_get_hlist_nth ls n) (Some x)),\nex\n (fun z : forall _ : hlist (app ls ls'), F (projT1 x) =>\n and\n (eq (nth_error_get_hlist_nth (app ls ls') n)\n (Some\n (existT (fun t : iT => forall _ : hlist (app ls ls'), F t)\n (projT1 x) z)))\n (forall (h : hlist ls) (h' : hlist ls'),\n eq (projT2 x h) (z (hlist_app h h'))))
ls : list iT
a : iT
ls' : list iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
ex (fun z : forall _ : hlist (cons a (app ls ls')), F x0 => and (eq match nth_error_get_hlist_nth (app ls ls') n with | Some (@existT _ _ x f) => Some (existT (fun t : iT => forall _ : hlist (cons a (app ls ls')), F t) x (fun h : hlist (cons a (app ls ls')) => f (hlist_tl h))) | None => None end (Some (existT (fun t : iT => forall _ : hlist (cons a (app ls ls')), F t) x0 z))) (forall (h : hlist (cons a ls)) (h' : hlist ls'), eq (f (hlist_tl h)) (z (hlist_app h h'))))
+++++
forward_reason.
-----
Lemma nth_error_get_hlist_nth_weaken : forall ls ls' n x, nth_error_get_hlist_nth ls n = Some x -> exists z, nth_error_get_hlist_nth (ls ++ ls') n = Some (@existT iT (fun t => hlist (ls ++ ls') -> F t) (projT1 x) z) /\\ forall h h', projT2 x h = z (hlist_app h h').
Proof.
intros ls ls'.
revert ls.
induction ls.
simpl.
intros.
try congruence.
destruct n.
inv_all.
subst.
forward.
inv_all.
subst.
simpl.
apply IHls in H0.
forward_reason.

*****
H0 : forall (h : hlist ls) (h' : hlist ls'),\neq (projT2 (existT (fun t : iT => forall _ : hlist ls, F t) x0 f) h)\n (x (hlist_app h h'))
H : eq (nth_error_get_hlist_nth (app ls ls') n)\n (Some\n (existT (fun t : iT => forall _ : hlist (app ls ls'), F t)\n (projT1 (existT (fun t : iT => forall _ : hlist ls, F t) x0 f))\n x))
x : forall _ : hlist (app ls ls'),\nF (projT1 (existT (fun t : iT => forall _ : hlist ls, F t) x0 f))
f : forall _ : hlist ls, F x0
x0 : iT
n : nat
IHls : forall (n : nat) (x : sigT (fun t : iT => forall _ : hlist ls, F t))\n (_ : eq (nth_error_get_hlist_nth ls n) (Some x)),\nex\n (fun z : forall _ : hlist (app ls ls'), F (projT1 x) =>\n and\n (eq (nth_error_get_hlist_nth (app ls ls') n)\n (Some\n (existT (fun t : iT => forall _ : hlist (app ls ls'), F t)\n (projT1 x) z)))\n (forall (h : hlist ls) (h' : hlist ls'),\n eq (projT2 x h) (z (hlist_app h h'))))
ls : list iT
a : iT
ls' : list iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
ex (fun z : forall _ : hlist (cons a (app ls ls')), F x0 => and (eq match nth_error_get_hlist_nth (app ls ls') n with | Some (@existT _ _ x f) => Some (existT (fun t : iT => forall _ : hlist (cons a (app ls ls')), F t) x (fun h : hlist (cons a (app ls ls')) => f (hlist_tl h))) | None => None end (Some (existT (fun t : iT => forall _ : hlist (cons a (app ls ls')), F t) x0 z))) (forall (h : hlist (cons a ls)) (h' : hlist ls'), eq (f (hlist_tl h)) (z (hlist_app h h'))))
+++++
rewrite H.
-----
Lemma nth_error_get_hlist_nth_weaken : forall ls ls' n x, nth_error_get_hlist_nth ls n = Some x -> exists z, nth_error_get_hlist_nth (ls ++ ls') n = Some (@existT iT (fun t => hlist (ls ++ ls') -> F t) (projT1 x) z) /\\ forall h h', projT2 x h = z (hlist_app h h').
Proof.
intros ls ls'.
revert ls.
induction ls.
simpl.
intros.
try congruence.
destruct n.
inv_all.
subst.
forward.
inv_all.
subst.
simpl.
apply IHls in H0.
forward_reason.
rewrite H.

*****
H0 : forall (h : hlist ls) (h' : hlist ls'),\neq (projT2 (existT (fun t : iT => forall _ : hlist ls, F t) x0 f) h)\n (x (hlist_app h h'))
H : eq (nth_error_get_hlist_nth (app ls ls') n)\n (Some\n (existT (fun t : iT => forall _ : hlist (app ls ls'), F t)\n (projT1 (existT (fun t : iT => forall _ : hlist ls, F t) x0 f))\n x))
x : forall _ : hlist (app ls ls'),\nF (projT1 (existT (fun t : iT => forall _ : hlist ls, F t) x0 f))
f : forall _ : hlist ls, F x0
x0 : iT
n : nat
IHls : forall (n : nat) (x : sigT (fun t : iT => forall _ : hlist ls, F t))\n (_ : eq (nth_error_get_hlist_nth ls n) (Some x)),\nex\n (fun z : forall _ : hlist (app ls ls'), F (projT1 x) =>\n and\n (eq (nth_error_get_hlist_nth (app ls ls') n)\n (Some\n (existT (fun t : iT => forall _ : hlist (app ls ls'), F t)\n (projT1 x) z)))\n (forall (h : hlist ls) (h' : hlist ls'),\n eq (projT2 x h) (z (hlist_app h h'))))
ls : list iT
a : iT
ls' : list iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
ex (fun z : forall _ : hlist (cons a (app ls ls')), F x0 => and (eq (Some (existT (fun t : iT => forall _ : hlist (cons a (app ls ls')), F t) (projT1 (existT (fun t : iT => forall _ : hlist ls, F t) x0 f)) (fun h : hlist (cons a (app ls ls')) => x (hlist_tl h)))) (Some (existT (fun t : iT => forall _ : hlist (cons a (app ls ls')), F t) x0 z))) (forall (h : hlist (cons a ls)) (h' : hlist ls'), eq (f (hlist_tl h)) (z (hlist_app h h'))))
+++++
eexists.
-----
Lemma nth_error_get_hlist_nth_weaken : forall ls ls' n x, nth_error_get_hlist_nth ls n = Some x -> exists z, nth_error_get_hlist_nth (ls ++ ls') n = Some (@existT iT (fun t => hlist (ls ++ ls') -> F t) (projT1 x) z) /\\ forall h h', projT2 x h = z (hlist_app h h').
Proof.
intros ls ls'.
revert ls.
induction ls.
simpl.
intros.
try congruence.
destruct n.
inv_all.
subst.
forward.
inv_all.
subst.
simpl.
apply IHls in H0.
forward_reason.
rewrite H.
eexists.

*****
H0 : forall (h : hlist ls) (h' : hlist ls'),\neq (projT2 (existT (fun t : iT => forall _ : hlist ls, F t) x0 f) h)\n (x (hlist_app h h'))
H : eq (nth_error_get_hlist_nth (app ls ls') n)\n (Some\n (existT (fun t : iT => forall _ : hlist (app ls ls'), F t)\n (projT1 (existT (fun t : iT => forall _ : hlist ls, F t) x0 f))\n x))
x : forall _ : hlist (app ls ls'),\nF (projT1 (existT (fun t : iT => forall _ : hlist ls, F t) x0 f))
f : forall _ : hlist ls, F x0
x0 : iT
n : nat
IHls : forall (n : nat) (x : sigT (fun t : iT => forall _ : hlist ls, F t))\n (_ : eq (nth_error_get_hlist_nth ls n) (Some x)),\nex\n (fun z : forall _ : hlist (app ls ls'), F (projT1 x) =>\n and\n (eq (nth_error_get_hlist_nth (app ls ls') n)\n (Some\n (existT (fun t : iT => forall _ : hlist (app ls ls'), F t)\n (projT1 x) z)))\n (forall (h : hlist ls) (h' : hlist ls'),\n eq (projT2 x h) (z (hlist_app h h'))))
ls : list iT
a : iT
ls' : list iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
and (eq (Some (existT (fun t : iT => forall _ : hlist (cons a (app ls ls')), F t) (projT1 (existT (fun t : iT => forall _ : hlist ls, F t) x0 f)) (fun h : hlist (cons a (app ls ls')) => x (hlist_tl h)))) (Some (existT (fun t : iT => forall _ : hlist (cons a (app ls ls')), F t) x0 ?z))) (forall (h : hlist (cons a ls)) (h' : hlist ls'), eq (f (hlist_tl h)) (?z (hlist_app h h')))
+++++
split.
-----
Lemma nth_error_get_hlist_nth_weaken : forall ls ls' n x, nth_error_get_hlist_nth ls n = Some x -> exists z, nth_error_get_hlist_nth (ls ++ ls') n = Some (@existT iT (fun t => hlist (ls ++ ls') -> F t) (projT1 x) z) /\\ forall h h', projT2 x h = z (hlist_app h h').
Proof.
intros ls ls'.
revert ls.
induction ls.
simpl.
intros.
try congruence.
destruct n.
inv_all.
subst.
forward.
inv_all.
subst.
simpl.
apply IHls in H0.
forward_reason.
rewrite H.
eexists.
split.

*****
H0 : forall (h : hlist ls) (h' : hlist ls'),\neq (projT2 (existT (fun t : iT => forall _ : hlist ls, F t) x0 f) h)\n (x (hlist_app h h'))
H : eq (nth_error_get_hlist_nth (app ls ls') n)\n (Some\n (existT (fun t : iT => forall _ : hlist (app ls ls'), F t)\n (projT1 (existT (fun t : iT => forall _ : hlist ls, F t) x0 f))\n x))
x : forall _ : hlist (app ls ls'),\nF (projT1 (existT (fun t : iT => forall _ : hlist ls, F t) x0 f))
f : forall _ : hlist ls, F x0
x0 : iT
n : nat
IHls : forall (n : nat) (x : sigT (fun t : iT => forall _ : hlist ls, F t))\n (_ : eq (nth_error_get_hlist_nth ls n) (Some x)),\nex\n (fun z : forall _ : hlist (app ls ls'), F (projT1 x) =>\n and\n (eq (nth_error_get_hlist_nth (app ls ls') n)\n (Some\n (existT (fun t : iT => forall _ : hlist (app ls ls'), F t)\n (projT1 x) z)))\n (forall (h : hlist ls) (h' : hlist ls'),\n eq (projT2 x h) (z (hlist_app h h'))))
ls : list iT
a : iT
ls' : list iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
eq (Some (existT (fun t : iT => forall _ : hlist (cons a (app ls ls')), F t) (projT1 (existT (fun t : iT => forall _ : hlist ls, F t) x0 f)) (fun h : hlist (cons a (app ls ls')) => x (hlist_tl h)))) (Some (existT (fun t : iT => forall _ : hlist (cons a (app ls ls')), F t) x0 ?z))
+++++
eauto.
-----
Lemma nth_error_get_hlist_nth_weaken : forall ls ls' n x, nth_error_get_hlist_nth ls n = Some x -> exists z, nth_error_get_hlist_nth (ls ++ ls') n = Some (@existT iT (fun t => hlist (ls ++ ls') -> F t) (projT1 x) z) /\\ forall h h', projT2 x h = z (hlist_app h h').
Proof.
intros ls ls'.
revert ls.
induction ls.
simpl.
intros.
try congruence.
destruct n.
inv_all.
subst.
forward.
inv_all.
subst.
simpl.
apply IHls in H0.
forward_reason.
rewrite H.
eexists.
split.

*****
H0 : forall (h : hlist ls) (h' : hlist ls'),\neq (projT2 (existT (fun t : iT => forall _ : hlist ls, F t) x0 f) h)\n (x (hlist_app h h'))
H : eq (nth_error_get_hlist_nth (app ls ls') n)\n (Some\n (existT (fun t : iT => forall _ : hlist (app ls ls'), F t)\n (projT1 (existT (fun t : iT => forall _ : hlist ls, F t) x0 f))\n x))
x : forall _ : hlist (app ls ls'),\nF (projT1 (existT (fun t : iT => forall _ : hlist ls, F t) x0 f))
f : forall _ : hlist ls, F x0
x0 : iT
n : nat
IHls : forall (n : nat) (x : sigT (fun t : iT => forall _ : hlist ls, F t))\n (_ : eq (nth_error_get_hlist_nth ls n) (Some x)),\nex\n (fun z : forall _ : hlist (app ls ls'), F (projT1 x) =>\n and\n (eq (nth_error_get_hlist_nth (app ls ls') n)\n (Some\n (existT (fun t : iT => forall _ : hlist (app ls ls'), F t)\n (projT1 x) z)))\n (forall (h : hlist ls) (h' : hlist ls'),\n eq (projT2 x h) (z (hlist_app h h'))))
ls : list iT
a : iT
ls' : list iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall (h : hlist (cons a ls)) (h' : hlist ls'), eq (f (hlist_tl h)) ((fun h0 : hlist (cons a (app ls ls')) => x (hlist_tl h0)) (hlist_app h h'))
+++++
eauto.
-----
Lemma nth_error_get_hlist_nth_weaken : forall ls ls' n x, nth_error_get_hlist_nth ls n = Some x -> exists z, nth_error_get_hlist_nth (ls ++ ls') n = Some (@existT iT (fun t => hlist (ls ++ ls') -> F t) (projT1 x) z) /\\ forall h h', projT2 x h = z (hlist_app h h').
Proof.
intros ls ls'.
revert ls.
induction ls.
simpl.
intros.
try congruence.
destruct n.
inv_all.
subst.
forward.
inv_all.
subst.
simpl.
apply IHls in H0.
forward_reason.
rewrite H.
eexists.
split.
eauto.

*****
H0 : forall (h : hlist ls) (h' : hlist ls'),\neq (projT2 (existT (fun t : iT => forall _ : hlist ls, F t) x0 f) h)\n (x (hlist_app h h'))
H : eq (nth_error_get_hlist_nth (app ls ls') n)\n (Some\n (existT (fun t : iT => forall _ : hlist (app ls ls'), F t)\n (projT1 (existT (fun t : iT => forall _ : hlist ls, F t) x0 f))\n x))
x : forall _ : hlist (app ls ls'),\nF (projT1 (existT (fun t : iT => forall _ : hlist ls, F t) x0 f))
f : forall _ : hlist ls, F x0
x0 : iT
n : nat
IHls : forall (n : nat) (x : sigT (fun t : iT => forall _ : hlist ls, F t))\n (_ : eq (nth_error_get_hlist_nth ls n) (Some x)),\nex\n (fun z : forall _ : hlist (app ls ls'), F (projT1 x) =>\n and\n (eq (nth_error_get_hlist_nth (app ls ls') n)\n (Some\n (existT (fun t : iT => forall _ : hlist (app ls ls'), F t)\n (projT1 x) z)))\n (forall (h : hlist ls) (h' : hlist ls'),\n eq (projT2 x h) (z (hlist_app h h'))))
ls : list iT
a : iT
ls' : list iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall (h : hlist (cons a ls)) (h' : hlist ls'), eq (f (hlist_tl h)) ((fun h0 : hlist (cons a (app ls ls')) => x (hlist_tl h0)) (hlist_app h h'))
+++++
intros.
-----
Lemma nth_error_get_hlist_nth_weaken : forall ls ls' n x, nth_error_get_hlist_nth ls n = Some x -> exists z, nth_error_get_hlist_nth (ls ++ ls') n = Some (@existT iT (fun t => hlist (ls ++ ls') -> F t) (projT1 x) z) /\\ forall h h', projT2 x h = z (hlist_app h h').
Proof.
intros ls ls'.
revert ls.
induction ls.
simpl.
intros.
try congruence.
destruct n.
inv_all.
subst.
forward.
inv_all.
subst.
simpl.
apply IHls in H0.
forward_reason.
rewrite H.
eexists.
split.
eauto.
intros.

*****
h' : hlist ls'
h : hlist (cons a ls)
H0 : forall (h : hlist ls) (h' : hlist ls'),\neq (projT2 (existT (fun t : iT => forall _ : hlist ls, F t) x0 f) h)\n (x (hlist_app h h'))
H : eq (nth_error_get_hlist_nth (app ls ls') n)\n (Some\n (existT (fun t : iT => forall _ : hlist (app ls ls'), F t)\n (projT1 (existT (fun t : iT => forall _ : hlist ls, F t) x0 f))\n x))
x : forall _ : hlist (app ls ls'),\nF (projT1 (existT (fun t : iT => forall _ : hlist ls, F t) x0 f))
f : forall _ : hlist ls, F x0
x0 : iT
n : nat
IHls : forall (n : nat) (x : sigT (fun t : iT => forall _ : hlist ls, F t))\n (_ : eq (nth_error_get_hlist_nth ls n) (Some x)),\nex\n (fun z : forall _ : hlist (app ls ls'), F (projT1 x) =>\n and\n (eq (nth_error_get_hlist_nth (app ls ls') n)\n (Some\n (existT (fun t : iT => forall _ : hlist (app ls ls'), F t)\n (projT1 x) z)))\n (forall (h : hlist ls) (h' : hlist ls'),\n eq (projT2 x h) (z (hlist_app h h'))))
ls : list iT
a : iT
ls' : list iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
eq (f (hlist_tl h)) ((fun h : hlist (cons a (app ls ls')) => x (hlist_tl h)) (hlist_app h h'))
+++++
rewrite (hlist_eta h).
-----
Lemma nth_error_get_hlist_nth_weaken : forall ls ls' n x, nth_error_get_hlist_nth ls n = Some x -> exists z, nth_error_get_hlist_nth (ls ++ ls') n = Some (@existT iT (fun t => hlist (ls ++ ls') -> F t) (projT1 x) z) /\\ forall h h', projT2 x h = z (hlist_app h h').
Proof.
intros ls ls'.
revert ls.
induction ls.
simpl.
intros.
try congruence.
destruct n.
inv_all.
subst.
forward.
inv_all.
subst.
simpl.
apply IHls in H0.
forward_reason.
rewrite H.
eexists.
split.
eauto.
intros.
rewrite (hlist_eta h).

*****
h' : hlist ls'
h : hlist (cons a ls)
H0 : forall (h : hlist ls) (h' : hlist ls'),\neq (projT2 (existT (fun t : iT => forall _ : hlist ls, F t) x0 f) h)\n (x (hlist_app h h'))
H : eq (nth_error_get_hlist_nth (app ls ls') n)\n (Some\n (existT (fun t : iT => forall _ : hlist (app ls ls'), F t)\n (projT1 (existT (fun t : iT => forall _ : hlist ls, F t) x0 f))\n x))
x : forall _ : hlist (app ls ls'),\nF (projT1 (existT (fun t : iT => forall _ : hlist ls, F t) x0 f))
f : forall _ : hlist ls, F x0
x0 : iT
n : nat
IHls : forall (n : nat) (x : sigT (fun t : iT => forall _ : hlist ls, F t))\n (_ : eq (nth_error_get_hlist_nth ls n) (Some x)),\nex\n (fun z : forall _ : hlist (app ls ls'), F (projT1 x) =>\n and\n (eq (nth_error_get_hlist_nth (app ls ls') n)\n (Some\n (existT (fun t : iT => forall _ : hlist (app ls ls'), F t)\n (projT1 x) z)))\n (forall (h : hlist ls) (h' : hlist ls'),\n eq (projT2 x h) (z (hlist_app h h'))))
ls : list iT
a : iT
ls' : list iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
eq (f (hlist_tl (Hcons (hlist_hd h) (hlist_tl h)))) (x (hlist_tl (hlist_app (Hcons (hlist_hd h) (hlist_tl h)) h')))
+++++
simpl in *.
-----
Lemma nth_error_get_hlist_nth_weaken : forall ls ls' n x, nth_error_get_hlist_nth ls n = Some x -> exists z, nth_error_get_hlist_nth (ls ++ ls') n = Some (@existT iT (fun t => hlist (ls ++ ls') -> F t) (projT1 x) z) /\\ forall h h', projT2 x h = z (hlist_app h h').
Proof.
intros ls ls'.
revert ls.
induction ls.
simpl.
intros.
try congruence.
destruct n.
inv_all.
subst.
forward.
inv_all.
subst.
simpl.
apply IHls in H0.
forward_reason.
rewrite H.
eexists.
split.
eauto.
intros.
rewrite (hlist_eta h).
simpl in *.

*****
h' : hlist ls'
h : hlist (cons a ls)
H0 : forall (h : hlist ls) (h' : hlist ls'), eq (f h) (x (hlist_app h h'))
H : eq (nth_error_get_hlist_nth (app ls ls') n)\n (Some\n (existT (fun t : iT => forall _ : hlist (app ls ls'), F t) x0 x))
x : forall _ : hlist (app ls ls'), F x0
f : forall _ : hlist ls, F x0
x0 : iT
n : nat
IHls : forall (n : nat) (x : sigT (fun t : iT => forall _ : hlist ls, F t))\n (_ : eq (nth_error_get_hlist_nth ls n) (Some x)),\nex\n (fun z : forall _ : hlist (app ls ls'), F (projT1 x) =>\n and\n (eq (nth_error_get_hlist_nth (app ls ls') n)\n (Some\n (existT (fun t : iT => forall _ : hlist (app ls ls'), F t)\n (projT1 x) z)))\n (forall (h : hlist ls) (h' : hlist ls'),\n eq (projT2 x h) (z (hlist_app h h'))))
ls : list iT
a : iT
ls' : list iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
eq (f (hlist_tl h)) (x (hlist_app (hlist_tl h) h'))
+++++
auto.
-----
Lemma nth_error_get_hlist_nth_weaken : forall ls ls' n x, nth_error_get_hlist_nth ls n = Some x -> exists z, nth_error_get_hlist_nth (ls ++ ls') n = Some (@existT iT (fun t => hlist (ls ++ ls') -> F t) (projT1 x) z) /\\ forall h h', projT2 x h = z (hlist_app h h').
Proof.
intros ls ls'.
revert ls.
induction ls.

*****

*****

+++++
Qed.
-----
Lemma nth_error_get_hlist_nth_appL\n  : forall tvs' tvs n,\n      n < length tvs ->\n      exists x,\n        nth_error_get_hlist_nth (tvs ++ tvs') n = Some x /\\n        exists y,\n          nth_error_get_hlist_nth tvs n = Some (@existT _ _ (projT1 x) y) /\\n          forall vs vs',\n            (projT2 x) (hlist_app vs vs') = y vs.
-----
Lemma nth_error_get_hlist_nth_appL : forall tvs' tvs n, n < length tvs -> exists x, nth_error_get_hlist_nth (tvs ++ tvs') n = Some x /\\ exists y, nth_error_get_hlist_nth tvs n = Some (@existT _ _ (projT1 x) y) /\\ forall vs vs', (projT2 x) (hlist_app vs vs') = y vs.

*****
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall (tvs' tvs : list iT) (n : nat) (_ : lt n (length tvs)), ex (fun x : sigT (fun t : iT => forall _ : hlist (app tvs tvs'), F t) => and (eq (nth_error_get_hlist_nth (app tvs tvs') n) (Some x)) (ex (fun y : (fun t : iT => forall _ : hlist tvs, F t) (projT1 x) => and (eq (nth_error_get_hlist_nth tvs n) (Some (existT (fun t : iT => forall _ : hlist tvs, F t) (projT1 x) y))) (forall (vs : hlist tvs) (vs' : hlist tvs'), eq (projT2 x (hlist_app vs vs')) (y vs)))))
+++++
Proof.
-----
Lemma nth_error_get_hlist_nth_appL : forall tvs' tvs n, n < length tvs -> exists x, nth_error_get_hlist_nth (tvs ++ tvs') n = Some x /\\ exists y, nth_error_get_hlist_nth tvs n = Some (@existT _ _ (projT1 x) y) /\\ forall vs vs', (projT2 x) (hlist_app vs vs') = y vs.
Proof.

*****
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall (tvs' tvs : list iT) (n : nat) (_ : lt n (length tvs)), ex (fun x : sigT (fun t : iT => forall _ : hlist (app tvs tvs'), F t) => and (eq (nth_error_get_hlist_nth (app tvs tvs') n) (Some x)) (ex (fun y : (fun t : iT => forall _ : hlist tvs, F t) (projT1 x) => and (eq (nth_error_get_hlist_nth tvs n) (Some (existT (fun t : iT => forall _ : hlist tvs, F t) (projT1 x) y))) (forall (vs : hlist tvs) (vs' : hlist tvs'), eq (projT2 x (hlist_app vs vs')) (y vs)))))
+++++
clear.
-----
Lemma nth_error_get_hlist_nth_appL : forall tvs' tvs n, n < length tvs -> exists x, nth_error_get_hlist_nth (tvs ++ tvs') n = Some x /\\ exists y, nth_error_get_hlist_nth tvs n = Some (@existT _ _ (projT1 x) y) /\\ forall vs vs', (projT2 x) (hlist_app vs vs') = y vs.
Proof.
clear.

*****
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall (tvs' tvs : list iT) (n : nat) (_ : lt n (length tvs)), ex (fun x : sigT (fun t : iT => forall _ : hlist (app tvs tvs'), F t) => and (eq (nth_error_get_hlist_nth (app tvs tvs') n) (Some x)) (ex (fun y : (fun t : iT => forall _ : hlist tvs, F t) (projT1 x) => and (eq (nth_error_get_hlist_nth tvs n) (Some (existT (fun t : iT => forall _ : hlist tvs, F t) (projT1 x) y))) (forall (vs : hlist tvs) (vs' : hlist tvs'), eq (projT2 x (hlist_app vs vs')) (y vs)))))
+++++
induction tvs.
-----
Lemma nth_error_get_hlist_nth_appL : forall tvs' tvs n, n < length tvs -> exists x, nth_error_get_hlist_nth (tvs ++ tvs') n = Some x /\\ exists y, nth_error_get_hlist_nth tvs n = Some (@existT _ _ (projT1 x) y) /\\ forall vs vs', (projT2 x) (hlist_app vs vs') = y vs.
Proof.
clear.
induction tvs.

*****
tvs' : list iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall (n : nat) (_ : lt n (length nil)), ex (fun x : sigT (fun t : iT => forall _ : hlist (app nil tvs'), F t) => and (eq (nth_error_get_hlist_nth (app nil tvs') n) (Some x)) (ex (fun y : forall _ : hlist nil, F (projT1 x) => and (eq (nth_error_get_hlist_nth nil n) (Some (existT (fun t : iT => forall _ : hlist nil, F t) (projT1 x) y))) (forall (vs : hlist nil) (vs' : hlist tvs'), eq (projT2 x (hlist_app vs vs')) (y vs)))))
+++++
simpl.
-----
Lemma nth_error_get_hlist_nth_appL : forall tvs' tvs n, n < length tvs -> exists x, nth_error_get_hlist_nth (tvs ++ tvs') n = Some x /\\ exists y, nth_error_get_hlist_nth tvs n = Some (@existT _ _ (projT1 x) y) /\\ forall vs vs', (projT2 x) (hlist_app vs vs') = y vs.
Proof.
clear.
induction tvs.
simpl.

*****
tvs' : list iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall (n : nat) (_ : lt n O), ex (fun x : sigT (fun t : iT => forall _ : hlist tvs', F t) => and (eq (nth_error_get_hlist_nth tvs' n) (Some x)) (ex (fun y : forall _ : hlist nil, F (projT1 x) => and (eq None (Some (existT (fun t : iT => forall _ : hlist nil, F t) (projT1 x) y))) (forall (vs : hlist nil) (vs' : hlist tvs'), eq (projT2 x (hlist_app vs vs')) (y vs)))))
+++++
intros.
-----
Lemma nth_error_get_hlist_nth_appL : forall tvs' tvs n, n < length tvs -> exists x, nth_error_get_hlist_nth (tvs ++ tvs') n = Some x /\\ exists y, nth_error_get_hlist_nth tvs n = Some (@existT _ _ (projT1 x) y) /\\ forall vs vs', (projT2 x) (hlist_app vs vs') = y vs.
Proof.
clear.
induction tvs.
simpl.
intros.

*****
H : lt n O
n : nat
tvs' : list iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
ex (fun x : sigT (fun t : iT => forall _ : hlist tvs', F t) => and (eq (nth_error_get_hlist_nth tvs' n) (Some x)) (ex (fun y : forall _ : hlist nil, F (projT1 x) => and (eq None (Some (existT (fun t : iT => forall _ : hlist nil, F t) (projT1 x) y))) (forall (vs : hlist nil) (vs' : hlist tvs'), eq (projT2 x (hlist_app vs vs')) (y vs)))))
+++++
exfalso.
-----
Lemma nth_error_get_hlist_nth_appL : forall tvs' tvs n, n < length tvs -> exists x, nth_error_get_hlist_nth (tvs ++ tvs') n = Some x /\\ exists y, nth_error_get_hlist_nth tvs n = Some (@existT _ _ (projT1 x) y) /\\ forall vs vs', (projT2 x) (hlist_app vs vs') = y vs.
Proof.
clear.
induction tvs.
simpl.
intros.
exfalso.

*****
H : lt n O
n : nat
tvs' : list iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
False
+++++
inversion H.
-----
Lemma nth_error_get_hlist_nth_appL : forall tvs' tvs n, n < length tvs -> exists x, nth_error_get_hlist_nth (tvs ++ tvs') n = Some x /\\ exists y, nth_error_get_hlist_nth tvs n = Some (@existT _ _ (projT1 x) y) /\\ forall vs vs', (projT2 x) (hlist_app vs vs') = y vs.
Proof.
clear.
induction tvs.

*****
IHtvs : forall (n : nat) (_ : lt n (length tvs)),\nex\n (fun x : sigT (fun t : iT => forall _ : hlist (app tvs tvs'), F t) =>\n and (eq (nth_error_get_hlist_nth (app tvs tvs') n) (Some x))\n (ex\n (fun y : forall _ : hlist tvs, F (projT1 x) =>\n and\n (eq (nth_error_get_hlist_nth tvs n)\n (Some\n (existT (fun t : iT => forall _ : hlist tvs, F t)\n (projT1 x) y)))\n (forall (vs : hlist tvs) (vs' : hlist tvs'),\n eq (projT2 x (hlist_app vs vs')) (y vs)))))
tvs : list iT
a : iT
tvs' : list iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall (n : nat) (_ : lt n (length (cons a tvs))), ex (fun x : sigT (fun t : iT => forall _ : hlist (app (cons a tvs) tvs'), F t) => and (eq (nth_error_get_hlist_nth (app (cons a tvs) tvs') n) (Some x)) (ex (fun y : forall _ : hlist (cons a tvs), F (projT1 x) => and (eq (nth_error_get_hlist_nth (cons a tvs) n) (Some (existT (fun t : iT => forall _ : hlist (cons a tvs), F t) (projT1 x) y))) (forall (vs : hlist (cons a tvs)) (vs' : hlist tvs'), eq (projT2 x (hlist_app vs vs')) (y vs)))))
+++++
simpl.
-----
Lemma nth_error_get_hlist_nth_appL : forall tvs' tvs n, n < length tvs -> exists x, nth_error_get_hlist_nth (tvs ++ tvs') n = Some x /\\ exists y, nth_error_get_hlist_nth tvs n = Some (@existT _ _ (projT1 x) y) /\\ forall vs vs', (projT2 x) (hlist_app vs vs') = y vs.
Proof.
clear.
induction tvs.
simpl.

*****
IHtvs : forall (n : nat) (_ : lt n (length tvs)),\nex\n (fun x : sigT (fun t : iT => forall _ : hlist (app tvs tvs'), F t) =>\n and (eq (nth_error_get_hlist_nth (app tvs tvs') n) (Some x))\n (ex\n (fun y : forall _ : hlist tvs, F (projT1 x) =>\n and\n (eq (nth_error_get_hlist_nth tvs n)\n (Some\n (existT (fun t : iT => forall _ : hlist tvs, F t)\n (projT1 x) y)))\n (forall (vs : hlist tvs) (vs' : hlist tvs'),\n eq (projT2 x (hlist_app vs vs')) (y vs)))))
tvs : list iT
a : iT
tvs' : list iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall (n : nat) (_ : lt n (S (length tvs))), ex (fun x : sigT (fun t : iT => forall _ : hlist (cons a (app tvs tvs')), F t) => and (eq match n with | O => Some (existT (fun t : iT => forall _ : hlist (cons a (app tvs tvs')), F t) a hlist_hd) | S n0 => match nth_error_get_hlist_nth (app tvs tvs') n0 with | Some (@existT _ _ x0 f) => Some (existT (fun t : iT => forall _ : hlist (cons a (app tvs tvs')), F t) x0 (fun h : hlist (cons a (app tvs tvs')) => f (hlist_tl h))) | None => None end end (Some x)) (ex (fun y : forall _ : hlist (cons a tvs), F (projT1 x) => and (eq match n with | O => Some (existT (fun t : iT => forall _ : hlist (cons a tvs), F t) a hlist_hd) | S n0 => match nth_error_get_hlist_nth tvs n0 with | Some (@existT _ _ x0 f) => Some (existT (fun t : iT => forall _ : hlist (cons a tvs), F t) x0 (fun h : hlist (cons a tvs) => f (hlist_tl h))) | None => None end end (Some (existT (fun t : iT => forall _ : hlist (cons a tvs), F t) (projT1 x) y))) (forall (vs : hlist (cons a tvs)) (vs' : hlist tvs'), eq (projT2 x (hlist_app vs vs')) (y vs)))))
+++++
intros.
-----
Lemma nth_error_get_hlist_nth_appL : forall tvs' tvs n, n < length tvs -> exists x, nth_error_get_hlist_nth (tvs ++ tvs') n = Some x /\\ exists y, nth_error_get_hlist_nth tvs n = Some (@existT _ _ (projT1 x) y) /\\ forall vs vs', (projT2 x) (hlist_app vs vs') = y vs.
Proof.
clear.
induction tvs.
simpl.
intros.

*****
H : lt n (S (length tvs))
n : nat
IHtvs : forall (n : nat) (_ : lt n (length tvs)),\nex\n (fun x : sigT (fun t : iT => forall _ : hlist (app tvs tvs'), F t) =>\n and (eq (nth_error_get_hlist_nth (app tvs tvs') n) (Some x))\n (ex\n (fun y : forall _ : hlist tvs, F (projT1 x) =>\n and\n (eq (nth_error_get_hlist_nth tvs n)\n (Some\n (existT (fun t : iT => forall _ : hlist tvs, F t)\n (projT1 x) y)))\n (forall (vs : hlist tvs) (vs' : hlist tvs'),\n eq (projT2 x (hlist_app vs vs')) (y vs)))))
tvs : list iT
a : iT
tvs' : list iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
ex (fun x : sigT (fun t : iT => forall _ : hlist (cons a (app tvs tvs')), F t) => and (eq match n with | O => Some (existT (fun t : iT => forall _ : hlist (cons a (app tvs tvs')), F t) a hlist_hd) | S n0 => match nth_error_get_hlist_nth (app tvs tvs') n0 with | Some (@existT _ _ x0 f) => Some (existT (fun t : iT => forall _ : hlist (cons a (app tvs tvs')), F t) x0 (fun h : hlist (cons a (app tvs tvs')) => f (hlist_tl h))) | None => None end end (Some x)) (ex (fun y : forall _ : hlist (cons a tvs), F (projT1 x) => and (eq match n with | O => Some (existT (fun t : iT => forall _ : hlist (cons a tvs), F t) a hlist_hd) | S n0 => match nth_error_get_hlist_nth tvs n0 with | Some (@existT _ _ x0 f) => Some (existT (fun t : iT => forall _ : hlist (cons a tvs), F t) x0 (fun h : hlist (cons a tvs) => f (hlist_tl h))) | None => None end end (Some (existT (fun t : iT => forall _ : hlist (cons a tvs), F t) (projT1 x) y))) (forall (vs : hlist (cons a tvs)) (vs' : hlist tvs'), eq (projT2 x (hlist_app vs vs')) (y vs)))))
+++++
destruct n.
-----
Lemma nth_error_get_hlist_nth_appL : forall tvs' tvs n, n < length tvs -> exists x, nth_error_get_hlist_nth (tvs ++ tvs') n = Some x /\\ exists y, nth_error_get_hlist_nth tvs n = Some (@existT _ _ (projT1 x) y) /\\ forall vs vs', (projT2 x) (hlist_app vs vs') = y vs.
Proof.
clear.
induction tvs.
simpl.
intros.
destruct n.

*****
H : lt O (S (length tvs))
IHtvs : forall (n : nat) (_ : lt n (length tvs)),\nex\n (fun x : sigT (fun t : iT => forall _ : hlist (app tvs tvs'), F t) =>\n and (eq (nth_error_get_hlist_nth (app tvs tvs') n) (Some x))\n (ex\n (fun y : forall _ : hlist tvs, F (projT1 x) =>\n and\n (eq (nth_error_get_hlist_nth tvs n)\n (Some\n (existT (fun t : iT => forall _ : hlist tvs, F t)\n (projT1 x) y)))\n (forall (vs : hlist tvs) (vs' : hlist tvs'),\n eq (projT2 x (hlist_app vs vs')) (y vs)))))
tvs : list iT
a : iT
tvs' : list iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
ex (fun x : sigT (fun t : iT => forall _ : hlist (cons a (app tvs tvs')), F t) => and (eq (Some (existT (fun t : iT => forall _ : hlist (cons a (app tvs tvs')), F t) a hlist_hd)) (Some x)) (ex (fun y : forall _ : hlist (cons a tvs), F (projT1 x) => and (eq (Some (existT (fun t : iT => forall _ : hlist (cons a tvs), F t) a hlist_hd)) (Some (existT (fun t : iT => forall _ : hlist (cons a tvs), F t) (projT1 x) y))) (forall (vs : hlist (cons a tvs)) (vs' : hlist tvs'), eq (projT2 x (hlist_app vs vs')) (y vs)))))
+++++
clear H IHtvs.
-----
Lemma nth_error_get_hlist_nth_appL : forall tvs' tvs n, n < length tvs -> exists x, nth_error_get_hlist_nth (tvs ++ tvs') n = Some x /\\ exists y, nth_error_get_hlist_nth tvs n = Some (@existT _ _ (projT1 x) y) /\\ forall vs vs', (projT2 x) (hlist_app vs vs') = y vs.
Proof.
clear.
induction tvs.
simpl.
intros.
destruct n.
clear H IHtvs.

*****
tvs : list iT
a : iT
tvs' : list iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
ex (fun x : sigT (fun t : iT => forall _ : hlist (cons a (app tvs tvs')), F t) => and (eq (Some (existT (fun t : iT => forall _ : hlist (cons a (app tvs tvs')), F t) a hlist_hd)) (Some x)) (ex (fun y : forall _ : hlist (cons a tvs), F (projT1 x) => and (eq (Some (existT (fun t : iT => forall _ : hlist (cons a tvs), F t) a hlist_hd)) (Some (existT (fun t : iT => forall _ : hlist (cons a tvs), F t) (projT1 x) y))) (forall (vs : hlist (cons a tvs)) (vs' : hlist tvs'), eq (projT2 x (hlist_app vs vs')) (y vs)))))
+++++
eexists.
-----
Lemma nth_error_get_hlist_nth_appL : forall tvs' tvs n, n < length tvs -> exists x, nth_error_get_hlist_nth (tvs ++ tvs') n = Some x /\\ exists y, nth_error_get_hlist_nth tvs n = Some (@existT _ _ (projT1 x) y) /\\ forall vs vs', (projT2 x) (hlist_app vs vs') = y vs.
Proof.
clear.
induction tvs.
simpl.
intros.
destruct n.
clear H IHtvs.
eexists.

*****
tvs : list iT
a : iT
tvs' : list iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
and (eq (Some (existT (fun t : iT => forall _ : hlist (cons a (app tvs tvs')), F t) a hlist_hd)) (Some ?x)) (ex (fun y : forall _ : hlist (cons a tvs), F (projT1 ?x) => and (eq (Some (existT (fun t : iT => forall _ : hlist (cons a tvs), F t) a hlist_hd)) (Some (existT (fun t : iT => forall _ : hlist (cons a tvs), F t) (projT1 ?x) y))) (forall (vs : hlist (cons a tvs)) (vs' : hlist tvs'), eq (projT2 ?x (hlist_app vs vs')) (y vs))))
+++++
split.
-----
Lemma nth_error_get_hlist_nth_appL : forall tvs' tvs n, n < length tvs -> exists x, nth_error_get_hlist_nth (tvs ++ tvs') n = Some x /\\ exists y, nth_error_get_hlist_nth tvs n = Some (@existT _ _ (projT1 x) y) /\\ forall vs vs', (projT2 x) (hlist_app vs vs') = y vs.
Proof.
clear.
induction tvs.
simpl.
intros.
destruct n.
clear H IHtvs.
eexists.
split.

*****
tvs : list iT
a : iT
tvs' : list iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
eq (Some (existT (fun t : iT => forall _ : hlist (cons a (app tvs tvs')), F t) a hlist_hd)) (Some ?x)
+++++
eauto.
-----
Lemma nth_error_get_hlist_nth_appL : forall tvs' tvs n, n < length tvs -> exists x, nth_error_get_hlist_nth (tvs ++ tvs') n = Some x /\\ exists y, nth_error_get_hlist_nth tvs n = Some (@existT _ _ (projT1 x) y) /\\ forall vs vs', (projT2 x) (hlist_app vs vs') = y vs.
Proof.
clear.
induction tvs.
simpl.
intros.
destruct n.
clear H IHtvs.
eexists.
split.

*****
tvs : list iT
a : iT
tvs' : list iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
ex (fun y : forall _ : hlist (cons a tvs), F (projT1 (existT (fun t : iT => forall _ : hlist (cons a (app tvs tvs')), F t) a hlist_hd)) => and (eq (Some (existT (fun t : iT => forall _ : hlist (cons a tvs), F t) a hlist_hd)) (Some (existT (fun t : iT => forall _ : hlist (cons a tvs), F t) (projT1 (existT (fun t : iT => forall _ : hlist (cons a (app tvs tvs')), F t) a hlist_hd)) y))) (forall (vs : hlist (cons a tvs)) (vs' : hlist tvs'), eq (projT2 (existT (fun t : iT => forall _ : hlist (cons a (app tvs tvs')), F t) a hlist_hd) (hlist_app vs vs')) (y vs)))
+++++
eauto.
-----
Lemma nth_error_get_hlist_nth_appL : forall tvs' tvs n, n < length tvs -> exists x, nth_error_get_hlist_nth (tvs ++ tvs') n = Some x /\\ exists y, nth_error_get_hlist_nth tvs n = Some (@existT _ _ (projT1 x) y) /\\ forall vs vs', (projT2 x) (hlist_app vs vs') = y vs.
Proof.
clear.
induction tvs.
simpl.
intros.
destruct n.
clear H IHtvs.
eexists.
split.
eauto.

*****
tvs : list iT
a : iT
tvs' : list iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
ex (fun y : forall _ : hlist (cons a tvs), F (projT1 (existT (fun t : iT => forall _ : hlist (cons a (app tvs tvs')), F t) a hlist_hd)) => and (eq (Some (existT (fun t : iT => forall _ : hlist (cons a tvs), F t) a hlist_hd)) (Some (existT (fun t : iT => forall _ : hlist (cons a tvs), F t) (projT1 (existT (fun t : iT => forall _ : hlist (cons a (app tvs tvs')), F t) a hlist_hd)) y))) (forall (vs : hlist (cons a tvs)) (vs' : hlist tvs'), eq (projT2 (existT (fun t : iT => forall _ : hlist (cons a (app tvs tvs')), F t) a hlist_hd) (hlist_app vs vs')) (y vs)))
+++++
eexists.
-----
Lemma nth_error_get_hlist_nth_appL : forall tvs' tvs n, n < length tvs -> exists x, nth_error_get_hlist_nth (tvs ++ tvs') n = Some x /\\ exists y, nth_error_get_hlist_nth tvs n = Some (@existT _ _ (projT1 x) y) /\\ forall vs vs', (projT2 x) (hlist_app vs vs') = y vs.
Proof.
clear.
induction tvs.
simpl.
intros.
destruct n.
clear H IHtvs.
eexists.
split.
eauto.
eexists.

*****
tvs : list iT
a : iT
tvs' : list iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
and (eq (Some (existT (fun t : iT => forall _ : hlist (cons a tvs), F t) a hlist_hd)) (Some (existT (fun t : iT => forall _ : hlist (cons a tvs), F t) (projT1 (existT (fun t : iT => forall _ : hlist (cons a (app tvs tvs')), F t) a hlist_hd)) ?y))) (forall (vs : hlist (cons a tvs)) (vs' : hlist tvs'), eq (projT2 (existT (fun t : iT => forall _ : hlist (cons a (app tvs tvs')), F t) a hlist_hd) (hlist_app vs vs')) (?y vs))
+++++
split.
-----
Lemma nth_error_get_hlist_nth_appL : forall tvs' tvs n, n < length tvs -> exists x, nth_error_get_hlist_nth (tvs ++ tvs') n = Some x /\\ exists y, nth_error_get_hlist_nth tvs n = Some (@existT _ _ (projT1 x) y) /\\ forall vs vs', (projT2 x) (hlist_app vs vs') = y vs.
Proof.
clear.
induction tvs.
simpl.
intros.
destruct n.
clear H IHtvs.
eexists.
split.
eauto.
eexists.
split.

*****
tvs : list iT
a : iT
tvs' : list iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
eq (Some (existT (fun t : iT => forall _ : hlist (cons a tvs), F t) a hlist_hd)) (Some (existT (fun t : iT => forall _ : hlist (cons a tvs), F t) (projT1 (existT (fun t : iT => forall _ : hlist (cons a (app tvs tvs')), F t) a hlist_hd)) ?y))
+++++
eauto.
-----
Lemma nth_error_get_hlist_nth_appL : forall tvs' tvs n, n < length tvs -> exists x, nth_error_get_hlist_nth (tvs ++ tvs') n = Some x /\\ exists y, nth_error_get_hlist_nth tvs n = Some (@existT _ _ (projT1 x) y) /\\ forall vs vs', (projT2 x) (hlist_app vs vs') = y vs.
Proof.
clear.
induction tvs.
simpl.
intros.
destruct n.
clear H IHtvs.
eexists.
split.
eauto.
eexists.
split.

*****
tvs : list iT
a : iT
tvs' : list iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall (vs : hlist (cons a tvs)) (vs' : hlist tvs'), eq (projT2 (existT (fun t : iT => forall _ : hlist (cons a (app tvs tvs')), F t) a hlist_hd) (hlist_app vs vs')) (hlist_hd vs)
+++++
eauto.
-----
Lemma nth_error_get_hlist_nth_appL : forall tvs' tvs n, n < length tvs -> exists x, nth_error_get_hlist_nth (tvs ++ tvs') n = Some x /\\ exists y, nth_error_get_hlist_nth tvs n = Some (@existT _ _ (projT1 x) y) /\\ forall vs vs', (projT2 x) (hlist_app vs vs') = y vs.
Proof.
clear.
induction tvs.
simpl.
intros.
destruct n.
clear H IHtvs.
eexists.
split.
eauto.
eexists.
split.
eauto.

*****
tvs : list iT
a : iT
tvs' : list iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall (vs : hlist (cons a tvs)) (vs' : hlist tvs'), eq (projT2 (existT (fun t : iT => forall _ : hlist (cons a (app tvs tvs')), F t) a hlist_hd) (hlist_app vs vs')) (hlist_hd vs)
+++++
simpl.
-----
Lemma nth_error_get_hlist_nth_appL : forall tvs' tvs n, n < length tvs -> exists x, nth_error_get_hlist_nth (tvs ++ tvs') n = Some x /\\ exists y, nth_error_get_hlist_nth tvs n = Some (@existT _ _ (projT1 x) y) /\\ forall vs vs', (projT2 x) (hlist_app vs vs') = y vs.
Proof.
clear.
induction tvs.
simpl.
intros.
destruct n.
clear H IHtvs.
eexists.
split.
eauto.
eexists.
split.
eauto.
simpl.

*****
tvs : list iT
a : iT
tvs' : list iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall (vs : hlist (cons a tvs)) (vs' : hlist tvs'), eq (hlist_hd (hlist_app vs vs')) (hlist_hd vs)
+++++
intros.
-----
Lemma nth_error_get_hlist_nth_appL : forall tvs' tvs n, n < length tvs -> exists x, nth_error_get_hlist_nth (tvs ++ tvs') n = Some x /\\ exists y, nth_error_get_hlist_nth tvs n = Some (@existT _ _ (projT1 x) y) /\\ forall vs vs', (projT2 x) (hlist_app vs vs') = y vs.
Proof.
clear.
induction tvs.
simpl.
intros.
destruct n.
clear H IHtvs.
eexists.
split.
eauto.
eexists.
split.
eauto.
simpl.
intros.

*****
vs' : hlist tvs'
vs : hlist (cons a tvs)
tvs : list iT
a : iT
tvs' : list iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
eq (hlist_hd (hlist_app vs vs')) (hlist_hd vs)
+++++
rewrite (hlist_eta vs).
-----
Lemma nth_error_get_hlist_nth_appL : forall tvs' tvs n, n < length tvs -> exists x, nth_error_get_hlist_nth (tvs ++ tvs') n = Some x /\\ exists y, nth_error_get_hlist_nth tvs n = Some (@existT _ _ (projT1 x) y) /\\ forall vs vs', (projT2 x) (hlist_app vs vs') = y vs.
Proof.
clear.
induction tvs.
simpl.
intros.
destruct n.
clear H IHtvs.
eexists.
split.
eauto.
eexists.
split.
eauto.
simpl.
intros.
rewrite (hlist_eta vs).

*****
vs' : hlist tvs'
vs : hlist (cons a tvs)
tvs : list iT
a : iT
tvs' : list iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
eq (hlist_hd (hlist_app (Hcons (hlist_hd vs) (hlist_tl vs)) vs')) (hlist_hd (Hcons (hlist_hd vs) (hlist_tl vs)))
+++++
reflexivity.
-----
Lemma nth_error_get_hlist_nth_appL : forall tvs' tvs n, n < length tvs -> exists x, nth_error_get_hlist_nth (tvs ++ tvs') n = Some x /\\ exists y, nth_error_get_hlist_nth tvs n = Some (@existT _ _ (projT1 x) y) /\\ forall vs vs', (projT2 x) (hlist_app vs vs') = y vs.
Proof.
clear.
induction tvs.
simpl.
intros.
destruct n.

*****
H : lt (S n) (S (length tvs))
n : nat
IHtvs : forall (n : nat) (_ : lt n (length tvs)),\nex\n (fun x : sigT (fun t : iT => forall _ : hlist (app tvs tvs'), F t) =>\n and (eq (nth_error_get_hlist_nth (app tvs tvs') n) (Some x))\n (ex\n (fun y : forall _ : hlist tvs, F (projT1 x) =>\n and\n (eq (nth_error_get_hlist_nth tvs n)\n (Some\n (existT (fun t : iT => forall _ : hlist tvs, F t)\n (projT1 x) y)))\n (forall (vs : hlist tvs) (vs' : hlist tvs'),\n eq (projT2 x (hlist_app vs vs')) (y vs)))))
tvs : list iT
a : iT
tvs' : list iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
ex (fun x : sigT (fun t : iT => forall _ : hlist (cons a (app tvs tvs')), F t) => and (eq match nth_error_get_hlist_nth (app tvs tvs') n with | Some (@existT _ _ x0 f) => Some (existT (fun t : iT => forall _ : hlist (cons a (app tvs tvs')), F t) x0 (fun h : hlist (cons a (app tvs tvs')) => f (hlist_tl h))) | None => None end (Some x)) (ex (fun y : forall _ : hlist (cons a tvs), F (projT1 x) => and (eq match nth_error_get_hlist_nth tvs n with | Some (@existT _ _ x0 f) => Some (existT (fun t : iT => forall _ : hlist (cons a tvs), F t) x0 (fun h : hlist (cons a tvs) => f (hlist_tl h))) | None => None end (Some (existT (fun t : iT => forall _ : hlist (cons a tvs), F t) (projT1 x) y))) (forall (vs : hlist (cons a tvs)) (vs' : hlist tvs'), eq (projT2 x (hlist_app vs vs')) (y vs)))))
+++++
apply Lt.lt_S_n in H.
-----
Lemma nth_error_get_hlist_nth_appL : forall tvs' tvs n, n < length tvs -> exists x, nth_error_get_hlist_nth (tvs ++ tvs') n = Some x /\\ exists y, nth_error_get_hlist_nth tvs n = Some (@existT _ _ (projT1 x) y) /\\ forall vs vs', (projT2 x) (hlist_app vs vs') = y vs.
Proof.
clear.
induction tvs.
simpl.
intros.
destruct n.
apply Lt.lt_S_n in H.

*****
H : lt n (length tvs)
n : nat
IHtvs : forall (n : nat) (_ : lt n (length tvs)),\nex\n (fun x : sigT (fun t : iT => forall _ : hlist (app tvs tvs'), F t) =>\n and (eq (nth_error_get_hlist_nth (app tvs tvs') n) (Some x))\n (ex\n (fun y : forall _ : hlist tvs, F (projT1 x) =>\n and\n (eq (nth_error_get_hlist_nth tvs n)\n (Some\n (existT (fun t : iT => forall _ : hlist tvs, F t)\n (projT1 x) y)))\n (forall (vs : hlist tvs) (vs' : hlist tvs'),\n eq (projT2 x (hlist_app vs vs')) (y vs)))))
tvs : list iT
a : iT
tvs' : list iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
ex (fun x : sigT (fun t : iT => forall _ : hlist (cons a (app tvs tvs')), F t) => and (eq match nth_error_get_hlist_nth (app tvs tvs') n with | Some (@existT _ _ x0 f) => Some (existT (fun t : iT => forall _ : hlist (cons a (app tvs tvs')), F t) x0 (fun h : hlist (cons a (app tvs tvs')) => f (hlist_tl h))) | None => None end (Some x)) (ex (fun y : forall _ : hlist (cons a tvs), F (projT1 x) => and (eq match nth_error_get_hlist_nth tvs n with | Some (@existT _ _ x0 f) => Some (existT (fun t : iT => forall _ : hlist (cons a tvs), F t) x0 (fun h : hlist (cons a tvs) => f (hlist_tl h))) | None => None end (Some (existT (fun t : iT => forall _ : hlist (cons a tvs), F t) (projT1 x) y))) (forall (vs : hlist (cons a tvs)) (vs' : hlist tvs'), eq (projT2 x (hlist_app vs vs')) (y vs)))))
+++++
specialize (IHtvs _ H).
-----
Lemma nth_error_get_hlist_nth_appL : forall tvs' tvs n, n < length tvs -> exists x, nth_error_get_hlist_nth (tvs ++ tvs') n = Some x /\\ exists y, nth_error_get_hlist_nth tvs n = Some (@existT _ _ (projT1 x) y) /\\ forall vs vs', (projT2 x) (hlist_app vs vs') = y vs.
Proof.
clear.
induction tvs.
simpl.
intros.
destruct n.
apply Lt.lt_S_n in H.
specialize (IHtvs _ H).

*****
H : lt n (length tvs)
IHtvs : ex\n (fun x : sigT (fun t : iT => forall _ : hlist (app tvs tvs'), F t) =>\n and (eq (nth_error_get_hlist_nth (app tvs tvs') n) (Some x))\n (ex\n (fun y : forall _ : hlist tvs, F (projT1 x) =>\n and\n (eq (nth_error_get_hlist_nth tvs n)\n (Some\n (existT (fun t : iT => forall _ : hlist tvs, F t)\n (projT1 x) y)))\n (forall (vs : hlist tvs) (vs' : hlist tvs'),\n eq (projT2 x (hlist_app vs vs')) (y vs)))))
n : nat
tvs : list iT
a : iT
tvs' : list iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
ex (fun x : sigT (fun t : iT => forall _ : hlist (cons a (app tvs tvs')), F t) => and (eq match nth_error_get_hlist_nth (app tvs tvs') n with | Some (@existT _ _ x0 f) => Some (existT (fun t : iT => forall _ : hlist (cons a (app tvs tvs')), F t) x0 (fun h : hlist (cons a (app tvs tvs')) => f (hlist_tl h))) | None => None end (Some x)) (ex (fun y : forall _ : hlist (cons a tvs), F (projT1 x) => and (eq match nth_error_get_hlist_nth tvs n with | Some (@existT _ _ x0 f) => Some (existT (fun t : iT => forall _ : hlist (cons a tvs), F t) x0 (fun h : hlist (cons a tvs) => f (hlist_tl h))) | None => None end (Some (existT (fun t : iT => forall _ : hlist (cons a tvs), F t) (projT1 x) y))) (forall (vs : hlist (cons a tvs)) (vs' : hlist tvs'), eq (projT2 x (hlist_app vs vs')) (y vs)))))
+++++
forward_reason.
-----
Lemma nth_error_get_hlist_nth_appL : forall tvs' tvs n, n < length tvs -> exists x, nth_error_get_hlist_nth (tvs ++ tvs') n = Some x /\\ exists y, nth_error_get_hlist_nth tvs n = Some (@existT _ _ (projT1 x) y) /\\ forall vs vs', (projT2 x) (hlist_app vs vs') = y vs.
Proof.
clear.
induction tvs.
simpl.
intros.
destruct n.
apply Lt.lt_S_n in H.
specialize (IHtvs _ H).
forward_reason.

*****
H : lt n (length tvs)
H2 : forall (vs : hlist tvs) (vs' : hlist tvs'),\neq (projT2 x (hlist_app vs vs')) (x0 vs)
H1 : eq (nth_error_get_hlist_nth tvs n)\n (Some\n (existT (fun t : iT => forall _ : hlist tvs, F t) (projT1 x) x0))
x0 : forall _ : hlist tvs, F (projT1 x)
H0 : eq (nth_error_get_hlist_nth (app tvs tvs') n) (Some x)
x : sigT (fun t : iT => forall _ : hlist (app tvs tvs'), F t)
n : nat
tvs : list iT
a : iT
tvs' : list iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
ex (fun x : sigT (fun t : iT => forall _ : hlist (cons a (app tvs tvs')), F t) => and (eq match nth_error_get_hlist_nth (app tvs tvs') n with | Some (@existT _ _ x0 f) => Some (existT (fun t : iT => forall _ : hlist (cons a (app tvs tvs')), F t) x0 (fun h : hlist (cons a (app tvs tvs')) => f (hlist_tl h))) | None => None end (Some x)) (ex (fun y : forall _ : hlist (cons a tvs), F (projT1 x) => and (eq match nth_error_get_hlist_nth tvs n with | Some (@existT _ _ x0 f) => Some (existT (fun t : iT => forall _ : hlist (cons a tvs), F t) x0 (fun h : hlist (cons a tvs) => f (hlist_tl h))) | None => None end (Some (existT (fun t : iT => forall _ : hlist (cons a tvs), F t) (projT1 x) y))) (forall (vs : hlist (cons a tvs)) (vs' : hlist tvs'), eq (projT2 x (hlist_app vs vs')) (y vs)))))
+++++
rewrite H0.
-----
Lemma nth_error_get_hlist_nth_appL : forall tvs' tvs n, n < length tvs -> exists x, nth_error_get_hlist_nth (tvs ++ tvs') n = Some x /\\ exists y, nth_error_get_hlist_nth tvs n = Some (@existT _ _ (projT1 x) y) /\\ forall vs vs', (projT2 x) (hlist_app vs vs') = y vs.
Proof.
clear.
induction tvs.
simpl.
intros.
destruct n.
apply Lt.lt_S_n in H.
specialize (IHtvs _ H).
forward_reason.
rewrite H0.

*****
H : lt n (length tvs)
H2 : forall (vs : hlist tvs) (vs' : hlist tvs'),\neq (projT2 x (hlist_app vs vs')) (x0 vs)
H1 : eq (nth_error_get_hlist_nth tvs n)\n (Some\n (existT (fun t : iT => forall _ : hlist tvs, F t) (projT1 x) x0))
x0 : forall _ : hlist tvs, F (projT1 x)
H0 : eq (nth_error_get_hlist_nth (app tvs tvs') n) (Some x)
x : sigT (fun t : iT => forall _ : hlist (app tvs tvs'), F t)
n : nat
tvs : list iT
a : iT
tvs' : list iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
ex (fun x0 : sigT (fun t : iT => forall _ : hlist (cons a (app tvs tvs')), F t) => and (eq (let (x, f) := x in Some (existT (fun t : iT => forall _ : hlist (cons a (app tvs tvs')), F t) x (fun h : hlist (cons a (app tvs tvs')) => f (hlist_tl h)))) (Some x0)) (ex (fun y : forall _ : hlist (cons a tvs), F (projT1 x0) => and (eq match nth_error_get_hlist_nth tvs n with | Some (@existT _ _ x f) => Some (existT (fun t : iT => forall _ : hlist (cons a tvs), F t) x (fun h : hlist (cons a tvs) => f (hlist_tl h))) | None => None end (Some (existT (fun t : iT => forall _ : hlist (cons a tvs), F t) (projT1 x0) y))) (forall (vs : hlist (cons a tvs)) (vs' : hlist tvs'), eq (projT2 x0 (hlist_app vs vs')) (y vs)))))
+++++
rewrite H1.
-----
Lemma nth_error_get_hlist_nth_appL : forall tvs' tvs n, n < length tvs -> exists x, nth_error_get_hlist_nth (tvs ++ tvs') n = Some x /\\ exists y, nth_error_get_hlist_nth tvs n = Some (@existT _ _ (projT1 x) y) /\\ forall vs vs', (projT2 x) (hlist_app vs vs') = y vs.
Proof.
clear.
induction tvs.
simpl.
intros.
destruct n.
apply Lt.lt_S_n in H.
specialize (IHtvs _ H).
forward_reason.
rewrite H0.
rewrite H1.

*****
H : lt n (length tvs)
H2 : forall (vs : hlist tvs) (vs' : hlist tvs'),\neq (projT2 x (hlist_app vs vs')) (x0 vs)
H1 : eq (nth_error_get_hlist_nth tvs n)\n (Some\n (existT (fun t : iT => forall _ : hlist tvs, F t) (projT1 x) x0))
x0 : forall _ : hlist tvs, F (projT1 x)
H0 : eq (nth_error_get_hlist_nth (app tvs tvs') n) (Some x)
x : sigT (fun t : iT => forall _ : hlist (app tvs tvs'), F t)
n : nat
tvs : list iT
a : iT
tvs' : list iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
ex (fun x1 : sigT (fun t : iT => forall _ : hlist (cons a (app tvs tvs')), F t) => and (eq (let (x, f) := x in Some (existT (fun t : iT => forall _ : hlist (cons a (app tvs tvs')), F t) x (fun h : hlist (cons a (app tvs tvs')) => f (hlist_tl h)))) (Some x1)) (ex (fun y : forall _ : hlist (cons a tvs), F (projT1 x1) => and (eq (Some (existT (fun t : iT => forall _ : hlist (cons a tvs), F t) (projT1 x) (fun h : hlist (cons a tvs) => x0 (hlist_tl h)))) (Some (existT (fun t : iT => forall _ : hlist (cons a tvs), F t) (projT1 x1) y))) (forall (vs : hlist (cons a tvs)) (vs' : hlist tvs'), eq (projT2 x1 (hlist_app vs vs')) (y vs)))))
+++++
forward.
-----
Lemma nth_error_get_hlist_nth_appL : forall tvs' tvs n, n < length tvs -> exists x, nth_error_get_hlist_nth (tvs ++ tvs') n = Some x /\\ exists y, nth_error_get_hlist_nth tvs n = Some (@existT _ _ (projT1 x) y) /\\ forall vs vs', (projT2 x) (hlist_app vs vs') = y vs.
Proof.
clear.
induction tvs.
simpl.
intros.
destruct n.
apply Lt.lt_S_n in H.
specialize (IHtvs _ H).
forward_reason.
rewrite H0.
rewrite H1.
forward.

*****
H3 : forall (vs : hlist tvs) (vs' : hlist tvs'),\neq\n (projT2\n (existT (fun t : iT => forall _ : hlist (app tvs tvs'), F t) x0 f)\n (hlist_app vs vs')) (x1 vs)
H2 : eq (nth_error_get_hlist_nth tvs n)\n (Some\n (existT (fun t : iT => forall _ : hlist tvs, F t)\n (projT1\n (existT (fun t : iT => forall _ : hlist (app tvs tvs'), F t)\n x0 f)) x1))
x1 : forall _ : hlist tvs,\nF\n (projT1\n (existT (fun t : iT => forall _ : hlist (app tvs tvs'), F t) x0 f))
H1 : eq (nth_error_get_hlist_nth (app tvs tvs') n)\n (Some\n (existT (fun t : iT => forall _ : hlist (app tvs tvs'), F t) x0 f))
H0 : eq x (existT (fun t : iT => forall _ : hlist (app tvs tvs'), F t) x0 f)
f : forall _ : hlist (app tvs tvs'), F x0
x0 : iT
H : lt n (length tvs)
x : sigT (fun t : iT => forall _ : hlist (app tvs tvs'), F t)
n : nat
tvs : list iT
a : iT
tvs' : list iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
ex (fun x : sigT (fun t : iT => forall _ : hlist (cons a (app tvs tvs')), F t) => and (eq (Some (existT (fun t : iT => forall _ : hlist (cons a (app tvs tvs')), F t) x0 (fun h : hlist (cons a (app tvs tvs')) => f (hlist_tl h)))) (Some x)) (ex (fun y : forall _ : hlist (cons a tvs), F (projT1 x) => and (eq (Some (existT (fun t : iT => forall _ : hlist (cons a tvs), F t) (projT1 (existT (fun t : iT => forall _ : hlist (app tvs tvs'), F t) x0 f)) (fun h : hlist (cons a tvs) => x1 (hlist_tl h)))) (Some (existT (fun t : iT => forall _ : hlist (cons a tvs), F t) (projT1 x) y))) (forall (vs : hlist (cons a tvs)) (vs' : hlist tvs'), eq (projT2 x (hlist_app vs vs')) (y vs)))))
+++++
subst.
-----
Lemma nth_error_get_hlist_nth_appL : forall tvs' tvs n, n < length tvs -> exists x, nth_error_get_hlist_nth (tvs ++ tvs') n = Some x /\\ exists y, nth_error_get_hlist_nth tvs n = Some (@existT _ _ (projT1 x) y) /\\ forall vs vs', (projT2 x) (hlist_app vs vs') = y vs.
Proof.
clear.
induction tvs.
simpl.
intros.
destruct n.
apply Lt.lt_S_n in H.
specialize (IHtvs _ H).
forward_reason.
rewrite H0.
rewrite H1.
forward.
subst.

*****
H3 : forall (vs : hlist tvs) (vs' : hlist tvs'),\neq\n (projT2\n (existT (fun t : iT => forall _ : hlist (app tvs tvs'), F t) x0 f)\n (hlist_app vs vs')) (x1 vs)
H2 : eq (nth_error_get_hlist_nth tvs n)\n (Some\n (existT (fun t : iT => forall _ : hlist tvs, F t)\n (projT1\n (existT (fun t : iT => forall _ : hlist (app tvs tvs'), F t)\n x0 f)) x1))
x1 : forall _ : hlist tvs,\nF\n (projT1\n (existT (fun t : iT => forall _ : hlist (app tvs tvs'), F t) x0 f))
H1 : eq (nth_error_get_hlist_nth (app tvs tvs') n)\n (Some\n (existT (fun t : iT => forall _ : hlist (app tvs tvs'), F t) x0 f))
f : forall _ : hlist (app tvs tvs'), F x0
x0 : iT
H : lt n (length tvs)
n : nat
tvs : list iT
a : iT
tvs' : list iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
ex (fun x : sigT (fun t : iT => forall _ : hlist (cons a (app tvs tvs')), F t) => and (eq (Some (existT (fun t : iT => forall _ : hlist (cons a (app tvs tvs')), F t) x0 (fun h : hlist (cons a (app tvs tvs')) => f (hlist_tl h)))) (Some x)) (ex (fun y : forall _ : hlist (cons a tvs), F (projT1 x) => and (eq (Some (existT (fun t : iT => forall _ : hlist (cons a tvs), F t) (projT1 (existT (fun t : iT => forall _ : hlist (app tvs tvs'), F t) x0 f)) (fun h : hlist (cons a tvs) => x1 (hlist_tl h)))) (Some (existT (fun t : iT => forall _ : hlist (cons a tvs), F t) (projT1 x) y))) (forall (vs : hlist (cons a tvs)) (vs' : hlist tvs'), eq (projT2 x (hlist_app vs vs')) (y vs)))))
+++++
simpl in *.
-----
Lemma nth_error_get_hlist_nth_appL : forall tvs' tvs n, n < length tvs -> exists x, nth_error_get_hlist_nth (tvs ++ tvs') n = Some x /\\ exists y, nth_error_get_hlist_nth tvs n = Some (@existT _ _ (projT1 x) y) /\\ forall vs vs', (projT2 x) (hlist_app vs vs') = y vs.
Proof.
clear.
induction tvs.
simpl.
intros.
destruct n.
apply Lt.lt_S_n in H.
specialize (IHtvs _ H).
forward_reason.
rewrite H0.
rewrite H1.
forward.
subst.
simpl in *.

*****
H3 : forall (vs : hlist tvs) (vs' : hlist tvs'),\neq (f (hlist_app vs vs')) (x1 vs)
H2 : eq (nth_error_get_hlist_nth tvs n)\n (Some (existT (fun t : iT => forall _ : hlist tvs, F t) x0 x1))
x1 : forall _ : hlist tvs, F x0
H1 : eq (nth_error_get_hlist_nth (app tvs tvs') n)\n (Some\n (existT (fun t : iT => forall _ : hlist (app tvs tvs'), F t) x0 f))
f : forall _ : hlist (app tvs tvs'), F x0
x0 : iT
H : lt n (length tvs)
n : nat
tvs : list iT
a : iT
tvs' : list iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
ex (fun x : sigT (fun t : iT => forall _ : hlist (cons a (app tvs tvs')), F t) => and (eq (Some (existT (fun t : iT => forall _ : hlist (cons a (app tvs tvs')), F t) x0 (fun h : hlist (cons a (app tvs tvs')) => f (hlist_tl h)))) (Some x)) (ex (fun y : forall _ : hlist (cons a tvs), F (projT1 x) => and (eq (Some (existT (fun t : iT => forall _ : hlist (cons a tvs), F t) x0 (fun h : hlist (cons a tvs) => x1 (hlist_tl h)))) (Some (existT (fun t : iT => forall _ : hlist (cons a tvs), F t) (projT1 x) y))) (forall (vs : hlist (cons a tvs)) (vs' : hlist tvs'), eq (projT2 x (hlist_app vs vs')) (y vs)))))
+++++
eexists.
-----
Lemma nth_error_get_hlist_nth_appL : forall tvs' tvs n, n < length tvs -> exists x, nth_error_get_hlist_nth (tvs ++ tvs') n = Some x /\\ exists y, nth_error_get_hlist_nth tvs n = Some (@existT _ _ (projT1 x) y) /\\ forall vs vs', (projT2 x) (hlist_app vs vs') = y vs.
Proof.
clear.
induction tvs.
simpl.
intros.
destruct n.
apply Lt.lt_S_n in H.
specialize (IHtvs _ H).
forward_reason.
rewrite H0.
rewrite H1.
forward.
subst.
simpl in *.
eexists.

*****
H3 : forall (vs : hlist tvs) (vs' : hlist tvs'),\neq (f (hlist_app vs vs')) (x1 vs)
H2 : eq (nth_error_get_hlist_nth tvs n)\n (Some (existT (fun t : iT => forall _ : hlist tvs, F t) x0 x1))
x1 : forall _ : hlist tvs, F x0
H1 : eq (nth_error_get_hlist_nth (app tvs tvs') n)\n (Some\n (existT (fun t : iT => forall _ : hlist (app tvs tvs'), F t) x0 f))
f : forall _ : hlist (app tvs tvs'), F x0
x0 : iT
H : lt n (length tvs)
n : nat
tvs : list iT
a : iT
tvs' : list iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
and (eq (Some (existT (fun t : iT => forall _ : hlist (cons a (app tvs tvs')), F t) x0 (fun h : hlist (cons a (app tvs tvs')) => f (hlist_tl h)))) (Some ?x)) (ex (fun y : forall _ : hlist (cons a tvs), F (projT1 ?x) => and (eq (Some (existT (fun t : iT => forall _ : hlist (cons a tvs), F t) x0 (fun h : hlist (cons a tvs) => x1 (hlist_tl h)))) (Some (existT (fun t : iT => forall _ : hlist (cons a tvs), F t) (projT1 ?x) y))) (forall (vs : hlist (cons a tvs)) (vs' : hlist tvs'), eq (projT2 ?x (hlist_app vs vs')) (y vs))))
+++++
split.
-----
Lemma nth_error_get_hlist_nth_appL : forall tvs' tvs n, n < length tvs -> exists x, nth_error_get_hlist_nth (tvs ++ tvs') n = Some x /\\ exists y, nth_error_get_hlist_nth tvs n = Some (@existT _ _ (projT1 x) y) /\\ forall vs vs', (projT2 x) (hlist_app vs vs') = y vs.
Proof.
clear.
induction tvs.
simpl.
intros.
destruct n.
apply Lt.lt_S_n in H.
specialize (IHtvs _ H).
forward_reason.
rewrite H0.
rewrite H1.
forward.
subst.
simpl in *.
eexists.
split.

*****
H3 : forall (vs : hlist tvs) (vs' : hlist tvs'),\neq (f (hlist_app vs vs')) (x1 vs)
H2 : eq (nth_error_get_hlist_nth tvs n)\n (Some (existT (fun t : iT => forall _ : hlist tvs, F t) x0 x1))
x1 : forall _ : hlist tvs, F x0
H1 : eq (nth_error_get_hlist_nth (app tvs tvs') n)\n (Some\n (existT (fun t : iT => forall _ : hlist (app tvs tvs'), F t) x0 f))
f : forall _ : hlist (app tvs tvs'), F x0
x0 : iT
H : lt n (length tvs)
n : nat
tvs : list iT
a : iT
tvs' : list iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
eq (Some (existT (fun t : iT => forall _ : hlist (cons a (app tvs tvs')), F t) x0 (fun h : hlist (cons a (app tvs tvs')) => f (hlist_tl h)))) (Some ?x)
+++++
eauto.
-----
Lemma nth_error_get_hlist_nth_appL : forall tvs' tvs n, n < length tvs -> exists x, nth_error_get_hlist_nth (tvs ++ tvs') n = Some x /\\ exists y, nth_error_get_hlist_nth tvs n = Some (@existT _ _ (projT1 x) y) /\\ forall vs vs', (projT2 x) (hlist_app vs vs') = y vs.
Proof.
clear.
induction tvs.
simpl.
intros.
destruct n.
apply Lt.lt_S_n in H.
specialize (IHtvs _ H).
forward_reason.
rewrite H0.
rewrite H1.
forward.
subst.
simpl in *.
eexists.
split.

*****
H3 : forall (vs : hlist tvs) (vs' : hlist tvs'),\neq (f (hlist_app vs vs')) (x1 vs)
H2 : eq (nth_error_get_hlist_nth tvs n)\n (Some (existT (fun t : iT => forall _ : hlist tvs, F t) x0 x1))
x1 : forall _ : hlist tvs, F x0
H1 : eq (nth_error_get_hlist_nth (app tvs tvs') n)\n (Some\n (existT (fun t : iT => forall _ : hlist (app tvs tvs'), F t) x0 f))
f : forall _ : hlist (app tvs tvs'), F x0
x0 : iT
H : lt n (length tvs)
n : nat
tvs : list iT
a : iT
tvs' : list iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
ex (fun y : forall _ : hlist (cons a tvs), F (projT1 (existT (fun t : iT => forall _ : hlist (cons a (app tvs tvs')), F t) x0 (fun h : hlist (cons a (app tvs tvs')) => f (hlist_tl h)))) => and (eq (Some (existT (fun t : iT => forall _ : hlist (cons a tvs), F t) x0 (fun h : hlist (cons a tvs) => x1 (hlist_tl h)))) (Some (existT (fun t : iT => forall _ : hlist (cons a tvs), F t) (projT1 (existT (fun t : iT => forall _ : hlist (cons a (app tvs tvs')), F t) x0 (fun h : hlist (cons a (app tvs tvs')) => f (hlist_tl h)))) y))) (forall (vs : hlist (cons a tvs)) (vs' : hlist tvs'), eq (projT2 (existT (fun t : iT => forall _ : hlist (cons a (app tvs tvs')), F t) x0 (fun h : hlist (cons a (app tvs tvs')) => f (hlist_tl h))) (hlist_app vs vs')) (y vs)))
+++++
eauto.
-----
Lemma nth_error_get_hlist_nth_appL : forall tvs' tvs n, n < length tvs -> exists x, nth_error_get_hlist_nth (tvs ++ tvs') n = Some x /\\ exists y, nth_error_get_hlist_nth tvs n = Some (@existT _ _ (projT1 x) y) /\\ forall vs vs', (projT2 x) (hlist_app vs vs') = y vs.
Proof.
clear.
induction tvs.
simpl.
intros.
destruct n.
apply Lt.lt_S_n in H.
specialize (IHtvs _ H).
forward_reason.
rewrite H0.
rewrite H1.
forward.
subst.
simpl in *.
eexists.
split.
eauto.

*****
H3 : forall (vs : hlist tvs) (vs' : hlist tvs'),\neq (f (hlist_app vs vs')) (x1 vs)
H2 : eq (nth_error_get_hlist_nth tvs n)\n (Some (existT (fun t : iT => forall _ : hlist tvs, F t) x0 x1))
x1 : forall _ : hlist tvs, F x0
H1 : eq (nth_error_get_hlist_nth (app tvs tvs') n)\n (Some\n (existT (fun t : iT => forall _ : hlist (app tvs tvs'), F t) x0 f))
f : forall _ : hlist (app tvs tvs'), F x0
x0 : iT
H : lt n (length tvs)
n : nat
tvs : list iT
a : iT
tvs' : list iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
ex (fun y : forall _ : hlist (cons a tvs), F (projT1 (existT (fun t : iT => forall _ : hlist (cons a (app tvs tvs')), F t) x0 (fun h : hlist (cons a (app tvs tvs')) => f (hlist_tl h)))) => and (eq (Some (existT (fun t : iT => forall _ : hlist (cons a tvs), F t) x0 (fun h : hlist (cons a tvs) => x1 (hlist_tl h)))) (Some (existT (fun t : iT => forall _ : hlist (cons a tvs), F t) (projT1 (existT (fun t : iT => forall _ : hlist (cons a (app tvs tvs')), F t) x0 (fun h : hlist (cons a (app tvs tvs')) => f (hlist_tl h)))) y))) (forall (vs : hlist (cons a tvs)) (vs' : hlist tvs'), eq (projT2 (existT (fun t : iT => forall _ : hlist (cons a (app tvs tvs')), F t) x0 (fun h : hlist (cons a (app tvs tvs')) => f (hlist_tl h))) (hlist_app vs vs')) (y vs)))
+++++
eexists.
-----
Lemma nth_error_get_hlist_nth_appL : forall tvs' tvs n, n < length tvs -> exists x, nth_error_get_hlist_nth (tvs ++ tvs') n = Some x /\\ exists y, nth_error_get_hlist_nth tvs n = Some (@existT _ _ (projT1 x) y) /\\ forall vs vs', (projT2 x) (hlist_app vs vs') = y vs.
Proof.
clear.
induction tvs.
simpl.
intros.
destruct n.
apply Lt.lt_S_n in H.
specialize (IHtvs _ H).
forward_reason.
rewrite H0.
rewrite H1.
forward.
subst.
simpl in *.
eexists.
split.
eauto.
eexists.

*****
H3 : forall (vs : hlist tvs) (vs' : hlist tvs'),\neq (f (hlist_app vs vs')) (x1 vs)
H2 : eq (nth_error_get_hlist_nth tvs n)\n (Some (existT (fun t : iT => forall _ : hlist tvs, F t) x0 x1))
x1 : forall _ : hlist tvs, F x0
H1 : eq (nth_error_get_hlist_nth (app tvs tvs') n)\n (Some\n (existT (fun t : iT => forall _ : hlist (app tvs tvs'), F t) x0 f))
f : forall _ : hlist (app tvs tvs'), F x0
x0 : iT
H : lt n (length tvs)
n : nat
tvs : list iT
a : iT
tvs' : list iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
and (eq (Some (existT (fun t : iT => forall _ : hlist (cons a tvs), F t) x0 (fun h : hlist (cons a tvs) => x1 (hlist_tl h)))) (Some (existT (fun t : iT => forall _ : hlist (cons a tvs), F t) (projT1 (existT (fun t : iT => forall _ : hlist (cons a (app tvs tvs')), F t) x0 (fun h : hlist (cons a (app tvs tvs')) => f (hlist_tl h)))) ?y))) (forall (vs : hlist (cons a tvs)) (vs' : hlist tvs'), eq (projT2 (existT (fun t : iT => forall _ : hlist (cons a (app tvs tvs')), F t) x0 (fun h : hlist (cons a (app tvs tvs')) => f (hlist_tl h))) (hlist_app vs vs')) (?y vs))
+++++
split.
-----
Lemma nth_error_get_hlist_nth_appL : forall tvs' tvs n, n < length tvs -> exists x, nth_error_get_hlist_nth (tvs ++ tvs') n = Some x /\\ exists y, nth_error_get_hlist_nth tvs n = Some (@existT _ _ (projT1 x) y) /\\ forall vs vs', (projT2 x) (hlist_app vs vs') = y vs.
Proof.
clear.
induction tvs.
simpl.
intros.
destruct n.
apply Lt.lt_S_n in H.
specialize (IHtvs _ H).
forward_reason.
rewrite H0.
rewrite H1.
forward.
subst.
simpl in *.
eexists.
split.
eauto.
eexists.
split.

*****
H3 : forall (vs : hlist tvs) (vs' : hlist tvs'),\neq (f (hlist_app vs vs')) (x1 vs)
H2 : eq (nth_error_get_hlist_nth tvs n)\n (Some (existT (fun t : iT => forall _ : hlist tvs, F t) x0 x1))
x1 : forall _ : hlist tvs, F x0
H1 : eq (nth_error_get_hlist_nth (app tvs tvs') n)\n (Some\n (existT (fun t : iT => forall _ : hlist (app tvs tvs'), F t) x0 f))
f : forall _ : hlist (app tvs tvs'), F x0
x0 : iT
H : lt n (length tvs)
n : nat
tvs : list iT
a : iT
tvs' : list iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
eq (Some (existT (fun t : iT => forall _ : hlist (cons a tvs), F t) x0 (fun h : hlist (cons a tvs) => x1 (hlist_tl h)))) (Some (existT (fun t : iT => forall _ : hlist (cons a tvs), F t) (projT1 (existT (fun t : iT => forall _ : hlist (cons a (app tvs tvs')), F t) x0 (fun h : hlist (cons a (app tvs tvs')) => f (hlist_tl h)))) ?y))
+++++
eauto.
-----
Lemma nth_error_get_hlist_nth_appL : forall tvs' tvs n, n < length tvs -> exists x, nth_error_get_hlist_nth (tvs ++ tvs') n = Some x /\\ exists y, nth_error_get_hlist_nth tvs n = Some (@existT _ _ (projT1 x) y) /\\ forall vs vs', (projT2 x) (hlist_app vs vs') = y vs.
Proof.
clear.
induction tvs.
simpl.
intros.
destruct n.
apply Lt.lt_S_n in H.
specialize (IHtvs _ H).
forward_reason.
rewrite H0.
rewrite H1.
forward.
subst.
simpl in *.
eexists.
split.
eauto.
eexists.
split.

*****
H3 : forall (vs : hlist tvs) (vs' : hlist tvs'),\neq (f (hlist_app vs vs')) (x1 vs)
H2 : eq (nth_error_get_hlist_nth tvs n)\n (Some (existT (fun t : iT => forall _ : hlist tvs, F t) x0 x1))
x1 : forall _ : hlist tvs, F x0
H1 : eq (nth_error_get_hlist_nth (app tvs tvs') n)\n (Some\n (existT (fun t : iT => forall _ : hlist (app tvs tvs'), F t) x0 f))
f : forall _ : hlist (app tvs tvs'), F x0
x0 : iT
H : lt n (length tvs)
n : nat
tvs : list iT
a : iT
tvs' : list iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall (vs : hlist (cons a tvs)) (vs' : hlist tvs'), eq (projT2 (existT (fun t : iT => forall _ : hlist (cons a (app tvs tvs')), F t) x0 (fun h : hlist (cons a (app tvs tvs')) => f (hlist_tl h))) (hlist_app vs vs')) ((fun h : hlist (cons a tvs) => x1 (hlist_tl h)) vs)
+++++
eauto.
-----
Lemma nth_error_get_hlist_nth_appL : forall tvs' tvs n, n < length tvs -> exists x, nth_error_get_hlist_nth (tvs ++ tvs') n = Some x /\\ exists y, nth_error_get_hlist_nth tvs n = Some (@existT _ _ (projT1 x) y) /\\ forall vs vs', (projT2 x) (hlist_app vs vs') = y vs.
Proof.
clear.
induction tvs.
simpl.
intros.
destruct n.
apply Lt.lt_S_n in H.
specialize (IHtvs _ H).
forward_reason.
rewrite H0.
rewrite H1.
forward.
subst.
simpl in *.
eexists.
split.
eauto.
eexists.
split.
eauto.

*****
H3 : forall (vs : hlist tvs) (vs' : hlist tvs'),\neq (f (hlist_app vs vs')) (x1 vs)
H2 : eq (nth_error_get_hlist_nth tvs n)\n (Some (existT (fun t : iT => forall _ : hlist tvs, F t) x0 x1))
x1 : forall _ : hlist tvs, F x0
H1 : eq (nth_error_get_hlist_nth (app tvs tvs') n)\n (Some\n (existT (fun t : iT => forall _ : hlist (app tvs tvs'), F t) x0 f))
f : forall _ : hlist (app tvs tvs'), F x0
x0 : iT
H : lt n (length tvs)
n : nat
tvs : list iT
a : iT
tvs' : list iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall (vs : hlist (cons a tvs)) (vs' : hlist tvs'), eq (projT2 (existT (fun t : iT => forall _ : hlist (cons a (app tvs tvs')), F t) x0 (fun h : hlist (cons a (app tvs tvs')) => f (hlist_tl h))) (hlist_app vs vs')) ((fun h : hlist (cons a tvs) => x1 (hlist_tl h)) vs)
+++++
simpl.
-----
Lemma nth_error_get_hlist_nth_appL : forall tvs' tvs n, n < length tvs -> exists x, nth_error_get_hlist_nth (tvs ++ tvs') n = Some x /\\ exists y, nth_error_get_hlist_nth tvs n = Some (@existT _ _ (projT1 x) y) /\\ forall vs vs', (projT2 x) (hlist_app vs vs') = y vs.
Proof.
clear.
induction tvs.
simpl.
intros.
destruct n.
apply Lt.lt_S_n in H.
specialize (IHtvs _ H).
forward_reason.
rewrite H0.
rewrite H1.
forward.
subst.
simpl in *.
eexists.
split.
eauto.
eexists.
split.
eauto.
simpl.

*****
H3 : forall (vs : hlist tvs) (vs' : hlist tvs'),\neq (f (hlist_app vs vs')) (x1 vs)
H2 : eq (nth_error_get_hlist_nth tvs n)\n (Some (existT (fun t : iT => forall _ : hlist tvs, F t) x0 x1))
x1 : forall _ : hlist tvs, F x0
H1 : eq (nth_error_get_hlist_nth (app tvs tvs') n)\n (Some\n (existT (fun t : iT => forall _ : hlist (app tvs tvs'), F t) x0 f))
f : forall _ : hlist (app tvs tvs'), F x0
x0 : iT
H : lt n (length tvs)
n : nat
tvs : list iT
a : iT
tvs' : list iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall (vs : hlist (cons a tvs)) (vs' : hlist tvs'), eq (f (hlist_tl (hlist_app vs vs'))) (x1 (hlist_tl vs))
+++++
intros.
-----
Lemma nth_error_get_hlist_nth_appL : forall tvs' tvs n, n < length tvs -> exists x, nth_error_get_hlist_nth (tvs ++ tvs') n = Some x /\\ exists y, nth_error_get_hlist_nth tvs n = Some (@existT _ _ (projT1 x) y) /\\ forall vs vs', (projT2 x) (hlist_app vs vs') = y vs.
Proof.
clear.
induction tvs.
simpl.
intros.
destruct n.
apply Lt.lt_S_n in H.
specialize (IHtvs _ H).
forward_reason.
rewrite H0.
rewrite H1.
forward.
subst.
simpl in *.
eexists.
split.
eauto.
eexists.
split.
eauto.
simpl.
intros.

*****
vs' : hlist tvs'
vs : hlist (cons a tvs)
H3 : forall (vs : hlist tvs) (vs' : hlist tvs'),\neq (f (hlist_app vs vs')) (x1 vs)
H2 : eq (nth_error_get_hlist_nth tvs n)\n (Some (existT (fun t : iT => forall _ : hlist tvs, F t) x0 x1))
x1 : forall _ : hlist tvs, F x0
H1 : eq (nth_error_get_hlist_nth (app tvs tvs') n)\n (Some\n (existT (fun t : iT => forall _ : hlist (app tvs tvs'), F t) x0 f))
f : forall _ : hlist (app tvs tvs'), F x0
x0 : iT
H : lt n (length tvs)
n : nat
tvs : list iT
a : iT
tvs' : list iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
eq (f (hlist_tl (hlist_app vs vs'))) (x1 (hlist_tl vs))
+++++
rewrite (hlist_eta vs).
-----
Lemma nth_error_get_hlist_nth_appL : forall tvs' tvs n, n < length tvs -> exists x, nth_error_get_hlist_nth (tvs ++ tvs') n = Some x /\\ exists y, nth_error_get_hlist_nth tvs n = Some (@existT _ _ (projT1 x) y) /\\ forall vs vs', (projT2 x) (hlist_app vs vs') = y vs.
Proof.
clear.
induction tvs.
simpl.
intros.
destruct n.
apply Lt.lt_S_n in H.
specialize (IHtvs _ H).
forward_reason.
rewrite H0.
rewrite H1.
forward.
subst.
simpl in *.
eexists.
split.
eauto.
eexists.
split.
eauto.
simpl.
intros.
rewrite (hlist_eta vs).

*****
vs' : hlist tvs'
vs : hlist (cons a tvs)
H3 : forall (vs : hlist tvs) (vs' : hlist tvs'),\neq (f (hlist_app vs vs')) (x1 vs)
H2 : eq (nth_error_get_hlist_nth tvs n)\n (Some (existT (fun t : iT => forall _ : hlist tvs, F t) x0 x1))
x1 : forall _ : hlist tvs, F x0
H1 : eq (nth_error_get_hlist_nth (app tvs tvs') n)\n (Some\n (existT (fun t : iT => forall _ : hlist (app tvs tvs'), F t) x0 f))
f : forall _ : hlist (app tvs tvs'), F x0
x0 : iT
H : lt n (length tvs)
n : nat
tvs : list iT
a : iT
tvs' : list iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
eq (f (hlist_tl (hlist_app (Hcons (hlist_hd vs) (hlist_tl vs)) vs'))) (x1 (hlist_tl (Hcons (hlist_hd vs) (hlist_tl vs))))
+++++
simpl.
-----
Lemma nth_error_get_hlist_nth_appL : forall tvs' tvs n, n < length tvs -> exists x, nth_error_get_hlist_nth (tvs ++ tvs') n = Some x /\\ exists y, nth_error_get_hlist_nth tvs n = Some (@existT _ _ (projT1 x) y) /\\ forall vs vs', (projT2 x) (hlist_app vs vs') = y vs.
Proof.
clear.
induction tvs.
simpl.
intros.
destruct n.
apply Lt.lt_S_n in H.
specialize (IHtvs _ H).
forward_reason.
rewrite H0.
rewrite H1.
forward.
subst.
simpl in *.
eexists.
split.
eauto.
eexists.
split.
eauto.
simpl.
intros.
rewrite (hlist_eta vs).
simpl.

*****
vs' : hlist tvs'
vs : hlist (cons a tvs)
H3 : forall (vs : hlist tvs) (vs' : hlist tvs'),\neq (f (hlist_app vs vs')) (x1 vs)
H2 : eq (nth_error_get_hlist_nth tvs n)\n (Some (existT (fun t : iT => forall _ : hlist tvs, F t) x0 x1))
x1 : forall _ : hlist tvs, F x0
H1 : eq (nth_error_get_hlist_nth (app tvs tvs') n)\n (Some\n (existT (fun t : iT => forall _ : hlist (app tvs tvs'), F t) x0 f))
f : forall _ : hlist (app tvs tvs'), F x0
x0 : iT
H : lt n (length tvs)
n : nat
tvs : list iT
a : iT
tvs' : list iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
eq (f (hlist_app (hlist_tl vs) vs')) (x1 (hlist_tl vs))
+++++
auto.
-----
Lemma nth_error_get_hlist_nth_appL : forall tvs' tvs n, n < length tvs -> exists x, nth_error_get_hlist_nth (tvs ++ tvs') n = Some x /\\ exists y, nth_error_get_hlist_nth tvs n = Some (@existT _ _ (projT1 x) y) /\\ forall vs vs', (projT2 x) (hlist_app vs vs') = y vs.
Proof.
clear.
induction tvs.

*****

*****

+++++
Qed.
-----
Lemma nth_error_get_hlist_nth_appR\n  : forall tvs' tvs n x,\n      n >= length tvs ->\n      nth_error_get_hlist_nth (tvs ++ tvs') n = Some x ->\n      exists y,\n        nth_error_get_hlist_nth tvs' (n - length tvs) = Some (@existT _ _ (projT1 x) y) /\\n        forall vs vs',\n          (projT2 x) (hlist_app vs vs') = y vs'.
-----
Lemma nth_error_get_hlist_nth_appR : forall tvs' tvs n x, n >= length tvs -> nth_error_get_hlist_nth (tvs ++ tvs') n = Some x -> exists y, nth_error_get_hlist_nth tvs' (n - length tvs) = Some (@existT _ _ (projT1 x) y) /\\ forall vs vs', (projT2 x) (hlist_app vs vs') = y vs'.

*****
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall (tvs' tvs : list iT) (n : nat) (x : sigT (fun t : iT => forall _ : hlist (app tvs tvs'), F t)) (_ : ge n (length tvs)) (_ : eq (nth_error_get_hlist_nth (app tvs tvs') n) (Some x)), ex (fun y : (fun t : iT => forall _ : hlist tvs', F t) (projT1 x) => and (eq (nth_error_get_hlist_nth tvs' (Nat.sub n (length tvs))) (Some (existT (fun t : iT => forall _ : hlist tvs', F t) (projT1 x) y))) (forall (vs : hlist tvs) (vs' : hlist tvs'), eq (projT2 x (hlist_app vs vs')) (y vs')))
+++++
Proof.
-----
Lemma nth_error_get_hlist_nth_appR : forall tvs' tvs n x, n >= length tvs -> nth_error_get_hlist_nth (tvs ++ tvs') n = Some x -> exists y, nth_error_get_hlist_nth tvs' (n - length tvs) = Some (@existT _ _ (projT1 x) y) /\\ forall vs vs', (projT2 x) (hlist_app vs vs') = y vs'.
Proof.

*****
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall (tvs' tvs : list iT) (n : nat) (x : sigT (fun t : iT => forall _ : hlist (app tvs tvs'), F t)) (_ : ge n (length tvs)) (_ : eq (nth_error_get_hlist_nth (app tvs tvs') n) (Some x)), ex (fun y : (fun t : iT => forall _ : hlist tvs', F t) (projT1 x) => and (eq (nth_error_get_hlist_nth tvs' (Nat.sub n (length tvs))) (Some (existT (fun t : iT => forall _ : hlist tvs', F t) (projT1 x) y))) (forall (vs : hlist tvs) (vs' : hlist tvs'), eq (projT2 x (hlist_app vs vs')) (y vs')))
+++++
clear.
-----
Lemma nth_error_get_hlist_nth_appR : forall tvs' tvs n x, n >= length tvs -> nth_error_get_hlist_nth (tvs ++ tvs') n = Some x -> exists y, nth_error_get_hlist_nth tvs' (n - length tvs) = Some (@existT _ _ (projT1 x) y) /\\ forall vs vs', (projT2 x) (hlist_app vs vs') = y vs'.
Proof.
clear.

*****
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall (tvs' tvs : list iT) (n : nat) (x : sigT (fun t : iT => forall _ : hlist (app tvs tvs'), F t)) (_ : ge n (length tvs)) (_ : eq (nth_error_get_hlist_nth (app tvs tvs') n) (Some x)), ex (fun y : (fun t : iT => forall _ : hlist tvs', F t) (projT1 x) => and (eq (nth_error_get_hlist_nth tvs' (Nat.sub n (length tvs))) (Some (existT (fun t : iT => forall _ : hlist tvs', F t) (projT1 x) y))) (forall (vs : hlist tvs) (vs' : hlist tvs'), eq (projT2 x (hlist_app vs vs')) (y vs')))
+++++
induction tvs.
-----
Lemma nth_error_get_hlist_nth_appR : forall tvs' tvs n x, n >= length tvs -> nth_error_get_hlist_nth (tvs ++ tvs') n = Some x -> exists y, nth_error_get_hlist_nth tvs' (n - length tvs) = Some (@existT _ _ (projT1 x) y) /\\ forall vs vs', (projT2 x) (hlist_app vs vs') = y vs'.
Proof.
clear.
induction tvs.

*****
tvs' : list iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall (n : nat) (x : sigT (fun t : iT => forall _ : hlist (app nil tvs'), F t)) (_ : ge n (length nil)) (_ : eq (nth_error_get_hlist_nth (app nil tvs') n) (Some x)), ex (fun y : forall _ : hlist tvs', F (projT1 x) => and (eq (nth_error_get_hlist_nth tvs' (Nat.sub n (length nil))) (Some (existT (fun t : iT => forall _ : hlist tvs', F t) (projT1 x) y))) (forall (vs : hlist nil) (vs' : hlist tvs'), eq (projT2 x (hlist_app vs vs')) (y vs')))
+++++
simpl.
-----
Lemma nth_error_get_hlist_nth_appR : forall tvs' tvs n x, n >= length tvs -> nth_error_get_hlist_nth (tvs ++ tvs') n = Some x -> exists y, nth_error_get_hlist_nth tvs' (n - length tvs) = Some (@existT _ _ (projT1 x) y) /\\ forall vs vs', (projT2 x) (hlist_app vs vs') = y vs'.
Proof.
clear.
induction tvs.
simpl.

*****
tvs' : list iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall (n : nat) (x : sigT (fun t : iT => forall _ : hlist tvs', F t)) (_ : ge n O) (_ : eq (nth_error_get_hlist_nth tvs' n) (Some x)), ex (fun y : forall _ : hlist tvs', F (projT1 x) => and (eq (nth_error_get_hlist_nth tvs' (Nat.sub n O)) (Some (existT (fun t : iT => forall _ : hlist tvs', F t) (projT1 x) y))) (forall (vs : hlist nil) (vs' : hlist tvs'), eq (projT2 x (hlist_app vs vs')) (y vs')))
+++++
intros.
-----
Lemma nth_error_get_hlist_nth_appR : forall tvs' tvs n x, n >= length tvs -> nth_error_get_hlist_nth (tvs ++ tvs') n = Some x -> exists y, nth_error_get_hlist_nth tvs' (n - length tvs) = Some (@existT _ _ (projT1 x) y) /\\ forall vs vs', (projT2 x) (hlist_app vs vs') = y vs'.
Proof.
clear.
induction tvs.
simpl.
intros.

*****
H0 : eq (nth_error_get_hlist_nth tvs' n) (Some x)
H : ge n O
x : sigT (fun t : iT => forall _ : hlist tvs', F t)
n : nat
tvs' : list iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
ex (fun y : forall _ : hlist tvs', F (projT1 x) => and (eq (nth_error_get_hlist_nth tvs' (Nat.sub n O)) (Some (existT (fun t : iT => forall _ : hlist tvs', F t) (projT1 x) y))) (forall (vs : hlist nil) (vs' : hlist tvs'), eq (projT2 x (hlist_app vs vs')) (y vs')))
+++++
rewrite <- Minus.minus_n_O.
-----
Lemma nth_error_get_hlist_nth_appR : forall tvs' tvs n x, n >= length tvs -> nth_error_get_hlist_nth (tvs ++ tvs') n = Some x -> exists y, nth_error_get_hlist_nth tvs' (n - length tvs) = Some (@existT _ _ (projT1 x) y) /\\ forall vs vs', (projT2 x) (hlist_app vs vs') = y vs'.
Proof.
clear.
induction tvs.
simpl.
intros.
rewrite <- Minus.minus_n_O.

*****
H0 : eq (nth_error_get_hlist_nth tvs' n) (Some x)
H : ge n O
x : sigT (fun t : iT => forall _ : hlist tvs', F t)
n : nat
tvs' : list iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
ex (fun y : forall _ : hlist tvs', F (projT1 x) => and (eq (nth_error_get_hlist_nth tvs' n) (Some (existT (fun t : iT => forall _ : hlist tvs', F t) (projT1 x) y))) (forall (vs : hlist nil) (vs' : hlist tvs'), eq (projT2 x (hlist_app vs vs')) (y vs')))
+++++
rewrite H0.
-----
Lemma nth_error_get_hlist_nth_appR : forall tvs' tvs n x, n >= length tvs -> nth_error_get_hlist_nth (tvs ++ tvs') n = Some x -> exists y, nth_error_get_hlist_nth tvs' (n - length tvs) = Some (@existT _ _ (projT1 x) y) /\\ forall vs vs', (projT2 x) (hlist_app vs vs') = y vs'.
Proof.
clear.
induction tvs.
simpl.
intros.
rewrite <- Minus.minus_n_O.
rewrite H0.

*****
H0 : eq (nth_error_get_hlist_nth tvs' n) (Some x)
H : ge n O
x : sigT (fun t : iT => forall _ : hlist tvs', F t)
n : nat
tvs' : list iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
ex (fun y : forall _ : hlist tvs', F (projT1 x) => and (eq (Some x) (Some (existT (fun t : iT => forall _ : hlist tvs', F t) (projT1 x) y))) (forall (vs : hlist nil) (vs' : hlist tvs'), eq (projT2 x (hlist_app vs vs')) (y vs')))
+++++
destruct x.
-----
Lemma nth_error_get_hlist_nth_appR : forall tvs' tvs n x, n >= length tvs -> nth_error_get_hlist_nth (tvs ++ tvs') n = Some x -> exists y, nth_error_get_hlist_nth tvs' (n - length tvs) = Some (@existT _ _ (projT1 x) y) /\\ forall vs vs', (projT2 x) (hlist_app vs vs') = y vs'.
Proof.
clear.
induction tvs.
simpl.
intros.
rewrite <- Minus.minus_n_O.
rewrite H0.
destruct x.

*****
H0 : eq (nth_error_get_hlist_nth tvs' n)\n (Some (existT (fun t : iT => forall _ : hlist tvs', F t) x f))
H : ge n O
f : forall _ : hlist tvs', F x
x : iT
n : nat
tvs' : list iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
ex (fun y : forall _ : hlist tvs', F (projT1 (existT (fun t : iT => forall _ : hlist tvs', F t) x f)) => and (eq (Some (existT (fun t : iT => forall _ : hlist tvs', F t) x f)) (Some (existT (fun t : iT => forall _ : hlist tvs', F t) (projT1 (existT (fun t : iT => forall _ : hlist tvs', F t) x f)) y))) (forall (vs : hlist nil) (vs' : hlist tvs'), eq (projT2 (existT (fun t : iT => forall _ : hlist tvs', F t) x f) (hlist_app vs vs')) (y vs')))
+++++
simpl.
-----
Lemma nth_error_get_hlist_nth_appR : forall tvs' tvs n x, n >= length tvs -> nth_error_get_hlist_nth (tvs ++ tvs') n = Some x -> exists y, nth_error_get_hlist_nth tvs' (n - length tvs) = Some (@existT _ _ (projT1 x) y) /\\ forall vs vs', (projT2 x) (hlist_app vs vs') = y vs'.
Proof.
clear.
induction tvs.
simpl.
intros.
rewrite <- Minus.minus_n_O.
rewrite H0.
destruct x.
simpl.

*****
H0 : eq (nth_error_get_hlist_nth tvs' n)\n (Some (existT (fun t : iT => forall _ : hlist tvs', F t) x f))
H : ge n O
f : forall _ : hlist tvs', F x
x : iT
n : nat
tvs' : list iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
ex (fun y : forall _ : hlist tvs', F x => and (eq (Some (existT (fun t : iT => forall _ : hlist tvs', F t) x f)) (Some (existT (fun t : iT => forall _ : hlist tvs', F t) x y))) (forall (vs : hlist nil) (vs' : hlist tvs'), eq (f (hlist_app vs vs')) (y vs')))
+++++
eexists.
-----
Lemma nth_error_get_hlist_nth_appR : forall tvs' tvs n x, n >= length tvs -> nth_error_get_hlist_nth (tvs ++ tvs') n = Some x -> exists y, nth_error_get_hlist_nth tvs' (n - length tvs) = Some (@existT _ _ (projT1 x) y) /\\ forall vs vs', (projT2 x) (hlist_app vs vs') = y vs'.
Proof.
clear.
induction tvs.
simpl.
intros.
rewrite <- Minus.minus_n_O.
rewrite H0.
destruct x.
simpl.
eexists.

*****
H0 : eq (nth_error_get_hlist_nth tvs' n)\n (Some (existT (fun t : iT => forall _ : hlist tvs', F t) x f))
H : ge n O
f : forall _ : hlist tvs', F x
x : iT
n : nat
tvs' : list iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
and (eq (Some (existT (fun t : iT => forall _ : hlist tvs', F t) x f)) (Some (existT (fun t : iT => forall _ : hlist tvs', F t) x ?y))) (forall (vs : hlist nil) (vs' : hlist tvs'), eq (f (hlist_app vs vs')) (?y vs'))
+++++
split.
-----
Lemma nth_error_get_hlist_nth_appR : forall tvs' tvs n x, n >= length tvs -> nth_error_get_hlist_nth (tvs ++ tvs') n = Some x -> exists y, nth_error_get_hlist_nth tvs' (n - length tvs) = Some (@existT _ _ (projT1 x) y) /\\ forall vs vs', (projT2 x) (hlist_app vs vs') = y vs'.
Proof.
clear.
induction tvs.
simpl.
intros.
rewrite <- Minus.minus_n_O.
rewrite H0.
destruct x.
simpl.
eexists.
split.

*****
H0 : eq (nth_error_get_hlist_nth tvs' n)\n (Some (existT (fun t : iT => forall _ : hlist tvs', F t) x f))
H : ge n O
f : forall _ : hlist tvs', F x
x : iT
n : nat
tvs' : list iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
eq (Some (existT (fun t : iT => forall _ : hlist tvs', F t) x f)) (Some (existT (fun t : iT => forall _ : hlist tvs', F t) x ?y))
+++++
eauto.
-----
Lemma nth_error_get_hlist_nth_appR : forall tvs' tvs n x, n >= length tvs -> nth_error_get_hlist_nth (tvs ++ tvs') n = Some x -> exists y, nth_error_get_hlist_nth tvs' (n - length tvs) = Some (@existT _ _ (projT1 x) y) /\\ forall vs vs', (projT2 x) (hlist_app vs vs') = y vs'.
Proof.
clear.
induction tvs.
simpl.
intros.
rewrite <- Minus.minus_n_O.
rewrite H0.
destruct x.
simpl.
eexists.
split.

*****
H0 : eq (nth_error_get_hlist_nth tvs' n)\n (Some (existT (fun t : iT => forall _ : hlist tvs', F t) x f))
H : ge n O
f : forall _ : hlist tvs', F x
x : iT
n : nat
tvs' : list iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall (vs : hlist nil) (vs' : hlist tvs'), eq (f (hlist_app vs vs')) (f vs')
+++++
eauto.
-----
Lemma nth_error_get_hlist_nth_appR : forall tvs' tvs n x, n >= length tvs -> nth_error_get_hlist_nth (tvs ++ tvs') n = Some x -> exists y, nth_error_get_hlist_nth tvs' (n - length tvs) = Some (@existT _ _ (projT1 x) y) /\\ forall vs vs', (projT2 x) (hlist_app vs vs') = y vs'.
Proof.
clear.
induction tvs.
simpl.
intros.
rewrite <- Minus.minus_n_O.
rewrite H0.
destruct x.
simpl.
eexists.
split.
eauto.

*****
H0 : eq (nth_error_get_hlist_nth tvs' n)\n (Some (existT (fun t : iT => forall _ : hlist tvs', F t) x f))
H : ge n O
f : forall _ : hlist tvs', F x
x : iT
n : nat
tvs' : list iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall (vs : hlist nil) (vs' : hlist tvs'), eq (f (hlist_app vs vs')) (f vs')
+++++
intros.
-----
Lemma nth_error_get_hlist_nth_appR : forall tvs' tvs n x, n >= length tvs -> nth_error_get_hlist_nth (tvs ++ tvs') n = Some x -> exists y, nth_error_get_hlist_nth tvs' (n - length tvs) = Some (@existT _ _ (projT1 x) y) /\\ forall vs vs', (projT2 x) (hlist_app vs vs') = y vs'.
Proof.
clear.
induction tvs.
simpl.
intros.
rewrite <- Minus.minus_n_O.
rewrite H0.
destruct x.
simpl.
eexists.
split.
eauto.
intros.

*****
vs' : hlist tvs'
vs : hlist nil
H0 : eq (nth_error_get_hlist_nth tvs' n)\n (Some (existT (fun t : iT => forall _ : hlist tvs', F t) x f))
H : ge n O
f : forall _ : hlist tvs', F x
x : iT
n : nat
tvs' : list iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
eq (f (hlist_app vs vs')) (f vs')
+++++
rewrite (hlist_eta vs).
-----
Lemma nth_error_get_hlist_nth_appR : forall tvs' tvs n x, n >= length tvs -> nth_error_get_hlist_nth (tvs ++ tvs') n = Some x -> exists y, nth_error_get_hlist_nth tvs' (n - length tvs) = Some (@existT _ _ (projT1 x) y) /\\ forall vs vs', (projT2 x) (hlist_app vs vs') = y vs'.
Proof.
clear.
induction tvs.
simpl.
intros.
rewrite <- Minus.minus_n_O.
rewrite H0.
destruct x.
simpl.
eexists.
split.
eauto.
intros.
rewrite (hlist_eta vs).

*****
vs' : hlist tvs'
vs : hlist nil
H0 : eq (nth_error_get_hlist_nth tvs' n)\n (Some (existT (fun t : iT => forall _ : hlist tvs', F t) x f))
H : ge n O
f : forall _ : hlist tvs', F x
x : iT
n : nat
tvs' : list iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
eq (f (hlist_app Hnil vs')) (f vs')
+++++
reflexivity.
-----
Lemma nth_error_get_hlist_nth_appR : forall tvs' tvs n x, n >= length tvs -> nth_error_get_hlist_nth (tvs ++ tvs') n = Some x -> exists y, nth_error_get_hlist_nth tvs' (n - length tvs) = Some (@existT _ _ (projT1 x) y) /\\ forall vs vs', (projT2 x) (hlist_app vs vs') = y vs'.
Proof.
clear.
induction tvs.

*****
IHtvs : forall (n : nat)\n (x : sigT (fun t : iT => forall _ : hlist (app tvs tvs'), F t))\n (_ : ge n (length tvs))\n (_ : eq (nth_error_get_hlist_nth (app tvs tvs') n) (Some x)),\nex\n (fun y : forall _ : hlist tvs', F (projT1 x) =>\n and\n (eq (nth_error_get_hlist_nth tvs' (Nat.sub n (length tvs)))\n (Some\n (existT (fun t : iT => forall _ : hlist tvs', F t)\n (projT1 x) y)))\n (forall (vs : hlist tvs) (vs' : hlist tvs'),\n eq (projT2 x (hlist_app vs vs')) (y vs')))
tvs : list iT
a : iT
tvs' : list iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall (n : nat) (x : sigT (fun t : iT => forall _ : hlist (app (cons a tvs) tvs'), F t)) (_ : ge n (length (cons a tvs))) (_ : eq (nth_error_get_hlist_nth (app (cons a tvs) tvs') n) (Some x)), ex (fun y : forall _ : hlist tvs', F (projT1 x) => and (eq (nth_error_get_hlist_nth tvs' (Nat.sub n (length (cons a tvs)))) (Some (existT (fun t : iT => forall _ : hlist tvs', F t) (projT1 x) y))) (forall (vs : hlist (cons a tvs)) (vs' : hlist tvs'), eq (projT2 x (hlist_app vs vs')) (y vs')))
+++++
simpl.
-----
Lemma nth_error_get_hlist_nth_appR : forall tvs' tvs n x, n >= length tvs -> nth_error_get_hlist_nth (tvs ++ tvs') n = Some x -> exists y, nth_error_get_hlist_nth tvs' (n - length tvs) = Some (@existT _ _ (projT1 x) y) /\\ forall vs vs', (projT2 x) (hlist_app vs vs') = y vs'.
Proof.
clear.
induction tvs.
simpl.

*****
IHtvs : forall (n : nat)\n (x : sigT (fun t : iT => forall _ : hlist (app tvs tvs'), F t))\n (_ : ge n (length tvs))\n (_ : eq (nth_error_get_hlist_nth (app tvs tvs') n) (Some x)),\nex\n (fun y : forall _ : hlist tvs', F (projT1 x) =>\n and\n (eq (nth_error_get_hlist_nth tvs' (Nat.sub n (length tvs)))\n (Some\n (existT (fun t : iT => forall _ : hlist tvs', F t)\n (projT1 x) y)))\n (forall (vs : hlist tvs) (vs' : hlist tvs'),\n eq (projT2 x (hlist_app vs vs')) (y vs')))
tvs : list iT
a : iT
tvs' : list iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall (n : nat) (x : sigT (fun t : iT => forall _ : hlist (cons a (app tvs tvs')), F t)) (_ : ge n (S (length tvs))) (_ : eq match n with | O => Some (existT (fun t : iT => forall _ : hlist (cons a (app tvs tvs')), F t) a hlist_hd) | S n0 => match nth_error_get_hlist_nth (app tvs tvs') n0 with | Some (@existT _ _ x0 f) => Some (existT (fun t : iT => forall _ : hlist (cons a (app tvs tvs')), F t) x0 (fun h : hlist (cons a (app tvs tvs')) => f (hlist_tl h))) | None => None end end (Some x)), ex (fun y : forall _ : hlist tvs', F (projT1 x) => and (eq (nth_error_get_hlist_nth tvs' (Nat.sub n (S (length tvs)))) (Some (existT (fun t : iT => forall _ : hlist tvs', F t) (projT1 x) y))) (forall (vs : hlist (cons a tvs)) (vs' : hlist tvs'), eq (projT2 x (hlist_app vs vs')) (y vs')))
+++++
intros.
-----
Lemma nth_error_get_hlist_nth_appR : forall tvs' tvs n x, n >= length tvs -> nth_error_get_hlist_nth (tvs ++ tvs') n = Some x -> exists y, nth_error_get_hlist_nth tvs' (n - length tvs) = Some (@existT _ _ (projT1 x) y) /\\ forall vs vs', (projT2 x) (hlist_app vs vs') = y vs'.
Proof.
clear.
induction tvs.
simpl.
intros.

*****
H0 : eq\n match n with\n | O =>\n Some\n (existT\n (fun t : iT => forall _ : hlist (cons a (app tvs tvs')), F t)\n a hlist_hd)\n | S n0 =>\n match nth_error_get_hlist_nth (app tvs tvs') n0 with\n | Some (@existT _ _ x f) =>\n Some\n (existT\n (fun t : iT =>\n forall _ : hlist (cons a (app tvs tvs')), F t) x\n (fun h : hlist (cons a (app tvs tvs')) => f (hlist_tl h)))\n | None => None\n end\n end (Some x)
H : ge n (S (length tvs))
x : sigT (fun t : iT => forall _ : hlist (cons a (app tvs tvs')), F t)
n : nat
IHtvs : forall (n : nat)\n (x : sigT (fun t : iT => forall _ : hlist (app tvs tvs'), F t))\n (_ : ge n (length tvs))\n (_ : eq (nth_error_get_hlist_nth (app tvs tvs') n) (Some x)),\nex\n (fun y : forall _ : hlist tvs', F (projT1 x) =>\n and\n (eq (nth_error_get_hlist_nth tvs' (Nat.sub n (length tvs)))\n (Some\n (existT (fun t : iT => forall _ : hlist tvs', F t)\n (projT1 x) y)))\n (forall (vs : hlist tvs) (vs' : hlist tvs'),\n eq (projT2 x (hlist_app vs vs')) (y vs')))
tvs : list iT
a : iT
tvs' : list iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
ex (fun y : forall _ : hlist tvs', F (projT1 x) => and (eq (nth_error_get_hlist_nth tvs' (Nat.sub n (S (length tvs)))) (Some (existT (fun t : iT => forall _ : hlist tvs', F t) (projT1 x) y))) (forall (vs : hlist (cons a tvs)) (vs' : hlist tvs'), eq (projT2 x (hlist_app vs vs')) (y vs')))
+++++
destruct n.
-----
Lemma nth_error_get_hlist_nth_appR : forall tvs' tvs n x, n >= length tvs -> nth_error_get_hlist_nth (tvs ++ tvs') n = Some x -> exists y, nth_error_get_hlist_nth tvs' (n - length tvs) = Some (@existT _ _ (projT1 x) y) /\\ forall vs vs', (projT2 x) (hlist_app vs vs') = y vs'.
Proof.
clear.
induction tvs.
simpl.
intros.
destruct n.

*****
H0 : eq\n (Some\n (existT\n (fun t : iT => forall _ : hlist (cons a (app tvs tvs')), F t) a\n hlist_hd)) (Some x)
H : ge O (S (length tvs))
x : sigT (fun t : iT => forall _ : hlist (cons a (app tvs tvs')), F t)
IHtvs : forall (n : nat)\n (x : sigT (fun t : iT => forall _ : hlist (app tvs tvs'), F t))\n (_ : ge n (length tvs))\n (_ : eq (nth_error_get_hlist_nth (app tvs tvs') n) (Some x)),\nex\n (fun y : forall _ : hlist tvs', F (projT1 x) =>\n and\n (eq (nth_error_get_hlist_nth tvs' (Nat.sub n (length tvs)))\n (Some\n (existT (fun t : iT => forall _ : hlist tvs', F t)\n (projT1 x) y)))\n (forall (vs : hlist tvs) (vs' : hlist tvs'),\n eq (projT2 x (hlist_app vs vs')) (y vs')))
tvs : list iT
a : iT
tvs' : list iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
ex (fun y : forall _ : hlist tvs', F (projT1 x) => and (eq (nth_error_get_hlist_nth tvs' (Nat.sub O (S (length tvs)))) (Some (existT (fun t : iT => forall _ : hlist tvs', F t) (projT1 x) y))) (forall (vs : hlist (cons a tvs)) (vs' : hlist tvs'), eq (projT2 x (hlist_app vs vs')) (y vs')))
+++++
inversion H.
-----
Lemma nth_error_get_hlist_nth_appR : forall tvs' tvs n x, n >= length tvs -> nth_error_get_hlist_nth (tvs ++ tvs') n = Some x -> exists y, nth_error_get_hlist_nth tvs' (n - length tvs) = Some (@existT _ _ (projT1 x) y) /\\ forall vs vs', (projT2 x) (hlist_app vs vs') = y vs'.
Proof.
clear.
induction tvs.
simpl.
intros.
destruct n.

*****
H0 : eq\n match nth_error_get_hlist_nth (app tvs tvs') n with\n | Some (@existT _ _ x f) =>\n Some\n (existT\n (fun t : iT => forall _ : hlist (cons a (app tvs tvs')), F t)\n x (fun h : hlist (cons a (app tvs tvs')) => f (hlist_tl h)))\n | None => None\n end (Some x)
H : ge (S n) (S (length tvs))
x : sigT (fun t : iT => forall _ : hlist (cons a (app tvs tvs')), F t)
n : nat
IHtvs : forall (n : nat)\n (x : sigT (fun t : iT => forall _ : hlist (app tvs tvs'), F t))\n (_ : ge n (length tvs))\n (_ : eq (nth_error_get_hlist_nth (app tvs tvs') n) (Some x)),\nex\n (fun y : forall _ : hlist tvs', F (projT1 x) =>\n and\n (eq (nth_error_get_hlist_nth tvs' (Nat.sub n (length tvs)))\n (Some\n (existT (fun t : iT => forall _ : hlist tvs', F t)\n (projT1 x) y)))\n (forall (vs : hlist tvs) (vs' : hlist tvs'),\n eq (projT2 x (hlist_app vs vs')) (y vs')))
tvs : list iT
a : iT
tvs' : list iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
ex (fun y : forall _ : hlist tvs', F (projT1 x) => and (eq (nth_error_get_hlist_nth tvs' (Nat.sub (S n) (S (length tvs)))) (Some (existT (fun t : iT => forall _ : hlist tvs', F t) (projT1 x) y))) (forall (vs : hlist (cons a tvs)) (vs' : hlist tvs'), eq (projT2 x (hlist_app vs vs')) (y vs')))
+++++
assert (n >= length tvs).
-----
Lemma nth_error_get_hlist_nth_appR : forall tvs' tvs n x, n >= length tvs -> nth_error_get_hlist_nth (tvs ++ tvs') n = Some x -> exists y, nth_error_get_hlist_nth tvs' (n - length tvs) = Some (@existT _ _ (projT1 x) y) /\\ forall vs vs', (projT2 x) (hlist_app vs vs') = y vs'.
Proof.
clear.
induction tvs.
simpl.
intros.
destruct n.
assert (n >= length tvs).

*****
H0 : eq\n match nth_error_get_hlist_nth (app tvs tvs') n with\n | Some (@existT _ _ x f) =>\n Some\n (existT\n (fun t : iT => forall _ : hlist (cons a (app tvs tvs')), F t)\n x (fun h : hlist (cons a (app tvs tvs')) => f (hlist_tl h)))\n | None => None\n end (Some x)
H : ge (S n) (S (length tvs))
x : sigT (fun t : iT => forall _ : hlist (cons a (app tvs tvs')), F t)
n : nat
IHtvs : forall (n : nat)\n (x : sigT (fun t : iT => forall _ : hlist (app tvs tvs'), F t))\n (_ : ge n (length tvs))\n (_ : eq (nth_error_get_hlist_nth (app tvs tvs') n) (Some x)),\nex\n (fun y : forall _ : hlist tvs', F (projT1 x) =>\n and\n (eq (nth_error_get_hlist_nth tvs' (Nat.sub n (length tvs)))\n (Some\n (existT (fun t : iT => forall _ : hlist tvs', F t)\n (projT1 x) y)))\n (forall (vs : hlist tvs) (vs' : hlist tvs'),\n eq (projT2 x (hlist_app vs vs')) (y vs')))
tvs : list iT
a : iT
tvs' : list iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
ge n (length tvs)
+++++
eapply le_S_n.
-----
Lemma nth_error_get_hlist_nth_appR : forall tvs' tvs n x, n >= length tvs -> nth_error_get_hlist_nth (tvs ++ tvs') n = Some x -> exists y, nth_error_get_hlist_nth tvs' (n - length tvs) = Some (@existT _ _ (projT1 x) y) /\\ forall vs vs', (projT2 x) (hlist_app vs vs') = y vs'.
Proof.
clear.
induction tvs.
simpl.
intros.
destruct n.
assert (n >= length tvs).
eapply le_S_n.

*****
H0 : eq\n match nth_error_get_hlist_nth (app tvs tvs') n with\n | Some (@existT _ _ x f) =>\n Some\n (existT\n (fun t : iT => forall _ : hlist (cons a (app tvs tvs')), F t)\n x (fun h : hlist (cons a (app tvs tvs')) => f (hlist_tl h)))\n | None => None\n end (Some x)
H : ge (S n) (S (length tvs))
x : sigT (fun t : iT => forall _ : hlist (cons a (app tvs tvs')), F t)
n : nat
IHtvs : forall (n : nat)\n (x : sigT (fun t : iT => forall _ : hlist (app tvs tvs'), F t))\n (_ : ge n (length tvs))\n (_ : eq (nth_error_get_hlist_nth (app tvs tvs') n) (Some x)),\nex\n (fun y : forall _ : hlist tvs', F (projT1 x) =>\n and\n (eq (nth_error_get_hlist_nth tvs' (Nat.sub n (length tvs)))\n (Some\n (existT (fun t : iT => forall _ : hlist tvs', F t)\n (projT1 x) y)))\n (forall (vs : hlist tvs) (vs' : hlist tvs'),\n eq (projT2 x (hlist_app vs vs')) (y vs')))
tvs : list iT
a : iT
tvs' : list iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
le (S (length tvs)) (S n)
+++++
eassumption.
-----
Lemma nth_error_get_hlist_nth_appR : forall tvs' tvs n x, n >= length tvs -> nth_error_get_hlist_nth (tvs ++ tvs') n = Some x -> exists y, nth_error_get_hlist_nth tvs' (n - length tvs) = Some (@existT _ _ (projT1 x) y) /\\ forall vs vs', (projT2 x) (hlist_app vs vs') = y vs'.
Proof.
clear.
induction tvs.
simpl.
intros.
destruct n.
assert (n >= length tvs).

*****
H1 : ge n (length tvs)
H0 : eq\n match nth_error_get_hlist_nth (app tvs tvs') n with\n | Some (@existT _ _ x f) =>\n Some\n (existT\n (fun t : iT => forall _ : hlist (cons a (app tvs tvs')), F t)\n x (fun h : hlist (cons a (app tvs tvs')) => f (hlist_tl h)))\n | None => None\n end (Some x)
H : ge (S n) (S (length tvs))
x : sigT (fun t : iT => forall _ : hlist (cons a (app tvs tvs')), F t)
n : nat
IHtvs : forall (n : nat)\n (x : sigT (fun t : iT => forall _ : hlist (app tvs tvs'), F t))\n (_ : ge n (length tvs))\n (_ : eq (nth_error_get_hlist_nth (app tvs tvs') n) (Some x)),\nex\n (fun y : forall _ : hlist tvs', F (projT1 x) =>\n and\n (eq (nth_error_get_hlist_nth tvs' (Nat.sub n (length tvs)))\n (Some\n (existT (fun t : iT => forall _ : hlist tvs', F t)\n (projT1 x) y)))\n (forall (vs : hlist tvs) (vs' : hlist tvs'),\n eq (projT2 x (hlist_app vs vs')) (y vs')))
tvs : list iT
a : iT
tvs' : list iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
ex (fun y : forall _ : hlist tvs', F (projT1 x) => and (eq (nth_error_get_hlist_nth tvs' (Nat.sub (S n) (S (length tvs)))) (Some (existT (fun t : iT => forall _ : hlist tvs', F t) (projT1 x) y))) (forall (vs : hlist (cons a tvs)) (vs' : hlist tvs'), eq (projT2 x (hlist_app vs vs')) (y vs')))
+++++
idtac.
-----
Lemma nth_error_get_hlist_nth_appR : forall tvs' tvs n x, n >= length tvs -> nth_error_get_hlist_nth (tvs ++ tvs') n = Some x -> exists y, nth_error_get_hlist_nth tvs' (n - length tvs) = Some (@existT _ _ (projT1 x) y) /\\ forall vs vs', (projT2 x) (hlist_app vs vs') = y vs'.
Proof.
clear.
induction tvs.
simpl.
intros.
destruct n.
assert (n >= length tvs).
idtac.

*****
H1 : ge n (length tvs)
H0 : eq\n match nth_error_get_hlist_nth (app tvs tvs') n with\n | Some (@existT _ _ x f) =>\n Some\n (existT\n (fun t : iT => forall _ : hlist (cons a (app tvs tvs')), F t)\n x (fun h : hlist (cons a (app tvs tvs')) => f (hlist_tl h)))\n | None => None\n end (Some x)
H : ge (S n) (S (length tvs))
x : sigT (fun t : iT => forall _ : hlist (cons a (app tvs tvs')), F t)
n : nat
IHtvs : forall (n : nat)\n (x : sigT (fun t : iT => forall _ : hlist (app tvs tvs'), F t))\n (_ : ge n (length tvs))\n (_ : eq (nth_error_get_hlist_nth (app tvs tvs') n) (Some x)),\nex\n (fun y : forall _ : hlist tvs', F (projT1 x) =>\n and\n (eq (nth_error_get_hlist_nth tvs' (Nat.sub n (length tvs)))\n (Some\n (existT (fun t : iT => forall _ : hlist tvs', F t)\n (projT1 x) y)))\n (forall (vs : hlist tvs) (vs' : hlist tvs'),\n eq (projT2 x (hlist_app vs vs')) (y vs')))
tvs : list iT
a : iT
tvs' : list iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
ex (fun y : forall _ : hlist tvs', F (projT1 x) => and (eq (nth_error_get_hlist_nth tvs' (Nat.sub (S n) (S (length tvs)))) (Some (existT (fun t : iT => forall _ : hlist tvs', F t) (projT1 x) y))) (forall (vs : hlist (cons a tvs)) (vs' : hlist tvs'), eq (projT2 x (hlist_app vs vs')) (y vs')))
+++++
clear H.
-----
Lemma nth_error_get_hlist_nth_appR : forall tvs' tvs n x, n >= length tvs -> nth_error_get_hlist_nth (tvs ++ tvs') n = Some x -> exists y, nth_error_get_hlist_nth tvs' (n - length tvs) = Some (@existT _ _ (projT1 x) y) /\\ forall vs vs', (projT2 x) (hlist_app vs vs') = y vs'.
Proof.
clear.
induction tvs.
simpl.
intros.
destruct n.
assert (n >= length tvs).
idtac.
clear H.

*****
H1 : ge n (length tvs)
H0 : eq\n match nth_error_get_hlist_nth (app tvs tvs') n with\n | Some (@existT _ _ x f) =>\n Some\n (existT\n (fun t : iT => forall _ : hlist (cons a (app tvs tvs')), F t)\n x (fun h : hlist (cons a (app tvs tvs')) => f (hlist_tl h)))\n | None => None\n end (Some x)
x : sigT (fun t : iT => forall _ : hlist (cons a (app tvs tvs')), F t)
n : nat
IHtvs : forall (n : nat)\n (x : sigT (fun t : iT => forall _ : hlist (app tvs tvs'), F t))\n (_ : ge n (length tvs))\n (_ : eq (nth_error_get_hlist_nth (app tvs tvs') n) (Some x)),\nex\n (fun y : forall _ : hlist tvs', F (projT1 x) =>\n and\n (eq (nth_error_get_hlist_nth tvs' (Nat.sub n (length tvs)))\n (Some\n (existT (fun t : iT => forall _ : hlist tvs', F t)\n (projT1 x) y)))\n (forall (vs : hlist tvs) (vs' : hlist tvs'),\n eq (projT2 x (hlist_app vs vs')) (y vs')))
tvs : list iT
a : iT
tvs' : list iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
ex (fun y : forall _ : hlist tvs', F (projT1 x) => and (eq (nth_error_get_hlist_nth tvs' (Nat.sub (S n) (S (length tvs)))) (Some (existT (fun t : iT => forall _ : hlist tvs', F t) (projT1 x) y))) (forall (vs : hlist (cons a tvs)) (vs' : hlist tvs'), eq (projT2 x (hlist_app vs vs')) (y vs')))
+++++
forward.
-----
Lemma nth_error_get_hlist_nth_appR : forall tvs' tvs n x, n >= length tvs -> nth_error_get_hlist_nth (tvs ++ tvs') n = Some x -> exists y, nth_error_get_hlist_nth tvs' (n - length tvs) = Some (@existT _ _ (projT1 x) y) /\\ forall vs vs', (projT2 x) (hlist_app vs vs') = y vs'.
Proof.
clear.
induction tvs.
simpl.
intros.
destruct n.
assert (n >= length tvs).
idtac.
clear H.
forward.

*****
H2 : eq\n (Some\n (existT\n (fun t : iT => forall _ : hlist (cons a (app tvs tvs')), F t)\n x0 (fun h : hlist (cons a (app tvs tvs')) => f (hlist_tl h))))\n (Some x)
H0 : eq (nth_error_get_hlist_nth (app tvs tvs') n)\n (Some\n (existT (fun t : iT => forall _ : hlist (app tvs tvs'), F t) x0 f))
H : eq s (existT (fun t : iT => forall _ : hlist (app tvs tvs'), F t) x0 f)
f : forall _ : hlist (app tvs tvs'), F x0
x0 : iT
s : sigT (fun t : iT => forall _ : hlist (app tvs tvs'), F t)
H1 : ge n (length tvs)
x : sigT (fun t : iT => forall _ : hlist (cons a (app tvs tvs')), F t)
n : nat
IHtvs : forall (n : nat)\n (x : sigT (fun t : iT => forall _ : hlist (app tvs tvs'), F t))\n (_ : ge n (length tvs))\n (_ : eq (nth_error_get_hlist_nth (app tvs tvs') n) (Some x)),\nex\n (fun y : forall _ : hlist tvs', F (projT1 x) =>\n and\n (eq (nth_error_get_hlist_nth tvs' (Nat.sub n (length tvs)))\n (Some\n (existT (fun t : iT => forall _ : hlist tvs', F t)\n (projT1 x) y)))\n (forall (vs : hlist tvs) (vs' : hlist tvs'),\n eq (projT2 x (hlist_app vs vs')) (y vs')))
tvs : list iT
a : iT
tvs' : list iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
ex (fun y : forall _ : hlist tvs', F (projT1 x) => and (eq (nth_error_get_hlist_nth tvs' (Nat.sub (S n) (S (length tvs)))) (Some (existT (fun t : iT => forall _ : hlist tvs', F t) (projT1 x) y))) (forall (vs : hlist (cons a tvs)) (vs' : hlist tvs'), eq (projT2 x (hlist_app vs vs')) (y vs')))
+++++
inv_all.
-----
Lemma nth_error_get_hlist_nth_appR : forall tvs' tvs n x, n >= length tvs -> nth_error_get_hlist_nth (tvs ++ tvs') n = Some x -> exists y, nth_error_get_hlist_nth tvs' (n - length tvs) = Some (@existT _ _ (projT1 x) y) /\\ forall vs vs', (projT2 x) (hlist_app vs vs') = y vs'.
Proof.
clear.
induction tvs.
simpl.
intros.
destruct n.
assert (n >= length tvs).
idtac.
clear H.
forward.
inv_all.

*****
H2 : eq\n (existT (fun t : iT => forall _ : hlist (cons a (app tvs tvs')), F t)\n x0 (fun h : hlist (cons a (app tvs tvs')) => f (hlist_tl h))) x
H0 : eq (nth_error_get_hlist_nth (app tvs tvs') n)\n (Some\n (existT (fun t : iT => forall _ : hlist (app tvs tvs'), F t) x0 f))
H : eq s (existT (fun t : iT => forall _ : hlist (app tvs tvs'), F t) x0 f)
f : forall _ : hlist (app tvs tvs'), F x0
x0 : iT
s : sigT (fun t : iT => forall _ : hlist (app tvs tvs'), F t)
H1 : ge n (length tvs)
x : sigT (fun t : iT => forall _ : hlist (cons a (app tvs tvs')), F t)
n : nat
IHtvs : forall (n : nat)\n (x : sigT (fun t : iT => forall _ : hlist (app tvs tvs'), F t))\n (_ : ge n (length tvs))\n (_ : eq (nth_error_get_hlist_nth (app tvs tvs') n) (Some x)),\nex\n (fun y : forall _ : hlist tvs', F (projT1 x) =>\n and\n (eq (nth_error_get_hlist_nth tvs' (Nat.sub n (length tvs)))\n (Some\n (existT (fun t : iT => forall _ : hlist tvs', F t)\n (projT1 x) y)))\n (forall (vs : hlist tvs) (vs' : hlist tvs'),\n eq (projT2 x (hlist_app vs vs')) (y vs')))
tvs : list iT
a : iT
tvs' : list iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
ex (fun y : forall _ : hlist tvs', F (projT1 x) => and (eq (nth_error_get_hlist_nth tvs' (Nat.sub (S n) (S (length tvs)))) (Some (existT (fun t : iT => forall _ : hlist tvs', F t) (projT1 x) y))) (forall (vs : hlist (cons a tvs)) (vs' : hlist tvs'), eq (projT2 x (hlist_app vs vs')) (y vs')))
+++++
subst.
-----
Lemma nth_error_get_hlist_nth_appR : forall tvs' tvs n x, n >= length tvs -> nth_error_get_hlist_nth (tvs ++ tvs') n = Some x -> exists y, nth_error_get_hlist_nth tvs' (n - length tvs) = Some (@existT _ _ (projT1 x) y) /\\ forall vs vs', (projT2 x) (hlist_app vs vs') = y vs'.
Proof.
clear.
induction tvs.
simpl.
intros.
destruct n.
assert (n >= length tvs).
idtac.
clear H.
forward.
inv_all.
subst.

*****
H0 : eq (nth_error_get_hlist_nth (app tvs tvs') n)\n (Some\n (existT (fun t : iT => forall _ : hlist (app tvs tvs'), F t) x0 f))
f : forall _ : hlist (app tvs tvs'), F x0
x0 : iT
H1 : ge n (length tvs)
n : nat
IHtvs : forall (n : nat)\n (x : sigT (fun t : iT => forall _ : hlist (app tvs tvs'), F t))\n (_ : ge n (length tvs))\n (_ : eq (nth_error_get_hlist_nth (app tvs tvs') n) (Some x)),\nex\n (fun y : forall _ : hlist tvs', F (projT1 x) =>\n and\n (eq (nth_error_get_hlist_nth tvs' (Nat.sub n (length tvs)))\n (Some\n (existT (fun t : iT => forall _ : hlist tvs', F t)\n (projT1 x) y)))\n (forall (vs : hlist tvs) (vs' : hlist tvs'),\n eq (projT2 x (hlist_app vs vs')) (y vs')))
tvs : list iT
a : iT
tvs' : list iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
ex (fun y : forall _ : hlist tvs', F (projT1 (existT (fun t : iT => forall _ : hlist (cons a (app tvs tvs')), F t) x0 (fun h : hlist (cons a (app tvs tvs')) => f (hlist_tl h)))) => and (eq (nth_error_get_hlist_nth tvs' (Nat.sub (S n) (S (length tvs)))) (Some (existT (fun t : iT => forall _ : hlist tvs', F t) (projT1 (existT (fun t : iT => forall _ : hlist (cons a (app tvs tvs')), F t) x0 (fun h : hlist (cons a (app tvs tvs')) => f (hlist_tl h)))) y))) (forall (vs : hlist (cons a tvs)) (vs' : hlist tvs'), eq (projT2 (existT (fun t : iT => forall _ : hlist (cons a (app tvs tvs')), F t) x0 (fun h : hlist (cons a (app tvs tvs')) => f (hlist_tl h))) (hlist_app vs vs')) (y vs')))
+++++
simpl in *.
-----
Lemma nth_error_get_hlist_nth_appR : forall tvs' tvs n x, n >= length tvs -> nth_error_get_hlist_nth (tvs ++ tvs') n = Some x -> exists y, nth_error_get_hlist_nth tvs' (n - length tvs) = Some (@existT _ _ (projT1 x) y) /\\ forall vs vs', (projT2 x) (hlist_app vs vs') = y vs'.
Proof.
clear.
induction tvs.
simpl.
intros.
destruct n.
assert (n >= length tvs).
idtac.
clear H.
forward.
inv_all.
subst.
simpl in *.

*****
H0 : eq (nth_error_get_hlist_nth (app tvs tvs') n)\n (Some\n (existT (fun t : iT => forall _ : hlist (app tvs tvs'), F t) x0 f))
f : forall _ : hlist (app tvs tvs'), F x0
x0 : iT
H1 : ge n (length tvs)
n : nat
IHtvs : forall (n : nat)\n (x : sigT (fun t : iT => forall _ : hlist (app tvs tvs'), F t))\n (_ : ge n (length tvs))\n (_ : eq (nth_error_get_hlist_nth (app tvs tvs') n) (Some x)),\nex\n (fun y : forall _ : hlist tvs', F (projT1 x) =>\n and\n (eq (nth_error_get_hlist_nth tvs' (Nat.sub n (length tvs)))\n (Some\n (existT (fun t : iT => forall _ : hlist tvs', F t)\n (projT1 x) y)))\n (forall (vs : hlist tvs) (vs' : hlist tvs'),\n eq (projT2 x (hlist_app vs vs')) (y vs')))
tvs : list iT
a : iT
tvs' : list iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
ex (fun y : forall _ : hlist tvs', F x0 => and (eq (nth_error_get_hlist_nth tvs' (Nat.sub n (length tvs))) (Some (existT (fun t : iT => forall _ : hlist tvs', F t) x0 y))) (forall (vs : hlist (cons a tvs)) (vs' : hlist tvs'), eq (f (hlist_tl (hlist_app vs vs'))) (y vs')))
+++++
specialize (IHtvs _ _ H1 H0).
-----
Lemma nth_error_get_hlist_nth_appR : forall tvs' tvs n x, n >= length tvs -> nth_error_get_hlist_nth (tvs ++ tvs') n = Some x -> exists y, nth_error_get_hlist_nth tvs' (n - length tvs) = Some (@existT _ _ (projT1 x) y) /\\ forall vs vs', (projT2 x) (hlist_app vs vs') = y vs'.
Proof.
clear.
induction tvs.
simpl.
intros.
destruct n.
assert (n >= length tvs).
idtac.
clear H.
forward.
inv_all.
subst.
simpl in *.
specialize (IHtvs _ _ H1 H0).

*****
H0 : eq (nth_error_get_hlist_nth (app tvs tvs') n)\n (Some\n (existT (fun t : iT => forall _ : hlist (app tvs tvs'), F t) x0 f))
H1 : ge n (length tvs)
IHtvs : ex\n (fun\n y : forall _ : hlist tvs',\n F\n (projT1\n (existT\n (fun t : iT => forall _ : hlist (app tvs tvs'), F t)\n x0 f)) =>\n and\n (eq (nth_error_get_hlist_nth tvs' (Nat.sub n (length tvs)))\n (Some\n (existT (fun t : iT => forall _ : hlist tvs', F t)\n (projT1\n (existT\n (fun t : iT => forall _ : hlist (app tvs tvs'), F t)\n x0 f)) y)))\n (forall (vs : hlist tvs) (vs' : hlist tvs'),\n eq\n (projT2\n (existT (fun t : iT => forall _ : hlist (app tvs tvs'), F t)\n x0 f) (hlist_app vs vs')) (y vs')))
f : forall _ : hlist (app tvs tvs'), F x0
x0 : iT
n : nat
tvs : list iT
a : iT
tvs' : list iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
ex (fun y : forall _ : hlist tvs', F x0 => and (eq (nth_error_get_hlist_nth tvs' (Nat.sub n (length tvs))) (Some (existT (fun t : iT => forall _ : hlist tvs', F t) x0 y))) (forall (vs : hlist (cons a tvs)) (vs' : hlist tvs'), eq (f (hlist_tl (hlist_app vs vs'))) (y vs')))
+++++
simpl in *.
-----
Lemma nth_error_get_hlist_nth_appR : forall tvs' tvs n x, n >= length tvs -> nth_error_get_hlist_nth (tvs ++ tvs') n = Some x -> exists y, nth_error_get_hlist_nth tvs' (n - length tvs) = Some (@existT _ _ (projT1 x) y) /\\ forall vs vs', (projT2 x) (hlist_app vs vs') = y vs'.
Proof.
clear.
induction tvs.
simpl.
intros.
destruct n.
assert (n >= length tvs).
idtac.
clear H.
forward.
inv_all.
subst.
simpl in *.
specialize (IHtvs _ _ H1 H0).
simpl in *.

*****
H0 : eq (nth_error_get_hlist_nth (app tvs tvs') n)\n (Some\n (existT (fun t : iT => forall _ : hlist (app tvs tvs'), F t) x0 f))
H1 : ge n (length tvs)
IHtvs : ex\n (fun y : forall _ : hlist tvs', F x0 =>\n and\n (eq (nth_error_get_hlist_nth tvs' (Nat.sub n (length tvs)))\n (Some (existT (fun t : iT => forall _ : hlist tvs', F t) x0 y)))\n (forall (vs : hlist tvs) (vs' : hlist tvs'),\n eq (f (hlist_app vs vs')) (y vs')))
f : forall _ : hlist (app tvs tvs'), F x0
x0 : iT
n : nat
tvs : list iT
a : iT
tvs' : list iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
ex (fun y : forall _ : hlist tvs', F x0 => and (eq (nth_error_get_hlist_nth tvs' (Nat.sub n (length tvs))) (Some (existT (fun t : iT => forall _ : hlist tvs', F t) x0 y))) (forall (vs : hlist (cons a tvs)) (vs' : hlist tvs'), eq (f (hlist_tl (hlist_app vs vs'))) (y vs')))
+++++
forward_reason.
-----
Lemma nth_error_get_hlist_nth_appR : forall tvs' tvs n x, n >= length tvs -> nth_error_get_hlist_nth (tvs ++ tvs') n = Some x -> exists y, nth_error_get_hlist_nth tvs' (n - length tvs) = Some (@existT _ _ (projT1 x) y) /\\ forall vs vs', (projT2 x) (hlist_app vs vs') = y vs'.
Proof.
clear.
induction tvs.
simpl.
intros.
destruct n.
assert (n >= length tvs).
idtac.
clear H.
forward.
inv_all.
subst.
simpl in *.
specialize (IHtvs _ _ H1 H0).
simpl in *.
forward_reason.

*****
H0 : eq (nth_error_get_hlist_nth (app tvs tvs') n)\n (Some\n (existT (fun t : iT => forall _ : hlist (app tvs tvs'), F t) x0 f))
H1 : ge n (length tvs)
H2 : forall (vs : hlist tvs) (vs' : hlist tvs'),\neq (f (hlist_app vs vs')) (x vs')
H : eq (nth_error_get_hlist_nth tvs' (Nat.sub n (length tvs)))\n (Some (existT (fun t : iT => forall _ : hlist tvs', F t) x0 x))
x : forall _ : hlist tvs', F x0
f : forall _ : hlist (app tvs tvs'), F x0
x0 : iT
n : nat
tvs : list iT
a : iT
tvs' : list iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
ex (fun y : forall _ : hlist tvs', F x0 => and (eq (nth_error_get_hlist_nth tvs' (Nat.sub n (length tvs))) (Some (existT (fun t : iT => forall _ : hlist tvs', F t) x0 y))) (forall (vs : hlist (cons a tvs)) (vs' : hlist tvs'), eq (f (hlist_tl (hlist_app vs vs'))) (y vs')))
+++++
rewrite H.
-----
Lemma nth_error_get_hlist_nth_appR : forall tvs' tvs n x, n >= length tvs -> nth_error_get_hlist_nth (tvs ++ tvs') n = Some x -> exists y, nth_error_get_hlist_nth tvs' (n - length tvs) = Some (@existT _ _ (projT1 x) y) /\\ forall vs vs', (projT2 x) (hlist_app vs vs') = y vs'.
Proof.
clear.
induction tvs.
simpl.
intros.
destruct n.
assert (n >= length tvs).
idtac.
clear H.
forward.
inv_all.
subst.
simpl in *.
specialize (IHtvs _ _ H1 H0).
simpl in *.
forward_reason.
rewrite H.

*****
H0 : eq (nth_error_get_hlist_nth (app tvs tvs') n)\n (Some\n (existT (fun t : iT => forall _ : hlist (app tvs tvs'), F t) x0 f))
H1 : ge n (length tvs)
H2 : forall (vs : hlist tvs) (vs' : hlist tvs'),\neq (f (hlist_app vs vs')) (x vs')
H : eq (nth_error_get_hlist_nth tvs' (Nat.sub n (length tvs)))\n (Some (existT (fun t : iT => forall _ : hlist tvs', F t) x0 x))
x : forall _ : hlist tvs', F x0
f : forall _ : hlist (app tvs tvs'), F x0
x0 : iT
n : nat
tvs : list iT
a : iT
tvs' : list iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
ex (fun y : forall _ : hlist tvs', F x0 => and (eq (Some (existT (fun t : iT => forall _ : hlist tvs', F t) x0 x)) (Some (existT (fun t : iT => forall _ : hlist tvs', F t) x0 y))) (forall (vs : hlist (cons a tvs)) (vs' : hlist tvs'), eq (f (hlist_tl (hlist_app vs vs'))) (y vs')))
+++++
eexists.
-----
Lemma nth_error_get_hlist_nth_appR : forall tvs' tvs n x, n >= length tvs -> nth_error_get_hlist_nth (tvs ++ tvs') n = Some x -> exists y, nth_error_get_hlist_nth tvs' (n - length tvs) = Some (@existT _ _ (projT1 x) y) /\\ forall vs vs', (projT2 x) (hlist_app vs vs') = y vs'.
Proof.
clear.
induction tvs.
simpl.
intros.
destruct n.
assert (n >= length tvs).
idtac.
clear H.
forward.
inv_all.
subst.
simpl in *.
specialize (IHtvs _ _ H1 H0).
simpl in *.
forward_reason.
rewrite H.
eexists.

*****
H0 : eq (nth_error_get_hlist_nth (app tvs tvs') n)\n (Some\n (existT (fun t : iT => forall _ : hlist (app tvs tvs'), F t) x0 f))
H1 : ge n (length tvs)
H2 : forall (vs : hlist tvs) (vs' : hlist tvs'),\neq (f (hlist_app vs vs')) (x vs')
H : eq (nth_error_get_hlist_nth tvs' (Nat.sub n (length tvs)))\n (Some (existT (fun t : iT => forall _ : hlist tvs', F t) x0 x))
x : forall _ : hlist tvs', F x0
f : forall _ : hlist (app tvs tvs'), F x0
x0 : iT
n : nat
tvs : list iT
a : iT
tvs' : list iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
and (eq (Some (existT (fun t : iT => forall _ : hlist tvs', F t) x0 x)) (Some (existT (fun t : iT => forall _ : hlist tvs', F t) x0 ?y))) (forall (vs : hlist (cons a tvs)) (vs' : hlist tvs'), eq (f (hlist_tl (hlist_app vs vs'))) (?y vs'))
+++++
split.
-----
Lemma nth_error_get_hlist_nth_appR : forall tvs' tvs n x, n >= length tvs -> nth_error_get_hlist_nth (tvs ++ tvs') n = Some x -> exists y, nth_error_get_hlist_nth tvs' (n - length tvs) = Some (@existT _ _ (projT1 x) y) /\\ forall vs vs', (projT2 x) (hlist_app vs vs') = y vs'.
Proof.
clear.
induction tvs.
simpl.
intros.
destruct n.
assert (n >= length tvs).
idtac.
clear H.
forward.
inv_all.
subst.
simpl in *.
specialize (IHtvs _ _ H1 H0).
simpl in *.
forward_reason.
rewrite H.
eexists.
split.

*****
H0 : eq (nth_error_get_hlist_nth (app tvs tvs') n)\n (Some\n (existT (fun t : iT => forall _ : hlist (app tvs tvs'), F t) x0 f))
H1 : ge n (length tvs)
H2 : forall (vs : hlist tvs) (vs' : hlist tvs'),\neq (f (hlist_app vs vs')) (x vs')
H : eq (nth_error_get_hlist_nth tvs' (Nat.sub n (length tvs)))\n (Some (existT (fun t : iT => forall _ : hlist tvs', F t) x0 x))
x : forall _ : hlist tvs', F x0
f : forall _ : hlist (app tvs tvs'), F x0
x0 : iT
n : nat
tvs : list iT
a : iT
tvs' : list iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
eq (Some (existT (fun t : iT => forall _ : hlist tvs', F t) x0 x)) (Some (existT (fun t : iT => forall _ : hlist tvs', F t) x0 ?y))
+++++
eauto.
-----
Lemma nth_error_get_hlist_nth_appR : forall tvs' tvs n x, n >= length tvs -> nth_error_get_hlist_nth (tvs ++ tvs') n = Some x -> exists y, nth_error_get_hlist_nth tvs' (n - length tvs) = Some (@existT _ _ (projT1 x) y) /\\ forall vs vs', (projT2 x) (hlist_app vs vs') = y vs'.
Proof.
clear.
induction tvs.
simpl.
intros.
destruct n.
assert (n >= length tvs).
idtac.
clear H.
forward.
inv_all.
subst.
simpl in *.
specialize (IHtvs _ _ H1 H0).
simpl in *.
forward_reason.
rewrite H.
eexists.
split.

*****
H0 : eq (nth_error_get_hlist_nth (app tvs tvs') n)\n (Some\n (existT (fun t : iT => forall _ : hlist (app tvs tvs'), F t) x0 f))
H1 : ge n (length tvs)
H2 : forall (vs : hlist tvs) (vs' : hlist tvs'),\neq (f (hlist_app vs vs')) (x vs')
H : eq (nth_error_get_hlist_nth tvs' (Nat.sub n (length tvs)))\n (Some (existT (fun t : iT => forall _ : hlist tvs', F t) x0 x))
x : forall _ : hlist tvs', F x0
f : forall _ : hlist (app tvs tvs'), F x0
x0 : iT
n : nat
tvs : list iT
a : iT
tvs' : list iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall (vs : hlist (cons a tvs)) (vs' : hlist tvs'), eq (f (hlist_tl (hlist_app vs vs'))) (x vs')
+++++
eauto.
-----
Lemma nth_error_get_hlist_nth_appR : forall tvs' tvs n x, n >= length tvs -> nth_error_get_hlist_nth (tvs ++ tvs') n = Some x -> exists y, nth_error_get_hlist_nth tvs' (n - length tvs) = Some (@existT _ _ (projT1 x) y) /\\ forall vs vs', (projT2 x) (hlist_app vs vs') = y vs'.
Proof.
clear.
induction tvs.
simpl.
intros.
destruct n.
assert (n >= length tvs).
idtac.
clear H.
forward.
inv_all.
subst.
simpl in *.
specialize (IHtvs _ _ H1 H0).
simpl in *.
forward_reason.
rewrite H.
eexists.
split.
eauto.

*****
H0 : eq (nth_error_get_hlist_nth (app tvs tvs') n)\n (Some\n (existT (fun t : iT => forall _ : hlist (app tvs tvs'), F t) x0 f))
H1 : ge n (length tvs)
H2 : forall (vs : hlist tvs) (vs' : hlist tvs'),\neq (f (hlist_app vs vs')) (x vs')
H : eq (nth_error_get_hlist_nth tvs' (Nat.sub n (length tvs)))\n (Some (existT (fun t : iT => forall _ : hlist tvs', F t) x0 x))
x : forall _ : hlist tvs', F x0
f : forall _ : hlist (app tvs tvs'), F x0
x0 : iT
n : nat
tvs : list iT
a : iT
tvs' : list iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
forall (vs : hlist (cons a tvs)) (vs' : hlist tvs'), eq (f (hlist_tl (hlist_app vs vs'))) (x vs')
+++++
intros.
-----
Lemma nth_error_get_hlist_nth_appR : forall tvs' tvs n x, n >= length tvs -> nth_error_get_hlist_nth (tvs ++ tvs') n = Some x -> exists y, nth_error_get_hlist_nth tvs' (n - length tvs) = Some (@existT _ _ (projT1 x) y) /\\ forall vs vs', (projT2 x) (hlist_app vs vs') = y vs'.
Proof.
clear.
induction tvs.
simpl.
intros.
destruct n.
assert (n >= length tvs).
idtac.
clear H.
forward.
inv_all.
subst.
simpl in *.
specialize (IHtvs _ _ H1 H0).
simpl in *.
forward_reason.
rewrite H.
eexists.
split.
eauto.
intros.

*****
vs' : hlist tvs'
vs : hlist (cons a tvs)
H0 : eq (nth_error_get_hlist_nth (app tvs tvs') n)\n (Some\n (existT (fun t : iT => forall _ : hlist (app tvs tvs'), F t) x0 f))
H1 : ge n (length tvs)
H2 : forall (vs : hlist tvs) (vs' : hlist tvs'),\neq (f (hlist_app vs vs')) (x vs')
H : eq (nth_error_get_hlist_nth tvs' (Nat.sub n (length tvs)))\n (Some (existT (fun t : iT => forall _ : hlist tvs', F t) x0 x))
x : forall _ : hlist tvs', F x0
f : forall _ : hlist (app tvs tvs'), F x0
x0 : iT
n : nat
tvs : list iT
a : iT
tvs' : list iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
eq (f (hlist_tl (hlist_app vs vs'))) (x vs')
+++++
rewrite (hlist_eta vs).
-----
Lemma nth_error_get_hlist_nth_appR : forall tvs' tvs n x, n >= length tvs -> nth_error_get_hlist_nth (tvs ++ tvs') n = Some x -> exists y, nth_error_get_hlist_nth tvs' (n - length tvs) = Some (@existT _ _ (projT1 x) y) /\\ forall vs vs', (projT2 x) (hlist_app vs vs') = y vs'.
Proof.
clear.
induction tvs.
simpl.
intros.
destruct n.
assert (n >= length tvs).
idtac.
clear H.
forward.
inv_all.
subst.
simpl in *.
specialize (IHtvs _ _ H1 H0).
simpl in *.
forward_reason.
rewrite H.
eexists.
split.
eauto.
intros.
rewrite (hlist_eta vs).

*****
vs' : hlist tvs'
vs : hlist (cons a tvs)
H0 : eq (nth_error_get_hlist_nth (app tvs tvs') n)\n (Some\n (existT (fun t : iT => forall _ : hlist (app tvs tvs'), F t) x0 f))
H1 : ge n (length tvs)
H2 : forall (vs : hlist tvs) (vs' : hlist tvs'),\neq (f (hlist_app vs vs')) (x vs')
H : eq (nth_error_get_hlist_nth tvs' (Nat.sub n (length tvs)))\n (Some (existT (fun t : iT => forall _ : hlist tvs', F t) x0 x))
x : forall _ : hlist tvs', F x0
f : forall _ : hlist (app tvs tvs'), F x0
x0 : iT
n : nat
tvs : list iT
a : iT
tvs' : list iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
eq (f (hlist_tl (hlist_app (Hcons (hlist_hd vs) (hlist_tl vs)) vs'))) (x vs')
+++++
simpl.
-----
Lemma nth_error_get_hlist_nth_appR : forall tvs' tvs n x, n >= length tvs -> nth_error_get_hlist_nth (tvs ++ tvs') n = Some x -> exists y, nth_error_get_hlist_nth tvs' (n - length tvs) = Some (@existT _ _ (projT1 x) y) /\\ forall vs vs', (projT2 x) (hlist_app vs vs') = y vs'.
Proof.
clear.
induction tvs.
simpl.
intros.
destruct n.
assert (n >= length tvs).
idtac.
clear H.
forward.
inv_all.
subst.
simpl in *.
specialize (IHtvs _ _ H1 H0).
simpl in *.
forward_reason.
rewrite H.
eexists.
split.
eauto.
intros.
rewrite (hlist_eta vs).
simpl.

*****
vs' : hlist tvs'
vs : hlist (cons a tvs)
H0 : eq (nth_error_get_hlist_nth (app tvs tvs') n)\n (Some\n (existT (fun t : iT => forall _ : hlist (app tvs tvs'), F t) x0 f))
H1 : ge n (length tvs)
H2 : forall (vs : hlist tvs) (vs' : hlist tvs'),\neq (f (hlist_app vs vs')) (x vs')
H : eq (nth_error_get_hlist_nth tvs' (Nat.sub n (length tvs)))\n (Some (existT (fun t : iT => forall _ : hlist tvs', F t) x0 x))
x : forall _ : hlist tvs', F x0
f : forall _ : hlist (app tvs tvs'), F x0
x0 : iT
n : nat
tvs : list iT
a : iT
tvs' : list iT
F : forall _ : iT, Type@{Uv}
iT : Type@{Ui}
*****
eq (f (hlist_app (hlist_tl vs) vs')) (x vs')
+++++
auto.
-----
Lemma nth_error_get_hlist_nth_appR : forall tvs' tvs n x, n >= length tvs -> nth_error_get_hlist_nth (tvs ++ tvs') n = Some x -> exists y, nth_error_get_hlist_nth tvs' (n - length tvs) = Some (@existT _ _ (projT1 x) y) /\\ forall vs vs', (projT2 x) (hlist_app vs vs') = y vs'.
Proof.
clear.
induction tvs.

*****

*****

+++++
Qed.
-----
End hlist.
-----
Arguments Hnil {_ _}.
-----
Arguments Hcons {_ _ _ _} _ _.
-----
Arguments equiv_hlist {_ F} R {_} _ _ : rename.
-----
Section hlist_map.
-----
Variable A : Type.
-----
Variables F G : A -> Type.
-----
Variable ff : forall x, F x -> G x.
-----
Fixpoint hlist_map (ls : list A) (hl : hlist F ls) {struct hl} : hlist G ls :=\n    match hl in @hlist _ _ ls return hlist G ls with\n      | Hnil => Hnil\n      | Hcons _ _ hd tl =>\n        Hcons (ff hd) (hlist_map tl)\n    end.
-----
Theorem hlist_app_hlist_map\n    : forall ls ls' (a : hlist F ls) (b : hlist F ls'),\n      hlist_map (hlist_app a b) =\n      hlist_app (hlist_map a) (hlist_map b).
-----
Theorem hlist_app_hlist_map : forall ls ls' (a : hlist F ls) (b : hlist F ls'), hlist_map (hlist_app a b) = hlist_app (hlist_map a) (hlist_map b).

*****
ff : forall (x : A) (_ : F x), G x
G : forall _ : A, Type@{SerTop.353}
F : forall _ : A, Type@{SerTop.352}
A : Type@{SerTop\.351}
*****
forall (ls ls' : list A) (a : hlist@{SerTop.351 SerTop.352} F ls) (b : hlist@{SerTop.351 SerTop.352} F ls'), eq (hlist_map (hlist_app@{SerTop.351 SerTop.352} a b)) (hlist_app@{SerTop.351 SerTop.353} (hlist_map a) (hlist_map b))
+++++
Proof.
-----
Theorem hlist_app_hlist_map : forall ls ls' (a : hlist F ls) (b : hlist F ls'), hlist_map (hlist_app a b) = hlist_app (hlist_map a) (hlist_map b).
Proof.

*****
ff : forall (x : A) (_ : F x), G x
G : forall _ : A, Type@{SerTop.353}
F : forall _ : A, Type@{SerTop.352}
A : Type@{SerTop\.351}
*****
forall (ls ls' : list A) (a : hlist@{SerTop.351 SerTop.352} F ls) (b : hlist@{SerTop.351 SerTop.352} F ls'), eq (hlist_map (hlist_app@{SerTop.351 SerTop.352} a b)) (hlist_app@{SerTop.351 SerTop.353} (hlist_map a) (hlist_map b))
+++++
induction a.
-----
Theorem hlist_app_hlist_map : forall ls ls' (a : hlist F ls) (b : hlist F ls'), hlist_map (hlist_app a b) = hlist_app (hlist_map a) (hlist_map b).
Proof.
induction a.

*****
ls' : list A
ff : forall (x : A) (_ : F x), G x
G : forall _ : A, Type@{SerTop.353}
F : forall _ : A, Type@{SerTop.352}
A : Type@{SerTop\.351}
*****
forall b : hlist@{SerTop.351 SerTop.352} F ls', eq (hlist_map (hlist_app@{SerTop.351 SerTop.352} Hnil@{SerTop.351 SerTop.352} b)) (hlist_app@{SerTop.351 SerTop.353} (hlist_map Hnil@{SerTop.351 SerTop.352}) (hlist_map b))
+++++
simpl.
-----
Theorem hlist_app_hlist_map : forall ls ls' (a : hlist F ls) (b : hlist F ls'), hlist_map (hlist_app a b) = hlist_app (hlist_map a) (hlist_map b).
Proof.
induction a.
simpl.

*****
ls' : list A
ff : forall (x : A) (_ : F x), G x
G : forall _ : A, Type@{SerTop.353}
F : forall _ : A, Type@{SerTop.352}
A : Type@{SerTop\.351}
*****
forall b : hlist@{SerTop.351 SerTop.352} F ls', eq (hlist_map b) (hlist_map b)
+++++
auto.
-----
Theorem hlist_app_hlist_map : forall ls ls' (a : hlist F ls) (b : hlist F ls'), hlist_map (hlist_app a b) = hlist_app (hlist_map a) (hlist_map b).
Proof.
induction a.

*****
IHa : forall b : hlist@{SerTop.351 SerTop.352} F ls',\neq (hlist_map (hlist_app@{SerTop.351 SerTop.352} a b))\n (hlist_app@{SerTop.351 SerTop.353} (hlist_map a) (hlist_map b))
a : hlist@{SerTop.351 SerTop.352} F ls
f : F l
ls : list A
l : A
ls' : list A
ff : forall (x : A) (_ : F x), G x
G : forall _ : A, Type@{SerTop.353}
F : forall _ : A, Type@{SerTop.352}
A : Type@{SerTop\.351}
*****
forall b : hlist@{SerTop.351 SerTop.352} F ls', eq (hlist_map (hlist_app@{SerTop.351 SerTop.352} (Hcons@{SerTop.351 SerTop.352} f a) b)) (hlist_app@{SerTop.351 SerTop.353} (hlist_map (Hcons@{SerTop.351 SerTop.352} f a)) (hlist_map b))
+++++
simpl.
-----
Theorem hlist_app_hlist_map : forall ls ls' (a : hlist F ls) (b : hlist F ls'), hlist_map (hlist_app a b) = hlist_app (hlist_map a) (hlist_map b).
Proof.
induction a.
simpl.

*****
IHa : forall b : hlist@{SerTop.351 SerTop.352} F ls',\neq (hlist_map (hlist_app@{SerTop.351 SerTop.352} a b))\n (hlist_app@{SerTop.351 SerTop.353} (hlist_map a) (hlist_map b))
a : hlist@{SerTop.351 SerTop.352} F ls
f : F l
ls : list A
l : A
ls' : list A
ff : forall (x : A) (_ : F x), G x
G : forall _ : A, Type@{SerTop.353}
F : forall _ : A, Type@{SerTop.352}
A : Type@{SerTop\.351}
*****
forall b : hlist@{SerTop.351 SerTop.352} F ls', eq (Hcons@{SerTop.351 SerTop.353} (ff f) (hlist_map (hlist_app@{SerTop.351 SerTop.352} a b))) (Hcons@{SerTop.351 SerTop.353} (ff f) (hlist_app@{SerTop.351 SerTop.353} (hlist_map a) (hlist_map b)))
+++++
intros.
-----
Theorem hlist_app_hlist_map : forall ls ls' (a : hlist F ls) (b : hlist F ls'), hlist_map (hlist_app a b) = hlist_app (hlist_map a) (hlist_map b).
Proof.
induction a.
simpl.
intros.

*****
b : hlist@{SerTop.351 SerTop.352} F ls'
IHa : forall b : hlist@{SerTop.351 SerTop.352} F ls',\neq (hlist_map (hlist_app@{SerTop.351 SerTop.352} a b))\n (hlist_app@{SerTop.351 SerTop.353} (hlist_map a) (hlist_map b))
a : hlist@{SerTop.351 SerTop.352} F ls
f : F l
ls : list A
l : A
ls' : list A
ff : forall (x : A) (_ : F x), G x
G : forall _ : A, Type@{SerTop.353}
F : forall _ : A, Type@{SerTop.352}
A : Type@{SerTop\.351}
*****
eq (Hcons@{SerTop.351 SerTop.353} (ff f) (hlist_map (hlist_app@{SerTop.351 SerTop.352} a b))) (Hcons@{SerTop.351 SerTop.353} (ff f) (hlist_app@{SerTop.351 SerTop.353} (hlist_map a) (hlist_map b)))
+++++
f_equal.
-----
Theorem hlist_app_hlist_map : forall ls ls' (a : hlist F ls) (b : hlist F ls'), hlist_map (hlist_app a b) = hlist_app (hlist_map a) (hlist_map b).
Proof.
induction a.
simpl.
intros.
f_equal.

*****
b : hlist@{SerTop.351 SerTop.352} F ls'
IHa : forall b : hlist@{SerTop.351 SerTop.352} F ls',\neq (hlist_map (hlist_app@{SerTop.351 SerTop.352} a b))\n (hlist_app@{SerTop.351 SerTop.353} (hlist_map a) (hlist_map b))
a : hlist@{SerTop.351 SerTop.352} F ls
f : F l
ls : list A
l : A
ls' : list A
ff : forall (x : A) (_ : F x), G x
G : forall _ : A, Type@{SerTop.353}
F : forall _ : A, Type@{SerTop.352}
A : Type@{SerTop\.351}
*****
eq (hlist_map (hlist_app@{SerTop.351 SerTop.352} a b)) (hlist_app@{SerTop.351 SerTop.353} (hlist_map a) (hlist_map b))
+++++
auto.
-----
Theorem hlist_app_hlist_map : forall ls ls' (a : hlist F ls) (b : hlist F ls'), hlist_map (hlist_app a b) = hlist_app (hlist_map a) (hlist_map b).
Proof.
induction a.

*****

*****

+++++
Qed.
-----
End hlist_map.
-----
Arguments hlist_map {_ _ _} _ {_} _.
-----
Section hlist_map_rules.
-----
Variable A : Type.
-----
Variables F G G' : A -> Type.
-----
Variable ff : forall x, F x -> G x.
-----
Variable gg : forall x, G x -> G' x.
-----
Theorem hlist_map_hlist_map : forall ls (hl : hlist F ls),\n      hlist_map gg (hlist_map ff hl) = hlist_map (fun _ x => gg (ff x)) hl.
-----
Theorem hlist_map_hlist_map : forall ls (hl : hlist F ls), hlist_map gg (hlist_map ff hl) = hlist_map (fun _ x => gg (ff x)) hl.

*****
gg : forall (x : A) (_ : G x), G' x
ff : forall (x : A) (_ : F x), G x
G' : forall _ : A, Type@{SerTop.387}
G : forall _ : A, Type@{SerTop.386}
F : forall _ : A, Type@{SerTop.385}
A : Type@{SerTop\.384}
*****
forall (ls : list A) (hl : hlist@{SerTop.384 SerTop.385} F ls), eq (hlist_map@{SerTop.384 SerTop.386 SerTop.387} gg (hlist_map@{SerTop.384 SerTop.385 SerTop.386} ff hl)) (hlist_map@{SerTop.384 SerTop.385 SerTop.387} (fun (x : A) (x0 : (fun H : A => F H) x) => gg (ff x0)) hl)
+++++
Proof.
-----
Theorem hlist_map_hlist_map : forall ls (hl : hlist F ls), hlist_map gg (hlist_map ff hl) = hlist_map (fun _ x => gg (ff x)) hl.
Proof.

*****
gg : forall (x : A) (_ : G x), G' x
ff : forall (x : A) (_ : F x), G x
G' : forall _ : A, Type@{SerTop.387}
G : forall _ : A, Type@{SerTop.386}
F : forall _ : A, Type@{SerTop.385}
A : Type@{SerTop\.384}
*****
forall (ls : list A) (hl : hlist@{SerTop.384 SerTop.385} F ls), eq (hlist_map@{SerTop.384 SerTop.386 SerTop.387} gg (hlist_map@{SerTop.384 SerTop.385 SerTop.386} ff hl)) (hlist_map@{SerTop.384 SerTop.385 SerTop.387} (fun (x : A) (x0 : (fun H : A => F H) x) => gg (ff x0)) hl)
+++++
induction hl.
-----
Theorem hlist_map_hlist_map : forall ls (hl : hlist F ls), hlist_map gg (hlist_map ff hl) = hlist_map (fun _ x => gg (ff x)) hl.
Proof.
induction hl.

*****
gg : forall (x : A) (_ : G x), G' x
ff : forall (x : A) (_ : F x), G x
G' : forall _ : A, Type@{SerTop.387}
G : forall _ : A, Type@{SerTop.386}
F : forall _ : A, Type@{SerTop.385}
A : Type@{SerTop\.384}
*****
eq (hlist_map@{SerTop.384 SerTop.386 SerTop.387} gg (hlist_map@{SerTop.384 SerTop.385 SerTop.386} ff Hnil@{SerTop.384 SerTop.385})) (hlist_map@{SerTop.384 SerTop.385 SerTop.387} (fun (x : A) (x0 : F x) => gg (ff x0)) Hnil@{SerTop.384 SerTop.385})
+++++
simpl.
-----
Theorem hlist_map_hlist_map : forall ls (hl : hlist F ls), hlist_map gg (hlist_map ff hl) = hlist_map (fun _ x => gg (ff x)) hl.
Proof.
induction hl.
simpl.

*****
gg : forall (x : A) (_ : G x), G' x
ff : forall (x : A) (_ : F x), G x
G' : forall _ : A, Type@{SerTop.387}
G : forall _ : A, Type@{SerTop.386}
F : forall _ : A, Type@{SerTop.385}
A : Type@{SerTop\.384}
*****
eq Hnil@{SerTop.384 SerTop.387} Hnil@{SerTop.384 SerTop.387}
+++++
f_equal.
-----
Theorem hlist_map_hlist_map : forall ls (hl : hlist F ls), hlist_map gg (hlist_map ff hl) = hlist_map (fun _ x => gg (ff x)) hl.
Proof.
induction hl.

*****
IHhl : eq\n (hlist_map@{SerTop.384 SerTop.386 SerTop.387} gg\n (hlist_map@{SerTop.384 SerTop.385 SerTop.386} ff hl))\n (hlist_map@{SerTop.384 SerTop.385 SerTop.387}\n (fun (x : A) (x0 : F x) => gg (ff x0)) hl)
hl : hlist@{SerTop.384 SerTop.385} F ls
f : F l
ls : list A
l : A
gg : forall (x : A) (_ : G x), G' x
ff : forall (x : A) (_ : F x), G x
G' : forall _ : A, Type@{SerTop.387}
G : forall _ : A, Type@{SerTop.386}
F : forall _ : A, Type@{SerTop.385}
A : Type@{SerTop\.384}
*****
eq (hlist_map@{SerTop.384 SerTop.386 SerTop.387} gg (hlist_map@{SerTop.384 SerTop.385 SerTop.386} ff (Hcons@{SerTop.384 SerTop.385} f hl))) (hlist_map@{SerTop.384 SerTop.385 SerTop.387} (fun (x : A) (x0 : F x) => gg (ff x0)) (Hcons@{SerTop.384 SerTop.385} f hl))
+++++
simpl.
-----
Theorem hlist_map_hlist_map : forall ls (hl : hlist F ls), hlist_map gg (hlist_map ff hl) = hlist_map (fun _ x => gg (ff x)) hl.
Proof.
induction hl.
simpl.

*****
IHhl : eq\n (hlist_map@{SerTop.384 SerTop.386 SerTop.387} gg\n (hlist_map@{SerTop.384 SerTop.385 SerTop.386} ff hl))\n (hlist_map@{SerTop.384 SerTop.385 SerTop.387}\n (fun (x : A) (x0 : F x) => gg (ff x0)) hl)
hl : hlist@{SerTop.384 SerTop.385} F ls
f : F l
ls : list A
l : A
gg : forall (x : A) (_ : G x), G' x
ff : forall (x : A) (_ : F x), G x
G' : forall _ : A, Type@{SerTop.387}
G : forall _ : A, Type@{SerTop.386}
F : forall _ : A, Type@{SerTop.385}
A : Type@{SerTop\.384}
*****
eq (Hcons@{SerTop.384 SerTop.387} (gg (ff f)) (hlist_map@{SerTop.384 SerTop.386 SerTop.387} gg (hlist_map@{SerTop.384 SerTop.385 SerTop.386} ff hl))) (Hcons@{SerTop.384 SerTop.387} (gg (ff f)) (hlist_map@{SerTop.384 SerTop.385 SerTop.387} (fun (x : A) (x0 : F x) => gg (ff x0)) hl))
+++++
f_equal.
-----
Theorem hlist_map_hlist_map : forall ls (hl : hlist F ls), hlist_map gg (hlist_map ff hl) = hlist_map (fun _ x => gg (ff x)) hl.
Proof.
induction hl.
simpl.
f_equal.

*****
IHhl : eq\n (hlist_map@{SerTop.384 SerTop.386 SerTop.387} gg\n (hlist_map@{SerTop.384 SerTop.385 SerTop.386} ff hl))\n (hlist_map@{SerTop.384 SerTop.385 SerTop.387}\n (fun (x : A) (x0 : F x) => gg (ff x0)) hl)
hl : hlist@{SerTop.384 SerTop.385} F ls
f : F l
ls : list A
l : A
gg : forall (x : A) (_ : G x), G' x
ff : forall (x : A) (_ : F x), G x
G' : forall _ : A, Type@{SerTop.387}
G : forall _ : A, Type@{SerTop.386}
F : forall _ : A, Type@{SerTop.385}
A : Type@{SerTop\.384}
*****
eq (hlist_map@{SerTop.384 SerTop.386 SerTop.387} gg (hlist_map@{SerTop.384 SerTop.385 SerTop.386} ff hl)) (hlist_map@{SerTop.384 SerTop.385 SerTop.387} (fun (x : A) (x0 : F x) => gg (ff x0)) hl)
+++++
assumption.
-----
Theorem hlist_map_hlist_map : forall ls (hl : hlist F ls), hlist_map gg (hlist_map ff hl) = hlist_map (fun _ x => gg (ff x)) hl.
Proof.
induction hl.

*****

*****

+++++
Defined.
-----
Theorem hlist_get_hlist_map : forall ls t (hl : hlist F ls) (m : member t ls),\n      hlist_get m (hlist_map ff hl) = ff (hlist_get m hl).
-----
Theorem hlist_get_hlist_map : forall ls t (hl : hlist F ls) (m : member t ls), hlist_get m (hlist_map ff hl) = ff (hlist_get m hl).

*****
gg : forall (x : A) (_ : G x), G' x
ff : forall (x : A) (_ : F x), G x
G' : forall _ : A, Type@{SerTop.387}
G : forall _ : A, Type@{SerTop.386}
F : forall _ : A, Type@{SerTop.385}
A : Type@{SerTop\.384}
*****
forall (ls : list A) (t : A) (hl : hlist@{SerTop.384 SerTop.385} F ls) (m : member t ls), eq (hlist_get@{SerTop.384 SerTop.386} m (hlist_map@{SerTop.384 SerTop.385 SerTop.386} ff hl)) (ff (hlist_get@{SerTop.384 SerTop.385} m hl))
+++++
Proof.
-----
Theorem hlist_get_hlist_map : forall ls t (hl : hlist F ls) (m : member t ls), hlist_get m (hlist_map ff hl) = ff (hlist_get m hl).
Proof.

*****
gg : forall (x : A) (_ : G x), G' x
ff : forall (x : A) (_ : F x), G x
G' : forall _ : A, Type@{SerTop.387}
G : forall _ : A, Type@{SerTop.386}
F : forall _ : A, Type@{SerTop.385}
A : Type@{SerTop\.384}
*****
forall (ls : list A) (t : A) (hl : hlist@{SerTop.384 SerTop.385} F ls) (m : member t ls), eq (hlist_get@{SerTop.384 SerTop.386} m (hlist_map@{SerTop.384 SerTop.385 SerTop.386} ff hl)) (ff (hlist_get@{SerTop.384 SerTop.385} m hl))
+++++
induction m.
-----
Theorem hlist_get_hlist_map : forall ls t (hl : hlist F ls) (m : member t ls), hlist_get m (hlist_map ff hl) = ff (hlist_get m hl).
Proof.
induction m.

*****
hl : hlist@{SerTop.384 SerTop.385} F (cons t ls)
ls : list A
t : A
gg : forall (x : A) (_ : G x), G' x
ff : forall (x : A) (_ : F x), G x
G' : forall _ : A, Type@{SerTop.387}
G : forall _ : A, Type@{SerTop.386}
F : forall _ : A, Type@{SerTop.385}
A : Type@{SerTop\.384}
*****
eq (hlist_get@{SerTop.384 SerTop.386} (MZ t ls) (hlist_map@{SerTop.384 SerTop.385 SerTop.386} ff hl)) (ff (hlist_get@{SerTop.384 SerTop.385} (MZ t ls) hl))
+++++
simpl.
-----
Theorem hlist_get_hlist_map : forall ls t (hl : hlist F ls) (m : member t ls), hlist_get m (hlist_map ff hl) = ff (hlist_get m hl).
Proof.
induction m.
simpl.

*****
hl : hlist@{SerTop.384 SerTop.385} F (cons t ls)
ls : list A
t : A
gg : forall (x : A) (_ : G x), G' x
ff : forall (x : A) (_ : F x), G x
G' : forall _ : A, Type@{SerTop.387}
G : forall _ : A, Type@{SerTop.386}
F : forall _ : A, Type@{SerTop.385}
A : Type@{SerTop\.384}
*****
eq (hlist_hd@{SerTop.384 SerTop.386} (hlist_map@{SerTop.384 SerTop.385 SerTop.386} ff hl)) (ff (hlist_hd@{SerTop.384 SerTop.385} hl))
+++++
rewrite (hlist_eta hl).
-----
Theorem hlist_get_hlist_map : forall ls t (hl : hlist F ls) (m : member t ls), hlist_get m (hlist_map ff hl) = ff (hlist_get m hl).
Proof.
induction m.
simpl.
rewrite (hlist_eta hl).

*****
hl : hlist@{SerTop.384 SerTop.385} F (cons t ls)
ls : list A
t : A
gg : forall (x : A) (_ : G x), G' x
ff : forall (x : A) (_ : F x), G x
G' : forall _ : A, Type@{SerTop.387}
G : forall _ : A, Type@{SerTop.386}
F : forall _ : A, Type@{SerTop.385}
A : Type@{SerTop\.384}
*****
eq (hlist_hd@{SerTop.384 SerTop.386} (hlist_map@{SerTop.384 SerTop.385 SerTop.386} ff (Hcons@{SerTop.384 SerTop.385} (hlist_hd@{SerTop.384 SerTop.385} hl) (hlist_tl@{SerTop.384 SerTop.385} hl)))) (ff (hlist_hd@{SerTop.384 SerTop.385} (Hcons@{SerTop.384 SerTop.385} (hlist_hd@{SerTop.384 SerTop.385} hl) (hlist_tl@{SerTop.384 SerTop.385} hl))))
+++++
reflexivity.
-----
Theorem hlist_get_hlist_map : forall ls t (hl : hlist F ls) (m : member t ls), hlist_get m (hlist_map ff hl) = ff (hlist_get m hl).
Proof.
induction m.

*****
IHm : forall hl : hlist@{SerTop.384 SerTop.385} F ls,\neq\n (hlist_get@{SerTop.384 SerTop.386} m\n (hlist_map@{SerTop.384 SerTop.385 SerTop.386} ff hl))\n (ff (hlist_get@{SerTop.384 SerTop.385} m hl))
m : member t ls
hl : hlist@{SerTop.384 SerTop.385} F (cons l ls)
ls : list A
t,l : A
gg : forall (x : A) (_ : G x), G' x
ff : forall (x : A) (_ : F x), G x
G' : forall _ : A, Type@{SerTop.387}
G : forall _ : A, Type@{SerTop.386}
F : forall _ : A, Type@{SerTop.385}
A : Type@{SerTop\.384}
*****
eq (hlist_get@{SerTop.384 SerTop.386} (MN l m) (hlist_map@{SerTop.384 SerTop.385 SerTop.386} ff hl)) (ff (hlist_get@{SerTop.384 SerTop.385} (MN l m) hl))
+++++
simpl.
-----
Theorem hlist_get_hlist_map : forall ls t (hl : hlist F ls) (m : member t ls), hlist_get m (hlist_map ff hl) = ff (hlist_get m hl).
Proof.
induction m.
simpl.

*****
IHm : forall hl : hlist@{SerTop.384 SerTop.385} F ls,\neq\n (hlist_get@{SerTop.384 SerTop.386} m\n (hlist_map@{SerTop.384 SerTop.385 SerTop.386} ff hl))\n (ff (hlist_get@{SerTop.384 SerTop.385} m hl))
m : member t ls
hl : hlist@{SerTop.384 SerTop.385} F (cons l ls)
ls : list A
t,l : A
gg : forall (x : A) (_ : G x), G' x
ff : forall (x : A) (_ : F x), G x
G' : forall _ : A, Type@{SerTop.387}
G : forall _ : A, Type@{SerTop.386}
F : forall _ : A, Type@{SerTop.385}
A : Type@{SerTop\.384}
*****
eq (hlist_get@{SerTop.384 SerTop.386} m (hlist_tl@{SerTop.384 SerTop.386} (hlist_map@{SerTop.384 SerTop.385 SerTop.386} ff hl))) (ff (hlist_get@{SerTop.384 SerTop.385} m (hlist_tl@{SerTop.384 SerTop.385} hl)))
+++++
rewrite (hlist_eta hl).
-----
Theorem hlist_get_hlist_map : forall ls t (hl : hlist F ls) (m : member t ls), hlist_get m (hlist_map ff hl) = ff (hlist_get m hl).
Proof.
induction m.
simpl.
rewrite (hlist_eta hl).

*****
IHm : forall hl : hlist@{SerTop.384 SerTop.385} F ls,\neq\n (hlist_get@{SerTop.384 SerTop.386} m\n (hlist_map@{SerTop.384 SerTop.385 SerTop.386} ff hl))\n (ff (hlist_get@{SerTop.384 SerTop.385} m hl))
m : member t ls
hl : hlist@{SerTop.384 SerTop.385} F (cons l ls)
ls : list A
t,l : A
gg : forall (x : A) (_ : G x), G' x
ff : forall (x : A) (_ : F x), G x
G' : forall _ : A, Type@{SerTop.387}
G : forall _ : A, Type@{SerTop.386}
F : forall _ : A, Type@{SerTop.385}
A : Type@{SerTop\.384}
*****
eq (hlist_get@{SerTop.384 SerTop.386} m (hlist_tl@{SerTop.384 SerTop.386} (hlist_map@{SerTop.384 SerTop.385 SerTop.386} ff (Hcons@{SerTop.384 SerTop.385} (hlist_hd@{SerTop.384 SerTop.385} hl) (hlist_tl@{SerTop.384 SerTop.385} hl))))) (ff (hlist_get@{SerTop.384 SerTop.385} m (hlist_tl@{SerTop.384 SerTop.385} (Hcons@{SerTop.384 SerTop.385} (hlist_hd@{SerTop.384 SerTop.385} hl) (hlist_tl@{SerTop.384 SerTop.385} hl)))))
+++++
simpl.
-----
Theorem hlist_get_hlist_map : forall ls t (hl : hlist F ls) (m : member t ls), hlist_get m (hlist_map ff hl) = ff (hlist_get m hl).
Proof.
induction m.
simpl.
rewrite (hlist_eta hl).
simpl.

*****
IHm : forall hl : hlist@{SerTop.384 SerTop.385} F ls,\neq\n (hlist_get@{SerTop.384 SerTop.386} m\n (hlist_map@{SerTop.384 SerTop.385 SerTop.386} ff hl))\n (ff (hlist_get@{SerTop.384 SerTop.385} m hl))
m : member t ls
hl : hlist@{SerTop.384 SerTop.385} F (cons l ls)
ls : list A
t,l : A
gg : forall (x : A) (_ : G x), G' x
ff : forall (x : A) (_ : F x), G x
G' : forall _ : A, Type@{SerTop.387}
G : forall _ : A, Type@{SerTop.386}
F : forall _ : A, Type@{SerTop.385}
A : Type@{SerTop\.384}
*****
eq (hlist_get@{SerTop.384 SerTop.386} m (hlist_map@{SerTop.384 SerTop.385 SerTop.386} ff (hlist_tl@{SerTop.384 SerTop.385} hl))) (ff (hlist_get@{SerTop.384 SerTop.385} m (hlist_tl@{SerTop.384 SerTop.385} hl)))
+++++
auto.
-----
Theorem hlist_get_hlist_map : forall ls t (hl : hlist F ls) (m : member t ls), hlist_get m (hlist_map ff hl) = ff (hlist_get m hl).
Proof.
induction m.

*****

*****

+++++
Defined.
-----
Lemma hlist_map_ext : forall (ff gg : forall x, F x -> G x),\n      (forall x t, ff x t = gg x t) ->\n      forall ls (hl : hlist F ls),\n        hlist_map ff hl = hlist_map gg hl.
-----
Lemma hlist_map_ext : forall (ff gg : forall x, F x -> G x), (forall x t, ff x t = gg x t) -> forall ls (hl : hlist F ls), hlist_map ff hl = hlist_map gg hl.

*****
gg : forall (x : A) (_ : G x), G' x
ff : forall (x : A) (_ : F x), G x
G' : forall _ : A, Type@{SerTop.387}
G : forall _ : A, Type@{SerTop.386}
F : forall _ : A, Type@{SerTop.385}
A : Type@{SerTop\.384}
*****
forall (ff gg : forall (x : A) (_ : F x), G x) (_ : forall (x : A) (t : F x), eq (ff x t) (gg x t)) (ls : list A) (hl : hlist@{SerTop.384 SerTop.385} F ls), eq (hlist_map@{SerTop.384 SerTop.385 SerTop.386} ff hl) (hlist_map@{SerTop.384 SerTop.385 SerTop.386} gg hl)
+++++
Proof.
-----
Lemma hlist_map_ext : forall (ff gg : forall x, F x -> G x), (forall x t, ff x t = gg x t) -> forall ls (hl : hlist F ls), hlist_map ff hl = hlist_map gg hl.
Proof.

*****
gg : forall (x : A) (_ : G x), G' x
ff : forall (x : A) (_ : F x), G x
G' : forall _ : A, Type@{SerTop.387}
G : forall _ : A, Type@{SerTop.386}
F : forall _ : A, Type@{SerTop.385}
A : Type@{SerTop\.384}
*****
forall (ff gg : forall (x : A) (_ : F x), G x) (_ : forall (x : A) (t : F x), eq (ff x t) (gg x t)) (ls : list A) (hl : hlist@{SerTop.384 SerTop.385} F ls), eq (hlist_map@{SerTop.384 SerTop.385 SerTop.386} ff hl) (hlist_map@{SerTop.384 SerTop.385 SerTop.386} gg hl)
+++++
induction hl.
-----
Lemma hlist_map_ext : forall (ff gg : forall x, F x -> G x), (forall x t, ff x t = gg x t) -> forall ls (hl : hlist F ls), hlist_map ff hl = hlist_map gg hl.
Proof.
induction hl.

*****
H : forall (x : A) (t : F x), eq (ff0 x t) (gg0 x t)
ff0,gg0 : forall (x : A) (_ : F x), G x
gg : forall (x : A) (_ : G x), G' x
ff : forall (x : A) (_ : F x), G x
G' : forall _ : A, Type@{SerTop.387}
G : forall _ : A, Type@{SerTop.386}
F : forall _ : A, Type@{SerTop.385}
A : Type@{SerTop\.384}
*****
eq (hlist_map@{SerTop.384 SerTop.385 SerTop.386} ff0 Hnil@{SerTop.384 SerTop.385}) (hlist_map@{SerTop.384 SerTop.385 SerTop.386} gg0 Hnil@{SerTop.384 SerTop.385})
+++++
simpl.
-----
Lemma hlist_map_ext : forall (ff gg : forall x, F x -> G x), (forall x t, ff x t = gg x t) -> forall ls (hl : hlist F ls), hlist_map ff hl = hlist_map gg hl.
Proof.
induction hl.
simpl.

*****
H : forall (x : A) (t : F x), eq (ff0 x t) (gg0 x t)
ff0,gg0 : forall (x : A) (_ : F x), G x
gg : forall (x : A) (_ : G x), G' x
ff : forall (x : A) (_ : F x), G x
G' : forall _ : A, Type@{SerTop.387}
G : forall _ : A, Type@{SerTop.386}
F : forall _ : A, Type@{SerTop.385}
A : Type@{SerTop\.384}
*****
eq Hnil@{SerTop.384 SerTop.386} Hnil@{SerTop.384 SerTop.386}
+++++
auto.
-----
Lemma hlist_map_ext : forall (ff gg : forall x, F x -> G x), (forall x t, ff x t = gg x t) -> forall ls (hl : hlist F ls), hlist_map ff hl = hlist_map gg hl.
Proof.
induction hl.

*****
IHhl : eq (hlist_map@{SerTop.384 SerTop.385 SerTop.386} ff0 hl)\n (hlist_map@{SerTop.384 SerTop.385 SerTop.386} gg0 hl)
hl : hlist@{SerTop.384 SerTop.385} F ls
f : F l
ls : list A
l : A
H : forall (x : A) (t : F x), eq (ff0 x t) (gg0 x t)
ff0,gg0 : forall (x : A) (_ : F x), G x
gg : forall (x : A) (_ : G x), G' x
ff : forall (x : A) (_ : F x), G x
G' : forall _ : A, Type@{SerTop.387}
G : forall _ : A, Type@{SerTop.386}
F : forall _ : A, Type@{SerTop.385}
A : Type@{SerTop\.384}
*****
eq (hlist_map@{SerTop.384 SerTop.385 SerTop.386} ff0 (Hcons@{SerTop.384 SerTop.385} f hl)) (hlist_map@{SerTop.384 SerTop.385 SerTop.386} gg0 (Hcons@{SerTop.384 SerTop.385} f hl))
+++++
simpl.
-----
Lemma hlist_map_ext : forall (ff gg : forall x, F x -> G x), (forall x t, ff x t = gg x t) -> forall ls (hl : hlist F ls), hlist_map ff hl = hlist_map gg hl.
Proof.
induction hl.
simpl.

*****
IHhl : eq (hlist_map@{SerTop.384 SerTop.385 SerTop.386} ff0 hl)\n (hlist_map@{SerTop.384 SerTop.385 SerTop.386} gg0 hl)
hl : hlist@{SerTop.384 SerTop.385} F ls
f : F l
ls : list A
l : A
H : forall (x : A) (t : F x), eq (ff0 x t) (gg0 x t)
ff0,gg0 : forall (x : A) (_ : F x), G x
gg : forall (x : A) (_ : G x), G' x
ff : forall (x : A) (_ : F x), G x
G' : forall _ : A, Type@{SerTop.387}
G : forall _ : A, Type@{SerTop.386}
F : forall _ : A, Type@{SerTop.385}
A : Type@{SerTop\.384}
*****
eq (Hcons@{SerTop.384 SerTop.386} (ff0 l f) (hlist_map@{SerTop.384 SerTop.385 SerTop.386} ff0 hl)) (Hcons@{SerTop.384 SerTop.386} (gg0 l f) (hlist_map@{SerTop.384 SerTop.385 SerTop.386} gg0 hl))
+++++
auto.
-----
Lemma hlist_map_ext : forall (ff gg : forall x, F x -> G x), (forall x t, ff x t = gg x t) -> forall ls (hl : hlist F ls), hlist_map ff hl = hlist_map gg hl.
Proof.
induction hl.
simpl.
auto.

*****
IHhl : eq (hlist_map@{SerTop.384 SerTop.385 SerTop.386} ff0 hl)\n (hlist_map@{SerTop.384 SerTop.385 SerTop.386} gg0 hl)
hl : hlist@{SerTop.384 SerTop.385} F ls
f : F l
ls : list A
l : A
H : forall (x : A) (t : F x), eq (ff0 x t) (gg0 x t)
ff0,gg0 : forall (x : A) (_ : F x), G x
gg : forall (x : A) (_ : G x), G' x
ff : forall (x : A) (_ : F x), G x
G' : forall _ : A, Type@{SerTop.387}
G : forall _ : A, Type@{SerTop.386}
F : forall _ : A, Type@{SerTop.385}
A : Type@{SerTop\.384}
*****
eq (Hcons@{SerTop.384 SerTop.386} (ff0 l f) (hlist_map@{SerTop.384 SerTop.385 SerTop.386} ff0 hl)) (Hcons@{SerTop.384 SerTop.386} (gg0 l f) (hlist_map@{SerTop.384 SerTop.385 SerTop.386} gg0 hl))
+++++
intros.
-----
Lemma hlist_map_ext : forall (ff gg : forall x, F x -> G x), (forall x t, ff x t = gg x t) -> forall ls (hl : hlist F ls), hlist_map ff hl = hlist_map gg hl.
Proof.
induction hl.
simpl.
auto.
intros.

*****
IHhl : eq (hlist_map@{SerTop.384 SerTop.385 SerTop.386} ff0 hl)\n (hlist_map@{SerTop.384 SerTop.385 SerTop.386} gg0 hl)
hl : hlist@{SerTop.384 SerTop.385} F ls
f : F l
ls : list A
l : A
H : forall (x : A) (t : F x), eq (ff0 x t) (gg0 x t)
ff0,gg0 : forall (x : A) (_ : F x), G x
gg : forall (x : A) (_ : G x), G' x
ff : forall (x : A) (_ : F x), G x
G' : forall _ : A, Type@{SerTop.387}
G : forall _ : A, Type@{SerTop.386}
F : forall _ : A, Type@{SerTop.385}
A : Type@{SerTop\.384}
*****
eq (Hcons@{SerTop.384 SerTop.386} (ff0 l f) (hlist_map@{SerTop.384 SerTop.385 SerTop.386} ff0 hl)) (Hcons@{SerTop.384 SerTop.386} (gg0 l f) (hlist_map@{SerTop.384 SerTop.385 SerTop.386} gg0 hl))
+++++
f_equal.
-----
Lemma hlist_map_ext : forall (ff gg : forall x, F x -> G x), (forall x t, ff x t = gg x t) -> forall ls (hl : hlist F ls), hlist_map ff hl = hlist_map gg hl.
Proof.
induction hl.
simpl.
auto.
intros.
f_equal.

*****
IHhl : eq (hlist_map@{SerTop.384 SerTop.385 SerTop.386} ff0 hl)\n (hlist_map@{SerTop.384 SerTop.385 SerTop.386} gg0 hl)
hl : hlist@{SerTop.384 SerTop.385} F ls
f : F l
ls : list A
l : A
H : forall (x : A) (t : F x), eq (ff0 x t) (gg0 x t)
ff0,gg0 : forall (x : A) (_ : F x), G x
gg : forall (x : A) (_ : G x), G' x
ff : forall (x : A) (_ : F x), G x
G' : forall _ : A, Type@{SerTop.387}
G : forall _ : A, Type@{SerTop.386}
F : forall _ : A, Type@{SerTop.385}
A : Type@{SerTop\.384}
*****
eq (ff0 l f) (gg0 l f)
+++++
auto.
-----
Lemma hlist_map_ext : forall (ff gg : forall x, F x -> G x), (forall x t, ff x t = gg x t) -> forall ls (hl : hlist F ls), hlist_map ff hl = hlist_map gg hl.
Proof.
induction hl.
simpl.
auto.
intros.
f_equal.

*****
IHhl : eq (hlist_map@{SerTop.384 SerTop.385 SerTop.386} ff0 hl)\n (hlist_map@{SerTop.384 SerTop.385 SerTop.386} gg0 hl)
hl : hlist@{SerTop.384 SerTop.385} F ls
f : F l
ls : list A
l : A
H : forall (x : A) (t : F x), eq (ff0 x t) (gg0 x t)
ff0,gg0 : forall (x : A) (_ : F x), G x
gg : forall (x : A) (_ : G x), G' x
ff : forall (x : A) (_ : F x), G x
G' : forall _ : A, Type@{SerTop.387}
G : forall _ : A, Type@{SerTop.386}
F : forall _ : A, Type@{SerTop.385}
A : Type@{SerTop\.384}
*****
eq (hlist_map@{SerTop.384 SerTop.385 SerTop.386} ff0 hl) (hlist_map@{SerTop.384 SerTop.385 SerTop.386} gg0 hl)
+++++
auto.
-----
Lemma hlist_map_ext : forall (ff gg : forall x, F x -> G x), (forall x t, ff x t = gg x t) -> forall ls (hl : hlist F ls), hlist_map ff hl = hlist_map gg hl.
Proof.
induction hl.

*****

*****

+++++
Defined.
-----
End hlist_map_rules.
-----
Lemma equiv_hlist_map\n: forall T U (F : T -> Type) (R : forall t, F t -> F t -> Prop)\n         (R' : forall t, U t -> U t -> Prop)\n         (f g : forall t, F t -> U t),\n    (forall t (x y : F t), R t x y -> R' t (f t x) (g t y)) ->\n    forall  ls (a b : hlist F ls),\n      equiv_hlist R a b ->\n      equiv_hlist R' (hlist_map f a) (hlist_map g b).
-----
Lemma equiv_hlist_map : forall T U (F : T -> Type) (R : forall t, F t -> F t -> Prop) (R' : forall t, U t -> U t -> Prop) (f g : forall t, F t -> U t), (forall t (x y : F t), R t x y -> R' t (f t x) (g t y)) -> forall ls (a b : hlist F ls), equiv_hlist R a b -> equiv_hlist R' (hlist_map f a) (hlist_map g b).

*****

*****
forall (T : Type@{SerTop.453}) (U : forall _ : T, Type@{SerTop.460}) (F : forall _ : T, Type@{SerTop.454}) (R : forall (t : T) (_ : F t) (_ : F t), Prop) (R' : forall (t : T) (_ : U t) (_ : U t), Prop) (f g : forall (t : T) (_ : F t), U t) (_ : forall (t : T) (x y : F t) (_ : R t x y), R' t (f t x) (g t y)) (ls : list T) (a b : hlist@{SerTop.453 SerTop.454} F ls) (_ : equiv_hlist@{SerTop.453 SerTop.454} R a b), equiv_hlist@{SerTop.453 SerTop.460} R' (hlist_map@{SerTop.453 SerTop.454 SerTop.460} f a) (hlist_map@{SerTop.453 SerTop.454 SerTop.460} g b)
+++++
Proof.
-----
Lemma equiv_hlist_map : forall T U (F : T -> Type) (R : forall t, F t -> F t -> Prop) (R' : forall t, U t -> U t -> Prop) (f g : forall t, F t -> U t), (forall t (x y : F t), R t x y -> R' t (f t x) (g t y)) -> forall ls (a b : hlist F ls), equiv_hlist R a b -> equiv_hlist R' (hlist_map f a) (hlist_map g b).
Proof.

*****

*****
forall (T : Type@{SerTop.453}) (U : forall _ : T, Type@{SerTop.460}) (F : forall _ : T, Type@{SerTop.454}) (R : forall (t : T) (_ : F t) (_ : F t), Prop) (R' : forall (t : T) (_ : U t) (_ : U t), Prop) (f g : forall (t : T) (_ : F t), U t) (_ : forall (t : T) (x y : F t) (_ : R t x y), R' t (f t x) (g t y)) (ls : list T) (a b : hlist@{SerTop.453 SerTop.454} F ls) (_ : equiv_hlist@{SerTop.453 SerTop.454} R a b), equiv_hlist@{SerTop.453 SerTop.460} R' (hlist_map@{SerTop.453 SerTop.454 SerTop.460} f a) (hlist_map@{SerTop.453 SerTop.454 SerTop.460} g b)
+++++
clear.
-----
Lemma equiv_hlist_map : forall T U (F : T -> Type) (R : forall t, F t -> F t -> Prop) (R' : forall t, U t -> U t -> Prop) (f g : forall t, F t -> U t), (forall t (x y : F t), R t x y -> R' t (f t x) (g t y)) -> forall ls (a b : hlist F ls), equiv_hlist R a b -> equiv_hlist R' (hlist_map f a) (hlist_map g b).
Proof.
clear.

*****

*****
forall (T : Type@{SerTop.453}) (U : forall _ : T, Type@{SerTop.460}) (F : forall _ : T, Type@{SerTop.454}) (R : forall (t : T) (_ : F t) (_ : F t), Prop) (R' : forall (t : T) (_ : U t) (_ : U t), Prop) (f g : forall (t : T) (_ : F t), U t) (_ : forall (t : T) (x y : F t) (_ : R t x y), R' t (f t x) (g t y)) (ls : list T) (a b : hlist@{SerTop.453 SerTop.454} F ls) (_ : equiv_hlist@{SerTop.453 SerTop.454} R a b), equiv_hlist@{SerTop.453 SerTop.460} R' (hlist_map@{SerTop.453 SerTop.454 SerTop.460} f a) (hlist_map@{SerTop.453 SerTop.454 SerTop.460} g b)
+++++
induction 2.
-----
Lemma equiv_hlist_map : forall T U (F : T -> Type) (R : forall t, F t -> F t -> Prop) (R' : forall t, U t -> U t -> Prop) (f g : forall t, F t -> U t), (forall t (x y : F t), R t x y -> R' t (f t x) (g t y)) -> forall ls (a b : hlist F ls), equiv_hlist R a b -> equiv_hlist R' (hlist_map f a) (hlist_map g b).
Proof.
clear.
induction 2.

*****
H : forall (t : T) (x y : F t) (_ : R t x y), R' t (f t x) (g t y)
f,g : forall (t : T) (_ : F t), U t
R' : forall (t : T) (_ : U t) (_ : U t), Prop
R : forall (t : T) (_ : F t) (_ : F t), Prop
F : forall _ : T, Type@{SerTop.454}
U : forall _ : T, Type@{SerTop.460}
T : Type@{SerTop\.453}
*****
equiv_hlist@{SerTop.453 SerTop.460} R' (hlist_map@{SerTop.453 SerTop.454 SerTop.460} f Hnil@{SerTop.453 SerTop.454}) (hlist_map@{SerTop.453 SerTop.454 SerTop.460} g Hnil@{SerTop.453 SerTop.454})
+++++
simpl.
-----
Lemma equiv_hlist_map : forall T U (F : T -> Type) (R : forall t, F t -> F t -> Prop) (R' : forall t, U t -> U t -> Prop) (f g : forall t, F t -> U t), (forall t (x y : F t), R t x y -> R' t (f t x) (g t y)) -> forall ls (a b : hlist F ls), equiv_hlist R a b -> equiv_hlist R' (hlist_map f a) (hlist_map g b).
Proof.
clear.
induction 2.
simpl.

*****
H : forall (t : T) (x y : F t) (_ : R t x y), R' t (f t x) (g t y)
f,g : forall (t : T) (_ : F t), U t
R' : forall (t : T) (_ : U t) (_ : U t), Prop
R : forall (t : T) (_ : F t) (_ : F t), Prop
F : forall _ : T, Type@{SerTop.454}
U : forall _ : T, Type@{SerTop.460}
T : Type@{SerTop\.453}
*****
equiv_hlist@{SerTop.453 SerTop.460} R' Hnil@{SerTop.453 SerTop.460} Hnil@{SerTop.453 SerTop.460}
+++++
intros.
-----
Lemma equiv_hlist_map : forall T U (F : T -> Type) (R : forall t, F t -> F t -> Prop) (R' : forall t, U t -> U t -> Prop) (f g : forall t, F t -> U t), (forall t (x y : F t), R t x y -> R' t (f t x) (g t y)) -> forall ls (a b : hlist F ls), equiv_hlist R a b -> equiv_hlist R' (hlist_map f a) (hlist_map g b).
Proof.
clear.
induction 2.
simpl.
intros.

*****
H : forall (t : T) (x y : F t) (_ : R t x y), R' t (f t x) (g t y)
f,g : forall (t : T) (_ : F t), U t
R' : forall (t : T) (_ : U t) (_ : U t), Prop
R : forall (t : T) (_ : F t) (_ : F t), Prop
F : forall _ : T, Type@{SerTop.454}
U : forall _ : T, Type@{SerTop.460}
T : Type@{SerTop\.453}
*****
equiv_hlist@{SerTop.453 SerTop.460} R' Hnil@{SerTop.453 SerTop.460} Hnil@{SerTop.453 SerTop.460}
+++++
constructor.
-----
Lemma equiv_hlist_map : forall T U (F : T -> Type) (R : forall t, F t -> F t -> Prop) (R' : forall t, U t -> U t -> Prop) (f g : forall t, F t -> U t), (forall t (x y : F t), R t x y -> R' t (f t x) (g t y)) -> forall ls (a b : hlist F ls), equiv_hlist R a b -> equiv_hlist R' (hlist_map f a) (hlist_map g b).
Proof.
clear.
induction 2.

*****
IHequiv_hlist : equiv_hlist@{SerTop.453 SerTop.460} R'\n (hlist_map@{SerTop.453 SerTop.454 SerTop.460} f h1)\n (hlist_map@{SerTop.453 SerTop.454 SerTop.460} g h2)
H1 : equiv_hlist@{SerTop.453 SerTop.454} R h1 h2
H0 : R l x y
h1,h2 : hlist@{SerTop.453 SerTop.454} F ls
x,y : F l
ls : list T
l : T
H : forall (t : T) (x y : F t) (_ : R t x y), R' t (f t x) (g t y)
f,g : forall (t : T) (_ : F t), U t
R' : forall (t : T) (_ : U t) (_ : U t), Prop
R : forall (t : T) (_ : F t) (_ : F t), Prop
F : forall _ : T, Type@{SerTop.454}
U : forall _ : T, Type@{SerTop.460}
T : Type@{SerTop\.453}
*****
equiv_hlist@{SerTop.453 SerTop.460} R' (hlist_map@{SerTop.453 SerTop.454 SerTop.460} f (Hcons@{SerTop.453 SerTop.454} x h1)) (hlist_map@{SerTop.453 SerTop.454 SerTop.460} g (Hcons@{SerTop.453 SerTop.454} y h2))
+++++
simpl.
-----
Lemma equiv_hlist_map : forall T U (F : T -> Type) (R : forall t, F t -> F t -> Prop) (R' : forall t, U t -> U t -> Prop) (f g : forall t, F t -> U t), (forall t (x y : F t), R t x y -> R' t (f t x) (g t y)) -> forall ls (a b : hlist F ls), equiv_hlist R a b -> equiv_hlist R' (hlist_map f a) (hlist_map g b).
Proof.
clear.
induction 2.
simpl.

*****
IHequiv_hlist : equiv_hlist@{SerTop.453 SerTop.460} R'\n (hlist_map@{SerTop.453 SerTop.454 SerTop.460} f h1)\n (hlist_map@{SerTop.453 SerTop.454 SerTop.460} g h2)
H1 : equiv_hlist@{SerTop.453 SerTop.454} R h1 h2
H0 : R l x y
h1,h2 : hlist@{SerTop.453 SerTop.454} F ls
x,y : F l
ls : list T
l : T
H : forall (t : T) (x y : F t) (_ : R t x y), R' t (f t x) (g t y)
f,g : forall (t : T) (_ : F t), U t
R' : forall (t : T) (_ : U t) (_ : U t), Prop
R : forall (t : T) (_ : F t) (_ : F t), Prop
F : forall _ : T, Type@{SerTop.454}
U : forall _ : T, Type@{SerTop.460}
T : Type@{SerTop\.453}
*****
equiv_hlist@{SerTop.453 SerTop.460} R' (Hcons@{SerTop.453 SerTop.460} (f l x) (hlist_map@{SerTop.453 SerTop.454 SerTop.460} f h1)) (Hcons@{SerTop.453 SerTop.460} (g l y) (hlist_map@{SerTop.453 SerTop.454 SerTop.460} g h2))
+++++
intros.
-----
Lemma equiv_hlist_map : forall T U (F : T -> Type) (R : forall t, F t -> F t -> Prop) (R' : forall t, U t -> U t -> Prop) (f g : forall t, F t -> U t), (forall t (x y : F t), R t x y -> R' t (f t x) (g t y)) -> forall ls (a b : hlist F ls), equiv_hlist R a b -> equiv_hlist R' (hlist_map f a) (hlist_map g b).
Proof.
clear.
induction 2.
simpl.
intros.

*****
IHequiv_hlist : equiv_hlist@{SerTop.453 SerTop.460} R'\n (hlist_map@{SerTop.453 SerTop.454 SerTop.460} f h1)\n (hlist_map@{SerTop.453 SerTop.454 SerTop.460} g h2)
H1 : equiv_hlist@{SerTop.453 SerTop.454} R h1 h2
H0 : R l x y
h1,h2 : hlist@{SerTop.453 SerTop.454} F ls
x,y : F l
ls : list T
l : T
H : forall (t : T) (x y : F t) (_ : R t x y), R' t (f t x) (g t y)
f,g : forall (t : T) (_ : F t), U t
R' : forall (t : T) (_ : U t) (_ : U t), Prop
R : forall (t : T) (_ : F t) (_ : F t), Prop
F : forall _ : T, Type@{SerTop.454}
U : forall _ : T, Type@{SerTop.460}
T : Type@{SerTop\.453}
*****
equiv_hlist@{SerTop.453 SerTop.460} R' (Hcons@{SerTop.453 SerTop.460} (f l x) (hlist_map@{SerTop.453 SerTop.454 SerTop.460} f h1)) (Hcons@{SerTop.453 SerTop.460} (g l y) (hlist_map@{SerTop.453 SerTop.454 SerTop.460} g h2))
+++++
constructor.
-----
Lemma equiv_hlist_map : forall T U (F : T -> Type) (R : forall t, F t -> F t -> Prop) (R' : forall t, U t -> U t -> Prop) (f g : forall t, F t -> U t), (forall t (x y : F t), R t x y -> R' t (f t x) (g t y)) -> forall ls (a b : hlist F ls), equiv_hlist R a b -> equiv_hlist R' (hlist_map f a) (hlist_map g b).
Proof.
clear.
induction 2.
simpl.
intros.
constructor.

*****
IHequiv_hlist : equiv_hlist@{SerTop.453 SerTop.460} R'\n (hlist_map@{SerTop.453 SerTop.454 SerTop.460} f h1)\n (hlist_map@{SerTop.453 SerTop.454 SerTop.460} g h2)
H1 : equiv_hlist@{SerTop.453 SerTop.454} R h1 h2
H0 : R l x y
h1,h2 : hlist@{SerTop.453 SerTop.454} F ls
x,y : F l
ls : list T
l : T
H : forall (t : T) (x y : F t) (_ : R t x y), R' t (f t x) (g t y)
f,g : forall (t : T) (_ : F t), U t
R' : forall (t : T) (_ : U t) (_ : U t), Prop
R : forall (t : T) (_ : F t) (_ : F t), Prop
F : forall _ : T, Type@{SerTop.454}
U : forall _ : T, Type@{SerTop.460}
T : Type@{SerTop\.453}
*****
R' l (f l x) (g l y)
+++++
eauto.
-----
Lemma equiv_hlist_map : forall T U (F : T -> Type) (R : forall t, F t -> F t -> Prop) (R' : forall t, U t -> U t -> Prop) (f g : forall t, F t -> U t), (forall t (x y : F t), R t x y -> R' t (f t x) (g t y)) -> forall ls (a b : hlist F ls), equiv_hlist R a b -> equiv_hlist R' (hlist_map f a) (hlist_map g b).
Proof.
clear.
induction 2.
simpl.
intros.
constructor.

*****
IHequiv_hlist : equiv_hlist@{SerTop.453 SerTop.460} R'\n (hlist_map@{SerTop.453 SerTop.454 SerTop.460} f h1)\n (hlist_map@{SerTop.453 SerTop.454 SerTop.460} g h2)
H1 : equiv_hlist@{SerTop.453 SerTop.454} R h1 h2
H0 : R l x y
h1,h2 : hlist@{SerTop.453 SerTop.454} F ls
x,y : F l
ls : list T
l : T
H : forall (t : T) (x y : F t) (_ : R t x y), R' t (f t x) (g t y)
f,g : forall (t : T) (_ : F t), U t
R' : forall (t : T) (_ : U t) (_ : U t), Prop
R : forall (t : T) (_ : F t) (_ : F t), Prop
F : forall _ : T, Type@{SerTop.454}
U : forall _ : T, Type@{SerTop.460}
T : Type@{SerTop\.453}
*****
equiv_hlist@{SerTop.453 SerTop.460} R' (hlist_map@{SerTop.453 SerTop.454 SerTop.460} f h1) (hlist_map@{SerTop.453 SerTop.454 SerTop.460} g h2)
+++++
eauto.
-----
Lemma equiv_hlist_map : forall T U (F : T -> Type) (R : forall t, F t -> F t -> Prop) (R' : forall t, U t -> U t -> Prop) (f g : forall t, F t -> U t), (forall t (x y : F t), R t x y -> R' t (f t x) (g t y)) -> forall ls (a b : hlist F ls), equiv_hlist R a b -> equiv_hlist R' (hlist_map f a) (hlist_map g b).
Proof.
clear.
induction 2.

*****

*****

+++++
Qed.
-----
Section hlist_gen.
-----
Variable A : Type.
-----
Variable F : A -> Type.
-----
Variable f : forall a, F a.
-----
Fixpoint hlist_gen ls : hlist F ls :=\n    match ls with\n    | nil => Hnil\n    | cons x ls' => Hcons (f x) (hlist_gen ls')\n    end.
-----
Lemma hlist_get_hlist_gen : forall ls t (m : member t ls),\n    hlist_get m (hlist_gen ls) = f t.
-----
Lemma hlist_get_hlist_gen : forall ls t (m : member t ls), hlist_get m (hlist_gen ls) = f t.

*****
f : forall a : A, F a
F : forall _ : A, Type@{SerTop.490}
A : Type@{SerTop\.489}
*****
forall (ls : list A) (t : A) (m : member t ls), eq (hlist_get@{SerTop.489 SerTop.490} m (hlist_gen ls)) (f t)
+++++
Proof.
-----
Lemma hlist_get_hlist_gen : forall ls t (m : member t ls), hlist_get m (hlist_gen ls) = f t.
Proof.

*****
f : forall a : A, F a
F : forall _ : A, Type@{SerTop.490}
A : Type@{SerTop\.489}
*****
forall (ls : list A) (t : A) (m : member t ls), eq (hlist_get@{SerTop.489 SerTop.490} m (hlist_gen ls)) (f t)
+++++
induction m.
-----
Lemma hlist_get_hlist_gen : forall ls t (m : member t ls), hlist_get m (hlist_gen ls) = f t.
Proof.
induction m.

*****
ls : list A
t : A
f : forall a : A, F a
F : forall _ : A, Type@{SerTop.490}
A : Type@{SerTop\.489}
*****
eq (hlist_get@{SerTop.489 SerTop.490} (MZ t ls) (hlist_gen (cons t ls))) (f t)
+++++
simpl.
-----
Lemma hlist_get_hlist_gen : forall ls t (m : member t ls), hlist_get m (hlist_gen ls) = f t.
Proof.
induction m.
simpl.

*****
ls : list A
t : A
f : forall a : A, F a
F : forall _ : A, Type@{SerTop.490}
A : Type@{SerTop\.489}
*****
eq (f t) (f t)
+++++
auto.
-----
Lemma hlist_get_hlist_gen : forall ls t (m : member t ls), hlist_get m (hlist_gen ls) = f t.
Proof.
induction m.

*****
IHm : eq (hlist_get@{SerTop.489 SerTop.490} m (hlist_gen ls)) (f t)
m : member t ls
ls : list A
t,l : A
f : forall a : A, F a
F : forall _ : A, Type@{SerTop.490}
A : Type@{SerTop\.489}
*****
eq (hlist_get@{SerTop.489 SerTop.490} (MN l m) (hlist_gen (cons l ls))) (f t)
+++++
simpl.
-----
Lemma hlist_get_hlist_gen : forall ls t (m : member t ls), hlist_get m (hlist_gen ls) = f t.
Proof.
induction m.
simpl.

*****
IHm : eq (hlist_get@{SerTop.489 SerTop.490} m (hlist_gen ls)) (f t)
m : member t ls
ls : list A
t,l : A
f : forall a : A, F a
F : forall _ : A, Type@{SerTop.490}
A : Type@{SerTop\.489}
*****
eq (hlist_get@{SerTop.489 SerTop.490} m (hlist_gen ls)) (f t)
+++++
auto.
-----
Lemma hlist_get_hlist_gen : forall ls t (m : member t ls), hlist_get m (hlist_gen ls) = f t.
Proof.
induction m.

*****

*****

+++++
Qed.
-----
Fixpoint hlist_gen_member ls : (forall a, member a ls -> F a) -> hlist F ls :=\n    match ls as ls return ((forall a : A, member a ls -> F a) -> hlist F ls) with\n    | nil => fun _ => Hnil\n    | a :: ls' => fun fm =>\n        Hcons (fm a (MZ a ls'))\n          (hlist_gen_member (fun a' (M : member a' ls') => fm a' (MN a M)))\n    end.
-----
Lemma hlist_gen_member_hlist_gen : forall ls,\n    hlist_gen_member (fun a _ => f a) = hlist_gen ls.
-----
Lemma hlist_gen_member_hlist_gen : forall ls, hlist_gen_member (fun a _ => f a) = hlist_gen ls.

*****
f : forall a : A, F a
F : forall _ : A, Type@{SerTop.490}
A : Type@{SerTop\.489}
*****
forall ls : list A, eq (hlist_gen_member (fun (a : A) (_ : member a ls) => f a)) (hlist_gen ls)
+++++
Proof.
-----
Lemma hlist_gen_member_hlist_gen : forall ls, hlist_gen_member (fun a _ => f a) = hlist_gen ls.
Proof.

*****
f : forall a : A, F a
F : forall _ : A, Type@{SerTop.490}
A : Type@{SerTop\.489}
*****
forall ls : list A, eq (hlist_gen_member (fun (a : A) (_ : member a ls) => f a)) (hlist_gen ls)
+++++
induction ls.
-----
Lemma hlist_gen_member_hlist_gen : forall ls, hlist_gen_member (fun a _ => f a) = hlist_gen ls.
Proof.
induction ls.

*****
f : forall a : A, F a
F : forall _ : A, Type@{SerTop.490}
A : Type@{SerTop\.489}
*****
eq (hlist_gen_member (fun (a : A) (_ : member a nil) => f a)) (hlist_gen nil)
+++++
simpl.
-----
Lemma hlist_gen_member_hlist_gen : forall ls, hlist_gen_member (fun a _ => f a) = hlist_gen ls.
Proof.
induction ls.
simpl.

*****
f : forall a : A, F a
F : forall _ : A, Type@{SerTop.490}
A : Type@{SerTop\.489}
*****
eq Hnil@{SerTop.489 SerTop.490} Hnil@{SerTop.489 SerTop.490}
+++++
f_equal.
-----
Lemma hlist_gen_member_hlist_gen : forall ls, hlist_gen_member (fun a _ => f a) = hlist_gen ls.
Proof.
induction ls.

*****
IHls : eq (hlist_gen_member (fun (a : A) (_ : member a ls) => f a))\n (hlist_gen ls)
ls : list A
a : A
f : forall a : A, F a
F : forall _ : A, Type@{SerTop.490}
A : Type@{SerTop\.489}
*****
eq (hlist_gen_member (fun (a0 : A) (_ : member a0 (cons a ls)) => f a0)) (hlist_gen (cons a ls))
+++++
simpl.
-----
Lemma hlist_gen_member_hlist_gen : forall ls, hlist_gen_member (fun a _ => f a) = hlist_gen ls.
Proof.
induction ls.
simpl.

*****
IHls : eq (hlist_gen_member (fun (a : A) (_ : member a ls) => f a))\n (hlist_gen ls)
ls : list A
a : A
f : forall a : A, F a
F : forall _ : A, Type@{SerTop.490}
A : Type@{SerTop\.489}
*****
eq (Hcons@{SerTop.489 SerTop.490} (f a) (hlist_gen_member (fun (a' : A) (_ : member a' ls) => f a'))) (Hcons@{SerTop.489 SerTop.490} (f a) (hlist_gen ls))
+++++
f_equal.
-----
Lemma hlist_gen_member_hlist_gen : forall ls, hlist_gen_member (fun a _ => f a) = hlist_gen ls.
Proof.
induction ls.
simpl.
f_equal.

*****
IHls : eq (hlist_gen_member (fun (a : A) (_ : member a ls) => f a))\n (hlist_gen ls)
ls : list A
a : A
f : forall a : A, F a
F : forall _ : A, Type@{SerTop.490}
A : Type@{SerTop\.489}
*****
eq (hlist_gen_member (fun (a' : A) (_ : member a' ls) => f a')) (hlist_gen ls)
+++++
auto.
-----
Lemma hlist_gen_member_hlist_gen : forall ls, hlist_gen_member (fun a _ => f a) = hlist_gen ls.
Proof.
induction ls.

*****

*****

+++++
Qed.
-----
Lemma hlist_gen_member_ext : forall ls (f g : forall a, member a ls -> F a),\n    (forall x M, f x M = g x M) ->\n    hlist_gen_member f = hlist_gen_member g.
-----
Lemma hlist_gen_member_ext : forall ls (f g : forall a, member a ls -> F a), (forall x M, f x M = g x M) -> hlist_gen_member f = hlist_gen_member g.

*****
f : forall a : A, F a
F : forall _ : A, Type@{SerTop.490}
A : Type@{SerTop\.489}
*****
forall (ls : list A) (f g : forall (a : A) (_ : member a ls), F a) (_ : forall (x : A) (M : member x ls), eq (f x M) (g x M)), eq (hlist_gen_member f) (hlist_gen_member g)
+++++
Proof.
-----
Lemma hlist_gen_member_ext : forall ls (f g : forall a, member a ls -> F a), (forall x M, f x M = g x M) -> hlist_gen_member f = hlist_gen_member g.
Proof.

*****
f : forall a : A, F a
F : forall _ : A, Type@{SerTop.490}
A : Type@{SerTop\.489}
*****
forall (ls : list A) (f g : forall (a : A) (_ : member a ls), F a) (_ : forall (x : A) (M : member x ls), eq (f x M) (g x M)), eq (hlist_gen_member f) (hlist_gen_member g)
+++++
intros.
-----
Lemma hlist_gen_member_ext : forall ls (f g : forall a, member a ls -> F a), (forall x M, f x M = g x M) -> hlist_gen_member f = hlist_gen_member g.
Proof.
intros.

*****
H : forall (x : A) (M : member x ls), eq (f0 x M) (g x M)
f0,g : forall (a : A) (_ : member a ls), F a
ls : list A
f : forall a : A, F a
F : forall _ : A, Type@{SerTop.490}
A : Type@{SerTop\.489}
*****
eq (hlist_gen_member f0) (hlist_gen_member g)
+++++
induction ls.
-----
Lemma hlist_gen_member_ext : forall ls (f g : forall a, member a ls -> F a), (forall x M, f x M = g x M) -> hlist_gen_member f = hlist_gen_member g.
Proof.
intros.
induction ls.

*****
H : forall (x : A) (M : member x nil), eq (f0 x M) (g x M)
f0,g : forall (a : A) (_ : member a nil), F a
f : forall a : A, F a
F : forall _ : A, Type@{SerTop.490}
A : Type@{SerTop\.489}
*****
eq (hlist_gen_member f0) (hlist_gen_member g)
+++++
simpl.
-----
Lemma hlist_gen_member_ext : forall ls (f g : forall a, member a ls -> F a), (forall x M, f x M = g x M) -> hlist_gen_member f = hlist_gen_member g.
Proof.
intros.
induction ls.
simpl.

*****
H : forall (x : A) (M : member x nil), eq (f0 x M) (g x M)
f0,g : forall (a : A) (_ : member a nil), F a
f : forall a : A, F a
F : forall _ : A, Type@{SerTop.490}
A : Type@{SerTop\.489}
*****
eq Hnil@{SerTop.489 SerTop.490} Hnil@{SerTop.489 SerTop.490}
+++++
f_equal.
-----
Lemma hlist_gen_member_ext : forall ls (f g : forall a, member a ls -> F a), (forall x M, f x M = g x M) -> hlist_gen_member f = hlist_gen_member g.
Proof.
intros.
induction ls.

*****
IHls : forall (f0 g : forall (a : A) (_ : member a ls), F a)\n (_ : forall (x : A) (M : member x ls), eq (f0 x M) (g x M)),\neq (hlist_gen_member f0) (hlist_gen_member g)
H : forall (x : A) (M : member x (cons a ls)), eq (f0 x M) (g x M)
f0,g : forall (a0 : A) (_ : member a0 (cons a ls)), F a0
ls : list A
a : A
f : forall a : A, F a
F : forall _ : A, Type@{SerTop.490}
A : Type@{SerTop\.489}
*****
eq (hlist_gen_member f0) (hlist_gen_member g)
+++++
simpl.
-----
Lemma hlist_gen_member_ext : forall ls (f g : forall a, member a ls -> F a), (forall x M, f x M = g x M) -> hlist_gen_member f = hlist_gen_member g.
Proof.
intros.
induction ls.
simpl.

*****
IHls : forall (f0 g : forall (a : A) (_ : member a ls), F a)\n (_ : forall (x : A) (M : member x ls), eq (f0 x M) (g x M)),\neq (hlist_gen_member f0) (hlist_gen_member g)
H : forall (x : A) (M : member x (cons a ls)), eq (f0 x M) (g x M)
f0,g : forall (a0 : A) (_ : member a0 (cons a ls)), F a0
ls : list A
a : A
f : forall a : A, F a
F : forall _ : A, Type@{SerTop.490}
A : Type@{SerTop\.489}
*****
eq (Hcons@{SerTop.489 SerTop.490} (f0 a (MZ a ls)) (hlist_gen_member (fun (a' : A) (M : member a' ls) => f0 a' (MN a M)))) (Hcons@{SerTop.489 SerTop.490} (g a (MZ a ls)) (hlist_gen_member (fun (a' : A) (M : member a' ls) => g a' (MN a M))))
+++++
f_equal.
-----
Lemma hlist_gen_member_ext : forall ls (f g : forall a, member a ls -> F a), (forall x M, f x M = g x M) -> hlist_gen_member f = hlist_gen_member g.
Proof.
intros.
induction ls.
simpl.
f_equal.

*****
IHls : forall (f0 g : forall (a : A) (_ : member a ls), F a)\n (_ : forall (x : A) (M : member x ls), eq (f0 x M) (g x M)),\neq (hlist_gen_member f0) (hlist_gen_member g)
H : forall (x : A) (M : member x (cons a ls)), eq (f0 x M) (g x M)
f0,g : forall (a0 : A) (_ : member a0 (cons a ls)), F a0
ls : list A
a : A
f : forall a : A, F a
F : forall _ : A, Type@{SerTop.490}
A : Type@{SerTop\.489}
*****
eq (f0 a (MZ a ls)) (g a (MZ a ls))
+++++
auto.
-----
Lemma hlist_gen_member_ext : forall ls (f g : forall a, member a ls -> F a), (forall x M, f x M = g x M) -> hlist_gen_member f = hlist_gen_member g.
Proof.
intros.
induction ls.
simpl.
f_equal.

*****
IHls : forall (f0 g : forall (a : A) (_ : member a ls), F a)\n (_ : forall (x : A) (M : member x ls), eq (f0 x M) (g x M)),\neq (hlist_gen_member f0) (hlist_gen_member g)
H : forall (x : A) (M : member x (cons a ls)), eq (f0 x M) (g x M)
f0,g : forall (a0 : A) (_ : member a0 (cons a ls)), F a0
ls : list A
a : A
f : forall a : A, F a
F : forall _ : A, Type@{SerTop.490}
A : Type@{SerTop\.489}
*****
eq (hlist_gen_member (fun (a' : A) (M : member a' ls) => f0 a' (MN a M))) (hlist_gen_member (fun (a' : A) (M : member a' ls) => g a' (MN a M)))
+++++
auto.
-----
Lemma hlist_gen_member_ext : forall ls (f g : forall a, member a ls -> F a), (forall x M, f x M = g x M) -> hlist_gen_member f = hlist_gen_member g.
Proof.
intros.
induction ls.

*****

*****

+++++
Qed.
-----
End hlist_gen.
-----
Arguments hlist_gen {A F} f ls.
-----
Lemma hlist_gen_member_hlist_map : forall A (F G : A -> Type) (ff : forall t, F t -> G t) ls f,\n  hlist_map ff (hlist_gen_member F (ls := ls) f) = hlist_gen_member G (fun a M => ff _ (f _ M)).
-----
Lemma hlist_gen_member_hlist_map : forall A (F G : A -> Type) (ff : forall t, F t -> G t) ls f, hlist_map ff (hlist_gen_member F (ls := ls) f) = hlist_gen_member G (fun a M => ff _ (f _ M)).

*****

*****
forall (A : Type@{SerTop.535}) (F : forall _ : A, Type@{SerTop.536}) (G : forall _ : A, Type@{SerTop.537}) (ff : forall (t : A) (_ : F t), G t) (ls : list A) (f : forall (a : A) (_ : member a ls), F a), eq (hlist_map@{SerTop.535 SerTop.536 SerTop.537} ff (hlist_gen_member@{SerTop.535 SerTop.536} F f)) (hlist_gen_member@{SerTop.535 SerTop.537} G (fun (a : A) (M : member a ls) => ff a (f a M)))
+++++
Proof.
-----
Lemma hlist_gen_member_hlist_map : forall A (F G : A -> Type) (ff : forall t, F t -> G t) ls f, hlist_map ff (hlist_gen_member F (ls := ls) f) = hlist_gen_member G (fun a M => ff _ (f _ M)).
Proof.

*****

*****
forall (A : Type@{SerTop.535}) (F : forall _ : A, Type@{SerTop.536}) (G : forall _ : A, Type@{SerTop.537}) (ff : forall (t : A) (_ : F t), G t) (ls : list A) (f : forall (a : A) (_ : member a ls), F a), eq (hlist_map@{SerTop.535 SerTop.536 SerTop.537} ff (hlist_gen_member@{SerTop.535 SerTop.536} F f)) (hlist_gen_member@{SerTop.535 SerTop.537} G (fun (a : A) (M : member a ls) => ff a (f a M)))
+++++
intros.
-----
Lemma hlist_gen_member_hlist_map : forall A (F G : A -> Type) (ff : forall t, F t -> G t) ls f, hlist_map ff (hlist_gen_member F (ls := ls) f) = hlist_gen_member G (fun a M => ff _ (f _ M)).
Proof.
intros.

*****
f : forall (a : A) (_ : member a ls), F a
ls : list A
ff : forall (t : A) (_ : F t), G t
G : forall _ : A, Type@{SerTop.537}
F : forall _ : A, Type@{SerTop.536}
A : Type@{SerTop\.535}
*****
eq (hlist_map@{SerTop.535 SerTop.536 SerTop.537} ff (hlist_gen_member@{SerTop.535 SerTop.536} F f)) (hlist_gen_member@{SerTop.535 SerTop.537} G (fun (a : A) (M : member a ls) => ff a (f a M)))
+++++
induction ls.
-----
Lemma hlist_gen_member_hlist_map : forall A (F G : A -> Type) (ff : forall t, F t -> G t) ls f, hlist_map ff (hlist_gen_member F (ls := ls) f) = hlist_gen_member G (fun a M => ff _ (f _ M)).
Proof.
intros.
induction ls.

*****
f : forall (a : A) (_ : member a nil), F a
ff : forall (t : A) (_ : F t), G t
G : forall _ : A, Type@{SerTop.537}
F : forall _ : A, Type@{SerTop.536}
A : Type@{SerTop\.535}
*****
eq (hlist_map@{SerTop.535 SerTop.536 SerTop.537} ff (hlist_gen_member@{SerTop.535 SerTop.536} F f)) (hlist_gen_member@{SerTop.535 SerTop.537} G (fun (a : A) (M : member a nil) => ff a (f a M)))
+++++
simpl.
-----
Lemma hlist_gen_member_hlist_map : forall A (F G : A -> Type) (ff : forall t, F t -> G t) ls f, hlist_map ff (hlist_gen_member F (ls := ls) f) = hlist_gen_member G (fun a M => ff _ (f _ M)).
Proof.
intros.
induction ls.
simpl.

*****
f : forall (a : A) (_ : member a nil), F a
ff : forall (t : A) (_ : F t), G t
G : forall _ : A, Type@{SerTop.537}
F : forall _ : A, Type@{SerTop.536}
A : Type@{SerTop\.535}
*****
eq Hnil@{SerTop.535 SerTop.537} Hnil@{SerTop.535 SerTop.537}
+++++
f_equal.
-----
Lemma hlist_gen_member_hlist_map : forall A (F G : A -> Type) (ff : forall t, F t -> G t) ls f, hlist_map ff (hlist_gen_member F (ls := ls) f) = hlist_gen_member G (fun a M => ff _ (f _ M)).
Proof.
intros.
induction ls.

*****
IHls : forall f : forall (a : A) (_ : member a ls), F a,\neq\n (hlist_map@{SerTop.535 SerTop.536 SerTop.537} ff\n (hlist_gen_member@{SerTop.535 SerTop.536} F f))\n (hlist_gen_member@{SerTop.535 SerTop.537} G\n (fun (a : A) (M : member a ls) => ff a (f a M)))
f : forall (a0 : A) (_ : member a0 (cons a ls)), F a0
ls : list A
a : A
ff : forall (t : A) (_ : F t), G t
G : forall _ : A, Type@{SerTop.537}
F : forall _ : A, Type@{SerTop.536}
A : Type@{SerTop\.535}
*****
eq (hlist_map@{SerTop.535 SerTop.536 SerTop.537} ff (hlist_gen_member@{SerTop.535 SerTop.536} F f)) (hlist_gen_member@{SerTop.535 SerTop.537} G (fun (a0 : A) (M : member a0 (cons a ls)) => ff a0 (f a0 M)))
+++++
simpl.
-----
Lemma hlist_gen_member_hlist_map : forall A (F G : A -> Type) (ff : forall t, F t -> G t) ls f, hlist_map ff (hlist_gen_member F (ls := ls) f) = hlist_gen_member G (fun a M => ff _ (f _ M)).
Proof.
intros.
induction ls.
simpl.

*****
IHls : forall f : forall (a : A) (_ : member a ls), F a,\neq\n (hlist_map@{SerTop.535 SerTop.536 SerTop.537} ff\n (hlist_gen_member@{SerTop.535 SerTop.536} F f))\n (hlist_gen_member@{SerTop.535 SerTop.537} G\n (fun (a : A) (M : member a ls) => ff a (f a M)))
f : forall (a0 : A) (_ : member a0 (cons a ls)), F a0
ls : list A
a : A
ff : forall (t : A) (_ : F t), G t
G : forall _ : A, Type@{SerTop.537}
F : forall _ : A, Type@{SerTop.536}
A : Type@{SerTop\.535}
*****
eq (Hcons@{SerTop.535 SerTop.537} (ff a (f a (MZ a ls))) (hlist_map@{SerTop.535 SerTop.536 SerTop.537} ff (hlist_gen_member@{SerTop.535 SerTop.536} F (fun (a' : A) (M : member a' ls) => f a' (MN a M))))) (Hcons@{SerTop.535 SerTop.537} (ff a (f a (MZ a ls))) (hlist_gen_member@{SerTop.535 SerTop.537} G (fun (a' : A) (M : member a' ls) => ff a' (f a' (MN a M)))))
+++++
f_equal.
-----
Lemma hlist_gen_member_hlist_map : forall A (F G : A -> Type) (ff : forall t, F t -> G t) ls f, hlist_map ff (hlist_gen_member F (ls := ls) f) = hlist_gen_member G (fun a M => ff _ (f _ M)).
Proof.
intros.
induction ls.
simpl.
f_equal.

*****
IHls : forall f : forall (a : A) (_ : member a ls), F a,\neq\n (hlist_map@{SerTop.535 SerTop.536 SerTop.537} ff\n (hlist_gen_member@{SerTop.535 SerTop.536} F f))\n (hlist_gen_member@{SerTop.535 SerTop.537} G\n (fun (a : A) (M : member a ls) => ff a (f a M)))
f : forall (a0 : A) (_ : member a0 (cons a ls)), F a0
ls : list A
a : A
ff : forall (t : A) (_ : F t), G t
G : forall _ : A, Type@{SerTop.537}
F : forall _ : A, Type@{SerTop.536}
A : Type@{SerTop\.535}
*****
eq (hlist_map@{SerTop.535 SerTop.536 SerTop.537} ff (hlist_gen_member@{SerTop.535 SerTop.536} F (fun (a' : A) (M : member a' ls) => f a' (MN a M)))) (hlist_gen_member@{SerTop.535 SerTop.537} G (fun (a' : A) (M : member a' ls) => ff a' (f a' (MN a M))))
+++++
auto.
-----
Lemma hlist_gen_member_hlist_map : forall A (F G : A -> Type) (ff : forall t, F t -> G t) ls f, hlist_map ff (hlist_gen_member F (ls := ls) f) = hlist_gen_member G (fun a M => ff _ (f _ M)).
Proof.
intros.
induction ls.

*****

*****

+++++
Qed.
-----
Lemma hlist_gen_hlist_map : forall A (F G : A -> Type) (ff : forall t, F t -> G t) f ls,\n  hlist_map ff (hlist_gen f ls) = hlist_gen (fun a => ff _ (f a)) ls.
-----
Lemma hlist_gen_hlist_map : forall A (F G : A -> Type) (ff : forall t, F t -> G t) f ls, hlist_map ff (hlist_gen f ls) = hlist_gen (fun a => ff _ (f a)) ls.

*****

*****
forall (A : Type@{SerTop.549}) (F : forall _ : A, Type@{SerTop.550}) (G : forall _ : A, Type@{SerTop.551}) (ff : forall (t : A) (_ : F t), G t) (f : forall a : A, F a) (ls : list A), eq (hlist_map@{SerTop.549 SerTop.550 SerTop.551} ff (hlist_gen@{SerTop.549 SerTop.550} f ls)) (hlist_gen@{SerTop.549 SerTop.551} (fun a : A => ff a (f a)) ls)
+++++
Proof.
-----
Lemma hlist_gen_hlist_map : forall A (F G : A -> Type) (ff : forall t, F t -> G t) f ls, hlist_map ff (hlist_gen f ls) = hlist_gen (fun a => ff _ (f a)) ls.
Proof.

*****

*****
forall (A : Type@{SerTop.549}) (F : forall _ : A, Type@{SerTop.550}) (G : forall _ : A, Type@{SerTop.551}) (ff : forall (t : A) (_ : F t), G t) (f : forall a : A, F a) (ls : list A), eq (hlist_map@{SerTop.549 SerTop.550 SerTop.551} ff (hlist_gen@{SerTop.549 SerTop.550} f ls)) (hlist_gen@{SerTop.549 SerTop.551} (fun a : A => ff a (f a)) ls)
+++++
intros.
-----
Lemma hlist_gen_hlist_map : forall A (F G : A -> Type) (ff : forall t, F t -> G t) f ls, hlist_map ff (hlist_gen f ls) = hlist_gen (fun a => ff _ (f a)) ls.
Proof.
intros.

*****
ls : list A
f : forall a : A, F a
ff : forall (t : A) (_ : F t), G t
G : forall _ : A, Type@{SerTop.551}
F : forall _ : A, Type@{SerTop.550}
A : Type@{SerTop\.549}
*****
eq (hlist_map@{SerTop.549 SerTop.550 SerTop.551} ff (hlist_gen@{SerTop.549 SerTop.550} f ls)) (hlist_gen@{SerTop.549 SerTop.551} (fun a : A => ff a (f a)) ls)
+++++
do 2 rewrite <- hlist_gen_member_hlist_gen.
-----
Lemma hlist_gen_hlist_map : forall A (F G : A -> Type) (ff : forall t, F t -> G t) f ls, hlist_map ff (hlist_gen f ls) = hlist_gen (fun a => ff _ (f a)) ls.
Proof.
intros.
do 2 rewrite <- hlist_gen_member_hlist_gen.

*****
ls : list A
f : forall a : A, F a
ff : forall (t : A) (_ : F t), G t
G : forall _ : A, Type@{SerTop.551}
F : forall _ : A, Type@{SerTop.550}
A : Type@{SerTop\.549}
*****
eq (hlist_map@{SerTop.549 SerTop.550 SerTop.551} ff (hlist_gen_member@{SerTop.549 SerTop.550} F (fun (a : A) (_ : member a ls) => f a))) (hlist_gen_member@{SerTop.549 SerTop.551} G (fun (a : A) (_ : member a ls) => ff a (f a)))
+++++
apply hlist_gen_member_hlist_map.
-----
Lemma hlist_gen_hlist_map : forall A (F G : A -> Type) (ff : forall t, F t -> G t) f ls, hlist_map ff (hlist_gen f ls) = hlist_gen (fun a => ff _ (f a)) ls.
Proof.
intros.
do 2 rewrite <- hlist_gen_member_hlist_gen.
apply hlist_gen_member_hlist_map.

*****

*****

+++++
Qed.
-----
Lemma hlist_gen_ext : forall A F (f g : forall a, F a),\n  (forall x, f x = g x) ->\n  forall ls : list A, hlist_gen f ls = hlist_gen g ls.
-----
Lemma hlist_gen_ext : forall A F (f g : forall a, F a), (forall x, f x = g x) -> forall ls : list A, hlist_gen f ls = hlist_gen g ls.

*****

*****
forall (A : Type@{SerTop.601}) (F : forall _ : A, Type@{SerTop.595}) (f g : forall a : A, F a) (_ : forall x : A, eq (f x) (g x)) (ls : list A), eq (hlist_gen@{SerTop.601 SerTop.595} f ls) (hlist_gen@{SerTop.601 SerTop.595} g ls)
+++++
Proof.
-----
Lemma hlist_gen_ext : forall A F (f g : forall a, F a), (forall x, f x = g x) -> forall ls : list A, hlist_gen f ls = hlist_gen g ls.
Proof.

*****

*****
forall (A : Type@{SerTop.601}) (F : forall _ : A, Type@{SerTop.595}) (f g : forall a : A, F a) (_ : forall x : A, eq (f x) (g x)) (ls : list A), eq (hlist_gen@{SerTop.601 SerTop.595} f ls) (hlist_gen@{SerTop.601 SerTop.595} g ls)
+++++
intros.
-----
Lemma hlist_gen_ext : forall A F (f g : forall a, F a), (forall x, f x = g x) -> forall ls : list A, hlist_gen f ls = hlist_gen g ls.
Proof.
intros.

*****
ls : list A
H : forall x : A, eq (f x) (g x)
f,g : forall a : A, F a
F : forall _ : A, Type@{SerTop.595}
A : Type@{SerTop\.601}
*****
eq (hlist_gen@{SerTop.601 SerTop.595} f ls) (hlist_gen@{SerTop.601 SerTop.595} g ls)
+++++
do 2 rewrite <- hlist_gen_member_hlist_gen.
-----
Lemma hlist_gen_ext : forall A F (f g : forall a, F a), (forall x, f x = g x) -> forall ls : list A, hlist_gen f ls = hlist_gen g ls.
Proof.
intros.
do 2 rewrite <- hlist_gen_member_hlist_gen.

*****
ls : list A
H : forall x : A, eq (f x) (g x)
f,g : forall a : A, F a
F : forall _ : A, Type@{SerTop.595}
A : Type@{SerTop\.601}
*****
eq (hlist_gen_member@{SerTop.601 SerTop.595} F (fun (a : A) (_ : member a ls) => f a)) (hlist_gen_member@{SerTop.601 SerTop.595} F (fun (a : A) (_ : member a ls) => g a))
+++++
apply hlist_gen_member_ext.
-----
Lemma hlist_gen_ext : forall A F (f g : forall a, F a), (forall x, f x = g x) -> forall ls : list A, hlist_gen f ls = hlist_gen g ls.
Proof.
intros.
do 2 rewrite <- hlist_gen_member_hlist_gen.
apply hlist_gen_member_ext.

*****
ls : list A
H : forall x : A, eq (f x) (g x)
f,g : forall a : A, F a
F : forall _ : A, Type@{SerTop.595}
A : Type@{SerTop\.601}
*****
forall (x : A) (_ : member x ls), eq (f x) (g x)
+++++
auto.
-----
Lemma hlist_gen_ext : forall A F (f g : forall a, F a), (forall x, f x = g x) -> forall ls : list A, hlist_gen f ls = hlist_gen g ls.
Proof.
intros.
do 2 rewrite <- hlist_gen_member_hlist_gen.
apply hlist_gen_member_ext.
auto.

*****

*****

+++++
Qed.
-----
Global Instance Proper_hlist_gen : forall A F,\n  Proper (forall_relation (fun _ => eq) ==> forall_relation (fun _ => eq))\n         (@hlist_gen A F).
-----
Global Instance Proper_hlist_gen : forall A F, Proper (forall_relation (fun _ => eq) ==> forall_relation (fun _ => eq)) (@hlist_gen A F).

*****

*****
forall (A : Type@{SerTop.642}) (F : forall _ : A, Type@{SerTop.643}), Proper (respectful (forall_relation (fun a : A => eq)) (forall_relation (fun a : list A => eq))) hlist_gen@{SerTop.642 SerTop.643}
+++++
Proof.
-----
Global Instance Proper_hlist_gen : forall A F, Proper (forall_relation (fun _ => eq) ==> forall_relation (fun _ => eq)) (@hlist_gen A F).
Proof.

*****

*****
forall (A : Type@{SerTop.642}) (F : forall _ : A, Type@{SerTop.643}), Proper (respectful (forall_relation (fun a : A => eq)) (forall_relation (fun a : list A => eq))) hlist_gen@{SerTop.642 SerTop.643}
+++++
repeat intro.
-----
Global Instance Proper_hlist_gen : forall A F, Proper (forall_relation (fun _ => eq) ==> forall_relation (fun _ => eq)) (@hlist_gen A F).
Proof.
repeat intro.

*****
a : list A
H : forall_relation (fun a : A => eq) x y
x,y : forall x : A, F x
F : forall _ : A, Type@{SerTop.643}
A : Type@{SerTop\.642}
*****
eq (hlist_gen@{SerTop.642 SerTop.643} x a) (hlist_gen@{SerTop.642 SerTop.643} y a)
+++++
apply hlist_gen_ext.
-----
Global Instance Proper_hlist_gen : forall A F, Proper (forall_relation (fun _ => eq) ==> forall_relation (fun _ => eq)) (@hlist_gen A F).
Proof.
repeat intro.
apply hlist_gen_ext.

*****
a : list A
H : forall_relation (fun a : A => eq) x y
x,y : forall x : A, F x
F : forall _ : A, Type@{SerTop.643}
A : Type@{SerTop\.642}
*****
forall x0 : A, eq (x x0) (y x0)
+++++
auto.
-----
Global Instance Proper_hlist_gen : forall A F, Proper (forall_relation (fun _ => eq) ==> forall_relation (fun _ => eq)) (@hlist_gen A F).
Proof.
repeat intro.
apply hlist_gen_ext.
auto.

*****

*****

+++++
Qed.
-----
Lemma equiv_hlist_gen : forall T (F : T -> Type) (f : forall t, F t) f'\n    (R : forall t, F t -> F t -> Prop),\n  (forall t, R t (f t) (f' t)) ->\n  forall ls,\n    equiv_hlist R (hlist_gen f ls) (hlist_gen f' ls).
-----
Lemma equiv_hlist_gen : forall T (F : T -> Type) (f : forall t, F t) f' (R : forall t, F t -> F t -> Prop), (forall t, R t (f t) (f' t)) -> forall ls, equiv_hlist R (hlist_gen f ls) (hlist_gen f' ls).

*****

*****
forall (T : Type@{SerTop.651}) (F : forall _ : T, Type@{SerTop.652}) (f : forall t : T, F t) (f' : forall x : T, F x) (R : forall (t : T) (_ : F t) (_ : F t), Prop) (_ : forall t : T, R t (f t) (f' t)) (ls : list T), equiv_hlist@{SerTop.651 SerTop.652} R (hlist_gen@{SerTop.651 SerTop.652} f ls) (hlist_gen@{SerTop.651 SerTop.652} f' ls)
+++++
Proof.
-----
Lemma equiv_hlist_gen : forall T (F : T -> Type) (f : forall t, F t) f' (R : forall t, F t -> F t -> Prop), (forall t, R t (f t) (f' t)) -> forall ls, equiv_hlist R (hlist_gen f ls) (hlist_gen f' ls).
Proof.

*****

*****
forall (T : Type@{SerTop.651}) (F : forall _ : T, Type@{SerTop.652}) (f : forall t : T, F t) (f' : forall x : T, F x) (R : forall (t : T) (_ : F t) (_ : F t), Prop) (_ : forall t : T, R t (f t) (f' t)) (ls : list T), equiv_hlist@{SerTop.651 SerTop.652} R (hlist_gen@{SerTop.651 SerTop.652} f ls) (hlist_gen@{SerTop.651 SerTop.652} f' ls)
+++++
induction ls.
-----
Lemma equiv_hlist_gen : forall T (F : T -> Type) (f : forall t, F t) f' (R : forall t, F t -> F t -> Prop), (forall t, R t (f t) (f' t)) -> forall ls, equiv_hlist R (hlist_gen f ls) (hlist_gen f' ls).
Proof.
induction ls.

*****
H : forall t : T, R t (f t) (f' t)
R : forall (t : T) (_ : F t) (_ : F t), Prop
f,f' : forall x : T, F x
F : forall _ : T, Type@{SerTop.652}
T : Type@{SerTop\.651}
*****
equiv_hlist@{SerTop.651 SerTop.652} R (hlist_gen@{SerTop.651 SerTop.652} f nil) (hlist_gen@{SerTop.651 SerTop.652} f' nil)
+++++
simpl.
-----
Lemma equiv_hlist_gen : forall T (F : T -> Type) (f : forall t, F t) f' (R : forall t, F t -> F t -> Prop), (forall t, R t (f t) (f' t)) -> forall ls, equiv_hlist R (hlist_gen f ls) (hlist_gen f' ls).
Proof.
induction ls.
simpl.

*****
H : forall t : T, R t (f t) (f' t)
R : forall (t : T) (_ : F t) (_ : F t), Prop
f,f' : forall x : T, F x
F : forall _ : T, Type@{SerTop.652}
T : Type@{SerTop\.651}
*****
equiv_hlist@{SerTop.651 SerTop.652} R Hnil@{SerTop.651 SerTop.652} Hnil@{SerTop.651 SerTop.652}
+++++
constructor.
-----
Lemma equiv_hlist_gen : forall T (F : T -> Type) (f : forall t, F t) f' (R : forall t, F t -> F t -> Prop), (forall t, R t (f t) (f' t)) -> forall ls, equiv_hlist R (hlist_gen f ls) (hlist_gen f' ls).
Proof.
induction ls.

*****
IHls : equiv_hlist@{SerTop.651 SerTop.652} R\n (hlist_gen@{SerTop.651 SerTop.652} f ls)\n (hlist_gen@{SerTop.651 SerTop.652} f' ls)
ls : list T
a : T
H : forall t : T, R t (f t) (f' t)
R : forall (t : T) (_ : F t) (_ : F t), Prop
f,f' : forall x : T, F x
F : forall _ : T, Type@{SerTop.652}
T : Type@{SerTop\.651}
*****
equiv_hlist@{SerTop.651 SerTop.652} R (hlist_gen@{SerTop.651 SerTop.652} f (cons a ls)) (hlist_gen@{SerTop.651 SerTop.652} f' (cons a ls))
+++++
simpl.
-----
Lemma equiv_hlist_gen : forall T (F : T -> Type) (f : forall t, F t) f' (R : forall t, F t -> F t -> Prop), (forall t, R t (f t) (f' t)) -> forall ls, equiv_hlist R (hlist_gen f ls) (hlist_gen f' ls).
Proof.
induction ls.
simpl.

*****
IHls : equiv_hlist@{SerTop.651 SerTop.652} R\n (hlist_gen@{SerTop.651 SerTop.652} f ls)\n (hlist_gen@{SerTop.651 SerTop.652} f' ls)
ls : list T
a : T
H : forall t : T, R t (f t) (f' t)
R : forall (t : T) (_ : F t) (_ : F t), Prop
f,f' : forall x : T, F x
F : forall _ : T, Type@{SerTop.652}
T : Type@{SerTop\.651}
*****
equiv_hlist@{SerTop.651 SerTop.652} R (Hcons@{SerTop.651 SerTop.652} (f a) (hlist_gen@{SerTop.651 SerTop.652} f ls)) (Hcons@{SerTop.651 SerTop.652} (f' a) (hlist_gen@{SerTop.651 SerTop.652} f' ls))
+++++
constructor.
-----
Lemma equiv_hlist_gen : forall T (F : T -> Type) (f : forall t, F t) f' (R : forall t, F t -> F t -> Prop), (forall t, R t (f t) (f' t)) -> forall ls, equiv_hlist R (hlist_gen f ls) (hlist_gen f' ls).
Proof.
induction ls.
simpl.
constructor.

*****
IHls : equiv_hlist@{SerTop.651 SerTop.652} R\n (hlist_gen@{SerTop.651 SerTop.652} f ls)\n (hlist_gen@{SerTop.651 SerTop.652} f' ls)
ls : list T
a : T
H : forall t : T, R t (f t) (f' t)
R : forall (t : T) (_ : F t) (_ : F t), Prop
f,f' : forall x : T, F x
F : forall _ : T, Type@{SerTop.652}
T : Type@{SerTop\.651}
*****
R a (f a) (f' a)
+++++
auto.
-----
Lemma equiv_hlist_gen : forall T (F : T -> Type) (f : forall t, F t) f' (R : forall t, F t -> F t -> Prop), (forall t, R t (f t) (f' t)) -> forall ls, equiv_hlist R (hlist_gen f ls) (hlist_gen f' ls).
Proof.
induction ls.
simpl.
constructor.

*****
IHls : equiv_hlist@{SerTop.651 SerTop.652} R\n (hlist_gen@{SerTop.651 SerTop.652} f ls)\n (hlist_gen@{SerTop.651 SerTop.652} f' ls)
ls : list T
a : T
H : forall t : T, R t (f t) (f' t)
R : forall (t : T) (_ : F t) (_ : F t), Prop
f,f' : forall x : T, F x
F : forall _ : T, Type@{SerTop.652}
T : Type@{SerTop\.651}
*****
equiv_hlist@{SerTop.651 SerTop.652} R (hlist_gen@{SerTop.651 SerTop.652} f ls) (hlist_gen@{SerTop.651 SerTop.652} f' ls)
+++++
auto.
-----
Lemma equiv_hlist_gen : forall T (F : T -> Type) (f : forall t, F t) f' (R : forall t, F t -> F t -> Prop), (forall t, R t (f t) (f' t)) -> forall ls, equiv_hlist R (hlist_gen f ls) (hlist_gen f' ls).
Proof.
induction ls.

*****

*****

+++++
Qed.
-----
Global Instance Proper_equiv_hlist_gen : forall A (F : A -> Type) R,\n  Proper (forall_relation R ==> forall_relation (@equiv_hlist _ _ R))\n         (@hlist_gen A F).
-----
Global Instance Proper_equiv_hlist_gen : forall A (F : A -> Type) R, Proper (forall_relation R ==> forall_relation (@equiv_hlist _ _ R)) (@hlist_gen A F).

*****

*****
forall (A : Type@{SerTop.673}) (F : forall _ : A, Type@{SerTop.674}) (R : forall a : A, relation (F a)), Proper (respectful (forall_relation R) (forall_relation (@equiv_hlist@{SerTop.673 SerTop.674} A F R))) hlist_gen@{SerTop.673 SerTop.674}
+++++
Proof.
-----
Global Instance Proper_equiv_hlist_gen : forall A (F : A -> Type) R, Proper (forall_relation R ==> forall_relation (@equiv_hlist _ _ R)) (@hlist_gen A F).
Proof.

*****

*****
forall (A : Type@{SerTop.673}) (F : forall _ : A, Type@{SerTop.674}) (R : forall a : A, relation (F a)), Proper (respectful (forall_relation R) (forall_relation (@equiv_hlist@{SerTop.673 SerTop.674} A F R))) hlist_gen@{SerTop.673 SerTop.674}
+++++
repeat intro.
-----
Global Instance Proper_equiv_hlist_gen : forall A (F : A -> Type) R, Proper (forall_relation R ==> forall_relation (@equiv_hlist _ _ R)) (@hlist_gen A F).
Proof.
repeat intro.

*****
a : list A
H : forall_relation R x y
x,y : forall x : A, F x
R : forall a : A, relation (F a)
F : forall _ : A, Type@{SerTop.674}
A : Type@{SerTop\.673}
*****
equiv_hlist@{SerTop.673 SerTop.674} R (hlist_gen@{SerTop.673 SerTop.674} x a) (hlist_gen@{SerTop.673 SerTop.674} y a)
+++++
apply equiv_hlist_gen.
-----
Global Instance Proper_equiv_hlist_gen : forall A (F : A -> Type) R, Proper (forall_relation R ==> forall_relation (@equiv_hlist _ _ R)) (@hlist_gen A F).
Proof.
repeat intro.
apply equiv_hlist_gen.

*****
a : list A
H : forall_relation R x y
x,y : forall x : A, F x
R : forall a : A, relation (F a)
F : forall _ : A, Type@{SerTop.674}
A : Type@{SerTop\.673}
*****
forall t : A, R t (x t) (y t)
+++++
auto.
-----
Global Instance Proper_equiv_hlist_gen : forall A (F : A -> Type) R, Proper (forall_relation R ==> forall_relation (@equiv_hlist _ _ R)) (@hlist_gen A F).
Proof.
repeat intro.
apply equiv_hlist_gen.
auto.

*****

*****

+++++
Qed.
-----
Fixpoint hlist_erase {A B} {ls : list A} (hs : hlist (fun _ => B) ls) : list B :=\n  match hs with\n  | Hnil => nil\n  | Hcons _ _ x hs' => cons x (hlist_erase hs')\n  end.
-----
Lemma hlist_erase_hlist_gen : forall A B ls (f : A -> B),\n  hlist_erase (hlist_gen f ls) = map f ls.
-----
Lemma hlist_erase_hlist_gen : forall A B ls (f : A -> B), hlist_erase (hlist_gen f ls) = map f ls.

*****

*****
forall (A : Type@{SerTop.696}) (B : Type@{SerTop.697}) (ls : list A) (f : forall _ : A, B), eq (hlist_erase@{SerTop.696 SerTop.697} (hlist_gen@{SerTop.696 SerTop.697} f ls)) (map f ls)
+++++
Proof.
-----
Lemma hlist_erase_hlist_gen : forall A B ls (f : A -> B), hlist_erase (hlist_gen f ls) = map f ls.
Proof.

*****

*****
forall (A : Type@{SerTop.696}) (B : Type@{SerTop.697}) (ls : list A) (f : forall _ : A, B), eq (hlist_erase@{SerTop.696 SerTop.697} (hlist_gen@{SerTop.696 SerTop.697} f ls)) (map f ls)
+++++
induction ls.
-----
Lemma hlist_erase_hlist_gen : forall A B ls (f : A -> B), hlist_erase (hlist_gen f ls) = map f ls.
Proof.
induction ls.

*****
B : Type@{SerTop\.697}
A : Type@{SerTop\.696}
*****
forall f : forall _ : A, B, eq (hlist_erase@{SerTop.696 SerTop.697} (hlist_gen@{SerTop.696 SerTop.697} f nil)) (map f nil)
+++++
simpl.
-----
Lemma hlist_erase_hlist_gen : forall A B ls (f : A -> B), hlist_erase (hlist_gen f ls) = map f ls.
Proof.
induction ls.
simpl.

*****
B : Type@{SerTop\.697}
A : Type@{SerTop\.696}
*****
forall _ : forall _ : A, B, eq nil nil
+++++
intros.
-----
Lemma hlist_erase_hlist_gen : forall A B ls (f : A -> B), hlist_erase (hlist_gen f ls) = map f ls.
Proof.
induction ls.
simpl.
intros.

*****
f : forall _ : A, B
B : Type@{SerTop\.697}
A : Type@{SerTop\.696}
*****
eq nil nil
+++++
f_equal.
-----
Lemma hlist_erase_hlist_gen : forall A B ls (f : A -> B), hlist_erase (hlist_gen f ls) = map f ls.
Proof.
induction ls.

*****
IHls : forall f : forall _ : A, B,\neq\n (hlist_erase@{SerTop.696 SerTop.697}\n (hlist_gen@{SerTop.696 SerTop.697} f ls)) (map f ls)
ls : list A
a : A
B : Type@{SerTop\.697}
A : Type@{SerTop\.696}
*****
forall f : forall _ : A, B, eq (hlist_erase@{SerTop.696 SerTop.697} (hlist_gen@{SerTop.696 SerTop.697} f (cons a ls))) (map f (cons a ls))
+++++
simpl.
-----
Lemma hlist_erase_hlist_gen : forall A B ls (f : A -> B), hlist_erase (hlist_gen f ls) = map f ls.
Proof.
induction ls.
simpl.

*****
IHls : forall f : forall _ : A, B,\neq\n (hlist_erase@{SerTop.696 SerTop.697}\n (hlist_gen@{SerTop.696 SerTop.697} f ls)) (map f ls)
ls : list A
a : A
B : Type@{SerTop\.697}
A : Type@{SerTop\.696}
*****
forall f : forall _ : A, B, eq (cons (f a) (hlist_erase@{SerTop.696 SerTop.697} (hlist_gen@{SerTop.696 SerTop.697} f ls))) (cons (f a) (map f ls))
+++++
intros.
-----
Lemma hlist_erase_hlist_gen : forall A B ls (f : A -> B), hlist_erase (hlist_gen f ls) = map f ls.
Proof.
induction ls.
simpl.
intros.

*****
f : forall _ : A, B
IHls : forall f : forall _ : A, B,\neq\n (hlist_erase@{SerTop.696 SerTop.697}\n (hlist_gen@{SerTop.696 SerTop.697} f ls)) (map f ls)
ls : list A
a : A
B : Type@{SerTop\.697}
A : Type@{SerTop\.696}
*****
eq (cons (f a) (hlist_erase@{SerTop.696 SerTop.697} (hlist_gen@{SerTop.696 SerTop.697} f ls))) (cons (f a) (map f ls))
+++++
f_equal.
-----
Lemma hlist_erase_hlist_gen : forall A B ls (f : A -> B), hlist_erase (hlist_gen f ls) = map f ls.
Proof.
induction ls.
simpl.
intros.
f_equal.

*****
f : forall _ : A, B
IHls : forall f : forall _ : A, B,\neq\n (hlist_erase@{SerTop.696 SerTop.697}\n (hlist_gen@{SerTop.696 SerTop.697} f ls)) (map f ls)
ls : list A
a : A
B : Type@{SerTop\.697}
A : Type@{SerTop\.696}
*****
eq (hlist_erase@{SerTop.696 SerTop.697} (hlist_gen@{SerTop.696 SerTop.697} f ls)) (map f ls)
+++++
auto.
-----
Lemma hlist_erase_hlist_gen : forall A B ls (f : A -> B), hlist_erase (hlist_gen f ls) = map f ls.
Proof.
induction ls.

*****

*****

+++++
Qed.
-----
Section hlist_Forall.
-----
Variable A : Type.
-----
Variable P : A -> Prop.
-----
Fixpoint hlist_Forall ls (hs : hlist P ls) : Forall P ls :=\n    match hs with\n    | Hnil => Forall_nil _\n    | Hcons _ _ H hs' => Forall_cons _ H (hlist_Forall hs')\n    end.
-----
End hlist_Forall.
-----
Section hlist_rel.
-----
Variable A : Type.
-----
Variables F G : A -> Type.
-----
Variable R : forall x : A, F x -> G x -> Prop.
-----
Inductive hlist_hrel : forall ls, hlist F ls -> hlist G ls -> Prop :=\n  | hrel_Hnil : hlist_hrel Hnil Hnil\n  | hrel_Hcons : forall t ts x y xs ys, @R t x y -> @hlist_hrel ts xs ys ->\n                                        @hlist_hrel (t :: ts) (Hcons x xs) (Hcons y ys).
-----
End hlist_rel.
-----
Section hlist_rel_map.
-----
Variable A : Type.
-----
Variables F G F' G' : A -> Type.
-----
Variable R : forall x : A, F x -> G x -> Prop.
-----
Variable R' : forall x : A, F' x -> G' x -> Prop.
-----
Variable ff : forall x : A, F x -> F' x.
-----
Variable gg : forall x : A, G x -> G' x.
-----
Hypothesis R_ff_R' :\n    forall t x y, @R t x y ->\n                  @R' t (ff x) (gg y).
-----
Theorem hlist_hrel_map\n  : forall ls xs ys,\n      @hlist_hrel A F G R ls xs ys ->\n      @hlist_hrel A F' G' R' ls (hlist_map ff xs) (hlist_map gg ys).
-----
Theorem hlist_hrel_map : forall ls xs ys, @hlist_hrel A F G R ls xs ys -> @hlist_hrel A F' G' R' ls (hlist_map ff xs) (hlist_map gg ys).

*****
R_ff_R' : forall (t : A) (x : F t) (y : G t) (_ : R x y), R' (ff x) (gg y)
gg : forall (x : A) (_ : G x), G' x
ff : forall (x : A) (_ : F x), F' x
R' : forall (x : A) (_ : F' x) (_ : G' x), Prop
R : forall (x : A) (_ : F x) (_ : G x), Prop
G' : forall _ : A, Type@{SerTop.733}
F' : forall _ : A, Type@{SerTop.732}
G : forall _ : A, Type@{SerTop.731}
F : forall _ : A, Type@{SerTop.730}
A : Type@{SerTop\.729}
*****
forall (ls : list A) (xs : hlist@{SerTop.729 SerTop.730} F ls) (ys : hlist@{SerTop.729 SerTop.731} G ls) (_ : hlist_hrel@{SerTop.729 SerTop.730 SerTop.731} R xs ys), hlist_hrel@{SerTop.729 SerTop.732 SerTop.733} R' (hlist_map@{SerTop.729 SerTop.730 SerTop.732} ff xs) (hlist_map@{SerTop.729 SerTop.731 SerTop.733} gg ys)
+++++
Proof.
-----
Theorem hlist_hrel_map : forall ls xs ys, @hlist_hrel A F G R ls xs ys -> @hlist_hrel A F' G' R' ls (hlist_map ff xs) (hlist_map gg ys).
Proof.

*****
R_ff_R' : forall (t : A) (x : F t) (y : G t) (_ : R x y), R' (ff x) (gg y)
gg : forall (x : A) (_ : G x), G' x
ff : forall (x : A) (_ : F x), F' x
R' : forall (x : A) (_ : F' x) (_ : G' x), Prop
R : forall (x : A) (_ : F x) (_ : G x), Prop
G' : forall _ : A, Type@{SerTop.733}
F' : forall _ : A, Type@{SerTop.732}
G : forall _ : A, Type@{SerTop.731}
F : forall _ : A, Type@{SerTop.730}
A : Type@{SerTop\.729}
*****
forall (ls : list A) (xs : hlist@{SerTop.729 SerTop.730} F ls) (ys : hlist@{SerTop.729 SerTop.731} G ls) (_ : hlist_hrel@{SerTop.729 SerTop.730 SerTop.731} R xs ys), hlist_hrel@{SerTop.729 SerTop.732 SerTop.733} R' (hlist_map@{SerTop.729 SerTop.730 SerTop.732} ff xs) (hlist_map@{SerTop.729 SerTop.731 SerTop.733} gg ys)
+++++
induction 1.
-----
Theorem hlist_hrel_map : forall ls xs ys, @hlist_hrel A F G R ls xs ys -> @hlist_hrel A F' G' R' ls (hlist_map ff xs) (hlist_map gg ys).
Proof.
induction 1.

*****
R_ff_R' : forall (t : A) (x : F t) (y : G t) (_ : R x y), R' (ff x) (gg y)
gg : forall (x : A) (_ : G x), G' x
ff : forall (x : A) (_ : F x), F' x
R' : forall (x : A) (_ : F' x) (_ : G' x), Prop
R : forall (x : A) (_ : F x) (_ : G x), Prop
G' : forall _ : A, Type@{SerTop.733}
F' : forall _ : A, Type@{SerTop.732}
G : forall _ : A, Type@{SerTop.731}
F : forall _ : A, Type@{SerTop.730}
A : Type@{SerTop\.729}
*****
hlist_hrel@{SerTop.729 SerTop.732 SerTop.733} R' (hlist_map@{SerTop.729 SerTop.730 SerTop.732} ff Hnil@{SerTop.729 SerTop.730}) (hlist_map@{SerTop.729 SerTop.731 SerTop.733} gg Hnil@{SerTop.729 SerTop.731})
+++++
simpl.
-----
Theorem hlist_hrel_map : forall ls xs ys, @hlist_hrel A F G R ls xs ys -> @hlist_hrel A F' G' R' ls (hlist_map ff xs) (hlist_map gg ys).
Proof.
induction 1.
simpl.

*****
R_ff_R' : forall (t : A) (x : F t) (y : G t) (_ : R x y), R' (ff x) (gg y)
gg : forall (x : A) (_ : G x), G' x
ff : forall (x : A) (_ : F x), F' x
R' : forall (x : A) (_ : F' x) (_ : G' x), Prop
R : forall (x : A) (_ : F x) (_ : G x), Prop
G' : forall _ : A, Type@{SerTop.733}
F' : forall _ : A, Type@{SerTop.732}
G : forall _ : A, Type@{SerTop.731}
F : forall _ : A, Type@{SerTop.730}
A : Type@{SerTop\.729}
*****
hlist_hrel@{SerTop.729 SerTop.732 SerTop.733} R' Hnil@{SerTop.729 SerTop.732} Hnil@{SerTop.729 SerTop.733}
+++++
constructor.
-----
Theorem hlist_hrel_map : forall ls xs ys, @hlist_hrel A F G R ls xs ys -> @hlist_hrel A F' G' R' ls (hlist_map ff xs) (hlist_map gg ys).
Proof.
induction 1.

*****
IHhlist_hrel : hlist_hrel@{SerTop.729 SerTop.732 SerTop.733} R'\n (hlist_map@{SerTop.729 SerTop.730 SerTop.732} ff xs)\n (hlist_map@{SerTop.729 SerTop.731 SerTop.733} gg ys)
H0 : hlist_hrel@{SerTop.729 SerTop.730 SerTop.731} R xs ys
H : R x y
ys : hlist@{SerTop.729 SerTop.731} G ts
xs : hlist@{SerTop.729 SerTop.730} F ts
y : G t
x : F t
ts : list A
t : A
R_ff_R' : forall (t : A) (x : F t) (y : G t) (_ : R x y), R' (ff x) (gg y)
gg : forall (x : A) (_ : G x), G' x
ff : forall (x : A) (_ : F x), F' x
R' : forall (x : A) (_ : F' x) (_ : G' x), Prop
R : forall (x : A) (_ : F x) (_ : G x), Prop
G' : forall _ : A, Type@{SerTop.733}
F' : forall _ : A, Type@{SerTop.732}
G : forall _ : A, Type@{SerTop.731}
F : forall _ : A, Type@{SerTop.730}
A : Type@{SerTop\.729}
*****
hlist_hrel@{SerTop.729 SerTop.732 SerTop.733} R' (hlist_map@{SerTop.729 SerTop.730 SerTop.732} ff (Hcons@{SerTop.729 SerTop.730} x xs)) (hlist_map@{SerTop.729 SerTop.731 SerTop.733} gg (Hcons@{SerTop.729 SerTop.731} y ys))
+++++
simpl.
-----
Theorem hlist_hrel_map : forall ls xs ys, @hlist_hrel A F G R ls xs ys -> @hlist_hrel A F' G' R' ls (hlist_map ff xs) (hlist_map gg ys).
Proof.
induction 1.
simpl.

*****
IHhlist_hrel : hlist_hrel@{SerTop.729 SerTop.732 SerTop.733} R'\n (hlist_map@{SerTop.729 SerTop.730 SerTop.732} ff xs)\n (hlist_map@{SerTop.729 SerTop.731 SerTop.733} gg ys)
H0 : hlist_hrel@{SerTop.729 SerTop.730 SerTop.731} R xs ys
H : R x y
ys : hlist@{SerTop.729 SerTop.731} G ts
xs : hlist@{SerTop.729 SerTop.730} F ts
y : G t
x : F t
ts : list A
t : A
R_ff_R' : forall (t : A) (x : F t) (y : G t) (_ : R x y), R' (ff x) (gg y)
gg : forall (x : A) (_ : G x), G' x
ff : forall (x : A) (_ : F x), F' x
R' : forall (x : A) (_ : F' x) (_ : G' x), Prop
R : forall (x : A) (_ : F x) (_ : G x), Prop
G' : forall _ : A, Type@{SerTop.733}
F' : forall _ : A, Type@{SerTop.732}
G : forall _ : A, Type@{SerTop.731}
F : forall _ : A, Type@{SerTop.730}
A : Type@{SerTop\.729}
*****
hlist_hrel@{SerTop.729 SerTop.732 SerTop.733} R' (Hcons@{SerTop.729 SerTop.732} (ff x) (hlist_map@{SerTop.729 SerTop.730 SerTop.732} ff xs)) (Hcons@{SerTop.729 SerTop.733} (gg y) (hlist_map@{SerTop.729 SerTop.731 SerTop.733} gg ys))
+++++
constructor.
-----
Theorem hlist_hrel_map : forall ls xs ys, @hlist_hrel A F G R ls xs ys -> @hlist_hrel A F' G' R' ls (hlist_map ff xs) (hlist_map gg ys).
Proof.
induction 1.
simpl.
constructor.

*****
IHhlist_hrel : hlist_hrel@{SerTop.729 SerTop.732 SerTop.733} R'\n (hlist_map@{SerTop.729 SerTop.730 SerTop.732} ff xs)\n (hlist_map@{SerTop.729 SerTop.731 SerTop.733} gg ys)
H0 : hlist_hrel@{SerTop.729 SerTop.730 SerTop.731} R xs ys
H : R x y
ys : hlist@{SerTop.729 SerTop.731} G ts
xs : hlist@{SerTop.729 SerTop.730} F ts
y : G t
x : F t
ts : list A
t : A
R_ff_R' : forall (t : A) (x : F t) (y : G t) (_ : R x y), R' (ff x) (gg y)
gg : forall (x : A) (_ : G x), G' x
ff : forall (x : A) (_ : F x), F' x
R' : forall (x : A) (_ : F' x) (_ : G' x), Prop
R : forall (x : A) (_ : F x) (_ : G x), Prop
G' : forall _ : A, Type@{SerTop.733}
F' : forall _ : A, Type@{SerTop.732}
G : forall _ : A, Type@{SerTop.731}
F : forall _ : A, Type@{SerTop.730}
A : Type@{SerTop\.729}
*****
R' (ff x) (gg y)
+++++
eauto.
-----
Theorem hlist_hrel_map : forall ls xs ys, @hlist_hrel A F G R ls xs ys -> @hlist_hrel A F' G' R' ls (hlist_map ff xs) (hlist_map gg ys).
Proof.
induction 1.
simpl.
constructor.

*****
IHhlist_hrel : hlist_hrel@{SerTop.729 SerTop.732 SerTop.733} R'\n (hlist_map@{SerTop.729 SerTop.730 SerTop.732} ff xs)\n (hlist_map@{SerTop.729 SerTop.731 SerTop.733} gg ys)
H0 : hlist_hrel@{SerTop.729 SerTop.730 SerTop.731} R xs ys
H : R x y
ys : hlist@{SerTop.729 SerTop.731} G ts
xs : hlist@{SerTop.729 SerTop.730} F ts
y : G t
x : F t
ts : list A
t : A
R_ff_R' : forall (t : A) (x : F t) (y : G t) (_ : R x y), R' (ff x) (gg y)
gg : forall (x : A) (_ : G x), G' x
ff : forall (x : A) (_ : F x), F' x
R' : forall (x : A) (_ : F' x) (_ : G' x), Prop
R : forall (x : A) (_ : F x) (_ : G x), Prop
G' : forall _ : A, Type@{SerTop.733}
F' : forall _ : A, Type@{SerTop.732}
G : forall _ : A, Type@{SerTop.731}
F : forall _ : A, Type@{SerTop.730}
A : Type@{SerTop\.729}
*****
hlist_hrel@{SerTop.729 SerTop.732 SerTop.733} R' (hlist_map@{SerTop.729 SerTop.730 SerTop.732} ff xs) (hlist_map@{SerTop.729 SerTop.731 SerTop.733} gg ys)
+++++
eauto.
-----
Theorem hlist_hrel_map : forall ls xs ys, @hlist_hrel A F G R ls xs ys -> @hlist_hrel A F' G' R' ls (hlist_map ff xs) (hlist_map gg ys).
Proof.
induction 1.

*****

*****

+++++
Qed.
-----
Theorem hlist_hrel_cons\n  : forall l ls x xs y ys,\n      @hlist_hrel A F G R (l :: ls) (Hcons x xs) (Hcons y ys) ->\n      @R l x y /\ @hlist_hrel A F G R ls xs ys.
-----
Theorem hlist_hrel_cons : forall l ls x xs y ys, @hlist_hrel A F G R (l :: ls) (Hcons x xs) (Hcons y ys) -> @R l x y /\\ @hlist_hrel A F G R ls xs ys.

*****
R_ff_R' : forall (t : A) (x : F t) (y : G t) (_ : R x y), R' (ff x) (gg y)
gg : forall (x : A) (_ : G x), G' x
ff : forall (x : A) (_ : F x), F' x
R' : forall (x : A) (_ : F' x) (_ : G' x), Prop
R : forall (x : A) (_ : F x) (_ : G x), Prop
G' : forall _ : A, Type@{SerTop.733}
F' : forall _ : A, Type@{SerTop.732}
G : forall _ : A, Type@{SerTop.731}
F : forall _ : A, Type@{SerTop.730}
A : Type@{SerTop\.729}
*****
forall (l : A) (ls : list A) (x : F l) (xs : hlist@{SerTop.729 SerTop.730} F ls) (y : G l) (ys : hlist@{SerTop.729 SerTop.731} G ls) (_ : hlist_hrel@{SerTop.729 SerTop.730 SerTop.731} R (Hcons@{SerTop.729 SerTop.730} x xs) (Hcons@{SerTop.729 SerTop.731} y ys)), and (R x y) (hlist_hrel@{SerTop.729 SerTop.730 SerTop.731} R xs ys)
+++++
Proof.
-----
Theorem hlist_hrel_cons : forall l ls x xs y ys, @hlist_hrel A F G R (l :: ls) (Hcons x xs) (Hcons y ys) -> @R l x y /\\ @hlist_hrel A F G R ls xs ys.
Proof.

*****
R_ff_R' : forall (t : A) (x : F t) (y : G t) (_ : R x y), R' (ff x) (gg y)
gg : forall (x : A) (_ : G x), G' x
ff : forall (x : A) (_ : F x), F' x
R' : forall (x : A) (_ : F' x) (_ : G' x), Prop
R : forall (x : A) (_ : F x) (_ : G x), Prop
G' : forall _ : A, Type@{SerTop.733}
F' : forall _ : A, Type@{SerTop.732}
G : forall _ : A, Type@{SerTop.731}
F : forall _ : A, Type@{SerTop.730}
A : Type@{SerTop\.729}
*****
forall (l : A) (ls : list A) (x : F l) (xs : hlist@{SerTop.729 SerTop.730} F ls) (y : G l) (ys : hlist@{SerTop.729 SerTop.731} G ls) (_ : hlist_hrel@{SerTop.729 SerTop.730 SerTop.731} R (Hcons@{SerTop.729 SerTop.730} x xs) (Hcons@{SerTop.729 SerTop.731} y ys)), and (R x y) (hlist_hrel@{SerTop.729 SerTop.730 SerTop.731} R xs ys)
+++++
intros.
-----
Theorem hlist_hrel_cons : forall l ls x xs y ys, @hlist_hrel A F G R (l :: ls) (Hcons x xs) (Hcons y ys) -> @R l x y /\\ @hlist_hrel A F G R ls xs ys.
Proof.
intros.

*****
H : hlist_hrel@{SerTop.729 SerTop.730 SerTop.731} R\n (Hcons@{SerTop.729 SerTop.730} x xs)\n (Hcons@{SerTop.729 SerTop.731} y ys)
ys : hlist@{SerTop.729 SerTop.731} G ls
y : G l
xs : hlist@{SerTop.729 SerTop.730} F ls
x : F l
ls : list A
l : A
R_ff_R' : forall (t : A) (x : F t) (y : G t) (_ : R x y), R' (ff x) (gg y)
gg : forall (x : A) (_ : G x), G' x
ff : forall (x : A) (_ : F x), F' x
R' : forall (x : A) (_ : F' x) (_ : G' x), Prop
R : forall (x : A) (_ : F x) (_ : G x), Prop
G' : forall _ : A, Type@{SerTop.733}
F' : forall _ : A, Type@{SerTop.732}
G : forall _ : A, Type@{SerTop.731}
F : forall _ : A, Type@{SerTop.730}
A : Type@{SerTop\.729}
*****
and (R x y) (hlist_hrel@{SerTop.729 SerTop.730 SerTop.731} R xs ys)
+++++
refine match H in @hlist_hrel _ _ _ _ ls' xs' ys' return match ls' as ls' return hlist F ls' -> hlist G ls' -> Prop with | nil => fun _ _ => True | l' :: ls' => fun x y => R (hlist_hd x) (hlist_hd y) /\ hlist_hrel R (hlist_tl x) (hlist_tl y) end xs' ys' with | hrel_Hnil => I | hrel_Hcons _ _ _ _ _ _ pf pf' => conj pf pf' end.
-----
Theorem hlist_hrel_cons : forall l ls x xs y ys, @hlist_hrel A F G R (l :: ls) (Hcons x xs) (Hcons y ys) -> @R l x y /\\ @hlist_hrel A F G R ls xs ys.
Proof.
intros.
refine match H in @hlist_hrel _ _ _ _ ls' xs' ys' return match ls' as ls' return hlist F ls' -> hlist G ls' -> Prop with | nil => fun _ _ => True | l' :: ls' => fun x y => R (hlist_hd x) (hlist_hd y) /\\ hlist_hrel R (hlist_tl x) (hlist_tl y) end xs' ys' with | hrel_Hnil => I | hrel_Hcons _ _ _ _ _ _ pf pf' => conj pf pf' end.

*****

*****

+++++
Qed.
-----
Theorem hlist_hrel_app\n  : forall l ls x xs y ys,\n      @hlist_hrel A F G R (l ++ ls) (hlist_app x xs) (hlist_app y ys) ->\n      @hlist_hrel A F G R l x y /\ @hlist_hrel A F G R ls xs ys.
-----
Theorem hlist_hrel_app : forall l ls x xs y ys, @hlist_hrel A F G R (l ++ ls) (hlist_app x xs) (hlist_app y ys) -> @hlist_hrel A F G R l x y /\\ @hlist_hrel A F G R ls xs ys.

*****
R_ff_R' : forall (t : A) (x : F t) (y : G t) (_ : R x y), R' (ff x) (gg y)
gg : forall (x : A) (_ : G x), G' x
ff : forall (x : A) (_ : F x), F' x
R' : forall (x : A) (_ : F' x) (_ : G' x), Prop
R : forall (x : A) (_ : F x) (_ : G x), Prop
G' : forall _ : A, Type@{SerTop.733}
F' : forall _ : A, Type@{SerTop.732}
G : forall _ : A, Type@{SerTop.731}
F : forall _ : A, Type@{SerTop.730}
A : Type@{SerTop\.729}
*****
forall (l ls : list A) (x : hlist@{SerTop.729 SerTop.730} F l) (xs : hlist@{SerTop.729 SerTop.730} F ls) (y : hlist@{SerTop.729 SerTop.731} G l) (ys : hlist@{SerTop.729 SerTop.731} G ls) (_ : hlist_hrel@{SerTop.729 SerTop.730 SerTop.731} R (hlist_app@{SerTop.729 SerTop.730} x xs) (hlist_app@{SerTop.729 SerTop.731} y ys)), and (hlist_hrel@{SerTop.729 SerTop.730 SerTop.731} R x y) (hlist_hrel@{SerTop.729 SerTop.730 SerTop.731} R xs ys)
+++++
Proof.
-----
Theorem hlist_hrel_app : forall l ls x xs y ys, @hlist_hrel A F G R (l ++ ls) (hlist_app x xs) (hlist_app y ys) -> @hlist_hrel A F G R l x y /\\ @hlist_hrel A F G R ls xs ys.
Proof.

*****
R_ff_R' : forall (t : A) (x : F t) (y : G t) (_ : R x y), R' (ff x) (gg y)
gg : forall (x : A) (_ : G x), G' x
ff : forall (x : A) (_ : F x), F' x
R' : forall (x : A) (_ : F' x) (_ : G' x), Prop
R : forall (x : A) (_ : F x) (_ : G x), Prop
G' : forall _ : A, Type@{SerTop.733}
F' : forall _ : A, Type@{SerTop.732}
G : forall _ : A, Type@{SerTop.731}
F : forall _ : A, Type@{SerTop.730}
A : Type@{SerTop\.729}
*****
forall (l ls : list A) (x : hlist@{SerTop.729 SerTop.730} F l) (xs : hlist@{SerTop.729 SerTop.730} F ls) (y : hlist@{SerTop.729 SerTop.731} G l) (ys : hlist@{SerTop.729 SerTop.731} G ls) (_ : hlist_hrel@{SerTop.729 SerTop.730 SerTop.731} R (hlist_app@{SerTop.729 SerTop.730} x xs) (hlist_app@{SerTop.729 SerTop.731} y ys)), and (hlist_hrel@{SerTop.729 SerTop.730 SerTop.731} R x y) (hlist_hrel@{SerTop.729 SerTop.730 SerTop.731} R xs ys)
+++++
induction x.
-----
Theorem hlist_hrel_app : forall l ls x xs y ys, @hlist_hrel A F G R (l ++ ls) (hlist_app x xs) (hlist_app y ys) -> @hlist_hrel A F G R l x y /\\ @hlist_hrel A F G R ls xs ys.
Proof.
induction x.

*****
ls : list A
R_ff_R' : forall (t : A) (x : F t) (y : G t) (_ : R x y), R' (ff x) (gg y)
gg : forall (x : A) (_ : G x), G' x
ff : forall (x : A) (_ : F x), F' x
R' : forall (x : A) (_ : F' x) (_ : G' x), Prop
R : forall (x : A) (_ : F x) (_ : G x), Prop
G' : forall _ : A, Type@{SerTop.733}
F' : forall _ : A, Type@{SerTop.732}
G : forall _ : A, Type@{SerTop.731}
F : forall _ : A, Type@{SerTop.730}
A : Type@{SerTop\.729}
*****
forall (xs : hlist@{SerTop.729 SerTop.730} F ls) (y : hlist@{SerTop.729 SerTop.731} G nil) (ys : hlist@{SerTop.729 SerTop.731} G ls) (_ : hlist_hrel@{SerTop.729 SerTop.730 SerTop.731} R (hlist_app@{SerTop.729 SerTop.730} Hnil@{SerTop.729 SerTop.730} xs) (hlist_app@{SerTop.729 SerTop.731} y ys)), and (hlist_hrel@{SerTop.729 SerTop.730 SerTop.731} R Hnil@{SerTop.729 SerTop.730} y) (hlist_hrel@{SerTop.729 SerTop.730 SerTop.731} R xs ys)
+++++
intros xs y ys.
-----
Theorem hlist_hrel_app : forall l ls x xs y ys, @hlist_hrel A F G R (l ++ ls) (hlist_app x xs) (hlist_app y ys) -> @hlist_hrel A F G R l x y /\\ @hlist_hrel A F G R ls xs ys.
Proof.
induction x.
intros xs y ys.

*****
ys : hlist@{SerTop.729 SerTop.731} G ls
y : hlist@{SerTop.729 SerTop.731} G nil
xs : hlist@{SerTop.729 SerTop.730} F ls
ls : list A
R_ff_R' : forall (t : A) (x : F t) (y : G t) (_ : R x y), R' (ff x) (gg y)
gg : forall (x : A) (_ : G x), G' x
ff : forall (x : A) (_ : F x), F' x
R' : forall (x : A) (_ : F' x) (_ : G' x), Prop
R : forall (x : A) (_ : F x) (_ : G x), Prop
G' : forall _ : A, Type@{SerTop.733}
F' : forall _ : A, Type@{SerTop.732}
G : forall _ : A, Type@{SerTop.731}
F : forall _ : A, Type@{SerTop.730}
A : Type@{SerTop\.729}
*****
forall _ : hlist_hrel@{SerTop.729 SerTop.730 SerTop.731} R (hlist_app@{SerTop.729 SerTop.730} Hnil@{SerTop.729 SerTop.730} xs) (hlist_app@{SerTop.729 SerTop.731} y ys), and (hlist_hrel@{SerTop.729 SerTop.730 SerTop.731} R Hnil@{SerTop.729 SerTop.730} y) (hlist_hrel@{SerTop.729 SerTop.730 SerTop.731} R xs ys)
+++++
rewrite (hlist_eta y).
-----
Theorem hlist_hrel_app : forall l ls x xs y ys, @hlist_hrel A F G R (l ++ ls) (hlist_app x xs) (hlist_app y ys) -> @hlist_hrel A F G R l x y /\\ @hlist_hrel A F G R ls xs ys.
Proof.
induction x.
intros xs y ys.
rewrite (hlist_eta y).

*****
ys : hlist@{SerTop.729 SerTop.731} G ls
y : hlist@{SerTop.729 SerTop.731} G nil
xs : hlist@{SerTop.729 SerTop.730} F ls
ls : list A
R_ff_R' : forall (t : A) (x : F t) (y : G t) (_ : R x y), R' (ff x) (gg y)
gg : forall (x : A) (_ : G x), G' x
ff : forall (x : A) (_ : F x), F' x
R' : forall (x : A) (_ : F' x) (_ : G' x), Prop
R : forall (x : A) (_ : F x) (_ : G x), Prop
G' : forall _ : A, Type@{SerTop.733}
F' : forall _ : A, Type@{SerTop.732}
G : forall _ : A, Type@{SerTop.731}
F : forall _ : A, Type@{SerTop.730}
A : Type@{SerTop\.729}
*****
forall _ : hlist_hrel@{SerTop.729 SerTop.730 SerTop.731} R (hlist_app@{SerTop.729 SerTop.730} Hnil@{SerTop.729 SerTop.730} xs) (hlist_app@{SerTop.729 SerTop.731} Hnil@{SerTop.729 SerTop.731} ys), and (hlist_hrel@{SerTop.729 SerTop.730 SerTop.731} R Hnil@{SerTop.729 SerTop.730} Hnil@{SerTop.729 SerTop.731}) (hlist_hrel@{SerTop.729 SerTop.730 SerTop.731} R xs ys)
+++++
simpl.
-----
Theorem hlist_hrel_app : forall l ls x xs y ys, @hlist_hrel A F G R (l ++ ls) (hlist_app x xs) (hlist_app y ys) -> @hlist_hrel A F G R l x y /\\ @hlist_hrel A F G R ls xs ys.
Proof.
induction x.
intros xs y ys.
rewrite (hlist_eta y).
simpl.

*****
ys : hlist@{SerTop.729 SerTop.731} G ls
y : hlist@{SerTop.729 SerTop.731} G nil
xs : hlist@{SerTop.729 SerTop.730} F ls
ls : list A
R_ff_R' : forall (t : A) (x : F t) (y : G t) (_ : R x y), R' (ff x) (gg y)
gg : forall (x : A) (_ : G x), G' x
ff : forall (x : A) (_ : F x), F' x
R' : forall (x : A) (_ : F' x) (_ : G' x), Prop
R : forall (x : A) (_ : F x) (_ : G x), Prop
G' : forall _ : A, Type@{SerTop.733}
F' : forall _ : A, Type@{SerTop.732}
G : forall _ : A, Type@{SerTop.731}
F : forall _ : A, Type@{SerTop.730}
A : Type@{SerTop\.729}
*****
forall _ : hlist_hrel@{SerTop.729 SerTop.730 SerTop.731} R xs ys, and (hlist_hrel@{SerTop.729 SerTop.730 SerTop.731} R Hnil@{SerTop.729 SerTop.730} Hnil@{SerTop.729 SerTop.731}) (hlist_hrel@{SerTop.729 SerTop.730 SerTop.731} R xs ys)
+++++
intros.
-----
Theorem hlist_hrel_app : forall l ls x xs y ys, @hlist_hrel A F G R (l ++ ls) (hlist_app x xs) (hlist_app y ys) -> @hlist_hrel A F G R l x y /\\ @hlist_hrel A F G R ls xs ys.
Proof.
induction x.
intros xs y ys.
rewrite (hlist_eta y).
simpl.
intros.

*****
H : hlist_hrel@{SerTop.729 SerTop.730 SerTop.731} R xs ys
ys : hlist@{SerTop.729 SerTop.731} G ls
y : hlist@{SerTop.729 SerTop.731} G nil
xs : hlist@{SerTop.729 SerTop.730} F ls
ls : list A
R_ff_R' : forall (t : A) (x : F t) (y : G t) (_ : R x y), R' (ff x) (gg y)
gg : forall (x : A) (_ : G x), G' x
ff : forall (x : A) (_ : F x), F' x
R' : forall (x : A) (_ : F' x) (_ : G' x), Prop
R : forall (x : A) (_ : F x) (_ : G x), Prop
G' : forall _ : A, Type@{SerTop.733}
F' : forall _ : A, Type@{SerTop.732}
G : forall _ : A, Type@{SerTop.731}
F : forall _ : A, Type@{SerTop.730}
A : Type@{SerTop\.729}
*****
and (hlist_hrel@{SerTop.729 SerTop.730 SerTop.731} R Hnil@{SerTop.729 SerTop.730} Hnil@{SerTop.729 SerTop.731}) (hlist_hrel@{SerTop.729 SerTop.730 SerTop.731} R xs ys)
+++++
split.
-----
Theorem hlist_hrel_app : forall l ls x xs y ys, @hlist_hrel A F G R (l ++ ls) (hlist_app x xs) (hlist_app y ys) -> @hlist_hrel A F G R l x y /\\ @hlist_hrel A F G R ls xs ys.
Proof.
induction x.
intros xs y ys.
rewrite (hlist_eta y).
simpl.
intros.
split.

*****
H : hlist_hrel@{SerTop.729 SerTop.730 SerTop.731} R xs ys
ys : hlist@{SerTop.729 SerTop.731} G ls
y : hlist@{SerTop.729 SerTop.731} G nil
xs : hlist@{SerTop.729 SerTop.730} F ls
ls : list A
R_ff_R' : forall (t : A) (x : F t) (y : G t) (_ : R x y), R' (ff x) (gg y)
gg : forall (x : A) (_ : G x), G' x
ff : forall (x : A) (_ : F x), F' x
R' : forall (x : A) (_ : F' x) (_ : G' x), Prop
R : forall (x : A) (_ : F x) (_ : G x), Prop
G' : forall _ : A, Type@{SerTop.733}
F' : forall _ : A, Type@{SerTop.732}
G : forall _ : A, Type@{SerTop.731}
F : forall _ : A, Type@{SerTop.730}
A : Type@{SerTop\.729}
*****
hlist_hrel@{SerTop.729 SerTop.730 SerTop.731} R Hnil@{SerTop.729 SerTop.730} Hnil@{SerTop.729 SerTop.731}
+++++
auto.
-----
Theorem hlist_hrel_app : forall l ls x xs y ys, @hlist_hrel A F G R (l ++ ls) (hlist_app x xs) (hlist_app y ys) -> @hlist_hrel A F G R l x y /\\ @hlist_hrel A F G R ls xs ys.
Proof.
induction x.
intros xs y ys.
rewrite (hlist_eta y).
simpl.
intros.
split.
auto.

*****
H : hlist_hrel@{SerTop.729 SerTop.730 SerTop.731} R xs ys
ys : hlist@{SerTop.729 SerTop.731} G ls
y : hlist@{SerTop.729 SerTop.731} G nil
xs : hlist@{SerTop.729 SerTop.730} F ls
ls : list A
R_ff_R' : forall (t : A) (x : F t) (y : G t) (_ : R x y), R' (ff x) (gg y)
gg : forall (x : A) (_ : G x), G' x
ff : forall (x : A) (_ : F x), F' x
R' : forall (x : A) (_ : F' x) (_ : G' x), Prop
R : forall (x : A) (_ : F x) (_ : G x), Prop
G' : forall _ : A, Type@{SerTop.733}
F' : forall _ : A, Type@{SerTop.732}
G : forall _ : A, Type@{SerTop.731}
F : forall _ : A, Type@{SerTop.730}
A : Type@{SerTop\.729}
*****
hlist_hrel@{SerTop.729 SerTop.730 SerTop.731} R Hnil@{SerTop.729 SerTop.730} Hnil@{SerTop.729 SerTop.731}
+++++
constructor.
-----
Theorem hlist_hrel_app : forall l ls x xs y ys, @hlist_hrel A F G R (l ++ ls) (hlist_app x xs) (hlist_app y ys) -> @hlist_hrel A F G R l x y /\\ @hlist_hrel A F G R ls xs ys.
Proof.
induction x.
intros xs y ys.
rewrite (hlist_eta y).
simpl.
intros.
split.

*****
H : hlist_hrel@{SerTop.729 SerTop.730 SerTop.731} R xs ys
ys : hlist@{SerTop.729 SerTop.731} G ls
y : hlist@{SerTop.729 SerTop.731} G nil
xs : hlist@{SerTop.729 SerTop.730} F ls
ls : list A
R_ff_R' : forall (t : A) (x : F t) (y : G t) (_ : R x y), R' (ff x) (gg y)
gg : forall (x : A) (_ : G x), G' x
ff : forall (x : A) (_ : F x), F' x
R' : forall (x : A) (_ : F' x) (_ : G' x), Prop
R : forall (x : A) (_ : F x) (_ : G x), Prop
G' : forall _ : A, Type@{SerTop.733}
F' : forall _ : A, Type@{SerTop.732}
G : forall _ : A, Type@{SerTop.731}
F : forall _ : A, Type@{SerTop.730}
A : Type@{SerTop\.729}
*****
hlist_hrel@{SerTop.729 SerTop.730 SerTop.731} R xs ys
+++++
auto.
-----
Theorem hlist_hrel_app : forall l ls x xs y ys, @hlist_hrel A F G R (l ++ ls) (hlist_app x xs) (hlist_app y ys) -> @hlist_hrel A F G R l x y /\\ @hlist_hrel A F G R ls xs ys.
Proof.
induction x.

*****
IHx : forall (xs : hlist@{SerTop.729 SerTop.730} F ls)\n (y : hlist@{SerTop.729 SerTop.731} G ls0)\n (ys : hlist@{SerTop.729 SerTop.731} G ls)\n (_ : hlist_hrel@{SerTop.729 SerTop.730 SerTop.731} R\n (hlist_app@{SerTop.729 SerTop.730} x xs)\n (hlist_app@{SerTop.729 SerTop.731} y ys)),\nand (hlist_hrel@{SerTop.729 SerTop.730 SerTop.731} R x y)\n (hlist_hrel@{SerTop.729 SerTop.730 SerTop.731} R xs ys)
x : hlist@{SerTop.729 SerTop.730} F ls0
f : F l
ls0 : list A
l : A
ls : list A
R_ff_R' : forall (t : A) (x : F t) (y : G t) (_ : R x y), R' (ff x) (gg y)
gg : forall (x : A) (_ : G x), G' x
ff : forall (x : A) (_ : F x), F' x
R' : forall (x : A) (_ : F' x) (_ : G' x), Prop
R : forall (x : A) (_ : F x) (_ : G x), Prop
G' : forall _ : A, Type@{SerTop.733}
F' : forall _ : A, Type@{SerTop.732}
G : forall _ : A, Type@{SerTop.731}
F : forall _ : A, Type@{SerTop.730}
A : Type@{SerTop\.729}
*****
forall (xs : hlist@{SerTop.729 SerTop.730} F ls) (y : hlist@{SerTop.729 SerTop.731} G (cons l ls0)) (ys : hlist@{SerTop.729 SerTop.731} G ls) (_ : hlist_hrel@{SerTop.729 SerTop.730 SerTop.731} R (hlist_app@{SerTop.729 SerTop.730} (Hcons@{SerTop.729 SerTop.730} f x) xs) (hlist_app@{SerTop.729 SerTop.731} y ys)), and (hlist_hrel@{SerTop.729 SerTop.730 SerTop.731} R (Hcons@{SerTop.729 SerTop.730} f x) y) (hlist_hrel@{SerTop.729 SerTop.730 SerTop.731} R xs ys)
+++++
intros xs y ys.
-----
Theorem hlist_hrel_app : forall l ls x xs y ys, @hlist_hrel A F G R (l ++ ls) (hlist_app x xs) (hlist_app y ys) -> @hlist_hrel A F G R l x y /\\ @hlist_hrel A F G R ls xs ys.
Proof.
induction x.
intros xs y ys.

*****
ys : hlist@{SerTop.729 SerTop.731} G ls
y : hlist@{SerTop.729 SerTop.731} G (cons l ls0)
xs : hlist@{SerTop.729 SerTop.730} F ls
IHx : forall (xs : hlist@{SerTop.729 SerTop.730} F ls)\n (y : hlist@{SerTop.729 SerTop.731} G ls0)\n (ys : hlist@{SerTop.729 SerTop.731} G ls)\n (_ : hlist_hrel@{SerTop.729 SerTop.730 SerTop.731} R\n (hlist_app@{SerTop.729 SerTop.730} x xs)\n (hlist_app@{SerTop.729 SerTop.731} y ys)),\nand (hlist_hrel@{SerTop.729 SerTop.730 SerTop.731} R x y)\n (hlist_hrel@{SerTop.729 SerTop.730 SerTop.731} R xs ys)
x : hlist@{SerTop.729 SerTop.730} F ls0
f : F l
ls0 : list A
l : A
ls : list A
R_ff_R' : forall (t : A) (x : F t) (y : G t) (_ : R x y), R' (ff x) (gg y)
gg : forall (x : A) (_ : G x), G' x
ff : forall (x : A) (_ : F x), F' x
R' : forall (x : A) (_ : F' x) (_ : G' x), Prop
R : forall (x : A) (_ : F x) (_ : G x), Prop
G' : forall _ : A, Type@{SerTop.733}
F' : forall _ : A, Type@{SerTop.732}
G : forall _ : A, Type@{SerTop.731}
F : forall _ : A, Type@{SerTop.730}
A : Type@{SerTop\.729}
*****
forall _ : hlist_hrel@{SerTop.729 SerTop.730 SerTop.731} R (hlist_app@{SerTop.729 SerTop.730} (Hcons@{SerTop.729 SerTop.730} f x) xs) (hlist_app@{SerTop.729 SerTop.731} y ys), and (hlist_hrel@{SerTop.729 SerTop.730 SerTop.731} R (Hcons@{SerTop.729 SerTop.730} f x) y) (hlist_hrel@{SerTop.729 SerTop.730 SerTop.731} R xs ys)
+++++
rewrite (hlist_eta y).
-----
Theorem hlist_hrel_app : forall l ls x xs y ys, @hlist_hrel A F G R (l ++ ls) (hlist_app x xs) (hlist_app y ys) -> @hlist_hrel A F G R l x y /\\ @hlist_hrel A F G R ls xs ys.
Proof.
induction x.
intros xs y ys.
rewrite (hlist_eta y).

*****
ys : hlist@{SerTop.729 SerTop.731} G ls
y : hlist@{SerTop.729 SerTop.731} G (cons l ls0)
xs : hlist@{SerTop.729 SerTop.730} F ls
IHx : forall (xs : hlist@{SerTop.729 SerTop.730} F ls)\n (y : hlist@{SerTop.729 SerTop.731} G ls0)\n (ys : hlist@{SerTop.729 SerTop.731} G ls)\n (_ : hlist_hrel@{SerTop.729 SerTop.730 SerTop.731} R\n (hlist_app@{SerTop.729 SerTop.730} x xs)\n (hlist_app@{SerTop.729 SerTop.731} y ys)),\nand (hlist_hrel@{SerTop.729 SerTop.730 SerTop.731} R x y)\n (hlist_hrel@{SerTop.729 SerTop.730 SerTop.731} R xs ys)
x : hlist@{SerTop.729 SerTop.730} F ls0
f : F l
ls0 : list A
l : A
ls : list A
R_ff_R' : forall (t : A) (x : F t) (y : G t) (_ : R x y), R' (ff x) (gg y)
gg : forall (x : A) (_ : G x), G' x
ff : forall (x : A) (_ : F x), F' x
R' : forall (x : A) (_ : F' x) (_ : G' x), Prop
R : forall (x : A) (_ : F x) (_ : G x), Prop
G' : forall _ : A, Type@{SerTop.733}
F' : forall _ : A, Type@{SerTop.732}
G : forall _ : A, Type@{SerTop.731}
F : forall _ : A, Type@{SerTop.730}
A : Type@{SerTop\.729}
*****
forall _ : hlist_hrel@{SerTop.729 SerTop.730 SerTop.731} R (hlist_app@{SerTop.729 SerTop.730} (Hcons@{SerTop.729 SerTop.730} f x) xs) (hlist_app@{SerTop.729 SerTop.731} (Hcons@{SerTop.729 SerTop.731} (hlist_hd@{SerTop.729 SerTop.731} y) (hlist_tl@{SerTop.729 SerTop.731} y)) ys), and (hlist_hrel@{SerTop.729 SerTop.730 SerTop.731} R (Hcons@{SerTop.729 SerTop.730} f x) (Hcons@{SerTop.729 SerTop.731} (hlist_hd@{SerTop.729 SerTop.731} y) (hlist_tl@{SerTop.729 SerTop.731} y))) (hlist_hrel@{SerTop.729 SerTop.730 SerTop.731} R xs ys)
+++++
intros.
-----
Theorem hlist_hrel_app : forall l ls x xs y ys, @hlist_hrel A F G R (l ++ ls) (hlist_app x xs) (hlist_app y ys) -> @hlist_hrel A F G R l x y /\\ @hlist_hrel A F G R ls xs ys.
Proof.
induction x.
intros xs y ys.
rewrite (hlist_eta y).
intros.

*****
H : hlist_hrel@{SerTop.729 SerTop.730 SerTop.731} R\n (hlist_app@{SerTop.729 SerTop.730}\n (Hcons@{SerTop.729 SerTop.730} f x) xs)\n (hlist_app@{SerTop.729 SerTop.731}\n (Hcons@{SerTop.729 SerTop.731}\n (hlist_hd@{SerTop.729 SerTop.731} y)\n (hlist_tl@{SerTop.729 SerTop.731} y)) ys)
ys : hlist@{SerTop.729 SerTop.731} G ls
y : hlist@{SerTop.729 SerTop.731} G (cons l ls0)
xs : hlist@{SerTop.729 SerTop.730} F ls
IHx : forall (xs : hlist@{SerTop.729 SerTop.730} F ls)\n (y : hlist@{SerTop.729 SerTop.731} G ls0)\n (ys : hlist@{SerTop.729 SerTop.731} G ls)\n (_ : hlist_hrel@{SerTop.729 SerTop.730 SerTop.731} R\n (hlist_app@{SerTop.729 SerTop.730} x xs)\n (hlist_app@{SerTop.729 SerTop.731} y ys)),\nand (hlist_hrel@{SerTop.729 SerTop.730 SerTop.731} R x y)\n (hlist_hrel@{SerTop.729 SerTop.730 SerTop.731} R xs ys)
x : hlist@{SerTop.729 SerTop.730} F ls0
f : F l
ls0 : list A
l : A
ls : list A
R_ff_R' : forall (t : A) (x : F t) (y : G t) (_ : R x y), R' (ff x) (gg y)
gg : forall (x : A) (_ : G x), G' x
ff : forall (x : A) (_ : F x), F' x
R' : forall (x : A) (_ : F' x) (_ : G' x), Prop
R : forall (x : A) (_ : F x) (_ : G x), Prop
G' : forall _ : A, Type@{SerTop.733}
F' : forall _ : A, Type@{SerTop.732}
G : forall _ : A, Type@{SerTop.731}
F : forall _ : A, Type@{SerTop.730}
A : Type@{SerTop\.729}
*****
and (hlist_hrel@{SerTop.729 SerTop.730 SerTop.731} R (Hcons@{SerTop.729 SerTop.730} f x) (Hcons@{SerTop.729 SerTop.731} (hlist_hd@{SerTop.729 SerTop.731} y) (hlist_tl@{SerTop.729 SerTop.731} y))) (hlist_hrel@{SerTop.729 SerTop.730 SerTop.731} R xs ys)
+++++
eapply hlist_hrel_cons in H.
-----
Theorem hlist_hrel_app : forall l ls x xs y ys, @hlist_hrel A F G R (l ++ ls) (hlist_app x xs) (hlist_app y ys) -> @hlist_hrel A F G R l x y /\\ @hlist_hrel A F G R ls xs ys.
Proof.
induction x.
intros xs y ys.
rewrite (hlist_eta y).
intros.
eapply hlist_hrel_cons in H.

*****
H : and (R f (hlist_hd@{SerTop.729 SerTop.731} y))\n (hlist_hrel@{SerTop.729 SerTop.730 SerTop.731} R\n ((fix\n hlist_app (ll lr : list A)\n (h : hlist@{SerTop.729 SerTop.730} F ll) {struct h} :\n forall _ : hlist@{SerTop.729 SerTop.730} F lr,\n hlist@{SerTop.729 SerTop.730} F (app ll lr) :=\n match\n h in (hlist _ ll0)\n return\n (forall _ : hlist@{SerTop.729 SerTop.730} F lr,\n hlist@{SerTop.729 SerTop.730} F (app ll0 lr))\n with\n | Hnil => fun x : hlist@{SerTop.729 SerTop.730} F lr => x\n | @Hcons _ _ l ls hd tl =>\n fun r : hlist@{SerTop.729 SerTop.730} F lr =>\n Hcons@{SerTop.729 SerTop.730} hd (hlist_app ls lr tl r)\n end) ls0 ls x xs)\n ((fix\n hlist_app (ll lr : list A)\n (h : hlist@{SerTop.729 SerTop.731} G ll) {struct h} :\n forall _ : hlist@{SerTop.729 SerTop.731} G lr,\n hlist@{SerTop.729 SerTop.731} G (app ll lr) :=\n match\n h in (hlist _ ll0)\n return\n (forall _ : hlist@{SerTop.729 SerTop.731} G lr,\n hlist@{SerTop.729 SerTop.731} G (app ll0 lr))\n with\n | Hnil => fun x : hlist@{SerTop.729 SerTop.731} G lr => x\n | @Hcons _ _ l ls hd tl =>\n fun r : hlist@{SerTop.729 SerTop.731} G lr =>\n Hcons@{SerTop.729 SerTop.731} hd (hlist_app ls lr tl r)\n end) ls0 ls (hlist_tl@{SerTop.729 SerTop.731} y) ys))
ys : hlist@{SerTop.729 SerTop.731} G ls
y : hlist@{SerTop.729 SerTop.731} G (cons l ls0)
xs : hlist@{SerTop.729 SerTop.730} F ls
IHx : forall (xs : hlist@{SerTop.729 SerTop.730} F ls)\n (y : hlist@{SerTop.729 SerTop.731} G ls0)\n (ys : hlist@{SerTop.729 SerTop.731} G ls)\n (_ : hlist_hrel@{SerTop.729 SerTop.730 SerTop.731} R\n (hlist_app@{SerTop.729 SerTop.730} x xs)\n (hlist_app@{SerTop.729 SerTop.731} y ys)),\nand (hlist_hrel@{SerTop.729 SerTop.730 SerTop.731} R x y)\n (hlist_hrel@{SerTop.729 SerTop.730 SerTop.731} R xs ys)
x : hlist@{SerTop.729 SerTop.730} F ls0
f : F l
ls0 : list A
l : A
ls : list A
R_ff_R' : forall (t : A) (x : F t) (y : G t) (_ : R x y), R' (ff x) (gg y)
gg : forall (x : A) (_ : G x), G' x
ff : forall (x : A) (_ : F x), F' x
R' : forall (x : A) (_ : F' x) (_ : G' x), Prop
R : forall (x : A) (_ : F x) (_ : G x), Prop
G' : forall _ : A, Type@{SerTop.733}
F' : forall _ : A, Type@{SerTop.732}
G : forall _ : A, Type@{SerTop.731}
F : forall _ : A, Type@{SerTop.730}
A : Type@{SerTop\.729}
*****
and (hlist_hrel@{SerTop.729 SerTop.730 SerTop.731} R (Hcons@{SerTop.729 SerTop.730} f x) (Hcons@{SerTop.729 SerTop.731} (hlist_hd@{SerTop.729 SerTop.731} y) (hlist_tl@{SerTop.729 SerTop.731} y))) (hlist_hrel@{SerTop.729 SerTop.730 SerTop.731} R xs ys)
+++++
destruct H.
-----
Theorem hlist_hrel_app : forall l ls x xs y ys, @hlist_hrel A F G R (l ++ ls) (hlist_app x xs) (hlist_app y ys) -> @hlist_hrel A F G R l x y /\\ @hlist_hrel A F G R ls xs ys.
Proof.
induction x.
intros xs y ys.
rewrite (hlist_eta y).
intros.
eapply hlist_hrel_cons in H.
destruct H.

*****
H0 : hlist_hrel@{SerTop.729 SerTop.730 SerTop.731} R\n ((fix\n hlist_app (ll lr : list A) (h : hlist@{SerTop.729 SerTop.730} F ll)\n {struct h} :\n forall _ : hlist@{SerTop.729 SerTop.730} F lr,\n hlist@{SerTop.729 SerTop.730} F (app ll lr) :=\n match\n h in (hlist _ ll0)\n return\n (forall _ : hlist@{SerTop.729 SerTop.730} F lr,\n hlist@{SerTop.729 SerTop.730} F (app ll0 lr))\n with\n | Hnil => fun x : hlist@{SerTop.729 SerTop.730} F lr => x\n | @Hcons _ _ l ls hd tl =>\n fun r : hlist@{SerTop.729 SerTop.730} F lr =>\n Hcons@{SerTop.729 SerTop.730} hd (hlist_app ls lr tl r)\n end) ls0 ls x xs)\n ((fix\n hlist_app (ll lr : list A) (h : hlist@{SerTop.729 SerTop.731} G ll)\n {struct h} :\n forall _ : hlist@{SerTop.729 SerTop.731} G lr,\n hlist@{SerTop.729 SerTop.731} G (app ll lr) :=\n match\n h in (hlist _ ll0)\n return\n (forall _ : hlist@{SerTop.729 SerTop.731} G lr,\n hlist@{SerTop.729 SerTop.731} G (app ll0 lr))\n with\n | Hnil => fun x : hlist@{SerTop.729 SerTop.731} G lr => x\n | @Hcons _ _ l ls hd tl =>\n fun r : hlist@{SerTop.729 SerTop.731} G lr =>\n Hcons@{SerTop.729 SerTop.731} hd (hlist_app ls lr tl r)\n end) ls0 ls (hlist_tl@{SerTop.729 SerTop.731} y) ys)
H : R f (hlist_hd@{SerTop.729 SerTop.731} y)
ys : hlist@{SerTop.729 SerTop.731} G ls
y : hlist@{SerTop.729 SerTop.731} G (cons l ls0)
xs : hlist@{SerTop.729 SerTop.730} F ls
IHx : forall (xs : hlist@{SerTop.729 SerTop.730} F ls)\n (y : hlist@{SerTop.729 SerTop.731} G ls0)\n (ys : hlist@{SerTop.729 SerTop.731} G ls)\n (_ : hlist_hrel@{SerTop.729 SerTop.730 SerTop.731} R\n (hlist_app@{SerTop.729 SerTop.730} x xs)\n (hlist_app@{SerTop.729 SerTop.731} y ys)),\nand (hlist_hrel@{SerTop.729 SerTop.730 SerTop.731} R x y)\n (hlist_hrel@{SerTop.729 SerTop.730 SerTop.731} R xs ys)
x : hlist@{SerTop.729 SerTop.730} F ls0
f : F l
ls0 : list A
l : A
ls : list A
R_ff_R' : forall (t : A) (x : F t) (y : G t) (_ : R x y), R' (ff x) (gg y)
gg : forall (x : A) (_ : G x), G' x
ff : forall (x : A) (_ : F x), F' x
R' : forall (x : A) (_ : F' x) (_ : G' x), Prop
R : forall (x : A) (_ : F x) (_ : G x), Prop
G' : forall _ : A, Type@{SerTop.733}
F' : forall _ : A, Type@{SerTop.732}
G : forall _ : A, Type@{SerTop.731}
F : forall _ : A, Type@{SerTop.730}
A : Type@{SerTop\.729}
*****
and (hlist_hrel@{SerTop.729 SerTop.730 SerTop.731} R (Hcons@{SerTop.729 SerTop.730} f x) (Hcons@{SerTop.729 SerTop.731} (hlist_hd@{SerTop.729 SerTop.731} y) (hlist_tl@{SerTop.729 SerTop.731} y))) (hlist_hrel@{SerTop.729 SerTop.730 SerTop.731} R xs ys)
+++++
apply IHx in H0.
-----
Theorem hlist_hrel_app : forall l ls x xs y ys, @hlist_hrel A F G R (l ++ ls) (hlist_app x xs) (hlist_app y ys) -> @hlist_hrel A F G R l x y /\\ @hlist_hrel A F G R ls xs ys.
Proof.
induction x.
intros xs y ys.
rewrite (hlist_eta y).
intros.
eapply hlist_hrel_cons in H.
destruct H.
apply IHx in H0.

*****
H0 : and\n (hlist_hrel@{SerTop.729 SerTop.730 SerTop.731} R x\n (hlist_tl@{SerTop.729 SerTop.731} y))\n (hlist_hrel@{SerTop.729 SerTop.730 SerTop.731} R xs ys)
H : R f (hlist_hd@{SerTop.729 SerTop.731} y)
ys : hlist@{SerTop.729 SerTop.731} G ls
y : hlist@{SerTop.729 SerTop.731} G (cons l ls0)
xs : hlist@{SerTop.729 SerTop.730} F ls
IHx : forall (xs : hlist@{SerTop.729 SerTop.730} F ls)\n (y : hlist@{SerTop.729 SerTop.731} G ls0)\n (ys : hlist@{SerTop.729 SerTop.731} G ls)\n (_ : hlist_hrel@{SerTop.729 SerTop.730 SerTop.731} R\n (hlist_app@{SerTop.729 SerTop.730} x xs)\n (hlist_app@{SerTop.729 SerTop.731} y ys)),\nand (hlist_hrel@{SerTop.729 SerTop.730 SerTop.731} R x y)\n (hlist_hrel@{SerTop.729 SerTop.730 SerTop.731} R xs ys)
x : hlist@{SerTop.729 SerTop.730} F ls0
f : F l
ls0 : list A
l : A
ls : list A
R_ff_R' : forall (t : A) (x : F t) (y : G t) (_ : R x y), R' (ff x) (gg y)
gg : forall (x : A) (_ : G x), G' x
ff : forall (x : A) (_ : F x), F' x
R' : forall (x : A) (_ : F' x) (_ : G' x), Prop
R : forall (x : A) (_ : F x) (_ : G x), Prop
G' : forall _ : A, Type@{SerTop.733}
F' : forall _ : A, Type@{SerTop.732}
G : forall _ : A, Type@{SerTop.731}
F : forall _ : A, Type@{SerTop.730}
A : Type@{SerTop\.729}
*****
and (hlist_hrel@{SerTop.729 SerTop.730 SerTop.731} R (Hcons@{SerTop.729 SerTop.730} f x) (Hcons@{SerTop.729 SerTop.731} (hlist_hd@{SerTop.729 SerTop.731} y) (hlist_tl@{SerTop.729 SerTop.731} y))) (hlist_hrel@{SerTop.729 SerTop.730 SerTop.731} R xs ys)
+++++
intuition.
-----
Theorem hlist_hrel_app : forall l ls x xs y ys, @hlist_hrel A F G R (l ++ ls) (hlist_app x xs) (hlist_app y ys) -> @hlist_hrel A F G R l x y /\\ @hlist_hrel A F G R ls xs ys.
Proof.
induction x.
intros xs y ys.
rewrite (hlist_eta y).
intros.
eapply hlist_hrel_cons in H.
destruct H.
apply IHx in H0.
intuition.

*****
H2 : hlist_hrel@{SerTop.729 SerTop.730 SerTop.731} R xs ys
H1 : hlist_hrel@{SerTop.729 SerTop.730 SerTop.731} R x\n (hlist_tl@{SerTop.729 SerTop.731} y)
H : R f (hlist_hd@{SerTop.729 SerTop.731} y)
ys : hlist@{SerTop.729 SerTop.731} G ls
y : hlist@{SerTop.729 SerTop.731} G (cons l ls0)
xs : hlist@{SerTop.729 SerTop.730} F ls
IHx : forall (xs : hlist@{SerTop.729 SerTop.730} F ls)\n (y : hlist@{SerTop.729 SerTop.731} G ls0)\n (ys : hlist@{SerTop.729 SerTop.731} G ls)\n (_ : hlist_hrel@{SerTop.729 SerTop.730 SerTop.731} R\n (hlist_app@{SerTop.729 SerTop.730} x xs)\n (hlist_app@{SerTop.729 SerTop.731} y ys)),\nand (hlist_hrel@{SerTop.729 SerTop.730 SerTop.731} R x y)\n (hlist_hrel@{SerTop.729 SerTop.730 SerTop.731} R xs ys)
x : hlist@{SerTop.729 SerTop.730} F ls0
f : F l
ls0 : list A
l : A
ls : list A
R_ff_R' : forall (t : A) (x : F t) (y : G t) (_ : R x y), R' (ff x) (gg y)
gg : forall (x : A) (_ : G x), G' x
ff : forall (x : A) (_ : F x), F' x
R' : forall (x : A) (_ : F' x) (_ : G' x), Prop
R : forall (x : A) (_ : F x) (_ : G x), Prop
G' : forall _ : A, Type@{SerTop.733}
F' : forall _ : A, Type@{SerTop.732}
G : forall _ : A, Type@{SerTop.731}
F : forall _ : A, Type@{SerTop.730}
A : Type@{SerTop\.729}
*****
hlist_hrel@{SerTop.729 SerTop.730 SerTop.731} R (Hcons@{SerTop.729 SerTop.730} f x) (Hcons@{SerTop.729 SerTop.731} (hlist_hd@{SerTop.729 SerTop.731} y) (hlist_tl@{SerTop.729 SerTop.731} y))
+++++
constructor.
-----
Theorem hlist_hrel_app : forall l ls x xs y ys, @hlist_hrel A F G R (l ++ ls) (hlist_app x xs) (hlist_app y ys) -> @hlist_hrel A F G R l x y /\\ @hlist_hrel A F G R ls xs ys.
Proof.
induction x.
intros xs y ys.
rewrite (hlist_eta y).
intros.
eapply hlist_hrel_cons in H.
destruct H.
apply IHx in H0.
intuition.
constructor.

*****
H2 : hlist_hrel@{SerTop.729 SerTop.730 SerTop.731} R xs ys
H1 : hlist_hrel@{SerTop.729 SerTop.730 SerTop.731} R x\n (hlist_tl@{SerTop.729 SerTop.731} y)
H : R f (hlist_hd@{SerTop.729 SerTop.731} y)
ys : hlist@{SerTop.729 SerTop.731} G ls
y : hlist@{SerTop.729 SerTop.731} G (cons l ls0)
xs : hlist@{SerTop.729 SerTop.730} F ls
IHx : forall (xs : hlist@{SerTop.729 SerTop.730} F ls)\n (y : hlist@{SerTop.729 SerTop.731} G ls0)\n (ys : hlist@{SerTop.729 SerTop.731} G ls)\n (_ : hlist_hrel@{SerTop.729 SerTop.730 SerTop.731} R\n (hlist_app@{SerTop.729 SerTop.730} x xs)\n (hlist_app@{SerTop.729 SerTop.731} y ys)),\nand (hlist_hrel@{SerTop.729 SerTop.730 SerTop.731} R x y)\n (hlist_hrel@{SerTop.729 SerTop.730 SerTop.731} R xs ys)
x : hlist@{SerTop.729 SerTop.730} F ls0
f : F l
ls0 : list A
l : A
ls : list A
R_ff_R' : forall (t : A) (x : F t) (y : G t) (_ : R x y), R' (ff x) (gg y)
gg : forall (x : A) (_ : G x), G' x
ff : forall (x : A) (_ : F x), F' x
R' : forall (x : A) (_ : F' x) (_ : G' x), Prop
R : forall (x : A) (_ : F x) (_ : G x), Prop
G' : forall _ : A, Type@{SerTop.733}
F' : forall _ : A, Type@{SerTop.732}
G : forall _ : A, Type@{SerTop.731}
F : forall _ : A, Type@{SerTop.730}
A : Type@{SerTop\.729}
*****
R f (hlist_hd@{SerTop.729 SerTop.731} y)
+++++
auto.
-----
Theorem hlist_hrel_app : forall l ls x xs y ys, @hlist_hrel A F G R (l ++ ls) (hlist_app x xs) (hlist_app y ys) -> @hlist_hrel A F G R l x y /\\ @hlist_hrel A F G R ls xs ys.
Proof.
induction x.
intros xs y ys.
rewrite (hlist_eta y).
intros.
eapply hlist_hrel_cons in H.
destruct H.
apply IHx in H0.
intuition.
constructor.

*****
H2 : hlist_hrel@{SerTop.729 SerTop.730 SerTop.731} R xs ys
H1 : hlist_hrel@{SerTop.729 SerTop.730 SerTop.731} R x\n (hlist_tl@{SerTop.729 SerTop.731} y)
H : R f (hlist_hd@{SerTop.729 SerTop.731} y)
ys : hlist@{SerTop.729 SerTop.731} G ls
y : hlist@{SerTop.729 SerTop.731} G (cons l ls0)
xs : hlist@{SerTop.729 SerTop.730} F ls
IHx : forall (xs : hlist@{SerTop.729 SerTop.730} F ls)\n (y : hlist@{SerTop.729 SerTop.731} G ls0)\n (ys : hlist@{SerTop.729 SerTop.731} G ls)\n (_ : hlist_hrel@{SerTop.729 SerTop.730 SerTop.731} R\n (hlist_app@{SerTop.729 SerTop.730} x xs)\n (hlist_app@{SerTop.729 SerTop.731} y ys)),\nand (hlist_hrel@{SerTop.729 SerTop.730 SerTop.731} R x y)\n (hlist_hrel@{SerTop.729 SerTop.730 SerTop.731} R xs ys)
x : hlist@{SerTop.729 SerTop.730} F ls0
f : F l
ls0 : list A
l : A
ls : list A
R_ff_R' : forall (t : A) (x : F t) (y : G t) (_ : R x y), R' (ff x) (gg y)
gg : forall (x : A) (_ : G x), G' x
ff : forall (x : A) (_ : F x), F' x
R' : forall (x : A) (_ : F' x) (_ : G' x), Prop
R : forall (x : A) (_ : F x) (_ : G x), Prop
G' : forall _ : A, Type@{SerTop.733}
F' : forall _ : A, Type@{SerTop.732}
G : forall _ : A, Type@{SerTop.731}
F : forall _ : A, Type@{SerTop.730}
A : Type@{SerTop\.729}
*****
hlist_hrel@{SerTop.729 SerTop.730 SerTop.731} R x (hlist_tl@{SerTop.729 SerTop.731} y)
+++++
auto.
-----
Theorem hlist_hrel_app : forall l ls x xs y ys, @hlist_hrel A F G R (l ++ ls) (hlist_app x xs) (hlist_app y ys) -> @hlist_hrel A F G R l x y /\\ @hlist_hrel A F G R ls xs ys.
Proof.
induction x.

*****

*****

+++++
Qed.
-----
End hlist_rel_map.
-----
Theorem hlist_hrel_equiv\n: forall T (F : T -> Type) (R : forall t, F t -> F t -> Prop) ls (h h' : hlist F ls),\n    hlist_hrel R h h' ->\n    equiv_hlist R h h'.
-----
Theorem hlist_hrel_equiv : forall T (F : T -> Type) (R : forall t, F t -> F t -> Prop) ls (h h' : hlist F ls), hlist_hrel R h h' -> equiv_hlist R h h'.

*****

*****
forall (T : Type@{SerTop.848}) (F : forall _ : T, Type@{SerTop.849}) (R : forall (t : T) (_ : F t) (_ : F t), Prop) (ls : list T) (h h' : hlist@{SerTop.848 SerTop.849} F ls) (_ : hlist_hrel@{SerTop.848 SerTop.849 SerTop.849} R h h'), equiv_hlist@{SerTop.848 SerTop.849} R h h'
+++++
Proof.
-----
Theorem hlist_hrel_equiv : forall T (F : T -> Type) (R : forall t, F t -> F t -> Prop) ls (h h' : hlist F ls), hlist_hrel R h h' -> equiv_hlist R h h'.
Proof.

*****

*****
forall (T : Type@{SerTop.848}) (F : forall _ : T, Type@{SerTop.849}) (R : forall (t : T) (_ : F t) (_ : F t), Prop) (ls : list T) (h h' : hlist@{SerTop.848 SerTop.849} F ls) (_ : hlist_hrel@{SerTop.848 SerTop.849 SerTop.849} R h h'), equiv_hlist@{SerTop.848 SerTop.849} R h h'
+++++
induction 1.
-----
Theorem hlist_hrel_equiv : forall T (F : T -> Type) (R : forall t, F t -> F t -> Prop) ls (h h' : hlist F ls), hlist_hrel R h h' -> equiv_hlist R h h'.
Proof.
induction 1.

*****
R : forall (t : T) (_ : F t) (_ : F t), Prop
F : forall _ : T, Type@{SerTop.849}
T : Type@{SerTop\.848}
*****
equiv_hlist@{SerTop.848 SerTop.849} R Hnil@{SerTop.848 SerTop.849} Hnil@{SerTop.848 SerTop.849}
+++++
constructor.
-----
Theorem hlist_hrel_equiv : forall T (F : T -> Type) (R : forall t, F t -> F t -> Prop) ls (h h' : hlist F ls), hlist_hrel R h h' -> equiv_hlist R h h'.
Proof.
induction 1.

*****
IHhlist_hrel : equiv_hlist@{SerTop.848 SerTop.849} R xs ys
H0 : hlist_hrel@{SerTop.848 SerTop.849 SerTop.849} R xs ys
H : R x y
xs,ys : hlist@{SerTop.848 SerTop.849} F ts
x,y : F t
ts : list T
t : T
R : forall (t : T) (_ : F t) (_ : F t), Prop
F : forall _ : T, Type@{SerTop.849}
T : Type@{SerTop\.848}
*****
equiv_hlist@{SerTop.848 SerTop.849} R (Hcons@{SerTop.848 SerTop.849} x xs) (Hcons@{SerTop.848 SerTop.849} y ys)
+++++
constructor.
-----
Theorem hlist_hrel_equiv : forall T (F : T -> Type) (R : forall t, F t -> F t -> Prop) ls (h h' : hlist F ls), hlist_hrel R h h' -> equiv_hlist R h h'.
Proof.
induction 1.
constructor.

*****
IHhlist_hrel : equiv_hlist@{SerTop.848 SerTop.849} R xs ys
H0 : hlist_hrel@{SerTop.848 SerTop.849 SerTop.849} R xs ys
H : R x y
xs,ys : hlist@{SerTop.848 SerTop.849} F ts
x,y : F t
ts : list T
t : T
R : forall (t : T) (_ : F t) (_ : F t), Prop
F : forall _ : T, Type@{SerTop.849}
T : Type@{SerTop\.848}
*****
R x y
+++++
auto.
-----
Theorem hlist_hrel_equiv : forall T (F : T -> Type) (R : forall t, F t -> F t -> Prop) ls (h h' : hlist F ls), hlist_hrel R h h' -> equiv_hlist R h h'.
Proof.
induction 1.
constructor.

*****
IHhlist_hrel : equiv_hlist@{SerTop.848 SerTop.849} R xs ys
H0 : hlist_hrel@{SerTop.848 SerTop.849 SerTop.849} R xs ys
H : R x y
xs,ys : hlist@{SerTop.848 SerTop.849} F ts
x,y : F t
ts : list T
t : T
R : forall (t : T) (_ : F t) (_ : F t), Prop
F : forall _ : T, Type@{SerTop.849}
T : Type@{SerTop\.848}
*****
equiv_hlist@{SerTop.848 SerTop.849} R xs ys
+++++
auto.
-----
Theorem hlist_hrel_equiv : forall T (F : T -> Type) (R : forall t, F t -> F t -> Prop) ls (h h' : hlist F ls), hlist_hrel R h h' -> equiv_hlist R h h'.
Proof.
induction 1.

*****

*****

+++++
Qed.
-----
Theorem hlist_hrel_flip\n: forall T (F G : T -> Type) (R : forall t, F t -> G t -> Prop) ls\n         (h : hlist F ls) (h' : hlist G ls),\n    hlist_hrel R h h' ->\n    hlist_hrel (fun t a b => R t b a) h' h.
-----
Theorem hlist_hrel_flip : forall T (F G : T -> Type) (R : forall t, F t -> G t -> Prop) ls (h : hlist F ls) (h' : hlist G ls), hlist_hrel R h h' -> hlist_hrel (fun t a b => R t b a) h' h.

*****

*****
forall (T : Type@{SerTop.874}) (F : forall _ : T, Type@{SerTop.875}) (G : forall _ : T, Type@{SerTop.876}) (R : forall (t : T) (_ : F t) (_ : G t), Prop) (ls : list T) (h : hlist@{SerTop.874 SerTop.875} F ls) (h' : hlist@{SerTop.874 SerTop.876} G ls) (_ : hlist_hrel@{SerTop.874 SerTop.875 SerTop.876} R h h'), hlist_hrel@{SerTop.874 SerTop.876 SerTop.875} (fun (t : T) (a : G t) (b : F t) => R t b a) h' h
+++++
Proof.
-----
Theorem hlist_hrel_flip : forall T (F G : T -> Type) (R : forall t, F t -> G t -> Prop) ls (h : hlist F ls) (h' : hlist G ls), hlist_hrel R h h' -> hlist_hrel (fun t a b => R t b a) h' h.
Proof.

*****

*****
forall (T : Type@{SerTop.874}) (F : forall _ : T, Type@{SerTop.875}) (G : forall _ : T, Type@{SerTop.876}) (R : forall (t : T) (_ : F t) (_ : G t), Prop) (ls : list T) (h : hlist@{SerTop.874 SerTop.875} F ls) (h' : hlist@{SerTop.874 SerTop.876} G ls) (_ : hlist_hrel@{SerTop.874 SerTop.875 SerTop.876} R h h'), hlist_hrel@{SerTop.874 SerTop.876 SerTop.875} (fun (t : T) (a : G t) (b : F t) => R t b a) h' h
+++++
induction 1.
-----
Theorem hlist_hrel_flip : forall T (F G : T -> Type) (R : forall t, F t -> G t -> Prop) ls (h : hlist F ls) (h' : hlist G ls), hlist_hrel R h h' -> hlist_hrel (fun t a b => R t b a) h' h.
Proof.
induction 1.

*****
R : forall (t : T) (_ : F t) (_ : G t), Prop
G : forall _ : T, Type@{SerTop.876}
F : forall _ : T, Type@{SerTop.875}
T : Type@{SerTop\.874}
*****
hlist_hrel@{SerTop.874 SerTop.876 SerTop.875} (fun (t : T) (a : G t) (b : F t) => R t b a) Hnil@{SerTop.874 SerTop.876} Hnil@{SerTop.874 SerTop.875}
+++++
constructor.
-----
Theorem hlist_hrel_flip : forall T (F G : T -> Type) (R : forall t, F t -> G t -> Prop) ls (h : hlist F ls) (h' : hlist G ls), hlist_hrel R h h' -> hlist_hrel (fun t a b => R t b a) h' h.
Proof.
induction 1.

*****
IHhlist_hrel : hlist_hrel@{SerTop.874 SerTop.876 SerTop.875}\n (fun (t : T) (a : G t) (b : F t) => R t b a) ys xs
H0 : hlist_hrel@{SerTop.874 SerTop.875 SerTop.876} R xs ys
H : R x y
ys : hlist@{SerTop.874 SerTop.876} G ts
xs : hlist@{SerTop.874 SerTop.875} F ts
y : G t
x : F t
ts : list T
t : T
R : forall (t : T) (_ : F t) (_ : G t), Prop
G : forall _ : T, Type@{SerTop.876}
F : forall _ : T, Type@{SerTop.875}
T : Type@{SerTop\.874}
*****
hlist_hrel@{SerTop.874 SerTop.876 SerTop.875} (fun (t : T) (a : G t) (b : F t) => R t b a) (Hcons@{SerTop.874 SerTop.876} y ys) (Hcons@{SerTop.874 SerTop.875} x xs)
+++++
constructor.
-----
Theorem hlist_hrel_flip : forall T (F G : T -> Type) (R : forall t, F t -> G t -> Prop) ls (h : hlist F ls) (h' : hlist G ls), hlist_hrel R h h' -> hlist_hrel (fun t a b => R t b a) h' h.
Proof.
induction 1.
constructor.

*****
IHhlist_hrel : hlist_hrel@{SerTop.874 SerTop.876 SerTop.875}\n (fun (t : T) (a : G t) (b : F t) => R t b a) ys xs
H0 : hlist_hrel@{SerTop.874 SerTop.875 SerTop.876} R xs ys
H : R x y
ys : hlist@{SerTop.874 SerTop.876} G ts
xs : hlist@{SerTop.874 SerTop.875} F ts
y : G t
x : F t
ts : list T
t : T
R : forall (t : T) (_ : F t) (_ : G t), Prop
G : forall _ : T, Type@{SerTop.876}
F : forall _ : T, Type@{SerTop.875}
T : Type@{SerTop\.874}
*****
R x y
+++++
auto.
-----
Theorem hlist_hrel_flip : forall T (F G : T -> Type) (R : forall t, F t -> G t -> Prop) ls (h : hlist F ls) (h' : hlist G ls), hlist_hrel R h h' -> hlist_hrel (fun t a b => R t b a) h' h.
Proof.
induction 1.
constructor.

*****
IHhlist_hrel : hlist_hrel@{SerTop.874 SerTop.876 SerTop.875}\n (fun (t : T) (a : G t) (b : F t) => R t b a) ys xs
H0 : hlist_hrel@{SerTop.874 SerTop.875 SerTop.876} R xs ys
H : R x y
ys : hlist@{SerTop.874 SerTop.876} G ts
xs : hlist@{SerTop.874 SerTop.875} F ts
y : G t
x : F t
ts : list T
t : T
R : forall (t : T) (_ : F t) (_ : G t), Prop
G : forall _ : T, Type@{SerTop.876}
F : forall _ : T, Type@{SerTop.875}
T : Type@{SerTop\.874}
*****
hlist_hrel@{SerTop.874 SerTop.876 SerTop.875} (fun (t : T) (a : G t) (b : F t) => R t b a) ys xs
+++++
auto.
-----
Theorem hlist_hrel_flip : forall T (F G : T -> Type) (R : forall t, F t -> G t -> Prop) ls (h : hlist F ls) (h' : hlist G ls), hlist_hrel R h h' -> hlist_hrel (fun t a b => R t b a) h' h.
Proof.
induction 1.

*****

*****

+++++
Qed.
-----
