Require Import GeoCoq.Axioms.parallel_postulates.
-----
Require Import GeoCoq.Tarski_dev.Annexes.suma.
-----
Require Import GeoCoq.Tarski_dev.Ch12_parallel.
-----
Section bachmann_s_lotschnittaxiom_weak_inverse_projection_postulate.
-----
Context `{TnEQD:Tarski_neutral_dimensionless_with_decidable_point_equality}.
-----
Lemma bachmann_s_lotschnittaxiom__weak_inverse_projection_postulate :\n  bachmann_s_lotschnittaxiom -> weak_inverse_projection_postulate.
-----
Lemma bachmann_s_lotschnittaxiom__weak_inverse_projection_postulate : bachmann_s_lotschnittaxiom -> weak_inverse_projection_postulate.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : bachmann_s_lotschnittaxiom, weak_inverse_projection_postulate
+++++
Proof.
-----
Lemma bachmann_s_lotschnittaxiom__weak_inverse_projection_postulate : bachmann_s_lotschnittaxiom -> weak_inverse_projection_postulate.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : bachmann_s_lotschnittaxiom, weak_inverse_projection_postulate
+++++
intro bla.
-----
Lemma bachmann_s_lotschnittaxiom__weak_inverse_projection_postulate : bachmann_s_lotschnittaxiom -> weak_inverse_projection_postulate.
Proof.
intro bla.

*****
bla : bachmann_s_lotschnittaxiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
weak_inverse_projection_postulate
+++++
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\ Col D1 D2 I).
-----
Lemma bachmann_s_lotschnittaxiom__weak_inverse_projection_postulate : bachmann_s_lotschnittaxiom -> weak_inverse_projection_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).

*****
bla : bachmann_s_lotschnittaxiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint) (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2) (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC) (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD) (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2) (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2) (_ : not (Col IAB IAC IBD)), ex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I)), weak_inverse_projection_postulate
+++++
clear bla; intro lotschnitt.
-----
Lemma bachmann_s_lotschnittaxiom__weak_inverse_projection_postulate : bachmann_s_lotschnittaxiom -> weak_inverse_projection_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro lotschnitt.

*****
lotschnitt : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
weak_inverse_projection_postulate
+++++
intros A B C D E F P Q HAcute HPer HSuma HOut HPQ HPerP HCop.
-----
Lemma bachmann_s_lotschnittaxiom__weak_inverse_projection_postulate : bachmann_s_lotschnittaxiom -> weak_inverse_projection_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro lotschnitt.
intros A B C D E F P Q HAcute HPer HSuma HOut HPQ HPerP HCop.

*****
HCop : Coplanar A B C Q
HPerP : Per B P Q
HPQ : not (eq P Q)
HOut : Out B A P
HSuma : SumA A B C A B C D E F
HPer : Per D E F
HAcute : Acute A B C
A,B,C,D,E,F,P,Q : Tpoint
lotschnitt : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Y : Tpoint => and (Out B C Y) (Col P Q Y))
+++++
suma.assert_diffs.
-----
Lemma bachmann_s_lotschnittaxiom__weak_inverse_projection_postulate : bachmann_s_lotschnittaxiom -> weak_inverse_projection_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro lotschnitt.
intros A B C D E F P Q HAcute HPer HSuma HOut HPQ HPerP HCop.
suma.assert_diffs.

*****
H0 : not (eq D F)
H9 : not (eq E F)
H7 : not (eq D E)
H5 : not (eq B C)
H2 : not (eq P B)
H1 : not (eq A B)
H : not (eq B Q)
HCop : Coplanar A B C Q
HPerP : Per B P Q
HPQ : not (eq P Q)
HOut : Out B A P
HSuma : SumA A B C A B C D E F
HPer : Per D E F
HAcute : Acute A B C
A,B,C,D,E,F,P,Q : Tpoint
lotschnitt : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Y : Tpoint => and (Out B C Y) (Col P Q Y))
+++++
assert (HNCol : ~ Col A B C).
-----
Lemma bachmann_s_lotschnittaxiom__weak_inverse_projection_postulate : bachmann_s_lotschnittaxiom -> weak_inverse_projection_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro lotschnitt.
intros A B C D E F P Q HAcute HPer HSuma HOut HPQ HPerP HCop.
suma.assert_diffs.
assert (HNCol : ~ Col A B C).

*****
H0 : not (eq D F)
H9 : not (eq E F)
H7 : not (eq D E)
H5 : not (eq B C)
H2 : not (eq P B)
H1 : not (eq A B)
H : not (eq B Q)
HCop : Coplanar A B C Q
HPerP : Per B P Q
HPQ : not (eq P Q)
HOut : Out B A P
HSuma : SumA A B C A B C D E F
HPer : Per D E F
HAcute : Acute A B C
A,B,C,D,E,F,P,Q : Tpoint
lotschnitt : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col A B C)
+++++
intro HCol.
-----
Lemma bachmann_s_lotschnittaxiom__weak_inverse_projection_postulate : bachmann_s_lotschnittaxiom -> weak_inverse_projection_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro lotschnitt.
intros A B C D E F P Q HAcute HPer HSuma HOut HPQ HPerP HCop.
suma.assert_diffs.
assert (HNCol : ~ Col A B C).
intro HCol.

*****
HCol : Col A B C
H0 : not (eq D F)
H9 : not (eq E F)
H7 : not (eq D E)
H5 : not (eq B C)
H2 : not (eq P B)
H1 : not (eq A B)
H : not (eq B Q)
HCop : Coplanar A B C Q
HPerP : Per B P Q
HPQ : not (eq P Q)
HOut : Out B A P
HSuma : SumA A B C A B C D E F
HPer : Per D E F
HAcute : Acute A B C
A,B,C,D,E,F,P,Q : Tpoint
lotschnitt : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
apply (per_not_col D E F); auto.
-----
Lemma bachmann_s_lotschnittaxiom__weak_inverse_projection_postulate : bachmann_s_lotschnittaxiom -> weak_inverse_projection_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro lotschnitt.
intros A B C D E F P Q HAcute HPer HSuma HOut HPQ HPerP HCop.
suma.assert_diffs.
assert (HNCol : ~ Col A B C).
intro HCol.
apply (per_not_col D E F); auto.

*****
HCol : Col A B C
H0 : not (eq D F)
H9 : not (eq E F)
H7 : not (eq D E)
H5 : not (eq B C)
H2 : not (eq P B)
H1 : not (eq A B)
H : not (eq B Q)
HCop : Coplanar A B C Q
HPerP : Per B P Q
HPQ : not (eq P Q)
HOut : Out B A P
HSuma : SumA A B C A B C D E F
HPer : Per D E F
HAcute : Acute A B C
A,B,C,D,E,F,P,Q : Tpoint
lotschnitt : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col D E F
+++++
apply (col2_suma__col A B C A B C); assumption.
-----
Lemma bachmann_s_lotschnittaxiom__weak_inverse_projection_postulate : bachmann_s_lotschnittaxiom -> weak_inverse_projection_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro lotschnitt.
intros A B C D E F P Q HAcute HPer HSuma HOut HPQ HPerP HCop.
suma.assert_diffs.
assert (HNCol : ~ Col A B C).

*****
HNCol : not (Col A B C)
H0 : not (eq D F)
H9 : not (eq E F)
H7 : not (eq D E)
H5 : not (eq B C)
H2 : not (eq P B)
H1 : not (eq A B)
H : not (eq B Q)
HCop : Coplanar A B C Q
HPerP : Per B P Q
HPQ : not (eq P Q)
HOut : Out B A P
HSuma : SumA A B C A B C D E F
HPer : Per D E F
HAcute : Acute A B C
A,B,C,D,E,F,P,Q : Tpoint
lotschnitt : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Y : Tpoint => and (Out B C Y) (Col P Q Y))
+++++
assert (HNCol1 : ~ Col B C P) by (intro; apply HNCol; ColR).
-----
Lemma bachmann_s_lotschnittaxiom__weak_inverse_projection_postulate : bachmann_s_lotschnittaxiom -> weak_inverse_projection_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro lotschnitt.
intros A B C D E F P Q HAcute HPer HSuma HOut HPQ HPerP HCop.
suma.assert_diffs.
assert (HNCol : ~ Col A B C).
assert (HNCol1 : ~ Col B C P) by (intro; apply HNCol; ColR).

*****
HNCol1 : not (Col B C P)
HNCol : not (Col A B C)
H0 : not (eq D F)
H9 : not (eq E F)
H7 : not (eq D E)
H5 : not (eq B C)
H2 : not (eq P B)
H1 : not (eq A B)
H : not (eq B Q)
HCop : Coplanar A B C Q
HPerP : Per B P Q
HPQ : not (eq P Q)
HOut : Out B A P
HSuma : SumA A B C A B C D E F
HPer : Per D E F
HAcute : Acute A B C
A,B,C,D,E,F,P,Q : Tpoint
lotschnitt : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Y : Tpoint => and (Out B C Y) (Col P Q Y))
+++++
destruct (l10_6_existence_spec B C P) as [P' HP']; trivial.
-----
Lemma bachmann_s_lotschnittaxiom__weak_inverse_projection_postulate : bachmann_s_lotschnittaxiom -> weak_inverse_projection_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro lotschnitt.
intros A B C D E F P Q HAcute HPer HSuma HOut HPQ HPerP HCop.
suma.assert_diffs.
assert (HNCol : ~ Col A B C).
assert (HNCol1 : ~ Col B C P) by (intro; apply HNCol; ColR).
destruct (l10_6_existence_spec B C P) as [P' HP']; trivial.

*****
HP' : ReflectL P P' B C
P' : Tpoint
HNCol1 : not (Col B C P)
HNCol : not (Col A B C)
H0 : not (eq D F)
H9 : not (eq E F)
H7 : not (eq D E)
H5 : not (eq B C)
H2 : not (eq P B)
H1 : not (eq A B)
H : not (eq B Q)
HCop : Coplanar A B C Q
HPerP : Per B P Q
HPQ : not (eq P Q)
HOut : Out B A P
HSuma : SumA A B C A B C D E F
HPer : Per D E F
HAcute : Acute A B C
A,B,C,D,E,F,P,Q : Tpoint
lotschnitt : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Y : Tpoint => and (Out B C Y) (Col P Q Y))
+++++
assert (HP'1 : Reflect P P' B C) by (apply is_image_is_image_spec; auto).
-----
Lemma bachmann_s_lotschnittaxiom__weak_inverse_projection_postulate : bachmann_s_lotschnittaxiom -> weak_inverse_projection_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro lotschnitt.
intros A B C D E F P Q HAcute HPer HSuma HOut HPQ HPerP HCop.
suma.assert_diffs.
assert (HNCol : ~ Col A B C).
assert (HNCol1 : ~ Col B C P) by (intro; apply HNCol; ColR).
destruct (l10_6_existence_spec B C P) as [P' HP']; trivial.
assert (HP'1 : Reflect P P' B C) by (apply is_image_is_image_spec; auto).

*****
HP'1 : Reflect P P' B C
HP' : ReflectL P P' B C
P' : Tpoint
HNCol1 : not (Col B C P)
HNCol : not (Col A B C)
H0 : not (eq D F)
H9 : not (eq E F)
H7 : not (eq D E)
H5 : not (eq B C)
H2 : not (eq P B)
H1 : not (eq A B)
H : not (eq B Q)
HCop : Coplanar A B C Q
HPerP : Per B P Q
HPQ : not (eq P Q)
HOut : Out B A P
HSuma : SumA A B C A B C D E F
HPer : Per D E F
HAcute : Acute A B C
A,B,C,D,E,F,P,Q : Tpoint
lotschnitt : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Y : Tpoint => and (Out B C Y) (Col P Q Y))
+++++
assert (HNCol2 : ~ Col B C P') by (apply osym_not_col with P; trivial).
-----
Lemma bachmann_s_lotschnittaxiom__weak_inverse_projection_postulate : bachmann_s_lotschnittaxiom -> weak_inverse_projection_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro lotschnitt.
intros A B C D E F P Q HAcute HPer HSuma HOut HPQ HPerP HCop.
suma.assert_diffs.
assert (HNCol : ~ Col A B C).
assert (HNCol1 : ~ Col B C P) by (intro; apply HNCol; ColR).
destruct (l10_6_existence_spec B C P) as [P' HP']; trivial.
assert (HP'1 : Reflect P P' B C) by (apply is_image_is_image_spec; auto).
assert (HNCol2 : ~ Col B C P') by (apply osym_not_col with P; trivial).

*****
HNCol2 : not (Col B C P')
HP'1 : Reflect P P' B C
HP' : ReflectL P P' B C
P' : Tpoint
HNCol1 : not (Col B C P)
HNCol : not (Col A B C)
H0 : not (eq D F)
H9 : not (eq E F)
H7 : not (eq D E)
H5 : not (eq B C)
H2 : not (eq P B)
H1 : not (eq A B)
H : not (eq B Q)
HCop : Coplanar A B C Q
HPerP : Per B P Q
HPQ : not (eq P Q)
HOut : Out B A P
HSuma : SumA A B C A B C D E F
HPer : Per D E F
HAcute : Acute A B C
A,B,C,D,E,F,P,Q : Tpoint
lotschnitt : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Y : Tpoint => and (Out B C Y) (Col P Q Y))
+++++
destruct (l10_6_existence_spec B C Q) as [Q' HQ']; trivial.
-----
Lemma bachmann_s_lotschnittaxiom__weak_inverse_projection_postulate : bachmann_s_lotschnittaxiom -> weak_inverse_projection_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro lotschnitt.
intros A B C D E F P Q HAcute HPer HSuma HOut HPQ HPerP HCop.
suma.assert_diffs.
assert (HNCol : ~ Col A B C).
assert (HNCol1 : ~ Col B C P) by (intro; apply HNCol; ColR).
destruct (l10_6_existence_spec B C P) as [P' HP']; trivial.
assert (HP'1 : Reflect P P' B C) by (apply is_image_is_image_spec; auto).
assert (HNCol2 : ~ Col B C P') by (apply osym_not_col with P; trivial).
destruct (l10_6_existence_spec B C Q) as [Q' HQ']; trivial.

*****
HQ' : ReflectL Q Q' B C
Q' : Tpoint
HNCol2 : not (Col B C P')
HP'1 : Reflect P P' B C
HP' : ReflectL P P' B C
P' : Tpoint
HNCol1 : not (Col B C P)
HNCol : not (Col A B C)
H0 : not (eq D F)
H9 : not (eq E F)
H7 : not (eq D E)
H5 : not (eq B C)
H2 : not (eq P B)
H1 : not (eq A B)
H : not (eq B Q)
HCop : Coplanar A B C Q
HPerP : Per B P Q
HPQ : not (eq P Q)
HOut : Out B A P
HSuma : SumA A B C A B C D E F
HPer : Per D E F
HAcute : Acute A B C
A,B,C,D,E,F,P,Q : Tpoint
lotschnitt : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Y : Tpoint => and (Out B C Y) (Col P Q Y))
+++++
assert (HQ'1 : Reflect Q Q' B C) by (apply is_image_is_image_spec; auto).
-----
Lemma bachmann_s_lotschnittaxiom__weak_inverse_projection_postulate : bachmann_s_lotschnittaxiom -> weak_inverse_projection_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro lotschnitt.
intros A B C D E F P Q HAcute HPer HSuma HOut HPQ HPerP HCop.
suma.assert_diffs.
assert (HNCol : ~ Col A B C).
assert (HNCol1 : ~ Col B C P) by (intro; apply HNCol; ColR).
destruct (l10_6_existence_spec B C P) as [P' HP']; trivial.
assert (HP'1 : Reflect P P' B C) by (apply is_image_is_image_spec; auto).
assert (HNCol2 : ~ Col B C P') by (apply osym_not_col with P; trivial).
destruct (l10_6_existence_spec B C Q) as [Q' HQ']; trivial.
assert (HQ'1 : Reflect Q Q' B C) by (apply is_image_is_image_spec; auto).

*****
HQ'1 : Reflect Q Q' B C
HQ' : ReflectL Q Q' B C
Q' : Tpoint
HNCol2 : not (Col B C P')
HP'1 : Reflect P P' B C
HP' : ReflectL P P' B C
P' : Tpoint
HNCol1 : not (Col B C P)
HNCol : not (Col A B C)
H0 : not (eq D F)
H9 : not (eq E F)
H7 : not (eq D E)
H5 : not (eq B C)
H2 : not (eq P B)
H1 : not (eq A B)
H : not (eq B Q)
HCop : Coplanar A B C Q
HPerP : Per B P Q
HPQ : not (eq P Q)
HOut : Out B A P
HSuma : SumA A B C A B C D E F
HPer : Per D E F
HAcute : Acute A B C
A,B,C,D,E,F,P,Q : Tpoint
lotschnitt : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Y : Tpoint => and (Out B C Y) (Col P Q Y))
+++++
assert_diffs.
-----
Lemma bachmann_s_lotschnittaxiom__weak_inverse_projection_postulate : bachmann_s_lotschnittaxiom -> weak_inverse_projection_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro lotschnitt.
intros A B C D E F P Q HAcute HPer HSuma HOut HPQ HPerP HCop.
suma.assert_diffs.
assert (HNCol : ~ Col A B C).
assert (HNCol1 : ~ Col B C P) by (intro; apply HNCol; ColR).
destruct (l10_6_existence_spec B C P) as [P' HP']; trivial.
assert (HP'1 : Reflect P P' B C) by (apply is_image_is_image_spec; auto).
assert (HNCol2 : ~ Col B C P') by (apply osym_not_col with P; trivial).
destruct (l10_6_existence_spec B C Q) as [Q' HQ']; trivial.
assert (HQ'1 : Reflect Q Q' B C) by (apply is_image_is_image_spec; auto).
assert_diffs.

*****
H14 : not (eq A C)
H8 : not (eq C P)
H11 : not (eq B P')
H6 : not (eq C P')
HQ'1 : Reflect Q Q' B C
HQ' : ReflectL Q Q' B C
Q' : Tpoint
HNCol2 : not (Col B C P')
HP'1 : Reflect P P' B C
HP' : ReflectL P P' B C
P' : Tpoint
HNCol1 : not (Col B C P)
HNCol : not (Col A B C)
H0 : not (eq D F)
H9 : not (eq E F)
H7 : not (eq D E)
H5 : not (eq B C)
H2 : not (eq P B)
H1 : not (eq A B)
H : not (eq B Q)
HCop : Coplanar A B C Q
HPerP : Per B P Q
HPQ : not (eq P Q)
HOut : Out B A P
HSuma : SumA A B C A B C D E F
HPer : Per D E F
HAcute : Acute A B C
A,B,C,D,E,F,P,Q : Tpoint
lotschnitt : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Y : Tpoint => and (Out B C Y) (Col P Q Y))
+++++
assert (P' <> Q').
-----
Lemma bachmann_s_lotschnittaxiom__weak_inverse_projection_postulate : bachmann_s_lotschnittaxiom -> weak_inverse_projection_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro lotschnitt.
intros A B C D E F P Q HAcute HPer HSuma HOut HPQ HPerP HCop.
suma.assert_diffs.
assert (HNCol : ~ Col A B C).
assert (HNCol1 : ~ Col B C P) by (intro; apply HNCol; ColR).
destruct (l10_6_existence_spec B C P) as [P' HP']; trivial.
assert (HP'1 : Reflect P P' B C) by (apply is_image_is_image_spec; auto).
assert (HNCol2 : ~ Col B C P') by (apply osym_not_col with P; trivial).
destruct (l10_6_existence_spec B C Q) as [Q' HQ']; trivial.
assert (HQ'1 : Reflect Q Q' B C) by (apply is_image_is_image_spec; auto).
assert_diffs.
assert (P' <> Q').

*****
H14 : not (eq A C)
H8 : not (eq C P)
H11 : not (eq B P')
H6 : not (eq C P')
HQ'1 : Reflect Q Q' B C
HQ' : ReflectL Q Q' B C
Q' : Tpoint
HNCol2 : not (Col B C P')
HP'1 : Reflect P P' B C
HP' : ReflectL P P' B C
P' : Tpoint
HNCol1 : not (Col B C P)
HNCol : not (Col A B C)
H0 : not (eq D F)
H9 : not (eq E F)
H7 : not (eq D E)
H5 : not (eq B C)
H2 : not (eq P B)
H1 : not (eq A B)
H : not (eq B Q)
HCop : Coplanar A B C Q
HPerP : Per B P Q
HPQ : not (eq P Q)
HOut : Out B A P
HSuma : SumA A B C A B C D E F
HPer : Per D E F
HAcute : Acute A B C
A,B,C,D,E,F,P,Q : Tpoint
lotschnitt : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq P' Q')
+++++
intro; subst Q'; assert (P = Q) by (apply (l10_2_uniqueness B C P'); assumption); auto.
-----
Lemma bachmann_s_lotschnittaxiom__weak_inverse_projection_postulate : bachmann_s_lotschnittaxiom -> weak_inverse_projection_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro lotschnitt.
intros A B C D E F P Q HAcute HPer HSuma HOut HPQ HPerP HCop.
suma.assert_diffs.
assert (HNCol : ~ Col A B C).
assert (HNCol1 : ~ Col B C P) by (intro; apply HNCol; ColR).
destruct (l10_6_existence_spec B C P) as [P' HP']; trivial.
assert (HP'1 : Reflect P P' B C) by (apply is_image_is_image_spec; auto).
assert (HNCol2 : ~ Col B C P') by (apply osym_not_col with P; trivial).
destruct (l10_6_existence_spec B C Q) as [Q' HQ']; trivial.
assert (HQ'1 : Reflect Q Q' B C) by (apply is_image_is_image_spec; auto).
assert_diffs.
assert (P' <> Q').
intro; subst Q'; assert (P = Q) by (apply (l10_2_uniqueness B C P'); assumption); auto.

*****
H3 : not (eq P' Q')
H14 : not (eq A C)
H8 : not (eq C P)
H11 : not (eq B P')
H6 : not (eq C P')
HQ'1 : Reflect Q Q' B C
HQ' : ReflectL Q Q' B C
Q' : Tpoint
HNCol2 : not (Col B C P')
HP'1 : Reflect P P' B C
HP' : ReflectL P P' B C
P' : Tpoint
HNCol1 : not (Col B C P)
HNCol : not (Col A B C)
H0 : not (eq D F)
H9 : not (eq E F)
H7 : not (eq D E)
H5 : not (eq B C)
H2 : not (eq P B)
H1 : not (eq A B)
H : not (eq B Q)
HCop : Coplanar A B C Q
HPerP : Per B P Q
HPQ : not (eq P Q)
HOut : Out B A P
HSuma : SumA A B C A B C D E F
HPer : Per D E F
HAcute : Acute A B C
A,B,C,D,E,F,P,Q : Tpoint
lotschnitt : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Y : Tpoint => and (Out B C Y) (Col P Q Y))
+++++
apply l6_6 in HOut.
-----
Lemma bachmann_s_lotschnittaxiom__weak_inverse_projection_postulate : bachmann_s_lotschnittaxiom -> weak_inverse_projection_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro lotschnitt.
intros A B C D E F P Q HAcute HPer HSuma HOut HPQ HPerP HCop.
suma.assert_diffs.
assert (HNCol : ~ Col A B C).
assert (HNCol1 : ~ Col B C P) by (intro; apply HNCol; ColR).
destruct (l10_6_existence_spec B C P) as [P' HP']; trivial.
assert (HP'1 : Reflect P P' B C) by (apply is_image_is_image_spec; auto).
assert (HNCol2 : ~ Col B C P') by (apply osym_not_col with P; trivial).
destruct (l10_6_existence_spec B C Q) as [Q' HQ']; trivial.
assert (HQ'1 : Reflect Q Q' B C) by (apply is_image_is_image_spec; auto).
assert_diffs.
assert (P' <> Q').
intro; subst Q'; assert (P = Q) by (apply (l10_2_uniqueness B C P'); assumption); auto.
apply l6_6 in HOut.

*****
H3 : not (eq P' Q')
H14 : not (eq A C)
H8 : not (eq C P)
H11 : not (eq B P')
H6 : not (eq C P')
HQ'1 : Reflect Q Q' B C
HQ' : ReflectL Q Q' B C
Q' : Tpoint
HNCol2 : not (Col B C P')
HP'1 : Reflect P P' B C
HP' : ReflectL P P' B C
P' : Tpoint
HNCol1 : not (Col B C P)
HNCol : not (Col A B C)
H0 : not (eq D F)
H9 : not (eq E F)
H7 : not (eq D E)
H5 : not (eq B C)
H2 : not (eq P B)
H1 : not (eq A B)
H : not (eq B Q)
HCop : Coplanar A B C Q
HPerP : Per B P Q
HPQ : not (eq P Q)
HOut : Out B P A
HSuma : SumA A B C A B C D E F
HPer : Per D E F
HAcute : Acute A B C
A,B,C,D,E,F,P,Q : Tpoint
lotschnitt : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Y : Tpoint => and (Out B C Y) (Col P Q Y))
+++++
assert (HCongA : CongA C B P' A B C).
-----
Lemma bachmann_s_lotschnittaxiom__weak_inverse_projection_postulate : bachmann_s_lotschnittaxiom -> weak_inverse_projection_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro lotschnitt.
intros A B C D E F P Q HAcute HPer HSuma HOut HPQ HPerP HCop.
suma.assert_diffs.
assert (HNCol : ~ Col A B C).
assert (HNCol1 : ~ Col B C P) by (intro; apply HNCol; ColR).
destruct (l10_6_existence_spec B C P) as [P' HP']; trivial.
assert (HP'1 : Reflect P P' B C) by (apply is_image_is_image_spec; auto).
assert (HNCol2 : ~ Col B C P') by (apply osym_not_col with P; trivial).
destruct (l10_6_existence_spec B C Q) as [Q' HQ']; trivial.
assert (HQ'1 : Reflect Q Q' B C) by (apply is_image_is_image_spec; auto).
assert_diffs.
assert (P' <> Q').
intro; subst Q'; assert (P = Q) by (apply (l10_2_uniqueness B C P'); assumption); auto.
apply l6_6 in HOut.
assert (HCongA : CongA C B P' A B C).

*****
H3 : not (eq P' Q')
H14 : not (eq A C)
H8 : not (eq C P)
H11 : not (eq B P')
H6 : not (eq C P')
HQ'1 : Reflect Q Q' B C
HQ' : ReflectL Q Q' B C
Q' : Tpoint
HNCol2 : not (Col B C P')
HP'1 : Reflect P P' B C
HP' : ReflectL P P' B C
P' : Tpoint
HNCol1 : not (Col B C P)
HNCol : not (Col A B C)
H0 : not (eq D F)
H9 : not (eq E F)
H7 : not (eq D E)
H5 : not (eq B C)
H2 : not (eq P B)
H1 : not (eq A B)
H : not (eq B Q)
HCop : Coplanar A B C Q
HPerP : Per B P Q
HPQ : not (eq P Q)
HOut : Out B P A
HSuma : SumA A B C A B C D E F
HPer : Per D E F
HAcute : Acute A B C
A,B,C,D,E,F,P,Q : Tpoint
lotschnitt : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
CongA C B P' A B C
+++++
apply out_conga with C P' P C; try (apply out_trivial); auto.
-----
Lemma bachmann_s_lotschnittaxiom__weak_inverse_projection_postulate : bachmann_s_lotschnittaxiom -> weak_inverse_projection_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro lotschnitt.
intros A B C D E F P Q HAcute HPer HSuma HOut HPQ HPerP HCop.
suma.assert_diffs.
assert (HNCol : ~ Col A B C).
assert (HNCol1 : ~ Col B C P) by (intro; apply HNCol; ColR).
destruct (l10_6_existence_spec B C P) as [P' HP']; trivial.
assert (HP'1 : Reflect P P' B C) by (apply is_image_is_image_spec; auto).
assert (HNCol2 : ~ Col B C P') by (apply osym_not_col with P; trivial).
destruct (l10_6_existence_spec B C Q) as [Q' HQ']; trivial.
assert (HQ'1 : Reflect Q Q' B C) by (apply is_image_is_image_spec; auto).
assert_diffs.
assert (P' <> Q').
intro; subst Q'; assert (P = Q) by (apply (l10_2_uniqueness B C P'); assumption); auto.
apply l6_6 in HOut.
assert (HCongA : CongA C B P' A B C).
apply out_conga with C P' P C; try (apply out_trivial); auto.

*****
H3 : not (eq P' Q')
H14 : not (eq A C)
H8 : not (eq C P)
H11 : not (eq B P')
H6 : not (eq C P')
HQ'1 : Reflect Q Q' B C
HQ' : ReflectL Q Q' B C
Q' : Tpoint
HNCol2 : not (Col B C P')
HP'1 : Reflect P P' B C
HP' : ReflectL P P' B C
P' : Tpoint
HNCol1 : not (Col B C P)
HNCol : not (Col A B C)
H0 : not (eq D F)
H9 : not (eq E F)
H7 : not (eq D E)
H5 : not (eq B C)
H2 : not (eq P B)
H1 : not (eq A B)
H : not (eq B Q)
HCop : Coplanar A B C Q
HPerP : Per B P Q
HPQ : not (eq P Q)
HOut : Out B P A
HSuma : SumA A B C A B C D E F
HPer : Per D E F
HAcute : Acute A B C
A,B,C,D,E,F,P,Q : Tpoint
lotschnitt : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
CongA C B P' P B C
+++++
apply conga_sym, conga_left_comm, reflectl__conga; auto.
-----
Lemma bachmann_s_lotschnittaxiom__weak_inverse_projection_postulate : bachmann_s_lotschnittaxiom -> weak_inverse_projection_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro lotschnitt.
intros A B C D E F P Q HAcute HPer HSuma HOut HPQ HPerP HCop.
suma.assert_diffs.
assert (HNCol : ~ Col A B C).
assert (HNCol1 : ~ Col B C P) by (intro; apply HNCol; ColR).
destruct (l10_6_existence_spec B C P) as [P' HP']; trivial.
assert (HP'1 : Reflect P P' B C) by (apply is_image_is_image_spec; auto).
assert (HNCol2 : ~ Col B C P') by (apply osym_not_col with P; trivial).
destruct (l10_6_existence_spec B C Q) as [Q' HQ']; trivial.
assert (HQ'1 : Reflect Q Q' B C) by (apply is_image_is_image_spec; auto).
assert_diffs.
assert (P' <> Q').
intro; subst Q'; assert (P = Q) by (apply (l10_2_uniqueness B C P'); assumption); auto.
apply l6_6 in HOut.
assert (HCongA : CongA C B P' A B C).
apply out_conga with C P' P C; try (apply out_trivial); auto.
apply conga_sym, conga_left_comm, reflectl__conga; auto.

*****
H3 : not (eq P' Q')
H14 : not (eq A C)
H8 : not (eq C P)
H11 : not (eq B P')
H6 : not (eq C P')
HQ'1 : Reflect Q Q' B C
HQ' : ReflectL Q Q' B C
Q' : Tpoint
HNCol2 : not (Col B C P')
HP'1 : Reflect P P' B C
HP' : ReflectL P P' B C
P' : Tpoint
HNCol1 : not (Col B C P)
HNCol : not (Col A B C)
H0 : not (eq D F)
H9 : not (eq E F)
H7 : not (eq D E)
H5 : not (eq B C)
H2 : not (eq P B)
H1 : not (eq A B)
H : not (eq B Q)
HCop : Coplanar A B C Q
HPerP : Per B P Q
HPQ : not (eq P Q)
HOut : Out B P A
HSuma : SumA A B C A B C D E F
HPer : Per D E F
HAcute : Acute A B C
A,B,C,D,E,F,P,Q : Tpoint
lotschnitt : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ReflectL P P' C B
+++++
apply is_image_spec_rev, HP'.
-----
Lemma bachmann_s_lotschnittaxiom__weak_inverse_projection_postulate : bachmann_s_lotschnittaxiom -> weak_inverse_projection_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro lotschnitt.
intros A B C D E F P Q HAcute HPer HSuma HOut HPQ HPerP HCop.
suma.assert_diffs.
assert (HNCol : ~ Col A B C).
assert (HNCol1 : ~ Col B C P) by (intro; apply HNCol; ColR).
destruct (l10_6_existence_spec B C P) as [P' HP']; trivial.
assert (HP'1 : Reflect P P' B C) by (apply is_image_is_image_spec; auto).
assert (HNCol2 : ~ Col B C P') by (apply osym_not_col with P; trivial).
destruct (l10_6_existence_spec B C Q) as [Q' HQ']; trivial.
assert (HQ'1 : Reflect Q Q' B C) by (apply is_image_is_image_spec; auto).
assert_diffs.
assert (P' <> Q').
intro; subst Q'; assert (P = Q) by (apply (l10_2_uniqueness B C P'); assumption); auto.
apply l6_6 in HOut.
assert (HCongA : CongA C B P' A B C).
apply out_conga with C P' P C; try (apply out_trivial); auto.
apply conga_sym, conga_left_comm, reflectl__conga; auto.
apply is_image_spec_rev, HP'.

*****
HCongA : CongA C B P' A B C
H3 : not (eq P' Q')
H14 : not (eq A C)
H8 : not (eq C P)
H11 : not (eq B P')
H6 : not (eq C P')
HQ'1 : Reflect Q Q' B C
HQ' : ReflectL Q Q' B C
Q' : Tpoint
HNCol2 : not (Col B C P')
HP'1 : Reflect P P' B C
HP' : ReflectL P P' B C
P' : Tpoint
HNCol1 : not (Col B C P)
HNCol : not (Col A B C)
H0 : not (eq D F)
H9 : not (eq E F)
H7 : not (eq D E)
H5 : not (eq B C)
H2 : not (eq P B)
H1 : not (eq A B)
H : not (eq B Q)
HCop : Coplanar A B C Q
HPerP : Per B P Q
HPQ : not (eq P Q)
HOut : Out B P A
HSuma : SumA A B C A B C D E F
HPer : Per D E F
HAcute : Acute A B C
A,B,C,D,E,F,P,Q : Tpoint
lotschnitt : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Y : Tpoint => and (Out B C Y) (Col P Q Y))
+++++
assert (HTS : TS B C P P').
-----
Lemma bachmann_s_lotschnittaxiom__weak_inverse_projection_postulate : bachmann_s_lotschnittaxiom -> weak_inverse_projection_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro lotschnitt.
intros A B C D E F P Q HAcute HPer HSuma HOut HPQ HPerP HCop.
suma.assert_diffs.
assert (HNCol : ~ Col A B C).
assert (HNCol1 : ~ Col B C P) by (intro; apply HNCol; ColR).
destruct (l10_6_existence_spec B C P) as [P' HP']; trivial.
assert (HP'1 : Reflect P P' B C) by (apply is_image_is_image_spec; auto).
assert (HNCol2 : ~ Col B C P') by (apply osym_not_col with P; trivial).
destruct (l10_6_existence_spec B C Q) as [Q' HQ']; trivial.
assert (HQ'1 : Reflect Q Q' B C) by (apply is_image_is_image_spec; auto).
assert_diffs.
assert (P' <> Q').
intro; subst Q'; assert (P = Q) by (apply (l10_2_uniqueness B C P'); assumption); auto.
apply l6_6 in HOut.
assert (HCongA : CongA C B P' A B C).
apply out_conga with C P' P C; try (apply out_trivial); auto.
apply conga_sym, conga_left_comm, reflectl__conga; auto.
apply is_image_spec_rev, HP'.
assert (HTS : TS B C P P').

*****
HCongA : CongA C B P' A B C
H3 : not (eq P' Q')
H14 : not (eq A C)
H8 : not (eq C P)
H11 : not (eq B P')
H6 : not (eq C P')
HQ'1 : Reflect Q Q' B C
HQ' : ReflectL Q Q' B C
Q' : Tpoint
HNCol2 : not (Col B C P')
HP'1 : Reflect P P' B C
HP' : ReflectL P P' B C
P' : Tpoint
HNCol1 : not (Col B C P)
HNCol : not (Col A B C)
H0 : not (eq D F)
H9 : not (eq E F)
H7 : not (eq D E)
H5 : not (eq B C)
H2 : not (eq P B)
H1 : not (eq A B)
H : not (eq B Q)
HCop : Coplanar A B C Q
HPerP : Per B P Q
HPQ : not (eq P Q)
HOut : Out B P A
HSuma : SumA A B C A B C D E F
HPer : Per D E F
HAcute : Acute A B C
A,B,C,D,E,F,P,Q : Tpoint
lotschnitt : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
TS B C P P'
+++++
repeat split; Col; destruct HP' as [[X [HX1 HX2]] _]; exists X; split; Col; Between.
-----
Lemma bachmann_s_lotschnittaxiom__weak_inverse_projection_postulate : bachmann_s_lotschnittaxiom -> weak_inverse_projection_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro lotschnitt.
intros A B C D E F P Q HAcute HPer HSuma HOut HPQ HPerP HCop.
suma.assert_diffs.
assert (HNCol : ~ Col A B C).
assert (HNCol1 : ~ Col B C P) by (intro; apply HNCol; ColR).
destruct (l10_6_existence_spec B C P) as [P' HP']; trivial.
assert (HP'1 : Reflect P P' B C) by (apply is_image_is_image_spec; auto).
assert (HNCol2 : ~ Col B C P') by (apply osym_not_col with P; trivial).
destruct (l10_6_existence_spec B C Q) as [Q' HQ']; trivial.
assert (HQ'1 : Reflect Q Q' B C) by (apply is_image_is_image_spec; auto).
assert_diffs.
assert (P' <> Q').
intro; subst Q'; assert (P = Q) by (apply (l10_2_uniqueness B C P'); assumption); auto.
apply l6_6 in HOut.
assert (HCongA : CongA C B P' A B C).
apply out_conga with C P' P C; try (apply out_trivial); auto.
apply conga_sym, conga_left_comm, reflectl__conga; auto.
apply is_image_spec_rev, HP'.
assert (HTS : TS B C P P').
repeat split; Col; destruct HP' as [[X [HX1 HX2]] _]; exists X; split; Col; Between.

*****
HTS : TS B C P P'
HCongA : CongA C B P' A B C
H3 : not (eq P' Q')
H14 : not (eq A C)
H8 : not (eq C P)
H11 : not (eq B P')
H6 : not (eq C P')
HQ'1 : Reflect Q Q' B C
HQ' : ReflectL Q Q' B C
Q' : Tpoint
HNCol2 : not (Col B C P')
HP'1 : Reflect P P' B C
HP' : ReflectL P P' B C
P' : Tpoint
HNCol1 : not (Col B C P)
HNCol : not (Col A B C)
H0 : not (eq D F)
H9 : not (eq E F)
H7 : not (eq D E)
H5 : not (eq B C)
H2 : not (eq P B)
H1 : not (eq A B)
H : not (eq B Q)
HCop : Coplanar A B C Q
HPerP : Per B P Q
HPQ : not (eq P Q)
HOut : Out B P A
HSuma : SumA A B C A B C D E F
HPer : Per D E F
HAcute : Acute A B C
A,B,C,D,E,F,P,Q : Tpoint
lotschnitt : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Y : Tpoint => and (Out B C Y) (Col P Q Y))
+++++
assert (HPer1 : Per A B P').
-----
Lemma bachmann_s_lotschnittaxiom__weak_inverse_projection_postulate : bachmann_s_lotschnittaxiom -> weak_inverse_projection_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro lotschnitt.
intros A B C D E F P Q HAcute HPer HSuma HOut HPQ HPerP HCop.
suma.assert_diffs.
assert (HNCol : ~ Col A B C).
assert (HNCol1 : ~ Col B C P) by (intro; apply HNCol; ColR).
destruct (l10_6_existence_spec B C P) as [P' HP']; trivial.
assert (HP'1 : Reflect P P' B C) by (apply is_image_is_image_spec; auto).
assert (HNCol2 : ~ Col B C P') by (apply osym_not_col with P; trivial).
destruct (l10_6_existence_spec B C Q) as [Q' HQ']; trivial.
assert (HQ'1 : Reflect Q Q' B C) by (apply is_image_is_image_spec; auto).
assert_diffs.
assert (P' <> Q').
intro; subst Q'; assert (P = Q) by (apply (l10_2_uniqueness B C P'); assumption); auto.
apply l6_6 in HOut.
assert (HCongA : CongA C B P' A B C).
apply out_conga with C P' P C; try (apply out_trivial); auto.
apply conga_sym, conga_left_comm, reflectl__conga; auto.
apply is_image_spec_rev, HP'.
assert (HTS : TS B C P P').
repeat split; Col; destruct HP' as [[X [HX1 HX2]] _]; exists X; split; Col; Between.
assert (HPer1 : Per A B P').

*****
HTS : TS B C P P'
HCongA : CongA C B P' A B C
H3 : not (eq P' Q')
H14 : not (eq A C)
H8 : not (eq C P)
H11 : not (eq B P')
H6 : not (eq C P')
HQ'1 : Reflect Q Q' B C
HQ' : ReflectL Q Q' B C
Q' : Tpoint
HNCol2 : not (Col B C P')
HP'1 : Reflect P P' B C
HP' : ReflectL P P' B C
P' : Tpoint
HNCol1 : not (Col B C P)
HNCol : not (Col A B C)
H0 : not (eq D F)
H9 : not (eq E F)
H7 : not (eq D E)
H5 : not (eq B C)
H2 : not (eq P B)
H1 : not (eq A B)
H : not (eq B Q)
HCop : Coplanar A B C Q
HPerP : Per B P Q
HPQ : not (eq P Q)
HOut : Out B P A
HSuma : SumA A B C A B C D E F
HPer : Per D E F
HAcute : Acute A B C
A,B,C,D,E,F,P,Q : Tpoint
lotschnitt : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Per A B P'
+++++
apply l11_17 with D E F; trivial.
-----
Lemma bachmann_s_lotschnittaxiom__weak_inverse_projection_postulate : bachmann_s_lotschnittaxiom -> weak_inverse_projection_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro lotschnitt.
intros A B C D E F P Q HAcute HPer HSuma HOut HPQ HPerP HCop.
suma.assert_diffs.
assert (HNCol : ~ Col A B C).
assert (HNCol1 : ~ Col B C P) by (intro; apply HNCol; ColR).
destruct (l10_6_existence_spec B C P) as [P' HP']; trivial.
assert (HP'1 : Reflect P P' B C) by (apply is_image_is_image_spec; auto).
assert (HNCol2 : ~ Col B C P') by (apply osym_not_col with P; trivial).
destruct (l10_6_existence_spec B C Q) as [Q' HQ']; trivial.
assert (HQ'1 : Reflect Q Q' B C) by (apply is_image_is_image_spec; auto).
assert_diffs.
assert (P' <> Q').
intro; subst Q'; assert (P = Q) by (apply (l10_2_uniqueness B C P'); assumption); auto.
apply l6_6 in HOut.
assert (HCongA : CongA C B P' A B C).
apply out_conga with C P' P C; try (apply out_trivial); auto.
apply conga_sym, conga_left_comm, reflectl__conga; auto.
apply is_image_spec_rev, HP'.
assert (HTS : TS B C P P').
repeat split; Col; destruct HP' as [[X [HX1 HX2]] _]; exists X; split; Col; Between.
assert (HPer1 : Per A B P').
apply l11_17 with D E F; trivial.

*****
HTS : TS B C P P'
HCongA : CongA C B P' A B C
H3 : not (eq P' Q')
H14 : not (eq A C)
H8 : not (eq C P)
H11 : not (eq B P')
H6 : not (eq C P')
HQ'1 : Reflect Q Q' B C
HQ' : ReflectL Q Q' B C
Q' : Tpoint
HNCol2 : not (Col B C P')
HP'1 : Reflect P P' B C
HP' : ReflectL P P' B C
P' : Tpoint
HNCol1 : not (Col B C P)
HNCol : not (Col A B C)
H0 : not (eq D F)
H9 : not (eq E F)
H7 : not (eq D E)
H5 : not (eq B C)
H2 : not (eq P B)
H1 : not (eq A B)
H : not (eq B Q)
HCop : Coplanar A B C Q
HPerP : Per B P Q
HPQ : not (eq P Q)
HOut : Out B P A
HSuma : SumA A B C A B C D E F
HPer : Per D E F
HAcute : Acute A B C
A,B,C,D,E,F,P,Q : Tpoint
lotschnitt : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
CongA D E F A B P'
+++++
apply (suma2__conga A B C A B C); trivial.
-----
Lemma bachmann_s_lotschnittaxiom__weak_inverse_projection_postulate : bachmann_s_lotschnittaxiom -> weak_inverse_projection_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro lotschnitt.
intros A B C D E F P Q HAcute HPer HSuma HOut HPQ HPerP HCop.
suma.assert_diffs.
assert (HNCol : ~ Col A B C).
assert (HNCol1 : ~ Col B C P) by (intro; apply HNCol; ColR).
destruct (l10_6_existence_spec B C P) as [P' HP']; trivial.
assert (HP'1 : Reflect P P' B C) by (apply is_image_is_image_spec; auto).
assert (HNCol2 : ~ Col B C P') by (apply osym_not_col with P; trivial).
destruct (l10_6_existence_spec B C Q) as [Q' HQ']; trivial.
assert (HQ'1 : Reflect Q Q' B C) by (apply is_image_is_image_spec; auto).
assert_diffs.
assert (P' <> Q').
intro; subst Q'; assert (P = Q) by (apply (l10_2_uniqueness B C P'); assumption); auto.
apply l6_6 in HOut.
assert (HCongA : CongA C B P' A B C).
apply out_conga with C P' P C; try (apply out_trivial); auto.
apply conga_sym, conga_left_comm, reflectl__conga; auto.
apply is_image_spec_rev, HP'.
assert (HTS : TS B C P P').
repeat split; Col; destruct HP' as [[X [HX1 HX2]] _]; exists X; split; Col; Between.
assert (HPer1 : Per A B P').
apply l11_17 with D E F; trivial.
apply (suma2__conga A B C A B C); trivial.

*****
HTS : TS B C P P'
HCongA : CongA C B P' A B C
H3 : not (eq P' Q')
H14 : not (eq A C)
H8 : not (eq C P)
H11 : not (eq B P')
H6 : not (eq C P')
HQ'1 : Reflect Q Q' B C
HQ' : ReflectL Q Q' B C
Q' : Tpoint
HNCol2 : not (Col B C P')
HP'1 : Reflect P P' B C
HP' : ReflectL P P' B C
P' : Tpoint
HNCol1 : not (Col B C P)
HNCol : not (Col A B C)
H0 : not (eq D F)
H9 : not (eq E F)
H7 : not (eq D E)
H5 : not (eq B C)
H2 : not (eq P B)
H1 : not (eq A B)
H : not (eq B Q)
HCop : Coplanar A B C Q
HPerP : Per B P Q
HPQ : not (eq P Q)
HOut : Out B P A
HSuma : SumA A B C A B C D E F
HPer : Per D E F
HAcute : Acute A B C
A,B,C,D,E,F,P,Q : Tpoint
lotschnitt : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
SumA A B C A B C A B P'
+++++
apply conga3_suma__suma with A B C C B P' A B P'; CongA.
-----
Lemma bachmann_s_lotschnittaxiom__weak_inverse_projection_postulate : bachmann_s_lotschnittaxiom -> weak_inverse_projection_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro lotschnitt.
intros A B C D E F P Q HAcute HPer HSuma HOut HPQ HPerP HCop.
suma.assert_diffs.
assert (HNCol : ~ Col A B C).
assert (HNCol1 : ~ Col B C P) by (intro; apply HNCol; ColR).
destruct (l10_6_existence_spec B C P) as [P' HP']; trivial.
assert (HP'1 : Reflect P P' B C) by (apply is_image_is_image_spec; auto).
assert (HNCol2 : ~ Col B C P') by (apply osym_not_col with P; trivial).
destruct (l10_6_existence_spec B C Q) as [Q' HQ']; trivial.
assert (HQ'1 : Reflect Q Q' B C) by (apply is_image_is_image_spec; auto).
assert_diffs.
assert (P' <> Q').
intro; subst Q'; assert (P = Q) by (apply (l10_2_uniqueness B C P'); assumption); auto.
apply l6_6 in HOut.
assert (HCongA : CongA C B P' A B C).
apply out_conga with C P' P C; try (apply out_trivial); auto.
apply conga_sym, conga_left_comm, reflectl__conga; auto.
apply is_image_spec_rev, HP'.
assert (HTS : TS B C P P').
repeat split; Col; destruct HP' as [[X [HX1 HX2]] _]; exists X; split; Col; Between.
assert (HPer1 : Per A B P').
apply l11_17 with D E F; trivial.
apply (suma2__conga A B C A B C); trivial.
apply conga3_suma__suma with A B C C B P' A B P'; CongA.

*****
HTS : TS B C P P'
HCongA : CongA C B P' A B C
H3 : not (eq P' Q')
H14 : not (eq A C)
H8 : not (eq C P)
H11 : not (eq B P')
H6 : not (eq C P')
HQ'1 : Reflect Q Q' B C
HQ' : ReflectL Q Q' B C
Q' : Tpoint
HNCol2 : not (Col B C P')
HP'1 : Reflect P P' B C
HP' : ReflectL P P' B C
P' : Tpoint
HNCol1 : not (Col B C P)
HNCol : not (Col A B C)
H0 : not (eq D F)
H9 : not (eq E F)
H7 : not (eq D E)
H5 : not (eq B C)
H2 : not (eq P B)
H1 : not (eq A B)
H : not (eq B Q)
HCop : Coplanar A B C Q
HPerP : Per B P Q
HPQ : not (eq P Q)
HOut : Out B P A
HSuma : SumA A B C A B C D E F
HPer : Per D E F
HAcute : Acute A B C
A,B,C,D,E,F,P,Q : Tpoint
lotschnitt : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
SumA A B C C B P' A B P'
+++++
exists P'; assert_diffs; repeat (split; CongA).
-----
Lemma bachmann_s_lotschnittaxiom__weak_inverse_projection_postulate : bachmann_s_lotschnittaxiom -> weak_inverse_projection_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro lotschnitt.
intros A B C D E F P Q HAcute HPer HSuma HOut HPQ HPerP HCop.
suma.assert_diffs.
assert (HNCol : ~ Col A B C).
assert (HNCol1 : ~ Col B C P) by (intro; apply HNCol; ColR).
destruct (l10_6_existence_spec B C P) as [P' HP']; trivial.
assert (HP'1 : Reflect P P' B C) by (apply is_image_is_image_spec; auto).
assert (HNCol2 : ~ Col B C P') by (apply osym_not_col with P; trivial).
destruct (l10_6_existence_spec B C Q) as [Q' HQ']; trivial.
assert (HQ'1 : Reflect Q Q' B C) by (apply is_image_is_image_spec; auto).
assert_diffs.
assert (P' <> Q').
intro; subst Q'; assert (P = Q) by (apply (l10_2_uniqueness B C P'); assumption); auto.
apply l6_6 in HOut.
assert (HCongA : CongA C B P' A B C).
apply out_conga with C P' P C; try (apply out_trivial); auto.
apply conga_sym, conga_left_comm, reflectl__conga; auto.
apply is_image_spec_rev, HP'.
assert (HTS : TS B C P P').
repeat split; Col; destruct HP' as [[X [HX1 HX2]] _]; exists X; split; Col; Between.
assert (HPer1 : Per A B P').
apply l11_17 with D E F; trivial.
apply (suma2__conga A B C A B C); trivial.
apply conga3_suma__suma with A B C C B P' A B P'; CongA.
exists P'; assert_diffs; repeat (split; CongA).

*****
H18 : not (eq P P')
HTS : TS B C P P'
HCongA : CongA C B P' A B C
H3 : not (eq P' Q')
H14 : not (eq A C)
H8 : not (eq C P)
H11 : not (eq B P')
H6 : not (eq C P')
HQ'1 : Reflect Q Q' B C
HQ' : ReflectL Q Q' B C
Q' : Tpoint
HNCol2 : not (Col B C P')
HP'1 : Reflect P P' B C
HP' : ReflectL P P' B C
P' : Tpoint
HNCol1 : not (Col B C P)
HNCol : not (Col A B C)
H0 : not (eq D F)
H9 : not (eq E F)
H7 : not (eq D E)
H5 : not (eq B C)
H2 : not (eq P B)
H1 : not (eq A B)
H : not (eq B Q)
HCop : Coplanar A B C Q
HPerP : Per B P Q
HPQ : not (eq P Q)
HOut : Out B P A
HSuma : SumA A B C A B C D E F
HPer : Per D E F
HAcute : Acute A B C
A,B,C,D,E,F,P,Q : Tpoint
lotschnitt : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (OS B C A P')
+++++
apply l9_9, l9_5 with P B; Col.
-----
Lemma bachmann_s_lotschnittaxiom__weak_inverse_projection_postulate : bachmann_s_lotschnittaxiom -> weak_inverse_projection_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro lotschnitt.
intros A B C D E F P Q HAcute HPer HSuma HOut HPQ HPerP HCop.
suma.assert_diffs.
assert (HNCol : ~ Col A B C).
assert (HNCol1 : ~ Col B C P) by (intro; apply HNCol; ColR).
destruct (l10_6_existence_spec B C P) as [P' HP']; trivial.
assert (HP'1 : Reflect P P' B C) by (apply is_image_is_image_spec; auto).
assert (HNCol2 : ~ Col B C P') by (apply osym_not_col with P; trivial).
destruct (l10_6_existence_spec B C Q) as [Q' HQ']; trivial.
assert (HQ'1 : Reflect Q Q' B C) by (apply is_image_is_image_spec; auto).
assert_diffs.
assert (P' <> Q').
intro; subst Q'; assert (P = Q) by (apply (l10_2_uniqueness B C P'); assumption); auto.
apply l6_6 in HOut.
assert (HCongA : CongA C B P' A B C).
apply out_conga with C P' P C; try (apply out_trivial); auto.
apply conga_sym, conga_left_comm, reflectl__conga; auto.
apply is_image_spec_rev, HP'.
assert (HTS : TS B C P P').
repeat split; Col; destruct HP' as [[X [HX1 HX2]] _]; exists X; split; Col; Between.
assert (HPer1 : Per A B P').
apply l11_17 with D E F; trivial.
apply (suma2__conga A B C A B C); trivial.
apply conga3_suma__suma with A B C C B P' A B P'; CongA.
exists P'; assert_diffs; repeat (split; CongA).
apply l9_9, l9_5 with P B; Col.

*****
H18 : not (eq P P')
HTS : TS B C P P'
HCongA : CongA C B P' A B C
H3 : not (eq P' Q')
H14 : not (eq A C)
H8 : not (eq C P)
H11 : not (eq B P')
H6 : not (eq C P')
HQ'1 : Reflect Q Q' B C
HQ' : ReflectL Q Q' B C
Q' : Tpoint
HNCol2 : not (Col B C P')
HP'1 : Reflect P P' B C
HP' : ReflectL P P' B C
P' : Tpoint
HNCol1 : not (Col B C P)
HNCol : not (Col A B C)
H0 : not (eq D F)
H9 : not (eq E F)
H7 : not (eq D E)
H5 : not (eq B C)
H2 : not (eq P B)
H1 : not (eq A B)
H : not (eq B Q)
HCop : Coplanar A B C Q
HPerP : Per B P Q
HPQ : not (eq P Q)
HOut : Out B P A
HSuma : SumA A B C A B C D E F
HPer : Per D E F
HAcute : Acute A B C
A,B,C,D,E,F,P,Q : Tpoint
lotschnitt : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar A B C P'
+++++
assert (Coplanar P' C A B) by (apply col2_cop__cop with P B; Col; Cop).
-----
Lemma bachmann_s_lotschnittaxiom__weak_inverse_projection_postulate : bachmann_s_lotschnittaxiom -> weak_inverse_projection_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro lotschnitt.
intros A B C D E F P Q HAcute HPer HSuma HOut HPQ HPerP HCop.
suma.assert_diffs.
assert (HNCol : ~ Col A B C).
assert (HNCol1 : ~ Col B C P) by (intro; apply HNCol; ColR).
destruct (l10_6_existence_spec B C P) as [P' HP']; trivial.
assert (HP'1 : Reflect P P' B C) by (apply is_image_is_image_spec; auto).
assert (HNCol2 : ~ Col B C P') by (apply osym_not_col with P; trivial).
destruct (l10_6_existence_spec B C Q) as [Q' HQ']; trivial.
assert (HQ'1 : Reflect Q Q' B C) by (apply is_image_is_image_spec; auto).
assert_diffs.
assert (P' <> Q').
intro; subst Q'; assert (P = Q) by (apply (l10_2_uniqueness B C P'); assumption); auto.
apply l6_6 in HOut.
assert (HCongA : CongA C B P' A B C).
apply out_conga with C P' P C; try (apply out_trivial); auto.
apply conga_sym, conga_left_comm, reflectl__conga; auto.
apply is_image_spec_rev, HP'.
assert (HTS : TS B C P P').
repeat split; Col; destruct HP' as [[X [HX1 HX2]] _]; exists X; split; Col; Between.
assert (HPer1 : Per A B P').
apply l11_17 with D E F; trivial.
apply (suma2__conga A B C A B C); trivial.
apply conga3_suma__suma with A B C C B P' A B P'; CongA.
exists P'; assert_diffs; repeat (split; CongA).
apply l9_9, l9_5 with P B; Col.
assert (Coplanar P' C A B) by (apply col2_cop__cop with P B; Col; Cop).

*****
H4 : Coplanar P' C A B
H18 : not (eq P P')
HTS : TS B C P P'
HCongA : CongA C B P' A B C
H3 : not (eq P' Q')
H14 : not (eq A C)
H8 : not (eq C P)
H11 : not (eq B P')
H6 : not (eq C P')
HQ'1 : Reflect Q Q' B C
HQ' : ReflectL Q Q' B C
Q' : Tpoint
HNCol2 : not (Col B C P')
HP'1 : Reflect P P' B C
HP' : ReflectL P P' B C
P' : Tpoint
HNCol1 : not (Col B C P)
HNCol : not (Col A B C)
H0 : not (eq D F)
H9 : not (eq E F)
H7 : not (eq D E)
H5 : not (eq B C)
H2 : not (eq P B)
H1 : not (eq A B)
H : not (eq B Q)
HCop : Coplanar A B C Q
HPerP : Per B P Q
HPQ : not (eq P Q)
HOut : Out B P A
HSuma : SumA A B C A B C D E F
HPer : Per D E F
HAcute : Acute A B C
A,B,C,D,E,F,P,Q : Tpoint
lotschnitt : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar A B C P'
+++++
Cop.
-----
Lemma bachmann_s_lotschnittaxiom__weak_inverse_projection_postulate : bachmann_s_lotschnittaxiom -> weak_inverse_projection_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro lotschnitt.
intros A B C D E F P Q HAcute HPer HSuma HOut HPQ HPerP HCop.
suma.assert_diffs.
assert (HNCol : ~ Col A B C).
assert (HNCol1 : ~ Col B C P) by (intro; apply HNCol; ColR).
destruct (l10_6_existence_spec B C P) as [P' HP']; trivial.
assert (HP'1 : Reflect P P' B C) by (apply is_image_is_image_spec; auto).
assert (HNCol2 : ~ Col B C P') by (apply osym_not_col with P; trivial).
destruct (l10_6_existence_spec B C Q) as [Q' HQ']; trivial.
assert (HQ'1 : Reflect Q Q' B C) by (apply is_image_is_image_spec; auto).
assert_diffs.
assert (P' <> Q').
intro; subst Q'; assert (P = Q) by (apply (l10_2_uniqueness B C P'); assumption); auto.
apply l6_6 in HOut.
assert (HCongA : CongA C B P' A B C).
apply out_conga with C P' P C; try (apply out_trivial); auto.
apply conga_sym, conga_left_comm, reflectl__conga; auto.
apply is_image_spec_rev, HP'.
assert (HTS : TS B C P P').
repeat split; Col; destruct HP' as [[X [HX1 HX2]] _]; exists X; split; Col; Between.
assert (HPer1 : Per A B P').

*****
HPer1 : Per A B P'
HTS : TS B C P P'
HCongA : CongA C B P' A B C
H3 : not (eq P' Q')
H14 : not (eq A C)
H8 : not (eq C P)
H11 : not (eq B P')
H6 : not (eq C P')
HQ'1 : Reflect Q Q' B C
HQ' : ReflectL Q Q' B C
Q' : Tpoint
HNCol2 : not (Col B C P')
HP'1 : Reflect P P' B C
HP' : ReflectL P P' B C
P' : Tpoint
HNCol1 : not (Col B C P)
HNCol : not (Col A B C)
H0 : not (eq D F)
H9 : not (eq E F)
H7 : not (eq D E)
H5 : not (eq B C)
H2 : not (eq P B)
H1 : not (eq A B)
H : not (eq B Q)
HCop : Coplanar A B C Q
HPerP : Per B P Q
HPQ : not (eq P Q)
HOut : Out B P A
HSuma : SumA A B C A B C D E F
HPer : Per D E F
HAcute : Acute A B C
A,B,C,D,E,F,P,Q : Tpoint
lotschnitt : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Y : Tpoint => and (Out B C Y) (Col P Q Y))
+++++
assert (HNCol3 : ~ Col A B P') by (apply per_not_col; auto).
-----
Lemma bachmann_s_lotschnittaxiom__weak_inverse_projection_postulate : bachmann_s_lotschnittaxiom -> weak_inverse_projection_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro lotschnitt.
intros A B C D E F P Q HAcute HPer HSuma HOut HPQ HPerP HCop.
suma.assert_diffs.
assert (HNCol : ~ Col A B C).
assert (HNCol1 : ~ Col B C P) by (intro; apply HNCol; ColR).
destruct (l10_6_existence_spec B C P) as [P' HP']; trivial.
assert (HP'1 : Reflect P P' B C) by (apply is_image_is_image_spec; auto).
assert (HNCol2 : ~ Col B C P') by (apply osym_not_col with P; trivial).
destruct (l10_6_existence_spec B C Q) as [Q' HQ']; trivial.
assert (HQ'1 : Reflect Q Q' B C) by (apply is_image_is_image_spec; auto).
assert_diffs.
assert (P' <> Q').
intro; subst Q'; assert (P = Q) by (apply (l10_2_uniqueness B C P'); assumption); auto.
apply l6_6 in HOut.
assert (HCongA : CongA C B P' A B C).
apply out_conga with C P' P C; try (apply out_trivial); auto.
apply conga_sym, conga_left_comm, reflectl__conga; auto.
apply is_image_spec_rev, HP'.
assert (HTS : TS B C P P').
repeat split; Col; destruct HP' as [[X [HX1 HX2]] _]; exists X; split; Col; Between.
assert (HPer1 : Per A B P').
assert (HNCol3 : ~ Col A B P') by (apply per_not_col; auto).

*****
HNCol3 : not (Col A B P')
HPer1 : Per A B P'
HTS : TS B C P P'
HCongA : CongA C B P' A B C
H3 : not (eq P' Q')
H14 : not (eq A C)
H8 : not (eq C P)
H11 : not (eq B P')
H6 : not (eq C P')
HQ'1 : Reflect Q Q' B C
HQ' : ReflectL Q Q' B C
Q' : Tpoint
HNCol2 : not (Col B C P')
HP'1 : Reflect P P' B C
HP' : ReflectL P P' B C
P' : Tpoint
HNCol1 : not (Col B C P)
HNCol : not (Col A B C)
H0 : not (eq D F)
H9 : not (eq E F)
H7 : not (eq D E)
H5 : not (eq B C)
H2 : not (eq P B)
H1 : not (eq A B)
H : not (eq B Q)
HCop : Coplanar A B C Q
HPerP : Per B P Q
HPQ : not (eq P Q)
HOut : Out B P A
HSuma : SumA A B C A B C D E F
HPer : Per D E F
HAcute : Acute A B C
A,B,C,D,E,F,P,Q : Tpoint
lotschnitt : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Y : Tpoint => and (Out B C Y) (Col P Q Y))
+++++
assert (HNCol4 : ~ Col B P' P) by (intro; apply HNCol3; ColR).
-----
Lemma bachmann_s_lotschnittaxiom__weak_inverse_projection_postulate : bachmann_s_lotschnittaxiom -> weak_inverse_projection_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro lotschnitt.
intros A B C D E F P Q HAcute HPer HSuma HOut HPQ HPerP HCop.
suma.assert_diffs.
assert (HNCol : ~ Col A B C).
assert (HNCol1 : ~ Col B C P) by (intro; apply HNCol; ColR).
destruct (l10_6_existence_spec B C P) as [P' HP']; trivial.
assert (HP'1 : Reflect P P' B C) by (apply is_image_is_image_spec; auto).
assert (HNCol2 : ~ Col B C P') by (apply osym_not_col with P; trivial).
destruct (l10_6_existence_spec B C Q) as [Q' HQ']; trivial.
assert (HQ'1 : Reflect Q Q' B C) by (apply is_image_is_image_spec; auto).
assert_diffs.
assert (P' <> Q').
intro; subst Q'; assert (P = Q) by (apply (l10_2_uniqueness B C P'); assumption); auto.
apply l6_6 in HOut.
assert (HCongA : CongA C B P' A B C).
apply out_conga with C P' P C; try (apply out_trivial); auto.
apply conga_sym, conga_left_comm, reflectl__conga; auto.
apply is_image_spec_rev, HP'.
assert (HTS : TS B C P P').
repeat split; Col; destruct HP' as [[X [HX1 HX2]] _]; exists X; split; Col; Between.
assert (HPer1 : Per A B P').
assert (HNCol3 : ~ Col A B P') by (apply per_not_col; auto).
assert (HNCol4 : ~ Col B P' P) by (intro; apply HNCol3; ColR).

*****
HNCol4 : not (Col B P' P)
HNCol3 : not (Col A B P')
HPer1 : Per A B P'
HTS : TS B C P P'
HCongA : CongA C B P' A B C
H3 : not (eq P' Q')
H14 : not (eq A C)
H8 : not (eq C P)
H11 : not (eq B P')
H6 : not (eq C P')
HQ'1 : Reflect Q Q' B C
HQ' : ReflectL Q Q' B C
Q' : Tpoint
HNCol2 : not (Col B C P')
HP'1 : Reflect P P' B C
HP' : ReflectL P P' B C
P' : Tpoint
HNCol1 : not (Col B C P)
HNCol : not (Col A B C)
H0 : not (eq D F)
H9 : not (eq E F)
H7 : not (eq D E)
H5 : not (eq B C)
H2 : not (eq P B)
H1 : not (eq A B)
H : not (eq B Q)
HCop : Coplanar A B C Q
HPerP : Per B P Q
HPQ : not (eq P Q)
HOut : Out B P A
HSuma : SumA A B C A B C D E F
HPer : Per D E F
HAcute : Acute A B C
A,B,C,D,E,F,P,Q : Tpoint
lotschnitt : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Y : Tpoint => and (Out B C Y) (Col P Q Y))
+++++
assert (HPerp1 : Perp A B B P') by (apply per_perp; auto).
-----
Lemma bachmann_s_lotschnittaxiom__weak_inverse_projection_postulate : bachmann_s_lotschnittaxiom -> weak_inverse_projection_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro lotschnitt.
intros A B C D E F P Q HAcute HPer HSuma HOut HPQ HPerP HCop.
suma.assert_diffs.
assert (HNCol : ~ Col A B C).
assert (HNCol1 : ~ Col B C P) by (intro; apply HNCol; ColR).
destruct (l10_6_existence_spec B C P) as [P' HP']; trivial.
assert (HP'1 : Reflect P P' B C) by (apply is_image_is_image_spec; auto).
assert (HNCol2 : ~ Col B C P') by (apply osym_not_col with P; trivial).
destruct (l10_6_existence_spec B C Q) as [Q' HQ']; trivial.
assert (HQ'1 : Reflect Q Q' B C) by (apply is_image_is_image_spec; auto).
assert_diffs.
assert (P' <> Q').
intro; subst Q'; assert (P = Q) by (apply (l10_2_uniqueness B C P'); assumption); auto.
apply l6_6 in HOut.
assert (HCongA : CongA C B P' A B C).
apply out_conga with C P' P C; try (apply out_trivial); auto.
apply conga_sym, conga_left_comm, reflectl__conga; auto.
apply is_image_spec_rev, HP'.
assert (HTS : TS B C P P').
repeat split; Col; destruct HP' as [[X [HX1 HX2]] _]; exists X; split; Col; Between.
assert (HPer1 : Per A B P').
assert (HNCol3 : ~ Col A B P') by (apply per_not_col; auto).
assert (HNCol4 : ~ Col B P' P) by (intro; apply HNCol3; ColR).
assert (HPerp1 : Perp A B B P') by (apply per_perp; auto).

*****
HPerp1 : Perp A B B P'
HNCol4 : not (Col B P' P)
HNCol3 : not (Col A B P')
HPer1 : Per A B P'
HTS : TS B C P P'
HCongA : CongA C B P' A B C
H3 : not (eq P' Q')
H14 : not (eq A C)
H8 : not (eq C P)
H11 : not (eq B P')
H6 : not (eq C P')
HQ'1 : Reflect Q Q' B C
HQ' : ReflectL Q Q' B C
Q' : Tpoint
HNCol2 : not (Col B C P')
HP'1 : Reflect P P' B C
HP' : ReflectL P P' B C
P' : Tpoint
HNCol1 : not (Col B C P)
HNCol : not (Col A B C)
H0 : not (eq D F)
H9 : not (eq E F)
H7 : not (eq D E)
H5 : not (eq B C)
H2 : not (eq P B)
H1 : not (eq A B)
H : not (eq B Q)
HCop : Coplanar A B C Q
HPerP : Per B P Q
HPQ : not (eq P Q)
HOut : Out B P A
HSuma : SumA A B C A B C D E F
HPer : Per D E F
HAcute : Acute A B C
A,B,C,D,E,F,P,Q : Tpoint
lotschnitt : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Y : Tpoint => and (Out B C Y) (Col P Q Y))
+++++
assert (HPerp2 : Perp A B P Q) by (apply perp_left_comm, perp_col with P; Col; apply per_perp; auto).
-----
Lemma bachmann_s_lotschnittaxiom__weak_inverse_projection_postulate : bachmann_s_lotschnittaxiom -> weak_inverse_projection_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro lotschnitt.
intros A B C D E F P Q HAcute HPer HSuma HOut HPQ HPerP HCop.
suma.assert_diffs.
assert (HNCol : ~ Col A B C).
assert (HNCol1 : ~ Col B C P) by (intro; apply HNCol; ColR).
destruct (l10_6_existence_spec B C P) as [P' HP']; trivial.
assert (HP'1 : Reflect P P' B C) by (apply is_image_is_image_spec; auto).
assert (HNCol2 : ~ Col B C P') by (apply osym_not_col with P; trivial).
destruct (l10_6_existence_spec B C Q) as [Q' HQ']; trivial.
assert (HQ'1 : Reflect Q Q' B C) by (apply is_image_is_image_spec; auto).
assert_diffs.
assert (P' <> Q').
intro; subst Q'; assert (P = Q) by (apply (l10_2_uniqueness B C P'); assumption); auto.
apply l6_6 in HOut.
assert (HCongA : CongA C B P' A B C).
apply out_conga with C P' P C; try (apply out_trivial); auto.
apply conga_sym, conga_left_comm, reflectl__conga; auto.
apply is_image_spec_rev, HP'.
assert (HTS : TS B C P P').
repeat split; Col; destruct HP' as [[X [HX1 HX2]] _]; exists X; split; Col; Between.
assert (HPer1 : Per A B P').
assert (HNCol3 : ~ Col A B P') by (apply per_not_col; auto).
assert (HNCol4 : ~ Col B P' P) by (intro; apply HNCol3; ColR).
assert (HPerp1 : Perp A B B P') by (apply per_perp; auto).
assert (HPerp2 : Perp A B P Q) by (apply perp_left_comm, perp_col with P; Col; apply per_perp; auto).

*****
HPerp2 : Perp A B P Q
HPerp1 : Perp A B B P'
HNCol4 : not (Col B P' P)
HNCol3 : not (Col A B P')
HPer1 : Per A B P'
HTS : TS B C P P'
HCongA : CongA C B P' A B C
H3 : not (eq P' Q')
H14 : not (eq A C)
H8 : not (eq C P)
H11 : not (eq B P')
H6 : not (eq C P')
HQ'1 : Reflect Q Q' B C
HQ' : ReflectL Q Q' B C
Q' : Tpoint
HNCol2 : not (Col B C P')
HP'1 : Reflect P P' B C
HP' : ReflectL P P' B C
P' : Tpoint
HNCol1 : not (Col B C P)
HNCol : not (Col A B C)
H0 : not (eq D F)
H9 : not (eq E F)
H7 : not (eq D E)
H5 : not (eq B C)
H2 : not (eq P B)
H1 : not (eq A B)
H : not (eq B Q)
HCop : Coplanar A B C Q
HPerP : Per B P Q
HPQ : not (eq P Q)
HOut : Out B P A
HSuma : SumA A B C A B C D E F
HPer : Per D E F
HAcute : Acute A B C
A,B,C,D,E,F,P,Q : Tpoint
lotschnitt : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Y : Tpoint => and (Out B C Y) (Col P Q Y))
+++++
assert (HPerp3 : Perp B P' P' Q').
-----
Lemma bachmann_s_lotschnittaxiom__weak_inverse_projection_postulate : bachmann_s_lotschnittaxiom -> weak_inverse_projection_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro lotschnitt.
intros A B C D E F P Q HAcute HPer HSuma HOut HPQ HPerP HCop.
suma.assert_diffs.
assert (HNCol : ~ Col A B C).
assert (HNCol1 : ~ Col B C P) by (intro; apply HNCol; ColR).
destruct (l10_6_existence_spec B C P) as [P' HP']; trivial.
assert (HP'1 : Reflect P P' B C) by (apply is_image_is_image_spec; auto).
assert (HNCol2 : ~ Col B C P') by (apply osym_not_col with P; trivial).
destruct (l10_6_existence_spec B C Q) as [Q' HQ']; trivial.
assert (HQ'1 : Reflect Q Q' B C) by (apply is_image_is_image_spec; auto).
assert_diffs.
assert (P' <> Q').
intro; subst Q'; assert (P = Q) by (apply (l10_2_uniqueness B C P'); assumption); auto.
apply l6_6 in HOut.
assert (HCongA : CongA C B P' A B C).
apply out_conga with C P' P C; try (apply out_trivial); auto.
apply conga_sym, conga_left_comm, reflectl__conga; auto.
apply is_image_spec_rev, HP'.
assert (HTS : TS B C P P').
repeat split; Col; destruct HP' as [[X [HX1 HX2]] _]; exists X; split; Col; Between.
assert (HPer1 : Per A B P').
assert (HNCol3 : ~ Col A B P') by (apply per_not_col; auto).
assert (HNCol4 : ~ Col B P' P) by (intro; apply HNCol3; ColR).
assert (HPerp1 : Perp A B B P') by (apply per_perp; auto).
assert (HPerp2 : Perp A B P Q) by (apply perp_left_comm, perp_col with P; Col; apply per_perp; auto).
assert (HPerp3 : Perp B P' P' Q').

*****
HPerp2 : Perp A B P Q
HPerp1 : Perp A B B P'
HNCol4 : not (Col B P' P)
HNCol3 : not (Col A B P')
HPer1 : Per A B P'
HTS : TS B C P P'
HCongA : CongA C B P' A B C
H3 : not (eq P' Q')
H14 : not (eq A C)
H8 : not (eq C P)
H11 : not (eq B P')
H6 : not (eq C P')
HQ'1 : Reflect Q Q' B C
HQ' : ReflectL Q Q' B C
Q' : Tpoint
HNCol2 : not (Col B C P')
HP'1 : Reflect P P' B C
HP' : ReflectL P P' B C
P' : Tpoint
HNCol1 : not (Col B C P)
HNCol : not (Col A B C)
H0 : not (eq D F)
H9 : not (eq E F)
H7 : not (eq D E)
H5 : not (eq B C)
H2 : not (eq P B)
H1 : not (eq A B)
H : not (eq B Q)
HCop : Coplanar A B C Q
HPerP : Per B P Q
HPQ : not (eq P Q)
HOut : Out B P A
HSuma : SumA A B C A B C D E F
HPer : Per D E F
HAcute : Acute A B C
A,B,C,D,E,F,P,Q : Tpoint
lotschnitt : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Perp B P' P' Q'
+++++
apply per_perp; auto; apply image_spec_preserves_per with B P Q B C; trivial; apply col__refl; Col.
-----
Lemma bachmann_s_lotschnittaxiom__weak_inverse_projection_postulate : bachmann_s_lotschnittaxiom -> weak_inverse_projection_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro lotschnitt.
intros A B C D E F P Q HAcute HPer HSuma HOut HPQ HPerP HCop.
suma.assert_diffs.
assert (HNCol : ~ Col A B C).
assert (HNCol1 : ~ Col B C P) by (intro; apply HNCol; ColR).
destruct (l10_6_existence_spec B C P) as [P' HP']; trivial.
assert (HP'1 : Reflect P P' B C) by (apply is_image_is_image_spec; auto).
assert (HNCol2 : ~ Col B C P') by (apply osym_not_col with P; trivial).
destruct (l10_6_existence_spec B C Q) as [Q' HQ']; trivial.
assert (HQ'1 : Reflect Q Q' B C) by (apply is_image_is_image_spec; auto).
assert_diffs.
assert (P' <> Q').
intro; subst Q'; assert (P = Q) by (apply (l10_2_uniqueness B C P'); assumption); auto.
apply l6_6 in HOut.
assert (HCongA : CongA C B P' A B C).
apply out_conga with C P' P C; try (apply out_trivial); auto.
apply conga_sym, conga_left_comm, reflectl__conga; auto.
apply is_image_spec_rev, HP'.
assert (HTS : TS B C P P').
repeat split; Col; destruct HP' as [[X [HX1 HX2]] _]; exists X; split; Col; Between.
assert (HPer1 : Per A B P').
assert (HNCol3 : ~ Col A B P') by (apply per_not_col; auto).
assert (HNCol4 : ~ Col B P' P) by (intro; apply HNCol3; ColR).
assert (HPerp1 : Perp A B B P') by (apply per_perp; auto).
assert (HPerp2 : Perp A B P Q) by (apply perp_left_comm, perp_col with P; Col; apply per_perp; auto).
assert (HPerp3 : Perp B P' P' Q').
apply per_perp; auto; apply image_spec_preserves_per with B P Q B C; trivial; apply col__refl; Col.

*****
HPerp3 : Perp B P' P' Q'
HPerp2 : Perp A B P Q
HPerp1 : Perp A B B P'
HNCol4 : not (Col B P' P)
HNCol3 : not (Col A B P')
HPer1 : Per A B P'
HTS : TS B C P P'
HCongA : CongA C B P' A B C
H3 : not (eq P' Q')
H14 : not (eq A C)
H8 : not (eq C P)
H11 : not (eq B P')
H6 : not (eq C P')
HQ'1 : Reflect Q Q' B C
HQ' : ReflectL Q Q' B C
Q' : Tpoint
HNCol2 : not (Col B C P')
HP'1 : Reflect P P' B C
HP' : ReflectL P P' B C
P' : Tpoint
HNCol1 : not (Col B C P)
HNCol : not (Col A B C)
H0 : not (eq D F)
H9 : not (eq E F)
H7 : not (eq D E)
H5 : not (eq B C)
H2 : not (eq P B)
H1 : not (eq A B)
H : not (eq B Q)
HCop : Coplanar A B C Q
HPerP : Per B P Q
HPQ : not (eq P Q)
HOut : Out B P A
HSuma : SumA A B C A B C D E F
HPer : Per D E F
HAcute : Acute A B C
A,B,C,D,E,F,P,Q : Tpoint
lotschnitt : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Y : Tpoint => and (Out B C Y) (Col P Q Y))
+++++
assert (HNCol5 : ~ Col P' P Q).
-----
Lemma bachmann_s_lotschnittaxiom__weak_inverse_projection_postulate : bachmann_s_lotschnittaxiom -> weak_inverse_projection_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro lotschnitt.
intros A B C D E F P Q HAcute HPer HSuma HOut HPQ HPerP HCop.
suma.assert_diffs.
assert (HNCol : ~ Col A B C).
assert (HNCol1 : ~ Col B C P) by (intro; apply HNCol; ColR).
destruct (l10_6_existence_spec B C P) as [P' HP']; trivial.
assert (HP'1 : Reflect P P' B C) by (apply is_image_is_image_spec; auto).
assert (HNCol2 : ~ Col B C P') by (apply osym_not_col with P; trivial).
destruct (l10_6_existence_spec B C Q) as [Q' HQ']; trivial.
assert (HQ'1 : Reflect Q Q' B C) by (apply is_image_is_image_spec; auto).
assert_diffs.
assert (P' <> Q').
intro; subst Q'; assert (P = Q) by (apply (l10_2_uniqueness B C P'); assumption); auto.
apply l6_6 in HOut.
assert (HCongA : CongA C B P' A B C).
apply out_conga with C P' P C; try (apply out_trivial); auto.
apply conga_sym, conga_left_comm, reflectl__conga; auto.
apply is_image_spec_rev, HP'.
assert (HTS : TS B C P P').
repeat split; Col; destruct HP' as [[X [HX1 HX2]] _]; exists X; split; Col; Between.
assert (HPer1 : Per A B P').
assert (HNCol3 : ~ Col A B P') by (apply per_not_col; auto).
assert (HNCol4 : ~ Col B P' P) by (intro; apply HNCol3; ColR).
assert (HPerp1 : Perp A B B P') by (apply per_perp; auto).
assert (HPerp2 : Perp A B P Q) by (apply perp_left_comm, perp_col with P; Col; apply per_perp; auto).
assert (HPerp3 : Perp B P' P' Q').
apply per_perp; auto; apply image_spec_preserves_per with B P Q B C; trivial; apply col__refl; Col.
assert (HNCol5 : ~ Col P' P Q).

*****
HPerp3 : Perp B P' P' Q'
HPerp2 : Perp A B P Q
HPerp1 : Perp A B B P'
HNCol4 : not (Col B P' P)
HNCol3 : not (Col A B P')
HPer1 : Per A B P'
HTS : TS B C P P'
HCongA : CongA C B P' A B C
H3 : not (eq P' Q')
H14 : not (eq A C)
H8 : not (eq C P)
H11 : not (eq B P')
H6 : not (eq C P')
HQ'1 : Reflect Q Q' B C
HQ' : ReflectL Q Q' B C
Q' : Tpoint
HNCol2 : not (Col B C P')
HP'1 : Reflect P P' B C
HP' : ReflectL P P' B C
P' : Tpoint
HNCol1 : not (Col B C P)
HNCol : not (Col A B C)
H0 : not (eq D F)
H9 : not (eq E F)
H7 : not (eq D E)
H5 : not (eq B C)
H2 : not (eq P B)
H1 : not (eq A B)
H : not (eq B Q)
HCop : Coplanar A B C Q
HPerP : Per B P Q
HPQ : not (eq P Q)
HOut : Out B P A
HSuma : SumA A B C A B C D E F
HPer : Per D E F
HAcute : Acute A B C
A,B,C,D,E,F,P,Q : Tpoint
lotschnitt : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col P' P Q)
+++++
apply (par_not_col B P'); Col.
-----
Lemma bachmann_s_lotschnittaxiom__weak_inverse_projection_postulate : bachmann_s_lotschnittaxiom -> weak_inverse_projection_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro lotschnitt.
intros A B C D E F P Q HAcute HPer HSuma HOut HPQ HPerP HCop.
suma.assert_diffs.
assert (HNCol : ~ Col A B C).
assert (HNCol1 : ~ Col B C P) by (intro; apply HNCol; ColR).
destruct (l10_6_existence_spec B C P) as [P' HP']; trivial.
assert (HP'1 : Reflect P P' B C) by (apply is_image_is_image_spec; auto).
assert (HNCol2 : ~ Col B C P') by (apply osym_not_col with P; trivial).
destruct (l10_6_existence_spec B C Q) as [Q' HQ']; trivial.
assert (HQ'1 : Reflect Q Q' B C) by (apply is_image_is_image_spec; auto).
assert_diffs.
assert (P' <> Q').
intro; subst Q'; assert (P = Q) by (apply (l10_2_uniqueness B C P'); assumption); auto.
apply l6_6 in HOut.
assert (HCongA : CongA C B P' A B C).
apply out_conga with C P' P C; try (apply out_trivial); auto.
apply conga_sym, conga_left_comm, reflectl__conga; auto.
apply is_image_spec_rev, HP'.
assert (HTS : TS B C P P').
repeat split; Col; destruct HP' as [[X [HX1 HX2]] _]; exists X; split; Col; Between.
assert (HPer1 : Per A B P').
assert (HNCol3 : ~ Col A B P') by (apply per_not_col; auto).
assert (HNCol4 : ~ Col B P' P) by (intro; apply HNCol3; ColR).
assert (HPerp1 : Perp A B B P') by (apply per_perp; auto).
assert (HPerp2 : Perp A B P Q) by (apply perp_left_comm, perp_col with P; Col; apply per_perp; auto).
assert (HPerp3 : Perp B P' P' Q').
apply per_perp; auto; apply image_spec_preserves_per with B P Q B C; trivial; apply col__refl; Col.
assert (HNCol5 : ~ Col P' P Q).
apply (par_not_col B P'); Col.

*****
HPerp3 : Perp B P' P' Q'
HPerp2 : Perp A B P Q
HPerp1 : Perp A B B P'
HNCol4 : not (Col B P' P)
HNCol3 : not (Col A B P')
HPer1 : Per A B P'
HTS : TS B C P P'
HCongA : CongA C B P' A B C
H3 : not (eq P' Q')
H14 : not (eq A C)
H8 : not (eq C P)
H11 : not (eq B P')
H6 : not (eq C P')
HQ'1 : Reflect Q Q' B C
HQ' : ReflectL Q Q' B C
Q' : Tpoint
HNCol2 : not (Col B C P')
HP'1 : Reflect P P' B C
HP' : ReflectL P P' B C
P' : Tpoint
HNCol1 : not (Col B C P)
HNCol : not (Col A B C)
H0 : not (eq D F)
H9 : not (eq E F)
H7 : not (eq D E)
H5 : not (eq B C)
H2 : not (eq P B)
H1 : not (eq A B)
H : not (eq B Q)
HCop : Coplanar A B C Q
HPerP : Per B P Q
HPQ : not (eq P Q)
HOut : Out B P A
HSuma : SumA A B C A B C D E F
HPer : Per D E F
HAcute : Acute A B C
A,B,C,D,E,F,P,Q : Tpoint
lotschnitt : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Par_strict B P' P Q
+++++
apply par_not_col_strict with P; Col.
-----
Lemma bachmann_s_lotschnittaxiom__weak_inverse_projection_postulate : bachmann_s_lotschnittaxiom -> weak_inverse_projection_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro lotschnitt.
intros A B C D E F P Q HAcute HPer HSuma HOut HPQ HPerP HCop.
suma.assert_diffs.
assert (HNCol : ~ Col A B C).
assert (HNCol1 : ~ Col B C P) by (intro; apply HNCol; ColR).
destruct (l10_6_existence_spec B C P) as [P' HP']; trivial.
assert (HP'1 : Reflect P P' B C) by (apply is_image_is_image_spec; auto).
assert (HNCol2 : ~ Col B C P') by (apply osym_not_col with P; trivial).
destruct (l10_6_existence_spec B C Q) as [Q' HQ']; trivial.
assert (HQ'1 : Reflect Q Q' B C) by (apply is_image_is_image_spec; auto).
assert_diffs.
assert (P' <> Q').
intro; subst Q'; assert (P = Q) by (apply (l10_2_uniqueness B C P'); assumption); auto.
apply l6_6 in HOut.
assert (HCongA : CongA C B P' A B C).
apply out_conga with C P' P C; try (apply out_trivial); auto.
apply conga_sym, conga_left_comm, reflectl__conga; auto.
apply is_image_spec_rev, HP'.
assert (HTS : TS B C P P').
repeat split; Col; destruct HP' as [[X [HX1 HX2]] _]; exists X; split; Col; Between.
assert (HPer1 : Per A B P').
assert (HNCol3 : ~ Col A B P') by (apply per_not_col; auto).
assert (HNCol4 : ~ Col B P' P) by (intro; apply HNCol3; ColR).
assert (HPerp1 : Perp A B B P') by (apply per_perp; auto).
assert (HPerp2 : Perp A B P Q) by (apply perp_left_comm, perp_col with P; Col; apply per_perp; auto).
assert (HPerp3 : Perp B P' P' Q').
apply per_perp; auto; apply image_spec_preserves_per with B P Q B C; trivial; apply col__refl; Col.
assert (HNCol5 : ~ Col P' P Q).
apply (par_not_col B P'); Col.
apply par_not_col_strict with P; Col.

*****
HPerp3 : Perp B P' P' Q'
HPerp2 : Perp A B P Q
HPerp1 : Perp A B B P'
HNCol4 : not (Col B P' P)
HNCol3 : not (Col A B P')
HPer1 : Per A B P'
HTS : TS B C P P'
HCongA : CongA C B P' A B C
H3 : not (eq P' Q')
H14 : not (eq A C)
H8 : not (eq C P)
H11 : not (eq B P')
H6 : not (eq C P')
HQ'1 : Reflect Q Q' B C
HQ' : ReflectL Q Q' B C
Q' : Tpoint
HNCol2 : not (Col B C P')
HP'1 : Reflect P P' B C
HP' : ReflectL P P' B C
P' : Tpoint
HNCol1 : not (Col B C P)
HNCol : not (Col A B C)
H0 : not (eq D F)
H9 : not (eq E F)
H7 : not (eq D E)
H5 : not (eq B C)
H2 : not (eq P B)
H1 : not (eq A B)
H : not (eq B Q)
HCop : Coplanar A B C Q
HPerP : Per B P Q
HPQ : not (eq P Q)
HOut : Out B P A
HSuma : SumA A B C A B C D E F
HPer : Per D E F
HAcute : Acute A B C
A,B,C,D,E,F,P,Q : Tpoint
lotschnitt : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Par B P' P Q
+++++
apply l12_9 with A B; Perp; Cop.
-----
Lemma bachmann_s_lotschnittaxiom__weak_inverse_projection_postulate : bachmann_s_lotschnittaxiom -> weak_inverse_projection_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro lotschnitt.
intros A B C D E F P Q HAcute HPer HSuma HOut HPQ HPerP HCop.
suma.assert_diffs.
assert (HNCol : ~ Col A B C).
assert (HNCol1 : ~ Col B C P) by (intro; apply HNCol; ColR).
destruct (l10_6_existence_spec B C P) as [P' HP']; trivial.
assert (HP'1 : Reflect P P' B C) by (apply is_image_is_image_spec; auto).
assert (HNCol2 : ~ Col B C P') by (apply osym_not_col with P; trivial).
destruct (l10_6_existence_spec B C Q) as [Q' HQ']; trivial.
assert (HQ'1 : Reflect Q Q' B C) by (apply is_image_is_image_spec; auto).
assert_diffs.
assert (P' <> Q').
intro; subst Q'; assert (P = Q) by (apply (l10_2_uniqueness B C P'); assumption); auto.
apply l6_6 in HOut.
assert (HCongA : CongA C B P' A B C).
apply out_conga with C P' P C; try (apply out_trivial); auto.
apply conga_sym, conga_left_comm, reflectl__conga; auto.
apply is_image_spec_rev, HP'.
assert (HTS : TS B C P P').
repeat split; Col; destruct HP' as [[X [HX1 HX2]] _]; exists X; split; Col; Between.
assert (HPer1 : Per A B P').
assert (HNCol3 : ~ Col A B P') by (apply per_not_col; auto).
assert (HNCol4 : ~ Col B P' P) by (intro; apply HNCol3; ColR).
assert (HPerp1 : Perp A B B P') by (apply per_perp; auto).
assert (HPerp2 : Perp A B P Q) by (apply perp_left_comm, perp_col with P; Col; apply per_perp; auto).
assert (HPerp3 : Perp B P' P' Q').
apply per_perp; auto; apply image_spec_preserves_per with B P Q B C; trivial; apply col__refl; Col.
assert (HNCol5 : ~ Col P' P Q).
apply (par_not_col B P'); Col.
apply par_not_col_strict with P; Col.
apply l12_9 with A B; Perp; Cop.

*****
HPerp3 : Perp B P' P' Q'
HPerp2 : Perp A B P Q
HPerp1 : Perp A B B P'
HNCol4 : not (Col B P' P)
HNCol3 : not (Col A B P')
HPer1 : Per A B P'
HTS : TS B C P P'
HCongA : CongA C B P' A B C
H3 : not (eq P' Q')
H14 : not (eq A C)
H8 : not (eq C P)
H11 : not (eq B P')
H6 : not (eq C P')
HQ'1 : Reflect Q Q' B C
HQ' : ReflectL Q Q' B C
Q' : Tpoint
HNCol2 : not (Col B C P')
HP'1 : Reflect P P' B C
HP' : ReflectL P P' B C
P' : Tpoint
HNCol1 : not (Col B C P)
HNCol : not (Col A B C)
H0 : not (eq D F)
H9 : not (eq E F)
H7 : not (eq D E)
H5 : not (eq B C)
H2 : not (eq P B)
H1 : not (eq A B)
H : not (eq B Q)
HCop : Coplanar A B C Q
HPerP : Per B P Q
HPQ : not (eq P Q)
HOut : Out B P A
HSuma : SumA A B C A B C D E F
HPer : Per D E F
HAcute : Acute A B C
A,B,C,D,E,F,P,Q : Tpoint
lotschnitt : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar A B P' Q
+++++
assert (Coplanar P' C A B) by (apply col2_cop__cop with P B; Col; Cop).
-----
Lemma bachmann_s_lotschnittaxiom__weak_inverse_projection_postulate : bachmann_s_lotschnittaxiom -> weak_inverse_projection_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro lotschnitt.
intros A B C D E F P Q HAcute HPer HSuma HOut HPQ HPerP HCop.
suma.assert_diffs.
assert (HNCol : ~ Col A B C).
assert (HNCol1 : ~ Col B C P) by (intro; apply HNCol; ColR).
destruct (l10_6_existence_spec B C P) as [P' HP']; trivial.
assert (HP'1 : Reflect P P' B C) by (apply is_image_is_image_spec; auto).
assert (HNCol2 : ~ Col B C P') by (apply osym_not_col with P; trivial).
destruct (l10_6_existence_spec B C Q) as [Q' HQ']; trivial.
assert (HQ'1 : Reflect Q Q' B C) by (apply is_image_is_image_spec; auto).
assert_diffs.
assert (P' <> Q').
intro; subst Q'; assert (P = Q) by (apply (l10_2_uniqueness B C P'); assumption); auto.
apply l6_6 in HOut.
assert (HCongA : CongA C B P' A B C).
apply out_conga with C P' P C; try (apply out_trivial); auto.
apply conga_sym, conga_left_comm, reflectl__conga; auto.
apply is_image_spec_rev, HP'.
assert (HTS : TS B C P P').
repeat split; Col; destruct HP' as [[X [HX1 HX2]] _]; exists X; split; Col; Between.
assert (HPer1 : Per A B P').
assert (HNCol3 : ~ Col A B P') by (apply per_not_col; auto).
assert (HNCol4 : ~ Col B P' P) by (intro; apply HNCol3; ColR).
assert (HPerp1 : Perp A B B P') by (apply per_perp; auto).
assert (HPerp2 : Perp A B P Q) by (apply perp_left_comm, perp_col with P; Col; apply per_perp; auto).
assert (HPerp3 : Perp B P' P' Q').
apply per_perp; auto; apply image_spec_preserves_per with B P Q B C; trivial; apply col__refl; Col.
assert (HNCol5 : ~ Col P' P Q).
apply (par_not_col B P'); Col.
apply par_not_col_strict with P; Col.
apply l12_9 with A B; Perp; Cop.
assert (Coplanar P' C A B) by (apply col2_cop__cop with P B; Col; Cop).

*****
H4 : Coplanar P' C A B
HPerp3 : Perp B P' P' Q'
HPerp2 : Perp A B P Q
HPerp1 : Perp A B B P'
HNCol4 : not (Col B P' P)
HNCol3 : not (Col A B P')
HPer1 : Per A B P'
HTS : TS B C P P'
HCongA : CongA C B P' A B C
H3 : not (eq P' Q')
H14 : not (eq A C)
H8 : not (eq C P)
H11 : not (eq B P')
H6 : not (eq C P')
HQ'1 : Reflect Q Q' B C
HQ' : ReflectL Q Q' B C
Q' : Tpoint
HNCol2 : not (Col B C P')
HP'1 : Reflect P P' B C
HP' : ReflectL P P' B C
P' : Tpoint
HNCol1 : not (Col B C P)
HNCol : not (Col A B C)
H0 : not (eq D F)
H9 : not (eq E F)
H7 : not (eq D E)
H5 : not (eq B C)
H2 : not (eq P B)
H1 : not (eq A B)
H : not (eq B Q)
HCop : Coplanar A B C Q
HPerP : Per B P Q
HPQ : not (eq P Q)
HOut : Out B P A
HSuma : SumA A B C A B C D E F
HPer : Per D E F
HAcute : Acute A B C
A,B,C,D,E,F,P,Q : Tpoint
lotschnitt : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar A B P' Q
+++++
CopR.
-----
Lemma bachmann_s_lotschnittaxiom__weak_inverse_projection_postulate : bachmann_s_lotschnittaxiom -> weak_inverse_projection_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro lotschnitt.
intros A B C D E F P Q HAcute HPer HSuma HOut HPQ HPerP HCop.
suma.assert_diffs.
assert (HNCol : ~ Col A B C).
assert (HNCol1 : ~ Col B C P) by (intro; apply HNCol; ColR).
destruct (l10_6_existence_spec B C P) as [P' HP']; trivial.
assert (HP'1 : Reflect P P' B C) by (apply is_image_is_image_spec; auto).
assert (HNCol2 : ~ Col B C P') by (apply osym_not_col with P; trivial).
destruct (l10_6_existence_spec B C Q) as [Q' HQ']; trivial.
assert (HQ'1 : Reflect Q Q' B C) by (apply is_image_is_image_spec; auto).
assert_diffs.
assert (P' <> Q').
intro; subst Q'; assert (P = Q) by (apply (l10_2_uniqueness B C P'); assumption); auto.
apply l6_6 in HOut.
assert (HCongA : CongA C B P' A B C).
apply out_conga with C P' P C; try (apply out_trivial); auto.
apply conga_sym, conga_left_comm, reflectl__conga; auto.
apply is_image_spec_rev, HP'.
assert (HTS : TS B C P P').
repeat split; Col; destruct HP' as [[X [HX1 HX2]] _]; exists X; split; Col; Between.
assert (HPer1 : Per A B P').
assert (HNCol3 : ~ Col A B P') by (apply per_not_col; auto).
assert (HNCol4 : ~ Col B P' P) by (intro; apply HNCol3; ColR).
assert (HPerp1 : Perp A B B P') by (apply per_perp; auto).
assert (HPerp2 : Perp A B P Q) by (apply perp_left_comm, perp_col with P; Col; apply per_perp; auto).
assert (HPerp3 : Perp B P' P' Q').
apply per_perp; auto; apply image_spec_preserves_per with B P Q B C; trivial; apply col__refl; Col.
assert (HNCol5 : ~ Col P' P Q).
apply (par_not_col B P'); Col.
apply par_not_col_strict with P; Col.
apply l12_9 with A B; Perp; Cop.
assert (Coplanar P' C A B) by (apply col2_cop__cop with P B; Col; Cop).
CopR.

*****
HNCol5 : not (Col P' P Q)
HPerp3 : Perp B P' P' Q'
HPerp2 : Perp A B P Q
HPerp1 : Perp A B B P'
HNCol4 : not (Col B P' P)
HNCol3 : not (Col A B P')
HPer1 : Per A B P'
HTS : TS B C P P'
HCongA : CongA C B P' A B C
H3 : not (eq P' Q')
H14 : not (eq A C)
H8 : not (eq C P)
H11 : not (eq B P')
H6 : not (eq C P')
HQ'1 : Reflect Q Q' B C
HQ' : ReflectL Q Q' B C
Q' : Tpoint
HNCol2 : not (Col B C P')
HP'1 : Reflect P P' B C
HP' : ReflectL P P' B C
P' : Tpoint
HNCol1 : not (Col B C P)
HNCol : not (Col A B C)
H0 : not (eq D F)
H9 : not (eq E F)
H7 : not (eq D E)
H5 : not (eq B C)
H2 : not (eq P B)
H1 : not (eq A B)
H : not (eq B Q)
HCop : Coplanar A B C Q
HPerP : Per B P Q
HPQ : not (eq P Q)
HOut : Out B P A
HSuma : SumA A B C A B C D E F
HPer : Per D E F
HAcute : Acute A B C
A,B,C,D,E,F,P,Q : Tpoint
lotschnitt : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Y : Tpoint => and (Out B C Y) (Col P Q Y))
+++++
assert (HI := HPerp2); destruct HI as [I [_ [_ [HCol1 [HCol2 _]]]]].
-----
Lemma bachmann_s_lotschnittaxiom__weak_inverse_projection_postulate : bachmann_s_lotschnittaxiom -> weak_inverse_projection_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro lotschnitt.
intros A B C D E F P Q HAcute HPer HSuma HOut HPQ HPerP HCop.
suma.assert_diffs.
assert (HNCol : ~ Col A B C).
assert (HNCol1 : ~ Col B C P) by (intro; apply HNCol; ColR).
destruct (l10_6_existence_spec B C P) as [P' HP']; trivial.
assert (HP'1 : Reflect P P' B C) by (apply is_image_is_image_spec; auto).
assert (HNCol2 : ~ Col B C P') by (apply osym_not_col with P; trivial).
destruct (l10_6_existence_spec B C Q) as [Q' HQ']; trivial.
assert (HQ'1 : Reflect Q Q' B C) by (apply is_image_is_image_spec; auto).
assert_diffs.
assert (P' <> Q').
intro; subst Q'; assert (P = Q) by (apply (l10_2_uniqueness B C P'); assumption); auto.
apply l6_6 in HOut.
assert (HCongA : CongA C B P' A B C).
apply out_conga with C P' P C; try (apply out_trivial); auto.
apply conga_sym, conga_left_comm, reflectl__conga; auto.
apply is_image_spec_rev, HP'.
assert (HTS : TS B C P P').
repeat split; Col; destruct HP' as [[X [HX1 HX2]] _]; exists X; split; Col; Between.
assert (HPer1 : Per A B P').
assert (HNCol3 : ~ Col A B P') by (apply per_not_col; auto).
assert (HNCol4 : ~ Col B P' P) by (intro; apply HNCol3; ColR).
assert (HPerp1 : Perp A B B P') by (apply per_perp; auto).
assert (HPerp2 : Perp A B P Q) by (apply perp_left_comm, perp_col with P; Col; apply per_perp; auto).
assert (HPerp3 : Perp B P' P' Q').
apply per_perp; auto; apply image_spec_preserves_per with B P Q B C; trivial; apply col__refl; Col.
assert (HNCol5 : ~ Col P' P Q).
apply (par_not_col B P'); Col.
apply par_not_col_strict with P; Col.
apply l12_9 with A B; Perp; Cop.
assert (Coplanar P' C A B) by (apply col2_cop__cop with P B; Col; Cop).
CopR.
assert (HI := HPerp2); destruct HI as [I [_ [_ [HCol1 [HCol2 _]]]]].

*****
HCol2 : Col I P Q
HCol1 : Col I A B
I : Tpoint
HNCol5 : not (Col P' P Q)
HPerp3 : Perp B P' P' Q'
HPerp2 : Perp A B P Q
HPerp1 : Perp A B B P'
HNCol4 : not (Col B P' P)
HNCol3 : not (Col A B P')
HPer1 : Per A B P'
HTS : TS B C P P'
HCongA : CongA C B P' A B C
H3 : not (eq P' Q')
H14 : not (eq A C)
H8 : not (eq C P)
H11 : not (eq B P')
H6 : not (eq C P')
HQ'1 : Reflect Q Q' B C
HQ' : ReflectL Q Q' B C
Q' : Tpoint
HNCol2 : not (Col B C P')
HP'1 : Reflect P P' B C
HP' : ReflectL P P' B C
P' : Tpoint
HNCol1 : not (Col B C P)
HNCol : not (Col A B C)
H0 : not (eq D F)
H9 : not (eq E F)
H7 : not (eq D E)
H5 : not (eq B C)
H2 : not (eq P B)
H1 : not (eq A B)
H : not (eq B Q)
HCop : Coplanar A B C Q
HPerP : Per B P Q
HPQ : not (eq P Q)
HOut : Out B P A
HSuma : SumA A B C A B C D E F
HPer : Per D E F
HAcute : Acute A B C
A,B,C,D,E,F,P,Q : Tpoint
lotschnitt : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Y : Tpoint => and (Out B C Y) (Col P Q Y))
+++++
assert (Coplanar P' C A B) by (apply col2_cop__cop with P B; Col; Cop).
-----
Lemma bachmann_s_lotschnittaxiom__weak_inverse_projection_postulate : bachmann_s_lotschnittaxiom -> weak_inverse_projection_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro lotschnitt.
intros A B C D E F P Q HAcute HPer HSuma HOut HPQ HPerP HCop.
suma.assert_diffs.
assert (HNCol : ~ Col A B C).
assert (HNCol1 : ~ Col B C P) by (intro; apply HNCol; ColR).
destruct (l10_6_existence_spec B C P) as [P' HP']; trivial.
assert (HP'1 : Reflect P P' B C) by (apply is_image_is_image_spec; auto).
assert (HNCol2 : ~ Col B C P') by (apply osym_not_col with P; trivial).
destruct (l10_6_existence_spec B C Q) as [Q' HQ']; trivial.
assert (HQ'1 : Reflect Q Q' B C) by (apply is_image_is_image_spec; auto).
assert_diffs.
assert (P' <> Q').
intro; subst Q'; assert (P = Q) by (apply (l10_2_uniqueness B C P'); assumption); auto.
apply l6_6 in HOut.
assert (HCongA : CongA C B P' A B C).
apply out_conga with C P' P C; try (apply out_trivial); auto.
apply conga_sym, conga_left_comm, reflectl__conga; auto.
apply is_image_spec_rev, HP'.
assert (HTS : TS B C P P').
repeat split; Col; destruct HP' as [[X [HX1 HX2]] _]; exists X; split; Col; Between.
assert (HPer1 : Per A B P').
assert (HNCol3 : ~ Col A B P') by (apply per_not_col; auto).
assert (HNCol4 : ~ Col B P' P) by (intro; apply HNCol3; ColR).
assert (HPerp1 : Perp A B B P') by (apply per_perp; auto).
assert (HPerp2 : Perp A B P Q) by (apply perp_left_comm, perp_col with P; Col; apply per_perp; auto).
assert (HPerp3 : Perp B P' P' Q').
apply per_perp; auto; apply image_spec_preserves_per with B P Q B C; trivial; apply col__refl; Col.
assert (HNCol5 : ~ Col P' P Q).
apply (par_not_col B P'); Col.
apply par_not_col_strict with P; Col.
apply l12_9 with A B; Perp; Cop.
assert (Coplanar P' C A B) by (apply col2_cop__cop with P B; Col; Cop).
CopR.
assert (HI := HPerp2); destruct HI as [I [_ [_ [HCol1 [HCol2 _]]]]].
assert (Coplanar P' C A B) by (apply col2_cop__cop with P B; Col; Cop).

*****
H4 : Coplanar P' C A B
HCol2 : Col I P Q
HCol1 : Col I A B
I : Tpoint
HNCol5 : not (Col P' P Q)
HPerp3 : Perp B P' P' Q'
HPerp2 : Perp A B P Q
HPerp1 : Perp A B B P'
HNCol4 : not (Col B P' P)
HNCol3 : not (Col A B P')
HPer1 : Per A B P'
HTS : TS B C P P'
HCongA : CongA C B P' A B C
H3 : not (eq P' Q')
H14 : not (eq A C)
H8 : not (eq C P)
H11 : not (eq B P')
H6 : not (eq C P')
HQ'1 : Reflect Q Q' B C
HQ' : ReflectL Q Q' B C
Q' : Tpoint
HNCol2 : not (Col B C P')
HP'1 : Reflect P P' B C
HP' : ReflectL P P' B C
P' : Tpoint
HNCol1 : not (Col B C P)
HNCol : not (Col A B C)
H0 : not (eq D F)
H9 : not (eq E F)
H7 : not (eq D E)
H5 : not (eq B C)
H2 : not (eq P B)
H1 : not (eq A B)
H : not (eq B Q)
HCop : Coplanar A B C Q
HPerP : Per B P Q
HPQ : not (eq P Q)
HOut : Out B P A
HSuma : SumA A B C A B C D E F
HPer : Per D E F
HAcute : Acute A B C
A,B,C,D,E,F,P,Q : Tpoint
lotschnitt : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Y : Tpoint => and (Out B C Y) (Col P Q Y))
+++++
assert (Coplanar P C A B) by Cop.
-----
Lemma bachmann_s_lotschnittaxiom__weak_inverse_projection_postulate : bachmann_s_lotschnittaxiom -> weak_inverse_projection_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro lotschnitt.
intros A B C D E F P Q HAcute HPer HSuma HOut HPQ HPerP HCop.
suma.assert_diffs.
assert (HNCol : ~ Col A B C).
assert (HNCol1 : ~ Col B C P) by (intro; apply HNCol; ColR).
destruct (l10_6_existence_spec B C P) as [P' HP']; trivial.
assert (HP'1 : Reflect P P' B C) by (apply is_image_is_image_spec; auto).
assert (HNCol2 : ~ Col B C P') by (apply osym_not_col with P; trivial).
destruct (l10_6_existence_spec B C Q) as [Q' HQ']; trivial.
assert (HQ'1 : Reflect Q Q' B C) by (apply is_image_is_image_spec; auto).
assert_diffs.
assert (P' <> Q').
intro; subst Q'; assert (P = Q) by (apply (l10_2_uniqueness B C P'); assumption); auto.
apply l6_6 in HOut.
assert (HCongA : CongA C B P' A B C).
apply out_conga with C P' P C; try (apply out_trivial); auto.
apply conga_sym, conga_left_comm, reflectl__conga; auto.
apply is_image_spec_rev, HP'.
assert (HTS : TS B C P P').
repeat split; Col; destruct HP' as [[X [HX1 HX2]] _]; exists X; split; Col; Between.
assert (HPer1 : Per A B P').
assert (HNCol3 : ~ Col A B P') by (apply per_not_col; auto).
assert (HNCol4 : ~ Col B P' P) by (intro; apply HNCol3; ColR).
assert (HPerp1 : Perp A B B P') by (apply per_perp; auto).
assert (HPerp2 : Perp A B P Q) by (apply perp_left_comm, perp_col with P; Col; apply per_perp; auto).
assert (HPerp3 : Perp B P' P' Q').
apply per_perp; auto; apply image_spec_preserves_per with B P Q B C; trivial; apply col__refl; Col.
assert (HNCol5 : ~ Col P' P Q).
apply (par_not_col B P'); Col.
apply par_not_col_strict with P; Col.
apply l12_9 with A B; Perp; Cop.
assert (Coplanar P' C A B) by (apply col2_cop__cop with P B; Col; Cop).
CopR.
assert (HI := HPerp2); destruct HI as [I [_ [_ [HCol1 [HCol2 _]]]]].
assert (Coplanar P' C A B) by (apply col2_cop__cop with P B; Col; Cop).
assert (Coplanar P C A B) by Cop.

*****
H10 : Coplanar P C A B
H4 : Coplanar P' C A B
HCol2 : Col I P Q
HCol1 : Col I A B
I : Tpoint
HNCol5 : not (Col P' P Q)
HPerp3 : Perp B P' P' Q'
HPerp2 : Perp A B P Q
HPerp1 : Perp A B B P'
HNCol4 : not (Col B P' P)
HNCol3 : not (Col A B P')
HPer1 : Per A B P'
HTS : TS B C P P'
HCongA : CongA C B P' A B C
H3 : not (eq P' Q')
H14 : not (eq A C)
H8 : not (eq C P)
H11 : not (eq B P')
H6 : not (eq C P')
HQ'1 : Reflect Q Q' B C
HQ' : ReflectL Q Q' B C
Q' : Tpoint
HNCol2 : not (Col B C P')
HP'1 : Reflect P P' B C
HP' : ReflectL P P' B C
P' : Tpoint
HNCol1 : not (Col B C P)
HNCol : not (Col A B C)
H0 : not (eq D F)
H9 : not (eq E F)
H7 : not (eq D E)
H5 : not (eq B C)
H2 : not (eq P B)
H1 : not (eq A B)
H : not (eq B Q)
HCop : Coplanar A B C Q
HPerP : Per B P Q
HPQ : not (eq P Q)
HOut : Out B P A
HSuma : SumA A B C A B C D E F
HPer : Per D E F
HAcute : Acute A B C
A,B,C,D,E,F,P,Q : Tpoint
lotschnitt : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Y : Tpoint => and (Out B C Y) (Col P Q Y))
+++++
assert (Coplanar Q Q' B C) by Cop.
-----
Lemma bachmann_s_lotschnittaxiom__weak_inverse_projection_postulate : bachmann_s_lotschnittaxiom -> weak_inverse_projection_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro lotschnitt.
intros A B C D E F P Q HAcute HPer HSuma HOut HPQ HPerP HCop.
suma.assert_diffs.
assert (HNCol : ~ Col A B C).
assert (HNCol1 : ~ Col B C P) by (intro; apply HNCol; ColR).
destruct (l10_6_existence_spec B C P) as [P' HP']; trivial.
assert (HP'1 : Reflect P P' B C) by (apply is_image_is_image_spec; auto).
assert (HNCol2 : ~ Col B C P') by (apply osym_not_col with P; trivial).
destruct (l10_6_existence_spec B C Q) as [Q' HQ']; trivial.
assert (HQ'1 : Reflect Q Q' B C) by (apply is_image_is_image_spec; auto).
assert_diffs.
assert (P' <> Q').
intro; subst Q'; assert (P = Q) by (apply (l10_2_uniqueness B C P'); assumption); auto.
apply l6_6 in HOut.
assert (HCongA : CongA C B P' A B C).
apply out_conga with C P' P C; try (apply out_trivial); auto.
apply conga_sym, conga_left_comm, reflectl__conga; auto.
apply is_image_spec_rev, HP'.
assert (HTS : TS B C P P').
repeat split; Col; destruct HP' as [[X [HX1 HX2]] _]; exists X; split; Col; Between.
assert (HPer1 : Per A B P').
assert (HNCol3 : ~ Col A B P') by (apply per_not_col; auto).
assert (HNCol4 : ~ Col B P' P) by (intro; apply HNCol3; ColR).
assert (HPerp1 : Perp A B B P') by (apply per_perp; auto).
assert (HPerp2 : Perp A B P Q) by (apply perp_left_comm, perp_col with P; Col; apply per_perp; auto).
assert (HPerp3 : Perp B P' P' Q').
apply per_perp; auto; apply image_spec_preserves_per with B P Q B C; trivial; apply col__refl; Col.
assert (HNCol5 : ~ Col P' P Q).
apply (par_not_col B P'); Col.
apply par_not_col_strict with P; Col.
apply l12_9 with A B; Perp; Cop.
assert (Coplanar P' C A B) by (apply col2_cop__cop with P B; Col; Cop).
CopR.
assert (HI := HPerp2); destruct HI as [I [_ [_ [HCol1 [HCol2 _]]]]].
assert (Coplanar P' C A B) by (apply col2_cop__cop with P B; Col; Cop).
assert (Coplanar P C A B) by Cop.
assert (Coplanar Q Q' B C) by Cop.

*****
H12 : Coplanar Q Q' B C
H10 : Coplanar P C A B
H4 : Coplanar P' C A B
HCol2 : Col I P Q
HCol1 : Col I A B
I : Tpoint
HNCol5 : not (Col P' P Q)
HPerp3 : Perp B P' P' Q'
HPerp2 : Perp A B P Q
HPerp1 : Perp A B B P'
HNCol4 : not (Col B P' P)
HNCol3 : not (Col A B P')
HPer1 : Per A B P'
HTS : TS B C P P'
HCongA : CongA C B P' A B C
H3 : not (eq P' Q')
H14 : not (eq A C)
H8 : not (eq C P)
H11 : not (eq B P')
H6 : not (eq C P')
HQ'1 : Reflect Q Q' B C
HQ' : ReflectL Q Q' B C
Q' : Tpoint
HNCol2 : not (Col B C P')
HP'1 : Reflect P P' B C
HP' : ReflectL P P' B C
P' : Tpoint
HNCol1 : not (Col B C P)
HNCol : not (Col A B C)
H0 : not (eq D F)
H9 : not (eq E F)
H7 : not (eq D E)
H5 : not (eq B C)
H2 : not (eq P B)
H1 : not (eq A B)
H : not (eq B Q)
HCop : Coplanar A B C Q
HPerP : Per B P Q
HPQ : not (eq P Q)
HOut : Out B P A
HSuma : SumA A B C A B C D E F
HPer : Per D E F
HAcute : Acute A B C
A,B,C,D,E,F,P,Q : Tpoint
lotschnitt : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Y : Tpoint => and (Out B C Y) (Col P Q Y))
+++++
destruct (lotschnitt A B B P' P Q P' Q' B P P') as [Y [HY1 HY2]]; Col; try CopR.
-----
Lemma bachmann_s_lotschnittaxiom__weak_inverse_projection_postulate : bachmann_s_lotschnittaxiom -> weak_inverse_projection_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro lotschnitt.
intros A B C D E F P Q HAcute HPer HSuma HOut HPQ HPerP HCop.
suma.assert_diffs.
assert (HNCol : ~ Col A B C).
assert (HNCol1 : ~ Col B C P) by (intro; apply HNCol; ColR).
destruct (l10_6_existence_spec B C P) as [P' HP']; trivial.
assert (HP'1 : Reflect P P' B C) by (apply is_image_is_image_spec; auto).
assert (HNCol2 : ~ Col B C P') by (apply osym_not_col with P; trivial).
destruct (l10_6_existence_spec B C Q) as [Q' HQ']; trivial.
assert (HQ'1 : Reflect Q Q' B C) by (apply is_image_is_image_spec; auto).
assert_diffs.
assert (P' <> Q').
intro; subst Q'; assert (P = Q) by (apply (l10_2_uniqueness B C P'); assumption); auto.
apply l6_6 in HOut.
assert (HCongA : CongA C B P' A B C).
apply out_conga with C P' P C; try (apply out_trivial); auto.
apply conga_sym, conga_left_comm, reflectl__conga; auto.
apply is_image_spec_rev, HP'.
assert (HTS : TS B C P P').
repeat split; Col; destruct HP' as [[X [HX1 HX2]] _]; exists X; split; Col; Between.
assert (HPer1 : Per A B P').
assert (HNCol3 : ~ Col A B P') by (apply per_not_col; auto).
assert (HNCol4 : ~ Col B P' P) by (intro; apply HNCol3; ColR).
assert (HPerp1 : Perp A B B P') by (apply per_perp; auto).
assert (HPerp2 : Perp A B P Q) by (apply perp_left_comm, perp_col with P; Col; apply per_perp; auto).
assert (HPerp3 : Perp B P' P' Q').
apply per_perp; auto; apply image_spec_preserves_per with B P Q B C; trivial; apply col__refl; Col.
assert (HNCol5 : ~ Col P' P Q).
apply (par_not_col B P'); Col.
apply par_not_col_strict with P; Col.
apply l12_9 with A B; Perp; Cop.
assert (Coplanar P' C A B) by (apply col2_cop__cop with P B; Col; Cop).
CopR.
assert (HI := HPerp2); destruct HI as [I [_ [_ [HCol1 [HCol2 _]]]]].
assert (Coplanar P' C A B) by (apply col2_cop__cop with P B; Col; Cop).
assert (Coplanar P C A B) by Cop.
assert (Coplanar Q Q' B C) by Cop.
destruct (lotschnitt A B B P' P Q P' Q' B P P') as [Y [HY1 HY2]]; Col; try CopR.

*****
H12 : Coplanar Q Q' B C
H10 : Coplanar P C A B
H4 : Coplanar P' C A B
HCol2 : Col I P Q
HCol1 : Col I A B
I : Tpoint
HNCol5 : not (Col P' P Q)
HPerp3 : Perp B P' P' Q'
HPerp2 : Perp A B P Q
HPerp1 : Perp A B B P'
HNCol4 : not (Col B P' P)
HNCol3 : not (Col A B P')
HPer1 : Per A B P'
HTS : TS B C P P'
HCongA : CongA C B P' A B C
H3 : not (eq P' Q')
H14 : not (eq A C)
H8 : not (eq C P)
H11 : not (eq B P')
H6 : not (eq C P')
HQ'1 : Reflect Q Q' B C
HQ' : ReflectL Q Q' B C
Q' : Tpoint
HNCol2 : not (Col B C P')
HP'1 : Reflect P P' B C
HP' : ReflectL P P' B C
P' : Tpoint
HNCol1 : not (Col B C P)
HNCol : not (Col A B C)
H0 : not (eq D F)
H9 : not (eq E F)
H7 : not (eq D E)
H5 : not (eq B C)
H2 : not (eq P B)
H1 : not (eq A B)
H : not (eq B Q)
HCop : Coplanar A B C Q
HPerP : Per B P Q
HPQ : not (eq P Q)
HOut : Out B P A
HSuma : SumA A B C A B C D E F
HPer : Per D E F
HAcute : Acute A B C
A,B,C,D,E,F,P,Q : Tpoint
lotschnitt : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar B P P' Q'
+++++
elim (col_dec B C Q); intro; [|CopR].
-----
Lemma bachmann_s_lotschnittaxiom__weak_inverse_projection_postulate : bachmann_s_lotschnittaxiom -> weak_inverse_projection_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro lotschnitt.
intros A B C D E F P Q HAcute HPer HSuma HOut HPQ HPerP HCop.
suma.assert_diffs.
assert (HNCol : ~ Col A B C).
assert (HNCol1 : ~ Col B C P) by (intro; apply HNCol; ColR).
destruct (l10_6_existence_spec B C P) as [P' HP']; trivial.
assert (HP'1 : Reflect P P' B C) by (apply is_image_is_image_spec; auto).
assert (HNCol2 : ~ Col B C P') by (apply osym_not_col with P; trivial).
destruct (l10_6_existence_spec B C Q) as [Q' HQ']; trivial.
assert (HQ'1 : Reflect Q Q' B C) by (apply is_image_is_image_spec; auto).
assert_diffs.
assert (P' <> Q').
intro; subst Q'; assert (P = Q) by (apply (l10_2_uniqueness B C P'); assumption); auto.
apply l6_6 in HOut.
assert (HCongA : CongA C B P' A B C).
apply out_conga with C P' P C; try (apply out_trivial); auto.
apply conga_sym, conga_left_comm, reflectl__conga; auto.
apply is_image_spec_rev, HP'.
assert (HTS : TS B C P P').
repeat split; Col; destruct HP' as [[X [HX1 HX2]] _]; exists X; split; Col; Between.
assert (HPer1 : Per A B P').
assert (HNCol3 : ~ Col A B P') by (apply per_not_col; auto).
assert (HNCol4 : ~ Col B P' P) by (intro; apply HNCol3; ColR).
assert (HPerp1 : Perp A B B P') by (apply per_perp; auto).
assert (HPerp2 : Perp A B P Q) by (apply perp_left_comm, perp_col with P; Col; apply per_perp; auto).
assert (HPerp3 : Perp B P' P' Q').
apply per_perp; auto; apply image_spec_preserves_per with B P Q B C; trivial; apply col__refl; Col.
assert (HNCol5 : ~ Col P' P Q).
apply (par_not_col B P'); Col.
apply par_not_col_strict with P; Col.
apply l12_9 with A B; Perp; Cop.
assert (Coplanar P' C A B) by (apply col2_cop__cop with P B; Col; Cop).
CopR.
assert (HI := HPerp2); destruct HI as [I [_ [_ [HCol1 [HCol2 _]]]]].
assert (Coplanar P' C A B) by (apply col2_cop__cop with P B; Col; Cop).
assert (Coplanar P C A B) by Cop.
assert (Coplanar Q Q' B C) by Cop.
destruct (lotschnitt A B B P' P Q P' Q' B P P') as [Y [HY1 HY2]]; Col; try CopR.
elim (col_dec B C Q); intro; [|CopR].

*****
H13 : Col B C Q
H12 : Coplanar Q Q' B C
H10 : Coplanar P C A B
H4 : Coplanar P' C A B
HCol2 : Col I P Q
HCol1 : Col I A B
I : Tpoint
HNCol5 : not (Col P' P Q)
HPerp3 : Perp B P' P' Q'
HPerp2 : Perp A B P Q
HPerp1 : Perp A B B P'
HNCol4 : not (Col B P' P)
HNCol3 : not (Col A B P')
HPer1 : Per A B P'
HTS : TS B C P P'
HCongA : CongA C B P' A B C
H3 : not (eq P' Q')
H14 : not (eq A C)
H8 : not (eq C P)
H11 : not (eq B P')
H6 : not (eq C P')
HQ'1 : Reflect Q Q' B C
HQ' : ReflectL Q Q' B C
Q' : Tpoint
HNCol2 : not (Col B C P')
HP'1 : Reflect P P' B C
HP' : ReflectL P P' B C
P' : Tpoint
HNCol1 : not (Col B C P)
HNCol : not (Col A B C)
H0 : not (eq D F)
H9 : not (eq E F)
H7 : not (eq D E)
H5 : not (eq B C)
H2 : not (eq P B)
H1 : not (eq A B)
H : not (eq B Q)
HCop : Coplanar A B C Q
HPerP : Per B P Q
HPQ : not (eq P Q)
HOut : Out B P A
HSuma : SumA A B C A B C D E F
HPer : Per D E F
HAcute : Acute A B C
A,B,C,D,E,F,P,Q : Tpoint
lotschnitt : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar B P P' Q'
+++++
assert (Q = Q'); [|treat_equalities; CopR].
-----
Lemma bachmann_s_lotschnittaxiom__weak_inverse_projection_postulate : bachmann_s_lotschnittaxiom -> weak_inverse_projection_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro lotschnitt.
intros A B C D E F P Q HAcute HPer HSuma HOut HPQ HPerP HCop.
suma.assert_diffs.
assert (HNCol : ~ Col A B C).
assert (HNCol1 : ~ Col B C P) by (intro; apply HNCol; ColR).
destruct (l10_6_existence_spec B C P) as [P' HP']; trivial.
assert (HP'1 : Reflect P P' B C) by (apply is_image_is_image_spec; auto).
assert (HNCol2 : ~ Col B C P') by (apply osym_not_col with P; trivial).
destruct (l10_6_existence_spec B C Q) as [Q' HQ']; trivial.
assert (HQ'1 : Reflect Q Q' B C) by (apply is_image_is_image_spec; auto).
assert_diffs.
assert (P' <> Q').
intro; subst Q'; assert (P = Q) by (apply (l10_2_uniqueness B C P'); assumption); auto.
apply l6_6 in HOut.
assert (HCongA : CongA C B P' A B C).
apply out_conga with C P' P C; try (apply out_trivial); auto.
apply conga_sym, conga_left_comm, reflectl__conga; auto.
apply is_image_spec_rev, HP'.
assert (HTS : TS B C P P').
repeat split; Col; destruct HP' as [[X [HX1 HX2]] _]; exists X; split; Col; Between.
assert (HPer1 : Per A B P').
assert (HNCol3 : ~ Col A B P') by (apply per_not_col; auto).
assert (HNCol4 : ~ Col B P' P) by (intro; apply HNCol3; ColR).
assert (HPerp1 : Perp A B B P') by (apply per_perp; auto).
assert (HPerp2 : Perp A B P Q) by (apply perp_left_comm, perp_col with P; Col; apply per_perp; auto).
assert (HPerp3 : Perp B P' P' Q').
apply per_perp; auto; apply image_spec_preserves_per with B P Q B C; trivial; apply col__refl; Col.
assert (HNCol5 : ~ Col P' P Q).
apply (par_not_col B P'); Col.
apply par_not_col_strict with P; Col.
apply l12_9 with A B; Perp; Cop.
assert (Coplanar P' C A B) by (apply col2_cop__cop with P B; Col; Cop).
CopR.
assert (HI := HPerp2); destruct HI as [I [_ [_ [HCol1 [HCol2 _]]]]].
assert (Coplanar P' C A B) by (apply col2_cop__cop with P B; Col; Cop).
assert (Coplanar P C A B) by Cop.
assert (Coplanar Q Q' B C) by Cop.
destruct (lotschnitt A B B P' P Q P' Q' B P P') as [Y [HY1 HY2]]; Col; try CopR.
elim (col_dec B C Q); intro; [|CopR].
assert (Q = Q'); [|treat_equalities; CopR].

*****
H13 : Col B C Q
H12 : Coplanar Q Q' B C
H10 : Coplanar P C A B
H4 : Coplanar P' C A B
HCol2 : Col I P Q
HCol1 : Col I A B
I : Tpoint
HNCol5 : not (Col P' P Q)
HPerp3 : Perp B P' P' Q'
HPerp2 : Perp A B P Q
HPerp1 : Perp A B B P'
HNCol4 : not (Col B P' P)
HNCol3 : not (Col A B P')
HPer1 : Per A B P'
HTS : TS B C P P'
HCongA : CongA C B P' A B C
H3 : not (eq P' Q')
H14 : not (eq A C)
H8 : not (eq C P)
H11 : not (eq B P')
H6 : not (eq C P')
HQ'1 : Reflect Q Q' B C
HQ' : ReflectL Q Q' B C
Q' : Tpoint
HNCol2 : not (Col B C P')
HP'1 : Reflect P P' B C
HP' : ReflectL P P' B C
P' : Tpoint
HNCol1 : not (Col B C P)
HNCol : not (Col A B C)
H0 : not (eq D F)
H9 : not (eq E F)
H7 : not (eq D E)
H5 : not (eq B C)
H2 : not (eq P B)
H1 : not (eq A B)
H : not (eq B Q)
HCop : Coplanar A B C Q
HPerP : Per B P Q
HPQ : not (eq P Q)
HOut : Out B P A
HSuma : SumA A B C A B C D E F
HPer : Per D E F
HAcute : Acute A B C
A,B,C,D,E,F,P,Q : Tpoint
lotschnitt : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
eq Q Q'
+++++
apply col_image_spec__eq with B C; Col.
-----
Lemma bachmann_s_lotschnittaxiom__weak_inverse_projection_postulate : bachmann_s_lotschnittaxiom -> weak_inverse_projection_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro lotschnitt.
intros A B C D E F P Q HAcute HPer HSuma HOut HPQ HPerP HCop.
suma.assert_diffs.
assert (HNCol : ~ Col A B C).
assert (HNCol1 : ~ Col B C P) by (intro; apply HNCol; ColR).
destruct (l10_6_existence_spec B C P) as [P' HP']; trivial.
assert (HP'1 : Reflect P P' B C) by (apply is_image_is_image_spec; auto).
assert (HNCol2 : ~ Col B C P') by (apply osym_not_col with P; trivial).
destruct (l10_6_existence_spec B C Q) as [Q' HQ']; trivial.
assert (HQ'1 : Reflect Q Q' B C) by (apply is_image_is_image_spec; auto).
assert_diffs.
assert (P' <> Q').
intro; subst Q'; assert (P = Q) by (apply (l10_2_uniqueness B C P'); assumption); auto.
apply l6_6 in HOut.
assert (HCongA : CongA C B P' A B C).
apply out_conga with C P' P C; try (apply out_trivial); auto.
apply conga_sym, conga_left_comm, reflectl__conga; auto.
apply is_image_spec_rev, HP'.
assert (HTS : TS B C P P').
repeat split; Col; destruct HP' as [[X [HX1 HX2]] _]; exists X; split; Col; Between.
assert (HPer1 : Per A B P').
assert (HNCol3 : ~ Col A B P') by (apply per_not_col; auto).
assert (HNCol4 : ~ Col B P' P) by (intro; apply HNCol3; ColR).
assert (HPerp1 : Perp A B B P') by (apply per_perp; auto).
assert (HPerp2 : Perp A B P Q) by (apply perp_left_comm, perp_col with P; Col; apply per_perp; auto).
assert (HPerp3 : Perp B P' P' Q').
apply per_perp; auto; apply image_spec_preserves_per with B P Q B C; trivial; apply col__refl; Col.
assert (HNCol5 : ~ Col P' P Q).
apply (par_not_col B P'); Col.
apply par_not_col_strict with P; Col.
apply l12_9 with A B; Perp; Cop.
assert (Coplanar P' C A B) by (apply col2_cop__cop with P B; Col; Cop).
CopR.
assert (HI := HPerp2); destruct HI as [I [_ [_ [HCol1 [HCol2 _]]]]].
assert (Coplanar P' C A B) by (apply col2_cop__cop with P B; Col; Cop).
assert (Coplanar P C A B) by Cop.
assert (Coplanar Q Q' B C) by Cop.
destruct (lotschnitt A B B P' P Q P' Q' B P P') as [Y [HY1 HY2]]; Col; try CopR.

*****
HY2 : Col P' Q' Y
HY1 : Col P Q Y
Y : Tpoint
H12 : Coplanar Q Q' B C
H10 : Coplanar P C A B
H4 : Coplanar P' C A B
HCol2 : Col I P Q
HCol1 : Col I A B
I : Tpoint
HNCol5 : not (Col P' P Q)
HPerp3 : Perp B P' P' Q'
HPerp2 : Perp A B P Q
HPerp1 : Perp A B B P'
HNCol4 : not (Col B P' P)
HNCol3 : not (Col A B P')
HPer1 : Per A B P'
HTS : TS B C P P'
HCongA : CongA C B P' A B C
H3 : not (eq P' Q')
H14 : not (eq A C)
H8 : not (eq C P)
H11 : not (eq B P')
H6 : not (eq C P')
HQ'1 : Reflect Q Q' B C
HQ' : ReflectL Q Q' B C
Q' : Tpoint
HNCol2 : not (Col B C P')
HP'1 : Reflect P P' B C
HP' : ReflectL P P' B C
P' : Tpoint
HNCol1 : not (Col B C P)
HNCol : not (Col A B C)
H0 : not (eq D F)
H9 : not (eq E F)
H7 : not (eq D E)
H5 : not (eq B C)
H2 : not (eq P B)
H1 : not (eq A B)
H : not (eq B Q)
HCop : Coplanar A B C Q
HPerP : Per B P Q
HPQ : not (eq P Q)
HOut : Out B P A
HSuma : SumA A B C A B C D E F
HPer : Per D E F
HAcute : Acute A B C
A,B,C,D,E,F,P,Q : Tpoint
lotschnitt : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Y : Tpoint => and (Out B C Y) (Col P Q Y))
+++++
exists Y; split; trivial.
-----
Lemma bachmann_s_lotschnittaxiom__weak_inverse_projection_postulate : bachmann_s_lotschnittaxiom -> weak_inverse_projection_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro lotschnitt.
intros A B C D E F P Q HAcute HPer HSuma HOut HPQ HPerP HCop.
suma.assert_diffs.
assert (HNCol : ~ Col A B C).
assert (HNCol1 : ~ Col B C P) by (intro; apply HNCol; ColR).
destruct (l10_6_existence_spec B C P) as [P' HP']; trivial.
assert (HP'1 : Reflect P P' B C) by (apply is_image_is_image_spec; auto).
assert (HNCol2 : ~ Col B C P') by (apply osym_not_col with P; trivial).
destruct (l10_6_existence_spec B C Q) as [Q' HQ']; trivial.
assert (HQ'1 : Reflect Q Q' B C) by (apply is_image_is_image_spec; auto).
assert_diffs.
assert (P' <> Q').
intro; subst Q'; assert (P = Q) by (apply (l10_2_uniqueness B C P'); assumption); auto.
apply l6_6 in HOut.
assert (HCongA : CongA C B P' A B C).
apply out_conga with C P' P C; try (apply out_trivial); auto.
apply conga_sym, conga_left_comm, reflectl__conga; auto.
apply is_image_spec_rev, HP'.
assert (HTS : TS B C P P').
repeat split; Col; destruct HP' as [[X [HX1 HX2]] _]; exists X; split; Col; Between.
assert (HPer1 : Per A B P').
assert (HNCol3 : ~ Col A B P') by (apply per_not_col; auto).
assert (HNCol4 : ~ Col B P' P) by (intro; apply HNCol3; ColR).
assert (HPerp1 : Perp A B B P') by (apply per_perp; auto).
assert (HPerp2 : Perp A B P Q) by (apply perp_left_comm, perp_col with P; Col; apply per_perp; auto).
assert (HPerp3 : Perp B P' P' Q').
apply per_perp; auto; apply image_spec_preserves_per with B P Q B C; trivial; apply col__refl; Col.
assert (HNCol5 : ~ Col P' P Q).
apply (par_not_col B P'); Col.
apply par_not_col_strict with P; Col.
apply l12_9 with A B; Perp; Cop.
assert (Coplanar P' C A B) by (apply col2_cop__cop with P B; Col; Cop).
CopR.
assert (HI := HPerp2); destruct HI as [I [_ [_ [HCol1 [HCol2 _]]]]].
assert (Coplanar P' C A B) by (apply col2_cop__cop with P B; Col; Cop).
assert (Coplanar P C A B) by Cop.
assert (Coplanar Q Q' B C) by Cop.
destruct (lotschnitt A B B P' P Q P' Q' B P P') as [Y [HY1 HY2]]; Col; try CopR.
exists Y; split; trivial.

*****
HY2 : Col P' Q' Y
HY1 : Col P Q Y
Y : Tpoint
H12 : Coplanar Q Q' B C
H10 : Coplanar P C A B
H4 : Coplanar P' C A B
HCol2 : Col I P Q
HCol1 : Col I A B
I : Tpoint
HNCol5 : not (Col P' P Q)
HPerp3 : Perp B P' P' Q'
HPerp2 : Perp A B P Q
HPerp1 : Perp A B B P'
HNCol4 : not (Col B P' P)
HNCol3 : not (Col A B P')
HPer1 : Per A B P'
HTS : TS B C P P'
HCongA : CongA C B P' A B C
H3 : not (eq P' Q')
H14 : not (eq A C)
H8 : not (eq C P)
H11 : not (eq B P')
H6 : not (eq C P')
HQ'1 : Reflect Q Q' B C
HQ' : ReflectL Q Q' B C
Q' : Tpoint
HNCol2 : not (Col B C P')
HP'1 : Reflect P P' B C
HP' : ReflectL P P' B C
P' : Tpoint
HNCol1 : not (Col B C P)
HNCol : not (Col A B C)
H0 : not (eq D F)
H9 : not (eq E F)
H7 : not (eq D E)
H5 : not (eq B C)
H2 : not (eq P B)
H1 : not (eq A B)
H : not (eq B Q)
HCop : Coplanar A B C Q
HPerP : Per B P Q
HPQ : not (eq P Q)
HOut : Out B P A
HSuma : SumA A B C A B C D E F
HPer : Per D E F
HAcute : Acute A B C
A,B,C,D,E,F,P,Q : Tpoint
lotschnitt : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out B C Y
+++++
apply col_one_side_out with A.
-----
Lemma bachmann_s_lotschnittaxiom__weak_inverse_projection_postulate : bachmann_s_lotschnittaxiom -> weak_inverse_projection_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro lotschnitt.
intros A B C D E F P Q HAcute HPer HSuma HOut HPQ HPerP HCop.
suma.assert_diffs.
assert (HNCol : ~ Col A B C).
assert (HNCol1 : ~ Col B C P) by (intro; apply HNCol; ColR).
destruct (l10_6_existence_spec B C P) as [P' HP']; trivial.
assert (HP'1 : Reflect P P' B C) by (apply is_image_is_image_spec; auto).
assert (HNCol2 : ~ Col B C P') by (apply osym_not_col with P; trivial).
destruct (l10_6_existence_spec B C Q) as [Q' HQ']; trivial.
assert (HQ'1 : Reflect Q Q' B C) by (apply is_image_is_image_spec; auto).
assert_diffs.
assert (P' <> Q').
intro; subst Q'; assert (P = Q) by (apply (l10_2_uniqueness B C P'); assumption); auto.
apply l6_6 in HOut.
assert (HCongA : CongA C B P' A B C).
apply out_conga with C P' P C; try (apply out_trivial); auto.
apply conga_sym, conga_left_comm, reflectl__conga; auto.
apply is_image_spec_rev, HP'.
assert (HTS : TS B C P P').
repeat split; Col; destruct HP' as [[X [HX1 HX2]] _]; exists X; split; Col; Between.
assert (HPer1 : Per A B P').
assert (HNCol3 : ~ Col A B P') by (apply per_not_col; auto).
assert (HNCol4 : ~ Col B P' P) by (intro; apply HNCol3; ColR).
assert (HPerp1 : Perp A B B P') by (apply per_perp; auto).
assert (HPerp2 : Perp A B P Q) by (apply perp_left_comm, perp_col with P; Col; apply per_perp; auto).
assert (HPerp3 : Perp B P' P' Q').
apply per_perp; auto; apply image_spec_preserves_per with B P Q B C; trivial; apply col__refl; Col.
assert (HNCol5 : ~ Col P' P Q).
apply (par_not_col B P'); Col.
apply par_not_col_strict with P; Col.
apply l12_9 with A B; Perp; Cop.
assert (Coplanar P' C A B) by (apply col2_cop__cop with P B; Col; Cop).
CopR.
assert (HI := HPerp2); destruct HI as [I [_ [_ [HCol1 [HCol2 _]]]]].
assert (Coplanar P' C A B) by (apply col2_cop__cop with P B; Col; Cop).
assert (Coplanar P C A B) by Cop.
assert (Coplanar Q Q' B C) by Cop.
destruct (lotschnitt A B B P' P Q P' Q' B P P') as [Y [HY1 HY2]]; Col; try CopR.
exists Y; split; trivial.
apply col_one_side_out with A.

*****
HY2 : Col P' Q' Y
HY1 : Col P Q Y
Y : Tpoint
H12 : Coplanar Q Q' B C
H10 : Coplanar P C A B
H4 : Coplanar P' C A B
HCol2 : Col I P Q
HCol1 : Col I A B
I : Tpoint
HNCol5 : not (Col P' P Q)
HPerp3 : Perp B P' P' Q'
HPerp2 : Perp A B P Q
HPerp1 : Perp A B B P'
HNCol4 : not (Col B P' P)
HNCol3 : not (Col A B P')
HPer1 : Per A B P'
HTS : TS B C P P'
HCongA : CongA C B P' A B C
H3 : not (eq P' Q')
H14 : not (eq A C)
H8 : not (eq C P)
H11 : not (eq B P')
H6 : not (eq C P')
HQ'1 : Reflect Q Q' B C
HQ' : ReflectL Q Q' B C
Q' : Tpoint
HNCol2 : not (Col B C P')
HP'1 : Reflect P P' B C
HP' : ReflectL P P' B C
P' : Tpoint
HNCol1 : not (Col B C P)
HNCol : not (Col A B C)
H0 : not (eq D F)
H9 : not (eq E F)
H7 : not (eq D E)
H5 : not (eq B C)
H2 : not (eq P B)
H1 : not (eq A B)
H : not (eq B Q)
HCop : Coplanar A B C Q
HPerP : Per B P Q
HPQ : not (eq P Q)
HOut : Out B P A
HSuma : SumA A B C A B C D E F
HPer : Per D E F
HAcute : Acute A B C
A,B,C,D,E,F,P,Q : Tpoint
lotschnitt : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col B C Y
+++++
apply col_permutation_1, intersection_with_image_gen with P Q P' Q'; Col.
-----
Lemma bachmann_s_lotschnittaxiom__weak_inverse_projection_postulate : bachmann_s_lotschnittaxiom -> weak_inverse_projection_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro lotschnitt.
intros A B C D E F P Q HAcute HPer HSuma HOut HPQ HPerP HCop.
suma.assert_diffs.
assert (HNCol : ~ Col A B C).
assert (HNCol1 : ~ Col B C P) by (intro; apply HNCol; ColR).
destruct (l10_6_existence_spec B C P) as [P' HP']; trivial.
assert (HP'1 : Reflect P P' B C) by (apply is_image_is_image_spec; auto).
assert (HNCol2 : ~ Col B C P') by (apply osym_not_col with P; trivial).
destruct (l10_6_existence_spec B C Q) as [Q' HQ']; trivial.
assert (HQ'1 : Reflect Q Q' B C) by (apply is_image_is_image_spec; auto).
assert_diffs.
assert (P' <> Q').
intro; subst Q'; assert (P = Q) by (apply (l10_2_uniqueness B C P'); assumption); auto.
apply l6_6 in HOut.
assert (HCongA : CongA C B P' A B C).
apply out_conga with C P' P C; try (apply out_trivial); auto.
apply conga_sym, conga_left_comm, reflectl__conga; auto.
apply is_image_spec_rev, HP'.
assert (HTS : TS B C P P').
repeat split; Col; destruct HP' as [[X [HX1 HX2]] _]; exists X; split; Col; Between.
assert (HPer1 : Per A B P').
assert (HNCol3 : ~ Col A B P') by (apply per_not_col; auto).
assert (HNCol4 : ~ Col B P' P) by (intro; apply HNCol3; ColR).
assert (HPerp1 : Perp A B B P') by (apply per_perp; auto).
assert (HPerp2 : Perp A B P Q) by (apply perp_left_comm, perp_col with P; Col; apply per_perp; auto).
assert (HPerp3 : Perp B P' P' Q').
apply per_perp; auto; apply image_spec_preserves_per with B P Q B C; trivial; apply col__refl; Col.
assert (HNCol5 : ~ Col P' P Q).
apply (par_not_col B P'); Col.
apply par_not_col_strict with P; Col.
apply l12_9 with A B; Perp; Cop.
assert (Coplanar P' C A B) by (apply col2_cop__cop with P B; Col; Cop).
CopR.
assert (HI := HPerp2); destruct HI as [I [_ [_ [HCol1 [HCol2 _]]]]].
assert (Coplanar P' C A B) by (apply col2_cop__cop with P B; Col; Cop).
assert (Coplanar P C A B) by Cop.
assert (Coplanar Q Q' B C) by Cop.
destruct (lotschnitt A B B P' P Q P' Q' B P P') as [Y [HY1 HY2]]; Col; try CopR.
exists Y; split; trivial.
apply col_one_side_out with A.
apply col_permutation_1, intersection_with_image_gen with P Q P' Q'; Col.

*****
HY2 : Col P' Q' Y
HY1 : Col P Q Y
Y : Tpoint
H12 : Coplanar Q Q' B C
H10 : Coplanar P C A B
H4 : Coplanar P' C A B
HCol2 : Col I P Q
HCol1 : Col I A B
I : Tpoint
HNCol5 : not (Col P' P Q)
HPerp3 : Perp B P' P' Q'
HPerp2 : Perp A B P Q
HPerp1 : Perp A B B P'
HNCol4 : not (Col B P' P)
HNCol3 : not (Col A B P')
HPer1 : Per A B P'
HTS : TS B C P P'
HCongA : CongA C B P' A B C
H3 : not (eq P' Q')
H14 : not (eq A C)
H8 : not (eq C P)
H11 : not (eq B P')
H6 : not (eq C P')
HQ'1 : Reflect Q Q' B C
HQ' : ReflectL Q Q' B C
Q' : Tpoint
HNCol2 : not (Col B C P')
HP'1 : Reflect P P' B C
HP' : ReflectL P P' B C
P' : Tpoint
HNCol1 : not (Col B C P)
HNCol : not (Col A B C)
H0 : not (eq D F)
H9 : not (eq E F)
H7 : not (eq D E)
H5 : not (eq B C)
H2 : not (eq P B)
H1 : not (eq A B)
H : not (eq B Q)
HCop : Coplanar A B C Q
HPerP : Per B P Q
HPQ : not (eq P Q)
HOut : Out B P A
HSuma : SumA A B C A B C D E F
HPer : Per D E F
HAcute : Acute A B C
A,B,C,D,E,F,P,Q : Tpoint
lotschnitt : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OS B A C Y
+++++
apply invert_one_side, one_side_transitivity with P'.
-----
Lemma bachmann_s_lotschnittaxiom__weak_inverse_projection_postulate : bachmann_s_lotschnittaxiom -> weak_inverse_projection_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro lotschnitt.
intros A B C D E F P Q HAcute HPer HSuma HOut HPQ HPerP HCop.
suma.assert_diffs.
assert (HNCol : ~ Col A B C).
assert (HNCol1 : ~ Col B C P) by (intro; apply HNCol; ColR).
destruct (l10_6_existence_spec B C P) as [P' HP']; trivial.
assert (HP'1 : Reflect P P' B C) by (apply is_image_is_image_spec; auto).
assert (HNCol2 : ~ Col B C P') by (apply osym_not_col with P; trivial).
destruct (l10_6_existence_spec B C Q) as [Q' HQ']; trivial.
assert (HQ'1 : Reflect Q Q' B C) by (apply is_image_is_image_spec; auto).
assert_diffs.
assert (P' <> Q').
intro; subst Q'; assert (P = Q) by (apply (l10_2_uniqueness B C P'); assumption); auto.
apply l6_6 in HOut.
assert (HCongA : CongA C B P' A B C).
apply out_conga with C P' P C; try (apply out_trivial); auto.
apply conga_sym, conga_left_comm, reflectl__conga; auto.
apply is_image_spec_rev, HP'.
assert (HTS : TS B C P P').
repeat split; Col; destruct HP' as [[X [HX1 HX2]] _]; exists X; split; Col; Between.
assert (HPer1 : Per A B P').
assert (HNCol3 : ~ Col A B P') by (apply per_not_col; auto).
assert (HNCol4 : ~ Col B P' P) by (intro; apply HNCol3; ColR).
assert (HPerp1 : Perp A B B P') by (apply per_perp; auto).
assert (HPerp2 : Perp A B P Q) by (apply perp_left_comm, perp_col with P; Col; apply per_perp; auto).
assert (HPerp3 : Perp B P' P' Q').
apply per_perp; auto; apply image_spec_preserves_per with B P Q B C; trivial; apply col__refl; Col.
assert (HNCol5 : ~ Col P' P Q).
apply (par_not_col B P'); Col.
apply par_not_col_strict with P; Col.
apply l12_9 with A B; Perp; Cop.
assert (Coplanar P' C A B) by (apply col2_cop__cop with P B; Col; Cop).
CopR.
assert (HI := HPerp2); destruct HI as [I [_ [_ [HCol1 [HCol2 _]]]]].
assert (Coplanar P' C A B) by (apply col2_cop__cop with P B; Col; Cop).
assert (Coplanar P C A B) by Cop.
assert (Coplanar Q Q' B C) by Cop.
destruct (lotschnitt A B B P' P Q P' Q' B P P') as [Y [HY1 HY2]]; Col; try CopR.
exists Y; split; trivial.
apply col_one_side_out with A.
apply col_permutation_1, intersection_with_image_gen with P Q P' Q'; Col.
apply invert_one_side, one_side_transitivity with P'.

*****
HY2 : Col P' Q' Y
HY1 : Col P Q Y
Y : Tpoint
H12 : Coplanar Q Q' B C
H10 : Coplanar P C A B
H4 : Coplanar P' C A B
HCol2 : Col I P Q
HCol1 : Col I A B
I : Tpoint
HNCol5 : not (Col P' P Q)
HPerp3 : Perp B P' P' Q'
HPerp2 : Perp A B P Q
HPerp1 : Perp A B B P'
HNCol4 : not (Col B P' P)
HNCol3 : not (Col A B P')
HPer1 : Per A B P'
HTS : TS B C P P'
HCongA : CongA C B P' A B C
H3 : not (eq P' Q')
H14 : not (eq A C)
H8 : not (eq C P)
H11 : not (eq B P')
H6 : not (eq C P')
HQ'1 : Reflect Q Q' B C
HQ' : ReflectL Q Q' B C
Q' : Tpoint
HNCol2 : not (Col B C P')
HP'1 : Reflect P P' B C
HP' : ReflectL P P' B C
P' : Tpoint
HNCol1 : not (Col B C P)
HNCol : not (Col A B C)
H0 : not (eq D F)
H9 : not (eq E F)
H7 : not (eq D E)
H5 : not (eq B C)
H2 : not (eq P B)
H1 : not (eq A B)
H : not (eq B Q)
HCop : Coplanar A B C Q
HPerP : Per B P Q
HPQ : not (eq P Q)
HOut : Out B P A
HSuma : SumA A B C A B C D E F
HPer : Per D E F
HAcute : Acute A B C
A,B,C,D,E,F,P,Q : Tpoint
lotschnitt : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OS A B C P'
+++++
apply cop__not_two_sides_one_side; Col.
-----
Lemma bachmann_s_lotschnittaxiom__weak_inverse_projection_postulate : bachmann_s_lotschnittaxiom -> weak_inverse_projection_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro lotschnitt.
intros A B C D E F P Q HAcute HPer HSuma HOut HPQ HPerP HCop.
suma.assert_diffs.
assert (HNCol : ~ Col A B C).
assert (HNCol1 : ~ Col B C P) by (intro; apply HNCol; ColR).
destruct (l10_6_existence_spec B C P) as [P' HP']; trivial.
assert (HP'1 : Reflect P P' B C) by (apply is_image_is_image_spec; auto).
assert (HNCol2 : ~ Col B C P') by (apply osym_not_col with P; trivial).
destruct (l10_6_existence_spec B C Q) as [Q' HQ']; trivial.
assert (HQ'1 : Reflect Q Q' B C) by (apply is_image_is_image_spec; auto).
assert_diffs.
assert (P' <> Q').
intro; subst Q'; assert (P = Q) by (apply (l10_2_uniqueness B C P'); assumption); auto.
apply l6_6 in HOut.
assert (HCongA : CongA C B P' A B C).
apply out_conga with C P' P C; try (apply out_trivial); auto.
apply conga_sym, conga_left_comm, reflectl__conga; auto.
apply is_image_spec_rev, HP'.
assert (HTS : TS B C P P').
repeat split; Col; destruct HP' as [[X [HX1 HX2]] _]; exists X; split; Col; Between.
assert (HPer1 : Per A B P').
assert (HNCol3 : ~ Col A B P') by (apply per_not_col; auto).
assert (HNCol4 : ~ Col B P' P) by (intro; apply HNCol3; ColR).
assert (HPerp1 : Perp A B B P') by (apply per_perp; auto).
assert (HPerp2 : Perp A B P Q) by (apply perp_left_comm, perp_col with P; Col; apply per_perp; auto).
assert (HPerp3 : Perp B P' P' Q').
apply per_perp; auto; apply image_spec_preserves_per with B P Q B C; trivial; apply col__refl; Col.
assert (HNCol5 : ~ Col P' P Q).
apply (par_not_col B P'); Col.
apply par_not_col_strict with P; Col.
apply l12_9 with A B; Perp; Cop.
assert (Coplanar P' C A B) by (apply col2_cop__cop with P B; Col; Cop).
CopR.
assert (HI := HPerp2); destruct HI as [I [_ [_ [HCol1 [HCol2 _]]]]].
assert (Coplanar P' C A B) by (apply col2_cop__cop with P B; Col; Cop).
assert (Coplanar P C A B) by Cop.
assert (Coplanar Q Q' B C) by Cop.
destruct (lotschnitt A B B P' P Q P' Q' B P P') as [Y [HY1 HY2]]; Col; try CopR.
exists Y; split; trivial.
apply col_one_side_out with A.
apply col_permutation_1, intersection_with_image_gen with P Q P' Q'; Col.
apply invert_one_side, one_side_transitivity with P'.
apply cop__not_two_sides_one_side; Col.

*****
HY2 : Col P' Q' Y
HY1 : Col P Q Y
Y : Tpoint
H12 : Coplanar Q Q' B C
H10 : Coplanar P C A B
H4 : Coplanar P' C A B
HCol2 : Col I P Q
HCol1 : Col I A B
I : Tpoint
HNCol5 : not (Col P' P Q)
HPerp3 : Perp B P' P' Q'
HPerp2 : Perp A B P Q
HPerp1 : Perp A B B P'
HNCol4 : not (Col B P' P)
HNCol3 : not (Col A B P')
HPer1 : Per A B P'
HTS : TS B C P P'
HCongA : CongA C B P' A B C
H3 : not (eq P' Q')
H14 : not (eq A C)
H8 : not (eq C P)
H11 : not (eq B P')
H6 : not (eq C P')
HQ'1 : Reflect Q Q' B C
HQ' : ReflectL Q Q' B C
Q' : Tpoint
HNCol2 : not (Col B C P')
HP'1 : Reflect P P' B C
HP' : ReflectL P P' B C
P' : Tpoint
HNCol1 : not (Col B C P)
HNCol : not (Col A B C)
H0 : not (eq D F)
H9 : not (eq E F)
H7 : not (eq D E)
H5 : not (eq B C)
H2 : not (eq P B)
H1 : not (eq A B)
H : not (eq B Q)
HCop : Coplanar A B C Q
HPerP : Per B P Q
HPQ : not (eq P Q)
HOut : Out B P A
HSuma : SumA A B C A B C D E F
HPer : Per D E F
HAcute : Acute A B C
A,B,C,D,E,F,P,Q : Tpoint
lotschnitt : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar A B C P'
+++++
assert (Coplanar P' C A B) by (apply col2_cop__cop with P B; Col; Cop).
-----
Lemma bachmann_s_lotschnittaxiom__weak_inverse_projection_postulate : bachmann_s_lotschnittaxiom -> weak_inverse_projection_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro lotschnitt.
intros A B C D E F P Q HAcute HPer HSuma HOut HPQ HPerP HCop.
suma.assert_diffs.
assert (HNCol : ~ Col A B C).
assert (HNCol1 : ~ Col B C P) by (intro; apply HNCol; ColR).
destruct (l10_6_existence_spec B C P) as [P' HP']; trivial.
assert (HP'1 : Reflect P P' B C) by (apply is_image_is_image_spec; auto).
assert (HNCol2 : ~ Col B C P') by (apply osym_not_col with P; trivial).
destruct (l10_6_existence_spec B C Q) as [Q' HQ']; trivial.
assert (HQ'1 : Reflect Q Q' B C) by (apply is_image_is_image_spec; auto).
assert_diffs.
assert (P' <> Q').
intro; subst Q'; assert (P = Q) by (apply (l10_2_uniqueness B C P'); assumption); auto.
apply l6_6 in HOut.
assert (HCongA : CongA C B P' A B C).
apply out_conga with C P' P C; try (apply out_trivial); auto.
apply conga_sym, conga_left_comm, reflectl__conga; auto.
apply is_image_spec_rev, HP'.
assert (HTS : TS B C P P').
repeat split; Col; destruct HP' as [[X [HX1 HX2]] _]; exists X; split; Col; Between.
assert (HPer1 : Per A B P').
assert (HNCol3 : ~ Col A B P') by (apply per_not_col; auto).
assert (HNCol4 : ~ Col B P' P) by (intro; apply HNCol3; ColR).
assert (HPerp1 : Perp A B B P') by (apply per_perp; auto).
assert (HPerp2 : Perp A B P Q) by (apply perp_left_comm, perp_col with P; Col; apply per_perp; auto).
assert (HPerp3 : Perp B P' P' Q').
apply per_perp; auto; apply image_spec_preserves_per with B P Q B C; trivial; apply col__refl; Col.
assert (HNCol5 : ~ Col P' P Q).
apply (par_not_col B P'); Col.
apply par_not_col_strict with P; Col.
apply l12_9 with A B; Perp; Cop.
assert (Coplanar P' C A B) by (apply col2_cop__cop with P B; Col; Cop).
CopR.
assert (HI := HPerp2); destruct HI as [I [_ [_ [HCol1 [HCol2 _]]]]].
assert (Coplanar P' C A B) by (apply col2_cop__cop with P B; Col; Cop).
assert (Coplanar P C A B) by Cop.
assert (Coplanar Q Q' B C) by Cop.
destruct (lotschnitt A B B P' P Q P' Q' B P P') as [Y [HY1 HY2]]; Col; try CopR.
exists Y; split; trivial.
apply col_one_side_out with A.
apply col_permutation_1, intersection_with_image_gen with P Q P' Q'; Col.
apply invert_one_side, one_side_transitivity with P'.
apply cop__not_two_sides_one_side; Col.
assert (Coplanar P' C A B) by (apply col2_cop__cop with P B; Col; Cop).

*****
H13 : Coplanar P' C A B
HY2 : Col P' Q' Y
HY1 : Col P Q Y
Y : Tpoint
H12 : Coplanar Q Q' B C
H10 : Coplanar P C A B
H4 : Coplanar P' C A B
HCol2 : Col I P Q
HCol1 : Col I A B
I : Tpoint
HNCol5 : not (Col P' P Q)
HPerp3 : Perp B P' P' Q'
HPerp2 : Perp A B P Q
HPerp1 : Perp A B B P'
HNCol4 : not (Col B P' P)
HNCol3 : not (Col A B P')
HPer1 : Per A B P'
HTS : TS B C P P'
HCongA : CongA C B P' A B C
H3 : not (eq P' Q')
H14 : not (eq A C)
H8 : not (eq C P)
H11 : not (eq B P')
H6 : not (eq C P')
HQ'1 : Reflect Q Q' B C
HQ' : ReflectL Q Q' B C
Q' : Tpoint
HNCol2 : not (Col B C P')
HP'1 : Reflect P P' B C
HP' : ReflectL P P' B C
P' : Tpoint
HNCol1 : not (Col B C P)
HNCol : not (Col A B C)
H0 : not (eq D F)
H9 : not (eq E F)
H7 : not (eq D E)
H5 : not (eq B C)
H2 : not (eq P B)
H1 : not (eq A B)
H : not (eq B Q)
HCop : Coplanar A B C Q
HPerP : Per B P Q
HPQ : not (eq P Q)
HOut : Out B P A
HSuma : SumA A B C A B C D E F
HPer : Per D E F
HAcute : Acute A B C
A,B,C,D,E,F,P,Q : Tpoint
lotschnitt : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar A B C P'
+++++
Cop.
-----
Lemma bachmann_s_lotschnittaxiom__weak_inverse_projection_postulate : bachmann_s_lotschnittaxiom -> weak_inverse_projection_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro lotschnitt.
intros A B C D E F P Q HAcute HPer HSuma HOut HPQ HPerP HCop.
suma.assert_diffs.
assert (HNCol : ~ Col A B C).
assert (HNCol1 : ~ Col B C P) by (intro; apply HNCol; ColR).
destruct (l10_6_existence_spec B C P) as [P' HP']; trivial.
assert (HP'1 : Reflect P P' B C) by (apply is_image_is_image_spec; auto).
assert (HNCol2 : ~ Col B C P') by (apply osym_not_col with P; trivial).
destruct (l10_6_existence_spec B C Q) as [Q' HQ']; trivial.
assert (HQ'1 : Reflect Q Q' B C) by (apply is_image_is_image_spec; auto).
assert_diffs.
assert (P' <> Q').
intro; subst Q'; assert (P = Q) by (apply (l10_2_uniqueness B C P'); assumption); auto.
apply l6_6 in HOut.
assert (HCongA : CongA C B P' A B C).
apply out_conga with C P' P C; try (apply out_trivial); auto.
apply conga_sym, conga_left_comm, reflectl__conga; auto.
apply is_image_spec_rev, HP'.
assert (HTS : TS B C P P').
repeat split; Col; destruct HP' as [[X [HX1 HX2]] _]; exists X; split; Col; Between.
assert (HPer1 : Per A B P').
assert (HNCol3 : ~ Col A B P') by (apply per_not_col; auto).
assert (HNCol4 : ~ Col B P' P) by (intro; apply HNCol3; ColR).
assert (HPerp1 : Perp A B B P') by (apply per_perp; auto).
assert (HPerp2 : Perp A B P Q) by (apply perp_left_comm, perp_col with P; Col; apply per_perp; auto).
assert (HPerp3 : Perp B P' P' Q').
apply per_perp; auto; apply image_spec_preserves_per with B P Q B C; trivial; apply col__refl; Col.
assert (HNCol5 : ~ Col P' P Q).
apply (par_not_col B P'); Col.
apply par_not_col_strict with P; Col.
apply l12_9 with A B; Perp; Cop.
assert (Coplanar P' C A B) by (apply col2_cop__cop with P B; Col; Cop).
CopR.
assert (HI := HPerp2); destruct HI as [I [_ [_ [HCol1 [HCol2 _]]]]].
assert (Coplanar P' C A B) by (apply col2_cop__cop with P B; Col; Cop).
assert (Coplanar P C A B) by Cop.
assert (Coplanar Q Q' B C) by Cop.
destruct (lotschnitt A B B P' P Q P' Q' B P P') as [Y [HY1 HY2]]; Col; try CopR.
exists Y; split; trivial.
apply col_one_side_out with A.
apply col_permutation_1, intersection_with_image_gen with P Q P' Q'; Col.
apply invert_one_side, one_side_transitivity with P'.
apply cop__not_two_sides_one_side; Col.
assert (Coplanar P' C A B) by (apply col2_cop__cop with P B; Col; Cop).
Cop.

*****
HY2 : Col P' Q' Y
HY1 : Col P Q Y
Y : Tpoint
H12 : Coplanar Q Q' B C
H10 : Coplanar P C A B
H4 : Coplanar P' C A B
HCol2 : Col I P Q
HCol1 : Col I A B
I : Tpoint
HNCol5 : not (Col P' P Q)
HPerp3 : Perp B P' P' Q'
HPerp2 : Perp A B P Q
HPerp1 : Perp A B B P'
HNCol4 : not (Col B P' P)
HNCol3 : not (Col A B P')
HPer1 : Per A B P'
HTS : TS B C P P'
HCongA : CongA C B P' A B C
H3 : not (eq P' Q')
H14 : not (eq A C)
H8 : not (eq C P)
H11 : not (eq B P')
H6 : not (eq C P')
HQ'1 : Reflect Q Q' B C
HQ' : ReflectL Q Q' B C
Q' : Tpoint
HNCol2 : not (Col B C P')
HP'1 : Reflect P P' B C
HP' : ReflectL P P' B C
P' : Tpoint
HNCol1 : not (Col B C P)
HNCol : not (Col A B C)
H0 : not (eq D F)
H9 : not (eq E F)
H7 : not (eq D E)
H5 : not (eq B C)
H2 : not (eq P B)
H1 : not (eq A B)
H : not (eq B Q)
HCop : Coplanar A B C Q
HPerP : Per B P Q
HPQ : not (eq P Q)
HOut : Out B P A
HSuma : SumA A B C A B C D E F
HPer : Per D E F
HAcute : Acute A B C
A,B,C,D,E,F,P,Q : Tpoint
lotschnitt : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (TS A B C P')
+++++
apply (conga_sams_nos__nts A B C A B C P'); SumA.
-----
Lemma bachmann_s_lotschnittaxiom__weak_inverse_projection_postulate : bachmann_s_lotschnittaxiom -> weak_inverse_projection_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro lotschnitt.
intros A B C D E F P Q HAcute HPer HSuma HOut HPQ HPerP HCop.
suma.assert_diffs.
assert (HNCol : ~ Col A B C).
assert (HNCol1 : ~ Col B C P) by (intro; apply HNCol; ColR).
destruct (l10_6_existence_spec B C P) as [P' HP']; trivial.
assert (HP'1 : Reflect P P' B C) by (apply is_image_is_image_spec; auto).
assert (HNCol2 : ~ Col B C P') by (apply osym_not_col with P; trivial).
destruct (l10_6_existence_spec B C Q) as [Q' HQ']; trivial.
assert (HQ'1 : Reflect Q Q' B C) by (apply is_image_is_image_spec; auto).
assert_diffs.
assert (P' <> Q').
intro; subst Q'; assert (P = Q) by (apply (l10_2_uniqueness B C P'); assumption); auto.
apply l6_6 in HOut.
assert (HCongA : CongA C B P' A B C).
apply out_conga with C P' P C; try (apply out_trivial); auto.
apply conga_sym, conga_left_comm, reflectl__conga; auto.
apply is_image_spec_rev, HP'.
assert (HTS : TS B C P P').
repeat split; Col; destruct HP' as [[X [HX1 HX2]] _]; exists X; split; Col; Between.
assert (HPer1 : Per A B P').
assert (HNCol3 : ~ Col A B P') by (apply per_not_col; auto).
assert (HNCol4 : ~ Col B P' P) by (intro; apply HNCol3; ColR).
assert (HPerp1 : Perp A B B P') by (apply per_perp; auto).
assert (HPerp2 : Perp A B P Q) by (apply perp_left_comm, perp_col with P; Col; apply per_perp; auto).
assert (HPerp3 : Perp B P' P' Q').
apply per_perp; auto; apply image_spec_preserves_per with B P Q B C; trivial; apply col__refl; Col.
assert (HNCol5 : ~ Col P' P Q).
apply (par_not_col B P'); Col.
apply par_not_col_strict with P; Col.
apply l12_9 with A B; Perp; Cop.
assert (Coplanar P' C A B) by (apply col2_cop__cop with P B; Col; Cop).
CopR.
assert (HI := HPerp2); destruct HI as [I [_ [_ [HCol1 [HCol2 _]]]]].
assert (Coplanar P' C A B) by (apply col2_cop__cop with P B; Col; Cop).
assert (Coplanar P C A B) by Cop.
assert (Coplanar Q Q' B C) by Cop.
destruct (lotschnitt A B B P' P Q P' Q' B P P') as [Y [HY1 HY2]]; Col; try CopR.
exists Y; split; trivial.
apply col_one_side_out with A.
apply col_permutation_1, intersection_with_image_gen with P Q P' Q'; Col.
apply invert_one_side, one_side_transitivity with P'.
apply cop__not_two_sides_one_side; Col.
assert (Coplanar P' C A B) by (apply col2_cop__cop with P B; Col; Cop).
Cop.
apply (conga_sams_nos__nts A B C A B C P'); SumA.

*****
HY2 : Col P' Q' Y
HY1 : Col P Q Y
Y : Tpoint
H12 : Coplanar Q Q' B C
H10 : Coplanar P C A B
H4 : Coplanar P' C A B
HCol2 : Col I P Q
HCol1 : Col I A B
I : Tpoint
HNCol5 : not (Col P' P Q)
HPerp3 : Perp B P' P' Q'
HPerp2 : Perp A B P Q
HPerp1 : Perp A B B P'
HNCol4 : not (Col B P' P)
HNCol3 : not (Col A B P')
HPer1 : Per A B P'
HTS : TS B C P P'
HCongA : CongA C B P' A B C
H3 : not (eq P' Q')
H14 : not (eq A C)
H8 : not (eq C P)
H11 : not (eq B P')
H6 : not (eq C P')
HQ'1 : Reflect Q Q' B C
HQ' : ReflectL Q Q' B C
Q' : Tpoint
HNCol2 : not (Col B C P')
HP'1 : Reflect P P' B C
HP' : ReflectL P P' B C
P' : Tpoint
HNCol1 : not (Col B C P)
HNCol : not (Col A B C)
H0 : not (eq D F)
H9 : not (eq E F)
H7 : not (eq D E)
H5 : not (eq B C)
H2 : not (eq P B)
H1 : not (eq A B)
H : not (eq B Q)
HCop : Coplanar A B C Q
HPerP : Per B P Q
HPQ : not (eq P Q)
HOut : Out B P A
HSuma : SumA A B C A B C D E F
HPer : Per D E F
HAcute : Acute A B C
A,B,C,D,E,F,P,Q : Tpoint
lotschnitt : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (OS B C A P')
+++++
apply l9_9, l9_5 with P B; Col.
-----
Lemma bachmann_s_lotschnittaxiom__weak_inverse_projection_postulate : bachmann_s_lotschnittaxiom -> weak_inverse_projection_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro lotschnitt.
intros A B C D E F P Q HAcute HPer HSuma HOut HPQ HPerP HCop.
suma.assert_diffs.
assert (HNCol : ~ Col A B C).
assert (HNCol1 : ~ Col B C P) by (intro; apply HNCol; ColR).
destruct (l10_6_existence_spec B C P) as [P' HP']; trivial.
assert (HP'1 : Reflect P P' B C) by (apply is_image_is_image_spec; auto).
assert (HNCol2 : ~ Col B C P') by (apply osym_not_col with P; trivial).
destruct (l10_6_existence_spec B C Q) as [Q' HQ']; trivial.
assert (HQ'1 : Reflect Q Q' B C) by (apply is_image_is_image_spec; auto).
assert_diffs.
assert (P' <> Q').
intro; subst Q'; assert (P = Q) by (apply (l10_2_uniqueness B C P'); assumption); auto.
apply l6_6 in HOut.
assert (HCongA : CongA C B P' A B C).
apply out_conga with C P' P C; try (apply out_trivial); auto.
apply conga_sym, conga_left_comm, reflectl__conga; auto.
apply is_image_spec_rev, HP'.
assert (HTS : TS B C P P').
repeat split; Col; destruct HP' as [[X [HX1 HX2]] _]; exists X; split; Col; Between.
assert (HPer1 : Per A B P').
assert (HNCol3 : ~ Col A B P') by (apply per_not_col; auto).
assert (HNCol4 : ~ Col B P' P) by (intro; apply HNCol3; ColR).
assert (HPerp1 : Perp A B B P') by (apply per_perp; auto).
assert (HPerp2 : Perp A B P Q) by (apply perp_left_comm, perp_col with P; Col; apply per_perp; auto).
assert (HPerp3 : Perp B P' P' Q').
apply per_perp; auto; apply image_spec_preserves_per with B P Q B C; trivial; apply col__refl; Col.
assert (HNCol5 : ~ Col P' P Q).
apply (par_not_col B P'); Col.
apply par_not_col_strict with P; Col.
apply l12_9 with A B; Perp; Cop.
assert (Coplanar P' C A B) by (apply col2_cop__cop with P B; Col; Cop).
CopR.
assert (HI := HPerp2); destruct HI as [I [_ [_ [HCol1 [HCol2 _]]]]].
assert (Coplanar P' C A B) by (apply col2_cop__cop with P B; Col; Cop).
assert (Coplanar P C A B) by Cop.
assert (Coplanar Q Q' B C) by Cop.
destruct (lotschnitt A B B P' P Q P' Q' B P P') as [Y [HY1 HY2]]; Col; try CopR.
exists Y; split; trivial.
apply col_one_side_out with A.
apply col_permutation_1, intersection_with_image_gen with P Q P' Q'; Col.
apply invert_one_side, one_side_transitivity with P'.
apply cop__not_two_sides_one_side; Col.
assert (Coplanar P' C A B) by (apply col2_cop__cop with P B; Col; Cop).
Cop.
apply (conga_sams_nos__nts A B C A B C P'); SumA.
apply l9_9, l9_5 with P B; Col.

*****
HY2 : Col P' Q' Y
HY1 : Col P Q Y
Y : Tpoint
H12 : Coplanar Q Q' B C
H10 : Coplanar P C A B
H4 : Coplanar P' C A B
HCol2 : Col I P Q
HCol1 : Col I A B
I : Tpoint
HNCol5 : not (Col P' P Q)
HPerp3 : Perp B P' P' Q'
HPerp2 : Perp A B P Q
HPerp1 : Perp A B B P'
HNCol4 : not (Col B P' P)
HNCol3 : not (Col A B P')
HPer1 : Per A B P'
HTS : TS B C P P'
HCongA : CongA C B P' A B C
H3 : not (eq P' Q')
H14 : not (eq A C)
H8 : not (eq C P)
H11 : not (eq B P')
H6 : not (eq C P')
HQ'1 : Reflect Q Q' B C
HQ' : ReflectL Q Q' B C
Q' : Tpoint
HNCol2 : not (Col B C P')
HP'1 : Reflect P P' B C
HP' : ReflectL P P' B C
P' : Tpoint
HNCol1 : not (Col B C P)
HNCol : not (Col A B C)
H0 : not (eq D F)
H9 : not (eq E F)
H7 : not (eq D E)
H5 : not (eq B C)
H2 : not (eq P B)
H1 : not (eq A B)
H : not (eq B Q)
HCop : Coplanar A B C Q
HPerP : Per B P Q
HPQ : not (eq P Q)
HOut : Out B P A
HSuma : SumA A B C A B C D E F
HPer : Per D E F
HAcute : Acute A B C
A,B,C,D,E,F,P,Q : Tpoint
lotschnitt : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OS A B P' Y
+++++
apply l12_6, par_strict_col_par_strict with Q'; Col.
-----
Lemma bachmann_s_lotschnittaxiom__weak_inverse_projection_postulate : bachmann_s_lotschnittaxiom -> weak_inverse_projection_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro lotschnitt.
intros A B C D E F P Q HAcute HPer HSuma HOut HPQ HPerP HCop.
suma.assert_diffs.
assert (HNCol : ~ Col A B C).
assert (HNCol1 : ~ Col B C P) by (intro; apply HNCol; ColR).
destruct (l10_6_existence_spec B C P) as [P' HP']; trivial.
assert (HP'1 : Reflect P P' B C) by (apply is_image_is_image_spec; auto).
assert (HNCol2 : ~ Col B C P') by (apply osym_not_col with P; trivial).
destruct (l10_6_existence_spec B C Q) as [Q' HQ']; trivial.
assert (HQ'1 : Reflect Q Q' B C) by (apply is_image_is_image_spec; auto).
assert_diffs.
assert (P' <> Q').
intro; subst Q'; assert (P = Q) by (apply (l10_2_uniqueness B C P'); assumption); auto.
apply l6_6 in HOut.
assert (HCongA : CongA C B P' A B C).
apply out_conga with C P' P C; try (apply out_trivial); auto.
apply conga_sym, conga_left_comm, reflectl__conga; auto.
apply is_image_spec_rev, HP'.
assert (HTS : TS B C P P').
repeat split; Col; destruct HP' as [[X [HX1 HX2]] _]; exists X; split; Col; Between.
assert (HPer1 : Per A B P').
assert (HNCol3 : ~ Col A B P') by (apply per_not_col; auto).
assert (HNCol4 : ~ Col B P' P) by (intro; apply HNCol3; ColR).
assert (HPerp1 : Perp A B B P') by (apply per_perp; auto).
assert (HPerp2 : Perp A B P Q) by (apply perp_left_comm, perp_col with P; Col; apply per_perp; auto).
assert (HPerp3 : Perp B P' P' Q').
apply per_perp; auto; apply image_spec_preserves_per with B P Q B C; trivial; apply col__refl; Col.
assert (HNCol5 : ~ Col P' P Q).
apply (par_not_col B P'); Col.
apply par_not_col_strict with P; Col.
apply l12_9 with A B; Perp; Cop.
assert (Coplanar P' C A B) by (apply col2_cop__cop with P B; Col; Cop).
CopR.
assert (HI := HPerp2); destruct HI as [I [_ [_ [HCol1 [HCol2 _]]]]].
assert (Coplanar P' C A B) by (apply col2_cop__cop with P B; Col; Cop).
assert (Coplanar P C A B) by Cop.
assert (Coplanar Q Q' B C) by Cop.
destruct (lotschnitt A B B P' P Q P' Q' B P P') as [Y [HY1 HY2]]; Col; try CopR.
exists Y; split; trivial.
apply col_one_side_out with A.
apply col_permutation_1, intersection_with_image_gen with P Q P' Q'; Col.
apply invert_one_side, one_side_transitivity with P'.
apply cop__not_two_sides_one_side; Col.
assert (Coplanar P' C A B) by (apply col2_cop__cop with P B; Col; Cop).
Cop.
apply (conga_sams_nos__nts A B C A B C P'); SumA.
apply l9_9, l9_5 with P B; Col.
apply l12_6, par_strict_col_par_strict with Q'; Col.

*****
HY2 : Col P' Q' Y
HY1 : Col P Q Y
Y : Tpoint
H12 : Coplanar Q Q' B C
H10 : Coplanar P C A B
H4 : Coplanar P' C A B
HCol2 : Col I P Q
HCol1 : Col I A B
I : Tpoint
HNCol5 : not (Col P' P Q)
HPerp3 : Perp B P' P' Q'
HPerp2 : Perp A B P Q
HPerp1 : Perp A B B P'
HNCol4 : not (Col B P' P)
HNCol3 : not (Col A B P')
HPer1 : Per A B P'
HTS : TS B C P P'
HCongA : CongA C B P' A B C
H3 : not (eq P' Q')
H14 : not (eq A C)
H8 : not (eq C P)
H11 : not (eq B P')
H6 : not (eq C P')
HQ'1 : Reflect Q Q' B C
HQ' : ReflectL Q Q' B C
Q' : Tpoint
HNCol2 : not (Col B C P')
HP'1 : Reflect P P' B C
HP' : ReflectL P P' B C
P' : Tpoint
HNCol1 : not (Col B C P)
HNCol : not (Col A B C)
H0 : not (eq D F)
H9 : not (eq E F)
H7 : not (eq D E)
H5 : not (eq B C)
H2 : not (eq P B)
H1 : not (eq A B)
H : not (eq B Q)
HCop : Coplanar A B C Q
HPerP : Per B P Q
HPQ : not (eq P Q)
HOut : Out B P A
HSuma : SumA A B C A B C D E F
HPer : Per D E F
HAcute : Acute A B C
A,B,C,D,E,F,P,Q : Tpoint
lotschnitt : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq P' Y)
+++++
intro; subst; apply HNCol5; Col.
-----
Lemma bachmann_s_lotschnittaxiom__weak_inverse_projection_postulate : bachmann_s_lotschnittaxiom -> weak_inverse_projection_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro lotschnitt.
intros A B C D E F P Q HAcute HPer HSuma HOut HPQ HPerP HCop.
suma.assert_diffs.
assert (HNCol : ~ Col A B C).
assert (HNCol1 : ~ Col B C P) by (intro; apply HNCol; ColR).
destruct (l10_6_existence_spec B C P) as [P' HP']; trivial.
assert (HP'1 : Reflect P P' B C) by (apply is_image_is_image_spec; auto).
assert (HNCol2 : ~ Col B C P') by (apply osym_not_col with P; trivial).
destruct (l10_6_existence_spec B C Q) as [Q' HQ']; trivial.
assert (HQ'1 : Reflect Q Q' B C) by (apply is_image_is_image_spec; auto).
assert_diffs.
assert (P' <> Q').
intro; subst Q'; assert (P = Q) by (apply (l10_2_uniqueness B C P'); assumption); auto.
apply l6_6 in HOut.
assert (HCongA : CongA C B P' A B C).
apply out_conga with C P' P C; try (apply out_trivial); auto.
apply conga_sym, conga_left_comm, reflectl__conga; auto.
apply is_image_spec_rev, HP'.
assert (HTS : TS B C P P').
repeat split; Col; destruct HP' as [[X [HX1 HX2]] _]; exists X; split; Col; Between.
assert (HPer1 : Per A B P').
assert (HNCol3 : ~ Col A B P') by (apply per_not_col; auto).
assert (HNCol4 : ~ Col B P' P) by (intro; apply HNCol3; ColR).
assert (HPerp1 : Perp A B B P') by (apply per_perp; auto).
assert (HPerp2 : Perp A B P Q) by (apply perp_left_comm, perp_col with P; Col; apply per_perp; auto).
assert (HPerp3 : Perp B P' P' Q').
apply per_perp; auto; apply image_spec_preserves_per with B P Q B C; trivial; apply col__refl; Col.
assert (HNCol5 : ~ Col P' P Q).
apply (par_not_col B P'); Col.
apply par_not_col_strict with P; Col.
apply l12_9 with A B; Perp; Cop.
assert (Coplanar P' C A B) by (apply col2_cop__cop with P B; Col; Cop).
CopR.
assert (HI := HPerp2); destruct HI as [I [_ [_ [HCol1 [HCol2 _]]]]].
assert (Coplanar P' C A B) by (apply col2_cop__cop with P B; Col; Cop).
assert (Coplanar P C A B) by Cop.
assert (Coplanar Q Q' B C) by Cop.
destruct (lotschnitt A B B P' P Q P' Q' B P P') as [Y [HY1 HY2]]; Col; try CopR.
exists Y; split; trivial.
apply col_one_side_out with A.
apply col_permutation_1, intersection_with_image_gen with P Q P' Q'; Col.
apply invert_one_side, one_side_transitivity with P'.
apply cop__not_two_sides_one_side; Col.
assert (Coplanar P' C A B) by (apply col2_cop__cop with P B; Col; Cop).
Cop.
apply (conga_sams_nos__nts A B C A B C P'); SumA.
apply l9_9, l9_5 with P B; Col.
apply l12_6, par_strict_col_par_strict with Q'; Col.
intro; subst; apply HNCol5; Col.

*****
HY2 : Col P' Q' Y
HY1 : Col P Q Y
Y : Tpoint
H12 : Coplanar Q Q' B C
H10 : Coplanar P C A B
H4 : Coplanar P' C A B
HCol2 : Col I P Q
HCol1 : Col I A B
I : Tpoint
HNCol5 : not (Col P' P Q)
HPerp3 : Perp B P' P' Q'
HPerp2 : Perp A B P Q
HPerp1 : Perp A B B P'
HNCol4 : not (Col B P' P)
HNCol3 : not (Col A B P')
HPer1 : Per A B P'
HTS : TS B C P P'
HCongA : CongA C B P' A B C
H3 : not (eq P' Q')
H14 : not (eq A C)
H8 : not (eq C P)
H11 : not (eq B P')
H6 : not (eq C P')
HQ'1 : Reflect Q Q' B C
HQ' : ReflectL Q Q' B C
Q' : Tpoint
HNCol2 : not (Col B C P')
HP'1 : Reflect P P' B C
HP' : ReflectL P P' B C
P' : Tpoint
HNCol1 : not (Col B C P)
HNCol : not (Col A B C)
H0 : not (eq D F)
H9 : not (eq E F)
H7 : not (eq D E)
H5 : not (eq B C)
H2 : not (eq P B)
H1 : not (eq A B)
H : not (eq B Q)
HCop : Coplanar A B C Q
HPerP : Per B P Q
HPQ : not (eq P Q)
HOut : Out B P A
HSuma : SumA A B C A B C D E F
HPer : Per D E F
HAcute : Acute A B C
A,B,C,D,E,F,P,Q : Tpoint
lotschnitt : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Par_strict A B P' Q'
+++++
apply par_not_col_strict with P'; Col.
-----
Lemma bachmann_s_lotschnittaxiom__weak_inverse_projection_postulate : bachmann_s_lotschnittaxiom -> weak_inverse_projection_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro lotschnitt.
intros A B C D E F P Q HAcute HPer HSuma HOut HPQ HPerP HCop.
suma.assert_diffs.
assert (HNCol : ~ Col A B C).
assert (HNCol1 : ~ Col B C P) by (intro; apply HNCol; ColR).
destruct (l10_6_existence_spec B C P) as [P' HP']; trivial.
assert (HP'1 : Reflect P P' B C) by (apply is_image_is_image_spec; auto).
assert (HNCol2 : ~ Col B C P') by (apply osym_not_col with P; trivial).
destruct (l10_6_existence_spec B C Q) as [Q' HQ']; trivial.
assert (HQ'1 : Reflect Q Q' B C) by (apply is_image_is_image_spec; auto).
assert_diffs.
assert (P' <> Q').
intro; subst Q'; assert (P = Q) by (apply (l10_2_uniqueness B C P'); assumption); auto.
apply l6_6 in HOut.
assert (HCongA : CongA C B P' A B C).
apply out_conga with C P' P C; try (apply out_trivial); auto.
apply conga_sym, conga_left_comm, reflectl__conga; auto.
apply is_image_spec_rev, HP'.
assert (HTS : TS B C P P').
repeat split; Col; destruct HP' as [[X [HX1 HX2]] _]; exists X; split; Col; Between.
assert (HPer1 : Per A B P').
assert (HNCol3 : ~ Col A B P') by (apply per_not_col; auto).
assert (HNCol4 : ~ Col B P' P) by (intro; apply HNCol3; ColR).
assert (HPerp1 : Perp A B B P') by (apply per_perp; auto).
assert (HPerp2 : Perp A B P Q) by (apply perp_left_comm, perp_col with P; Col; apply per_perp; auto).
assert (HPerp3 : Perp B P' P' Q').
apply per_perp; auto; apply image_spec_preserves_per with B P Q B C; trivial; apply col__refl; Col.
assert (HNCol5 : ~ Col P' P Q).
apply (par_not_col B P'); Col.
apply par_not_col_strict with P; Col.
apply l12_9 with A B; Perp; Cop.
assert (Coplanar P' C A B) by (apply col2_cop__cop with P B; Col; Cop).
CopR.
assert (HI := HPerp2); destruct HI as [I [_ [_ [HCol1 [HCol2 _]]]]].
assert (Coplanar P' C A B) by (apply col2_cop__cop with P B; Col; Cop).
assert (Coplanar P C A B) by Cop.
assert (Coplanar Q Q' B C) by Cop.
destruct (lotschnitt A B B P' P Q P' Q' B P P') as [Y [HY1 HY2]]; Col; try CopR.
exists Y; split; trivial.
apply col_one_side_out with A.
apply col_permutation_1, intersection_with_image_gen with P Q P' Q'; Col.
apply invert_one_side, one_side_transitivity with P'.
apply cop__not_two_sides_one_side; Col.
assert (Coplanar P' C A B) by (apply col2_cop__cop with P B; Col; Cop).
Cop.
apply (conga_sams_nos__nts A B C A B C P'); SumA.
apply l9_9, l9_5 with P B; Col.
apply l12_6, par_strict_col_par_strict with Q'; Col.
intro; subst; apply HNCol5; Col.
apply par_not_col_strict with P'; Col.

*****
HY2 : Col P' Q' Y
HY1 : Col P Q Y
Y : Tpoint
H12 : Coplanar Q Q' B C
H10 : Coplanar P C A B
H4 : Coplanar P' C A B
HCol2 : Col I P Q
HCol1 : Col I A B
I : Tpoint
HNCol5 : not (Col P' P Q)
HPerp3 : Perp B P' P' Q'
HPerp2 : Perp A B P Q
HPerp1 : Perp A B B P'
HNCol4 : not (Col B P' P)
HNCol3 : not (Col A B P')
HPer1 : Per A B P'
HTS : TS B C P P'
HCongA : CongA C B P' A B C
H3 : not (eq P' Q')
H14 : not (eq A C)
H8 : not (eq C P)
H11 : not (eq B P')
H6 : not (eq C P')
HQ'1 : Reflect Q Q' B C
HQ' : ReflectL Q Q' B C
Q' : Tpoint
HNCol2 : not (Col B C P')
HP'1 : Reflect P P' B C
HP' : ReflectL P P' B C
P' : Tpoint
HNCol1 : not (Col B C P)
HNCol : not (Col A B C)
H0 : not (eq D F)
H9 : not (eq E F)
H7 : not (eq D E)
H5 : not (eq B C)
H2 : not (eq P B)
H1 : not (eq A B)
H : not (eq B Q)
HCop : Coplanar A B C Q
HPerP : Per B P Q
HPQ : not (eq P Q)
HOut : Out B P A
HSuma : SumA A B C A B C D E F
HPer : Per D E F
HAcute : Acute A B C
A,B,C,D,E,F,P,Q : Tpoint
lotschnitt : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Par A B P' Q'
+++++
apply l12_9 with B P'; Perp; Cop.
-----
Lemma bachmann_s_lotschnittaxiom__weak_inverse_projection_postulate : bachmann_s_lotschnittaxiom -> weak_inverse_projection_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro lotschnitt.
intros A B C D E F P Q HAcute HPer HSuma HOut HPQ HPerP HCop.
suma.assert_diffs.
assert (HNCol : ~ Col A B C).
assert (HNCol1 : ~ Col B C P) by (intro; apply HNCol; ColR).
destruct (l10_6_existence_spec B C P) as [P' HP']; trivial.
assert (HP'1 : Reflect P P' B C) by (apply is_image_is_image_spec; auto).
assert (HNCol2 : ~ Col B C P') by (apply osym_not_col with P; trivial).
destruct (l10_6_existence_spec B C Q) as [Q' HQ']; trivial.
assert (HQ'1 : Reflect Q Q' B C) by (apply is_image_is_image_spec; auto).
assert_diffs.
assert (P' <> Q').
intro; subst Q'; assert (P = Q) by (apply (l10_2_uniqueness B C P'); assumption); auto.
apply l6_6 in HOut.
assert (HCongA : CongA C B P' A B C).
apply out_conga with C P' P C; try (apply out_trivial); auto.
apply conga_sym, conga_left_comm, reflectl__conga; auto.
apply is_image_spec_rev, HP'.
assert (HTS : TS B C P P').
repeat split; Col; destruct HP' as [[X [HX1 HX2]] _]; exists X; split; Col; Between.
assert (HPer1 : Per A B P').
assert (HNCol3 : ~ Col A B P') by (apply per_not_col; auto).
assert (HNCol4 : ~ Col B P' P) by (intro; apply HNCol3; ColR).
assert (HPerp1 : Perp A B B P') by (apply per_perp; auto).
assert (HPerp2 : Perp A B P Q) by (apply perp_left_comm, perp_col with P; Col; apply per_perp; auto).
assert (HPerp3 : Perp B P' P' Q').
apply per_perp; auto; apply image_spec_preserves_per with B P Q B C; trivial; apply col__refl; Col.
assert (HNCol5 : ~ Col P' P Q).
apply (par_not_col B P'); Col.
apply par_not_col_strict with P; Col.
apply l12_9 with A B; Perp; Cop.
assert (Coplanar P' C A B) by (apply col2_cop__cop with P B; Col; Cop).
CopR.
assert (HI := HPerp2); destruct HI as [I [_ [_ [HCol1 [HCol2 _]]]]].
assert (Coplanar P' C A B) by (apply col2_cop__cop with P B; Col; Cop).
assert (Coplanar P C A B) by Cop.
assert (Coplanar Q Q' B C) by Cop.
destruct (lotschnitt A B B P' P Q P' Q' B P P') as [Y [HY1 HY2]]; Col; try CopR.
exists Y; split; trivial.
apply col_one_side_out with A.
apply col_permutation_1, intersection_with_image_gen with P Q P' Q'; Col.
apply invert_one_side, one_side_transitivity with P'.
apply cop__not_two_sides_one_side; Col.
assert (Coplanar P' C A B) by (apply col2_cop__cop with P B; Col; Cop).
Cop.
apply (conga_sams_nos__nts A B C A B C P'); SumA.
apply l9_9, l9_5 with P B; Col.
apply l12_6, par_strict_col_par_strict with Q'; Col.
intro; subst; apply HNCol5; Col.
apply par_not_col_strict with P'; Col.
apply l12_9 with B P'; Perp; Cop.

*****
HY2 : Col P' Q' Y
HY1 : Col P Q Y
Y : Tpoint
H12 : Coplanar Q Q' B C
H10 : Coplanar P C A B
H4 : Coplanar P' C A B
HCol2 : Col I P Q
HCol1 : Col I A B
I : Tpoint
HNCol5 : not (Col P' P Q)
HPerp3 : Perp B P' P' Q'
HPerp2 : Perp A B P Q
HPerp1 : Perp A B B P'
HNCol4 : not (Col B P' P)
HNCol3 : not (Col A B P')
HPer1 : Per A B P'
HTS : TS B C P P'
HCongA : CongA C B P' A B C
H3 : not (eq P' Q')
H14 : not (eq A C)
H8 : not (eq C P)
H11 : not (eq B P')
H6 : not (eq C P')
HQ'1 : Reflect Q Q' B C
HQ' : ReflectL Q Q' B C
Q' : Tpoint
HNCol2 : not (Col B C P')
HP'1 : Reflect P P' B C
HP' : ReflectL P P' B C
P' : Tpoint
HNCol1 : not (Col B C P)
HNCol : not (Col A B C)
H0 : not (eq D F)
H9 : not (eq E F)
H7 : not (eq D E)
H5 : not (eq B C)
H2 : not (eq P B)
H1 : not (eq A B)
H : not (eq B Q)
HCop : Coplanar A B C Q
HPerP : Per B P Q
HPQ : not (eq P Q)
HOut : Out B P A
HSuma : SumA A B C A B C D E F
HPer : Per D E F
HAcute : Acute A B C
A,B,C,D,E,F,P,Q : Tpoint
lotschnitt : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar B P' A Q'
+++++
elim (col_dec B C Q); intro; [|CopR].
-----
Lemma bachmann_s_lotschnittaxiom__weak_inverse_projection_postulate : bachmann_s_lotschnittaxiom -> weak_inverse_projection_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro lotschnitt.
intros A B C D E F P Q HAcute HPer HSuma HOut HPQ HPerP HCop.
suma.assert_diffs.
assert (HNCol : ~ Col A B C).
assert (HNCol1 : ~ Col B C P) by (intro; apply HNCol; ColR).
destruct (l10_6_existence_spec B C P) as [P' HP']; trivial.
assert (HP'1 : Reflect P P' B C) by (apply is_image_is_image_spec; auto).
assert (HNCol2 : ~ Col B C P') by (apply osym_not_col with P; trivial).
destruct (l10_6_existence_spec B C Q) as [Q' HQ']; trivial.
assert (HQ'1 : Reflect Q Q' B C) by (apply is_image_is_image_spec; auto).
assert_diffs.
assert (P' <> Q').
intro; subst Q'; assert (P = Q) by (apply (l10_2_uniqueness B C P'); assumption); auto.
apply l6_6 in HOut.
assert (HCongA : CongA C B P' A B C).
apply out_conga with C P' P C; try (apply out_trivial); auto.
apply conga_sym, conga_left_comm, reflectl__conga; auto.
apply is_image_spec_rev, HP'.
assert (HTS : TS B C P P').
repeat split; Col; destruct HP' as [[X [HX1 HX2]] _]; exists X; split; Col; Between.
assert (HPer1 : Per A B P').
assert (HNCol3 : ~ Col A B P') by (apply per_not_col; auto).
assert (HNCol4 : ~ Col B P' P) by (intro; apply HNCol3; ColR).
assert (HPerp1 : Perp A B B P') by (apply per_perp; auto).
assert (HPerp2 : Perp A B P Q) by (apply perp_left_comm, perp_col with P; Col; apply per_perp; auto).
assert (HPerp3 : Perp B P' P' Q').
apply per_perp; auto; apply image_spec_preserves_per with B P Q B C; trivial; apply col__refl; Col.
assert (HNCol5 : ~ Col P' P Q).
apply (par_not_col B P'); Col.
apply par_not_col_strict with P; Col.
apply l12_9 with A B; Perp; Cop.
assert (Coplanar P' C A B) by (apply col2_cop__cop with P B; Col; Cop).
CopR.
assert (HI := HPerp2); destruct HI as [I [_ [_ [HCol1 [HCol2 _]]]]].
assert (Coplanar P' C A B) by (apply col2_cop__cop with P B; Col; Cop).
assert (Coplanar P C A B) by Cop.
assert (Coplanar Q Q' B C) by Cop.
destruct (lotschnitt A B B P' P Q P' Q' B P P') as [Y [HY1 HY2]]; Col; try CopR.
exists Y; split; trivial.
apply col_one_side_out with A.
apply col_permutation_1, intersection_with_image_gen with P Q P' Q'; Col.
apply invert_one_side, one_side_transitivity with P'.
apply cop__not_two_sides_one_side; Col.
assert (Coplanar P' C A B) by (apply col2_cop__cop with P B; Col; Cop).
Cop.
apply (conga_sams_nos__nts A B C A B C P'); SumA.
apply l9_9, l9_5 with P B; Col.
apply l12_6, par_strict_col_par_strict with Q'; Col.
intro; subst; apply HNCol5; Col.
apply par_not_col_strict with P'; Col.
apply l12_9 with B P'; Perp; Cop.
elim (col_dec B C Q); intro; [|CopR].

*****
H13 : Col B C Q
HY2 : Col P' Q' Y
HY1 : Col P Q Y
Y : Tpoint
H12 : Coplanar Q Q' B C
H10 : Coplanar P C A B
H4 : Coplanar P' C A B
HCol2 : Col I P Q
HCol1 : Col I A B
I : Tpoint
HNCol5 : not (Col P' P Q)
HPerp3 : Perp B P' P' Q'
HPerp2 : Perp A B P Q
HPerp1 : Perp A B B P'
HNCol4 : not (Col B P' P)
HNCol3 : not (Col A B P')
HPer1 : Per A B P'
HTS : TS B C P P'
HCongA : CongA C B P' A B C
H3 : not (eq P' Q')
H14 : not (eq A C)
H8 : not (eq C P)
H11 : not (eq B P')
H6 : not (eq C P')
HQ'1 : Reflect Q Q' B C
HQ' : ReflectL Q Q' B C
Q' : Tpoint
HNCol2 : not (Col B C P')
HP'1 : Reflect P P' B C
HP' : ReflectL P P' B C
P' : Tpoint
HNCol1 : not (Col B C P)
HNCol : not (Col A B C)
H0 : not (eq D F)
H9 : not (eq E F)
H7 : not (eq D E)
H5 : not (eq B C)
H2 : not (eq P B)
H1 : not (eq A B)
H : not (eq B Q)
HCop : Coplanar A B C Q
HPerP : Per B P Q
HPQ : not (eq P Q)
HOut : Out B P A
HSuma : SumA A B C A B C D E F
HPer : Per D E F
HAcute : Acute A B C
A,B,C,D,E,F,P,Q : Tpoint
lotschnitt : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar B P' A Q'
+++++
assert (Q = Q'); [|treat_equalities; CopR].
-----
Lemma bachmann_s_lotschnittaxiom__weak_inverse_projection_postulate : bachmann_s_lotschnittaxiom -> weak_inverse_projection_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro lotschnitt.
intros A B C D E F P Q HAcute HPer HSuma HOut HPQ HPerP HCop.
suma.assert_diffs.
assert (HNCol : ~ Col A B C).
assert (HNCol1 : ~ Col B C P) by (intro; apply HNCol; ColR).
destruct (l10_6_existence_spec B C P) as [P' HP']; trivial.
assert (HP'1 : Reflect P P' B C) by (apply is_image_is_image_spec; auto).
assert (HNCol2 : ~ Col B C P') by (apply osym_not_col with P; trivial).
destruct (l10_6_existence_spec B C Q) as [Q' HQ']; trivial.
assert (HQ'1 : Reflect Q Q' B C) by (apply is_image_is_image_spec; auto).
assert_diffs.
assert (P' <> Q').
intro; subst Q'; assert (P = Q) by (apply (l10_2_uniqueness B C P'); assumption); auto.
apply l6_6 in HOut.
assert (HCongA : CongA C B P' A B C).
apply out_conga with C P' P C; try (apply out_trivial); auto.
apply conga_sym, conga_left_comm, reflectl__conga; auto.
apply is_image_spec_rev, HP'.
assert (HTS : TS B C P P').
repeat split; Col; destruct HP' as [[X [HX1 HX2]] _]; exists X; split; Col; Between.
assert (HPer1 : Per A B P').
assert (HNCol3 : ~ Col A B P') by (apply per_not_col; auto).
assert (HNCol4 : ~ Col B P' P) by (intro; apply HNCol3; ColR).
assert (HPerp1 : Perp A B B P') by (apply per_perp; auto).
assert (HPerp2 : Perp A B P Q) by (apply perp_left_comm, perp_col with P; Col; apply per_perp; auto).
assert (HPerp3 : Perp B P' P' Q').
apply per_perp; auto; apply image_spec_preserves_per with B P Q B C; trivial; apply col__refl; Col.
assert (HNCol5 : ~ Col P' P Q).
apply (par_not_col B P'); Col.
apply par_not_col_strict with P; Col.
apply l12_9 with A B; Perp; Cop.
assert (Coplanar P' C A B) by (apply col2_cop__cop with P B; Col; Cop).
CopR.
assert (HI := HPerp2); destruct HI as [I [_ [_ [HCol1 [HCol2 _]]]]].
assert (Coplanar P' C A B) by (apply col2_cop__cop with P B; Col; Cop).
assert (Coplanar P C A B) by Cop.
assert (Coplanar Q Q' B C) by Cop.
destruct (lotschnitt A B B P' P Q P' Q' B P P') as [Y [HY1 HY2]]; Col; try CopR.
exists Y; split; trivial.
apply col_one_side_out with A.
apply col_permutation_1, intersection_with_image_gen with P Q P' Q'; Col.
apply invert_one_side, one_side_transitivity with P'.
apply cop__not_two_sides_one_side; Col.
assert (Coplanar P' C A B) by (apply col2_cop__cop with P B; Col; Cop).
Cop.
apply (conga_sams_nos__nts A B C A B C P'); SumA.
apply l9_9, l9_5 with P B; Col.
apply l12_6, par_strict_col_par_strict with Q'; Col.
intro; subst; apply HNCol5; Col.
apply par_not_col_strict with P'; Col.
apply l12_9 with B P'; Perp; Cop.
elim (col_dec B C Q); intro; [|CopR].
assert (Q = Q'); [|treat_equalities; CopR].

*****
H13 : Col B C Q
HY2 : Col P' Q' Y
HY1 : Col P Q Y
Y : Tpoint
H12 : Coplanar Q Q' B C
H10 : Coplanar P C A B
H4 : Coplanar P' C A B
HCol2 : Col I P Q
HCol1 : Col I A B
I : Tpoint
HNCol5 : not (Col P' P Q)
HPerp3 : Perp B P' P' Q'
HPerp2 : Perp A B P Q
HPerp1 : Perp A B B P'
HNCol4 : not (Col B P' P)
HNCol3 : not (Col A B P')
HPer1 : Per A B P'
HTS : TS B C P P'
HCongA : CongA C B P' A B C
H3 : not (eq P' Q')
H14 : not (eq A C)
H8 : not (eq C P)
H11 : not (eq B P')
H6 : not (eq C P')
HQ'1 : Reflect Q Q' B C
HQ' : ReflectL Q Q' B C
Q' : Tpoint
HNCol2 : not (Col B C P')
HP'1 : Reflect P P' B C
HP' : ReflectL P P' B C
P' : Tpoint
HNCol1 : not (Col B C P)
HNCol : not (Col A B C)
H0 : not (eq D F)
H9 : not (eq E F)
H7 : not (eq D E)
H5 : not (eq B C)
H2 : not (eq P B)
H1 : not (eq A B)
H : not (eq B Q)
HCop : Coplanar A B C Q
HPerP : Per B P Q
HPQ : not (eq P Q)
HOut : Out B P A
HSuma : SumA A B C A B C D E F
HPer : Per D E F
HAcute : Acute A B C
A,B,C,D,E,F,P,Q : Tpoint
lotschnitt : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
eq Q Q'
+++++
apply col_image_spec__eq with B C; Col.
-----
Lemma bachmann_s_lotschnittaxiom__weak_inverse_projection_postulate : bachmann_s_lotschnittaxiom -> weak_inverse_projection_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).

*****
bla : bachmann_s_lotschnittaxiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint) (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2) (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC) (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD) (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2) (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2) (_ : not (Col IAB IAC IBD)), ex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
+++++
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
-----
Lemma bachmann_s_lotschnittaxiom__weak_inverse_projection_postulate : bachmann_s_lotschnittaxiom -> weak_inverse_projection_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.

*****
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,IAB,IAC,IBD : Tpoint
bla : bachmann_s_lotschnittaxiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC) (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD) (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2) (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2) (_ : not (Col IAB IAC IBD)), ex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
+++++
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HNCop1 HCop2 HCop3 HCop4 HNC1.
-----
Lemma bachmann_s_lotschnittaxiom__weak_inverse_projection_postulate : bachmann_s_lotschnittaxiom -> weak_inverse_projection_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HNCop1 HCop2 HCop3 HCop4 HNC1.

*****
HNC1 : not (Col IAB IAC IBD)
HCop4 : Coplanar IAB IAC IBD D2
HCop3 : Coplanar IAB IAC IBD D1
HCop2 : Coplanar IAB IAC IBD C2
HNCop1 : Coplanar IAB IAC IBD C1
HCol6 : Col D1 D2 IBD
HCol5 : Col B1 B2 IBD
HCol4 : Col C1 C2 IAC
HCol3 : Col A1 A2 IAC
HCol2 : Col B1 B2 IAB
HCol1 : Col A1 A2 IAB
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,IAB,IAC,IBD : Tpoint
bla : bachmann_s_lotschnittaxiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
+++++
assert (Col IAB IAC A1) by (assert_diffs; ColR).
-----
Lemma bachmann_s_lotschnittaxiom__weak_inverse_projection_postulate : bachmann_s_lotschnittaxiom -> weak_inverse_projection_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HNCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).

*****
H : Col IAB IAC A1
HNC1 : not (Col IAB IAC IBD)
HCop4 : Coplanar IAB IAC IBD D2
HCop3 : Coplanar IAB IAC IBD D1
HCop2 : Coplanar IAB IAC IBD C2
HNCop1 : Coplanar IAB IAC IBD C1
HCol6 : Col D1 D2 IBD
HCol5 : Col B1 B2 IBD
HCol4 : Col C1 C2 IAC
HCol3 : Col A1 A2 IAC
HCol2 : Col B1 B2 IAB
HCol1 : Col A1 A2 IAB
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,IAB,IAC,IBD : Tpoint
bla : bachmann_s_lotschnittaxiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
+++++
assert (Col IAB IAC A2) by (assert_diffs; ColR).
-----
Lemma bachmann_s_lotschnittaxiom__weak_inverse_projection_postulate : bachmann_s_lotschnittaxiom -> weak_inverse_projection_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HNCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).

*****
H0 : Col IAB IAC A2
H : Col IAB IAC A1
HNC1 : not (Col IAB IAC IBD)
HCop4 : Coplanar IAB IAC IBD D2
HCop3 : Coplanar IAB IAC IBD D1
HCop2 : Coplanar IAB IAC IBD C2
HNCop1 : Coplanar IAB IAC IBD C1
HCol6 : Col D1 D2 IBD
HCol5 : Col B1 B2 IBD
HCol4 : Col C1 C2 IAC
HCol3 : Col A1 A2 IAC
HCol2 : Col B1 B2 IAB
HCol1 : Col A1 A2 IAB
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,IAB,IAC,IBD : Tpoint
bla : bachmann_s_lotschnittaxiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
+++++
assert (Col IAB IBD B1) by (assert_diffs; ColR).
-----
Lemma bachmann_s_lotschnittaxiom__weak_inverse_projection_postulate : bachmann_s_lotschnittaxiom -> weak_inverse_projection_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HNCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).

*****
H1 : Col IAB IBD B1
H0 : Col IAB IAC A2
H : Col IAB IAC A1
HNC1 : not (Col IAB IAC IBD)
HCop4 : Coplanar IAB IAC IBD D2
HCop3 : Coplanar IAB IAC IBD D1
HCop2 : Coplanar IAB IAC IBD C2
HNCop1 : Coplanar IAB IAC IBD C1
HCol6 : Col D1 D2 IBD
HCol5 : Col B1 B2 IBD
HCol4 : Col C1 C2 IAC
HCol3 : Col A1 A2 IAC
HCol2 : Col B1 B2 IAB
HCol1 : Col A1 A2 IAB
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,IAB,IAC,IBD : Tpoint
bla : bachmann_s_lotschnittaxiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
+++++
assert (Col IAB IBD B2) by (assert_diffs; ColR).
-----
Lemma bachmann_s_lotschnittaxiom__weak_inverse_projection_postulate : bachmann_s_lotschnittaxiom -> weak_inverse_projection_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HNCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).

*****
H2 : Col IAB IBD B2
H1 : Col IAB IBD B1
H0 : Col IAB IAC A2
H : Col IAB IAC A1
HNC1 : not (Col IAB IAC IBD)
HCop4 : Coplanar IAB IAC IBD D2
HCop3 : Coplanar IAB IAC IBD D1
HCop2 : Coplanar IAB IAC IBD C2
HNCop1 : Coplanar IAB IAC IBD C1
HCol6 : Col D1 D2 IBD
HCol5 : Col B1 B2 IBD
HCol4 : Col C1 C2 IAC
HCol3 : Col A1 A2 IAC
HCol2 : Col B1 B2 IAB
HCol1 : Col A1 A2 IAB
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,IAB,IAC,IBD : Tpoint
bla : bachmann_s_lotschnittaxiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
+++++
assert (Coplanar IAB IAC IBD A1) by Cop.
-----
Lemma bachmann_s_lotschnittaxiom__weak_inverse_projection_postulate : bachmann_s_lotschnittaxiom -> weak_inverse_projection_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HNCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.

*****
H3 : Coplanar IAB IAC IBD A1
H2 : Col IAB IBD B2
H1 : Col IAB IBD B1
H0 : Col IAB IAC A2
H : Col IAB IAC A1
HNC1 : not (Col IAB IAC IBD)
HCop4 : Coplanar IAB IAC IBD D2
HCop3 : Coplanar IAB IAC IBD D1
HCop2 : Coplanar IAB IAC IBD C2
HNCop1 : Coplanar IAB IAC IBD C1
HCol6 : Col D1 D2 IBD
HCol5 : Col B1 B2 IBD
HCol4 : Col C1 C2 IAC
HCol3 : Col A1 A2 IAC
HCol2 : Col B1 B2 IAB
HCol1 : Col A1 A2 IAB
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,IAB,IAC,IBD : Tpoint
bla : bachmann_s_lotschnittaxiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
+++++
assert (Coplanar IAB IAC IBD A2) by Cop.
-----
Lemma bachmann_s_lotschnittaxiom__weak_inverse_projection_postulate : bachmann_s_lotschnittaxiom -> weak_inverse_projection_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HNCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.

*****
H4 : Coplanar IAB IAC IBD A2
H3 : Coplanar IAB IAC IBD A1
H2 : Col IAB IBD B2
H1 : Col IAB IBD B1
H0 : Col IAB IAC A2
H : Col IAB IAC A1
HNC1 : not (Col IAB IAC IBD)
HCop4 : Coplanar IAB IAC IBD D2
HCop3 : Coplanar IAB IAC IBD D1
HCop2 : Coplanar IAB IAC IBD C2
HNCop1 : Coplanar IAB IAC IBD C1
HCol6 : Col D1 D2 IBD
HCol5 : Col B1 B2 IBD
HCol4 : Col C1 C2 IAC
HCol3 : Col A1 A2 IAC
HCol2 : Col B1 B2 IAB
HCol1 : Col A1 A2 IAB
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,IAB,IAC,IBD : Tpoint
bla : bachmann_s_lotschnittaxiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
+++++
assert (Coplanar IAB IAC IBD B1) by Cop.
-----
Lemma bachmann_s_lotschnittaxiom__weak_inverse_projection_postulate : bachmann_s_lotschnittaxiom -> weak_inverse_projection_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HNCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.
assert (Coplanar IAB IAC IBD B1) by Cop.

*****
H5 : Coplanar IAB IAC IBD B1
H4 : Coplanar IAB IAC IBD A2
H3 : Coplanar IAB IAC IBD A1
H2 : Col IAB IBD B2
H1 : Col IAB IBD B1
H0 : Col IAB IAC A2
H : Col IAB IAC A1
HNC1 : not (Col IAB IAC IBD)
HCop4 : Coplanar IAB IAC IBD D2
HCop3 : Coplanar IAB IAC IBD D1
HCop2 : Coplanar IAB IAC IBD C2
HNCop1 : Coplanar IAB IAC IBD C1
HCol6 : Col D1 D2 IBD
HCol5 : Col B1 B2 IBD
HCol4 : Col C1 C2 IAC
HCol3 : Col A1 A2 IAC
HCol2 : Col B1 B2 IAB
HCol1 : Col A1 A2 IAB
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,IAB,IAC,IBD : Tpoint
bla : bachmann_s_lotschnittaxiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
+++++
assert (Coplanar IAB IAC IBD B2) by Cop.
-----
Lemma bachmann_s_lotschnittaxiom__weak_inverse_projection_postulate : bachmann_s_lotschnittaxiom -> weak_inverse_projection_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HNCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.
assert (Coplanar IAB IAC IBD B1) by Cop.
assert (Coplanar IAB IAC IBD B2) by Cop.

*****
H6 : Coplanar IAB IAC IBD B2
H5 : Coplanar IAB IAC IBD B1
H4 : Coplanar IAB IAC IBD A2
H3 : Coplanar IAB IAC IBD A1
H2 : Col IAB IBD B2
H1 : Col IAB IBD B1
H0 : Col IAB IAC A2
H : Col IAB IAC A1
HNC1 : not (Col IAB IAC IBD)
HCop4 : Coplanar IAB IAC IBD D2
HCop3 : Coplanar IAB IAC IBD D1
HCop2 : Coplanar IAB IAC IBD C2
HNCop1 : Coplanar IAB IAC IBD C1
HCol6 : Col D1 D2 IBD
HCol5 : Col B1 B2 IBD
HCol4 : Col C1 C2 IAC
HCol3 : Col A1 A2 IAC
HCol2 : Col B1 B2 IAB
HCol1 : Col A1 A2 IAB
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,IAB,IAC,IBD : Tpoint
bla : bachmann_s_lotschnittaxiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
+++++
assert (HNC2 : ~ Col A1 A2 D1).
-----
Lemma bachmann_s_lotschnittaxiom__weak_inverse_projection_postulate : bachmann_s_lotschnittaxiom -> weak_inverse_projection_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HNCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.
assert (Coplanar IAB IAC IBD B1) by Cop.
assert (Coplanar IAB IAC IBD B2) by Cop.
assert (HNC2 : ~ Col A1 A2 D1).

*****
H6 : Coplanar IAB IAC IBD B2
H5 : Coplanar IAB IAC IBD B1
H4 : Coplanar IAB IAC IBD A2
H3 : Coplanar IAB IAC IBD A1
H2 : Col IAB IBD B2
H1 : Col IAB IBD B1
H0 : Col IAB IAC A2
H : Col IAB IAC A1
HNC1 : not (Col IAB IAC IBD)
HCop4 : Coplanar IAB IAC IBD D2
HCop3 : Coplanar IAB IAC IBD D1
HCop2 : Coplanar IAB IAC IBD C2
HNCop1 : Coplanar IAB IAC IBD C1
HCol6 : Col D1 D2 IBD
HCol5 : Col B1 B2 IBD
HCol4 : Col C1 C2 IAC
HCol3 : Col A1 A2 IAC
HCol2 : Col B1 B2 IAB
HCol1 : Col A1 A2 IAB
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,IAB,IAC,IBD : Tpoint
bla : bachmann_s_lotschnittaxiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col A1 A2 D1)
+++++
apply par_strict_not_col_1 with D2; apply par_not_col_strict with IBD; Col; try (intro; apply HNC1; assert_diffs; ColR).
-----
Lemma bachmann_s_lotschnittaxiom__weak_inverse_projection_postulate : bachmann_s_lotschnittaxiom -> weak_inverse_projection_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HNCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.
assert (Coplanar IAB IAC IBD B1) by Cop.
assert (Coplanar IAB IAC IBD B2) by Cop.
assert (HNC2 : ~ Col A1 A2 D1).
apply par_strict_not_col_1 with D2; apply par_not_col_strict with IBD; Col; try (intro; apply HNC1; assert_diffs; ColR).

*****
H6 : Coplanar IAB IAC IBD B2
H5 : Coplanar IAB IAC IBD B1
H4 : Coplanar IAB IAC IBD A2
H3 : Coplanar IAB IAC IBD A1
H2 : Col IAB IBD B2
H1 : Col IAB IBD B1
H0 : Col IAB IAC A2
H : Col IAB IAC A1
HNC1 : not (Col IAB IAC IBD)
HCop4 : Coplanar IAB IAC IBD D2
HCop3 : Coplanar IAB IAC IBD D1
HCop2 : Coplanar IAB IAC IBD C2
HNCop1 : Coplanar IAB IAC IBD C1
HCol6 : Col D1 D2 IBD
HCol5 : Col B1 B2 IBD
HCol4 : Col C1 C2 IAC
HCol3 : Col A1 A2 IAC
HCol2 : Col B1 B2 IAB
HCol1 : Col A1 A2 IAB
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,IAB,IAC,IBD : Tpoint
bla : bachmann_s_lotschnittaxiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Par A1 A2 D1 D2
+++++
apply l12_9 with B1 B2; Perp; CopR.
-----
Lemma bachmann_s_lotschnittaxiom__weak_inverse_projection_postulate : bachmann_s_lotschnittaxiom -> weak_inverse_projection_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HNCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.
assert (Coplanar IAB IAC IBD B1) by Cop.
assert (Coplanar IAB IAC IBD B2) by Cop.
assert (HNC2 : ~ Col A1 A2 D1).

*****
HNC2 : not (Col A1 A2 D1)
H6 : Coplanar IAB IAC IBD B2
H5 : Coplanar IAB IAC IBD B1
H4 : Coplanar IAB IAC IBD A2
H3 : Coplanar IAB IAC IBD A1
H2 : Col IAB IBD B2
H1 : Col IAB IBD B1
H0 : Col IAB IAC A2
H : Col IAB IAC A1
HNC1 : not (Col IAB IAC IBD)
HCop4 : Coplanar IAB IAC IBD D2
HCop3 : Coplanar IAB IAC IBD D1
HCop2 : Coplanar IAB IAC IBD C2
HNCop1 : Coplanar IAB IAC IBD C1
HCol6 : Col D1 D2 IBD
HCol5 : Col B1 B2 IBD
HCol4 : Col C1 C2 IAC
HCol3 : Col A1 A2 IAC
HCol2 : Col B1 B2 IAB
HCol1 : Col A1 A2 IAB
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,IAB,IAC,IBD : Tpoint
bla : bachmann_s_lotschnittaxiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
+++++
assert (HNC3 : ~ Col B1 B2 C1).
-----
Lemma bachmann_s_lotschnittaxiom__weak_inverse_projection_postulate : bachmann_s_lotschnittaxiom -> weak_inverse_projection_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HNCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.
assert (Coplanar IAB IAC IBD B1) by Cop.
assert (Coplanar IAB IAC IBD B2) by Cop.
assert (HNC2 : ~ Col A1 A2 D1).
assert (HNC3 : ~ Col B1 B2 C1).

*****
HNC2 : not (Col A1 A2 D1)
H6 : Coplanar IAB IAC IBD B2
H5 : Coplanar IAB IAC IBD B1
H4 : Coplanar IAB IAC IBD A2
H3 : Coplanar IAB IAC IBD A1
H2 : Col IAB IBD B2
H1 : Col IAB IBD B1
H0 : Col IAB IAC A2
H : Col IAB IAC A1
HNC1 : not (Col IAB IAC IBD)
HCop4 : Coplanar IAB IAC IBD D2
HCop3 : Coplanar IAB IAC IBD D1
HCop2 : Coplanar IAB IAC IBD C2
HNCop1 : Coplanar IAB IAC IBD C1
HCol6 : Col D1 D2 IBD
HCol5 : Col B1 B2 IBD
HCol4 : Col C1 C2 IAC
HCol3 : Col A1 A2 IAC
HCol2 : Col B1 B2 IAB
HCol1 : Col A1 A2 IAB
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,IAB,IAC,IBD : Tpoint
bla : bachmann_s_lotschnittaxiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col B1 B2 C1)
+++++
apply par_strict_not_col_1 with C2; apply par_not_col_strict with IAC; Col; try (intro; apply HNC1; assert_diffs; ColR).
-----
Lemma bachmann_s_lotschnittaxiom__weak_inverse_projection_postulate : bachmann_s_lotschnittaxiom -> weak_inverse_projection_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HNCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.
assert (Coplanar IAB IAC IBD B1) by Cop.
assert (Coplanar IAB IAC IBD B2) by Cop.
assert (HNC2 : ~ Col A1 A2 D1).
assert (HNC3 : ~ Col B1 B2 C1).
apply par_strict_not_col_1 with C2; apply par_not_col_strict with IAC; Col; try (intro; apply HNC1; assert_diffs; ColR).

*****
HNC2 : not (Col A1 A2 D1)
H6 : Coplanar IAB IAC IBD B2
H5 : Coplanar IAB IAC IBD B1
H4 : Coplanar IAB IAC IBD A2
H3 : Coplanar IAB IAC IBD A1
H2 : Col IAB IBD B2
H1 : Col IAB IBD B1
H0 : Col IAB IAC A2
H : Col IAB IAC A1
HNC1 : not (Col IAB IAC IBD)
HCop4 : Coplanar IAB IAC IBD D2
HCop3 : Coplanar IAB IAC IBD D1
HCop2 : Coplanar IAB IAC IBD C2
HNCop1 : Coplanar IAB IAC IBD C1
HCol6 : Col D1 D2 IBD
HCol5 : Col B1 B2 IBD
HCol4 : Col C1 C2 IAC
HCol3 : Col A1 A2 IAC
HCol2 : Col B1 B2 IAB
HCol1 : Col A1 A2 IAB
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,IAB,IAC,IBD : Tpoint
bla : bachmann_s_lotschnittaxiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Par B1 B2 C1 C2
+++++
apply l12_9 with A1 A2; Perp; CopR.
-----
Lemma bachmann_s_lotschnittaxiom__weak_inverse_projection_postulate : bachmann_s_lotschnittaxiom -> weak_inverse_projection_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HNCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.
assert (Coplanar IAB IAC IBD B1) by Cop.
assert (Coplanar IAB IAC IBD B2) by Cop.
assert (HNC2 : ~ Col A1 A2 D1).
assert (HNC3 : ~ Col B1 B2 C1).

*****
HNC3 : not (Col B1 B2 C1)
HNC2 : not (Col A1 A2 D1)
H6 : Coplanar IAB IAC IBD B2
H5 : Coplanar IAB IAC IBD B1
H4 : Coplanar IAB IAC IBD A2
H3 : Coplanar IAB IAC IBD A1
H2 : Col IAB IBD B2
H1 : Col IAB IBD B1
H0 : Col IAB IAC A2
H : Col IAB IAC A1
HNC1 : not (Col IAB IAC IBD)
HCop4 : Coplanar IAB IAC IBD D2
HCop3 : Coplanar IAB IAC IBD D1
HCop2 : Coplanar IAB IAC IBD C2
HNCop1 : Coplanar IAB IAC IBD C1
HCol6 : Col D1 D2 IBD
HCol5 : Col B1 B2 IBD
HCol4 : Col C1 C2 IAC
HCol3 : Col A1 A2 IAC
HCol2 : Col B1 B2 IAB
HCol1 : Col A1 A2 IAB
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,IAB,IAC,IBD : Tpoint
bla : bachmann_s_lotschnittaxiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
+++++
assert (HParA : Par_strict A1 A2 D1 D2).
-----
Lemma bachmann_s_lotschnittaxiom__weak_inverse_projection_postulate : bachmann_s_lotschnittaxiom -> weak_inverse_projection_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HNCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.
assert (Coplanar IAB IAC IBD B1) by Cop.
assert (Coplanar IAB IAC IBD B2) by Cop.
assert (HNC2 : ~ Col A1 A2 D1).
assert (HNC3 : ~ Col B1 B2 C1).
assert (HParA : Par_strict A1 A2 D1 D2).

*****
HNC3 : not (Col B1 B2 C1)
HNC2 : not (Col A1 A2 D1)
H6 : Coplanar IAB IAC IBD B2
H5 : Coplanar IAB IAC IBD B1
H4 : Coplanar IAB IAC IBD A2
H3 : Coplanar IAB IAC IBD A1
H2 : Col IAB IBD B2
H1 : Col IAB IBD B1
H0 : Col IAB IAC A2
H : Col IAB IAC A1
HNC1 : not (Col IAB IAC IBD)
HCop4 : Coplanar IAB IAC IBD D2
HCop3 : Coplanar IAB IAC IBD D1
HCop2 : Coplanar IAB IAC IBD C2
HNCop1 : Coplanar IAB IAC IBD C1
HCol6 : Col D1 D2 IBD
HCol5 : Col B1 B2 IBD
HCol4 : Col C1 C2 IAC
HCol3 : Col A1 A2 IAC
HCol2 : Col B1 B2 IAB
HCol1 : Col A1 A2 IAB
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,IAB,IAC,IBD : Tpoint
bla : bachmann_s_lotschnittaxiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Par_strict A1 A2 D1 D2
+++++
apply par_not_col_strict with D1; Col; apply l12_9 with B1 B2; Perp; CopR.
-----
Lemma bachmann_s_lotschnittaxiom__weak_inverse_projection_postulate : bachmann_s_lotschnittaxiom -> weak_inverse_projection_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HNCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.
assert (Coplanar IAB IAC IBD B1) by Cop.
assert (Coplanar IAB IAC IBD B2) by Cop.
assert (HNC2 : ~ Col A1 A2 D1).
assert (HNC3 : ~ Col B1 B2 C1).
assert (HParA : Par_strict A1 A2 D1 D2).
apply par_not_col_strict with D1; Col; apply l12_9 with B1 B2; Perp; CopR.

*****
HParA : Par_strict A1 A2 D1 D2
HNC3 : not (Col B1 B2 C1)
HNC2 : not (Col A1 A2 D1)
H6 : Coplanar IAB IAC IBD B2
H5 : Coplanar IAB IAC IBD B1
H4 : Coplanar IAB IAC IBD A2
H3 : Coplanar IAB IAC IBD A1
H2 : Col IAB IBD B2
H1 : Col IAB IBD B1
H0 : Col IAB IAC A2
H : Col IAB IAC A1
HNC1 : not (Col IAB IAC IBD)
HCop4 : Coplanar IAB IAC IBD D2
HCop3 : Coplanar IAB IAC IBD D1
HCop2 : Coplanar IAB IAC IBD C2
HNCop1 : Coplanar IAB IAC IBD C1
HCol6 : Col D1 D2 IBD
HCol5 : Col B1 B2 IBD
HCol4 : Col C1 C2 IAC
HCol3 : Col A1 A2 IAC
HCol2 : Col B1 B2 IAB
HCol1 : Col A1 A2 IAB
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,IAB,IAC,IBD : Tpoint
bla : bachmann_s_lotschnittaxiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
+++++
assert (HParB : Par_strict B1 B2 C1 C2).
-----
Lemma bachmann_s_lotschnittaxiom__weak_inverse_projection_postulate : bachmann_s_lotschnittaxiom -> weak_inverse_projection_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HNCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.
assert (Coplanar IAB IAC IBD B1) by Cop.
assert (Coplanar IAB IAC IBD B2) by Cop.
assert (HNC2 : ~ Col A1 A2 D1).
assert (HNC3 : ~ Col B1 B2 C1).
assert (HParA : Par_strict A1 A2 D1 D2).
apply par_not_col_strict with D1; Col; apply l12_9 with B1 B2; Perp; CopR.
assert (HParB : Par_strict B1 B2 C1 C2).

*****
HParA : Par_strict A1 A2 D1 D2
HNC3 : not (Col B1 B2 C1)
HNC2 : not (Col A1 A2 D1)
H6 : Coplanar IAB IAC IBD B2
H5 : Coplanar IAB IAC IBD B1
H4 : Coplanar IAB IAC IBD A2
H3 : Coplanar IAB IAC IBD A1
H2 : Col IAB IBD B2
H1 : Col IAB IBD B1
H0 : Col IAB IAC A2
H : Col IAB IAC A1
HNC1 : not (Col IAB IAC IBD)
HCop4 : Coplanar IAB IAC IBD D2
HCop3 : Coplanar IAB IAC IBD D1
HCop2 : Coplanar IAB IAC IBD C2
HNCop1 : Coplanar IAB IAC IBD C1
HCol6 : Col D1 D2 IBD
HCol5 : Col B1 B2 IBD
HCol4 : Col C1 C2 IAC
HCol3 : Col A1 A2 IAC
HCol2 : Col B1 B2 IAB
HCol1 : Col A1 A2 IAB
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,IAB,IAC,IBD : Tpoint
bla : bachmann_s_lotschnittaxiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Par_strict B1 B2 C1 C2
+++++
apply par_not_col_strict with C1; Col; apply l12_9 with A1 A2; Perp; CopR.
-----
Lemma bachmann_s_lotschnittaxiom__weak_inverse_projection_postulate : bachmann_s_lotschnittaxiom -> weak_inverse_projection_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HNCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.
assert (Coplanar IAB IAC IBD B1) by Cop.
assert (Coplanar IAB IAC IBD B2) by Cop.
assert (HNC2 : ~ Col A1 A2 D1).
assert (HNC3 : ~ Col B1 B2 C1).
assert (HParA : Par_strict A1 A2 D1 D2).
apply par_not_col_strict with D1; Col; apply l12_9 with B1 B2; Perp; CopR.
assert (HParB : Par_strict B1 B2 C1 C2).
apply par_not_col_strict with C1; Col; apply l12_9 with A1 A2; Perp; CopR.

*****
HParB : Par_strict B1 B2 C1 C2
HParA : Par_strict A1 A2 D1 D2
HNC3 : not (Col B1 B2 C1)
HNC2 : not (Col A1 A2 D1)
H6 : Coplanar IAB IAC IBD B2
H5 : Coplanar IAB IAC IBD B1
H4 : Coplanar IAB IAC IBD A2
H3 : Coplanar IAB IAC IBD A1
H2 : Col IAB IBD B2
H1 : Col IAB IBD B1
H0 : Col IAB IAC A2
H : Col IAB IAC A1
HNC1 : not (Col IAB IAC IBD)
HCop4 : Coplanar IAB IAC IBD D2
HCop3 : Coplanar IAB IAC IBD D1
HCop2 : Coplanar IAB IAC IBD C2
HNCop1 : Coplanar IAB IAC IBD C1
HCol6 : Col D1 D2 IBD
HCol5 : Col B1 B2 IBD
HCol4 : Col C1 C2 IAC
HCol3 : Col A1 A2 IAC
HCol2 : Col B1 B2 IAB
HCol1 : Col A1 A2 IAB
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,IAB,IAC,IBD : Tpoint
bla : bachmann_s_lotschnittaxiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
+++++
assert (HNCol3 : ~ Col IAC B1 B2) by (apply par_not_col with C1 C2; Par; ColR).
-----
Lemma bachmann_s_lotschnittaxiom__weak_inverse_projection_postulate : bachmann_s_lotschnittaxiom -> weak_inverse_projection_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HNCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.
assert (Coplanar IAB IAC IBD B1) by Cop.
assert (Coplanar IAB IAC IBD B2) by Cop.
assert (HNC2 : ~ Col A1 A2 D1).
assert (HNC3 : ~ Col B1 B2 C1).
assert (HParA : Par_strict A1 A2 D1 D2).
apply par_not_col_strict with D1; Col; apply l12_9 with B1 B2; Perp; CopR.
assert (HParB : Par_strict B1 B2 C1 C2).
apply par_not_col_strict with C1; Col; apply l12_9 with A1 A2; Perp; CopR.
assert (HNCol3 : ~ Col IAC B1 B2) by (apply par_not_col with C1 C2; Par; ColR).

*****
HNCol3 : not (Col IAC B1 B2)
HParB : Par_strict B1 B2 C1 C2
HParA : Par_strict A1 A2 D1 D2
HNC3 : not (Col B1 B2 C1)
HNC2 : not (Col A1 A2 D1)
H6 : Coplanar IAB IAC IBD B2
H5 : Coplanar IAB IAC IBD B1
H4 : Coplanar IAB IAC IBD A2
H3 : Coplanar IAB IAC IBD A1
H2 : Col IAB IBD B2
H1 : Col IAB IBD B1
H0 : Col IAB IAC A2
H : Col IAB IAC A1
HNC1 : not (Col IAB IAC IBD)
HCop4 : Coplanar IAB IAC IBD D2
HCop3 : Coplanar IAB IAC IBD D1
HCop2 : Coplanar IAB IAC IBD C2
HNCop1 : Coplanar IAB IAC IBD C1
HCol6 : Col D1 D2 IBD
HCol5 : Col B1 B2 IBD
HCol4 : Col C1 C2 IAC
HCol3 : Col A1 A2 IAC
HCol2 : Col B1 B2 IAB
HCol1 : Col A1 A2 IAB
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,IAB,IAC,IBD : Tpoint
bla : bachmann_s_lotschnittaxiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
+++++
assert (HNCol4 : ~ Col IBD A1 A2) by (apply par_not_col with D1 D2; Par; ColR).
-----
Lemma bachmann_s_lotschnittaxiom__weak_inverse_projection_postulate : bachmann_s_lotschnittaxiom -> weak_inverse_projection_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HNCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.
assert (Coplanar IAB IAC IBD B1) by Cop.
assert (Coplanar IAB IAC IBD B2) by Cop.
assert (HNC2 : ~ Col A1 A2 D1).
assert (HNC3 : ~ Col B1 B2 C1).
assert (HParA : Par_strict A1 A2 D1 D2).
apply par_not_col_strict with D1; Col; apply l12_9 with B1 B2; Perp; CopR.
assert (HParB : Par_strict B1 B2 C1 C2).
apply par_not_col_strict with C1; Col; apply l12_9 with A1 A2; Perp; CopR.
assert (HNCol3 : ~ Col IAC B1 B2) by (apply par_not_col with C1 C2; Par; ColR).
assert (HNCol4 : ~ Col IBD A1 A2) by (apply par_not_col with D1 D2; Par; ColR).

*****
HNCol4 : not (Col IBD A1 A2)
HNCol3 : not (Col IAC B1 B2)
HParB : Par_strict B1 B2 C1 C2
HParA : Par_strict A1 A2 D1 D2
HNC3 : not (Col B1 B2 C1)
HNC2 : not (Col A1 A2 D1)
H6 : Coplanar IAB IAC IBD B2
H5 : Coplanar IAB IAC IBD B1
H4 : Coplanar IAB IAC IBD A2
H3 : Coplanar IAB IAC IBD A1
H2 : Col IAB IBD B2
H1 : Col IAB IBD B1
H0 : Col IAB IAC A2
H : Col IAB IAC A1
HNC1 : not (Col IAB IAC IBD)
HCop4 : Coplanar IAB IAC IBD D2
HCop3 : Coplanar IAB IAC IBD D1
HCop2 : Coplanar IAB IAC IBD C2
HNCop1 : Coplanar IAB IAC IBD C1
HCol6 : Col D1 D2 IBD
HCol5 : Col B1 B2 IBD
HCol4 : Col C1 C2 IAC
HCol3 : Col A1 A2 IAC
HCol2 : Col B1 B2 IAB
HCol1 : Col A1 A2 IAB
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,IAB,IAC,IBD : Tpoint
bla : bachmann_s_lotschnittaxiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
+++++
assert (HPQ : IAC <> IAB) by (assert_diffs; auto).
-----
Lemma bachmann_s_lotschnittaxiom__weak_inverse_projection_postulate : bachmann_s_lotschnittaxiom -> weak_inverse_projection_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HNCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.
assert (Coplanar IAB IAC IBD B1) by Cop.
assert (Coplanar IAB IAC IBD B2) by Cop.
assert (HNC2 : ~ Col A1 A2 D1).
assert (HNC3 : ~ Col B1 B2 C1).
assert (HParA : Par_strict A1 A2 D1 D2).
apply par_not_col_strict with D1; Col; apply l12_9 with B1 B2; Perp; CopR.
assert (HParB : Par_strict B1 B2 C1 C2).
apply par_not_col_strict with C1; Col; apply l12_9 with A1 A2; Perp; CopR.
assert (HNCol3 : ~ Col IAC B1 B2) by (apply par_not_col with C1 C2; Par; ColR).
assert (HNCol4 : ~ Col IBD A1 A2) by (apply par_not_col with D1 D2; Par; ColR).
assert (HPQ : IAC <> IAB) by (assert_diffs; auto).

*****
HPQ : not (eq IAC IAB)
HNCol4 : not (Col IBD A1 A2)
HNCol3 : not (Col IAC B1 B2)
HParB : Par_strict B1 B2 C1 C2
HParA : Par_strict A1 A2 D1 D2
HNC3 : not (Col B1 B2 C1)
HNC2 : not (Col A1 A2 D1)
H6 : Coplanar IAB IAC IBD B2
H5 : Coplanar IAB IAC IBD B1
H4 : Coplanar IAB IAC IBD A2
H3 : Coplanar IAB IAC IBD A1
H2 : Col IAB IBD B2
H1 : Col IAB IBD B1
H0 : Col IAB IAC A2
H : Col IAB IAC A1
HNC1 : not (Col IAB IAC IBD)
HCop4 : Coplanar IAB IAC IBD D2
HCop3 : Coplanar IAB IAC IBD D1
HCop2 : Coplanar IAB IAC IBD C2
HNCop1 : Coplanar IAB IAC IBD C1
HCol6 : Col D1 D2 IBD
HCol5 : Col B1 B2 IBD
HCol4 : Col C1 C2 IAC
HCol3 : Col A1 A2 IAC
HCol2 : Col B1 B2 IAB
HCol1 : Col A1 A2 IAB
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,IAB,IAC,IBD : Tpoint
bla : bachmann_s_lotschnittaxiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
+++++
assert (HQR : IAB <> IBD) by (assert_diffs; auto).
-----
Lemma bachmann_s_lotschnittaxiom__weak_inverse_projection_postulate : bachmann_s_lotschnittaxiom -> weak_inverse_projection_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HNCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.
assert (Coplanar IAB IAC IBD B1) by Cop.
assert (Coplanar IAB IAC IBD B2) by Cop.
assert (HNC2 : ~ Col A1 A2 D1).
assert (HNC3 : ~ Col B1 B2 C1).
assert (HParA : Par_strict A1 A2 D1 D2).
apply par_not_col_strict with D1; Col; apply l12_9 with B1 B2; Perp; CopR.
assert (HParB : Par_strict B1 B2 C1 C2).
apply par_not_col_strict with C1; Col; apply l12_9 with A1 A2; Perp; CopR.
assert (HNCol3 : ~ Col IAC B1 B2) by (apply par_not_col with C1 C2; Par; ColR).
assert (HNCol4 : ~ Col IBD A1 A2) by (apply par_not_col with D1 D2; Par; ColR).
assert (HPQ : IAC <> IAB) by (assert_diffs; auto).
assert (HQR : IAB <> IBD) by (assert_diffs; auto).

*****
HQR : not (eq IAB IBD)
HPQ : not (eq IAC IAB)
HNCol4 : not (Col IBD A1 A2)
HNCol3 : not (Col IAC B1 B2)
HParB : Par_strict B1 B2 C1 C2
HParA : Par_strict A1 A2 D1 D2
HNC3 : not (Col B1 B2 C1)
HNC2 : not (Col A1 A2 D1)
H6 : Coplanar IAB IAC IBD B2
H5 : Coplanar IAB IAC IBD B1
H4 : Coplanar IAB IAC IBD A2
H3 : Coplanar IAB IAC IBD A1
H2 : Col IAB IBD B2
H1 : Col IAB IBD B1
H0 : Col IAB IAC A2
H : Col IAB IAC A1
HNC1 : not (Col IAB IAC IBD)
HCop4 : Coplanar IAB IAC IBD D2
HCop3 : Coplanar IAB IAC IBD D1
HCop2 : Coplanar IAB IAC IBD C2
HNCop1 : Coplanar IAB IAC IBD C1
HCol6 : Col D1 D2 IBD
HCol5 : Col B1 B2 IBD
HCol4 : Col C1 C2 IAC
HCol3 : Col A1 A2 IAC
HCol2 : Col B1 B2 IAB
HCol1 : Col A1 A2 IAB
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,IAB,IAC,IBD : Tpoint
bla : bachmann_s_lotschnittaxiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
+++++
destruct (diff_col_ex3 C1 C2 IAC) as [P1 [HC1P1 [HC2P1 [HPP1 HCP1]]]]; Col.
-----
Lemma bachmann_s_lotschnittaxiom__weak_inverse_projection_postulate : bachmann_s_lotschnittaxiom -> weak_inverse_projection_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HNCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.
assert (Coplanar IAB IAC IBD B1) by Cop.
assert (Coplanar IAB IAC IBD B2) by Cop.
assert (HNC2 : ~ Col A1 A2 D1).
assert (HNC3 : ~ Col B1 B2 C1).
assert (HParA : Par_strict A1 A2 D1 D2).
apply par_not_col_strict with D1; Col; apply l12_9 with B1 B2; Perp; CopR.
assert (HParB : Par_strict B1 B2 C1 C2).
apply par_not_col_strict with C1; Col; apply l12_9 with A1 A2; Perp; CopR.
assert (HNCol3 : ~ Col IAC B1 B2) by (apply par_not_col with C1 C2; Par; ColR).
assert (HNCol4 : ~ Col IBD A1 A2) by (apply par_not_col with D1 D2; Par; ColR).
assert (HPQ : IAC <> IAB) by (assert_diffs; auto).
assert (HQR : IAB <> IBD) by (assert_diffs; auto).
destruct (diff_col_ex3 C1 C2 IAC) as [P1 [HC1P1 [HC2P1 [HPP1 HCP1]]]]; Col.

*****
HCP1 : Col C1 C2 P1
HPP1 : not (eq IAC P1)
HC2P1 : not (eq C2 P1)
HC1P1 : not (eq C1 P1)
P1 : Tpoint
HQR : not (eq IAB IBD)
HPQ : not (eq IAC IAB)
HNCol4 : not (Col IBD A1 A2)
HNCol3 : not (Col IAC B1 B2)
HParB : Par_strict B1 B2 C1 C2
HParA : Par_strict A1 A2 D1 D2
HNC3 : not (Col B1 B2 C1)
HNC2 : not (Col A1 A2 D1)
H6 : Coplanar IAB IAC IBD B2
H5 : Coplanar IAB IAC IBD B1
H4 : Coplanar IAB IAC IBD A2
H3 : Coplanar IAB IAC IBD A1
H2 : Col IAB IBD B2
H1 : Col IAB IBD B1
H0 : Col IAB IAC A2
H : Col IAB IAC A1
HNC1 : not (Col IAB IAC IBD)
HCop4 : Coplanar IAB IAC IBD D2
HCop3 : Coplanar IAB IAC IBD D1
HCop2 : Coplanar IAB IAC IBD C2
HNCop1 : Coplanar IAB IAC IBD C1
HCol6 : Col D1 D2 IBD
HCol5 : Col B1 B2 IBD
HCol4 : Col C1 C2 IAC
HCol3 : Col A1 A2 IAC
HCol2 : Col B1 B2 IAB
HCol1 : Col A1 A2 IAB
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,IAB,IAC,IBD : Tpoint
bla : bachmann_s_lotschnittaxiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
+++++
destruct (diff_col_ex3 D1 D2 IBD) as [R1 [HD1R1 [HD2R1 [HRR1 HDR1]]]]; Col.
-----
Lemma bachmann_s_lotschnittaxiom__weak_inverse_projection_postulate : bachmann_s_lotschnittaxiom -> weak_inverse_projection_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HNCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.
assert (Coplanar IAB IAC IBD B1) by Cop.
assert (Coplanar IAB IAC IBD B2) by Cop.
assert (HNC2 : ~ Col A1 A2 D1).
assert (HNC3 : ~ Col B1 B2 C1).
assert (HParA : Par_strict A1 A2 D1 D2).
apply par_not_col_strict with D1; Col; apply l12_9 with B1 B2; Perp; CopR.
assert (HParB : Par_strict B1 B2 C1 C2).
apply par_not_col_strict with C1; Col; apply l12_9 with A1 A2; Perp; CopR.
assert (HNCol3 : ~ Col IAC B1 B2) by (apply par_not_col with C1 C2; Par; ColR).
assert (HNCol4 : ~ Col IBD A1 A2) by (apply par_not_col with D1 D2; Par; ColR).
assert (HPQ : IAC <> IAB) by (assert_diffs; auto).
assert (HQR : IAB <> IBD) by (assert_diffs; auto).
destruct (diff_col_ex3 C1 C2 IAC) as [P1 [HC1P1 [HC2P1 [HPP1 HCP1]]]]; Col.
destruct (diff_col_ex3 D1 D2 IBD) as [R1 [HD1R1 [HD2R1 [HRR1 HDR1]]]]; Col.

*****
HDR1 : Col D1 D2 R1
HRR1 : not (eq IBD R1)
HD2R1 : not (eq D2 R1)
HD1R1 : not (eq D1 R1)
R1 : Tpoint
HCP1 : Col C1 C2 P1
HPP1 : not (eq IAC P1)
HC2P1 : not (eq C2 P1)
HC1P1 : not (eq C1 P1)
P1 : Tpoint
HQR : not (eq IAB IBD)
HPQ : not (eq IAC IAB)
HNCol4 : not (Col IBD A1 A2)
HNCol3 : not (Col IAC B1 B2)
HParB : Par_strict B1 B2 C1 C2
HParA : Par_strict A1 A2 D1 D2
HNC3 : not (Col B1 B2 C1)
HNC2 : not (Col A1 A2 D1)
H6 : Coplanar IAB IAC IBD B2
H5 : Coplanar IAB IAC IBD B1
H4 : Coplanar IAB IAC IBD A2
H3 : Coplanar IAB IAC IBD A1
H2 : Col IAB IBD B2
H1 : Col IAB IBD B1
H0 : Col IAB IAC A2
H : Col IAB IAC A1
HNC1 : not (Col IAB IAC IBD)
HCop4 : Coplanar IAB IAC IBD D2
HCop3 : Coplanar IAB IAC IBD D1
HCop2 : Coplanar IAB IAC IBD C2
HNCop1 : Coplanar IAB IAC IBD C1
HCol6 : Col D1 D2 IBD
HCol5 : Col B1 B2 IBD
HCol4 : Col C1 C2 IAC
HCol3 : Col A1 A2 IAC
HCol2 : Col B1 B2 IAB
HCol1 : Col A1 A2 IAB
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,IAB,IAC,IBD : Tpoint
bla : bachmann_s_lotschnittaxiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
+++++
destruct (bla IAC IAB IBD P1 R1) as [I [HI1 HI2]]; auto.
-----
Lemma bachmann_s_lotschnittaxiom__weak_inverse_projection_postulate : bachmann_s_lotschnittaxiom -> weak_inverse_projection_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HNCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.
assert (Coplanar IAB IAC IBD B1) by Cop.
assert (Coplanar IAB IAC IBD B2) by Cop.
assert (HNC2 : ~ Col A1 A2 D1).
assert (HNC3 : ~ Col B1 B2 C1).
assert (HParA : Par_strict A1 A2 D1 D2).
apply par_not_col_strict with D1; Col; apply l12_9 with B1 B2; Perp; CopR.
assert (HParB : Par_strict B1 B2 C1 C2).
apply par_not_col_strict with C1; Col; apply l12_9 with A1 A2; Perp; CopR.
assert (HNCol3 : ~ Col IAC B1 B2) by (apply par_not_col with C1 C2; Par; ColR).
assert (HNCol4 : ~ Col IBD A1 A2) by (apply par_not_col with D1 D2; Par; ColR).
assert (HPQ : IAC <> IAB) by (assert_diffs; auto).
assert (HQR : IAB <> IBD) by (assert_diffs; auto).
destruct (diff_col_ex3 C1 C2 IAC) as [P1 [HC1P1 [HC2P1 [HPP1 HCP1]]]]; Col.
destruct (diff_col_ex3 D1 D2 IBD) as [R1 [HD1R1 [HD2R1 [HRR1 HDR1]]]]; Col.
destruct (bla IAC IAB IBD P1 R1) as [I [HI1 HI2]]; auto.

*****
HDR1 : Col D1 D2 R1
HRR1 : not (eq IBD R1)
HD2R1 : not (eq D2 R1)
HD1R1 : not (eq D1 R1)
R1 : Tpoint
HCP1 : Col C1 C2 P1
HPP1 : not (eq IAC P1)
HC2P1 : not (eq C2 P1)
HC1P1 : not (eq C1 P1)
P1 : Tpoint
HQR : not (eq IAB IBD)
HPQ : not (eq IAC IAB)
HNCol4 : not (Col IBD A1 A2)
HNCol3 : not (Col IAC B1 B2)
HParB : Par_strict B1 B2 C1 C2
HParA : Par_strict A1 A2 D1 D2
HNC3 : not (Col B1 B2 C1)
HNC2 : not (Col A1 A2 D1)
H6 : Coplanar IAB IAC IBD B2
H5 : Coplanar IAB IAC IBD B1
H4 : Coplanar IAB IAC IBD A2
H3 : Coplanar IAB IAC IBD A1
H2 : Col IAB IBD B2
H1 : Col IAB IBD B1
H0 : Col IAB IAC A2
H : Col IAB IAC A1
HNC1 : not (Col IAB IAC IBD)
HCop4 : Coplanar IAB IAC IBD D2
HCop3 : Coplanar IAB IAC IBD D1
HCop2 : Coplanar IAB IAC IBD C2
HNCop1 : Coplanar IAB IAC IBD C1
HCol6 : Col D1 D2 IBD
HCol5 : Col B1 B2 IBD
HCol4 : Col C1 C2 IAC
HCol3 : Col A1 A2 IAC
HCol2 : Col B1 B2 IAB
HCol1 : Col A1 A2 IAB
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,IAB,IAC,IBD : Tpoint
bla : bachmann_s_lotschnittaxiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Per IAC IAB IBD
+++++
apply perp_per_2; apply perp_col2 with A1 A2; Col; apply perp_sym; apply perp_col2 with B1 B2; Col; Perp.
-----
Lemma bachmann_s_lotschnittaxiom__weak_inverse_projection_postulate : bachmann_s_lotschnittaxiom -> weak_inverse_projection_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HNCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.
assert (Coplanar IAB IAC IBD B1) by Cop.
assert (Coplanar IAB IAC IBD B2) by Cop.
assert (HNC2 : ~ Col A1 A2 D1).
assert (HNC3 : ~ Col B1 B2 C1).
assert (HParA : Par_strict A1 A2 D1 D2).
apply par_not_col_strict with D1; Col; apply l12_9 with B1 B2; Perp; CopR.
assert (HParB : Par_strict B1 B2 C1 C2).
apply par_not_col_strict with C1; Col; apply l12_9 with A1 A2; Perp; CopR.
assert (HNCol3 : ~ Col IAC B1 B2) by (apply par_not_col with C1 C2; Par; ColR).
assert (HNCol4 : ~ Col IBD A1 A2) by (apply par_not_col with D1 D2; Par; ColR).
assert (HPQ : IAC <> IAB) by (assert_diffs; auto).
assert (HQR : IAB <> IBD) by (assert_diffs; auto).
destruct (diff_col_ex3 C1 C2 IAC) as [P1 [HC1P1 [HC2P1 [HPP1 HCP1]]]]; Col.
destruct (diff_col_ex3 D1 D2 IBD) as [R1 [HD1R1 [HD2R1 [HRR1 HDR1]]]]; Col.
destruct (bla IAC IAB IBD P1 R1) as [I [HI1 HI2]]; auto.
apply perp_per_2; apply perp_col2 with A1 A2; Col; apply perp_sym; apply perp_col2 with B1 B2; Col; Perp.

*****
HDR1 : Col D1 D2 R1
HRR1 : not (eq IBD R1)
HD2R1 : not (eq D2 R1)
HD1R1 : not (eq D1 R1)
R1 : Tpoint
HCP1 : Col C1 C2 P1
HPP1 : not (eq IAC P1)
HC2P1 : not (eq C2 P1)
HC1P1 : not (eq C1 P1)
P1 : Tpoint
HQR : not (eq IAB IBD)
HPQ : not (eq IAC IAB)
HNCol4 : not (Col IBD A1 A2)
HNCol3 : not (Col IAC B1 B2)
HParB : Par_strict B1 B2 C1 C2
HParA : Par_strict A1 A2 D1 D2
HNC3 : not (Col B1 B2 C1)
HNC2 : not (Col A1 A2 D1)
H6 : Coplanar IAB IAC IBD B2
H5 : Coplanar IAB IAC IBD B1
H4 : Coplanar IAB IAC IBD A2
H3 : Coplanar IAB IAC IBD A1
H2 : Col IAB IBD B2
H1 : Col IAB IBD B1
H0 : Col IAB IAC A2
H : Col IAB IAC A1
HNC1 : not (Col IAB IAC IBD)
HCop4 : Coplanar IAB IAC IBD D2
HCop3 : Coplanar IAB IAC IBD D1
HCop2 : Coplanar IAB IAC IBD C2
HNCop1 : Coplanar IAB IAC IBD C1
HCol6 : Col D1 D2 IBD
HCol5 : Col B1 B2 IBD
HCol4 : Col C1 C2 IAC
HCol3 : Col A1 A2 IAC
HCol2 : Col B1 B2 IAB
HCol1 : Col A1 A2 IAB
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,IAB,IAC,IBD : Tpoint
bla : bachmann_s_lotschnittaxiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Per IAB IAC P1
+++++
apply perp_per_2; apply perp_col2 with A1 A2; Col; apply perp_sym; apply perp_col2 with C1 C2; Col; Perp.
-----
Lemma bachmann_s_lotschnittaxiom__weak_inverse_projection_postulate : bachmann_s_lotschnittaxiom -> weak_inverse_projection_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HNCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.
assert (Coplanar IAB IAC IBD B1) by Cop.
assert (Coplanar IAB IAC IBD B2) by Cop.
assert (HNC2 : ~ Col A1 A2 D1).
assert (HNC3 : ~ Col B1 B2 C1).
assert (HParA : Par_strict A1 A2 D1 D2).
apply par_not_col_strict with D1; Col; apply l12_9 with B1 B2; Perp; CopR.
assert (HParB : Par_strict B1 B2 C1 C2).
apply par_not_col_strict with C1; Col; apply l12_9 with A1 A2; Perp; CopR.
assert (HNCol3 : ~ Col IAC B1 B2) by (apply par_not_col with C1 C2; Par; ColR).
assert (HNCol4 : ~ Col IBD A1 A2) by (apply par_not_col with D1 D2; Par; ColR).
assert (HPQ : IAC <> IAB) by (assert_diffs; auto).
assert (HQR : IAB <> IBD) by (assert_diffs; auto).
destruct (diff_col_ex3 C1 C2 IAC) as [P1 [HC1P1 [HC2P1 [HPP1 HCP1]]]]; Col.
destruct (diff_col_ex3 D1 D2 IBD) as [R1 [HD1R1 [HD2R1 [HRR1 HDR1]]]]; Col.
destruct (bla IAC IAB IBD P1 R1) as [I [HI1 HI2]]; auto.
apply perp_per_2; apply perp_col2 with A1 A2; Col; apply perp_sym; apply perp_col2 with B1 B2; Col; Perp.
apply perp_per_2; apply perp_col2 with A1 A2; Col; apply perp_sym; apply perp_col2 with C1 C2; Col; Perp.

*****
HDR1 : Col D1 D2 R1
HRR1 : not (eq IBD R1)
HD2R1 : not (eq D2 R1)
HD1R1 : not (eq D1 R1)
R1 : Tpoint
HCP1 : Col C1 C2 P1
HPP1 : not (eq IAC P1)
HC2P1 : not (eq C2 P1)
HC1P1 : not (eq C1 P1)
P1 : Tpoint
HQR : not (eq IAB IBD)
HPQ : not (eq IAC IAB)
HNCol4 : not (Col IBD A1 A2)
HNCol3 : not (Col IAC B1 B2)
HParB : Par_strict B1 B2 C1 C2
HParA : Par_strict A1 A2 D1 D2
HNC3 : not (Col B1 B2 C1)
HNC2 : not (Col A1 A2 D1)
H6 : Coplanar IAB IAC IBD B2
H5 : Coplanar IAB IAC IBD B1
H4 : Coplanar IAB IAC IBD A2
H3 : Coplanar IAB IAC IBD A1
H2 : Col IAB IBD B2
H1 : Col IAB IBD B1
H0 : Col IAB IAC A2
H : Col IAB IAC A1
HNC1 : not (Col IAB IAC IBD)
HCop4 : Coplanar IAB IAC IBD D2
HCop3 : Coplanar IAB IAC IBD D1
HCop2 : Coplanar IAB IAC IBD C2
HNCop1 : Coplanar IAB IAC IBD C1
HCol6 : Col D1 D2 IBD
HCol5 : Col B1 B2 IBD
HCol4 : Col C1 C2 IAC
HCol3 : Col A1 A2 IAC
HCol2 : Col B1 B2 IAB
HCol1 : Col A1 A2 IAB
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,IAB,IAC,IBD : Tpoint
bla : bachmann_s_lotschnittaxiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Per IAB IBD R1
+++++
apply perp_per_2; apply perp_col2 with B1 B2; Col; apply perp_sym; apply perp_col2 with D1 D2; Col; Perp.
-----
Lemma bachmann_s_lotschnittaxiom__weak_inverse_projection_postulate : bachmann_s_lotschnittaxiom -> weak_inverse_projection_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HNCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.
assert (Coplanar IAB IAC IBD B1) by Cop.
assert (Coplanar IAB IAC IBD B2) by Cop.
assert (HNC2 : ~ Col A1 A2 D1).
assert (HNC3 : ~ Col B1 B2 C1).
assert (HParA : Par_strict A1 A2 D1 D2).
apply par_not_col_strict with D1; Col; apply l12_9 with B1 B2; Perp; CopR.
assert (HParB : Par_strict B1 B2 C1 C2).
apply par_not_col_strict with C1; Col; apply l12_9 with A1 A2; Perp; CopR.
assert (HNCol3 : ~ Col IAC B1 B2) by (apply par_not_col with C1 C2; Par; ColR).
assert (HNCol4 : ~ Col IBD A1 A2) by (apply par_not_col with D1 D2; Par; ColR).
assert (HPQ : IAC <> IAB) by (assert_diffs; auto).
assert (HQR : IAB <> IBD) by (assert_diffs; auto).
destruct (diff_col_ex3 C1 C2 IAC) as [P1 [HC1P1 [HC2P1 [HPP1 HCP1]]]]; Col.
destruct (diff_col_ex3 D1 D2 IBD) as [R1 [HD1R1 [HD2R1 [HRR1 HDR1]]]]; Col.
destruct (bla IAC IAB IBD P1 R1) as [I [HI1 HI2]]; auto.
apply perp_per_2; apply perp_col2 with A1 A2; Col; apply perp_sym; apply perp_col2 with B1 B2; Col; Perp.
apply perp_per_2; apply perp_col2 with A1 A2; Col; apply perp_sym; apply perp_col2 with C1 C2; Col; Perp.
apply perp_per_2; apply perp_col2 with B1 B2; Col; apply perp_sym; apply perp_col2 with D1 D2; Col; Perp.

*****
HDR1 : Col D1 D2 R1
HRR1 : not (eq IBD R1)
HD2R1 : not (eq D2 R1)
HD1R1 : not (eq D1 R1)
R1 : Tpoint
HCP1 : Col C1 C2 P1
HPP1 : not (eq IAC P1)
HC2P1 : not (eq C2 P1)
HC1P1 : not (eq C1 P1)
P1 : Tpoint
HQR : not (eq IAB IBD)
HPQ : not (eq IAC IAB)
HNCol4 : not (Col IBD A1 A2)
HNCol3 : not (Col IAC B1 B2)
HParB : Par_strict B1 B2 C1 C2
HParA : Par_strict A1 A2 D1 D2
HNC3 : not (Col B1 B2 C1)
HNC2 : not (Col A1 A2 D1)
H6 : Coplanar IAB IAC IBD B2
H5 : Coplanar IAB IAC IBD B1
H4 : Coplanar IAB IAC IBD A2
H3 : Coplanar IAB IAC IBD A1
H2 : Col IAB IBD B2
H1 : Col IAB IBD B1
H0 : Col IAB IAC A2
H : Col IAB IAC A1
HNC1 : not (Col IAB IAC IBD)
HCop4 : Coplanar IAB IAC IBD D2
HCop3 : Coplanar IAB IAC IBD D1
HCop2 : Coplanar IAB IAC IBD C2
HNCop1 : Coplanar IAB IAC IBD C1
HCol6 : Col D1 D2 IBD
HCol5 : Col B1 B2 IBD
HCol4 : Col C1 C2 IAC
HCol3 : Col A1 A2 IAC
HCol2 : Col B1 B2 IAB
HCol1 : Col A1 A2 IAB
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,IAB,IAC,IBD : Tpoint
bla : bachmann_s_lotschnittaxiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar IAC IAB IBD P1
+++++
assert_diffs; apply col_cop2__cop with C1 C2; Col; CopR.
-----
Lemma bachmann_s_lotschnittaxiom__weak_inverse_projection_postulate : bachmann_s_lotschnittaxiom -> weak_inverse_projection_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HNCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.
assert (Coplanar IAB IAC IBD B1) by Cop.
assert (Coplanar IAB IAC IBD B2) by Cop.
assert (HNC2 : ~ Col A1 A2 D1).
assert (HNC3 : ~ Col B1 B2 C1).
assert (HParA : Par_strict A1 A2 D1 D2).
apply par_not_col_strict with D1; Col; apply l12_9 with B1 B2; Perp; CopR.
assert (HParB : Par_strict B1 B2 C1 C2).
apply par_not_col_strict with C1; Col; apply l12_9 with A1 A2; Perp; CopR.
assert (HNCol3 : ~ Col IAC B1 B2) by (apply par_not_col with C1 C2; Par; ColR).
assert (HNCol4 : ~ Col IBD A1 A2) by (apply par_not_col with D1 D2; Par; ColR).
assert (HPQ : IAC <> IAB) by (assert_diffs; auto).
assert (HQR : IAB <> IBD) by (assert_diffs; auto).
destruct (diff_col_ex3 C1 C2 IAC) as [P1 [HC1P1 [HC2P1 [HPP1 HCP1]]]]; Col.
destruct (diff_col_ex3 D1 D2 IBD) as [R1 [HD1R1 [HD2R1 [HRR1 HDR1]]]]; Col.
destruct (bla IAC IAB IBD P1 R1) as [I [HI1 HI2]]; auto.
apply perp_per_2; apply perp_col2 with A1 A2; Col; apply perp_sym; apply perp_col2 with B1 B2; Col; Perp.
apply perp_per_2; apply perp_col2 with A1 A2; Col; apply perp_sym; apply perp_col2 with C1 C2; Col; Perp.
apply perp_per_2; apply perp_col2 with B1 B2; Col; apply perp_sym; apply perp_col2 with D1 D2; Col; Perp.
assert_diffs; apply col_cop2__cop with C1 C2; Col; CopR.

*****
HDR1 : Col D1 D2 R1
HRR1 : not (eq IBD R1)
HD2R1 : not (eq D2 R1)
HD1R1 : not (eq D1 R1)
R1 : Tpoint
HCP1 : Col C1 C2 P1
HPP1 : not (eq IAC P1)
HC2P1 : not (eq C2 P1)
HC1P1 : not (eq C1 P1)
P1 : Tpoint
HQR : not (eq IAB IBD)
HPQ : not (eq IAC IAB)
HNCol4 : not (Col IBD A1 A2)
HNCol3 : not (Col IAC B1 B2)
HParB : Par_strict B1 B2 C1 C2
HParA : Par_strict A1 A2 D1 D2
HNC3 : not (Col B1 B2 C1)
HNC2 : not (Col A1 A2 D1)
H6 : Coplanar IAB IAC IBD B2
H5 : Coplanar IAB IAC IBD B1
H4 : Coplanar IAB IAC IBD A2
H3 : Coplanar IAB IAC IBD A1
H2 : Col IAB IBD B2
H1 : Col IAB IBD B1
H0 : Col IAB IAC A2
H : Col IAB IAC A1
HNC1 : not (Col IAB IAC IBD)
HCop4 : Coplanar IAB IAC IBD D2
HCop3 : Coplanar IAB IAC IBD D1
HCop2 : Coplanar IAB IAC IBD C2
HNCop1 : Coplanar IAB IAC IBD C1
HCol6 : Col D1 D2 IBD
HCol5 : Col B1 B2 IBD
HCol4 : Col C1 C2 IAC
HCol3 : Col A1 A2 IAC
HCol2 : Col B1 B2 IAB
HCol1 : Col A1 A2 IAB
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,IAB,IAC,IBD : Tpoint
bla : bachmann_s_lotschnittaxiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar IAC IAB IBD R1
+++++
assert_diffs; apply col_cop2__cop with D1 D2; Col; CopR.
-----
Lemma bachmann_s_lotschnittaxiom__weak_inverse_projection_postulate : bachmann_s_lotschnittaxiom -> weak_inverse_projection_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HNCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.
assert (Coplanar IAB IAC IBD B1) by Cop.
assert (Coplanar IAB IAC IBD B2) by Cop.
assert (HNC2 : ~ Col A1 A2 D1).
assert (HNC3 : ~ Col B1 B2 C1).
assert (HParA : Par_strict A1 A2 D1 D2).
apply par_not_col_strict with D1; Col; apply l12_9 with B1 B2; Perp; CopR.
assert (HParB : Par_strict B1 B2 C1 C2).
apply par_not_col_strict with C1; Col; apply l12_9 with A1 A2; Perp; CopR.
assert (HNCol3 : ~ Col IAC B1 B2) by (apply par_not_col with C1 C2; Par; ColR).
assert (HNCol4 : ~ Col IBD A1 A2) by (apply par_not_col with D1 D2; Par; ColR).
assert (HPQ : IAC <> IAB) by (assert_diffs; auto).
assert (HQR : IAB <> IBD) by (assert_diffs; auto).
destruct (diff_col_ex3 C1 C2 IAC) as [P1 [HC1P1 [HC2P1 [HPP1 HCP1]]]]; Col.
destruct (diff_col_ex3 D1 D2 IBD) as [R1 [HD1R1 [HD2R1 [HRR1 HDR1]]]]; Col.
destruct (bla IAC IAB IBD P1 R1) as [I [HI1 HI2]]; auto.
apply perp_per_2; apply perp_col2 with A1 A2; Col; apply perp_sym; apply perp_col2 with B1 B2; Col; Perp.
apply perp_per_2; apply perp_col2 with A1 A2; Col; apply perp_sym; apply perp_col2 with C1 C2; Col; Perp.
apply perp_per_2; apply perp_col2 with B1 B2; Col; apply perp_sym; apply perp_col2 with D1 D2; Col; Perp.
assert_diffs; apply col_cop2__cop with C1 C2; Col; CopR.
assert_diffs; apply col_cop2__cop with D1 D2; Col; CopR.

*****
HI2 : Col IBD R1 I
HI1 : Col IAC P1 I
I : Tpoint
HDR1 : Col D1 D2 R1
HRR1 : not (eq IBD R1)
HD2R1 : not (eq D2 R1)
HD1R1 : not (eq D1 R1)
R1 : Tpoint
HCP1 : Col C1 C2 P1
HPP1 : not (eq IAC P1)
HC2P1 : not (eq C2 P1)
HC1P1 : not (eq C1 P1)
P1 : Tpoint
HQR : not (eq IAB IBD)
HPQ : not (eq IAC IAB)
HNCol4 : not (Col IBD A1 A2)
HNCol3 : not (Col IAC B1 B2)
HParB : Par_strict B1 B2 C1 C2
HParA : Par_strict A1 A2 D1 D2
HNC3 : not (Col B1 B2 C1)
HNC2 : not (Col A1 A2 D1)
H6 : Coplanar IAB IAC IBD B2
H5 : Coplanar IAB IAC IBD B1
H4 : Coplanar IAB IAC IBD A2
H3 : Coplanar IAB IAC IBD A1
H2 : Col IAB IBD B2
H1 : Col IAB IBD B1
H0 : Col IAB IAC A2
H : Col IAB IAC A1
HNC1 : not (Col IAB IAC IBD)
HCop4 : Coplanar IAB IAC IBD D2
HCop3 : Coplanar IAB IAC IBD D1
HCop2 : Coplanar IAB IAC IBD C2
HNCop1 : Coplanar IAB IAC IBD C1
HCol6 : Col D1 D2 IBD
HCol5 : Col B1 B2 IBD
HCol4 : Col C1 C2 IAC
HCol3 : Col A1 A2 IAC
HCol2 : Col B1 B2 IAB
HCol1 : Col A1 A2 IAB
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,IAB,IAC,IBD : Tpoint
bla : bachmann_s_lotschnittaxiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
+++++
exists I.
-----
Lemma bachmann_s_lotschnittaxiom__weak_inverse_projection_postulate : bachmann_s_lotschnittaxiom -> weak_inverse_projection_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HNCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.
assert (Coplanar IAB IAC IBD B1) by Cop.
assert (Coplanar IAB IAC IBD B2) by Cop.
assert (HNC2 : ~ Col A1 A2 D1).
assert (HNC3 : ~ Col B1 B2 C1).
assert (HParA : Par_strict A1 A2 D1 D2).
apply par_not_col_strict with D1; Col; apply l12_9 with B1 B2; Perp; CopR.
assert (HParB : Par_strict B1 B2 C1 C2).
apply par_not_col_strict with C1; Col; apply l12_9 with A1 A2; Perp; CopR.
assert (HNCol3 : ~ Col IAC B1 B2) by (apply par_not_col with C1 C2; Par; ColR).
assert (HNCol4 : ~ Col IBD A1 A2) by (apply par_not_col with D1 D2; Par; ColR).
assert (HPQ : IAC <> IAB) by (assert_diffs; auto).
assert (HQR : IAB <> IBD) by (assert_diffs; auto).
destruct (diff_col_ex3 C1 C2 IAC) as [P1 [HC1P1 [HC2P1 [HPP1 HCP1]]]]; Col.
destruct (diff_col_ex3 D1 D2 IBD) as [R1 [HD1R1 [HD2R1 [HRR1 HDR1]]]]; Col.
destruct (bla IAC IAB IBD P1 R1) as [I [HI1 HI2]]; auto.
apply perp_per_2; apply perp_col2 with A1 A2; Col; apply perp_sym; apply perp_col2 with B1 B2; Col; Perp.
apply perp_per_2; apply perp_col2 with A1 A2; Col; apply perp_sym; apply perp_col2 with C1 C2; Col; Perp.
apply perp_per_2; apply perp_col2 with B1 B2; Col; apply perp_sym; apply perp_col2 with D1 D2; Col; Perp.
assert_diffs; apply col_cop2__cop with C1 C2; Col; CopR.
assert_diffs; apply col_cop2__cop with D1 D2; Col; CopR.
exists I.

*****
HI2 : Col IBD R1 I
HI1 : Col IAC P1 I
I : Tpoint
HDR1 : Col D1 D2 R1
HRR1 : not (eq IBD R1)
HD2R1 : not (eq D2 R1)
HD1R1 : not (eq D1 R1)
R1 : Tpoint
HCP1 : Col C1 C2 P1
HPP1 : not (eq IAC P1)
HC2P1 : not (eq C2 P1)
HC1P1 : not (eq C1 P1)
P1 : Tpoint
HQR : not (eq IAB IBD)
HPQ : not (eq IAC IAB)
HNCol4 : not (Col IBD A1 A2)
HNCol3 : not (Col IAC B1 B2)
HParB : Par_strict B1 B2 C1 C2
HParA : Par_strict A1 A2 D1 D2
HNC3 : not (Col B1 B2 C1)
HNC2 : not (Col A1 A2 D1)
H6 : Coplanar IAB IAC IBD B2
H5 : Coplanar IAB IAC IBD B1
H4 : Coplanar IAB IAC IBD A2
H3 : Coplanar IAB IAC IBD A1
H2 : Col IAB IBD B2
H1 : Col IAB IBD B1
H0 : Col IAB IAC A2
H : Col IAB IAC A1
HNC1 : not (Col IAB IAC IBD)
HCop4 : Coplanar IAB IAC IBD D2
HCop3 : Coplanar IAB IAC IBD D1
HCop2 : Coplanar IAB IAC IBD C2
HNCop1 : Coplanar IAB IAC IBD C1
HCol6 : Col D1 D2 IBD
HCol5 : Col B1 B2 IBD
HCol4 : Col C1 C2 IAC
HCol3 : Col A1 A2 IAC
HCol2 : Col B1 B2 IAB
HCol1 : Col A1 A2 IAB
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,IAB,IAC,IBD : Tpoint
bla : bachmann_s_lotschnittaxiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Col C1 C2 I) (Col D1 D2 I)
+++++
split; assert_diffs; ColR.
-----
Lemma bachmann_s_lotschnittaxiom__weak_inverse_projection_postulate : bachmann_s_lotschnittaxiom -> weak_inverse_projection_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).

*****

*****

+++++
Qed.
-----
End bachmann_s_lotschnittaxiom_weak_inverse_projection_postulate.
-----
