Require Import GeoCoq.Axioms.tarski_axioms.
-----
Require Import GeoCoq.Elements.OriginalProofs.proposition_01.
-----
Require Import GeoCoq.Elements.OriginalProofs.lemma_congruenceflip.
-----
Require Import GeoCoq.Elements.OriginalProofs.lemma_extension.
-----
From Coq Require Import Classical.
-----
Section Euclid_to_Tarski.
-----
Context `{Ax:euclidean_neutral_ruler_compass}.
-----
Definition Bet A B C := BetS A B C \/ A=B \/ B=C.
-----
Lemma Bet_sym : forall A B C,\n  Bet A B C -> Bet C B A.
-----
Lemma Bet_sym : forall A B C, Bet A B C -> Bet C B A.

*****
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
forall (A B C : Point) (_ : Bet A B C), Bet C B A
+++++
Proof.
-----
Lemma Bet_sym : forall A B C, Bet A B C -> Bet C B A.
Proof.

*****
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
forall (A B C : Point) (_ : Bet A B C), Bet C B A
+++++
intros.
-----
Lemma Bet_sym : forall A B C, Bet A B C -> Bet C B A.
Proof.
intros.

*****
H : Bet A B C
A,B,C : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
Bet C B A
+++++
unfold Bet in *.
-----
Lemma Bet_sym : forall A B C, Bet A B C -> Bet C B A.
Proof.
intros.
unfold Bet in *.

*****
H : or (BetS A B C) (or (Logic.eq A B) (Logic.eq B C))
A,B,C : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
or (BetS C B A) (or (Logic.eq C B) (Logic.eq B A))
+++++
decompose [or] H.
-----
Lemma Bet_sym : forall A B C, Bet A B C -> Bet C B A.
Proof.
intros.
unfold Bet in *.
decompose [or] H.

*****
H0 : BetS A B C
H : or (BetS A B C) (or (Logic.eq A B) (Logic.eq B C))
A,B,C : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
or (BetS C B A) (or (Logic.eq C B) (Logic.eq B A))
+++++
left.
-----
Lemma Bet_sym : forall A B C, Bet A B C -> Bet C B A.
Proof.
intros.
unfold Bet in *.
decompose [or] H.
left.

*****
H0 : BetS A B C
H : or (BetS A B C) (or (Logic.eq A B) (Logic.eq B C))
A,B,C : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
BetS C B A
+++++
eauto using axiom_betweennesssymmetry.
-----
Lemma Bet_sym : forall A B C, Bet A B C -> Bet C B A.
Proof.
intros.
unfold Bet in *.
decompose [or] H.

*****
H1 : Logic.eq A B
H : or (BetS A B C) (or (Logic.eq A B) (Logic.eq B C))
A,B,C : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
or (BetS C B A) (or (Logic.eq C B) (Logic.eq B A))
+++++
right.
-----
Lemma Bet_sym : forall A B C, Bet A B C -> Bet C B A.
Proof.
intros.
unfold Bet in *.
decompose [or] H.
right.

*****
H1 : Logic.eq A B
H : or (BetS A B C) (or (Logic.eq A B) (Logic.eq B C))
A,B,C : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
or (Logic.eq C B) (Logic.eq B A)
+++++
right.
-----
Lemma Bet_sym : forall A B C, Bet A B C -> Bet C B A.
Proof.
intros.
unfold Bet in *.
decompose [or] H.
right.
right.

*****
H1 : Logic.eq A B
H : or (BetS A B C) (or (Logic.eq A B) (Logic.eq B C))
A,B,C : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
Logic.eq B A
+++++
auto.
-----
Lemma Bet_sym : forall A B C, Bet A B C -> Bet C B A.
Proof.
intros.
unfold Bet in *.
decompose [or] H.

*****
H1 : Logic.eq B C
H : or (BetS A B C) (or (Logic.eq A B) (Logic.eq B C))
A,B,C : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
or (BetS C B A) (or (Logic.eq C B) (Logic.eq B A))
+++++
right.
-----
Lemma Bet_sym : forall A B C, Bet A B C -> Bet C B A.
Proof.
intros.
unfold Bet in *.
decompose [or] H.
right.

*****
H1 : Logic.eq B C
H : or (BetS A B C) (or (Logic.eq A B) (Logic.eq B C))
A,B,C : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
or (Logic.eq C B) (Logic.eq B A)
+++++
left.
-----
Lemma Bet_sym : forall A B C, Bet A B C -> Bet C B A.
Proof.
intros.
unfold Bet in *.
decompose [or] H.
right.
left.

*****
H1 : Logic.eq B C
H : or (BetS A B C) (or (Logic.eq A B) (Logic.eq B C))
A,B,C : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
Logic.eq C B
+++++
auto.
-----
Lemma Bet_sym : forall A B C, Bet A B C -> Bet C B A.
Proof.
intros.
unfold Bet in *.
decompose [or] H.

*****

*****

+++++
Qed.
-----
Definition TCong A B C D := Cong A B C D \/ (A=B /\ C=D).
-----
Lemma cong_sym : forall A B C D, Cong A B C D -> Cong C D A B.
-----
Lemma cong_sym : forall A B C D, Cong A B C D -> Cong C D A B.

*****
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
forall (A B C D : Point) (_ : Cong A B C D), Cong C D A B
+++++
Proof.
-----
Lemma cong_sym : forall A B C D, Cong A B C D -> Cong C D A B.
Proof.

*****
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
forall (A B C D : Point) (_ : Cong A B C D), Cong C D A B
+++++
intros.
-----
Lemma cong_sym : forall A B C D, Cong A B C D -> Cong C D A B.
Proof.
intros.

*****
H : Cong A B C D
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
Cong C D A B
+++++
apply (cn_congruencetransitive C D A B A B).
-----
Lemma cong_sym : forall A B C D, Cong A B C D -> Cong C D A B.
Proof.
intros.
apply (cn_congruencetransitive C D A B A B).

*****
H : Cong A B C D
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
Cong A B C D
+++++
assumption.
-----
Lemma cong_sym : forall A B C D, Cong A B C D -> Cong C D A B.
Proof.
intros.
apply (cn_congruencetransitive C D A B A B).

*****
H : Cong A B C D
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
Cong A B A B
+++++
apply (cn_congruencereflexive).
-----
Lemma cong_sym : forall A B C D, Cong A B C D -> Cong C D A B.
Proof.
intros.
apply (cn_congruencetransitive C D A B A B).

*****

*****

+++++
Qed.
-----
Lemma cong_eq : forall A B C, Cong B C A A -> B=C.
-----
Lemma cong_eq : forall A B C, Cong B C A A -> B=C.

*****
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
forall (A B C : Point) (_ : Cong B C A A), Logic.eq B C
+++++
Proof.
-----
Lemma cong_eq : forall A B C, Cong B C A A -> B=C.
Proof.

*****
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
forall (A B C : Point) (_ : Cong B C A A), Logic.eq B C
+++++
intros.
-----
Lemma cong_eq : forall A B C, Cong B C A A -> B=C.
Proof.
intros.

*****
H : Cong B C A A
A,B,C : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
Logic.eq B C
+++++
destruct (classic (B=C)).
-----
Lemma cong_eq : forall A B C, Cong B C A A -> B=C.
Proof.
intros.
destruct (classic (B=C)).

*****
H0 : Logic.eq B C
H : Cong B C A A
A,B,C : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
Logic.eq B C
+++++
assumption.
-----
Lemma cong_eq : forall A B C, Cong B C A A -> B=C.
Proof.
intros.
destruct (classic (B=C)).

*****
H0 : not (Logic.eq B C)
H : Cong B C A A
A,B,C : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
Logic.eq B C
+++++
assert (A<>A).
-----
Lemma cong_eq : forall A B C, Cong B C A A -> B=C.
Proof.
intros.
destruct (classic (B=C)).
assert (A<>A).

*****
H0 : not (Logic.eq B C)
H : Cong B C A A
A,B,C : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
not (Logic.eq A A)
+++++
apply axiom_nocollapse with B C.
-----
Lemma cong_eq : forall A B C, Cong B C A A -> B=C.
Proof.
intros.
destruct (classic (B=C)).
assert (A<>A).
apply axiom_nocollapse with B C.

*****
H0 : not (Logic.eq B C)
H : Cong B C A A
A,B,C : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
neq B C
+++++
auto.
-----
Lemma cong_eq : forall A B C, Cong B C A A -> B=C.
Proof.
intros.
destruct (classic (B=C)).
assert (A<>A).
apply axiom_nocollapse with B C.

*****
H0 : not (Logic.eq B C)
H : Cong B C A A
A,B,C : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
Cong B C A A
+++++
auto.
-----
Lemma cong_eq : forall A B C, Cong B C A A -> B=C.
Proof.
intros.
destruct (classic (B=C)).
assert (A<>A).

*****
H1 : not (Logic.eq A A)
H0 : not (Logic.eq B C)
H : Cong B C A A
A,B,C : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
Logic.eq B C
+++++
intuition.
-----
Lemma cong_eq : forall A B C, Cong B C A A -> B=C.
Proof.
intros.
destruct (classic (B=C)).

*****

*****

+++++
Qed.
-----
Lemma nullsegment2 : forall A B, TCong A A B B.
-----
Lemma nullsegment2 : forall A B, TCong A A B B.

*****
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
forall A B : Point, TCong A A B B
+++++
Proof.
-----
Lemma nullsegment2 : forall A B, TCong A A B B.
Proof.

*****
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
forall A B : Point, TCong A A B B
+++++
intros.
-----
Lemma nullsegment2 : forall A B, TCong A A B B.
Proof.
intros.

*****
A,B : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
TCong A A B B
+++++
unfold TCong.
-----
Lemma nullsegment2 : forall A B, TCong A A B B.
Proof.
intros.
unfold TCong.

*****
A,B : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
or (Cong A A B B) (and (Logic.eq A A) (Logic.eq B B))
+++++
auto.
-----
Lemma nullsegment2 : forall A B, TCong A A B B.
Proof.
intros.
unfold TCong.
auto.

*****

*****

+++++
Qed.
-----
Lemma Tcong_reflexive: forall A B, TCong A B A B.
-----
Lemma Tcong_reflexive: forall A B, TCong A B A B.

*****
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
forall A B : Point, TCong A B A B
+++++
Proof.
-----
Lemma Tcong_reflexive: forall A B, TCong A B A B.
Proof.

*****
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
forall A B : Point, TCong A B A B
+++++
intros.
-----
Lemma Tcong_reflexive: forall A B, TCong A B A B.
Proof.
intros.

*****
A,B : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
TCong A B A B
+++++
unfold TCong.
-----
Lemma Tcong_reflexive: forall A B, TCong A B A B.
Proof.
intros.
unfold TCong.

*****
A,B : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
or (Cong A B A B) (and (Logic.eq A B) (Logic.eq A B))
+++++
left.
-----
Lemma Tcong_reflexive: forall A B, TCong A B A B.
Proof.
intros.
unfold TCong.
left.

*****
A,B : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
Cong A B A B
+++++
apply cn_congruencereflexive.
-----
Lemma Tcong_reflexive: forall A B, TCong A B A B.
Proof.
intros.
unfold TCong.
left.
apply cn_congruencereflexive.

*****

*****

+++++
Qed.
-----
Lemma Tcong_symmetric: forall A B C D, TCong A B C D -> TCong C D A B.
-----
Lemma Tcong_symmetric: forall A B C D, TCong A B C D -> TCong C D A B.

*****
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
forall (A B C D : Point) (_ : TCong A B C D), TCong C D A B
+++++
Proof.
-----
Lemma Tcong_symmetric: forall A B C D, TCong A B C D -> TCong C D A B.
Proof.

*****
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
forall (A B C D : Point) (_ : TCong A B C D), TCong C D A B
+++++
intros.
-----
Lemma Tcong_symmetric: forall A B C D, TCong A B C D -> TCong C D A B.
Proof.
intros.

*****
H : TCong A B C D
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
TCong C D A B
+++++
unfold TCong in *.
-----
Lemma Tcong_symmetric: forall A B C D, TCong A B C D -> TCong C D A B.
Proof.
intros.
unfold TCong in *.

*****
H : or (Cong A B C D) (and (Logic.eq A B) (Logic.eq C D))
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
or (Cong C D A B) (and (Logic.eq C D) (Logic.eq A B))
+++++
destruct H.
-----
Lemma Tcong_symmetric: forall A B C D, TCong A B C D -> TCong C D A B.
Proof.
intros.
unfold TCong in *.
destruct H.

*****
H : Cong A B C D
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
or (Cong C D A B) (and (Logic.eq C D) (Logic.eq A B))
+++++
left.
-----
Lemma Tcong_symmetric: forall A B C D, TCong A B C D -> TCong C D A B.
Proof.
intros.
unfold TCong in *.
destruct H.
left.

*****
H : Cong A B C D
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
Cong C D A B
+++++
apply cong_sym.
-----
Lemma Tcong_symmetric: forall A B C D, TCong A B C D -> TCong C D A B.
Proof.
intros.
unfold TCong in *.
destruct H.
left.
apply cong_sym.

*****
H : Cong A B C D
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
Cong A B C D
+++++
assumption.
-----
Lemma Tcong_symmetric: forall A B C D, TCong A B C D -> TCong C D A B.
Proof.
intros.
unfold TCong in *.
destruct H.

*****
H : and (Logic.eq A B) (Logic.eq C D)
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
or (Cong C D A B) (and (Logic.eq C D) (Logic.eq A B))
+++++
right.
-----
Lemma Tcong_symmetric: forall A B C D, TCong A B C D -> TCong C D A B.
Proof.
intros.
unfold TCong in *.
destruct H.
right.

*****
H : and (Logic.eq A B) (Logic.eq C D)
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
and (Logic.eq C D) (Logic.eq A B)
+++++
intuition.
-----
Lemma Tcong_symmetric: forall A B C D, TCong A B C D -> TCong C D A B.
Proof.
intros.
unfold TCong in *.
destruct H.

*****

*****

+++++
Qed.
-----
Lemma nullsegment1 : forall A B C, TCong A A B C -> B=C.
-----
Lemma nullsegment1 : forall A B C, TCong A A B C -> B=C.

*****
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
forall (A B C : Point) (_ : TCong A A B C), Logic.eq B C
+++++
Proof.
-----
Lemma nullsegment1 : forall A B C, TCong A A B C -> B=C.
Proof.

*****
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
forall (A B C : Point) (_ : TCong A A B C), Logic.eq B C
+++++
intros.
-----
Lemma nullsegment1 : forall A B C, TCong A A B C -> B=C.
Proof.
intros.

*****
H : TCong A A B C
A,B,C : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
Logic.eq B C
+++++
unfold TCong in *.
-----
Lemma nullsegment1 : forall A B C, TCong A A B C -> B=C.
Proof.
intros.
unfold TCong in *.

*****
H : or (Cong A A B C) (and (Logic.eq A A) (Logic.eq B C))
A,B,C : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
Logic.eq B C
+++++
destruct H.
-----
Lemma nullsegment1 : forall A B C, TCong A A B C -> B=C.
Proof.
intros.
unfold TCong in *.
destruct H.

*****
H : Cong A A B C
A,B,C : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
Logic.eq B C
+++++
apply cong_sym in H.
-----
Lemma nullsegment1 : forall A B C, TCong A A B C -> B=C.
Proof.
intros.
unfold TCong in *.
destruct H.
apply cong_sym in H.

*****
H : Cong B C A A
A,B,C : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
Logic.eq B C
+++++
apply cong_eq in H.
-----
Lemma nullsegment1 : forall A B C, TCong A A B C -> B=C.
Proof.
intros.
unfold TCong in *.
destruct H.
apply cong_sym in H.
apply cong_eq in H.

*****
H : Logic.eq B C
A,B,C : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
Logic.eq B C
+++++
assumption.
-----
Lemma nullsegment1 : forall A B C, TCong A A B C -> B=C.
Proof.
intros.
unfold TCong in *.
destruct H.

*****
H : and (Logic.eq A A) (Logic.eq B C)
A,B,C : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
Logic.eq B C
+++++
intuition.
-----
Lemma nullsegment1 : forall A B C, TCong A A B C -> B=C.
Proof.
intros.
unfold TCong in *.
destruct H.

*****

*****

+++++
Qed.
-----
Lemma TCong_neq_Cong : forall A B C D, A<>B -> TCong A B C D -> Cong A B C D.
-----
Lemma TCong_neq_Cong : forall A B C D, A<>B -> TCong A B C D -> Cong A B C D.

*****
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
forall (A B C D : Point) (_ : not (Logic.eq A B)) (_ : TCong A B C D), Cong A B C D
+++++
Proof.
-----
Lemma TCong_neq_Cong : forall A B C D, A<>B -> TCong A B C D -> Cong A B C D.
Proof.

*****
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
forall (A B C D : Point) (_ : not (Logic.eq A B)) (_ : TCong A B C D), Cong A B C D
+++++
intros.
-----
Lemma TCong_neq_Cong : forall A B C D, A<>B -> TCong A B C D -> Cong A B C D.
Proof.
intros.

*****
H0 : TCong A B C D
H : not (Logic.eq A B)
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
Cong A B C D
+++++
destruct H0.
-----
Lemma TCong_neq_Cong : forall A B C D, A<>B -> TCong A B C D -> Cong A B C D.
Proof.
intros.
destruct H0.

*****
H0 : Cong A B C D
H : not (Logic.eq A B)
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
Cong A B C D
+++++
assumption.
-----
Lemma TCong_neq_Cong : forall A B C D, A<>B -> TCong A B C D -> Cong A B C D.
Proof.
intros.
destruct H0.

*****
H0 : and (Logic.eq A B) (Logic.eq C D)
H : not (Logic.eq A B)
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
Cong A B C D
+++++
intuition.
-----
Lemma TCong_neq_Cong : forall A B C D, A<>B -> TCong A B C D -> Cong A B C D.
Proof.
intros.
destruct H0.

*****

*****

+++++
Qed.
-----
Lemma lemma_congruenceflip : \n   forall A B C D, \n   Cong A B C D ->\n   Cong B A D C.
-----
Lemma lemma_congruenceflip : forall A B C D, Cong A B C D -> Cong B A D C.

*****
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
forall (A B C D : Point) (_ : Cong A B C D), Cong B A D C
+++++
Proof.
-----
Lemma lemma_congruenceflip : forall A B C D, Cong A B C D -> Cong B A D C.
Proof.

*****
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
forall (A B C D : Point) (_ : Cong A B C D), Cong B A D C
+++++
intros.
-----
Lemma lemma_congruenceflip : forall A B C D, Cong A B C D -> Cong B A D C.
Proof.
intros.

*****
H : Cong A B C D
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
Cong B A D C
+++++
assert (Cong B A A B).
-----
Lemma lemma_congruenceflip : forall A B C D, Cong A B C D -> Cong B A D C.
Proof.
intros.
assert (Cong B A A B).

*****
H : Cong A B C D
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
Cong B A A B
+++++
auto using cn_equalityreverse.
-----
Lemma lemma_congruenceflip : forall A B C D, Cong A B C D -> Cong B A D C.
Proof.
intros.
assert (Cong B A A B).

*****
H0 : Cong B A A B
H : Cong A B C D
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
Cong B A D C
+++++
idtac.
-----
Lemma lemma_congruenceflip : forall A B C D, Cong A B C D -> Cong B A D C.
Proof.
intros.
assert (Cong B A A B).
idtac.

*****
H0 : Cong B A A B
H : Cong A B C D
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
Cong B A D C
+++++
assert (Cong C D D C).
-----
Lemma lemma_congruenceflip : forall A B C D, Cong A B C D -> Cong B A D C.
Proof.
intros.
assert (Cong B A A B).
idtac.
assert (Cong C D D C).

*****
H0 : Cong B A A B
H : Cong A B C D
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
Cong C D D C
+++++
auto using cn_equalityreverse.
-----
Lemma lemma_congruenceflip : forall A B C D, Cong A B C D -> Cong B A D C.
Proof.
intros.
assert (Cong B A A B).
idtac.
assert (Cong C D D C).

*****
H1 : Cong C D D C
H0 : Cong B A A B
H : Cong A B C D
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
Cong B A D C
+++++
idtac.
-----
Lemma lemma_congruenceflip : forall A B C D, Cong A B C D -> Cong B A D C.
Proof.
intros.
assert (Cong B A A B).
idtac.
assert (Cong C D D C).
idtac.

*****
H1 : Cong C D D C
H0 : Cong B A A B
H : Cong A B C D
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
Cong B A D C
+++++
assert (Cong B A C D).
-----
Lemma lemma_congruenceflip : forall A B C D, Cong A B C D -> Cong B A D C.
Proof.
intros.
assert (Cong B A A B).
idtac.
assert (Cong C D D C).
idtac.
assert (Cong B A C D).

*****
H1 : Cong C D D C
H0 : Cong B A A B
H : Cong A B C D
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
Cong B A C D
+++++
conclude lemma_congruencetransitive.
-----
Lemma lemma_congruenceflip : forall A B C D, Cong A B C D -> Cong B A D C.
Proof.
intros.
assert (Cong B A A B).
idtac.
assert (Cong C D D C).
idtac.
assert (Cong B A C D).

*****
H2 : Cong B A C D
H1 : Cong C D D C
H0 : Cong B A A B
H : Cong A B C D
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
Cong B A D C
+++++
idtac.
-----
Lemma lemma_congruenceflip : forall A B C D, Cong A B C D -> Cong B A D C.
Proof.
intros.
assert (Cong B A A B).
idtac.
assert (Cong C D D C).
idtac.
assert (Cong B A C D).
idtac.

*****
H2 : Cong B A C D
H1 : Cong C D D C
H0 : Cong B A A B
H : Cong A B C D
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
Cong B A D C
+++++
conclude lemma_congruencetransitive.
-----
Lemma lemma_congruenceflip : forall A B C D, Cong A B C D -> Cong B A D C.
Proof.
intros.
assert (Cong B A A B).

*****

*****

+++++
Qed.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.

*****
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
Tarski_neutral_dimensionless
+++++
Proof.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.

*****
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
Tarski_neutral_dimensionless
+++++
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).

*****
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
forall A B : Point, TCong A B B A
+++++
intros.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.

*****
A,B : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
TCong A B B A
+++++
unfold TCong.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
unfold TCong.

*****
A,B : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
or (Cong A B B A) (and (Logic.eq A B) (Logic.eq B A))
+++++
left.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
unfold TCong.
left.

*****
A,B : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
Cong A B B A
+++++
apply cn_equalityreverse.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).

*****
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
forall (A B C D E F : Point) (_ : TCong A B C D) (_ : TCong A B E F), TCong C D E F
+++++
intros.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.

*****
H0 : TCong A B E F
H : TCong A B C D
A,B,C,D,E,F : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
TCong C D E F
+++++
unfold TCong in *.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
unfold TCong in *.

*****
H0 : or (Cong A B E F) (and (Logic.eq A B) (Logic.eq E F))
H : or (Cong A B C D) (and (Logic.eq A B) (Logic.eq C D))
A,B,C,D,E,F : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
or (Cong C D E F) (and (Logic.eq C D) (Logic.eq E F))
+++++
destruct H.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
unfold TCong in *.
destruct H.

*****
H0 : or (Cong A B E F) (and (Logic.eq A B) (Logic.eq E F))
H : Cong A B C D
A,B,C,D,E,F : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
or (Cong C D E F) (and (Logic.eq C D) (Logic.eq E F))
+++++
destruct H0.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
unfold TCong in *.
destruct H.
destruct H0.

*****
H0 : Cong A B E F
H : Cong A B C D
A,B,C,D,E,F : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
or (Cong C D E F) (and (Logic.eq C D) (Logic.eq E F))
+++++
left.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
unfold TCong in *.
destruct H.
destruct H0.
left.

*****
H0 : Cong A B E F
H : Cong A B C D
A,B,C,D,E,F : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
Cong C D E F
+++++
apply cn_congruencetransitive with A B.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
unfold TCong in *.
destruct H.
destruct H0.
left.
apply cn_congruencetransitive with A B.

*****
H0 : Cong A B E F
H : Cong A B C D
A,B,C,D,E,F : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
Cong A B C D
+++++
auto.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
unfold TCong in *.
destruct H.
destruct H0.
left.
apply cn_congruencetransitive with A B.

*****
H0 : Cong A B E F
H : Cong A B C D
A,B,C,D,E,F : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
Cong A B E F
+++++
auto.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
unfold TCong in *.
destruct H.
destruct H0.

*****
H0 : and (Logic.eq A B) (Logic.eq E F)
H : Cong A B C D
A,B,C,D,E,F : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
or (Cong C D E F) (and (Logic.eq C D) (Logic.eq E F))
+++++
spliter.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
unfold TCong in *.
destruct H.
destruct H0.
spliter.

*****
H1 : Logic.eq E F
H0 : Logic.eq A B
H : Cong A B C D
A,B,C,D,E,F : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
or (Cong C D E F) (and (Logic.eq C D) (Logic.eq E F))
+++++
subst.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
unfold TCong in *.
destruct H.
destruct H0.
spliter.
subst.

*****
H : Cong B B C D
B,C,D,F : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
or (Cong C D F F) (and (Logic.eq C D) (Logic.eq F F))
+++++
apply cong_sym in H.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
unfold TCong in *.
destruct H.
destruct H0.
spliter.
subst.
apply cong_sym in H.

*****
H : Cong C D B B
B,C,D,F : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
or (Cong C D F F) (and (Logic.eq C D) (Logic.eq F F))
+++++
apply cong_eq in H.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
unfold TCong in *.
destruct H.
destruct H0.
spliter.
subst.
apply cong_sym in H.
apply cong_eq in H.

*****
H : Logic.eq C D
B,C,D,F : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
or (Cong C D F F) (and (Logic.eq C D) (Logic.eq F F))
+++++
subst.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
unfold TCong in *.
destruct H.
destruct H0.
spliter.
subst.
apply cong_sym in H.
apply cong_eq in H.
subst.

*****
B,D,F : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
or (Cong D D F F) (and (Logic.eq D D) (Logic.eq F F))
+++++
auto.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
unfold TCong in *.
destruct H.

*****
H0 : or (Cong A B E F) (and (Logic.eq A B) (Logic.eq E F))
H : and (Logic.eq A B) (Logic.eq C D)
A,B,C,D,E,F : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
or (Cong C D E F) (and (Logic.eq C D) (Logic.eq E F))
+++++
destruct H0.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
unfold TCong in *.
destruct H.
destruct H0.

*****
H0 : Cong A B E F
H : and (Logic.eq A B) (Logic.eq C D)
A,B,C,D,E,F : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
or (Cong C D E F) (and (Logic.eq C D) (Logic.eq E F))
+++++
spliter.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
unfold TCong in *.
destruct H.
destruct H0.
spliter.

*****
H0 : Cong A B E F
H1 : Logic.eq C D
H : Logic.eq A B
A,B,C,D,E,F : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
or (Cong C D E F) (and (Logic.eq C D) (Logic.eq E F))
+++++
subst.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
unfold TCong in *.
destruct H.
destruct H0.
spliter.
subst.

*****
H0 : Cong B B E F
B,D,E,F : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
or (Cong D D E F) (and (Logic.eq D D) (Logic.eq E F))
+++++
apply cong_sym in H0.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
unfold TCong in *.
destruct H.
destruct H0.
spliter.
subst.
apply cong_sym in H0.

*****
H0 : Cong E F B B
B,D,E,F : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
or (Cong D D E F) (and (Logic.eq D D) (Logic.eq E F))
+++++
apply cong_eq in H0.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
unfold TCong in *.
destruct H.
destruct H0.
spliter.
subst.
apply cong_sym in H0.
apply cong_eq in H0.

*****
H0 : Logic.eq E F
B,D,E,F : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
or (Cong D D E F) (and (Logic.eq D D) (Logic.eq E F))
+++++
subst.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
unfold TCong in *.
destruct H.
destruct H0.
spliter.
subst.
apply cong_sym in H0.
apply cong_eq in H0.
subst.

*****
B,D,F : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
or (Cong D D F F) (and (Logic.eq D D) (Logic.eq F F))
+++++
auto.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
unfold TCong in *.
destruct H.
destruct H0.

*****
H0 : and (Logic.eq A B) (Logic.eq E F)
H : and (Logic.eq A B) (Logic.eq C D)
A,B,C,D,E,F : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
or (Cong C D E F) (and (Logic.eq C D) (Logic.eq E F))
+++++
spliter.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
unfold TCong in *.
destruct H.
destruct H0.
spliter.

*****
H1 : Logic.eq E F
H0 : Logic.eq A B
H2 : Logic.eq C D
H : Logic.eq A B
A,B,C,D,E,F : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
or (Cong C D E F) (and (Logic.eq C D) (Logic.eq E F))
+++++
subst.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
unfold TCong in *.
destruct H.
destruct H0.
spliter.
subst.

*****
H0 : Logic.eq B B
B,D,F : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
or (Cong D D F F) (and (Logic.eq D D) (Logic.eq F F))
+++++
auto.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).

*****
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
forall (A B C : Point) (_ : TCong A B C C), Logic.eq A B
+++++
intros.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.

*****
H : TCong A B C C
A,B,C : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
Logic.eq A B
+++++
unfold TCong in *.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
unfold TCong in *.

*****
H : or (Cong A B C C) (and (Logic.eq A B) (Logic.eq C C))
A,B,C : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
Logic.eq A B
+++++
destruct H.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
unfold TCong in *.
destruct H.

*****
H : Cong A B C C
A,B,C : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
Logic.eq A B
+++++
apply cong_eq with C.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
unfold TCong in *.
destruct H.
apply cong_eq with C.

*****
H : Cong A B C C
A,B,C : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
Cong A B C C
+++++
assumption.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
unfold TCong in *.
destruct H.

*****
H : and (Logic.eq A B) (Logic.eq C C)
A,B,C : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
Logic.eq A B
+++++
intuition.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).

*****
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
forall A B C D : Point, ex (fun E : Point => and (Bet A B E) (TCong B E C D))
+++++
intros.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.

*****
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
ex (fun E : Point => and (Bet A B E) (TCong B E C D))
+++++
elim (classic (C=D)).
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
elim (classic (C=D)).

*****
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
forall _ : Logic.eq C D, ex (fun E : Point => and (Bet A B E) (TCong B E C D))
+++++
intro.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
elim (classic (C=D)).
intro.

*****
H : Logic.eq C D
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
ex (fun E : Point => and (Bet A B E) (TCong B E C D))
+++++
subst.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
elim (classic (C=D)).
intro.
subst.

*****
A,B,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
ex (fun E : Point => and (Bet A B E) (TCong B E D D))
+++++
exists B.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
elim (classic (C=D)).
intro.
subst.
exists B.

*****
A,B,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
and (Bet A B B) (TCong B B D D)
+++++
split.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
elim (classic (C=D)).
intro.
subst.
exists B.
split.

*****
A,B,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
Bet A B B
+++++
unfold Bet.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
elim (classic (C=D)).
intro.
subst.
exists B.
split.
unfold Bet.

*****
A,B,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
or (BetS A B B) (or (Logic.eq A B) (Logic.eq B B))
+++++
auto.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
elim (classic (C=D)).
intro.
subst.
exists B.
split.

*****
A,B,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
TCong B B D D
+++++
apply nullsegment2.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
elim (classic (C=D)).

*****
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
forall _ : not (Logic.eq C D), ex (fun E : Point => and (Bet A B E) (TCong B E C D))
+++++
intro.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
elim (classic (C=D)).
intro.

*****
H : not (Logic.eq C D)
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
ex (fun E : Point => and (Bet A B E) (TCong B E C D))
+++++
elim (classic (A=B)).
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
elim (classic (C=D)).
intro.
elim (classic (A=B)).

*****
H : not (Logic.eq C D)
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
forall _ : Logic.eq A B, ex (fun E : Point => and (Bet A B E) (TCong B E C D))
+++++
intro.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
elim (classic (C=D)).
intro.
elim (classic (A=B)).
intro.

*****
H0 : Logic.eq A B
H : not (Logic.eq C D)
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
ex (fun E : Point => and (Bet A B E) (TCong B E C D))
+++++
subst.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
elim (classic (C=D)).
intro.
elim (classic (A=B)).
intro.
subst.

*****
H : not (Logic.eq C D)
B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
ex (fun E : Point => and (Bet B B E) (TCong B E C D))
+++++
elim (classic (B=C)).
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
elim (classic (C=D)).
intro.
elim (classic (A=B)).
intro.
subst.
elim (classic (B=C)).

*****
H : not (Logic.eq C D)
B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
forall _ : Logic.eq B C, ex (fun E : Point => and (Bet B B E) (TCong B E C D))
+++++
intro.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
elim (classic (C=D)).
intro.
elim (classic (A=B)).
intro.
subst.
elim (classic (B=C)).
intro.

*****
H0 : Logic.eq B C
H : not (Logic.eq C D)
B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
ex (fun E : Point => and (Bet B B E) (TCong B E C D))
+++++
subst.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
elim (classic (C=D)).
intro.
elim (classic (A=B)).
intro.
subst.
elim (classic (B=C)).
intro.
subst.

*****
H : not (Logic.eq C D)
C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
ex (fun E : Point => and (Bet C C E) (TCong C E C D))
+++++
exists D.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
elim (classic (C=D)).
intro.
elim (classic (A=B)).
intro.
subst.
elim (classic (B=C)).
intro.
subst.
exists D.

*****
H : not (Logic.eq C D)
C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
and (Bet C C D) (TCong C D C D)
+++++
split.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
elim (classic (C=D)).
intro.
elim (classic (A=B)).
intro.
subst.
elim (classic (B=C)).
intro.
subst.
exists D.
split.

*****
H : not (Logic.eq C D)
C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
Bet C C D
+++++
unfold Bet.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
elim (classic (C=D)).
intro.
elim (classic (A=B)).
intro.
subst.
elim (classic (B=C)).
intro.
subst.
exists D.
split.
unfold Bet.

*****
H : not (Logic.eq C D)
C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
or (BetS C C D) (or (Logic.eq C C) (Logic.eq C D))
+++++
right.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
elim (classic (C=D)).
intro.
elim (classic (A=B)).
intro.
subst.
elim (classic (B=C)).
intro.
subst.
exists D.
split.
unfold Bet.
right.

*****
H : not (Logic.eq C D)
C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
or (Logic.eq C C) (Logic.eq C D)
+++++
auto.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
elim (classic (C=D)).
intro.
elim (classic (A=B)).
intro.
subst.
elim (classic (B=C)).
intro.
subst.
exists D.
split.

*****
H : not (Logic.eq C D)
C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
TCong C D C D
+++++
apply Tcong_reflexive.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
elim (classic (C=D)).
intro.
elim (classic (A=B)).
intro.
subst.
elim (classic (B=C)).

*****
H : not (Logic.eq C D)
B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
forall _ : not (Logic.eq B C), ex (fun E : Point => and (Bet B B E) (TCong B E C D))
+++++
intro.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
elim (classic (C=D)).
intro.
elim (classic (A=B)).
intro.
subst.
elim (classic (B=C)).
intro.

*****
H0 : not (Logic.eq B C)
H : not (Logic.eq C D)
B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
ex (fun E : Point => and (Bet B B E) (TCong B E C D))
+++++
destruct (lemma_extension C B C D) as [X [HXA HXB]].
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
elim (classic (C=D)).
intro.
elim (classic (A=B)).
intro.
subst.
elim (classic (B=C)).
intro.
destruct (lemma_extension C B C D) as [X [HXA HXB]].

*****
H0 : not (Logic.eq B C)
H : not (Logic.eq C D)
B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
neq C B
+++++
unfold neq.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
elim (classic (C=D)).
intro.
elim (classic (A=B)).
intro.
subst.
elim (classic (B=C)).
intro.
destruct (lemma_extension C B C D) as [X [HXA HXB]].
unfold neq.

*****
H0 : not (Logic.eq B C)
H : not (Logic.eq C D)
B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
not (eq C B)
+++++
auto.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
elim (classic (C=D)).
intro.
elim (classic (A=B)).
intro.
subst.
elim (classic (B=C)).
intro.
destruct (lemma_extension C B C D) as [X [HXA HXB]].

*****
H0 : not (Logic.eq B C)
H : not (Logic.eq C D)
B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
neq C D
+++++
unfold neq.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
elim (classic (C=D)).
intro.
elim (classic (A=B)).
intro.
subst.
elim (classic (B=C)).
intro.
destruct (lemma_extension C B C D) as [X [HXA HXB]].
unfold neq.

*****
H0 : not (Logic.eq B C)
H : not (Logic.eq C D)
B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
not (eq C D)
+++++
auto.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
elim (classic (C=D)).
intro.
elim (classic (A=B)).
intro.
subst.
elim (classic (B=C)).
intro.
destruct (lemma_extension C B C D) as [X [HXA HXB]].

*****
HXB : Cong B X C D
HXA : BetS C B X
X : Point
H0 : not (Logic.eq B C)
H : not (Logic.eq C D)
B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
ex (fun E : Point => and (Bet B B E) (TCong B E C D))
+++++
unfold neq.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
elim (classic (C=D)).
intro.
elim (classic (A=B)).
intro.
subst.
elim (classic (B=C)).
intro.
destruct (lemma_extension C B C D) as [X [HXA HXB]].
unfold neq.

*****
HXB : Cong B X C D
HXA : BetS C B X
X : Point
H0 : not (Logic.eq B C)
H : not (Logic.eq C D)
B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
ex (fun E : Point => and (Bet B B E) (TCong B E C D))
+++++
auto.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
elim (classic (C=D)).
intro.
elim (classic (A=B)).
intro.
subst.
elim (classic (B=C)).
intro.
destruct (lemma_extension C B C D) as [X [HXA HXB]].
unfold neq.
auto.

*****
HXB : Cong B X C D
HXA : BetS C B X
X : Point
H0 : not (Logic.eq B C)
H : not (Logic.eq C D)
B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
ex (fun E : Point => and (Bet B B E) (TCong B E C D))
+++++
exists X.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
elim (classic (C=D)).
intro.
elim (classic (A=B)).
intro.
subst.
elim (classic (B=C)).
intro.
destruct (lemma_extension C B C D) as [X [HXA HXB]].
unfold neq.
auto.
exists X.

*****
HXB : Cong B X C D
HXA : BetS C B X
X : Point
H0 : not (Logic.eq B C)
H : not (Logic.eq C D)
B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
and (Bet B B X) (TCong B X C D)
+++++
split.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
elim (classic (C=D)).
intro.
elim (classic (A=B)).
intro.
subst.
elim (classic (B=C)).
intro.
destruct (lemma_extension C B C D) as [X [HXA HXB]].
unfold neq.
auto.
exists X.
split.

*****
HXB : Cong B X C D
HXA : BetS C B X
X : Point
H0 : not (Logic.eq B C)
H : not (Logic.eq C D)
B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
Bet B B X
+++++
unfold Bet.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
elim (classic (C=D)).
intro.
elim (classic (A=B)).
intro.
subst.
elim (classic (B=C)).
intro.
destruct (lemma_extension C B C D) as [X [HXA HXB]].
unfold neq.
auto.
exists X.
split.
unfold Bet.

*****
HXB : Cong B X C D
HXA : BetS C B X
X : Point
H0 : not (Logic.eq B C)
H : not (Logic.eq C D)
B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
or (BetS B B X) (or (Logic.eq B B) (Logic.eq B X))
+++++
right.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
elim (classic (C=D)).
intro.
elim (classic (A=B)).
intro.
subst.
elim (classic (B=C)).
intro.
destruct (lemma_extension C B C D) as [X [HXA HXB]].
unfold neq.
auto.
exists X.
split.
unfold Bet.
right.

*****
HXB : Cong B X C D
HXA : BetS C B X
X : Point
H0 : not (Logic.eq B C)
H : not (Logic.eq C D)
B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
or (Logic.eq B B) (Logic.eq B X)
+++++
auto.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
elim (classic (C=D)).
intro.
elim (classic (A=B)).
intro.
subst.
elim (classic (B=C)).
intro.
destruct (lemma_extension C B C D) as [X [HXA HXB]].
unfold neq.
auto.
exists X.
split.

*****
HXB : Cong B X C D
HXA : BetS C B X
X : Point
H0 : not (Logic.eq B C)
H : not (Logic.eq C D)
B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
TCong B X C D
+++++
unfold TCong.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
elim (classic (C=D)).
intro.
elim (classic (A=B)).
intro.
subst.
elim (classic (B=C)).
intro.
destruct (lemma_extension C B C D) as [X [HXA HXB]].
unfold neq.
auto.
exists X.
split.
unfold TCong.

*****
HXB : Cong B X C D
HXA : BetS C B X
X : Point
H0 : not (Logic.eq B C)
H : not (Logic.eq C D)
B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
or (Cong B X C D) (and (Logic.eq B X) (Logic.eq C D))
+++++
auto.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
elim (classic (C=D)).
intro.
elim (classic (A=B)).

*****
H : not (Logic.eq C D)
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
forall _ : not (Logic.eq A B), ex (fun E : Point => and (Bet A B E) (TCong B E C D))
+++++
intro.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
elim (classic (C=D)).
intro.
elim (classic (A=B)).
intro.

*****
H0 : not (Logic.eq A B)
H : not (Logic.eq C D)
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
ex (fun E : Point => and (Bet A B E) (TCong B E C D))
+++++
destruct (lemma_extension A B C D) as [X [HXA HXB]].
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
elim (classic (C=D)).
intro.
elim (classic (A=B)).
intro.
destruct (lemma_extension A B C D) as [X [HXA HXB]].

*****
H0 : not (Logic.eq A B)
H : not (Logic.eq C D)
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
neq A B
+++++
unfold neq.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
elim (classic (C=D)).
intro.
elim (classic (A=B)).
intro.
destruct (lemma_extension A B C D) as [X [HXA HXB]].
unfold neq.

*****
H0 : not (Logic.eq A B)
H : not (Logic.eq C D)
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
not (eq A B)
+++++
auto.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
elim (classic (C=D)).
intro.
elim (classic (A=B)).
intro.
destruct (lemma_extension A B C D) as [X [HXA HXB]].

*****
H0 : not (Logic.eq A B)
H : not (Logic.eq C D)
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
neq C D
+++++
unfold neq.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
elim (classic (C=D)).
intro.
elim (classic (A=B)).
intro.
destruct (lemma_extension A B C D) as [X [HXA HXB]].
unfold neq.

*****
H0 : not (Logic.eq A B)
H : not (Logic.eq C D)
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
not (eq C D)
+++++
auto.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
elim (classic (C=D)).
intro.
elim (classic (A=B)).
intro.
destruct (lemma_extension A B C D) as [X [HXA HXB]].

*****
HXB : Cong B X C D
HXA : BetS A B X
X : Point
H0 : not (Logic.eq A B)
H : not (Logic.eq C D)
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
ex (fun E : Point => and (Bet A B E) (TCong B E C D))
+++++
unfold neq.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
elim (classic (C=D)).
intro.
elim (classic (A=B)).
intro.
destruct (lemma_extension A B C D) as [X [HXA HXB]].
unfold neq.

*****
HXB : Cong B X C D
HXA : BetS A B X
X : Point
H0 : not (Logic.eq A B)
H : not (Logic.eq C D)
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
ex (fun E : Point => and (Bet A B E) (TCong B E C D))
+++++
auto.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
elim (classic (C=D)).
intro.
elim (classic (A=B)).
intro.
destruct (lemma_extension A B C D) as [X [HXA HXB]].
unfold neq.
auto.

*****
HXB : Cong B X C D
HXA : BetS A B X
X : Point
H0 : not (Logic.eq A B)
H : not (Logic.eq C D)
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
ex (fun E : Point => and (Bet A B E) (TCong B E C D))
+++++
exists X.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
elim (classic (C=D)).
intro.
elim (classic (A=B)).
intro.
destruct (lemma_extension A B C D) as [X [HXA HXB]].
unfold neq.
auto.
exists X.

*****
HXB : Cong B X C D
HXA : BetS A B X
X : Point
H0 : not (Logic.eq A B)
H : not (Logic.eq C D)
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
and (Bet A B X) (TCong B X C D)
+++++
unfold Bet.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
elim (classic (C=D)).
intro.
elim (classic (A=B)).
intro.
destruct (lemma_extension A B C D) as [X [HXA HXB]].
unfold neq.
auto.
exists X.
unfold Bet.

*****
HXB : Cong B X C D
HXA : BetS A B X
X : Point
H0 : not (Logic.eq A B)
H : not (Logic.eq C D)
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
and (or (BetS A B X) (or (Logic.eq A B) (Logic.eq B X))) (TCong B X C D)
+++++
unfold TCong.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
elim (classic (C=D)).
intro.
elim (classic (A=B)).
intro.
destruct (lemma_extension A B C D) as [X [HXA HXB]].
unfold neq.
auto.
exists X.
unfold Bet.
unfold TCong.

*****
HXB : Cong B X C D
HXA : BetS A B X
X : Point
H0 : not (Logic.eq A B)
H : not (Logic.eq C D)
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
and (or (BetS A B X) (or (Logic.eq A B) (Logic.eq B X))) (or (Cong B X C D) (and (Logic.eq B X) (Logic.eq C D)))
+++++
auto.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).

*****
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
forall (A A' B B' C C' D D' : Point) (_ : TCong A B A' B') (_ : TCong B C B' C') (_ : TCong A D A' D') (_ : TCong B D B' D') (_ : Bet A B C) (_ : Bet A' B' C') (_ : not (Logic.eq A B)), TCong C D C' D'
+++++
intros.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.

*****
H5 : not (Logic.eq A B)
H4 : Bet A' B' C'
H3 : Bet A B C
H2 : TCong B D B' D'
H1 : TCong A D A' D'
H0 : TCong B C B' C'
H : TCong A B A' B'
A,A',B,B',C,C',D,D' : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
TCong C D C' D'
+++++
elim (classic (B=C)).
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
elim (classic (B=C)).

*****
H5 : not (Logic.eq A B)
H4 : Bet A' B' C'
H3 : Bet A B C
H2 : TCong B D B' D'
H1 : TCong A D A' D'
H0 : TCong B C B' C'
H : TCong A B A' B'
A,A',B,B',C,C',D,D' : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
forall _ : Logic.eq B C, TCong C D C' D'
+++++
intro.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
elim (classic (B=C)).
intro.

*****
H6 : Logic.eq B C
H5 : not (Logic.eq A B)
H4 : Bet A' B' C'
H3 : Bet A B C
H2 : TCong B D B' D'
H1 : TCong A D A' D'
H0 : TCong B C B' C'
H : TCong A B A' B'
A,A',B,B',C,C',D,D' : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
TCong C D C' D'
+++++
subst.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
elim (classic (B=C)).
intro.
subst.

*****
H5 : not (Logic.eq A C)
H4 : Bet A' B' C'
H2 : TCong C D B' D'
H3 : Bet A C C
H1 : TCong A D A' D'
H : TCong A C A' B'
H0 : TCong C C B' C'
A,A',B',C,C',D,D' : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
TCong C D C' D'
+++++
assert (B'=C').
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
elim (classic (B=C)).
intro.
subst.
assert (B'=C').

*****
H5 : not (Logic.eq A C)
H4 : Bet A' B' C'
H2 : TCong C D B' D'
H3 : Bet A C C
H1 : TCong A D A' D'
H : TCong A C A' B'
H0 : TCong C C B' C'
A,A',B',C,C',D,D' : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
Logic.eq B' C'
+++++
apply nullsegment1 with C.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
elim (classic (B=C)).
intro.
subst.
assert (B'=C').
apply nullsegment1 with C.

*****
H5 : not (Logic.eq A C)
H4 : Bet A' B' C'
H2 : TCong C D B' D'
H3 : Bet A C C
H1 : TCong A D A' D'
H : TCong A C A' B'
H0 : TCong C C B' C'
A,A',B',C,C',D,D' : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
TCong C C B' C'
+++++
assumption.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
elim (classic (B=C)).
intro.
subst.
assert (B'=C').

*****
H6 : Logic.eq B' C'
H5 : not (Logic.eq A C)
H4 : Bet A' B' C'
H2 : TCong C D B' D'
H3 : Bet A C C
H1 : TCong A D A' D'
H : TCong A C A' B'
H0 : TCong C C B' C'
A,A',B',C,C',D,D' : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
TCong C D C' D'
+++++
subst.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
elim (classic (B=C)).
intro.
subst.
assert (B'=C').
subst.

*****
H5 : not (Logic.eq A C)
H2 : TCong C D C' D'
H4 : Bet A' C' C'
H3 : Bet A C C
H1 : TCong A D A' D'
H0 : TCong C C C' C'
H : TCong A C A' C'
A,A',C,C',D,D' : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
TCong C D C' D'
+++++
assumption.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
elim (classic (B=C)).

*****
H5 : not (Logic.eq A B)
H4 : Bet A' B' C'
H3 : Bet A B C
H2 : TCong B D B' D'
H1 : TCong A D A' D'
H0 : TCong B C B' C'
H : TCong A B A' B'
A,A',B,B',C,C',D,D' : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
forall _ : not (Logic.eq B C), TCong C D C' D'
+++++
intro.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
elim (classic (B=C)).
intro.

*****
H6 : not (Logic.eq B C)
H5 : not (Logic.eq A B)
H4 : Bet A' B' C'
H3 : Bet A B C
H2 : TCong B D B' D'
H1 : TCong A D A' D'
H0 : TCong B C B' C'
H : TCong A B A' B'
A,A',B,B',C,C',D,D' : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
TCong C D C' D'
+++++
assert (B'<>C').
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
elim (classic (B=C)).
intro.
assert (B'<>C').

*****
H6 : not (Logic.eq B C)
H5 : not (Logic.eq A B)
H4 : Bet A' B' C'
H3 : Bet A B C
H2 : TCong B D B' D'
H1 : TCong A D A' D'
H0 : TCong B C B' C'
H : TCong A B A' B'
A,A',B,B',C,C',D,D' : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
not (Logic.eq B' C')
+++++
intro.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
elim (classic (B=C)).
intro.
assert (B'<>C').
intro.

*****
H7 : Logic.eq B' C'
H6 : not (Logic.eq B C)
H5 : not (Logic.eq A B)
H4 : Bet A' B' C'
H3 : Bet A B C
H2 : TCong B D B' D'
H1 : TCong A D A' D'
H0 : TCong B C B' C'
H : TCong A B A' B'
A,A',B,B',C,C',D,D' : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
False
+++++
subst.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
elim (classic (B=C)).
intro.
assert (B'<>C').
intro.
subst.

*****
H6 : not (Logic.eq B C)
H5 : not (Logic.eq A B)
H4 : Bet A' C' C'
H3 : Bet A B C
H2 : TCong B D C' D'
H1 : TCong A D A' D'
H : TCong A B A' C'
H0 : TCong B C C' C'
A,A',B,C,C',D,D' : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
False
+++++
apply H6.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
elim (classic (B=C)).
intro.
assert (B'<>C').
intro.
subst.
apply H6.

*****
H6 : not (Logic.eq B C)
H5 : not (Logic.eq A B)
H4 : Bet A' C' C'
H3 : Bet A B C
H2 : TCong B D C' D'
H1 : TCong A D A' D'
H : TCong A B A' C'
H0 : TCong B C C' C'
A,A',B,C,C',D,D' : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
Logic.eq B C
+++++
apply nullsegment1 with C'.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
elim (classic (B=C)).
intro.
assert (B'<>C').
intro.
subst.
apply H6.
apply nullsegment1 with C'.

*****
H6 : not (Logic.eq B C)
H5 : not (Logic.eq A B)
H4 : Bet A' C' C'
H3 : Bet A B C
H2 : TCong B D C' D'
H1 : TCong A D A' D'
H : TCong A B A' C'
H0 : TCong B C C' C'
A,A',B,C,C',D,D' : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
TCong C' C' B C
+++++
apply Tcong_symmetric.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
elim (classic (B=C)).
intro.
assert (B'<>C').
intro.
subst.
apply H6.
apply nullsegment1 with C'.
apply Tcong_symmetric.

*****
H6 : not (Logic.eq B C)
H5 : not (Logic.eq A B)
H4 : Bet A' C' C'
H3 : Bet A B C
H2 : TCong B D C' D'
H1 : TCong A D A' D'
H : TCong A B A' C'
H0 : TCong B C C' C'
A,A',B,C,C',D,D' : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
TCong B C C' C'
+++++
assumption.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
elim (classic (B=C)).
intro.
assert (B'<>C').

*****
H7 : not (Logic.eq B' C')
H6 : not (Logic.eq B C)
H5 : not (Logic.eq A B)
H4 : Bet A' B' C'
H3 : Bet A B C
H2 : TCong B D B' D'
H1 : TCong A D A' D'
H0 : TCong B C B' C'
H : TCong A B A' B'
A,A',B,B',C,C',D,D' : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
TCong C D C' D'
+++++
assert (A'<>B').
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
elim (classic (B=C)).
intro.
assert (B'<>C').
assert (A'<>B').

*****
H7 : not (Logic.eq B' C')
H6 : not (Logic.eq B C)
H5 : not (Logic.eq A B)
H4 : Bet A' B' C'
H3 : Bet A B C
H2 : TCong B D B' D'
H1 : TCong A D A' D'
H0 : TCong B C B' C'
H : TCong A B A' B'
A,A',B,B',C,C',D,D' : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
not (Logic.eq A' B')
+++++
intro.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
elim (classic (B=C)).
intro.
assert (B'<>C').
assert (A'<>B').
intro.

*****
H8 : Logic.eq A' B'
H7 : not (Logic.eq B' C')
H6 : not (Logic.eq B C)
H5 : not (Logic.eq A B)
H4 : Bet A' B' C'
H3 : Bet A B C
H2 : TCong B D B' D'
H1 : TCong A D A' D'
H0 : TCong B C B' C'
H : TCong A B A' B'
A,A',B,B',C,C',D,D' : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
False
+++++
subst.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
elim (classic (B=C)).
intro.
assert (B'<>C').
assert (A'<>B').
intro.
subst.

*****
H7 : not (Logic.eq B' C')
H6 : not (Logic.eq B C)
H5 : not (Logic.eq A B)
H4 : Bet B' B' C'
H3 : Bet A B C
H2 : TCong B D B' D'
H1 : TCong A D B' D'
H0 : TCong B C B' C'
H : TCong A B B' B'
A,B,B',C,C',D,D' : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
False
+++++
apply H5.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
elim (classic (B=C)).
intro.
assert (B'<>C').
assert (A'<>B').
intro.
subst.
apply H5.

*****
H7 : not (Logic.eq B' C')
H6 : not (Logic.eq B C)
H5 : not (Logic.eq A B)
H4 : Bet B' B' C'
H3 : Bet A B C
H2 : TCong B D B' D'
H1 : TCong A D B' D'
H0 : TCong B C B' C'
H : TCong A B B' B'
A,B,B',C,C',D,D' : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
Logic.eq A B
+++++
apply nullsegment1 with B'.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
elim (classic (B=C)).
intro.
assert (B'<>C').
assert (A'<>B').
intro.
subst.
apply H5.
apply nullsegment1 with B'.

*****
H7 : not (Logic.eq B' C')
H6 : not (Logic.eq B C)
H5 : not (Logic.eq A B)
H4 : Bet B' B' C'
H3 : Bet A B C
H2 : TCong B D B' D'
H1 : TCong A D B' D'
H0 : TCong B C B' C'
H : TCong A B B' B'
A,B,B',C,C',D,D' : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
TCong B' B' A B
+++++
apply Tcong_symmetric.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
elim (classic (B=C)).
intro.
assert (B'<>C').
assert (A'<>B').
intro.
subst.
apply H5.
apply nullsegment1 with B'.
apply Tcong_symmetric.

*****
H7 : not (Logic.eq B' C')
H6 : not (Logic.eq B C)
H5 : not (Logic.eq A B)
H4 : Bet B' B' C'
H3 : Bet A B C
H2 : TCong B D B' D'
H1 : TCong A D B' D'
H0 : TCong B C B' C'
H : TCong A B B' B'
A,B,B',C,C',D,D' : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
TCong A B B' B'
+++++
assumption.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
elim (classic (B=C)).
intro.
assert (B'<>C').
assert (A'<>B').

*****
H8 : not (Logic.eq A' B')
H7 : not (Logic.eq B' C')
H6 : not (Logic.eq B C)
H5 : not (Logic.eq A B)
H4 : Bet A' B' C'
H3 : Bet A B C
H2 : TCong B D B' D'
H1 : TCong A D A' D'
H0 : TCong B C B' C'
H : TCong A B A' B'
A,A',B,B',C,C',D,D' : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
TCong C D C' D'
+++++
apply TCong_neq_Cong in H0.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
elim (classic (B=C)).
intro.
assert (B'<>C').
assert (A'<>B').
apply TCong_neq_Cong in H0.

*****
H8 : not (Logic.eq A' B')
H7 : not (Logic.eq B' C')
H6 : not (Logic.eq B C)
H5 : not (Logic.eq A B)
H4 : Bet A' B' C'
H3 : Bet A B C
H2 : TCong B D B' D'
H1 : TCong A D A' D'
H0 : Cong B C B' C'
H : TCong A B A' B'
A,A',B,B',C,C',D,D' : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
TCong C D C' D'
+++++
auto.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
elim (classic (B=C)).
intro.
assert (B'<>C').
assert (A'<>B').
apply TCong_neq_Cong in H0.
auto.

*****
H8 : not (Logic.eq A' B')
H7 : not (Logic.eq B' C')
H6 : not (Logic.eq B C)
H5 : not (Logic.eq A B)
H4 : Bet A' B' C'
H3 : Bet A B C
H2 : TCong B D B' D'
H1 : TCong A D A' D'
H0 : Cong B C B' C'
H : TCong A B A' B'
A,A',B,B',C,C',D,D' : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
TCong C D C' D'
+++++
apply TCong_neq_Cong in H.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
elim (classic (B=C)).
intro.
assert (B'<>C').
assert (A'<>B').
apply TCong_neq_Cong in H0.
auto.
apply TCong_neq_Cong in H.

*****
H8 : not (Logic.eq A' B')
H7 : not (Logic.eq B' C')
H6 : not (Logic.eq B C)
H5 : not (Logic.eq A B)
H4 : Bet A' B' C'
H3 : Bet A B C
H2 : TCong B D B' D'
H1 : TCong A D A' D'
H0 : Cong B C B' C'
H : Cong A B A' B'
A,A',B,B',C,C',D,D' : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
TCong C D C' D'
+++++
auto.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
elim (classic (B=C)).
intro.
assert (B'<>C').
assert (A'<>B').
apply TCong_neq_Cong in H0.
auto.
apply TCong_neq_Cong in H.
auto.

*****
H8 : not (Logic.eq A' B')
H7 : not (Logic.eq B' C')
H6 : not (Logic.eq B C)
H5 : not (Logic.eq A B)
H4 : Bet A' B' C'
H3 : Bet A B C
H2 : TCong B D B' D'
H1 : TCong A D A' D'
H0 : Cong B C B' C'
H : Cong A B A' B'
A,A',B,B',C,C',D,D' : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
TCong C D C' D'
+++++
destruct (classic (A=D)).
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
elim (classic (B=C)).
intro.
assert (B'<>C').
assert (A'<>B').
apply TCong_neq_Cong in H0.
auto.
apply TCong_neq_Cong in H.
auto.
destruct (classic (A=D)).

*****
H9 : Logic.eq A D
H8 : not (Logic.eq A' B')
H7 : not (Logic.eq B' C')
H6 : not (Logic.eq B C)
H5 : not (Logic.eq A B)
H4 : Bet A' B' C'
H3 : Bet A B C
H2 : TCong B D B' D'
H1 : TCong A D A' D'
H0 : Cong B C B' C'
H : Cong A B A' B'
A,A',B,B',C,C',D,D' : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
TCong C D C' D'
+++++
subst.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
elim (classic (B=C)).
intro.
assert (B'<>C').
assert (A'<>B').
apply TCong_neq_Cong in H0.
auto.
apply TCong_neq_Cong in H.
auto.
destruct (classic (A=D)).
subst.

*****
H8 : not (Logic.eq A' B')
H7 : not (Logic.eq B' C')
H6 : not (Logic.eq B C)
H5 : not (Logic.eq D B)
H4 : Bet A' B' C'
H3 : Bet D B C
H2 : TCong B D B' D'
H1 : TCong D D A' D'
H0 : Cong B C B' C'
H : Cong D B A' B'
A',B,B',C,C',D,D' : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
TCong C D C' D'
+++++
assert (A'=D').
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
elim (classic (B=C)).
intro.
assert (B'<>C').
assert (A'<>B').
apply TCong_neq_Cong in H0.
auto.
apply TCong_neq_Cong in H.
auto.
destruct (classic (A=D)).
subst.
assert (A'=D').

*****
H8 : not (Logic.eq A' B')
H7 : not (Logic.eq B' C')
H6 : not (Logic.eq B C)
H5 : not (Logic.eq D B)
H4 : Bet A' B' C'
H3 : Bet D B C
H2 : TCong B D B' D'
H1 : TCong D D A' D'
H0 : Cong B C B' C'
H : Cong D B A' B'
A',B,B',C,C',D,D' : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
Logic.eq A' D'
+++++
apply nullsegment1 with D.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
elim (classic (B=C)).
intro.
assert (B'<>C').
assert (A'<>B').
apply TCong_neq_Cong in H0.
auto.
apply TCong_neq_Cong in H.
auto.
destruct (classic (A=D)).
subst.
assert (A'=D').
apply nullsegment1 with D.

*****
H8 : not (Logic.eq A' B')
H7 : not (Logic.eq B' C')
H6 : not (Logic.eq B C)
H5 : not (Logic.eq D B)
H4 : Bet A' B' C'
H3 : Bet D B C
H2 : TCong B D B' D'
H1 : TCong D D A' D'
H0 : Cong B C B' C'
H : Cong D B A' B'
A',B,B',C,C',D,D' : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
TCong D D A' D'
+++++
auto.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
elim (classic (B=C)).
intro.
assert (B'<>C').
assert (A'<>B').
apply TCong_neq_Cong in H0.
auto.
apply TCong_neq_Cong in H.
auto.
destruct (classic (A=D)).
subst.
assert (A'=D').

*****
H9 : Logic.eq A' D'
H8 : not (Logic.eq A' B')
H7 : not (Logic.eq B' C')
H6 : not (Logic.eq B C)
H5 : not (Logic.eq D B)
H4 : Bet A' B' C'
H3 : Bet D B C
H2 : TCong B D B' D'
H1 : TCong D D A' D'
H0 : Cong B C B' C'
H : Cong D B A' B'
A',B,B',C,C',D,D' : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
TCong C D C' D'
+++++
idtac.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
elim (classic (B=C)).
intro.
assert (B'<>C').
assert (A'<>B').
apply TCong_neq_Cong in H0.
auto.
apply TCong_neq_Cong in H.
auto.
destruct (classic (A=D)).
subst.
assert (A'=D').
idtac.

*****
H9 : Logic.eq A' D'
H8 : not (Logic.eq A' B')
H7 : not (Logic.eq B' C')
H6 : not (Logic.eq B C)
H5 : not (Logic.eq D B)
H4 : Bet A' B' C'
H3 : Bet D B C
H2 : TCong B D B' D'
H1 : TCong D D A' D'
H0 : Cong B C B' C'
H : Cong D B A' B'
A',B,B',C,C',D,D' : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
TCong C D C' D'
+++++
subst.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
elim (classic (B=C)).
intro.
assert (B'<>C').
assert (A'<>B').
apply TCong_neq_Cong in H0.
auto.
apply TCong_neq_Cong in H.
auto.
destruct (classic (A=D)).
subst.
assert (A'=D').
idtac.
subst.

*****
H8 : not (Logic.eq D' B')
H7 : not (Logic.eq B' C')
H6 : not (Logic.eq B C)
H5 : not (Logic.eq D B)
H4 : Bet D' B' C'
H3 : Bet D B C
H2 : TCong B D B' D'
H1 : TCong D D D' D'
H0 : Cong B C B' C'
H : Cong D B D' B'
B,B',C,C',D,D' : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
TCong C D C' D'
+++++
unfold TCong.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
elim (classic (B=C)).
intro.
assert (B'<>C').
assert (A'<>B').
apply TCong_neq_Cong in H0.
auto.
apply TCong_neq_Cong in H.
auto.
destruct (classic (A=D)).
subst.
assert (A'=D').
idtac.
subst.
unfold TCong.

*****
H8 : not (Logic.eq D' B')
H7 : not (Logic.eq B' C')
H6 : not (Logic.eq B C)
H5 : not (Logic.eq D B)
H4 : Bet D' B' C'
H3 : Bet D B C
H2 : TCong B D B' D'
H1 : TCong D D D' D'
H0 : Cong B C B' C'
H : Cong D B D' B'
B,B',C,C',D,D' : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
or (Cong C D C' D') (and (Logic.eq C D) (Logic.eq C' D'))
+++++
left.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
elim (classic (B=C)).
intro.
assert (B'<>C').
assert (A'<>B').
apply TCong_neq_Cong in H0.
auto.
apply TCong_neq_Cong in H.
auto.
destruct (classic (A=D)).
subst.
assert (A'=D').
idtac.
subst.
unfold TCong.
left.

*****
H8 : not (Logic.eq D' B')
H7 : not (Logic.eq B' C')
H6 : not (Logic.eq B C)
H5 : not (Logic.eq D B)
H4 : Bet D' B' C'
H3 : Bet D B C
H2 : TCong B D B' D'
H1 : TCong D D D' D'
H0 : Cong B C B' C'
H : Cong D B D' B'
B,B',C,C',D,D' : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
Cong C D C' D'
+++++
apply cn_sumofparts with B B'.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
elim (classic (B=C)).
intro.
assert (B'<>C').
assert (A'<>B').
apply TCong_neq_Cong in H0.
auto.
apply TCong_neq_Cong in H.
auto.
destruct (classic (A=D)).
subst.
assert (A'=D').
idtac.
subst.
unfold TCong.
left.
apply cn_sumofparts with B B'.

*****
H8 : not (Logic.eq D' B')
H7 : not (Logic.eq B' C')
H6 : not (Logic.eq B C)
H5 : not (Logic.eq D B)
H4 : Bet D' B' C'
H3 : Bet D B C
H2 : TCong B D B' D'
H1 : TCong D D D' D'
H0 : Cong B C B' C'
H : Cong D B D' B'
B,B',C,C',D,D' : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
Cong C B C' B'
+++++
apply lemma_congruenceflip.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
elim (classic (B=C)).
intro.
assert (B'<>C').
assert (A'<>B').
apply TCong_neq_Cong in H0.
auto.
apply TCong_neq_Cong in H.
auto.
destruct (classic (A=D)).
subst.
assert (A'=D').
idtac.
subst.
unfold TCong.
left.
apply cn_sumofparts with B B'.
apply lemma_congruenceflip.

*****
H8 : not (Logic.eq D' B')
H7 : not (Logic.eq B' C')
H6 : not (Logic.eq B C)
H5 : not (Logic.eq D B)
H4 : Bet D' B' C'
H3 : Bet D B C
H2 : TCong B D B' D'
H1 : TCong D D D' D'
H0 : Cong B C B' C'
H : Cong D B D' B'
B,B',C,C',D,D' : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
Cong B C B' C'
+++++
auto.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
elim (classic (B=C)).
intro.
assert (B'<>C').
assert (A'<>B').
apply TCong_neq_Cong in H0.
auto.
apply TCong_neq_Cong in H.
auto.
destruct (classic (A=D)).
subst.
assert (A'=D').
idtac.
subst.
unfold TCong.
left.
apply cn_sumofparts with B B'.

*****
H8 : not (Logic.eq D' B')
H7 : not (Logic.eq B' C')
H6 : not (Logic.eq B C)
H5 : not (Logic.eq D B)
H4 : Bet D' B' C'
H3 : Bet D B C
H2 : TCong B D B' D'
H1 : TCong D D D' D'
H0 : Cong B C B' C'
H : Cong D B D' B'
B,B',C,C',D,D' : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
Cong B D B' D'
+++++
apply lemma_congruenceflip.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
elim (classic (B=C)).
intro.
assert (B'<>C').
assert (A'<>B').
apply TCong_neq_Cong in H0.
auto.
apply TCong_neq_Cong in H.
auto.
destruct (classic (A=D)).
subst.
assert (A'=D').
idtac.
subst.
unfold TCong.
left.
apply cn_sumofparts with B B'.
apply lemma_congruenceflip.

*****
H8 : not (Logic.eq D' B')
H7 : not (Logic.eq B' C')
H6 : not (Logic.eq B C)
H5 : not (Logic.eq D B)
H4 : Bet D' B' C'
H3 : Bet D B C
H2 : TCong B D B' D'
H1 : TCong D D D' D'
H0 : Cong B C B' C'
H : Cong D B D' B'
B,B',C,C',D,D' : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
Cong D B D' B'
+++++
auto.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
elim (classic (B=C)).
intro.
assert (B'<>C').
assert (A'<>B').
apply TCong_neq_Cong in H0.
auto.
apply TCong_neq_Cong in H.
auto.
destruct (classic (A=D)).
subst.
assert (A'=D').
idtac.
subst.
unfold TCong.
left.
apply cn_sumofparts with B B'.

*****
H8 : not (Logic.eq D' B')
H7 : not (Logic.eq B' C')
H6 : not (Logic.eq B C)
H5 : not (Logic.eq D B)
H4 : Bet D' B' C'
H3 : Bet D B C
H2 : TCong B D B' D'
H1 : TCong D D D' D'
H0 : Cong B C B' C'
H : Cong D B D' B'
B,B',C,C',D,D' : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
BetS C B D
+++++
unfold Bet in H3.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
elim (classic (B=C)).
intro.
assert (B'<>C').
assert (A'<>B').
apply TCong_neq_Cong in H0.
auto.
apply TCong_neq_Cong in H.
auto.
destruct (classic (A=D)).
subst.
assert (A'=D').
idtac.
subst.
unfold TCong.
left.
apply cn_sumofparts with B B'.
unfold Bet in H3.

*****
H8 : not (Logic.eq D' B')
H7 : not (Logic.eq B' C')
H6 : not (Logic.eq B C)
H5 : not (Logic.eq D B)
H4 : Bet D' B' C'
H3 : or (BetS D B C) (or (Logic.eq D B) (Logic.eq B C))
H2 : TCong B D B' D'
H1 : TCong D D D' D'
H0 : Cong B C B' C'
H : Cong D B D' B'
B,B',C,C',D,D' : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
BetS C B D
+++++
apply axiom_betweennesssymmetry.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
elim (classic (B=C)).
intro.
assert (B'<>C').
assert (A'<>B').
apply TCong_neq_Cong in H0.
auto.
apply TCong_neq_Cong in H.
auto.
destruct (classic (A=D)).
subst.
assert (A'=D').
idtac.
subst.
unfold TCong.
left.
apply cn_sumofparts with B B'.
unfold Bet in H3.
apply axiom_betweennesssymmetry.

*****
H8 : not (Logic.eq D' B')
H7 : not (Logic.eq B' C')
H6 : not (Logic.eq B C)
H5 : not (Logic.eq D B)
H4 : Bet D' B' C'
H3 : or (BetS D B C) (or (Logic.eq D B) (Logic.eq B C))
H2 : TCong B D B' D'
H1 : TCong D D D' D'
H0 : Cong B C B' C'
H : Cong D B D' B'
B,B',C,C',D,D' : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
BetS D B C
+++++
destruct H3.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
elim (classic (B=C)).
intro.
assert (B'<>C').
assert (A'<>B').
apply TCong_neq_Cong in H0.
auto.
apply TCong_neq_Cong in H.
auto.
destruct (classic (A=D)).
subst.
assert (A'=D').
idtac.
subst.
unfold TCong.
left.
apply cn_sumofparts with B B'.
unfold Bet in H3.
apply axiom_betweennesssymmetry.
destruct H3.

*****
H8 : not (Logic.eq D' B')
H7 : not (Logic.eq B' C')
H6 : not (Logic.eq B C)
H5 : not (Logic.eq D B)
H4 : Bet D' B' C'
H3 : BetS D B C
H2 : TCong B D B' D'
H1 : TCong D D D' D'
H0 : Cong B C B' C'
H : Cong D B D' B'
B,B',C,C',D,D' : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
BetS D B C
+++++
intuition.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
elim (classic (B=C)).
intro.
assert (B'<>C').
assert (A'<>B').
apply TCong_neq_Cong in H0.
auto.
apply TCong_neq_Cong in H.
auto.
destruct (classic (A=D)).
subst.
assert (A'=D').
idtac.
subst.
unfold TCong.
left.
apply cn_sumofparts with B B'.
unfold Bet in H3.
apply axiom_betweennesssymmetry.
destruct H3.

*****
H8 : not (Logic.eq D' B')
H7 : not (Logic.eq B' C')
H6 : not (Logic.eq B C)
H5 : not (Logic.eq D B)
H4 : Bet D' B' C'
H3 : or (Logic.eq D B) (Logic.eq B C)
H2 : TCong B D B' D'
H1 : TCong D D D' D'
H0 : Cong B C B' C'
H : Cong D B D' B'
B,B',C,C',D,D' : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
BetS D B C
+++++
intuition.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
elim (classic (B=C)).
intro.
assert (B'<>C').
assert (A'<>B').
apply TCong_neq_Cong in H0.
auto.
apply TCong_neq_Cong in H.
auto.
destruct (classic (A=D)).
subst.
assert (A'=D').
idtac.
subst.
unfold TCong.
left.
apply cn_sumofparts with B B'.

*****
H8 : not (Logic.eq D' B')
H7 : not (Logic.eq B' C')
H6 : not (Logic.eq B C)
H5 : not (Logic.eq D B)
H4 : Bet D' B' C'
H3 : Bet D B C
H2 : TCong B D B' D'
H1 : TCong D D D' D'
H0 : Cong B C B' C'
H : Cong D B D' B'
B,B',C,C',D,D' : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
BetS C' B' D'
+++++
apply axiom_betweennesssymmetry.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
elim (classic (B=C)).
intro.
assert (B'<>C').
assert (A'<>B').
apply TCong_neq_Cong in H0.
auto.
apply TCong_neq_Cong in H.
auto.
destruct (classic (A=D)).
subst.
assert (A'=D').
idtac.
subst.
unfold TCong.
left.
apply cn_sumofparts with B B'.
apply axiom_betweennesssymmetry.

*****
H8 : not (Logic.eq D' B')
H7 : not (Logic.eq B' C')
H6 : not (Logic.eq B C)
H5 : not (Logic.eq D B)
H4 : Bet D' B' C'
H3 : Bet D B C
H2 : TCong B D B' D'
H1 : TCong D D D' D'
H0 : Cong B C B' C'
H : Cong D B D' B'
B,B',C,C',D,D' : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
BetS D' B' C'
+++++
destruct H4.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
elim (classic (B=C)).
intro.
assert (B'<>C').
assert (A'<>B').
apply TCong_neq_Cong in H0.
auto.
apply TCong_neq_Cong in H.
auto.
destruct (classic (A=D)).
subst.
assert (A'=D').
idtac.
subst.
unfold TCong.
left.
apply cn_sumofparts with B B'.
apply axiom_betweennesssymmetry.
destruct H4.

*****
H8 : not (Logic.eq D' B')
H7 : not (Logic.eq B' C')
H6 : not (Logic.eq B C)
H5 : not (Logic.eq D B)
H4 : BetS D' B' C'
H3 : Bet D B C
H2 : TCong B D B' D'
H1 : TCong D D D' D'
H0 : Cong B C B' C'
H : Cong D B D' B'
B,B',C,C',D,D' : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
BetS D' B' C'
+++++
intuition.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
elim (classic (B=C)).
intro.
assert (B'<>C').
assert (A'<>B').
apply TCong_neq_Cong in H0.
auto.
apply TCong_neq_Cong in H.
auto.
destruct (classic (A=D)).
subst.
assert (A'=D').
idtac.
subst.
unfold TCong.
left.
apply cn_sumofparts with B B'.
apply axiom_betweennesssymmetry.
destruct H4.

*****
H8 : not (Logic.eq D' B')
H7 : not (Logic.eq B' C')
H6 : not (Logic.eq B C)
H5 : not (Logic.eq D B)
H4 : or (Logic.eq D' B') (Logic.eq B' C')
H3 : Bet D B C
H2 : TCong B D B' D'
H1 : TCong D D D' D'
H0 : Cong B C B' C'
H : Cong D B D' B'
B,B',C,C',D,D' : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
BetS D' B' C'
+++++
intuition.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
elim (classic (B=C)).
intro.
assert (B'<>C').
assert (A'<>B').
apply TCong_neq_Cong in H0.
auto.
apply TCong_neq_Cong in H.
auto.
destruct (classic (A=D)).

*****
H9 : not (Logic.eq A D)
H8 : not (Logic.eq A' B')
H7 : not (Logic.eq B' C')
H6 : not (Logic.eq B C)
H5 : not (Logic.eq A B)
H4 : Bet A' B' C'
H3 : Bet A B C
H2 : TCong B D B' D'
H1 : TCong A D A' D'
H0 : Cong B C B' C'
H : Cong A B A' B'
A,A',B,B',C,C',D,D' : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
TCong C D C' D'
+++++
assert (A'<>D').
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
elim (classic (B=C)).
intro.
assert (B'<>C').
assert (A'<>B').
apply TCong_neq_Cong in H0.
auto.
apply TCong_neq_Cong in H.
auto.
destruct (classic (A=D)).
assert (A'<>D').

*****
H9 : not (Logic.eq A D)
H8 : not (Logic.eq A' B')
H7 : not (Logic.eq B' C')
H6 : not (Logic.eq B C)
H5 : not (Logic.eq A B)
H4 : Bet A' B' C'
H3 : Bet A B C
H2 : TCong B D B' D'
H1 : TCong A D A' D'
H0 : Cong B C B' C'
H : Cong A B A' B'
A,A',B,B',C,C',D,D' : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
not (Logic.eq A' D')
+++++
intro.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
elim (classic (B=C)).
intro.
assert (B'<>C').
assert (A'<>B').
apply TCong_neq_Cong in H0.
auto.
apply TCong_neq_Cong in H.
auto.
destruct (classic (A=D)).
assert (A'<>D').
intro.

*****
H10 : Logic.eq A' D'
H9 : not (Logic.eq A D)
H8 : not (Logic.eq A' B')
H7 : not (Logic.eq B' C')
H6 : not (Logic.eq B C)
H5 : not (Logic.eq A B)
H4 : Bet A' B' C'
H3 : Bet A B C
H2 : TCong B D B' D'
H1 : TCong A D A' D'
H0 : Cong B C B' C'
H : Cong A B A' B'
A,A',B,B',C,C',D,D' : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
False
+++++
subst.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
elim (classic (B=C)).
intro.
assert (B'<>C').
assert (A'<>B').
apply TCong_neq_Cong in H0.
auto.
apply TCong_neq_Cong in H.
auto.
destruct (classic (A=D)).
assert (A'<>D').
intro.
subst.

*****
H9 : not (Logic.eq A D)
H8 : not (Logic.eq D' B')
H7 : not (Logic.eq B' C')
H6 : not (Logic.eq B C)
H5 : not (Logic.eq A B)
H4 : Bet D' B' C'
H3 : Bet A B C
H2 : TCong B D B' D'
H1 : TCong A D D' D'
H0 : Cong B C B' C'
H : Cong A B D' B'
A,B,B',C,C',D,D' : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
False
+++++
apply H9.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
elim (classic (B=C)).
intro.
assert (B'<>C').
assert (A'<>B').
apply TCong_neq_Cong in H0.
auto.
apply TCong_neq_Cong in H.
auto.
destruct (classic (A=D)).
assert (A'<>D').
intro.
subst.
apply H9.

*****
H9 : not (Logic.eq A D)
H8 : not (Logic.eq D' B')
H7 : not (Logic.eq B' C')
H6 : not (Logic.eq B C)
H5 : not (Logic.eq A B)
H4 : Bet D' B' C'
H3 : Bet A B C
H2 : TCong B D B' D'
H1 : TCong A D D' D'
H0 : Cong B C B' C'
H : Cong A B D' B'
A,B,B',C,C',D,D' : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
Logic.eq A D
+++++
apply nullsegment1 with D'.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
elim (classic (B=C)).
intro.
assert (B'<>C').
assert (A'<>B').
apply TCong_neq_Cong in H0.
auto.
apply TCong_neq_Cong in H.
auto.
destruct (classic (A=D)).
assert (A'<>D').
intro.
subst.
apply H9.
apply nullsegment1 with D'.

*****
H9 : not (Logic.eq A D)
H8 : not (Logic.eq D' B')
H7 : not (Logic.eq B' C')
H6 : not (Logic.eq B C)
H5 : not (Logic.eq A B)
H4 : Bet D' B' C'
H3 : Bet A B C
H2 : TCong B D B' D'
H1 : TCong A D D' D'
H0 : Cong B C B' C'
H : Cong A B D' B'
A,B,B',C,C',D,D' : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
TCong D' D' A D
+++++
apply Tcong_symmetric.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
elim (classic (B=C)).
intro.
assert (B'<>C').
assert (A'<>B').
apply TCong_neq_Cong in H0.
auto.
apply TCong_neq_Cong in H.
auto.
destruct (classic (A=D)).
assert (A'<>D').
intro.
subst.
apply H9.
apply nullsegment1 with D'.
apply Tcong_symmetric.

*****
H9 : not (Logic.eq A D)
H8 : not (Logic.eq D' B')
H7 : not (Logic.eq B' C')
H6 : not (Logic.eq B C)
H5 : not (Logic.eq A B)
H4 : Bet D' B' C'
H3 : Bet A B C
H2 : TCong B D B' D'
H1 : TCong A D D' D'
H0 : Cong B C B' C'
H : Cong A B D' B'
A,B,B',C,C',D,D' : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
TCong A D D' D'
+++++
assumption.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
elim (classic (B=C)).
intro.
assert (B'<>C').
assert (A'<>B').
apply TCong_neq_Cong in H0.
auto.
apply TCong_neq_Cong in H.
auto.
destruct (classic (A=D)).
assert (A'<>D').

*****
H10 : not (Logic.eq A' D')
H9 : not (Logic.eq A D)
H8 : not (Logic.eq A' B')
H7 : not (Logic.eq B' C')
H6 : not (Logic.eq B C)
H5 : not (Logic.eq A B)
H4 : Bet A' B' C'
H3 : Bet A B C
H2 : TCong B D B' D'
H1 : TCong A D A' D'
H0 : Cong B C B' C'
H : Cong A B A' B'
A,A',B,B',C,C',D,D' : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
TCong C D C' D'
+++++
apply TCong_neq_Cong in H1.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
elim (classic (B=C)).
intro.
assert (B'<>C').
assert (A'<>B').
apply TCong_neq_Cong in H0.
auto.
apply TCong_neq_Cong in H.
auto.
destruct (classic (A=D)).
assert (A'<>D').
apply TCong_neq_Cong in H1.

*****
H10 : not (Logic.eq A' D')
H9 : not (Logic.eq A D)
H8 : not (Logic.eq A' B')
H7 : not (Logic.eq B' C')
H6 : not (Logic.eq B C)
H5 : not (Logic.eq A B)
H4 : Bet A' B' C'
H3 : Bet A B C
H2 : TCong B D B' D'
H1 : Cong A D A' D'
H0 : Cong B C B' C'
H : Cong A B A' B'
A,A',B,B',C,C',D,D' : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
TCong C D C' D'
+++++
auto.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
elim (classic (B=C)).
intro.
assert (B'<>C').
assert (A'<>B').
apply TCong_neq_Cong in H0.
auto.
apply TCong_neq_Cong in H.
auto.
destruct (classic (A=D)).
assert (A'<>D').
apply TCong_neq_Cong in H1.
auto.

*****
H10 : not (Logic.eq A' D')
H9 : not (Logic.eq A D)
H8 : not (Logic.eq A' B')
H7 : not (Logic.eq B' C')
H6 : not (Logic.eq B C)
H5 : not (Logic.eq A B)
H4 : Bet A' B' C'
H3 : Bet A B C
H2 : TCong B D B' D'
H1 : Cong A D A' D'
H0 : Cong B C B' C'
H : Cong A B A' B'
A,A',B,B',C,C',D,D' : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
TCong C D C' D'
+++++
destruct (classic (B=D)).
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
elim (classic (B=C)).
intro.
assert (B'<>C').
assert (A'<>B').
apply TCong_neq_Cong in H0.
auto.
apply TCong_neq_Cong in H.
auto.
destruct (classic (A=D)).
assert (A'<>D').
apply TCong_neq_Cong in H1.
auto.
destruct (classic (B=D)).

*****
H11 : Logic.eq B D
H10 : not (Logic.eq A' D')
H9 : not (Logic.eq A D)
H8 : not (Logic.eq A' B')
H7 : not (Logic.eq B' C')
H6 : not (Logic.eq B C)
H5 : not (Logic.eq A B)
H4 : Bet A' B' C'
H3 : Bet A B C
H2 : TCong B D B' D'
H1 : Cong A D A' D'
H0 : Cong B C B' C'
H : Cong A B A' B'
A,A',B,B',C,C',D,D' : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
TCong C D C' D'
+++++
subst.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
elim (classic (B=C)).
intro.
assert (B'<>C').
assert (A'<>B').
apply TCong_neq_Cong in H0.
auto.
apply TCong_neq_Cong in H.
auto.
destruct (classic (A=D)).
assert (A'<>D').
apply TCong_neq_Cong in H1.
auto.
destruct (classic (B=D)).
subst.

*****
H10 : not (Logic.eq A' D')
H9 : not (Logic.eq A D)
H8 : not (Logic.eq A' B')
H7 : not (Logic.eq B' C')
H5 : not (Logic.eq A D)
H6 : not (Logic.eq D C)
H4 : Bet A' B' C'
H2 : TCong D D B' D'
H3 : Bet A D C
H1 : Cong A D A' D'
H : Cong A D A' B'
H0 : Cong D C B' C'
A,A',B',C,C',D,D' : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
TCong C D C' D'
+++++
assert (B'=D').
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
elim (classic (B=C)).
intro.
assert (B'<>C').
assert (A'<>B').
apply TCong_neq_Cong in H0.
auto.
apply TCong_neq_Cong in H.
auto.
destruct (classic (A=D)).
assert (A'<>D').
apply TCong_neq_Cong in H1.
auto.
destruct (classic (B=D)).
subst.
assert (B'=D').

*****
H10 : not (Logic.eq A' D')
H9 : not (Logic.eq A D)
H8 : not (Logic.eq A' B')
H7 : not (Logic.eq B' C')
H5 : not (Logic.eq A D)
H6 : not (Logic.eq D C)
H4 : Bet A' B' C'
H2 : TCong D D B' D'
H3 : Bet A D C
H1 : Cong A D A' D'
H : Cong A D A' B'
H0 : Cong D C B' C'
A,A',B',C,C',D,D' : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
Logic.eq B' D'
+++++
apply nullsegment1 with D.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
elim (classic (B=C)).
intro.
assert (B'<>C').
assert (A'<>B').
apply TCong_neq_Cong in H0.
auto.
apply TCong_neq_Cong in H.
auto.
destruct (classic (A=D)).
assert (A'<>D').
apply TCong_neq_Cong in H1.
auto.
destruct (classic (B=D)).
subst.
assert (B'=D').
apply nullsegment1 with D.

*****
H10 : not (Logic.eq A' D')
H9 : not (Logic.eq A D)
H8 : not (Logic.eq A' B')
H7 : not (Logic.eq B' C')
H5 : not (Logic.eq A D)
H6 : not (Logic.eq D C)
H4 : Bet A' B' C'
H2 : TCong D D B' D'
H3 : Bet A D C
H1 : Cong A D A' D'
H : Cong A D A' B'
H0 : Cong D C B' C'
A,A',B',C,C',D,D' : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
TCong D D B' D'
+++++
assumption.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
elim (classic (B=C)).
intro.
assert (B'<>C').
assert (A'<>B').
apply TCong_neq_Cong in H0.
auto.
apply TCong_neq_Cong in H.
auto.
destruct (classic (A=D)).
assert (A'<>D').
apply TCong_neq_Cong in H1.
auto.
destruct (classic (B=D)).
subst.
assert (B'=D').

*****
H11 : Logic.eq B' D'
H10 : not (Logic.eq A' D')
H9 : not (Logic.eq A D)
H8 : not (Logic.eq A' B')
H7 : not (Logic.eq B' C')
H5 : not (Logic.eq A D)
H6 : not (Logic.eq D C)
H4 : Bet A' B' C'
H2 : TCong D D B' D'
H3 : Bet A D C
H1 : Cong A D A' D'
H : Cong A D A' B'
H0 : Cong D C B' C'
A,A',B',C,C',D,D' : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
TCong C D C' D'
+++++
subst.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
elim (classic (B=C)).
intro.
assert (B'<>C').
assert (A'<>B').
apply TCong_neq_Cong in H0.
auto.
apply TCong_neq_Cong in H.
auto.
destruct (classic (A=D)).
assert (A'<>D').
apply TCong_neq_Cong in H1.
auto.
destruct (classic (B=D)).
subst.
assert (B'=D').
subst.

*****
H10 : not (Logic.eq A' D')
H9 : not (Logic.eq A D)
H7 : not (Logic.eq D' C')
H8 : not (Logic.eq A' D')
H5 : not (Logic.eq A D)
H6 : not (Logic.eq D C)
H2 : TCong D D D' D'
H4 : Bet A' D' C'
H3 : Bet A D C
H1 : Cong A D A' D'
H0 : Cong D C D' C'
H : Cong A D A' D'
A,A',C,C',D,D' : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
TCong C D C' D'
+++++
unfold TCong.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
elim (classic (B=C)).
intro.
assert (B'<>C').
assert (A'<>B').
apply TCong_neq_Cong in H0.
auto.
apply TCong_neq_Cong in H.
auto.
destruct (classic (A=D)).
assert (A'<>D').
apply TCong_neq_Cong in H1.
auto.
destruct (classic (B=D)).
subst.
assert (B'=D').
subst.
unfold TCong.

*****
H10 : not (Logic.eq A' D')
H9 : not (Logic.eq A D)
H7 : not (Logic.eq D' C')
H8 : not (Logic.eq A' D')
H5 : not (Logic.eq A D)
H6 : not (Logic.eq D C)
H2 : TCong D D D' D'
H4 : Bet A' D' C'
H3 : Bet A D C
H1 : Cong A D A' D'
H0 : Cong D C D' C'
H : Cong A D A' D'
A,A',C,C',D,D' : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
or (Cong C D C' D') (and (Logic.eq C D) (Logic.eq C' D'))
+++++
left.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
elim (classic (B=C)).
intro.
assert (B'<>C').
assert (A'<>B').
apply TCong_neq_Cong in H0.
auto.
apply TCong_neq_Cong in H.
auto.
destruct (classic (A=D)).
assert (A'<>D').
apply TCong_neq_Cong in H1.
auto.
destruct (classic (B=D)).
subst.
assert (B'=D').
subst.
unfold TCong.
left.

*****
H10 : not (Logic.eq A' D')
H9 : not (Logic.eq A D)
H7 : not (Logic.eq D' C')
H8 : not (Logic.eq A' D')
H5 : not (Logic.eq A D)
H6 : not (Logic.eq D C)
H2 : TCong D D D' D'
H4 : Bet A' D' C'
H3 : Bet A D C
H1 : Cong A D A' D'
H0 : Cong D C D' C'
H : Cong A D A' D'
A,A',C,C',D,D' : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
Cong C D C' D'
+++++
apply lemma_congruenceflip.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
elim (classic (B=C)).
intro.
assert (B'<>C').
assert (A'<>B').
apply TCong_neq_Cong in H0.
auto.
apply TCong_neq_Cong in H.
auto.
destruct (classic (A=D)).
assert (A'<>D').
apply TCong_neq_Cong in H1.
auto.
destruct (classic (B=D)).
subst.
assert (B'=D').
subst.
unfold TCong.
left.
apply lemma_congruenceflip.

*****
H10 : not (Logic.eq A' D')
H9 : not (Logic.eq A D)
H7 : not (Logic.eq D' C')
H8 : not (Logic.eq A' D')
H5 : not (Logic.eq A D)
H6 : not (Logic.eq D C)
H2 : TCong D D D' D'
H4 : Bet A' D' C'
H3 : Bet A D C
H1 : Cong A D A' D'
H0 : Cong D C D' C'
H : Cong A D A' D'
A,A',C,C',D,D' : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
Cong D C D' C'
+++++
assumption.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
elim (classic (B=C)).
intro.
assert (B'<>C').
assert (A'<>B').
apply TCong_neq_Cong in H0.
auto.
apply TCong_neq_Cong in H.
auto.
destruct (classic (A=D)).
assert (A'<>D').
apply TCong_neq_Cong in H1.
auto.
destruct (classic (B=D)).

*****
H11 : not (Logic.eq B D)
H10 : not (Logic.eq A' D')
H9 : not (Logic.eq A D)
H8 : not (Logic.eq A' B')
H7 : not (Logic.eq B' C')
H6 : not (Logic.eq B C)
H5 : not (Logic.eq A B)
H4 : Bet A' B' C'
H3 : Bet A B C
H2 : TCong B D B' D'
H1 : Cong A D A' D'
H0 : Cong B C B' C'
H : Cong A B A' B'
A,A',B,B',C,C',D,D' : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
TCong C D C' D'
+++++
apply TCong_neq_Cong in H2.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
elim (classic (B=C)).
intro.
assert (B'<>C').
assert (A'<>B').
apply TCong_neq_Cong in H0.
auto.
apply TCong_neq_Cong in H.
auto.
destruct (classic (A=D)).
assert (A'<>D').
apply TCong_neq_Cong in H1.
auto.
destruct (classic (B=D)).
apply TCong_neq_Cong in H2.

*****
H11 : not (Logic.eq B D)
H10 : not (Logic.eq A' D')
H9 : not (Logic.eq A D)
H8 : not (Logic.eq A' B')
H7 : not (Logic.eq B' C')
H6 : not (Logic.eq B C)
H5 : not (Logic.eq A B)
H4 : Bet A' B' C'
H3 : Bet A B C
H2 : Cong B D B' D'
H1 : Cong A D A' D'
H0 : Cong B C B' C'
H : Cong A B A' B'
A,A',B,B',C,C',D,D' : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
TCong C D C' D'
+++++
auto.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
elim (classic (B=C)).
intro.
assert (B'<>C').
assert (A'<>B').
apply TCong_neq_Cong in H0.
auto.
apply TCong_neq_Cong in H.
auto.
destruct (classic (A=D)).
assert (A'<>D').
apply TCong_neq_Cong in H1.
auto.
destruct (classic (B=D)).
apply TCong_neq_Cong in H2.
auto.

*****
H11 : not (Logic.eq B D)
H10 : not (Logic.eq A' D')
H9 : not (Logic.eq A D)
H8 : not (Logic.eq A' B')
H7 : not (Logic.eq B' C')
H6 : not (Logic.eq B C)
H5 : not (Logic.eq A B)
H4 : Bet A' B' C'
H3 : Bet A B C
H2 : Cong B D B' D'
H1 : Cong A D A' D'
H0 : Cong B C B' C'
H : Cong A B A' B'
A,A',B,B',C,C',D,D' : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
TCong C D C' D'
+++++
assert (Cong D C D' C').
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
elim (classic (B=C)).
intro.
assert (B'<>C').
assert (A'<>B').
apply TCong_neq_Cong in H0.
auto.
apply TCong_neq_Cong in H.
auto.
destruct (classic (A=D)).
assert (A'<>D').
apply TCong_neq_Cong in H1.
auto.
destruct (classic (B=D)).
apply TCong_neq_Cong in H2.
auto.
assert (Cong D C D' C').

*****
H11 : not (Logic.eq B D)
H10 : not (Logic.eq A' D')
H9 : not (Logic.eq A D)
H8 : not (Logic.eq A' B')
H7 : not (Logic.eq B' C')
H6 : not (Logic.eq B C)
H5 : not (Logic.eq A B)
H4 : Bet A' B' C'
H3 : Bet A B C
H2 : Cong B D B' D'
H1 : Cong A D A' D'
H0 : Cong B C B' C'
H : Cong A B A' B'
A,A',B,B',C,C',D,D' : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
Cong D C D' C'
+++++
apply (axiom_5_line A B C D A' B' C' D' H0 H1 H2).
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
elim (classic (B=C)).
intro.
assert (B'<>C').
assert (A'<>B').
apply TCong_neq_Cong in H0.
auto.
apply TCong_neq_Cong in H.
auto.
destruct (classic (A=D)).
assert (A'<>D').
apply TCong_neq_Cong in H1.
auto.
destruct (classic (B=D)).
apply TCong_neq_Cong in H2.
auto.
assert (Cong D C D' C').
apply (axiom_5_line A B C D A' B' C' D' H0 H1 H2).

*****
H11 : not (Logic.eq B D)
H10 : not (Logic.eq A' D')
H9 : not (Logic.eq A D)
H8 : not (Logic.eq A' B')
H7 : not (Logic.eq B' C')
H6 : not (Logic.eq B C)
H5 : not (Logic.eq A B)
H4 : Bet A' B' C'
H3 : Bet A B C
H2 : Cong B D B' D'
H1 : Cong A D A' D'
H0 : Cong B C B' C'
H : Cong A B A' B'
A,A',B,B',C,C',D,D' : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
BetS A B C
+++++
try assumption.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
elim (classic (B=C)).
intro.
assert (B'<>C').
assert (A'<>B').
apply TCong_neq_Cong in H0.
auto.
apply TCong_neq_Cong in H.
auto.
destruct (classic (A=D)).
assert (A'<>D').
apply TCong_neq_Cong in H1.
auto.
destruct (classic (B=D)).
apply TCong_neq_Cong in H2.
auto.
assert (Cong D C D' C').
apply (axiom_5_line A B C D A' B' C' D' H0 H1 H2).
try assumption.

*****
H11 : not (Logic.eq B D)
H10 : not (Logic.eq A' D')
H9 : not (Logic.eq A D)
H8 : not (Logic.eq A' B')
H7 : not (Logic.eq B' C')
H6 : not (Logic.eq B C)
H5 : not (Logic.eq A B)
H4 : Bet A' B' C'
H3 : Bet A B C
H2 : Cong B D B' D'
H1 : Cong A D A' D'
H0 : Cong B C B' C'
H : Cong A B A' B'
A,A',B,B',C,C',D,D' : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
BetS A B C
+++++
unfold Bet in *.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
elim (classic (B=C)).
intro.
assert (B'<>C').
assert (A'<>B').
apply TCong_neq_Cong in H0.
auto.
apply TCong_neq_Cong in H.
auto.
destruct (classic (A=D)).
assert (A'<>D').
apply TCong_neq_Cong in H1.
auto.
destruct (classic (B=D)).
apply TCong_neq_Cong in H2.
auto.
assert (Cong D C D' C').
apply (axiom_5_line A B C D A' B' C' D' H0 H1 H2).
try assumption.
unfold Bet in *.

*****
H11 : not (Logic.eq B D)
H10 : not (Logic.eq A' D')
H9 : not (Logic.eq A D)
H8 : not (Logic.eq A' B')
H7 : not (Logic.eq B' C')
H6 : not (Logic.eq B C)
H5 : not (Logic.eq A B)
H4 : or (BetS A' B' C') (or (Logic.eq A' B') (Logic.eq B' C'))
H3 : or (BetS A B C) (or (Logic.eq A B) (Logic.eq B C))
H2 : Cong B D B' D'
H1 : Cong A D A' D'
H0 : Cong B C B' C'
H : Cong A B A' B'
A,A',B,B',C,C',D,D' : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
BetS A B C
+++++
intuition.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
elim (classic (B=C)).
intro.
assert (B'<>C').
assert (A'<>B').
apply TCong_neq_Cong in H0.
auto.
apply TCong_neq_Cong in H.
auto.
destruct (classic (A=D)).
assert (A'<>D').
apply TCong_neq_Cong in H1.
auto.
destruct (classic (B=D)).
apply TCong_neq_Cong in H2.
auto.
assert (Cong D C D' C').
apply (axiom_5_line A B C D A' B' C' D' H0 H1 H2).

*****
H11 : not (Logic.eq B D)
H10 : not (Logic.eq A' D')
H9 : not (Logic.eq A D)
H8 : not (Logic.eq A' B')
H7 : not (Logic.eq B' C')
H6 : not (Logic.eq B C)
H5 : not (Logic.eq A B)
H4 : Bet A' B' C'
H3 : Bet A B C
H2 : Cong B D B' D'
H1 : Cong A D A' D'
H0 : Cong B C B' C'
H : Cong A B A' B'
A,A',B,B',C,C',D,D' : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
BetS A' B' C'
+++++
try assumption.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
elim (classic (B=C)).
intro.
assert (B'<>C').
assert (A'<>B').
apply TCong_neq_Cong in H0.
auto.
apply TCong_neq_Cong in H.
auto.
destruct (classic (A=D)).
assert (A'<>D').
apply TCong_neq_Cong in H1.
auto.
destruct (classic (B=D)).
apply TCong_neq_Cong in H2.
auto.
assert (Cong D C D' C').
apply (axiom_5_line A B C D A' B' C' D' H0 H1 H2).
try assumption.

*****
H11 : not (Logic.eq B D)
H10 : not (Logic.eq A' D')
H9 : not (Logic.eq A D)
H8 : not (Logic.eq A' B')
H7 : not (Logic.eq B' C')
H6 : not (Logic.eq B C)
H5 : not (Logic.eq A B)
H4 : Bet A' B' C'
H3 : Bet A B C
H2 : Cong B D B' D'
H1 : Cong A D A' D'
H0 : Cong B C B' C'
H : Cong A B A' B'
A,A',B,B',C,C',D,D' : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
BetS A' B' C'
+++++
unfold Bet in *.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
elim (classic (B=C)).
intro.
assert (B'<>C').
assert (A'<>B').
apply TCong_neq_Cong in H0.
auto.
apply TCong_neq_Cong in H.
auto.
destruct (classic (A=D)).
assert (A'<>D').
apply TCong_neq_Cong in H1.
auto.
destruct (classic (B=D)).
apply TCong_neq_Cong in H2.
auto.
assert (Cong D C D' C').
apply (axiom_5_line A B C D A' B' C' D' H0 H1 H2).
try assumption.
unfold Bet in *.

*****
H11 : not (Logic.eq B D)
H10 : not (Logic.eq A' D')
H9 : not (Logic.eq A D)
H8 : not (Logic.eq A' B')
H7 : not (Logic.eq B' C')
H6 : not (Logic.eq B C)
H5 : not (Logic.eq A B)
H4 : or (BetS A' B' C') (or (Logic.eq A' B') (Logic.eq B' C'))
H3 : or (BetS A B C) (or (Logic.eq A B) (Logic.eq B C))
H2 : Cong B D B' D'
H1 : Cong A D A' D'
H0 : Cong B C B' C'
H : Cong A B A' B'
A,A',B,B',C,C',D,D' : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
BetS A' B' C'
+++++
intuition.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
elim (classic (B=C)).
intro.
assert (B'<>C').
assert (A'<>B').
apply TCong_neq_Cong in H0.
auto.
apply TCong_neq_Cong in H.
auto.
destruct (classic (A=D)).
assert (A'<>D').
apply TCong_neq_Cong in H1.
auto.
destruct (classic (B=D)).
apply TCong_neq_Cong in H2.
auto.
assert (Cong D C D' C').
apply (axiom_5_line A B C D A' B' C' D' H0 H1 H2).

*****
H11 : not (Logic.eq B D)
H10 : not (Logic.eq A' D')
H9 : not (Logic.eq A D)
H8 : not (Logic.eq A' B')
H7 : not (Logic.eq B' C')
H6 : not (Logic.eq B C)
H5 : not (Logic.eq A B)
H4 : Bet A' B' C'
H3 : Bet A B C
H2 : Cong B D B' D'
H1 : Cong A D A' D'
H0 : Cong B C B' C'
H : Cong A B A' B'
A,A',B,B',C,C',D,D' : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
Cong A B A' B'
+++++
try assumption.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
elim (classic (B=C)).
intro.
assert (B'<>C').
assert (A'<>B').
apply TCong_neq_Cong in H0.
auto.
apply TCong_neq_Cong in H.
auto.
destruct (classic (A=D)).
assert (A'<>D').
apply TCong_neq_Cong in H1.
auto.
destruct (classic (B=D)).
apply TCong_neq_Cong in H2.
auto.
assert (Cong D C D' C').

*****
H12 : Cong D C D' C'
H11 : not (Logic.eq B D)
H10 : not (Logic.eq A' D')
H9 : not (Logic.eq A D)
H8 : not (Logic.eq A' B')
H7 : not (Logic.eq B' C')
H6 : not (Logic.eq B C)
H5 : not (Logic.eq A B)
H4 : Bet A' B' C'
H3 : Bet A B C
H2 : Cong B D B' D'
H1 : Cong A D A' D'
H0 : Cong B C B' C'
H : Cong A B A' B'
A,A',B,B',C,C',D,D' : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
TCong C D C' D'
+++++
unfold TCong.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
elim (classic (B=C)).
intro.
assert (B'<>C').
assert (A'<>B').
apply TCong_neq_Cong in H0.
auto.
apply TCong_neq_Cong in H.
auto.
destruct (classic (A=D)).
assert (A'<>D').
apply TCong_neq_Cong in H1.
auto.
destruct (classic (B=D)).
apply TCong_neq_Cong in H2.
auto.
assert (Cong D C D' C').
unfold TCong.

*****
H12 : Cong D C D' C'
H11 : not (Logic.eq B D)
H10 : not (Logic.eq A' D')
H9 : not (Logic.eq A D)
H8 : not (Logic.eq A' B')
H7 : not (Logic.eq B' C')
H6 : not (Logic.eq B C)
H5 : not (Logic.eq A B)
H4 : Bet A' B' C'
H3 : Bet A B C
H2 : Cong B D B' D'
H1 : Cong A D A' D'
H0 : Cong B C B' C'
H : Cong A B A' B'
A,A',B,B',C,C',D,D' : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
or (Cong C D C' D') (and (Logic.eq C D) (Logic.eq C' D'))
+++++
left.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
elim (classic (B=C)).
intro.
assert (B'<>C').
assert (A'<>B').
apply TCong_neq_Cong in H0.
auto.
apply TCong_neq_Cong in H.
auto.
destruct (classic (A=D)).
assert (A'<>D').
apply TCong_neq_Cong in H1.
auto.
destruct (classic (B=D)).
apply TCong_neq_Cong in H2.
auto.
assert (Cong D C D' C').
unfold TCong.
left.

*****
H12 : Cong D C D' C'
H11 : not (Logic.eq B D)
H10 : not (Logic.eq A' D')
H9 : not (Logic.eq A D)
H8 : not (Logic.eq A' B')
H7 : not (Logic.eq B' C')
H6 : not (Logic.eq B C)
H5 : not (Logic.eq A B)
H4 : Bet A' B' C'
H3 : Bet A B C
H2 : Cong B D B' D'
H1 : Cong A D A' D'
H0 : Cong B C B' C'
H : Cong A B A' B'
A,A',B,B',C,C',D,D' : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
Cong C D C' D'
+++++
apply (lemma_congruenceflip).
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
elim (classic (B=C)).
intro.
assert (B'<>C').
assert (A'<>B').
apply TCong_neq_Cong in H0.
auto.
apply TCong_neq_Cong in H.
auto.
destruct (classic (A=D)).
assert (A'<>D').
apply TCong_neq_Cong in H1.
auto.
destruct (classic (B=D)).
apply TCong_neq_Cong in H2.
auto.
assert (Cong D C D' C').
unfold TCong.
left.
apply (lemma_congruenceflip).

*****
H12 : Cong D C D' C'
H11 : not (Logic.eq B D)
H10 : not (Logic.eq A' D')
H9 : not (Logic.eq A D)
H8 : not (Logic.eq A' B')
H7 : not (Logic.eq B' C')
H6 : not (Logic.eq B C)
H5 : not (Logic.eq A B)
H4 : Bet A' B' C'
H3 : Bet A B C
H2 : Cong B D B' D'
H1 : Cong A D A' D'
H0 : Cong B C B' C'
H : Cong A B A' B'
A,A',B,B',C,C',D,D' : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
Cong D C D' C'
+++++
auto.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
elim (classic (B=C)).
intro.
assert (B'<>C').
assert (A'<>B').
apply TCong_neq_Cong in H0.
auto.
apply TCong_neq_Cong in H.
auto.
destruct (classic (A=D)).
assert (A'<>D').
apply TCong_neq_Cong in H1.
auto.
destruct (classic (B=D)).
apply TCong_neq_Cong in H2.

*****
H11 : not (Logic.eq B D)
H10 : not (Logic.eq A' D')
H9 : not (Logic.eq A D)
H8 : not (Logic.eq A' B')
H7 : not (Logic.eq B' C')
H6 : not (Logic.eq B C)
H5 : not (Logic.eq A B)
H4 : Bet A' B' C'
H3 : Bet A B C
H2 : TCong B D B' D'
H1 : Cong A D A' D'
H0 : Cong B C B' C'
H : Cong A B A' B'
A,A',B,B',C,C',D,D' : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
not (Logic.eq B D)
+++++
auto.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
elim (classic (B=C)).
intro.
assert (B'<>C').
assert (A'<>B').
apply TCong_neq_Cong in H0.
auto.
apply TCong_neq_Cong in H.
auto.
destruct (classic (A=D)).
assert (A'<>D').
apply TCong_neq_Cong in H1.

*****
H10 : not (Logic.eq A' D')
H9 : not (Logic.eq A D)
H8 : not (Logic.eq A' B')
H7 : not (Logic.eq B' C')
H6 : not (Logic.eq B C)
H5 : not (Logic.eq A B)
H4 : Bet A' B' C'
H3 : Bet A B C
H2 : TCong B D B' D'
H1 : TCong A D A' D'
H0 : Cong B C B' C'
H : Cong A B A' B'
A,A',B,B',C,C',D,D' : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
not (Logic.eq A D)
+++++
auto.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
elim (classic (B=C)).
intro.
assert (B'<>C').
assert (A'<>B').
apply TCong_neq_Cong in H0.
auto.
apply TCong_neq_Cong in H.

*****
H8 : not (Logic.eq A' B')
H7 : not (Logic.eq B' C')
H6 : not (Logic.eq B C)
H5 : not (Logic.eq A B)
H4 : Bet A' B' C'
H3 : Bet A B C
H2 : TCong B D B' D'
H1 : TCong A D A' D'
H0 : Cong B C B' C'
H : TCong A B A' B'
A,A',B,B',C,C',D,D' : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
not (Logic.eq A B)
+++++
auto.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
elim (classic (B=C)).
intro.
assert (B'<>C').
assert (A'<>B').
apply TCong_neq_Cong in H0.

*****
H8 : not (Logic.eq A' B')
H7 : not (Logic.eq B' C')
H6 : not (Logic.eq B C)
H5 : not (Logic.eq A B)
H4 : Bet A' B' C'
H3 : Bet A B C
H2 : TCong B D B' D'
H1 : TCong A D A' D'
H0 : TCong B C B' C'
H : TCong A B A' B'
A,A',B,B',C,C',D,D' : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
not (Logic.eq B C)
+++++
auto.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).

*****
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
forall (A B : Point) (_ : Bet A B A), Logic.eq A B
+++++
intros.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.

*****
H : Bet A B A
A,B : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
Logic.eq A B
+++++
unfold Bet in *.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
unfold Bet in *.

*****
H : or (BetS A B A) (or (Logic.eq A B) (Logic.eq B A))
A,B : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
Logic.eq A B
+++++
destruct H.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
unfold Bet in *.
destruct H.

*****
H : BetS A B A
A,B : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
Logic.eq A B
+++++
exfalso.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
unfold Bet in *.
destruct H.
exfalso.

*****
H : BetS A B A
A,B : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
False
+++++
apply (axiom_betweennessidentity A B).
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
unfold Bet in *.
destruct H.
exfalso.
apply (axiom_betweennessidentity A B).

*****
H : BetS A B A
A,B : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
BetS A B A
+++++
auto.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros.
unfold Bet in *.
destruct H.

*****
H : or (Logic.eq A B) (Logic.eq B A)
A,B : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
Logic.eq A B
+++++
intuition.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).

*****
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
forall (A B C P Q : Point) (_ : Bet A P C) (_ : Bet B Q C), ex (fun X : Point => and (Bet P X B) (Bet Q X A))
+++++
intros A B C P Q H H0.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros A B C P Q H H0.

*****
H0 : Bet B Q C
H : Bet A P C
A,B,C,P,Q : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
ex (fun X : Point => and (Bet P X B) (Bet Q X A))
+++++
destruct H.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros A B C P Q H H0.
destruct H.

*****
H0 : Bet B Q C
H : BetS A P C
A,B,C,P,Q : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
ex (fun X : Point => and (Bet P X B) (Bet Q X A))
+++++
destruct H0.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros A B C P Q H H0.
destruct H.
destruct H0.

*****
H0 : BetS B Q C
H : BetS A P C
A,B,C,P,Q : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
ex (fun X : Point => and (Bet P X B) (Bet Q X A))
+++++
elim (classic (Col A B C)).
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros A B C P Q H H0.
destruct H.
destruct H0.
elim (classic (Col A B C)).

*****
H0 : BetS B Q C
H : BetS A P C
A,B,C,P,Q : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
forall _ : Col A B C, ex (fun X : Point => and (Bet P X B) (Bet Q X A))
+++++
intro.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros A B C P Q H H0.
destruct H.
destruct H0.
elim (classic (Col A B C)).
intro.

*****
H1 : Col A B C
H0 : BetS B Q C
H : BetS A P C
A,B,C,P,Q : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
ex (fun X : Point => and (Bet P X B) (Bet Q X A))
+++++
unfold Col in *.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros A B C P Q H H0.
destruct H.
destruct H0.
elim (classic (Col A B C)).
intro.
unfold Col in *.

*****
H1 : or (eq A B)\n (or (eq A C)\n (or (eq B C) (or (BetS B A C) (or (BetS A B C) (BetS A C B)))))
H0 : BetS B Q C
H : BetS A P C
A,B,C,P,Q : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
ex (fun X : Point => and (Bet P X B) (Bet Q X A))
+++++
decompose [or] H1.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros A B C P Q H H0.
destruct H.
destruct H0.
elim (classic (Col A B C)).
intro.
unfold Col in *.
decompose [or] H1.

*****
H2 : eq A B
H1 : or (eq A B)\n (or (eq A C)\n (or (eq B C) (or (BetS B A C) (or (BetS A B C) (BetS A C B)))))
H0 : BetS B Q C
H : BetS A P C
A,B,C,P,Q : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
ex (fun X : Point => and (Bet P X B) (Bet Q X A))
+++++
clear H1.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros A B C P Q H H0.
destruct H.
destruct H0.
elim (classic (Col A B C)).
intro.
unfold Col in *.
decompose [or] H1.
clear H1.

*****
H2 : eq A B
H0 : BetS B Q C
H : BetS A P C
A,B,C,P,Q : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
ex (fun X : Point => and (Bet P X B) (Bet Q X A))
+++++
unfold eq in *.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros A B C P Q H H0.
destruct H.
destruct H0.
elim (classic (Col A B C)).
intro.
unfold Col in *.
decompose [or] H1.
clear H1.
unfold eq in *.

*****
H2 : Logic.eq A B
H0 : BetS B Q C
H : BetS A P C
A,B,C,P,Q : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
ex (fun X : Point => and (Bet P X B) (Bet Q X A))
+++++
subst.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros A B C P Q H H0.
destruct H.
destruct H0.
elim (classic (Col A B C)).
intro.
unfold Col in *.
decompose [or] H1.
clear H1.
unfold eq in *.
subst.

*****
H0 : BetS B Q C
H : BetS B P C
B,C,P,Q : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
ex (fun X : Point => and (Bet P X B) (Bet Q X B))
+++++
exists B.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros A B C P Q H H0.
destruct H.
destruct H0.
elim (classic (Col A B C)).
intro.
unfold Col in *.
decompose [or] H1.
clear H1.
unfold eq in *.
subst.
exists B.

*****
H0 : BetS B Q C
H : BetS B P C
B,C,P,Q : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
and (Bet P B B) (Bet Q B B)
+++++
split.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros A B C P Q H H0.
destruct H.
destruct H0.
elim (classic (Col A B C)).
intro.
unfold Col in *.
decompose [or] H1.
clear H1.
unfold eq in *.
subst.
exists B.
split.

*****
H0 : BetS B Q C
H : BetS B P C
B,C,P,Q : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
Bet P B B
+++++
unfold Bet.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros A B C P Q H H0.
destruct H.
destruct H0.
elim (classic (Col A B C)).
intro.
unfold Col in *.
decompose [or] H1.
clear H1.
unfold eq in *.
subst.
exists B.
split.
unfold Bet.

*****
H0 : BetS B Q C
H : BetS B P C
B,C,P,Q : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
or (BetS P B B) (or (Logic.eq P B) (Logic.eq B B))
+++++
auto.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros A B C P Q H H0.
destruct H.
destruct H0.
elim (classic (Col A B C)).
intro.
unfold Col in *.
decompose [or] H1.
clear H1.
unfold eq in *.
subst.
exists B.
split.

*****
H0 : BetS B Q C
H : BetS B P C
B,C,P,Q : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
Bet Q B B
+++++
unfold Bet.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros A B C P Q H H0.
destruct H.
destruct H0.
elim (classic (Col A B C)).
intro.
unfold Col in *.
decompose [or] H1.
clear H1.
unfold eq in *.
subst.
exists B.
split.
unfold Bet.

*****
H0 : BetS B Q C
H : BetS B P C
B,C,P,Q : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
or (BetS Q B B) (or (Logic.eq Q B) (Logic.eq B B))
+++++
auto.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros A B C P Q H H0.
destruct H.
destruct H0.
elim (classic (Col A B C)).
intro.
unfold Col in *.
decompose [or] H1.

*****
H3 : eq A C
H1 : or (eq A B)\n (or (eq A C)\n (or (eq B C) (or (BetS B A C) (or (BetS A B C) (BetS A C B)))))
H0 : BetS B Q C
H : BetS A P C
A,B,C,P,Q : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
ex (fun X : Point => and (Bet P X B) (Bet Q X A))
+++++
clear H1.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros A B C P Q H H0.
destruct H.
destruct H0.
elim (classic (Col A B C)).
intro.
unfold Col in *.
decompose [or] H1.
clear H1.

*****
H3 : eq A C
H0 : BetS B Q C
H : BetS A P C
A,B,C,P,Q : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
ex (fun X : Point => and (Bet P X B) (Bet Q X A))
+++++
unfold eq in *.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros A B C P Q H H0.
destruct H.
destruct H0.
elim (classic (Col A B C)).
intro.
unfold Col in *.
decompose [or] H1.
clear H1.
unfold eq in *.

*****
H3 : Logic.eq A C
H0 : BetS B Q C
H : BetS A P C
A,B,C,P,Q : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
ex (fun X : Point => and (Bet P X B) (Bet Q X A))
+++++
subst.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros A B C P Q H H0.
destruct H.
destruct H0.
elim (classic (Col A B C)).
intro.
unfold Col in *.
decompose [or] H1.
clear H1.
unfold eq in *.
subst.

*****
H0 : BetS B Q C
H : BetS C P C
B,C,P,Q : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
ex (fun X : Point => and (Bet P X B) (Bet Q X C))
+++++
exfalso.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros A B C P Q H H0.
destruct H.
destruct H0.
elim (classic (Col A B C)).
intro.
unfold Col in *.
decompose [or] H1.
clear H1.
unfold eq in *.
subst.
exfalso.

*****
H0 : BetS B Q C
H : BetS C P C
B,C,P,Q : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
False
+++++
apply lemma_betweennotequal in H.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros A B C P Q H H0.
destruct H.
destruct H0.
elim (classic (Col A B C)).
intro.
unfold Col in *.
decompose [or] H1.
clear H1.
unfold eq in *.
subst.
exfalso.
apply lemma_betweennotequal in H.

*****
H0 : BetS B Q C
H : and (neq P C) (and (neq C P) (neq C C))
B,C,P,Q : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
False
+++++
unfold neq in *.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros A B C P Q H H0.
destruct H.
destruct H0.
elim (classic (Col A B C)).
intro.
unfold Col in *.
decompose [or] H1.
clear H1.
unfold eq in *.
subst.
exfalso.
apply lemma_betweennotequal in H.
unfold neq in *.

*****
H0 : BetS B Q C
H : and (not (eq P C)) (and (not (eq C P)) (not (eq C C)))
B,C,P,Q : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
False
+++++
unfold eq in *.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros A B C P Q H H0.
destruct H.
destruct H0.
elim (classic (Col A B C)).
intro.
unfold Col in *.
decompose [or] H1.
clear H1.
unfold eq in *.
subst.
exfalso.
apply lemma_betweennotequal in H.
unfold neq in *.
unfold eq in *.

*****
H0 : BetS B Q C
H : and (not (Logic.eq P C))\n (and (not (Logic.eq C P)) (not (Logic.eq C C)))
B,C,P,Q : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
False
+++++
spliter.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros A B C P Q H H0.
destruct H.
destruct H0.
elim (classic (Col A B C)).
intro.
unfold Col in *.
decompose [or] H1.
clear H1.
unfold eq in *.
subst.
exfalso.
apply lemma_betweennotequal in H.
unfold neq in *.
unfold eq in *.
spliter.

*****
H0 : BetS B Q C
H2 : not (Logic.eq C C)
H1 : not (Logic.eq C P)
H : not (Logic.eq P C)
B,C,P,Q : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
False
+++++
intuition.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros A B C P Q H H0.
destruct H.
destruct H0.
elim (classic (Col A B C)).
intro.
unfold Col in *.
decompose [or] H1.

*****
H2 : eq B C
H1 : or (eq A B)\n (or (eq A C)\n (or (eq B C) (or (BetS B A C) (or (BetS A B C) (BetS A C B)))))
H0 : BetS B Q C
H : BetS A P C
A,B,C,P,Q : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
ex (fun X : Point => and (Bet P X B) (Bet Q X A))
+++++
clear H1.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros A B C P Q H H0.
destruct H.
destruct H0.
elim (classic (Col A B C)).
intro.
unfold Col in *.
decompose [or] H1.
clear H1.

*****
H2 : eq B C
H0 : BetS B Q C
H : BetS A P C
A,B,C,P,Q : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
ex (fun X : Point => and (Bet P X B) (Bet Q X A))
+++++
unfold eq in *.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros A B C P Q H H0.
destruct H.
destruct H0.
elim (classic (Col A B C)).
intro.
unfold Col in *.
decompose [or] H1.
clear H1.
unfold eq in *.

*****
H2 : Logic.eq B C
H0 : BetS B Q C
H : BetS A P C
A,B,C,P,Q : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
ex (fun X : Point => and (Bet P X B) (Bet Q X A))
+++++
subst.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros A B C P Q H H0.
destruct H.
destruct H0.
elim (classic (Col A B C)).
intro.
unfold Col in *.
decompose [or] H1.
clear H1.
unfold eq in *.
subst.

*****
H0 : BetS C Q C
H : BetS A P C
A,C,P,Q : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
ex (fun X : Point => and (Bet P X C) (Bet Q X A))
+++++
exfalso.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros A B C P Q H H0.
destruct H.
destruct H0.
elim (classic (Col A B C)).
intro.
unfold Col in *.
decompose [or] H1.
clear H1.
unfold eq in *.
subst.
exfalso.

*****
H0 : BetS C Q C
H : BetS A P C
A,C,P,Q : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
False
+++++
apply lemma_betweennotequal in H0.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros A B C P Q H H0.
destruct H.
destruct H0.
elim (classic (Col A B C)).
intro.
unfold Col in *.
decompose [or] H1.
clear H1.
unfold eq in *.
subst.
exfalso.
apply lemma_betweennotequal in H0.

*****
H0 : and (neq Q C) (and (neq C Q) (neq C C))
H : BetS A P C
A,C,P,Q : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
False
+++++
unfold neq in *.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros A B C P Q H H0.
destruct H.
destruct H0.
elim (classic (Col A B C)).
intro.
unfold Col in *.
decompose [or] H1.
clear H1.
unfold eq in *.
subst.
exfalso.
apply lemma_betweennotequal in H0.
unfold neq in *.

*****
H0 : and (not (eq Q C)) (and (not (eq C Q)) (not (eq C C)))
H : BetS A P C
A,C,P,Q : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
False
+++++
unfold eq in *.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros A B C P Q H H0.
destruct H.
destruct H0.
elim (classic (Col A B C)).
intro.
unfold Col in *.
decompose [or] H1.
clear H1.
unfold eq in *.
subst.
exfalso.
apply lemma_betweennotequal in H0.
unfold neq in *.
unfold eq in *.

*****
H0 : and (not (Logic.eq Q C))\n (and (not (Logic.eq C Q)) (not (Logic.eq C C)))
H : BetS A P C
A,C,P,Q : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
False
+++++
intuition.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros A B C P Q H H0.
destruct H.
destruct H0.
elim (classic (Col A B C)).
intro.
unfold Col in *.
decompose [or] H1.

*****
H3 : BetS B A C
H1 : or (eq A B)\n (or (eq A C)\n (or (eq B C) (or (BetS B A C) (or (BetS A B C) (BetS A C B)))))
H0 : BetS B Q C
H : BetS A P C
A,B,C,P,Q : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
ex (fun X : Point => and (Bet P X B) (Bet Q X A))
+++++
clear H1.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros A B C P Q H H0.
destruct H.
destruct H0.
elim (classic (Col A B C)).
intro.
unfold Col in *.
decompose [or] H1.
clear H1.

*****
H3 : BetS B A C
H0 : BetS B Q C
H : BetS A P C
A,B,C,P,Q : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
ex (fun X : Point => and (Bet P X B) (Bet Q X A))
+++++
unfold eq in *.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros A B C P Q H H0.
destruct H.
destruct H0.
elim (classic (Col A B C)).
intro.
unfold Col in *.
decompose [or] H1.
clear H1.
unfold eq in *.

*****
H3 : BetS B A C
H0 : BetS B Q C
H : BetS A P C
A,B,C,P,Q : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
ex (fun X : Point => and (Bet P X B) (Bet Q X A))
+++++
subst.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros A B C P Q H H0.
destruct H.
destruct H0.
elim (classic (Col A B C)).
intro.
unfold Col in *.
decompose [or] H1.
clear H1.
unfold eq in *.
subst.

*****
H3 : BetS B A C
H0 : BetS B Q C
H : BetS A P C
A,B,C,P,Q : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
ex (fun X : Point => and (Bet P X B) (Bet Q X A))
+++++
exists A.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros A B C P Q H H0.
destruct H.
destruct H0.
elim (classic (Col A B C)).
intro.
unfold Col in *.
decompose [or] H1.
clear H1.
unfold eq in *.
subst.
exists A.

*****
H3 : BetS B A C
H0 : BetS B Q C
H : BetS A P C
A,B,C,P,Q : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
and (Bet P A B) (Bet Q A A)
+++++
split.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros A B C P Q H H0.
destruct H.
destruct H0.
elim (classic (Col A B C)).
intro.
unfold Col in *.
decompose [or] H1.
clear H1.
unfold eq in *.
subst.
exists A.
split.

*****
H3 : BetS B A C
H0 : BetS B Q C
H : BetS A P C
A,B,C,P,Q : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
Bet P A B
+++++
unfold Bet.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros A B C P Q H H0.
destruct H.
destruct H0.
elim (classic (Col A B C)).
intro.
unfold Col in *.
decompose [or] H1.
clear H1.
unfold eq in *.
subst.
exists A.
split.
unfold Bet.

*****
H3 : BetS B A C
H0 : BetS B Q C
H : BetS A P C
A,B,C,P,Q : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
or (BetS P A B) (or (Logic.eq P A) (Logic.eq A B))
+++++
left.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros A B C P Q H H0.
destruct H.
destruct H0.
elim (classic (Col A B C)).
intro.
unfold Col in *.
decompose [or] H1.
clear H1.
unfold eq in *.
subst.
exists A.
split.
unfold Bet.
left.

*****
H3 : BetS B A C
H0 : BetS B Q C
H : BetS A P C
A,B,C,P,Q : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
BetS P A B
+++++
eauto using lemma_3_6a, axiom_betweennesssymmetry.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros A B C P Q H H0.
destruct H.
destruct H0.
elim (classic (Col A B C)).
intro.
unfold Col in *.
decompose [or] H1.
clear H1.
unfold eq in *.
subst.
exists A.
split.

*****
H3 : BetS B A C
H0 : BetS B Q C
H : BetS A P C
A,B,C,P,Q : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
Bet Q A A
+++++
unfold Bet.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros A B C P Q H H0.
destruct H.
destruct H0.
elim (classic (Col A B C)).
intro.
unfold Col in *.
decompose [or] H1.
clear H1.
unfold eq in *.
subst.
exists A.
split.
unfold Bet.

*****
H3 : BetS B A C
H0 : BetS B Q C
H : BetS A P C
A,B,C,P,Q : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
or (BetS Q A A) (or (Logic.eq Q A) (Logic.eq A A))
+++++
auto.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros A B C P Q H H0.
destruct H.
destruct H0.
elim (classic (Col A B C)).
intro.
unfold Col in *.
decompose [or] H1.

*****
H2 : BetS A B C
H1 : or (eq A B)\n (or (eq A C)\n (or (eq B C) (or (BetS B A C) (or (BetS A B C) (BetS A C B)))))
H0 : BetS B Q C
H : BetS A P C
A,B,C,P,Q : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
ex (fun X : Point => and (Bet P X B) (Bet Q X A))
+++++
clear H1.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros A B C P Q H H0.
destruct H.
destruct H0.
elim (classic (Col A B C)).
intro.
unfold Col in *.
decompose [or] H1.
clear H1.

*****
H2 : BetS A B C
H0 : BetS B Q C
H : BetS A P C
A,B,C,P,Q : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
ex (fun X : Point => and (Bet P X B) (Bet Q X A))
+++++
unfold eq in *.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros A B C P Q H H0.
destruct H.
destruct H0.
elim (classic (Col A B C)).
intro.
unfold Col in *.
decompose [or] H1.
clear H1.
unfold eq in *.

*****
H2 : BetS A B C
H0 : BetS B Q C
H : BetS A P C
A,B,C,P,Q : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
ex (fun X : Point => and (Bet P X B) (Bet Q X A))
+++++
subst.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros A B C P Q H H0.
destruct H.
destruct H0.
elim (classic (Col A B C)).
intro.
unfold Col in *.
decompose [or] H1.
clear H1.
unfold eq in *.
subst.

*****
H2 : BetS A B C
H0 : BetS B Q C
H : BetS A P C
A,B,C,P,Q : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
ex (fun X : Point => and (Bet P X B) (Bet Q X A))
+++++
exists B.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros A B C P Q H H0.
destruct H.
destruct H0.
elim (classic (Col A B C)).
intro.
unfold Col in *.
decompose [or] H1.
clear H1.
unfold eq in *.
subst.
exists B.

*****
H2 : BetS A B C
H0 : BetS B Q C
H : BetS A P C
A,B,C,P,Q : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
and (Bet P B B) (Bet Q B A)
+++++
split.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros A B C P Q H H0.
destruct H.
destruct H0.
elim (classic (Col A B C)).
intro.
unfold Col in *.
decompose [or] H1.
clear H1.
unfold eq in *.
subst.
exists B.
split.

*****
H2 : BetS A B C
H0 : BetS B Q C
H : BetS A P C
A,B,C,P,Q : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
Bet P B B
+++++
unfold Bet.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros A B C P Q H H0.
destruct H.
destruct H0.
elim (classic (Col A B C)).
intro.
unfold Col in *.
decompose [or] H1.
clear H1.
unfold eq in *.
subst.
exists B.
split.
unfold Bet.

*****
H2 : BetS A B C
H0 : BetS B Q C
H : BetS A P C
A,B,C,P,Q : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
or (BetS P B B) (or (Logic.eq P B) (Logic.eq B B))
+++++
auto.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros A B C P Q H H0.
destruct H.
destruct H0.
elim (classic (Col A B C)).
intro.
unfold Col in *.
decompose [or] H1.
clear H1.
unfold eq in *.
subst.
exists B.
split.

*****
H2 : BetS A B C
H0 : BetS B Q C
H : BetS A P C
A,B,C,P,Q : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
Bet Q B A
+++++
unfold Bet.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros A B C P Q H H0.
destruct H.
destruct H0.
elim (classic (Col A B C)).
intro.
unfold Col in *.
decompose [or] H1.
clear H1.
unfold eq in *.
subst.
exists B.
split.
unfold Bet.

*****
H2 : BetS A B C
H0 : BetS B Q C
H : BetS A P C
A,B,C,P,Q : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
or (BetS Q B A) (or (Logic.eq Q B) (Logic.eq B A))
+++++
left.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros A B C P Q H H0.
destruct H.
destruct H0.
elim (classic (Col A B C)).
intro.
unfold Col in *.
decompose [or] H1.
clear H1.
unfold eq in *.
subst.
exists B.
split.
unfold Bet.
left.

*****
H2 : BetS A B C
H0 : BetS B Q C
H : BetS A P C
A,B,C,P,Q : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
BetS Q B A
+++++
eauto using lemma_3_6a, axiom_betweennesssymmetry.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros A B C P Q H H0.
destruct H.
destruct H0.
elim (classic (Col A B C)).
intro.
unfold Col in *.
decompose [or] H1.

*****
H2 : BetS A C B
H1 : or (eq A B)\n (or (eq A C)\n (or (eq B C) (or (BetS B A C) (or (BetS A B C) (BetS A C B)))))
H0 : BetS B Q C
H : BetS A P C
A,B,C,P,Q : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
ex (fun X : Point => and (Bet P X B) (Bet Q X A))
+++++
clear H1.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros A B C P Q H H0.
destruct H.
destruct H0.
elim (classic (Col A B C)).
intro.
unfold Col in *.
decompose [or] H1.
clear H1.

*****
H2 : BetS A C B
H0 : BetS B Q C
H : BetS A P C
A,B,C,P,Q : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
ex (fun X : Point => and (Bet P X B) (Bet Q X A))
+++++
unfold eq in *.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros A B C P Q H H0.
destruct H.
destruct H0.
elim (classic (Col A B C)).
intro.
unfold Col in *.
decompose [or] H1.
clear H1.
unfold eq in *.

*****
H2 : BetS A C B
H0 : BetS B Q C
H : BetS A P C
A,B,C,P,Q : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
ex (fun X : Point => and (Bet P X B) (Bet Q X A))
+++++
subst.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros A B C P Q H H0.
destruct H.
destruct H0.
elim (classic (Col A B C)).
intro.
unfold Col in *.
decompose [or] H1.
clear H1.
unfold eq in *.
subst.

*****
H2 : BetS A C B
H0 : BetS B Q C
H : BetS A P C
A,B,C,P,Q : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
ex (fun X : Point => and (Bet P X B) (Bet Q X A))
+++++
exists C.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros A B C P Q H H0.
destruct H.
destruct H0.
elim (classic (Col A B C)).
intro.
unfold Col in *.
decompose [or] H1.
clear H1.
unfold eq in *.
subst.
exists C.

*****
H2 : BetS A C B
H0 : BetS B Q C
H : BetS A P C
A,B,C,P,Q : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
and (Bet P C B) (Bet Q C A)
+++++
split.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros A B C P Q H H0.
destruct H.
destruct H0.
elim (classic (Col A B C)).
intro.
unfold Col in *.
decompose [or] H1.
clear H1.
unfold eq in *.
subst.
exists C.
split.

*****
H2 : BetS A C B
H0 : BetS B Q C
H : BetS A P C
A,B,C,P,Q : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
Bet P C B
+++++
unfold Bet.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros A B C P Q H H0.
destruct H.
destruct H0.
elim (classic (Col A B C)).
intro.
unfold Col in *.
decompose [or] H1.
clear H1.
unfold eq in *.
subst.
exists C.
split.
unfold Bet.

*****
H2 : BetS A C B
H0 : BetS B Q C
H : BetS A P C
A,B,C,P,Q : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
or (BetS P C B) (or (Logic.eq P C) (Logic.eq C B))
+++++
left.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros A B C P Q H H0.
destruct H.
destruct H0.
elim (classic (Col A B C)).
intro.
unfold Col in *.
decompose [or] H1.
clear H1.
unfold eq in *.
subst.
exists C.
split.
unfold Bet.
left.

*****
H2 : BetS A C B
H0 : BetS B Q C
H : BetS A P C
A,B,C,P,Q : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
BetS P C B
+++++
eauto using lemma_3_6a, axiom_betweennesssymmetry.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros A B C P Q H H0.
destruct H.
destruct H0.
elim (classic (Col A B C)).
intro.
unfold Col in *.
decompose [or] H1.
clear H1.
unfold eq in *.
subst.
exists C.
split.

*****
H2 : BetS A C B
H0 : BetS B Q C
H : BetS A P C
A,B,C,P,Q : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
Bet Q C A
+++++
unfold Bet.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros A B C P Q H H0.
destruct H.
destruct H0.
elim (classic (Col A B C)).
intro.
unfold Col in *.
decompose [or] H1.
clear H1.
unfold eq in *.
subst.
exists C.
split.
unfold Bet.

*****
H2 : BetS A C B
H0 : BetS B Q C
H : BetS A P C
A,B,C,P,Q : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
or (BetS Q C A) (or (Logic.eq Q C) (Logic.eq C A))
+++++
left.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros A B C P Q H H0.
destruct H.
destruct H0.
elim (classic (Col A B C)).
intro.
unfold Col in *.
decompose [or] H1.
clear H1.
unfold eq in *.
subst.
exists C.
split.
unfold Bet.
left.

*****
H2 : BetS A C B
H0 : BetS B Q C
H : BetS A P C
A,B,C,P,Q : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
BetS Q C A
+++++
eauto using lemma_3_6a, axiom_betweennesssymmetry.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros A B C P Q H H0.
destruct H.
destruct H0.
elim (classic (Col A B C)).

*****
H0 : BetS B Q C
H : BetS A P C
A,B,C,P,Q : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
forall _ : not (Col A B C), ex (fun X : Point => and (Bet P X B) (Bet Q X A))
+++++
intro.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros A B C P Q H H0.
destruct H.
destruct H0.
elim (classic (Col A B C)).
intro.

*****
H1 : not (Col A B C)
H0 : BetS B Q C
H : BetS A P C
A,B,C,P,Q : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
ex (fun X : Point => and (Bet P X B) (Bet Q X A))
+++++
assert (T:exists X : Point, BetS A X Q /\ BetS B X P).
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros A B C P Q H H0.
destruct H.
destruct H0.
elim (classic (Col A B C)).
intro.
assert (T:exists X : Point, BetS A X Q /\\ BetS B X P).

*****
H1 : not (Col A B C)
H0 : BetS B Q C
H : BetS A P C
A,B,C,P,Q : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
ex (fun X : Point => and (BetS A X Q) (BetS B X P))
+++++
apply (postulate_Pasch_inner A B C P Q H H0).
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros A B C P Q H H0.
destruct H.
destruct H0.
elim (classic (Col A B C)).
intro.
assert (T:exists X : Point, BetS A X Q /\\ BetS B X P).
apply (postulate_Pasch_inner A B C P Q H H0).

*****
H1 : not (Col A B C)
H0 : BetS B Q C
H : BetS A P C
A,B,C,P,Q : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
nCol A C B
+++++
unfold nCol.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros A B C P Q H H0.
destruct H.
destruct H0.
elim (classic (Col A B C)).
intro.
assert (T:exists X : Point, BetS A X Q /\\ BetS B X P).
apply (postulate_Pasch_inner A B C P Q H H0).
unfold nCol.

*****
H1 : not (Col A B C)
H0 : BetS B Q C
H : BetS A P C
A,B,C,P,Q : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
and (neq A C) (and (neq A B) (and (neq C B) (and (not (BetS A C B)) (and (not (BetS A B C)) (not (BetS C A B))))))
+++++
unfold neq.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros A B C P Q H H0.
destruct H.
destruct H0.
elim (classic (Col A B C)).
intro.
assert (T:exists X : Point, BetS A X Q /\\ BetS B X P).
apply (postulate_Pasch_inner A B C P Q H H0).
unfold nCol.
unfold neq.

*****
H1 : not (Col A B C)
H0 : BetS B Q C
H : BetS A P C
A,B,C,P,Q : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
and (not (eq A C)) (and (not (eq A B)) (and (not (eq C B)) (and (not (BetS A C B)) (and (not (BetS A B C)) (not (BetS C A B))))))
+++++
unfold Col in *.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros A B C P Q H H0.
destruct H.
destruct H0.
elim (classic (Col A B C)).
intro.
assert (T:exists X : Point, BetS A X Q /\\ BetS B X P).
apply (postulate_Pasch_inner A B C P Q H H0).
unfold nCol.
unfold neq.
unfold Col in *.

*****
H1 : not\n (or (eq A B)\n (or (eq A C)\n (or (eq B C) (or (BetS B A C) (or (BetS A B C) (BetS A C B))))))
H0 : BetS B Q C
H : BetS A P C
A,B,C,P,Q : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
and (not (eq A C)) (and (not (eq A B)) (and (not (eq C B)) (and (not (BetS A C B)) (and (not (BetS A B C)) (not (BetS C A B))))))
+++++
assert (BetS B A C <-> BetS C A B).
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros A B C P Q H H0.
destruct H.
destruct H0.
elim (classic (Col A B C)).
intro.
assert (T:exists X : Point, BetS A X Q /\\ BetS B X P).
apply (postulate_Pasch_inner A B C P Q H H0).
unfold nCol.
unfold neq.
unfold Col in *.
assert (BetS B A C <-> BetS C A B).

*****
H1 : not\n (or (eq A B)\n (or (eq A C)\n (or (eq B C) (or (BetS B A C) (or (BetS A B C) (BetS A C B))))))
H0 : BetS B Q C
H : BetS A P C
A,B,C,P,Q : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
iff (BetS B A C) (BetS C A B)
+++++
split.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros A B C P Q H H0.
destruct H.
destruct H0.
elim (classic (Col A B C)).
intro.
assert (T:exists X : Point, BetS A X Q /\\ BetS B X P).
apply (postulate_Pasch_inner A B C P Q H H0).
unfold nCol.
unfold neq.
unfold Col in *.
assert (BetS B A C <-> BetS C A B).
split.

*****
H1 : not\n (or (eq A B)\n (or (eq A C)\n (or (eq B C) (or (BetS B A C) (or (BetS A B C) (BetS A C B))))))
H0 : BetS B Q C
H : BetS A P C
A,B,C,P,Q : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
forall _ : BetS B A C, BetS C A B
+++++
intro.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros A B C P Q H H0.
destruct H.
destruct H0.
elim (classic (Col A B C)).
intro.
assert (T:exists X : Point, BetS A X Q /\\ BetS B X P).
apply (postulate_Pasch_inner A B C P Q H H0).
unfold nCol.
unfold neq.
unfold Col in *.
assert (BetS B A C <-> BetS C A B).
split.
intro.

*****
H2 : BetS B A C
H1 : not\n (or (eq A B)\n (or (eq A C)\n (or (eq B C) (or (BetS B A C) (or (BetS A B C) (BetS A C B))))))
H0 : BetS B Q C
H : BetS A P C
A,B,C,P,Q : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
BetS C A B
+++++
apply axiom_betweennesssymmetry.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros A B C P Q H H0.
destruct H.
destruct H0.
elim (classic (Col A B C)).
intro.
assert (T:exists X : Point, BetS A X Q /\\ BetS B X P).
apply (postulate_Pasch_inner A B C P Q H H0).
unfold nCol.
unfold neq.
unfold Col in *.
assert (BetS B A C <-> BetS C A B).
split.
intro.
apply axiom_betweennesssymmetry.

*****
H2 : BetS B A C
H1 : not\n (or (eq A B)\n (or (eq A C)\n (or (eq B C) (or (BetS B A C) (or (BetS A B C) (BetS A C B))))))
H0 : BetS B Q C
H : BetS A P C
A,B,C,P,Q : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
BetS B A C
+++++
auto.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros A B C P Q H H0.
destruct H.
destruct H0.
elim (classic (Col A B C)).
intro.
assert (T:exists X : Point, BetS A X Q /\\ BetS B X P).
apply (postulate_Pasch_inner A B C P Q H H0).
unfold nCol.
unfold neq.
unfold Col in *.
assert (BetS B A C <-> BetS C A B).
split.

*****
H1 : not\n (or (eq A B)\n (or (eq A C)\n (or (eq B C) (or (BetS B A C) (or (BetS A B C) (BetS A C B))))))
H0 : BetS B Q C
H : BetS A P C
A,B,C,P,Q : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
forall _ : BetS C A B, BetS B A C
+++++
intro.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros A B C P Q H H0.
destruct H.
destruct H0.
elim (classic (Col A B C)).
intro.
assert (T:exists X : Point, BetS A X Q /\\ BetS B X P).
apply (postulate_Pasch_inner A B C P Q H H0).
unfold nCol.
unfold neq.
unfold Col in *.
assert (BetS B A C <-> BetS C A B).
split.
intro.

*****
H2 : BetS C A B
H1 : not\n (or (eq A B)\n (or (eq A C)\n (or (eq B C) (or (BetS B A C) (or (BetS A B C) (BetS A C B))))))
H0 : BetS B Q C
H : BetS A P C
A,B,C,P,Q : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
BetS B A C
+++++
apply axiom_betweennesssymmetry.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros A B C P Q H H0.
destruct H.
destruct H0.
elim (classic (Col A B C)).
intro.
assert (T:exists X : Point, BetS A X Q /\\ BetS B X P).
apply (postulate_Pasch_inner A B C P Q H H0).
unfold nCol.
unfold neq.
unfold Col in *.
assert (BetS B A C <-> BetS C A B).
split.
intro.
apply axiom_betweennesssymmetry.

*****
H2 : BetS C A B
H1 : not\n (or (eq A B)\n (or (eq A C)\n (or (eq B C) (or (BetS B A C) (or (BetS A B C) (BetS A C B))))))
H0 : BetS B Q C
H : BetS A P C
A,B,C,P,Q : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
BetS C A B
+++++
auto.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros A B C P Q H H0.
destruct H.
destruct H0.
elim (classic (Col A B C)).
intro.
assert (T:exists X : Point, BetS A X Q /\\ BetS B X P).
apply (postulate_Pasch_inner A B C P Q H H0).
unfold nCol.
unfold neq.
unfold Col in *.
assert (BetS B A C <-> BetS C A B).

*****
H2 : iff (BetS B A C) (BetS C A B)
H1 : not\n (or (eq A B)\n (or (eq A C)\n (or (eq B C) (or (BetS B A C) (or (BetS A B C) (BetS A C B))))))
H0 : BetS B Q C
H : BetS A P C
A,B,C,P,Q : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
and (not (eq A C)) (and (not (eq A B)) (and (not (eq C B)) (and (not (BetS A C B)) (and (not (BetS A B C)) (not (BetS C A B))))))
+++++
idtac.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros A B C P Q H H0.
destruct H.
destruct H0.
elim (classic (Col A B C)).
intro.
assert (T:exists X : Point, BetS A X Q /\\ BetS B X P).
apply (postulate_Pasch_inner A B C P Q H H0).
unfold nCol.
unfold neq.
unfold Col in *.
assert (BetS B A C <-> BetS C A B).
idtac.

*****
H2 : iff (BetS B A C) (BetS C A B)
H1 : not\n (or (eq A B)\n (or (eq A C)\n (or (eq B C) (or (BetS B A C) (or (BetS A B C) (BetS A C B))))))
H0 : BetS B Q C
H : BetS A P C
A,B,C,P,Q : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
and (not (eq A C)) (and (not (eq A B)) (and (not (eq C B)) (and (not (BetS A C B)) (and (not (BetS A B C)) (not (BetS C A B))))))
+++++
assert (eq C B <-> eq B C).
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros A B C P Q H H0.
destruct H.
destruct H0.
elim (classic (Col A B C)).
intro.
assert (T:exists X : Point, BetS A X Q /\\ BetS B X P).
apply (postulate_Pasch_inner A B C P Q H H0).
unfold nCol.
unfold neq.
unfold Col in *.
assert (BetS B A C <-> BetS C A B).
idtac.
assert (eq C B <-> eq B C).

*****
H2 : iff (BetS B A C) (BetS C A B)
H1 : not\n (or (eq A B)\n (or (eq A C)\n (or (eq B C) (or (BetS B A C) (or (BetS A B C) (BetS A C B))))))
H0 : BetS B Q C
H : BetS A P C
A,B,C,P,Q : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
iff (eq C B) (eq B C)
+++++
split.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros A B C P Q H H0.
destruct H.
destruct H0.
elim (classic (Col A B C)).
intro.
assert (T:exists X : Point, BetS A X Q /\\ BetS B X P).
apply (postulate_Pasch_inner A B C P Q H H0).
unfold nCol.
unfold neq.
unfold Col in *.
assert (BetS B A C <-> BetS C A B).
idtac.
assert (eq C B <-> eq B C).
split.

*****
H2 : iff (BetS B A C) (BetS C A B)
H1 : not\n (or (eq A B)\n (or (eq A C)\n (or (eq B C) (or (BetS B A C) (or (BetS A B C) (BetS A C B))))))
H0 : BetS B Q C
H : BetS A P C
A,B,C,P,Q : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
forall _ : eq C B, eq B C
+++++
unfold eq.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros A B C P Q H H0.
destruct H.
destruct H0.
elim (classic (Col A B C)).
intro.
assert (T:exists X : Point, BetS A X Q /\\ BetS B X P).
apply (postulate_Pasch_inner A B C P Q H H0).
unfold nCol.
unfold neq.
unfold Col in *.
assert (BetS B A C <-> BetS C A B).
idtac.
assert (eq C B <-> eq B C).
split.
unfold eq.

*****
H2 : iff (BetS B A C) (BetS C A B)
H1 : not\n (or (eq A B)\n (or (eq A C)\n (or (eq B C) (or (BetS B A C) (or (BetS A B C) (BetS A C B))))))
H0 : BetS B Q C
H : BetS A P C
A,B,C,P,Q : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
forall _ : Logic.eq C B, Logic.eq B C
+++++
intro.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros A B C P Q H H0.
destruct H.
destruct H0.
elim (classic (Col A B C)).
intro.
assert (T:exists X : Point, BetS A X Q /\\ BetS B X P).
apply (postulate_Pasch_inner A B C P Q H H0).
unfold nCol.
unfold neq.
unfold Col in *.
assert (BetS B A C <-> BetS C A B).
idtac.
assert (eq C B <-> eq B C).
split.
unfold eq.
intro.

*****
H3 : Logic.eq C B
H2 : iff (BetS B A C) (BetS C A B)
H1 : not\n (or (eq A B)\n (or (eq A C)\n (or (eq B C) (or (BetS B A C) (or (BetS A B C) (BetS A C B))))))
H0 : BetS B Q C
H : BetS A P C
A,B,C,P,Q : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
Logic.eq B C
+++++
auto.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros A B C P Q H H0.
destruct H.
destruct H0.
elim (classic (Col A B C)).
intro.
assert (T:exists X : Point, BetS A X Q /\\ BetS B X P).
apply (postulate_Pasch_inner A B C P Q H H0).
unfold nCol.
unfold neq.
unfold Col in *.
assert (BetS B A C <-> BetS C A B).
idtac.
assert (eq C B <-> eq B C).
split.

*****
H2 : iff (BetS B A C) (BetS C A B)
H1 : not\n (or (eq A B)\n (or (eq A C)\n (or (eq B C) (or (BetS B A C) (or (BetS A B C) (BetS A C B))))))
H0 : BetS B Q C
H : BetS A P C
A,B,C,P,Q : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
forall _ : eq B C, eq C B
+++++
unfold eq.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros A B C P Q H H0.
destruct H.
destruct H0.
elim (classic (Col A B C)).
intro.
assert (T:exists X : Point, BetS A X Q /\\ BetS B X P).
apply (postulate_Pasch_inner A B C P Q H H0).
unfold nCol.
unfold neq.
unfold Col in *.
assert (BetS B A C <-> BetS C A B).
idtac.
assert (eq C B <-> eq B C).
split.
unfold eq.

*****
H2 : iff (BetS B A C) (BetS C A B)
H1 : not\n (or (eq A B)\n (or (eq A C)\n (or (eq B C) (or (BetS B A C) (or (BetS A B C) (BetS A C B))))))
H0 : BetS B Q C
H : BetS A P C
A,B,C,P,Q : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
forall _ : Logic.eq B C, Logic.eq C B
+++++
intro.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros A B C P Q H H0.
destruct H.
destruct H0.
elim (classic (Col A B C)).
intro.
assert (T:exists X : Point, BetS A X Q /\\ BetS B X P).
apply (postulate_Pasch_inner A B C P Q H H0).
unfold nCol.
unfold neq.
unfold Col in *.
assert (BetS B A C <-> BetS C A B).
idtac.
assert (eq C B <-> eq B C).
split.
unfold eq.
intro.

*****
H3 : Logic.eq B C
H2 : iff (BetS B A C) (BetS C A B)
H1 : not\n (or (eq A B)\n (or (eq A C)\n (or (eq B C) (or (BetS B A C) (or (BetS A B C) (BetS A C B))))))
H0 : BetS B Q C
H : BetS A P C
A,B,C,P,Q : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
Logic.eq C B
+++++
auto.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros A B C P Q H H0.
destruct H.
destruct H0.
elim (classic (Col A B C)).
intro.
assert (T:exists X : Point, BetS A X Q /\\ BetS B X P).
apply (postulate_Pasch_inner A B C P Q H H0).
unfold nCol.
unfold neq.
unfold Col in *.
assert (BetS B A C <-> BetS C A B).
idtac.
assert (eq C B <-> eq B C).

*****
H3 : iff (eq C B) (eq B C)
H2 : iff (BetS B A C) (BetS C A B)
H1 : not\n (or (eq A B)\n (or (eq A C)\n (or (eq B C) (or (BetS B A C) (or (BetS A B C) (BetS A C B))))))
H0 : BetS B Q C
H : BetS A P C
A,B,C,P,Q : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
and (not (eq A C)) (and (not (eq A B)) (and (not (eq C B)) (and (not (BetS A C B)) (and (not (BetS A B C)) (not (BetS C A B))))))
+++++
idtac.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros A B C P Q H H0.
destruct H.
destruct H0.
elim (classic (Col A B C)).
intro.
assert (T:exists X : Point, BetS A X Q /\\ BetS B X P).
apply (postulate_Pasch_inner A B C P Q H H0).
unfold nCol.
unfold neq.
unfold Col in *.
assert (BetS B A C <-> BetS C A B).
idtac.
assert (eq C B <-> eq B C).
idtac.

*****
H3 : iff (eq C B) (eq B C)
H2 : iff (BetS B A C) (BetS C A B)
H1 : not\n (or (eq A B)\n (or (eq A C)\n (or (eq B C) (or (BetS B A C) (or (BetS A B C) (BetS A C B))))))
H0 : BetS B Q C
H : BetS A P C
A,B,C,P,Q : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
and (not (eq A C)) (and (not (eq A B)) (and (not (eq C B)) (and (not (BetS A C B)) (and (not (BetS A B C)) (not (BetS C A B))))))
+++++
tauto.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros A B C P Q H H0.
destruct H.
destruct H0.
elim (classic (Col A B C)).
intro.
assert (T:exists X : Point, BetS A X Q /\\ BetS B X P).

*****
T : ex (fun X : Point => and (BetS A X Q) (BetS B X P))
H1 : not (Col A B C)
H0 : BetS B Q C
H : BetS A P C
A,B,C,P,Q : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
ex (fun X : Point => and (Bet P X B) (Bet Q X A))
+++++
destruct T as [X [HXA HXB]].
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros A B C P Q H H0.
destruct H.
destruct H0.
elim (classic (Col A B C)).
intro.
assert (T:exists X : Point, BetS A X Q /\\ BetS B X P).
destruct T as [X [HXA HXB]].

*****
HXB : BetS B X P
HXA : BetS A X Q
X : Point
H1 : not (Col A B C)
H0 : BetS B Q C
H : BetS A P C
A,B,C,P,Q : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
ex (fun X : Point => and (Bet P X B) (Bet Q X A))
+++++
exists X.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros A B C P Q H H0.
destruct H.
destruct H0.
elim (classic (Col A B C)).
intro.
assert (T:exists X : Point, BetS A X Q /\\ BetS B X P).
destruct T as [X [HXA HXB]].
exists X.

*****
HXB : BetS B X P
HXA : BetS A X Q
X : Point
H1 : not (Col A B C)
H0 : BetS B Q C
H : BetS A P C
A,B,C,P,Q : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
and (Bet P X B) (Bet Q X A)
+++++
split.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros A B C P Q H H0.
destruct H.
destruct H0.
elim (classic (Col A B C)).
intro.
assert (T:exists X : Point, BetS A X Q /\\ BetS B X P).
destruct T as [X [HXA HXB]].
exists X.
split.

*****
HXB : BetS B X P
HXA : BetS A X Q
X : Point
H1 : not (Col A B C)
H0 : BetS B Q C
H : BetS A P C
A,B,C,P,Q : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
Bet P X B
+++++
unfold Bet.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros A B C P Q H H0.
destruct H.
destruct H0.
elim (classic (Col A B C)).
intro.
assert (T:exists X : Point, BetS A X Q /\\ BetS B X P).
destruct T as [X [HXA HXB]].
exists X.
split.
unfold Bet.

*****
HXB : BetS B X P
HXA : BetS A X Q
X : Point
H1 : not (Col A B C)
H0 : BetS B Q C
H : BetS A P C
A,B,C,P,Q : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
or (BetS P X B) (or (Logic.eq P X) (Logic.eq X B))
+++++
left.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros A B C P Q H H0.
destruct H.
destruct H0.
elim (classic (Col A B C)).
intro.
assert (T:exists X : Point, BetS A X Q /\\ BetS B X P).
destruct T as [X [HXA HXB]].
exists X.
split.
unfold Bet.
left.

*****
HXB : BetS B X P
HXA : BetS A X Q
X : Point
H1 : not (Col A B C)
H0 : BetS B Q C
H : BetS A P C
A,B,C,P,Q : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
BetS P X B
+++++
auto using axiom_betweennesssymmetry.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros A B C P Q H H0.
destruct H.
destruct H0.
elim (classic (Col A B C)).
intro.
assert (T:exists X : Point, BetS A X Q /\\ BetS B X P).
destruct T as [X [HXA HXB]].
exists X.
split.

*****
HXB : BetS B X P
HXA : BetS A X Q
X : Point
H1 : not (Col A B C)
H0 : BetS B Q C
H : BetS A P C
A,B,C,P,Q : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
Bet Q X A
+++++
unfold Bet.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros A B C P Q H H0.
destruct H.
destruct H0.
elim (classic (Col A B C)).
intro.
assert (T:exists X : Point, BetS A X Q /\\ BetS B X P).
destruct T as [X [HXA HXB]].
exists X.
split.
unfold Bet.

*****
HXB : BetS B X P
HXA : BetS A X Q
X : Point
H1 : not (Col A B C)
H0 : BetS B Q C
H : BetS A P C
A,B,C,P,Q : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
or (BetS Q X A) (or (Logic.eq Q X) (Logic.eq X A))
+++++
left.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros A B C P Q H H0.
destruct H.
destruct H0.
elim (classic (Col A B C)).
intro.
assert (T:exists X : Point, BetS A X Q /\\ BetS B X P).
destruct T as [X [HXA HXB]].
exists X.
split.
unfold Bet.
left.

*****
HXB : BetS B X P
HXA : BetS A X Q
X : Point
H1 : not (Col A B C)
H0 : BetS B Q C
H : BetS A P C
A,B,C,P,Q : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
BetS Q X A
+++++
auto using axiom_betweennesssymmetry.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros A B C P Q H H0.
destruct H.
destruct H0.

*****
H0 : or (Logic.eq B Q) (Logic.eq Q C)
H : BetS A P C
A,B,C,P,Q : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
ex (fun X : Point => and (Bet P X B) (Bet Q X A))
+++++
destruct H0.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros A B C P Q H H0.
destruct H.
destruct H0.
destruct H0.

*****
H0 : Logic.eq B Q
H : BetS A P C
A,B,C,P,Q : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
ex (fun X : Point => and (Bet P X B) (Bet Q X A))
+++++
subst.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros A B C P Q H H0.
destruct H.
destruct H0.
destruct H0.
subst.

*****
H : BetS A P C
A,C,P,Q : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
ex (fun X : Point => and (Bet P X Q) (Bet Q X A))
+++++
exists Q.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros A B C P Q H H0.
destruct H.
destruct H0.
destruct H0.
subst.
exists Q.

*****
H : BetS A P C
A,C,P,Q : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
and (Bet P Q Q) (Bet Q Q A)
+++++
unfold Bet.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros A B C P Q H H0.
destruct H.
destruct H0.
destruct H0.
subst.
exists Q.
unfold Bet.

*****
H : BetS A P C
A,C,P,Q : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
and (or (BetS P Q Q) (or (Logic.eq P Q) (Logic.eq Q Q))) (or (BetS Q Q A) (or (Logic.eq Q Q) (Logic.eq Q A)))
+++++
auto.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros A B C P Q H H0.
destruct H.
destruct H0.
destruct H0.

*****
H0 : Logic.eq Q C
H : BetS A P C
A,B,C,P,Q : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
ex (fun X : Point => and (Bet P X B) (Bet Q X A))
+++++
subst.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros A B C P Q H H0.
destruct H.
destruct H0.
destruct H0.
subst.

*****
H : BetS A P C
A,B,C,P : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
ex (fun X : Point => and (Bet P X B) (Bet C X A))
+++++
exists P.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros A B C P Q H H0.
destruct H.
destruct H0.
destruct H0.
subst.
exists P.

*****
H : BetS A P C
A,B,C,P : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
and (Bet P P B) (Bet C P A)
+++++
unfold Bet.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros A B C P Q H H0.
destruct H.
destruct H0.
destruct H0.
subst.
exists P.
unfold Bet.

*****
H : BetS A P C
A,B,C,P : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
and (or (BetS P P B) (or (Logic.eq P P) (Logic.eq P B))) (or (BetS C P A) (or (Logic.eq C P) (Logic.eq P A)))
+++++
auto using axiom_betweennesssymmetry.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros A B C P Q H H0.
destruct H.

*****
H0 : Bet B Q C
H : or (Logic.eq A P) (Logic.eq P C)
A,B,C,P,Q : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
ex (fun X : Point => and (Bet P X B) (Bet Q X A))
+++++
destruct H.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros A B C P Q H H0.
destruct H.
destruct H.

*****
H0 : Bet B Q C
H : Logic.eq A P
A,B,C,P,Q : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
ex (fun X : Point => and (Bet P X B) (Bet Q X A))
+++++
subst.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros A B C P Q H H0.
destruct H.
destruct H.
subst.

*****
H0 : Bet B Q C
B,C,P,Q : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
ex (fun X : Point => and (Bet P X B) (Bet Q X P))
+++++
exists P.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros A B C P Q H H0.
destruct H.
destruct H.
subst.
exists P.

*****
H0 : Bet B Q C
B,C,P,Q : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
and (Bet P P B) (Bet Q P P)
+++++
unfold Bet.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros A B C P Q H H0.
destruct H.
destruct H.
subst.
exists P.
unfold Bet.

*****
H0 : Bet B Q C
B,C,P,Q : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
and (or (BetS P P B) (or (Logic.eq P P) (Logic.eq P B))) (or (BetS Q P P) (or (Logic.eq Q P) (Logic.eq P P)))
+++++
auto.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros A B C P Q H H0.
destruct H.
destruct H.

*****
H0 : Bet B Q C
H : Logic.eq P C
A,B,C,P,Q : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
ex (fun X : Point => and (Bet P X B) (Bet Q X A))
+++++
subst.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros A B C P Q H H0.
destruct H.
destruct H.
subst.

*****
H0 : Bet B Q C
A,B,C,Q : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
ex (fun X : Point => and (Bet C X B) (Bet Q X A))
+++++
exists Q.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros A B C P Q H H0.
destruct H.
destruct H.
subst.
exists Q.

*****
H0 : Bet B Q C
A,B,C,Q : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
and (Bet C Q B) (Bet Q Q A)
+++++
split.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros A B C P Q H H0.
destruct H.
destruct H.
subst.
exists Q.
split.

*****
H0 : Bet B Q C
A,B,C,Q : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
Bet C Q B
+++++
auto using Bet_sym.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros A B C P Q H H0.
destruct H.
destruct H.
subst.
exists Q.
split.

*****
H0 : Bet B Q C
A,B,C,Q : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
Bet Q Q A
+++++
unfold Bet.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
intros A B C P Q H H0.
destruct H.
destruct H.
subst.
exists Q.
split.
unfold Bet.

*****
H0 : Bet B Q C
A,B,C,Q : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
or (BetS Q Q A) (or (Logic.eq Q Q) (Logic.eq Q A))
+++++
auto.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).

*****
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
not (or (Bet PA PB PC) (or (Bet PB PC PA) (Bet PC PA PB)))
+++++
assert (T:=axiom_lower_dim).
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
assert (T:=axiom_lower_dim).

*****
T : nCol PA PB PC
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
not (or (Bet PA PB PC) (or (Bet PB PC PA) (Bet PC PA PB)))
+++++
unfold nCol in *.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
assert (T:=axiom_lower_dim).
unfold nCol in *.

*****
T : and (neq PA PB)\n (and (neq PA PC)\n (and (neq PB PC)\n (and (not (BetS PA PB PC))\n (and (not (BetS PA PC PB)) (not (BetS PB PA PC))))))
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
not (or (Bet PA PB PC) (or (Bet PB PC PA) (Bet PC PA PB)))
+++++
unfold Bet in *.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
assert (T:=axiom_lower_dim).
unfold nCol in *.
unfold Bet in *.

*****
T : and (neq PA PB)\n (and (neq PA PC)\n (and (neq PB PC)\n (and (not (BetS PA PB PC))\n (and (not (BetS PA PC PB)) (not (BetS PB PA PC))))))
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
not (or (or (BetS PA PB PC) (or (Logic.eq PA PB) (Logic.eq PB PC))) (or (or (BetS PB PC PA) (or (Logic.eq PB PC) (Logic.eq PC PA))) (or (BetS PC PA PB) (or (Logic.eq PC PA) (Logic.eq PA PB)))))
+++++
unfold neq in *.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
assert (T:=axiom_lower_dim).
unfold nCol in *.
unfold Bet in *.
unfold neq in *.

*****
T : and (not (eq PA PB))\n (and (not (eq PA PC))\n (and (not (eq PB PC))\n (and (not (BetS PA PB PC))\n (and (not (BetS PA PC PB)) (not (BetS PB PA PC))))))
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
not (or (or (BetS PA PB PC) (or (Logic.eq PA PB) (Logic.eq PB PC))) (or (or (BetS PB PC PA) (or (Logic.eq PB PC) (Logic.eq PC PA))) (or (BetS PC PA PB) (or (Logic.eq PC PA) (Logic.eq PA PB)))))
+++++
unfold eq in *.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
assert (T:=axiom_lower_dim).
unfold nCol in *.
unfold Bet in *.
unfold neq in *.
unfold eq in *.

*****
T : and (not (Logic.eq PA PB))\n (and (not (Logic.eq PA PC))\n (and (not (Logic.eq PB PC))\n (and (not (BetS PA PB PC))\n (and (not (BetS PA PC PB)) (not (BetS PB PA PC))))))
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
not (or (or (BetS PA PB PC) (or (Logic.eq PA PB) (Logic.eq PB PC))) (or (or (BetS PB PC PA) (or (Logic.eq PB PC) (Logic.eq PC PA))) (or (BetS PC PA PB) (or (Logic.eq PC PA) (Logic.eq PA PB)))))
+++++
intro.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
assert (T:=axiom_lower_dim).
unfold nCol in *.
unfold Bet in *.
unfold neq in *.
unfold eq in *.
intro.

*****
H : or (or (BetS PA PB PC) (or (Logic.eq PA PB) (Logic.eq PB PC)))\n (or (or (BetS PB PC PA) (or (Logic.eq PB PC) (Logic.eq PC PA)))\n (or (BetS PC PA PB) (or (Logic.eq PC PA) (Logic.eq PA PB))))
T : and (not (Logic.eq PA PB))\n (and (not (Logic.eq PA PC))\n (and (not (Logic.eq PB PC))\n (and (not (BetS PA PB PC))\n (and (not (BetS PA PC PB)) (not (BetS PB PA PC))))))
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
False
+++++
spliter.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
assert (T:=axiom_lower_dim).
unfold nCol in *.
unfold Bet in *.
unfold neq in *.
unfold eq in *.
intro.
spliter.

*****
H : or (or (BetS PA PB PC) (or (Logic.eq PA PB) (Logic.eq PB PC)))\n (or (or (BetS PB PC PA) (or (Logic.eq PB PC) (Logic.eq PC PA)))\n (or (BetS PC PA PB) (or (Logic.eq PC PA) (Logic.eq PA PB))))
H5 : not (BetS PB PA PC)
H4 : not (BetS PA PC PB)
H3 : not (BetS PA PB PC)
H2 : not (Logic.eq PB PC)
H1 : not (Logic.eq PA PC)
H0 : not (Logic.eq PA PB)
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
False
+++++
decompose [or] H.
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
assert (T:=axiom_lower_dim).
unfold nCol in *.
unfold Bet in *.
unfold neq in *.
unfold eq in *.
intro.
spliter.
decompose [or] H.

*****
H7 : BetS PA PB PC
H : or (or (BetS PA PB PC) (or (Logic.eq PA PB) (Logic.eq PB PC)))\n (or (or (BetS PB PC PA) (or (Logic.eq PB PC) (Logic.eq PC PA)))\n (or (BetS PC PA PB) (or (Logic.eq PC PA) (Logic.eq PA PB))))
H5 : not (BetS PB PA PC)
H4 : not (BetS PA PC PB)
H3 : not (BetS PA PB PC)
H2 : not (Logic.eq PB PC)
H1 : not (Logic.eq PA PC)
H0 : not (Logic.eq PA PB)
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
False
+++++
try solve [auto using axiom_betweennesssymmetry].
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
assert (T:=axiom_lower_dim).
unfold nCol in *.
unfold Bet in *.
unfold neq in *.
unfold eq in *.
intro.
spliter.
decompose [or] H.

*****
H6 : Logic.eq PA PB
H : or (or (BetS PA PB PC) (or (Logic.eq PA PB) (Logic.eq PB PC)))\n (or (or (BetS PB PC PA) (or (Logic.eq PB PC) (Logic.eq PC PA)))\n (or (BetS PC PA PB) (or (Logic.eq PC PA) (Logic.eq PA PB))))
H5 : not (BetS PB PA PC)
H4 : not (BetS PA PC PB)
H3 : not (BetS PA PB PC)
H2 : not (Logic.eq PB PC)
H1 : not (Logic.eq PA PC)
H0 : not (Logic.eq PA PB)
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
False
+++++
try solve [auto using axiom_betweennesssymmetry].
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
assert (T:=axiom_lower_dim).
unfold nCol in *.
unfold Bet in *.
unfold neq in *.
unfold eq in *.
intro.
spliter.
decompose [or] H.

*****
H6 : Logic.eq PB PC
H : or (or (BetS PA PB PC) (or (Logic.eq PA PB) (Logic.eq PB PC)))\n (or (or (BetS PB PC PA) (or (Logic.eq PB PC) (Logic.eq PC PA)))\n (or (BetS PC PA PB) (or (Logic.eq PC PA) (Logic.eq PA PB))))
H5 : not (BetS PB PA PC)
H4 : not (BetS PA PC PB)
H3 : not (BetS PA PB PC)
H2 : not (Logic.eq PB PC)
H1 : not (Logic.eq PA PC)
H0 : not (Logic.eq PA PB)
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
False
+++++
try solve [auto using axiom_betweennesssymmetry].
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
assert (T:=axiom_lower_dim).
unfold nCol in *.
unfold Bet in *.
unfold neq in *.
unfold eq in *.
intro.
spliter.
decompose [or] H.

*****
H6 : BetS PB PC PA
H : or (or (BetS PA PB PC) (or (Logic.eq PA PB) (Logic.eq PB PC)))\n (or (or (BetS PB PC PA) (or (Logic.eq PB PC) (Logic.eq PC PA)))\n (or (BetS PC PA PB) (or (Logic.eq PC PA) (Logic.eq PA PB))))
H5 : not (BetS PB PA PC)
H4 : not (BetS PA PC PB)
H3 : not (BetS PA PB PC)
H2 : not (Logic.eq PB PC)
H1 : not (Logic.eq PA PC)
H0 : not (Logic.eq PA PB)
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
False
+++++
try solve [auto using axiom_betweennesssymmetry].
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
assert (T:=axiom_lower_dim).
unfold nCol in *.
unfold Bet in *.
unfold neq in *.
unfold eq in *.
intro.
spliter.
decompose [or] H.

*****
H7 : Logic.eq PB PC
H : or (or (BetS PA PB PC) (or (Logic.eq PA PB) (Logic.eq PB PC)))\n (or (or (BetS PB PC PA) (or (Logic.eq PB PC) (Logic.eq PC PA)))\n (or (BetS PC PA PB) (or (Logic.eq PC PA) (Logic.eq PA PB))))
H5 : not (BetS PB PA PC)
H4 : not (BetS PA PC PB)
H3 : not (BetS PA PB PC)
H2 : not (Logic.eq PB PC)
H1 : not (Logic.eq PA PC)
H0 : not (Logic.eq PA PB)
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
False
+++++
try solve [auto using axiom_betweennesssymmetry].
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
assert (T:=axiom_lower_dim).
unfold nCol in *.
unfold Bet in *.
unfold neq in *.
unfold eq in *.
intro.
spliter.
decompose [or] H.

*****
H7 : Logic.eq PC PA
H : or (or (BetS PA PB PC) (or (Logic.eq PA PB) (Logic.eq PB PC)))\n (or (or (BetS PB PC PA) (or (Logic.eq PB PC) (Logic.eq PC PA)))\n (or (BetS PC PA PB) (or (Logic.eq PC PA) (Logic.eq PA PB))))
H5 : not (BetS PB PA PC)
H4 : not (BetS PA PC PB)
H3 : not (BetS PA PB PC)
H2 : not (Logic.eq PB PC)
H1 : not (Logic.eq PA PC)
H0 : not (Logic.eq PA PB)
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
False
+++++
try solve [auto using axiom_betweennesssymmetry].
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
assert (T:=axiom_lower_dim).
unfold nCol in *.
unfold Bet in *.
unfold neq in *.
unfold eq in *.
intro.
spliter.
decompose [or] H.

*****
H6 : BetS PC PA PB
H : or (or (BetS PA PB PC) (or (Logic.eq PA PB) (Logic.eq PB PC)))\n (or (or (BetS PB PC PA) (or (Logic.eq PB PC) (Logic.eq PC PA)))\n (or (BetS PC PA PB) (or (Logic.eq PC PA) (Logic.eq PA PB))))
H5 : not (BetS PB PA PC)
H4 : not (BetS PA PC PB)
H3 : not (BetS PA PB PC)
H2 : not (Logic.eq PB PC)
H1 : not (Logic.eq PA PC)
H0 : not (Logic.eq PA PB)
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
False
+++++
try solve [auto using axiom_betweennesssymmetry].
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
assert (T:=axiom_lower_dim).
unfold nCol in *.
unfold Bet in *.
unfold neq in *.
unfold eq in *.
intro.
spliter.
decompose [or] H.

*****
H7 : Logic.eq PC PA
H : or (or (BetS PA PB PC) (or (Logic.eq PA PB) (Logic.eq PB PC)))\n (or (or (BetS PB PC PA) (or (Logic.eq PB PC) (Logic.eq PC PA)))\n (or (BetS PC PA PB) (or (Logic.eq PC PA) (Logic.eq PA PB))))
H5 : not (BetS PB PA PC)
H4 : not (BetS PA PC PB)
H3 : not (BetS PA PB PC)
H2 : not (Logic.eq PB PC)
H1 : not (Logic.eq PA PC)
H0 : not (Logic.eq PA PB)
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
False
+++++
try solve [auto using axiom_betweennesssymmetry].
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).
assert (T:=axiom_lower_dim).
unfold nCol in *.
unfold Bet in *.
unfold neq in *.
unfold eq in *.
intro.
spliter.
decompose [or] H.

*****
H7 : Logic.eq PA PB
H : or (or (BetS PA PB PC) (or (Logic.eq PA PB) (Logic.eq PB PC)))\n (or (or (BetS PB PC PA) (or (Logic.eq PB PC) (Logic.eq PC PA)))\n (or (BetS PC PA PB) (or (Logic.eq PC PA) (Logic.eq PA PB))))
H5 : not (BetS PB PA PC)
H4 : not (BetS PA PC PB)
H3 : not (BetS PA PB PC)
H2 : not (Logic.eq PB PC)
H1 : not (Logic.eq PA PC)
H0 : not (Logic.eq PA PB)
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
False
+++++
try solve [auto using axiom_betweennesssymmetry].
-----
Instance Tarski_follows_Euclid: Tarski_neutral_dimensionless.
Proof.
eapply (Build_Tarski_neutral_dimensionless Point Bet TCong) with (PA:=PA) (PB:=PB) (PC:=PC).

*****

*****

+++++
Qed.
-----
End Euclid_to_Tarski.
-----
