Require Export GeoCoq.Elements.OriginalProofs.lemma_parallelcollinear.
-----
Section Euclid.
-----
Context `{Ax:euclidean_neutral_ruler_compass}.
-----
Lemma lemma_paralleldef2B : \n   forall A B C D, \n   Par A B C D ->\n   TP A B C D.
-----
Lemma lemma_paralleldef2B : forall A B C D, Par A B C D -> TP A B C D.

*****
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
forall (A B C D : Point) (_ : Par A B C D), TP A B C D
+++++
Proof.
-----
Lemma lemma_paralleldef2B : forall A B C D, Par A B C D -> TP A B C D.
Proof.

*****
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
forall (A B C D : Point) (_ : Par A B C D), TP A B C D
+++++
intros.
-----
Lemma lemma_paralleldef2B : forall A B C D, Par A B C D -> TP A B C D.
Proof.
intros.

*****
H : Par A B C D
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
TP A B C D
+++++
let Tf:=fresh in assert (Tf:exists a b c d e, (neq A B /\ neq C D /\ Col A B a /\ Col A B b /\ neq a b /\ Col C D c /\ Col C D d /\ neq c d /\ ~ Meet A B C D /\ BetS a e d /\ BetS c e b)) by (conclude_def Par );destruct Tf as [a[b[c[d[e]]]]];spliter.
-----
Lemma lemma_paralleldef2B : forall A B C D, Par A B C D -> TP A B C D.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists a b c d e, (neq A B /\\ neq C D /\\ Col A B a /\\ Col A B b /\\ neq a b /\\ Col C D c /\\ Col C D d /\\ neq c d /\\ ~ Meet A B C D /\\ BetS a e d /\\ BetS c e b)) by (conclude_def Par );destruct Tf as [a[b[c[d[e]]]]];spliter.

*****
H10 : BetS c e b
H9 : BetS a e d
H8 : not (Meet A B C D)
H7 : neq c d
H6 : Col C D d
H5 : Col C D c
H4 : neq a b
H3 : Col A B b
H2 : Col A B a
H1 : neq C D
H0 : neq A B
a,b,c,d,e : Point
H : Par A B C D
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
TP A B C D
+++++
assert (neq b a) by (conclude lemma_inequalitysymmetric).
-----
Lemma lemma_paralleldef2B : forall A B C D, Par A B C D -> TP A B C D.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists a b c d e, (neq A B /\\ neq C D /\\ Col A B a /\\ Col A B b /\\ neq a b /\\ Col C D c /\\ Col C D d /\\ neq c d /\\ ~ Meet A B C D /\\ BetS a e d /\\ BetS c e b)) by (conclude_def Par );destruct Tf as [a[b[c[d[e]]]]];spliter.
assert (neq b a) by (conclude lemma_inequalitysymmetric).

*****
H11 : neq b a
H10 : BetS c e b
H9 : BetS a e d
H8 : not (Meet A B C D)
H7 : neq c d
H6 : Col C D d
H5 : Col C D c
H4 : neq a b
H3 : Col A B b
H2 : Col A B a
H1 : neq C D
H0 : neq A B
a,b,c,d,e : Point
H : Par A B C D
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
TP A B C D
+++++
assert (neq e b) by (forward_using lemma_betweennotequal).
-----
Lemma lemma_paralleldef2B : forall A B C D, Par A B C D -> TP A B C D.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists a b c d e, (neq A B /\\ neq C D /\\ Col A B a /\\ Col A B b /\\ neq a b /\\ Col C D c /\\ Col C D d /\\ neq c d /\\ ~ Meet A B C D /\\ BetS a e d /\\ BetS c e b)) by (conclude_def Par );destruct Tf as [a[b[c[d[e]]]]];spliter.
assert (neq b a) by (conclude lemma_inequalitysymmetric).
assert (neq e b) by (forward_using lemma_betweennotequal).

*****
H12 : neq e b
H11 : neq b a
H10 : BetS c e b
H9 : BetS a e d
H8 : not (Meet A B C D)
H7 : neq c d
H6 : Col C D d
H5 : Col C D c
H4 : neq a b
H3 : Col A B b
H2 : Col A B a
H1 : neq C D
H0 : neq A B
a,b,c,d,e : Point
H : Par A B C D
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
TP A B C D
+++++
assert (~ Meet a b C D).
-----
Lemma lemma_paralleldef2B : forall A B C D, Par A B C D -> TP A B C D.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists a b c d e, (neq A B /\\ neq C D /\\ Col A B a /\\ Col A B b /\\ neq a b /\\ Col C D c /\\ Col C D d /\\ neq c d /\\ ~ Meet A B C D /\\ BetS a e d /\\ BetS c e b)) by (conclude_def Par );destruct Tf as [a[b[c[d[e]]]]];spliter.
assert (neq b a) by (conclude lemma_inequalitysymmetric).
assert (neq e b) by (forward_using lemma_betweennotequal).
assert (~ Meet a b C D).

*****
H12 : neq e b
H11 : neq b a
H10 : BetS c e b
H9 : BetS a e d
H8 : not (Meet A B C D)
H7 : neq c d
H6 : Col C D d
H5 : Col C D c
H4 : neq a b
H3 : Col A B b
H2 : Col A B a
H1 : neq C D
H0 : neq A B
a,b,c,d,e : Point
H : Par A B C D
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
not (Meet a b C D)
+++++
intro.
-----
Lemma lemma_paralleldef2B : forall A B C D, Par A B C D -> TP A B C D.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists a b c d e, (neq A B /\\ neq C D /\\ Col A B a /\\ Col A B b /\\ neq a b /\\ Col C D c /\\ Col C D d /\\ neq c d /\\ ~ Meet A B C D /\\ BetS a e d /\\ BetS c e b)) by (conclude_def Par );destruct Tf as [a[b[c[d[e]]]]];spliter.
assert (neq b a) by (conclude lemma_inequalitysymmetric).
assert (neq e b) by (forward_using lemma_betweennotequal).
assert (~ Meet a b C D).
intro.

*****
H13 : Meet a b C D
H12 : neq e b
H11 : neq b a
H10 : BetS c e b
H9 : BetS a e d
H8 : not (Meet A B C D)
H7 : neq c d
H6 : Col C D d
H5 : Col C D c
H4 : neq a b
H3 : Col A B b
H2 : Col A B a
H1 : neq C D
H0 : neq A B
a,b,c,d,e : Point
H : Par A B C D
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
False
+++++
let Tf:=fresh in assert (Tf:exists R, (neq a b /\ neq C D /\ Col a b R /\ Col C D R)) by (conclude_def Meet );destruct Tf as [R];spliter.
-----
Lemma lemma_paralleldef2B : forall A B C D, Par A B C D -> TP A B C D.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists a b c d e, (neq A B /\\ neq C D /\\ Col A B a /\\ Col A B b /\\ neq a b /\\ Col C D c /\\ Col C D d /\\ neq c d /\\ ~ Meet A B C D /\\ BetS a e d /\\ BetS c e b)) by (conclude_def Par );destruct Tf as [a[b[c[d[e]]]]];spliter.
assert (neq b a) by (conclude lemma_inequalitysymmetric).
assert (neq e b) by (forward_using lemma_betweennotequal).
assert (~ Meet a b C D).
intro.
let Tf:=fresh in assert (Tf:exists R, (neq a b /\\ neq C D /\\ Col a b R /\\ Col C D R)) by (conclude_def Meet );destruct Tf as [R];spliter.

*****
H17 : Col C D R
H16 : Col a b R
H15 : neq C D
H14 : neq a b
R : Point
H13 : Meet a b C D
H12 : neq e b
H11 : neq b a
H10 : BetS c e b
H9 : BetS a e d
H8 : not (Meet A B C D)
H7 : neq c d
H6 : Col C D d
H5 : Col C D c
H4 : neq a b
H3 : Col A B b
H2 : Col A B a
H1 : neq C D
H0 : neq A B
a,b,c,d,e : Point
H : Par A B C D
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
False
+++++
assert (Col b a R) by (forward_using lemma_collinearorder).
-----
Lemma lemma_paralleldef2B : forall A B C D, Par A B C D -> TP A B C D.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists a b c d e, (neq A B /\\ neq C D /\\ Col A B a /\\ Col A B b /\\ neq a b /\\ Col C D c /\\ Col C D d /\\ neq c d /\\ ~ Meet A B C D /\\ BetS a e d /\\ BetS c e b)) by (conclude_def Par );destruct Tf as [a[b[c[d[e]]]]];spliter.
assert (neq b a) by (conclude lemma_inequalitysymmetric).
assert (neq e b) by (forward_using lemma_betweennotequal).
assert (~ Meet a b C D).
intro.
let Tf:=fresh in assert (Tf:exists R, (neq a b /\\ neq C D /\\ Col a b R /\\ Col C D R)) by (conclude_def Meet );destruct Tf as [R];spliter.
assert (Col b a R) by (forward_using lemma_collinearorder).

*****
H18 : Col b a R
H17 : Col C D R
H16 : Col a b R
H15 : neq C D
H14 : neq a b
R : Point
H13 : Meet a b C D
H12 : neq e b
H11 : neq b a
H10 : BetS c e b
H9 : BetS a e d
H8 : not (Meet A B C D)
H7 : neq c d
H6 : Col C D d
H5 : Col C D c
H4 : neq a b
H3 : Col A B b
H2 : Col A B a
H1 : neq C D
H0 : neq A B
a,b,c,d,e : Point
H : Par A B C D
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
False
+++++
assert (Col B a b) by (conclude lemma_collinear4).
-----
Lemma lemma_paralleldef2B : forall A B C D, Par A B C D -> TP A B C D.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists a b c d e, (neq A B /\\ neq C D /\\ Col A B a /\\ Col A B b /\\ neq a b /\\ Col C D c /\\ Col C D d /\\ neq c d /\\ ~ Meet A B C D /\\ BetS a e d /\\ BetS c e b)) by (conclude_def Par );destruct Tf as [a[b[c[d[e]]]]];spliter.
assert (neq b a) by (conclude lemma_inequalitysymmetric).
assert (neq e b) by (forward_using lemma_betweennotequal).
assert (~ Meet a b C D).
intro.
let Tf:=fresh in assert (Tf:exists R, (neq a b /\\ neq C D /\\ Col a b R /\\ Col C D R)) by (conclude_def Meet );destruct Tf as [R];spliter.
assert (Col b a R) by (forward_using lemma_collinearorder).
assert (Col B a b) by (conclude lemma_collinear4).

*****
H19 : Col B a b
H18 : Col b a R
H17 : Col C D R
H16 : Col a b R
H15 : neq C D
H14 : neq a b
R : Point
H13 : Meet a b C D
H12 : neq e b
H11 : neq b a
H10 : BetS c e b
H9 : BetS a e d
H8 : not (Meet A B C D)
H7 : neq c d
H6 : Col C D d
H5 : Col C D c
H4 : neq a b
H3 : Col A B b
H2 : Col A B a
H1 : neq C D
H0 : neq A B
a,b,c,d,e : Point
H : Par A B C D
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
False
+++++
assert (Col b a B) by (forward_using lemma_collinearorder).
-----
Lemma lemma_paralleldef2B : forall A B C D, Par A B C D -> TP A B C D.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists a b c d e, (neq A B /\\ neq C D /\\ Col A B a /\\ Col A B b /\\ neq a b /\\ Col C D c /\\ Col C D d /\\ neq c d /\\ ~ Meet A B C D /\\ BetS a e d /\\ BetS c e b)) by (conclude_def Par );destruct Tf as [a[b[c[d[e]]]]];spliter.
assert (neq b a) by (conclude lemma_inequalitysymmetric).
assert (neq e b) by (forward_using lemma_betweennotequal).
assert (~ Meet a b C D).
intro.
let Tf:=fresh in assert (Tf:exists R, (neq a b /\\ neq C D /\\ Col a b R /\\ Col C D R)) by (conclude_def Meet );destruct Tf as [R];spliter.
assert (Col b a R) by (forward_using lemma_collinearorder).
assert (Col B a b) by (conclude lemma_collinear4).
assert (Col b a B) by (forward_using lemma_collinearorder).

*****
H20 : Col b a B
H19 : Col B a b
H18 : Col b a R
H17 : Col C D R
H16 : Col a b R
H15 : neq C D
H14 : neq a b
R : Point
H13 : Meet a b C D
H12 : neq e b
H11 : neq b a
H10 : BetS c e b
H9 : BetS a e d
H8 : not (Meet A B C D)
H7 : neq c d
H6 : Col C D d
H5 : Col C D c
H4 : neq a b
H3 : Col A B b
H2 : Col A B a
H1 : neq C D
H0 : neq A B
a,b,c,d,e : Point
H : Par A B C D
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
False
+++++
assert (Col a B R) by (conclude lemma_collinear4).
-----
Lemma lemma_paralleldef2B : forall A B C D, Par A B C D -> TP A B C D.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists a b c d e, (neq A B /\\ neq C D /\\ Col A B a /\\ Col A B b /\\ neq a b /\\ Col C D c /\\ Col C D d /\\ neq c d /\\ ~ Meet A B C D /\\ BetS a e d /\\ BetS c e b)) by (conclude_def Par );destruct Tf as [a[b[c[d[e]]]]];spliter.
assert (neq b a) by (conclude lemma_inequalitysymmetric).
assert (neq e b) by (forward_using lemma_betweennotequal).
assert (~ Meet a b C D).
intro.
let Tf:=fresh in assert (Tf:exists R, (neq a b /\\ neq C D /\\ Col a b R /\\ Col C D R)) by (conclude_def Meet );destruct Tf as [R];spliter.
assert (Col b a R) by (forward_using lemma_collinearorder).
assert (Col B a b) by (conclude lemma_collinear4).
assert (Col b a B) by (forward_using lemma_collinearorder).
assert (Col a B R) by (conclude lemma_collinear4).

*****
H21 : Col a B R
H20 : Col b a B
H19 : Col B a b
H18 : Col b a R
H17 : Col C D R
H16 : Col a b R
H15 : neq C D
H14 : neq a b
R : Point
H13 : Meet a b C D
H12 : neq e b
H11 : neq b a
H10 : BetS c e b
H9 : BetS a e d
H8 : not (Meet A B C D)
H7 : neq c d
H6 : Col C D d
H5 : Col C D c
H4 : neq a b
H3 : Col A B b
H2 : Col A B a
H1 : neq C D
H0 : neq A B
a,b,c,d,e : Point
H : Par A B C D
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
False
+++++
assert (Col a B A) by (forward_using lemma_collinearorder).
-----
Lemma lemma_paralleldef2B : forall A B C D, Par A B C D -> TP A B C D.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists a b c d e, (neq A B /\\ neq C D /\\ Col A B a /\\ Col A B b /\\ neq a b /\\ Col C D c /\\ Col C D d /\\ neq c d /\\ ~ Meet A B C D /\\ BetS a e d /\\ BetS c e b)) by (conclude_def Par );destruct Tf as [a[b[c[d[e]]]]];spliter.
assert (neq b a) by (conclude lemma_inequalitysymmetric).
assert (neq e b) by (forward_using lemma_betweennotequal).
assert (~ Meet a b C D).
intro.
let Tf:=fresh in assert (Tf:exists R, (neq a b /\\ neq C D /\\ Col a b R /\\ Col C D R)) by (conclude_def Meet );destruct Tf as [R];spliter.
assert (Col b a R) by (forward_using lemma_collinearorder).
assert (Col B a b) by (conclude lemma_collinear4).
assert (Col b a B) by (forward_using lemma_collinearorder).
assert (Col a B R) by (conclude lemma_collinear4).
assert (Col a B A) by (forward_using lemma_collinearorder).

*****
H22 : Col a B A
H21 : Col a B R
H20 : Col b a B
H19 : Col B a b
H18 : Col b a R
H17 : Col C D R
H16 : Col a b R
H15 : neq C D
H14 : neq a b
R : Point
H13 : Meet a b C D
H12 : neq e b
H11 : neq b a
H10 : BetS c e b
H9 : BetS a e d
H8 : not (Meet A B C D)
H7 : neq c d
H6 : Col C D d
H5 : Col C D c
H4 : neq a b
H3 : Col A B b
H2 : Col A B a
H1 : neq C D
H0 : neq A B
a,b,c,d,e : Point
H : Par A B C D
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
False
+++++
assert (Col A B R).
-----
Lemma lemma_paralleldef2B : forall A B C D, Par A B C D -> TP A B C D.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists a b c d e, (neq A B /\\ neq C D /\\ Col A B a /\\ Col A B b /\\ neq a b /\\ Col C D c /\\ Col C D d /\\ neq c d /\\ ~ Meet A B C D /\\ BetS a e d /\\ BetS c e b)) by (conclude_def Par );destruct Tf as [a[b[c[d[e]]]]];spliter.
assert (neq b a) by (conclude lemma_inequalitysymmetric).
assert (neq e b) by (forward_using lemma_betweennotequal).
assert (~ Meet a b C D).
intro.
let Tf:=fresh in assert (Tf:exists R, (neq a b /\\ neq C D /\\ Col a b R /\\ Col C D R)) by (conclude_def Meet );destruct Tf as [R];spliter.
assert (Col b a R) by (forward_using lemma_collinearorder).
assert (Col B a b) by (conclude lemma_collinear4).
assert (Col b a B) by (forward_using lemma_collinearorder).
assert (Col a B R) by (conclude lemma_collinear4).
assert (Col a B A) by (forward_using lemma_collinearorder).
assert (Col A B R).

*****
H22 : Col a B A
H21 : Col a B R
H20 : Col b a B
H19 : Col B a b
H18 : Col b a R
H17 : Col C D R
H16 : Col a b R
H15 : neq C D
H14 : neq a b
R : Point
H13 : Meet a b C D
H12 : neq e b
H11 : neq b a
H10 : BetS c e b
H9 : BetS a e d
H8 : not (Meet A B C D)
H7 : neq c d
H6 : Col C D d
H5 : Col C D c
H4 : neq a b
H3 : Col A B b
H2 : Col A B a
H1 : neq C D
H0 : neq A B
a,b,c,d,e : Point
H : Par A B C D
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
Col A B R
+++++
by cases on (neq a B \/ eq a B).
-----
Lemma lemma_paralleldef2B : forall A B C D, Par A B C D -> TP A B C D.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists a b c d e, (neq A B /\\ neq C D /\\ Col A B a /\\ Col A B b /\\ neq a b /\\ Col C D c /\\ Col C D d /\\ neq c d /\\ ~ Meet A B C D /\\ BetS a e d /\\ BetS c e b)) by (conclude_def Par );destruct Tf as [a[b[c[d[e]]]]];spliter.
assert (neq b a) by (conclude lemma_inequalitysymmetric).
assert (neq e b) by (forward_using lemma_betweennotequal).
assert (~ Meet a b C D).
intro.
let Tf:=fresh in assert (Tf:exists R, (neq a b /\\ neq C D /\\ Col a b R /\\ Col C D R)) by (conclude_def Meet );destruct Tf as [R];spliter.
assert (Col b a R) by (forward_using lemma_collinearorder).
assert (Col B a b) by (conclude lemma_collinear4).
assert (Col b a B) by (forward_using lemma_collinearorder).
assert (Col a B R) by (conclude lemma_collinear4).
assert (Col a B A) by (forward_using lemma_collinearorder).
assert (Col A B R).
by cases on (neq a B \\/ eq a B).

*****
H24 : neq a B
H22 : Col a B A
H21 : Col a B R
H20 : Col b a B
H19 : Col B a b
H18 : Col b a R
H17 : Col C D R
H16 : Col a b R
H15 : neq C D
H14 : neq a b
R : Point
H13 : Meet a b C D
H12 : neq e b
H11 : neq b a
H10 : BetS c e b
H9 : BetS a e d
H8 : not (Meet A B C D)
H7 : neq c d
H6 : Col C D d
H5 : Col C D c
H4 : neq a b
H3 : Col A B b
H2 : Col A B a
H1 : neq C D
H0 : neq A B
a,b,c,d,e : Point
H : Par A B C D
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
Col A B R
+++++
assert (Col B R A) by (conclude lemma_collinear4).
-----
Lemma lemma_paralleldef2B : forall A B C D, Par A B C D -> TP A B C D.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists a b c d e, (neq A B /\\ neq C D /\\ Col A B a /\\ Col A B b /\\ neq a b /\\ Col C D c /\\ Col C D d /\\ neq c d /\\ ~ Meet A B C D /\\ BetS a e d /\\ BetS c e b)) by (conclude_def Par );destruct Tf as [a[b[c[d[e]]]]];spliter.
assert (neq b a) by (conclude lemma_inequalitysymmetric).
assert (neq e b) by (forward_using lemma_betweennotequal).
assert (~ Meet a b C D).
intro.
let Tf:=fresh in assert (Tf:exists R, (neq a b /\\ neq C D /\\ Col a b R /\\ Col C D R)) by (conclude_def Meet );destruct Tf as [R];spliter.
assert (Col b a R) by (forward_using lemma_collinearorder).
assert (Col B a b) by (conclude lemma_collinear4).
assert (Col b a B) by (forward_using lemma_collinearorder).
assert (Col a B R) by (conclude lemma_collinear4).
assert (Col a B A) by (forward_using lemma_collinearorder).
assert (Col A B R).
by cases on (neq a B \\/ eq a B).
assert (Col B R A) by (conclude lemma_collinear4).

*****
H23 : Col B R A
H24 : neq a B
H22 : Col a B A
H21 : Col a B R
H20 : Col b a B
H19 : Col B a b
H18 : Col b a R
H17 : Col C D R
H16 : Col a b R
H15 : neq C D
H14 : neq a b
R : Point
H13 : Meet a b C D
H12 : neq e b
H11 : neq b a
H10 : BetS c e b
H9 : BetS a e d
H8 : not (Meet A B C D)
H7 : neq c d
H6 : Col C D d
H5 : Col C D c
H4 : neq a b
H3 : Col A B b
H2 : Col A B a
H1 : neq C D
H0 : neq A B
a,b,c,d,e : Point
H : Par A B C D
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
Col A B R
+++++
assert (Col A B R) by (forward_using lemma_collinearorder).
-----
Lemma lemma_paralleldef2B : forall A B C D, Par A B C D -> TP A B C D.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists a b c d e, (neq A B /\\ neq C D /\\ Col A B a /\\ Col A B b /\\ neq a b /\\ Col C D c /\\ Col C D d /\\ neq c d /\\ ~ Meet A B C D /\\ BetS a e d /\\ BetS c e b)) by (conclude_def Par );destruct Tf as [a[b[c[d[e]]]]];spliter.
assert (neq b a) by (conclude lemma_inequalitysymmetric).
assert (neq e b) by (forward_using lemma_betweennotequal).
assert (~ Meet a b C D).
intro.
let Tf:=fresh in assert (Tf:exists R, (neq a b /\\ neq C D /\\ Col a b R /\\ Col C D R)) by (conclude_def Meet );destruct Tf as [R];spliter.
assert (Col b a R) by (forward_using lemma_collinearorder).
assert (Col B a b) by (conclude lemma_collinear4).
assert (Col b a B) by (forward_using lemma_collinearorder).
assert (Col a B R) by (conclude lemma_collinear4).
assert (Col a B A) by (forward_using lemma_collinearorder).
assert (Col A B R).
by cases on (neq a B \\/ eq a B).
assert (Col B R A) by (conclude lemma_collinear4).
assert (Col A B R) by (forward_using lemma_collinearorder).

*****
H25 : Col A B R
H23 : Col B R A
H24 : neq a B
H22 : Col a B A
H21 : Col a B R
H20 : Col b a B
H19 : Col B a b
H18 : Col b a R
H17 : Col C D R
H16 : Col a b R
H15 : neq C D
H14 : neq a b
R : Point
H13 : Meet a b C D
H12 : neq e b
H11 : neq b a
H10 : BetS c e b
H9 : BetS a e d
H8 : not (Meet A B C D)
H7 : neq c d
H6 : Col C D d
H5 : Col C D c
H4 : neq a b
H3 : Col A B b
H2 : Col A B a
H1 : neq C D
H0 : neq A B
a,b,c,d,e : Point
H : Par A B C D
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
Col A B R
+++++
close.
-----
Lemma lemma_paralleldef2B : forall A B C D, Par A B C D -> TP A B C D.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists a b c d e, (neq A B /\\ neq C D /\\ Col A B a /\\ Col A B b /\\ neq a b /\\ Col C D c /\\ Col C D d /\\ neq c d /\\ ~ Meet A B C D /\\ BetS a e d /\\ BetS c e b)) by (conclude_def Par );destruct Tf as [a[b[c[d[e]]]]];spliter.
assert (neq b a) by (conclude lemma_inequalitysymmetric).
assert (neq e b) by (forward_using lemma_betweennotequal).
assert (~ Meet a b C D).
intro.
let Tf:=fresh in assert (Tf:exists R, (neq a b /\\ neq C D /\\ Col a b R /\\ Col C D R)) by (conclude_def Meet );destruct Tf as [R];spliter.
assert (Col b a R) by (forward_using lemma_collinearorder).
assert (Col B a b) by (conclude lemma_collinear4).
assert (Col b a B) by (forward_using lemma_collinearorder).
assert (Col a B R) by (conclude lemma_collinear4).
assert (Col a B A) by (forward_using lemma_collinearorder).
assert (Col A B R).
by cases on (neq a B \\/ eq a B).

*****
H24 : eq a B
H22 : Col a B A
H21 : Col a B R
H20 : Col b a B
H19 : Col B a b
H18 : Col b a R
H17 : Col C D R
H16 : Col a b R
H15 : neq C D
H14 : neq a b
R : Point
H13 : Meet a b C D
H12 : neq e b
H11 : neq b a
H10 : BetS c e b
H9 : BetS a e d
H8 : not (Meet A B C D)
H7 : neq c d
H6 : Col C D d
H5 : Col C D c
H4 : neq a b
H3 : Col A B b
H2 : Col A B a
H1 : neq C D
H0 : neq A B
a,b,c,d,e : Point
H : Par A B C D
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
Col A B R
+++++
assert (neq A a) by (conclude cn_equalitysub).
-----
Lemma lemma_paralleldef2B : forall A B C D, Par A B C D -> TP A B C D.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists a b c d e, (neq A B /\\ neq C D /\\ Col A B a /\\ Col A B b /\\ neq a b /\\ Col C D c /\\ Col C D d /\\ neq c d /\\ ~ Meet A B C D /\\ BetS a e d /\\ BetS c e b)) by (conclude_def Par );destruct Tf as [a[b[c[d[e]]]]];spliter.
assert (neq b a) by (conclude lemma_inequalitysymmetric).
assert (neq e b) by (forward_using lemma_betweennotequal).
assert (~ Meet a b C D).
intro.
let Tf:=fresh in assert (Tf:exists R, (neq a b /\\ neq C D /\\ Col a b R /\\ Col C D R)) by (conclude_def Meet );destruct Tf as [R];spliter.
assert (Col b a R) by (forward_using lemma_collinearorder).
assert (Col B a b) by (conclude lemma_collinear4).
assert (Col b a B) by (forward_using lemma_collinearorder).
assert (Col a B R) by (conclude lemma_collinear4).
assert (Col a B A) by (forward_using lemma_collinearorder).
assert (Col A B R).
by cases on (neq a B \\/ eq a B).
assert (neq A a) by (conclude cn_equalitysub).

*****
H23 : neq A a
H24 : eq a B
H22 : Col a B A
H21 : Col a B R
H20 : Col b a B
H19 : Col B a b
H18 : Col b a R
H17 : Col C D R
H16 : Col a b R
H15 : neq C D
H14 : neq a b
R : Point
H13 : Meet a b C D
H12 : neq e b
H11 : neq b a
H10 : BetS c e b
H9 : BetS a e d
H8 : not (Meet A B C D)
H7 : neq c d
H6 : Col C D d
H5 : Col C D c
H4 : neq a b
H3 : Col A B b
H2 : Col A B a
H1 : neq C D
H0 : neq A B
a,b,c,d,e : Point
H : Par A B C D
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
Col A B R
+++++
assert (Col B A a) by (forward_using lemma_collinearorder).
-----
Lemma lemma_paralleldef2B : forall A B C D, Par A B C D -> TP A B C D.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists a b c d e, (neq A B /\\ neq C D /\\ Col A B a /\\ Col A B b /\\ neq a b /\\ Col C D c /\\ Col C D d /\\ neq c d /\\ ~ Meet A B C D /\\ BetS a e d /\\ BetS c e b)) by (conclude_def Par );destruct Tf as [a[b[c[d[e]]]]];spliter.
assert (neq b a) by (conclude lemma_inequalitysymmetric).
assert (neq e b) by (forward_using lemma_betweennotequal).
assert (~ Meet a b C D).
intro.
let Tf:=fresh in assert (Tf:exists R, (neq a b /\\ neq C D /\\ Col a b R /\\ Col C D R)) by (conclude_def Meet );destruct Tf as [R];spliter.
assert (Col b a R) by (forward_using lemma_collinearorder).
assert (Col B a b) by (conclude lemma_collinear4).
assert (Col b a B) by (forward_using lemma_collinearorder).
assert (Col a B R) by (conclude lemma_collinear4).
assert (Col a B A) by (forward_using lemma_collinearorder).
assert (Col A B R).
by cases on (neq a B \\/ eq a B).
assert (neq A a) by (conclude cn_equalitysub).
assert (Col B A a) by (forward_using lemma_collinearorder).

*****
H25 : Col B A a
H23 : neq A a
H24 : eq a B
H22 : Col a B A
H21 : Col a B R
H20 : Col b a B
H19 : Col B a b
H18 : Col b a R
H17 : Col C D R
H16 : Col a b R
H15 : neq C D
H14 : neq a b
R : Point
H13 : Meet a b C D
H12 : neq e b
H11 : neq b a
H10 : BetS c e b
H9 : BetS a e d
H8 : not (Meet A B C D)
H7 : neq c d
H6 : Col C D d
H5 : Col C D c
H4 : neq a b
H3 : Col A B b
H2 : Col A B a
H1 : neq C D
H0 : neq A B
a,b,c,d,e : Point
H : Par A B C D
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
Col A B R
+++++
assert (Col B A b) by (forward_using lemma_collinearorder).
-----
Lemma lemma_paralleldef2B : forall A B C D, Par A B C D -> TP A B C D.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists a b c d e, (neq A B /\\ neq C D /\\ Col A B a /\\ Col A B b /\\ neq a b /\\ Col C D c /\\ Col C D d /\\ neq c d /\\ ~ Meet A B C D /\\ BetS a e d /\\ BetS c e b)) by (conclude_def Par );destruct Tf as [a[b[c[d[e]]]]];spliter.
assert (neq b a) by (conclude lemma_inequalitysymmetric).
assert (neq e b) by (forward_using lemma_betweennotequal).
assert (~ Meet a b C D).
intro.
let Tf:=fresh in assert (Tf:exists R, (neq a b /\\ neq C D /\\ Col a b R /\\ Col C D R)) by (conclude_def Meet );destruct Tf as [R];spliter.
assert (Col b a R) by (forward_using lemma_collinearorder).
assert (Col B a b) by (conclude lemma_collinear4).
assert (Col b a B) by (forward_using lemma_collinearorder).
assert (Col a B R) by (conclude lemma_collinear4).
assert (Col a B A) by (forward_using lemma_collinearorder).
assert (Col A B R).
by cases on (neq a B \\/ eq a B).
assert (neq A a) by (conclude cn_equalitysub).
assert (Col B A a) by (forward_using lemma_collinearorder).
assert (Col B A b) by (forward_using lemma_collinearorder).

*****
H26 : Col B A b
H25 : Col B A a
H23 : neq A a
H24 : eq a B
H22 : Col a B A
H21 : Col a B R
H20 : Col b a B
H19 : Col B a b
H18 : Col b a R
H17 : Col C D R
H16 : Col a b R
H15 : neq C D
H14 : neq a b
R : Point
H13 : Meet a b C D
H12 : neq e b
H11 : neq b a
H10 : BetS c e b
H9 : BetS a e d
H8 : not (Meet A B C D)
H7 : neq c d
H6 : Col C D d
H5 : Col C D c
H4 : neq a b
H3 : Col A B b
H2 : Col A B a
H1 : neq C D
H0 : neq A B
a,b,c,d,e : Point
H : Par A B C D
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
Col A B R
+++++
assert (neq B A) by (conclude lemma_inequalitysymmetric).
-----
Lemma lemma_paralleldef2B : forall A B C D, Par A B C D -> TP A B C D.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists a b c d e, (neq A B /\\ neq C D /\\ Col A B a /\\ Col A B b /\\ neq a b /\\ Col C D c /\\ Col C D d /\\ neq c d /\\ ~ Meet A B C D /\\ BetS a e d /\\ BetS c e b)) by (conclude_def Par );destruct Tf as [a[b[c[d[e]]]]];spliter.
assert (neq b a) by (conclude lemma_inequalitysymmetric).
assert (neq e b) by (forward_using lemma_betweennotequal).
assert (~ Meet a b C D).
intro.
let Tf:=fresh in assert (Tf:exists R, (neq a b /\\ neq C D /\\ Col a b R /\\ Col C D R)) by (conclude_def Meet );destruct Tf as [R];spliter.
assert (Col b a R) by (forward_using lemma_collinearorder).
assert (Col B a b) by (conclude lemma_collinear4).
assert (Col b a B) by (forward_using lemma_collinearorder).
assert (Col a B R) by (conclude lemma_collinear4).
assert (Col a B A) by (forward_using lemma_collinearorder).
assert (Col A B R).
by cases on (neq a B \\/ eq a B).
assert (neq A a) by (conclude cn_equalitysub).
assert (Col B A a) by (forward_using lemma_collinearorder).
assert (Col B A b) by (forward_using lemma_collinearorder).
assert (neq B A) by (conclude lemma_inequalitysymmetric).

*****
H27 : neq B A
H26 : Col B A b
H25 : Col B A a
H23 : neq A a
H24 : eq a B
H22 : Col a B A
H21 : Col a B R
H20 : Col b a B
H19 : Col B a b
H18 : Col b a R
H17 : Col C D R
H16 : Col a b R
H15 : neq C D
H14 : neq a b
R : Point
H13 : Meet a b C D
H12 : neq e b
H11 : neq b a
H10 : BetS c e b
H9 : BetS a e d
H8 : not (Meet A B C D)
H7 : neq c d
H6 : Col C D d
H5 : Col C D c
H4 : neq a b
H3 : Col A B b
H2 : Col A B a
H1 : neq C D
H0 : neq A B
a,b,c,d,e : Point
H : Par A B C D
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
Col A B R
+++++
assert (Col A a b) by (conclude lemma_collinear4).
-----
Lemma lemma_paralleldef2B : forall A B C D, Par A B C D -> TP A B C D.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists a b c d e, (neq A B /\\ neq C D /\\ Col A B a /\\ Col A B b /\\ neq a b /\\ Col C D c /\\ Col C D d /\\ neq c d /\\ ~ Meet A B C D /\\ BetS a e d /\\ BetS c e b)) by (conclude_def Par );destruct Tf as [a[b[c[d[e]]]]];spliter.
assert (neq b a) by (conclude lemma_inequalitysymmetric).
assert (neq e b) by (forward_using lemma_betweennotequal).
assert (~ Meet a b C D).
intro.
let Tf:=fresh in assert (Tf:exists R, (neq a b /\\ neq C D /\\ Col a b R /\\ Col C D R)) by (conclude_def Meet );destruct Tf as [R];spliter.
assert (Col b a R) by (forward_using lemma_collinearorder).
assert (Col B a b) by (conclude lemma_collinear4).
assert (Col b a B) by (forward_using lemma_collinearorder).
assert (Col a B R) by (conclude lemma_collinear4).
assert (Col a B A) by (forward_using lemma_collinearorder).
assert (Col A B R).
by cases on (neq a B \\/ eq a B).
assert (neq A a) by (conclude cn_equalitysub).
assert (Col B A a) by (forward_using lemma_collinearorder).
assert (Col B A b) by (forward_using lemma_collinearorder).
assert (neq B A) by (conclude lemma_inequalitysymmetric).
assert (Col A a b) by (conclude lemma_collinear4).

*****
H28 : Col A a b
H27 : neq B A
H26 : Col B A b
H25 : Col B A a
H23 : neq A a
H24 : eq a B
H22 : Col a B A
H21 : Col a B R
H20 : Col b a B
H19 : Col B a b
H18 : Col b a R
H17 : Col C D R
H16 : Col a b R
H15 : neq C D
H14 : neq a b
R : Point
H13 : Meet a b C D
H12 : neq e b
H11 : neq b a
H10 : BetS c e b
H9 : BetS a e d
H8 : not (Meet A B C D)
H7 : neq c d
H6 : Col C D d
H5 : Col C D c
H4 : neq a b
H3 : Col A B b
H2 : Col A B a
H1 : neq C D
H0 : neq A B
a,b,c,d,e : Point
H : Par A B C D
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
Col A B R
+++++
assert (Col b a A) by (forward_using lemma_collinearorder).
-----
Lemma lemma_paralleldef2B : forall A B C D, Par A B C D -> TP A B C D.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists a b c d e, (neq A B /\\ neq C D /\\ Col A B a /\\ Col A B b /\\ neq a b /\\ Col C D c /\\ Col C D d /\\ neq c d /\\ ~ Meet A B C D /\\ BetS a e d /\\ BetS c e b)) by (conclude_def Par );destruct Tf as [a[b[c[d[e]]]]];spliter.
assert (neq b a) by (conclude lemma_inequalitysymmetric).
assert (neq e b) by (forward_using lemma_betweennotequal).
assert (~ Meet a b C D).
intro.
let Tf:=fresh in assert (Tf:exists R, (neq a b /\\ neq C D /\\ Col a b R /\\ Col C D R)) by (conclude_def Meet );destruct Tf as [R];spliter.
assert (Col b a R) by (forward_using lemma_collinearorder).
assert (Col B a b) by (conclude lemma_collinear4).
assert (Col b a B) by (forward_using lemma_collinearorder).
assert (Col a B R) by (conclude lemma_collinear4).
assert (Col a B A) by (forward_using lemma_collinearorder).
assert (Col A B R).
by cases on (neq a B \\/ eq a B).
assert (neq A a) by (conclude cn_equalitysub).
assert (Col B A a) by (forward_using lemma_collinearorder).
assert (Col B A b) by (forward_using lemma_collinearorder).
assert (neq B A) by (conclude lemma_inequalitysymmetric).
assert (Col A a b) by (conclude lemma_collinear4).
assert (Col b a A) by (forward_using lemma_collinearorder).

*****
H29 : Col b a A
H28 : Col A a b
H27 : neq B A
H26 : Col B A b
H25 : Col B A a
H23 : neq A a
H24 : eq a B
H22 : Col a B A
H21 : Col a B R
H20 : Col b a B
H19 : Col B a b
H18 : Col b a R
H17 : Col C D R
H16 : Col a b R
H15 : neq C D
H14 : neq a b
R : Point
H13 : Meet a b C D
H12 : neq e b
H11 : neq b a
H10 : BetS c e b
H9 : BetS a e d
H8 : not (Meet A B C D)
H7 : neq c d
H6 : Col C D d
H5 : Col C D c
H4 : neq a b
H3 : Col A B b
H2 : Col A B a
H1 : neq C D
H0 : neq A B
a,b,c,d,e : Point
H : Par A B C D
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
Col A B R
+++++
assert (Col a A R) by (conclude lemma_collinear4).
-----
Lemma lemma_paralleldef2B : forall A B C D, Par A B C D -> TP A B C D.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists a b c d e, (neq A B /\\ neq C D /\\ Col A B a /\\ Col A B b /\\ neq a b /\\ Col C D c /\\ Col C D d /\\ neq c d /\\ ~ Meet A B C D /\\ BetS a e d /\\ BetS c e b)) by (conclude_def Par );destruct Tf as [a[b[c[d[e]]]]];spliter.
assert (neq b a) by (conclude lemma_inequalitysymmetric).
assert (neq e b) by (forward_using lemma_betweennotequal).
assert (~ Meet a b C D).
intro.
let Tf:=fresh in assert (Tf:exists R, (neq a b /\\ neq C D /\\ Col a b R /\\ Col C D R)) by (conclude_def Meet );destruct Tf as [R];spliter.
assert (Col b a R) by (forward_using lemma_collinearorder).
assert (Col B a b) by (conclude lemma_collinear4).
assert (Col b a B) by (forward_using lemma_collinearorder).
assert (Col a B R) by (conclude lemma_collinear4).
assert (Col a B A) by (forward_using lemma_collinearorder).
assert (Col A B R).
by cases on (neq a B \\/ eq a B).
assert (neq A a) by (conclude cn_equalitysub).
assert (Col B A a) by (forward_using lemma_collinearorder).
assert (Col B A b) by (forward_using lemma_collinearorder).
assert (neq B A) by (conclude lemma_inequalitysymmetric).
assert (Col A a b) by (conclude lemma_collinear4).
assert (Col b a A) by (forward_using lemma_collinearorder).
assert (Col a A R) by (conclude lemma_collinear4).

*****
H30 : Col a A R
H29 : Col b a A
H28 : Col A a b
H27 : neq B A
H26 : Col B A b
H25 : Col B A a
H23 : neq A a
H24 : eq a B
H22 : Col a B A
H21 : Col a B R
H20 : Col b a B
H19 : Col B a b
H18 : Col b a R
H17 : Col C D R
H16 : Col a b R
H15 : neq C D
H14 : neq a b
R : Point
H13 : Meet a b C D
H12 : neq e b
H11 : neq b a
H10 : BetS c e b
H9 : BetS a e d
H8 : not (Meet A B C D)
H7 : neq c d
H6 : Col C D d
H5 : Col C D c
H4 : neq a b
H3 : Col A B b
H2 : Col A B a
H1 : neq C D
H0 : neq A B
a,b,c,d,e : Point
H : Par A B C D
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
Col A B R
+++++
assert (Col a A B) by (forward_using lemma_collinearorder).
-----
Lemma lemma_paralleldef2B : forall A B C D, Par A B C D -> TP A B C D.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists a b c d e, (neq A B /\\ neq C D /\\ Col A B a /\\ Col A B b /\\ neq a b /\\ Col C D c /\\ Col C D d /\\ neq c d /\\ ~ Meet A B C D /\\ BetS a e d /\\ BetS c e b)) by (conclude_def Par );destruct Tf as [a[b[c[d[e]]]]];spliter.
assert (neq b a) by (conclude lemma_inequalitysymmetric).
assert (neq e b) by (forward_using lemma_betweennotequal).
assert (~ Meet a b C D).
intro.
let Tf:=fresh in assert (Tf:exists R, (neq a b /\\ neq C D /\\ Col a b R /\\ Col C D R)) by (conclude_def Meet );destruct Tf as [R];spliter.
assert (Col b a R) by (forward_using lemma_collinearorder).
assert (Col B a b) by (conclude lemma_collinear4).
assert (Col b a B) by (forward_using lemma_collinearorder).
assert (Col a B R) by (conclude lemma_collinear4).
assert (Col a B A) by (forward_using lemma_collinearorder).
assert (Col A B R).
by cases on (neq a B \\/ eq a B).
assert (neq A a) by (conclude cn_equalitysub).
assert (Col B A a) by (forward_using lemma_collinearorder).
assert (Col B A b) by (forward_using lemma_collinearorder).
assert (neq B A) by (conclude lemma_inequalitysymmetric).
assert (Col A a b) by (conclude lemma_collinear4).
assert (Col b a A) by (forward_using lemma_collinearorder).
assert (Col a A R) by (conclude lemma_collinear4).
assert (Col a A B) by (forward_using lemma_collinearorder).

*****
H31 : Col a A B
H30 : Col a A R
H29 : Col b a A
H28 : Col A a b
H27 : neq B A
H26 : Col B A b
H25 : Col B A a
H23 : neq A a
H24 : eq a B
H22 : Col a B A
H21 : Col a B R
H20 : Col b a B
H19 : Col B a b
H18 : Col b a R
H17 : Col C D R
H16 : Col a b R
H15 : neq C D
H14 : neq a b
R : Point
H13 : Meet a b C D
H12 : neq e b
H11 : neq b a
H10 : BetS c e b
H9 : BetS a e d
H8 : not (Meet A B C D)
H7 : neq c d
H6 : Col C D d
H5 : Col C D c
H4 : neq a b
H3 : Col A B b
H2 : Col A B a
H1 : neq C D
H0 : neq A B
a,b,c,d,e : Point
H : Par A B C D
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
Col A B R
+++++
assert (neq A a) by (conclude cn_equalitysub).
-----
Lemma lemma_paralleldef2B : forall A B C D, Par A B C D -> TP A B C D.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists a b c d e, (neq A B /\\ neq C D /\\ Col A B a /\\ Col A B b /\\ neq a b /\\ Col C D c /\\ Col C D d /\\ neq c d /\\ ~ Meet A B C D /\\ BetS a e d /\\ BetS c e b)) by (conclude_def Par );destruct Tf as [a[b[c[d[e]]]]];spliter.
assert (neq b a) by (conclude lemma_inequalitysymmetric).
assert (neq e b) by (forward_using lemma_betweennotequal).
assert (~ Meet a b C D).
intro.
let Tf:=fresh in assert (Tf:exists R, (neq a b /\\ neq C D /\\ Col a b R /\\ Col C D R)) by (conclude_def Meet );destruct Tf as [R];spliter.
assert (Col b a R) by (forward_using lemma_collinearorder).
assert (Col B a b) by (conclude lemma_collinear4).
assert (Col b a B) by (forward_using lemma_collinearorder).
assert (Col a B R) by (conclude lemma_collinear4).
assert (Col a B A) by (forward_using lemma_collinearorder).
assert (Col A B R).
by cases on (neq a B \\/ eq a B).
assert (neq A a) by (conclude cn_equalitysub).
assert (Col B A a) by (forward_using lemma_collinearorder).
assert (Col B A b) by (forward_using lemma_collinearorder).
assert (neq B A) by (conclude lemma_inequalitysymmetric).
assert (Col A a b) by (conclude lemma_collinear4).
assert (Col b a A) by (forward_using lemma_collinearorder).
assert (Col a A R) by (conclude lemma_collinear4).
assert (Col a A B) by (forward_using lemma_collinearorder).
assert (neq A a) by (conclude cn_equalitysub).

*****
H32 : neq A a
H31 : Col a A B
H30 : Col a A R
H29 : Col b a A
H28 : Col A a b
H27 : neq B A
H26 : Col B A b
H25 : Col B A a
H23 : neq A a
H24 : eq a B
H22 : Col a B A
H21 : Col a B R
H20 : Col b a B
H19 : Col B a b
H18 : Col b a R
H17 : Col C D R
H16 : Col a b R
H15 : neq C D
H14 : neq a b
R : Point
H13 : Meet a b C D
H12 : neq e b
H11 : neq b a
H10 : BetS c e b
H9 : BetS a e d
H8 : not (Meet A B C D)
H7 : neq c d
H6 : Col C D d
H5 : Col C D c
H4 : neq a b
H3 : Col A B b
H2 : Col A B a
H1 : neq C D
H0 : neq A B
a,b,c,d,e : Point
H : Par A B C D
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
Col A B R
+++++
assert (neq a A) by (conclude lemma_inequalitysymmetric).
-----
Lemma lemma_paralleldef2B : forall A B C D, Par A B C D -> TP A B C D.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists a b c d e, (neq A B /\\ neq C D /\\ Col A B a /\\ Col A B b /\\ neq a b /\\ Col C D c /\\ Col C D d /\\ neq c d /\\ ~ Meet A B C D /\\ BetS a e d /\\ BetS c e b)) by (conclude_def Par );destruct Tf as [a[b[c[d[e]]]]];spliter.
assert (neq b a) by (conclude lemma_inequalitysymmetric).
assert (neq e b) by (forward_using lemma_betweennotequal).
assert (~ Meet a b C D).
intro.
let Tf:=fresh in assert (Tf:exists R, (neq a b /\\ neq C D /\\ Col a b R /\\ Col C D R)) by (conclude_def Meet );destruct Tf as [R];spliter.
assert (Col b a R) by (forward_using lemma_collinearorder).
assert (Col B a b) by (conclude lemma_collinear4).
assert (Col b a B) by (forward_using lemma_collinearorder).
assert (Col a B R) by (conclude lemma_collinear4).
assert (Col a B A) by (forward_using lemma_collinearorder).
assert (Col A B R).
by cases on (neq a B \\/ eq a B).
assert (neq A a) by (conclude cn_equalitysub).
assert (Col B A a) by (forward_using lemma_collinearorder).
assert (Col B A b) by (forward_using lemma_collinearorder).
assert (neq B A) by (conclude lemma_inequalitysymmetric).
assert (Col A a b) by (conclude lemma_collinear4).
assert (Col b a A) by (forward_using lemma_collinearorder).
assert (Col a A R) by (conclude lemma_collinear4).
assert (Col a A B) by (forward_using lemma_collinearorder).
assert (neq A a) by (conclude cn_equalitysub).
assert (neq a A) by (conclude lemma_inequalitysymmetric).

*****
H33 : neq a A
H32 : neq A a
H31 : Col a A B
H30 : Col a A R
H29 : Col b a A
H28 : Col A a b
H27 : neq B A
H26 : Col B A b
H25 : Col B A a
H23 : neq A a
H24 : eq a B
H22 : Col a B A
H21 : Col a B R
H20 : Col b a B
H19 : Col B a b
H18 : Col b a R
H17 : Col C D R
H16 : Col a b R
H15 : neq C D
H14 : neq a b
R : Point
H13 : Meet a b C D
H12 : neq e b
H11 : neq b a
H10 : BetS c e b
H9 : BetS a e d
H8 : not (Meet A B C D)
H7 : neq c d
H6 : Col C D d
H5 : Col C D c
H4 : neq a b
H3 : Col A B b
H2 : Col A B a
H1 : neq C D
H0 : neq A B
a,b,c,d,e : Point
H : Par A B C D
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
Col A B R
+++++
assert (Col A R B) by (conclude lemma_collinear4).
-----
Lemma lemma_paralleldef2B : forall A B C D, Par A B C D -> TP A B C D.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists a b c d e, (neq A B /\\ neq C D /\\ Col A B a /\\ Col A B b /\\ neq a b /\\ Col C D c /\\ Col C D d /\\ neq c d /\\ ~ Meet A B C D /\\ BetS a e d /\\ BetS c e b)) by (conclude_def Par );destruct Tf as [a[b[c[d[e]]]]];spliter.
assert (neq b a) by (conclude lemma_inequalitysymmetric).
assert (neq e b) by (forward_using lemma_betweennotequal).
assert (~ Meet a b C D).
intro.
let Tf:=fresh in assert (Tf:exists R, (neq a b /\\ neq C D /\\ Col a b R /\\ Col C D R)) by (conclude_def Meet );destruct Tf as [R];spliter.
assert (Col b a R) by (forward_using lemma_collinearorder).
assert (Col B a b) by (conclude lemma_collinear4).
assert (Col b a B) by (forward_using lemma_collinearorder).
assert (Col a B R) by (conclude lemma_collinear4).
assert (Col a B A) by (forward_using lemma_collinearorder).
assert (Col A B R).
by cases on (neq a B \\/ eq a B).
assert (neq A a) by (conclude cn_equalitysub).
assert (Col B A a) by (forward_using lemma_collinearorder).
assert (Col B A b) by (forward_using lemma_collinearorder).
assert (neq B A) by (conclude lemma_inequalitysymmetric).
assert (Col A a b) by (conclude lemma_collinear4).
assert (Col b a A) by (forward_using lemma_collinearorder).
assert (Col a A R) by (conclude lemma_collinear4).
assert (Col a A B) by (forward_using lemma_collinearorder).
assert (neq A a) by (conclude cn_equalitysub).
assert (neq a A) by (conclude lemma_inequalitysymmetric).
assert (Col A R B) by (conclude lemma_collinear4).

*****
H34 : Col A R B
H33 : neq a A
H32 : neq A a
H31 : Col a A B
H30 : Col a A R
H29 : Col b a A
H28 : Col A a b
H27 : neq B A
H26 : Col B A b
H25 : Col B A a
H23 : neq A a
H24 : eq a B
H22 : Col a B A
H21 : Col a B R
H20 : Col b a B
H19 : Col B a b
H18 : Col b a R
H17 : Col C D R
H16 : Col a b R
H15 : neq C D
H14 : neq a b
R : Point
H13 : Meet a b C D
H12 : neq e b
H11 : neq b a
H10 : BetS c e b
H9 : BetS a e d
H8 : not (Meet A B C D)
H7 : neq c d
H6 : Col C D d
H5 : Col C D c
H4 : neq a b
H3 : Col A B b
H2 : Col A B a
H1 : neq C D
H0 : neq A B
a,b,c,d,e : Point
H : Par A B C D
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
Col A B R
+++++
assert (Col A B R) by (forward_using lemma_collinearorder).
-----
Lemma lemma_paralleldef2B : forall A B C D, Par A B C D -> TP A B C D.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists a b c d e, (neq A B /\\ neq C D /\\ Col A B a /\\ Col A B b /\\ neq a b /\\ Col C D c /\\ Col C D d /\\ neq c d /\\ ~ Meet A B C D /\\ BetS a e d /\\ BetS c e b)) by (conclude_def Par );destruct Tf as [a[b[c[d[e]]]]];spliter.
assert (neq b a) by (conclude lemma_inequalitysymmetric).
assert (neq e b) by (forward_using lemma_betweennotequal).
assert (~ Meet a b C D).
intro.
let Tf:=fresh in assert (Tf:exists R, (neq a b /\\ neq C D /\\ Col a b R /\\ Col C D R)) by (conclude_def Meet );destruct Tf as [R];spliter.
assert (Col b a R) by (forward_using lemma_collinearorder).
assert (Col B a b) by (conclude lemma_collinear4).
assert (Col b a B) by (forward_using lemma_collinearorder).
assert (Col a B R) by (conclude lemma_collinear4).
assert (Col a B A) by (forward_using lemma_collinearorder).
assert (Col A B R).
by cases on (neq a B \\/ eq a B).
assert (neq A a) by (conclude cn_equalitysub).
assert (Col B A a) by (forward_using lemma_collinearorder).
assert (Col B A b) by (forward_using lemma_collinearorder).
assert (neq B A) by (conclude lemma_inequalitysymmetric).
assert (Col A a b) by (conclude lemma_collinear4).
assert (Col b a A) by (forward_using lemma_collinearorder).
assert (Col a A R) by (conclude lemma_collinear4).
assert (Col a A B) by (forward_using lemma_collinearorder).
assert (neq A a) by (conclude cn_equalitysub).
assert (neq a A) by (conclude lemma_inequalitysymmetric).
assert (Col A R B) by (conclude lemma_collinear4).
assert (Col A B R) by (forward_using lemma_collinearorder).

*****
H35 : Col A B R
H34 : Col A R B
H33 : neq a A
H32 : neq A a
H31 : Col a A B
H30 : Col a A R
H29 : Col b a A
H28 : Col A a b
H27 : neq B A
H26 : Col B A b
H25 : Col B A a
H23 : neq A a
H24 : eq a B
H22 : Col a B A
H21 : Col a B R
H20 : Col b a B
H19 : Col B a b
H18 : Col b a R
H17 : Col C D R
H16 : Col a b R
H15 : neq C D
H14 : neq a b
R : Point
H13 : Meet a b C D
H12 : neq e b
H11 : neq b a
H10 : BetS c e b
H9 : BetS a e d
H8 : not (Meet A B C D)
H7 : neq c d
H6 : Col C D d
H5 : Col C D c
H4 : neq a b
H3 : Col A B b
H2 : Col A B a
H1 : neq C D
H0 : neq A B
a,b,c,d,e : Point
H : Par A B C D
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
Col A B R
+++++
close.
-----
Lemma lemma_paralleldef2B : forall A B C D, Par A B C D -> TP A B C D.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists a b c d e, (neq A B /\\ neq C D /\\ Col A B a /\\ Col A B b /\\ neq a b /\\ Col C D c /\\ Col C D d /\\ neq c d /\\ ~ Meet A B C D /\\ BetS a e d /\\ BetS c e b)) by (conclude_def Par );destruct Tf as [a[b[c[d[e]]]]];spliter.
assert (neq b a) by (conclude lemma_inequalitysymmetric).
assert (neq e b) by (forward_using lemma_betweennotequal).
assert (~ Meet a b C D).
intro.
let Tf:=fresh in assert (Tf:exists R, (neq a b /\\ neq C D /\\ Col a b R /\\ Col C D R)) by (conclude_def Meet );destruct Tf as [R];spliter.
assert (Col b a R) by (forward_using lemma_collinearorder).
assert (Col B a b) by (conclude lemma_collinear4).
assert (Col b a B) by (forward_using lemma_collinearorder).
assert (Col a B R) by (conclude lemma_collinear4).
assert (Col a B A) by (forward_using lemma_collinearorder).
assert (Col A B R).
by cases on (neq a B \\/ eq a B).

*****
H23 : Col A B R
H22 : Col a B A
H21 : Col a B R
H20 : Col b a B
H19 : Col B a b
H18 : Col b a R
H17 : Col C D R
H16 : Col a b R
H15 : neq C D
H14 : neq a b
R : Point
H13 : Meet a b C D
H12 : neq e b
H11 : neq b a
H10 : BetS c e b
H9 : BetS a e d
H8 : not (Meet A B C D)
H7 : neq c d
H6 : Col C D d
H5 : Col C D c
H4 : neq a b
H3 : Col A B b
H2 : Col A B a
H1 : neq C D
H0 : neq A B
a,b,c,d,e : Point
H : Par A B C D
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
False
+++++
assert (Meet A B C D) by (conclude_def Meet ).
-----
Lemma lemma_paralleldef2B : forall A B C D, Par A B C D -> TP A B C D.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists a b c d e, (neq A B /\\ neq C D /\\ Col A B a /\\ Col A B b /\\ neq a b /\\ Col C D c /\\ Col C D d /\\ neq c d /\\ ~ Meet A B C D /\\ BetS a e d /\\ BetS c e b)) by (conclude_def Par );destruct Tf as [a[b[c[d[e]]]]];spliter.
assert (neq b a) by (conclude lemma_inequalitysymmetric).
assert (neq e b) by (forward_using lemma_betweennotequal).
assert (~ Meet a b C D).
intro.
let Tf:=fresh in assert (Tf:exists R, (neq a b /\\ neq C D /\\ Col a b R /\\ Col C D R)) by (conclude_def Meet );destruct Tf as [R];spliter.
assert (Col b a R) by (forward_using lemma_collinearorder).
assert (Col B a b) by (conclude lemma_collinear4).
assert (Col b a B) by (forward_using lemma_collinearorder).
assert (Col a B R) by (conclude lemma_collinear4).
assert (Col a B A) by (forward_using lemma_collinearorder).
assert (Col A B R).
by cases on (neq a B \\/ eq a B).
assert (Meet A B C D) by (conclude_def Meet ).

*****
H24 : Meet A B C D
H23 : Col A B R
H22 : Col a B A
H21 : Col a B R
H20 : Col b a B
H19 : Col B a b
H18 : Col b a R
H17 : Col C D R
H16 : Col a b R
H15 : neq C D
H14 : neq a b
R : Point
H13 : Meet a b C D
H12 : neq e b
H11 : neq b a
H10 : BetS c e b
H9 : BetS a e d
H8 : not (Meet A B C D)
H7 : neq c d
H6 : Col C D d
H5 : Col C D c
H4 : neq a b
H3 : Col A B b
H2 : Col A B a
H1 : neq C D
H0 : neq A B
a,b,c,d,e : Point
H : Par A B C D
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
False
+++++
contradict.
-----
Lemma lemma_paralleldef2B : forall A B C D, Par A B C D -> TP A B C D.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists a b c d e, (neq A B /\\ neq C D /\\ Col A B a /\\ Col A B b /\\ neq a b /\\ Col C D c /\\ Col C D d /\\ neq c d /\\ ~ Meet A B C D /\\ BetS a e d /\\ BetS c e b)) by (conclude_def Par );destruct Tf as [a[b[c[d[e]]]]];spliter.
assert (neq b a) by (conclude lemma_inequalitysymmetric).
assert (neq e b) by (forward_using lemma_betweennotequal).
assert (~ Meet a b C D).

*****
H13 : not (Meet a b C D)
H12 : neq e b
H11 : neq b a
H10 : BetS c e b
H9 : BetS a e d
H8 : not (Meet A B C D)
H7 : neq c d
H6 : Col C D d
H5 : Col C D c
H4 : neq a b
H3 : Col A B b
H2 : Col A B a
H1 : neq C D
H0 : neq A B
a,b,c,d,e : Point
H : Par A B C D
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
TP A B C D
+++++
let Tf:=fresh in assert (Tf:exists P, (BetS e b P /\ Cong b P e b)) by (conclude lemma_extension);destruct Tf as [P];spliter.
-----
Lemma lemma_paralleldef2B : forall A B C D, Par A B C D -> TP A B C D.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists a b c d e, (neq A B /\\ neq C D /\\ Col A B a /\\ Col A B b /\\ neq a b /\\ Col C D c /\\ Col C D d /\\ neq c d /\\ ~ Meet A B C D /\\ BetS a e d /\\ BetS c e b)) by (conclude_def Par );destruct Tf as [a[b[c[d[e]]]]];spliter.
assert (neq b a) by (conclude lemma_inequalitysymmetric).
assert (neq e b) by (forward_using lemma_betweennotequal).
assert (~ Meet a b C D).
let Tf:=fresh in assert (Tf:exists P, (BetS e b P /\\ Cong b P e b)) by (conclude lemma_extension);destruct Tf as [P];spliter.

*****
H15 : Cong b P e b
H14 : BetS e b P
P : Point
H13 : not (Meet a b C D)
H12 : neq e b
H11 : neq b a
H10 : BetS c e b
H9 : BetS a e d
H8 : not (Meet A B C D)
H7 : neq c d
H6 : Col C D d
H5 : Col C D c
H4 : neq a b
H3 : Col A B b
H2 : Col A B a
H1 : neq C D
H0 : neq A B
a,b,c,d,e : Point
H : Par A B C D
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
TP A B C D
+++++
assert (BetS P b e) by (conclude axiom_betweennesssymmetry).
-----
Lemma lemma_paralleldef2B : forall A B C D, Par A B C D -> TP A B C D.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists a b c d e, (neq A B /\\ neq C D /\\ Col A B a /\\ Col A B b /\\ neq a b /\\ Col C D c /\\ Col C D d /\\ neq c d /\\ ~ Meet A B C D /\\ BetS a e d /\\ BetS c e b)) by (conclude_def Par );destruct Tf as [a[b[c[d[e]]]]];spliter.
assert (neq b a) by (conclude lemma_inequalitysymmetric).
assert (neq e b) by (forward_using lemma_betweennotequal).
assert (~ Meet a b C D).
let Tf:=fresh in assert (Tf:exists P, (BetS e b P /\\ Cong b P e b)) by (conclude lemma_extension);destruct Tf as [P];spliter.
assert (BetS P b e) by (conclude axiom_betweennesssymmetry).

*****
H16 : BetS P b e
H15 : Cong b P e b
H14 : BetS e b P
P : Point
H13 : not (Meet a b C D)
H12 : neq e b
H11 : neq b a
H10 : BetS c e b
H9 : BetS a e d
H8 : not (Meet A B C D)
H7 : neq c d
H6 : Col C D d
H5 : Col C D c
H4 : neq a b
H3 : Col A B b
H2 : Col A B a
H1 : neq C D
H0 : neq A B
a,b,c,d,e : Point
H : Par A B C D
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
TP A B C D
+++++
assert (BetS b e c) by (conclude axiom_betweennesssymmetry).
-----
Lemma lemma_paralleldef2B : forall A B C D, Par A B C D -> TP A B C D.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists a b c d e, (neq A B /\\ neq C D /\\ Col A B a /\\ Col A B b /\\ neq a b /\\ Col C D c /\\ Col C D d /\\ neq c d /\\ ~ Meet A B C D /\\ BetS a e d /\\ BetS c e b)) by (conclude_def Par );destruct Tf as [a[b[c[d[e]]]]];spliter.
assert (neq b a) by (conclude lemma_inequalitysymmetric).
assert (neq e b) by (forward_using lemma_betweennotequal).
assert (~ Meet a b C D).
let Tf:=fresh in assert (Tf:exists P, (BetS e b P /\\ Cong b P e b)) by (conclude lemma_extension);destruct Tf as [P];spliter.
assert (BetS P b e) by (conclude axiom_betweennesssymmetry).
assert (BetS b e c) by (conclude axiom_betweennesssymmetry).

*****
H17 : BetS b e c
H16 : BetS P b e
H15 : Cong b P e b
H14 : BetS e b P
P : Point
H13 : not (Meet a b C D)
H12 : neq e b
H11 : neq b a
H10 : BetS c e b
H9 : BetS a e d
H8 : not (Meet A B C D)
H7 : neq c d
H6 : Col C D d
H5 : Col C D c
H4 : neq a b
H3 : Col A B b
H2 : Col A B a
H1 : neq C D
H0 : neq A B
a,b,c,d,e : Point
H : Par A B C D
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
TP A B C D
+++++
assert (BetS P b c) by (conclude lemma_3_7b).
-----
Lemma lemma_paralleldef2B : forall A B C D, Par A B C D -> TP A B C D.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists a b c d e, (neq A B /\\ neq C D /\\ Col A B a /\\ Col A B b /\\ neq a b /\\ Col C D c /\\ Col C D d /\\ neq c d /\\ ~ Meet A B C D /\\ BetS a e d /\\ BetS c e b)) by (conclude_def Par );destruct Tf as [a[b[c[d[e]]]]];spliter.
assert (neq b a) by (conclude lemma_inequalitysymmetric).
assert (neq e b) by (forward_using lemma_betweennotequal).
assert (~ Meet a b C D).
let Tf:=fresh in assert (Tf:exists P, (BetS e b P /\\ Cong b P e b)) by (conclude lemma_extension);destruct Tf as [P];spliter.
assert (BetS P b e) by (conclude axiom_betweennesssymmetry).
assert (BetS b e c) by (conclude axiom_betweennesssymmetry).
assert (BetS P b c) by (conclude lemma_3_7b).

*****
H18 : BetS P b c
H17 : BetS b e c
H16 : BetS P b e
H15 : Cong b P e b
H14 : BetS e b P
P : Point
H13 : not (Meet a b C D)
H12 : neq e b
H11 : neq b a
H10 : BetS c e b
H9 : BetS a e d
H8 : not (Meet A B C D)
H7 : neq c d
H6 : Col C D d
H5 : Col C D c
H4 : neq a b
H3 : Col A B b
H2 : Col A B a
H1 : neq C D
H0 : neq A B
a,b,c,d,e : Point
H : Par A B C D
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
TP A B C D
+++++
assert (BetS c b P) by (conclude axiom_betweennesssymmetry).
-----
Lemma lemma_paralleldef2B : forall A B C D, Par A B C D -> TP A B C D.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists a b c d e, (neq A B /\\ neq C D /\\ Col A B a /\\ Col A B b /\\ neq a b /\\ Col C D c /\\ Col C D d /\\ neq c d /\\ ~ Meet A B C D /\\ BetS a e d /\\ BetS c e b)) by (conclude_def Par );destruct Tf as [a[b[c[d[e]]]]];spliter.
assert (neq b a) by (conclude lemma_inequalitysymmetric).
assert (neq e b) by (forward_using lemma_betweennotequal).
assert (~ Meet a b C D).
let Tf:=fresh in assert (Tf:exists P, (BetS e b P /\\ Cong b P e b)) by (conclude lemma_extension);destruct Tf as [P];spliter.
assert (BetS P b e) by (conclude axiom_betweennesssymmetry).
assert (BetS b e c) by (conclude axiom_betweennesssymmetry).
assert (BetS P b c) by (conclude lemma_3_7b).
assert (BetS c b P) by (conclude axiom_betweennesssymmetry).

*****
H19 : BetS c b P
H18 : BetS P b c
H17 : BetS b e c
H16 : BetS P b e
H15 : Cong b P e b
H14 : BetS e b P
P : Point
H13 : not (Meet a b C D)
H12 : neq e b
H11 : neq b a
H10 : BetS c e b
H9 : BetS a e d
H8 : not (Meet A B C D)
H7 : neq c d
H6 : Col C D d
H5 : Col C D c
H4 : neq a b
H3 : Col A B b
H2 : Col A B a
H1 : neq C D
H0 : neq A B
a,b,c,d,e : Point
H : Par A B C D
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
TP A B C D
+++++
assert (~ Col a d P).
-----
Lemma lemma_paralleldef2B : forall A B C D, Par A B C D -> TP A B C D.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists a b c d e, (neq A B /\\ neq C D /\\ Col A B a /\\ Col A B b /\\ neq a b /\\ Col C D c /\\ Col C D d /\\ neq c d /\\ ~ Meet A B C D /\\ BetS a e d /\\ BetS c e b)) by (conclude_def Par );destruct Tf as [a[b[c[d[e]]]]];spliter.
assert (neq b a) by (conclude lemma_inequalitysymmetric).
assert (neq e b) by (forward_using lemma_betweennotequal).
assert (~ Meet a b C D).
let Tf:=fresh in assert (Tf:exists P, (BetS e b P /\\ Cong b P e b)) by (conclude lemma_extension);destruct Tf as [P];spliter.
assert (BetS P b e) by (conclude axiom_betweennesssymmetry).
assert (BetS b e c) by (conclude axiom_betweennesssymmetry).
assert (BetS P b c) by (conclude lemma_3_7b).
assert (BetS c b P) by (conclude axiom_betweennesssymmetry).
assert (~ Col a d P).

*****
H19 : BetS c b P
H18 : BetS P b c
H17 : BetS b e c
H16 : BetS P b e
H15 : Cong b P e b
H14 : BetS e b P
P : Point
H13 : not (Meet a b C D)
H12 : neq e b
H11 : neq b a
H10 : BetS c e b
H9 : BetS a e d
H8 : not (Meet A B C D)
H7 : neq c d
H6 : Col C D d
H5 : Col C D c
H4 : neq a b
H3 : Col A B b
H2 : Col A B a
H1 : neq C D
H0 : neq A B
a,b,c,d,e : Point
H : Par A B C D
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
not (Col a d P)
+++++
intro.
-----
Lemma lemma_paralleldef2B : forall A B C D, Par A B C D -> TP A B C D.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists a b c d e, (neq A B /\\ neq C D /\\ Col A B a /\\ Col A B b /\\ neq a b /\\ Col C D c /\\ Col C D d /\\ neq c d /\\ ~ Meet A B C D /\\ BetS a e d /\\ BetS c e b)) by (conclude_def Par );destruct Tf as [a[b[c[d[e]]]]];spliter.
assert (neq b a) by (conclude lemma_inequalitysymmetric).
assert (neq e b) by (forward_using lemma_betweennotequal).
assert (~ Meet a b C D).
let Tf:=fresh in assert (Tf:exists P, (BetS e b P /\\ Cong b P e b)) by (conclude lemma_extension);destruct Tf as [P];spliter.
assert (BetS P b e) by (conclude axiom_betweennesssymmetry).
assert (BetS b e c) by (conclude axiom_betweennesssymmetry).
assert (BetS P b c) by (conclude lemma_3_7b).
assert (BetS c b P) by (conclude axiom_betweennesssymmetry).
assert (~ Col a d P).
intro.

*****
H20 : Col a d P
H19 : BetS c b P
H18 : BetS P b c
H17 : BetS b e c
H16 : BetS P b e
H15 : Cong b P e b
H14 : BetS e b P
P : Point
H13 : not (Meet a b C D)
H12 : neq e b
H11 : neq b a
H10 : BetS c e b
H9 : BetS a e d
H8 : not (Meet A B C D)
H7 : neq c d
H6 : Col C D d
H5 : Col C D c
H4 : neq a b
H3 : Col A B b
H2 : Col A B a
H1 : neq C D
H0 : neq A B
a,b,c,d,e : Point
H : Par A B C D
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
False
+++++
assert (Col a e d) by (conclude_def Col ).
-----
Lemma lemma_paralleldef2B : forall A B C D, Par A B C D -> TP A B C D.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists a b c d e, (neq A B /\\ neq C D /\\ Col A B a /\\ Col A B b /\\ neq a b /\\ Col C D c /\\ Col C D d /\\ neq c d /\\ ~ Meet A B C D /\\ BetS a e d /\\ BetS c e b)) by (conclude_def Par );destruct Tf as [a[b[c[d[e]]]]];spliter.
assert (neq b a) by (conclude lemma_inequalitysymmetric).
assert (neq e b) by (forward_using lemma_betweennotequal).
assert (~ Meet a b C D).
let Tf:=fresh in assert (Tf:exists P, (BetS e b P /\\ Cong b P e b)) by (conclude lemma_extension);destruct Tf as [P];spliter.
assert (BetS P b e) by (conclude axiom_betweennesssymmetry).
assert (BetS b e c) by (conclude axiom_betweennesssymmetry).
assert (BetS P b c) by (conclude lemma_3_7b).
assert (BetS c b P) by (conclude axiom_betweennesssymmetry).
assert (~ Col a d P).
intro.
assert (Col a e d) by (conclude_def Col ).

*****
H21 : Col a e d
H20 : Col a d P
H19 : BetS c b P
H18 : BetS P b c
H17 : BetS b e c
H16 : BetS P b e
H15 : Cong b P e b
H14 : BetS e b P
P : Point
H13 : not (Meet a b C D)
H12 : neq e b
H11 : neq b a
H10 : BetS c e b
H9 : BetS a e d
H8 : not (Meet A B C D)
H7 : neq c d
H6 : Col C D d
H5 : Col C D c
H4 : neq a b
H3 : Col A B b
H2 : Col A B a
H1 : neq C D
H0 : neq A B
a,b,c,d,e : Point
H : Par A B C D
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
False
+++++
assert (Col a d e) by (forward_using lemma_collinearorder).
-----
Lemma lemma_paralleldef2B : forall A B C D, Par A B C D -> TP A B C D.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists a b c d e, (neq A B /\\ neq C D /\\ Col A B a /\\ Col A B b /\\ neq a b /\\ Col C D c /\\ Col C D d /\\ neq c d /\\ ~ Meet A B C D /\\ BetS a e d /\\ BetS c e b)) by (conclude_def Par );destruct Tf as [a[b[c[d[e]]]]];spliter.
assert (neq b a) by (conclude lemma_inequalitysymmetric).
assert (neq e b) by (forward_using lemma_betweennotequal).
assert (~ Meet a b C D).
let Tf:=fresh in assert (Tf:exists P, (BetS e b P /\\ Cong b P e b)) by (conclude lemma_extension);destruct Tf as [P];spliter.
assert (BetS P b e) by (conclude axiom_betweennesssymmetry).
assert (BetS b e c) by (conclude axiom_betweennesssymmetry).
assert (BetS P b c) by (conclude lemma_3_7b).
assert (BetS c b P) by (conclude axiom_betweennesssymmetry).
assert (~ Col a d P).
intro.
assert (Col a e d) by (conclude_def Col ).
assert (Col a d e) by (forward_using lemma_collinearorder).

*****
H22 : Col a d e
H21 : Col a e d
H20 : Col a d P
H19 : BetS c b P
H18 : BetS P b c
H17 : BetS b e c
H16 : BetS P b e
H15 : Cong b P e b
H14 : BetS e b P
P : Point
H13 : not (Meet a b C D)
H12 : neq e b
H11 : neq b a
H10 : BetS c e b
H9 : BetS a e d
H8 : not (Meet A B C D)
H7 : neq c d
H6 : Col C D d
H5 : Col C D c
H4 : neq a b
H3 : Col A B b
H2 : Col A B a
H1 : neq C D
H0 : neq A B
a,b,c,d,e : Point
H : Par A B C D
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
False
+++++
assert (neq a d) by (forward_using lemma_betweennotequal).
-----
Lemma lemma_paralleldef2B : forall A B C D, Par A B C D -> TP A B C D.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists a b c d e, (neq A B /\\ neq C D /\\ Col A B a /\\ Col A B b /\\ neq a b /\\ Col C D c /\\ Col C D d /\\ neq c d /\\ ~ Meet A B C D /\\ BetS a e d /\\ BetS c e b)) by (conclude_def Par );destruct Tf as [a[b[c[d[e]]]]];spliter.
assert (neq b a) by (conclude lemma_inequalitysymmetric).
assert (neq e b) by (forward_using lemma_betweennotequal).
assert (~ Meet a b C D).
let Tf:=fresh in assert (Tf:exists P, (BetS e b P /\\ Cong b P e b)) by (conclude lemma_extension);destruct Tf as [P];spliter.
assert (BetS P b e) by (conclude axiom_betweennesssymmetry).
assert (BetS b e c) by (conclude axiom_betweennesssymmetry).
assert (BetS P b c) by (conclude lemma_3_7b).
assert (BetS c b P) by (conclude axiom_betweennesssymmetry).
assert (~ Col a d P).
intro.
assert (Col a e d) by (conclude_def Col ).
assert (Col a d e) by (forward_using lemma_collinearorder).
assert (neq a d) by (forward_using lemma_betweennotequal).

*****
H23 : neq a d
H22 : Col a d e
H21 : Col a e d
H20 : Col a d P
H19 : BetS c b P
H18 : BetS P b c
H17 : BetS b e c
H16 : BetS P b e
H15 : Cong b P e b
H14 : BetS e b P
P : Point
H13 : not (Meet a b C D)
H12 : neq e b
H11 : neq b a
H10 : BetS c e b
H9 : BetS a e d
H8 : not (Meet A B C D)
H7 : neq c d
H6 : Col C D d
H5 : Col C D c
H4 : neq a b
H3 : Col A B b
H2 : Col A B a
H1 : neq C D
H0 : neq A B
a,b,c,d,e : Point
H : Par A B C D
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
False
+++++
assert (Col d P e) by (conclude lemma_collinear4).
-----
Lemma lemma_paralleldef2B : forall A B C D, Par A B C D -> TP A B C D.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists a b c d e, (neq A B /\\ neq C D /\\ Col A B a /\\ Col A B b /\\ neq a b /\\ Col C D c /\\ Col C D d /\\ neq c d /\\ ~ Meet A B C D /\\ BetS a e d /\\ BetS c e b)) by (conclude_def Par );destruct Tf as [a[b[c[d[e]]]]];spliter.
assert (neq b a) by (conclude lemma_inequalitysymmetric).
assert (neq e b) by (forward_using lemma_betweennotequal).
assert (~ Meet a b C D).
let Tf:=fresh in assert (Tf:exists P, (BetS e b P /\\ Cong b P e b)) by (conclude lemma_extension);destruct Tf as [P];spliter.
assert (BetS P b e) by (conclude axiom_betweennesssymmetry).
assert (BetS b e c) by (conclude axiom_betweennesssymmetry).
assert (BetS P b c) by (conclude lemma_3_7b).
assert (BetS c b P) by (conclude axiom_betweennesssymmetry).
assert (~ Col a d P).
intro.
assert (Col a e d) by (conclude_def Col ).
assert (Col a d e) by (forward_using lemma_collinearorder).
assert (neq a d) by (forward_using lemma_betweennotequal).
assert (Col d P e) by (conclude lemma_collinear4).

*****
H24 : Col d P e
H23 : neq a d
H22 : Col a d e
H21 : Col a e d
H20 : Col a d P
H19 : BetS c b P
H18 : BetS P b c
H17 : BetS b e c
H16 : BetS P b e
H15 : Cong b P e b
H14 : BetS e b P
P : Point
H13 : not (Meet a b C D)
H12 : neq e b
H11 : neq b a
H10 : BetS c e b
H9 : BetS a e d
H8 : not (Meet A B C D)
H7 : neq c d
H6 : Col C D d
H5 : Col C D c
H4 : neq a b
H3 : Col A B b
H2 : Col A B a
H1 : neq C D
H0 : neq A B
a,b,c,d,e : Point
H : Par A B C D
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
False
+++++
assert (Col e P d) by (forward_using lemma_collinearorder).
-----
Lemma lemma_paralleldef2B : forall A B C D, Par A B C D -> TP A B C D.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists a b c d e, (neq A B /\\ neq C D /\\ Col A B a /\\ Col A B b /\\ neq a b /\\ Col C D c /\\ Col C D d /\\ neq c d /\\ ~ Meet A B C D /\\ BetS a e d /\\ BetS c e b)) by (conclude_def Par );destruct Tf as [a[b[c[d[e]]]]];spliter.
assert (neq b a) by (conclude lemma_inequalitysymmetric).
assert (neq e b) by (forward_using lemma_betweennotequal).
assert (~ Meet a b C D).
let Tf:=fresh in assert (Tf:exists P, (BetS e b P /\\ Cong b P e b)) by (conclude lemma_extension);destruct Tf as [P];spliter.
assert (BetS P b e) by (conclude axiom_betweennesssymmetry).
assert (BetS b e c) by (conclude axiom_betweennesssymmetry).
assert (BetS P b c) by (conclude lemma_3_7b).
assert (BetS c b P) by (conclude axiom_betweennesssymmetry).
assert (~ Col a d P).
intro.
assert (Col a e d) by (conclude_def Col ).
assert (Col a d e) by (forward_using lemma_collinearorder).
assert (neq a d) by (forward_using lemma_betweennotequal).
assert (Col d P e) by (conclude lemma_collinear4).
assert (Col e P d) by (forward_using lemma_collinearorder).

*****
H25 : Col e P d
H24 : Col d P e
H23 : neq a d
H22 : Col a d e
H21 : Col a e d
H20 : Col a d P
H19 : BetS c b P
H18 : BetS P b c
H17 : BetS b e c
H16 : BetS P b e
H15 : Cong b P e b
H14 : BetS e b P
P : Point
H13 : not (Meet a b C D)
H12 : neq e b
H11 : neq b a
H10 : BetS c e b
H9 : BetS a e d
H8 : not (Meet A B C D)
H7 : neq c d
H6 : Col C D d
H5 : Col C D c
H4 : neq a b
H3 : Col A B b
H2 : Col A B a
H1 : neq C D
H0 : neq A B
a,b,c,d,e : Point
H : Par A B C D
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
False
+++++
assert (Col e b P) by (conclude_def Col ).
-----
Lemma lemma_paralleldef2B : forall A B C D, Par A B C D -> TP A B C D.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists a b c d e, (neq A B /\\ neq C D /\\ Col A B a /\\ Col A B b /\\ neq a b /\\ Col C D c /\\ Col C D d /\\ neq c d /\\ ~ Meet A B C D /\\ BetS a e d /\\ BetS c e b)) by (conclude_def Par );destruct Tf as [a[b[c[d[e]]]]];spliter.
assert (neq b a) by (conclude lemma_inequalitysymmetric).
assert (neq e b) by (forward_using lemma_betweennotequal).
assert (~ Meet a b C D).
let Tf:=fresh in assert (Tf:exists P, (BetS e b P /\\ Cong b P e b)) by (conclude lemma_extension);destruct Tf as [P];spliter.
assert (BetS P b e) by (conclude axiom_betweennesssymmetry).
assert (BetS b e c) by (conclude axiom_betweennesssymmetry).
assert (BetS P b c) by (conclude lemma_3_7b).
assert (BetS c b P) by (conclude axiom_betweennesssymmetry).
assert (~ Col a d P).
intro.
assert (Col a e d) by (conclude_def Col ).
assert (Col a d e) by (forward_using lemma_collinearorder).
assert (neq a d) by (forward_using lemma_betweennotequal).
assert (Col d P e) by (conclude lemma_collinear4).
assert (Col e P d) by (forward_using lemma_collinearorder).
assert (Col e b P) by (conclude_def Col ).

*****
H26 : Col e b P
H25 : Col e P d
H24 : Col d P e
H23 : neq a d
H22 : Col a d e
H21 : Col a e d
H20 : Col a d P
H19 : BetS c b P
H18 : BetS P b c
H17 : BetS b e c
H16 : BetS P b e
H15 : Cong b P e b
H14 : BetS e b P
P : Point
H13 : not (Meet a b C D)
H12 : neq e b
H11 : neq b a
H10 : BetS c e b
H9 : BetS a e d
H8 : not (Meet A B C D)
H7 : neq c d
H6 : Col C D d
H5 : Col C D c
H4 : neq a b
H3 : Col A B b
H2 : Col A B a
H1 : neq C D
H0 : neq A B
a,b,c,d,e : Point
H : Par A B C D
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
False
+++++
assert (Col e P b) by (forward_using lemma_collinearorder).
-----
Lemma lemma_paralleldef2B : forall A B C D, Par A B C D -> TP A B C D.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists a b c d e, (neq A B /\\ neq C D /\\ Col A B a /\\ Col A B b /\\ neq a b /\\ Col C D c /\\ Col C D d /\\ neq c d /\\ ~ Meet A B C D /\\ BetS a e d /\\ BetS c e b)) by (conclude_def Par );destruct Tf as [a[b[c[d[e]]]]];spliter.
assert (neq b a) by (conclude lemma_inequalitysymmetric).
assert (neq e b) by (forward_using lemma_betweennotequal).
assert (~ Meet a b C D).
let Tf:=fresh in assert (Tf:exists P, (BetS e b P /\\ Cong b P e b)) by (conclude lemma_extension);destruct Tf as [P];spliter.
assert (BetS P b e) by (conclude axiom_betweennesssymmetry).
assert (BetS b e c) by (conclude axiom_betweennesssymmetry).
assert (BetS P b c) by (conclude lemma_3_7b).
assert (BetS c b P) by (conclude axiom_betweennesssymmetry).
assert (~ Col a d P).
intro.
assert (Col a e d) by (conclude_def Col ).
assert (Col a d e) by (forward_using lemma_collinearorder).
assert (neq a d) by (forward_using lemma_betweennotequal).
assert (Col d P e) by (conclude lemma_collinear4).
assert (Col e P d) by (forward_using lemma_collinearorder).
assert (Col e b P) by (conclude_def Col ).
assert (Col e P b) by (forward_using lemma_collinearorder).

*****
H27 : Col e P b
H26 : Col e b P
H25 : Col e P d
H24 : Col d P e
H23 : neq a d
H22 : Col a d e
H21 : Col a e d
H20 : Col a d P
H19 : BetS c b P
H18 : BetS P b c
H17 : BetS b e c
H16 : BetS P b e
H15 : Cong b P e b
H14 : BetS e b P
P : Point
H13 : not (Meet a b C D)
H12 : neq e b
H11 : neq b a
H10 : BetS c e b
H9 : BetS a e d
H8 : not (Meet A B C D)
H7 : neq c d
H6 : Col C D d
H5 : Col C D c
H4 : neq a b
H3 : Col A B b
H2 : Col A B a
H1 : neq C D
H0 : neq A B
a,b,c,d,e : Point
H : Par A B C D
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
False
+++++
assert (neq e P) by (forward_using lemma_betweennotequal).
-----
Lemma lemma_paralleldef2B : forall A B C D, Par A B C D -> TP A B C D.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists a b c d e, (neq A B /\\ neq C D /\\ Col A B a /\\ Col A B b /\\ neq a b /\\ Col C D c /\\ Col C D d /\\ neq c d /\\ ~ Meet A B C D /\\ BetS a e d /\\ BetS c e b)) by (conclude_def Par );destruct Tf as [a[b[c[d[e]]]]];spliter.
assert (neq b a) by (conclude lemma_inequalitysymmetric).
assert (neq e b) by (forward_using lemma_betweennotequal).
assert (~ Meet a b C D).
let Tf:=fresh in assert (Tf:exists P, (BetS e b P /\\ Cong b P e b)) by (conclude lemma_extension);destruct Tf as [P];spliter.
assert (BetS P b e) by (conclude axiom_betweennesssymmetry).
assert (BetS b e c) by (conclude axiom_betweennesssymmetry).
assert (BetS P b c) by (conclude lemma_3_7b).
assert (BetS c b P) by (conclude axiom_betweennesssymmetry).
assert (~ Col a d P).
intro.
assert (Col a e d) by (conclude_def Col ).
assert (Col a d e) by (forward_using lemma_collinearorder).
assert (neq a d) by (forward_using lemma_betweennotequal).
assert (Col d P e) by (conclude lemma_collinear4).
assert (Col e P d) by (forward_using lemma_collinearorder).
assert (Col e b P) by (conclude_def Col ).
assert (Col e P b) by (forward_using lemma_collinearorder).
assert (neq e P) by (forward_using lemma_betweennotequal).

*****
H28 : neq e P
H27 : Col e P b
H26 : Col e b P
H25 : Col e P d
H24 : Col d P e
H23 : neq a d
H22 : Col a d e
H21 : Col a e d
H20 : Col a d P
H19 : BetS c b P
H18 : BetS P b c
H17 : BetS b e c
H16 : BetS P b e
H15 : Cong b P e b
H14 : BetS e b P
P : Point
H13 : not (Meet a b C D)
H12 : neq e b
H11 : neq b a
H10 : BetS c e b
H9 : BetS a e d
H8 : not (Meet A B C D)
H7 : neq c d
H6 : Col C D d
H5 : Col C D c
H4 : neq a b
H3 : Col A B b
H2 : Col A B a
H1 : neq C D
H0 : neq A B
a,b,c,d,e : Point
H : Par A B C D
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
False
+++++
assert (Col P d b) by (conclude lemma_collinear4).
-----
Lemma lemma_paralleldef2B : forall A B C D, Par A B C D -> TP A B C D.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists a b c d e, (neq A B /\\ neq C D /\\ Col A B a /\\ Col A B b /\\ neq a b /\\ Col C D c /\\ Col C D d /\\ neq c d /\\ ~ Meet A B C D /\\ BetS a e d /\\ BetS c e b)) by (conclude_def Par );destruct Tf as [a[b[c[d[e]]]]];spliter.
assert (neq b a) by (conclude lemma_inequalitysymmetric).
assert (neq e b) by (forward_using lemma_betweennotequal).
assert (~ Meet a b C D).
let Tf:=fresh in assert (Tf:exists P, (BetS e b P /\\ Cong b P e b)) by (conclude lemma_extension);destruct Tf as [P];spliter.
assert (BetS P b e) by (conclude axiom_betweennesssymmetry).
assert (BetS b e c) by (conclude axiom_betweennesssymmetry).
assert (BetS P b c) by (conclude lemma_3_7b).
assert (BetS c b P) by (conclude axiom_betweennesssymmetry).
assert (~ Col a d P).
intro.
assert (Col a e d) by (conclude_def Col ).
assert (Col a d e) by (forward_using lemma_collinearorder).
assert (neq a d) by (forward_using lemma_betweennotequal).
assert (Col d P e) by (conclude lemma_collinear4).
assert (Col e P d) by (forward_using lemma_collinearorder).
assert (Col e b P) by (conclude_def Col ).
assert (Col e P b) by (forward_using lemma_collinearorder).
assert (neq e P) by (forward_using lemma_betweennotequal).
assert (Col P d b) by (conclude lemma_collinear4).

*****
H29 : Col P d b
H28 : neq e P
H27 : Col e P b
H26 : Col e b P
H25 : Col e P d
H24 : Col d P e
H23 : neq a d
H22 : Col a d e
H21 : Col a e d
H20 : Col a d P
H19 : BetS c b P
H18 : BetS P b c
H17 : BetS b e c
H16 : BetS P b e
H15 : Cong b P e b
H14 : BetS e b P
P : Point
H13 : not (Meet a b C D)
H12 : neq e b
H11 : neq b a
H10 : BetS c e b
H9 : BetS a e d
H8 : not (Meet A B C D)
H7 : neq c d
H6 : Col C D d
H5 : Col C D c
H4 : neq a b
H3 : Col A B b
H2 : Col A B a
H1 : neq C D
H0 : neq A B
a,b,c,d,e : Point
H : Par A B C D
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
False
+++++
assert (Col d P b) by (forward_using lemma_collinearorder).
-----
Lemma lemma_paralleldef2B : forall A B C D, Par A B C D -> TP A B C D.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists a b c d e, (neq A B /\\ neq C D /\\ Col A B a /\\ Col A B b /\\ neq a b /\\ Col C D c /\\ Col C D d /\\ neq c d /\\ ~ Meet A B C D /\\ BetS a e d /\\ BetS c e b)) by (conclude_def Par );destruct Tf as [a[b[c[d[e]]]]];spliter.
assert (neq b a) by (conclude lemma_inequalitysymmetric).
assert (neq e b) by (forward_using lemma_betweennotequal).
assert (~ Meet a b C D).
let Tf:=fresh in assert (Tf:exists P, (BetS e b P /\\ Cong b P e b)) by (conclude lemma_extension);destruct Tf as [P];spliter.
assert (BetS P b e) by (conclude axiom_betweennesssymmetry).
assert (BetS b e c) by (conclude axiom_betweennesssymmetry).
assert (BetS P b c) by (conclude lemma_3_7b).
assert (BetS c b P) by (conclude axiom_betweennesssymmetry).
assert (~ Col a d P).
intro.
assert (Col a e d) by (conclude_def Col ).
assert (Col a d e) by (forward_using lemma_collinearorder).
assert (neq a d) by (forward_using lemma_betweennotequal).
assert (Col d P e) by (conclude lemma_collinear4).
assert (Col e P d) by (forward_using lemma_collinearorder).
assert (Col e b P) by (conclude_def Col ).
assert (Col e P b) by (forward_using lemma_collinearorder).
assert (neq e P) by (forward_using lemma_betweennotequal).
assert (Col P d b) by (conclude lemma_collinear4).
assert (Col d P b) by (forward_using lemma_collinearorder).

*****
H30 : Col d P b
H29 : Col P d b
H28 : neq e P
H27 : Col e P b
H26 : Col e b P
H25 : Col e P d
H24 : Col d P e
H23 : neq a d
H22 : Col a d e
H21 : Col a e d
H20 : Col a d P
H19 : BetS c b P
H18 : BetS P b c
H17 : BetS b e c
H16 : BetS P b e
H15 : Cong b P e b
H14 : BetS e b P
P : Point
H13 : not (Meet a b C D)
H12 : neq e b
H11 : neq b a
H10 : BetS c e b
H9 : BetS a e d
H8 : not (Meet A B C D)
H7 : neq c d
H6 : Col C D d
H5 : Col C D c
H4 : neq a b
H3 : Col A B b
H2 : Col A B a
H1 : neq C D
H0 : neq A B
a,b,c,d,e : Point
H : Par A B C D
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
False
+++++
assert (Col d P a) by (forward_using lemma_collinearorder).
-----
Lemma lemma_paralleldef2B : forall A B C D, Par A B C D -> TP A B C D.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists a b c d e, (neq A B /\\ neq C D /\\ Col A B a /\\ Col A B b /\\ neq a b /\\ Col C D c /\\ Col C D d /\\ neq c d /\\ ~ Meet A B C D /\\ BetS a e d /\\ BetS c e b)) by (conclude_def Par );destruct Tf as [a[b[c[d[e]]]]];spliter.
assert (neq b a) by (conclude lemma_inequalitysymmetric).
assert (neq e b) by (forward_using lemma_betweennotequal).
assert (~ Meet a b C D).
let Tf:=fresh in assert (Tf:exists P, (BetS e b P /\\ Cong b P e b)) by (conclude lemma_extension);destruct Tf as [P];spliter.
assert (BetS P b e) by (conclude axiom_betweennesssymmetry).
assert (BetS b e c) by (conclude axiom_betweennesssymmetry).
assert (BetS P b c) by (conclude lemma_3_7b).
assert (BetS c b P) by (conclude axiom_betweennesssymmetry).
assert (~ Col a d P).
intro.
assert (Col a e d) by (conclude_def Col ).
assert (Col a d e) by (forward_using lemma_collinearorder).
assert (neq a d) by (forward_using lemma_betweennotequal).
assert (Col d P e) by (conclude lemma_collinear4).
assert (Col e P d) by (forward_using lemma_collinearorder).
assert (Col e b P) by (conclude_def Col ).
assert (Col e P b) by (forward_using lemma_collinearorder).
assert (neq e P) by (forward_using lemma_betweennotequal).
assert (Col P d b) by (conclude lemma_collinear4).
assert (Col d P b) by (forward_using lemma_collinearorder).
assert (Col d P a) by (forward_using lemma_collinearorder).

*****
H31 : Col d P a
H30 : Col d P b
H29 : Col P d b
H28 : neq e P
H27 : Col e P b
H26 : Col e b P
H25 : Col e P d
H24 : Col d P e
H23 : neq a d
H22 : Col a d e
H21 : Col a e d
H20 : Col a d P
H19 : BetS c b P
H18 : BetS P b c
H17 : BetS b e c
H16 : BetS P b e
H15 : Cong b P e b
H14 : BetS e b P
P : Point
H13 : not (Meet a b C D)
H12 : neq e b
H11 : neq b a
H10 : BetS c e b
H9 : BetS a e d
H8 : not (Meet A B C D)
H7 : neq c d
H6 : Col C D d
H5 : Col C D c
H4 : neq a b
H3 : Col A B b
H2 : Col A B a
H1 : neq C D
H0 : neq A B
a,b,c,d,e : Point
H : Par A B C D
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
False
+++++
assert (~ eq d P).
-----
Lemma lemma_paralleldef2B : forall A B C D, Par A B C D -> TP A B C D.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists a b c d e, (neq A B /\\ neq C D /\\ Col A B a /\\ Col A B b /\\ neq a b /\\ Col C D c /\\ Col C D d /\\ neq c d /\\ ~ Meet A B C D /\\ BetS a e d /\\ BetS c e b)) by (conclude_def Par );destruct Tf as [a[b[c[d[e]]]]];spliter.
assert (neq b a) by (conclude lemma_inequalitysymmetric).
assert (neq e b) by (forward_using lemma_betweennotequal).
assert (~ Meet a b C D).
let Tf:=fresh in assert (Tf:exists P, (BetS e b P /\\ Cong b P e b)) by (conclude lemma_extension);destruct Tf as [P];spliter.
assert (BetS P b e) by (conclude axiom_betweennesssymmetry).
assert (BetS b e c) by (conclude axiom_betweennesssymmetry).
assert (BetS P b c) by (conclude lemma_3_7b).
assert (BetS c b P) by (conclude axiom_betweennesssymmetry).
assert (~ Col a d P).
intro.
assert (Col a e d) by (conclude_def Col ).
assert (Col a d e) by (forward_using lemma_collinearorder).
assert (neq a d) by (forward_using lemma_betweennotequal).
assert (Col d P e) by (conclude lemma_collinear4).
assert (Col e P d) by (forward_using lemma_collinearorder).
assert (Col e b P) by (conclude_def Col ).
assert (Col e P b) by (forward_using lemma_collinearorder).
assert (neq e P) by (forward_using lemma_betweennotequal).
assert (Col P d b) by (conclude lemma_collinear4).
assert (Col d P b) by (forward_using lemma_collinearorder).
assert (Col d P a) by (forward_using lemma_collinearorder).
assert (~ eq d P).

*****
H31 : Col d P a
H30 : Col d P b
H29 : Col P d b
H28 : neq e P
H27 : Col e P b
H26 : Col e b P
H25 : Col e P d
H24 : Col d P e
H23 : neq a d
H22 : Col a d e
H21 : Col a e d
H20 : Col a d P
H19 : BetS c b P
H18 : BetS P b c
H17 : BetS b e c
H16 : BetS P b e
H15 : Cong b P e b
H14 : BetS e b P
P : Point
H13 : not (Meet a b C D)
H12 : neq e b
H11 : neq b a
H10 : BetS c e b
H9 : BetS a e d
H8 : not (Meet A B C D)
H7 : neq c d
H6 : Col C D d
H5 : Col C D c
H4 : neq a b
H3 : Col A B b
H2 : Col A B a
H1 : neq C D
H0 : neq A B
a,b,c,d,e : Point
H : Par A B C D
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
not (eq d P)
+++++
intro.
-----
Lemma lemma_paralleldef2B : forall A B C D, Par A B C D -> TP A B C D.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists a b c d e, (neq A B /\\ neq C D /\\ Col A B a /\\ Col A B b /\\ neq a b /\\ Col C D c /\\ Col C D d /\\ neq c d /\\ ~ Meet A B C D /\\ BetS a e d /\\ BetS c e b)) by (conclude_def Par );destruct Tf as [a[b[c[d[e]]]]];spliter.
assert (neq b a) by (conclude lemma_inequalitysymmetric).
assert (neq e b) by (forward_using lemma_betweennotequal).
assert (~ Meet a b C D).
let Tf:=fresh in assert (Tf:exists P, (BetS e b P /\\ Cong b P e b)) by (conclude lemma_extension);destruct Tf as [P];spliter.
assert (BetS P b e) by (conclude axiom_betweennesssymmetry).
assert (BetS b e c) by (conclude axiom_betweennesssymmetry).
assert (BetS P b c) by (conclude lemma_3_7b).
assert (BetS c b P) by (conclude axiom_betweennesssymmetry).
assert (~ Col a d P).
intro.
assert (Col a e d) by (conclude_def Col ).
assert (Col a d e) by (forward_using lemma_collinearorder).
assert (neq a d) by (forward_using lemma_betweennotequal).
assert (Col d P e) by (conclude lemma_collinear4).
assert (Col e P d) by (forward_using lemma_collinearorder).
assert (Col e b P) by (conclude_def Col ).
assert (Col e P b) by (forward_using lemma_collinearorder).
assert (neq e P) by (forward_using lemma_betweennotequal).
assert (Col P d b) by (conclude lemma_collinear4).
assert (Col d P b) by (forward_using lemma_collinearorder).
assert (Col d P a) by (forward_using lemma_collinearorder).
assert (~ eq d P).
intro.

*****
H32 : eq d P
H31 : Col d P a
H30 : Col d P b
H29 : Col P d b
H28 : neq e P
H27 : Col e P b
H26 : Col e b P
H25 : Col e P d
H24 : Col d P e
H23 : neq a d
H22 : Col a d e
H21 : Col a e d
H20 : Col a d P
H19 : BetS c b P
H18 : BetS P b c
H17 : BetS b e c
H16 : BetS P b e
H15 : Cong b P e b
H14 : BetS e b P
P : Point
H13 : not (Meet a b C D)
H12 : neq e b
H11 : neq b a
H10 : BetS c e b
H9 : BetS a e d
H8 : not (Meet A B C D)
H7 : neq c d
H6 : Col C D d
H5 : Col C D c
H4 : neq a b
H3 : Col A B b
H2 : Col A B a
H1 : neq C D
H0 : neq A B
a,b,c,d,e : Point
H : Par A B C D
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
False
+++++
assert (Col c b P) by (conclude_def Col ).
-----
Lemma lemma_paralleldef2B : forall A B C D, Par A B C D -> TP A B C D.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists a b c d e, (neq A B /\\ neq C D /\\ Col A B a /\\ Col A B b /\\ neq a b /\\ Col C D c /\\ Col C D d /\\ neq c d /\\ ~ Meet A B C D /\\ BetS a e d /\\ BetS c e b)) by (conclude_def Par );destruct Tf as [a[b[c[d[e]]]]];spliter.
assert (neq b a) by (conclude lemma_inequalitysymmetric).
assert (neq e b) by (forward_using lemma_betweennotequal).
assert (~ Meet a b C D).
let Tf:=fresh in assert (Tf:exists P, (BetS e b P /\\ Cong b P e b)) by (conclude lemma_extension);destruct Tf as [P];spliter.
assert (BetS P b e) by (conclude axiom_betweennesssymmetry).
assert (BetS b e c) by (conclude axiom_betweennesssymmetry).
assert (BetS P b c) by (conclude lemma_3_7b).
assert (BetS c b P) by (conclude axiom_betweennesssymmetry).
assert (~ Col a d P).
intro.
assert (Col a e d) by (conclude_def Col ).
assert (Col a d e) by (forward_using lemma_collinearorder).
assert (neq a d) by (forward_using lemma_betweennotequal).
assert (Col d P e) by (conclude lemma_collinear4).
assert (Col e P d) by (forward_using lemma_collinearorder).
assert (Col e b P) by (conclude_def Col ).
assert (Col e P b) by (forward_using lemma_collinearorder).
assert (neq e P) by (forward_using lemma_betweennotequal).
assert (Col P d b) by (conclude lemma_collinear4).
assert (Col d P b) by (forward_using lemma_collinearorder).
assert (Col d P a) by (forward_using lemma_collinearorder).
assert (~ eq d P).
intro.
assert (Col c b P) by (conclude_def Col ).

*****
H33 : Col c b P
H32 : eq d P
H31 : Col d P a
H30 : Col d P b
H29 : Col P d b
H28 : neq e P
H27 : Col e P b
H26 : Col e b P
H25 : Col e P d
H24 : Col d P e
H23 : neq a d
H22 : Col a d e
H21 : Col a e d
H20 : Col a d P
H19 : BetS c b P
H18 : BetS P b c
H17 : BetS b e c
H16 : BetS P b e
H15 : Cong b P e b
H14 : BetS e b P
P : Point
H13 : not (Meet a b C D)
H12 : neq e b
H11 : neq b a
H10 : BetS c e b
H9 : BetS a e d
H8 : not (Meet A B C D)
H7 : neq c d
H6 : Col C D d
H5 : Col C D c
H4 : neq a b
H3 : Col A B b
H2 : Col A B a
H1 : neq C D
H0 : neq A B
a,b,c,d,e : Point
H : Par A B C D
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
False
+++++
assert (Col c b d) by (conclude cn_equalitysub).
-----
Lemma lemma_paralleldef2B : forall A B C D, Par A B C D -> TP A B C D.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists a b c d e, (neq A B /\\ neq C D /\\ Col A B a /\\ Col A B b /\\ neq a b /\\ Col C D c /\\ Col C D d /\\ neq c d /\\ ~ Meet A B C D /\\ BetS a e d /\\ BetS c e b)) by (conclude_def Par );destruct Tf as [a[b[c[d[e]]]]];spliter.
assert (neq b a) by (conclude lemma_inequalitysymmetric).
assert (neq e b) by (forward_using lemma_betweennotequal).
assert (~ Meet a b C D).
let Tf:=fresh in assert (Tf:exists P, (BetS e b P /\\ Cong b P e b)) by (conclude lemma_extension);destruct Tf as [P];spliter.
assert (BetS P b e) by (conclude axiom_betweennesssymmetry).
assert (BetS b e c) by (conclude axiom_betweennesssymmetry).
assert (BetS P b c) by (conclude lemma_3_7b).
assert (BetS c b P) by (conclude axiom_betweennesssymmetry).
assert (~ Col a d P).
intro.
assert (Col a e d) by (conclude_def Col ).
assert (Col a d e) by (forward_using lemma_collinearorder).
assert (neq a d) by (forward_using lemma_betweennotequal).
assert (Col d P e) by (conclude lemma_collinear4).
assert (Col e P d) by (forward_using lemma_collinearorder).
assert (Col e b P) by (conclude_def Col ).
assert (Col e P b) by (forward_using lemma_collinearorder).
assert (neq e P) by (forward_using lemma_betweennotequal).
assert (Col P d b) by (conclude lemma_collinear4).
assert (Col d P b) by (forward_using lemma_collinearorder).
assert (Col d P a) by (forward_using lemma_collinearorder).
assert (~ eq d P).
intro.
assert (Col c b P) by (conclude_def Col ).
assert (Col c b d) by (conclude cn_equalitysub).

*****
H34 : Col c b d
H33 : Col c b P
H32 : eq d P
H31 : Col d P a
H30 : Col d P b
H29 : Col P d b
H28 : neq e P
H27 : Col e P b
H26 : Col e b P
H25 : Col e P d
H24 : Col d P e
H23 : neq a d
H22 : Col a d e
H21 : Col a e d
H20 : Col a d P
H19 : BetS c b P
H18 : BetS P b c
H17 : BetS b e c
H16 : BetS P b e
H15 : Cong b P e b
H14 : BetS e b P
P : Point
H13 : not (Meet a b C D)
H12 : neq e b
H11 : neq b a
H10 : BetS c e b
H9 : BetS a e d
H8 : not (Meet A B C D)
H7 : neq c d
H6 : Col C D d
H5 : Col C D c
H4 : neq a b
H3 : Col A B b
H2 : Col A B a
H1 : neq C D
H0 : neq A B
a,b,c,d,e : Point
H : Par A B C D
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
False
+++++
assert (Col b e c) by (conclude_def Col ).
-----
Lemma lemma_paralleldef2B : forall A B C D, Par A B C D -> TP A B C D.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists a b c d e, (neq A B /\\ neq C D /\\ Col A B a /\\ Col A B b /\\ neq a b /\\ Col C D c /\\ Col C D d /\\ neq c d /\\ ~ Meet A B C D /\\ BetS a e d /\\ BetS c e b)) by (conclude_def Par );destruct Tf as [a[b[c[d[e]]]]];spliter.
assert (neq b a) by (conclude lemma_inequalitysymmetric).
assert (neq e b) by (forward_using lemma_betweennotequal).
assert (~ Meet a b C D).
let Tf:=fresh in assert (Tf:exists P, (BetS e b P /\\ Cong b P e b)) by (conclude lemma_extension);destruct Tf as [P];spliter.
assert (BetS P b e) by (conclude axiom_betweennesssymmetry).
assert (BetS b e c) by (conclude axiom_betweennesssymmetry).
assert (BetS P b c) by (conclude lemma_3_7b).
assert (BetS c b P) by (conclude axiom_betweennesssymmetry).
assert (~ Col a d P).
intro.
assert (Col a e d) by (conclude_def Col ).
assert (Col a d e) by (forward_using lemma_collinearorder).
assert (neq a d) by (forward_using lemma_betweennotequal).
assert (Col d P e) by (conclude lemma_collinear4).
assert (Col e P d) by (forward_using lemma_collinearorder).
assert (Col e b P) by (conclude_def Col ).
assert (Col e P b) by (forward_using lemma_collinearorder).
assert (neq e P) by (forward_using lemma_betweennotequal).
assert (Col P d b) by (conclude lemma_collinear4).
assert (Col d P b) by (forward_using lemma_collinearorder).
assert (Col d P a) by (forward_using lemma_collinearorder).
assert (~ eq d P).
intro.
assert (Col c b P) by (conclude_def Col ).
assert (Col c b d) by (conclude cn_equalitysub).
assert (Col b e c) by (conclude_def Col ).

*****
H35 : Col b e c
H34 : Col c b d
H33 : Col c b P
H32 : eq d P
H31 : Col d P a
H30 : Col d P b
H29 : Col P d b
H28 : neq e P
H27 : Col e P b
H26 : Col e b P
H25 : Col e P d
H24 : Col d P e
H23 : neq a d
H22 : Col a d e
H21 : Col a e d
H20 : Col a d P
H19 : BetS c b P
H18 : BetS P b c
H17 : BetS b e c
H16 : BetS P b e
H15 : Cong b P e b
H14 : BetS e b P
P : Point
H13 : not (Meet a b C D)
H12 : neq e b
H11 : neq b a
H10 : BetS c e b
H9 : BetS a e d
H8 : not (Meet A B C D)
H7 : neq c d
H6 : Col C D d
H5 : Col C D c
H4 : neq a b
H3 : Col A B b
H2 : Col A B a
H1 : neq C D
H0 : neq A B
a,b,c,d,e : Point
H : Par A B C D
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
False
+++++
assert (Col c b e) by (forward_using lemma_collinearorder).
-----
Lemma lemma_paralleldef2B : forall A B C D, Par A B C D -> TP A B C D.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists a b c d e, (neq A B /\\ neq C D /\\ Col A B a /\\ Col A B b /\\ neq a b /\\ Col C D c /\\ Col C D d /\\ neq c d /\\ ~ Meet A B C D /\\ BetS a e d /\\ BetS c e b)) by (conclude_def Par );destruct Tf as [a[b[c[d[e]]]]];spliter.
assert (neq b a) by (conclude lemma_inequalitysymmetric).
assert (neq e b) by (forward_using lemma_betweennotequal).
assert (~ Meet a b C D).
let Tf:=fresh in assert (Tf:exists P, (BetS e b P /\\ Cong b P e b)) by (conclude lemma_extension);destruct Tf as [P];spliter.
assert (BetS P b e) by (conclude axiom_betweennesssymmetry).
assert (BetS b e c) by (conclude axiom_betweennesssymmetry).
assert (BetS P b c) by (conclude lemma_3_7b).
assert (BetS c b P) by (conclude axiom_betweennesssymmetry).
assert (~ Col a d P).
intro.
assert (Col a e d) by (conclude_def Col ).
assert (Col a d e) by (forward_using lemma_collinearorder).
assert (neq a d) by (forward_using lemma_betweennotequal).
assert (Col d P e) by (conclude lemma_collinear4).
assert (Col e P d) by (forward_using lemma_collinearorder).
assert (Col e b P) by (conclude_def Col ).
assert (Col e P b) by (forward_using lemma_collinearorder).
assert (neq e P) by (forward_using lemma_betweennotequal).
assert (Col P d b) by (conclude lemma_collinear4).
assert (Col d P b) by (forward_using lemma_collinearorder).
assert (Col d P a) by (forward_using lemma_collinearorder).
assert (~ eq d P).
intro.
assert (Col c b P) by (conclude_def Col ).
assert (Col c b d) by (conclude cn_equalitysub).
assert (Col b e c) by (conclude_def Col ).
assert (Col c b e) by (forward_using lemma_collinearorder).

*****
H36 : Col c b e
H35 : Col b e c
H34 : Col c b d
H33 : Col c b P
H32 : eq d P
H31 : Col d P a
H30 : Col d P b
H29 : Col P d b
H28 : neq e P
H27 : Col e P b
H26 : Col e b P
H25 : Col e P d
H24 : Col d P e
H23 : neq a d
H22 : Col a d e
H21 : Col a e d
H20 : Col a d P
H19 : BetS c b P
H18 : BetS P b c
H17 : BetS b e c
H16 : BetS P b e
H15 : Cong b P e b
H14 : BetS e b P
P : Point
H13 : not (Meet a b C D)
H12 : neq e b
H11 : neq b a
H10 : BetS c e b
H9 : BetS a e d
H8 : not (Meet A B C D)
H7 : neq c d
H6 : Col C D d
H5 : Col C D c
H4 : neq a b
H3 : Col A B b
H2 : Col A B a
H1 : neq C D
H0 : neq A B
a,b,c,d,e : Point
H : Par A B C D
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
False
+++++
assert (neq c b) by (forward_using lemma_betweennotequal).
-----
Lemma lemma_paralleldef2B : forall A B C D, Par A B C D -> TP A B C D.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists a b c d e, (neq A B /\\ neq C D /\\ Col A B a /\\ Col A B b /\\ neq a b /\\ Col C D c /\\ Col C D d /\\ neq c d /\\ ~ Meet A B C D /\\ BetS a e d /\\ BetS c e b)) by (conclude_def Par );destruct Tf as [a[b[c[d[e]]]]];spliter.
assert (neq b a) by (conclude lemma_inequalitysymmetric).
assert (neq e b) by (forward_using lemma_betweennotequal).
assert (~ Meet a b C D).
let Tf:=fresh in assert (Tf:exists P, (BetS e b P /\\ Cong b P e b)) by (conclude lemma_extension);destruct Tf as [P];spliter.
assert (BetS P b e) by (conclude axiom_betweennesssymmetry).
assert (BetS b e c) by (conclude axiom_betweennesssymmetry).
assert (BetS P b c) by (conclude lemma_3_7b).
assert (BetS c b P) by (conclude axiom_betweennesssymmetry).
assert (~ Col a d P).
intro.
assert (Col a e d) by (conclude_def Col ).
assert (Col a d e) by (forward_using lemma_collinearorder).
assert (neq a d) by (forward_using lemma_betweennotequal).
assert (Col d P e) by (conclude lemma_collinear4).
assert (Col e P d) by (forward_using lemma_collinearorder).
assert (Col e b P) by (conclude_def Col ).
assert (Col e P b) by (forward_using lemma_collinearorder).
assert (neq e P) by (forward_using lemma_betweennotequal).
assert (Col P d b) by (conclude lemma_collinear4).
assert (Col d P b) by (forward_using lemma_collinearorder).
assert (Col d P a) by (forward_using lemma_collinearorder).
assert (~ eq d P).
intro.
assert (Col c b P) by (conclude_def Col ).
assert (Col c b d) by (conclude cn_equalitysub).
assert (Col b e c) by (conclude_def Col ).
assert (Col c b e) by (forward_using lemma_collinearorder).
assert (neq c b) by (forward_using lemma_betweennotequal).

*****
H37 : neq c b
H36 : Col c b e
H35 : Col b e c
H34 : Col c b d
H33 : Col c b P
H32 : eq d P
H31 : Col d P a
H30 : Col d P b
H29 : Col P d b
H28 : neq e P
H27 : Col e P b
H26 : Col e b P
H25 : Col e P d
H24 : Col d P e
H23 : neq a d
H22 : Col a d e
H21 : Col a e d
H20 : Col a d P
H19 : BetS c b P
H18 : BetS P b c
H17 : BetS b e c
H16 : BetS P b e
H15 : Cong b P e b
H14 : BetS e b P
P : Point
H13 : not (Meet a b C D)
H12 : neq e b
H11 : neq b a
H10 : BetS c e b
H9 : BetS a e d
H8 : not (Meet A B C D)
H7 : neq c d
H6 : Col C D d
H5 : Col C D c
H4 : neq a b
H3 : Col A B b
H2 : Col A B a
H1 : neq C D
H0 : neq A B
a,b,c,d,e : Point
H : Par A B C D
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
False
+++++
assert (Col b d e) by (conclude lemma_collinear4).
-----
Lemma lemma_paralleldef2B : forall A B C D, Par A B C D -> TP A B C D.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists a b c d e, (neq A B /\\ neq C D /\\ Col A B a /\\ Col A B b /\\ neq a b /\\ Col C D c /\\ Col C D d /\\ neq c d /\\ ~ Meet A B C D /\\ BetS a e d /\\ BetS c e b)) by (conclude_def Par );destruct Tf as [a[b[c[d[e]]]]];spliter.
assert (neq b a) by (conclude lemma_inequalitysymmetric).
assert (neq e b) by (forward_using lemma_betweennotequal).
assert (~ Meet a b C D).
let Tf:=fresh in assert (Tf:exists P, (BetS e b P /\\ Cong b P e b)) by (conclude lemma_extension);destruct Tf as [P];spliter.
assert (BetS P b e) by (conclude axiom_betweennesssymmetry).
assert (BetS b e c) by (conclude axiom_betweennesssymmetry).
assert (BetS P b c) by (conclude lemma_3_7b).
assert (BetS c b P) by (conclude axiom_betweennesssymmetry).
assert (~ Col a d P).
intro.
assert (Col a e d) by (conclude_def Col ).
assert (Col a d e) by (forward_using lemma_collinearorder).
assert (neq a d) by (forward_using lemma_betweennotequal).
assert (Col d P e) by (conclude lemma_collinear4).
assert (Col e P d) by (forward_using lemma_collinearorder).
assert (Col e b P) by (conclude_def Col ).
assert (Col e P b) by (forward_using lemma_collinearorder).
assert (neq e P) by (forward_using lemma_betweennotequal).
assert (Col P d b) by (conclude lemma_collinear4).
assert (Col d P b) by (forward_using lemma_collinearorder).
assert (Col d P a) by (forward_using lemma_collinearorder).
assert (~ eq d P).
intro.
assert (Col c b P) by (conclude_def Col ).
assert (Col c b d) by (conclude cn_equalitysub).
assert (Col b e c) by (conclude_def Col ).
assert (Col c b e) by (forward_using lemma_collinearorder).
assert (neq c b) by (forward_using lemma_betweennotequal).
assert (Col b d e) by (conclude lemma_collinear4).

*****
H38 : Col b d e
H37 : neq c b
H36 : Col c b e
H35 : Col b e c
H34 : Col c b d
H33 : Col c b P
H32 : eq d P
H31 : Col d P a
H30 : Col d P b
H29 : Col P d b
H28 : neq e P
H27 : Col e P b
H26 : Col e b P
H25 : Col e P d
H24 : Col d P e
H23 : neq a d
H22 : Col a d e
H21 : Col a e d
H20 : Col a d P
H19 : BetS c b P
H18 : BetS P b c
H17 : BetS b e c
H16 : BetS P b e
H15 : Cong b P e b
H14 : BetS e b P
P : Point
H13 : not (Meet a b C D)
H12 : neq e b
H11 : neq b a
H10 : BetS c e b
H9 : BetS a e d
H8 : not (Meet A B C D)
H7 : neq c d
H6 : Col C D d
H5 : Col C D c
H4 : neq a b
H3 : Col A B b
H2 : Col A B a
H1 : neq C D
H0 : neq A B
a,b,c,d,e : Point
H : Par A B C D
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
False
+++++
assert (Col a e d) by (conclude_def Col ).
-----
Lemma lemma_paralleldef2B : forall A B C D, Par A B C D -> TP A B C D.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists a b c d e, (neq A B /\\ neq C D /\\ Col A B a /\\ Col A B b /\\ neq a b /\\ Col C D c /\\ Col C D d /\\ neq c d /\\ ~ Meet A B C D /\\ BetS a e d /\\ BetS c e b)) by (conclude_def Par );destruct Tf as [a[b[c[d[e]]]]];spliter.
assert (neq b a) by (conclude lemma_inequalitysymmetric).
assert (neq e b) by (forward_using lemma_betweennotequal).
assert (~ Meet a b C D).
let Tf:=fresh in assert (Tf:exists P, (BetS e b P /\\ Cong b P e b)) by (conclude lemma_extension);destruct Tf as [P];spliter.
assert (BetS P b e) by (conclude axiom_betweennesssymmetry).
assert (BetS b e c) by (conclude axiom_betweennesssymmetry).
assert (BetS P b c) by (conclude lemma_3_7b).
assert (BetS c b P) by (conclude axiom_betweennesssymmetry).
assert (~ Col a d P).
intro.
assert (Col a e d) by (conclude_def Col ).
assert (Col a d e) by (forward_using lemma_collinearorder).
assert (neq a d) by (forward_using lemma_betweennotequal).
assert (Col d P e) by (conclude lemma_collinear4).
assert (Col e P d) by (forward_using lemma_collinearorder).
assert (Col e b P) by (conclude_def Col ).
assert (Col e P b) by (forward_using lemma_collinearorder).
assert (neq e P) by (forward_using lemma_betweennotequal).
assert (Col P d b) by (conclude lemma_collinear4).
assert (Col d P b) by (forward_using lemma_collinearorder).
assert (Col d P a) by (forward_using lemma_collinearorder).
assert (~ eq d P).
intro.
assert (Col c b P) by (conclude_def Col ).
assert (Col c b d) by (conclude cn_equalitysub).
assert (Col b e c) by (conclude_def Col ).
assert (Col c b e) by (forward_using lemma_collinearorder).
assert (neq c b) by (forward_using lemma_betweennotequal).
assert (Col b d e) by (conclude lemma_collinear4).
assert (Col a e d) by (conclude_def Col ).

*****
H39 : Col a e d
H38 : Col b d e
H37 : neq c b
H36 : Col c b e
H35 : Col b e c
H34 : Col c b d
H33 : Col c b P
H32 : eq d P
H31 : Col d P a
H30 : Col d P b
H29 : Col P d b
H28 : neq e P
H27 : Col e P b
H26 : Col e b P
H25 : Col e P d
H24 : Col d P e
H23 : neq a d
H22 : Col a d e
H21 : Col a e d
H20 : Col a d P
H19 : BetS c b P
H18 : BetS P b c
H17 : BetS b e c
H16 : BetS P b e
H15 : Cong b P e b
H14 : BetS e b P
P : Point
H13 : not (Meet a b C D)
H12 : neq e b
H11 : neq b a
H10 : BetS c e b
H9 : BetS a e d
H8 : not (Meet A B C D)
H7 : neq c d
H6 : Col C D d
H5 : Col C D c
H4 : neq a b
H3 : Col A B b
H2 : Col A B a
H1 : neq C D
H0 : neq A B
a,b,c,d,e : Point
H : Par A B C D
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
False
+++++
assert (Col d e a) by (forward_using lemma_collinearorder).
-----
Lemma lemma_paralleldef2B : forall A B C D, Par A B C D -> TP A B C D.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists a b c d e, (neq A B /\\ neq C D /\\ Col A B a /\\ Col A B b /\\ neq a b /\\ Col C D c /\\ Col C D d /\\ neq c d /\\ ~ Meet A B C D /\\ BetS a e d /\\ BetS c e b)) by (conclude_def Par );destruct Tf as [a[b[c[d[e]]]]];spliter.
assert (neq b a) by (conclude lemma_inequalitysymmetric).
assert (neq e b) by (forward_using lemma_betweennotequal).
assert (~ Meet a b C D).
let Tf:=fresh in assert (Tf:exists P, (BetS e b P /\\ Cong b P e b)) by (conclude lemma_extension);destruct Tf as [P];spliter.
assert (BetS P b e) by (conclude axiom_betweennesssymmetry).
assert (BetS b e c) by (conclude axiom_betweennesssymmetry).
assert (BetS P b c) by (conclude lemma_3_7b).
assert (BetS c b P) by (conclude axiom_betweennesssymmetry).
assert (~ Col a d P).
intro.
assert (Col a e d) by (conclude_def Col ).
assert (Col a d e) by (forward_using lemma_collinearorder).
assert (neq a d) by (forward_using lemma_betweennotequal).
assert (Col d P e) by (conclude lemma_collinear4).
assert (Col e P d) by (forward_using lemma_collinearorder).
assert (Col e b P) by (conclude_def Col ).
assert (Col e P b) by (forward_using lemma_collinearorder).
assert (neq e P) by (forward_using lemma_betweennotequal).
assert (Col P d b) by (conclude lemma_collinear4).
assert (Col d P b) by (forward_using lemma_collinearorder).
assert (Col d P a) by (forward_using lemma_collinearorder).
assert (~ eq d P).
intro.
assert (Col c b P) by (conclude_def Col ).
assert (Col c b d) by (conclude cn_equalitysub).
assert (Col b e c) by (conclude_def Col ).
assert (Col c b e) by (forward_using lemma_collinearorder).
assert (neq c b) by (forward_using lemma_betweennotequal).
assert (Col b d e) by (conclude lemma_collinear4).
assert (Col a e d) by (conclude_def Col ).
assert (Col d e a) by (forward_using lemma_collinearorder).

*****
H40 : Col d e a
H39 : Col a e d
H38 : Col b d e
H37 : neq c b
H36 : Col c b e
H35 : Col b e c
H34 : Col c b d
H33 : Col c b P
H32 : eq d P
H31 : Col d P a
H30 : Col d P b
H29 : Col P d b
H28 : neq e P
H27 : Col e P b
H26 : Col e b P
H25 : Col e P d
H24 : Col d P e
H23 : neq a d
H22 : Col a d e
H21 : Col a e d
H20 : Col a d P
H19 : BetS c b P
H18 : BetS P b c
H17 : BetS b e c
H16 : BetS P b e
H15 : Cong b P e b
H14 : BetS e b P
P : Point
H13 : not (Meet a b C D)
H12 : neq e b
H11 : neq b a
H10 : BetS c e b
H9 : BetS a e d
H8 : not (Meet A B C D)
H7 : neq c d
H6 : Col C D d
H5 : Col C D c
H4 : neq a b
H3 : Col A B b
H2 : Col A B a
H1 : neq C D
H0 : neq A B
a,b,c,d,e : Point
H : Par A B C D
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
False
+++++
assert (Col d e b) by (forward_using lemma_collinearorder).
-----
Lemma lemma_paralleldef2B : forall A B C D, Par A B C D -> TP A B C D.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists a b c d e, (neq A B /\\ neq C D /\\ Col A B a /\\ Col A B b /\\ neq a b /\\ Col C D c /\\ Col C D d /\\ neq c d /\\ ~ Meet A B C D /\\ BetS a e d /\\ BetS c e b)) by (conclude_def Par );destruct Tf as [a[b[c[d[e]]]]];spliter.
assert (neq b a) by (conclude lemma_inequalitysymmetric).
assert (neq e b) by (forward_using lemma_betweennotequal).
assert (~ Meet a b C D).
let Tf:=fresh in assert (Tf:exists P, (BetS e b P /\\ Cong b P e b)) by (conclude lemma_extension);destruct Tf as [P];spliter.
assert (BetS P b e) by (conclude axiom_betweennesssymmetry).
assert (BetS b e c) by (conclude axiom_betweennesssymmetry).
assert (BetS P b c) by (conclude lemma_3_7b).
assert (BetS c b P) by (conclude axiom_betweennesssymmetry).
assert (~ Col a d P).
intro.
assert (Col a e d) by (conclude_def Col ).
assert (Col a d e) by (forward_using lemma_collinearorder).
assert (neq a d) by (forward_using lemma_betweennotequal).
assert (Col d P e) by (conclude lemma_collinear4).
assert (Col e P d) by (forward_using lemma_collinearorder).
assert (Col e b P) by (conclude_def Col ).
assert (Col e P b) by (forward_using lemma_collinearorder).
assert (neq e P) by (forward_using lemma_betweennotequal).
assert (Col P d b) by (conclude lemma_collinear4).
assert (Col d P b) by (forward_using lemma_collinearorder).
assert (Col d P a) by (forward_using lemma_collinearorder).
assert (~ eq d P).
intro.
assert (Col c b P) by (conclude_def Col ).
assert (Col c b d) by (conclude cn_equalitysub).
assert (Col b e c) by (conclude_def Col ).
assert (Col c b e) by (forward_using lemma_collinearorder).
assert (neq c b) by (forward_using lemma_betweennotequal).
assert (Col b d e) by (conclude lemma_collinear4).
assert (Col a e d) by (conclude_def Col ).
assert (Col d e a) by (forward_using lemma_collinearorder).
assert (Col d e b) by (forward_using lemma_collinearorder).

*****
H41 : Col d e b
H40 : Col d e a
H39 : Col a e d
H38 : Col b d e
H37 : neq c b
H36 : Col c b e
H35 : Col b e c
H34 : Col c b d
H33 : Col c b P
H32 : eq d P
H31 : Col d P a
H30 : Col d P b
H29 : Col P d b
H28 : neq e P
H27 : Col e P b
H26 : Col e b P
H25 : Col e P d
H24 : Col d P e
H23 : neq a d
H22 : Col a d e
H21 : Col a e d
H20 : Col a d P
H19 : BetS c b P
H18 : BetS P b c
H17 : BetS b e c
H16 : BetS P b e
H15 : Cong b P e b
H14 : BetS e b P
P : Point
H13 : not (Meet a b C D)
H12 : neq e b
H11 : neq b a
H10 : BetS c e b
H9 : BetS a e d
H8 : not (Meet A B C D)
H7 : neq c d
H6 : Col C D d
H5 : Col C D c
H4 : neq a b
H3 : Col A B b
H2 : Col A B a
H1 : neq C D
H0 : neq A B
a,b,c,d,e : Point
H : Par A B C D
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
False
+++++
assert (neq e d) by (forward_using lemma_betweennotequal).
-----
Lemma lemma_paralleldef2B : forall A B C D, Par A B C D -> TP A B C D.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists a b c d e, (neq A B /\\ neq C D /\\ Col A B a /\\ Col A B b /\\ neq a b /\\ Col C D c /\\ Col C D d /\\ neq c d /\\ ~ Meet A B C D /\\ BetS a e d /\\ BetS c e b)) by (conclude_def Par );destruct Tf as [a[b[c[d[e]]]]];spliter.
assert (neq b a) by (conclude lemma_inequalitysymmetric).
assert (neq e b) by (forward_using lemma_betweennotequal).
assert (~ Meet a b C D).
let Tf:=fresh in assert (Tf:exists P, (BetS e b P /\\ Cong b P e b)) by (conclude lemma_extension);destruct Tf as [P];spliter.
assert (BetS P b e) by (conclude axiom_betweennesssymmetry).
assert (BetS b e c) by (conclude axiom_betweennesssymmetry).
assert (BetS P b c) by (conclude lemma_3_7b).
assert (BetS c b P) by (conclude axiom_betweennesssymmetry).
assert (~ Col a d P).
intro.
assert (Col a e d) by (conclude_def Col ).
assert (Col a d e) by (forward_using lemma_collinearorder).
assert (neq a d) by (forward_using lemma_betweennotequal).
assert (Col d P e) by (conclude lemma_collinear4).
assert (Col e P d) by (forward_using lemma_collinearorder).
assert (Col e b P) by (conclude_def Col ).
assert (Col e P b) by (forward_using lemma_collinearorder).
assert (neq e P) by (forward_using lemma_betweennotequal).
assert (Col P d b) by (conclude lemma_collinear4).
assert (Col d P b) by (forward_using lemma_collinearorder).
assert (Col d P a) by (forward_using lemma_collinearorder).
assert (~ eq d P).
intro.
assert (Col c b P) by (conclude_def Col ).
assert (Col c b d) by (conclude cn_equalitysub).
assert (Col b e c) by (conclude_def Col ).
assert (Col c b e) by (forward_using lemma_collinearorder).
assert (neq c b) by (forward_using lemma_betweennotequal).
assert (Col b d e) by (conclude lemma_collinear4).
assert (Col a e d) by (conclude_def Col ).
assert (Col d e a) by (forward_using lemma_collinearorder).
assert (Col d e b) by (forward_using lemma_collinearorder).
assert (neq e d) by (forward_using lemma_betweennotequal).

*****
H42 : neq e d
H41 : Col d e b
H40 : Col d e a
H39 : Col a e d
H38 : Col b d e
H37 : neq c b
H36 : Col c b e
H35 : Col b e c
H34 : Col c b d
H33 : Col c b P
H32 : eq d P
H31 : Col d P a
H30 : Col d P b
H29 : Col P d b
H28 : neq e P
H27 : Col e P b
H26 : Col e b P
H25 : Col e P d
H24 : Col d P e
H23 : neq a d
H22 : Col a d e
H21 : Col a e d
H20 : Col a d P
H19 : BetS c b P
H18 : BetS P b c
H17 : BetS b e c
H16 : BetS P b e
H15 : Cong b P e b
H14 : BetS e b P
P : Point
H13 : not (Meet a b C D)
H12 : neq e b
H11 : neq b a
H10 : BetS c e b
H9 : BetS a e d
H8 : not (Meet A B C D)
H7 : neq c d
H6 : Col C D d
H5 : Col C D c
H4 : neq a b
H3 : Col A B b
H2 : Col A B a
H1 : neq C D
H0 : neq A B
a,b,c,d,e : Point
H : Par A B C D
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
False
+++++
assert (neq d e) by (conclude lemma_inequalitysymmetric).
-----
Lemma lemma_paralleldef2B : forall A B C D, Par A B C D -> TP A B C D.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists a b c d e, (neq A B /\\ neq C D /\\ Col A B a /\\ Col A B b /\\ neq a b /\\ Col C D c /\\ Col C D d /\\ neq c d /\\ ~ Meet A B C D /\\ BetS a e d /\\ BetS c e b)) by (conclude_def Par );destruct Tf as [a[b[c[d[e]]]]];spliter.
assert (neq b a) by (conclude lemma_inequalitysymmetric).
assert (neq e b) by (forward_using lemma_betweennotequal).
assert (~ Meet a b C D).
let Tf:=fresh in assert (Tf:exists P, (BetS e b P /\\ Cong b P e b)) by (conclude lemma_extension);destruct Tf as [P];spliter.
assert (BetS P b e) by (conclude axiom_betweennesssymmetry).
assert (BetS b e c) by (conclude axiom_betweennesssymmetry).
assert (BetS P b c) by (conclude lemma_3_7b).
assert (BetS c b P) by (conclude axiom_betweennesssymmetry).
assert (~ Col a d P).
intro.
assert (Col a e d) by (conclude_def Col ).
assert (Col a d e) by (forward_using lemma_collinearorder).
assert (neq a d) by (forward_using lemma_betweennotequal).
assert (Col d P e) by (conclude lemma_collinear4).
assert (Col e P d) by (forward_using lemma_collinearorder).
assert (Col e b P) by (conclude_def Col ).
assert (Col e P b) by (forward_using lemma_collinearorder).
assert (neq e P) by (forward_using lemma_betweennotequal).
assert (Col P d b) by (conclude lemma_collinear4).
assert (Col d P b) by (forward_using lemma_collinearorder).
assert (Col d P a) by (forward_using lemma_collinearorder).
assert (~ eq d P).
intro.
assert (Col c b P) by (conclude_def Col ).
assert (Col c b d) by (conclude cn_equalitysub).
assert (Col b e c) by (conclude_def Col ).
assert (Col c b e) by (forward_using lemma_collinearorder).
assert (neq c b) by (forward_using lemma_betweennotequal).
assert (Col b d e) by (conclude lemma_collinear4).
assert (Col a e d) by (conclude_def Col ).
assert (Col d e a) by (forward_using lemma_collinearorder).
assert (Col d e b) by (forward_using lemma_collinearorder).
assert (neq e d) by (forward_using lemma_betweennotequal).
assert (neq d e) by (conclude lemma_inequalitysymmetric).

*****
H43 : neq d e
H42 : neq e d
H41 : Col d e b
H40 : Col d e a
H39 : Col a e d
H38 : Col b d e
H37 : neq c b
H36 : Col c b e
H35 : Col b e c
H34 : Col c b d
H33 : Col c b P
H32 : eq d P
H31 : Col d P a
H30 : Col d P b
H29 : Col P d b
H28 : neq e P
H27 : Col e P b
H26 : Col e b P
H25 : Col e P d
H24 : Col d P e
H23 : neq a d
H22 : Col a d e
H21 : Col a e d
H20 : Col a d P
H19 : BetS c b P
H18 : BetS P b c
H17 : BetS b e c
H16 : BetS P b e
H15 : Cong b P e b
H14 : BetS e b P
P : Point
H13 : not (Meet a b C D)
H12 : neq e b
H11 : neq b a
H10 : BetS c e b
H9 : BetS a e d
H8 : not (Meet A B C D)
H7 : neq c d
H6 : Col C D d
H5 : Col C D c
H4 : neq a b
H3 : Col A B b
H2 : Col A B a
H1 : neq C D
H0 : neq A B
a,b,c,d,e : Point
H : Par A B C D
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
False
+++++
assert (Col e a b) by (conclude lemma_collinear4).
-----
Lemma lemma_paralleldef2B : forall A B C D, Par A B C D -> TP A B C D.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists a b c d e, (neq A B /\\ neq C D /\\ Col A B a /\\ Col A B b /\\ neq a b /\\ Col C D c /\\ Col C D d /\\ neq c d /\\ ~ Meet A B C D /\\ BetS a e d /\\ BetS c e b)) by (conclude_def Par );destruct Tf as [a[b[c[d[e]]]]];spliter.
assert (neq b a) by (conclude lemma_inequalitysymmetric).
assert (neq e b) by (forward_using lemma_betweennotequal).
assert (~ Meet a b C D).
let Tf:=fresh in assert (Tf:exists P, (BetS e b P /\\ Cong b P e b)) by (conclude lemma_extension);destruct Tf as [P];spliter.
assert (BetS P b e) by (conclude axiom_betweennesssymmetry).
assert (BetS b e c) by (conclude axiom_betweennesssymmetry).
assert (BetS P b c) by (conclude lemma_3_7b).
assert (BetS c b P) by (conclude axiom_betweennesssymmetry).
assert (~ Col a d P).
intro.
assert (Col a e d) by (conclude_def Col ).
assert (Col a d e) by (forward_using lemma_collinearorder).
assert (neq a d) by (forward_using lemma_betweennotequal).
assert (Col d P e) by (conclude lemma_collinear4).
assert (Col e P d) by (forward_using lemma_collinearorder).
assert (Col e b P) by (conclude_def Col ).
assert (Col e P b) by (forward_using lemma_collinearorder).
assert (neq e P) by (forward_using lemma_betweennotequal).
assert (Col P d b) by (conclude lemma_collinear4).
assert (Col d P b) by (forward_using lemma_collinearorder).
assert (Col d P a) by (forward_using lemma_collinearorder).
assert (~ eq d P).
intro.
assert (Col c b P) by (conclude_def Col ).
assert (Col c b d) by (conclude cn_equalitysub).
assert (Col b e c) by (conclude_def Col ).
assert (Col c b e) by (forward_using lemma_collinearorder).
assert (neq c b) by (forward_using lemma_betweennotequal).
assert (Col b d e) by (conclude lemma_collinear4).
assert (Col a e d) by (conclude_def Col ).
assert (Col d e a) by (forward_using lemma_collinearorder).
assert (Col d e b) by (forward_using lemma_collinearorder).
assert (neq e d) by (forward_using lemma_betweennotequal).
assert (neq d e) by (conclude lemma_inequalitysymmetric).
assert (Col e a b) by (conclude lemma_collinear4).

*****
H44 : Col e a b
H43 : neq d e
H42 : neq e d
H41 : Col d e b
H40 : Col d e a
H39 : Col a e d
H38 : Col b d e
H37 : neq c b
H36 : Col c b e
H35 : Col b e c
H34 : Col c b d
H33 : Col c b P
H32 : eq d P
H31 : Col d P a
H30 : Col d P b
H29 : Col P d b
H28 : neq e P
H27 : Col e P b
H26 : Col e b P
H25 : Col e P d
H24 : Col d P e
H23 : neq a d
H22 : Col a d e
H21 : Col a e d
H20 : Col a d P
H19 : BetS c b P
H18 : BetS P b c
H17 : BetS b e c
H16 : BetS P b e
H15 : Cong b P e b
H14 : BetS e b P
P : Point
H13 : not (Meet a b C D)
H12 : neq e b
H11 : neq b a
H10 : BetS c e b
H9 : BetS a e d
H8 : not (Meet A B C D)
H7 : neq c d
H6 : Col C D d
H5 : Col C D c
H4 : neq a b
H3 : Col A B b
H2 : Col A B a
H1 : neq C D
H0 : neq A B
a,b,c,d,e : Point
H : Par A B C D
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
False
+++++
assert (Col a e d) by (conclude_def Col ).
-----
Lemma lemma_paralleldef2B : forall A B C D, Par A B C D -> TP A B C D.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists a b c d e, (neq A B /\\ neq C D /\\ Col A B a /\\ Col A B b /\\ neq a b /\\ Col C D c /\\ Col C D d /\\ neq c d /\\ ~ Meet A B C D /\\ BetS a e d /\\ BetS c e b)) by (conclude_def Par );destruct Tf as [a[b[c[d[e]]]]];spliter.
assert (neq b a) by (conclude lemma_inequalitysymmetric).
assert (neq e b) by (forward_using lemma_betweennotequal).
assert (~ Meet a b C D).
let Tf:=fresh in assert (Tf:exists P, (BetS e b P /\\ Cong b P e b)) by (conclude lemma_extension);destruct Tf as [P];spliter.
assert (BetS P b e) by (conclude axiom_betweennesssymmetry).
assert (BetS b e c) by (conclude axiom_betweennesssymmetry).
assert (BetS P b c) by (conclude lemma_3_7b).
assert (BetS c b P) by (conclude axiom_betweennesssymmetry).
assert (~ Col a d P).
intro.
assert (Col a e d) by (conclude_def Col ).
assert (Col a d e) by (forward_using lemma_collinearorder).
assert (neq a d) by (forward_using lemma_betweennotequal).
assert (Col d P e) by (conclude lemma_collinear4).
assert (Col e P d) by (forward_using lemma_collinearorder).
assert (Col e b P) by (conclude_def Col ).
assert (Col e P b) by (forward_using lemma_collinearorder).
assert (neq e P) by (forward_using lemma_betweennotequal).
assert (Col P d b) by (conclude lemma_collinear4).
assert (Col d P b) by (forward_using lemma_collinearorder).
assert (Col d P a) by (forward_using lemma_collinearorder).
assert (~ eq d P).
intro.
assert (Col c b P) by (conclude_def Col ).
assert (Col c b d) by (conclude cn_equalitysub).
assert (Col b e c) by (conclude_def Col ).
assert (Col c b e) by (forward_using lemma_collinearorder).
assert (neq c b) by (forward_using lemma_betweennotequal).
assert (Col b d e) by (conclude lemma_collinear4).
assert (Col a e d) by (conclude_def Col ).
assert (Col d e a) by (forward_using lemma_collinearorder).
assert (Col d e b) by (forward_using lemma_collinearorder).
assert (neq e d) by (forward_using lemma_betweennotequal).
assert (neq d e) by (conclude lemma_inequalitysymmetric).
assert (Col e a b) by (conclude lemma_collinear4).
assert (Col a e d) by (conclude_def Col ).

*****
H45 : Col a e d
H44 : Col e a b
H43 : neq d e
H42 : neq e d
H41 : Col d e b
H40 : Col d e a
H39 : Col a e d
H38 : Col b d e
H37 : neq c b
H36 : Col c b e
H35 : Col b e c
H34 : Col c b d
H33 : Col c b P
H32 : eq d P
H31 : Col d P a
H30 : Col d P b
H29 : Col P d b
H28 : neq e P
H27 : Col e P b
H26 : Col e b P
H25 : Col e P d
H24 : Col d P e
H23 : neq a d
H22 : Col a d e
H21 : Col a e d
H20 : Col a d P
H19 : BetS c b P
H18 : BetS P b c
H17 : BetS b e c
H16 : BetS P b e
H15 : Cong b P e b
H14 : BetS e b P
P : Point
H13 : not (Meet a b C D)
H12 : neq e b
H11 : neq b a
H10 : BetS c e b
H9 : BetS a e d
H8 : not (Meet A B C D)
H7 : neq c d
H6 : Col C D d
H5 : Col C D c
H4 : neq a b
H3 : Col A B b
H2 : Col A B a
H1 : neq C D
H0 : neq A B
a,b,c,d,e : Point
H : Par A B C D
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
False
+++++
assert (Col e a d) by (forward_using lemma_collinearorder).
-----
Lemma lemma_paralleldef2B : forall A B C D, Par A B C D -> TP A B C D.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists a b c d e, (neq A B /\\ neq C D /\\ Col A B a /\\ Col A B b /\\ neq a b /\\ Col C D c /\\ Col C D d /\\ neq c d /\\ ~ Meet A B C D /\\ BetS a e d /\\ BetS c e b)) by (conclude_def Par );destruct Tf as [a[b[c[d[e]]]]];spliter.
assert (neq b a) by (conclude lemma_inequalitysymmetric).
assert (neq e b) by (forward_using lemma_betweennotequal).
assert (~ Meet a b C D).
let Tf:=fresh in assert (Tf:exists P, (BetS e b P /\\ Cong b P e b)) by (conclude lemma_extension);destruct Tf as [P];spliter.
assert (BetS P b e) by (conclude axiom_betweennesssymmetry).
assert (BetS b e c) by (conclude axiom_betweennesssymmetry).
assert (BetS P b c) by (conclude lemma_3_7b).
assert (BetS c b P) by (conclude axiom_betweennesssymmetry).
assert (~ Col a d P).
intro.
assert (Col a e d) by (conclude_def Col ).
assert (Col a d e) by (forward_using lemma_collinearorder).
assert (neq a d) by (forward_using lemma_betweennotequal).
assert (Col d P e) by (conclude lemma_collinear4).
assert (Col e P d) by (forward_using lemma_collinearorder).
assert (Col e b P) by (conclude_def Col ).
assert (Col e P b) by (forward_using lemma_collinearorder).
assert (neq e P) by (forward_using lemma_betweennotequal).
assert (Col P d b) by (conclude lemma_collinear4).
assert (Col d P b) by (forward_using lemma_collinearorder).
assert (Col d P a) by (forward_using lemma_collinearorder).
assert (~ eq d P).
intro.
assert (Col c b P) by (conclude_def Col ).
assert (Col c b d) by (conclude cn_equalitysub).
assert (Col b e c) by (conclude_def Col ).
assert (Col c b e) by (forward_using lemma_collinearorder).
assert (neq c b) by (forward_using lemma_betweennotequal).
assert (Col b d e) by (conclude lemma_collinear4).
assert (Col a e d) by (conclude_def Col ).
assert (Col d e a) by (forward_using lemma_collinearorder).
assert (Col d e b) by (forward_using lemma_collinearorder).
assert (neq e d) by (forward_using lemma_betweennotequal).
assert (neq d e) by (conclude lemma_inequalitysymmetric).
assert (Col e a b) by (conclude lemma_collinear4).
assert (Col a e d) by (conclude_def Col ).
assert (Col e a d) by (forward_using lemma_collinearorder).

*****
H46 : Col e a d
H45 : Col a e d
H44 : Col e a b
H43 : neq d e
H42 : neq e d
H41 : Col d e b
H40 : Col d e a
H39 : Col a e d
H38 : Col b d e
H37 : neq c b
H36 : Col c b e
H35 : Col b e c
H34 : Col c b d
H33 : Col c b P
H32 : eq d P
H31 : Col d P a
H30 : Col d P b
H29 : Col P d b
H28 : neq e P
H27 : Col e P b
H26 : Col e b P
H25 : Col e P d
H24 : Col d P e
H23 : neq a d
H22 : Col a d e
H21 : Col a e d
H20 : Col a d P
H19 : BetS c b P
H18 : BetS P b c
H17 : BetS b e c
H16 : BetS P b e
H15 : Cong b P e b
H14 : BetS e b P
P : Point
H13 : not (Meet a b C D)
H12 : neq e b
H11 : neq b a
H10 : BetS c e b
H9 : BetS a e d
H8 : not (Meet A B C D)
H7 : neq c d
H6 : Col C D d
H5 : Col C D c
H4 : neq a b
H3 : Col A B b
H2 : Col A B a
H1 : neq C D
H0 : neq A B
a,b,c,d,e : Point
H : Par A B C D
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
False
+++++
assert (neq a e) by (forward_using lemma_betweennotequal).
-----
Lemma lemma_paralleldef2B : forall A B C D, Par A B C D -> TP A B C D.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists a b c d e, (neq A B /\\ neq C D /\\ Col A B a /\\ Col A B b /\\ neq a b /\\ Col C D c /\\ Col C D d /\\ neq c d /\\ ~ Meet A B C D /\\ BetS a e d /\\ BetS c e b)) by (conclude_def Par );destruct Tf as [a[b[c[d[e]]]]];spliter.
assert (neq b a) by (conclude lemma_inequalitysymmetric).
assert (neq e b) by (forward_using lemma_betweennotequal).
assert (~ Meet a b C D).
let Tf:=fresh in assert (Tf:exists P, (BetS e b P /\\ Cong b P e b)) by (conclude lemma_extension);destruct Tf as [P];spliter.
assert (BetS P b e) by (conclude axiom_betweennesssymmetry).
assert (BetS b e c) by (conclude axiom_betweennesssymmetry).
assert (BetS P b c) by (conclude lemma_3_7b).
assert (BetS c b P) by (conclude axiom_betweennesssymmetry).
assert (~ Col a d P).
intro.
assert (Col a e d) by (conclude_def Col ).
assert (Col a d e) by (forward_using lemma_collinearorder).
assert (neq a d) by (forward_using lemma_betweennotequal).
assert (Col d P e) by (conclude lemma_collinear4).
assert (Col e P d) by (forward_using lemma_collinearorder).
assert (Col e b P) by (conclude_def Col ).
assert (Col e P b) by (forward_using lemma_collinearorder).
assert (neq e P) by (forward_using lemma_betweennotequal).
assert (Col P d b) by (conclude lemma_collinear4).
assert (Col d P b) by (forward_using lemma_collinearorder).
assert (Col d P a) by (forward_using lemma_collinearorder).
assert (~ eq d P).
intro.
assert (Col c b P) by (conclude_def Col ).
assert (Col c b d) by (conclude cn_equalitysub).
assert (Col b e c) by (conclude_def Col ).
assert (Col c b e) by (forward_using lemma_collinearorder).
assert (neq c b) by (forward_using lemma_betweennotequal).
assert (Col b d e) by (conclude lemma_collinear4).
assert (Col a e d) by (conclude_def Col ).
assert (Col d e a) by (forward_using lemma_collinearorder).
assert (Col d e b) by (forward_using lemma_collinearorder).
assert (neq e d) by (forward_using lemma_betweennotequal).
assert (neq d e) by (conclude lemma_inequalitysymmetric).
assert (Col e a b) by (conclude lemma_collinear4).
assert (Col a e d) by (conclude_def Col ).
assert (Col e a d) by (forward_using lemma_collinearorder).
assert (neq a e) by (forward_using lemma_betweennotequal).

*****
H47 : neq a e
H46 : Col e a d
H45 : Col a e d
H44 : Col e a b
H43 : neq d e
H42 : neq e d
H41 : Col d e b
H40 : Col d e a
H39 : Col a e d
H38 : Col b d e
H37 : neq c b
H36 : Col c b e
H35 : Col b e c
H34 : Col c b d
H33 : Col c b P
H32 : eq d P
H31 : Col d P a
H30 : Col d P b
H29 : Col P d b
H28 : neq e P
H27 : Col e P b
H26 : Col e b P
H25 : Col e P d
H24 : Col d P e
H23 : neq a d
H22 : Col a d e
H21 : Col a e d
H20 : Col a d P
H19 : BetS c b P
H18 : BetS P b c
H17 : BetS b e c
H16 : BetS P b e
H15 : Cong b P e b
H14 : BetS e b P
P : Point
H13 : not (Meet a b C D)
H12 : neq e b
H11 : neq b a
H10 : BetS c e b
H9 : BetS a e d
H8 : not (Meet A B C D)
H7 : neq c d
H6 : Col C D d
H5 : Col C D c
H4 : neq a b
H3 : Col A B b
H2 : Col A B a
H1 : neq C D
H0 : neq A B
a,b,c,d,e : Point
H : Par A B C D
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
False
+++++
assert (neq e a) by (conclude lemma_inequalitysymmetric).
-----
Lemma lemma_paralleldef2B : forall A B C D, Par A B C D -> TP A B C D.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists a b c d e, (neq A B /\\ neq C D /\\ Col A B a /\\ Col A B b /\\ neq a b /\\ Col C D c /\\ Col C D d /\\ neq c d /\\ ~ Meet A B C D /\\ BetS a e d /\\ BetS c e b)) by (conclude_def Par );destruct Tf as [a[b[c[d[e]]]]];spliter.
assert (neq b a) by (conclude lemma_inequalitysymmetric).
assert (neq e b) by (forward_using lemma_betweennotequal).
assert (~ Meet a b C D).
let Tf:=fresh in assert (Tf:exists P, (BetS e b P /\\ Cong b P e b)) by (conclude lemma_extension);destruct Tf as [P];spliter.
assert (BetS P b e) by (conclude axiom_betweennesssymmetry).
assert (BetS b e c) by (conclude axiom_betweennesssymmetry).
assert (BetS P b c) by (conclude lemma_3_7b).
assert (BetS c b P) by (conclude axiom_betweennesssymmetry).
assert (~ Col a d P).
intro.
assert (Col a e d) by (conclude_def Col ).
assert (Col a d e) by (forward_using lemma_collinearorder).
assert (neq a d) by (forward_using lemma_betweennotequal).
assert (Col d P e) by (conclude lemma_collinear4).
assert (Col e P d) by (forward_using lemma_collinearorder).
assert (Col e b P) by (conclude_def Col ).
assert (Col e P b) by (forward_using lemma_collinearorder).
assert (neq e P) by (forward_using lemma_betweennotequal).
assert (Col P d b) by (conclude lemma_collinear4).
assert (Col d P b) by (forward_using lemma_collinearorder).
assert (Col d P a) by (forward_using lemma_collinearorder).
assert (~ eq d P).
intro.
assert (Col c b P) by (conclude_def Col ).
assert (Col c b d) by (conclude cn_equalitysub).
assert (Col b e c) by (conclude_def Col ).
assert (Col c b e) by (forward_using lemma_collinearorder).
assert (neq c b) by (forward_using lemma_betweennotequal).
assert (Col b d e) by (conclude lemma_collinear4).
assert (Col a e d) by (conclude_def Col ).
assert (Col d e a) by (forward_using lemma_collinearorder).
assert (Col d e b) by (forward_using lemma_collinearorder).
assert (neq e d) by (forward_using lemma_betweennotequal).
assert (neq d e) by (conclude lemma_inequalitysymmetric).
assert (Col e a b) by (conclude lemma_collinear4).
assert (Col a e d) by (conclude_def Col ).
assert (Col e a d) by (forward_using lemma_collinearorder).
assert (neq a e) by (forward_using lemma_betweennotequal).
assert (neq e a) by (conclude lemma_inequalitysymmetric).

*****
H48 : neq e a
H47 : neq a e
H46 : Col e a d
H45 : Col a e d
H44 : Col e a b
H43 : neq d e
H42 : neq e d
H41 : Col d e b
H40 : Col d e a
H39 : Col a e d
H38 : Col b d e
H37 : neq c b
H36 : Col c b e
H35 : Col b e c
H34 : Col c b d
H33 : Col c b P
H32 : eq d P
H31 : Col d P a
H30 : Col d P b
H29 : Col P d b
H28 : neq e P
H27 : Col e P b
H26 : Col e b P
H25 : Col e P d
H24 : Col d P e
H23 : neq a d
H22 : Col a d e
H21 : Col a e d
H20 : Col a d P
H19 : BetS c b P
H18 : BetS P b c
H17 : BetS b e c
H16 : BetS P b e
H15 : Cong b P e b
H14 : BetS e b P
P : Point
H13 : not (Meet a b C D)
H12 : neq e b
H11 : neq b a
H10 : BetS c e b
H9 : BetS a e d
H8 : not (Meet A B C D)
H7 : neq c d
H6 : Col C D d
H5 : Col C D c
H4 : neq a b
H3 : Col A B b
H2 : Col A B a
H1 : neq C D
H0 : neq A B
a,b,c,d,e : Point
H : Par A B C D
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
False
+++++
assert (Col a b d) by (conclude lemma_collinear4).
-----
Lemma lemma_paralleldef2B : forall A B C D, Par A B C D -> TP A B C D.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists a b c d e, (neq A B /\\ neq C D /\\ Col A B a /\\ Col A B b /\\ neq a b /\\ Col C D c /\\ Col C D d /\\ neq c d /\\ ~ Meet A B C D /\\ BetS a e d /\\ BetS c e b)) by (conclude_def Par );destruct Tf as [a[b[c[d[e]]]]];spliter.
assert (neq b a) by (conclude lemma_inequalitysymmetric).
assert (neq e b) by (forward_using lemma_betweennotequal).
assert (~ Meet a b C D).
let Tf:=fresh in assert (Tf:exists P, (BetS e b P /\\ Cong b P e b)) by (conclude lemma_extension);destruct Tf as [P];spliter.
assert (BetS P b e) by (conclude axiom_betweennesssymmetry).
assert (BetS b e c) by (conclude axiom_betweennesssymmetry).
assert (BetS P b c) by (conclude lemma_3_7b).
assert (BetS c b P) by (conclude axiom_betweennesssymmetry).
assert (~ Col a d P).
intro.
assert (Col a e d) by (conclude_def Col ).
assert (Col a d e) by (forward_using lemma_collinearorder).
assert (neq a d) by (forward_using lemma_betweennotequal).
assert (Col d P e) by (conclude lemma_collinear4).
assert (Col e P d) by (forward_using lemma_collinearorder).
assert (Col e b P) by (conclude_def Col ).
assert (Col e P b) by (forward_using lemma_collinearorder).
assert (neq e P) by (forward_using lemma_betweennotequal).
assert (Col P d b) by (conclude lemma_collinear4).
assert (Col d P b) by (forward_using lemma_collinearorder).
assert (Col d P a) by (forward_using lemma_collinearorder).
assert (~ eq d P).
intro.
assert (Col c b P) by (conclude_def Col ).
assert (Col c b d) by (conclude cn_equalitysub).
assert (Col b e c) by (conclude_def Col ).
assert (Col c b e) by (forward_using lemma_collinearorder).
assert (neq c b) by (forward_using lemma_betweennotequal).
assert (Col b d e) by (conclude lemma_collinear4).
assert (Col a e d) by (conclude_def Col ).
assert (Col d e a) by (forward_using lemma_collinearorder).
assert (Col d e b) by (forward_using lemma_collinearorder).
assert (neq e d) by (forward_using lemma_betweennotequal).
assert (neq d e) by (conclude lemma_inequalitysymmetric).
assert (Col e a b) by (conclude lemma_collinear4).
assert (Col a e d) by (conclude_def Col ).
assert (Col e a d) by (forward_using lemma_collinearorder).
assert (neq a e) by (forward_using lemma_betweennotequal).
assert (neq e a) by (conclude lemma_inequalitysymmetric).
assert (Col a b d) by (conclude lemma_collinear4).

*****
H49 : Col a b d
H48 : neq e a
H47 : neq a e
H46 : Col e a d
H45 : Col a e d
H44 : Col e a b
H43 : neq d e
H42 : neq e d
H41 : Col d e b
H40 : Col d e a
H39 : Col a e d
H38 : Col b d e
H37 : neq c b
H36 : Col c b e
H35 : Col b e c
H34 : Col c b d
H33 : Col c b P
H32 : eq d P
H31 : Col d P a
H30 : Col d P b
H29 : Col P d b
H28 : neq e P
H27 : Col e P b
H26 : Col e b P
H25 : Col e P d
H24 : Col d P e
H23 : neq a d
H22 : Col a d e
H21 : Col a e d
H20 : Col a d P
H19 : BetS c b P
H18 : BetS P b c
H17 : BetS b e c
H16 : BetS P b e
H15 : Cong b P e b
H14 : BetS e b P
P : Point
H13 : not (Meet a b C D)
H12 : neq e b
H11 : neq b a
H10 : BetS c e b
H9 : BetS a e d
H8 : not (Meet A B C D)
H7 : neq c d
H6 : Col C D d
H5 : Col C D c
H4 : neq a b
H3 : Col A B b
H2 : Col A B a
H1 : neq C D
H0 : neq A B
a,b,c,d,e : Point
H : Par A B C D
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
False
+++++
assert (Meet a b C D) by (conclude_def Meet ).
-----
Lemma lemma_paralleldef2B : forall A B C D, Par A B C D -> TP A B C D.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists a b c d e, (neq A B /\\ neq C D /\\ Col A B a /\\ Col A B b /\\ neq a b /\\ Col C D c /\\ Col C D d /\\ neq c d /\\ ~ Meet A B C D /\\ BetS a e d /\\ BetS c e b)) by (conclude_def Par );destruct Tf as [a[b[c[d[e]]]]];spliter.
assert (neq b a) by (conclude lemma_inequalitysymmetric).
assert (neq e b) by (forward_using lemma_betweennotequal).
assert (~ Meet a b C D).
let Tf:=fresh in assert (Tf:exists P, (BetS e b P /\\ Cong b P e b)) by (conclude lemma_extension);destruct Tf as [P];spliter.
assert (BetS P b e) by (conclude axiom_betweennesssymmetry).
assert (BetS b e c) by (conclude axiom_betweennesssymmetry).
assert (BetS P b c) by (conclude lemma_3_7b).
assert (BetS c b P) by (conclude axiom_betweennesssymmetry).
assert (~ Col a d P).
intro.
assert (Col a e d) by (conclude_def Col ).
assert (Col a d e) by (forward_using lemma_collinearorder).
assert (neq a d) by (forward_using lemma_betweennotequal).
assert (Col d P e) by (conclude lemma_collinear4).
assert (Col e P d) by (forward_using lemma_collinearorder).
assert (Col e b P) by (conclude_def Col ).
assert (Col e P b) by (forward_using lemma_collinearorder).
assert (neq e P) by (forward_using lemma_betweennotequal).
assert (Col P d b) by (conclude lemma_collinear4).
assert (Col d P b) by (forward_using lemma_collinearorder).
assert (Col d P a) by (forward_using lemma_collinearorder).
assert (~ eq d P).
intro.
assert (Col c b P) by (conclude_def Col ).
assert (Col c b d) by (conclude cn_equalitysub).
assert (Col b e c) by (conclude_def Col ).
assert (Col c b e) by (forward_using lemma_collinearorder).
assert (neq c b) by (forward_using lemma_betweennotequal).
assert (Col b d e) by (conclude lemma_collinear4).
assert (Col a e d) by (conclude_def Col ).
assert (Col d e a) by (forward_using lemma_collinearorder).
assert (Col d e b) by (forward_using lemma_collinearorder).
assert (neq e d) by (forward_using lemma_betweennotequal).
assert (neq d e) by (conclude lemma_inequalitysymmetric).
assert (Col e a b) by (conclude lemma_collinear4).
assert (Col a e d) by (conclude_def Col ).
assert (Col e a d) by (forward_using lemma_collinearorder).
assert (neq a e) by (forward_using lemma_betweennotequal).
assert (neq e a) by (conclude lemma_inequalitysymmetric).
assert (Col a b d) by (conclude lemma_collinear4).
assert (Meet a b C D) by (conclude_def Meet ).

*****
H50 : Meet a b C D
H49 : Col a b d
H48 : neq e a
H47 : neq a e
H46 : Col e a d
H45 : Col a e d
H44 : Col e a b
H43 : neq d e
H42 : neq e d
H41 : Col d e b
H40 : Col d e a
H39 : Col a e d
H38 : Col b d e
H37 : neq c b
H36 : Col c b e
H35 : Col b e c
H34 : Col c b d
H33 : Col c b P
H32 : eq d P
H31 : Col d P a
H30 : Col d P b
H29 : Col P d b
H28 : neq e P
H27 : Col e P b
H26 : Col e b P
H25 : Col e P d
H24 : Col d P e
H23 : neq a d
H22 : Col a d e
H21 : Col a e d
H20 : Col a d P
H19 : BetS c b P
H18 : BetS P b c
H17 : BetS b e c
H16 : BetS P b e
H15 : Cong b P e b
H14 : BetS e b P
P : Point
H13 : not (Meet a b C D)
H12 : neq e b
H11 : neq b a
H10 : BetS c e b
H9 : BetS a e d
H8 : not (Meet A B C D)
H7 : neq c d
H6 : Col C D d
H5 : Col C D c
H4 : neq a b
H3 : Col A B b
H2 : Col A B a
H1 : neq C D
H0 : neq A B
a,b,c,d,e : Point
H : Par A B C D
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
False
+++++
contradict.
-----
Lemma lemma_paralleldef2B : forall A B C D, Par A B C D -> TP A B C D.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists a b c d e, (neq A B /\\ neq C D /\\ Col A B a /\\ Col A B b /\\ neq a b /\\ Col C D c /\\ Col C D d /\\ neq c d /\\ ~ Meet A B C D /\\ BetS a e d /\\ BetS c e b)) by (conclude_def Par );destruct Tf as [a[b[c[d[e]]]]];spliter.
assert (neq b a) by (conclude lemma_inequalitysymmetric).
assert (neq e b) by (forward_using lemma_betweennotequal).
assert (~ Meet a b C D).
let Tf:=fresh in assert (Tf:exists P, (BetS e b P /\\ Cong b P e b)) by (conclude lemma_extension);destruct Tf as [P];spliter.
assert (BetS P b e) by (conclude axiom_betweennesssymmetry).
assert (BetS b e c) by (conclude axiom_betweennesssymmetry).
assert (BetS P b c) by (conclude lemma_3_7b).
assert (BetS c b P) by (conclude axiom_betweennesssymmetry).
assert (~ Col a d P).
intro.
assert (Col a e d) by (conclude_def Col ).
assert (Col a d e) by (forward_using lemma_collinearorder).
assert (neq a d) by (forward_using lemma_betweennotequal).
assert (Col d P e) by (conclude lemma_collinear4).
assert (Col e P d) by (forward_using lemma_collinearorder).
assert (Col e b P) by (conclude_def Col ).
assert (Col e P b) by (forward_using lemma_collinearorder).
assert (neq e P) by (forward_using lemma_betweennotequal).
assert (Col P d b) by (conclude lemma_collinear4).
assert (Col d P b) by (forward_using lemma_collinearorder).
assert (Col d P a) by (forward_using lemma_collinearorder).
assert (~ eq d P).

*****
H32 : not (eq d P)
H31 : Col d P a
H30 : Col d P b
H29 : Col P d b
H28 : neq e P
H27 : Col e P b
H26 : Col e b P
H25 : Col e P d
H24 : Col d P e
H23 : neq a d
H22 : Col a d e
H21 : Col a e d
H20 : Col a d P
H19 : BetS c b P
H18 : BetS P b c
H17 : BetS b e c
H16 : BetS P b e
H15 : Cong b P e b
H14 : BetS e b P
P : Point
H13 : not (Meet a b C D)
H12 : neq e b
H11 : neq b a
H10 : BetS c e b
H9 : BetS a e d
H8 : not (Meet A B C D)
H7 : neq c d
H6 : Col C D d
H5 : Col C D c
H4 : neq a b
H3 : Col A B b
H2 : Col A B a
H1 : neq C D
H0 : neq A B
a,b,c,d,e : Point
H : Par A B C D
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
False
+++++
assert (Col P b a) by (conclude lemma_collinear4).
-----
Lemma lemma_paralleldef2B : forall A B C D, Par A B C D -> TP A B C D.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists a b c d e, (neq A B /\\ neq C D /\\ Col A B a /\\ Col A B b /\\ neq a b /\\ Col C D c /\\ Col C D d /\\ neq c d /\\ ~ Meet A B C D /\\ BetS a e d /\\ BetS c e b)) by (conclude_def Par );destruct Tf as [a[b[c[d[e]]]]];spliter.
assert (neq b a) by (conclude lemma_inequalitysymmetric).
assert (neq e b) by (forward_using lemma_betweennotequal).
assert (~ Meet a b C D).
let Tf:=fresh in assert (Tf:exists P, (BetS e b P /\\ Cong b P e b)) by (conclude lemma_extension);destruct Tf as [P];spliter.
assert (BetS P b e) by (conclude axiom_betweennesssymmetry).
assert (BetS b e c) by (conclude axiom_betweennesssymmetry).
assert (BetS P b c) by (conclude lemma_3_7b).
assert (BetS c b P) by (conclude axiom_betweennesssymmetry).
assert (~ Col a d P).
intro.
assert (Col a e d) by (conclude_def Col ).
assert (Col a d e) by (forward_using lemma_collinearorder).
assert (neq a d) by (forward_using lemma_betweennotequal).
assert (Col d P e) by (conclude lemma_collinear4).
assert (Col e P d) by (forward_using lemma_collinearorder).
assert (Col e b P) by (conclude_def Col ).
assert (Col e P b) by (forward_using lemma_collinearorder).
assert (neq e P) by (forward_using lemma_betweennotequal).
assert (Col P d b) by (conclude lemma_collinear4).
assert (Col d P b) by (forward_using lemma_collinearorder).
assert (Col d P a) by (forward_using lemma_collinearorder).
assert (~ eq d P).
assert (Col P b a) by (conclude lemma_collinear4).

*****
H33 : Col P b a
H32 : not (eq d P)
H31 : Col d P a
H30 : Col d P b
H29 : Col P d b
H28 : neq e P
H27 : Col e P b
H26 : Col e b P
H25 : Col e P d
H24 : Col d P e
H23 : neq a d
H22 : Col a d e
H21 : Col a e d
H20 : Col a d P
H19 : BetS c b P
H18 : BetS P b c
H17 : BetS b e c
H16 : BetS P b e
H15 : Cong b P e b
H14 : BetS e b P
P : Point
H13 : not (Meet a b C D)
H12 : neq e b
H11 : neq b a
H10 : BetS c e b
H9 : BetS a e d
H8 : not (Meet A B C D)
H7 : neq c d
H6 : Col C D d
H5 : Col C D c
H4 : neq a b
H3 : Col A B b
H2 : Col A B a
H1 : neq C D
H0 : neq A B
a,b,c,d,e : Point
H : Par A B C D
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
False
+++++
assert (Col P b c) by (conclude_def Col ).
-----
Lemma lemma_paralleldef2B : forall A B C D, Par A B C D -> TP A B C D.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists a b c d e, (neq A B /\\ neq C D /\\ Col A B a /\\ Col A B b /\\ neq a b /\\ Col C D c /\\ Col C D d /\\ neq c d /\\ ~ Meet A B C D /\\ BetS a e d /\\ BetS c e b)) by (conclude_def Par );destruct Tf as [a[b[c[d[e]]]]];spliter.
assert (neq b a) by (conclude lemma_inequalitysymmetric).
assert (neq e b) by (forward_using lemma_betweennotequal).
assert (~ Meet a b C D).
let Tf:=fresh in assert (Tf:exists P, (BetS e b P /\\ Cong b P e b)) by (conclude lemma_extension);destruct Tf as [P];spliter.
assert (BetS P b e) by (conclude axiom_betweennesssymmetry).
assert (BetS b e c) by (conclude axiom_betweennesssymmetry).
assert (BetS P b c) by (conclude lemma_3_7b).
assert (BetS c b P) by (conclude axiom_betweennesssymmetry).
assert (~ Col a d P).
intro.
assert (Col a e d) by (conclude_def Col ).
assert (Col a d e) by (forward_using lemma_collinearorder).
assert (neq a d) by (forward_using lemma_betweennotequal).
assert (Col d P e) by (conclude lemma_collinear4).
assert (Col e P d) by (forward_using lemma_collinearorder).
assert (Col e b P) by (conclude_def Col ).
assert (Col e P b) by (forward_using lemma_collinearorder).
assert (neq e P) by (forward_using lemma_betweennotequal).
assert (Col P d b) by (conclude lemma_collinear4).
assert (Col d P b) by (forward_using lemma_collinearorder).
assert (Col d P a) by (forward_using lemma_collinearorder).
assert (~ eq d P).
assert (Col P b a) by (conclude lemma_collinear4).
assert (Col P b c) by (conclude_def Col ).

*****
H34 : Col P b c
H33 : Col P b a
H32 : not (eq d P)
H31 : Col d P a
H30 : Col d P b
H29 : Col P d b
H28 : neq e P
H27 : Col e P b
H26 : Col e b P
H25 : Col e P d
H24 : Col d P e
H23 : neq a d
H22 : Col a d e
H21 : Col a e d
H20 : Col a d P
H19 : BetS c b P
H18 : BetS P b c
H17 : BetS b e c
H16 : BetS P b e
H15 : Cong b P e b
H14 : BetS e b P
P : Point
H13 : not (Meet a b C D)
H12 : neq e b
H11 : neq b a
H10 : BetS c e b
H9 : BetS a e d
H8 : not (Meet A B C D)
H7 : neq c d
H6 : Col C D d
H5 : Col C D c
H4 : neq a b
H3 : Col A B b
H2 : Col A B a
H1 : neq C D
H0 : neq A B
a,b,c,d,e : Point
H : Par A B C D
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
False
+++++
assert (neq b P) by (forward_using lemma_betweennotequal).
-----
Lemma lemma_paralleldef2B : forall A B C D, Par A B C D -> TP A B C D.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists a b c d e, (neq A B /\\ neq C D /\\ Col A B a /\\ Col A B b /\\ neq a b /\\ Col C D c /\\ Col C D d /\\ neq c d /\\ ~ Meet A B C D /\\ BetS a e d /\\ BetS c e b)) by (conclude_def Par );destruct Tf as [a[b[c[d[e]]]]];spliter.
assert (neq b a) by (conclude lemma_inequalitysymmetric).
assert (neq e b) by (forward_using lemma_betweennotequal).
assert (~ Meet a b C D).
let Tf:=fresh in assert (Tf:exists P, (BetS e b P /\\ Cong b P e b)) by (conclude lemma_extension);destruct Tf as [P];spliter.
assert (BetS P b e) by (conclude axiom_betweennesssymmetry).
assert (BetS b e c) by (conclude axiom_betweennesssymmetry).
assert (BetS P b c) by (conclude lemma_3_7b).
assert (BetS c b P) by (conclude axiom_betweennesssymmetry).
assert (~ Col a d P).
intro.
assert (Col a e d) by (conclude_def Col ).
assert (Col a d e) by (forward_using lemma_collinearorder).
assert (neq a d) by (forward_using lemma_betweennotequal).
assert (Col d P e) by (conclude lemma_collinear4).
assert (Col e P d) by (forward_using lemma_collinearorder).
assert (Col e b P) by (conclude_def Col ).
assert (Col e P b) by (forward_using lemma_collinearorder).
assert (neq e P) by (forward_using lemma_betweennotequal).
assert (Col P d b) by (conclude lemma_collinear4).
assert (Col d P b) by (forward_using lemma_collinearorder).
assert (Col d P a) by (forward_using lemma_collinearorder).
assert (~ eq d P).
assert (Col P b a) by (conclude lemma_collinear4).
assert (Col P b c) by (conclude_def Col ).
assert (neq b P) by (forward_using lemma_betweennotequal).

*****
H35 : neq b P
H34 : Col P b c
H33 : Col P b a
H32 : not (eq d P)
H31 : Col d P a
H30 : Col d P b
H29 : Col P d b
H28 : neq e P
H27 : Col e P b
H26 : Col e b P
H25 : Col e P d
H24 : Col d P e
H23 : neq a d
H22 : Col a d e
H21 : Col a e d
H20 : Col a d P
H19 : BetS c b P
H18 : BetS P b c
H17 : BetS b e c
H16 : BetS P b e
H15 : Cong b P e b
H14 : BetS e b P
P : Point
H13 : not (Meet a b C D)
H12 : neq e b
H11 : neq b a
H10 : BetS c e b
H9 : BetS a e d
H8 : not (Meet A B C D)
H7 : neq c d
H6 : Col C D d
H5 : Col C D c
H4 : neq a b
H3 : Col A B b
H2 : Col A B a
H1 : neq C D
H0 : neq A B
a,b,c,d,e : Point
H : Par A B C D
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
False
+++++
assert (neq P b) by (conclude lemma_inequalitysymmetric).
-----
Lemma lemma_paralleldef2B : forall A B C D, Par A B C D -> TP A B C D.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists a b c d e, (neq A B /\\ neq C D /\\ Col A B a /\\ Col A B b /\\ neq a b /\\ Col C D c /\\ Col C D d /\\ neq c d /\\ ~ Meet A B C D /\\ BetS a e d /\\ BetS c e b)) by (conclude_def Par );destruct Tf as [a[b[c[d[e]]]]];spliter.
assert (neq b a) by (conclude lemma_inequalitysymmetric).
assert (neq e b) by (forward_using lemma_betweennotequal).
assert (~ Meet a b C D).
let Tf:=fresh in assert (Tf:exists P, (BetS e b P /\\ Cong b P e b)) by (conclude lemma_extension);destruct Tf as [P];spliter.
assert (BetS P b e) by (conclude axiom_betweennesssymmetry).
assert (BetS b e c) by (conclude axiom_betweennesssymmetry).
assert (BetS P b c) by (conclude lemma_3_7b).
assert (BetS c b P) by (conclude axiom_betweennesssymmetry).
assert (~ Col a d P).
intro.
assert (Col a e d) by (conclude_def Col ).
assert (Col a d e) by (forward_using lemma_collinearorder).
assert (neq a d) by (forward_using lemma_betweennotequal).
assert (Col d P e) by (conclude lemma_collinear4).
assert (Col e P d) by (forward_using lemma_collinearorder).
assert (Col e b P) by (conclude_def Col ).
assert (Col e P b) by (forward_using lemma_collinearorder).
assert (neq e P) by (forward_using lemma_betweennotequal).
assert (Col P d b) by (conclude lemma_collinear4).
assert (Col d P b) by (forward_using lemma_collinearorder).
assert (Col d P a) by (forward_using lemma_collinearorder).
assert (~ eq d P).
assert (Col P b a) by (conclude lemma_collinear4).
assert (Col P b c) by (conclude_def Col ).
assert (neq b P) by (forward_using lemma_betweennotequal).
assert (neq P b) by (conclude lemma_inequalitysymmetric).

*****
H36 : neq P b
H35 : neq b P
H34 : Col P b c
H33 : Col P b a
H32 : not (eq d P)
H31 : Col d P a
H30 : Col d P b
H29 : Col P d b
H28 : neq e P
H27 : Col e P b
H26 : Col e b P
H25 : Col e P d
H24 : Col d P e
H23 : neq a d
H22 : Col a d e
H21 : Col a e d
H20 : Col a d P
H19 : BetS c b P
H18 : BetS P b c
H17 : BetS b e c
H16 : BetS P b e
H15 : Cong b P e b
H14 : BetS e b P
P : Point
H13 : not (Meet a b C D)
H12 : neq e b
H11 : neq b a
H10 : BetS c e b
H9 : BetS a e d
H8 : not (Meet A B C D)
H7 : neq c d
H6 : Col C D d
H5 : Col C D c
H4 : neq a b
H3 : Col A B b
H2 : Col A B a
H1 : neq C D
H0 : neq A B
a,b,c,d,e : Point
H : Par A B C D
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
False
+++++
assert (Col b a c) by (conclude lemma_collinear4).
-----
Lemma lemma_paralleldef2B : forall A B C D, Par A B C D -> TP A B C D.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists a b c d e, (neq A B /\\ neq C D /\\ Col A B a /\\ Col A B b /\\ neq a b /\\ Col C D c /\\ Col C D d /\\ neq c d /\\ ~ Meet A B C D /\\ BetS a e d /\\ BetS c e b)) by (conclude_def Par );destruct Tf as [a[b[c[d[e]]]]];spliter.
assert (neq b a) by (conclude lemma_inequalitysymmetric).
assert (neq e b) by (forward_using lemma_betweennotequal).
assert (~ Meet a b C D).
let Tf:=fresh in assert (Tf:exists P, (BetS e b P /\\ Cong b P e b)) by (conclude lemma_extension);destruct Tf as [P];spliter.
assert (BetS P b e) by (conclude axiom_betweennesssymmetry).
assert (BetS b e c) by (conclude axiom_betweennesssymmetry).
assert (BetS P b c) by (conclude lemma_3_7b).
assert (BetS c b P) by (conclude axiom_betweennesssymmetry).
assert (~ Col a d P).
intro.
assert (Col a e d) by (conclude_def Col ).
assert (Col a d e) by (forward_using lemma_collinearorder).
assert (neq a d) by (forward_using lemma_betweennotequal).
assert (Col d P e) by (conclude lemma_collinear4).
assert (Col e P d) by (forward_using lemma_collinearorder).
assert (Col e b P) by (conclude_def Col ).
assert (Col e P b) by (forward_using lemma_collinearorder).
assert (neq e P) by (forward_using lemma_betweennotequal).
assert (Col P d b) by (conclude lemma_collinear4).
assert (Col d P b) by (forward_using lemma_collinearorder).
assert (Col d P a) by (forward_using lemma_collinearorder).
assert (~ eq d P).
assert (Col P b a) by (conclude lemma_collinear4).
assert (Col P b c) by (conclude_def Col ).
assert (neq b P) by (forward_using lemma_betweennotequal).
assert (neq P b) by (conclude lemma_inequalitysymmetric).
assert (Col b a c) by (conclude lemma_collinear4).

*****
H37 : Col b a c
H36 : neq P b
H35 : neq b P
H34 : Col P b c
H33 : Col P b a
H32 : not (eq d P)
H31 : Col d P a
H30 : Col d P b
H29 : Col P d b
H28 : neq e P
H27 : Col e P b
H26 : Col e b P
H25 : Col e P d
H24 : Col d P e
H23 : neq a d
H22 : Col a d e
H21 : Col a e d
H20 : Col a d P
H19 : BetS c b P
H18 : BetS P b c
H17 : BetS b e c
H16 : BetS P b e
H15 : Cong b P e b
H14 : BetS e b P
P : Point
H13 : not (Meet a b C D)
H12 : neq e b
H11 : neq b a
H10 : BetS c e b
H9 : BetS a e d
H8 : not (Meet A B C D)
H7 : neq c d
H6 : Col C D d
H5 : Col C D c
H4 : neq a b
H3 : Col A B b
H2 : Col A B a
H1 : neq C D
H0 : neq A B
a,b,c,d,e : Point
H : Par A B C D
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
False
+++++
assert (Col B a b) by (conclude lemma_collinear4).
-----
Lemma lemma_paralleldef2B : forall A B C D, Par A B C D -> TP A B C D.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists a b c d e, (neq A B /\\ neq C D /\\ Col A B a /\\ Col A B b /\\ neq a b /\\ Col C D c /\\ Col C D d /\\ neq c d /\\ ~ Meet A B C D /\\ BetS a e d /\\ BetS c e b)) by (conclude_def Par );destruct Tf as [a[b[c[d[e]]]]];spliter.
assert (neq b a) by (conclude lemma_inequalitysymmetric).
assert (neq e b) by (forward_using lemma_betweennotequal).
assert (~ Meet a b C D).
let Tf:=fresh in assert (Tf:exists P, (BetS e b P /\\ Cong b P e b)) by (conclude lemma_extension);destruct Tf as [P];spliter.
assert (BetS P b e) by (conclude axiom_betweennesssymmetry).
assert (BetS b e c) by (conclude axiom_betweennesssymmetry).
assert (BetS P b c) by (conclude lemma_3_7b).
assert (BetS c b P) by (conclude axiom_betweennesssymmetry).
assert (~ Col a d P).
intro.
assert (Col a e d) by (conclude_def Col ).
assert (Col a d e) by (forward_using lemma_collinearorder).
assert (neq a d) by (forward_using lemma_betweennotequal).
assert (Col d P e) by (conclude lemma_collinear4).
assert (Col e P d) by (forward_using lemma_collinearorder).
assert (Col e b P) by (conclude_def Col ).
assert (Col e P b) by (forward_using lemma_collinearorder).
assert (neq e P) by (forward_using lemma_betweennotequal).
assert (Col P d b) by (conclude lemma_collinear4).
assert (Col d P b) by (forward_using lemma_collinearorder).
assert (Col d P a) by (forward_using lemma_collinearorder).
assert (~ eq d P).
assert (Col P b a) by (conclude lemma_collinear4).
assert (Col P b c) by (conclude_def Col ).
assert (neq b P) by (forward_using lemma_betweennotequal).
assert (neq P b) by (conclude lemma_inequalitysymmetric).
assert (Col b a c) by (conclude lemma_collinear4).
assert (Col B a b) by (conclude lemma_collinear4).

*****
H38 : Col B a b
H37 : Col b a c
H36 : neq P b
H35 : neq b P
H34 : Col P b c
H33 : Col P b a
H32 : not (eq d P)
H31 : Col d P a
H30 : Col d P b
H29 : Col P d b
H28 : neq e P
H27 : Col e P b
H26 : Col e b P
H25 : Col e P d
H24 : Col d P e
H23 : neq a d
H22 : Col a d e
H21 : Col a e d
H20 : Col a d P
H19 : BetS c b P
H18 : BetS P b c
H17 : BetS b e c
H16 : BetS P b e
H15 : Cong b P e b
H14 : BetS e b P
P : Point
H13 : not (Meet a b C D)
H12 : neq e b
H11 : neq b a
H10 : BetS c e b
H9 : BetS a e d
H8 : not (Meet A B C D)
H7 : neq c d
H6 : Col C D d
H5 : Col C D c
H4 : neq a b
H3 : Col A B b
H2 : Col A B a
H1 : neq C D
H0 : neq A B
a,b,c,d,e : Point
H : Par A B C D
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
False
+++++
assert (Col b a B) by (forward_using lemma_collinearorder).
-----
Lemma lemma_paralleldef2B : forall A B C D, Par A B C D -> TP A B C D.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists a b c d e, (neq A B /\\ neq C D /\\ Col A B a /\\ Col A B b /\\ neq a b /\\ Col C D c /\\ Col C D d /\\ neq c d /\\ ~ Meet A B C D /\\ BetS a e d /\\ BetS c e b)) by (conclude_def Par );destruct Tf as [a[b[c[d[e]]]]];spliter.
assert (neq b a) by (conclude lemma_inequalitysymmetric).
assert (neq e b) by (forward_using lemma_betweennotequal).
assert (~ Meet a b C D).
let Tf:=fresh in assert (Tf:exists P, (BetS e b P /\\ Cong b P e b)) by (conclude lemma_extension);destruct Tf as [P];spliter.
assert (BetS P b e) by (conclude axiom_betweennesssymmetry).
assert (BetS b e c) by (conclude axiom_betweennesssymmetry).
assert (BetS P b c) by (conclude lemma_3_7b).
assert (BetS c b P) by (conclude axiom_betweennesssymmetry).
assert (~ Col a d P).
intro.
assert (Col a e d) by (conclude_def Col ).
assert (Col a d e) by (forward_using lemma_collinearorder).
assert (neq a d) by (forward_using lemma_betweennotequal).
assert (Col d P e) by (conclude lemma_collinear4).
assert (Col e P d) by (forward_using lemma_collinearorder).
assert (Col e b P) by (conclude_def Col ).
assert (Col e P b) by (forward_using lemma_collinearorder).
assert (neq e P) by (forward_using lemma_betweennotequal).
assert (Col P d b) by (conclude lemma_collinear4).
assert (Col d P b) by (forward_using lemma_collinearorder).
assert (Col d P a) by (forward_using lemma_collinearorder).
assert (~ eq d P).
assert (Col P b a) by (conclude lemma_collinear4).
assert (Col P b c) by (conclude_def Col ).
assert (neq b P) by (forward_using lemma_betweennotequal).
assert (neq P b) by (conclude lemma_inequalitysymmetric).
assert (Col b a c) by (conclude lemma_collinear4).
assert (Col B a b) by (conclude lemma_collinear4).
assert (Col b a B) by (forward_using lemma_collinearorder).

*****
H39 : Col b a B
H38 : Col B a b
H37 : Col b a c
H36 : neq P b
H35 : neq b P
H34 : Col P b c
H33 : Col P b a
H32 : not (eq d P)
H31 : Col d P a
H30 : Col d P b
H29 : Col P d b
H28 : neq e P
H27 : Col e P b
H26 : Col e b P
H25 : Col e P d
H24 : Col d P e
H23 : neq a d
H22 : Col a d e
H21 : Col a e d
H20 : Col a d P
H19 : BetS c b P
H18 : BetS P b c
H17 : BetS b e c
H16 : BetS P b e
H15 : Cong b P e b
H14 : BetS e b P
P : Point
H13 : not (Meet a b C D)
H12 : neq e b
H11 : neq b a
H10 : BetS c e b
H9 : BetS a e d
H8 : not (Meet A B C D)
H7 : neq c d
H6 : Col C D d
H5 : Col C D c
H4 : neq a b
H3 : Col A B b
H2 : Col A B a
H1 : neq C D
H0 : neq A B
a,b,c,d,e : Point
H : Par A B C D
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
False
+++++
assert (Col a b c) by (forward_using lemma_collinearorder).
-----
Lemma lemma_paralleldef2B : forall A B C D, Par A B C D -> TP A B C D.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists a b c d e, (neq A B /\\ neq C D /\\ Col A B a /\\ Col A B b /\\ neq a b /\\ Col C D c /\\ Col C D d /\\ neq c d /\\ ~ Meet A B C D /\\ BetS a e d /\\ BetS c e b)) by (conclude_def Par );destruct Tf as [a[b[c[d[e]]]]];spliter.
assert (neq b a) by (conclude lemma_inequalitysymmetric).
assert (neq e b) by (forward_using lemma_betweennotequal).
assert (~ Meet a b C D).
let Tf:=fresh in assert (Tf:exists P, (BetS e b P /\\ Cong b P e b)) by (conclude lemma_extension);destruct Tf as [P];spliter.
assert (BetS P b e) by (conclude axiom_betweennesssymmetry).
assert (BetS b e c) by (conclude axiom_betweennesssymmetry).
assert (BetS P b c) by (conclude lemma_3_7b).
assert (BetS c b P) by (conclude axiom_betweennesssymmetry).
assert (~ Col a d P).
intro.
assert (Col a e d) by (conclude_def Col ).
assert (Col a d e) by (forward_using lemma_collinearorder).
assert (neq a d) by (forward_using lemma_betweennotequal).
assert (Col d P e) by (conclude lemma_collinear4).
assert (Col e P d) by (forward_using lemma_collinearorder).
assert (Col e b P) by (conclude_def Col ).
assert (Col e P b) by (forward_using lemma_collinearorder).
assert (neq e P) by (forward_using lemma_betweennotequal).
assert (Col P d b) by (conclude lemma_collinear4).
assert (Col d P b) by (forward_using lemma_collinearorder).
assert (Col d P a) by (forward_using lemma_collinearorder).
assert (~ eq d P).
assert (Col P b a) by (conclude lemma_collinear4).
assert (Col P b c) by (conclude_def Col ).
assert (neq b P) by (forward_using lemma_betweennotequal).
assert (neq P b) by (conclude lemma_inequalitysymmetric).
assert (Col b a c) by (conclude lemma_collinear4).
assert (Col B a b) by (conclude lemma_collinear4).
assert (Col b a B) by (forward_using lemma_collinearorder).
assert (Col a b c) by (forward_using lemma_collinearorder).

*****
H40 : Col a b c
H39 : Col b a B
H38 : Col B a b
H37 : Col b a c
H36 : neq P b
H35 : neq b P
H34 : Col P b c
H33 : Col P b a
H32 : not (eq d P)
H31 : Col d P a
H30 : Col d P b
H29 : Col P d b
H28 : neq e P
H27 : Col e P b
H26 : Col e b P
H25 : Col e P d
H24 : Col d P e
H23 : neq a d
H22 : Col a d e
H21 : Col a e d
H20 : Col a d P
H19 : BetS c b P
H18 : BetS P b c
H17 : BetS b e c
H16 : BetS P b e
H15 : Cong b P e b
H14 : BetS e b P
P : Point
H13 : not (Meet a b C D)
H12 : neq e b
H11 : neq b a
H10 : BetS c e b
H9 : BetS a e d
H8 : not (Meet A B C D)
H7 : neq c d
H6 : Col C D d
H5 : Col C D c
H4 : neq a b
H3 : Col A B b
H2 : Col A B a
H1 : neq C D
H0 : neq A B
a,b,c,d,e : Point
H : Par A B C D
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
False
+++++
assert (eq c c) by (conclude cn_equalityreflexive).
-----
Lemma lemma_paralleldef2B : forall A B C D, Par A B C D -> TP A B C D.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists a b c d e, (neq A B /\\ neq C D /\\ Col A B a /\\ Col A B b /\\ neq a b /\\ Col C D c /\\ Col C D d /\\ neq c d /\\ ~ Meet A B C D /\\ BetS a e d /\\ BetS c e b)) by (conclude_def Par );destruct Tf as [a[b[c[d[e]]]]];spliter.
assert (neq b a) by (conclude lemma_inequalitysymmetric).
assert (neq e b) by (forward_using lemma_betweennotequal).
assert (~ Meet a b C D).
let Tf:=fresh in assert (Tf:exists P, (BetS e b P /\\ Cong b P e b)) by (conclude lemma_extension);destruct Tf as [P];spliter.
assert (BetS P b e) by (conclude axiom_betweennesssymmetry).
assert (BetS b e c) by (conclude axiom_betweennesssymmetry).
assert (BetS P b c) by (conclude lemma_3_7b).
assert (BetS c b P) by (conclude axiom_betweennesssymmetry).
assert (~ Col a d P).
intro.
assert (Col a e d) by (conclude_def Col ).
assert (Col a d e) by (forward_using lemma_collinearorder).
assert (neq a d) by (forward_using lemma_betweennotequal).
assert (Col d P e) by (conclude lemma_collinear4).
assert (Col e P d) by (forward_using lemma_collinearorder).
assert (Col e b P) by (conclude_def Col ).
assert (Col e P b) by (forward_using lemma_collinearorder).
assert (neq e P) by (forward_using lemma_betweennotequal).
assert (Col P d b) by (conclude lemma_collinear4).
assert (Col d P b) by (forward_using lemma_collinearorder).
assert (Col d P a) by (forward_using lemma_collinearorder).
assert (~ eq d P).
assert (Col P b a) by (conclude lemma_collinear4).
assert (Col P b c) by (conclude_def Col ).
assert (neq b P) by (forward_using lemma_betweennotequal).
assert (neq P b) by (conclude lemma_inequalitysymmetric).
assert (Col b a c) by (conclude lemma_collinear4).
assert (Col B a b) by (conclude lemma_collinear4).
assert (Col b a B) by (forward_using lemma_collinearorder).
assert (Col a b c) by (forward_using lemma_collinearorder).
assert (eq c c) by (conclude cn_equalityreflexive).

*****
H41 : eq c c
H40 : Col a b c
H39 : Col b a B
H38 : Col B a b
H37 : Col b a c
H36 : neq P b
H35 : neq b P
H34 : Col P b c
H33 : Col P b a
H32 : not (eq d P)
H31 : Col d P a
H30 : Col d P b
H29 : Col P d b
H28 : neq e P
H27 : Col e P b
H26 : Col e b P
H25 : Col e P d
H24 : Col d P e
H23 : neq a d
H22 : Col a d e
H21 : Col a e d
H20 : Col a d P
H19 : BetS c b P
H18 : BetS P b c
H17 : BetS b e c
H16 : BetS P b e
H15 : Cong b P e b
H14 : BetS e b P
P : Point
H13 : not (Meet a b C D)
H12 : neq e b
H11 : neq b a
H10 : BetS c e b
H9 : BetS a e d
H8 : not (Meet A B C D)
H7 : neq c d
H6 : Col C D d
H5 : Col C D c
H4 : neq a b
H3 : Col A B b
H2 : Col A B a
H1 : neq C D
H0 : neq A B
a,b,c,d,e : Point
H : Par A B C D
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
False
+++++
assert (Meet a b C D) by (conclude_def Meet ).
-----
Lemma lemma_paralleldef2B : forall A B C D, Par A B C D -> TP A B C D.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists a b c d e, (neq A B /\\ neq C D /\\ Col A B a /\\ Col A B b /\\ neq a b /\\ Col C D c /\\ Col C D d /\\ neq c d /\\ ~ Meet A B C D /\\ BetS a e d /\\ BetS c e b)) by (conclude_def Par );destruct Tf as [a[b[c[d[e]]]]];spliter.
assert (neq b a) by (conclude lemma_inequalitysymmetric).
assert (neq e b) by (forward_using lemma_betweennotequal).
assert (~ Meet a b C D).
let Tf:=fresh in assert (Tf:exists P, (BetS e b P /\\ Cong b P e b)) by (conclude lemma_extension);destruct Tf as [P];spliter.
assert (BetS P b e) by (conclude axiom_betweennesssymmetry).
assert (BetS b e c) by (conclude axiom_betweennesssymmetry).
assert (BetS P b c) by (conclude lemma_3_7b).
assert (BetS c b P) by (conclude axiom_betweennesssymmetry).
assert (~ Col a d P).
intro.
assert (Col a e d) by (conclude_def Col ).
assert (Col a d e) by (forward_using lemma_collinearorder).
assert (neq a d) by (forward_using lemma_betweennotequal).
assert (Col d P e) by (conclude lemma_collinear4).
assert (Col e P d) by (forward_using lemma_collinearorder).
assert (Col e b P) by (conclude_def Col ).
assert (Col e P b) by (forward_using lemma_collinearorder).
assert (neq e P) by (forward_using lemma_betweennotequal).
assert (Col P d b) by (conclude lemma_collinear4).
assert (Col d P b) by (forward_using lemma_collinearorder).
assert (Col d P a) by (forward_using lemma_collinearorder).
assert (~ eq d P).
assert (Col P b a) by (conclude lemma_collinear4).
assert (Col P b c) by (conclude_def Col ).
assert (neq b P) by (forward_using lemma_betweennotequal).
assert (neq P b) by (conclude lemma_inequalitysymmetric).
assert (Col b a c) by (conclude lemma_collinear4).
assert (Col B a b) by (conclude lemma_collinear4).
assert (Col b a B) by (forward_using lemma_collinearorder).
assert (Col a b c) by (forward_using lemma_collinearorder).
assert (eq c c) by (conclude cn_equalityreflexive).
assert (Meet a b C D) by (conclude_def Meet ).

*****
H42 : Meet a b C D
H41 : eq c c
H40 : Col a b c
H39 : Col b a B
H38 : Col B a b
H37 : Col b a c
H36 : neq P b
H35 : neq b P
H34 : Col P b c
H33 : Col P b a
H32 : not (eq d P)
H31 : Col d P a
H30 : Col d P b
H29 : Col P d b
H28 : neq e P
H27 : Col e P b
H26 : Col e b P
H25 : Col e P d
H24 : Col d P e
H23 : neq a d
H22 : Col a d e
H21 : Col a e d
H20 : Col a d P
H19 : BetS c b P
H18 : BetS P b c
H17 : BetS b e c
H16 : BetS P b e
H15 : Cong b P e b
H14 : BetS e b P
P : Point
H13 : not (Meet a b C D)
H12 : neq e b
H11 : neq b a
H10 : BetS c e b
H9 : BetS a e d
H8 : not (Meet A B C D)
H7 : neq c d
H6 : Col C D d
H5 : Col C D c
H4 : neq a b
H3 : Col A B b
H2 : Col A B a
H1 : neq C D
H0 : neq A B
a,b,c,d,e : Point
H : Par A B C D
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
False
+++++
contradict.
-----
Lemma lemma_paralleldef2B : forall A B C D, Par A B C D -> TP A B C D.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists a b c d e, (neq A B /\\ neq C D /\\ Col A B a /\\ Col A B b /\\ neq a b /\\ Col C D c /\\ Col C D d /\\ neq c d /\\ ~ Meet A B C D /\\ BetS a e d /\\ BetS c e b)) by (conclude_def Par );destruct Tf as [a[b[c[d[e]]]]];spliter.
assert (neq b a) by (conclude lemma_inequalitysymmetric).
assert (neq e b) by (forward_using lemma_betweennotequal).
assert (~ Meet a b C D).
let Tf:=fresh in assert (Tf:exists P, (BetS e b P /\\ Cong b P e b)) by (conclude lemma_extension);destruct Tf as [P];spliter.
assert (BetS P b e) by (conclude axiom_betweennesssymmetry).
assert (BetS b e c) by (conclude axiom_betweennesssymmetry).
assert (BetS P b c) by (conclude lemma_3_7b).
assert (BetS c b P) by (conclude axiom_betweennesssymmetry).
assert (~ Col a d P).

*****
H20 : not (Col a d P)
H19 : BetS c b P
H18 : BetS P b c
H17 : BetS b e c
H16 : BetS P b e
H15 : Cong b P e b
H14 : BetS e b P
P : Point
H13 : not (Meet a b C D)
H12 : neq e b
H11 : neq b a
H10 : BetS c e b
H9 : BetS a e d
H8 : not (Meet A B C D)
H7 : neq c d
H6 : Col C D d
H5 : Col C D c
H4 : neq a b
H3 : Col A B b
H2 : Col A B a
H1 : neq C D
H0 : neq A B
a,b,c,d,e : Point
H : Par A B C D
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
TP A B C D
+++++
let Tf:=fresh in assert (Tf:exists M, (BetS P M d /\ BetS a b M)) by (conclude postulate_Pasch_outer);destruct Tf as [M];spliter.
-----
Lemma lemma_paralleldef2B : forall A B C D, Par A B C D -> TP A B C D.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists a b c d e, (neq A B /\\ neq C D /\\ Col A B a /\\ Col A B b /\\ neq a b /\\ Col C D c /\\ Col C D d /\\ neq c d /\\ ~ Meet A B C D /\\ BetS a e d /\\ BetS c e b)) by (conclude_def Par );destruct Tf as [a[b[c[d[e]]]]];spliter.
assert (neq b a) by (conclude lemma_inequalitysymmetric).
assert (neq e b) by (forward_using lemma_betweennotequal).
assert (~ Meet a b C D).
let Tf:=fresh in assert (Tf:exists P, (BetS e b P /\\ Cong b P e b)) by (conclude lemma_extension);destruct Tf as [P];spliter.
assert (BetS P b e) by (conclude axiom_betweennesssymmetry).
assert (BetS b e c) by (conclude axiom_betweennesssymmetry).
assert (BetS P b c) by (conclude lemma_3_7b).
assert (BetS c b P) by (conclude axiom_betweennesssymmetry).
assert (~ Col a d P).
let Tf:=fresh in assert (Tf:exists M, (BetS P M d /\\ BetS a b M)) by (conclude postulate_Pasch_outer);destruct Tf as [M];spliter.

*****
H22 : BetS a b M
H21 : BetS P M d
M : Point
H20 : not (Col a d P)
H19 : BetS c b P
H18 : BetS P b c
H17 : BetS b e c
H16 : BetS P b e
H15 : Cong b P e b
H14 : BetS e b P
P : Point
H13 : not (Meet a b C D)
H12 : neq e b
H11 : neq b a
H10 : BetS c e b
H9 : BetS a e d
H8 : not (Meet A B C D)
H7 : neq c d
H6 : Col C D d
H5 : Col C D c
H4 : neq a b
H3 : Col A B b
H2 : Col A B a
H1 : neq C D
H0 : neq A B
a,b,c,d,e : Point
H : Par A B C D
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
TP A B C D
+++++
assert (BetS M b a) by (conclude axiom_betweennesssymmetry).
-----
Lemma lemma_paralleldef2B : forall A B C D, Par A B C D -> TP A B C D.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists a b c d e, (neq A B /\\ neq C D /\\ Col A B a /\\ Col A B b /\\ neq a b /\\ Col C D c /\\ Col C D d /\\ neq c d /\\ ~ Meet A B C D /\\ BetS a e d /\\ BetS c e b)) by (conclude_def Par );destruct Tf as [a[b[c[d[e]]]]];spliter.
assert (neq b a) by (conclude lemma_inequalitysymmetric).
assert (neq e b) by (forward_using lemma_betweennotequal).
assert (~ Meet a b C D).
let Tf:=fresh in assert (Tf:exists P, (BetS e b P /\\ Cong b P e b)) by (conclude lemma_extension);destruct Tf as [P];spliter.
assert (BetS P b e) by (conclude axiom_betweennesssymmetry).
assert (BetS b e c) by (conclude axiom_betweennesssymmetry).
assert (BetS P b c) by (conclude lemma_3_7b).
assert (BetS c b P) by (conclude axiom_betweennesssymmetry).
assert (~ Col a d P).
let Tf:=fresh in assert (Tf:exists M, (BetS P M d /\\ BetS a b M)) by (conclude postulate_Pasch_outer);destruct Tf as [M];spliter.
assert (BetS M b a) by (conclude axiom_betweennesssymmetry).

*****
H23 : BetS M b a
H22 : BetS a b M
H21 : BetS P M d
M : Point
H20 : not (Col a d P)
H19 : BetS c b P
H18 : BetS P b c
H17 : BetS b e c
H16 : BetS P b e
H15 : Cong b P e b
H14 : BetS e b P
P : Point
H13 : not (Meet a b C D)
H12 : neq e b
H11 : neq b a
H10 : BetS c e b
H9 : BetS a e d
H8 : not (Meet A B C D)
H7 : neq c d
H6 : Col C D d
H5 : Col C D c
H4 : neq a b
H3 : Col A B b
H2 : Col A B a
H1 : neq C D
H0 : neq A B
a,b,c,d,e : Point
H : Par A B C D
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
TP A B C D
+++++
assert (BetS P b c) by (conclude axiom_betweennesssymmetry).
-----
Lemma lemma_paralleldef2B : forall A B C D, Par A B C D -> TP A B C D.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists a b c d e, (neq A B /\\ neq C D /\\ Col A B a /\\ Col A B b /\\ neq a b /\\ Col C D c /\\ Col C D d /\\ neq c d /\\ ~ Meet A B C D /\\ BetS a e d /\\ BetS c e b)) by (conclude_def Par );destruct Tf as [a[b[c[d[e]]]]];spliter.
assert (neq b a) by (conclude lemma_inequalitysymmetric).
assert (neq e b) by (forward_using lemma_betweennotequal).
assert (~ Meet a b C D).
let Tf:=fresh in assert (Tf:exists P, (BetS e b P /\\ Cong b P e b)) by (conclude lemma_extension);destruct Tf as [P];spliter.
assert (BetS P b e) by (conclude axiom_betweennesssymmetry).
assert (BetS b e c) by (conclude axiom_betweennesssymmetry).
assert (BetS P b c) by (conclude lemma_3_7b).
assert (BetS c b P) by (conclude axiom_betweennesssymmetry).
assert (~ Col a d P).
let Tf:=fresh in assert (Tf:exists M, (BetS P M d /\\ BetS a b M)) by (conclude postulate_Pasch_outer);destruct Tf as [M];spliter.
assert (BetS M b a) by (conclude axiom_betweennesssymmetry).
assert (BetS P b c) by (conclude axiom_betweennesssymmetry).

*****
H24 : BetS P b c
H23 : BetS M b a
H22 : BetS a b M
H21 : BetS P M d
M : Point
H20 : not (Col a d P)
H19 : BetS c b P
H18 : BetS P b c
H17 : BetS b e c
H16 : BetS P b e
H15 : Cong b P e b
H14 : BetS e b P
P : Point
H13 : not (Meet a b C D)
H12 : neq e b
H11 : neq b a
H10 : BetS c e b
H9 : BetS a e d
H8 : not (Meet A B C D)
H7 : neq c d
H6 : Col C D d
H5 : Col C D c
H4 : neq a b
H3 : Col A B b
H2 : Col A B a
H1 : neq C D
H0 : neq A B
a,b,c,d,e : Point
H : Par A B C D
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
TP A B C D
+++++
assert (Col a b M) by (conclude_def Col ).
-----
Lemma lemma_paralleldef2B : forall A B C D, Par A B C D -> TP A B C D.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists a b c d e, (neq A B /\\ neq C D /\\ Col A B a /\\ Col A B b /\\ neq a b /\\ Col C D c /\\ Col C D d /\\ neq c d /\\ ~ Meet A B C D /\\ BetS a e d /\\ BetS c e b)) by (conclude_def Par );destruct Tf as [a[b[c[d[e]]]]];spliter.
assert (neq b a) by (conclude lemma_inequalitysymmetric).
assert (neq e b) by (forward_using lemma_betweennotequal).
assert (~ Meet a b C D).
let Tf:=fresh in assert (Tf:exists P, (BetS e b P /\\ Cong b P e b)) by (conclude lemma_extension);destruct Tf as [P];spliter.
assert (BetS P b e) by (conclude axiom_betweennesssymmetry).
assert (BetS b e c) by (conclude axiom_betweennesssymmetry).
assert (BetS P b c) by (conclude lemma_3_7b).
assert (BetS c b P) by (conclude axiom_betweennesssymmetry).
assert (~ Col a d P).
let Tf:=fresh in assert (Tf:exists M, (BetS P M d /\\ BetS a b M)) by (conclude postulate_Pasch_outer);destruct Tf as [M];spliter.
assert (BetS M b a) by (conclude axiom_betweennesssymmetry).
assert (BetS P b c) by (conclude axiom_betweennesssymmetry).
assert (Col a b M) by (conclude_def Col ).

*****
H25 : Col a b M
H24 : BetS P b c
H23 : BetS M b a
H22 : BetS a b M
H21 : BetS P M d
M : Point
H20 : not (Col a d P)
H19 : BetS c b P
H18 : BetS P b c
H17 : BetS b e c
H16 : BetS P b e
H15 : Cong b P e b
H14 : BetS e b P
P : Point
H13 : not (Meet a b C D)
H12 : neq e b
H11 : neq b a
H10 : BetS c e b
H9 : BetS a e d
H8 : not (Meet A B C D)
H7 : neq c d
H6 : Col C D d
H5 : Col C D c
H4 : neq a b
H3 : Col A B b
H2 : Col A B a
H1 : neq C D
H0 : neq A B
a,b,c,d,e : Point
H : Par A B C D
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
TP A B C D
+++++
assert (Col B a b) by (conclude lemma_collinear4).
-----
Lemma lemma_paralleldef2B : forall A B C D, Par A B C D -> TP A B C D.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists a b c d e, (neq A B /\\ neq C D /\\ Col A B a /\\ Col A B b /\\ neq a b /\\ Col C D c /\\ Col C D d /\\ neq c d /\\ ~ Meet A B C D /\\ BetS a e d /\\ BetS c e b)) by (conclude_def Par );destruct Tf as [a[b[c[d[e]]]]];spliter.
assert (neq b a) by (conclude lemma_inequalitysymmetric).
assert (neq e b) by (forward_using lemma_betweennotequal).
assert (~ Meet a b C D).
let Tf:=fresh in assert (Tf:exists P, (BetS e b P /\\ Cong b P e b)) by (conclude lemma_extension);destruct Tf as [P];spliter.
assert (BetS P b e) by (conclude axiom_betweennesssymmetry).
assert (BetS b e c) by (conclude axiom_betweennesssymmetry).
assert (BetS P b c) by (conclude lemma_3_7b).
assert (BetS c b P) by (conclude axiom_betweennesssymmetry).
assert (~ Col a d P).
let Tf:=fresh in assert (Tf:exists M, (BetS P M d /\\ BetS a b M)) by (conclude postulate_Pasch_outer);destruct Tf as [M];spliter.
assert (BetS M b a) by (conclude axiom_betweennesssymmetry).
assert (BetS P b c) by (conclude axiom_betweennesssymmetry).
assert (Col a b M) by (conclude_def Col ).
assert (Col B a b) by (conclude lemma_collinear4).

*****
H26 : Col B a b
H25 : Col a b M
H24 : BetS P b c
H23 : BetS M b a
H22 : BetS a b M
H21 : BetS P M d
M : Point
H20 : not (Col a d P)
H19 : BetS c b P
H18 : BetS P b c
H17 : BetS b e c
H16 : BetS P b e
H15 : Cong b P e b
H14 : BetS e b P
P : Point
H13 : not (Meet a b C D)
H12 : neq e b
H11 : neq b a
H10 : BetS c e b
H9 : BetS a e d
H8 : not (Meet A B C D)
H7 : neq c d
H6 : Col C D d
H5 : Col C D c
H4 : neq a b
H3 : Col A B b
H2 : Col A B a
H1 : neq C D
H0 : neq A B
a,b,c,d,e : Point
H : Par A B C D
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
TP A B C D
+++++
assert (Col b a B) by (forward_using lemma_collinearorder).
-----
Lemma lemma_paralleldef2B : forall A B C D, Par A B C D -> TP A B C D.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists a b c d e, (neq A B /\\ neq C D /\\ Col A B a /\\ Col A B b /\\ neq a b /\\ Col C D c /\\ Col C D d /\\ neq c d /\\ ~ Meet A B C D /\\ BetS a e d /\\ BetS c e b)) by (conclude_def Par );destruct Tf as [a[b[c[d[e]]]]];spliter.
assert (neq b a) by (conclude lemma_inequalitysymmetric).
assert (neq e b) by (forward_using lemma_betweennotequal).
assert (~ Meet a b C D).
let Tf:=fresh in assert (Tf:exists P, (BetS e b P /\\ Cong b P e b)) by (conclude lemma_extension);destruct Tf as [P];spliter.
assert (BetS P b e) by (conclude axiom_betweennesssymmetry).
assert (BetS b e c) by (conclude axiom_betweennesssymmetry).
assert (BetS P b c) by (conclude lemma_3_7b).
assert (BetS c b P) by (conclude axiom_betweennesssymmetry).
assert (~ Col a d P).
let Tf:=fresh in assert (Tf:exists M, (BetS P M d /\\ BetS a b M)) by (conclude postulate_Pasch_outer);destruct Tf as [M];spliter.
assert (BetS M b a) by (conclude axiom_betweennesssymmetry).
assert (BetS P b c) by (conclude axiom_betweennesssymmetry).
assert (Col a b M) by (conclude_def Col ).
assert (Col B a b) by (conclude lemma_collinear4).
assert (Col b a B) by (forward_using lemma_collinearorder).

*****
H27 : Col b a B
H26 : Col B a b
H25 : Col a b M
H24 : BetS P b c
H23 : BetS M b a
H22 : BetS a b M
H21 : BetS P M d
M : Point
H20 : not (Col a d P)
H19 : BetS c b P
H18 : BetS P b c
H17 : BetS b e c
H16 : BetS P b e
H15 : Cong b P e b
H14 : BetS e b P
P : Point
H13 : not (Meet a b C D)
H12 : neq e b
H11 : neq b a
H10 : BetS c e b
H9 : BetS a e d
H8 : not (Meet A B C D)
H7 : neq c d
H6 : Col C D d
H5 : Col C D c
H4 : neq a b
H3 : Col A B b
H2 : Col A B a
H1 : neq C D
H0 : neq A B
a,b,c,d,e : Point
H : Par A B C D
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
TP A B C D
+++++
assert (Col b a M) by (forward_using lemma_collinearorder).
-----
Lemma lemma_paralleldef2B : forall A B C D, Par A B C D -> TP A B C D.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists a b c d e, (neq A B /\\ neq C D /\\ Col A B a /\\ Col A B b /\\ neq a b /\\ Col C D c /\\ Col C D d /\\ neq c d /\\ ~ Meet A B C D /\\ BetS a e d /\\ BetS c e b)) by (conclude_def Par );destruct Tf as [a[b[c[d[e]]]]];spliter.
assert (neq b a) by (conclude lemma_inequalitysymmetric).
assert (neq e b) by (forward_using lemma_betweennotequal).
assert (~ Meet a b C D).
let Tf:=fresh in assert (Tf:exists P, (BetS e b P /\\ Cong b P e b)) by (conclude lemma_extension);destruct Tf as [P];spliter.
assert (BetS P b e) by (conclude axiom_betweennesssymmetry).
assert (BetS b e c) by (conclude axiom_betweennesssymmetry).
assert (BetS P b c) by (conclude lemma_3_7b).
assert (BetS c b P) by (conclude axiom_betweennesssymmetry).
assert (~ Col a d P).
let Tf:=fresh in assert (Tf:exists M, (BetS P M d /\\ BetS a b M)) by (conclude postulate_Pasch_outer);destruct Tf as [M];spliter.
assert (BetS M b a) by (conclude axiom_betweennesssymmetry).
assert (BetS P b c) by (conclude axiom_betweennesssymmetry).
assert (Col a b M) by (conclude_def Col ).
assert (Col B a b) by (conclude lemma_collinear4).
assert (Col b a B) by (forward_using lemma_collinearorder).
assert (Col b a M) by (forward_using lemma_collinearorder).

*****
H28 : Col b a M
H27 : Col b a B
H26 : Col B a b
H25 : Col a b M
H24 : BetS P b c
H23 : BetS M b a
H22 : BetS a b M
H21 : BetS P M d
M : Point
H20 : not (Col a d P)
H19 : BetS c b P
H18 : BetS P b c
H17 : BetS b e c
H16 : BetS P b e
H15 : Cong b P e b
H14 : BetS e b P
P : Point
H13 : not (Meet a b C D)
H12 : neq e b
H11 : neq b a
H10 : BetS c e b
H9 : BetS a e d
H8 : not (Meet A B C D)
H7 : neq c d
H6 : Col C D d
H5 : Col C D c
H4 : neq a b
H3 : Col A B b
H2 : Col A B a
H1 : neq C D
H0 : neq A B
a,b,c,d,e : Point
H : Par A B C D
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
TP A B C D
+++++
assert (neq b a) by (conclude lemma_inequalitysymmetric).
-----
Lemma lemma_paralleldef2B : forall A B C D, Par A B C D -> TP A B C D.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists a b c d e, (neq A B /\\ neq C D /\\ Col A B a /\\ Col A B b /\\ neq a b /\\ Col C D c /\\ Col C D d /\\ neq c d /\\ ~ Meet A B C D /\\ BetS a e d /\\ BetS c e b)) by (conclude_def Par );destruct Tf as [a[b[c[d[e]]]]];spliter.
assert (neq b a) by (conclude lemma_inequalitysymmetric).
assert (neq e b) by (forward_using lemma_betweennotequal).
assert (~ Meet a b C D).
let Tf:=fresh in assert (Tf:exists P, (BetS e b P /\\ Cong b P e b)) by (conclude lemma_extension);destruct Tf as [P];spliter.
assert (BetS P b e) by (conclude axiom_betweennesssymmetry).
assert (BetS b e c) by (conclude axiom_betweennesssymmetry).
assert (BetS P b c) by (conclude lemma_3_7b).
assert (BetS c b P) by (conclude axiom_betweennesssymmetry).
assert (~ Col a d P).
let Tf:=fresh in assert (Tf:exists M, (BetS P M d /\\ BetS a b M)) by (conclude postulate_Pasch_outer);destruct Tf as [M];spliter.
assert (BetS M b a) by (conclude axiom_betweennesssymmetry).
assert (BetS P b c) by (conclude axiom_betweennesssymmetry).
assert (Col a b M) by (conclude_def Col ).
assert (Col B a b) by (conclude lemma_collinear4).
assert (Col b a B) by (forward_using lemma_collinearorder).
assert (Col b a M) by (forward_using lemma_collinearorder).
assert (neq b a) by (conclude lemma_inequalitysymmetric).

*****
H29 : neq b a
H28 : Col b a M
H27 : Col b a B
H26 : Col B a b
H25 : Col a b M
H24 : BetS P b c
H23 : BetS M b a
H22 : BetS a b M
H21 : BetS P M d
M : Point
H20 : not (Col a d P)
H19 : BetS c b P
H18 : BetS P b c
H17 : BetS b e c
H16 : BetS P b e
H15 : Cong b P e b
H14 : BetS e b P
P : Point
H13 : not (Meet a b C D)
H12 : neq e b
H11 : neq b a
H10 : BetS c e b
H9 : BetS a e d
H8 : not (Meet A B C D)
H7 : neq c d
H6 : Col C D d
H5 : Col C D c
H4 : neq a b
H3 : Col A B b
H2 : Col A B a
H1 : neq C D
H0 : neq A B
a,b,c,d,e : Point
H : Par A B C D
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
TP A B C D
+++++
assert (Col a B M) by (conclude lemma_collinear4).
-----
Lemma lemma_paralleldef2B : forall A B C D, Par A B C D -> TP A B C D.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists a b c d e, (neq A B /\\ neq C D /\\ Col A B a /\\ Col A B b /\\ neq a b /\\ Col C D c /\\ Col C D d /\\ neq c d /\\ ~ Meet A B C D /\\ BetS a e d /\\ BetS c e b)) by (conclude_def Par );destruct Tf as [a[b[c[d[e]]]]];spliter.
assert (neq b a) by (conclude lemma_inequalitysymmetric).
assert (neq e b) by (forward_using lemma_betweennotequal).
assert (~ Meet a b C D).
let Tf:=fresh in assert (Tf:exists P, (BetS e b P /\\ Cong b P e b)) by (conclude lemma_extension);destruct Tf as [P];spliter.
assert (BetS P b e) by (conclude axiom_betweennesssymmetry).
assert (BetS b e c) by (conclude axiom_betweennesssymmetry).
assert (BetS P b c) by (conclude lemma_3_7b).
assert (BetS c b P) by (conclude axiom_betweennesssymmetry).
assert (~ Col a d P).
let Tf:=fresh in assert (Tf:exists M, (BetS P M d /\\ BetS a b M)) by (conclude postulate_Pasch_outer);destruct Tf as [M];spliter.
assert (BetS M b a) by (conclude axiom_betweennesssymmetry).
assert (BetS P b c) by (conclude axiom_betweennesssymmetry).
assert (Col a b M) by (conclude_def Col ).
assert (Col B a b) by (conclude lemma_collinear4).
assert (Col b a B) by (forward_using lemma_collinearorder).
assert (Col b a M) by (forward_using lemma_collinearorder).
assert (neq b a) by (conclude lemma_inequalitysymmetric).
assert (Col a B M) by (conclude lemma_collinear4).

*****
H30 : Col a B M
H29 : neq b a
H28 : Col b a M
H27 : Col b a B
H26 : Col B a b
H25 : Col a b M
H24 : BetS P b c
H23 : BetS M b a
H22 : BetS a b M
H21 : BetS P M d
M : Point
H20 : not (Col a d P)
H19 : BetS c b P
H18 : BetS P b c
H17 : BetS b e c
H16 : BetS P b e
H15 : Cong b P e b
H14 : BetS e b P
P : Point
H13 : not (Meet a b C D)
H12 : neq e b
H11 : neq b a
H10 : BetS c e b
H9 : BetS a e d
H8 : not (Meet A B C D)
H7 : neq c d
H6 : Col C D d
H5 : Col C D c
H4 : neq a b
H3 : Col A B b
H2 : Col A B a
H1 : neq C D
H0 : neq A B
a,b,c,d,e : Point
H : Par A B C D
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
TP A B C D
+++++
assert (Col a B A) by (forward_using lemma_collinearorder).
-----
Lemma lemma_paralleldef2B : forall A B C D, Par A B C D -> TP A B C D.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists a b c d e, (neq A B /\\ neq C D /\\ Col A B a /\\ Col A B b /\\ neq a b /\\ Col C D c /\\ Col C D d /\\ neq c d /\\ ~ Meet A B C D /\\ BetS a e d /\\ BetS c e b)) by (conclude_def Par );destruct Tf as [a[b[c[d[e]]]]];spliter.
assert (neq b a) by (conclude lemma_inequalitysymmetric).
assert (neq e b) by (forward_using lemma_betweennotequal).
assert (~ Meet a b C D).
let Tf:=fresh in assert (Tf:exists P, (BetS e b P /\\ Cong b P e b)) by (conclude lemma_extension);destruct Tf as [P];spliter.
assert (BetS P b e) by (conclude axiom_betweennesssymmetry).
assert (BetS b e c) by (conclude axiom_betweennesssymmetry).
assert (BetS P b c) by (conclude lemma_3_7b).
assert (BetS c b P) by (conclude axiom_betweennesssymmetry).
assert (~ Col a d P).
let Tf:=fresh in assert (Tf:exists M, (BetS P M d /\\ BetS a b M)) by (conclude postulate_Pasch_outer);destruct Tf as [M];spliter.
assert (BetS M b a) by (conclude axiom_betweennesssymmetry).
assert (BetS P b c) by (conclude axiom_betweennesssymmetry).
assert (Col a b M) by (conclude_def Col ).
assert (Col B a b) by (conclude lemma_collinear4).
assert (Col b a B) by (forward_using lemma_collinearorder).
assert (Col b a M) by (forward_using lemma_collinearorder).
assert (neq b a) by (conclude lemma_inequalitysymmetric).
assert (Col a B M) by (conclude lemma_collinear4).
assert (Col a B A) by (forward_using lemma_collinearorder).

*****
H31 : Col a B A
H30 : Col a B M
H29 : neq b a
H28 : Col b a M
H27 : Col b a B
H26 : Col B a b
H25 : Col a b M
H24 : BetS P b c
H23 : BetS M b a
H22 : BetS a b M
H21 : BetS P M d
M : Point
H20 : not (Col a d P)
H19 : BetS c b P
H18 : BetS P b c
H17 : BetS b e c
H16 : BetS P b e
H15 : Cong b P e b
H14 : BetS e b P
P : Point
H13 : not (Meet a b C D)
H12 : neq e b
H11 : neq b a
H10 : BetS c e b
H9 : BetS a e d
H8 : not (Meet A B C D)
H7 : neq c d
H6 : Col C D d
H5 : Col C D c
H4 : neq a b
H3 : Col A B b
H2 : Col A B a
H1 : neq C D
H0 : neq A B
a,b,c,d,e : Point
H : Par A B C D
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
TP A B C D
+++++
assert (Col A B M).
-----
Lemma lemma_paralleldef2B : forall A B C D, Par A B C D -> TP A B C D.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists a b c d e, (neq A B /\\ neq C D /\\ Col A B a /\\ Col A B b /\\ neq a b /\\ Col C D c /\\ Col C D d /\\ neq c d /\\ ~ Meet A B C D /\\ BetS a e d /\\ BetS c e b)) by (conclude_def Par );destruct Tf as [a[b[c[d[e]]]]];spliter.
assert (neq b a) by (conclude lemma_inequalitysymmetric).
assert (neq e b) by (forward_using lemma_betweennotequal).
assert (~ Meet a b C D).
let Tf:=fresh in assert (Tf:exists P, (BetS e b P /\\ Cong b P e b)) by (conclude lemma_extension);destruct Tf as [P];spliter.
assert (BetS P b e) by (conclude axiom_betweennesssymmetry).
assert (BetS b e c) by (conclude axiom_betweennesssymmetry).
assert (BetS P b c) by (conclude lemma_3_7b).
assert (BetS c b P) by (conclude axiom_betweennesssymmetry).
assert (~ Col a d P).
let Tf:=fresh in assert (Tf:exists M, (BetS P M d /\\ BetS a b M)) by (conclude postulate_Pasch_outer);destruct Tf as [M];spliter.
assert (BetS M b a) by (conclude axiom_betweennesssymmetry).
assert (BetS P b c) by (conclude axiom_betweennesssymmetry).
assert (Col a b M) by (conclude_def Col ).
assert (Col B a b) by (conclude lemma_collinear4).
assert (Col b a B) by (forward_using lemma_collinearorder).
assert (Col b a M) by (forward_using lemma_collinearorder).
assert (neq b a) by (conclude lemma_inequalitysymmetric).
assert (Col a B M) by (conclude lemma_collinear4).
assert (Col a B A) by (forward_using lemma_collinearorder).
assert (Col A B M).

*****
H31 : Col a B A
H30 : Col a B M
H29 : neq b a
H28 : Col b a M
H27 : Col b a B
H26 : Col B a b
H25 : Col a b M
H24 : BetS P b c
H23 : BetS M b a
H22 : BetS a b M
H21 : BetS P M d
M : Point
H20 : not (Col a d P)
H19 : BetS c b P
H18 : BetS P b c
H17 : BetS b e c
H16 : BetS P b e
H15 : Cong b P e b
H14 : BetS e b P
P : Point
H13 : not (Meet a b C D)
H12 : neq e b
H11 : neq b a
H10 : BetS c e b
H9 : BetS a e d
H8 : not (Meet A B C D)
H7 : neq c d
H6 : Col C D d
H5 : Col C D c
H4 : neq a b
H3 : Col A B b
H2 : Col A B a
H1 : neq C D
H0 : neq A B
a,b,c,d,e : Point
H : Par A B C D
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
Col A B M
+++++
by cases on (neq a B \/ eq a B).
-----
Lemma lemma_paralleldef2B : forall A B C D, Par A B C D -> TP A B C D.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists a b c d e, (neq A B /\\ neq C D /\\ Col A B a /\\ Col A B b /\\ neq a b /\\ Col C D c /\\ Col C D d /\\ neq c d /\\ ~ Meet A B C D /\\ BetS a e d /\\ BetS c e b)) by (conclude_def Par );destruct Tf as [a[b[c[d[e]]]]];spliter.
assert (neq b a) by (conclude lemma_inequalitysymmetric).
assert (neq e b) by (forward_using lemma_betweennotequal).
assert (~ Meet a b C D).
let Tf:=fresh in assert (Tf:exists P, (BetS e b P /\\ Cong b P e b)) by (conclude lemma_extension);destruct Tf as [P];spliter.
assert (BetS P b e) by (conclude axiom_betweennesssymmetry).
assert (BetS b e c) by (conclude axiom_betweennesssymmetry).
assert (BetS P b c) by (conclude lemma_3_7b).
assert (BetS c b P) by (conclude axiom_betweennesssymmetry).
assert (~ Col a d P).
let Tf:=fresh in assert (Tf:exists M, (BetS P M d /\\ BetS a b M)) by (conclude postulate_Pasch_outer);destruct Tf as [M];spliter.
assert (BetS M b a) by (conclude axiom_betweennesssymmetry).
assert (BetS P b c) by (conclude axiom_betweennesssymmetry).
assert (Col a b M) by (conclude_def Col ).
assert (Col B a b) by (conclude lemma_collinear4).
assert (Col b a B) by (forward_using lemma_collinearorder).
assert (Col b a M) by (forward_using lemma_collinearorder).
assert (neq b a) by (conclude lemma_inequalitysymmetric).
assert (Col a B M) by (conclude lemma_collinear4).
assert (Col a B A) by (forward_using lemma_collinearorder).
assert (Col A B M).
by cases on (neq a B \\/ eq a B).

*****
H33 : neq a B
H31 : Col a B A
H30 : Col a B M
H29 : neq b a
H28 : Col b a M
H27 : Col b a B
H26 : Col B a b
H25 : Col a b M
H24 : BetS P b c
H23 : BetS M b a
H22 : BetS a b M
H21 : BetS P M d
M : Point
H20 : not (Col a d P)
H19 : BetS c b P
H18 : BetS P b c
H17 : BetS b e c
H16 : BetS P b e
H15 : Cong b P e b
H14 : BetS e b P
P : Point
H13 : not (Meet a b C D)
H12 : neq e b
H11 : neq b a
H10 : BetS c e b
H9 : BetS a e d
H8 : not (Meet A B C D)
H7 : neq c d
H6 : Col C D d
H5 : Col C D c
H4 : neq a b
H3 : Col A B b
H2 : Col A B a
H1 : neq C D
H0 : neq A B
a,b,c,d,e : Point
H : Par A B C D
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
Col A B M
+++++
assert (Col B M A) by (conclude lemma_collinear4).
-----
Lemma lemma_paralleldef2B : forall A B C D, Par A B C D -> TP A B C D.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists a b c d e, (neq A B /\\ neq C D /\\ Col A B a /\\ Col A B b /\\ neq a b /\\ Col C D c /\\ Col C D d /\\ neq c d /\\ ~ Meet A B C D /\\ BetS a e d /\\ BetS c e b)) by (conclude_def Par );destruct Tf as [a[b[c[d[e]]]]];spliter.
assert (neq b a) by (conclude lemma_inequalitysymmetric).
assert (neq e b) by (forward_using lemma_betweennotequal).
assert (~ Meet a b C D).
let Tf:=fresh in assert (Tf:exists P, (BetS e b P /\\ Cong b P e b)) by (conclude lemma_extension);destruct Tf as [P];spliter.
assert (BetS P b e) by (conclude axiom_betweennesssymmetry).
assert (BetS b e c) by (conclude axiom_betweennesssymmetry).
assert (BetS P b c) by (conclude lemma_3_7b).
assert (BetS c b P) by (conclude axiom_betweennesssymmetry).
assert (~ Col a d P).
let Tf:=fresh in assert (Tf:exists M, (BetS P M d /\\ BetS a b M)) by (conclude postulate_Pasch_outer);destruct Tf as [M];spliter.
assert (BetS M b a) by (conclude axiom_betweennesssymmetry).
assert (BetS P b c) by (conclude axiom_betweennesssymmetry).
assert (Col a b M) by (conclude_def Col ).
assert (Col B a b) by (conclude lemma_collinear4).
assert (Col b a B) by (forward_using lemma_collinearorder).
assert (Col b a M) by (forward_using lemma_collinearorder).
assert (neq b a) by (conclude lemma_inequalitysymmetric).
assert (Col a B M) by (conclude lemma_collinear4).
assert (Col a B A) by (forward_using lemma_collinearorder).
assert (Col A B M).
by cases on (neq a B \\/ eq a B).
assert (Col B M A) by (conclude lemma_collinear4).

*****
H32 : Col B M A
H33 : neq a B
H31 : Col a B A
H30 : Col a B M
H29 : neq b a
H28 : Col b a M
H27 : Col b a B
H26 : Col B a b
H25 : Col a b M
H24 : BetS P b c
H23 : BetS M b a
H22 : BetS a b M
H21 : BetS P M d
M : Point
H20 : not (Col a d P)
H19 : BetS c b P
H18 : BetS P b c
H17 : BetS b e c
H16 : BetS P b e
H15 : Cong b P e b
H14 : BetS e b P
P : Point
H13 : not (Meet a b C D)
H12 : neq e b
H11 : neq b a
H10 : BetS c e b
H9 : BetS a e d
H8 : not (Meet A B C D)
H7 : neq c d
H6 : Col C D d
H5 : Col C D c
H4 : neq a b
H3 : Col A B b
H2 : Col A B a
H1 : neq C D
H0 : neq A B
a,b,c,d,e : Point
H : Par A B C D
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
Col A B M
+++++
assert (Col A B M) by (forward_using lemma_collinearorder).
-----
Lemma lemma_paralleldef2B : forall A B C D, Par A B C D -> TP A B C D.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists a b c d e, (neq A B /\\ neq C D /\\ Col A B a /\\ Col A B b /\\ neq a b /\\ Col C D c /\\ Col C D d /\\ neq c d /\\ ~ Meet A B C D /\\ BetS a e d /\\ BetS c e b)) by (conclude_def Par );destruct Tf as [a[b[c[d[e]]]]];spliter.
assert (neq b a) by (conclude lemma_inequalitysymmetric).
assert (neq e b) by (forward_using lemma_betweennotequal).
assert (~ Meet a b C D).
let Tf:=fresh in assert (Tf:exists P, (BetS e b P /\\ Cong b P e b)) by (conclude lemma_extension);destruct Tf as [P];spliter.
assert (BetS P b e) by (conclude axiom_betweennesssymmetry).
assert (BetS b e c) by (conclude axiom_betweennesssymmetry).
assert (BetS P b c) by (conclude lemma_3_7b).
assert (BetS c b P) by (conclude axiom_betweennesssymmetry).
assert (~ Col a d P).
let Tf:=fresh in assert (Tf:exists M, (BetS P M d /\\ BetS a b M)) by (conclude postulate_Pasch_outer);destruct Tf as [M];spliter.
assert (BetS M b a) by (conclude axiom_betweennesssymmetry).
assert (BetS P b c) by (conclude axiom_betweennesssymmetry).
assert (Col a b M) by (conclude_def Col ).
assert (Col B a b) by (conclude lemma_collinear4).
assert (Col b a B) by (forward_using lemma_collinearorder).
assert (Col b a M) by (forward_using lemma_collinearorder).
assert (neq b a) by (conclude lemma_inequalitysymmetric).
assert (Col a B M) by (conclude lemma_collinear4).
assert (Col a B A) by (forward_using lemma_collinearorder).
assert (Col A B M).
by cases on (neq a B \\/ eq a B).
assert (Col B M A) by (conclude lemma_collinear4).
assert (Col A B M) by (forward_using lemma_collinearorder).

*****
H34 : Col A B M
H32 : Col B M A
H33 : neq a B
H31 : Col a B A
H30 : Col a B M
H29 : neq b a
H28 : Col b a M
H27 : Col b a B
H26 : Col B a b
H25 : Col a b M
H24 : BetS P b c
H23 : BetS M b a
H22 : BetS a b M
H21 : BetS P M d
M : Point
H20 : not (Col a d P)
H19 : BetS c b P
H18 : BetS P b c
H17 : BetS b e c
H16 : BetS P b e
H15 : Cong b P e b
H14 : BetS e b P
P : Point
H13 : not (Meet a b C D)
H12 : neq e b
H11 : neq b a
H10 : BetS c e b
H9 : BetS a e d
H8 : not (Meet A B C D)
H7 : neq c d
H6 : Col C D d
H5 : Col C D c
H4 : neq a b
H3 : Col A B b
H2 : Col A B a
H1 : neq C D
H0 : neq A B
a,b,c,d,e : Point
H : Par A B C D
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
Col A B M
+++++
close.
-----
Lemma lemma_paralleldef2B : forall A B C D, Par A B C D -> TP A B C D.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists a b c d e, (neq A B /\\ neq C D /\\ Col A B a /\\ Col A B b /\\ neq a b /\\ Col C D c /\\ Col C D d /\\ neq c d /\\ ~ Meet A B C D /\\ BetS a e d /\\ BetS c e b)) by (conclude_def Par );destruct Tf as [a[b[c[d[e]]]]];spliter.
assert (neq b a) by (conclude lemma_inequalitysymmetric).
assert (neq e b) by (forward_using lemma_betweennotequal).
assert (~ Meet a b C D).
let Tf:=fresh in assert (Tf:exists P, (BetS e b P /\\ Cong b P e b)) by (conclude lemma_extension);destruct Tf as [P];spliter.
assert (BetS P b e) by (conclude axiom_betweennesssymmetry).
assert (BetS b e c) by (conclude axiom_betweennesssymmetry).
assert (BetS P b c) by (conclude lemma_3_7b).
assert (BetS c b P) by (conclude axiom_betweennesssymmetry).
assert (~ Col a d P).
let Tf:=fresh in assert (Tf:exists M, (BetS P M d /\\ BetS a b M)) by (conclude postulate_Pasch_outer);destruct Tf as [M];spliter.
assert (BetS M b a) by (conclude axiom_betweennesssymmetry).
assert (BetS P b c) by (conclude axiom_betweennesssymmetry).
assert (Col a b M) by (conclude_def Col ).
assert (Col B a b) by (conclude lemma_collinear4).
assert (Col b a B) by (forward_using lemma_collinearorder).
assert (Col b a M) by (forward_using lemma_collinearorder).
assert (neq b a) by (conclude lemma_inequalitysymmetric).
assert (Col a B M) by (conclude lemma_collinear4).
assert (Col a B A) by (forward_using lemma_collinearorder).
assert (Col A B M).
by cases on (neq a B \\/ eq a B).

*****
H33 : eq a B
H31 : Col a B A
H30 : Col a B M
H29 : neq b a
H28 : Col b a M
H27 : Col b a B
H26 : Col B a b
H25 : Col a b M
H24 : BetS P b c
H23 : BetS M b a
H22 : BetS a b M
H21 : BetS P M d
M : Point
H20 : not (Col a d P)
H19 : BetS c b P
H18 : BetS P b c
H17 : BetS b e c
H16 : BetS P b e
H15 : Cong b P e b
H14 : BetS e b P
P : Point
H13 : not (Meet a b C D)
H12 : neq e b
H11 : neq b a
H10 : BetS c e b
H9 : BetS a e d
H8 : not (Meet A B C D)
H7 : neq c d
H6 : Col C D d
H5 : Col C D c
H4 : neq a b
H3 : Col A B b
H2 : Col A B a
H1 : neq C D
H0 : neq A B
a,b,c,d,e : Point
H : Par A B C D
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
Col A B M
+++++
assert (neq A a) by (conclude cn_equalitysub).
-----
Lemma lemma_paralleldef2B : forall A B C D, Par A B C D -> TP A B C D.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists a b c d e, (neq A B /\\ neq C D /\\ Col A B a /\\ Col A B b /\\ neq a b /\\ Col C D c /\\ Col C D d /\\ neq c d /\\ ~ Meet A B C D /\\ BetS a e d /\\ BetS c e b)) by (conclude_def Par );destruct Tf as [a[b[c[d[e]]]]];spliter.
assert (neq b a) by (conclude lemma_inequalitysymmetric).
assert (neq e b) by (forward_using lemma_betweennotequal).
assert (~ Meet a b C D).
let Tf:=fresh in assert (Tf:exists P, (BetS e b P /\\ Cong b P e b)) by (conclude lemma_extension);destruct Tf as [P];spliter.
assert (BetS P b e) by (conclude axiom_betweennesssymmetry).
assert (BetS b e c) by (conclude axiom_betweennesssymmetry).
assert (BetS P b c) by (conclude lemma_3_7b).
assert (BetS c b P) by (conclude axiom_betweennesssymmetry).
assert (~ Col a d P).
let Tf:=fresh in assert (Tf:exists M, (BetS P M d /\\ BetS a b M)) by (conclude postulate_Pasch_outer);destruct Tf as [M];spliter.
assert (BetS M b a) by (conclude axiom_betweennesssymmetry).
assert (BetS P b c) by (conclude axiom_betweennesssymmetry).
assert (Col a b M) by (conclude_def Col ).
assert (Col B a b) by (conclude lemma_collinear4).
assert (Col b a B) by (forward_using lemma_collinearorder).
assert (Col b a M) by (forward_using lemma_collinearorder).
assert (neq b a) by (conclude lemma_inequalitysymmetric).
assert (Col a B M) by (conclude lemma_collinear4).
assert (Col a B A) by (forward_using lemma_collinearorder).
assert (Col A B M).
by cases on (neq a B \\/ eq a B).
assert (neq A a) by (conclude cn_equalitysub).

*****
H32 : neq A a
H33 : eq a B
H31 : Col a B A
H30 : Col a B M
H29 : neq b a
H28 : Col b a M
H27 : Col b a B
H26 : Col B a b
H25 : Col a b M
H24 : BetS P b c
H23 : BetS M b a
H22 : BetS a b M
H21 : BetS P M d
M : Point
H20 : not (Col a d P)
H19 : BetS c b P
H18 : BetS P b c
H17 : BetS b e c
H16 : BetS P b e
H15 : Cong b P e b
H14 : BetS e b P
P : Point
H13 : not (Meet a b C D)
H12 : neq e b
H11 : neq b a
H10 : BetS c e b
H9 : BetS a e d
H8 : not (Meet A B C D)
H7 : neq c d
H6 : Col C D d
H5 : Col C D c
H4 : neq a b
H3 : Col A B b
H2 : Col A B a
H1 : neq C D
H0 : neq A B
a,b,c,d,e : Point
H : Par A B C D
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
Col A B M
+++++
assert (Col A a b) by (conclude cn_equalitysub).
-----
Lemma lemma_paralleldef2B : forall A B C D, Par A B C D -> TP A B C D.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists a b c d e, (neq A B /\\ neq C D /\\ Col A B a /\\ Col A B b /\\ neq a b /\\ Col C D c /\\ Col C D d /\\ neq c d /\\ ~ Meet A B C D /\\ BetS a e d /\\ BetS c e b)) by (conclude_def Par );destruct Tf as [a[b[c[d[e]]]]];spliter.
assert (neq b a) by (conclude lemma_inequalitysymmetric).
assert (neq e b) by (forward_using lemma_betweennotequal).
assert (~ Meet a b C D).
let Tf:=fresh in assert (Tf:exists P, (BetS e b P /\\ Cong b P e b)) by (conclude lemma_extension);destruct Tf as [P];spliter.
assert (BetS P b e) by (conclude axiom_betweennesssymmetry).
assert (BetS b e c) by (conclude axiom_betweennesssymmetry).
assert (BetS P b c) by (conclude lemma_3_7b).
assert (BetS c b P) by (conclude axiom_betweennesssymmetry).
assert (~ Col a d P).
let Tf:=fresh in assert (Tf:exists M, (BetS P M d /\\ BetS a b M)) by (conclude postulate_Pasch_outer);destruct Tf as [M];spliter.
assert (BetS M b a) by (conclude axiom_betweennesssymmetry).
assert (BetS P b c) by (conclude axiom_betweennesssymmetry).
assert (Col a b M) by (conclude_def Col ).
assert (Col B a b) by (conclude lemma_collinear4).
assert (Col b a B) by (forward_using lemma_collinearorder).
assert (Col b a M) by (forward_using lemma_collinearorder).
assert (neq b a) by (conclude lemma_inequalitysymmetric).
assert (Col a B M) by (conclude lemma_collinear4).
assert (Col a B A) by (forward_using lemma_collinearorder).
assert (Col A B M).
by cases on (neq a B \\/ eq a B).
assert (neq A a) by (conclude cn_equalitysub).
assert (Col A a b) by (conclude cn_equalitysub).

*****
H34 : Col A a b
H32 : neq A a
H33 : eq a B
H31 : Col a B A
H30 : Col a B M
H29 : neq b a
H28 : Col b a M
H27 : Col b a B
H26 : Col B a b
H25 : Col a b M
H24 : BetS P b c
H23 : BetS M b a
H22 : BetS a b M
H21 : BetS P M d
M : Point
H20 : not (Col a d P)
H19 : BetS c b P
H18 : BetS P b c
H17 : BetS b e c
H16 : BetS P b e
H15 : Cong b P e b
H14 : BetS e b P
P : Point
H13 : not (Meet a b C D)
H12 : neq e b
H11 : neq b a
H10 : BetS c e b
H9 : BetS a e d
H8 : not (Meet A B C D)
H7 : neq c d
H6 : Col C D d
H5 : Col C D c
H4 : neq a b
H3 : Col A B b
H2 : Col A B a
H1 : neq C D
H0 : neq A B
a,b,c,d,e : Point
H : Par A B C D
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
Col A B M
+++++
assert (Col b a A) by (forward_using lemma_collinearorder).
-----
Lemma lemma_paralleldef2B : forall A B C D, Par A B C D -> TP A B C D.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists a b c d e, (neq A B /\\ neq C D /\\ Col A B a /\\ Col A B b /\\ neq a b /\\ Col C D c /\\ Col C D d /\\ neq c d /\\ ~ Meet A B C D /\\ BetS a e d /\\ BetS c e b)) by (conclude_def Par );destruct Tf as [a[b[c[d[e]]]]];spliter.
assert (neq b a) by (conclude lemma_inequalitysymmetric).
assert (neq e b) by (forward_using lemma_betweennotequal).
assert (~ Meet a b C D).
let Tf:=fresh in assert (Tf:exists P, (BetS e b P /\\ Cong b P e b)) by (conclude lemma_extension);destruct Tf as [P];spliter.
assert (BetS P b e) by (conclude axiom_betweennesssymmetry).
assert (BetS b e c) by (conclude axiom_betweennesssymmetry).
assert (BetS P b c) by (conclude lemma_3_7b).
assert (BetS c b P) by (conclude axiom_betweennesssymmetry).
assert (~ Col a d P).
let Tf:=fresh in assert (Tf:exists M, (BetS P M d /\\ BetS a b M)) by (conclude postulate_Pasch_outer);destruct Tf as [M];spliter.
assert (BetS M b a) by (conclude axiom_betweennesssymmetry).
assert (BetS P b c) by (conclude axiom_betweennesssymmetry).
assert (Col a b M) by (conclude_def Col ).
assert (Col B a b) by (conclude lemma_collinear4).
assert (Col b a B) by (forward_using lemma_collinearorder).
assert (Col b a M) by (forward_using lemma_collinearorder).
assert (neq b a) by (conclude lemma_inequalitysymmetric).
assert (Col a B M) by (conclude lemma_collinear4).
assert (Col a B A) by (forward_using lemma_collinearorder).
assert (Col A B M).
by cases on (neq a B \\/ eq a B).
assert (neq A a) by (conclude cn_equalitysub).
assert (Col A a b) by (conclude cn_equalitysub).
assert (Col b a A) by (forward_using lemma_collinearorder).

*****
H35 : Col b a A
H34 : Col A a b
H32 : neq A a
H33 : eq a B
H31 : Col a B A
H30 : Col a B M
H29 : neq b a
H28 : Col b a M
H27 : Col b a B
H26 : Col B a b
H25 : Col a b M
H24 : BetS P b c
H23 : BetS M b a
H22 : BetS a b M
H21 : BetS P M d
M : Point
H20 : not (Col a d P)
H19 : BetS c b P
H18 : BetS P b c
H17 : BetS b e c
H16 : BetS P b e
H15 : Cong b P e b
H14 : BetS e b P
P : Point
H13 : not (Meet a b C D)
H12 : neq e b
H11 : neq b a
H10 : BetS c e b
H9 : BetS a e d
H8 : not (Meet A B C D)
H7 : neq c d
H6 : Col C D d
H5 : Col C D c
H4 : neq a b
H3 : Col A B b
H2 : Col A B a
H1 : neq C D
H0 : neq A B
a,b,c,d,e : Point
H : Par A B C D
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
Col A B M
+++++
assert (Col a A M) by (conclude lemma_collinear4).
-----
Lemma lemma_paralleldef2B : forall A B C D, Par A B C D -> TP A B C D.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists a b c d e, (neq A B /\\ neq C D /\\ Col A B a /\\ Col A B b /\\ neq a b /\\ Col C D c /\\ Col C D d /\\ neq c d /\\ ~ Meet A B C D /\\ BetS a e d /\\ BetS c e b)) by (conclude_def Par );destruct Tf as [a[b[c[d[e]]]]];spliter.
assert (neq b a) by (conclude lemma_inequalitysymmetric).
assert (neq e b) by (forward_using lemma_betweennotequal).
assert (~ Meet a b C D).
let Tf:=fresh in assert (Tf:exists P, (BetS e b P /\\ Cong b P e b)) by (conclude lemma_extension);destruct Tf as [P];spliter.
assert (BetS P b e) by (conclude axiom_betweennesssymmetry).
assert (BetS b e c) by (conclude axiom_betweennesssymmetry).
assert (BetS P b c) by (conclude lemma_3_7b).
assert (BetS c b P) by (conclude axiom_betweennesssymmetry).
assert (~ Col a d P).
let Tf:=fresh in assert (Tf:exists M, (BetS P M d /\\ BetS a b M)) by (conclude postulate_Pasch_outer);destruct Tf as [M];spliter.
assert (BetS M b a) by (conclude axiom_betweennesssymmetry).
assert (BetS P b c) by (conclude axiom_betweennesssymmetry).
assert (Col a b M) by (conclude_def Col ).
assert (Col B a b) by (conclude lemma_collinear4).
assert (Col b a B) by (forward_using lemma_collinearorder).
assert (Col b a M) by (forward_using lemma_collinearorder).
assert (neq b a) by (conclude lemma_inequalitysymmetric).
assert (Col a B M) by (conclude lemma_collinear4).
assert (Col a B A) by (forward_using lemma_collinearorder).
assert (Col A B M).
by cases on (neq a B \\/ eq a B).
assert (neq A a) by (conclude cn_equalitysub).
assert (Col A a b) by (conclude cn_equalitysub).
assert (Col b a A) by (forward_using lemma_collinearorder).
assert (Col a A M) by (conclude lemma_collinear4).

*****
H36 : Col a A M
H35 : Col b a A
H34 : Col A a b
H32 : neq A a
H33 : eq a B
H31 : Col a B A
H30 : Col a B M
H29 : neq b a
H28 : Col b a M
H27 : Col b a B
H26 : Col B a b
H25 : Col a b M
H24 : BetS P b c
H23 : BetS M b a
H22 : BetS a b M
H21 : BetS P M d
M : Point
H20 : not (Col a d P)
H19 : BetS c b P
H18 : BetS P b c
H17 : BetS b e c
H16 : BetS P b e
H15 : Cong b P e b
H14 : BetS e b P
P : Point
H13 : not (Meet a b C D)
H12 : neq e b
H11 : neq b a
H10 : BetS c e b
H9 : BetS a e d
H8 : not (Meet A B C D)
H7 : neq c d
H6 : Col C D d
H5 : Col C D c
H4 : neq a b
H3 : Col A B b
H2 : Col A B a
H1 : neq C D
H0 : neq A B
a,b,c,d,e : Point
H : Par A B C D
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
Col A B M
+++++
assert (Col a A B) by (forward_using lemma_collinearorder).
-----
Lemma lemma_paralleldef2B : forall A B C D, Par A B C D -> TP A B C D.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists a b c d e, (neq A B /\\ neq C D /\\ Col A B a /\\ Col A B b /\\ neq a b /\\ Col C D c /\\ Col C D d /\\ neq c d /\\ ~ Meet A B C D /\\ BetS a e d /\\ BetS c e b)) by (conclude_def Par );destruct Tf as [a[b[c[d[e]]]]];spliter.
assert (neq b a) by (conclude lemma_inequalitysymmetric).
assert (neq e b) by (forward_using lemma_betweennotequal).
assert (~ Meet a b C D).
let Tf:=fresh in assert (Tf:exists P, (BetS e b P /\\ Cong b P e b)) by (conclude lemma_extension);destruct Tf as [P];spliter.
assert (BetS P b e) by (conclude axiom_betweennesssymmetry).
assert (BetS b e c) by (conclude axiom_betweennesssymmetry).
assert (BetS P b c) by (conclude lemma_3_7b).
assert (BetS c b P) by (conclude axiom_betweennesssymmetry).
assert (~ Col a d P).
let Tf:=fresh in assert (Tf:exists M, (BetS P M d /\\ BetS a b M)) by (conclude postulate_Pasch_outer);destruct Tf as [M];spliter.
assert (BetS M b a) by (conclude axiom_betweennesssymmetry).
assert (BetS P b c) by (conclude axiom_betweennesssymmetry).
assert (Col a b M) by (conclude_def Col ).
assert (Col B a b) by (conclude lemma_collinear4).
assert (Col b a B) by (forward_using lemma_collinearorder).
assert (Col b a M) by (forward_using lemma_collinearorder).
assert (neq b a) by (conclude lemma_inequalitysymmetric).
assert (Col a B M) by (conclude lemma_collinear4).
assert (Col a B A) by (forward_using lemma_collinearorder).
assert (Col A B M).
by cases on (neq a B \\/ eq a B).
assert (neq A a) by (conclude cn_equalitysub).
assert (Col A a b) by (conclude cn_equalitysub).
assert (Col b a A) by (forward_using lemma_collinearorder).
assert (Col a A M) by (conclude lemma_collinear4).
assert (Col a A B) by (forward_using lemma_collinearorder).

*****
H37 : Col a A B
H36 : Col a A M
H35 : Col b a A
H34 : Col A a b
H32 : neq A a
H33 : eq a B
H31 : Col a B A
H30 : Col a B M
H29 : neq b a
H28 : Col b a M
H27 : Col b a B
H26 : Col B a b
H25 : Col a b M
H24 : BetS P b c
H23 : BetS M b a
H22 : BetS a b M
H21 : BetS P M d
M : Point
H20 : not (Col a d P)
H19 : BetS c b P
H18 : BetS P b c
H17 : BetS b e c
H16 : BetS P b e
H15 : Cong b P e b
H14 : BetS e b P
P : Point
H13 : not (Meet a b C D)
H12 : neq e b
H11 : neq b a
H10 : BetS c e b
H9 : BetS a e d
H8 : not (Meet A B C D)
H7 : neq c d
H6 : Col C D d
H5 : Col C D c
H4 : neq a b
H3 : Col A B b
H2 : Col A B a
H1 : neq C D
H0 : neq A B
a,b,c,d,e : Point
H : Par A B C D
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
Col A B M
+++++
assert (neq a A) by (conclude lemma_inequalitysymmetric).
-----
Lemma lemma_paralleldef2B : forall A B C D, Par A B C D -> TP A B C D.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists a b c d e, (neq A B /\\ neq C D /\\ Col A B a /\\ Col A B b /\\ neq a b /\\ Col C D c /\\ Col C D d /\\ neq c d /\\ ~ Meet A B C D /\\ BetS a e d /\\ BetS c e b)) by (conclude_def Par );destruct Tf as [a[b[c[d[e]]]]];spliter.
assert (neq b a) by (conclude lemma_inequalitysymmetric).
assert (neq e b) by (forward_using lemma_betweennotequal).
assert (~ Meet a b C D).
let Tf:=fresh in assert (Tf:exists P, (BetS e b P /\\ Cong b P e b)) by (conclude lemma_extension);destruct Tf as [P];spliter.
assert (BetS P b e) by (conclude axiom_betweennesssymmetry).
assert (BetS b e c) by (conclude axiom_betweennesssymmetry).
assert (BetS P b c) by (conclude lemma_3_7b).
assert (BetS c b P) by (conclude axiom_betweennesssymmetry).
assert (~ Col a d P).
let Tf:=fresh in assert (Tf:exists M, (BetS P M d /\\ BetS a b M)) by (conclude postulate_Pasch_outer);destruct Tf as [M];spliter.
assert (BetS M b a) by (conclude axiom_betweennesssymmetry).
assert (BetS P b c) by (conclude axiom_betweennesssymmetry).
assert (Col a b M) by (conclude_def Col ).
assert (Col B a b) by (conclude lemma_collinear4).
assert (Col b a B) by (forward_using lemma_collinearorder).
assert (Col b a M) by (forward_using lemma_collinearorder).
assert (neq b a) by (conclude lemma_inequalitysymmetric).
assert (Col a B M) by (conclude lemma_collinear4).
assert (Col a B A) by (forward_using lemma_collinearorder).
assert (Col A B M).
by cases on (neq a B \\/ eq a B).
assert (neq A a) by (conclude cn_equalitysub).
assert (Col A a b) by (conclude cn_equalitysub).
assert (Col b a A) by (forward_using lemma_collinearorder).
assert (Col a A M) by (conclude lemma_collinear4).
assert (Col a A B) by (forward_using lemma_collinearorder).
assert (neq a A) by (conclude lemma_inequalitysymmetric).

*****
H38 : neq a A
H37 : Col a A B
H36 : Col a A M
H35 : Col b a A
H34 : Col A a b
H32 : neq A a
H33 : eq a B
H31 : Col a B A
H30 : Col a B M
H29 : neq b a
H28 : Col b a M
H27 : Col b a B
H26 : Col B a b
H25 : Col a b M
H24 : BetS P b c
H23 : BetS M b a
H22 : BetS a b M
H21 : BetS P M d
M : Point
H20 : not (Col a d P)
H19 : BetS c b P
H18 : BetS P b c
H17 : BetS b e c
H16 : BetS P b e
H15 : Cong b P e b
H14 : BetS e b P
P : Point
H13 : not (Meet a b C D)
H12 : neq e b
H11 : neq b a
H10 : BetS c e b
H9 : BetS a e d
H8 : not (Meet A B C D)
H7 : neq c d
H6 : Col C D d
H5 : Col C D c
H4 : neq a b
H3 : Col A B b
H2 : Col A B a
H1 : neq C D
H0 : neq A B
a,b,c,d,e : Point
H : Par A B C D
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
Col A B M
+++++
assert (Col A M B) by (conclude lemma_collinear4).
-----
Lemma lemma_paralleldef2B : forall A B C D, Par A B C D -> TP A B C D.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists a b c d e, (neq A B /\\ neq C D /\\ Col A B a /\\ Col A B b /\\ neq a b /\\ Col C D c /\\ Col C D d /\\ neq c d /\\ ~ Meet A B C D /\\ BetS a e d /\\ BetS c e b)) by (conclude_def Par );destruct Tf as [a[b[c[d[e]]]]];spliter.
assert (neq b a) by (conclude lemma_inequalitysymmetric).
assert (neq e b) by (forward_using lemma_betweennotequal).
assert (~ Meet a b C D).
let Tf:=fresh in assert (Tf:exists P, (BetS e b P /\\ Cong b P e b)) by (conclude lemma_extension);destruct Tf as [P];spliter.
assert (BetS P b e) by (conclude axiom_betweennesssymmetry).
assert (BetS b e c) by (conclude axiom_betweennesssymmetry).
assert (BetS P b c) by (conclude lemma_3_7b).
assert (BetS c b P) by (conclude axiom_betweennesssymmetry).
assert (~ Col a d P).
let Tf:=fresh in assert (Tf:exists M, (BetS P M d /\\ BetS a b M)) by (conclude postulate_Pasch_outer);destruct Tf as [M];spliter.
assert (BetS M b a) by (conclude axiom_betweennesssymmetry).
assert (BetS P b c) by (conclude axiom_betweennesssymmetry).
assert (Col a b M) by (conclude_def Col ).
assert (Col B a b) by (conclude lemma_collinear4).
assert (Col b a B) by (forward_using lemma_collinearorder).
assert (Col b a M) by (forward_using lemma_collinearorder).
assert (neq b a) by (conclude lemma_inequalitysymmetric).
assert (Col a B M) by (conclude lemma_collinear4).
assert (Col a B A) by (forward_using lemma_collinearorder).
assert (Col A B M).
by cases on (neq a B \\/ eq a B).
assert (neq A a) by (conclude cn_equalitysub).
assert (Col A a b) by (conclude cn_equalitysub).
assert (Col b a A) by (forward_using lemma_collinearorder).
assert (Col a A M) by (conclude lemma_collinear4).
assert (Col a A B) by (forward_using lemma_collinearorder).
assert (neq a A) by (conclude lemma_inequalitysymmetric).
assert (Col A M B) by (conclude lemma_collinear4).

*****
H39 : Col A M B
H38 : neq a A
H37 : Col a A B
H36 : Col a A M
H35 : Col b a A
H34 : Col A a b
H32 : neq A a
H33 : eq a B
H31 : Col a B A
H30 : Col a B M
H29 : neq b a
H28 : Col b a M
H27 : Col b a B
H26 : Col B a b
H25 : Col a b M
H24 : BetS P b c
H23 : BetS M b a
H22 : BetS a b M
H21 : BetS P M d
M : Point
H20 : not (Col a d P)
H19 : BetS c b P
H18 : BetS P b c
H17 : BetS b e c
H16 : BetS P b e
H15 : Cong b P e b
H14 : BetS e b P
P : Point
H13 : not (Meet a b C D)
H12 : neq e b
H11 : neq b a
H10 : BetS c e b
H9 : BetS a e d
H8 : not (Meet A B C D)
H7 : neq c d
H6 : Col C D d
H5 : Col C D c
H4 : neq a b
H3 : Col A B b
H2 : Col A B a
H1 : neq C D
H0 : neq A B
a,b,c,d,e : Point
H : Par A B C D
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
Col A B M
+++++
assert (Col A B M) by (forward_using lemma_collinearorder).
-----
Lemma lemma_paralleldef2B : forall A B C D, Par A B C D -> TP A B C D.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists a b c d e, (neq A B /\\ neq C D /\\ Col A B a /\\ Col A B b /\\ neq a b /\\ Col C D c /\\ Col C D d /\\ neq c d /\\ ~ Meet A B C D /\\ BetS a e d /\\ BetS c e b)) by (conclude_def Par );destruct Tf as [a[b[c[d[e]]]]];spliter.
assert (neq b a) by (conclude lemma_inequalitysymmetric).
assert (neq e b) by (forward_using lemma_betweennotequal).
assert (~ Meet a b C D).
let Tf:=fresh in assert (Tf:exists P, (BetS e b P /\\ Cong b P e b)) by (conclude lemma_extension);destruct Tf as [P];spliter.
assert (BetS P b e) by (conclude axiom_betweennesssymmetry).
assert (BetS b e c) by (conclude axiom_betweennesssymmetry).
assert (BetS P b c) by (conclude lemma_3_7b).
assert (BetS c b P) by (conclude axiom_betweennesssymmetry).
assert (~ Col a d P).
let Tf:=fresh in assert (Tf:exists M, (BetS P M d /\\ BetS a b M)) by (conclude postulate_Pasch_outer);destruct Tf as [M];spliter.
assert (BetS M b a) by (conclude axiom_betweennesssymmetry).
assert (BetS P b c) by (conclude axiom_betweennesssymmetry).
assert (Col a b M) by (conclude_def Col ).
assert (Col B a b) by (conclude lemma_collinear4).
assert (Col b a B) by (forward_using lemma_collinearorder).
assert (Col b a M) by (forward_using lemma_collinearorder).
assert (neq b a) by (conclude lemma_inequalitysymmetric).
assert (Col a B M) by (conclude lemma_collinear4).
assert (Col a B A) by (forward_using lemma_collinearorder).
assert (Col A B M).
by cases on (neq a B \\/ eq a B).
assert (neq A a) by (conclude cn_equalitysub).
assert (Col A a b) by (conclude cn_equalitysub).
assert (Col b a A) by (forward_using lemma_collinearorder).
assert (Col a A M) by (conclude lemma_collinear4).
assert (Col a A B) by (forward_using lemma_collinearorder).
assert (neq a A) by (conclude lemma_inequalitysymmetric).
assert (Col A M B) by (conclude lemma_collinear4).
assert (Col A B M) by (forward_using lemma_collinearorder).

*****
H40 : Col A B M
H39 : Col A M B
H38 : neq a A
H37 : Col a A B
H36 : Col a A M
H35 : Col b a A
H34 : Col A a b
H32 : neq A a
H33 : eq a B
H31 : Col a B A
H30 : Col a B M
H29 : neq b a
H28 : Col b a M
H27 : Col b a B
H26 : Col B a b
H25 : Col a b M
H24 : BetS P b c
H23 : BetS M b a
H22 : BetS a b M
H21 : BetS P M d
M : Point
H20 : not (Col a d P)
H19 : BetS c b P
H18 : BetS P b c
H17 : BetS b e c
H16 : BetS P b e
H15 : Cong b P e b
H14 : BetS e b P
P : Point
H13 : not (Meet a b C D)
H12 : neq e b
H11 : neq b a
H10 : BetS c e b
H9 : BetS a e d
H8 : not (Meet A B C D)
H7 : neq c d
H6 : Col C D d
H5 : Col C D c
H4 : neq a b
H3 : Col A B b
H2 : Col A B a
H1 : neq C D
H0 : neq A B
a,b,c,d,e : Point
H : Par A B C D
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
Col A B M
+++++
close.
-----
Lemma lemma_paralleldef2B : forall A B C D, Par A B C D -> TP A B C D.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists a b c d e, (neq A B /\\ neq C D /\\ Col A B a /\\ Col A B b /\\ neq a b /\\ Col C D c /\\ Col C D d /\\ neq c d /\\ ~ Meet A B C D /\\ BetS a e d /\\ BetS c e b)) by (conclude_def Par );destruct Tf as [a[b[c[d[e]]]]];spliter.
assert (neq b a) by (conclude lemma_inequalitysymmetric).
assert (neq e b) by (forward_using lemma_betweennotequal).
assert (~ Meet a b C D).
let Tf:=fresh in assert (Tf:exists P, (BetS e b P /\\ Cong b P e b)) by (conclude lemma_extension);destruct Tf as [P];spliter.
assert (BetS P b e) by (conclude axiom_betweennesssymmetry).
assert (BetS b e c) by (conclude axiom_betweennesssymmetry).
assert (BetS P b c) by (conclude lemma_3_7b).
assert (BetS c b P) by (conclude axiom_betweennesssymmetry).
assert (~ Col a d P).
let Tf:=fresh in assert (Tf:exists M, (BetS P M d /\\ BetS a b M)) by (conclude postulate_Pasch_outer);destruct Tf as [M];spliter.
assert (BetS M b a) by (conclude axiom_betweennesssymmetry).
assert (BetS P b c) by (conclude axiom_betweennesssymmetry).
assert (Col a b M) by (conclude_def Col ).
assert (Col B a b) by (conclude lemma_collinear4).
assert (Col b a B) by (forward_using lemma_collinearorder).
assert (Col b a M) by (forward_using lemma_collinearorder).
assert (neq b a) by (conclude lemma_inequalitysymmetric).
assert (Col a B M) by (conclude lemma_collinear4).
assert (Col a B A) by (forward_using lemma_collinearorder).
assert (Col A B M).
by cases on (neq a B \\/ eq a B).

*****
H32 : Col A B M
H31 : Col a B A
H30 : Col a B M
H29 : neq b a
H28 : Col b a M
H27 : Col b a B
H26 : Col B a b
H25 : Col a b M
H24 : BetS P b c
H23 : BetS M b a
H22 : BetS a b M
H21 : BetS P M d
M : Point
H20 : not (Col a d P)
H19 : BetS c b P
H18 : BetS P b c
H17 : BetS b e c
H16 : BetS P b e
H15 : Cong b P e b
H14 : BetS e b P
P : Point
H13 : not (Meet a b C D)
H12 : neq e b
H11 : neq b a
H10 : BetS c e b
H9 : BetS a e d
H8 : not (Meet A B C D)
H7 : neq c d
H6 : Col C D d
H5 : Col C D c
H4 : neq a b
H3 : Col A B b
H2 : Col A B a
H1 : neq C D
H0 : neq A B
a,b,c,d,e : Point
H : Par A B C D
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
TP A B C D
+++++
assert (BetS c b P) by (conclude axiom_betweennesssymmetry).
-----
Lemma lemma_paralleldef2B : forall A B C D, Par A B C D -> TP A B C D.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists a b c d e, (neq A B /\\ neq C D /\\ Col A B a /\\ Col A B b /\\ neq a b /\\ Col C D c /\\ Col C D d /\\ neq c d /\\ ~ Meet A B C D /\\ BetS a e d /\\ BetS c e b)) by (conclude_def Par );destruct Tf as [a[b[c[d[e]]]]];spliter.
assert (neq b a) by (conclude lemma_inequalitysymmetric).
assert (neq e b) by (forward_using lemma_betweennotequal).
assert (~ Meet a b C D).
let Tf:=fresh in assert (Tf:exists P, (BetS e b P /\\ Cong b P e b)) by (conclude lemma_extension);destruct Tf as [P];spliter.
assert (BetS P b e) by (conclude axiom_betweennesssymmetry).
assert (BetS b e c) by (conclude axiom_betweennesssymmetry).
assert (BetS P b c) by (conclude lemma_3_7b).
assert (BetS c b P) by (conclude axiom_betweennesssymmetry).
assert (~ Col a d P).
let Tf:=fresh in assert (Tf:exists M, (BetS P M d /\\ BetS a b M)) by (conclude postulate_Pasch_outer);destruct Tf as [M];spliter.
assert (BetS M b a) by (conclude axiom_betweennesssymmetry).
assert (BetS P b c) by (conclude axiom_betweennesssymmetry).
assert (Col a b M) by (conclude_def Col ).
assert (Col B a b) by (conclude lemma_collinear4).
assert (Col b a B) by (forward_using lemma_collinearorder).
assert (Col b a M) by (forward_using lemma_collinearorder).
assert (neq b a) by (conclude lemma_inequalitysymmetric).
assert (Col a B M) by (conclude lemma_collinear4).
assert (Col a B A) by (forward_using lemma_collinearorder).
assert (Col A B M).
by cases on (neq a B \\/ eq a B).
assert (BetS c b P) by (conclude axiom_betweennesssymmetry).

*****
H33 : BetS c b P
H32 : Col A B M
H31 : Col a B A
H30 : Col a B M
H29 : neq b a
H28 : Col b a M
H27 : Col b a B
H26 : Col B a b
H25 : Col a b M
H24 : BetS P b c
H23 : BetS M b a
H22 : BetS a b M
H21 : BetS P M d
M : Point
H20 : not (Col a d P)
H19 : BetS c b P
H18 : BetS P b c
H17 : BetS b e c
H16 : BetS P b e
H15 : Cong b P e b
H14 : BetS e b P
P : Point
H13 : not (Meet a b C D)
H12 : neq e b
H11 : neq b a
H10 : BetS c e b
H9 : BetS a e d
H8 : not (Meet A B C D)
H7 : neq c d
H6 : Col C D d
H5 : Col C D c
H4 : neq a b
H3 : Col A B b
H2 : Col A B a
H1 : neq C D
H0 : neq A B
a,b,c,d,e : Point
H : Par A B C D
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
TP A B C D
+++++
assert (BetS d M P) by (conclude axiom_betweennesssymmetry).
-----
Lemma lemma_paralleldef2B : forall A B C D, Par A B C D -> TP A B C D.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists a b c d e, (neq A B /\\ neq C D /\\ Col A B a /\\ Col A B b /\\ neq a b /\\ Col C D c /\\ Col C D d /\\ neq c d /\\ ~ Meet A B C D /\\ BetS a e d /\\ BetS c e b)) by (conclude_def Par );destruct Tf as [a[b[c[d[e]]]]];spliter.
assert (neq b a) by (conclude lemma_inequalitysymmetric).
assert (neq e b) by (forward_using lemma_betweennotequal).
assert (~ Meet a b C D).
let Tf:=fresh in assert (Tf:exists P, (BetS e b P /\\ Cong b P e b)) by (conclude lemma_extension);destruct Tf as [P];spliter.
assert (BetS P b e) by (conclude axiom_betweennesssymmetry).
assert (BetS b e c) by (conclude axiom_betweennesssymmetry).
assert (BetS P b c) by (conclude lemma_3_7b).
assert (BetS c b P) by (conclude axiom_betweennesssymmetry).
assert (~ Col a d P).
let Tf:=fresh in assert (Tf:exists M, (BetS P M d /\\ BetS a b M)) by (conclude postulate_Pasch_outer);destruct Tf as [M];spliter.
assert (BetS M b a) by (conclude axiom_betweennesssymmetry).
assert (BetS P b c) by (conclude axiom_betweennesssymmetry).
assert (Col a b M) by (conclude_def Col ).
assert (Col B a b) by (conclude lemma_collinear4).
assert (Col b a B) by (forward_using lemma_collinearorder).
assert (Col b a M) by (forward_using lemma_collinearorder).
assert (neq b a) by (conclude lemma_inequalitysymmetric).
assert (Col a B M) by (conclude lemma_collinear4).
assert (Col a B A) by (forward_using lemma_collinearorder).
assert (Col A B M).
by cases on (neq a B \\/ eq a B).
assert (BetS c b P) by (conclude axiom_betweennesssymmetry).
assert (BetS d M P) by (conclude axiom_betweennesssymmetry).

*****
H34 : BetS d M P
H33 : BetS c b P
H32 : Col A B M
H31 : Col a B A
H30 : Col a B M
H29 : neq b a
H28 : Col b a M
H27 : Col b a B
H26 : Col B a b
H25 : Col a b M
H24 : BetS P b c
H23 : BetS M b a
H22 : BetS a b M
H21 : BetS P M d
M : Point
H20 : not (Col a d P)
H19 : BetS c b P
H18 : BetS P b c
H17 : BetS b e c
H16 : BetS P b e
H15 : Cong b P e b
H14 : BetS e b P
P : Point
H13 : not (Meet a b C D)
H12 : neq e b
H11 : neq b a
H10 : BetS c e b
H9 : BetS a e d
H8 : not (Meet A B C D)
H7 : neq c d
H6 : Col C D d
H5 : Col C D c
H4 : neq a b
H3 : Col A B b
H2 : Col A B a
H1 : neq C D
H0 : neq A B
a,b,c,d,e : Point
H : Par A B C D
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
TP A B C D
+++++
assert (~ Col A B c).
-----
Lemma lemma_paralleldef2B : forall A B C D, Par A B C D -> TP A B C D.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists a b c d e, (neq A B /\\ neq C D /\\ Col A B a /\\ Col A B b /\\ neq a b /\\ Col C D c /\\ Col C D d /\\ neq c d /\\ ~ Meet A B C D /\\ BetS a e d /\\ BetS c e b)) by (conclude_def Par );destruct Tf as [a[b[c[d[e]]]]];spliter.
assert (neq b a) by (conclude lemma_inequalitysymmetric).
assert (neq e b) by (forward_using lemma_betweennotequal).
assert (~ Meet a b C D).
let Tf:=fresh in assert (Tf:exists P, (BetS e b P /\\ Cong b P e b)) by (conclude lemma_extension);destruct Tf as [P];spliter.
assert (BetS P b e) by (conclude axiom_betweennesssymmetry).
assert (BetS b e c) by (conclude axiom_betweennesssymmetry).
assert (BetS P b c) by (conclude lemma_3_7b).
assert (BetS c b P) by (conclude axiom_betweennesssymmetry).
assert (~ Col a d P).
let Tf:=fresh in assert (Tf:exists M, (BetS P M d /\\ BetS a b M)) by (conclude postulate_Pasch_outer);destruct Tf as [M];spliter.
assert (BetS M b a) by (conclude axiom_betweennesssymmetry).
assert (BetS P b c) by (conclude axiom_betweennesssymmetry).
assert (Col a b M) by (conclude_def Col ).
assert (Col B a b) by (conclude lemma_collinear4).
assert (Col b a B) by (forward_using lemma_collinearorder).
assert (Col b a M) by (forward_using lemma_collinearorder).
assert (neq b a) by (conclude lemma_inequalitysymmetric).
assert (Col a B M) by (conclude lemma_collinear4).
assert (Col a B A) by (forward_using lemma_collinearorder).
assert (Col A B M).
by cases on (neq a B \\/ eq a B).
assert (BetS c b P) by (conclude axiom_betweennesssymmetry).
assert (BetS d M P) by (conclude axiom_betweennesssymmetry).
assert (~ Col A B c).

*****
H34 : BetS d M P
H33 : BetS c b P
H32 : Col A B M
H31 : Col a B A
H30 : Col a B M
H29 : neq b a
H28 : Col b a M
H27 : Col b a B
H26 : Col B a b
H25 : Col a b M
H24 : BetS P b c
H23 : BetS M b a
H22 : BetS a b M
H21 : BetS P M d
M : Point
H20 : not (Col a d P)
H19 : BetS c b P
H18 : BetS P b c
H17 : BetS b e c
H16 : BetS P b e
H15 : Cong b P e b
H14 : BetS e b P
P : Point
H13 : not (Meet a b C D)
H12 : neq e b
H11 : neq b a
H10 : BetS c e b
H9 : BetS a e d
H8 : not (Meet A B C D)
H7 : neq c d
H6 : Col C D d
H5 : Col C D c
H4 : neq a b
H3 : Col A B b
H2 : Col A B a
H1 : neq C D
H0 : neq A B
a,b,c,d,e : Point
H : Par A B C D
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
not (Col A B c)
+++++
intro.
-----
Lemma lemma_paralleldef2B : forall A B C D, Par A B C D -> TP A B C D.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists a b c d e, (neq A B /\\ neq C D /\\ Col A B a /\\ Col A B b /\\ neq a b /\\ Col C D c /\\ Col C D d /\\ neq c d /\\ ~ Meet A B C D /\\ BetS a e d /\\ BetS c e b)) by (conclude_def Par );destruct Tf as [a[b[c[d[e]]]]];spliter.
assert (neq b a) by (conclude lemma_inequalitysymmetric).
assert (neq e b) by (forward_using lemma_betweennotequal).
assert (~ Meet a b C D).
let Tf:=fresh in assert (Tf:exists P, (BetS e b P /\\ Cong b P e b)) by (conclude lemma_extension);destruct Tf as [P];spliter.
assert (BetS P b e) by (conclude axiom_betweennesssymmetry).
assert (BetS b e c) by (conclude axiom_betweennesssymmetry).
assert (BetS P b c) by (conclude lemma_3_7b).
assert (BetS c b P) by (conclude axiom_betweennesssymmetry).
assert (~ Col a d P).
let Tf:=fresh in assert (Tf:exists M, (BetS P M d /\\ BetS a b M)) by (conclude postulate_Pasch_outer);destruct Tf as [M];spliter.
assert (BetS M b a) by (conclude axiom_betweennesssymmetry).
assert (BetS P b c) by (conclude axiom_betweennesssymmetry).
assert (Col a b M) by (conclude_def Col ).
assert (Col B a b) by (conclude lemma_collinear4).
assert (Col b a B) by (forward_using lemma_collinearorder).
assert (Col b a M) by (forward_using lemma_collinearorder).
assert (neq b a) by (conclude lemma_inequalitysymmetric).
assert (Col a B M) by (conclude lemma_collinear4).
assert (Col a B A) by (forward_using lemma_collinearorder).
assert (Col A B M).
by cases on (neq a B \\/ eq a B).
assert (BetS c b P) by (conclude axiom_betweennesssymmetry).
assert (BetS d M P) by (conclude axiom_betweennesssymmetry).
assert (~ Col A B c).
intro.

*****
H35 : Col A B c
H34 : BetS d M P
H33 : BetS c b P
H32 : Col A B M
H31 : Col a B A
H30 : Col a B M
H29 : neq b a
H28 : Col b a M
H27 : Col b a B
H26 : Col B a b
H25 : Col a b M
H24 : BetS P b c
H23 : BetS M b a
H22 : BetS a b M
H21 : BetS P M d
M : Point
H20 : not (Col a d P)
H19 : BetS c b P
H18 : BetS P b c
H17 : BetS b e c
H16 : BetS P b e
H15 : Cong b P e b
H14 : BetS e b P
P : Point
H13 : not (Meet a b C D)
H12 : neq e b
H11 : neq b a
H10 : BetS c e b
H9 : BetS a e d
H8 : not (Meet A B C D)
H7 : neq c d
H6 : Col C D d
H5 : Col C D c
H4 : neq a b
H3 : Col A B b
H2 : Col A B a
H1 : neq C D
H0 : neq A B
a,b,c,d,e : Point
H : Par A B C D
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
False
+++++
assert (Meet A B C D) by (conclude_def Meet ).
-----
Lemma lemma_paralleldef2B : forall A B C D, Par A B C D -> TP A B C D.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists a b c d e, (neq A B /\\ neq C D /\\ Col A B a /\\ Col A B b /\\ neq a b /\\ Col C D c /\\ Col C D d /\\ neq c d /\\ ~ Meet A B C D /\\ BetS a e d /\\ BetS c e b)) by (conclude_def Par );destruct Tf as [a[b[c[d[e]]]]];spliter.
assert (neq b a) by (conclude lemma_inequalitysymmetric).
assert (neq e b) by (forward_using lemma_betweennotequal).
assert (~ Meet a b C D).
let Tf:=fresh in assert (Tf:exists P, (BetS e b P /\\ Cong b P e b)) by (conclude lemma_extension);destruct Tf as [P];spliter.
assert (BetS P b e) by (conclude axiom_betweennesssymmetry).
assert (BetS b e c) by (conclude axiom_betweennesssymmetry).
assert (BetS P b c) by (conclude lemma_3_7b).
assert (BetS c b P) by (conclude axiom_betweennesssymmetry).
assert (~ Col a d P).
let Tf:=fresh in assert (Tf:exists M, (BetS P M d /\\ BetS a b M)) by (conclude postulate_Pasch_outer);destruct Tf as [M];spliter.
assert (BetS M b a) by (conclude axiom_betweennesssymmetry).
assert (BetS P b c) by (conclude axiom_betweennesssymmetry).
assert (Col a b M) by (conclude_def Col ).
assert (Col B a b) by (conclude lemma_collinear4).
assert (Col b a B) by (forward_using lemma_collinearorder).
assert (Col b a M) by (forward_using lemma_collinearorder).
assert (neq b a) by (conclude lemma_inequalitysymmetric).
assert (Col a B M) by (conclude lemma_collinear4).
assert (Col a B A) by (forward_using lemma_collinearorder).
assert (Col A B M).
by cases on (neq a B \\/ eq a B).
assert (BetS c b P) by (conclude axiom_betweennesssymmetry).
assert (BetS d M P) by (conclude axiom_betweennesssymmetry).
assert (~ Col A B c).
intro.
assert (Meet A B C D) by (conclude_def Meet ).

*****
H36 : Meet A B C D
H35 : Col A B c
H34 : BetS d M P
H33 : BetS c b P
H32 : Col A B M
H31 : Col a B A
H30 : Col a B M
H29 : neq b a
H28 : Col b a M
H27 : Col b a B
H26 : Col B a b
H25 : Col a b M
H24 : BetS P b c
H23 : BetS M b a
H22 : BetS a b M
H21 : BetS P M d
M : Point
H20 : not (Col a d P)
H19 : BetS c b P
H18 : BetS P b c
H17 : BetS b e c
H16 : BetS P b e
H15 : Cong b P e b
H14 : BetS e b P
P : Point
H13 : not (Meet a b C D)
H12 : neq e b
H11 : neq b a
H10 : BetS c e b
H9 : BetS a e d
H8 : not (Meet A B C D)
H7 : neq c d
H6 : Col C D d
H5 : Col C D c
H4 : neq a b
H3 : Col A B b
H2 : Col A B a
H1 : neq C D
H0 : neq A B
a,b,c,d,e : Point
H : Par A B C D
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
False
+++++
contradict.
-----
Lemma lemma_paralleldef2B : forall A B C D, Par A B C D -> TP A B C D.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists a b c d e, (neq A B /\\ neq C D /\\ Col A B a /\\ Col A B b /\\ neq a b /\\ Col C D c /\\ Col C D d /\\ neq c d /\\ ~ Meet A B C D /\\ BetS a e d /\\ BetS c e b)) by (conclude_def Par );destruct Tf as [a[b[c[d[e]]]]];spliter.
assert (neq b a) by (conclude lemma_inequalitysymmetric).
assert (neq e b) by (forward_using lemma_betweennotequal).
assert (~ Meet a b C D).
let Tf:=fresh in assert (Tf:exists P, (BetS e b P /\\ Cong b P e b)) by (conclude lemma_extension);destruct Tf as [P];spliter.
assert (BetS P b e) by (conclude axiom_betweennesssymmetry).
assert (BetS b e c) by (conclude axiom_betweennesssymmetry).
assert (BetS P b c) by (conclude lemma_3_7b).
assert (BetS c b P) by (conclude axiom_betweennesssymmetry).
assert (~ Col a d P).
let Tf:=fresh in assert (Tf:exists M, (BetS P M d /\\ BetS a b M)) by (conclude postulate_Pasch_outer);destruct Tf as [M];spliter.
assert (BetS M b a) by (conclude axiom_betweennesssymmetry).
assert (BetS P b c) by (conclude axiom_betweennesssymmetry).
assert (Col a b M) by (conclude_def Col ).
assert (Col B a b) by (conclude lemma_collinear4).
assert (Col b a B) by (forward_using lemma_collinearorder).
assert (Col b a M) by (forward_using lemma_collinearorder).
assert (neq b a) by (conclude lemma_inequalitysymmetric).
assert (Col a B M) by (conclude lemma_collinear4).
assert (Col a B A) by (forward_using lemma_collinearorder).
assert (Col A B M).
by cases on (neq a B \\/ eq a B).
assert (BetS c b P) by (conclude axiom_betweennesssymmetry).
assert (BetS d M P) by (conclude axiom_betweennesssymmetry).
assert (~ Col A B c).

*****
H35 : not (Col A B c)
H34 : BetS d M P
H33 : BetS c b P
H32 : Col A B M
H31 : Col a B A
H30 : Col a B M
H29 : neq b a
H28 : Col b a M
H27 : Col b a B
H26 : Col B a b
H25 : Col a b M
H24 : BetS P b c
H23 : BetS M b a
H22 : BetS a b M
H21 : BetS P M d
M : Point
H20 : not (Col a d P)
H19 : BetS c b P
H18 : BetS P b c
H17 : BetS b e c
H16 : BetS P b e
H15 : Cong b P e b
H14 : BetS e b P
P : Point
H13 : not (Meet a b C D)
H12 : neq e b
H11 : neq b a
H10 : BetS c e b
H9 : BetS a e d
H8 : not (Meet A B C D)
H7 : neq c d
H6 : Col C D d
H5 : Col C D c
H4 : neq a b
H3 : Col A B b
H2 : Col A B a
H1 : neq C D
H0 : neq A B
a,b,c,d,e : Point
H : Par A B C D
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
TP A B C D
+++++
assert (~ Col A B d).
-----
Lemma lemma_paralleldef2B : forall A B C D, Par A B C D -> TP A B C D.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists a b c d e, (neq A B /\\ neq C D /\\ Col A B a /\\ Col A B b /\\ neq a b /\\ Col C D c /\\ Col C D d /\\ neq c d /\\ ~ Meet A B C D /\\ BetS a e d /\\ BetS c e b)) by (conclude_def Par );destruct Tf as [a[b[c[d[e]]]]];spliter.
assert (neq b a) by (conclude lemma_inequalitysymmetric).
assert (neq e b) by (forward_using lemma_betweennotequal).
assert (~ Meet a b C D).
let Tf:=fresh in assert (Tf:exists P, (BetS e b P /\\ Cong b P e b)) by (conclude lemma_extension);destruct Tf as [P];spliter.
assert (BetS P b e) by (conclude axiom_betweennesssymmetry).
assert (BetS b e c) by (conclude axiom_betweennesssymmetry).
assert (BetS P b c) by (conclude lemma_3_7b).
assert (BetS c b P) by (conclude axiom_betweennesssymmetry).
assert (~ Col a d P).
let Tf:=fresh in assert (Tf:exists M, (BetS P M d /\\ BetS a b M)) by (conclude postulate_Pasch_outer);destruct Tf as [M];spliter.
assert (BetS M b a) by (conclude axiom_betweennesssymmetry).
assert (BetS P b c) by (conclude axiom_betweennesssymmetry).
assert (Col a b M) by (conclude_def Col ).
assert (Col B a b) by (conclude lemma_collinear4).
assert (Col b a B) by (forward_using lemma_collinearorder).
assert (Col b a M) by (forward_using lemma_collinearorder).
assert (neq b a) by (conclude lemma_inequalitysymmetric).
assert (Col a B M) by (conclude lemma_collinear4).
assert (Col a B A) by (forward_using lemma_collinearorder).
assert (Col A B M).
by cases on (neq a B \\/ eq a B).
assert (BetS c b P) by (conclude axiom_betweennesssymmetry).
assert (BetS d M P) by (conclude axiom_betweennesssymmetry).
assert (~ Col A B c).
assert (~ Col A B d).

*****
H35 : not (Col A B c)
H34 : BetS d M P
H33 : BetS c b P
H32 : Col A B M
H31 : Col a B A
H30 : Col a B M
H29 : neq b a
H28 : Col b a M
H27 : Col b a B
H26 : Col B a b
H25 : Col a b M
H24 : BetS P b c
H23 : BetS M b a
H22 : BetS a b M
H21 : BetS P M d
M : Point
H20 : not (Col a d P)
H19 : BetS c b P
H18 : BetS P b c
H17 : BetS b e c
H16 : BetS P b e
H15 : Cong b P e b
H14 : BetS e b P
P : Point
H13 : not (Meet a b C D)
H12 : neq e b
H11 : neq b a
H10 : BetS c e b
H9 : BetS a e d
H8 : not (Meet A B C D)
H7 : neq c d
H6 : Col C D d
H5 : Col C D c
H4 : neq a b
H3 : Col A B b
H2 : Col A B a
H1 : neq C D
H0 : neq A B
a,b,c,d,e : Point
H : Par A B C D
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
not (Col A B d)
+++++
intro.
-----
Lemma lemma_paralleldef2B : forall A B C D, Par A B C D -> TP A B C D.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists a b c d e, (neq A B /\\ neq C D /\\ Col A B a /\\ Col A B b /\\ neq a b /\\ Col C D c /\\ Col C D d /\\ neq c d /\\ ~ Meet A B C D /\\ BetS a e d /\\ BetS c e b)) by (conclude_def Par );destruct Tf as [a[b[c[d[e]]]]];spliter.
assert (neq b a) by (conclude lemma_inequalitysymmetric).
assert (neq e b) by (forward_using lemma_betweennotequal).
assert (~ Meet a b C D).
let Tf:=fresh in assert (Tf:exists P, (BetS e b P /\\ Cong b P e b)) by (conclude lemma_extension);destruct Tf as [P];spliter.
assert (BetS P b e) by (conclude axiom_betweennesssymmetry).
assert (BetS b e c) by (conclude axiom_betweennesssymmetry).
assert (BetS P b c) by (conclude lemma_3_7b).
assert (BetS c b P) by (conclude axiom_betweennesssymmetry).
assert (~ Col a d P).
let Tf:=fresh in assert (Tf:exists M, (BetS P M d /\\ BetS a b M)) by (conclude postulate_Pasch_outer);destruct Tf as [M];spliter.
assert (BetS M b a) by (conclude axiom_betweennesssymmetry).
assert (BetS P b c) by (conclude axiom_betweennesssymmetry).
assert (Col a b M) by (conclude_def Col ).
assert (Col B a b) by (conclude lemma_collinear4).
assert (Col b a B) by (forward_using lemma_collinearorder).
assert (Col b a M) by (forward_using lemma_collinearorder).
assert (neq b a) by (conclude lemma_inequalitysymmetric).
assert (Col a B M) by (conclude lemma_collinear4).
assert (Col a B A) by (forward_using lemma_collinearorder).
assert (Col A B M).
by cases on (neq a B \\/ eq a B).
assert (BetS c b P) by (conclude axiom_betweennesssymmetry).
assert (BetS d M P) by (conclude axiom_betweennesssymmetry).
assert (~ Col A B c).
assert (~ Col A B d).
intro.

*****
H36 : Col A B d
H35 : not (Col A B c)
H34 : BetS d M P
H33 : BetS c b P
H32 : Col A B M
H31 : Col a B A
H30 : Col a B M
H29 : neq b a
H28 : Col b a M
H27 : Col b a B
H26 : Col B a b
H25 : Col a b M
H24 : BetS P b c
H23 : BetS M b a
H22 : BetS a b M
H21 : BetS P M d
M : Point
H20 : not (Col a d P)
H19 : BetS c b P
H18 : BetS P b c
H17 : BetS b e c
H16 : BetS P b e
H15 : Cong b P e b
H14 : BetS e b P
P : Point
H13 : not (Meet a b C D)
H12 : neq e b
H11 : neq b a
H10 : BetS c e b
H9 : BetS a e d
H8 : not (Meet A B C D)
H7 : neq c d
H6 : Col C D d
H5 : Col C D c
H4 : neq a b
H3 : Col A B b
H2 : Col A B a
H1 : neq C D
H0 : neq A B
a,b,c,d,e : Point
H : Par A B C D
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
False
+++++
assert (Meet A B C D) by (conclude_def Meet ).
-----
Lemma lemma_paralleldef2B : forall A B C D, Par A B C D -> TP A B C D.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists a b c d e, (neq A B /\\ neq C D /\\ Col A B a /\\ Col A B b /\\ neq a b /\\ Col C D c /\\ Col C D d /\\ neq c d /\\ ~ Meet A B C D /\\ BetS a e d /\\ BetS c e b)) by (conclude_def Par );destruct Tf as [a[b[c[d[e]]]]];spliter.
assert (neq b a) by (conclude lemma_inequalitysymmetric).
assert (neq e b) by (forward_using lemma_betweennotequal).
assert (~ Meet a b C D).
let Tf:=fresh in assert (Tf:exists P, (BetS e b P /\\ Cong b P e b)) by (conclude lemma_extension);destruct Tf as [P];spliter.
assert (BetS P b e) by (conclude axiom_betweennesssymmetry).
assert (BetS b e c) by (conclude axiom_betweennesssymmetry).
assert (BetS P b c) by (conclude lemma_3_7b).
assert (BetS c b P) by (conclude axiom_betweennesssymmetry).
assert (~ Col a d P).
let Tf:=fresh in assert (Tf:exists M, (BetS P M d /\\ BetS a b M)) by (conclude postulate_Pasch_outer);destruct Tf as [M];spliter.
assert (BetS M b a) by (conclude axiom_betweennesssymmetry).
assert (BetS P b c) by (conclude axiom_betweennesssymmetry).
assert (Col a b M) by (conclude_def Col ).
assert (Col B a b) by (conclude lemma_collinear4).
assert (Col b a B) by (forward_using lemma_collinearorder).
assert (Col b a M) by (forward_using lemma_collinearorder).
assert (neq b a) by (conclude lemma_inequalitysymmetric).
assert (Col a B M) by (conclude lemma_collinear4).
assert (Col a B A) by (forward_using lemma_collinearorder).
assert (Col A B M).
by cases on (neq a B \\/ eq a B).
assert (BetS c b P) by (conclude axiom_betweennesssymmetry).
assert (BetS d M P) by (conclude axiom_betweennesssymmetry).
assert (~ Col A B c).
assert (~ Col A B d).
intro.
assert (Meet A B C D) by (conclude_def Meet ).

*****
H37 : Meet A B C D
H36 : Col A B d
H35 : not (Col A B c)
H34 : BetS d M P
H33 : BetS c b P
H32 : Col A B M
H31 : Col a B A
H30 : Col a B M
H29 : neq b a
H28 : Col b a M
H27 : Col b a B
H26 : Col B a b
H25 : Col a b M
H24 : BetS P b c
H23 : BetS M b a
H22 : BetS a b M
H21 : BetS P M d
M : Point
H20 : not (Col a d P)
H19 : BetS c b P
H18 : BetS P b c
H17 : BetS b e c
H16 : BetS P b e
H15 : Cong b P e b
H14 : BetS e b P
P : Point
H13 : not (Meet a b C D)
H12 : neq e b
H11 : neq b a
H10 : BetS c e b
H9 : BetS a e d
H8 : not (Meet A B C D)
H7 : neq c d
H6 : Col C D d
H5 : Col C D c
H4 : neq a b
H3 : Col A B b
H2 : Col A B a
H1 : neq C D
H0 : neq A B
a,b,c,d,e : Point
H : Par A B C D
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
False
+++++
contradict.
-----
Lemma lemma_paralleldef2B : forall A B C D, Par A B C D -> TP A B C D.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists a b c d e, (neq A B /\\ neq C D /\\ Col A B a /\\ Col A B b /\\ neq a b /\\ Col C D c /\\ Col C D d /\\ neq c d /\\ ~ Meet A B C D /\\ BetS a e d /\\ BetS c e b)) by (conclude_def Par );destruct Tf as [a[b[c[d[e]]]]];spliter.
assert (neq b a) by (conclude lemma_inequalitysymmetric).
assert (neq e b) by (forward_using lemma_betweennotequal).
assert (~ Meet a b C D).
let Tf:=fresh in assert (Tf:exists P, (BetS e b P /\\ Cong b P e b)) by (conclude lemma_extension);destruct Tf as [P];spliter.
assert (BetS P b e) by (conclude axiom_betweennesssymmetry).
assert (BetS b e c) by (conclude axiom_betweennesssymmetry).
assert (BetS P b c) by (conclude lemma_3_7b).
assert (BetS c b P) by (conclude axiom_betweennesssymmetry).
assert (~ Col a d P).
let Tf:=fresh in assert (Tf:exists M, (BetS P M d /\\ BetS a b M)) by (conclude postulate_Pasch_outer);destruct Tf as [M];spliter.
assert (BetS M b a) by (conclude axiom_betweennesssymmetry).
assert (BetS P b c) by (conclude axiom_betweennesssymmetry).
assert (Col a b M) by (conclude_def Col ).
assert (Col B a b) by (conclude lemma_collinear4).
assert (Col b a B) by (forward_using lemma_collinearorder).
assert (Col b a M) by (forward_using lemma_collinearorder).
assert (neq b a) by (conclude lemma_inequalitysymmetric).
assert (Col a B M) by (conclude lemma_collinear4).
assert (Col a B A) by (forward_using lemma_collinearorder).
assert (Col A B M).
by cases on (neq a B \\/ eq a B).
assert (BetS c b P) by (conclude axiom_betweennesssymmetry).
assert (BetS d M P) by (conclude axiom_betweennesssymmetry).
assert (~ Col A B c).
assert (~ Col A B d).

*****
H36 : not (Col A B d)
H35 : not (Col A B c)
H34 : BetS d M P
H33 : BetS c b P
H32 : Col A B M
H31 : Col a B A
H30 : Col a B M
H29 : neq b a
H28 : Col b a M
H27 : Col b a B
H26 : Col B a b
H25 : Col a b M
H24 : BetS P b c
H23 : BetS M b a
H22 : BetS a b M
H21 : BetS P M d
M : Point
H20 : not (Col a d P)
H19 : BetS c b P
H18 : BetS P b c
H17 : BetS b e c
H16 : BetS P b e
H15 : Cong b P e b
H14 : BetS e b P
P : Point
H13 : not (Meet a b C D)
H12 : neq e b
H11 : neq b a
H10 : BetS c e b
H9 : BetS a e d
H8 : not (Meet A B C D)
H7 : neq c d
H6 : Col C D d
H5 : Col C D c
H4 : neq a b
H3 : Col A B b
H2 : Col A B a
H1 : neq C D
H0 : neq A B
a,b,c,d,e : Point
H : Par A B C D
A,B,C,D : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
TP A B C D
+++++
assert (OS c d A B) by (conclude_def OS ).
-----
