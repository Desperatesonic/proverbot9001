From Coq Require Import Bool.
-----
Require Import Coq.Bool.Sumbool.
-----
From Coq Require Import Arith.
-----
From Coq Require Import ZArith.
-----
Require Import   Coq.NArith.NArith Coq.NArith.Nnat Coq.NArith.Ndec Coq.NArith.Ndigits.
-----
From IntMap Require Import Allmaps.
-----
Definition BDDzero := N0.
-----
Definition BDDone := Npos 1.
-----
Definition BDDvar := ad.
-----
Definition BDDcompare (x y : BDDvar) :=\n    match x, y with\n    | N0, N0 => Datatypes.Eq\n    | N0, Npos _ => Datatypes.Lt\n    | Npos _, N0 => Datatypes.Gt\n    | Npos p1, Npos p2 => Pcompare p1 p2 Datatypes.Eq\n    end.
-----
Definition BDDvar_eq := Neqb.
-----
Definition ad_S (a : ad) :=\n    match a with\n    | N0 => Npos 1\n    | Npos p => Npos (Psucc p)\n    end.
-----
Lemma ad_S_is_S : forall a : ad, nat_of_N (ad_S a) = S (nat_of_N a).
-----
Lemma ad_S_is_S : forall a : ad, nat_of_N (ad_S a) = S (nat_of_N a).

*****

*****
forall a : ad, eq (N.to_nat (ad_S a)) (S (N.to_nat a))
+++++
Proof.
-----
Lemma ad_S_is_S : forall a : ad, nat_of_N (ad_S a) = S (nat_of_N a).
Proof.

*****

*****
forall a : ad, eq (N.to_nat (ad_S a)) (S (N.to_nat a))
+++++
simple induction a.
-----
Lemma ad_S_is_S : forall a : ad, nat_of_N (ad_S a) = S (nat_of_N a).
Proof.
simple induction a.

*****
a : ad
*****
eq (N.to_nat (ad_S N0)) (S (N.to_nat N0))
+++++
reflexivity.
-----
Lemma ad_S_is_S : forall a : ad, nat_of_N (ad_S a) = S (nat_of_N a).
Proof.
simple induction a.

*****
a : ad
*****
forall p : positive, eq (N.to_nat (ad_S (Npos p))) (S (N.to_nat (Npos p)))
+++++
simpl in |- *.
-----
Lemma ad_S_is_S : forall a : ad, nat_of_N (ad_S a) = S (nat_of_N a).
Proof.
simple induction a.
simpl in |- *.

*****
a : ad
*****
forall p : positive, eq (Pos.to_nat (Pos.succ p)) (S (Pos.to_nat p))
+++++
unfold nat_of_P in |- *.
-----
Lemma ad_S_is_S : forall a : ad, nat_of_N (ad_S a) = S (nat_of_N a).
Proof.
simple induction a.
simpl in |- *.
unfold nat_of_P in |- *.

*****
a : ad
*****
forall p : positive, eq (Pos.iter_op nat Init.Nat.add (Pos.succ p) (S O)) (S (Pos.iter_op nat Init.Nat.add p (S O)))
+++++
intro p.
-----
Lemma ad_S_is_S : forall a : ad, nat_of_N (ad_S a) = S (nat_of_N a).
Proof.
simple induction a.
simpl in |- *.
unfold nat_of_P in |- *.
intro p.

*****
p : positive
a : ad
*****
eq (Pos.iter_op nat Init.Nat.add (Pos.succ p) (S O)) (S (Pos.iter_op nat Init.Nat.add p (S O)))
+++++
exact (Pmult_nat_succ_morphism p 1).
-----
Lemma ad_S_is_S : forall a : ad, nat_of_N (ad_S a) = S (nat_of_N a).
Proof.
simple induction a.

*****

*****

+++++
Qed.
-----
Lemma lt_pred : forall x y : nat, x < y -> x <> 0 -> pred x < pred y.
-----
Lemma lt_pred : forall x y : nat, x < y -> x <> 0 -> pred x < pred y.

*****

*****
forall (x y : nat) (_ : lt x y) (_ : not (eq x O)), lt (Init.Nat.pred x) (Init.Nat.pred y)
+++++
Proof.
-----
Lemma lt_pred : forall x y : nat, x < y -> x <> 0 -> pred x < pred y.
Proof.

*****

*****
forall (x y : nat) (_ : lt x y) (_ : not (eq x O)), lt (Init.Nat.pred x) (Init.Nat.pred y)
+++++
simple induction x.
-----
Lemma lt_pred : forall x y : nat, x < y -> x <> 0 -> pred x < pred y.
Proof.
simple induction x.

*****
x : nat
*****
forall (y : nat) (_ : lt O y) (_ : not (eq O O)), lt (Init.Nat.pred O) (Init.Nat.pred y)
+++++
intros y H H0.
-----
Lemma lt_pred : forall x y : nat, x < y -> x <> 0 -> pred x < pred y.
Proof.
simple induction x.
intros y H H0.

*****
H0 : not (eq O O)
H : lt O y
x,y : nat
*****
lt (Init.Nat.pred O) (Init.Nat.pred y)
+++++
absurd (0 = 0).
-----
Lemma lt_pred : forall x y : nat, x < y -> x <> 0 -> pred x < pred y.
Proof.
simple induction x.
intros y H H0.
absurd (0 = 0).

*****
H0 : not (eq O O)
H : lt O y
x,y : nat
*****
not (eq O O)
+++++
assumption.
-----
Lemma lt_pred : forall x y : nat, x < y -> x <> 0 -> pred x < pred y.
Proof.
simple induction x.
intros y H H0.
absurd (0 = 0).

*****
H0 : not (eq O O)
H : lt O y
x,y : nat
*****
eq O O
+++++
reflexivity.
-----
Lemma lt_pred : forall x y : nat, x < y -> x <> 0 -> pred x < pred y.
Proof.
simple induction x.

*****
x : nat
*****
forall (n : nat) (_ : forall (y : nat) (_ : lt n y) (_ : not (eq n O)), lt (Init.Nat.pred n) (Init.Nat.pred y)) (y : nat) (_ : lt (S n) y) (_ : not (eq (S n) O)), lt (Init.Nat.pred (S n)) (Init.Nat.pred y)
+++++
intros n H y H0 H1.
-----
Lemma lt_pred : forall x y : nat, x < y -> x <> 0 -> pred x < pred y.
Proof.
simple induction x.
intros n H y H0 H1.

*****
H1 : not (eq (S n) O)
H0 : lt (S n) y
y : nat
H : forall (y : nat) (_ : lt n y) (_ : not (eq n O)),\nlt (Init.Nat.pred n) (Init.Nat.pred y)
x,n : nat
*****
lt (Init.Nat.pred (S n)) (Init.Nat.pred y)
+++++
apply lt_pred.
-----
Lemma lt_pred : forall x y : nat, x < y -> x <> 0 -> pred x < pred y.
Proof.
simple induction x.
intros n H y H0 H1.
apply lt_pred.

*****
H1 : not (eq (S n) O)
H0 : lt (S n) y
y : nat
H : forall (y : nat) (_ : lt n y) (_ : not (eq n O)),\nlt (Init.Nat.pred n) (Init.Nat.pred y)
x,n : nat
*****
lt (S (Init.Nat.pred (S n))) y
+++++
assumption.
-----
Lemma lt_pred : forall x y : nat, x < y -> x <> 0 -> pred x < pred y.
Proof.
simple induction x.

*****

*****

+++++
Qed.
-----
Lemma O_N0 : forall x : ad, nat_of_N x = 0 -> x = N0.
-----
Lemma O_N0 : forall x : ad, nat_of_N x = 0 -> x = N0.

*****

*****
forall (x : ad) (_ : eq (N.to_nat x) O), eq x N0
+++++
Proof.
-----
Lemma O_N0 : forall x : ad, nat_of_N x = 0 -> x = N0.
Proof.

*****

*****
forall (x : ad) (_ : eq (N.to_nat x) O), eq x N0
+++++
cut (0 = nat_of_N N0).
-----
Lemma O_N0 : forall x : ad, nat_of_N x = 0 -> x = N0.
Proof.
cut (0 = nat_of_N N0).

*****

*****
forall (_ : eq O (N.to_nat N0)) (x : ad) (_ : eq (N.to_nat x) O), eq x N0
+++++
intro H.
-----
Lemma O_N0 : forall x : ad, nat_of_N x = 0 -> x = N0.
Proof.
cut (0 = nat_of_N N0).
intro H.

*****
H : eq O (N.to_nat N0)
*****
forall (x : ad) (_ : eq (N.to_nat x) O), eq x N0
+++++
rewrite H.
-----
Lemma O_N0 : forall x : ad, nat_of_N x = 0 -> x = N0.
Proof.
cut (0 = nat_of_N N0).
intro H.
rewrite H.

*****
H : eq O (N.to_nat N0)
*****
forall (x : ad) (_ : eq (N.to_nat x) (N.to_nat N0)), eq x N0
+++++
intros x H0.
-----
Lemma O_N0 : forall x : ad, nat_of_N x = 0 -> x = N0.
Proof.
cut (0 = nat_of_N N0).
intro H.
rewrite H.
intros x H0.

*****
H0 : eq (N.to_nat x) (N.to_nat N0)
x : ad
H : eq O (N.to_nat N0)
*****
eq x N0
+++++
replace x with (N_of_nat (nat_of_N x)).
-----
Lemma O_N0 : forall x : ad, nat_of_N x = 0 -> x = N0.
Proof.
cut (0 = nat_of_N N0).
intro H.
rewrite H.
intros x H0.
replace x with (N_of_nat (nat_of_N x)).

*****
H0 : eq (N.to_nat x) (N.to_nat N0)
x : ad
H : eq O (N.to_nat N0)
*****
eq (N.of_nat (N.to_nat x)) N0
+++++
replace N0 with (N_of_nat (nat_of_N N0)).
-----
Lemma O_N0 : forall x : ad, nat_of_N x = 0 -> x = N0.
Proof.
cut (0 = nat_of_N N0).
intro H.
rewrite H.
intros x H0.
replace x with (N_of_nat (nat_of_N x)).
replace N0 with (N_of_nat (nat_of_N N0)).

*****
H0 : eq (N.to_nat x) (N.to_nat N0)
x : ad
H : eq O (N.to_nat N0)
*****
eq (N.of_nat (N.to_nat x)) (N.of_nat (N.to_nat N0))
+++++
rewrite H0.
-----
Lemma O_N0 : forall x : ad, nat_of_N x = 0 -> x = N0.
Proof.
cut (0 = nat_of_N N0).
intro H.
rewrite H.
intros x H0.
replace x with (N_of_nat (nat_of_N x)).
replace N0 with (N_of_nat (nat_of_N N0)).
rewrite H0.

*****
H0 : eq (N.to_nat x) (N.to_nat N0)
x : ad
H : eq O (N.to_nat N0)
*****
eq (N.of_nat (N.to_nat N0)) (N.of_nat (N.to_nat N0))
+++++
reflexivity.
-----
Lemma O_N0 : forall x : ad, nat_of_N x = 0 -> x = N0.
Proof.
cut (0 = nat_of_N N0).
intro H.
rewrite H.
intros x H0.
replace x with (N_of_nat (nat_of_N x)).
replace N0 with (N_of_nat (nat_of_N N0)).

*****
H0 : eq (N.to_nat x) (N.to_nat N0)
x : ad
H : eq O (N.to_nat N0)
*****
eq (N.of_nat (N.to_nat N0)) N0
+++++
rewrite (N_of_nat_of_N N0).
-----
Lemma O_N0 : forall x : ad, nat_of_N x = 0 -> x = N0.
Proof.
cut (0 = nat_of_N N0).
intro H.
rewrite H.
intros x H0.
replace x with (N_of_nat (nat_of_N x)).
replace N0 with (N_of_nat (nat_of_N N0)).
rewrite (N_of_nat_of_N N0).

*****
H0 : eq (N.to_nat x) (N.to_nat N0)
x : ad
H : eq O (N.to_nat N0)
*****
eq N0 N0
+++++
reflexivity.
-----
Lemma O_N0 : forall x : ad, nat_of_N x = 0 -> x = N0.
Proof.
cut (0 = nat_of_N N0).
intro H.
rewrite H.
intros x H0.
replace x with (N_of_nat (nat_of_N x)).

*****
H0 : eq (N.to_nat x) (N.to_nat N0)
x : ad
H : eq O (N.to_nat N0)
*****
eq (N.of_nat (N.to_nat x)) x
+++++
rewrite (N_of_nat_of_N x).
-----
Lemma O_N0 : forall x : ad, nat_of_N x = 0 -> x = N0.
Proof.
cut (0 = nat_of_N N0).
intro H.
rewrite H.
intros x H0.
replace x with (N_of_nat (nat_of_N x)).
rewrite (N_of_nat_of_N x).

*****
H0 : eq (N.to_nat x) (N.to_nat N0)
x : ad
H : eq O (N.to_nat N0)
*****
eq x x
+++++
reflexivity.
-----
Lemma O_N0 : forall x : ad, nat_of_N x = 0 -> x = N0.
Proof.
cut (0 = nat_of_N N0).

*****

*****
eq O (N.to_nat N0)
+++++
reflexivity.
-----
Lemma O_N0 : forall x : ad, nat_of_N x = 0 -> x = N0.
Proof.
cut (0 = nat_of_N N0).

*****

*****

+++++
Qed.
-----
Lemma INFERIEUR_neq_O :\n forall x y : ad, BDDcompare x y = Datatypes.Lt -> y <> N0.
-----
Lemma INFERIEUR_neq_O : forall x y : ad, BDDcompare x y = Datatypes.Lt -> y <> N0.

*****

*****
forall (x y : ad) (_ : eq (BDDcompare x y) Lt), not (eq y N0)
+++++
Proof.
-----
Lemma INFERIEUR_neq_O : forall x y : ad, BDDcompare x y = Datatypes.Lt -> y <> N0.
Proof.

*****

*****
forall (x y : ad) (_ : eq (BDDcompare x y) Lt), not (eq y N0)
+++++
double induction x y.
-----
Lemma INFERIEUR_neq_O : forall x y : ad, BDDcompare x y = Datatypes.Lt -> y <> N0.
Proof.
double induction x y.

*****
x,y : ad
*****
forall _ : eq (BDDcompare N0 N0) Lt, not (eq N0 N0)
+++++
simpl in |- *.
-----
Lemma INFERIEUR_neq_O : forall x y : ad, BDDcompare x y = Datatypes.Lt -> y <> N0.
Proof.
double induction x y.
simpl in |- *.

*****
x,y : ad
*****
forall _ : eq Eq Lt, not (eq N0 N0)
+++++
intro.
-----
Lemma INFERIEUR_neq_O : forall x y : ad, BDDcompare x y = Datatypes.Lt -> y <> N0.
Proof.
double induction x y.
simpl in |- *.
intro.

*****
H : eq Eq Lt
x,y : ad
*****
not (eq N0 N0)
+++++
discriminate.
-----
Lemma INFERIEUR_neq_O : forall x y : ad, BDDcompare x y = Datatypes.Lt -> y <> N0.
Proof.
double induction x y.

*****
x,y : ad
*****
forall (p : positive) (_ : eq (BDDcompare N0 (Npos p)) Lt), not (eq (Npos p) N0)
+++++
unfold not in |- *.
-----
Lemma INFERIEUR_neq_O : forall x y : ad, BDDcompare x y = Datatypes.Lt -> y <> N0.
Proof.
double induction x y.
unfold not in |- *.

*****
x,y : ad
*****
forall (p : positive) (_ : eq (BDDcompare N0 (Npos p)) Lt) (_ : eq (Npos p) N0), False
+++++
intros.
-----
Lemma INFERIEUR_neq_O : forall x y : ad, BDDcompare x y = Datatypes.Lt -> y <> N0.
Proof.
double induction x y.
unfold not in |- *.
intros.

*****
H0 : eq (Npos p) N0
H : eq (BDDcompare N0 (Npos p)) Lt
p : positive
x,y : ad
*****
False
+++++
discriminate.
-----
Lemma INFERIEUR_neq_O : forall x y : ad, BDDcompare x y = Datatypes.Lt -> y <> N0.
Proof.
double induction x y.

*****
x,y : ad
*****
forall (p : positive) (_ : eq (BDDcompare (Npos p) N0) Lt), not (eq N0 N0)
+++++
simpl in |- *.
-----
Lemma INFERIEUR_neq_O : forall x y : ad, BDDcompare x y = Datatypes.Lt -> y <> N0.
Proof.
double induction x y.
simpl in |- *.

*****
x,y : ad
*****
forall (_ : positive) (_ : eq Gt Lt), not (eq N0 N0)
+++++
intros.
-----
Lemma INFERIEUR_neq_O : forall x y : ad, BDDcompare x y = Datatypes.Lt -> y <> N0.
Proof.
double induction x y.
simpl in |- *.
intros.

*****
H : eq Gt Lt
p : positive
x,y : ad
*****
not (eq N0 N0)
+++++
discriminate.
-----
Lemma INFERIEUR_neq_O : forall x y : ad, BDDcompare x y = Datatypes.Lt -> y <> N0.
Proof.
double induction x y.

*****
x,y : ad
*****
forall (p p0 : positive) (_ : eq (BDDcompare (Npos p0) (Npos p)) Lt), not (eq (Npos p) N0)
+++++
unfold not in |- *.
-----
Lemma INFERIEUR_neq_O : forall x y : ad, BDDcompare x y = Datatypes.Lt -> y <> N0.
Proof.
double induction x y.
unfold not in |- *.

*****
x,y : ad
*****
forall (p p0 : positive) (_ : eq (BDDcompare (Npos p0) (Npos p)) Lt) (_ : eq (Npos p) N0), False
+++++
intros.
-----
Lemma INFERIEUR_neq_O : forall x y : ad, BDDcompare x y = Datatypes.Lt -> y <> N0.
Proof.
double induction x y.
unfold not in |- *.
intros.

*****
H0 : eq (Npos p) N0
H : eq (BDDcompare (Npos p0) (Npos p)) Lt
p,p0 : positive
x,y : ad
*****
False
+++++
discriminate.
-----
Lemma INFERIEUR_neq_O : forall x y : ad, BDDcompare x y = Datatypes.Lt -> y <> N0.
Proof.
double induction x y.

*****

*****

+++++
Qed.
-----
Lemma BDDcompare_trans :\n  forall x y z : BDDvar,\n  BDDcompare x y = Datatypes.Lt ->\n  BDDcompare y z = Datatypes.Lt -> BDDcompare x z = Datatypes.Lt.
-----
Lemma BDDcompare_trans : forall x y z : BDDvar, BDDcompare x y = Datatypes.Lt -> BDDcompare y z = Datatypes.Lt -> BDDcompare x z = Datatypes.Lt.

*****

*****
forall (x y z : BDDvar) (_ : eq (BDDcompare x y) Lt) (_ : eq (BDDcompare y z) Lt), eq (BDDcompare x z) Lt
+++++
Proof.
-----
Lemma BDDcompare_trans : forall x y z : BDDvar, BDDcompare x y = Datatypes.Lt -> BDDcompare y z = Datatypes.Lt -> BDDcompare x z = Datatypes.Lt.
Proof.

*****

*****
forall (x y z : BDDvar) (_ : eq (BDDcompare x y) Lt) (_ : eq (BDDcompare y z) Lt), eq (BDDcompare x z) Lt
+++++
double induction x y.
-----
Lemma BDDcompare_trans : forall x y z : BDDvar, BDDcompare x y = Datatypes.Lt -> BDDcompare y z = Datatypes.Lt -> BDDcompare x z = Datatypes.Lt.
Proof.
double induction x y.

*****
x,y : BDDvar
*****
forall (z : BDDvar) (_ : eq (BDDcompare N0 N0) Lt) (_ : eq (BDDcompare N0 z) Lt), eq (BDDcompare N0 z) Lt
+++++
simpl in |- *.
-----
Lemma BDDcompare_trans : forall x y z : BDDvar, BDDcompare x y = Datatypes.Lt -> BDDcompare y z = Datatypes.Lt -> BDDcompare x z = Datatypes.Lt.
Proof.
double induction x y.
simpl in |- *.

*****
x,y : BDDvar
*****
forall (z : BDDvar) (_ : eq Eq Lt) (_ : eq match z with | N0 => Eq | Npos _ => Lt end Lt), eq match z with | N0 => Eq | Npos _ => Lt end Lt
+++++
intros z H H0.
-----
Lemma BDDcompare_trans : forall x y z : BDDvar, BDDcompare x y = Datatypes.Lt -> BDDcompare y z = Datatypes.Lt -> BDDcompare x z = Datatypes.Lt.
Proof.
double induction x y.
simpl in |- *.
intros z H H0.

*****
H0 : eq match z with\n | N0 => Eq\n | Npos _ => Lt\n end Lt
H : eq Eq Lt
x,y,z : BDDvar
*****
eq match z with | N0 => Eq | Npos _ => Lt end Lt
+++++
discriminate H.
-----
Lemma BDDcompare_trans : forall x y z : BDDvar, BDDcompare x y = Datatypes.Lt -> BDDcompare y z = Datatypes.Lt -> BDDcompare x z = Datatypes.Lt.
Proof.
double induction x y.

*****
x,y : BDDvar
*****
forall (p : positive) (z : BDDvar) (_ : eq (BDDcompare N0 (Npos p)) Lt) (_ : eq (BDDcompare (Npos p) z) Lt), eq (BDDcompare N0 z) Lt
+++++
simpl in |- *.
-----
Lemma BDDcompare_trans : forall x y z : BDDvar, BDDcompare x y = Datatypes.Lt -> BDDcompare y z = Datatypes.Lt -> BDDcompare x z = Datatypes.Lt.
Proof.
double induction x y.
simpl in |- *.

*****
x,y : BDDvar
*****
forall (p : positive) (z : BDDvar) (_ : eq Lt Lt) (_ : eq match z with | N0 => Gt | Npos p2 => Pos.compare_cont Eq p p2 end Lt), eq match z with | N0 => Eq | Npos _ => Lt end Lt
+++++
intro p.
-----
Lemma BDDcompare_trans : forall x y z : BDDvar, BDDcompare x y = Datatypes.Lt -> BDDcompare y z = Datatypes.Lt -> BDDcompare x z = Datatypes.Lt.
Proof.
double induction x y.
simpl in |- *.
intro p.

*****
p : positive
x,y : BDDvar
*****
forall (z : BDDvar) (_ : eq Lt Lt) (_ : eq match z with | N0 => Gt | Npos p2 => Pos.compare_cont Eq p p2 end Lt), eq match z with | N0 => Eq | Npos _ => Lt end Lt
+++++
simple induction z.
-----
Lemma BDDcompare_trans : forall x y z : BDDvar, BDDcompare x y = Datatypes.Lt -> BDDcompare y z = Datatypes.Lt -> BDDcompare x z = Datatypes.Lt.
Proof.
double induction x y.
simpl in |- *.
intro p.
simple induction z.

*****
z : BDDvar
p : positive
x,y : BDDvar
*****
forall (_ : eq Lt Lt) (_ : eq Gt Lt), eq Eq Lt
+++++
intros H H0.
-----
Lemma BDDcompare_trans : forall x y z : BDDvar, BDDcompare x y = Datatypes.Lt -> BDDcompare y z = Datatypes.Lt -> BDDcompare x z = Datatypes.Lt.
Proof.
double induction x y.
simpl in |- *.
intro p.
simple induction z.
intros H H0.

*****
H0 : eq Gt Lt
H : eq Lt Lt
z : BDDvar
p : positive
x,y : BDDvar
*****
eq Eq Lt
+++++
discriminate H0.
-----
Lemma BDDcompare_trans : forall x y z : BDDvar, BDDcompare x y = Datatypes.Lt -> BDDcompare y z = Datatypes.Lt -> BDDcompare x z = Datatypes.Lt.
Proof.
double induction x y.
simpl in |- *.
intro p.
simple induction z.

*****
z : BDDvar
p : positive
x,y : BDDvar
*****
forall (p0 : positive) (_ : eq Lt Lt) (_ : eq (Pos.compare_cont Eq p p0) Lt), eq Lt Lt
+++++
trivial.
-----
Lemma BDDcompare_trans : forall x y z : BDDvar, BDDcompare x y = Datatypes.Lt -> BDDcompare y z = Datatypes.Lt -> BDDcompare x z = Datatypes.Lt.
Proof.
double induction x y.

*****
x,y : BDDvar
*****
forall (p : positive) (z : BDDvar) (_ : eq (BDDcompare (Npos p) N0) Lt) (_ : eq (BDDcompare N0 z) Lt), eq (BDDcompare (Npos p) z) Lt
+++++
simpl in |- *.
-----
Lemma BDDcompare_trans : forall x y z : BDDvar, BDDcompare x y = Datatypes.Lt -> BDDcompare y z = Datatypes.Lt -> BDDcompare x z = Datatypes.Lt.
Proof.
double induction x y.
simpl in |- *.

*****
x,y : BDDvar
*****
forall (p : positive) (z : BDDvar) (_ : eq Gt Lt) (_ : eq match z with | N0 => Eq | Npos _ => Lt end Lt), eq match z with | N0 => Gt | Npos p2 => Pos.compare_cont Eq p p2 end Lt
+++++
intros p z H H0.
-----
Lemma BDDcompare_trans : forall x y z : BDDvar, BDDcompare x y = Datatypes.Lt -> BDDcompare y z = Datatypes.Lt -> BDDcompare x z = Datatypes.Lt.
Proof.
double induction x y.
simpl in |- *.
intros p z H H0.

*****
H0 : eq match z with\n | N0 => Eq\n | Npos _ => Lt\n end Lt
H : eq Gt Lt
z : BDDvar
p : positive
x,y : BDDvar
*****
eq match z with | N0 => Gt | Npos p2 => Pos.compare_cont Eq p p2 end Lt
+++++
discriminate H.
-----
Lemma BDDcompare_trans : forall x y z : BDDvar, BDDcompare x y = Datatypes.Lt -> BDDcompare y z = Datatypes.Lt -> BDDcompare x z = Datatypes.Lt.
Proof.
double induction x y.

*****
x,y : BDDvar
*****
forall (p p0 : positive) (z : BDDvar) (_ : eq (BDDcompare (Npos p0) (Npos p)) Lt) (_ : eq (BDDcompare (Npos p) z) Lt), eq (BDDcompare (Npos p0) z) Lt
+++++
intro p.
-----
Lemma BDDcompare_trans : forall x y z : BDDvar, BDDcompare x y = Datatypes.Lt -> BDDcompare y z = Datatypes.Lt -> BDDcompare x z = Datatypes.Lt.
Proof.
double induction x y.
intro p.

*****
p : positive
x,y : BDDvar
*****
forall (p0 : positive) (z : BDDvar) (_ : eq (BDDcompare (Npos p0) (Npos p)) Lt) (_ : eq (BDDcompare (Npos p) z) Lt), eq (BDDcompare (Npos p0) z) Lt
+++++
intro p0.
-----
Lemma BDDcompare_trans : forall x y z : BDDvar, BDDcompare x y = Datatypes.Lt -> BDDcompare y z = Datatypes.Lt -> BDDcompare x z = Datatypes.Lt.
Proof.
double induction x y.
intro p.
intro p0.

*****
p,p0 : positive
x,y : BDDvar
*****
forall (z : BDDvar) (_ : eq (BDDcompare (Npos p0) (Npos p)) Lt) (_ : eq (BDDcompare (Npos p) z) Lt), eq (BDDcompare (Npos p0) z) Lt
+++++
simple induction z.
-----
Lemma BDDcompare_trans : forall x y z : BDDvar, BDDcompare x y = Datatypes.Lt -> BDDcompare y z = Datatypes.Lt -> BDDcompare x z = Datatypes.Lt.
Proof.
double induction x y.
intro p.
intro p0.
simple induction z.

*****
z : BDDvar
p,p0 : positive
x,y : BDDvar
*****
forall (_ : eq (BDDcompare (Npos p0) (Npos p)) Lt) (_ : eq (BDDcompare (Npos p) N0) Lt), eq (BDDcompare (Npos p0) N0) Lt
+++++
simpl in |- *.
-----
Lemma BDDcompare_trans : forall x y z : BDDvar, BDDcompare x y = Datatypes.Lt -> BDDcompare y z = Datatypes.Lt -> BDDcompare x z = Datatypes.Lt.
Proof.
double induction x y.
intro p.
intro p0.
simple induction z.
simpl in |- *.

*****
z : BDDvar
p,p0 : positive
x,y : BDDvar
*****
forall (_ : eq (Pos.compare_cont Eq p0 p) Lt) (_ : eq Gt Lt), eq Gt Lt
+++++
trivial.
-----
Lemma BDDcompare_trans : forall x y z : BDDvar, BDDcompare x y = Datatypes.Lt -> BDDcompare y z = Datatypes.Lt -> BDDcompare x z = Datatypes.Lt.
Proof.
double induction x y.
intro p.
intro p0.
simple induction z.

*****
z : BDDvar
p,p0 : positive
x,y : BDDvar
*****
forall (p1 : positive) (_ : eq (BDDcompare (Npos p0) (Npos p)) Lt) (_ : eq (BDDcompare (Npos p) (Npos p1)) Lt), eq (BDDcompare (Npos p0) (Npos p1)) Lt
+++++
intro p1.
-----
Lemma BDDcompare_trans : forall x y z : BDDvar, BDDcompare x y = Datatypes.Lt -> BDDcompare y z = Datatypes.Lt -> BDDcompare x z = Datatypes.Lt.
Proof.
double induction x y.
intro p.
intro p0.
simple induction z.
intro p1.

*****
p1 : positive
z : BDDvar
p,p0 : positive
x,y : BDDvar
*****
forall (_ : eq (BDDcompare (Npos p0) (Npos p)) Lt) (_ : eq (BDDcompare (Npos p) (Npos p1)) Lt), eq (BDDcompare (Npos p0) (Npos p1)) Lt
+++++
simpl in |- *.
-----
Lemma BDDcompare_trans : forall x y z : BDDvar, BDDcompare x y = Datatypes.Lt -> BDDcompare y z = Datatypes.Lt -> BDDcompare x z = Datatypes.Lt.
Proof.
double induction x y.
intro p.
intro p0.
simple induction z.
intro p1.
simpl in |- *.

*****
p1 : positive
z : BDDvar
p,p0 : positive
x,y : BDDvar
*****
forall (_ : eq (Pos.compare_cont Eq p0 p) Lt) (_ : eq (Pos.compare_cont Eq p p1) Lt), eq (Pos.compare_cont Eq p0 p1) Lt
+++++
intros H H0.
-----
Lemma BDDcompare_trans : forall x y z : BDDvar, BDDcompare x y = Datatypes.Lt -> BDDcompare y z = Datatypes.Lt -> BDDcompare x z = Datatypes.Lt.
Proof.
double induction x y.
intro p.
intro p0.
simple induction z.
intro p1.
simpl in |- *.
intros H H0.

*****
H0 : eq (Pos.compare_cont Eq p p1) Lt
H : eq (Pos.compare_cont Eq p0 p) Lt
p1 : positive
z : BDDvar
p,p0 : positive
x,y : BDDvar
*****
eq (Pos.compare_cont Eq p0 p1) Lt
+++++
cut (nat_of_P p0 < nat_of_P p).
-----
Lemma BDDcompare_trans : forall x y z : BDDvar, BDDcompare x y = Datatypes.Lt -> BDDcompare y z = Datatypes.Lt -> BDDcompare x z = Datatypes.Lt.
Proof.
double induction x y.
intro p.
intro p0.
simple induction z.
intro p1.
simpl in |- *.
intros H H0.
cut (nat_of_P p0 < nat_of_P p).

*****
H0 : eq (Pos.compare_cont Eq p p1) Lt
H : eq (Pos.compare_cont Eq p0 p) Lt
p1 : positive
z : BDDvar
p,p0 : positive
x,y : BDDvar
*****
forall _ : lt (Pos.to_nat p0) (Pos.to_nat p), eq (Pos.compare_cont Eq p0 p1) Lt
+++++
cut (nat_of_P p < nat_of_P p1).
-----
Lemma BDDcompare_trans : forall x y z : BDDvar, BDDcompare x y = Datatypes.Lt -> BDDcompare y z = Datatypes.Lt -> BDDcompare x z = Datatypes.Lt.
Proof.
double induction x y.
intro p.
intro p0.
simple induction z.
intro p1.
simpl in |- *.
intros H H0.
cut (nat_of_P p0 < nat_of_P p).
cut (nat_of_P p < nat_of_P p1).

*****
H0 : eq (Pos.compare_cont Eq p p1) Lt
H : eq (Pos.compare_cont Eq p0 p) Lt
p1 : positive
z : BDDvar
p,p0 : positive
x,y : BDDvar
*****
forall (_ : lt (Pos.to_nat p) (Pos.to_nat p1)) (_ : lt (Pos.to_nat p0) (Pos.to_nat p)), eq (Pos.compare_cont Eq p0 p1) Lt
+++++
intros H1 H2.
-----
Lemma BDDcompare_trans : forall x y z : BDDvar, BDDcompare x y = Datatypes.Lt -> BDDcompare y z = Datatypes.Lt -> BDDcompare x z = Datatypes.Lt.
Proof.
double induction x y.
intro p.
intro p0.
simple induction z.
intro p1.
simpl in |- *.
intros H H0.
cut (nat_of_P p0 < nat_of_P p).
cut (nat_of_P p < nat_of_P p1).
intros H1 H2.

*****
H2 : lt (Pos.to_nat p0) (Pos.to_nat p)
H1 : lt (Pos.to_nat p) (Pos.to_nat p1)
H0 : eq (Pos.compare_cont Eq p p1) Lt
H : eq (Pos.compare_cont Eq p0 p) Lt
p1 : positive
z : BDDvar
p,p0 : positive
x,y : BDDvar
*****
eq (Pos.compare_cont Eq p0 p1) Lt
+++++
apply nat_of_P_lt_Lt_compare_complement_morphism.
-----
Lemma BDDcompare_trans : forall x y z : BDDvar, BDDcompare x y = Datatypes.Lt -> BDDcompare y z = Datatypes.Lt -> BDDcompare x z = Datatypes.Lt.
Proof.
double induction x y.
intro p.
intro p0.
simple induction z.
intro p1.
simpl in |- *.
intros H H0.
cut (nat_of_P p0 < nat_of_P p).
cut (nat_of_P p < nat_of_P p1).
intros H1 H2.
apply nat_of_P_lt_Lt_compare_complement_morphism.

*****
H2 : lt (Pos.to_nat p0) (Pos.to_nat p)
H1 : lt (Pos.to_nat p) (Pos.to_nat p1)
H0 : eq (Pos.compare_cont Eq p p1) Lt
H : eq (Pos.compare_cont Eq p0 p) Lt
p1 : positive
z : BDDvar
p,p0 : positive
x,y : BDDvar
*****
lt (Pos.to_nat p0) (Pos.to_nat p1)
+++++
apply lt_trans with (m := nat_of_P p).
-----
Lemma BDDcompare_trans : forall x y z : BDDvar, BDDcompare x y = Datatypes.Lt -> BDDcompare y z = Datatypes.Lt -> BDDcompare x z = Datatypes.Lt.
Proof.
double induction x y.
intro p.
intro p0.
simple induction z.
intro p1.
simpl in |- *.
intros H H0.
cut (nat_of_P p0 < nat_of_P p).
cut (nat_of_P p < nat_of_P p1).
intros H1 H2.
apply nat_of_P_lt_Lt_compare_complement_morphism.
apply lt_trans with (m := nat_of_P p).

*****
H2 : lt (Pos.to_nat p0) (Pos.to_nat p)
H1 : lt (Pos.to_nat p) (Pos.to_nat p1)
H0 : eq (Pos.compare_cont Eq p p1) Lt
H : eq (Pos.compare_cont Eq p0 p) Lt
p1 : positive
z : BDDvar
p,p0 : positive
x,y : BDDvar
*****
lt (Pos.to_nat p0) (Pos.to_nat p)
+++++
assumption.
-----
Lemma BDDcompare_trans : forall x y z : BDDvar, BDDcompare x y = Datatypes.Lt -> BDDcompare y z = Datatypes.Lt -> BDDcompare x z = Datatypes.Lt.
Proof.
double induction x y.
intro p.
intro p0.
simple induction z.
intro p1.
simpl in |- *.
intros H H0.
cut (nat_of_P p0 < nat_of_P p).
cut (nat_of_P p < nat_of_P p1).
intros H1 H2.
apply nat_of_P_lt_Lt_compare_complement_morphism.
apply lt_trans with (m := nat_of_P p).

*****
H2 : lt (Pos.to_nat p0) (Pos.to_nat p)
H1 : lt (Pos.to_nat p) (Pos.to_nat p1)
H0 : eq (Pos.compare_cont Eq p p1) Lt
H : eq (Pos.compare_cont Eq p0 p) Lt
p1 : positive
z : BDDvar
p,p0 : positive
x,y : BDDvar
*****
lt (Pos.to_nat p) (Pos.to_nat p1)
+++++
assumption.
-----
Lemma BDDcompare_trans : forall x y z : BDDvar, BDDcompare x y = Datatypes.Lt -> BDDcompare y z = Datatypes.Lt -> BDDcompare x z = Datatypes.Lt.
Proof.
double induction x y.
intro p.
intro p0.
simple induction z.
intro p1.
simpl in |- *.
intros H H0.
cut (nat_of_P p0 < nat_of_P p).
cut (nat_of_P p < nat_of_P p1).

*****
H0 : eq (Pos.compare_cont Eq p p1) Lt
H : eq (Pos.compare_cont Eq p0 p) Lt
p1 : positive
z : BDDvar
p,p0 : positive
x,y : BDDvar
*****
lt (Pos.to_nat p) (Pos.to_nat p1)
+++++
apply nat_of_P_lt_Lt_compare_morphism.
-----
Lemma BDDcompare_trans : forall x y z : BDDvar, BDDcompare x y = Datatypes.Lt -> BDDcompare y z = Datatypes.Lt -> BDDcompare x z = Datatypes.Lt.
Proof.
double induction x y.
intro p.
intro p0.
simple induction z.
intro p1.
simpl in |- *.
intros H H0.
cut (nat_of_P p0 < nat_of_P p).
cut (nat_of_P p < nat_of_P p1).
apply nat_of_P_lt_Lt_compare_morphism.

*****
H0 : eq (Pos.compare_cont Eq p p1) Lt
H : eq (Pos.compare_cont Eq p0 p) Lt
p1 : positive
z : BDDvar
p,p0 : positive
x,y : BDDvar
*****
eq (Pos.compare_cont Eq p p1) Lt
+++++
assumption.
-----
Lemma BDDcompare_trans : forall x y z : BDDvar, BDDcompare x y = Datatypes.Lt -> BDDcompare y z = Datatypes.Lt -> BDDcompare x z = Datatypes.Lt.
Proof.
double induction x y.
intro p.
intro p0.
simple induction z.
intro p1.
simpl in |- *.
intros H H0.
cut (nat_of_P p0 < nat_of_P p).

*****
H0 : eq (Pos.compare_cont Eq p p1) Lt
H : eq (Pos.compare_cont Eq p0 p) Lt
p1 : positive
z : BDDvar
p,p0 : positive
x,y : BDDvar
*****
lt (Pos.to_nat p0) (Pos.to_nat p)
+++++
apply nat_of_P_lt_Lt_compare_morphism.
-----
Lemma BDDcompare_trans : forall x y z : BDDvar, BDDcompare x y = Datatypes.Lt -> BDDcompare y z = Datatypes.Lt -> BDDcompare x z = Datatypes.Lt.
Proof.
double induction x y.
intro p.
intro p0.
simple induction z.
intro p1.
simpl in |- *.
intros H H0.
cut (nat_of_P p0 < nat_of_P p).
apply nat_of_P_lt_Lt_compare_morphism.

*****
H0 : eq (Pos.compare_cont Eq p p1) Lt
H : eq (Pos.compare_cont Eq p0 p) Lt
p1 : positive
z : BDDvar
p,p0 : positive
x,y : BDDvar
*****
eq (Pos.compare_cont Eq p0 p) Lt
+++++
assumption.
-----
Lemma BDDcompare_trans : forall x y z : BDDvar, BDDcompare x y = Datatypes.Lt -> BDDcompare y z = Datatypes.Lt -> BDDcompare x z = Datatypes.Lt.
Proof.
double induction x y.

*****

*****

+++++
Qed.
-----
Lemma ad_S_le_then_le :\n   forall x y : ad, Nleb (ad_S x) y = true -> Nleb x y = true.
-----
Lemma ad_S_le_then_le : forall x y : ad, Nleb (ad_S x) y = true -> Nleb x y = true.

*****

*****
forall (x y : ad) (_ : eq (Nleb (ad_S x) y) true), eq (Nleb x y) true
+++++
Proof.
-----
Lemma ad_S_le_then_le : forall x y : ad, Nleb (ad_S x) y = true -> Nleb x y = true.
Proof.

*****

*****
forall (x y : ad) (_ : eq (Nleb (ad_S x) y) true), eq (Nleb x y) true
+++++
intros x y H.
-----
Lemma ad_S_le_then_le : forall x y : ad, Nleb (ad_S x) y = true -> Nleb x y = true.
Proof.
intros x y H.

*****
H : eq (Nleb (ad_S x) y) true
x,y : ad
*****
eq (Nleb x y) true
+++++
cut (Nleb x (ad_S x) = true).
-----
Lemma ad_S_le_then_le : forall x y : ad, Nleb (ad_S x) y = true -> Nleb x y = true.
Proof.
intros x y H.
cut (Nleb x (ad_S x) = true).

*****
H : eq (Nleb (ad_S x) y) true
x,y : ad
*****
forall _ : eq (Nleb x (ad_S x)) true, eq (Nleb x y) true
+++++
intro H0.
-----
Lemma ad_S_le_then_le : forall x y : ad, Nleb (ad_S x) y = true -> Nleb x y = true.
Proof.
intros x y H.
cut (Nleb x (ad_S x) = true).
intro H0.

*****
H0 : eq (Nleb x (ad_S x)) true
H : eq (Nleb (ad_S x) y) true
x,y : ad
*****
eq (Nleb x y) true
+++++
apply Nleb_trans with (b := ad_S x).
-----
Lemma ad_S_le_then_le : forall x y : ad, Nleb (ad_S x) y = true -> Nleb x y = true.
Proof.
intros x y H.
cut (Nleb x (ad_S x) = true).
intro H0.
apply Nleb_trans with (b := ad_S x).

*****
H0 : eq (Nleb x (ad_S x)) true
H : eq (Nleb (ad_S x) y) true
x,y : ad
*****
eq (Nleb x (ad_S x)) true
+++++
assumption.
-----
Lemma ad_S_le_then_le : forall x y : ad, Nleb (ad_S x) y = true -> Nleb x y = true.
Proof.
intros x y H.
cut (Nleb x (ad_S x) = true).
intro H0.
apply Nleb_trans with (b := ad_S x).

*****
H0 : eq (Nleb x (ad_S x)) true
H : eq (Nleb (ad_S x) y) true
x,y : ad
*****
eq (Nleb (ad_S x) y) true
+++++
assumption.
-----
Lemma ad_S_le_then_le : forall x y : ad, Nleb (ad_S x) y = true -> Nleb x y = true.
Proof.
intros x y H.
cut (Nleb x (ad_S x) = true).

*****
H : eq (Nleb (ad_S x) y) true
x,y : ad
*****
eq (Nleb x (ad_S x)) true
+++++
unfold Nleb in |- *.
-----
Lemma ad_S_le_then_le : forall x y : ad, Nleb (ad_S x) y = true -> Nleb x y = true.
Proof.
intros x y H.
cut (Nleb x (ad_S x) = true).
unfold Nleb in |- *.

*****
H : eq (Nleb (ad_S x) y) true
x,y : ad
*****
eq (Nat.leb (N.to_nat x) (N.to_nat (ad_S x))) true
+++++
apply leb_correct.
-----
Lemma ad_S_le_then_le : forall x y : ad, Nleb (ad_S x) y = true -> Nleb x y = true.
Proof.
intros x y H.
cut (Nleb x (ad_S x) = true).
unfold Nleb in |- *.
apply leb_correct.

*****
H : eq (Nleb (ad_S x) y) true
x,y : ad
*****
le (N.to_nat x) (N.to_nat (ad_S x))
+++++
rewrite (ad_S_is_S x).
-----
Lemma ad_S_le_then_le : forall x y : ad, Nleb (ad_S x) y = true -> Nleb x y = true.
Proof.
intros x y H.
cut (Nleb x (ad_S x) = true).
unfold Nleb in |- *.
apply leb_correct.
rewrite (ad_S_is_S x).

*****
H : eq (Nleb (ad_S x) y) true
x,y : ad
*****
le (N.to_nat x) (S (N.to_nat x))
+++++
apply le_S.
-----
Lemma ad_S_le_then_le : forall x y : ad, Nleb (ad_S x) y = true -> Nleb x y = true.
Proof.
intros x y H.
cut (Nleb x (ad_S x) = true).
unfold Nleb in |- *.
apply leb_correct.
rewrite (ad_S_is_S x).
apply le_S.

*****
H : eq (Nleb (ad_S x) y) true
x,y : ad
*****
le (N.to_nat x) (N.to_nat x)
+++++
apply le_n.
-----
Lemma ad_S_le_then_le : forall x y : ad, Nleb (ad_S x) y = true -> Nleb x y = true.
Proof.
intros x y H.
cut (Nleb x (ad_S x) = true).

*****

*****

+++++
Qed.
-----
Lemma le_then_le_S :\n   forall x y : ad, Nleb x y = true -> Nleb x (ad_S y) = true.
-----
Lemma le_then_le_S : forall x y : ad, Nleb x y = true -> Nleb x (ad_S y) = true.

*****

*****
forall (x y : ad) (_ : eq (Nleb x y) true), eq (Nleb x (ad_S y)) true
+++++
Proof.
-----
Lemma le_then_le_S : forall x y : ad, Nleb x y = true -> Nleb x (ad_S y) = true.
Proof.

*****

*****
forall (x y : ad) (_ : eq (Nleb x y) true), eq (Nleb x (ad_S y)) true
+++++
intros x y H.
-----
Lemma le_then_le_S : forall x y : ad, Nleb x y = true -> Nleb x (ad_S y) = true.
Proof.
intros x y H.

*****
H : eq (Nleb x y) true
x,y : ad
*****
eq (Nleb x (ad_S y)) true
+++++
cut (Nleb y (ad_S y) = true).
-----
Lemma le_then_le_S : forall x y : ad, Nleb x y = true -> Nleb x (ad_S y) = true.
Proof.
intros x y H.
cut (Nleb y (ad_S y) = true).

*****
H : eq (Nleb x y) true
x,y : ad
*****
forall _ : eq (Nleb y (ad_S y)) true, eq (Nleb x (ad_S y)) true
+++++
intro H0.
-----
Lemma le_then_le_S : forall x y : ad, Nleb x y = true -> Nleb x (ad_S y) = true.
Proof.
intros x y H.
cut (Nleb y (ad_S y) = true).
intro H0.

*****
H0 : eq (Nleb y (ad_S y)) true
H : eq (Nleb x y) true
x,y : ad
*****
eq (Nleb x (ad_S y)) true
+++++
apply Nleb_trans with (b := y).
-----
Lemma le_then_le_S : forall x y : ad, Nleb x y = true -> Nleb x (ad_S y) = true.
Proof.
intros x y H.
cut (Nleb y (ad_S y) = true).
intro H0.
apply Nleb_trans with (b := y).

*****
H0 : eq (Nleb y (ad_S y)) true
H : eq (Nleb x y) true
x,y : ad
*****
eq (Nleb x y) true
+++++
assumption.
-----
Lemma le_then_le_S : forall x y : ad, Nleb x y = true -> Nleb x (ad_S y) = true.
Proof.
intros x y H.
cut (Nleb y (ad_S y) = true).
intro H0.
apply Nleb_trans with (b := y).

*****
H0 : eq (Nleb y (ad_S y)) true
H : eq (Nleb x y) true
x,y : ad
*****
eq (Nleb y (ad_S y)) true
+++++
assumption.
-----
Lemma le_then_le_S : forall x y : ad, Nleb x y = true -> Nleb x (ad_S y) = true.
Proof.
intros x y H.
cut (Nleb y (ad_S y) = true).

*****
H : eq (Nleb x y) true
x,y : ad
*****
eq (Nleb y (ad_S y)) true
+++++
unfold Nleb in |- *.
-----
Lemma le_then_le_S : forall x y : ad, Nleb x y = true -> Nleb x (ad_S y) = true.
Proof.
intros x y H.
cut (Nleb y (ad_S y) = true).
unfold Nleb in |- *.

*****
H : eq (Nleb x y) true
x,y : ad
*****
eq (Nat.leb (N.to_nat y) (N.to_nat (ad_S y))) true
+++++
apply leb_correct.
-----
Lemma le_then_le_S : forall x y : ad, Nleb x y = true -> Nleb x (ad_S y) = true.
Proof.
intros x y H.
cut (Nleb y (ad_S y) = true).
unfold Nleb in |- *.
apply leb_correct.

*****
H : eq (Nleb x y) true
x,y : ad
*****
le (N.to_nat y) (N.to_nat (ad_S y))
+++++
rewrite (ad_S_is_S y).
-----
Lemma le_then_le_S : forall x y : ad, Nleb x y = true -> Nleb x (ad_S y) = true.
Proof.
intros x y H.
cut (Nleb y (ad_S y) = true).
unfold Nleb in |- *.
apply leb_correct.
rewrite (ad_S_is_S y).

*****
H : eq (Nleb x y) true
x,y : ad
*****
le (N.to_nat y) (S (N.to_nat y))
+++++
apply le_S.
-----
Lemma le_then_le_S : forall x y : ad, Nleb x y = true -> Nleb x (ad_S y) = true.
Proof.
intros x y H.
cut (Nleb y (ad_S y) = true).
unfold Nleb in |- *.
apply leb_correct.
rewrite (ad_S_is_S y).
apply le_S.

*****
H : eq (Nleb x y) true
x,y : ad
*****
le (N.to_nat y) (N.to_nat y)
+++++
apply le_n.
-----
Lemma le_then_le_S : forall x y : ad, Nleb x y = true -> Nleb x (ad_S y) = true.
Proof.
intros x y H.
cut (Nleb y (ad_S y) = true).

*****

*****

+++++
Qed.
-----
Lemma ad_S_le_then_neq :\n   forall x y : ad, Nleb (ad_S x) y = true -> Neqb x y = false.
-----
Lemma ad_S_le_then_neq : forall x y : ad, Nleb (ad_S x) y = true -> Neqb x y = false.

*****

*****
forall (x y : ad) (_ : eq (Nleb (ad_S x) y) true), eq (N.eqb x y) false
+++++
Proof.
-----
Lemma ad_S_le_then_neq : forall x y : ad, Nleb (ad_S x) y = true -> Neqb x y = false.
Proof.

*****

*****
forall (x y : ad) (_ : eq (Nleb (ad_S x) y) true), eq (N.eqb x y) false
+++++
intros x y H.
-----
Lemma ad_S_le_then_neq : forall x y : ad, Nleb (ad_S x) y = true -> Neqb x y = false.
Proof.
intros x y H.

*****
H : eq (Nleb (ad_S x) y) true
x,y : ad
*****
eq (N.eqb x y) false
+++++
cut (Neqb x y = true \/ Neqb x y = false).
-----
Lemma ad_S_le_then_neq : forall x y : ad, Nleb (ad_S x) y = true -> Neqb x y = false.
Proof.
intros x y H.
cut (Neqb x y = true \\/ Neqb x y = false).

*****
H : eq (Nleb (ad_S x) y) true
x,y : ad
*****
forall _ : or (eq (N.eqb x y) true) (eq (N.eqb x y) false), eq (N.eqb x y) false
+++++
intro H0.
-----
Lemma ad_S_le_then_neq : forall x y : ad, Nleb (ad_S x) y = true -> Neqb x y = false.
Proof.
intros x y H.
cut (Neqb x y = true \\/ Neqb x y = false).
intro H0.

*****
H0 : or (eq (N.eqb x y) true) (eq (N.eqb x y) false)
H : eq (Nleb (ad_S x) y) true
x,y : ad
*****
eq (N.eqb x y) false
+++++
elim H0.
-----
Lemma ad_S_le_then_neq : forall x y : ad, Nleb (ad_S x) y = true -> Neqb x y = false.
Proof.
intros x y H.
cut (Neqb x y = true \\/ Neqb x y = false).
intro H0.
elim H0.

*****
H0 : or (eq (N.eqb x y) true) (eq (N.eqb x y) false)
H : eq (Nleb (ad_S x) y) true
x,y : ad
*****
forall _ : eq (N.eqb x y) true, eq (N.eqb x y) false
+++++
clear H0.
-----
Lemma ad_S_le_then_neq : forall x y : ad, Nleb (ad_S x) y = true -> Neqb x y = false.
Proof.
intros x y H.
cut (Neqb x y = true \\/ Neqb x y = false).
intro H0.
elim H0.
clear H0.

*****
H : eq (Nleb (ad_S x) y) true
x,y : ad
*****
forall _ : eq (N.eqb x y) true, eq (N.eqb x y) false
+++++
intro H0.
-----
Lemma ad_S_le_then_neq : forall x y : ad, Nleb (ad_S x) y = true -> Neqb x y = false.
Proof.
intros x y H.
cut (Neqb x y = true \\/ Neqb x y = false).
intro H0.
elim H0.
clear H0.
intro H0.

*****
H0 : eq (N.eqb x y) true
H : eq (Nleb (ad_S x) y) true
x,y : ad
*****
eq (N.eqb x y) false
+++++
cut (x = y).
-----
Lemma ad_S_le_then_neq : forall x y : ad, Nleb (ad_S x) y = true -> Neqb x y = false.
Proof.
intros x y H.
cut (Neqb x y = true \\/ Neqb x y = false).
intro H0.
elim H0.
clear H0.
intro H0.
cut (x = y).

*****
H0 : eq (N.eqb x y) true
H : eq (Nleb (ad_S x) y) true
x,y : ad
*****
forall _ : eq x y, eq (N.eqb x y) false
+++++
intro H1.
-----
Lemma ad_S_le_then_neq : forall x y : ad, Nleb (ad_S x) y = true -> Neqb x y = false.
Proof.
intros x y H.
cut (Neqb x y = true \\/ Neqb x y = false).
intro H0.
elim H0.
clear H0.
intro H0.
cut (x = y).
intro H1.

*****
H1 : eq x y
H0 : eq (N.eqb x y) true
H : eq (Nleb (ad_S x) y) true
x,y : ad
*****
eq (N.eqb x y) false
+++++
rewrite H1 in H.
-----
Lemma ad_S_le_then_neq : forall x y : ad, Nleb (ad_S x) y = true -> Neqb x y = false.
Proof.
intros x y H.
cut (Neqb x y = true \\/ Neqb x y = false).
intro H0.
elim H0.
clear H0.
intro H0.
cut (x = y).
intro H1.
rewrite H1 in H.

*****
H1 : eq x y
H0 : eq (N.eqb x y) true
H : eq (Nleb (ad_S y) y) true
x,y : ad
*****
eq (N.eqb x y) false
+++++
unfold Nleb in H.
-----
Lemma ad_S_le_then_neq : forall x y : ad, Nleb (ad_S x) y = true -> Neqb x y = false.
Proof.
intros x y H.
cut (Neqb x y = true \\/ Neqb x y = false).
intro H0.
elim H0.
clear H0.
intro H0.
cut (x = y).
intro H1.
rewrite H1 in H.
unfold Nleb in H.

*****
H1 : eq x y
H0 : eq (N.eqb x y) true
H : eq (Nat.leb (N.to_nat (ad_S y)) (N.to_nat y)) true
x,y : ad
*****
eq (N.eqb x y) false
+++++
rewrite (ad_S_is_S y) in H.
-----
Lemma ad_S_le_then_neq : forall x y : ad, Nleb (ad_S x) y = true -> Neqb x y = false.
Proof.
intros x y H.
cut (Neqb x y = true \\/ Neqb x y = false).
intro H0.
elim H0.
clear H0.
intro H0.
cut (x = y).
intro H1.
rewrite H1 in H.
unfold Nleb in H.
rewrite (ad_S_is_S y) in H.

*****
H1 : eq x y
H0 : eq (N.eqb x y) true
H : eq (Nat.leb (S (N.to_nat y)) (N.to_nat y)) true
x,y : ad
*****
eq (N.eqb x y) false
+++++
cut (leb (S (nat_of_N y)) (nat_of_N y) = false).
-----
Lemma ad_S_le_then_neq : forall x y : ad, Nleb (ad_S x) y = true -> Neqb x y = false.
Proof.
intros x y H.
cut (Neqb x y = true \\/ Neqb x y = false).
intro H0.
elim H0.
clear H0.
intro H0.
cut (x = y).
intro H1.
rewrite H1 in H.
unfold Nleb in H.
rewrite (ad_S_is_S y) in H.
cut (leb (S (nat_of_N y)) (nat_of_N y) = false).

*****
H1 : eq x y
H0 : eq (N.eqb x y) true
H : eq (Nat.leb (S (N.to_nat y)) (N.to_nat y)) true
x,y : ad
*****
forall _ : eq (Nat.leb (S (N.to_nat y)) (N.to_nat y)) false, eq (N.eqb x y) false
+++++
rewrite H.
-----
Lemma ad_S_le_then_neq : forall x y : ad, Nleb (ad_S x) y = true -> Neqb x y = false.
Proof.
intros x y H.
cut (Neqb x y = true \\/ Neqb x y = false).
intro H0.
elim H0.
clear H0.
intro H0.
cut (x = y).
intro H1.
rewrite H1 in H.
unfold Nleb in H.
rewrite (ad_S_is_S y) in H.
cut (leb (S (nat_of_N y)) (nat_of_N y) = false).
rewrite H.

*****
H1 : eq x y
H0 : eq (N.eqb x y) true
H : eq (Nat.leb (S (N.to_nat y)) (N.to_nat y)) true
x,y : ad
*****
forall _ : eq true false, eq (N.eqb x y) false
+++++
intro H2.
-----
Lemma ad_S_le_then_neq : forall x y : ad, Nleb (ad_S x) y = true -> Neqb x y = false.
Proof.
intros x y H.
cut (Neqb x y = true \\/ Neqb x y = false).
intro H0.
elim H0.
clear H0.
intro H0.
cut (x = y).
intro H1.
rewrite H1 in H.
unfold Nleb in H.
rewrite (ad_S_is_S y) in H.
cut (leb (S (nat_of_N y)) (nat_of_N y) = false).
rewrite H.
intro H2.

*****
H2 : eq true false
H1 : eq x y
H0 : eq (N.eqb x y) true
H : eq (Nat.leb (S (N.to_nat y)) (N.to_nat y)) true
x,y : ad
*****
eq (N.eqb x y) false
+++++
discriminate H2.
-----
Lemma ad_S_le_then_neq : forall x y : ad, Nleb (ad_S x) y = true -> Neqb x y = false.
Proof.
intros x y H.
cut (Neqb x y = true \\/ Neqb x y = false).
intro H0.
elim H0.
clear H0.
intro H0.
cut (x = y).
intro H1.
rewrite H1 in H.
unfold Nleb in H.
rewrite (ad_S_is_S y) in H.
cut (leb (S (nat_of_N y)) (nat_of_N y) = false).

*****
H1 : eq x y
H0 : eq (N.eqb x y) true
H : eq (Nat.leb (S (N.to_nat y)) (N.to_nat y)) true
x,y : ad
*****
eq (Nat.leb (S (N.to_nat y)) (N.to_nat y)) false
+++++
cut (nat_of_N y < S (nat_of_N y)).
-----
Lemma ad_S_le_then_neq : forall x y : ad, Nleb (ad_S x) y = true -> Neqb x y = false.
Proof.
intros x y H.
cut (Neqb x y = true \\/ Neqb x y = false).
intro H0.
elim H0.
clear H0.
intro H0.
cut (x = y).
intro H1.
rewrite H1 in H.
unfold Nleb in H.
rewrite (ad_S_is_S y) in H.
cut (leb (S (nat_of_N y)) (nat_of_N y) = false).
cut (nat_of_N y < S (nat_of_N y)).

*****
H1 : eq x y
H0 : eq (N.eqb x y) true
H : eq (Nat.leb (S (N.to_nat y)) (N.to_nat y)) true
x,y : ad
*****
forall _ : lt (N.to_nat y) (S (N.to_nat y)), eq (Nat.leb (S (N.to_nat y)) (N.to_nat y)) false
+++++
intro H2.
-----
Lemma ad_S_le_then_neq : forall x y : ad, Nleb (ad_S x) y = true -> Neqb x y = false.
Proof.
intros x y H.
cut (Neqb x y = true \\/ Neqb x y = false).
intro H0.
elim H0.
clear H0.
intro H0.
cut (x = y).
intro H1.
rewrite H1 in H.
unfold Nleb in H.
rewrite (ad_S_is_S y) in H.
cut (leb (S (nat_of_N y)) (nat_of_N y) = false).
cut (nat_of_N y < S (nat_of_N y)).
intro H2.

*****
H2 : lt (N.to_nat y) (S (N.to_nat y))
H1 : eq x y
H0 : eq (N.eqb x y) true
H : eq (Nat.leb (S (N.to_nat y)) (N.to_nat y)) true
x,y : ad
*****
eq (Nat.leb (S (N.to_nat y)) (N.to_nat y)) false
+++++
apply leb_correct_conv.
-----
Lemma ad_S_le_then_neq : forall x y : ad, Nleb (ad_S x) y = true -> Neqb x y = false.
Proof.
intros x y H.
cut (Neqb x y = true \\/ Neqb x y = false).
intro H0.
elim H0.
clear H0.
intro H0.
cut (x = y).
intro H1.
rewrite H1 in H.
unfold Nleb in H.
rewrite (ad_S_is_S y) in H.
cut (leb (S (nat_of_N y)) (nat_of_N y) = false).
cut (nat_of_N y < S (nat_of_N y)).
intro H2.
apply leb_correct_conv.

*****
H2 : lt (N.to_nat y) (S (N.to_nat y))
H1 : eq x y
H0 : eq (N.eqb x y) true
H : eq (Nat.leb (S (N.to_nat y)) (N.to_nat y)) true
x,y : ad
*****
lt (N.to_nat y) (S (N.to_nat y))
+++++
assumption.
-----
Lemma ad_S_le_then_neq : forall x y : ad, Nleb (ad_S x) y = true -> Neqb x y = false.
Proof.
intros x y H.
cut (Neqb x y = true \\/ Neqb x y = false).
intro H0.
elim H0.
clear H0.
intro H0.
cut (x = y).
intro H1.
rewrite H1 in H.
unfold Nleb in H.
rewrite (ad_S_is_S y) in H.
cut (leb (S (nat_of_N y)) (nat_of_N y) = false).
cut (nat_of_N y < S (nat_of_N y)).

*****
H1 : eq x y
H0 : eq (N.eqb x y) true
H : eq (Nat.leb (S (N.to_nat y)) (N.to_nat y)) true
x,y : ad
*****
lt (N.to_nat y) (S (N.to_nat y))
+++++
unfold lt in |- *.
-----
Lemma ad_S_le_then_neq : forall x y : ad, Nleb (ad_S x) y = true -> Neqb x y = false.
Proof.
intros x y H.
cut (Neqb x y = true \\/ Neqb x y = false).
intro H0.
elim H0.
clear H0.
intro H0.
cut (x = y).
intro H1.
rewrite H1 in H.
unfold Nleb in H.
rewrite (ad_S_is_S y) in H.
cut (leb (S (nat_of_N y)) (nat_of_N y) = false).
cut (nat_of_N y < S (nat_of_N y)).
unfold lt in |- *.

*****
H1 : eq x y
H0 : eq (N.eqb x y) true
H : eq (Nat.leb (S (N.to_nat y)) (N.to_nat y)) true
x,y : ad
*****
le (S (N.to_nat y)) (S (N.to_nat y))
+++++
trivial.
-----
Lemma ad_S_le_then_neq : forall x y : ad, Nleb (ad_S x) y = true -> Neqb x y = false.
Proof.
intros x y H.
cut (Neqb x y = true \\/ Neqb x y = false).
intro H0.
elim H0.
clear H0.
intro H0.
cut (x = y).

*****
H0 : eq (N.eqb x y) true
H : eq (Nleb (ad_S x) y) true
x,y : ad
*****
eq x y
+++++
apply Neqb_complete.
-----
Lemma ad_S_le_then_neq : forall x y : ad, Nleb (ad_S x) y = true -> Neqb x y = false.
Proof.
intros x y H.
cut (Neqb x y = true \\/ Neqb x y = false).
intro H0.
elim H0.
clear H0.
intro H0.
cut (x = y).
apply Neqb_complete.

*****
H0 : eq (N.eqb x y) true
H : eq (Nleb (ad_S x) y) true
x,y : ad
*****
eq (N.eqb x y) true
+++++
assumption.
-----
Lemma ad_S_le_then_neq : forall x y : ad, Nleb (ad_S x) y = true -> Neqb x y = false.
Proof.
intros x y H.
cut (Neqb x y = true \\/ Neqb x y = false).
intro H0.
elim H0.

*****
H0 : or (eq (N.eqb x y) true) (eq (N.eqb x y) false)
H : eq (Nleb (ad_S x) y) true
x,y : ad
*****
forall _ : eq (N.eqb x y) false, eq (N.eqb x y) false
+++++
trivial.
-----
Lemma ad_S_le_then_neq : forall x y : ad, Nleb (ad_S x) y = true -> Neqb x y = false.
Proof.
intros x y H.
cut (Neqb x y = true \\/ Neqb x y = false).

*****
H : eq (Nleb (ad_S x) y) true
x,y : ad
*****
or (eq (N.eqb x y) true) (eq (N.eqb x y) false)
+++++
elim (Neqb x y).
-----
Lemma ad_S_le_then_neq : forall x y : ad, Nleb (ad_S x) y = true -> Neqb x y = false.
Proof.
intros x y H.
cut (Neqb x y = true \\/ Neqb x y = false).
elim (Neqb x y).

*****
H : eq (Nleb (ad_S x) y) true
x,y : ad
*****
or (eq true true) (eq true false)
+++++
auto.
-----
Lemma ad_S_le_then_neq : forall x y : ad, Nleb (ad_S x) y = true -> Neqb x y = false.
Proof.
intros x y H.
cut (Neqb x y = true \\/ Neqb x y = false).
elim (Neqb x y).

*****
H : eq (Nleb (ad_S x) y) true
x,y : ad
*****
or (eq false true) (eq false false)
+++++
auto.
-----
Lemma ad_S_le_then_neq : forall x y : ad, Nleb (ad_S x) y = true -> Neqb x y = false.
Proof.
intros x y H.
cut (Neqb x y = true \\/ Neqb x y = false).

*****

*****

+++++
Qed.
-----
Lemma BDDcompare_succ :\n   forall a : BDDvar, BDDcompare a (ad_S a) = Datatypes.Lt.
-----
Lemma BDDcompare_succ : forall a : BDDvar, BDDcompare a (ad_S a) = Datatypes.Lt.

*****

*****
forall a : BDDvar, eq (BDDcompare a (ad_S a)) Lt
+++++
Proof.
-----
Lemma BDDcompare_succ : forall a : BDDvar, BDDcompare a (ad_S a) = Datatypes.Lt.
Proof.

*****

*****
forall a : BDDvar, eq (BDDcompare a (ad_S a)) Lt
+++++
simple induction a.
-----
Lemma BDDcompare_succ : forall a : BDDvar, BDDcompare a (ad_S a) = Datatypes.Lt.
Proof.
simple induction a.

*****
a : BDDvar
*****
eq (BDDcompare N0 (ad_S N0)) Lt
+++++
simpl in |- *.
-----
Lemma BDDcompare_succ : forall a : BDDvar, BDDcompare a (ad_S a) = Datatypes.Lt.
Proof.
simple induction a.
simpl in |- *.

*****
a : BDDvar
*****
eq Lt Lt
+++++
trivial.
-----
Lemma BDDcompare_succ : forall a : BDDvar, BDDcompare a (ad_S a) = Datatypes.Lt.
Proof.
simple induction a.

*****
a : BDDvar
*****
forall p : positive, eq (BDDcompare (Npos p) (ad_S (Npos p))) Lt
+++++
simpl in |- *.
-----
Lemma BDDcompare_succ : forall a : BDDvar, BDDcompare a (ad_S a) = Datatypes.Lt.
Proof.
simple induction a.
simpl in |- *.

*****
a : BDDvar
*****
forall p : positive, eq (Pos.compare_cont Eq p (Pos.succ p)) Lt
+++++
intro p.
-----
Lemma BDDcompare_succ : forall a : BDDvar, BDDcompare a (ad_S a) = Datatypes.Lt.
Proof.
simple induction a.
simpl in |- *.
intro p.

*****
p : positive
a : BDDvar
*****
eq (Pos.compare_cont Eq p (Pos.succ p)) Lt
+++++
cut (nat_of_P p < nat_of_P (Psucc p)).
-----
Lemma BDDcompare_succ : forall a : BDDvar, BDDcompare a (ad_S a) = Datatypes.Lt.
Proof.
simple induction a.
simpl in |- *.
intro p.
cut (nat_of_P p < nat_of_P (Psucc p)).

*****
p : positive
a : BDDvar
*****
forall _ : lt (Pos.to_nat p) (Pos.to_nat (Pos.succ p)), eq (Pos.compare_cont Eq p (Pos.succ p)) Lt
+++++
intro H.
-----
Lemma BDDcompare_succ : forall a : BDDvar, BDDcompare a (ad_S a) = Datatypes.Lt.
Proof.
simple induction a.
simpl in |- *.
intro p.
cut (nat_of_P p < nat_of_P (Psucc p)).
intro H.

*****
H : lt (Pos.to_nat p) (Pos.to_nat (Pos.succ p))
p : positive
a : BDDvar
*****
eq (Pos.compare_cont Eq p (Pos.succ p)) Lt
+++++
apply nat_of_P_lt_Lt_compare_complement_morphism.
-----
Lemma BDDcompare_succ : forall a : BDDvar, BDDcompare a (ad_S a) = Datatypes.Lt.
Proof.
simple induction a.
simpl in |- *.
intro p.
cut (nat_of_P p < nat_of_P (Psucc p)).
intro H.
apply nat_of_P_lt_Lt_compare_complement_morphism.

*****
H : lt (Pos.to_nat p) (Pos.to_nat (Pos.succ p))
p : positive
a : BDDvar
*****
lt (Pos.to_nat p) (Pos.to_nat (Pos.succ p))
+++++
assumption.
-----
Lemma BDDcompare_succ : forall a : BDDvar, BDDcompare a (ad_S a) = Datatypes.Lt.
Proof.
simple induction a.
simpl in |- *.
intro p.
cut (nat_of_P p < nat_of_P (Psucc p)).

*****
p : positive
a : BDDvar
*****
lt (Pos.to_nat p) (Pos.to_nat (Pos.succ p))
+++++
cut (nat_of_P (Psucc p) = 1 + nat_of_P p).
-----
Lemma BDDcompare_succ : forall a : BDDvar, BDDcompare a (ad_S a) = Datatypes.Lt.
Proof.
simple induction a.
simpl in |- *.
intro p.
cut (nat_of_P p < nat_of_P (Psucc p)).
cut (nat_of_P (Psucc p) = 1 + nat_of_P p).

*****
p : positive
a : BDDvar
*****
forall _ : eq (Pos.to_nat (Pos.succ p)) (Init.Nat.add (S O) (Pos.to_nat p)), lt (Pos.to_nat p) (Pos.to_nat (Pos.succ p))
+++++
intro H.
-----
Lemma BDDcompare_succ : forall a : BDDvar, BDDcompare a (ad_S a) = Datatypes.Lt.
Proof.
simple induction a.
simpl in |- *.
intro p.
cut (nat_of_P p < nat_of_P (Psucc p)).
cut (nat_of_P (Psucc p) = 1 + nat_of_P p).
intro H.

*****
H : eq (Pos.to_nat (Pos.succ p)) (Init.Nat.add (S O) (Pos.to_nat p))
p : positive
a : BDDvar
*****
lt (Pos.to_nat p) (Pos.to_nat (Pos.succ p))
+++++
rewrite H.
-----
Lemma BDDcompare_succ : forall a : BDDvar, BDDcompare a (ad_S a) = Datatypes.Lt.
Proof.
simple induction a.
simpl in |- *.
intro p.
cut (nat_of_P p < nat_of_P (Psucc p)).
cut (nat_of_P (Psucc p) = 1 + nat_of_P p).
intro H.
rewrite H.

*****
H : eq (Pos.to_nat (Pos.succ p)) (Init.Nat.add (S O) (Pos.to_nat p))
p : positive
a : BDDvar
*****
lt (Pos.to_nat p) (Init.Nat.add (S O) (Pos.to_nat p))
+++++
simpl in |- *.
-----
Lemma BDDcompare_succ : forall a : BDDvar, BDDcompare a (ad_S a) = Datatypes.Lt.
Proof.
simple induction a.
simpl in |- *.
intro p.
cut (nat_of_P p < nat_of_P (Psucc p)).
cut (nat_of_P (Psucc p) = 1 + nat_of_P p).
intro H.
rewrite H.
simpl in |- *.

*****
H : eq (Pos.to_nat (Pos.succ p)) (Init.Nat.add (S O) (Pos.to_nat p))
p : positive
a : BDDvar
*****
lt (Pos.to_nat p) (S (Pos.to_nat p))
+++++
unfold lt in |- *.
-----
Lemma BDDcompare_succ : forall a : BDDvar, BDDcompare a (ad_S a) = Datatypes.Lt.
Proof.
simple induction a.
simpl in |- *.
intro p.
cut (nat_of_P p < nat_of_P (Psucc p)).
cut (nat_of_P (Psucc p) = 1 + nat_of_P p).
intro H.
rewrite H.
simpl in |- *.
unfold lt in |- *.

*****
H : eq (Pos.to_nat (Pos.succ p)) (Init.Nat.add (S O) (Pos.to_nat p))
p : positive
a : BDDvar
*****
le (S (Pos.to_nat p)) (S (Pos.to_nat p))
+++++
trivial.
-----
Lemma BDDcompare_succ : forall a : BDDvar, BDDcompare a (ad_S a) = Datatypes.Lt.
Proof.
simple induction a.
simpl in |- *.
intro p.
cut (nat_of_P p < nat_of_P (Psucc p)).
cut (nat_of_P (Psucc p) = 1 + nat_of_P p).

*****
p : positive
a : BDDvar
*****
eq (Pos.to_nat (Pos.succ p)) (Init.Nat.add (S O) (Pos.to_nat p))
+++++
unfold nat_of_P in |- *.
-----
Lemma BDDcompare_succ : forall a : BDDvar, BDDcompare a (ad_S a) = Datatypes.Lt.
Proof.
simple induction a.
simpl in |- *.
intro p.
cut (nat_of_P p < nat_of_P (Psucc p)).
cut (nat_of_P (Psucc p) = 1 + nat_of_P p).
unfold nat_of_P in |- *.

*****
p : positive
a : BDDvar
*****
eq (Pos.iter_op nat Init.Nat.add (Pos.succ p) (S O)) (Init.Nat.add (S O) (Pos.iter_op nat Init.Nat.add p (S O)))
+++++
apply Pmult_nat_succ_morphism.
-----
Lemma BDDcompare_succ : forall a : BDDvar, BDDcompare a (ad_S a) = Datatypes.Lt.
Proof.
simple induction a.

*****

*****

+++++
Qed.
-----
Lemma BDDcompare_lt :\n   forall x y : BDDvar,\n   BDDcompare x y = Datatypes.Lt -> nat_of_N x < nat_of_N y.
-----
Lemma BDDcompare_lt : forall x y : BDDvar, BDDcompare x y = Datatypes.Lt -> nat_of_N x < nat_of_N y.

*****

*****
forall (x y : BDDvar) (_ : eq (BDDcompare x y) Lt), lt (N.to_nat x) (N.to_nat y)
+++++
Proof.
-----
Lemma BDDcompare_lt : forall x y : BDDvar, BDDcompare x y = Datatypes.Lt -> nat_of_N x < nat_of_N y.
Proof.

*****

*****
forall (x y : BDDvar) (_ : eq (BDDcompare x y) Lt), lt (N.to_nat x) (N.to_nat y)
+++++
double induction x y.
-----
Lemma BDDcompare_lt : forall x y : BDDvar, BDDcompare x y = Datatypes.Lt -> nat_of_N x < nat_of_N y.
Proof.
double induction x y.

*****
x,y : BDDvar
*****
forall _ : eq (BDDcompare N0 N0) Lt, lt (N.to_nat N0) (N.to_nat N0)
+++++
simpl in |- *.
-----
Lemma BDDcompare_lt : forall x y : BDDvar, BDDcompare x y = Datatypes.Lt -> nat_of_N x < nat_of_N y.
Proof.
double induction x y.
simpl in |- *.

*****
x,y : BDDvar
*****
forall _ : eq Eq Lt, lt O O
+++++
intro H.
-----
Lemma BDDcompare_lt : forall x y : BDDvar, BDDcompare x y = Datatypes.Lt -> nat_of_N x < nat_of_N y.
Proof.
double induction x y.
simpl in |- *.
intro H.

*****
H : eq Eq Lt
x,y : BDDvar
*****
lt O O
+++++
discriminate.
-----
Lemma BDDcompare_lt : forall x y : BDDvar, BDDcompare x y = Datatypes.Lt -> nat_of_N x < nat_of_N y.
Proof.
double induction x y.

*****
x,y : BDDvar
*****
forall (p : positive) (_ : eq (BDDcompare N0 (Npos p)) Lt), lt (N.to_nat N0) (N.to_nat (Npos p))
+++++
simpl in |- *.
-----
Lemma BDDcompare_lt : forall x y : BDDvar, BDDcompare x y = Datatypes.Lt -> nat_of_N x < nat_of_N y.
Proof.
double induction x y.
simpl in |- *.

*****
x,y : BDDvar
*****
forall (p : positive) (_ : eq Lt Lt), lt O (Pos.to_nat p)
+++++
intros p H.
-----
Lemma BDDcompare_lt : forall x y : BDDvar, BDDcompare x y = Datatypes.Lt -> nat_of_N x < nat_of_N y.
Proof.
double induction x y.
simpl in |- *.
intros p H.

*****
H : eq Lt Lt
p : positive
x,y : BDDvar
*****
lt O (Pos.to_nat p)
+++++
cut (exists h : nat, nat_of_P p = S h).
-----
Lemma BDDcompare_lt : forall x y : BDDvar, BDDcompare x y = Datatypes.Lt -> nat_of_N x < nat_of_N y.
Proof.
double induction x y.
simpl in |- *.
intros p H.
cut (exists h : nat, nat_of_P p = S h).

*****
H : eq Lt Lt
p : positive
x,y : BDDvar
*****
forall _ : ex (fun h : nat => eq (Pos.to_nat p) (S h)), lt O (Pos.to_nat p)
+++++
intro H0.
-----
Lemma BDDcompare_lt : forall x y : BDDvar, BDDcompare x y = Datatypes.Lt -> nat_of_N x < nat_of_N y.
Proof.
double induction x y.
simpl in |- *.
intros p H.
cut (exists h : nat, nat_of_P p = S h).
intro H0.

*****
H0 : ex (fun h : nat => eq (Pos.to_nat p) (S h))
H : eq Lt Lt
p : positive
x,y : BDDvar
*****
lt O (Pos.to_nat p)
+++++
inversion H0.
-----
Lemma BDDcompare_lt : forall x y : BDDvar, BDDcompare x y = Datatypes.Lt -> nat_of_N x < nat_of_N y.
Proof.
double induction x y.
simpl in |- *.
intros p H.
cut (exists h : nat, nat_of_P p = S h).
intro H0.
inversion H0.

*****
H1 : eq (Pos.to_nat p) (S x0)
x0 : nat
H0 : ex (fun h : nat => eq (Pos.to_nat p) (S h))
H : eq Lt Lt
p : positive
x,y : BDDvar
*****
lt O (Pos.to_nat p)
+++++
rewrite H1.
-----
Lemma BDDcompare_lt : forall x y : BDDvar, BDDcompare x y = Datatypes.Lt -> nat_of_N x < nat_of_N y.
Proof.
double induction x y.
simpl in |- *.
intros p H.
cut (exists h : nat, nat_of_P p = S h).
intro H0.
inversion H0.
rewrite H1.

*****
H1 : eq (Pos.to_nat p) (S x0)
x0 : nat
H0 : ex (fun h : nat => eq (Pos.to_nat p) (S h))
H : eq Lt Lt
p : positive
x,y : BDDvar
*****
lt O (S x0)
+++++
apply lt_O_Sn.
-----
Lemma BDDcompare_lt : forall x y : BDDvar, BDDcompare x y = Datatypes.Lt -> nat_of_N x < nat_of_N y.
Proof.
double induction x y.
simpl in |- *.
intros p H.
cut (exists h : nat, nat_of_P p = S h).

*****
H : eq Lt Lt
p : positive
x,y : BDDvar
*****
ex (fun h : nat => eq (Pos.to_nat p) (S h))
+++++
apply ZL4.
-----
Lemma BDDcompare_lt : forall x y : BDDvar, BDDcompare x y = Datatypes.Lt -> nat_of_N x < nat_of_N y.
Proof.
double induction x y.

*****
x,y : BDDvar
*****
forall (p : positive) (_ : eq (BDDcompare (Npos p) N0) Lt), lt (N.to_nat (Npos p)) (N.to_nat N0)
+++++
simpl in |- *.
-----
Lemma BDDcompare_lt : forall x y : BDDvar, BDDcompare x y = Datatypes.Lt -> nat_of_N x < nat_of_N y.
Proof.
double induction x y.
simpl in |- *.

*****
x,y : BDDvar
*****
forall (p : positive) (_ : eq Gt Lt), lt (Pos.to_nat p) O
+++++
intros p H.
-----
Lemma BDDcompare_lt : forall x y : BDDvar, BDDcompare x y = Datatypes.Lt -> nat_of_N x < nat_of_N y.
Proof.
double induction x y.
simpl in |- *.
intros p H.

*****
H : eq Gt Lt
p : positive
x,y : BDDvar
*****
lt (Pos.to_nat p) O
+++++
discriminate.
-----
Lemma BDDcompare_lt : forall x y : BDDvar, BDDcompare x y = Datatypes.Lt -> nat_of_N x < nat_of_N y.
Proof.
double induction x y.

*****
x,y : BDDvar
*****
forall (p p0 : positive) (_ : eq (BDDcompare (Npos p0) (Npos p)) Lt), lt (N.to_nat (Npos p0)) (N.to_nat (Npos p))
+++++
simpl in |- *.
-----
Lemma BDDcompare_lt : forall x y : BDDvar, BDDcompare x y = Datatypes.Lt -> nat_of_N x < nat_of_N y.
Proof.
double induction x y.
simpl in |- *.

*****
x,y : BDDvar
*****
forall (p p0 : positive) (_ : eq (Pos.compare_cont Eq p0 p) Lt), lt (Pos.to_nat p0) (Pos.to_nat p)
+++++
intros p p0 H.
-----
Lemma BDDcompare_lt : forall x y : BDDvar, BDDcompare x y = Datatypes.Lt -> nat_of_N x < nat_of_N y.
Proof.
double induction x y.
simpl in |- *.
intros p p0 H.

*****
H : eq (Pos.compare_cont Eq p0 p) Lt
p,p0 : positive
x,y : BDDvar
*****
lt (Pos.to_nat p0) (Pos.to_nat p)
+++++
apply nat_of_P_lt_Lt_compare_morphism.
-----
Lemma BDDcompare_lt : forall x y : BDDvar, BDDcompare x y = Datatypes.Lt -> nat_of_N x < nat_of_N y.
Proof.
double induction x y.
simpl in |- *.
intros p p0 H.
apply nat_of_P_lt_Lt_compare_morphism.

*****
H : eq (Pos.compare_cont Eq p0 p) Lt
p,p0 : positive
x,y : BDDvar
*****
eq (Pos.compare_cont Eq p0 p) Lt
+++++
assumption.
-----
Lemma BDDcompare_lt : forall x y : BDDvar, BDDcompare x y = Datatypes.Lt -> nat_of_N x < nat_of_N y.
Proof.
double induction x y.

*****

*****

+++++
Qed.
-----
Lemma BDDlt_compare :\n forall x y : BDDvar,\n nat_of_N x < nat_of_N y -> BDDcompare x y = Datatypes.Lt.
-----
Lemma BDDlt_compare : forall x y : BDDvar, nat_of_N x < nat_of_N y -> BDDcompare x y = Datatypes.Lt.

*****

*****
forall (x y : BDDvar) (_ : lt (N.to_nat x) (N.to_nat y)), eq (BDDcompare x y) Lt
+++++
Proof.
-----
Lemma BDDlt_compare : forall x y : BDDvar, nat_of_N x < nat_of_N y -> BDDcompare x y = Datatypes.Lt.
Proof.

*****

*****
forall (x y : BDDvar) (_ : lt (N.to_nat x) (N.to_nat y)), eq (BDDcompare x y) Lt
+++++
double induction x y.
-----
Lemma BDDlt_compare : forall x y : BDDvar, nat_of_N x < nat_of_N y -> BDDcompare x y = Datatypes.Lt.
Proof.
double induction x y.

*****
x,y : BDDvar
*****
forall _ : lt (N.to_nat N0) (N.to_nat N0), eq (BDDcompare N0 N0) Lt
+++++
simpl in |- *.
-----
Lemma BDDlt_compare : forall x y : BDDvar, nat_of_N x < nat_of_N y -> BDDcompare x y = Datatypes.Lt.
Proof.
double induction x y.
simpl in |- *.

*****
x,y : BDDvar
*****
forall _ : lt O O, eq Eq Lt
+++++
intro H.
-----
Lemma BDDlt_compare : forall x y : BDDvar, nat_of_N x < nat_of_N y -> BDDcompare x y = Datatypes.Lt.
Proof.
double induction x y.
simpl in |- *.
intro H.

*****
H : lt O O
x,y : BDDvar
*****
eq Eq Lt
+++++
absurd (0 < 0).
-----
Lemma BDDlt_compare : forall x y : BDDvar, nat_of_N x < nat_of_N y -> BDDcompare x y = Datatypes.Lt.
Proof.
double induction x y.
simpl in |- *.
intro H.
absurd (0 < 0).

*****
H : lt O O
x,y : BDDvar
*****
not (lt O O)
+++++
apply lt_n_O.
-----
Lemma BDDlt_compare : forall x y : BDDvar, nat_of_N x < nat_of_N y -> BDDcompare x y = Datatypes.Lt.
Proof.
double induction x y.
simpl in |- *.
intro H.
absurd (0 < 0).

*****
H : lt O O
x,y : BDDvar
*****
lt O O
+++++
assumption.
-----
Lemma BDDlt_compare : forall x y : BDDvar, nat_of_N x < nat_of_N y -> BDDcompare x y = Datatypes.Lt.
Proof.
double induction x y.

*****
x,y : BDDvar
*****
forall (p : positive) (_ : lt (N.to_nat N0) (N.to_nat (Npos p))), eq (BDDcompare N0 (Npos p)) Lt
+++++
simpl in |- *.
-----
Lemma BDDlt_compare : forall x y : BDDvar, nat_of_N x < nat_of_N y -> BDDcompare x y = Datatypes.Lt.
Proof.
double induction x y.
simpl in |- *.

*****
x,y : BDDvar
*****
forall (p : positive) (_ : lt O (Pos.to_nat p)), eq Lt Lt
+++++
reflexivity.
-----
Lemma BDDlt_compare : forall x y : BDDvar, nat_of_N x < nat_of_N y -> BDDcompare x y = Datatypes.Lt.
Proof.
double induction x y.

*****
x,y : BDDvar
*****
forall (p : positive) (_ : lt (N.to_nat (Npos p)) (N.to_nat N0)), eq (BDDcompare (Npos p) N0) Lt
+++++
simpl in |- *.
-----
Lemma BDDlt_compare : forall x y : BDDvar, nat_of_N x < nat_of_N y -> BDDcompare x y = Datatypes.Lt.
Proof.
double induction x y.
simpl in |- *.

*****
x,y : BDDvar
*****
forall (p : positive) (_ : lt (Pos.to_nat p) O), eq Gt Lt
+++++
intro p.
-----
Lemma BDDlt_compare : forall x y : BDDvar, nat_of_N x < nat_of_N y -> BDDcompare x y = Datatypes.Lt.
Proof.
double induction x y.
simpl in |- *.
intro p.

*****
p : positive
x,y : BDDvar
*****
forall _ : lt (Pos.to_nat p) O, eq Gt Lt
+++++
cut (exists h : nat, nat_of_P p = S h).
-----
Lemma BDDlt_compare : forall x y : BDDvar, nat_of_N x < nat_of_N y -> BDDcompare x y = Datatypes.Lt.
Proof.
double induction x y.
simpl in |- *.
intro p.
cut (exists h : nat, nat_of_P p = S h).

*****
p : positive
x,y : BDDvar
*****
forall (_ : ex (fun h : nat => eq (Pos.to_nat p) (S h))) (_ : lt (Pos.to_nat p) O), eq Gt Lt
+++++
intro H.
-----
Lemma BDDlt_compare : forall x y : BDDvar, nat_of_N x < nat_of_N y -> BDDcompare x y = Datatypes.Lt.
Proof.
double induction x y.
simpl in |- *.
intro p.
cut (exists h : nat, nat_of_P p = S h).
intro H.

*****
H : ex (fun h : nat => eq (Pos.to_nat p) (S h))
p : positive
x,y : BDDvar
*****
forall _ : lt (Pos.to_nat p) O, eq Gt Lt
+++++
inversion H.
-----
Lemma BDDlt_compare : forall x y : BDDvar, nat_of_N x < nat_of_N y -> BDDcompare x y = Datatypes.Lt.
Proof.
double induction x y.
simpl in |- *.
intro p.
cut (exists h : nat, nat_of_P p = S h).
intro H.
inversion H.

*****
H0 : eq (Pos.to_nat p) (S x0)
x0 : nat
H : ex (fun h : nat => eq (Pos.to_nat p) (S h))
p : positive
x,y : BDDvar
*****
forall _ : lt (Pos.to_nat p) O, eq Gt Lt
+++++
rewrite H0.
-----
Lemma BDDlt_compare : forall x y : BDDvar, nat_of_N x < nat_of_N y -> BDDcompare x y = Datatypes.Lt.
Proof.
double induction x y.
simpl in |- *.
intro p.
cut (exists h : nat, nat_of_P p = S h).
intro H.
inversion H.
rewrite H0.

*****
H0 : eq (Pos.to_nat p) (S x0)
x0 : nat
H : ex (fun h : nat => eq (Pos.to_nat p) (S h))
p : positive
x,y : BDDvar
*****
forall _ : lt (S x0) O, eq Gt Lt
+++++
intro H1.
-----
Lemma BDDlt_compare : forall x y : BDDvar, nat_of_N x < nat_of_N y -> BDDcompare x y = Datatypes.Lt.
Proof.
double induction x y.
simpl in |- *.
intro p.
cut (exists h : nat, nat_of_P p = S h).
intro H.
inversion H.
rewrite H0.
intro H1.

*****
H1 : lt (S x0) O
H0 : eq (Pos.to_nat p) (S x0)
x0 : nat
H : ex (fun h : nat => eq (Pos.to_nat p) (S h))
p : positive
x,y : BDDvar
*****
eq Gt Lt
+++++
absurd (S x0 < 0).
-----
Lemma BDDlt_compare : forall x y : BDDvar, nat_of_N x < nat_of_N y -> BDDcompare x y = Datatypes.Lt.
Proof.
double induction x y.
simpl in |- *.
intro p.
cut (exists h : nat, nat_of_P p = S h).
intro H.
inversion H.
rewrite H0.
intro H1.
absurd (S x0 < 0).

*****
H1 : lt (S x0) O
H0 : eq (Pos.to_nat p) (S x0)
x0 : nat
H : ex (fun h : nat => eq (Pos.to_nat p) (S h))
p : positive
x,y : BDDvar
*****
not (lt (S x0) O)
+++++
apply lt_n_O.
-----
Lemma BDDlt_compare : forall x y : BDDvar, nat_of_N x < nat_of_N y -> BDDcompare x y = Datatypes.Lt.
Proof.
double induction x y.
simpl in |- *.
intro p.
cut (exists h : nat, nat_of_P p = S h).
intro H.
inversion H.
rewrite H0.
intro H1.
absurd (S x0 < 0).

*****
H1 : lt (S x0) O
H0 : eq (Pos.to_nat p) (S x0)
x0 : nat
H : ex (fun h : nat => eq (Pos.to_nat p) (S h))
p : positive
x,y : BDDvar
*****
lt (S x0) O
+++++
assumption.
-----
Lemma BDDlt_compare : forall x y : BDDvar, nat_of_N x < nat_of_N y -> BDDcompare x y = Datatypes.Lt.
Proof.
double induction x y.
simpl in |- *.
intro p.
cut (exists h : nat, nat_of_P p = S h).

*****
p : positive
x,y : BDDvar
*****
ex (fun h : nat => eq (Pos.to_nat p) (S h))
+++++
apply ZL4.
-----
Lemma BDDlt_compare : forall x y : BDDvar, nat_of_N x < nat_of_N y -> BDDcompare x y = Datatypes.Lt.
Proof.
double induction x y.

*****
x,y : BDDvar
*****
forall (p p0 : positive) (_ : lt (N.to_nat (Npos p0)) (N.to_nat (Npos p))), eq (BDDcompare (Npos p0) (Npos p)) Lt
+++++
simpl in |- *.
-----
Lemma BDDlt_compare : forall x y : BDDvar, nat_of_N x < nat_of_N y -> BDDcompare x y = Datatypes.Lt.
Proof.
double induction x y.
simpl in |- *.

*****
x,y : BDDvar
*****
forall (p p0 : positive) (_ : lt (Pos.to_nat p0) (Pos.to_nat p)), eq (Pos.compare_cont Eq p0 p) Lt
+++++
intro p.
-----
Lemma BDDlt_compare : forall x y : BDDvar, nat_of_N x < nat_of_N y -> BDDcompare x y = Datatypes.Lt.
Proof.
double induction x y.
simpl in |- *.
intro p.

*****
p : positive
x,y : BDDvar
*****
forall (p0 : positive) (_ : lt (Pos.to_nat p0) (Pos.to_nat p)), eq (Pos.compare_cont Eq p0 p) Lt
+++++
intros p0 H.
-----
Lemma BDDlt_compare : forall x y : BDDvar, nat_of_N x < nat_of_N y -> BDDcompare x y = Datatypes.Lt.
Proof.
double induction x y.
simpl in |- *.
intro p.
intros p0 H.

*****
H : lt (Pos.to_nat p0) (Pos.to_nat p)
p,p0 : positive
x,y : BDDvar
*****
eq (Pos.compare_cont Eq p0 p) Lt
+++++
apply nat_of_P_lt_Lt_compare_complement_morphism.
-----
Lemma BDDlt_compare : forall x y : BDDvar, nat_of_N x < nat_of_N y -> BDDcompare x y = Datatypes.Lt.
Proof.
double induction x y.
simpl in |- *.
intro p.
intros p0 H.
apply nat_of_P_lt_Lt_compare_complement_morphism.

*****
H : lt (Pos.to_nat p0) (Pos.to_nat p)
p,p0 : positive
x,y : BDDvar
*****
lt (Pos.to_nat p0) (Pos.to_nat p)
+++++
assumption.
-----
Lemma BDDlt_compare : forall x y : BDDvar, nat_of_N x < nat_of_N y -> BDDcompare x y = Datatypes.Lt.
Proof.
double induction x y.

*****

*****

+++++
Qed.
-----
Lemma relation_sum :\n forall r : Datatypes.comparison,\n {r = Datatypes.Eq} + {r = Datatypes.Lt} + {r = Datatypes.Gt}.
-----
Lemma relation_sum : forall r : Datatypes.comparison, {r = Datatypes.Eq} + {r = Datatypes.Lt} + {r = Datatypes.Gt}.

*****

*****
forall r : comparison, sumor (sumbool (eq r Eq) (eq r Lt)) (eq r Gt)
+++++
Proof.
-----
Lemma relation_sum : forall r : Datatypes.comparison, {r = Datatypes.Eq} + {r = Datatypes.Lt} + {r = Datatypes.Gt}.
Proof.

*****

*****
forall r : comparison, sumor (sumbool (eq r Eq) (eq r Lt)) (eq r Gt)
+++++
intro r.
-----
Lemma relation_sum : forall r : Datatypes.comparison, {r = Datatypes.Eq} + {r = Datatypes.Lt} + {r = Datatypes.Gt}.
Proof.
intro r.

*****
r : comparison
*****
sumor (sumbool (eq r Eq) (eq r Lt)) (eq r Gt)
+++++
elim r.
-----
Lemma relation_sum : forall r : Datatypes.comparison, {r = Datatypes.Eq} + {r = Datatypes.Lt} + {r = Datatypes.Gt}.
Proof.
intro r.
elim r.

*****
r : comparison
*****
sumor (sumbool (eq Eq Eq) (eq Eq Lt)) (eq Eq Gt)
+++++
left.
-----
Lemma relation_sum : forall r : Datatypes.comparison, {r = Datatypes.Eq} + {r = Datatypes.Lt} + {r = Datatypes.Gt}.
Proof.
intro r.
elim r.
left.

*****
r : comparison
*****
sumbool (eq Eq Eq) (eq Eq Lt)
+++++
left.
-----
Lemma relation_sum : forall r : Datatypes.comparison, {r = Datatypes.Eq} + {r = Datatypes.Lt} + {r = Datatypes.Gt}.
Proof.
intro r.
elim r.
left.
left.

*****
r : comparison
*****
eq Eq Eq
+++++
reflexivity.
-----
Lemma relation_sum : forall r : Datatypes.comparison, {r = Datatypes.Eq} + {r = Datatypes.Lt} + {r = Datatypes.Gt}.
Proof.
intro r.
elim r.

*****
r : comparison
*****
sumor (sumbool (eq Lt Eq) (eq Lt Lt)) (eq Lt Gt)
+++++
left.
-----
Lemma relation_sum : forall r : Datatypes.comparison, {r = Datatypes.Eq} + {r = Datatypes.Lt} + {r = Datatypes.Gt}.
Proof.
intro r.
elim r.
left.

*****
r : comparison
*****
sumbool (eq Lt Eq) (eq Lt Lt)
+++++
right.
-----
Lemma relation_sum : forall r : Datatypes.comparison, {r = Datatypes.Eq} + {r = Datatypes.Lt} + {r = Datatypes.Gt}.
Proof.
intro r.
elim r.
left.
right.

*****
r : comparison
*****
eq Lt Lt
+++++
reflexivity.
-----
Lemma relation_sum : forall r : Datatypes.comparison, {r = Datatypes.Eq} + {r = Datatypes.Lt} + {r = Datatypes.Gt}.
Proof.
intro r.
elim r.

*****
r : comparison
*****
sumor (sumbool (eq Gt Eq) (eq Gt Lt)) (eq Gt Gt)
+++++
right.
-----
Lemma relation_sum : forall r : Datatypes.comparison, {r = Datatypes.Eq} + {r = Datatypes.Lt} + {r = Datatypes.Gt}.
Proof.
intro r.
elim r.
right.

*****
r : comparison
*****
eq Gt Gt
+++++
reflexivity.
-----
Lemma relation_sum : forall r : Datatypes.comparison, {r = Datatypes.Eq} + {r = Datatypes.Lt} + {r = Datatypes.Gt}.
Proof.
intro r.
elim r.

*****

*****

+++++
Qed.
-----
Lemma BDD_EGAL_complete :\n forall x y : BDDvar, BDDcompare x y = Datatypes.Eq -> x = y.
-----
Lemma BDD_EGAL_complete : forall x y : BDDvar, BDDcompare x y = Datatypes.Eq -> x = y.

*****

*****
forall (x y : BDDvar) (_ : eq (BDDcompare x y) Eq), eq x y
+++++
Proof.
-----
Lemma BDD_EGAL_complete : forall x y : BDDvar, BDDcompare x y = Datatypes.Eq -> x = y.
Proof.

*****

*****
forall (x y : BDDvar) (_ : eq (BDDcompare x y) Eq), eq x y
+++++
double induction x y.
-----
Lemma BDD_EGAL_complete : forall x y : BDDvar, BDDcompare x y = Datatypes.Eq -> x = y.
Proof.
double induction x y.

*****
x,y : BDDvar
*****
forall _ : eq (BDDcompare N0 N0) Eq, eq N0 N0
+++++
reflexivity.
-----
Lemma BDD_EGAL_complete : forall x y : BDDvar, BDDcompare x y = Datatypes.Eq -> x = y.
Proof.
double induction x y.

*****
x,y : BDDvar
*****
forall (p : positive) (_ : eq (BDDcompare N0 (Npos p)) Eq), eq N0 (Npos p)
+++++
simpl in |- *.
-----
Lemma BDD_EGAL_complete : forall x y : BDDvar, BDDcompare x y = Datatypes.Eq -> x = y.
Proof.
double induction x y.
simpl in |- *.

*****
x,y : BDDvar
*****
forall (p : positive) (_ : eq Lt Eq), eq N0 (Npos p)
+++++
intros.
-----
Lemma BDD_EGAL_complete : forall x y : BDDvar, BDDcompare x y = Datatypes.Eq -> x = y.
Proof.
double induction x y.
simpl in |- *.
intros.

*****
H : eq Lt Eq
p : positive
x,y : BDDvar
*****
eq N0 (Npos p)
+++++
discriminate.
-----
Lemma BDD_EGAL_complete : forall x y : BDDvar, BDDcompare x y = Datatypes.Eq -> x = y.
Proof.
double induction x y.

*****
x,y : BDDvar
*****
forall (p : positive) (_ : eq (BDDcompare (Npos p) N0) Eq), eq (Npos p) N0
+++++
simpl in |- *.
-----
Lemma BDD_EGAL_complete : forall x y : BDDvar, BDDcompare x y = Datatypes.Eq -> x = y.
Proof.
double induction x y.
simpl in |- *.

*****
x,y : BDDvar
*****
forall (p : positive) (_ : eq Gt Eq), eq (Npos p) N0
+++++
intros.
-----
Lemma BDD_EGAL_complete : forall x y : BDDvar, BDDcompare x y = Datatypes.Eq -> x = y.
Proof.
double induction x y.
simpl in |- *.
intros.

*****
H : eq Gt Eq
p : positive
x,y : BDDvar
*****
eq (Npos p) N0
+++++
discriminate.
-----
Lemma BDD_EGAL_complete : forall x y : BDDvar, BDDcompare x y = Datatypes.Eq -> x = y.
Proof.
double induction x y.

*****
x,y : BDDvar
*****
forall (p p0 : positive) (_ : eq (BDDcompare (Npos p0) (Npos p)) Eq), eq (Npos p0) (Npos p)
+++++
simpl in |- *.
-----
Lemma BDD_EGAL_complete : forall x y : BDDvar, BDDcompare x y = Datatypes.Eq -> x = y.
Proof.
double induction x y.
simpl in |- *.

*****
x,y : BDDvar
*****
forall (p p0 : positive) (_ : eq (Pos.compare_cont Eq p0 p) Eq), eq (Npos p0) (Npos p)
+++++
intros p p0 H.
-----
Lemma BDD_EGAL_complete : forall x y : BDDvar, BDDcompare x y = Datatypes.Eq -> x = y.
Proof.
double induction x y.
simpl in |- *.
intros p p0 H.

*****
H : eq (Pos.compare_cont Eq p0 p) Eq
p,p0 : positive
x,y : BDDvar
*****
eq (Npos p0) (Npos p)
+++++
cut (p0 = p).
-----
Lemma BDD_EGAL_complete : forall x y : BDDvar, BDDcompare x y = Datatypes.Eq -> x = y.
Proof.
double induction x y.
simpl in |- *.
intros p p0 H.
cut (p0 = p).

*****
H : eq (Pos.compare_cont Eq p0 p) Eq
p,p0 : positive
x,y : BDDvar
*****
forall _ : eq p0 p, eq (Npos p0) (Npos p)
+++++
intro H0.
-----
Lemma BDD_EGAL_complete : forall x y : BDDvar, BDDcompare x y = Datatypes.Eq -> x = y.
Proof.
double induction x y.
simpl in |- *.
intros p p0 H.
cut (p0 = p).
intro H0.

*****
H0 : eq p0 p
H : eq (Pos.compare_cont Eq p0 p) Eq
p,p0 : positive
x,y : BDDvar
*****
eq (Npos p0) (Npos p)
+++++
rewrite H0.
-----
Lemma BDD_EGAL_complete : forall x y : BDDvar, BDDcompare x y = Datatypes.Eq -> x = y.
Proof.
double induction x y.
simpl in |- *.
intros p p0 H.
cut (p0 = p).
intro H0.
rewrite H0.

*****
H0 : eq p0 p
H : eq (Pos.compare_cont Eq p0 p) Eq
p,p0 : positive
x,y : BDDvar
*****
eq (Npos p) (Npos p)
+++++
reflexivity.
-----
Lemma BDD_EGAL_complete : forall x y : BDDvar, BDDcompare x y = Datatypes.Eq -> x = y.
Proof.
double induction x y.
simpl in |- *.
intros p p0 H.
cut (p0 = p).

*****
H : eq (Pos.compare_cont Eq p0 p) Eq
p,p0 : positive
x,y : BDDvar
*****
eq p0 p
+++++
apply Pcompare_Eq_eq.
-----
Lemma BDD_EGAL_complete : forall x y : BDDvar, BDDcompare x y = Datatypes.Eq -> x = y.
Proof.
double induction x y.
simpl in |- *.
intros p p0 H.
cut (p0 = p).
apply Pcompare_Eq_eq.

*****
H : eq (Pos.compare_cont Eq p0 p) Eq
p,p0 : positive
x,y : BDDvar
*****
eq (Pos.compare_cont Eq p0 p) Eq
+++++
assumption.
-----
Lemma BDD_EGAL_complete : forall x y : BDDvar, BDDcompare x y = Datatypes.Eq -> x = y.
Proof.
double induction x y.

*****

*****

+++++
Qed.
-----
Lemma lt_trans_1 : forall x y z : nat, x < y -> y < S z -> x < z.
-----
Lemma lt_trans_1 : forall x y z : nat, x < y -> y < S z -> x < z.

*****

*****
forall (x y z : nat) (_ : lt x y) (_ : lt y (S z)), lt x z
+++++
Proof.
-----
Lemma lt_trans_1 : forall x y z : nat, x < y -> y < S z -> x < z.
Proof.

*****

*****
forall (x y z : nat) (_ : lt x y) (_ : lt y (S z)), lt x z
+++++
intros x y z H H0.
-----
Lemma lt_trans_1 : forall x y z : nat, x < y -> y < S z -> x < z.
Proof.
intros x y z H H0.

*****
H0 : lt y (S z)
H : lt x y
x,y,z : nat
*****
lt x z
+++++
unfold lt in H0.
-----
Lemma lt_trans_1 : forall x y z : nat, x < y -> y < S z -> x < z.
Proof.
intros x y z H H0.
unfold lt in H0.

*****
H0 : le (S y) (S z)
H : lt x y
x,y,z : nat
*****
lt x z
+++++
unfold lt in H.
-----
Lemma lt_trans_1 : forall x y z : nat, x < y -> y < S z -> x < z.
Proof.
intros x y z H H0.
unfold lt in H0.
unfold lt in H.

*****
H0 : le (S y) (S z)
H : le (S x) y
x,y,z : nat
*****
lt x z
+++++
unfold lt in |- *.
-----
Lemma lt_trans_1 : forall x y z : nat, x < y -> y < S z -> x < z.
Proof.
intros x y z H H0.
unfold lt in H0.
unfold lt in H.
unfold lt in |- *.

*****
H0 : le (S y) (S z)
H : le (S x) y
x,y,z : nat
*****
le (S x) z
+++++
apply le_trans with (m := y).
-----
Lemma lt_trans_1 : forall x y z : nat, x < y -> y < S z -> x < z.
Proof.
intros x y z H H0.
unfold lt in H0.
unfold lt in H.
unfold lt in |- *.
apply le_trans with (m := y).

*****
H0 : le (S y) (S z)
H : le (S x) y
x,y,z : nat
*****
le (S x) y
+++++
assumption.
-----
Lemma lt_trans_1 : forall x y z : nat, x < y -> y < S z -> x < z.
Proof.
intros x y z H H0.
unfold lt in H0.
unfold lt in H.
unfold lt in |- *.
apply le_trans with (m := y).

*****
H0 : le (S y) (S z)
H : le (S x) y
x,y,z : nat
*****
le y z
+++++
apply le_S_n.
-----
Lemma lt_trans_1 : forall x y z : nat, x < y -> y < S z -> x < z.
Proof.
intros x y z H H0.
unfold lt in H0.
unfold lt in H.
unfold lt in |- *.
apply le_trans with (m := y).
apply le_S_n.

*****
H0 : le (S y) (S z)
H : le (S x) y
x,y,z : nat
*****
le (S y) (S z)
+++++
assumption.
-----
Lemma lt_trans_1 : forall x y z : nat, x < y -> y < S z -> x < z.
Proof.
intros x y z H H0.
unfold lt in H0.
unfold lt in H.
unfold lt in |- *.
apply le_trans with (m := y).

*****

*****

+++++
Qed.
-----
Lemma BDDcompare_sup_inf :\n forall x y : BDDvar,\n BDDcompare x y = Datatypes.Gt -> BDDcompare y x = Datatypes.Lt.
-----
Lemma BDDcompare_sup_inf : forall x y : BDDvar, BDDcompare x y = Datatypes.Gt -> BDDcompare y x = Datatypes.Lt.

*****

*****
forall (x y : BDDvar) (_ : eq (BDDcompare x y) Gt), eq (BDDcompare y x) Lt
+++++
Proof.
-----
Lemma BDDcompare_sup_inf : forall x y : BDDvar, BDDcompare x y = Datatypes.Gt -> BDDcompare y x = Datatypes.Lt.
Proof.

*****

*****
forall (x y : BDDvar) (_ : eq (BDDcompare x y) Gt), eq (BDDcompare y x) Lt
+++++
double induction x y.
-----
Lemma BDDcompare_sup_inf : forall x y : BDDvar, BDDcompare x y = Datatypes.Gt -> BDDcompare y x = Datatypes.Lt.
Proof.
double induction x y.

*****
x,y : BDDvar
*****
forall _ : eq (BDDcompare N0 N0) Gt, eq (BDDcompare N0 N0) Lt
+++++
simpl in |- *.
-----
Lemma BDDcompare_sup_inf : forall x y : BDDvar, BDDcompare x y = Datatypes.Gt -> BDDcompare y x = Datatypes.Lt.
Proof.
double induction x y.
simpl in |- *.

*****
x,y : BDDvar
*****
forall _ : eq Eq Gt, eq Eq Lt
+++++
intro.
-----
Lemma BDDcompare_sup_inf : forall x y : BDDvar, BDDcompare x y = Datatypes.Gt -> BDDcompare y x = Datatypes.Lt.
Proof.
double induction x y.
simpl in |- *.
intro.

*****
H : eq Eq Gt
x,y : BDDvar
*****
eq Eq Lt
+++++
discriminate.
-----
Lemma BDDcompare_sup_inf : forall x y : BDDvar, BDDcompare x y = Datatypes.Gt -> BDDcompare y x = Datatypes.Lt.
Proof.
double induction x y.

*****
x,y : BDDvar
*****
forall (p : positive) (_ : eq (BDDcompare N0 (Npos p)) Gt), eq (BDDcompare (Npos p) N0) Lt
+++++
simpl in |- *.
-----
Lemma BDDcompare_sup_inf : forall x y : BDDvar, BDDcompare x y = Datatypes.Gt -> BDDcompare y x = Datatypes.Lt.
Proof.
double induction x y.
simpl in |- *.

*****
x,y : BDDvar
*****
forall (_ : positive) (_ : eq Lt Gt), eq Gt Lt
+++++
intro p.
-----
Lemma BDDcompare_sup_inf : forall x y : BDDvar, BDDcompare x y = Datatypes.Gt -> BDDcompare y x = Datatypes.Lt.
Proof.
double induction x y.
simpl in |- *.
intro p.

*****
p : positive
x,y : BDDvar
*****
forall _ : eq Lt Gt, eq Gt Lt
+++++
intro.
-----
Lemma BDDcompare_sup_inf : forall x y : BDDvar, BDDcompare x y = Datatypes.Gt -> BDDcompare y x = Datatypes.Lt.
Proof.
double induction x y.
simpl in |- *.
intro p.
intro.

*****
H : eq Lt Gt
p : positive
x,y : BDDvar
*****
eq Gt Lt
+++++
discriminate.
-----
Lemma BDDcompare_sup_inf : forall x y : BDDvar, BDDcompare x y = Datatypes.Gt -> BDDcompare y x = Datatypes.Lt.
Proof.
double induction x y.

*****
x,y : BDDvar
*****
forall (p : positive) (_ : eq (BDDcompare (Npos p) N0) Gt), eq (BDDcompare N0 (Npos p)) Lt
+++++
simpl in |- *.
-----
Lemma BDDcompare_sup_inf : forall x y : BDDvar, BDDcompare x y = Datatypes.Gt -> BDDcompare y x = Datatypes.Lt.
Proof.
double induction x y.
simpl in |- *.

*****
x,y : BDDvar
*****
forall (_ : positive) (_ : eq Gt Gt), eq Lt Lt
+++++
reflexivity.
-----
Lemma BDDcompare_sup_inf : forall x y : BDDvar, BDDcompare x y = Datatypes.Gt -> BDDcompare y x = Datatypes.Lt.
Proof.
double induction x y.

*****
x,y : BDDvar
*****
forall (p p0 : positive) (_ : eq (BDDcompare (Npos p0) (Npos p)) Gt), eq (BDDcompare (Npos p) (Npos p0)) Lt
+++++
unfold BDDcompare in |- *.
-----
Lemma BDDcompare_sup_inf : forall x y : BDDvar, BDDcompare x y = Datatypes.Gt -> BDDcompare y x = Datatypes.Lt.
Proof.
double induction x y.
unfold BDDcompare in |- *.

*****
x,y : BDDvar
*****
forall (p p0 : positive) (_ : eq (Pos.compare_cont Eq p0 p) Gt), eq (Pos.compare_cont Eq p p0) Lt
+++++
intros p p0 H.
-----
Lemma BDDcompare_sup_inf : forall x y : BDDvar, BDDcompare x y = Datatypes.Gt -> BDDcompare y x = Datatypes.Lt.
Proof.
double induction x y.
unfold BDDcompare in |- *.
intros p p0 H.

*****
H : eq (Pos.compare_cont Eq p0 p) Gt
p,p0 : positive
x,y : BDDvar
*****
eq (Pos.compare_cont Eq p p0) Lt
+++++
apply ZC1.
-----
Lemma BDDcompare_sup_inf : forall x y : BDDvar, BDDcompare x y = Datatypes.Gt -> BDDcompare y x = Datatypes.Lt.
Proof.
double induction x y.
unfold BDDcompare in |- *.
intros p p0 H.
apply ZC1.

*****
H : eq (Pos.compare_cont Eq p0 p) Gt
p,p0 : positive
x,y : BDDvar
*****
Pos.gt p0 p
+++++
assumption.
-----
Lemma BDDcompare_sup_inf : forall x y : BDDvar, BDDcompare x y = Datatypes.Gt -> BDDcompare y x = Datatypes.Lt.
Proof.
double induction x y.

*****

*****

+++++
Qed.
-----
Lemma BDDcompare_1 :\n   forall x y : BDDvar,\n   BDDcompare x y = Datatypes.Lt ->\n   BDDcompare (ad_S x) y = Datatypes.Lt \/ ad_S x = y.
-----
Lemma BDDcompare_1 : forall x y : BDDvar, BDDcompare x y = Datatypes.Lt -> BDDcompare (ad_S x) y = Datatypes.Lt \\/ ad_S x = y.

*****

*****
forall (x y : BDDvar) (_ : eq (BDDcompare x y) Lt), or (eq (BDDcompare (ad_S x) y) Lt) (eq (ad_S x) y)
+++++
Proof.
-----
Lemma BDDcompare_1 : forall x y : BDDvar, BDDcompare x y = Datatypes.Lt -> BDDcompare (ad_S x) y = Datatypes.Lt \\/ ad_S x = y.
Proof.

*****

*****
forall (x y : BDDvar) (_ : eq (BDDcompare x y) Lt), or (eq (BDDcompare (ad_S x) y) Lt) (eq (ad_S x) y)
+++++
intros x y H.
-----
Lemma BDDcompare_1 : forall x y : BDDvar, BDDcompare x y = Datatypes.Lt -> BDDcompare (ad_S x) y = Datatypes.Lt \\/ ad_S x = y.
Proof.
intros x y H.

*****
H : eq (BDDcompare x y) Lt
x,y : BDDvar
*****
or (eq (BDDcompare (ad_S x) y) Lt) (eq (ad_S x) y)
+++++
elim (relation_sum (BDDcompare (ad_S x) y)).
-----
Lemma BDDcompare_1 : forall x y : BDDvar, BDDcompare x y = Datatypes.Lt -> BDDcompare (ad_S x) y = Datatypes.Lt \\/ ad_S x = y.
Proof.
intros x y H.
elim (relation_sum (BDDcompare (ad_S x) y)).

*****
H : eq (BDDcompare x y) Lt
x,y : BDDvar
*****
forall _ : sumbool (eq (BDDcompare (ad_S x) y) Eq) (eq (BDDcompare (ad_S x) y) Lt), or (eq (BDDcompare (ad_S x) y) Lt) (eq (ad_S x) y)
+++++
intro y0.
-----
Lemma BDDcompare_1 : forall x y : BDDvar, BDDcompare x y = Datatypes.Lt -> BDDcompare (ad_S x) y = Datatypes.Lt \\/ ad_S x = y.
Proof.
intros x y H.
elim (relation_sum (BDDcompare (ad_S x) y)).
intro y0.

*****
y0 : sumbool (eq (BDDcompare (ad_S x) y) Eq) (eq (BDDcompare (ad_S x) y) Lt)
H : eq (BDDcompare x y) Lt
x,y : BDDvar
*****
or (eq (BDDcompare (ad_S x) y) Lt) (eq (ad_S x) y)
+++++
elim y0.
-----
Lemma BDDcompare_1 : forall x y : BDDvar, BDDcompare x y = Datatypes.Lt -> BDDcompare (ad_S x) y = Datatypes.Lt \\/ ad_S x = y.
Proof.
intros x y H.
elim (relation_sum (BDDcompare (ad_S x) y)).
intro y0.
elim y0.

*****
y0 : sumbool (eq (BDDcompare (ad_S x) y) Eq) (eq (BDDcompare (ad_S x) y) Lt)
H : eq (BDDcompare x y) Lt
x,y : BDDvar
*****
forall _ : eq (BDDcompare (ad_S x) y) Eq, or (eq (BDDcompare (ad_S x) y) Lt) (eq (ad_S x) y)
+++++
intro.
-----
Lemma BDDcompare_1 : forall x y : BDDvar, BDDcompare x y = Datatypes.Lt -> BDDcompare (ad_S x) y = Datatypes.Lt \\/ ad_S x = y.
Proof.
intros x y H.
elim (relation_sum (BDDcompare (ad_S x) y)).
intro y0.
elim y0.
intro.

*****
a : eq (BDDcompare (ad_S x) y) Eq
y0 : sumbool (eq (BDDcompare (ad_S x) y) Eq) (eq (BDDcompare (ad_S x) y) Lt)
H : eq (BDDcompare x y) Lt
x,y : BDDvar
*****
or (eq (BDDcompare (ad_S x) y) Lt) (eq (ad_S x) y)
+++++
right.
-----
Lemma BDDcompare_1 : forall x y : BDDvar, BDDcompare x y = Datatypes.Lt -> BDDcompare (ad_S x) y = Datatypes.Lt \\/ ad_S x = y.
Proof.
intros x y H.
elim (relation_sum (BDDcompare (ad_S x) y)).
intro y0.
elim y0.
intro.
right.

*****
a : eq (BDDcompare (ad_S x) y) Eq
y0 : sumbool (eq (BDDcompare (ad_S x) y) Eq) (eq (BDDcompare (ad_S x) y) Lt)
H : eq (BDDcompare x y) Lt
x,y : BDDvar
*****
eq (ad_S x) y
+++++
apply BDD_EGAL_complete.
-----
Lemma BDDcompare_1 : forall x y : BDDvar, BDDcompare x y = Datatypes.Lt -> BDDcompare (ad_S x) y = Datatypes.Lt \\/ ad_S x = y.
Proof.
intros x y H.
elim (relation_sum (BDDcompare (ad_S x) y)).
intro y0.
elim y0.
intro.
right.
apply BDD_EGAL_complete.

*****
a : eq (BDDcompare (ad_S x) y) Eq
y0 : sumbool (eq (BDDcompare (ad_S x) y) Eq) (eq (BDDcompare (ad_S x) y) Lt)
H : eq (BDDcompare x y) Lt
x,y : BDDvar
*****
eq (BDDcompare (ad_S x) y) Eq
+++++
assumption.
-----
Lemma BDDcompare_1 : forall x y : BDDvar, BDDcompare x y = Datatypes.Lt -> BDDcompare (ad_S x) y = Datatypes.Lt \\/ ad_S x = y.
Proof.
intros x y H.
elim (relation_sum (BDDcompare (ad_S x) y)).
intro y0.
elim y0.

*****
y0 : sumbool (eq (BDDcompare (ad_S x) y) Eq) (eq (BDDcompare (ad_S x) y) Lt)
H : eq (BDDcompare x y) Lt
x,y : BDDvar
*****
forall _ : eq (BDDcompare (ad_S x) y) Lt, or (eq (BDDcompare (ad_S x) y) Lt) (eq (ad_S x) y)
+++++
intro.
-----
Lemma BDDcompare_1 : forall x y : BDDvar, BDDcompare x y = Datatypes.Lt -> BDDcompare (ad_S x) y = Datatypes.Lt \\/ ad_S x = y.
Proof.
intros x y H.
elim (relation_sum (BDDcompare (ad_S x) y)).
intro y0.
elim y0.
intro.

*****
b : eq (BDDcompare (ad_S x) y) Lt
y0 : sumbool (eq (BDDcompare (ad_S x) y) Eq) (eq (BDDcompare (ad_S x) y) Lt)
H : eq (BDDcompare x y) Lt
x,y : BDDvar
*****
or (eq (BDDcompare (ad_S x) y) Lt) (eq (ad_S x) y)
+++++
left.
-----
Lemma BDDcompare_1 : forall x y : BDDvar, BDDcompare x y = Datatypes.Lt -> BDDcompare (ad_S x) y = Datatypes.Lt \\/ ad_S x = y.
Proof.
intros x y H.
elim (relation_sum (BDDcompare (ad_S x) y)).
intro y0.
elim y0.
intro.
left.

*****
b : eq (BDDcompare (ad_S x) y) Lt
y0 : sumbool (eq (BDDcompare (ad_S x) y) Eq) (eq (BDDcompare (ad_S x) y) Lt)
H : eq (BDDcompare x y) Lt
x,y : BDDvar
*****
eq (BDDcompare (ad_S x) y) Lt
+++++
assumption.
-----
Lemma BDDcompare_1 : forall x y : BDDvar, BDDcompare x y = Datatypes.Lt -> BDDcompare (ad_S x) y = Datatypes.Lt \\/ ad_S x = y.
Proof.
intros x y H.
elim (relation_sum (BDDcompare (ad_S x) y)).

*****
H : eq (BDDcompare x y) Lt
x,y : BDDvar
*****
forall _ : eq (BDDcompare (ad_S x) y) Gt, or (eq (BDDcompare (ad_S x) y) Lt) (eq (ad_S x) y)
+++++
intro y0.
-----
Lemma BDDcompare_1 : forall x y : BDDvar, BDDcompare x y = Datatypes.Lt -> BDDcompare (ad_S x) y = Datatypes.Lt \\/ ad_S x = y.
Proof.
intros x y H.
elim (relation_sum (BDDcompare (ad_S x) y)).
intro y0.

*****
y0 : eq (BDDcompare (ad_S x) y) Gt
H : eq (BDDcompare x y) Lt
x,y : BDDvar
*****
or (eq (BDDcompare (ad_S x) y) Lt) (eq (ad_S x) y)
+++++
absurd (nat_of_N x < nat_of_N x).
-----
Lemma BDDcompare_1 : forall x y : BDDvar, BDDcompare x y = Datatypes.Lt -> BDDcompare (ad_S x) y = Datatypes.Lt \\/ ad_S x = y.
Proof.
intros x y H.
elim (relation_sum (BDDcompare (ad_S x) y)).
intro y0.
absurd (nat_of_N x < nat_of_N x).

*****
y0 : eq (BDDcompare (ad_S x) y) Gt
H : eq (BDDcompare x y) Lt
x,y : BDDvar
*****
not (lt (N.to_nat x) (N.to_nat x))
+++++
apply lt_irrefl.
-----
Lemma BDDcompare_1 : forall x y : BDDvar, BDDcompare x y = Datatypes.Lt -> BDDcompare (ad_S x) y = Datatypes.Lt \\/ ad_S x = y.
Proof.
intros x y H.
elim (relation_sum (BDDcompare (ad_S x) y)).
intro y0.
absurd (nat_of_N x < nat_of_N x).

*****
y0 : eq (BDDcompare (ad_S x) y) Gt
H : eq (BDDcompare x y) Lt
x,y : BDDvar
*****
lt (N.to_nat x) (N.to_nat x)
+++++
apply lt_trans_1 with (y := nat_of_N y).
-----
Lemma BDDcompare_1 : forall x y : BDDvar, BDDcompare x y = Datatypes.Lt -> BDDcompare (ad_S x) y = Datatypes.Lt \\/ ad_S x = y.
Proof.
intros x y H.
elim (relation_sum (BDDcompare (ad_S x) y)).
intro y0.
absurd (nat_of_N x < nat_of_N x).
apply lt_trans_1 with (y := nat_of_N y).

*****
y0 : eq (BDDcompare (ad_S x) y) Gt
H : eq (BDDcompare x y) Lt
x,y : BDDvar
*****
lt (N.to_nat x) (N.to_nat y)
+++++
apply BDDcompare_lt.
-----
Lemma BDDcompare_1 : forall x y : BDDvar, BDDcompare x y = Datatypes.Lt -> BDDcompare (ad_S x) y = Datatypes.Lt \\/ ad_S x = y.
Proof.
intros x y H.
elim (relation_sum (BDDcompare (ad_S x) y)).
intro y0.
absurd (nat_of_N x < nat_of_N x).
apply lt_trans_1 with (y := nat_of_N y).
apply BDDcompare_lt.

*****
y0 : eq (BDDcompare (ad_S x) y) Gt
H : eq (BDDcompare x y) Lt
x,y : BDDvar
*****
eq (BDDcompare x y) Lt
+++++
assumption.
-----
Lemma BDDcompare_1 : forall x y : BDDvar, BDDcompare x y = Datatypes.Lt -> BDDcompare (ad_S x) y = Datatypes.Lt \\/ ad_S x = y.
Proof.
intros x y H.
elim (relation_sum (BDDcompare (ad_S x) y)).
intro y0.
absurd (nat_of_N x < nat_of_N x).
apply lt_trans_1 with (y := nat_of_N y).

*****
y0 : eq (BDDcompare (ad_S x) y) Gt
H : eq (BDDcompare x y) Lt
x,y : BDDvar
*****
lt (N.to_nat y) (S (N.to_nat x))
+++++
rewrite <- (ad_S_is_S x).
-----
Lemma BDDcompare_1 : forall x y : BDDvar, BDDcompare x y = Datatypes.Lt -> BDDcompare (ad_S x) y = Datatypes.Lt \\/ ad_S x = y.
Proof.
intros x y H.
elim (relation_sum (BDDcompare (ad_S x) y)).
intro y0.
absurd (nat_of_N x < nat_of_N x).
apply lt_trans_1 with (y := nat_of_N y).
rewrite <- (ad_S_is_S x).

*****
y0 : eq (BDDcompare (ad_S x) y) Gt
H : eq (BDDcompare x y) Lt
x,y : BDDvar
*****
lt (N.to_nat y) (N.to_nat (ad_S x))
+++++
apply BDDcompare_lt.
-----
Lemma BDDcompare_1 : forall x y : BDDvar, BDDcompare x y = Datatypes.Lt -> BDDcompare (ad_S x) y = Datatypes.Lt \\/ ad_S x = y.
Proof.
intros x y H.
elim (relation_sum (BDDcompare (ad_S x) y)).
intro y0.
absurd (nat_of_N x < nat_of_N x).
apply lt_trans_1 with (y := nat_of_N y).
rewrite <- (ad_S_is_S x).
apply BDDcompare_lt.

*****
y0 : eq (BDDcompare (ad_S x) y) Gt
H : eq (BDDcompare x y) Lt
x,y : BDDvar
*****
eq (BDDcompare y (ad_S x)) Lt
+++++
apply BDDcompare_sup_inf.
-----
Lemma BDDcompare_1 : forall x y : BDDvar, BDDcompare x y = Datatypes.Lt -> BDDcompare (ad_S x) y = Datatypes.Lt \\/ ad_S x = y.
Proof.
intros x y H.
elim (relation_sum (BDDcompare (ad_S x) y)).
intro y0.
absurd (nat_of_N x < nat_of_N x).
apply lt_trans_1 with (y := nat_of_N y).
rewrite <- (ad_S_is_S x).
apply BDDcompare_lt.
apply BDDcompare_sup_inf.

*****
y0 : eq (BDDcompare (ad_S x) y) Gt
H : eq (BDDcompare x y) Lt
x,y : BDDvar
*****
eq (BDDcompare (ad_S x) y) Gt
+++++
assumption.
-----
Lemma BDDcompare_1 : forall x y : BDDvar, BDDcompare x y = Datatypes.Lt -> BDDcompare (ad_S x) y = Datatypes.Lt \\/ ad_S x = y.
Proof.
intros x y H.
elim (relation_sum (BDDcompare (ad_S x) y)).

*****

*****

+++++
Qed.
-----
Definition max (m n : nat) := if leb m n then n else m.
-----
Lemma lt_max_1_2 :\n forall x1 y1 x2 y2 : nat, x1 < x2 -> y1 < y2 -> max x1 y1 < max x2 y2.
-----
Lemma lt_max_1_2 : forall x1 y1 x2 y2 : nat, x1 < x2 -> y1 < y2 -> max x1 y1 < max x2 y2.

*****

*****
forall (x1 y1 x2 y2 : nat) (_ : lt x1 x2) (_ : lt y1 y2), lt (max x1 y1) (max x2 y2)
+++++
Proof.
-----
Lemma lt_max_1_2 : forall x1 y1 x2 y2 : nat, x1 < x2 -> y1 < y2 -> max x1 y1 < max x2 y2.
Proof.

*****

*****
forall (x1 y1 x2 y2 : nat) (_ : lt x1 x2) (_ : lt y1 y2), lt (max x1 y1) (max x2 y2)
+++++
intros x1 y1 x2 y2 H H0.
-----
Lemma lt_max_1_2 : forall x1 y1 x2 y2 : nat, x1 < x2 -> y1 < y2 -> max x1 y1 < max x2 y2.
Proof.
intros x1 y1 x2 y2 H H0.

*****
H0 : lt y1 y2
H : lt x1 x2
x1,y1,x2,y2 : nat
*****
lt (max x1 y1) (max x2 y2)
+++++
unfold max in |- *.
-----
Lemma lt_max_1_2 : forall x1 y1 x2 y2 : nat, x1 < x2 -> y1 < y2 -> max x1 y1 < max x2 y2.
Proof.
intros x1 y1 x2 y2 H H0.
unfold max in |- *.

*****
H0 : lt y1 y2
H : lt x1 x2
x1,y1,x2,y2 : nat
*****
lt (if Nat.leb x1 y1 then y1 else x1) (if Nat.leb x2 y2 then y2 else x2)
+++++
elim (sumbool_of_bool (leb x2 y2)).
-----
Lemma lt_max_1_2 : forall x1 y1 x2 y2 : nat, x1 < x2 -> y1 < y2 -> max x1 y1 < max x2 y2.
Proof.
intros x1 y1 x2 y2 H H0.
unfold max in |- *.
elim (sumbool_of_bool (leb x2 y2)).

*****
H0 : lt y1 y2
H : lt x1 x2
x1,y1,x2,y2 : nat
*****
forall _ : eq (Nat.leb x2 y2) true, lt (if Nat.leb x1 y1 then y1 else x1) (if Nat.leb x2 y2 then y2 else x2)
+++++
intro y.
-----
Lemma lt_max_1_2 : forall x1 y1 x2 y2 : nat, x1 < x2 -> y1 < y2 -> max x1 y1 < max x2 y2.
Proof.
intros x1 y1 x2 y2 H H0.
unfold max in |- *.
elim (sumbool_of_bool (leb x2 y2)).
intro y.

*****
y : eq (Nat.leb x2 y2) true
H0 : lt y1 y2
H : lt x1 x2
x1,y1,x2,y2 : nat
*****
lt (if Nat.leb x1 y1 then y1 else x1) (if Nat.leb x2 y2 then y2 else x2)
+++++
rewrite y.
-----
Lemma lt_max_1_2 : forall x1 y1 x2 y2 : nat, x1 < x2 -> y1 < y2 -> max x1 y1 < max x2 y2.
Proof.
intros x1 y1 x2 y2 H H0.
unfold max in |- *.
elim (sumbool_of_bool (leb x2 y2)).
intro y.
rewrite y.

*****
y : eq (Nat.leb x2 y2) true
H0 : lt y1 y2
H : lt x1 x2
x1,y1,x2,y2 : nat
*****
lt (if Nat.leb x1 y1 then y1 else x1) y2
+++++
elim (leb x1 y1).
-----
Lemma lt_max_1_2 : forall x1 y1 x2 y2 : nat, x1 < x2 -> y1 < y2 -> max x1 y1 < max x2 y2.
Proof.
intros x1 y1 x2 y2 H H0.
unfold max in |- *.
elim (sumbool_of_bool (leb x2 y2)).
intro y.
rewrite y.
elim (leb x1 y1).

*****
y : eq (Nat.leb x2 y2) true
H0 : lt y1 y2
H : lt x1 x2
x1,y1,x2,y2 : nat
*****
lt y1 y2
+++++
assumption.
-----
Lemma lt_max_1_2 : forall x1 y1 x2 y2 : nat, x1 < x2 -> y1 < y2 -> max x1 y1 < max x2 y2.
Proof.
intros x1 y1 x2 y2 H H0.
unfold max in |- *.
elim (sumbool_of_bool (leb x2 y2)).
intro y.
rewrite y.
elim (leb x1 y1).

*****
y : eq (Nat.leb x2 y2) true
H0 : lt y1 y2
H : lt x1 x2
x1,y1,x2,y2 : nat
*****
lt x1 y2
+++++
apply lt_le_trans with (m := x2).
-----
Lemma lt_max_1_2 : forall x1 y1 x2 y2 : nat, x1 < x2 -> y1 < y2 -> max x1 y1 < max x2 y2.
Proof.
intros x1 y1 x2 y2 H H0.
unfold max in |- *.
elim (sumbool_of_bool (leb x2 y2)).
intro y.
rewrite y.
elim (leb x1 y1).
apply lt_le_trans with (m := x2).

*****
y : eq (Nat.leb x2 y2) true
H0 : lt y1 y2
H : lt x1 x2
x1,y1,x2,y2 : nat
*****
lt x1 x2
+++++
assumption.
-----
Lemma lt_max_1_2 : forall x1 y1 x2 y2 : nat, x1 < x2 -> y1 < y2 -> max x1 y1 < max x2 y2.
Proof.
intros x1 y1 x2 y2 H H0.
unfold max in |- *.
elim (sumbool_of_bool (leb x2 y2)).
intro y.
rewrite y.
elim (leb x1 y1).
apply lt_le_trans with (m := x2).

*****
y : eq (Nat.leb x2 y2) true
H0 : lt y1 y2
H : lt x1 x2
x1,y1,x2,y2 : nat
*****
le x2 y2
+++++
apply leb_complete.
-----
Lemma lt_max_1_2 : forall x1 y1 x2 y2 : nat, x1 < x2 -> y1 < y2 -> max x1 y1 < max x2 y2.
Proof.
intros x1 y1 x2 y2 H H0.
unfold max in |- *.
elim (sumbool_of_bool (leb x2 y2)).
intro y.
rewrite y.
elim (leb x1 y1).
apply lt_le_trans with (m := x2).
apply leb_complete.

*****
y : eq (Nat.leb x2 y2) true
H0 : lt y1 y2
H : lt x1 x2
x1,y1,x2,y2 : nat
*****
eq (Nat.leb x2 y2) true
+++++
assumption.
-----
Lemma lt_max_1_2 : forall x1 y1 x2 y2 : nat, x1 < x2 -> y1 < y2 -> max x1 y1 < max x2 y2.
Proof.
intros x1 y1 x2 y2 H H0.
unfold max in |- *.
elim (sumbool_of_bool (leb x2 y2)).

*****
H0 : lt y1 y2
H : lt x1 x2
x1,y1,x2,y2 : nat
*****
forall _ : eq (Nat.leb x2 y2) false, lt (if Nat.leb x1 y1 then y1 else x1) (if Nat.leb x2 y2 then y2 else x2)
+++++
intro y.
-----
Lemma lt_max_1_2 : forall x1 y1 x2 y2 : nat, x1 < x2 -> y1 < y2 -> max x1 y1 < max x2 y2.
Proof.
intros x1 y1 x2 y2 H H0.
unfold max in |- *.
elim (sumbool_of_bool (leb x2 y2)).
intro y.

*****
y : eq (Nat.leb x2 y2) false
H0 : lt y1 y2
H : lt x1 x2
x1,y1,x2,y2 : nat
*****
lt (if Nat.leb x1 y1 then y1 else x1) (if Nat.leb x2 y2 then y2 else x2)
+++++
rewrite y.
-----
Lemma lt_max_1_2 : forall x1 y1 x2 y2 : nat, x1 < x2 -> y1 < y2 -> max x1 y1 < max x2 y2.
Proof.
intros x1 y1 x2 y2 H H0.
unfold max in |- *.
elim (sumbool_of_bool (leb x2 y2)).
intro y.
rewrite y.

*****
y : eq (Nat.leb x2 y2) false
H0 : lt y1 y2
H : lt x1 x2
x1,y1,x2,y2 : nat
*****
lt (if Nat.leb x1 y1 then y1 else x1) x2
+++++
elim (leb x1 y1).
-----
Lemma lt_max_1_2 : forall x1 y1 x2 y2 : nat, x1 < x2 -> y1 < y2 -> max x1 y1 < max x2 y2.
Proof.
intros x1 y1 x2 y2 H H0.
unfold max in |- *.
elim (sumbool_of_bool (leb x2 y2)).
intro y.
rewrite y.
elim (leb x1 y1).

*****
y : eq (Nat.leb x2 y2) false
H0 : lt y1 y2
H : lt x1 x2
x1,y1,x2,y2 : nat
*****
lt y1 x2
+++++
apply lt_trans with (m := y2).
-----
Lemma lt_max_1_2 : forall x1 y1 x2 y2 : nat, x1 < x2 -> y1 < y2 -> max x1 y1 < max x2 y2.
Proof.
intros x1 y1 x2 y2 H H0.
unfold max in |- *.
elim (sumbool_of_bool (leb x2 y2)).
intro y.
rewrite y.
elim (leb x1 y1).
apply lt_trans with (m := y2).

*****
y : eq (Nat.leb x2 y2) false
H0 : lt y1 y2
H : lt x1 x2
x1,y1,x2,y2 : nat
*****
lt y1 y2
+++++
assumption.
-----
Lemma lt_max_1_2 : forall x1 y1 x2 y2 : nat, x1 < x2 -> y1 < y2 -> max x1 y1 < max x2 y2.
Proof.
intros x1 y1 x2 y2 H H0.
unfold max in |- *.
elim (sumbool_of_bool (leb x2 y2)).
intro y.
rewrite y.
elim (leb x1 y1).
apply lt_trans with (m := y2).

*****
y : eq (Nat.leb x2 y2) false
H0 : lt y1 y2
H : lt x1 x2
x1,y1,x2,y2 : nat
*****
lt y2 x2
+++++
apply leb_complete_conv.
-----
Lemma lt_max_1_2 : forall x1 y1 x2 y2 : nat, x1 < x2 -> y1 < y2 -> max x1 y1 < max x2 y2.
Proof.
intros x1 y1 x2 y2 H H0.
unfold max in |- *.
elim (sumbool_of_bool (leb x2 y2)).
intro y.
rewrite y.
elim (leb x1 y1).
apply lt_trans with (m := y2).
apply leb_complete_conv.

*****
y : eq (Nat.leb x2 y2) false
H0 : lt y1 y2
H : lt x1 x2
x1,y1,x2,y2 : nat
*****
eq (Nat.leb x2 y2) false
+++++
assumption.
-----
Lemma lt_max_1_2 : forall x1 y1 x2 y2 : nat, x1 < x2 -> y1 < y2 -> max x1 y1 < max x2 y2.
Proof.
intros x1 y1 x2 y2 H H0.
unfold max in |- *.
elim (sumbool_of_bool (leb x2 y2)).
intro y.
rewrite y.
elim (leb x1 y1).

*****
y : eq (Nat.leb x2 y2) false
H0 : lt y1 y2
H : lt x1 x2
x1,y1,x2,y2 : nat
*****
lt x1 x2
+++++
assumption.
-----
Lemma lt_max_1_2 : forall x1 y1 x2 y2 : nat, x1 < x2 -> y1 < y2 -> max x1 y1 < max x2 y2.
Proof.
intros x1 y1 x2 y2 H H0.
unfold max in |- *.
elim (sumbool_of_bool (leb x2 y2)).

*****

*****

+++++
Qed.
-----
Lemma lt_max_2 :\n forall x1 y1 x2 y2 : nat, x1 < y2 -> y1 < y2 -> max x1 y1 < max x2 y2.
-----
Lemma lt_max_2 : forall x1 y1 x2 y2 : nat, x1 < y2 -> y1 < y2 -> max x1 y1 < max x2 y2.

*****

*****
forall (x1 y1 x2 y2 : nat) (_ : lt x1 y2) (_ : lt y1 y2), lt (max x1 y1) (max x2 y2)
+++++
Proof.
-----
Lemma lt_max_2 : forall x1 y1 x2 y2 : nat, x1 < y2 -> y1 < y2 -> max x1 y1 < max x2 y2.
Proof.

*****

*****
forall (x1 y1 x2 y2 : nat) (_ : lt x1 y2) (_ : lt y1 y2), lt (max x1 y1) (max x2 y2)
+++++
intros x1 y1 x2 y2 H H0.
-----
Lemma lt_max_2 : forall x1 y1 x2 y2 : nat, x1 < y2 -> y1 < y2 -> max x1 y1 < max x2 y2.
Proof.
intros x1 y1 x2 y2 H H0.

*****
H0 : lt y1 y2
H : lt x1 y2
x1,y1,x2,y2 : nat
*****
lt (max x1 y1) (max x2 y2)
+++++
unfold max in |- *.
-----
Lemma lt_max_2 : forall x1 y1 x2 y2 : nat, x1 < y2 -> y1 < y2 -> max x1 y1 < max x2 y2.
Proof.
intros x1 y1 x2 y2 H H0.
unfold max in |- *.

*****
H0 : lt y1 y2
H : lt x1 y2
x1,y1,x2,y2 : nat
*****
lt (if Nat.leb x1 y1 then y1 else x1) (if Nat.leb x2 y2 then y2 else x2)
+++++
elim (leb x1 y1).
-----
Lemma lt_max_2 : forall x1 y1 x2 y2 : nat, x1 < y2 -> y1 < y2 -> max x1 y1 < max x2 y2.
Proof.
intros x1 y1 x2 y2 H H0.
unfold max in |- *.
elim (leb x1 y1).

*****
H0 : lt y1 y2
H : lt x1 y2
x1,y1,x2,y2 : nat
*****
lt y1 (if Nat.leb x2 y2 then y2 else x2)
+++++
elim (sumbool_of_bool (leb x2 y2)).
-----
Lemma lt_max_2 : forall x1 y1 x2 y2 : nat, x1 < y2 -> y1 < y2 -> max x1 y1 < max x2 y2.
Proof.
intros x1 y1 x2 y2 H H0.
unfold max in |- *.
elim (leb x1 y1).
elim (sumbool_of_bool (leb x2 y2)).

*****
H0 : lt y1 y2
H : lt x1 y2
x1,y1,x2,y2 : nat
*****
forall _ : eq (Nat.leb x2 y2) true, lt y1 (if Nat.leb x2 y2 then y2 else x2)
+++++
intro y.
-----
Lemma lt_max_2 : forall x1 y1 x2 y2 : nat, x1 < y2 -> y1 < y2 -> max x1 y1 < max x2 y2.
Proof.
intros x1 y1 x2 y2 H H0.
unfold max in |- *.
elim (leb x1 y1).
elim (sumbool_of_bool (leb x2 y2)).
intro y.

*****
y : eq (Nat.leb x2 y2) true
H0 : lt y1 y2
H : lt x1 y2
x1,y1,x2,y2 : nat
*****
lt y1 (if Nat.leb x2 y2 then y2 else x2)
+++++
rewrite y.
-----
Lemma lt_max_2 : forall x1 y1 x2 y2 : nat, x1 < y2 -> y1 < y2 -> max x1 y1 < max x2 y2.
Proof.
intros x1 y1 x2 y2 H H0.
unfold max in |- *.
elim (leb x1 y1).
elim (sumbool_of_bool (leb x2 y2)).
intro y.
rewrite y.

*****
y : eq (Nat.leb x2 y2) true
H0 : lt y1 y2
H : lt x1 y2
x1,y1,x2,y2 : nat
*****
lt y1 y2
+++++
assumption.
-----
Lemma lt_max_2 : forall x1 y1 x2 y2 : nat, x1 < y2 -> y1 < y2 -> max x1 y1 < max x2 y2.
Proof.
intros x1 y1 x2 y2 H H0.
unfold max in |- *.
elim (leb x1 y1).
elim (sumbool_of_bool (leb x2 y2)).

*****
H0 : lt y1 y2
H : lt x1 y2
x1,y1,x2,y2 : nat
*****
forall _ : eq (Nat.leb x2 y2) false, lt y1 (if Nat.leb x2 y2 then y2 else x2)
+++++
intro y.
-----
Lemma lt_max_2 : forall x1 y1 x2 y2 : nat, x1 < y2 -> y1 < y2 -> max x1 y1 < max x2 y2.
Proof.
intros x1 y1 x2 y2 H H0.
unfold max in |- *.
elim (leb x1 y1).
elim (sumbool_of_bool (leb x2 y2)).
intro y.

*****
y : eq (Nat.leb x2 y2) false
H0 : lt y1 y2
H : lt x1 y2
x1,y1,x2,y2 : nat
*****
lt y1 (if Nat.leb x2 y2 then y2 else x2)
+++++
rewrite y.
-----
Lemma lt_max_2 : forall x1 y1 x2 y2 : nat, x1 < y2 -> y1 < y2 -> max x1 y1 < max x2 y2.
Proof.
intros x1 y1 x2 y2 H H0.
unfold max in |- *.
elim (leb x1 y1).
elim (sumbool_of_bool (leb x2 y2)).
intro y.
rewrite y.

*****
y : eq (Nat.leb x2 y2) false
H0 : lt y1 y2
H : lt x1 y2
x1,y1,x2,y2 : nat
*****
lt y1 x2
+++++
apply lt_trans with (m := y2).
-----
Lemma lt_max_2 : forall x1 y1 x2 y2 : nat, x1 < y2 -> y1 < y2 -> max x1 y1 < max x2 y2.
Proof.
intros x1 y1 x2 y2 H H0.
unfold max in |- *.
elim (leb x1 y1).
elim (sumbool_of_bool (leb x2 y2)).
intro y.
rewrite y.
apply lt_trans with (m := y2).

*****
y : eq (Nat.leb x2 y2) false
H0 : lt y1 y2
H : lt x1 y2
x1,y1,x2,y2 : nat
*****
lt y1 y2
+++++
assumption.
-----
Lemma lt_max_2 : forall x1 y1 x2 y2 : nat, x1 < y2 -> y1 < y2 -> max x1 y1 < max x2 y2.
Proof.
intros x1 y1 x2 y2 H H0.
unfold max in |- *.
elim (leb x1 y1).
elim (sumbool_of_bool (leb x2 y2)).
intro y.
rewrite y.
apply lt_trans with (m := y2).

*****
y : eq (Nat.leb x2 y2) false
H0 : lt y1 y2
H : lt x1 y2
x1,y1,x2,y2 : nat
*****
lt y2 x2
+++++
apply leb_complete_conv.
-----
Lemma lt_max_2 : forall x1 y1 x2 y2 : nat, x1 < y2 -> y1 < y2 -> max x1 y1 < max x2 y2.
Proof.
intros x1 y1 x2 y2 H H0.
unfold max in |- *.
elim (leb x1 y1).
elim (sumbool_of_bool (leb x2 y2)).
intro y.
rewrite y.
apply lt_trans with (m := y2).
apply leb_complete_conv.

*****
y : eq (Nat.leb x2 y2) false
H0 : lt y1 y2
H : lt x1 y2
x1,y1,x2,y2 : nat
*****
eq (Nat.leb x2 y2) false
+++++
assumption.
-----
Lemma lt_max_2 : forall x1 y1 x2 y2 : nat, x1 < y2 -> y1 < y2 -> max x1 y1 < max x2 y2.
Proof.
intros x1 y1 x2 y2 H H0.
unfold max in |- *.
elim (leb x1 y1).

*****
H0 : lt y1 y2
H : lt x1 y2
x1,y1,x2,y2 : nat
*****
lt x1 (if Nat.leb x2 y2 then y2 else x2)
+++++
elim (sumbool_of_bool (leb x2 y2)).
-----
Lemma lt_max_2 : forall x1 y1 x2 y2 : nat, x1 < y2 -> y1 < y2 -> max x1 y1 < max x2 y2.
Proof.
intros x1 y1 x2 y2 H H0.
unfold max in |- *.
elim (leb x1 y1).
elim (sumbool_of_bool (leb x2 y2)).

*****
H0 : lt y1 y2
H : lt x1 y2
x1,y1,x2,y2 : nat
*****
forall _ : eq (Nat.leb x2 y2) true, lt x1 (if Nat.leb x2 y2 then y2 else x2)
+++++
intro y.
-----
Lemma lt_max_2 : forall x1 y1 x2 y2 : nat, x1 < y2 -> y1 < y2 -> max x1 y1 < max x2 y2.
Proof.
intros x1 y1 x2 y2 H H0.
unfold max in |- *.
elim (leb x1 y1).
elim (sumbool_of_bool (leb x2 y2)).
intro y.

*****
y : eq (Nat.leb x2 y2) true
H0 : lt y1 y2
H : lt x1 y2
x1,y1,x2,y2 : nat
*****
lt x1 (if Nat.leb x2 y2 then y2 else x2)
+++++
rewrite y.
-----
Lemma lt_max_2 : forall x1 y1 x2 y2 : nat, x1 < y2 -> y1 < y2 -> max x1 y1 < max x2 y2.
Proof.
intros x1 y1 x2 y2 H H0.
unfold max in |- *.
elim (leb x1 y1).
elim (sumbool_of_bool (leb x2 y2)).
intro y.
rewrite y.

*****
y : eq (Nat.leb x2 y2) true
H0 : lt y1 y2
H : lt x1 y2
x1,y1,x2,y2 : nat
*****
lt x1 y2
+++++
assumption.
-----
Lemma lt_max_2 : forall x1 y1 x2 y2 : nat, x1 < y2 -> y1 < y2 -> max x1 y1 < max x2 y2.
Proof.
intros x1 y1 x2 y2 H H0.
unfold max in |- *.
elim (leb x1 y1).
elim (sumbool_of_bool (leb x2 y2)).

*****
H0 : lt y1 y2
H : lt x1 y2
x1,y1,x2,y2 : nat
*****
forall _ : eq (Nat.leb x2 y2) false, lt x1 (if Nat.leb x2 y2 then y2 else x2)
+++++
intro y.
-----
Lemma lt_max_2 : forall x1 y1 x2 y2 : nat, x1 < y2 -> y1 < y2 -> max x1 y1 < max x2 y2.
Proof.
intros x1 y1 x2 y2 H H0.
unfold max in |- *.
elim (leb x1 y1).
elim (sumbool_of_bool (leb x2 y2)).
intro y.

*****
y : eq (Nat.leb x2 y2) false
H0 : lt y1 y2
H : lt x1 y2
x1,y1,x2,y2 : nat
*****
lt x1 (if Nat.leb x2 y2 then y2 else x2)
+++++
rewrite y.
-----
Lemma lt_max_2 : forall x1 y1 x2 y2 : nat, x1 < y2 -> y1 < y2 -> max x1 y1 < max x2 y2.
Proof.
intros x1 y1 x2 y2 H H0.
unfold max in |- *.
elim (leb x1 y1).
elim (sumbool_of_bool (leb x2 y2)).
intro y.
rewrite y.

*****
y : eq (Nat.leb x2 y2) false
H0 : lt y1 y2
H : lt x1 y2
x1,y1,x2,y2 : nat
*****
lt x1 x2
+++++
apply lt_trans with (m := y2).
-----
Lemma lt_max_2 : forall x1 y1 x2 y2 : nat, x1 < y2 -> y1 < y2 -> max x1 y1 < max x2 y2.
Proof.
intros x1 y1 x2 y2 H H0.
unfold max in |- *.
elim (leb x1 y1).
elim (sumbool_of_bool (leb x2 y2)).
intro y.
rewrite y.
apply lt_trans with (m := y2).

*****
y : eq (Nat.leb x2 y2) false
H0 : lt y1 y2
H : lt x1 y2
x1,y1,x2,y2 : nat
*****
lt x1 y2
+++++
assumption.
-----
Lemma lt_max_2 : forall x1 y1 x2 y2 : nat, x1 < y2 -> y1 < y2 -> max x1 y1 < max x2 y2.
Proof.
intros x1 y1 x2 y2 H H0.
unfold max in |- *.
elim (leb x1 y1).
elim (sumbool_of_bool (leb x2 y2)).
intro y.
rewrite y.
apply lt_trans with (m := y2).

*****
y : eq (Nat.leb x2 y2) false
H0 : lt y1 y2
H : lt x1 y2
x1,y1,x2,y2 : nat
*****
lt y2 x2
+++++
apply leb_complete_conv.
-----
Lemma lt_max_2 : forall x1 y1 x2 y2 : nat, x1 < y2 -> y1 < y2 -> max x1 y1 < max x2 y2.
Proof.
intros x1 y1 x2 y2 H H0.
unfold max in |- *.
elim (leb x1 y1).
elim (sumbool_of_bool (leb x2 y2)).
intro y.
rewrite y.
apply lt_trans with (m := y2).
apply leb_complete_conv.

*****
y : eq (Nat.leb x2 y2) false
H0 : lt y1 y2
H : lt x1 y2
x1,y1,x2,y2 : nat
*****
eq (Nat.leb x2 y2) false
+++++
assumption.
-----
Lemma lt_max_2 : forall x1 y1 x2 y2 : nat, x1 < y2 -> y1 < y2 -> max x1 y1 < max x2 y2.
Proof.
intros x1 y1 x2 y2 H H0.
unfold max in |- *.
elim (leb x1 y1).

*****

*****

+++++
Qed.
-----
Lemma lt_max_12 :\n forall x1 y1 x2 y2 : nat, x1 < x2 -> y1 < x2 -> max x1 y1 < max x2 y2.
-----
Lemma lt_max_12 : forall x1 y1 x2 y2 : nat, x1 < x2 -> y1 < x2 -> max x1 y1 < max x2 y2.

*****

*****
forall (x1 y1 x2 y2 : nat) (_ : lt x1 x2) (_ : lt y1 x2), lt (max x1 y1) (max x2 y2)
+++++
Proof.
-----
Lemma lt_max_12 : forall x1 y1 x2 y2 : nat, x1 < x2 -> y1 < x2 -> max x1 y1 < max x2 y2.
Proof.

*****

*****
forall (x1 y1 x2 y2 : nat) (_ : lt x1 x2) (_ : lt y1 x2), lt (max x1 y1) (max x2 y2)
+++++
intros x1 y1 x2 y2 H H0.
-----
Lemma lt_max_12 : forall x1 y1 x2 y2 : nat, x1 < x2 -> y1 < x2 -> max x1 y1 < max x2 y2.
Proof.
intros x1 y1 x2 y2 H H0.

*****
H0 : lt y1 x2
H : lt x1 x2
x1,y1,x2,y2 : nat
*****
lt (max x1 y1) (max x2 y2)
+++++
unfold max in |- *.
-----
Lemma lt_max_12 : forall x1 y1 x2 y2 : nat, x1 < x2 -> y1 < x2 -> max x1 y1 < max x2 y2.
Proof.
intros x1 y1 x2 y2 H H0.
unfold max in |- *.

*****
H0 : lt y1 x2
H : lt x1 x2
x1,y1,x2,y2 : nat
*****
lt (if Nat.leb x1 y1 then y1 else x1) (if Nat.leb x2 y2 then y2 else x2)
+++++
elim (leb x1 y1).
-----
Lemma lt_max_12 : forall x1 y1 x2 y2 : nat, x1 < x2 -> y1 < x2 -> max x1 y1 < max x2 y2.
Proof.
intros x1 y1 x2 y2 H H0.
unfold max in |- *.
elim (leb x1 y1).

*****
H0 : lt y1 x2
H : lt x1 x2
x1,y1,x2,y2 : nat
*****
lt y1 (if Nat.leb x2 y2 then y2 else x2)
+++++
elim (sumbool_of_bool (leb x2 y2)).
-----
Lemma lt_max_12 : forall x1 y1 x2 y2 : nat, x1 < x2 -> y1 < x2 -> max x1 y1 < max x2 y2.
Proof.
intros x1 y1 x2 y2 H H0.
unfold max in |- *.
elim (leb x1 y1).
elim (sumbool_of_bool (leb x2 y2)).

*****
H0 : lt y1 x2
H : lt x1 x2
x1,y1,x2,y2 : nat
*****
forall _ : eq (Nat.leb x2 y2) true, lt y1 (if Nat.leb x2 y2 then y2 else x2)
+++++
intro y.
-----
Lemma lt_max_12 : forall x1 y1 x2 y2 : nat, x1 < x2 -> y1 < x2 -> max x1 y1 < max x2 y2.
Proof.
intros x1 y1 x2 y2 H H0.
unfold max in |- *.
elim (leb x1 y1).
elim (sumbool_of_bool (leb x2 y2)).
intro y.

*****
y : eq (Nat.leb x2 y2) true
H0 : lt y1 x2
H : lt x1 x2
x1,y1,x2,y2 : nat
*****
lt y1 (if Nat.leb x2 y2 then y2 else x2)
+++++
rewrite y.
-----
Lemma lt_max_12 : forall x1 y1 x2 y2 : nat, x1 < x2 -> y1 < x2 -> max x1 y1 < max x2 y2.
Proof.
intros x1 y1 x2 y2 H H0.
unfold max in |- *.
elim (leb x1 y1).
elim (sumbool_of_bool (leb x2 y2)).
intro y.
rewrite y.

*****
y : eq (Nat.leb x2 y2) true
H0 : lt y1 x2
H : lt x1 x2
x1,y1,x2,y2 : nat
*****
lt y1 y2
+++++
apply lt_le_trans with (m := x2).
-----
Lemma lt_max_12 : forall x1 y1 x2 y2 : nat, x1 < x2 -> y1 < x2 -> max x1 y1 < max x2 y2.
Proof.
intros x1 y1 x2 y2 H H0.
unfold max in |- *.
elim (leb x1 y1).
elim (sumbool_of_bool (leb x2 y2)).
intro y.
rewrite y.
apply lt_le_trans with (m := x2).

*****
y : eq (Nat.leb x2 y2) true
H0 : lt y1 x2
H : lt x1 x2
x1,y1,x2,y2 : nat
*****
lt y1 x2
+++++
assumption.
-----
Lemma lt_max_12 : forall x1 y1 x2 y2 : nat, x1 < x2 -> y1 < x2 -> max x1 y1 < max x2 y2.
Proof.
intros x1 y1 x2 y2 H H0.
unfold max in |- *.
elim (leb x1 y1).
elim (sumbool_of_bool (leb x2 y2)).
intro y.
rewrite y.
apply lt_le_trans with (m := x2).

*****
y : eq (Nat.leb x2 y2) true
H0 : lt y1 x2
H : lt x1 x2
x1,y1,x2,y2 : nat
*****
le x2 y2
+++++
apply leb_complete.
-----
Lemma lt_max_12 : forall x1 y1 x2 y2 : nat, x1 < x2 -> y1 < x2 -> max x1 y1 < max x2 y2.
Proof.
intros x1 y1 x2 y2 H H0.
unfold max in |- *.
elim (leb x1 y1).
elim (sumbool_of_bool (leb x2 y2)).
intro y.
rewrite y.
apply lt_le_trans with (m := x2).
apply leb_complete.

*****
y : eq (Nat.leb x2 y2) true
H0 : lt y1 x2
H : lt x1 x2
x1,y1,x2,y2 : nat
*****
eq (Nat.leb x2 y2) true
+++++
assumption.
-----
Lemma lt_max_12 : forall x1 y1 x2 y2 : nat, x1 < x2 -> y1 < x2 -> max x1 y1 < max x2 y2.
Proof.
intros x1 y1 x2 y2 H H0.
unfold max in |- *.
elim (leb x1 y1).
elim (sumbool_of_bool (leb x2 y2)).

*****
H0 : lt y1 x2
H : lt x1 x2
x1,y1,x2,y2 : nat
*****
forall _ : eq (Nat.leb x2 y2) false, lt y1 (if Nat.leb x2 y2 then y2 else x2)
+++++
intro y.
-----
Lemma lt_max_12 : forall x1 y1 x2 y2 : nat, x1 < x2 -> y1 < x2 -> max x1 y1 < max x2 y2.
Proof.
intros x1 y1 x2 y2 H H0.
unfold max in |- *.
elim (leb x1 y1).
elim (sumbool_of_bool (leb x2 y2)).
intro y.

*****
y : eq (Nat.leb x2 y2) false
H0 : lt y1 x2
H : lt x1 x2
x1,y1,x2,y2 : nat
*****
lt y1 (if Nat.leb x2 y2 then y2 else x2)
+++++
rewrite y.
-----
Lemma lt_max_12 : forall x1 y1 x2 y2 : nat, x1 < x2 -> y1 < x2 -> max x1 y1 < max x2 y2.
Proof.
intros x1 y1 x2 y2 H H0.
unfold max in |- *.
elim (leb x1 y1).
elim (sumbool_of_bool (leb x2 y2)).
intro y.
rewrite y.

*****
y : eq (Nat.leb x2 y2) false
H0 : lt y1 x2
H : lt x1 x2
x1,y1,x2,y2 : nat
*****
lt y1 x2
+++++
assumption.
-----
Lemma lt_max_12 : forall x1 y1 x2 y2 : nat, x1 < x2 -> y1 < x2 -> max x1 y1 < max x2 y2.
Proof.
intros x1 y1 x2 y2 H H0.
unfold max in |- *.
elim (leb x1 y1).

*****
H0 : lt y1 x2
H : lt x1 x2
x1,y1,x2,y2 : nat
*****
lt x1 (if Nat.leb x2 y2 then y2 else x2)
+++++
elim (sumbool_of_bool (leb x2 y2)).
-----
Lemma lt_max_12 : forall x1 y1 x2 y2 : nat, x1 < x2 -> y1 < x2 -> max x1 y1 < max x2 y2.
Proof.
intros x1 y1 x2 y2 H H0.
unfold max in |- *.
elim (leb x1 y1).
elim (sumbool_of_bool (leb x2 y2)).

*****
H0 : lt y1 x2
H : lt x1 x2
x1,y1,x2,y2 : nat
*****
forall _ : eq (Nat.leb x2 y2) true, lt x1 (if Nat.leb x2 y2 then y2 else x2)
+++++
intro y.
-----
Lemma lt_max_12 : forall x1 y1 x2 y2 : nat, x1 < x2 -> y1 < x2 -> max x1 y1 < max x2 y2.
Proof.
intros x1 y1 x2 y2 H H0.
unfold max in |- *.
elim (leb x1 y1).
elim (sumbool_of_bool (leb x2 y2)).
intro y.

*****
y : eq (Nat.leb x2 y2) true
H0 : lt y1 x2
H : lt x1 x2
x1,y1,x2,y2 : nat
*****
lt x1 (if Nat.leb x2 y2 then y2 else x2)
+++++
rewrite y.
-----
Lemma lt_max_12 : forall x1 y1 x2 y2 : nat, x1 < x2 -> y1 < x2 -> max x1 y1 < max x2 y2.
Proof.
intros x1 y1 x2 y2 H H0.
unfold max in |- *.
elim (leb x1 y1).
elim (sumbool_of_bool (leb x2 y2)).
intro y.
rewrite y.

*****
y : eq (Nat.leb x2 y2) true
H0 : lt y1 x2
H : lt x1 x2
x1,y1,x2,y2 : nat
*****
lt x1 y2
+++++
apply lt_le_trans with (m := x2).
-----
Lemma lt_max_12 : forall x1 y1 x2 y2 : nat, x1 < x2 -> y1 < x2 -> max x1 y1 < max x2 y2.
Proof.
intros x1 y1 x2 y2 H H0.
unfold max in |- *.
elim (leb x1 y1).
elim (sumbool_of_bool (leb x2 y2)).
intro y.
rewrite y.
apply lt_le_trans with (m := x2).

*****
y : eq (Nat.leb x2 y2) true
H0 : lt y1 x2
H : lt x1 x2
x1,y1,x2,y2 : nat
*****
lt x1 x2
+++++
assumption.
-----
Lemma lt_max_12 : forall x1 y1 x2 y2 : nat, x1 < x2 -> y1 < x2 -> max x1 y1 < max x2 y2.
Proof.
intros x1 y1 x2 y2 H H0.
unfold max in |- *.
elim (leb x1 y1).
elim (sumbool_of_bool (leb x2 y2)).
intro y.
rewrite y.
apply lt_le_trans with (m := x2).

*****
y : eq (Nat.leb x2 y2) true
H0 : lt y1 x2
H : lt x1 x2
x1,y1,x2,y2 : nat
*****
le x2 y2
+++++
apply leb_complete.
-----
Lemma lt_max_12 : forall x1 y1 x2 y2 : nat, x1 < x2 -> y1 < x2 -> max x1 y1 < max x2 y2.
Proof.
intros x1 y1 x2 y2 H H0.
unfold max in |- *.
elim (leb x1 y1).
elim (sumbool_of_bool (leb x2 y2)).
intro y.
rewrite y.
apply lt_le_trans with (m := x2).
apply leb_complete.

*****
y : eq (Nat.leb x2 y2) true
H0 : lt y1 x2
H : lt x1 x2
x1,y1,x2,y2 : nat
*****
eq (Nat.leb x2 y2) true
+++++
assumption.
-----
Lemma lt_max_12 : forall x1 y1 x2 y2 : nat, x1 < x2 -> y1 < x2 -> max x1 y1 < max x2 y2.
Proof.
intros x1 y1 x2 y2 H H0.
unfold max in |- *.
elim (leb x1 y1).
elim (sumbool_of_bool (leb x2 y2)).

*****
H0 : lt y1 x2
H : lt x1 x2
x1,y1,x2,y2 : nat
*****
forall _ : eq (Nat.leb x2 y2) false, lt x1 (if Nat.leb x2 y2 then y2 else x2)
+++++
intro y.
-----
Lemma lt_max_12 : forall x1 y1 x2 y2 : nat, x1 < x2 -> y1 < x2 -> max x1 y1 < max x2 y2.
Proof.
intros x1 y1 x2 y2 H H0.
unfold max in |- *.
elim (leb x1 y1).
elim (sumbool_of_bool (leb x2 y2)).
intro y.

*****
y : eq (Nat.leb x2 y2) false
H0 : lt y1 x2
H : lt x1 x2
x1,y1,x2,y2 : nat
*****
lt x1 (if Nat.leb x2 y2 then y2 else x2)
+++++
rewrite y.
-----
Lemma lt_max_12 : forall x1 y1 x2 y2 : nat, x1 < x2 -> y1 < x2 -> max x1 y1 < max x2 y2.
Proof.
intros x1 y1 x2 y2 H H0.
unfold max in |- *.
elim (leb x1 y1).
elim (sumbool_of_bool (leb x2 y2)).
intro y.
rewrite y.

*****
y : eq (Nat.leb x2 y2) false
H0 : lt y1 x2
H : lt x1 x2
x1,y1,x2,y2 : nat
*****
lt x1 x2
+++++
assumption.
-----
Lemma lt_max_12 : forall x1 y1 x2 y2 : nat, x1 < x2 -> y1 < x2 -> max x1 y1 < max x2 y2.
Proof.
intros x1 y1 x2 y2 H H0.
unfold max in |- *.
elim (leb x1 y1).

*****

*****

+++++
Qed.
-----
Lemma BDDcompare_eq :\n forall x y : BDDvar, BDDcompare x y = Datatypes.Eq -> x = y.
-----
Lemma BDDcompare_eq : forall x y : BDDvar, BDDcompare x y = Datatypes.Eq -> x = y.

*****

*****
forall (x y : BDDvar) (_ : eq (BDDcompare x y) Eq), eq x y
+++++
Proof.
-----
Lemma BDDcompare_eq : forall x y : BDDvar, BDDcompare x y = Datatypes.Eq -> x = y.
Proof.

*****

*****
forall (x y : BDDvar) (_ : eq (BDDcompare x y) Eq), eq x y
+++++
double induction x y.
-----
Lemma BDDcompare_eq : forall x y : BDDvar, BDDcompare x y = Datatypes.Eq -> x = y.
Proof.
double induction x y.

*****
x,y : BDDvar
*****
forall _ : eq (BDDcompare N0 N0) Eq, eq N0 N0
+++++
reflexivity.
-----
Lemma BDDcompare_eq : forall x y : BDDvar, BDDcompare x y = Datatypes.Eq -> x = y.
Proof.
double induction x y.

*****
x,y : BDDvar
*****
forall (p : positive) (_ : eq (BDDcompare N0 (Npos p)) Eq), eq N0 (Npos p)
+++++
simpl in |- *.
-----
Lemma BDDcompare_eq : forall x y : BDDvar, BDDcompare x y = Datatypes.Eq -> x = y.
Proof.
double induction x y.
simpl in |- *.

*****
x,y : BDDvar
*****
forall (p : positive) (_ : eq Lt Eq), eq N0 (Npos p)
+++++
intros.
-----
Lemma BDDcompare_eq : forall x y : BDDvar, BDDcompare x y = Datatypes.Eq -> x = y.
Proof.
double induction x y.
simpl in |- *.
intros.

*****
H : eq Lt Eq
p : positive
x,y : BDDvar
*****
eq N0 (Npos p)
+++++
discriminate.
-----
Lemma BDDcompare_eq : forall x y : BDDvar, BDDcompare x y = Datatypes.Eq -> x = y.
Proof.
double induction x y.

*****
x,y : BDDvar
*****
forall (p : positive) (_ : eq (BDDcompare (Npos p) N0) Eq), eq (Npos p) N0
+++++
simpl in |- *.
-----
Lemma BDDcompare_eq : forall x y : BDDvar, BDDcompare x y = Datatypes.Eq -> x = y.
Proof.
double induction x y.
simpl in |- *.

*****
x,y : BDDvar
*****
forall (p : positive) (_ : eq Gt Eq), eq (Npos p) N0
+++++
intros.
-----
Lemma BDDcompare_eq : forall x y : BDDvar, BDDcompare x y = Datatypes.Eq -> x = y.
Proof.
double induction x y.
simpl in |- *.
intros.

*****
H : eq Gt Eq
p : positive
x,y : BDDvar
*****
eq (Npos p) N0
+++++
discriminate.
-----
Lemma BDDcompare_eq : forall x y : BDDvar, BDDcompare x y = Datatypes.Eq -> x = y.
Proof.
double induction x y.

*****
x,y : BDDvar
*****
forall (p p0 : positive) (_ : eq (BDDcompare (Npos p0) (Npos p)) Eq), eq (Npos p0) (Npos p)
+++++
simpl in |- *.
-----
Lemma BDDcompare_eq : forall x y : BDDvar, BDDcompare x y = Datatypes.Eq -> x = y.
Proof.
double induction x y.
simpl in |- *.

*****
x,y : BDDvar
*****
forall (p p0 : positive) (_ : eq (Pos.compare_cont Eq p0 p) Eq), eq (Npos p0) (Npos p)
+++++
intros p p0 H.
-----
Lemma BDDcompare_eq : forall x y : BDDvar, BDDcompare x y = Datatypes.Eq -> x = y.
Proof.
double induction x y.
simpl in |- *.
intros p p0 H.

*****
H : eq (Pos.compare_cont Eq p0 p) Eq
p,p0 : positive
x,y : BDDvar
*****
eq (Npos p0) (Npos p)
+++++
cut (p0 = p).
-----
Lemma BDDcompare_eq : forall x y : BDDvar, BDDcompare x y = Datatypes.Eq -> x = y.
Proof.
double induction x y.
simpl in |- *.
intros p p0 H.
cut (p0 = p).

*****
H : eq (Pos.compare_cont Eq p0 p) Eq
p,p0 : positive
x,y : BDDvar
*****
forall _ : eq p0 p, eq (Npos p0) (Npos p)
+++++
intro H0.
-----
Lemma BDDcompare_eq : forall x y : BDDvar, BDDcompare x y = Datatypes.Eq -> x = y.
Proof.
double induction x y.
simpl in |- *.
intros p p0 H.
cut (p0 = p).
intro H0.

*****
H0 : eq p0 p
H : eq (Pos.compare_cont Eq p0 p) Eq
p,p0 : positive
x,y : BDDvar
*****
eq (Npos p0) (Npos p)
+++++
rewrite H0.
-----
Lemma BDDcompare_eq : forall x y : BDDvar, BDDcompare x y = Datatypes.Eq -> x = y.
Proof.
double induction x y.
simpl in |- *.
intros p p0 H.
cut (p0 = p).
intro H0.
rewrite H0.

*****
H0 : eq p0 p
H : eq (Pos.compare_cont Eq p0 p) Eq
p,p0 : positive
x,y : BDDvar
*****
eq (Npos p) (Npos p)
+++++
reflexivity.
-----
Lemma BDDcompare_eq : forall x y : BDDvar, BDDcompare x y = Datatypes.Eq -> x = y.
Proof.
double induction x y.
simpl in |- *.
intros p p0 H.
cut (p0 = p).

*****
H : eq (Pos.compare_cont Eq p0 p) Eq
p,p0 : positive
x,y : BDDvar
*****
eq p0 p
+++++
apply Pcompare_Eq_eq.
-----
Lemma BDDcompare_eq : forall x y : BDDvar, BDDcompare x y = Datatypes.Eq -> x = y.
Proof.
double induction x y.
simpl in |- *.
intros p p0 H.
cut (p0 = p).
apply Pcompare_Eq_eq.

*****
H : eq (Pos.compare_cont Eq p0 p) Eq
p,p0 : positive
x,y : BDDvar
*****
eq (Pos.compare_cont Eq p0 p) Eq
+++++
assumption.
-----
Lemma BDDcompare_eq : forall x y : BDDvar, BDDcompare x y = Datatypes.Eq -> x = y.
Proof.
double induction x y.

*****

*****

+++++
Qed.
-----
