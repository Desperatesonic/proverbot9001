From Coq Require Import List.
-----
From Coq Require Import Arith.
-----
Require Import BellantoniCook.Lib BellantoniCook.BC BellantoniCook.BCI BellantoniCook.BCI_to_BC.
-----
Fixpoint convI (e : BC) : BCI :=\n  match e with\n    | zero => zeroI\n    | proj n s i =>\n      if leb (S i) n then projIn i else projIs (i - n)\n    | succ b => succI b\n    | pred => predI\n    | cond => condI\n    | rec g h0 h1 => recI (convI g) (convI h0) (convI h1)\n    | comp n s g ln ls =>\n      compI (convI g) (map convI ln) (map convI ls)\n  end.
-----
Opaque maxl.
-----
Lemma convI_inf_correct : forall (e : BC) n s,\n  arities e = ok_arities n s ->\n  exists n', exists s', \n    n' <= n /\ s' <= s /\ inf (convI e) = I n' s'.
-----
Lemma convI_inf_correct : forall (e : BC) n s, arities e = ok_arities n s -> exists n', exists s', n' <= n /\\ s' <= s /\\ inf (convI e) = I n' s'.

*****

*****
forall (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), ex (fun n' : nat => ex (fun s' : nat => and (le n' n) (and (le s' s) (eq (inf (convI e)) (I n' s')))))
+++++
Proof.
-----
Lemma convI_inf_correct : forall (e : BC) n s, arities e = ok_arities n s -> exists n', exists s', n' <= n /\\ s' <= s /\\ inf (convI e) = I n' s'.
Proof.

*****

*****
forall (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), ex (fun n' : nat => ex (fun s' : nat => and (le n' n) (and (le s' s) (eq (inf (convI e)) (I n' s')))))
+++++
apply BC_ind_inf; simpl; intros.
-----
Lemma convI_inf_correct : forall (e : BC) n s, arities e = ok_arities n s -> exists n', exists s', n' <= n /\\ s' <= s /\\ inf (convI e) = I n' s'.
Proof.
apply BC_ind_inf; simpl; intros.

*****

*****
ex (fun n' : nat => ex (fun s' : nat => and (le n' Datatypes.O) (and (le s' Datatypes.O) (eq (I Datatypes.O Datatypes.O) (I n' s')))))
+++++
exists 0; exists 0; auto.
-----
Lemma convI_inf_correct : forall (e : BC) n s, arities e = ok_arities n s -> exists n', exists s', n' <= n /\\ s' <= s /\\ inf (convI e) = I n' s'.
Proof.
apply BC_ind_inf; simpl; intros.
exists 0; exists 0; auto.

*****
H : lt i (Init.Nat.add n s)
n,s,i : nat
*****
ex (fun n' : nat => ex (fun s' : nat => and (le n' n) (and (le s' s) (eq (inf (if match n with | Datatypes.O => false | S m' => Nat.leb i m' end then projIn i else projIs (Init.Nat.sub i n))) (I n' s')))))
+++++
destruct n; simpl.
-----
Lemma convI_inf_correct : forall (e : BC) n s, arities e = ok_arities n s -> exists n', exists s', n' <= n /\\ s' <= s /\\ inf (convI e) = I n' s'.
Proof.
apply BC_ind_inf; simpl; intros.
exists 0; exists 0; auto.
destruct n; simpl.

*****
H : lt i (Init.Nat.add Datatypes.O s)
s,i : nat
*****
ex (fun n' : nat => ex (fun s' : nat => and (le n' Datatypes.O) (and (le s' s) (eq (I Datatypes.O (S (Init.Nat.sub i Datatypes.O))) (I n' s')))))
+++++
exists 0; exists (S (i - 0)).
-----
Lemma convI_inf_correct : forall (e : BC) n s, arities e = ok_arities n s -> exists n', exists s', n' <= n /\\ s' <= s /\\ inf (convI e) = I n' s'.
Proof.
apply BC_ind_inf; simpl; intros.
exists 0; exists 0; auto.
destruct n; simpl.
exists 0; exists (S (i - 0)).

*****
H : lt i (Init.Nat.add Datatypes.O s)
s,i : nat
*****
and (le Datatypes.O Datatypes.O) (and (le (S (Init.Nat.sub i Datatypes.O)) s) (eq (I Datatypes.O (S (Init.Nat.sub i Datatypes.O))) (I Datatypes.O (S (Init.Nat.sub i Datatypes.O)))))
+++++
repeat (split; try omega).
-----
Lemma convI_inf_correct : forall (e : BC) n s, arities e = ok_arities n s -> exists n', exists s', n' <= n /\\ s' <= s /\\ inf (convI e) = I n' s'.
Proof.
apply BC_ind_inf; simpl; intros.
exists 0; exists 0; auto.
destruct n; simpl.
exists 0; exists (S (i - 0)).
repeat (split; try omega).

*****
H : lt i (Init.Nat.add (S n) s)
n,s,i : nat
*****
ex (fun n' : nat => ex (fun s' : nat => and (le n' (S n)) (and (le s' s) (eq (inf (if Nat.leb i n then projIn i else projIs (Init.Nat.sub i (S n)))) (I n' s')))))
+++++
case_eq (leb i n); intros; simpl.
-----
Lemma convI_inf_correct : forall (e : BC) n s, arities e = ok_arities n s -> exists n', exists s', n' <= n /\\ s' <= s /\\ inf (convI e) = I n' s'.
Proof.
apply BC_ind_inf; simpl; intros.
exists 0; exists 0; auto.
destruct n; simpl.
exists 0; exists (S (i - 0)).
repeat (split; try omega).
case_eq (leb i n); intros; simpl.

*****
H0 : eq (Nat.leb i n) true
H : lt i (Init.Nat.add (S n) s)
n,s,i : nat
*****
ex (fun n' : nat => ex (fun s' : nat => and (le n' (S n)) (and (le s' s) (eq (I (S i) Datatypes.O) (I n' s')))))
+++++
apply leb_complete in H0.
-----
Lemma convI_inf_correct : forall (e : BC) n s, arities e = ok_arities n s -> exists n', exists s', n' <= n /\\ s' <= s /\\ inf (convI e) = I n' s'.
Proof.
apply BC_ind_inf; simpl; intros.
exists 0; exists 0; auto.
destruct n; simpl.
exists 0; exists (S (i - 0)).
repeat (split; try omega).
case_eq (leb i n); intros; simpl.
apply leb_complete in H0.

*****
H0 : le i n
H : lt i (Init.Nat.add (S n) s)
n,s,i : nat
*****
ex (fun n' : nat => ex (fun s' : nat => and (le n' (S n)) (and (le s' s) (eq (I (S i) Datatypes.O) (I n' s')))))
+++++
exists (S i); exists 0.
-----
Lemma convI_inf_correct : forall (e : BC) n s, arities e = ok_arities n s -> exists n', exists s', n' <= n /\\ s' <= s /\\ inf (convI e) = I n' s'.
Proof.
apply BC_ind_inf; simpl; intros.
exists 0; exists 0; auto.
destruct n; simpl.
exists 0; exists (S (i - 0)).
repeat (split; try omega).
case_eq (leb i n); intros; simpl.
apply leb_complete in H0.
exists (S i); exists 0.

*****
H0 : le i n
H : lt i (Init.Nat.add (S n) s)
n,s,i : nat
*****
and (le (S i) (S n)) (and (le Datatypes.O s) (eq (I (S i) Datatypes.O) (I (S i) Datatypes.O)))
+++++
repeat (split; try omega).
-----
Lemma convI_inf_correct : forall (e : BC) n s, arities e = ok_arities n s -> exists n', exists s', n' <= n /\\ s' <= s /\\ inf (convI e) = I n' s'.
Proof.
apply BC_ind_inf; simpl; intros.
exists 0; exists 0; auto.
destruct n; simpl.
exists 0; exists (S (i - 0)).
repeat (split; try omega).
case_eq (leb i n); intros; simpl.
apply leb_complete in H0.
exists (S i); exists 0.
repeat (split; try omega).

*****
H0 : eq (Nat.leb i n) false
H : lt i (Init.Nat.add (S n) s)
n,s,i : nat
*****
ex (fun n' : nat => ex (fun s' : nat => and (le n' (S n)) (and (le s' s) (eq (I Datatypes.O (S (Init.Nat.sub i (S n)))) (I n' s')))))
+++++
apply leb_complete_conv in H0.
-----
Lemma convI_inf_correct : forall (e : BC) n s, arities e = ok_arities n s -> exists n', exists s', n' <= n /\\ s' <= s /\\ inf (convI e) = I n' s'.
Proof.
apply BC_ind_inf; simpl; intros.
exists 0; exists 0; auto.
destruct n; simpl.
exists 0; exists (S (i - 0)).
repeat (split; try omega).
case_eq (leb i n); intros; simpl.
apply leb_complete in H0.
exists (S i); exists 0.
repeat (split; try omega).
apply leb_complete_conv in H0.

*****
H0 : lt n i
H : lt i (Init.Nat.add (S n) s)
n,s,i : nat
*****
ex (fun n' : nat => ex (fun s' : nat => and (le n' (S n)) (and (le s' s) (eq (I Datatypes.O (S (Init.Nat.sub i (S n)))) (I n' s')))))
+++++
exists 0; exists (S (i - S n)).
-----
Lemma convI_inf_correct : forall (e : BC) n s, arities e = ok_arities n s -> exists n', exists s', n' <= n /\\ s' <= s /\\ inf (convI e) = I n' s'.
Proof.
apply BC_ind_inf; simpl; intros.
exists 0; exists 0; auto.
destruct n; simpl.
exists 0; exists (S (i - 0)).
repeat (split; try omega).
case_eq (leb i n); intros; simpl.
apply leb_complete in H0.
exists (S i); exists 0.
repeat (split; try omega).
apply leb_complete_conv in H0.
exists 0; exists (S (i - S n)).

*****
H0 : lt n i
H : lt i (Init.Nat.add (S n) s)
n,s,i : nat
*****
and (le Datatypes.O (S n)) (and (le (S (Init.Nat.sub i (S n))) s) (eq (I Datatypes.O (S (Init.Nat.sub i (S n)))) (I Datatypes.O (S (Init.Nat.sub i (S n))))))
+++++
repeat (split; try omega).
-----
Lemma convI_inf_correct : forall (e : BC) n s, arities e = ok_arities n s -> exists n', exists s', n' <= n /\\ s' <= s /\\ inf (convI e) = I n' s'.
Proof.
apply BC_ind_inf; simpl; intros.
exists 0; exists 0; auto.
destruct n; simpl.
exists 0; exists (S (i - 0)).
repeat (split; try omega).
case_eq (leb i n); intros; simpl.
apply leb_complete in H0.
exists (S i); exists 0.
repeat (split; try omega).
apply leb_complete_conv in H0.
exists 0; exists (S (i - S n)).
repeat (split; try omega).

*****
b : bool
*****
ex (fun n' : nat => ex (fun s' : nat => and (le n' Datatypes.O) (and (le s' (S Datatypes.O)) (eq (I Datatypes.O (S Datatypes.O)) (I n' s')))))
+++++
exists 0; exists 1; auto.
-----
Lemma convI_inf_correct : forall (e : BC) n s, arities e = ok_arities n s -> exists n', exists s', n' <= n /\\ s' <= s /\\ inf (convI e) = I n' s'.
Proof.
apply BC_ind_inf; simpl; intros.
exists 0; exists 0; auto.
destruct n; simpl.
exists 0; exists (S (i - 0)).
repeat (split; try omega).
case_eq (leb i n); intros; simpl.
apply leb_complete in H0.
exists (S i); exists 0.
repeat (split; try omega).
apply leb_complete_conv in H0.
exists 0; exists (S (i - S n)).
repeat (split; try omega).
exists 0; exists 1; auto.

*****

*****
ex (fun n' : nat => ex (fun s' : nat => and (le n' Datatypes.O) (and (le s' (S Datatypes.O)) (eq (I Datatypes.O (S Datatypes.O)) (I n' s')))))
+++++
exists 0; exists 1; auto.
-----
Lemma convI_inf_correct : forall (e : BC) n s, arities e = ok_arities n s -> exists n', exists s', n' <= n /\\ s' <= s /\\ inf (convI e) = I n' s'.
Proof.
apply BC_ind_inf; simpl; intros.
exists 0; exists 0; auto.
destruct n; simpl.
exists 0; exists (S (i - 0)).
repeat (split; try omega).
case_eq (leb i n); intros; simpl.
apply leb_complete in H0.
exists (S i); exists 0.
repeat (split; try omega).
apply leb_complete_conv in H0.
exists 0; exists (S (i - S n)).
repeat (split; try omega).
exists 0; exists 1; auto.
exists 0; exists 1; auto.

*****

*****
ex (fun n' : nat => ex (fun s' : nat => and (le n' Datatypes.O) (and (le s' (S (S (S (S Datatypes.O))))) (eq (I Datatypes.O (S (S (S (S Datatypes.O))))) (I n' s')))))
+++++
exists 0; exists 4; auto.
-----
Lemma convI_inf_correct : forall (e : BC) n s, arities e = ok_arities n s -> exists n', exists s', n' <= n /\\ s' <= s /\\ inf (convI e) = I n' s'.
Proof.
apply BC_ind_inf; simpl; intros.
exists 0; exists 0; auto.
destruct n; simpl.
exists 0; exists (S (i - 0)).
repeat (split; try omega).
case_eq (leb i n); intros; simpl.
apply leb_complete in H0.
exists (S i); exists 0.
repeat (split; try omega).
apply leb_complete_conv in H0.
exists 0; exists (S (i - S n)).
repeat (split; try omega).
exists 0; exists 1; auto.
exists 0; exists 1; auto.
exists 0; exists 4; auto.

*****
H4 : ex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' (S n))\n (and (le s' (S s)) (eq (inf (convI h1)) (I n' s')))))
H3 : ex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' (S n))\n (and (le s' (S s)) (eq (inf (convI h0)) (I n' s')))))
H2 : ex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n) (and (le s' s) (eq (inf (convI g)) (I n' s')))))
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
*****
ex (fun n' : nat => ex (fun s' : nat => and (le n' (S n)) (and (le s' s) (eq match inf (convI g) with | I gn gs => match inf (convI h0) with | I h0n h0s => match inf (convI h1) with | I h1n h1s => I (maxl (cons (S gn) (cons h0n (cons h1n nil)))) (maxl (cons gs (cons (Init.Nat.sub h0s (S Datatypes.O)) (cons (Init.Nat.sub h1s (S Datatypes.O)) nil)))) | E _ => E (Enat (S Datatypes.O)) end | E _ => E (Enat (S Datatypes.O)) end | E _ => E (Enat (S Datatypes.O)) end (I n' s')))))
+++++
destruct H2 as (ne1 & se1 & He1).
-----
Lemma convI_inf_correct : forall (e : BC) n s, arities e = ok_arities n s -> exists n', exists s', n' <= n /\\ s' <= s /\\ inf (convI e) = I n' s'.
Proof.
apply BC_ind_inf; simpl; intros.
exists 0; exists 0; auto.
destruct n; simpl.
exists 0; exists (S (i - 0)).
repeat (split; try omega).
case_eq (leb i n); intros; simpl.
apply leb_complete in H0.
exists (S i); exists 0.
repeat (split; try omega).
apply leb_complete_conv in H0.
exists 0; exists (S (i - S n)).
repeat (split; try omega).
exists 0; exists 1; auto.
exists 0; exists 1; auto.
exists 0; exists 4; auto.
destruct H2 as (ne1 & se1 & He1).

*****
H4 : ex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' (S n))\n (and (le s' (S s)) (eq (inf (convI h1)) (I n' s')))))
H3 : ex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' (S n))\n (and (le s' (S s)) (eq (inf (convI h0)) (I n' s')))))
He1 : and (le ne1 n) (and (le se1 s) (eq (inf (convI g)) (I ne1 se1)))
ne1,se1 : nat
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
*****
ex (fun n' : nat => ex (fun s' : nat => and (le n' (S n)) (and (le s' s) (eq match inf (convI g) with | I gn gs => match inf (convI h0) with | I h0n h0s => match inf (convI h1) with | I h1n h1s => I (maxl (cons (S gn) (cons h0n (cons h1n nil)))) (maxl (cons gs (cons (Init.Nat.sub h0s (S Datatypes.O)) (cons (Init.Nat.sub h1s (S Datatypes.O)) nil)))) | E _ => E (Enat (S Datatypes.O)) end | E _ => E (Enat (S Datatypes.O)) end | E _ => E (Enat (S Datatypes.O)) end (I n' s')))))
+++++
destruct H3 as (ne2 & se2 & He2).
-----
Lemma convI_inf_correct : forall (e : BC) n s, arities e = ok_arities n s -> exists n', exists s', n' <= n /\\ s' <= s /\\ inf (convI e) = I n' s'.
Proof.
apply BC_ind_inf; simpl; intros.
exists 0; exists 0; auto.
destruct n; simpl.
exists 0; exists (S (i - 0)).
repeat (split; try omega).
case_eq (leb i n); intros; simpl.
apply leb_complete in H0.
exists (S i); exists 0.
repeat (split; try omega).
apply leb_complete_conv in H0.
exists 0; exists (S (i - S n)).
repeat (split; try omega).
exists 0; exists 1; auto.
exists 0; exists 1; auto.
exists 0; exists 4; auto.
destruct H2 as (ne1 & se1 & He1).
destruct H3 as (ne2 & se2 & He2).

*****
H4 : ex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' (S n))\n (and (le s' (S s)) (eq (inf (convI h1)) (I n' s')))))
He2 : and (le ne2 (S n))\n (and (le se2 (S s)) (eq (inf (convI h0)) (I ne2 se2)))
ne2,se2 : nat
He1 : and (le ne1 n) (and (le se1 s) (eq (inf (convI g)) (I ne1 se1)))
ne1,se1 : nat
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
*****
ex (fun n' : nat => ex (fun s' : nat => and (le n' (S n)) (and (le s' s) (eq match inf (convI g) with | I gn gs => match inf (convI h0) with | I h0n h0s => match inf (convI h1) with | I h1n h1s => I (maxl (cons (S gn) (cons h0n (cons h1n nil)))) (maxl (cons gs (cons (Init.Nat.sub h0s (S Datatypes.O)) (cons (Init.Nat.sub h1s (S Datatypes.O)) nil)))) | E _ => E (Enat (S Datatypes.O)) end | E _ => E (Enat (S Datatypes.O)) end | E _ => E (Enat (S Datatypes.O)) end (I n' s')))))
+++++
destruct H4 as (ne3 & se3 & He3).
-----
Lemma convI_inf_correct : forall (e : BC) n s, arities e = ok_arities n s -> exists n', exists s', n' <= n /\\ s' <= s /\\ inf (convI e) = I n' s'.
Proof.
apply BC_ind_inf; simpl; intros.
exists 0; exists 0; auto.
destruct n; simpl.
exists 0; exists (S (i - 0)).
repeat (split; try omega).
case_eq (leb i n); intros; simpl.
apply leb_complete in H0.
exists (S i); exists 0.
repeat (split; try omega).
apply leb_complete_conv in H0.
exists 0; exists (S (i - S n)).
repeat (split; try omega).
exists 0; exists 1; auto.
exists 0; exists 1; auto.
exists 0; exists 4; auto.
destruct H2 as (ne1 & se1 & He1).
destruct H3 as (ne2 & se2 & He2).
destruct H4 as (ne3 & se3 & He3).

*****
He3 : and (le ne3 (S n))\n (and (le se3 (S s)) (eq (inf (convI h1)) (I ne3 se3)))
ne3,se3 : nat
He2 : and (le ne2 (S n))\n (and (le se2 (S s)) (eq (inf (convI h0)) (I ne2 se2)))
ne2,se2 : nat
He1 : and (le ne1 n) (and (le se1 s) (eq (inf (convI g)) (I ne1 se1)))
ne1,se1 : nat
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
*****
ex (fun n' : nat => ex (fun s' : nat => and (le n' (S n)) (and (le s' s) (eq match inf (convI g) with | I gn gs => match inf (convI h0) with | I h0n h0s => match inf (convI h1) with | I h1n h1s => I (maxl (cons (S gn) (cons h0n (cons h1n nil)))) (maxl (cons gs (cons (Init.Nat.sub h0s (S Datatypes.O)) (cons (Init.Nat.sub h1s (S Datatypes.O)) nil)))) | E _ => E (Enat (S Datatypes.O)) end | E _ => E (Enat (S Datatypes.O)) end | E _ => E (Enat (S Datatypes.O)) end (I n' s')))))
+++++
decompose [and] He1; decompose [and] He2; decompose [and] He3.
-----
Lemma convI_inf_correct : forall (e : BC) n s, arities e = ok_arities n s -> exists n', exists s', n' <= n /\\ s' <= s /\\ inf (convI e) = I n' s'.
Proof.
apply BC_ind_inf; simpl; intros.
exists 0; exists 0; auto.
destruct n; simpl.
exists 0; exists (S (i - 0)).
repeat (split; try omega).
case_eq (leb i n); intros; simpl.
apply leb_complete in H0.
exists (S i); exists 0.
repeat (split; try omega).
apply leb_complete_conv in H0.
exists 0; exists (S (i - S n)).
repeat (split; try omega).
exists 0; exists 1; auto.
exists 0; exists 1; auto.
exists 0; exists 4; auto.
destruct H2 as (ne1 & se1 & He1).
destruct H3 as (ne2 & se2 & He2).
destruct H4 as (ne3 & se3 & He3).
decompose [and] He1; decompose [and] He2; decompose [and] He3.

*****
H11 : eq (inf (convI h1)) (I ne3 se3)
H10 : le se3 (S s)
H6 : le ne3 (S n)
H8 : eq (inf (convI h0)) (I ne2 se2)
H7 : le se2 (S s)
H3 : le ne2 (S n)
H5 : eq (inf (convI g)) (I ne1 se1)
H4 : le se1 s
H2 : le ne1 n
He3 : and (le ne3 (S n))\n (and (le se3 (S s)) (eq (inf (convI h1)) (I ne3 se3)))
ne3,se3 : nat
He2 : and (le ne2 (S n))\n (and (le se2 (S s)) (eq (inf (convI h0)) (I ne2 se2)))
ne2,se2 : nat
He1 : and (le ne1 n) (and (le se1 s) (eq (inf (convI g)) (I ne1 se1)))
ne1,se1 : nat
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
*****
ex (fun n' : nat => ex (fun s' : nat => and (le n' (S n)) (and (le s' s) (eq match inf (convI g) with | I gn gs => match inf (convI h0) with | I h0n h0s => match inf (convI h1) with | I h1n h1s => I (maxl (cons (S gn) (cons h0n (cons h1n nil)))) (maxl (cons gs (cons (Init.Nat.sub h0s (S Datatypes.O)) (cons (Init.Nat.sub h1s (S Datatypes.O)) nil)))) | E _ => E (Enat (S Datatypes.O)) end | E _ => E (Enat (S Datatypes.O)) end | E _ => E (Enat (S Datatypes.O)) end (I n' s')))))
+++++
clear He1 He2 He3.
-----
Lemma convI_inf_correct : forall (e : BC) n s, arities e = ok_arities n s -> exists n', exists s', n' <= n /\\ s' <= s /\\ inf (convI e) = I n' s'.
Proof.
apply BC_ind_inf; simpl; intros.
exists 0; exists 0; auto.
destruct n; simpl.
exists 0; exists (S (i - 0)).
repeat (split; try omega).
case_eq (leb i n); intros; simpl.
apply leb_complete in H0.
exists (S i); exists 0.
repeat (split; try omega).
apply leb_complete_conv in H0.
exists 0; exists (S (i - S n)).
repeat (split; try omega).
exists 0; exists 1; auto.
exists 0; exists 1; auto.
exists 0; exists 4; auto.
destruct H2 as (ne1 & se1 & He1).
destruct H3 as (ne2 & se2 & He2).
destruct H4 as (ne3 & se3 & He3).
decompose [and] He1; decompose [and] He2; decompose [and] He3.
clear He1 He2 He3.

*****
H11 : eq (inf (convI h1)) (I ne3 se3)
H10 : le se3 (S s)
H6 : le ne3 (S n)
H8 : eq (inf (convI h0)) (I ne2 se2)
H7 : le se2 (S s)
H3 : le ne2 (S n)
H5 : eq (inf (convI g)) (I ne1 se1)
H4 : le se1 s
H2 : le ne1 n
ne1,se1,ne2,se2,ne3,se3 : nat
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
*****
ex (fun n' : nat => ex (fun s' : nat => and (le n' (S n)) (and (le s' s) (eq match inf (convI g) with | I gn gs => match inf (convI h0) with | I h0n h0s => match inf (convI h1) with | I h1n h1s => I (maxl (cons (S gn) (cons h0n (cons h1n nil)))) (maxl (cons gs (cons (Init.Nat.sub h0s (S Datatypes.O)) (cons (Init.Nat.sub h1s (S Datatypes.O)) nil)))) | E _ => E (Enat (S Datatypes.O)) end | E _ => E (Enat (S Datatypes.O)) end | E _ => E (Enat (S Datatypes.O)) end (I n' s')))))
+++++
rewrite H5, H8, H11.
-----
Lemma convI_inf_correct : forall (e : BC) n s, arities e = ok_arities n s -> exists n', exists s', n' <= n /\\ s' <= s /\\ inf (convI e) = I n' s'.
Proof.
apply BC_ind_inf; simpl; intros.
exists 0; exists 0; auto.
destruct n; simpl.
exists 0; exists (S (i - 0)).
repeat (split; try omega).
case_eq (leb i n); intros; simpl.
apply leb_complete in H0.
exists (S i); exists 0.
repeat (split; try omega).
apply leb_complete_conv in H0.
exists 0; exists (S (i - S n)).
repeat (split; try omega).
exists 0; exists 1; auto.
exists 0; exists 1; auto.
exists 0; exists 4; auto.
destruct H2 as (ne1 & se1 & He1).
destruct H3 as (ne2 & se2 & He2).
destruct H4 as (ne3 & se3 & He3).
decompose [and] He1; decompose [and] He2; decompose [and] He3.
clear He1 He2 He3.
rewrite H5, H8, H11.

*****
H11 : eq (inf (convI h1)) (I ne3 se3)
H10 : le se3 (S s)
H6 : le ne3 (S n)
H8 : eq (inf (convI h0)) (I ne2 se2)
H7 : le se2 (S s)
H3 : le ne2 (S n)
H5 : eq (inf (convI g)) (I ne1 se1)
H4 : le se1 s
H2 : le ne1 n
ne1,se1,ne2,se2,ne3,se3 : nat
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
*****
ex (fun n' : nat => ex (fun s' : nat => and (le n' (S n)) (and (le s' s) (eq (I (maxl (cons (S ne1) (cons ne2 (cons ne3 nil)))) (maxl (cons se1 (cons (Init.Nat.sub se2 (S Datatypes.O)) (cons (Init.Nat.sub se3 (S Datatypes.O)) nil))))) (I n' s')))))
+++++
eexists; eexists.
-----
Lemma convI_inf_correct : forall (e : BC) n s, arities e = ok_arities n s -> exists n', exists s', n' <= n /\\ s' <= s /\\ inf (convI e) = I n' s'.
Proof.
apply BC_ind_inf; simpl; intros.
exists 0; exists 0; auto.
destruct n; simpl.
exists 0; exists (S (i - 0)).
repeat (split; try omega).
case_eq (leb i n); intros; simpl.
apply leb_complete in H0.
exists (S i); exists 0.
repeat (split; try omega).
apply leb_complete_conv in H0.
exists 0; exists (S (i - S n)).
repeat (split; try omega).
exists 0; exists 1; auto.
exists 0; exists 1; auto.
exists 0; exists 4; auto.
destruct H2 as (ne1 & se1 & He1).
destruct H3 as (ne2 & se2 & He2).
destruct H4 as (ne3 & se3 & He3).
decompose [and] He1; decompose [and] He2; decompose [and] He3.
clear He1 He2 He3.
rewrite H5, H8, H11.
eexists; eexists.

*****
H11 : eq (inf (convI h1)) (I ne3 se3)
H10 : le se3 (S s)
H6 : le ne3 (S n)
H8 : eq (inf (convI h0)) (I ne2 se2)
H7 : le se2 (S s)
H3 : le ne2 (S n)
H5 : eq (inf (convI g)) (I ne1 se1)
H4 : le se1 s
H2 : le ne1 n
ne1,se1,ne2,se2,ne3,se3 : nat
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
*****
and (le ?n' (S n)) (and (le ?s' s) (eq (I (maxl (cons (S ne1) (cons ne2 (cons ne3 nil)))) (maxl (cons se1 (cons (Init.Nat.sub se2 (S Datatypes.O)) (cons (Init.Nat.sub se3 (S Datatypes.O)) nil))))) (I ?n' ?s')))
+++++
split; try split.
-----
Lemma convI_inf_correct : forall (e : BC) n s, arities e = ok_arities n s -> exists n', exists s', n' <= n /\\ s' <= s /\\ inf (convI e) = I n' s'.
Proof.
apply BC_ind_inf; simpl; intros.
exists 0; exists 0; auto.
destruct n; simpl.
exists 0; exists (S (i - 0)).
repeat (split; try omega).
case_eq (leb i n); intros; simpl.
apply leb_complete in H0.
exists (S i); exists 0.
repeat (split; try omega).
apply leb_complete_conv in H0.
exists 0; exists (S (i - S n)).
repeat (split; try omega).
exists 0; exists 1; auto.
exists 0; exists 1; auto.
exists 0; exists 4; auto.
destruct H2 as (ne1 & se1 & He1).
destruct H3 as (ne2 & se2 & He2).
destruct H4 as (ne3 & se3 & He3).
decompose [and] He1; decompose [and] He2; decompose [and] He3.
clear He1 He2 He3.
rewrite H5, H8, H11.
eexists; eexists.
split; try split.

*****
H11 : eq (inf (convI h1)) (I ne3 se3)
H10 : le se3 (S s)
H6 : le ne3 (S n)
H8 : eq (inf (convI h0)) (I ne2 se2)
H7 : le se2 (S s)
H3 : le ne2 (S n)
H5 : eq (inf (convI g)) (I ne1 se1)
H4 : le se1 s
H2 : le ne1 n
ne1,se1,ne2,se2,ne3,se3 : nat
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
*****
le ?n' (S n)
+++++
3: eauto.
-----
Lemma convI_inf_correct : forall (e : BC) n s, arities e = ok_arities n s -> exists n', exists s', n' <= n /\\ s' <= s /\\ inf (convI e) = I n' s'.
Proof.
apply BC_ind_inf; simpl; intros.
exists 0; exists 0; auto.
destruct n; simpl.
exists 0; exists (S (i - 0)).
repeat (split; try omega).
case_eq (leb i n); intros; simpl.
apply leb_complete in H0.
exists (S i); exists 0.
repeat (split; try omega).
apply leb_complete_conv in H0.
exists 0; exists (S (i - S n)).
repeat (split; try omega).
exists 0; exists 1; auto.
exists 0; exists 1; auto.
exists 0; exists 4; auto.
destruct H2 as (ne1 & se1 & He1).
destruct H3 as (ne2 & se2 & He2).
destruct H4 as (ne3 & se3 & He3).
decompose [and] He1; decompose [and] He2; decompose [and] He3.
clear He1 He2 He3.
rewrite H5, H8, H11.
eexists; eexists.
split; try split.
3: eauto.

*****
H11 : eq (inf (convI h1)) (I ne3 se3)
H10 : le se3 (S s)
H6 : le ne3 (S n)
H8 : eq (inf (convI h0)) (I ne2 se2)
H7 : le se2 (S s)
H3 : le ne2 (S n)
H5 : eq (inf (convI g)) (I ne1 se1)
H4 : le se1 s
H2 : le ne1 n
ne1,se1,ne2,se2,ne3,se3 : nat
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
*****
le (maxl (cons (S ne1) (cons ne2 (cons ne3 nil)))) (S n)
+++++
apply maxl_bound; omega.
-----
Lemma convI_inf_correct : forall (e : BC) n s, arities e = ok_arities n s -> exists n', exists s', n' <= n /\\ s' <= s /\\ inf (convI e) = I n' s'.
Proof.
apply BC_ind_inf; simpl; intros.
exists 0; exists 0; auto.
destruct n; simpl.
exists 0; exists (S (i - 0)).
repeat (split; try omega).
case_eq (leb i n); intros; simpl.
apply leb_complete in H0.
exists (S i); exists 0.
repeat (split; try omega).
apply leb_complete_conv in H0.
exists 0; exists (S (i - S n)).
repeat (split; try omega).
exists 0; exists 1; auto.
exists 0; exists 1; auto.
exists 0; exists 4; auto.
destruct H2 as (ne1 & se1 & He1).
destruct H3 as (ne2 & se2 & He2).
destruct H4 as (ne3 & se3 & He3).
decompose [and] He1; decompose [and] He2; decompose [and] He3.
clear He1 He2 He3.
rewrite H5, H8, H11.
eexists; eexists.
split; try split.
3: eauto.
apply maxl_bound; omega.

*****
H11 : eq (inf (convI h1)) (I ne3 se3)
H10 : le se3 (S s)
H6 : le ne3 (S n)
H8 : eq (inf (convI h0)) (I ne2 se2)
H7 : le se2 (S s)
H3 : le ne2 (S n)
H5 : eq (inf (convI g)) (I ne1 se1)
H4 : le se1 s
H2 : le ne1 n
ne1,se1,ne2,se2,ne3,se3 : nat
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
*****
le (maxl (cons se1 (cons (Init.Nat.sub se2 (S Datatypes.O)) (cons (Init.Nat.sub se3 (S Datatypes.O)) nil)))) s
+++++
apply maxl_bound; omega.
-----
Lemma convI_inf_correct : forall (e : BC) n s, arities e = ok_arities n s -> exists n', exists s', n' <= n /\\ s' <= s /\\ inf (convI e) = I n' s'.
Proof.
apply BC_ind_inf; simpl; intros.
exists 0; exists 0; auto.
destruct n; simpl.
exists 0; exists (S (i - 0)).
repeat (split; try omega).
case_eq (leb i n); intros; simpl.
apply leb_complete in H0.
exists (S i); exists 0.
repeat (split; try omega).
apply leb_complete_conv in H0.
exists 0; exists (S (i - S n)).
repeat (split; try omega).
exists 0; exists 1; auto.
exists 0; exists 1; auto.
exists 0; exists 4; auto.
destruct H2 as (ne1 & se1 & He1).
destruct H3 as (ne2 & se2 & He2).
destruct H4 as (ne3 & se3 & He3).
decompose [and] He1; decompose [and] He2; decompose [and] He3.
clear He1 He2 He3.
rewrite H5, H8, H11.
eexists; eexists.
split; try split.
3: eauto.
apply maxl_bound; omega.
apply maxl_bound; omega.

*****
H4 : forall (r : BC) (_ : In r tl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n) (and (le s' s) (eq (inf (convI r)) (I n' s')))))
H3 : forall (r : BC) (_ : In r rl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n)\n (and (le s' Datatypes.O) (eq (inf (convI r)) (I n' s')))))
H2 : ex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' (length rl))\n (and (le s' (length tl)) (eq (inf (convI h)) (I n' s')))))
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl),\neq (arities e) (ok_arities n Datatypes.O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
ex (fun n' : nat => ex (fun s' : nat => and (le n' n) (and (le s' s) (eq match inf (convI h) with | I hn hs => if andb (Nat.leb hn (length (map convI rl))) (Nat.leb hs (length (map convI tl))) then match inf_list (map inf (map convI rl)) with | I nnl snl => match inf_list (map inf (map convI tl)) with | I nsl ssl => if Nat.eqb snl Datatypes.O then I (Init.Nat.max nnl nsl) ssl else E (Enat (S (S (S (S Datatypes.O))))) | E _ => E (Enat (S (S (S (S (S Datatypes.O)))))) end | E _ => E (Enat (S (S (S (S (S Datatypes.O)))))) end else E (Enat (S (S (S (S (S (S Datatypes.O))))))) | E e => E e end (I n' s')))))
+++++
destruct H2 as (ne & se & He).
-----
Lemma convI_inf_correct : forall (e : BC) n s, arities e = ok_arities n s -> exists n', exists s', n' <= n /\\ s' <= s /\\ inf (convI e) = I n' s'.
Proof.
apply BC_ind_inf; simpl; intros.
exists 0; exists 0; auto.
destruct n; simpl.
exists 0; exists (S (i - 0)).
repeat (split; try omega).
case_eq (leb i n); intros; simpl.
apply leb_complete in H0.
exists (S i); exists 0.
repeat (split; try omega).
apply leb_complete_conv in H0.
exists 0; exists (S (i - S n)).
repeat (split; try omega).
exists 0; exists 1; auto.
exists 0; exists 1; auto.
exists 0; exists 4; auto.
destruct H2 as (ne1 & se1 & He1).
destruct H3 as (ne2 & se2 & He2).
destruct H4 as (ne3 & se3 & He3).
decompose [and] He1; decompose [and] He2; decompose [and] He3.
clear He1 He2 He3.
rewrite H5, H8, H11.
eexists; eexists.
split; try split.
3: eauto.
apply maxl_bound; omega.
apply maxl_bound; omega.
destruct H2 as (ne & se & He).

*****
H4 : forall (r : BC) (_ : In r tl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n) (and (le s' s) (eq (inf (convI r)) (I n' s')))))
H3 : forall (r : BC) (_ : In r rl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n)\n (and (le s' Datatypes.O) (eq (inf (convI r)) (I n' s')))))
He : and (le ne (length rl))\n (and (le se (length tl)) (eq (inf (convI h)) (I ne se)))
ne,se : nat
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl),\neq (arities e) (ok_arities n Datatypes.O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
ex (fun n' : nat => ex (fun s' : nat => and (le n' n) (and (le s' s) (eq match inf (convI h) with | I hn hs => if andb (Nat.leb hn (length (map convI rl))) (Nat.leb hs (length (map convI tl))) then match inf_list (map inf (map convI rl)) with | I nnl snl => match inf_list (map inf (map convI tl)) with | I nsl ssl => if Nat.eqb snl Datatypes.O then I (Init.Nat.max nnl nsl) ssl else E (Enat (S (S (S (S Datatypes.O))))) | E _ => E (Enat (S (S (S (S (S Datatypes.O)))))) end | E _ => E (Enat (S (S (S (S (S Datatypes.O)))))) end else E (Enat (S (S (S (S (S (S Datatypes.O))))))) | E e => E e end (I n' s')))))
+++++
decompose [and] He; clear He.
-----
Lemma convI_inf_correct : forall (e : BC) n s, arities e = ok_arities n s -> exists n', exists s', n' <= n /\\ s' <= s /\\ inf (convI e) = I n' s'.
Proof.
apply BC_ind_inf; simpl; intros.
exists 0; exists 0; auto.
destruct n; simpl.
exists 0; exists (S (i - 0)).
repeat (split; try omega).
case_eq (leb i n); intros; simpl.
apply leb_complete in H0.
exists (S i); exists 0.
repeat (split; try omega).
apply leb_complete_conv in H0.
exists 0; exists (S (i - S n)).
repeat (split; try omega).
exists 0; exists 1; auto.
exists 0; exists 1; auto.
exists 0; exists 4; auto.
destruct H2 as (ne1 & se1 & He1).
destruct H3 as (ne2 & se2 & He2).
destruct H4 as (ne3 & se3 & He3).
decompose [and] He1; decompose [and] He2; decompose [and] He3.
clear He1 He2 He3.
rewrite H5, H8, H11.
eexists; eexists.
split; try split.
3: eauto.
apply maxl_bound; omega.
apply maxl_bound; omega.
destruct H2 as (ne & se & He).
decompose [and] He; clear He.

*****
H7 : eq (inf (convI h)) (I ne se)
H6 : le se (length tl)
H2 : le ne (length rl)
H4 : forall (r : BC) (_ : In r tl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n) (and (le s' s) (eq (inf (convI r)) (I n' s')))))
H3 : forall (r : BC) (_ : In r rl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n)\n (and (le s' Datatypes.O) (eq (inf (convI r)) (I n' s')))))
ne,se : nat
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl),\neq (arities e) (ok_arities n Datatypes.O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
ex (fun n' : nat => ex (fun s' : nat => and (le n' n) (and (le s' s) (eq match inf (convI h) with | I hn hs => if andb (Nat.leb hn (length (map convI rl))) (Nat.leb hs (length (map convI tl))) then match inf_list (map inf (map convI rl)) with | I nnl snl => match inf_list (map inf (map convI tl)) with | I nsl ssl => if Nat.eqb snl Datatypes.O then I (Init.Nat.max nnl nsl) ssl else E (Enat (S (S (S (S Datatypes.O))))) | E _ => E (Enat (S (S (S (S (S Datatypes.O)))))) end | E _ => E (Enat (S (S (S (S (S Datatypes.O)))))) end else E (Enat (S (S (S (S (S (S Datatypes.O))))))) | E e => E e end (I n' s')))))
+++++
rewrite H7.
-----
Lemma convI_inf_correct : forall (e : BC) n s, arities e = ok_arities n s -> exists n', exists s', n' <= n /\\ s' <= s /\\ inf (convI e) = I n' s'.
Proof.
apply BC_ind_inf; simpl; intros.
exists 0; exists 0; auto.
destruct n; simpl.
exists 0; exists (S (i - 0)).
repeat (split; try omega).
case_eq (leb i n); intros; simpl.
apply leb_complete in H0.
exists (S i); exists 0.
repeat (split; try omega).
apply leb_complete_conv in H0.
exists 0; exists (S (i - S n)).
repeat (split; try omega).
exists 0; exists 1; auto.
exists 0; exists 1; auto.
exists 0; exists 4; auto.
destruct H2 as (ne1 & se1 & He1).
destruct H3 as (ne2 & se2 & He2).
destruct H4 as (ne3 & se3 & He3).
decompose [and] He1; decompose [and] He2; decompose [and] He3.
clear He1 He2 He3.
rewrite H5, H8, H11.
eexists; eexists.
split; try split.
3: eauto.
apply maxl_bound; omega.
apply maxl_bound; omega.
destruct H2 as (ne & se & He).
decompose [and] He; clear He.
rewrite H7.

*****
H7 : eq (inf (convI h)) (I ne se)
H6 : le se (length tl)
H2 : le ne (length rl)
H4 : forall (r : BC) (_ : In r tl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n) (and (le s' s) (eq (inf (convI r)) (I n' s')))))
H3 : forall (r : BC) (_ : In r rl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n)\n (and (le s' Datatypes.O) (eq (inf (convI r)) (I n' s')))))
ne,se : nat
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl),\neq (arities e) (ok_arities n Datatypes.O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
ex (fun n' : nat => ex (fun s' : nat => and (le n' n) (and (le s' s) (eq (if andb (Nat.leb ne (length (map convI rl))) (Nat.leb se (length (map convI tl))) then match inf_list (map inf (map convI rl)) with | I nnl snl => match inf_list (map inf (map convI tl)) with | I nsl ssl => if Nat.eqb snl Datatypes.O then I (Init.Nat.max nnl nsl) ssl else E (Enat (S (S (S (S Datatypes.O))))) | E _ => E (Enat (S (S (S (S (S Datatypes.O)))))) end | E _ => E (Enat (S (S (S (S (S Datatypes.O)))))) end else E (Enat (S (S (S (S (S (S Datatypes.O)))))))) (I n' s')))))
+++++
repeat rewrite leb_correct.
-----
Lemma convI_inf_correct : forall (e : BC) n s, arities e = ok_arities n s -> exists n', exists s', n' <= n /\\ s' <= s /\\ inf (convI e) = I n' s'.
Proof.
apply BC_ind_inf; simpl; intros.
exists 0; exists 0; auto.
destruct n; simpl.
exists 0; exists (S (i - 0)).
repeat (split; try omega).
case_eq (leb i n); intros; simpl.
apply leb_complete in H0.
exists (S i); exists 0.
repeat (split; try omega).
apply leb_complete_conv in H0.
exists 0; exists (S (i - S n)).
repeat (split; try omega).
exists 0; exists 1; auto.
exists 0; exists 1; auto.
exists 0; exists 4; auto.
destruct H2 as (ne1 & se1 & He1).
destruct H3 as (ne2 & se2 & He2).
destruct H4 as (ne3 & se3 & He3).
decompose [and] He1; decompose [and] He2; decompose [and] He3.
clear He1 He2 He3.
rewrite H5, H8, H11.
eexists; eexists.
split; try split.
3: eauto.
apply maxl_bound; omega.
apply maxl_bound; omega.
destruct H2 as (ne & se & He).
decompose [and] He; clear He.
rewrite H7.
repeat rewrite leb_correct.

*****
H7 : eq (inf (convI h)) (I ne se)
H6 : le se (length tl)
H2 : le ne (length rl)
H4 : forall (r : BC) (_ : In r tl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n) (and (le s' s) (eq (inf (convI r)) (I n' s')))))
H3 : forall (r : BC) (_ : In r rl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n)\n (and (le s' Datatypes.O) (eq (inf (convI r)) (I n' s')))))
ne,se : nat
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl),\neq (arities e) (ok_arities n Datatypes.O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
ex (fun n' : nat => ex (fun s' : nat => and (le n' n) (and (le s' s) (eq (if andb true true then match inf_list (map inf (map convI rl)) with | I nnl snl => match inf_list (map inf (map convI tl)) with | I nsl ssl => if Nat.eqb snl Datatypes.O then I (Init.Nat.max nnl nsl) ssl else E (Enat (S (S (S (S Datatypes.O))))) | E _ => E (Enat (S (S (S (S (S Datatypes.O)))))) end | E _ => E (Enat (S (S (S (S (S Datatypes.O)))))) end else E (Enat (S (S (S (S (S (S Datatypes.O)))))))) (I n' s')))))
+++++
simpl.
-----
Lemma convI_inf_correct : forall (e : BC) n s, arities e = ok_arities n s -> exists n', exists s', n' <= n /\\ s' <= s /\\ inf (convI e) = I n' s'.
Proof.
apply BC_ind_inf; simpl; intros.
exists 0; exists 0; auto.
destruct n; simpl.
exists 0; exists (S (i - 0)).
repeat (split; try omega).
case_eq (leb i n); intros; simpl.
apply leb_complete in H0.
exists (S i); exists 0.
repeat (split; try omega).
apply leb_complete_conv in H0.
exists 0; exists (S (i - S n)).
repeat (split; try omega).
exists 0; exists 1; auto.
exists 0; exists 1; auto.
exists 0; exists 4; auto.
destruct H2 as (ne1 & se1 & He1).
destruct H3 as (ne2 & se2 & He2).
destruct H4 as (ne3 & se3 & He3).
decompose [and] He1; decompose [and] He2; decompose [and] He3.
clear He1 He2 He3.
rewrite H5, H8, H11.
eexists; eexists.
split; try split.
3: eauto.
apply maxl_bound; omega.
apply maxl_bound; omega.
destruct H2 as (ne & se & He).
decompose [and] He; clear He.
rewrite H7.
repeat rewrite leb_correct.
simpl.

*****
H7 : eq (inf (convI h)) (I ne se)
H6 : le se (length tl)
H2 : le ne (length rl)
H4 : forall (r : BC) (_ : In r tl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n) (and (le s' s) (eq (inf (convI r)) (I n' s')))))
H3 : forall (r : BC) (_ : In r rl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n)\n (and (le s' Datatypes.O) (eq (inf (convI r)) (I n' s')))))
ne,se : nat
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl),\neq (arities e) (ok_arities n Datatypes.O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
ex (fun n' : nat => ex (fun s' : nat => and (le n' n) (and (le s' s) (eq match inf_list (map inf (map convI rl)) with | I nnl snl => match inf_list (map inf (map convI tl)) with | I nsl ssl => if Nat.eqb snl Datatypes.O then I (Init.Nat.max nnl nsl) ssl else E (Enat (S (S (S (S Datatypes.O))))) | E _ => E (Enat (S (S (S (S (S Datatypes.O)))))) end | E _ => E (Enat (S (S (S (S (S Datatypes.O)))))) end (I n' s')))))
+++++
case_eq ( inf_list (map inf (map convI rl)) ) ; intros.
-----
Lemma convI_inf_correct : forall (e : BC) n s, arities e = ok_arities n s -> exists n', exists s', n' <= n /\\ s' <= s /\\ inf (convI e) = I n' s'.
Proof.
apply BC_ind_inf; simpl; intros.
exists 0; exists 0; auto.
destruct n; simpl.
exists 0; exists (S (i - 0)).
repeat (split; try omega).
case_eq (leb i n); intros; simpl.
apply leb_complete in H0.
exists (S i); exists 0.
repeat (split; try omega).
apply leb_complete_conv in H0.
exists 0; exists (S (i - S n)).
repeat (split; try omega).
exists 0; exists 1; auto.
exists 0; exists 1; auto.
exists 0; exists 4; auto.
destruct H2 as (ne1 & se1 & He1).
destruct H3 as (ne2 & se2 & He2).
destruct H4 as (ne3 & se3 & He3).
decompose [and] He1; decompose [and] He2; decompose [and] He3.
clear He1 He2 He3.
rewrite H5, H8, H11.
eexists; eexists.
split; try split.
3: eauto.
apply maxl_bound; omega.
apply maxl_bound; omega.
destruct H2 as (ne & se & He).
decompose [and] He; clear He.
rewrite H7.
repeat rewrite leb_correct.
simpl.
case_eq ( inf_list (map inf (map convI rl)) ) ; intros.

*****
H5 : eq (inf_list (map inf (map convI rl))) (I n0 n1)
n0,n1 : nat
H7 : eq (inf (convI h)) (I ne se)
H6 : le se (length tl)
H2 : le ne (length rl)
H4 : forall (r : BC) (_ : In r tl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n) (and (le s' s) (eq (inf (convI r)) (I n' s')))))
H3 : forall (r : BC) (_ : In r rl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n)\n (and (le s' Datatypes.O) (eq (inf (convI r)) (I n' s')))))
ne,se : nat
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl),\neq (arities e) (ok_arities n Datatypes.O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
ex (fun n' : nat => ex (fun s' : nat => and (le n' n) (and (le s' s) (eq match inf_list (map inf (map convI tl)) with | I nsl ssl => if Nat.eqb n1 Datatypes.O then I (Init.Nat.max n0 nsl) ssl else E (Enat (S (S (S (S Datatypes.O))))) | E _ => E (Enat (S (S (S (S (S Datatypes.O)))))) end (I n' s')))))
+++++
case_eq ( inf_list (map inf (map convI tl)) ) ; intros.
-----
Lemma convI_inf_correct : forall (e : BC) n s, arities e = ok_arities n s -> exists n', exists s', n' <= n /\\ s' <= s /\\ inf (convI e) = I n' s'.
Proof.
apply BC_ind_inf; simpl; intros.
exists 0; exists 0; auto.
destruct n; simpl.
exists 0; exists (S (i - 0)).
repeat (split; try omega).
case_eq (leb i n); intros; simpl.
apply leb_complete in H0.
exists (S i); exists 0.
repeat (split; try omega).
apply leb_complete_conv in H0.
exists 0; exists (S (i - S n)).
repeat (split; try omega).
exists 0; exists 1; auto.
exists 0; exists 1; auto.
exists 0; exists 4; auto.
destruct H2 as (ne1 & se1 & He1).
destruct H3 as (ne2 & se2 & He2).
destruct H4 as (ne3 & se3 & He3).
decompose [and] He1; decompose [and] He2; decompose [and] He3.
clear He1 He2 He3.
rewrite H5, H8, H11.
eexists; eexists.
split; try split.
3: eauto.
apply maxl_bound; omega.
apply maxl_bound; omega.
destruct H2 as (ne & se & He).
decompose [and] He; clear He.
rewrite H7.
repeat rewrite leb_correct.
simpl.
case_eq ( inf_list (map inf (map convI rl)) ) ; intros.
case_eq ( inf_list (map inf (map convI tl)) ) ; intros.

*****
H8 : eq (inf_list (map inf (map convI tl))) (I n2 n3)
n2,n3 : nat
H5 : eq (inf_list (map inf (map convI rl))) (I n0 n1)
n0,n1 : nat
H7 : eq (inf (convI h)) (I ne se)
H6 : le se (length tl)
H2 : le ne (length rl)
H4 : forall (r : BC) (_ : In r tl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n) (and (le s' s) (eq (inf (convI r)) (I n' s')))))
H3 : forall (r : BC) (_ : In r rl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n)\n (and (le s' Datatypes.O) (eq (inf (convI r)) (I n' s')))))
ne,se : nat
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl),\neq (arities e) (ok_arities n Datatypes.O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
ex (fun n' : nat => ex (fun s' : nat => and (le n' n) (and (le s' s) (eq (if Nat.eqb n1 Datatypes.O then I (Init.Nat.max n0 n2) n3 else E (Enat (S (S (S (S Datatypes.O)))))) (I n' s')))))
+++++
case_eq (beq_nat n1 0); intros.
-----
Lemma convI_inf_correct : forall (e : BC) n s, arities e = ok_arities n s -> exists n', exists s', n' <= n /\\ s' <= s /\\ inf (convI e) = I n' s'.
Proof.
apply BC_ind_inf; simpl; intros.
exists 0; exists 0; auto.
destruct n; simpl.
exists 0; exists (S (i - 0)).
repeat (split; try omega).
case_eq (leb i n); intros; simpl.
apply leb_complete in H0.
exists (S i); exists 0.
repeat (split; try omega).
apply leb_complete_conv in H0.
exists 0; exists (S (i - S n)).
repeat (split; try omega).
exists 0; exists 1; auto.
exists 0; exists 1; auto.
exists 0; exists 4; auto.
destruct H2 as (ne1 & se1 & He1).
destruct H3 as (ne2 & se2 & He2).
destruct H4 as (ne3 & se3 & He3).
decompose [and] He1; decompose [and] He2; decompose [and] He3.
clear He1 He2 He3.
rewrite H5, H8, H11.
eexists; eexists.
split; try split.
3: eauto.
apply maxl_bound; omega.
apply maxl_bound; omega.
destruct H2 as (ne & se & He).
decompose [and] He; clear He.
rewrite H7.
repeat rewrite leb_correct.
simpl.
case_eq ( inf_list (map inf (map convI rl)) ) ; intros.
case_eq ( inf_list (map inf (map convI tl)) ) ; intros.
case_eq (beq_nat n1 0); intros.

*****
H9 : eq (Nat.eqb n1 Datatypes.O) true
H8 : eq (inf_list (map inf (map convI tl))) (I n2 n3)
n2,n3 : nat
H5 : eq (inf_list (map inf (map convI rl))) (I n0 n1)
n0,n1 : nat
H7 : eq (inf (convI h)) (I ne se)
H6 : le se (length tl)
H2 : le ne (length rl)
H4 : forall (r : BC) (_ : In r tl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n) (and (le s' s) (eq (inf (convI r)) (I n' s')))))
H3 : forall (r : BC) (_ : In r rl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n)\n (and (le s' Datatypes.O) (eq (inf (convI r)) (I n' s')))))
ne,se : nat
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl),\neq (arities e) (ok_arities n Datatypes.O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
ex (fun n' : nat => ex (fun s' : nat => and (le n' n) (and (le s' s) (eq (I (Init.Nat.max n0 n2) n3) (I n' s')))))
+++++
eexists; eexists; split; try split.
-----
Lemma convI_inf_correct : forall (e : BC) n s, arities e = ok_arities n s -> exists n', exists s', n' <= n /\\ s' <= s /\\ inf (convI e) = I n' s'.
Proof.
apply BC_ind_inf; simpl; intros.
exists 0; exists 0; auto.
destruct n; simpl.
exists 0; exists (S (i - 0)).
repeat (split; try omega).
case_eq (leb i n); intros; simpl.
apply leb_complete in H0.
exists (S i); exists 0.
repeat (split; try omega).
apply leb_complete_conv in H0.
exists 0; exists (S (i - S n)).
repeat (split; try omega).
exists 0; exists 1; auto.
exists 0; exists 1; auto.
exists 0; exists 4; auto.
destruct H2 as (ne1 & se1 & He1).
destruct H3 as (ne2 & se2 & He2).
destruct H4 as (ne3 & se3 & He3).
decompose [and] He1; decompose [and] He2; decompose [and] He3.
clear He1 He2 He3.
rewrite H5, H8, H11.
eexists; eexists.
split; try split.
3: eauto.
apply maxl_bound; omega.
apply maxl_bound; omega.
destruct H2 as (ne & se & He).
decompose [and] He; clear He.
rewrite H7.
repeat rewrite leb_correct.
simpl.
case_eq ( inf_list (map inf (map convI rl)) ) ; intros.
case_eq ( inf_list (map inf (map convI tl)) ) ; intros.
case_eq (beq_nat n1 0); intros.
eexists; eexists; split; try split.

*****
H9 : eq (Nat.eqb n1 Datatypes.O) true
H8 : eq (inf_list (map inf (map convI tl))) (I n2 n3)
n2,n3 : nat
H5 : eq (inf_list (map inf (map convI rl))) (I n0 n1)
n0,n1 : nat
H7 : eq (inf (convI h)) (I ne se)
H6 : le se (length tl)
H2 : le ne (length rl)
H4 : forall (r : BC) (_ : In r tl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n) (and (le s' s) (eq (inf (convI r)) (I n' s')))))
H3 : forall (r : BC) (_ : In r rl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n)\n (and (le s' Datatypes.O) (eq (inf (convI r)) (I n' s')))))
ne,se : nat
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl),\neq (arities e) (ok_arities n Datatypes.O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
le ?n' n
+++++
3: eauto.
-----
Lemma convI_inf_correct : forall (e : BC) n s, arities e = ok_arities n s -> exists n', exists s', n' <= n /\\ s' <= s /\\ inf (convI e) = I n' s'.
Proof.
apply BC_ind_inf; simpl; intros.
exists 0; exists 0; auto.
destruct n; simpl.
exists 0; exists (S (i - 0)).
repeat (split; try omega).
case_eq (leb i n); intros; simpl.
apply leb_complete in H0.
exists (S i); exists 0.
repeat (split; try omega).
apply leb_complete_conv in H0.
exists 0; exists (S (i - S n)).
repeat (split; try omega).
exists 0; exists 1; auto.
exists 0; exists 1; auto.
exists 0; exists 4; auto.
destruct H2 as (ne1 & se1 & He1).
destruct H3 as (ne2 & se2 & He2).
destruct H4 as (ne3 & se3 & He3).
decompose [and] He1; decompose [and] He2; decompose [and] He3.
clear He1 He2 He3.
rewrite H5, H8, H11.
eexists; eexists.
split; try split.
3: eauto.
apply maxl_bound; omega.
apply maxl_bound; omega.
destruct H2 as (ne & se & He).
decompose [and] He; clear He.
rewrite H7.
repeat rewrite leb_correct.
simpl.
case_eq ( inf_list (map inf (map convI rl)) ) ; intros.
case_eq ( inf_list (map inf (map convI tl)) ) ; intros.
case_eq (beq_nat n1 0); intros.
eexists; eexists; split; try split.
3: eauto.

*****
H9 : eq (Nat.eqb n1 Datatypes.O) true
H8 : eq (inf_list (map inf (map convI tl))) (I n2 n3)
n2,n3 : nat
H5 : eq (inf_list (map inf (map convI rl))) (I n0 n1)
n0,n1 : nat
H7 : eq (inf (convI h)) (I ne se)
H6 : le se (length tl)
H2 : le ne (length rl)
H4 : forall (r : BC) (_ : In r tl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n) (and (le s' s) (eq (inf (convI r)) (I n' s')))))
H3 : forall (r : BC) (_ : In r rl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n)\n (and (le s' Datatypes.O) (eq (inf (convI r)) (I n' s')))))
ne,se : nat
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl),\neq (arities e) (ok_arities n Datatypes.O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
le (Init.Nat.max n0 n2) n
+++++
apply Nat.max_lub.
-----
Lemma convI_inf_correct : forall (e : BC) n s, arities e = ok_arities n s -> exists n', exists s', n' <= n /\\ s' <= s /\\ inf (convI e) = I n' s'.
Proof.
apply BC_ind_inf; simpl; intros.
exists 0; exists 0; auto.
destruct n; simpl.
exists 0; exists (S (i - 0)).
repeat (split; try omega).
case_eq (leb i n); intros; simpl.
apply leb_complete in H0.
exists (S i); exists 0.
repeat (split; try omega).
apply leb_complete_conv in H0.
exists 0; exists (S (i - S n)).
repeat (split; try omega).
exists 0; exists 1; auto.
exists 0; exists 1; auto.
exists 0; exists 4; auto.
destruct H2 as (ne1 & se1 & He1).
destruct H3 as (ne2 & se2 & He2).
destruct H4 as (ne3 & se3 & He3).
decompose [and] He1; decompose [and] He2; decompose [and] He3.
clear He1 He2 He3.
rewrite H5, H8, H11.
eexists; eexists.
split; try split.
3: eauto.
apply maxl_bound; omega.
apply maxl_bound; omega.
destruct H2 as (ne & se & He).
decompose [and] He; clear He.
rewrite H7.
repeat rewrite leb_correct.
simpl.
case_eq ( inf_list (map inf (map convI rl)) ) ; intros.
case_eq ( inf_list (map inf (map convI tl)) ) ; intros.
case_eq (beq_nat n1 0); intros.
eexists; eexists; split; try split.
3: eauto.
apply Nat.max_lub.

*****
H9 : eq (Nat.eqb n1 Datatypes.O) true
H8 : eq (inf_list (map inf (map convI tl))) (I n2 n3)
n2,n3 : nat
H5 : eq (inf_list (map inf (map convI rl))) (I n0 n1)
n0,n1 : nat
H7 : eq (inf (convI h)) (I ne se)
H6 : le se (length tl)
H2 : le ne (length rl)
H4 : forall (r : BC) (_ : In r tl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n) (and (le s' s) (eq (inf (convI r)) (I n' s')))))
H3 : forall (r : BC) (_ : In r rl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n)\n (and (le s' Datatypes.O) (eq (inf (convI r)) (I n' s')))))
ne,se : nat
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl),\neq (arities e) (ok_arities n Datatypes.O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
le n0 n
+++++
apply inf_list_maxl_l in H5.
-----
Lemma convI_inf_correct : forall (e : BC) n s, arities e = ok_arities n s -> exists n', exists s', n' <= n /\\ s' <= s /\\ inf (convI e) = I n' s'.
Proof.
apply BC_ind_inf; simpl; intros.
exists 0; exists 0; auto.
destruct n; simpl.
exists 0; exists (S (i - 0)).
repeat (split; try omega).
case_eq (leb i n); intros; simpl.
apply leb_complete in H0.
exists (S i); exists 0.
repeat (split; try omega).
apply leb_complete_conv in H0.
exists 0; exists (S (i - S n)).
repeat (split; try omega).
exists 0; exists 1; auto.
exists 0; exists 1; auto.
exists 0; exists 4; auto.
destruct H2 as (ne1 & se1 & He1).
destruct H3 as (ne2 & se2 & He2).
destruct H4 as (ne3 & se3 & He3).
decompose [and] He1; decompose [and] He2; decompose [and] He3.
clear He1 He2 He3.
rewrite H5, H8, H11.
eexists; eexists.
split; try split.
3: eauto.
apply maxl_bound; omega.
apply maxl_bound; omega.
destruct H2 as (ne & se & He).
decompose [and] He; clear He.
rewrite H7.
repeat rewrite leb_correct.
simpl.
case_eq ( inf_list (map inf (map convI rl)) ) ; intros.
case_eq ( inf_list (map inf (map convI tl)) ) ; intros.
case_eq (beq_nat n1 0); intros.
eexists; eexists; split; try split.
3: eauto.
apply Nat.max_lub.
apply inf_list_maxl_l in H5.

*****
H9 : eq (Nat.eqb n1 Datatypes.O) true
H8 : eq (inf_list (map inf (map convI tl))) (I n2 n3)
n2,n3 : nat
H5 : eq n0 (maxl (map (leftI Datatypes.O) (map inf (map convI rl))))
n0,n1 : nat
H7 : eq (inf (convI h)) (I ne se)
H6 : le se (length tl)
H2 : le ne (length rl)
H4 : forall (r : BC) (_ : In r tl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n) (and (le s' s) (eq (inf (convI r)) (I n' s')))))
H3 : forall (r : BC) (_ : In r rl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n)\n (and (le s' Datatypes.O) (eq (inf (convI r)) (I n' s')))))
ne,se : nat
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl),\neq (arities e) (ok_arities n Datatypes.O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
le n0 n
+++++
rewrite H5.
-----
Lemma convI_inf_correct : forall (e : BC) n s, arities e = ok_arities n s -> exists n', exists s', n' <= n /\\ s' <= s /\\ inf (convI e) = I n' s'.
Proof.
apply BC_ind_inf; simpl; intros.
exists 0; exists 0; auto.
destruct n; simpl.
exists 0; exists (S (i - 0)).
repeat (split; try omega).
case_eq (leb i n); intros; simpl.
apply leb_complete in H0.
exists (S i); exists 0.
repeat (split; try omega).
apply leb_complete_conv in H0.
exists 0; exists (S (i - S n)).
repeat (split; try omega).
exists 0; exists 1; auto.
exists 0; exists 1; auto.
exists 0; exists 4; auto.
destruct H2 as (ne1 & se1 & He1).
destruct H3 as (ne2 & se2 & He2).
destruct H4 as (ne3 & se3 & He3).
decompose [and] He1; decompose [and] He2; decompose [and] He3.
clear He1 He2 He3.
rewrite H5, H8, H11.
eexists; eexists.
split; try split.
3: eauto.
apply maxl_bound; omega.
apply maxl_bound; omega.
destruct H2 as (ne & se & He).
decompose [and] He; clear He.
rewrite H7.
repeat rewrite leb_correct.
simpl.
case_eq ( inf_list (map inf (map convI rl)) ) ; intros.
case_eq ( inf_list (map inf (map convI tl)) ) ; intros.
case_eq (beq_nat n1 0); intros.
eexists; eexists; split; try split.
3: eauto.
apply Nat.max_lub.
apply inf_list_maxl_l in H5.
rewrite H5.

*****
H9 : eq (Nat.eqb n1 Datatypes.O) true
H8 : eq (inf_list (map inf (map convI tl))) (I n2 n3)
n2,n3 : nat
H5 : eq n0 (maxl (map (leftI Datatypes.O) (map inf (map convI rl))))
n0,n1 : nat
H7 : eq (inf (convI h)) (I ne se)
H6 : le se (length tl)
H2 : le ne (length rl)
H4 : forall (r : BC) (_ : In r tl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n) (and (le s' s) (eq (inf (convI r)) (I n' s')))))
H3 : forall (r : BC) (_ : In r rl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n)\n (and (le s' Datatypes.O) (eq (inf (convI r)) (I n' s')))))
ne,se : nat
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl),\neq (arities e) (ok_arities n Datatypes.O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
le (maxl (map (leftI Datatypes.O) (map inf (map convI rl)))) n
+++++
rewrite map_map.
-----
Lemma convI_inf_correct : forall (e : BC) n s, arities e = ok_arities n s -> exists n', exists s', n' <= n /\\ s' <= s /\\ inf (convI e) = I n' s'.
Proof.
apply BC_ind_inf; simpl; intros.
exists 0; exists 0; auto.
destruct n; simpl.
exists 0; exists (S (i - 0)).
repeat (split; try omega).
case_eq (leb i n); intros; simpl.
apply leb_complete in H0.
exists (S i); exists 0.
repeat (split; try omega).
apply leb_complete_conv in H0.
exists 0; exists (S (i - S n)).
repeat (split; try omega).
exists 0; exists 1; auto.
exists 0; exists 1; auto.
exists 0; exists 4; auto.
destruct H2 as (ne1 & se1 & He1).
destruct H3 as (ne2 & se2 & He2).
destruct H4 as (ne3 & se3 & He3).
decompose [and] He1; decompose [and] He2; decompose [and] He3.
clear He1 He2 He3.
rewrite H5, H8, H11.
eexists; eexists.
split; try split.
3: eauto.
apply maxl_bound; omega.
apply maxl_bound; omega.
destruct H2 as (ne & se & He).
decompose [and] He; clear He.
rewrite H7.
repeat rewrite leb_correct.
simpl.
case_eq ( inf_list (map inf (map convI rl)) ) ; intros.
case_eq ( inf_list (map inf (map convI tl)) ) ; intros.
case_eq (beq_nat n1 0); intros.
eexists; eexists; split; try split.
3: eauto.
apply Nat.max_lub.
apply inf_list_maxl_l in H5.
rewrite H5.
rewrite map_map.

*****
H9 : eq (Nat.eqb n1 Datatypes.O) true
H8 : eq (inf_list (map inf (map convI tl))) (I n2 n3)
n2,n3 : nat
H5 : eq n0 (maxl (map (leftI Datatypes.O) (map inf (map convI rl))))
n0,n1 : nat
H7 : eq (inf (convI h)) (I ne se)
H6 : le se (length tl)
H2 : le ne (length rl)
H4 : forall (r : BC) (_ : In r tl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n) (and (le s' s) (eq (inf (convI r)) (I n' s')))))
H3 : forall (r : BC) (_ : In r rl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n)\n (and (le s' Datatypes.O) (eq (inf (convI r)) (I n' s')))))
ne,se : nat
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl),\neq (arities e) (ok_arities n Datatypes.O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
le (maxl (map (fun x : BCI => leftI Datatypes.O (inf x)) (map convI rl))) n
+++++
rewrite map_map.
-----
Lemma convI_inf_correct : forall (e : BC) n s, arities e = ok_arities n s -> exists n', exists s', n' <= n /\\ s' <= s /\\ inf (convI e) = I n' s'.
Proof.
apply BC_ind_inf; simpl; intros.
exists 0; exists 0; auto.
destruct n; simpl.
exists 0; exists (S (i - 0)).
repeat (split; try omega).
case_eq (leb i n); intros; simpl.
apply leb_complete in H0.
exists (S i); exists 0.
repeat (split; try omega).
apply leb_complete_conv in H0.
exists 0; exists (S (i - S n)).
repeat (split; try omega).
exists 0; exists 1; auto.
exists 0; exists 1; auto.
exists 0; exists 4; auto.
destruct H2 as (ne1 & se1 & He1).
destruct H3 as (ne2 & se2 & He2).
destruct H4 as (ne3 & se3 & He3).
decompose [and] He1; decompose [and] He2; decompose [and] He3.
clear He1 He2 He3.
rewrite H5, H8, H11.
eexists; eexists.
split; try split.
3: eauto.
apply maxl_bound; omega.
apply maxl_bound; omega.
destruct H2 as (ne & se & He).
decompose [and] He; clear He.
rewrite H7.
repeat rewrite leb_correct.
simpl.
case_eq ( inf_list (map inf (map convI rl)) ) ; intros.
case_eq ( inf_list (map inf (map convI tl)) ) ; intros.
case_eq (beq_nat n1 0); intros.
eexists; eexists; split; try split.
3: eauto.
apply Nat.max_lub.
apply inf_list_maxl_l in H5.
rewrite H5.
rewrite map_map.
rewrite map_map.

*****
H9 : eq (Nat.eqb n1 Datatypes.O) true
H8 : eq (inf_list (map inf (map convI tl))) (I n2 n3)
n2,n3 : nat
H5 : eq n0 (maxl (map (leftI Datatypes.O) (map inf (map convI rl))))
n0,n1 : nat
H7 : eq (inf (convI h)) (I ne se)
H6 : le se (length tl)
H2 : le ne (length rl)
H4 : forall (r : BC) (_ : In r tl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n) (and (le s' s) (eq (inf (convI r)) (I n' s')))))
H3 : forall (r : BC) (_ : In r rl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n)\n (and (le s' Datatypes.O) (eq (inf (convI r)) (I n' s')))))
ne,se : nat
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl),\neq (arities e) (ok_arities n Datatypes.O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
le (maxl (map (fun x : BC => leftI Datatypes.O (inf (convI x))) rl)) n
+++++
apply maxl_bound_in.
-----
Lemma convI_inf_correct : forall (e : BC) n s, arities e = ok_arities n s -> exists n', exists s', n' <= n /\\ s' <= s /\\ inf (convI e) = I n' s'.
Proof.
apply BC_ind_inf; simpl; intros.
exists 0; exists 0; auto.
destruct n; simpl.
exists 0; exists (S (i - 0)).
repeat (split; try omega).
case_eq (leb i n); intros; simpl.
apply leb_complete in H0.
exists (S i); exists 0.
repeat (split; try omega).
apply leb_complete_conv in H0.
exists 0; exists (S (i - S n)).
repeat (split; try omega).
exists 0; exists 1; auto.
exists 0; exists 1; auto.
exists 0; exists 4; auto.
destruct H2 as (ne1 & se1 & He1).
destruct H3 as (ne2 & se2 & He2).
destruct H4 as (ne3 & se3 & He3).
decompose [and] He1; decompose [and] He2; decompose [and] He3.
clear He1 He2 He3.
rewrite H5, H8, H11.
eexists; eexists.
split; try split.
3: eauto.
apply maxl_bound; omega.
apply maxl_bound; omega.
destruct H2 as (ne & se & He).
decompose [and] He; clear He.
rewrite H7.
repeat rewrite leb_correct.
simpl.
case_eq ( inf_list (map inf (map convI rl)) ) ; intros.
case_eq ( inf_list (map inf (map convI tl)) ) ; intros.
case_eq (beq_nat n1 0); intros.
eexists; eexists; split; try split.
3: eauto.
apply Nat.max_lub.
apply inf_list_maxl_l in H5.
rewrite H5.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.

*****
H9 : eq (Nat.eqb n1 Datatypes.O) true
H8 : eq (inf_list (map inf (map convI tl))) (I n2 n3)
n2,n3 : nat
H5 : eq n0 (maxl (map (leftI Datatypes.O) (map inf (map convI rl))))
n0,n1 : nat
H7 : eq (inf (convI h)) (I ne se)
H6 : le se (length tl)
H2 : le ne (length rl)
H4 : forall (r : BC) (_ : In r tl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n) (and (le s' s) (eq (inf (convI r)) (I n' s')))))
H3 : forall (r : BC) (_ : In r rl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n)\n (and (le s' Datatypes.O) (eq (inf (convI r)) (I n' s')))))
ne,se : nat
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl),\neq (arities e) (ok_arities n Datatypes.O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
forall (e' : nat) (_ : In e' (map (fun x : BC => leftI Datatypes.O (inf (convI x))) rl)), le e' n
+++++
intros.
-----
Lemma convI_inf_correct : forall (e : BC) n s, arities e = ok_arities n s -> exists n', exists s', n' <= n /\\ s' <= s /\\ inf (convI e) = I n' s'.
Proof.
apply BC_ind_inf; simpl; intros.
exists 0; exists 0; auto.
destruct n; simpl.
exists 0; exists (S (i - 0)).
repeat (split; try omega).
case_eq (leb i n); intros; simpl.
apply leb_complete in H0.
exists (S i); exists 0.
repeat (split; try omega).
apply leb_complete_conv in H0.
exists 0; exists (S (i - S n)).
repeat (split; try omega).
exists 0; exists 1; auto.
exists 0; exists 1; auto.
exists 0; exists 4; auto.
destruct H2 as (ne1 & se1 & He1).
destruct H3 as (ne2 & se2 & He2).
destruct H4 as (ne3 & se3 & He3).
decompose [and] He1; decompose [and] He2; decompose [and] He3.
clear He1 He2 He3.
rewrite H5, H8, H11.
eexists; eexists.
split; try split.
3: eauto.
apply maxl_bound; omega.
apply maxl_bound; omega.
destruct H2 as (ne & se & He).
decompose [and] He; clear He.
rewrite H7.
repeat rewrite leb_correct.
simpl.
case_eq ( inf_list (map inf (map convI rl)) ) ; intros.
case_eq ( inf_list (map inf (map convI tl)) ) ; intros.
case_eq (beq_nat n1 0); intros.
eexists; eexists; split; try split.
3: eauto.
apply Nat.max_lub.
apply inf_list_maxl_l in H5.
rewrite H5.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.

*****
H10 : In e' (map (fun x : BC => leftI Datatypes.O (inf (convI x))) rl)
e' : nat
H9 : eq (Nat.eqb n1 Datatypes.O) true
H8 : eq (inf_list (map inf (map convI tl))) (I n2 n3)
n2,n3 : nat
H5 : eq n0 (maxl (map (leftI Datatypes.O) (map inf (map convI rl))))
n0,n1 : nat
H7 : eq (inf (convI h)) (I ne se)
H6 : le se (length tl)
H2 : le ne (length rl)
H4 : forall (r : BC) (_ : In r tl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n) (and (le s' s) (eq (inf (convI r)) (I n' s')))))
H3 : forall (r : BC) (_ : In r rl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n)\n (and (le s' Datatypes.O) (eq (inf (convI r)) (I n' s')))))
ne,se : nat
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl),\neq (arities e) (ok_arities n Datatypes.O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
le e' n
+++++
apply in_map_iff in H10.
-----
Lemma convI_inf_correct : forall (e : BC) n s, arities e = ok_arities n s -> exists n', exists s', n' <= n /\\ s' <= s /\\ inf (convI e) = I n' s'.
Proof.
apply BC_ind_inf; simpl; intros.
exists 0; exists 0; auto.
destruct n; simpl.
exists 0; exists (S (i - 0)).
repeat (split; try omega).
case_eq (leb i n); intros; simpl.
apply leb_complete in H0.
exists (S i); exists 0.
repeat (split; try omega).
apply leb_complete_conv in H0.
exists 0; exists (S (i - S n)).
repeat (split; try omega).
exists 0; exists 1; auto.
exists 0; exists 1; auto.
exists 0; exists 4; auto.
destruct H2 as (ne1 & se1 & He1).
destruct H3 as (ne2 & se2 & He2).
destruct H4 as (ne3 & se3 & He3).
decompose [and] He1; decompose [and] He2; decompose [and] He3.
clear He1 He2 He3.
rewrite H5, H8, H11.
eexists; eexists.
split; try split.
3: eauto.
apply maxl_bound; omega.
apply maxl_bound; omega.
destruct H2 as (ne & se & He).
decompose [and] He; clear He.
rewrite H7.
repeat rewrite leb_correct.
simpl.
case_eq ( inf_list (map inf (map convI rl)) ) ; intros.
case_eq ( inf_list (map inf (map convI tl)) ) ; intros.
case_eq (beq_nat n1 0); intros.
eexists; eexists; split; try split.
3: eauto.
apply Nat.max_lub.
apply inf_list_maxl_l in H5.
rewrite H5.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.

*****
H10 : ex\n (fun x : BC =>\n and (eq (leftI Datatypes.O (inf (convI x))) e') (In x rl))
e' : nat
H9 : eq (Nat.eqb n1 Datatypes.O) true
H8 : eq (inf_list (map inf (map convI tl))) (I n2 n3)
n2,n3 : nat
H5 : eq n0 (maxl (map (leftI Datatypes.O) (map inf (map convI rl))))
n0,n1 : nat
H7 : eq (inf (convI h)) (I ne se)
H6 : le se (length tl)
H2 : le ne (length rl)
H4 : forall (r : BC) (_ : In r tl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n) (and (le s' s) (eq (inf (convI r)) (I n' s')))))
H3 : forall (r : BC) (_ : In r rl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n)\n (and (le s' Datatypes.O) (eq (inf (convI r)) (I n' s')))))
ne,se : nat
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl),\neq (arities e) (ok_arities n Datatypes.O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
le e' n
+++++
destruct H10 as [? [? ?]].
-----
Lemma convI_inf_correct : forall (e : BC) n s, arities e = ok_arities n s -> exists n', exists s', n' <= n /\\ s' <= s /\\ inf (convI e) = I n' s'.
Proof.
apply BC_ind_inf; simpl; intros.
exists 0; exists 0; auto.
destruct n; simpl.
exists 0; exists (S (i - 0)).
repeat (split; try omega).
case_eq (leb i n); intros; simpl.
apply leb_complete in H0.
exists (S i); exists 0.
repeat (split; try omega).
apply leb_complete_conv in H0.
exists 0; exists (S (i - S n)).
repeat (split; try omega).
exists 0; exists 1; auto.
exists 0; exists 1; auto.
exists 0; exists 4; auto.
destruct H2 as (ne1 & se1 & He1).
destruct H3 as (ne2 & se2 & He2).
destruct H4 as (ne3 & se3 & He3).
decompose [and] He1; decompose [and] He2; decompose [and] He3.
clear He1 He2 He3.
rewrite H5, H8, H11.
eexists; eexists.
split; try split.
3: eauto.
apply maxl_bound; omega.
apply maxl_bound; omega.
destruct H2 as (ne & se & He).
decompose [and] He; clear He.
rewrite H7.
repeat rewrite leb_correct.
simpl.
case_eq ( inf_list (map inf (map convI rl)) ) ; intros.
case_eq ( inf_list (map inf (map convI tl)) ) ; intros.
case_eq (beq_nat n1 0); intros.
eexists; eexists; split; try split.
3: eauto.
apply Nat.max_lub.
apply inf_list_maxl_l in H5.
rewrite H5.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.
destruct H10 as [? [? ?]].

*****
H11 : In x rl
H10 : eq (leftI Datatypes.O (inf (convI x))) e'
x : BC
e' : nat
H9 : eq (Nat.eqb n1 Datatypes.O) true
H8 : eq (inf_list (map inf (map convI tl))) (I n2 n3)
n2,n3 : nat
H5 : eq n0 (maxl (map (leftI Datatypes.O) (map inf (map convI rl))))
n0,n1 : nat
H7 : eq (inf (convI h)) (I ne se)
H6 : le se (length tl)
H2 : le ne (length rl)
H4 : forall (r : BC) (_ : In r tl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n) (and (le s' s) (eq (inf (convI r)) (I n' s')))))
H3 : forall (r : BC) (_ : In r rl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n)\n (and (le s' Datatypes.O) (eq (inf (convI r)) (I n' s')))))
ne,se : nat
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl),\neq (arities e) (ok_arities n Datatypes.O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
le e' n
+++++
destruct (H3 x H11) as (? & ? & ?).
-----
Lemma convI_inf_correct : forall (e : BC) n s, arities e = ok_arities n s -> exists n', exists s', n' <= n /\\ s' <= s /\\ inf (convI e) = I n' s'.
Proof.
apply BC_ind_inf; simpl; intros.
exists 0; exists 0; auto.
destruct n; simpl.
exists 0; exists (S (i - 0)).
repeat (split; try omega).
case_eq (leb i n); intros; simpl.
apply leb_complete in H0.
exists (S i); exists 0.
repeat (split; try omega).
apply leb_complete_conv in H0.
exists 0; exists (S (i - S n)).
repeat (split; try omega).
exists 0; exists 1; auto.
exists 0; exists 1; auto.
exists 0; exists 4; auto.
destruct H2 as (ne1 & se1 & He1).
destruct H3 as (ne2 & se2 & He2).
destruct H4 as (ne3 & se3 & He3).
decompose [and] He1; decompose [and] He2; decompose [and] He3.
clear He1 He2 He3.
rewrite H5, H8, H11.
eexists; eexists.
split; try split.
3: eauto.
apply maxl_bound; omega.
apply maxl_bound; omega.
destruct H2 as (ne & se & He).
decompose [and] He; clear He.
rewrite H7.
repeat rewrite leb_correct.
simpl.
case_eq ( inf_list (map inf (map convI rl)) ) ; intros.
case_eq ( inf_list (map inf (map convI tl)) ) ; intros.
case_eq (beq_nat n1 0); intros.
eexists; eexists; split; try split.
3: eauto.
apply Nat.max_lub.
apply inf_list_maxl_l in H5.
rewrite H5.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.
destruct H10 as [? [? ?]].
destruct (H3 x H11) as (? & ? & ?).

*****
H12 : and (le x0 n) (and (le x1 Datatypes.O) (eq (inf (convI x)) (I x0 x1)))
x0,x1 : nat
H11 : In x rl
H10 : eq (leftI Datatypes.O (inf (convI x))) e'
x : BC
e' : nat
H9 : eq (Nat.eqb n1 Datatypes.O) true
H8 : eq (inf_list (map inf (map convI tl))) (I n2 n3)
n2,n3 : nat
H5 : eq n0 (maxl (map (leftI Datatypes.O) (map inf (map convI rl))))
n0,n1 : nat
H7 : eq (inf (convI h)) (I ne se)
H6 : le se (length tl)
H2 : le ne (length rl)
H4 : forall (r : BC) (_ : In r tl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n) (and (le s' s) (eq (inf (convI r)) (I n' s')))))
H3 : forall (r : BC) (_ : In r rl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n)\n (and (le s' Datatypes.O) (eq (inf (convI r)) (I n' s')))))
ne,se : nat
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl),\neq (arities e) (ok_arities n Datatypes.O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
le e' n
+++++
decompose [and] H12.
-----
Lemma convI_inf_correct : forall (e : BC) n s, arities e = ok_arities n s -> exists n', exists s', n' <= n /\\ s' <= s /\\ inf (convI e) = I n' s'.
Proof.
apply BC_ind_inf; simpl; intros.
exists 0; exists 0; auto.
destruct n; simpl.
exists 0; exists (S (i - 0)).
repeat (split; try omega).
case_eq (leb i n); intros; simpl.
apply leb_complete in H0.
exists (S i); exists 0.
repeat (split; try omega).
apply leb_complete_conv in H0.
exists 0; exists (S (i - S n)).
repeat (split; try omega).
exists 0; exists 1; auto.
exists 0; exists 1; auto.
exists 0; exists 4; auto.
destruct H2 as (ne1 & se1 & He1).
destruct H3 as (ne2 & se2 & He2).
destruct H4 as (ne3 & se3 & He3).
decompose [and] He1; decompose [and] He2; decompose [and] He3.
clear He1 He2 He3.
rewrite H5, H8, H11.
eexists; eexists.
split; try split.
3: eauto.
apply maxl_bound; omega.
apply maxl_bound; omega.
destruct H2 as (ne & se & He).
decompose [and] He; clear He.
rewrite H7.
repeat rewrite leb_correct.
simpl.
case_eq ( inf_list (map inf (map convI rl)) ) ; intros.
case_eq ( inf_list (map inf (map convI tl)) ) ; intros.
case_eq (beq_nat n1 0); intros.
eexists; eexists; split; try split.
3: eauto.
apply Nat.max_lub.
apply inf_list_maxl_l in H5.
rewrite H5.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.
destruct H10 as [? [? ?]].
destruct (H3 x H11) as (? & ? & ?).
decompose [and] H12.

*****
H16 : eq (inf (convI x)) (I x0 x1)
H15 : le x1 Datatypes.O
H13 : le x0 n
H12 : and (le x0 n) (and (le x1 Datatypes.O) (eq (inf (convI x)) (I x0 x1)))
x0,x1 : nat
H11 : In x rl
H10 : eq (leftI Datatypes.O (inf (convI x))) e'
x : BC
e' : nat
H9 : eq (Nat.eqb n1 Datatypes.O) true
H8 : eq (inf_list (map inf (map convI tl))) (I n2 n3)
n2,n3 : nat
H5 : eq n0 (maxl (map (leftI Datatypes.O) (map inf (map convI rl))))
n0,n1 : nat
H7 : eq (inf (convI h)) (I ne se)
H6 : le se (length tl)
H2 : le ne (length rl)
H4 : forall (r : BC) (_ : In r tl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n) (and (le s' s) (eq (inf (convI r)) (I n' s')))))
H3 : forall (r : BC) (_ : In r rl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n)\n (and (le s' Datatypes.O) (eq (inf (convI r)) (I n' s')))))
ne,se : nat
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl),\neq (arities e) (ok_arities n Datatypes.O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
le e' n
+++++
subst.
-----
Lemma convI_inf_correct : forall (e : BC) n s, arities e = ok_arities n s -> exists n', exists s', n' <= n /\\ s' <= s /\\ inf (convI e) = I n' s'.
Proof.
apply BC_ind_inf; simpl; intros.
exists 0; exists 0; auto.
destruct n; simpl.
exists 0; exists (S (i - 0)).
repeat (split; try omega).
case_eq (leb i n); intros; simpl.
apply leb_complete in H0.
exists (S i); exists 0.
repeat (split; try omega).
apply leb_complete_conv in H0.
exists 0; exists (S (i - S n)).
repeat (split; try omega).
exists 0; exists 1; auto.
exists 0; exists 1; auto.
exists 0; exists 4; auto.
destruct H2 as (ne1 & se1 & He1).
destruct H3 as (ne2 & se2 & He2).
destruct H4 as (ne3 & se3 & He3).
decompose [and] He1; decompose [and] He2; decompose [and] He3.
clear He1 He2 He3.
rewrite H5, H8, H11.
eexists; eexists.
split; try split.
3: eauto.
apply maxl_bound; omega.
apply maxl_bound; omega.
destruct H2 as (ne & se & He).
decompose [and] He; clear He.
rewrite H7.
repeat rewrite leb_correct.
simpl.
case_eq ( inf_list (map inf (map convI rl)) ) ; intros.
case_eq ( inf_list (map inf (map convI tl)) ) ; intros.
case_eq (beq_nat n1 0); intros.
eexists; eexists; split; try split.
3: eauto.
apply Nat.max_lub.
apply inf_list_maxl_l in H5.
rewrite H5.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.
destruct H10 as [? [? ?]].
destruct (H3 x H11) as (? & ? & ?).
decompose [and] H12.
subst.

*****
H16 : eq (inf (convI x)) (I x0 x1)
H15 : le x1 Datatypes.O
H13 : le x0 n
H12 : and (le x0 n) (and (le x1 Datatypes.O) (eq (inf (convI x)) (I x0 x1)))
x0,x1 : nat
H11 : In x rl
x : BC
H9 : eq (Nat.eqb n1 Datatypes.O) true
H8 : eq (inf_list (map inf (map convI tl))) (I n2 n3)
n1,n2,n3 : nat
H7 : eq (inf (convI h)) (I ne se)
H6 : le se (length tl)
H2 : le ne (length rl)
H4 : forall (r : BC) (_ : In r tl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n) (and (le s' s) (eq (inf (convI r)) (I n' s')))))
H3 : forall (r : BC) (_ : In r rl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n)\n (and (le s' Datatypes.O) (eq (inf (convI r)) (I n' s')))))
ne,se : nat
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl),\neq (arities e) (ok_arities n Datatypes.O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
le (leftI Datatypes.O (inf (convI x))) n
+++++
rewrite H16; simpl; trivial.
-----
Lemma convI_inf_correct : forall (e : BC) n s, arities e = ok_arities n s -> exists n', exists s', n' <= n /\\ s' <= s /\\ inf (convI e) = I n' s'.
Proof.
apply BC_ind_inf; simpl; intros.
exists 0; exists 0; auto.
destruct n; simpl.
exists 0; exists (S (i - 0)).
repeat (split; try omega).
case_eq (leb i n); intros; simpl.
apply leb_complete in H0.
exists (S i); exists 0.
repeat (split; try omega).
apply leb_complete_conv in H0.
exists 0; exists (S (i - S n)).
repeat (split; try omega).
exists 0; exists 1; auto.
exists 0; exists 1; auto.
exists 0; exists 4; auto.
destruct H2 as (ne1 & se1 & He1).
destruct H3 as (ne2 & se2 & He2).
destruct H4 as (ne3 & se3 & He3).
decompose [and] He1; decompose [and] He2; decompose [and] He3.
clear He1 He2 He3.
rewrite H5, H8, H11.
eexists; eexists.
split; try split.
3: eauto.
apply maxl_bound; omega.
apply maxl_bound; omega.
destruct H2 as (ne & se & He).
decompose [and] He; clear He.
rewrite H7.
repeat rewrite leb_correct.
simpl.
case_eq ( inf_list (map inf (map convI rl)) ) ; intros.
case_eq ( inf_list (map inf (map convI tl)) ) ; intros.
case_eq (beq_nat n1 0); intros.
eexists; eexists; split; try split.
3: eauto.
apply Nat.max_lub.
apply inf_list_maxl_l in H5.
rewrite H5.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.
destruct H10 as [? [? ?]].
destruct (H3 x H11) as (? & ? & ?).
decompose [and] H12.
subst.
rewrite H16; simpl; trivial.

*****
H9 : eq (Nat.eqb n1 Datatypes.O) true
H8 : eq (inf_list (map inf (map convI tl))) (I n2 n3)
n2,n3 : nat
H5 : eq (inf_list (map inf (map convI rl))) (I n0 n1)
n0,n1 : nat
H7 : eq (inf (convI h)) (I ne se)
H6 : le se (length tl)
H2 : le ne (length rl)
H4 : forall (r : BC) (_ : In r tl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n) (and (le s' s) (eq (inf (convI r)) (I n' s')))))
H3 : forall (r : BC) (_ : In r rl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n)\n (and (le s' Datatypes.O) (eq (inf (convI r)) (I n' s')))))
ne,se : nat
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl),\neq (arities e) (ok_arities n Datatypes.O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
le n2 n
+++++
apply inf_list_maxl_l in H8.
-----
Lemma convI_inf_correct : forall (e : BC) n s, arities e = ok_arities n s -> exists n', exists s', n' <= n /\\ s' <= s /\\ inf (convI e) = I n' s'.
Proof.
apply BC_ind_inf; simpl; intros.
exists 0; exists 0; auto.
destruct n; simpl.
exists 0; exists (S (i - 0)).
repeat (split; try omega).
case_eq (leb i n); intros; simpl.
apply leb_complete in H0.
exists (S i); exists 0.
repeat (split; try omega).
apply leb_complete_conv in H0.
exists 0; exists (S (i - S n)).
repeat (split; try omega).
exists 0; exists 1; auto.
exists 0; exists 1; auto.
exists 0; exists 4; auto.
destruct H2 as (ne1 & se1 & He1).
destruct H3 as (ne2 & se2 & He2).
destruct H4 as (ne3 & se3 & He3).
decompose [and] He1; decompose [and] He2; decompose [and] He3.
clear He1 He2 He3.
rewrite H5, H8, H11.
eexists; eexists.
split; try split.
3: eauto.
apply maxl_bound; omega.
apply maxl_bound; omega.
destruct H2 as (ne & se & He).
decompose [and] He; clear He.
rewrite H7.
repeat rewrite leb_correct.
simpl.
case_eq ( inf_list (map inf (map convI rl)) ) ; intros.
case_eq ( inf_list (map inf (map convI tl)) ) ; intros.
case_eq (beq_nat n1 0); intros.
eexists; eexists; split; try split.
3: eauto.
apply Nat.max_lub.
apply inf_list_maxl_l in H5.
rewrite H5.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.
destruct H10 as [? [? ?]].
destruct (H3 x H11) as (? & ? & ?).
decompose [and] H12.
subst.
rewrite H16; simpl; trivial.
apply inf_list_maxl_l in H8.

*****
H9 : eq (Nat.eqb n1 Datatypes.O) true
H8 : eq n2 (maxl (map (leftI Datatypes.O) (map inf (map convI tl))))
n2,n3 : nat
H5 : eq (inf_list (map inf (map convI rl))) (I n0 n1)
n0,n1 : nat
H7 : eq (inf (convI h)) (I ne se)
H6 : le se (length tl)
H2 : le ne (length rl)
H4 : forall (r : BC) (_ : In r tl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n) (and (le s' s) (eq (inf (convI r)) (I n' s')))))
H3 : forall (r : BC) (_ : In r rl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n)\n (and (le s' Datatypes.O) (eq (inf (convI r)) (I n' s')))))
ne,se : nat
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl),\neq (arities e) (ok_arities n Datatypes.O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
le n2 n
+++++
rewrite H8.
-----
Lemma convI_inf_correct : forall (e : BC) n s, arities e = ok_arities n s -> exists n', exists s', n' <= n /\\ s' <= s /\\ inf (convI e) = I n' s'.
Proof.
apply BC_ind_inf; simpl; intros.
exists 0; exists 0; auto.
destruct n; simpl.
exists 0; exists (S (i - 0)).
repeat (split; try omega).
case_eq (leb i n); intros; simpl.
apply leb_complete in H0.
exists (S i); exists 0.
repeat (split; try omega).
apply leb_complete_conv in H0.
exists 0; exists (S (i - S n)).
repeat (split; try omega).
exists 0; exists 1; auto.
exists 0; exists 1; auto.
exists 0; exists 4; auto.
destruct H2 as (ne1 & se1 & He1).
destruct H3 as (ne2 & se2 & He2).
destruct H4 as (ne3 & se3 & He3).
decompose [and] He1; decompose [and] He2; decompose [and] He3.
clear He1 He2 He3.
rewrite H5, H8, H11.
eexists; eexists.
split; try split.
3: eauto.
apply maxl_bound; omega.
apply maxl_bound; omega.
destruct H2 as (ne & se & He).
decompose [and] He; clear He.
rewrite H7.
repeat rewrite leb_correct.
simpl.
case_eq ( inf_list (map inf (map convI rl)) ) ; intros.
case_eq ( inf_list (map inf (map convI tl)) ) ; intros.
case_eq (beq_nat n1 0); intros.
eexists; eexists; split; try split.
3: eauto.
apply Nat.max_lub.
apply inf_list_maxl_l in H5.
rewrite H5.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.
destruct H10 as [? [? ?]].
destruct (H3 x H11) as (? & ? & ?).
decompose [and] H12.
subst.
rewrite H16; simpl; trivial.
apply inf_list_maxl_l in H8.
rewrite H8.

*****
H9 : eq (Nat.eqb n1 Datatypes.O) true
H8 : eq n2 (maxl (map (leftI Datatypes.O) (map inf (map convI tl))))
n2,n3 : nat
H5 : eq (inf_list (map inf (map convI rl))) (I n0 n1)
n0,n1 : nat
H7 : eq (inf (convI h)) (I ne se)
H6 : le se (length tl)
H2 : le ne (length rl)
H4 : forall (r : BC) (_ : In r tl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n) (and (le s' s) (eq (inf (convI r)) (I n' s')))))
H3 : forall (r : BC) (_ : In r rl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n)\n (and (le s' Datatypes.O) (eq (inf (convI r)) (I n' s')))))
ne,se : nat
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl),\neq (arities e) (ok_arities n Datatypes.O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
le (maxl (map (leftI Datatypes.O) (map inf (map convI tl)))) n
+++++
rewrite map_map.
-----
Lemma convI_inf_correct : forall (e : BC) n s, arities e = ok_arities n s -> exists n', exists s', n' <= n /\\ s' <= s /\\ inf (convI e) = I n' s'.
Proof.
apply BC_ind_inf; simpl; intros.
exists 0; exists 0; auto.
destruct n; simpl.
exists 0; exists (S (i - 0)).
repeat (split; try omega).
case_eq (leb i n); intros; simpl.
apply leb_complete in H0.
exists (S i); exists 0.
repeat (split; try omega).
apply leb_complete_conv in H0.
exists 0; exists (S (i - S n)).
repeat (split; try omega).
exists 0; exists 1; auto.
exists 0; exists 1; auto.
exists 0; exists 4; auto.
destruct H2 as (ne1 & se1 & He1).
destruct H3 as (ne2 & se2 & He2).
destruct H4 as (ne3 & se3 & He3).
decompose [and] He1; decompose [and] He2; decompose [and] He3.
clear He1 He2 He3.
rewrite H5, H8, H11.
eexists; eexists.
split; try split.
3: eauto.
apply maxl_bound; omega.
apply maxl_bound; omega.
destruct H2 as (ne & se & He).
decompose [and] He; clear He.
rewrite H7.
repeat rewrite leb_correct.
simpl.
case_eq ( inf_list (map inf (map convI rl)) ) ; intros.
case_eq ( inf_list (map inf (map convI tl)) ) ; intros.
case_eq (beq_nat n1 0); intros.
eexists; eexists; split; try split.
3: eauto.
apply Nat.max_lub.
apply inf_list_maxl_l in H5.
rewrite H5.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.
destruct H10 as [? [? ?]].
destruct (H3 x H11) as (? & ? & ?).
decompose [and] H12.
subst.
rewrite H16; simpl; trivial.
apply inf_list_maxl_l in H8.
rewrite H8.
rewrite map_map.

*****
H9 : eq (Nat.eqb n1 Datatypes.O) true
H8 : eq n2 (maxl (map (leftI Datatypes.O) (map inf (map convI tl))))
n2,n3 : nat
H5 : eq (inf_list (map inf (map convI rl))) (I n0 n1)
n0,n1 : nat
H7 : eq (inf (convI h)) (I ne se)
H6 : le se (length tl)
H2 : le ne (length rl)
H4 : forall (r : BC) (_ : In r tl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n) (and (le s' s) (eq (inf (convI r)) (I n' s')))))
H3 : forall (r : BC) (_ : In r rl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n)\n (and (le s' Datatypes.O) (eq (inf (convI r)) (I n' s')))))
ne,se : nat
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl),\neq (arities e) (ok_arities n Datatypes.O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
le (maxl (map (fun x : BCI => leftI Datatypes.O (inf x)) (map convI tl))) n
+++++
rewrite map_map.
-----
Lemma convI_inf_correct : forall (e : BC) n s, arities e = ok_arities n s -> exists n', exists s', n' <= n /\\ s' <= s /\\ inf (convI e) = I n' s'.
Proof.
apply BC_ind_inf; simpl; intros.
exists 0; exists 0; auto.
destruct n; simpl.
exists 0; exists (S (i - 0)).
repeat (split; try omega).
case_eq (leb i n); intros; simpl.
apply leb_complete in H0.
exists (S i); exists 0.
repeat (split; try omega).
apply leb_complete_conv in H0.
exists 0; exists (S (i - S n)).
repeat (split; try omega).
exists 0; exists 1; auto.
exists 0; exists 1; auto.
exists 0; exists 4; auto.
destruct H2 as (ne1 & se1 & He1).
destruct H3 as (ne2 & se2 & He2).
destruct H4 as (ne3 & se3 & He3).
decompose [and] He1; decompose [and] He2; decompose [and] He3.
clear He1 He2 He3.
rewrite H5, H8, H11.
eexists; eexists.
split; try split.
3: eauto.
apply maxl_bound; omega.
apply maxl_bound; omega.
destruct H2 as (ne & se & He).
decompose [and] He; clear He.
rewrite H7.
repeat rewrite leb_correct.
simpl.
case_eq ( inf_list (map inf (map convI rl)) ) ; intros.
case_eq ( inf_list (map inf (map convI tl)) ) ; intros.
case_eq (beq_nat n1 0); intros.
eexists; eexists; split; try split.
3: eauto.
apply Nat.max_lub.
apply inf_list_maxl_l in H5.
rewrite H5.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.
destruct H10 as [? [? ?]].
destruct (H3 x H11) as (? & ? & ?).
decompose [and] H12.
subst.
rewrite H16; simpl; trivial.
apply inf_list_maxl_l in H8.
rewrite H8.
rewrite map_map.
rewrite map_map.

*****
H9 : eq (Nat.eqb n1 Datatypes.O) true
H8 : eq n2 (maxl (map (leftI Datatypes.O) (map inf (map convI tl))))
n2,n3 : nat
H5 : eq (inf_list (map inf (map convI rl))) (I n0 n1)
n0,n1 : nat
H7 : eq (inf (convI h)) (I ne se)
H6 : le se (length tl)
H2 : le ne (length rl)
H4 : forall (r : BC) (_ : In r tl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n) (and (le s' s) (eq (inf (convI r)) (I n' s')))))
H3 : forall (r : BC) (_ : In r rl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n)\n (and (le s' Datatypes.O) (eq (inf (convI r)) (I n' s')))))
ne,se : nat
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl),\neq (arities e) (ok_arities n Datatypes.O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
le (maxl (map (fun x : BC => leftI Datatypes.O (inf (convI x))) tl)) n
+++++
apply maxl_bound_in.
-----
Lemma convI_inf_correct : forall (e : BC) n s, arities e = ok_arities n s -> exists n', exists s', n' <= n /\\ s' <= s /\\ inf (convI e) = I n' s'.
Proof.
apply BC_ind_inf; simpl; intros.
exists 0; exists 0; auto.
destruct n; simpl.
exists 0; exists (S (i - 0)).
repeat (split; try omega).
case_eq (leb i n); intros; simpl.
apply leb_complete in H0.
exists (S i); exists 0.
repeat (split; try omega).
apply leb_complete_conv in H0.
exists 0; exists (S (i - S n)).
repeat (split; try omega).
exists 0; exists 1; auto.
exists 0; exists 1; auto.
exists 0; exists 4; auto.
destruct H2 as (ne1 & se1 & He1).
destruct H3 as (ne2 & se2 & He2).
destruct H4 as (ne3 & se3 & He3).
decompose [and] He1; decompose [and] He2; decompose [and] He3.
clear He1 He2 He3.
rewrite H5, H8, H11.
eexists; eexists.
split; try split.
3: eauto.
apply maxl_bound; omega.
apply maxl_bound; omega.
destruct H2 as (ne & se & He).
decompose [and] He; clear He.
rewrite H7.
repeat rewrite leb_correct.
simpl.
case_eq ( inf_list (map inf (map convI rl)) ) ; intros.
case_eq ( inf_list (map inf (map convI tl)) ) ; intros.
case_eq (beq_nat n1 0); intros.
eexists; eexists; split; try split.
3: eauto.
apply Nat.max_lub.
apply inf_list_maxl_l in H5.
rewrite H5.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.
destruct H10 as [? [? ?]].
destruct (H3 x H11) as (? & ? & ?).
decompose [and] H12.
subst.
rewrite H16; simpl; trivial.
apply inf_list_maxl_l in H8.
rewrite H8.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.

*****
H9 : eq (Nat.eqb n1 Datatypes.O) true
H8 : eq n2 (maxl (map (leftI Datatypes.O) (map inf (map convI tl))))
n2,n3 : nat
H5 : eq (inf_list (map inf (map convI rl))) (I n0 n1)
n0,n1 : nat
H7 : eq (inf (convI h)) (I ne se)
H6 : le se (length tl)
H2 : le ne (length rl)
H4 : forall (r : BC) (_ : In r tl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n) (and (le s' s) (eq (inf (convI r)) (I n' s')))))
H3 : forall (r : BC) (_ : In r rl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n)\n (and (le s' Datatypes.O) (eq (inf (convI r)) (I n' s')))))
ne,se : nat
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl),\neq (arities e) (ok_arities n Datatypes.O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
forall (e' : nat) (_ : In e' (map (fun x : BC => leftI Datatypes.O (inf (convI x))) tl)), le e' n
+++++
intros.
-----
Lemma convI_inf_correct : forall (e : BC) n s, arities e = ok_arities n s -> exists n', exists s', n' <= n /\\ s' <= s /\\ inf (convI e) = I n' s'.
Proof.
apply BC_ind_inf; simpl; intros.
exists 0; exists 0; auto.
destruct n; simpl.
exists 0; exists (S (i - 0)).
repeat (split; try omega).
case_eq (leb i n); intros; simpl.
apply leb_complete in H0.
exists (S i); exists 0.
repeat (split; try omega).
apply leb_complete_conv in H0.
exists 0; exists (S (i - S n)).
repeat (split; try omega).
exists 0; exists 1; auto.
exists 0; exists 1; auto.
exists 0; exists 4; auto.
destruct H2 as (ne1 & se1 & He1).
destruct H3 as (ne2 & se2 & He2).
destruct H4 as (ne3 & se3 & He3).
decompose [and] He1; decompose [and] He2; decompose [and] He3.
clear He1 He2 He3.
rewrite H5, H8, H11.
eexists; eexists.
split; try split.
3: eauto.
apply maxl_bound; omega.
apply maxl_bound; omega.
destruct H2 as (ne & se & He).
decompose [and] He; clear He.
rewrite H7.
repeat rewrite leb_correct.
simpl.
case_eq ( inf_list (map inf (map convI rl)) ) ; intros.
case_eq ( inf_list (map inf (map convI tl)) ) ; intros.
case_eq (beq_nat n1 0); intros.
eexists; eexists; split; try split.
3: eauto.
apply Nat.max_lub.
apply inf_list_maxl_l in H5.
rewrite H5.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.
destruct H10 as [? [? ?]].
destruct (H3 x H11) as (? & ? & ?).
decompose [and] H12.
subst.
rewrite H16; simpl; trivial.
apply inf_list_maxl_l in H8.
rewrite H8.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.

*****
H10 : In e' (map (fun x : BC => leftI Datatypes.O (inf (convI x))) tl)
e' : nat
H9 : eq (Nat.eqb n1 Datatypes.O) true
H8 : eq n2 (maxl (map (leftI Datatypes.O) (map inf (map convI tl))))
n2,n3 : nat
H5 : eq (inf_list (map inf (map convI rl))) (I n0 n1)
n0,n1 : nat
H7 : eq (inf (convI h)) (I ne se)
H6 : le se (length tl)
H2 : le ne (length rl)
H4 : forall (r : BC) (_ : In r tl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n) (and (le s' s) (eq (inf (convI r)) (I n' s')))))
H3 : forall (r : BC) (_ : In r rl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n)\n (and (le s' Datatypes.O) (eq (inf (convI r)) (I n' s')))))
ne,se : nat
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl),\neq (arities e) (ok_arities n Datatypes.O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
le e' n
+++++
apply in_map_iff in H10.
-----
Lemma convI_inf_correct : forall (e : BC) n s, arities e = ok_arities n s -> exists n', exists s', n' <= n /\\ s' <= s /\\ inf (convI e) = I n' s'.
Proof.
apply BC_ind_inf; simpl; intros.
exists 0; exists 0; auto.
destruct n; simpl.
exists 0; exists (S (i - 0)).
repeat (split; try omega).
case_eq (leb i n); intros; simpl.
apply leb_complete in H0.
exists (S i); exists 0.
repeat (split; try omega).
apply leb_complete_conv in H0.
exists 0; exists (S (i - S n)).
repeat (split; try omega).
exists 0; exists 1; auto.
exists 0; exists 1; auto.
exists 0; exists 4; auto.
destruct H2 as (ne1 & se1 & He1).
destruct H3 as (ne2 & se2 & He2).
destruct H4 as (ne3 & se3 & He3).
decompose [and] He1; decompose [and] He2; decompose [and] He3.
clear He1 He2 He3.
rewrite H5, H8, H11.
eexists; eexists.
split; try split.
3: eauto.
apply maxl_bound; omega.
apply maxl_bound; omega.
destruct H2 as (ne & se & He).
decompose [and] He; clear He.
rewrite H7.
repeat rewrite leb_correct.
simpl.
case_eq ( inf_list (map inf (map convI rl)) ) ; intros.
case_eq ( inf_list (map inf (map convI tl)) ) ; intros.
case_eq (beq_nat n1 0); intros.
eexists; eexists; split; try split.
3: eauto.
apply Nat.max_lub.
apply inf_list_maxl_l in H5.
rewrite H5.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.
destruct H10 as [? [? ?]].
destruct (H3 x H11) as (? & ? & ?).
decompose [and] H12.
subst.
rewrite H16; simpl; trivial.
apply inf_list_maxl_l in H8.
rewrite H8.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.

*****
H10 : ex\n (fun x : BC =>\n and (eq (leftI Datatypes.O (inf (convI x))) e') (In x tl))
e' : nat
H9 : eq (Nat.eqb n1 Datatypes.O) true
H8 : eq n2 (maxl (map (leftI Datatypes.O) (map inf (map convI tl))))
n2,n3 : nat
H5 : eq (inf_list (map inf (map convI rl))) (I n0 n1)
n0,n1 : nat
H7 : eq (inf (convI h)) (I ne se)
H6 : le se (length tl)
H2 : le ne (length rl)
H4 : forall (r : BC) (_ : In r tl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n) (and (le s' s) (eq (inf (convI r)) (I n' s')))))
H3 : forall (r : BC) (_ : In r rl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n)\n (and (le s' Datatypes.O) (eq (inf (convI r)) (I n' s')))))
ne,se : nat
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl),\neq (arities e) (ok_arities n Datatypes.O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
le e' n
+++++
destruct H10 as [? [? ?]].
-----
Lemma convI_inf_correct : forall (e : BC) n s, arities e = ok_arities n s -> exists n', exists s', n' <= n /\\ s' <= s /\\ inf (convI e) = I n' s'.
Proof.
apply BC_ind_inf; simpl; intros.
exists 0; exists 0; auto.
destruct n; simpl.
exists 0; exists (S (i - 0)).
repeat (split; try omega).
case_eq (leb i n); intros; simpl.
apply leb_complete in H0.
exists (S i); exists 0.
repeat (split; try omega).
apply leb_complete_conv in H0.
exists 0; exists (S (i - S n)).
repeat (split; try omega).
exists 0; exists 1; auto.
exists 0; exists 1; auto.
exists 0; exists 4; auto.
destruct H2 as (ne1 & se1 & He1).
destruct H3 as (ne2 & se2 & He2).
destruct H4 as (ne3 & se3 & He3).
decompose [and] He1; decompose [and] He2; decompose [and] He3.
clear He1 He2 He3.
rewrite H5, H8, H11.
eexists; eexists.
split; try split.
3: eauto.
apply maxl_bound; omega.
apply maxl_bound; omega.
destruct H2 as (ne & se & He).
decompose [and] He; clear He.
rewrite H7.
repeat rewrite leb_correct.
simpl.
case_eq ( inf_list (map inf (map convI rl)) ) ; intros.
case_eq ( inf_list (map inf (map convI tl)) ) ; intros.
case_eq (beq_nat n1 0); intros.
eexists; eexists; split; try split.
3: eauto.
apply Nat.max_lub.
apply inf_list_maxl_l in H5.
rewrite H5.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.
destruct H10 as [? [? ?]].
destruct (H3 x H11) as (? & ? & ?).
decompose [and] H12.
subst.
rewrite H16; simpl; trivial.
apply inf_list_maxl_l in H8.
rewrite H8.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.
destruct H10 as [? [? ?]].

*****
H11 : In x tl
H10 : eq (leftI Datatypes.O (inf (convI x))) e'
x : BC
e' : nat
H9 : eq (Nat.eqb n1 Datatypes.O) true
H8 : eq n2 (maxl (map (leftI Datatypes.O) (map inf (map convI tl))))
n2,n3 : nat
H5 : eq (inf_list (map inf (map convI rl))) (I n0 n1)
n0,n1 : nat
H7 : eq (inf (convI h)) (I ne se)
H6 : le se (length tl)
H2 : le ne (length rl)
H4 : forall (r : BC) (_ : In r tl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n) (and (le s' s) (eq (inf (convI r)) (I n' s')))))
H3 : forall (r : BC) (_ : In r rl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n)\n (and (le s' Datatypes.O) (eq (inf (convI r)) (I n' s')))))
ne,se : nat
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl),\neq (arities e) (ok_arities n Datatypes.O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
le e' n
+++++
destruct (H4 x H11) as (? & ? & ?).
-----
Lemma convI_inf_correct : forall (e : BC) n s, arities e = ok_arities n s -> exists n', exists s', n' <= n /\\ s' <= s /\\ inf (convI e) = I n' s'.
Proof.
apply BC_ind_inf; simpl; intros.
exists 0; exists 0; auto.
destruct n; simpl.
exists 0; exists (S (i - 0)).
repeat (split; try omega).
case_eq (leb i n); intros; simpl.
apply leb_complete in H0.
exists (S i); exists 0.
repeat (split; try omega).
apply leb_complete_conv in H0.
exists 0; exists (S (i - S n)).
repeat (split; try omega).
exists 0; exists 1; auto.
exists 0; exists 1; auto.
exists 0; exists 4; auto.
destruct H2 as (ne1 & se1 & He1).
destruct H3 as (ne2 & se2 & He2).
destruct H4 as (ne3 & se3 & He3).
decompose [and] He1; decompose [and] He2; decompose [and] He3.
clear He1 He2 He3.
rewrite H5, H8, H11.
eexists; eexists.
split; try split.
3: eauto.
apply maxl_bound; omega.
apply maxl_bound; omega.
destruct H2 as (ne & se & He).
decompose [and] He; clear He.
rewrite H7.
repeat rewrite leb_correct.
simpl.
case_eq ( inf_list (map inf (map convI rl)) ) ; intros.
case_eq ( inf_list (map inf (map convI tl)) ) ; intros.
case_eq (beq_nat n1 0); intros.
eexists; eexists; split; try split.
3: eauto.
apply Nat.max_lub.
apply inf_list_maxl_l in H5.
rewrite H5.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.
destruct H10 as [? [? ?]].
destruct (H3 x H11) as (? & ? & ?).
decompose [and] H12.
subst.
rewrite H16; simpl; trivial.
apply inf_list_maxl_l in H8.
rewrite H8.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.
destruct H10 as [? [? ?]].
destruct (H4 x H11) as (? & ? & ?).

*****
H12 : and (le x0 n) (and (le x1 s) (eq (inf (convI x)) (I x0 x1)))
x0,x1 : nat
H11 : In x tl
H10 : eq (leftI Datatypes.O (inf (convI x))) e'
x : BC
e' : nat
H9 : eq (Nat.eqb n1 Datatypes.O) true
H8 : eq n2 (maxl (map (leftI Datatypes.O) (map inf (map convI tl))))
n2,n3 : nat
H5 : eq (inf_list (map inf (map convI rl))) (I n0 n1)
n0,n1 : nat
H7 : eq (inf (convI h)) (I ne se)
H6 : le se (length tl)
H2 : le ne (length rl)
H4 : forall (r : BC) (_ : In r tl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n) (and (le s' s) (eq (inf (convI r)) (I n' s')))))
H3 : forall (r : BC) (_ : In r rl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n)\n (and (le s' Datatypes.O) (eq (inf (convI r)) (I n' s')))))
ne,se : nat
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl),\neq (arities e) (ok_arities n Datatypes.O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
le e' n
+++++
decompose [and] H12.
-----
Lemma convI_inf_correct : forall (e : BC) n s, arities e = ok_arities n s -> exists n', exists s', n' <= n /\\ s' <= s /\\ inf (convI e) = I n' s'.
Proof.
apply BC_ind_inf; simpl; intros.
exists 0; exists 0; auto.
destruct n; simpl.
exists 0; exists (S (i - 0)).
repeat (split; try omega).
case_eq (leb i n); intros; simpl.
apply leb_complete in H0.
exists (S i); exists 0.
repeat (split; try omega).
apply leb_complete_conv in H0.
exists 0; exists (S (i - S n)).
repeat (split; try omega).
exists 0; exists 1; auto.
exists 0; exists 1; auto.
exists 0; exists 4; auto.
destruct H2 as (ne1 & se1 & He1).
destruct H3 as (ne2 & se2 & He2).
destruct H4 as (ne3 & se3 & He3).
decompose [and] He1; decompose [and] He2; decompose [and] He3.
clear He1 He2 He3.
rewrite H5, H8, H11.
eexists; eexists.
split; try split.
3: eauto.
apply maxl_bound; omega.
apply maxl_bound; omega.
destruct H2 as (ne & se & He).
decompose [and] He; clear He.
rewrite H7.
repeat rewrite leb_correct.
simpl.
case_eq ( inf_list (map inf (map convI rl)) ) ; intros.
case_eq ( inf_list (map inf (map convI tl)) ) ; intros.
case_eq (beq_nat n1 0); intros.
eexists; eexists; split; try split.
3: eauto.
apply Nat.max_lub.
apply inf_list_maxl_l in H5.
rewrite H5.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.
destruct H10 as [? [? ?]].
destruct (H3 x H11) as (? & ? & ?).
decompose [and] H12.
subst.
rewrite H16; simpl; trivial.
apply inf_list_maxl_l in H8.
rewrite H8.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.
destruct H10 as [? [? ?]].
destruct (H4 x H11) as (? & ? & ?).
decompose [and] H12.

*****
H16 : eq (inf (convI x)) (I x0 x1)
H15 : le x1 s
H13 : le x0 n
H12 : and (le x0 n) (and (le x1 s) (eq (inf (convI x)) (I x0 x1)))
x0,x1 : nat
H11 : In x tl
H10 : eq (leftI Datatypes.O (inf (convI x))) e'
x : BC
e' : nat
H9 : eq (Nat.eqb n1 Datatypes.O) true
H8 : eq n2 (maxl (map (leftI Datatypes.O) (map inf (map convI tl))))
n2,n3 : nat
H5 : eq (inf_list (map inf (map convI rl))) (I n0 n1)
n0,n1 : nat
H7 : eq (inf (convI h)) (I ne se)
H6 : le se (length tl)
H2 : le ne (length rl)
H4 : forall (r : BC) (_ : In r tl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n) (and (le s' s) (eq (inf (convI r)) (I n' s')))))
H3 : forall (r : BC) (_ : In r rl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n)\n (and (le s' Datatypes.O) (eq (inf (convI r)) (I n' s')))))
ne,se : nat
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl),\neq (arities e) (ok_arities n Datatypes.O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
le e' n
+++++
subst.
-----
Lemma convI_inf_correct : forall (e : BC) n s, arities e = ok_arities n s -> exists n', exists s', n' <= n /\\ s' <= s /\\ inf (convI e) = I n' s'.
Proof.
apply BC_ind_inf; simpl; intros.
exists 0; exists 0; auto.
destruct n; simpl.
exists 0; exists (S (i - 0)).
repeat (split; try omega).
case_eq (leb i n); intros; simpl.
apply leb_complete in H0.
exists (S i); exists 0.
repeat (split; try omega).
apply leb_complete_conv in H0.
exists 0; exists (S (i - S n)).
repeat (split; try omega).
exists 0; exists 1; auto.
exists 0; exists 1; auto.
exists 0; exists 4; auto.
destruct H2 as (ne1 & se1 & He1).
destruct H3 as (ne2 & se2 & He2).
destruct H4 as (ne3 & se3 & He3).
decompose [and] He1; decompose [and] He2; decompose [and] He3.
clear He1 He2 He3.
rewrite H5, H8, H11.
eexists; eexists.
split; try split.
3: eauto.
apply maxl_bound; omega.
apply maxl_bound; omega.
destruct H2 as (ne & se & He).
decompose [and] He; clear He.
rewrite H7.
repeat rewrite leb_correct.
simpl.
case_eq ( inf_list (map inf (map convI rl)) ) ; intros.
case_eq ( inf_list (map inf (map convI tl)) ) ; intros.
case_eq (beq_nat n1 0); intros.
eexists; eexists; split; try split.
3: eauto.
apply Nat.max_lub.
apply inf_list_maxl_l in H5.
rewrite H5.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.
destruct H10 as [? [? ?]].
destruct (H3 x H11) as (? & ? & ?).
decompose [and] H12.
subst.
rewrite H16; simpl; trivial.
apply inf_list_maxl_l in H8.
rewrite H8.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.
destruct H10 as [? [? ?]].
destruct (H4 x H11) as (? & ? & ?).
decompose [and] H12.
subst.

*****
H16 : eq (inf (convI x)) (I x0 x1)
H15 : le x1 s
H13 : le x0 n
H12 : and (le x0 n) (and (le x1 s) (eq (inf (convI x)) (I x0 x1)))
x0,x1 : nat
H11 : In x tl
x : BC
H9 : eq (Nat.eqb n1 Datatypes.O) true
n3 : nat
H5 : eq (inf_list (map inf (map convI rl))) (I n0 n1)
n0,n1 : nat
H7 : eq (inf (convI h)) (I ne se)
H6 : le se (length tl)
H2 : le ne (length rl)
H4 : forall (r : BC) (_ : In r tl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n) (and (le s' s) (eq (inf (convI r)) (I n' s')))))
H3 : forall (r : BC) (_ : In r rl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n)\n (and (le s' Datatypes.O) (eq (inf (convI r)) (I n' s')))))
ne,se : nat
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl),\neq (arities e) (ok_arities n Datatypes.O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
le (leftI Datatypes.O (inf (convI x))) n
+++++
rewrite H16; simpl; trivial.
-----
Lemma convI_inf_correct : forall (e : BC) n s, arities e = ok_arities n s -> exists n', exists s', n' <= n /\\ s' <= s /\\ inf (convI e) = I n' s'.
Proof.
apply BC_ind_inf; simpl; intros.
exists 0; exists 0; auto.
destruct n; simpl.
exists 0; exists (S (i - 0)).
repeat (split; try omega).
case_eq (leb i n); intros; simpl.
apply leb_complete in H0.
exists (S i); exists 0.
repeat (split; try omega).
apply leb_complete_conv in H0.
exists 0; exists (S (i - S n)).
repeat (split; try omega).
exists 0; exists 1; auto.
exists 0; exists 1; auto.
exists 0; exists 4; auto.
destruct H2 as (ne1 & se1 & He1).
destruct H3 as (ne2 & se2 & He2).
destruct H4 as (ne3 & se3 & He3).
decompose [and] He1; decompose [and] He2; decompose [and] He3.
clear He1 He2 He3.
rewrite H5, H8, H11.
eexists; eexists.
split; try split.
3: eauto.
apply maxl_bound; omega.
apply maxl_bound; omega.
destruct H2 as (ne & se & He).
decompose [and] He; clear He.
rewrite H7.
repeat rewrite leb_correct.
simpl.
case_eq ( inf_list (map inf (map convI rl)) ) ; intros.
case_eq ( inf_list (map inf (map convI tl)) ) ; intros.
case_eq (beq_nat n1 0); intros.
eexists; eexists; split; try split.
3: eauto.
apply Nat.max_lub.
apply inf_list_maxl_l in H5.
rewrite H5.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.
destruct H10 as [? [? ?]].
destruct (H3 x H11) as (? & ? & ?).
decompose [and] H12.
subst.
rewrite H16; simpl; trivial.
apply inf_list_maxl_l in H8.
rewrite H8.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.
destruct H10 as [? [? ?]].
destruct (H4 x H11) as (? & ? & ?).
decompose [and] H12.
subst.
rewrite H16; simpl; trivial.

*****
H9 : eq (Nat.eqb n1 Datatypes.O) true
H8 : eq (inf_list (map inf (map convI tl))) (I n2 n3)
n2,n3 : nat
H5 : eq (inf_list (map inf (map convI rl))) (I n0 n1)
n0,n1 : nat
H7 : eq (inf (convI h)) (I ne se)
H6 : le se (length tl)
H2 : le ne (length rl)
H4 : forall (r : BC) (_ : In r tl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n) (and (le s' s) (eq (inf (convI r)) (I n' s')))))
H3 : forall (r : BC) (_ : In r rl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n)\n (and (le s' Datatypes.O) (eq (inf (convI r)) (I n' s')))))
ne,se : nat
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl),\neq (arities e) (ok_arities n Datatypes.O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
le n3 s
+++++
apply inf_list_maxl_r in H8.
-----
Lemma convI_inf_correct : forall (e : BC) n s, arities e = ok_arities n s -> exists n', exists s', n' <= n /\\ s' <= s /\\ inf (convI e) = I n' s'.
Proof.
apply BC_ind_inf; simpl; intros.
exists 0; exists 0; auto.
destruct n; simpl.
exists 0; exists (S (i - 0)).
repeat (split; try omega).
case_eq (leb i n); intros; simpl.
apply leb_complete in H0.
exists (S i); exists 0.
repeat (split; try omega).
apply leb_complete_conv in H0.
exists 0; exists (S (i - S n)).
repeat (split; try omega).
exists 0; exists 1; auto.
exists 0; exists 1; auto.
exists 0; exists 4; auto.
destruct H2 as (ne1 & se1 & He1).
destruct H3 as (ne2 & se2 & He2).
destruct H4 as (ne3 & se3 & He3).
decompose [and] He1; decompose [and] He2; decompose [and] He3.
clear He1 He2 He3.
rewrite H5, H8, H11.
eexists; eexists.
split; try split.
3: eauto.
apply maxl_bound; omega.
apply maxl_bound; omega.
destruct H2 as (ne & se & He).
decompose [and] He; clear He.
rewrite H7.
repeat rewrite leb_correct.
simpl.
case_eq ( inf_list (map inf (map convI rl)) ) ; intros.
case_eq ( inf_list (map inf (map convI tl)) ) ; intros.
case_eq (beq_nat n1 0); intros.
eexists; eexists; split; try split.
3: eauto.
apply Nat.max_lub.
apply inf_list_maxl_l in H5.
rewrite H5.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.
destruct H10 as [? [? ?]].
destruct (H3 x H11) as (? & ? & ?).
decompose [and] H12.
subst.
rewrite H16; simpl; trivial.
apply inf_list_maxl_l in H8.
rewrite H8.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.
destruct H10 as [? [? ?]].
destruct (H4 x H11) as (? & ? & ?).
decompose [and] H12.
subst.
rewrite H16; simpl; trivial.
apply inf_list_maxl_r in H8.

*****
H9 : eq (Nat.eqb n1 Datatypes.O) true
H8 : eq n3 (maxl (map (rightI Datatypes.O) (map inf (map convI tl))))
n2,n3 : nat
H5 : eq (inf_list (map inf (map convI rl))) (I n0 n1)
n0,n1 : nat
H7 : eq (inf (convI h)) (I ne se)
H6 : le se (length tl)
H2 : le ne (length rl)
H4 : forall (r : BC) (_ : In r tl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n) (and (le s' s) (eq (inf (convI r)) (I n' s')))))
H3 : forall (r : BC) (_ : In r rl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n)\n (and (le s' Datatypes.O) (eq (inf (convI r)) (I n' s')))))
ne,se : nat
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl),\neq (arities e) (ok_arities n Datatypes.O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
le n3 s
+++++
rewrite H8.
-----
Lemma convI_inf_correct : forall (e : BC) n s, arities e = ok_arities n s -> exists n', exists s', n' <= n /\\ s' <= s /\\ inf (convI e) = I n' s'.
Proof.
apply BC_ind_inf; simpl; intros.
exists 0; exists 0; auto.
destruct n; simpl.
exists 0; exists (S (i - 0)).
repeat (split; try omega).
case_eq (leb i n); intros; simpl.
apply leb_complete in H0.
exists (S i); exists 0.
repeat (split; try omega).
apply leb_complete_conv in H0.
exists 0; exists (S (i - S n)).
repeat (split; try omega).
exists 0; exists 1; auto.
exists 0; exists 1; auto.
exists 0; exists 4; auto.
destruct H2 as (ne1 & se1 & He1).
destruct H3 as (ne2 & se2 & He2).
destruct H4 as (ne3 & se3 & He3).
decompose [and] He1; decompose [and] He2; decompose [and] He3.
clear He1 He2 He3.
rewrite H5, H8, H11.
eexists; eexists.
split; try split.
3: eauto.
apply maxl_bound; omega.
apply maxl_bound; omega.
destruct H2 as (ne & se & He).
decompose [and] He; clear He.
rewrite H7.
repeat rewrite leb_correct.
simpl.
case_eq ( inf_list (map inf (map convI rl)) ) ; intros.
case_eq ( inf_list (map inf (map convI tl)) ) ; intros.
case_eq (beq_nat n1 0); intros.
eexists; eexists; split; try split.
3: eauto.
apply Nat.max_lub.
apply inf_list_maxl_l in H5.
rewrite H5.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.
destruct H10 as [? [? ?]].
destruct (H3 x H11) as (? & ? & ?).
decompose [and] H12.
subst.
rewrite H16; simpl; trivial.
apply inf_list_maxl_l in H8.
rewrite H8.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.
destruct H10 as [? [? ?]].
destruct (H4 x H11) as (? & ? & ?).
decompose [and] H12.
subst.
rewrite H16; simpl; trivial.
apply inf_list_maxl_r in H8.
rewrite H8.

*****
H9 : eq (Nat.eqb n1 Datatypes.O) true
H8 : eq n3 (maxl (map (rightI Datatypes.O) (map inf (map convI tl))))
n2,n3 : nat
H5 : eq (inf_list (map inf (map convI rl))) (I n0 n1)
n0,n1 : nat
H7 : eq (inf (convI h)) (I ne se)
H6 : le se (length tl)
H2 : le ne (length rl)
H4 : forall (r : BC) (_ : In r tl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n) (and (le s' s) (eq (inf (convI r)) (I n' s')))))
H3 : forall (r : BC) (_ : In r rl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n)\n (and (le s' Datatypes.O) (eq (inf (convI r)) (I n' s')))))
ne,se : nat
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl),\neq (arities e) (ok_arities n Datatypes.O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
le (maxl (map (rightI Datatypes.O) (map inf (map convI tl)))) s
+++++
rewrite map_map.
-----
Lemma convI_inf_correct : forall (e : BC) n s, arities e = ok_arities n s -> exists n', exists s', n' <= n /\\ s' <= s /\\ inf (convI e) = I n' s'.
Proof.
apply BC_ind_inf; simpl; intros.
exists 0; exists 0; auto.
destruct n; simpl.
exists 0; exists (S (i - 0)).
repeat (split; try omega).
case_eq (leb i n); intros; simpl.
apply leb_complete in H0.
exists (S i); exists 0.
repeat (split; try omega).
apply leb_complete_conv in H0.
exists 0; exists (S (i - S n)).
repeat (split; try omega).
exists 0; exists 1; auto.
exists 0; exists 1; auto.
exists 0; exists 4; auto.
destruct H2 as (ne1 & se1 & He1).
destruct H3 as (ne2 & se2 & He2).
destruct H4 as (ne3 & se3 & He3).
decompose [and] He1; decompose [and] He2; decompose [and] He3.
clear He1 He2 He3.
rewrite H5, H8, H11.
eexists; eexists.
split; try split.
3: eauto.
apply maxl_bound; omega.
apply maxl_bound; omega.
destruct H2 as (ne & se & He).
decompose [and] He; clear He.
rewrite H7.
repeat rewrite leb_correct.
simpl.
case_eq ( inf_list (map inf (map convI rl)) ) ; intros.
case_eq ( inf_list (map inf (map convI tl)) ) ; intros.
case_eq (beq_nat n1 0); intros.
eexists; eexists; split; try split.
3: eauto.
apply Nat.max_lub.
apply inf_list_maxl_l in H5.
rewrite H5.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.
destruct H10 as [? [? ?]].
destruct (H3 x H11) as (? & ? & ?).
decompose [and] H12.
subst.
rewrite H16; simpl; trivial.
apply inf_list_maxl_l in H8.
rewrite H8.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.
destruct H10 as [? [? ?]].
destruct (H4 x H11) as (? & ? & ?).
decompose [and] H12.
subst.
rewrite H16; simpl; trivial.
apply inf_list_maxl_r in H8.
rewrite H8.
rewrite map_map.

*****
H9 : eq (Nat.eqb n1 Datatypes.O) true
H8 : eq n3 (maxl (map (rightI Datatypes.O) (map inf (map convI tl))))
n2,n3 : nat
H5 : eq (inf_list (map inf (map convI rl))) (I n0 n1)
n0,n1 : nat
H7 : eq (inf (convI h)) (I ne se)
H6 : le se (length tl)
H2 : le ne (length rl)
H4 : forall (r : BC) (_ : In r tl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n) (and (le s' s) (eq (inf (convI r)) (I n' s')))))
H3 : forall (r : BC) (_ : In r rl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n)\n (and (le s' Datatypes.O) (eq (inf (convI r)) (I n' s')))))
ne,se : nat
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl),\neq (arities e) (ok_arities n Datatypes.O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
le (maxl (map (fun x : BCI => rightI Datatypes.O (inf x)) (map convI tl))) s
+++++
rewrite map_map.
-----
Lemma convI_inf_correct : forall (e : BC) n s, arities e = ok_arities n s -> exists n', exists s', n' <= n /\\ s' <= s /\\ inf (convI e) = I n' s'.
Proof.
apply BC_ind_inf; simpl; intros.
exists 0; exists 0; auto.
destruct n; simpl.
exists 0; exists (S (i - 0)).
repeat (split; try omega).
case_eq (leb i n); intros; simpl.
apply leb_complete in H0.
exists (S i); exists 0.
repeat (split; try omega).
apply leb_complete_conv in H0.
exists 0; exists (S (i - S n)).
repeat (split; try omega).
exists 0; exists 1; auto.
exists 0; exists 1; auto.
exists 0; exists 4; auto.
destruct H2 as (ne1 & se1 & He1).
destruct H3 as (ne2 & se2 & He2).
destruct H4 as (ne3 & se3 & He3).
decompose [and] He1; decompose [and] He2; decompose [and] He3.
clear He1 He2 He3.
rewrite H5, H8, H11.
eexists; eexists.
split; try split.
3: eauto.
apply maxl_bound; omega.
apply maxl_bound; omega.
destruct H2 as (ne & se & He).
decompose [and] He; clear He.
rewrite H7.
repeat rewrite leb_correct.
simpl.
case_eq ( inf_list (map inf (map convI rl)) ) ; intros.
case_eq ( inf_list (map inf (map convI tl)) ) ; intros.
case_eq (beq_nat n1 0); intros.
eexists; eexists; split; try split.
3: eauto.
apply Nat.max_lub.
apply inf_list_maxl_l in H5.
rewrite H5.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.
destruct H10 as [? [? ?]].
destruct (H3 x H11) as (? & ? & ?).
decompose [and] H12.
subst.
rewrite H16; simpl; trivial.
apply inf_list_maxl_l in H8.
rewrite H8.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.
destruct H10 as [? [? ?]].
destruct (H4 x H11) as (? & ? & ?).
decompose [and] H12.
subst.
rewrite H16; simpl; trivial.
apply inf_list_maxl_r in H8.
rewrite H8.
rewrite map_map.
rewrite map_map.

*****
H9 : eq (Nat.eqb n1 Datatypes.O) true
H8 : eq n3 (maxl (map (rightI Datatypes.O) (map inf (map convI tl))))
n2,n3 : nat
H5 : eq (inf_list (map inf (map convI rl))) (I n0 n1)
n0,n1 : nat
H7 : eq (inf (convI h)) (I ne se)
H6 : le se (length tl)
H2 : le ne (length rl)
H4 : forall (r : BC) (_ : In r tl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n) (and (le s' s) (eq (inf (convI r)) (I n' s')))))
H3 : forall (r : BC) (_ : In r rl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n)\n (and (le s' Datatypes.O) (eq (inf (convI r)) (I n' s')))))
ne,se : nat
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl),\neq (arities e) (ok_arities n Datatypes.O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
le (maxl (map (fun x : BC => rightI Datatypes.O (inf (convI x))) tl)) s
+++++
apply maxl_bound_in.
-----
Lemma convI_inf_correct : forall (e : BC) n s, arities e = ok_arities n s -> exists n', exists s', n' <= n /\\ s' <= s /\\ inf (convI e) = I n' s'.
Proof.
apply BC_ind_inf; simpl; intros.
exists 0; exists 0; auto.
destruct n; simpl.
exists 0; exists (S (i - 0)).
repeat (split; try omega).
case_eq (leb i n); intros; simpl.
apply leb_complete in H0.
exists (S i); exists 0.
repeat (split; try omega).
apply leb_complete_conv in H0.
exists 0; exists (S (i - S n)).
repeat (split; try omega).
exists 0; exists 1; auto.
exists 0; exists 1; auto.
exists 0; exists 4; auto.
destruct H2 as (ne1 & se1 & He1).
destruct H3 as (ne2 & se2 & He2).
destruct H4 as (ne3 & se3 & He3).
decompose [and] He1; decompose [and] He2; decompose [and] He3.
clear He1 He2 He3.
rewrite H5, H8, H11.
eexists; eexists.
split; try split.
3: eauto.
apply maxl_bound; omega.
apply maxl_bound; omega.
destruct H2 as (ne & se & He).
decompose [and] He; clear He.
rewrite H7.
repeat rewrite leb_correct.
simpl.
case_eq ( inf_list (map inf (map convI rl)) ) ; intros.
case_eq ( inf_list (map inf (map convI tl)) ) ; intros.
case_eq (beq_nat n1 0); intros.
eexists; eexists; split; try split.
3: eauto.
apply Nat.max_lub.
apply inf_list_maxl_l in H5.
rewrite H5.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.
destruct H10 as [? [? ?]].
destruct (H3 x H11) as (? & ? & ?).
decompose [and] H12.
subst.
rewrite H16; simpl; trivial.
apply inf_list_maxl_l in H8.
rewrite H8.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.
destruct H10 as [? [? ?]].
destruct (H4 x H11) as (? & ? & ?).
decompose [and] H12.
subst.
rewrite H16; simpl; trivial.
apply inf_list_maxl_r in H8.
rewrite H8.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.

*****
H9 : eq (Nat.eqb n1 Datatypes.O) true
H8 : eq n3 (maxl (map (rightI Datatypes.O) (map inf (map convI tl))))
n2,n3 : nat
H5 : eq (inf_list (map inf (map convI rl))) (I n0 n1)
n0,n1 : nat
H7 : eq (inf (convI h)) (I ne se)
H6 : le se (length tl)
H2 : le ne (length rl)
H4 : forall (r : BC) (_ : In r tl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n) (and (le s' s) (eq (inf (convI r)) (I n' s')))))
H3 : forall (r : BC) (_ : In r rl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n)\n (and (le s' Datatypes.O) (eq (inf (convI r)) (I n' s')))))
ne,se : nat
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl),\neq (arities e) (ok_arities n Datatypes.O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
forall (e' : nat) (_ : In e' (map (fun x : BC => rightI Datatypes.O (inf (convI x))) tl)), le e' s
+++++
intros.
-----
Lemma convI_inf_correct : forall (e : BC) n s, arities e = ok_arities n s -> exists n', exists s', n' <= n /\\ s' <= s /\\ inf (convI e) = I n' s'.
Proof.
apply BC_ind_inf; simpl; intros.
exists 0; exists 0; auto.
destruct n; simpl.
exists 0; exists (S (i - 0)).
repeat (split; try omega).
case_eq (leb i n); intros; simpl.
apply leb_complete in H0.
exists (S i); exists 0.
repeat (split; try omega).
apply leb_complete_conv in H0.
exists 0; exists (S (i - S n)).
repeat (split; try omega).
exists 0; exists 1; auto.
exists 0; exists 1; auto.
exists 0; exists 4; auto.
destruct H2 as (ne1 & se1 & He1).
destruct H3 as (ne2 & se2 & He2).
destruct H4 as (ne3 & se3 & He3).
decompose [and] He1; decompose [and] He2; decompose [and] He3.
clear He1 He2 He3.
rewrite H5, H8, H11.
eexists; eexists.
split; try split.
3: eauto.
apply maxl_bound; omega.
apply maxl_bound; omega.
destruct H2 as (ne & se & He).
decompose [and] He; clear He.
rewrite H7.
repeat rewrite leb_correct.
simpl.
case_eq ( inf_list (map inf (map convI rl)) ) ; intros.
case_eq ( inf_list (map inf (map convI tl)) ) ; intros.
case_eq (beq_nat n1 0); intros.
eexists; eexists; split; try split.
3: eauto.
apply Nat.max_lub.
apply inf_list_maxl_l in H5.
rewrite H5.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.
destruct H10 as [? [? ?]].
destruct (H3 x H11) as (? & ? & ?).
decompose [and] H12.
subst.
rewrite H16; simpl; trivial.
apply inf_list_maxl_l in H8.
rewrite H8.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.
destruct H10 as [? [? ?]].
destruct (H4 x H11) as (? & ? & ?).
decompose [and] H12.
subst.
rewrite H16; simpl; trivial.
apply inf_list_maxl_r in H8.
rewrite H8.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.

*****
H10 : In e' (map (fun x : BC => rightI Datatypes.O (inf (convI x))) tl)
e' : nat
H9 : eq (Nat.eqb n1 Datatypes.O) true
H8 : eq n3 (maxl (map (rightI Datatypes.O) (map inf (map convI tl))))
n2,n3 : nat
H5 : eq (inf_list (map inf (map convI rl))) (I n0 n1)
n0,n1 : nat
H7 : eq (inf (convI h)) (I ne se)
H6 : le se (length tl)
H2 : le ne (length rl)
H4 : forall (r : BC) (_ : In r tl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n) (and (le s' s) (eq (inf (convI r)) (I n' s')))))
H3 : forall (r : BC) (_ : In r rl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n)\n (and (le s' Datatypes.O) (eq (inf (convI r)) (I n' s')))))
ne,se : nat
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl),\neq (arities e) (ok_arities n Datatypes.O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
le e' s
+++++
apply in_map_iff in H10.
-----
Lemma convI_inf_correct : forall (e : BC) n s, arities e = ok_arities n s -> exists n', exists s', n' <= n /\\ s' <= s /\\ inf (convI e) = I n' s'.
Proof.
apply BC_ind_inf; simpl; intros.
exists 0; exists 0; auto.
destruct n; simpl.
exists 0; exists (S (i - 0)).
repeat (split; try omega).
case_eq (leb i n); intros; simpl.
apply leb_complete in H0.
exists (S i); exists 0.
repeat (split; try omega).
apply leb_complete_conv in H0.
exists 0; exists (S (i - S n)).
repeat (split; try omega).
exists 0; exists 1; auto.
exists 0; exists 1; auto.
exists 0; exists 4; auto.
destruct H2 as (ne1 & se1 & He1).
destruct H3 as (ne2 & se2 & He2).
destruct H4 as (ne3 & se3 & He3).
decompose [and] He1; decompose [and] He2; decompose [and] He3.
clear He1 He2 He3.
rewrite H5, H8, H11.
eexists; eexists.
split; try split.
3: eauto.
apply maxl_bound; omega.
apply maxl_bound; omega.
destruct H2 as (ne & se & He).
decompose [and] He; clear He.
rewrite H7.
repeat rewrite leb_correct.
simpl.
case_eq ( inf_list (map inf (map convI rl)) ) ; intros.
case_eq ( inf_list (map inf (map convI tl)) ) ; intros.
case_eq (beq_nat n1 0); intros.
eexists; eexists; split; try split.
3: eauto.
apply Nat.max_lub.
apply inf_list_maxl_l in H5.
rewrite H5.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.
destruct H10 as [? [? ?]].
destruct (H3 x H11) as (? & ? & ?).
decompose [and] H12.
subst.
rewrite H16; simpl; trivial.
apply inf_list_maxl_l in H8.
rewrite H8.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.
destruct H10 as [? [? ?]].
destruct (H4 x H11) as (? & ? & ?).
decompose [and] H12.
subst.
rewrite H16; simpl; trivial.
apply inf_list_maxl_r in H8.
rewrite H8.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.

*****
H10 : ex\n (fun x : BC =>\n and (eq (rightI Datatypes.O (inf (convI x))) e') (In x tl))
e' : nat
H9 : eq (Nat.eqb n1 Datatypes.O) true
H8 : eq n3 (maxl (map (rightI Datatypes.O) (map inf (map convI tl))))
n2,n3 : nat
H5 : eq (inf_list (map inf (map convI rl))) (I n0 n1)
n0,n1 : nat
H7 : eq (inf (convI h)) (I ne se)
H6 : le se (length tl)
H2 : le ne (length rl)
H4 : forall (r : BC) (_ : In r tl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n) (and (le s' s) (eq (inf (convI r)) (I n' s')))))
H3 : forall (r : BC) (_ : In r rl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n)\n (and (le s' Datatypes.O) (eq (inf (convI r)) (I n' s')))))
ne,se : nat
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl),\neq (arities e) (ok_arities n Datatypes.O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
le e' s
+++++
destruct H10 as [? [? ?]].
-----
Lemma convI_inf_correct : forall (e : BC) n s, arities e = ok_arities n s -> exists n', exists s', n' <= n /\\ s' <= s /\\ inf (convI e) = I n' s'.
Proof.
apply BC_ind_inf; simpl; intros.
exists 0; exists 0; auto.
destruct n; simpl.
exists 0; exists (S (i - 0)).
repeat (split; try omega).
case_eq (leb i n); intros; simpl.
apply leb_complete in H0.
exists (S i); exists 0.
repeat (split; try omega).
apply leb_complete_conv in H0.
exists 0; exists (S (i - S n)).
repeat (split; try omega).
exists 0; exists 1; auto.
exists 0; exists 1; auto.
exists 0; exists 4; auto.
destruct H2 as (ne1 & se1 & He1).
destruct H3 as (ne2 & se2 & He2).
destruct H4 as (ne3 & se3 & He3).
decompose [and] He1; decompose [and] He2; decompose [and] He3.
clear He1 He2 He3.
rewrite H5, H8, H11.
eexists; eexists.
split; try split.
3: eauto.
apply maxl_bound; omega.
apply maxl_bound; omega.
destruct H2 as (ne & se & He).
decompose [and] He; clear He.
rewrite H7.
repeat rewrite leb_correct.
simpl.
case_eq ( inf_list (map inf (map convI rl)) ) ; intros.
case_eq ( inf_list (map inf (map convI tl)) ) ; intros.
case_eq (beq_nat n1 0); intros.
eexists; eexists; split; try split.
3: eauto.
apply Nat.max_lub.
apply inf_list_maxl_l in H5.
rewrite H5.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.
destruct H10 as [? [? ?]].
destruct (H3 x H11) as (? & ? & ?).
decompose [and] H12.
subst.
rewrite H16; simpl; trivial.
apply inf_list_maxl_l in H8.
rewrite H8.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.
destruct H10 as [? [? ?]].
destruct (H4 x H11) as (? & ? & ?).
decompose [and] H12.
subst.
rewrite H16; simpl; trivial.
apply inf_list_maxl_r in H8.
rewrite H8.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.
destruct H10 as [? [? ?]].

*****
H11 : In x tl
H10 : eq (rightI Datatypes.O (inf (convI x))) e'
x : BC
e' : nat
H9 : eq (Nat.eqb n1 Datatypes.O) true
H8 : eq n3 (maxl (map (rightI Datatypes.O) (map inf (map convI tl))))
n2,n3 : nat
H5 : eq (inf_list (map inf (map convI rl))) (I n0 n1)
n0,n1 : nat
H7 : eq (inf (convI h)) (I ne se)
H6 : le se (length tl)
H2 : le ne (length rl)
H4 : forall (r : BC) (_ : In r tl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n) (and (le s' s) (eq (inf (convI r)) (I n' s')))))
H3 : forall (r : BC) (_ : In r rl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n)\n (and (le s' Datatypes.O) (eq (inf (convI r)) (I n' s')))))
ne,se : nat
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl),\neq (arities e) (ok_arities n Datatypes.O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
le e' s
+++++
destruct (H4 x H11) as (? & ? & ?).
-----
Lemma convI_inf_correct : forall (e : BC) n s, arities e = ok_arities n s -> exists n', exists s', n' <= n /\\ s' <= s /\\ inf (convI e) = I n' s'.
Proof.
apply BC_ind_inf; simpl; intros.
exists 0; exists 0; auto.
destruct n; simpl.
exists 0; exists (S (i - 0)).
repeat (split; try omega).
case_eq (leb i n); intros; simpl.
apply leb_complete in H0.
exists (S i); exists 0.
repeat (split; try omega).
apply leb_complete_conv in H0.
exists 0; exists (S (i - S n)).
repeat (split; try omega).
exists 0; exists 1; auto.
exists 0; exists 1; auto.
exists 0; exists 4; auto.
destruct H2 as (ne1 & se1 & He1).
destruct H3 as (ne2 & se2 & He2).
destruct H4 as (ne3 & se3 & He3).
decompose [and] He1; decompose [and] He2; decompose [and] He3.
clear He1 He2 He3.
rewrite H5, H8, H11.
eexists; eexists.
split; try split.
3: eauto.
apply maxl_bound; omega.
apply maxl_bound; omega.
destruct H2 as (ne & se & He).
decompose [and] He; clear He.
rewrite H7.
repeat rewrite leb_correct.
simpl.
case_eq ( inf_list (map inf (map convI rl)) ) ; intros.
case_eq ( inf_list (map inf (map convI tl)) ) ; intros.
case_eq (beq_nat n1 0); intros.
eexists; eexists; split; try split.
3: eauto.
apply Nat.max_lub.
apply inf_list_maxl_l in H5.
rewrite H5.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.
destruct H10 as [? [? ?]].
destruct (H3 x H11) as (? & ? & ?).
decompose [and] H12.
subst.
rewrite H16; simpl; trivial.
apply inf_list_maxl_l in H8.
rewrite H8.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.
destruct H10 as [? [? ?]].
destruct (H4 x H11) as (? & ? & ?).
decompose [and] H12.
subst.
rewrite H16; simpl; trivial.
apply inf_list_maxl_r in H8.
rewrite H8.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.
destruct H10 as [? [? ?]].
destruct (H4 x H11) as (? & ? & ?).

*****
H12 : and (le x0 n) (and (le x1 s) (eq (inf (convI x)) (I x0 x1)))
x0,x1 : nat
H11 : In x tl
H10 : eq (rightI Datatypes.O (inf (convI x))) e'
x : BC
e' : nat
H9 : eq (Nat.eqb n1 Datatypes.O) true
H8 : eq n3 (maxl (map (rightI Datatypes.O) (map inf (map convI tl))))
n2,n3 : nat
H5 : eq (inf_list (map inf (map convI rl))) (I n0 n1)
n0,n1 : nat
H7 : eq (inf (convI h)) (I ne se)
H6 : le se (length tl)
H2 : le ne (length rl)
H4 : forall (r : BC) (_ : In r tl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n) (and (le s' s) (eq (inf (convI r)) (I n' s')))))
H3 : forall (r : BC) (_ : In r rl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n)\n (and (le s' Datatypes.O) (eq (inf (convI r)) (I n' s')))))
ne,se : nat
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl),\neq (arities e) (ok_arities n Datatypes.O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
le e' s
+++++
decompose [and] H12.
-----
Lemma convI_inf_correct : forall (e : BC) n s, arities e = ok_arities n s -> exists n', exists s', n' <= n /\\ s' <= s /\\ inf (convI e) = I n' s'.
Proof.
apply BC_ind_inf; simpl; intros.
exists 0; exists 0; auto.
destruct n; simpl.
exists 0; exists (S (i - 0)).
repeat (split; try omega).
case_eq (leb i n); intros; simpl.
apply leb_complete in H0.
exists (S i); exists 0.
repeat (split; try omega).
apply leb_complete_conv in H0.
exists 0; exists (S (i - S n)).
repeat (split; try omega).
exists 0; exists 1; auto.
exists 0; exists 1; auto.
exists 0; exists 4; auto.
destruct H2 as (ne1 & se1 & He1).
destruct H3 as (ne2 & se2 & He2).
destruct H4 as (ne3 & se3 & He3).
decompose [and] He1; decompose [and] He2; decompose [and] He3.
clear He1 He2 He3.
rewrite H5, H8, H11.
eexists; eexists.
split; try split.
3: eauto.
apply maxl_bound; omega.
apply maxl_bound; omega.
destruct H2 as (ne & se & He).
decompose [and] He; clear He.
rewrite H7.
repeat rewrite leb_correct.
simpl.
case_eq ( inf_list (map inf (map convI rl)) ) ; intros.
case_eq ( inf_list (map inf (map convI tl)) ) ; intros.
case_eq (beq_nat n1 0); intros.
eexists; eexists; split; try split.
3: eauto.
apply Nat.max_lub.
apply inf_list_maxl_l in H5.
rewrite H5.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.
destruct H10 as [? [? ?]].
destruct (H3 x H11) as (? & ? & ?).
decompose [and] H12.
subst.
rewrite H16; simpl; trivial.
apply inf_list_maxl_l in H8.
rewrite H8.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.
destruct H10 as [? [? ?]].
destruct (H4 x H11) as (? & ? & ?).
decompose [and] H12.
subst.
rewrite H16; simpl; trivial.
apply inf_list_maxl_r in H8.
rewrite H8.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.
destruct H10 as [? [? ?]].
destruct (H4 x H11) as (? & ? & ?).
decompose [and] H12.

*****
H16 : eq (inf (convI x)) (I x0 x1)
H15 : le x1 s
H13 : le x0 n
H12 : and (le x0 n) (and (le x1 s) (eq (inf (convI x)) (I x0 x1)))
x0,x1 : nat
H11 : In x tl
H10 : eq (rightI Datatypes.O (inf (convI x))) e'
x : BC
e' : nat
H9 : eq (Nat.eqb n1 Datatypes.O) true
H8 : eq n3 (maxl (map (rightI Datatypes.O) (map inf (map convI tl))))
n2,n3 : nat
H5 : eq (inf_list (map inf (map convI rl))) (I n0 n1)
n0,n1 : nat
H7 : eq (inf (convI h)) (I ne se)
H6 : le se (length tl)
H2 : le ne (length rl)
H4 : forall (r : BC) (_ : In r tl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n) (and (le s' s) (eq (inf (convI r)) (I n' s')))))
H3 : forall (r : BC) (_ : In r rl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n)\n (and (le s' Datatypes.O) (eq (inf (convI r)) (I n' s')))))
ne,se : nat
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl),\neq (arities e) (ok_arities n Datatypes.O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
le e' s
+++++
subst.
-----
Lemma convI_inf_correct : forall (e : BC) n s, arities e = ok_arities n s -> exists n', exists s', n' <= n /\\ s' <= s /\\ inf (convI e) = I n' s'.
Proof.
apply BC_ind_inf; simpl; intros.
exists 0; exists 0; auto.
destruct n; simpl.
exists 0; exists (S (i - 0)).
repeat (split; try omega).
case_eq (leb i n); intros; simpl.
apply leb_complete in H0.
exists (S i); exists 0.
repeat (split; try omega).
apply leb_complete_conv in H0.
exists 0; exists (S (i - S n)).
repeat (split; try omega).
exists 0; exists 1; auto.
exists 0; exists 1; auto.
exists 0; exists 4; auto.
destruct H2 as (ne1 & se1 & He1).
destruct H3 as (ne2 & se2 & He2).
destruct H4 as (ne3 & se3 & He3).
decompose [and] He1; decompose [and] He2; decompose [and] He3.
clear He1 He2 He3.
rewrite H5, H8, H11.
eexists; eexists.
split; try split.
3: eauto.
apply maxl_bound; omega.
apply maxl_bound; omega.
destruct H2 as (ne & se & He).
decompose [and] He; clear He.
rewrite H7.
repeat rewrite leb_correct.
simpl.
case_eq ( inf_list (map inf (map convI rl)) ) ; intros.
case_eq ( inf_list (map inf (map convI tl)) ) ; intros.
case_eq (beq_nat n1 0); intros.
eexists; eexists; split; try split.
3: eauto.
apply Nat.max_lub.
apply inf_list_maxl_l in H5.
rewrite H5.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.
destruct H10 as [? [? ?]].
destruct (H3 x H11) as (? & ? & ?).
decompose [and] H12.
subst.
rewrite H16; simpl; trivial.
apply inf_list_maxl_l in H8.
rewrite H8.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.
destruct H10 as [? [? ?]].
destruct (H4 x H11) as (? & ? & ?).
decompose [and] H12.
subst.
rewrite H16; simpl; trivial.
apply inf_list_maxl_r in H8.
rewrite H8.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.
destruct H10 as [? [? ?]].
destruct (H4 x H11) as (? & ? & ?).
decompose [and] H12.
subst.

*****
H16 : eq (inf (convI x)) (I x0 x1)
H15 : le x1 s
H13 : le x0 n
H12 : and (le x0 n) (and (le x1 s) (eq (inf (convI x)) (I x0 x1)))
x0,x1 : nat
H11 : In x tl
x : BC
H9 : eq (Nat.eqb n1 Datatypes.O) true
n2 : nat
H5 : eq (inf_list (map inf (map convI rl))) (I n0 n1)
n0,n1 : nat
H7 : eq (inf (convI h)) (I ne se)
H6 : le se (length tl)
H2 : le ne (length rl)
H4 : forall (r : BC) (_ : In r tl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n) (and (le s' s) (eq (inf (convI r)) (I n' s')))))
H3 : forall (r : BC) (_ : In r rl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n)\n (and (le s' Datatypes.O) (eq (inf (convI r)) (I n' s')))))
ne,se : nat
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl),\neq (arities e) (ok_arities n Datatypes.O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
le (rightI Datatypes.O (inf (convI x))) s
+++++
rewrite H16; simpl; trivial.
-----
Lemma convI_inf_correct : forall (e : BC) n s, arities e = ok_arities n s -> exists n', exists s', n' <= n /\\ s' <= s /\\ inf (convI e) = I n' s'.
Proof.
apply BC_ind_inf; simpl; intros.
exists 0; exists 0; auto.
destruct n; simpl.
exists 0; exists (S (i - 0)).
repeat (split; try omega).
case_eq (leb i n); intros; simpl.
apply leb_complete in H0.
exists (S i); exists 0.
repeat (split; try omega).
apply leb_complete_conv in H0.
exists 0; exists (S (i - S n)).
repeat (split; try omega).
exists 0; exists 1; auto.
exists 0; exists 1; auto.
exists 0; exists 4; auto.
destruct H2 as (ne1 & se1 & He1).
destruct H3 as (ne2 & se2 & He2).
destruct H4 as (ne3 & se3 & He3).
decompose [and] He1; decompose [and] He2; decompose [and] He3.
clear He1 He2 He3.
rewrite H5, H8, H11.
eexists; eexists.
split; try split.
3: eauto.
apply maxl_bound; omega.
apply maxl_bound; omega.
destruct H2 as (ne & se & He).
decompose [and] He; clear He.
rewrite H7.
repeat rewrite leb_correct.
simpl.
case_eq ( inf_list (map inf (map convI rl)) ) ; intros.
case_eq ( inf_list (map inf (map convI tl)) ) ; intros.
case_eq (beq_nat n1 0); intros.
eexists; eexists; split; try split.
3: eauto.
apply Nat.max_lub.
apply inf_list_maxl_l in H5.
rewrite H5.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.
destruct H10 as [? [? ?]].
destruct (H3 x H11) as (? & ? & ?).
decompose [and] H12.
subst.
rewrite H16; simpl; trivial.
apply inf_list_maxl_l in H8.
rewrite H8.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.
destruct H10 as [? [? ?]].
destruct (H4 x H11) as (? & ? & ?).
decompose [and] H12.
subst.
rewrite H16; simpl; trivial.
apply inf_list_maxl_r in H8.
rewrite H8.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.
destruct H10 as [? [? ?]].
destruct (H4 x H11) as (? & ? & ?).
decompose [and] H12.
subst.
rewrite H16; simpl; trivial.

*****
H9 : eq (Nat.eqb n1 Datatypes.O) false
H8 : eq (inf_list (map inf (map convI tl))) (I n2 n3)
n2,n3 : nat
H5 : eq (inf_list (map inf (map convI rl))) (I n0 n1)
n0,n1 : nat
H7 : eq (inf (convI h)) (I ne se)
H6 : le se (length tl)
H2 : le ne (length rl)
H4 : forall (r : BC) (_ : In r tl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n) (and (le s' s) (eq (inf (convI r)) (I n' s')))))
H3 : forall (r : BC) (_ : In r rl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n)\n (and (le s' Datatypes.O) (eq (inf (convI r)) (I n' s')))))
ne,se : nat
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl),\neq (arities e) (ok_arities n Datatypes.O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
ex (fun n' : nat => ex (fun s' : nat => and (le n' n) (and (le s' s) (eq (E (Enat (S (S (S (S Datatypes.O)))))) (I n' s')))))
+++++
apply beq_nat_false in H9.
-----
Lemma convI_inf_correct : forall (e : BC) n s, arities e = ok_arities n s -> exists n', exists s', n' <= n /\\ s' <= s /\\ inf (convI e) = I n' s'.
Proof.
apply BC_ind_inf; simpl; intros.
exists 0; exists 0; auto.
destruct n; simpl.
exists 0; exists (S (i - 0)).
repeat (split; try omega).
case_eq (leb i n); intros; simpl.
apply leb_complete in H0.
exists (S i); exists 0.
repeat (split; try omega).
apply leb_complete_conv in H0.
exists 0; exists (S (i - S n)).
repeat (split; try omega).
exists 0; exists 1; auto.
exists 0; exists 1; auto.
exists 0; exists 4; auto.
destruct H2 as (ne1 & se1 & He1).
destruct H3 as (ne2 & se2 & He2).
destruct H4 as (ne3 & se3 & He3).
decompose [and] He1; decompose [and] He2; decompose [and] He3.
clear He1 He2 He3.
rewrite H5, H8, H11.
eexists; eexists.
split; try split.
3: eauto.
apply maxl_bound; omega.
apply maxl_bound; omega.
destruct H2 as (ne & se & He).
decompose [and] He; clear He.
rewrite H7.
repeat rewrite leb_correct.
simpl.
case_eq ( inf_list (map inf (map convI rl)) ) ; intros.
case_eq ( inf_list (map inf (map convI tl)) ) ; intros.
case_eq (beq_nat n1 0); intros.
eexists; eexists; split; try split.
3: eauto.
apply Nat.max_lub.
apply inf_list_maxl_l in H5.
rewrite H5.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.
destruct H10 as [? [? ?]].
destruct (H3 x H11) as (? & ? & ?).
decompose [and] H12.
subst.
rewrite H16; simpl; trivial.
apply inf_list_maxl_l in H8.
rewrite H8.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.
destruct H10 as [? [? ?]].
destruct (H4 x H11) as (? & ? & ?).
decompose [and] H12.
subst.
rewrite H16; simpl; trivial.
apply inf_list_maxl_r in H8.
rewrite H8.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.
destruct H10 as [? [? ?]].
destruct (H4 x H11) as (? & ? & ?).
decompose [and] H12.
subst.
rewrite H16; simpl; trivial.
apply beq_nat_false in H9.

*****
H9 : not (eq n1 Datatypes.O)
H8 : eq (inf_list (map inf (map convI tl))) (I n2 n3)
n2,n3 : nat
H5 : eq (inf_list (map inf (map convI rl))) (I n0 n1)
n0,n1 : nat
H7 : eq (inf (convI h)) (I ne se)
H6 : le se (length tl)
H2 : le ne (length rl)
H4 : forall (r : BC) (_ : In r tl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n) (and (le s' s) (eq (inf (convI r)) (I n' s')))))
H3 : forall (r : BC) (_ : In r rl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n)\n (and (le s' Datatypes.O) (eq (inf (convI r)) (I n' s')))))
ne,se : nat
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl),\neq (arities e) (ok_arities n Datatypes.O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
ex (fun n' : nat => ex (fun s' : nat => and (le n' n) (and (le s' s) (eq (E (Enat (S (S (S (S Datatypes.O)))))) (I n' s')))))
+++++
elim H9.
-----
Lemma convI_inf_correct : forall (e : BC) n s, arities e = ok_arities n s -> exists n', exists s', n' <= n /\\ s' <= s /\\ inf (convI e) = I n' s'.
Proof.
apply BC_ind_inf; simpl; intros.
exists 0; exists 0; auto.
destruct n; simpl.
exists 0; exists (S (i - 0)).
repeat (split; try omega).
case_eq (leb i n); intros; simpl.
apply leb_complete in H0.
exists (S i); exists 0.
repeat (split; try omega).
apply leb_complete_conv in H0.
exists 0; exists (S (i - S n)).
repeat (split; try omega).
exists 0; exists 1; auto.
exists 0; exists 1; auto.
exists 0; exists 4; auto.
destruct H2 as (ne1 & se1 & He1).
destruct H3 as (ne2 & se2 & He2).
destruct H4 as (ne3 & se3 & He3).
decompose [and] He1; decompose [and] He2; decompose [and] He3.
clear He1 He2 He3.
rewrite H5, H8, H11.
eexists; eexists.
split; try split.
3: eauto.
apply maxl_bound; omega.
apply maxl_bound; omega.
destruct H2 as (ne & se & He).
decompose [and] He; clear He.
rewrite H7.
repeat rewrite leb_correct.
simpl.
case_eq ( inf_list (map inf (map convI rl)) ) ; intros.
case_eq ( inf_list (map inf (map convI tl)) ) ; intros.
case_eq (beq_nat n1 0); intros.
eexists; eexists; split; try split.
3: eauto.
apply Nat.max_lub.
apply inf_list_maxl_l in H5.
rewrite H5.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.
destruct H10 as [? [? ?]].
destruct (H3 x H11) as (? & ? & ?).
decompose [and] H12.
subst.
rewrite H16; simpl; trivial.
apply inf_list_maxl_l in H8.
rewrite H8.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.
destruct H10 as [? [? ?]].
destruct (H4 x H11) as (? & ? & ?).
decompose [and] H12.
subst.
rewrite H16; simpl; trivial.
apply inf_list_maxl_r in H8.
rewrite H8.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.
destruct H10 as [? [? ?]].
destruct (H4 x H11) as (? & ? & ?).
decompose [and] H12.
subst.
rewrite H16; simpl; trivial.
apply beq_nat_false in H9.
elim H9.

*****
H9 : not (eq n1 Datatypes.O)
H8 : eq (inf_list (map inf (map convI tl))) (I n2 n3)
n2,n3 : nat
H5 : eq (inf_list (map inf (map convI rl))) (I n0 n1)
n0,n1 : nat
H7 : eq (inf (convI h)) (I ne se)
H6 : le se (length tl)
H2 : le ne (length rl)
H4 : forall (r : BC) (_ : In r tl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n) (and (le s' s) (eq (inf (convI r)) (I n' s')))))
H3 : forall (r : BC) (_ : In r rl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n)\n (and (le s' Datatypes.O) (eq (inf (convI r)) (I n' s')))))
ne,se : nat
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl),\neq (arities e) (ok_arities n Datatypes.O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
eq n1 Datatypes.O
+++++
apply inf_list_maxl_r in H5.
-----
Lemma convI_inf_correct : forall (e : BC) n s, arities e = ok_arities n s -> exists n', exists s', n' <= n /\\ s' <= s /\\ inf (convI e) = I n' s'.
Proof.
apply BC_ind_inf; simpl; intros.
exists 0; exists 0; auto.
destruct n; simpl.
exists 0; exists (S (i - 0)).
repeat (split; try omega).
case_eq (leb i n); intros; simpl.
apply leb_complete in H0.
exists (S i); exists 0.
repeat (split; try omega).
apply leb_complete_conv in H0.
exists 0; exists (S (i - S n)).
repeat (split; try omega).
exists 0; exists 1; auto.
exists 0; exists 1; auto.
exists 0; exists 4; auto.
destruct H2 as (ne1 & se1 & He1).
destruct H3 as (ne2 & se2 & He2).
destruct H4 as (ne3 & se3 & He3).
decompose [and] He1; decompose [and] He2; decompose [and] He3.
clear He1 He2 He3.
rewrite H5, H8, H11.
eexists; eexists.
split; try split.
3: eauto.
apply maxl_bound; omega.
apply maxl_bound; omega.
destruct H2 as (ne & se & He).
decompose [and] He; clear He.
rewrite H7.
repeat rewrite leb_correct.
simpl.
case_eq ( inf_list (map inf (map convI rl)) ) ; intros.
case_eq ( inf_list (map inf (map convI tl)) ) ; intros.
case_eq (beq_nat n1 0); intros.
eexists; eexists; split; try split.
3: eauto.
apply Nat.max_lub.
apply inf_list_maxl_l in H5.
rewrite H5.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.
destruct H10 as [? [? ?]].
destruct (H3 x H11) as (? & ? & ?).
decompose [and] H12.
subst.
rewrite H16; simpl; trivial.
apply inf_list_maxl_l in H8.
rewrite H8.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.
destruct H10 as [? [? ?]].
destruct (H4 x H11) as (? & ? & ?).
decompose [and] H12.
subst.
rewrite H16; simpl; trivial.
apply inf_list_maxl_r in H8.
rewrite H8.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.
destruct H10 as [? [? ?]].
destruct (H4 x H11) as (? & ? & ?).
decompose [and] H12.
subst.
rewrite H16; simpl; trivial.
apply beq_nat_false in H9.
elim H9.
apply inf_list_maxl_r in H5.

*****
H9 : not (eq n1 Datatypes.O)
H8 : eq (inf_list (map inf (map convI tl))) (I n2 n3)
n2,n3 : nat
H5 : eq n1 (maxl (map (rightI Datatypes.O) (map inf (map convI rl))))
n0,n1 : nat
H7 : eq (inf (convI h)) (I ne se)
H6 : le se (length tl)
H2 : le ne (length rl)
H4 : forall (r : BC) (_ : In r tl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n) (and (le s' s) (eq (inf (convI r)) (I n' s')))))
H3 : forall (r : BC) (_ : In r rl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n)\n (and (le s' Datatypes.O) (eq (inf (convI r)) (I n' s')))))
ne,se : nat
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl),\neq (arities e) (ok_arities n Datatypes.O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
eq n1 Datatypes.O
+++++
rewrite H5, map_map, map_map.
-----
Lemma convI_inf_correct : forall (e : BC) n s, arities e = ok_arities n s -> exists n', exists s', n' <= n /\\ s' <= s /\\ inf (convI e) = I n' s'.
Proof.
apply BC_ind_inf; simpl; intros.
exists 0; exists 0; auto.
destruct n; simpl.
exists 0; exists (S (i - 0)).
repeat (split; try omega).
case_eq (leb i n); intros; simpl.
apply leb_complete in H0.
exists (S i); exists 0.
repeat (split; try omega).
apply leb_complete_conv in H0.
exists 0; exists (S (i - S n)).
repeat (split; try omega).
exists 0; exists 1; auto.
exists 0; exists 1; auto.
exists 0; exists 4; auto.
destruct H2 as (ne1 & se1 & He1).
destruct H3 as (ne2 & se2 & He2).
destruct H4 as (ne3 & se3 & He3).
decompose [and] He1; decompose [and] He2; decompose [and] He3.
clear He1 He2 He3.
rewrite H5, H8, H11.
eexists; eexists.
split; try split.
3: eauto.
apply maxl_bound; omega.
apply maxl_bound; omega.
destruct H2 as (ne & se & He).
decompose [and] He; clear He.
rewrite H7.
repeat rewrite leb_correct.
simpl.
case_eq ( inf_list (map inf (map convI rl)) ) ; intros.
case_eq ( inf_list (map inf (map convI tl)) ) ; intros.
case_eq (beq_nat n1 0); intros.
eexists; eexists; split; try split.
3: eauto.
apply Nat.max_lub.
apply inf_list_maxl_l in H5.
rewrite H5.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.
destruct H10 as [? [? ?]].
destruct (H3 x H11) as (? & ? & ?).
decompose [and] H12.
subst.
rewrite H16; simpl; trivial.
apply inf_list_maxl_l in H8.
rewrite H8.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.
destruct H10 as [? [? ?]].
destruct (H4 x H11) as (? & ? & ?).
decompose [and] H12.
subst.
rewrite H16; simpl; trivial.
apply inf_list_maxl_r in H8.
rewrite H8.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.
destruct H10 as [? [? ?]].
destruct (H4 x H11) as (? & ? & ?).
decompose [and] H12.
subst.
rewrite H16; simpl; trivial.
apply beq_nat_false in H9.
elim H9.
apply inf_list_maxl_r in H5.
rewrite H5, map_map, map_map.

*****
H9 : not (eq n1 Datatypes.O)
H8 : eq (inf_list (map inf (map convI tl))) (I n2 n3)
n2,n3 : nat
H5 : eq n1 (maxl (map (rightI Datatypes.O) (map inf (map convI rl))))
n0,n1 : nat
H7 : eq (inf (convI h)) (I ne se)
H6 : le se (length tl)
H2 : le ne (length rl)
H4 : forall (r : BC) (_ : In r tl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n) (and (le s' s) (eq (inf (convI r)) (I n' s')))))
H3 : forall (r : BC) (_ : In r rl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n)\n (and (le s' Datatypes.O) (eq (inf (convI r)) (I n' s')))))
ne,se : nat
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl),\neq (arities e) (ok_arities n Datatypes.O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
eq (maxl (map (fun x : BC => rightI Datatypes.O (inf (convI x))) rl)) Datatypes.O
+++++
apply maxl_map_0.
-----
Lemma convI_inf_correct : forall (e : BC) n s, arities e = ok_arities n s -> exists n', exists s', n' <= n /\\ s' <= s /\\ inf (convI e) = I n' s'.
Proof.
apply BC_ind_inf; simpl; intros.
exists 0; exists 0; auto.
destruct n; simpl.
exists 0; exists (S (i - 0)).
repeat (split; try omega).
case_eq (leb i n); intros; simpl.
apply leb_complete in H0.
exists (S i); exists 0.
repeat (split; try omega).
apply leb_complete_conv in H0.
exists 0; exists (S (i - S n)).
repeat (split; try omega).
exists 0; exists 1; auto.
exists 0; exists 1; auto.
exists 0; exists 4; auto.
destruct H2 as (ne1 & se1 & He1).
destruct H3 as (ne2 & se2 & He2).
destruct H4 as (ne3 & se3 & He3).
decompose [and] He1; decompose [and] He2; decompose [and] He3.
clear He1 He2 He3.
rewrite H5, H8, H11.
eexists; eexists.
split; try split.
3: eauto.
apply maxl_bound; omega.
apply maxl_bound; omega.
destruct H2 as (ne & se & He).
decompose [and] He; clear He.
rewrite H7.
repeat rewrite leb_correct.
simpl.
case_eq ( inf_list (map inf (map convI rl)) ) ; intros.
case_eq ( inf_list (map inf (map convI tl)) ) ; intros.
case_eq (beq_nat n1 0); intros.
eexists; eexists; split; try split.
3: eauto.
apply Nat.max_lub.
apply inf_list_maxl_l in H5.
rewrite H5.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.
destruct H10 as [? [? ?]].
destruct (H3 x H11) as (? & ? & ?).
decompose [and] H12.
subst.
rewrite H16; simpl; trivial.
apply inf_list_maxl_l in H8.
rewrite H8.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.
destruct H10 as [? [? ?]].
destruct (H4 x H11) as (? & ? & ?).
decompose [and] H12.
subst.
rewrite H16; simpl; trivial.
apply inf_list_maxl_r in H8.
rewrite H8.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.
destruct H10 as [? [? ?]].
destruct (H4 x H11) as (? & ? & ?).
decompose [and] H12.
subst.
rewrite H16; simpl; trivial.
apply beq_nat_false in H9.
elim H9.
apply inf_list_maxl_r in H5.
rewrite H5, map_map, map_map.
apply maxl_map_0.

*****
H9 : not (eq n1 Datatypes.O)
H8 : eq (inf_list (map inf (map convI tl))) (I n2 n3)
n2,n3 : nat
H5 : eq n1 (maxl (map (rightI Datatypes.O) (map inf (map convI rl))))
n0,n1 : nat
H7 : eq (inf (convI h)) (I ne se)
H6 : le se (length tl)
H2 : le ne (length rl)
H4 : forall (r : BC) (_ : In r tl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n) (and (le s' s) (eq (inf (convI r)) (I n' s')))))
H3 : forall (r : BC) (_ : In r rl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n)\n (and (le s' Datatypes.O) (eq (inf (convI r)) (I n' s')))))
ne,se : nat
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl),\neq (arities e) (ok_arities n Datatypes.O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
forall (x : BC) (_ : In x rl), eq (rightI Datatypes.O (inf (convI x))) Datatypes.O
+++++
intros.
-----
Lemma convI_inf_correct : forall (e : BC) n s, arities e = ok_arities n s -> exists n', exists s', n' <= n /\\ s' <= s /\\ inf (convI e) = I n' s'.
Proof.
apply BC_ind_inf; simpl; intros.
exists 0; exists 0; auto.
destruct n; simpl.
exists 0; exists (S (i - 0)).
repeat (split; try omega).
case_eq (leb i n); intros; simpl.
apply leb_complete in H0.
exists (S i); exists 0.
repeat (split; try omega).
apply leb_complete_conv in H0.
exists 0; exists (S (i - S n)).
repeat (split; try omega).
exists 0; exists 1; auto.
exists 0; exists 1; auto.
exists 0; exists 4; auto.
destruct H2 as (ne1 & se1 & He1).
destruct H3 as (ne2 & se2 & He2).
destruct H4 as (ne3 & se3 & He3).
decompose [and] He1; decompose [and] He2; decompose [and] He3.
clear He1 He2 He3.
rewrite H5, H8, H11.
eexists; eexists.
split; try split.
3: eauto.
apply maxl_bound; omega.
apply maxl_bound; omega.
destruct H2 as (ne & se & He).
decompose [and] He; clear He.
rewrite H7.
repeat rewrite leb_correct.
simpl.
case_eq ( inf_list (map inf (map convI rl)) ) ; intros.
case_eq ( inf_list (map inf (map convI tl)) ) ; intros.
case_eq (beq_nat n1 0); intros.
eexists; eexists; split; try split.
3: eauto.
apply Nat.max_lub.
apply inf_list_maxl_l in H5.
rewrite H5.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.
destruct H10 as [? [? ?]].
destruct (H3 x H11) as (? & ? & ?).
decompose [and] H12.
subst.
rewrite H16; simpl; trivial.
apply inf_list_maxl_l in H8.
rewrite H8.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.
destruct H10 as [? [? ?]].
destruct (H4 x H11) as (? & ? & ?).
decompose [and] H12.
subst.
rewrite H16; simpl; trivial.
apply inf_list_maxl_r in H8.
rewrite H8.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.
destruct H10 as [? [? ?]].
destruct (H4 x H11) as (? & ? & ?).
decompose [and] H12.
subst.
rewrite H16; simpl; trivial.
apply beq_nat_false in H9.
elim H9.
apply inf_list_maxl_r in H5.
rewrite H5, map_map, map_map.
apply maxl_map_0.
intros.

*****
H10 : In x rl
x : BC
H9 : not (eq n1 Datatypes.O)
H8 : eq (inf_list (map inf (map convI tl))) (I n2 n3)
n2,n3 : nat
H5 : eq n1 (maxl (map (rightI Datatypes.O) (map inf (map convI rl))))
n0,n1 : nat
H7 : eq (inf (convI h)) (I ne se)
H6 : le se (length tl)
H2 : le ne (length rl)
H4 : forall (r : BC) (_ : In r tl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n) (and (le s' s) (eq (inf (convI r)) (I n' s')))))
H3 : forall (r : BC) (_ : In r rl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n)\n (and (le s' Datatypes.O) (eq (inf (convI r)) (I n' s')))))
ne,se : nat
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl),\neq (arities e) (ok_arities n Datatypes.O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
eq (rightI Datatypes.O (inf (convI x))) Datatypes.O
+++++
destruct (H3 x H10) as (? & ? & ?).
-----
Lemma convI_inf_correct : forall (e : BC) n s, arities e = ok_arities n s -> exists n', exists s', n' <= n /\\ s' <= s /\\ inf (convI e) = I n' s'.
Proof.
apply BC_ind_inf; simpl; intros.
exists 0; exists 0; auto.
destruct n; simpl.
exists 0; exists (S (i - 0)).
repeat (split; try omega).
case_eq (leb i n); intros; simpl.
apply leb_complete in H0.
exists (S i); exists 0.
repeat (split; try omega).
apply leb_complete_conv in H0.
exists 0; exists (S (i - S n)).
repeat (split; try omega).
exists 0; exists 1; auto.
exists 0; exists 1; auto.
exists 0; exists 4; auto.
destruct H2 as (ne1 & se1 & He1).
destruct H3 as (ne2 & se2 & He2).
destruct H4 as (ne3 & se3 & He3).
decompose [and] He1; decompose [and] He2; decompose [and] He3.
clear He1 He2 He3.
rewrite H5, H8, H11.
eexists; eexists.
split; try split.
3: eauto.
apply maxl_bound; omega.
apply maxl_bound; omega.
destruct H2 as (ne & se & He).
decompose [and] He; clear He.
rewrite H7.
repeat rewrite leb_correct.
simpl.
case_eq ( inf_list (map inf (map convI rl)) ) ; intros.
case_eq ( inf_list (map inf (map convI tl)) ) ; intros.
case_eq (beq_nat n1 0); intros.
eexists; eexists; split; try split.
3: eauto.
apply Nat.max_lub.
apply inf_list_maxl_l in H5.
rewrite H5.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.
destruct H10 as [? [? ?]].
destruct (H3 x H11) as (? & ? & ?).
decompose [and] H12.
subst.
rewrite H16; simpl; trivial.
apply inf_list_maxl_l in H8.
rewrite H8.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.
destruct H10 as [? [? ?]].
destruct (H4 x H11) as (? & ? & ?).
decompose [and] H12.
subst.
rewrite H16; simpl; trivial.
apply inf_list_maxl_r in H8.
rewrite H8.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.
destruct H10 as [? [? ?]].
destruct (H4 x H11) as (? & ? & ?).
decompose [and] H12.
subst.
rewrite H16; simpl; trivial.
apply beq_nat_false in H9.
elim H9.
apply inf_list_maxl_r in H5.
rewrite H5, map_map, map_map.
apply maxl_map_0.
intros.
destruct (H3 x H10) as (? & ? & ?).

*****
H11 : and (le x0 n) (and (le x1 Datatypes.O) (eq (inf (convI x)) (I x0 x1)))
x0,x1 : nat
H10 : In x rl
x : BC
H9 : not (eq n1 Datatypes.O)
H8 : eq (inf_list (map inf (map convI tl))) (I n2 n3)
n2,n3 : nat
H5 : eq n1 (maxl (map (rightI Datatypes.O) (map inf (map convI rl))))
n0,n1 : nat
H7 : eq (inf (convI h)) (I ne se)
H6 : le se (length tl)
H2 : le ne (length rl)
H4 : forall (r : BC) (_ : In r tl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n) (and (le s' s) (eq (inf (convI r)) (I n' s')))))
H3 : forall (r : BC) (_ : In r rl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n)\n (and (le s' Datatypes.O) (eq (inf (convI r)) (I n' s')))))
ne,se : nat
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl),\neq (arities e) (ok_arities n Datatypes.O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
eq (rightI Datatypes.O (inf (convI x))) Datatypes.O
+++++
decompose [and] H11.
-----
Lemma convI_inf_correct : forall (e : BC) n s, arities e = ok_arities n s -> exists n', exists s', n' <= n /\\ s' <= s /\\ inf (convI e) = I n' s'.
Proof.
apply BC_ind_inf; simpl; intros.
exists 0; exists 0; auto.
destruct n; simpl.
exists 0; exists (S (i - 0)).
repeat (split; try omega).
case_eq (leb i n); intros; simpl.
apply leb_complete in H0.
exists (S i); exists 0.
repeat (split; try omega).
apply leb_complete_conv in H0.
exists 0; exists (S (i - S n)).
repeat (split; try omega).
exists 0; exists 1; auto.
exists 0; exists 1; auto.
exists 0; exists 4; auto.
destruct H2 as (ne1 & se1 & He1).
destruct H3 as (ne2 & se2 & He2).
destruct H4 as (ne3 & se3 & He3).
decompose [and] He1; decompose [and] He2; decompose [and] He3.
clear He1 He2 He3.
rewrite H5, H8, H11.
eexists; eexists.
split; try split.
3: eauto.
apply maxl_bound; omega.
apply maxl_bound; omega.
destruct H2 as (ne & se & He).
decompose [and] He; clear He.
rewrite H7.
repeat rewrite leb_correct.
simpl.
case_eq ( inf_list (map inf (map convI rl)) ) ; intros.
case_eq ( inf_list (map inf (map convI tl)) ) ; intros.
case_eq (beq_nat n1 0); intros.
eexists; eexists; split; try split.
3: eauto.
apply Nat.max_lub.
apply inf_list_maxl_l in H5.
rewrite H5.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.
destruct H10 as [? [? ?]].
destruct (H3 x H11) as (? & ? & ?).
decompose [and] H12.
subst.
rewrite H16; simpl; trivial.
apply inf_list_maxl_l in H8.
rewrite H8.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.
destruct H10 as [? [? ?]].
destruct (H4 x H11) as (? & ? & ?).
decompose [and] H12.
subst.
rewrite H16; simpl; trivial.
apply inf_list_maxl_r in H8.
rewrite H8.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.
destruct H10 as [? [? ?]].
destruct (H4 x H11) as (? & ? & ?).
decompose [and] H12.
subst.
rewrite H16; simpl; trivial.
apply beq_nat_false in H9.
elim H9.
apply inf_list_maxl_r in H5.
rewrite H5, map_map, map_map.
apply maxl_map_0.
intros.
destruct (H3 x H10) as (? & ? & ?).
decompose [and] H11.

*****
H15 : eq (inf (convI x)) (I x0 x1)
H14 : le x1 Datatypes.O
H12 : le x0 n
H11 : and (le x0 n) (and (le x1 Datatypes.O) (eq (inf (convI x)) (I x0 x1)))
x0,x1 : nat
H10 : In x rl
x : BC
H9 : not (eq n1 Datatypes.O)
H8 : eq (inf_list (map inf (map convI tl))) (I n2 n3)
n2,n3 : nat
H5 : eq n1 (maxl (map (rightI Datatypes.O) (map inf (map convI rl))))
n0,n1 : nat
H7 : eq (inf (convI h)) (I ne se)
H6 : le se (length tl)
H2 : le ne (length rl)
H4 : forall (r : BC) (_ : In r tl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n) (and (le s' s) (eq (inf (convI r)) (I n' s')))))
H3 : forall (r : BC) (_ : In r rl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n)\n (and (le s' Datatypes.O) (eq (inf (convI r)) (I n' s')))))
ne,se : nat
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl),\neq (arities e) (ok_arities n Datatypes.O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
eq (rightI Datatypes.O (inf (convI x))) Datatypes.O
+++++
subst.
-----
Lemma convI_inf_correct : forall (e : BC) n s, arities e = ok_arities n s -> exists n', exists s', n' <= n /\\ s' <= s /\\ inf (convI e) = I n' s'.
Proof.
apply BC_ind_inf; simpl; intros.
exists 0; exists 0; auto.
destruct n; simpl.
exists 0; exists (S (i - 0)).
repeat (split; try omega).
case_eq (leb i n); intros; simpl.
apply leb_complete in H0.
exists (S i); exists 0.
repeat (split; try omega).
apply leb_complete_conv in H0.
exists 0; exists (S (i - S n)).
repeat (split; try omega).
exists 0; exists 1; auto.
exists 0; exists 1; auto.
exists 0; exists 4; auto.
destruct H2 as (ne1 & se1 & He1).
destruct H3 as (ne2 & se2 & He2).
destruct H4 as (ne3 & se3 & He3).
decompose [and] He1; decompose [and] He2; decompose [and] He3.
clear He1 He2 He3.
rewrite H5, H8, H11.
eexists; eexists.
split; try split.
3: eauto.
apply maxl_bound; omega.
apply maxl_bound; omega.
destruct H2 as (ne & se & He).
decompose [and] He; clear He.
rewrite H7.
repeat rewrite leb_correct.
simpl.
case_eq ( inf_list (map inf (map convI rl)) ) ; intros.
case_eq ( inf_list (map inf (map convI tl)) ) ; intros.
case_eq (beq_nat n1 0); intros.
eexists; eexists; split; try split.
3: eauto.
apply Nat.max_lub.
apply inf_list_maxl_l in H5.
rewrite H5.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.
destruct H10 as [? [? ?]].
destruct (H3 x H11) as (? & ? & ?).
decompose [and] H12.
subst.
rewrite H16; simpl; trivial.
apply inf_list_maxl_l in H8.
rewrite H8.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.
destruct H10 as [? [? ?]].
destruct (H4 x H11) as (? & ? & ?).
decompose [and] H12.
subst.
rewrite H16; simpl; trivial.
apply inf_list_maxl_r in H8.
rewrite H8.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.
destruct H10 as [? [? ?]].
destruct (H4 x H11) as (? & ? & ?).
decompose [and] H12.
subst.
rewrite H16; simpl; trivial.
apply beq_nat_false in H9.
elim H9.
apply inf_list_maxl_r in H5.
rewrite H5, map_map, map_map.
apply maxl_map_0.
intros.
destruct (H3 x H10) as (? & ? & ?).
decompose [and] H11.
subst.

*****
H15 : eq (inf (convI x)) (I x0 x1)
H14 : le x1 Datatypes.O
H12 : le x0 n
H11 : and (le x0 n) (and (le x1 Datatypes.O) (eq (inf (convI x)) (I x0 x1)))
x0,x1 : nat
H10 : In x rl
x : BC
H9 : not\n (eq (maxl (map (rightI Datatypes.O) (map inf (map convI rl))))\n Datatypes.O)
H8 : eq (inf_list (map inf (map convI tl))) (I n2 n3)
n0,n2,n3 : nat
H7 : eq (inf (convI h)) (I ne se)
H6 : le se (length tl)
H2 : le ne (length rl)
H4 : forall (r : BC) (_ : In r tl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n) (and (le s' s) (eq (inf (convI r)) (I n' s')))))
H3 : forall (r : BC) (_ : In r rl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n)\n (and (le s' Datatypes.O) (eq (inf (convI r)) (I n' s')))))
ne,se : nat
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl),\neq (arities e) (ok_arities n Datatypes.O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
eq (rightI Datatypes.O (inf (convI x))) Datatypes.O
+++++
rewrite H15; simpl; trivial.
-----
Lemma convI_inf_correct : forall (e : BC) n s, arities e = ok_arities n s -> exists n', exists s', n' <= n /\\ s' <= s /\\ inf (convI e) = I n' s'.
Proof.
apply BC_ind_inf; simpl; intros.
exists 0; exists 0; auto.
destruct n; simpl.
exists 0; exists (S (i - 0)).
repeat (split; try omega).
case_eq (leb i n); intros; simpl.
apply leb_complete in H0.
exists (S i); exists 0.
repeat (split; try omega).
apply leb_complete_conv in H0.
exists 0; exists (S (i - S n)).
repeat (split; try omega).
exists 0; exists 1; auto.
exists 0; exists 1; auto.
exists 0; exists 4; auto.
destruct H2 as (ne1 & se1 & He1).
destruct H3 as (ne2 & se2 & He2).
destruct H4 as (ne3 & se3 & He3).
decompose [and] He1; decompose [and] He2; decompose [and] He3.
clear He1 He2 He3.
rewrite H5, H8, H11.
eexists; eexists.
split; try split.
3: eauto.
apply maxl_bound; omega.
apply maxl_bound; omega.
destruct H2 as (ne & se & He).
decompose [and] He; clear He.
rewrite H7.
repeat rewrite leb_correct.
simpl.
case_eq ( inf_list (map inf (map convI rl)) ) ; intros.
case_eq ( inf_list (map inf (map convI tl)) ) ; intros.
case_eq (beq_nat n1 0); intros.
eexists; eexists; split; try split.
3: eauto.
apply Nat.max_lub.
apply inf_list_maxl_l in H5.
rewrite H5.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.
destruct H10 as [? [? ?]].
destruct (H3 x H11) as (? & ? & ?).
decompose [and] H12.
subst.
rewrite H16; simpl; trivial.
apply inf_list_maxl_l in H8.
rewrite H8.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.
destruct H10 as [? [? ?]].
destruct (H4 x H11) as (? & ? & ?).
decompose [and] H12.
subst.
rewrite H16; simpl; trivial.
apply inf_list_maxl_r in H8.
rewrite H8.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.
destruct H10 as [? [? ?]].
destruct (H4 x H11) as (? & ? & ?).
decompose [and] H12.
subst.
rewrite H16; simpl; trivial.
apply beq_nat_false in H9.
elim H9.
apply inf_list_maxl_r in H5.
rewrite H5, map_map, map_map.
apply maxl_map_0.
intros.
destruct (H3 x H10) as (? & ? & ?).
decompose [and] H11.
subst.
rewrite H15; simpl; trivial.

*****
H15 : eq (inf (convI x)) (I x0 x1)
H14 : le x1 Datatypes.O
H12 : le x0 n
H11 : and (le x0 n) (and (le x1 Datatypes.O) (eq (inf (convI x)) (I x0 x1)))
x0,x1 : nat
H10 : In x rl
x : BC
H9 : not\n (eq (maxl (map (rightI Datatypes.O) (map inf (map convI rl))))\n Datatypes.O)
H8 : eq (inf_list (map inf (map convI tl))) (I n2 n3)
n0,n2,n3 : nat
H7 : eq (inf (convI h)) (I ne se)
H6 : le se (length tl)
H2 : le ne (length rl)
H4 : forall (r : BC) (_ : In r tl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n) (and (le s' s) (eq (inf (convI r)) (I n' s')))))
H3 : forall (r : BC) (_ : In r rl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n)\n (and (le s' Datatypes.O) (eq (inf (convI r)) (I n' s')))))
ne,se : nat
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl),\neq (arities e) (ok_arities n Datatypes.O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
eq x1 Datatypes.O
+++++
omega.
-----
Lemma convI_inf_correct : forall (e : BC) n s, arities e = ok_arities n s -> exists n', exists s', n' <= n /\\ s' <= s /\\ inf (convI e) = I n' s'.
Proof.
apply BC_ind_inf; simpl; intros.
exists 0; exists 0; auto.
destruct n; simpl.
exists 0; exists (S (i - 0)).
repeat (split; try omega).
case_eq (leb i n); intros; simpl.
apply leb_complete in H0.
exists (S i); exists 0.
repeat (split; try omega).
apply leb_complete_conv in H0.
exists 0; exists (S (i - S n)).
repeat (split; try omega).
exists 0; exists 1; auto.
exists 0; exists 1; auto.
exists 0; exists 4; auto.
destruct H2 as (ne1 & se1 & He1).
destruct H3 as (ne2 & se2 & He2).
destruct H4 as (ne3 & se3 & He3).
decompose [and] He1; decompose [and] He2; decompose [and] He3.
clear He1 He2 He3.
rewrite H5, H8, H11.
eexists; eexists.
split; try split.
3: eauto.
apply maxl_bound; omega.
apply maxl_bound; omega.
destruct H2 as (ne & se & He).
decompose [and] He; clear He.
rewrite H7.
repeat rewrite leb_correct.
simpl.
case_eq ( inf_list (map inf (map convI rl)) ) ; intros.
case_eq ( inf_list (map inf (map convI tl)) ) ; intros.
case_eq (beq_nat n1 0); intros.
eexists; eexists; split; try split.
3: eauto.
apply Nat.max_lub.
apply inf_list_maxl_l in H5.
rewrite H5.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.
destruct H10 as [? [? ?]].
destruct (H3 x H11) as (? & ? & ?).
decompose [and] H12.
subst.
rewrite H16; simpl; trivial.
apply inf_list_maxl_l in H8.
rewrite H8.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.
destruct H10 as [? [? ?]].
destruct (H4 x H11) as (? & ? & ?).
decompose [and] H12.
subst.
rewrite H16; simpl; trivial.
apply inf_list_maxl_r in H8.
rewrite H8.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.
destruct H10 as [? [? ?]].
destruct (H4 x H11) as (? & ? & ?).
decompose [and] H12.
subst.
rewrite H16; simpl; trivial.
apply beq_nat_false in H9.
elim H9.
apply inf_list_maxl_r in H5.
rewrite H5, map_map, map_map.
apply maxl_map_0.
intros.
destruct (H3 x H10) as (? & ? & ?).
decompose [and] H11.
subst.
rewrite H15; simpl; trivial.
omega.

*****
H8 : eq (inf_list (map inf (map convI tl))) (E e)
e : ErrorI
H5 : eq (inf_list (map inf (map convI rl))) (I n0 n1)
n0,n1 : nat
H7 : eq (inf (convI h)) (I ne se)
H6 : le se (length tl)
H2 : le ne (length rl)
H4 : forall (r : BC) (_ : In r tl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n) (and (le s' s) (eq (inf (convI r)) (I n' s')))))
H3 : forall (r : BC) (_ : In r rl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n)\n (and (le s' Datatypes.O) (eq (inf (convI r)) (I n' s')))))
ne,se : nat
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl),\neq (arities e) (ok_arities n Datatypes.O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
ex (fun n' : nat => ex (fun s' : nat => and (le n' n) (and (le s' s) (eq (E (Enat (S (S (S (S (S Datatypes.O))))))) (I n' s')))))
+++++
elimtype False.
-----
Lemma convI_inf_correct : forall (e : BC) n s, arities e = ok_arities n s -> exists n', exists s', n' <= n /\\ s' <= s /\\ inf (convI e) = I n' s'.
Proof.
apply BC_ind_inf; simpl; intros.
exists 0; exists 0; auto.
destruct n; simpl.
exists 0; exists (S (i - 0)).
repeat (split; try omega).
case_eq (leb i n); intros; simpl.
apply leb_complete in H0.
exists (S i); exists 0.
repeat (split; try omega).
apply leb_complete_conv in H0.
exists 0; exists (S (i - S n)).
repeat (split; try omega).
exists 0; exists 1; auto.
exists 0; exists 1; auto.
exists 0; exists 4; auto.
destruct H2 as (ne1 & se1 & He1).
destruct H3 as (ne2 & se2 & He2).
destruct H4 as (ne3 & se3 & He3).
decompose [and] He1; decompose [and] He2; decompose [and] He3.
clear He1 He2 He3.
rewrite H5, H8, H11.
eexists; eexists.
split; try split.
3: eauto.
apply maxl_bound; omega.
apply maxl_bound; omega.
destruct H2 as (ne & se & He).
decompose [and] He; clear He.
rewrite H7.
repeat rewrite leb_correct.
simpl.
case_eq ( inf_list (map inf (map convI rl)) ) ; intros.
case_eq ( inf_list (map inf (map convI tl)) ) ; intros.
case_eq (beq_nat n1 0); intros.
eexists; eexists; split; try split.
3: eauto.
apply Nat.max_lub.
apply inf_list_maxl_l in H5.
rewrite H5.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.
destruct H10 as [? [? ?]].
destruct (H3 x H11) as (? & ? & ?).
decompose [and] H12.
subst.
rewrite H16; simpl; trivial.
apply inf_list_maxl_l in H8.
rewrite H8.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.
destruct H10 as [? [? ?]].
destruct (H4 x H11) as (? & ? & ?).
decompose [and] H12.
subst.
rewrite H16; simpl; trivial.
apply inf_list_maxl_r in H8.
rewrite H8.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.
destruct H10 as [? [? ?]].
destruct (H4 x H11) as (? & ? & ?).
decompose [and] H12.
subst.
rewrite H16; simpl; trivial.
apply beq_nat_false in H9.
elim H9.
apply inf_list_maxl_r in H5.
rewrite H5, map_map, map_map.
apply maxl_map_0.
intros.
destruct (H3 x H10) as (? & ? & ?).
decompose [and] H11.
subst.
rewrite H15; simpl; trivial.
omega.
elimtype False.

*****
H8 : eq (inf_list (map inf (map convI tl))) (E e)
e : ErrorI
H5 : eq (inf_list (map inf (map convI rl))) (I n0 n1)
n0,n1 : nat
H7 : eq (inf (convI h)) (I ne se)
H6 : le se (length tl)
H2 : le ne (length rl)
H4 : forall (r : BC) (_ : In r tl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n) (and (le s' s) (eq (inf (convI r)) (I n' s')))))
H3 : forall (r : BC) (_ : In r rl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n)\n (and (le s' Datatypes.O) (eq (inf (convI r)) (I n' s')))))
ne,se : nat
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl),\neq (arities e) (ok_arities n Datatypes.O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
False
+++++
apply in_inf_list_err_conv in H8.
-----
Lemma convI_inf_correct : forall (e : BC) n s, arities e = ok_arities n s -> exists n', exists s', n' <= n /\\ s' <= s /\\ inf (convI e) = I n' s'.
Proof.
apply BC_ind_inf; simpl; intros.
exists 0; exists 0; auto.
destruct n; simpl.
exists 0; exists (S (i - 0)).
repeat (split; try omega).
case_eq (leb i n); intros; simpl.
apply leb_complete in H0.
exists (S i); exists 0.
repeat (split; try omega).
apply leb_complete_conv in H0.
exists 0; exists (S (i - S n)).
repeat (split; try omega).
exists 0; exists 1; auto.
exists 0; exists 1; auto.
exists 0; exists 4; auto.
destruct H2 as (ne1 & se1 & He1).
destruct H3 as (ne2 & se2 & He2).
destruct H4 as (ne3 & se3 & He3).
decompose [and] He1; decompose [and] He2; decompose [and] He3.
clear He1 He2 He3.
rewrite H5, H8, H11.
eexists; eexists.
split; try split.
3: eauto.
apply maxl_bound; omega.
apply maxl_bound; omega.
destruct H2 as (ne & se & He).
decompose [and] He; clear He.
rewrite H7.
repeat rewrite leb_correct.
simpl.
case_eq ( inf_list (map inf (map convI rl)) ) ; intros.
case_eq ( inf_list (map inf (map convI tl)) ) ; intros.
case_eq (beq_nat n1 0); intros.
eexists; eexists; split; try split.
3: eauto.
apply Nat.max_lub.
apply inf_list_maxl_l in H5.
rewrite H5.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.
destruct H10 as [? [? ?]].
destruct (H3 x H11) as (? & ? & ?).
decompose [and] H12.
subst.
rewrite H16; simpl; trivial.
apply inf_list_maxl_l in H8.
rewrite H8.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.
destruct H10 as [? [? ?]].
destruct (H4 x H11) as (? & ? & ?).
decompose [and] H12.
subst.
rewrite H16; simpl; trivial.
apply inf_list_maxl_r in H8.
rewrite H8.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.
destruct H10 as [? [? ?]].
destruct (H4 x H11) as (? & ? & ?).
decompose [and] H12.
subst.
rewrite H16; simpl; trivial.
apply beq_nat_false in H9.
elim H9.
apply inf_list_maxl_r in H5.
rewrite H5, map_map, map_map.
apply maxl_map_0.
intros.
destruct (H3 x H10) as (? & ? & ?).
decompose [and] H11.
subst.
rewrite H15; simpl; trivial.
omega.
elimtype False.
apply in_inf_list_err_conv in H8.

*****
H8 : ex (fun err' : ErrorI => In (E err') (map inf (map convI tl)))
e : ErrorI
H5 : eq (inf_list (map inf (map convI rl))) (I n0 n1)
n0,n1 : nat
H7 : eq (inf (convI h)) (I ne se)
H6 : le se (length tl)
H2 : le ne (length rl)
H4 : forall (r : BC) (_ : In r tl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n) (and (le s' s) (eq (inf (convI r)) (I n' s')))))
H3 : forall (r : BC) (_ : In r rl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n)\n (and (le s' Datatypes.O) (eq (inf (convI r)) (I n' s')))))
ne,se : nat
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl),\neq (arities e) (ok_arities n Datatypes.O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
False
+++++
destruct H8.
-----
Lemma convI_inf_correct : forall (e : BC) n s, arities e = ok_arities n s -> exists n', exists s', n' <= n /\\ s' <= s /\\ inf (convI e) = I n' s'.
Proof.
apply BC_ind_inf; simpl; intros.
exists 0; exists 0; auto.
destruct n; simpl.
exists 0; exists (S (i - 0)).
repeat (split; try omega).
case_eq (leb i n); intros; simpl.
apply leb_complete in H0.
exists (S i); exists 0.
repeat (split; try omega).
apply leb_complete_conv in H0.
exists 0; exists (S (i - S n)).
repeat (split; try omega).
exists 0; exists 1; auto.
exists 0; exists 1; auto.
exists 0; exists 4; auto.
destruct H2 as (ne1 & se1 & He1).
destruct H3 as (ne2 & se2 & He2).
destruct H4 as (ne3 & se3 & He3).
decompose [and] He1; decompose [and] He2; decompose [and] He3.
clear He1 He2 He3.
rewrite H5, H8, H11.
eexists; eexists.
split; try split.
3: eauto.
apply maxl_bound; omega.
apply maxl_bound; omega.
destruct H2 as (ne & se & He).
decompose [and] He; clear He.
rewrite H7.
repeat rewrite leb_correct.
simpl.
case_eq ( inf_list (map inf (map convI rl)) ) ; intros.
case_eq ( inf_list (map inf (map convI tl)) ) ; intros.
case_eq (beq_nat n1 0); intros.
eexists; eexists; split; try split.
3: eauto.
apply Nat.max_lub.
apply inf_list_maxl_l in H5.
rewrite H5.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.
destruct H10 as [? [? ?]].
destruct (H3 x H11) as (? & ? & ?).
decompose [and] H12.
subst.
rewrite H16; simpl; trivial.
apply inf_list_maxl_l in H8.
rewrite H8.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.
destruct H10 as [? [? ?]].
destruct (H4 x H11) as (? & ? & ?).
decompose [and] H12.
subst.
rewrite H16; simpl; trivial.
apply inf_list_maxl_r in H8.
rewrite H8.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.
destruct H10 as [? [? ?]].
destruct (H4 x H11) as (? & ? & ?).
decompose [and] H12.
subst.
rewrite H16; simpl; trivial.
apply beq_nat_false in H9.
elim H9.
apply inf_list_maxl_r in H5.
rewrite H5, map_map, map_map.
apply maxl_map_0.
intros.
destruct (H3 x H10) as (? & ? & ?).
decompose [and] H11.
subst.
rewrite H15; simpl; trivial.
omega.
elimtype False.
apply in_inf_list_err_conv in H8.
destruct H8.

*****
H8 : In (E x) (map inf (map convI tl))
e,x : ErrorI
H5 : eq (inf_list (map inf (map convI rl))) (I n0 n1)
n0,n1 : nat
H7 : eq (inf (convI h)) (I ne se)
H6 : le se (length tl)
H2 : le ne (length rl)
H4 : forall (r : BC) (_ : In r tl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n) (and (le s' s) (eq (inf (convI r)) (I n' s')))))
H3 : forall (r : BC) (_ : In r rl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n)\n (and (le s' Datatypes.O) (eq (inf (convI r)) (I n' s')))))
ne,se : nat
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl),\neq (arities e) (ok_arities n Datatypes.O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
False
+++++
rewrite map_map in H8.
-----
Lemma convI_inf_correct : forall (e : BC) n s, arities e = ok_arities n s -> exists n', exists s', n' <= n /\\ s' <= s /\\ inf (convI e) = I n' s'.
Proof.
apply BC_ind_inf; simpl; intros.
exists 0; exists 0; auto.
destruct n; simpl.
exists 0; exists (S (i - 0)).
repeat (split; try omega).
case_eq (leb i n); intros; simpl.
apply leb_complete in H0.
exists (S i); exists 0.
repeat (split; try omega).
apply leb_complete_conv in H0.
exists 0; exists (S (i - S n)).
repeat (split; try omega).
exists 0; exists 1; auto.
exists 0; exists 1; auto.
exists 0; exists 4; auto.
destruct H2 as (ne1 & se1 & He1).
destruct H3 as (ne2 & se2 & He2).
destruct H4 as (ne3 & se3 & He3).
decompose [and] He1; decompose [and] He2; decompose [and] He3.
clear He1 He2 He3.
rewrite H5, H8, H11.
eexists; eexists.
split; try split.
3: eauto.
apply maxl_bound; omega.
apply maxl_bound; omega.
destruct H2 as (ne & se & He).
decompose [and] He; clear He.
rewrite H7.
repeat rewrite leb_correct.
simpl.
case_eq ( inf_list (map inf (map convI rl)) ) ; intros.
case_eq ( inf_list (map inf (map convI tl)) ) ; intros.
case_eq (beq_nat n1 0); intros.
eexists; eexists; split; try split.
3: eauto.
apply Nat.max_lub.
apply inf_list_maxl_l in H5.
rewrite H5.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.
destruct H10 as [? [? ?]].
destruct (H3 x H11) as (? & ? & ?).
decompose [and] H12.
subst.
rewrite H16; simpl; trivial.
apply inf_list_maxl_l in H8.
rewrite H8.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.
destruct H10 as [? [? ?]].
destruct (H4 x H11) as (? & ? & ?).
decompose [and] H12.
subst.
rewrite H16; simpl; trivial.
apply inf_list_maxl_r in H8.
rewrite H8.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.
destruct H10 as [? [? ?]].
destruct (H4 x H11) as (? & ? & ?).
decompose [and] H12.
subst.
rewrite H16; simpl; trivial.
apply beq_nat_false in H9.
elim H9.
apply inf_list_maxl_r in H5.
rewrite H5, map_map, map_map.
apply maxl_map_0.
intros.
destruct (H3 x H10) as (? & ? & ?).
decompose [and] H11.
subst.
rewrite H15; simpl; trivial.
omega.
elimtype False.
apply in_inf_list_err_conv in H8.
destruct H8.
rewrite map_map in H8.

*****
H8 : In (E x) (map (fun x : BC => inf (convI x)) tl)
e,x : ErrorI
H5 : eq (inf_list (map inf (map convI rl))) (I n0 n1)
n0,n1 : nat
H7 : eq (inf (convI h)) (I ne se)
H6 : le se (length tl)
H2 : le ne (length rl)
H4 : forall (r : BC) (_ : In r tl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n) (and (le s' s) (eq (inf (convI r)) (I n' s')))))
H3 : forall (r : BC) (_ : In r rl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n)\n (and (le s' Datatypes.O) (eq (inf (convI r)) (I n' s')))))
ne,se : nat
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl),\neq (arities e) (ok_arities n Datatypes.O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
False
+++++
apply in_map_iff in H8.
-----
Lemma convI_inf_correct : forall (e : BC) n s, arities e = ok_arities n s -> exists n', exists s', n' <= n /\\ s' <= s /\\ inf (convI e) = I n' s'.
Proof.
apply BC_ind_inf; simpl; intros.
exists 0; exists 0; auto.
destruct n; simpl.
exists 0; exists (S (i - 0)).
repeat (split; try omega).
case_eq (leb i n); intros; simpl.
apply leb_complete in H0.
exists (S i); exists 0.
repeat (split; try omega).
apply leb_complete_conv in H0.
exists 0; exists (S (i - S n)).
repeat (split; try omega).
exists 0; exists 1; auto.
exists 0; exists 1; auto.
exists 0; exists 4; auto.
destruct H2 as (ne1 & se1 & He1).
destruct H3 as (ne2 & se2 & He2).
destruct H4 as (ne3 & se3 & He3).
decompose [and] He1; decompose [and] He2; decompose [and] He3.
clear He1 He2 He3.
rewrite H5, H8, H11.
eexists; eexists.
split; try split.
3: eauto.
apply maxl_bound; omega.
apply maxl_bound; omega.
destruct H2 as (ne & se & He).
decompose [and] He; clear He.
rewrite H7.
repeat rewrite leb_correct.
simpl.
case_eq ( inf_list (map inf (map convI rl)) ) ; intros.
case_eq ( inf_list (map inf (map convI tl)) ) ; intros.
case_eq (beq_nat n1 0); intros.
eexists; eexists; split; try split.
3: eauto.
apply Nat.max_lub.
apply inf_list_maxl_l in H5.
rewrite H5.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.
destruct H10 as [? [? ?]].
destruct (H3 x H11) as (? & ? & ?).
decompose [and] H12.
subst.
rewrite H16; simpl; trivial.
apply inf_list_maxl_l in H8.
rewrite H8.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.
destruct H10 as [? [? ?]].
destruct (H4 x H11) as (? & ? & ?).
decompose [and] H12.
subst.
rewrite H16; simpl; trivial.
apply inf_list_maxl_r in H8.
rewrite H8.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.
destruct H10 as [? [? ?]].
destruct (H4 x H11) as (? & ? & ?).
decompose [and] H12.
subst.
rewrite H16; simpl; trivial.
apply beq_nat_false in H9.
elim H9.
apply inf_list_maxl_r in H5.
rewrite H5, map_map, map_map.
apply maxl_map_0.
intros.
destruct (H3 x H10) as (? & ? & ?).
decompose [and] H11.
subst.
rewrite H15; simpl; trivial.
omega.
elimtype False.
apply in_inf_list_err_conv in H8.
destruct H8.
rewrite map_map in H8.
apply in_map_iff in H8.

*****
H8 : ex (fun x0 : BC => and (eq (inf (convI x0)) (E x)) (In x0 tl))
e,x : ErrorI
H5 : eq (inf_list (map inf (map convI rl))) (I n0 n1)
n0,n1 : nat
H7 : eq (inf (convI h)) (I ne se)
H6 : le se (length tl)
H2 : le ne (length rl)
H4 : forall (r : BC) (_ : In r tl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n) (and (le s' s) (eq (inf (convI r)) (I n' s')))))
H3 : forall (r : BC) (_ : In r rl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n)\n (and (le s' Datatypes.O) (eq (inf (convI r)) (I n' s')))))
ne,se : nat
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl),\neq (arities e) (ok_arities n Datatypes.O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
False
+++++
destruct H8 as [? [? ?]].
-----
Lemma convI_inf_correct : forall (e : BC) n s, arities e = ok_arities n s -> exists n', exists s', n' <= n /\\ s' <= s /\\ inf (convI e) = I n' s'.
Proof.
apply BC_ind_inf; simpl; intros.
exists 0; exists 0; auto.
destruct n; simpl.
exists 0; exists (S (i - 0)).
repeat (split; try omega).
case_eq (leb i n); intros; simpl.
apply leb_complete in H0.
exists (S i); exists 0.
repeat (split; try omega).
apply leb_complete_conv in H0.
exists 0; exists (S (i - S n)).
repeat (split; try omega).
exists 0; exists 1; auto.
exists 0; exists 1; auto.
exists 0; exists 4; auto.
destruct H2 as (ne1 & se1 & He1).
destruct H3 as (ne2 & se2 & He2).
destruct H4 as (ne3 & se3 & He3).
decompose [and] He1; decompose [and] He2; decompose [and] He3.
clear He1 He2 He3.
rewrite H5, H8, H11.
eexists; eexists.
split; try split.
3: eauto.
apply maxl_bound; omega.
apply maxl_bound; omega.
destruct H2 as (ne & se & He).
decompose [and] He; clear He.
rewrite H7.
repeat rewrite leb_correct.
simpl.
case_eq ( inf_list (map inf (map convI rl)) ) ; intros.
case_eq ( inf_list (map inf (map convI tl)) ) ; intros.
case_eq (beq_nat n1 0); intros.
eexists; eexists; split; try split.
3: eauto.
apply Nat.max_lub.
apply inf_list_maxl_l in H5.
rewrite H5.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.
destruct H10 as [? [? ?]].
destruct (H3 x H11) as (? & ? & ?).
decompose [and] H12.
subst.
rewrite H16; simpl; trivial.
apply inf_list_maxl_l in H8.
rewrite H8.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.
destruct H10 as [? [? ?]].
destruct (H4 x H11) as (? & ? & ?).
decompose [and] H12.
subst.
rewrite H16; simpl; trivial.
apply inf_list_maxl_r in H8.
rewrite H8.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.
destruct H10 as [? [? ?]].
destruct (H4 x H11) as (? & ? & ?).
decompose [and] H12.
subst.
rewrite H16; simpl; trivial.
apply beq_nat_false in H9.
elim H9.
apply inf_list_maxl_r in H5.
rewrite H5, map_map, map_map.
apply maxl_map_0.
intros.
destruct (H3 x H10) as (? & ? & ?).
decompose [and] H11.
subst.
rewrite H15; simpl; trivial.
omega.
elimtype False.
apply in_inf_list_err_conv in H8.
destruct H8.
rewrite map_map in H8.
apply in_map_iff in H8.
destruct H8 as [? [? ?]].

*****
H9 : In x0 tl
H8 : eq (inf (convI x0)) (E x)
x0 : BC
e,x : ErrorI
H5 : eq (inf_list (map inf (map convI rl))) (I n0 n1)
n0,n1 : nat
H7 : eq (inf (convI h)) (I ne se)
H6 : le se (length tl)
H2 : le ne (length rl)
H4 : forall (r : BC) (_ : In r tl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n) (and (le s' s) (eq (inf (convI r)) (I n' s')))))
H3 : forall (r : BC) (_ : In r rl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n)\n (and (le s' Datatypes.O) (eq (inf (convI r)) (I n' s')))))
ne,se : nat
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl),\neq (arities e) (ok_arities n Datatypes.O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
False
+++++
destruct (H4 x0 H9) as (? & ? & ?).
-----
Lemma convI_inf_correct : forall (e : BC) n s, arities e = ok_arities n s -> exists n', exists s', n' <= n /\\ s' <= s /\\ inf (convI e) = I n' s'.
Proof.
apply BC_ind_inf; simpl; intros.
exists 0; exists 0; auto.
destruct n; simpl.
exists 0; exists (S (i - 0)).
repeat (split; try omega).
case_eq (leb i n); intros; simpl.
apply leb_complete in H0.
exists (S i); exists 0.
repeat (split; try omega).
apply leb_complete_conv in H0.
exists 0; exists (S (i - S n)).
repeat (split; try omega).
exists 0; exists 1; auto.
exists 0; exists 1; auto.
exists 0; exists 4; auto.
destruct H2 as (ne1 & se1 & He1).
destruct H3 as (ne2 & se2 & He2).
destruct H4 as (ne3 & se3 & He3).
decompose [and] He1; decompose [and] He2; decompose [and] He3.
clear He1 He2 He3.
rewrite H5, H8, H11.
eexists; eexists.
split; try split.
3: eauto.
apply maxl_bound; omega.
apply maxl_bound; omega.
destruct H2 as (ne & se & He).
decompose [and] He; clear He.
rewrite H7.
repeat rewrite leb_correct.
simpl.
case_eq ( inf_list (map inf (map convI rl)) ) ; intros.
case_eq ( inf_list (map inf (map convI tl)) ) ; intros.
case_eq (beq_nat n1 0); intros.
eexists; eexists; split; try split.
3: eauto.
apply Nat.max_lub.
apply inf_list_maxl_l in H5.
rewrite H5.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.
destruct H10 as [? [? ?]].
destruct (H3 x H11) as (? & ? & ?).
decompose [and] H12.
subst.
rewrite H16; simpl; trivial.
apply inf_list_maxl_l in H8.
rewrite H8.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.
destruct H10 as [? [? ?]].
destruct (H4 x H11) as (? & ? & ?).
decompose [and] H12.
subst.
rewrite H16; simpl; trivial.
apply inf_list_maxl_r in H8.
rewrite H8.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.
destruct H10 as [? [? ?]].
destruct (H4 x H11) as (? & ? & ?).
decompose [and] H12.
subst.
rewrite H16; simpl; trivial.
apply beq_nat_false in H9.
elim H9.
apply inf_list_maxl_r in H5.
rewrite H5, map_map, map_map.
apply maxl_map_0.
intros.
destruct (H3 x H10) as (? & ? & ?).
decompose [and] H11.
subst.
rewrite H15; simpl; trivial.
omega.
elimtype False.
apply in_inf_list_err_conv in H8.
destruct H8.
rewrite map_map in H8.
apply in_map_iff in H8.
destruct H8 as [? [? ?]].
destruct (H4 x0 H9) as (? & ? & ?).

*****
H10 : and (le x1 n) (and (le x2 s) (eq (inf (convI x0)) (I x1 x2)))
x1,x2 : nat
H9 : In x0 tl
H8 : eq (inf (convI x0)) (E x)
x0 : BC
e,x : ErrorI
H5 : eq (inf_list (map inf (map convI rl))) (I n0 n1)
n0,n1 : nat
H7 : eq (inf (convI h)) (I ne se)
H6 : le se (length tl)
H2 : le ne (length rl)
H4 : forall (r : BC) (_ : In r tl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n) (and (le s' s) (eq (inf (convI r)) (I n' s')))))
H3 : forall (r : BC) (_ : In r rl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n)\n (and (le s' Datatypes.O) (eq (inf (convI r)) (I n' s')))))
ne,se : nat
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl),\neq (arities e) (ok_arities n Datatypes.O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
False
+++++
decompose [and] H10.
-----
Lemma convI_inf_correct : forall (e : BC) n s, arities e = ok_arities n s -> exists n', exists s', n' <= n /\\ s' <= s /\\ inf (convI e) = I n' s'.
Proof.
apply BC_ind_inf; simpl; intros.
exists 0; exists 0; auto.
destruct n; simpl.
exists 0; exists (S (i - 0)).
repeat (split; try omega).
case_eq (leb i n); intros; simpl.
apply leb_complete in H0.
exists (S i); exists 0.
repeat (split; try omega).
apply leb_complete_conv in H0.
exists 0; exists (S (i - S n)).
repeat (split; try omega).
exists 0; exists 1; auto.
exists 0; exists 1; auto.
exists 0; exists 4; auto.
destruct H2 as (ne1 & se1 & He1).
destruct H3 as (ne2 & se2 & He2).
destruct H4 as (ne3 & se3 & He3).
decompose [and] He1; decompose [and] He2; decompose [and] He3.
clear He1 He2 He3.
rewrite H5, H8, H11.
eexists; eexists.
split; try split.
3: eauto.
apply maxl_bound; omega.
apply maxl_bound; omega.
destruct H2 as (ne & se & He).
decompose [and] He; clear He.
rewrite H7.
repeat rewrite leb_correct.
simpl.
case_eq ( inf_list (map inf (map convI rl)) ) ; intros.
case_eq ( inf_list (map inf (map convI tl)) ) ; intros.
case_eq (beq_nat n1 0); intros.
eexists; eexists; split; try split.
3: eauto.
apply Nat.max_lub.
apply inf_list_maxl_l in H5.
rewrite H5.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.
destruct H10 as [? [? ?]].
destruct (H3 x H11) as (? & ? & ?).
decompose [and] H12.
subst.
rewrite H16; simpl; trivial.
apply inf_list_maxl_l in H8.
rewrite H8.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.
destruct H10 as [? [? ?]].
destruct (H4 x H11) as (? & ? & ?).
decompose [and] H12.
subst.
rewrite H16; simpl; trivial.
apply inf_list_maxl_r in H8.
rewrite H8.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.
destruct H10 as [? [? ?]].
destruct (H4 x H11) as (? & ? & ?).
decompose [and] H12.
subst.
rewrite H16; simpl; trivial.
apply beq_nat_false in H9.
elim H9.
apply inf_list_maxl_r in H5.
rewrite H5, map_map, map_map.
apply maxl_map_0.
intros.
destruct (H3 x H10) as (? & ? & ?).
decompose [and] H11.
subst.
rewrite H15; simpl; trivial.
omega.
elimtype False.
apply in_inf_list_err_conv in H8.
destruct H8.
rewrite map_map in H8.
apply in_map_iff in H8.
destruct H8 as [? [? ?]].
destruct (H4 x0 H9) as (? & ? & ?).
decompose [and] H10.

*****
H14 : eq (inf (convI x0)) (I x1 x2)
H13 : le x2 s
H11 : le x1 n
H10 : and (le x1 n) (and (le x2 s) (eq (inf (convI x0)) (I x1 x2)))
x1,x2 : nat
H9 : In x0 tl
H8 : eq (inf (convI x0)) (E x)
x0 : BC
e,x : ErrorI
H5 : eq (inf_list (map inf (map convI rl))) (I n0 n1)
n0,n1 : nat
H7 : eq (inf (convI h)) (I ne se)
H6 : le se (length tl)
H2 : le ne (length rl)
H4 : forall (r : BC) (_ : In r tl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n) (and (le s' s) (eq (inf (convI r)) (I n' s')))))
H3 : forall (r : BC) (_ : In r rl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n)\n (and (le s' Datatypes.O) (eq (inf (convI r)) (I n' s')))))
ne,se : nat
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl),\neq (arities e) (ok_arities n Datatypes.O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
False
+++++
rewrite H8 in H14; discriminate.
-----
Lemma convI_inf_correct : forall (e : BC) n s, arities e = ok_arities n s -> exists n', exists s', n' <= n /\\ s' <= s /\\ inf (convI e) = I n' s'.
Proof.
apply BC_ind_inf; simpl; intros.
exists 0; exists 0; auto.
destruct n; simpl.
exists 0; exists (S (i - 0)).
repeat (split; try omega).
case_eq (leb i n); intros; simpl.
apply leb_complete in H0.
exists (S i); exists 0.
repeat (split; try omega).
apply leb_complete_conv in H0.
exists 0; exists (S (i - S n)).
repeat (split; try omega).
exists 0; exists 1; auto.
exists 0; exists 1; auto.
exists 0; exists 4; auto.
destruct H2 as (ne1 & se1 & He1).
destruct H3 as (ne2 & se2 & He2).
destruct H4 as (ne3 & se3 & He3).
decompose [and] He1; decompose [and] He2; decompose [and] He3.
clear He1 He2 He3.
rewrite H5, H8, H11.
eexists; eexists.
split; try split.
3: eauto.
apply maxl_bound; omega.
apply maxl_bound; omega.
destruct H2 as (ne & se & He).
decompose [and] He; clear He.
rewrite H7.
repeat rewrite leb_correct.
simpl.
case_eq ( inf_list (map inf (map convI rl)) ) ; intros.
case_eq ( inf_list (map inf (map convI tl)) ) ; intros.
case_eq (beq_nat n1 0); intros.
eexists; eexists; split; try split.
3: eauto.
apply Nat.max_lub.
apply inf_list_maxl_l in H5.
rewrite H5.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.
destruct H10 as [? [? ?]].
destruct (H3 x H11) as (? & ? & ?).
decompose [and] H12.
subst.
rewrite H16; simpl; trivial.
apply inf_list_maxl_l in H8.
rewrite H8.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.
destruct H10 as [? [? ?]].
destruct (H4 x H11) as (? & ? & ?).
decompose [and] H12.
subst.
rewrite H16; simpl; trivial.
apply inf_list_maxl_r in H8.
rewrite H8.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.
destruct H10 as [? [? ?]].
destruct (H4 x H11) as (? & ? & ?).
decompose [and] H12.
subst.
rewrite H16; simpl; trivial.
apply beq_nat_false in H9.
elim H9.
apply inf_list_maxl_r in H5.
rewrite H5, map_map, map_map.
apply maxl_map_0.
intros.
destruct (H3 x H10) as (? & ? & ?).
decompose [and] H11.
subst.
rewrite H15; simpl; trivial.
omega.
elimtype False.
apply in_inf_list_err_conv in H8.
destruct H8.
rewrite map_map in H8.
apply in_map_iff in H8.
destruct H8 as [? [? ?]].
destruct (H4 x0 H9) as (? & ? & ?).
decompose [and] H10.
rewrite H8 in H14; discriminate.

*****
H5 : eq (inf_list (map inf (map convI rl))) (E e)
e : ErrorI
H7 : eq (inf (convI h)) (I ne se)
H6 : le se (length tl)
H2 : le ne (length rl)
H4 : forall (r : BC) (_ : In r tl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n) (and (le s' s) (eq (inf (convI r)) (I n' s')))))
H3 : forall (r : BC) (_ : In r rl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n)\n (and (le s' Datatypes.O) (eq (inf (convI r)) (I n' s')))))
ne,se : nat
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl),\neq (arities e) (ok_arities n Datatypes.O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
ex (fun n' : nat => ex (fun s' : nat => and (le n' n) (and (le s' s) (eq (E (Enat (S (S (S (S (S Datatypes.O))))))) (I n' s')))))
+++++
elimtype False.
-----
Lemma convI_inf_correct : forall (e : BC) n s, arities e = ok_arities n s -> exists n', exists s', n' <= n /\\ s' <= s /\\ inf (convI e) = I n' s'.
Proof.
apply BC_ind_inf; simpl; intros.
exists 0; exists 0; auto.
destruct n; simpl.
exists 0; exists (S (i - 0)).
repeat (split; try omega).
case_eq (leb i n); intros; simpl.
apply leb_complete in H0.
exists (S i); exists 0.
repeat (split; try omega).
apply leb_complete_conv in H0.
exists 0; exists (S (i - S n)).
repeat (split; try omega).
exists 0; exists 1; auto.
exists 0; exists 1; auto.
exists 0; exists 4; auto.
destruct H2 as (ne1 & se1 & He1).
destruct H3 as (ne2 & se2 & He2).
destruct H4 as (ne3 & se3 & He3).
decompose [and] He1; decompose [and] He2; decompose [and] He3.
clear He1 He2 He3.
rewrite H5, H8, H11.
eexists; eexists.
split; try split.
3: eauto.
apply maxl_bound; omega.
apply maxl_bound; omega.
destruct H2 as (ne & se & He).
decompose [and] He; clear He.
rewrite H7.
repeat rewrite leb_correct.
simpl.
case_eq ( inf_list (map inf (map convI rl)) ) ; intros.
case_eq ( inf_list (map inf (map convI tl)) ) ; intros.
case_eq (beq_nat n1 0); intros.
eexists; eexists; split; try split.
3: eauto.
apply Nat.max_lub.
apply inf_list_maxl_l in H5.
rewrite H5.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.
destruct H10 as [? [? ?]].
destruct (H3 x H11) as (? & ? & ?).
decompose [and] H12.
subst.
rewrite H16; simpl; trivial.
apply inf_list_maxl_l in H8.
rewrite H8.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.
destruct H10 as [? [? ?]].
destruct (H4 x H11) as (? & ? & ?).
decompose [and] H12.
subst.
rewrite H16; simpl; trivial.
apply inf_list_maxl_r in H8.
rewrite H8.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.
destruct H10 as [? [? ?]].
destruct (H4 x H11) as (? & ? & ?).
decompose [and] H12.
subst.
rewrite H16; simpl; trivial.
apply beq_nat_false in H9.
elim H9.
apply inf_list_maxl_r in H5.
rewrite H5, map_map, map_map.
apply maxl_map_0.
intros.
destruct (H3 x H10) as (? & ? & ?).
decompose [and] H11.
subst.
rewrite H15; simpl; trivial.
omega.
elimtype False.
apply in_inf_list_err_conv in H8.
destruct H8.
rewrite map_map in H8.
apply in_map_iff in H8.
destruct H8 as [? [? ?]].
destruct (H4 x0 H9) as (? & ? & ?).
decompose [and] H10.
rewrite H8 in H14; discriminate.
elimtype False.

*****
H5 : eq (inf_list (map inf (map convI rl))) (E e)
e : ErrorI
H7 : eq (inf (convI h)) (I ne se)
H6 : le se (length tl)
H2 : le ne (length rl)
H4 : forall (r : BC) (_ : In r tl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n) (and (le s' s) (eq (inf (convI r)) (I n' s')))))
H3 : forall (r : BC) (_ : In r rl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n)\n (and (le s' Datatypes.O) (eq (inf (convI r)) (I n' s')))))
ne,se : nat
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl),\neq (arities e) (ok_arities n Datatypes.O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
False
+++++
apply in_inf_list_err_conv in H5.
-----
Lemma convI_inf_correct : forall (e : BC) n s, arities e = ok_arities n s -> exists n', exists s', n' <= n /\\ s' <= s /\\ inf (convI e) = I n' s'.
Proof.
apply BC_ind_inf; simpl; intros.
exists 0; exists 0; auto.
destruct n; simpl.
exists 0; exists (S (i - 0)).
repeat (split; try omega).
case_eq (leb i n); intros; simpl.
apply leb_complete in H0.
exists (S i); exists 0.
repeat (split; try omega).
apply leb_complete_conv in H0.
exists 0; exists (S (i - S n)).
repeat (split; try omega).
exists 0; exists 1; auto.
exists 0; exists 1; auto.
exists 0; exists 4; auto.
destruct H2 as (ne1 & se1 & He1).
destruct H3 as (ne2 & se2 & He2).
destruct H4 as (ne3 & se3 & He3).
decompose [and] He1; decompose [and] He2; decompose [and] He3.
clear He1 He2 He3.
rewrite H5, H8, H11.
eexists; eexists.
split; try split.
3: eauto.
apply maxl_bound; omega.
apply maxl_bound; omega.
destruct H2 as (ne & se & He).
decompose [and] He; clear He.
rewrite H7.
repeat rewrite leb_correct.
simpl.
case_eq ( inf_list (map inf (map convI rl)) ) ; intros.
case_eq ( inf_list (map inf (map convI tl)) ) ; intros.
case_eq (beq_nat n1 0); intros.
eexists; eexists; split; try split.
3: eauto.
apply Nat.max_lub.
apply inf_list_maxl_l in H5.
rewrite H5.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.
destruct H10 as [? [? ?]].
destruct (H3 x H11) as (? & ? & ?).
decompose [and] H12.
subst.
rewrite H16; simpl; trivial.
apply inf_list_maxl_l in H8.
rewrite H8.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.
destruct H10 as [? [? ?]].
destruct (H4 x H11) as (? & ? & ?).
decompose [and] H12.
subst.
rewrite H16; simpl; trivial.
apply inf_list_maxl_r in H8.
rewrite H8.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.
destruct H10 as [? [? ?]].
destruct (H4 x H11) as (? & ? & ?).
decompose [and] H12.
subst.
rewrite H16; simpl; trivial.
apply beq_nat_false in H9.
elim H9.
apply inf_list_maxl_r in H5.
rewrite H5, map_map, map_map.
apply maxl_map_0.
intros.
destruct (H3 x H10) as (? & ? & ?).
decompose [and] H11.
subst.
rewrite H15; simpl; trivial.
omega.
elimtype False.
apply in_inf_list_err_conv in H8.
destruct H8.
rewrite map_map in H8.
apply in_map_iff in H8.
destruct H8 as [? [? ?]].
destruct (H4 x0 H9) as (? & ? & ?).
decompose [and] H10.
rewrite H8 in H14; discriminate.
elimtype False.
apply in_inf_list_err_conv in H5.

*****
H5 : ex (fun err' : ErrorI => In (E err') (map inf (map convI rl)))
e : ErrorI
H7 : eq (inf (convI h)) (I ne se)
H6 : le se (length tl)
H2 : le ne (length rl)
H4 : forall (r : BC) (_ : In r tl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n) (and (le s' s) (eq (inf (convI r)) (I n' s')))))
H3 : forall (r : BC) (_ : In r rl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n)\n (and (le s' Datatypes.O) (eq (inf (convI r)) (I n' s')))))
ne,se : nat
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl),\neq (arities e) (ok_arities n Datatypes.O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
False
+++++
destruct H5.
-----
Lemma convI_inf_correct : forall (e : BC) n s, arities e = ok_arities n s -> exists n', exists s', n' <= n /\\ s' <= s /\\ inf (convI e) = I n' s'.
Proof.
apply BC_ind_inf; simpl; intros.
exists 0; exists 0; auto.
destruct n; simpl.
exists 0; exists (S (i - 0)).
repeat (split; try omega).
case_eq (leb i n); intros; simpl.
apply leb_complete in H0.
exists (S i); exists 0.
repeat (split; try omega).
apply leb_complete_conv in H0.
exists 0; exists (S (i - S n)).
repeat (split; try omega).
exists 0; exists 1; auto.
exists 0; exists 1; auto.
exists 0; exists 4; auto.
destruct H2 as (ne1 & se1 & He1).
destruct H3 as (ne2 & se2 & He2).
destruct H4 as (ne3 & se3 & He3).
decompose [and] He1; decompose [and] He2; decompose [and] He3.
clear He1 He2 He3.
rewrite H5, H8, H11.
eexists; eexists.
split; try split.
3: eauto.
apply maxl_bound; omega.
apply maxl_bound; omega.
destruct H2 as (ne & se & He).
decompose [and] He; clear He.
rewrite H7.
repeat rewrite leb_correct.
simpl.
case_eq ( inf_list (map inf (map convI rl)) ) ; intros.
case_eq ( inf_list (map inf (map convI tl)) ) ; intros.
case_eq (beq_nat n1 0); intros.
eexists; eexists; split; try split.
3: eauto.
apply Nat.max_lub.
apply inf_list_maxl_l in H5.
rewrite H5.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.
destruct H10 as [? [? ?]].
destruct (H3 x H11) as (? & ? & ?).
decompose [and] H12.
subst.
rewrite H16; simpl; trivial.
apply inf_list_maxl_l in H8.
rewrite H8.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.
destruct H10 as [? [? ?]].
destruct (H4 x H11) as (? & ? & ?).
decompose [and] H12.
subst.
rewrite H16; simpl; trivial.
apply inf_list_maxl_r in H8.
rewrite H8.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.
destruct H10 as [? [? ?]].
destruct (H4 x H11) as (? & ? & ?).
decompose [and] H12.
subst.
rewrite H16; simpl; trivial.
apply beq_nat_false in H9.
elim H9.
apply inf_list_maxl_r in H5.
rewrite H5, map_map, map_map.
apply maxl_map_0.
intros.
destruct (H3 x H10) as (? & ? & ?).
decompose [and] H11.
subst.
rewrite H15; simpl; trivial.
omega.
elimtype False.
apply in_inf_list_err_conv in H8.
destruct H8.
rewrite map_map in H8.
apply in_map_iff in H8.
destruct H8 as [? [? ?]].
destruct (H4 x0 H9) as (? & ? & ?).
decompose [and] H10.
rewrite H8 in H14; discriminate.
elimtype False.
apply in_inf_list_err_conv in H5.
destruct H5.

*****
H5 : In (E x) (map inf (map convI rl))
e,x : ErrorI
H7 : eq (inf (convI h)) (I ne se)
H6 : le se (length tl)
H2 : le ne (length rl)
H4 : forall (r : BC) (_ : In r tl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n) (and (le s' s) (eq (inf (convI r)) (I n' s')))))
H3 : forall (r : BC) (_ : In r rl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n)\n (and (le s' Datatypes.O) (eq (inf (convI r)) (I n' s')))))
ne,se : nat
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl),\neq (arities e) (ok_arities n Datatypes.O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
False
+++++
rewrite map_map in H5.
-----
Lemma convI_inf_correct : forall (e : BC) n s, arities e = ok_arities n s -> exists n', exists s', n' <= n /\\ s' <= s /\\ inf (convI e) = I n' s'.
Proof.
apply BC_ind_inf; simpl; intros.
exists 0; exists 0; auto.
destruct n; simpl.
exists 0; exists (S (i - 0)).
repeat (split; try omega).
case_eq (leb i n); intros; simpl.
apply leb_complete in H0.
exists (S i); exists 0.
repeat (split; try omega).
apply leb_complete_conv in H0.
exists 0; exists (S (i - S n)).
repeat (split; try omega).
exists 0; exists 1; auto.
exists 0; exists 1; auto.
exists 0; exists 4; auto.
destruct H2 as (ne1 & se1 & He1).
destruct H3 as (ne2 & se2 & He2).
destruct H4 as (ne3 & se3 & He3).
decompose [and] He1; decompose [and] He2; decompose [and] He3.
clear He1 He2 He3.
rewrite H5, H8, H11.
eexists; eexists.
split; try split.
3: eauto.
apply maxl_bound; omega.
apply maxl_bound; omega.
destruct H2 as (ne & se & He).
decompose [and] He; clear He.
rewrite H7.
repeat rewrite leb_correct.
simpl.
case_eq ( inf_list (map inf (map convI rl)) ) ; intros.
case_eq ( inf_list (map inf (map convI tl)) ) ; intros.
case_eq (beq_nat n1 0); intros.
eexists; eexists; split; try split.
3: eauto.
apply Nat.max_lub.
apply inf_list_maxl_l in H5.
rewrite H5.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.
destruct H10 as [? [? ?]].
destruct (H3 x H11) as (? & ? & ?).
decompose [and] H12.
subst.
rewrite H16; simpl; trivial.
apply inf_list_maxl_l in H8.
rewrite H8.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.
destruct H10 as [? [? ?]].
destruct (H4 x H11) as (? & ? & ?).
decompose [and] H12.
subst.
rewrite H16; simpl; trivial.
apply inf_list_maxl_r in H8.
rewrite H8.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.
destruct H10 as [? [? ?]].
destruct (H4 x H11) as (? & ? & ?).
decompose [and] H12.
subst.
rewrite H16; simpl; trivial.
apply beq_nat_false in H9.
elim H9.
apply inf_list_maxl_r in H5.
rewrite H5, map_map, map_map.
apply maxl_map_0.
intros.
destruct (H3 x H10) as (? & ? & ?).
decompose [and] H11.
subst.
rewrite H15; simpl; trivial.
omega.
elimtype False.
apply in_inf_list_err_conv in H8.
destruct H8.
rewrite map_map in H8.
apply in_map_iff in H8.
destruct H8 as [? [? ?]].
destruct (H4 x0 H9) as (? & ? & ?).
decompose [and] H10.
rewrite H8 in H14; discriminate.
elimtype False.
apply in_inf_list_err_conv in H5.
destruct H5.
rewrite map_map in H5.

*****
H5 : In (E x) (map (fun x : BC => inf (convI x)) rl)
e,x : ErrorI
H7 : eq (inf (convI h)) (I ne se)
H6 : le se (length tl)
H2 : le ne (length rl)
H4 : forall (r : BC) (_ : In r tl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n) (and (le s' s) (eq (inf (convI r)) (I n' s')))))
H3 : forall (r : BC) (_ : In r rl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n)\n (and (le s' Datatypes.O) (eq (inf (convI r)) (I n' s')))))
ne,se : nat
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl),\neq (arities e) (ok_arities n Datatypes.O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
False
+++++
apply in_map_iff in H5.
-----
Lemma convI_inf_correct : forall (e : BC) n s, arities e = ok_arities n s -> exists n', exists s', n' <= n /\\ s' <= s /\\ inf (convI e) = I n' s'.
Proof.
apply BC_ind_inf; simpl; intros.
exists 0; exists 0; auto.
destruct n; simpl.
exists 0; exists (S (i - 0)).
repeat (split; try omega).
case_eq (leb i n); intros; simpl.
apply leb_complete in H0.
exists (S i); exists 0.
repeat (split; try omega).
apply leb_complete_conv in H0.
exists 0; exists (S (i - S n)).
repeat (split; try omega).
exists 0; exists 1; auto.
exists 0; exists 1; auto.
exists 0; exists 4; auto.
destruct H2 as (ne1 & se1 & He1).
destruct H3 as (ne2 & se2 & He2).
destruct H4 as (ne3 & se3 & He3).
decompose [and] He1; decompose [and] He2; decompose [and] He3.
clear He1 He2 He3.
rewrite H5, H8, H11.
eexists; eexists.
split; try split.
3: eauto.
apply maxl_bound; omega.
apply maxl_bound; omega.
destruct H2 as (ne & se & He).
decompose [and] He; clear He.
rewrite H7.
repeat rewrite leb_correct.
simpl.
case_eq ( inf_list (map inf (map convI rl)) ) ; intros.
case_eq ( inf_list (map inf (map convI tl)) ) ; intros.
case_eq (beq_nat n1 0); intros.
eexists; eexists; split; try split.
3: eauto.
apply Nat.max_lub.
apply inf_list_maxl_l in H5.
rewrite H5.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.
destruct H10 as [? [? ?]].
destruct (H3 x H11) as (? & ? & ?).
decompose [and] H12.
subst.
rewrite H16; simpl; trivial.
apply inf_list_maxl_l in H8.
rewrite H8.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.
destruct H10 as [? [? ?]].
destruct (H4 x H11) as (? & ? & ?).
decompose [and] H12.
subst.
rewrite H16; simpl; trivial.
apply inf_list_maxl_r in H8.
rewrite H8.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.
destruct H10 as [? [? ?]].
destruct (H4 x H11) as (? & ? & ?).
decompose [and] H12.
subst.
rewrite H16; simpl; trivial.
apply beq_nat_false in H9.
elim H9.
apply inf_list_maxl_r in H5.
rewrite H5, map_map, map_map.
apply maxl_map_0.
intros.
destruct (H3 x H10) as (? & ? & ?).
decompose [and] H11.
subst.
rewrite H15; simpl; trivial.
omega.
elimtype False.
apply in_inf_list_err_conv in H8.
destruct H8.
rewrite map_map in H8.
apply in_map_iff in H8.
destruct H8 as [? [? ?]].
destruct (H4 x0 H9) as (? & ? & ?).
decompose [and] H10.
rewrite H8 in H14; discriminate.
elimtype False.
apply in_inf_list_err_conv in H5.
destruct H5.
rewrite map_map in H5.
apply in_map_iff in H5.

*****
H5 : ex (fun x0 : BC => and (eq (inf (convI x0)) (E x)) (In x0 rl))
e,x : ErrorI
H7 : eq (inf (convI h)) (I ne se)
H6 : le se (length tl)
H2 : le ne (length rl)
H4 : forall (r : BC) (_ : In r tl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n) (and (le s' s) (eq (inf (convI r)) (I n' s')))))
H3 : forall (r : BC) (_ : In r rl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n)\n (and (le s' Datatypes.O) (eq (inf (convI r)) (I n' s')))))
ne,se : nat
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl),\neq (arities e) (ok_arities n Datatypes.O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
False
+++++
destruct H5 as [? [? ?]].
-----
Lemma convI_inf_correct : forall (e : BC) n s, arities e = ok_arities n s -> exists n', exists s', n' <= n /\\ s' <= s /\\ inf (convI e) = I n' s'.
Proof.
apply BC_ind_inf; simpl; intros.
exists 0; exists 0; auto.
destruct n; simpl.
exists 0; exists (S (i - 0)).
repeat (split; try omega).
case_eq (leb i n); intros; simpl.
apply leb_complete in H0.
exists (S i); exists 0.
repeat (split; try omega).
apply leb_complete_conv in H0.
exists 0; exists (S (i - S n)).
repeat (split; try omega).
exists 0; exists 1; auto.
exists 0; exists 1; auto.
exists 0; exists 4; auto.
destruct H2 as (ne1 & se1 & He1).
destruct H3 as (ne2 & se2 & He2).
destruct H4 as (ne3 & se3 & He3).
decompose [and] He1; decompose [and] He2; decompose [and] He3.
clear He1 He2 He3.
rewrite H5, H8, H11.
eexists; eexists.
split; try split.
3: eauto.
apply maxl_bound; omega.
apply maxl_bound; omega.
destruct H2 as (ne & se & He).
decompose [and] He; clear He.
rewrite H7.
repeat rewrite leb_correct.
simpl.
case_eq ( inf_list (map inf (map convI rl)) ) ; intros.
case_eq ( inf_list (map inf (map convI tl)) ) ; intros.
case_eq (beq_nat n1 0); intros.
eexists; eexists; split; try split.
3: eauto.
apply Nat.max_lub.
apply inf_list_maxl_l in H5.
rewrite H5.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.
destruct H10 as [? [? ?]].
destruct (H3 x H11) as (? & ? & ?).
decompose [and] H12.
subst.
rewrite H16; simpl; trivial.
apply inf_list_maxl_l in H8.
rewrite H8.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.
destruct H10 as [? [? ?]].
destruct (H4 x H11) as (? & ? & ?).
decompose [and] H12.
subst.
rewrite H16; simpl; trivial.
apply inf_list_maxl_r in H8.
rewrite H8.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.
destruct H10 as [? [? ?]].
destruct (H4 x H11) as (? & ? & ?).
decompose [and] H12.
subst.
rewrite H16; simpl; trivial.
apply beq_nat_false in H9.
elim H9.
apply inf_list_maxl_r in H5.
rewrite H5, map_map, map_map.
apply maxl_map_0.
intros.
destruct (H3 x H10) as (? & ? & ?).
decompose [and] H11.
subst.
rewrite H15; simpl; trivial.
omega.
elimtype False.
apply in_inf_list_err_conv in H8.
destruct H8.
rewrite map_map in H8.
apply in_map_iff in H8.
destruct H8 as [? [? ?]].
destruct (H4 x0 H9) as (? & ? & ?).
decompose [and] H10.
rewrite H8 in H14; discriminate.
elimtype False.
apply in_inf_list_err_conv in H5.
destruct H5.
rewrite map_map in H5.
apply in_map_iff in H5.
destruct H5 as [? [? ?]].

*****
H8 : In x0 rl
H5 : eq (inf (convI x0)) (E x)
x0 : BC
e,x : ErrorI
H7 : eq (inf (convI h)) (I ne se)
H6 : le se (length tl)
H2 : le ne (length rl)
H4 : forall (r : BC) (_ : In r tl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n) (and (le s' s) (eq (inf (convI r)) (I n' s')))))
H3 : forall (r : BC) (_ : In r rl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n)\n (and (le s' Datatypes.O) (eq (inf (convI r)) (I n' s')))))
ne,se : nat
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl),\neq (arities e) (ok_arities n Datatypes.O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
False
+++++
destruct (H3 x0 H8) as (? & ? & ?).
-----
Lemma convI_inf_correct : forall (e : BC) n s, arities e = ok_arities n s -> exists n', exists s', n' <= n /\\ s' <= s /\\ inf (convI e) = I n' s'.
Proof.
apply BC_ind_inf; simpl; intros.
exists 0; exists 0; auto.
destruct n; simpl.
exists 0; exists (S (i - 0)).
repeat (split; try omega).
case_eq (leb i n); intros; simpl.
apply leb_complete in H0.
exists (S i); exists 0.
repeat (split; try omega).
apply leb_complete_conv in H0.
exists 0; exists (S (i - S n)).
repeat (split; try omega).
exists 0; exists 1; auto.
exists 0; exists 1; auto.
exists 0; exists 4; auto.
destruct H2 as (ne1 & se1 & He1).
destruct H3 as (ne2 & se2 & He2).
destruct H4 as (ne3 & se3 & He3).
decompose [and] He1; decompose [and] He2; decompose [and] He3.
clear He1 He2 He3.
rewrite H5, H8, H11.
eexists; eexists.
split; try split.
3: eauto.
apply maxl_bound; omega.
apply maxl_bound; omega.
destruct H2 as (ne & se & He).
decompose [and] He; clear He.
rewrite H7.
repeat rewrite leb_correct.
simpl.
case_eq ( inf_list (map inf (map convI rl)) ) ; intros.
case_eq ( inf_list (map inf (map convI tl)) ) ; intros.
case_eq (beq_nat n1 0); intros.
eexists; eexists; split; try split.
3: eauto.
apply Nat.max_lub.
apply inf_list_maxl_l in H5.
rewrite H5.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.
destruct H10 as [? [? ?]].
destruct (H3 x H11) as (? & ? & ?).
decompose [and] H12.
subst.
rewrite H16; simpl; trivial.
apply inf_list_maxl_l in H8.
rewrite H8.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.
destruct H10 as [? [? ?]].
destruct (H4 x H11) as (? & ? & ?).
decompose [and] H12.
subst.
rewrite H16; simpl; trivial.
apply inf_list_maxl_r in H8.
rewrite H8.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.
destruct H10 as [? [? ?]].
destruct (H4 x H11) as (? & ? & ?).
decompose [and] H12.
subst.
rewrite H16; simpl; trivial.
apply beq_nat_false in H9.
elim H9.
apply inf_list_maxl_r in H5.
rewrite H5, map_map, map_map.
apply maxl_map_0.
intros.
destruct (H3 x H10) as (? & ? & ?).
decompose [and] H11.
subst.
rewrite H15; simpl; trivial.
omega.
elimtype False.
apply in_inf_list_err_conv in H8.
destruct H8.
rewrite map_map in H8.
apply in_map_iff in H8.
destruct H8 as [? [? ?]].
destruct (H4 x0 H9) as (? & ? & ?).
decompose [and] H10.
rewrite H8 in H14; discriminate.
elimtype False.
apply in_inf_list_err_conv in H5.
destruct H5.
rewrite map_map in H5.
apply in_map_iff in H5.
destruct H5 as [? [? ?]].
destruct (H3 x0 H8) as (? & ? & ?).

*****
H9 : and (le x1 n) (and (le x2 Datatypes.O) (eq (inf (convI x0)) (I x1 x2)))
x1,x2 : nat
H8 : In x0 rl
H5 : eq (inf (convI x0)) (E x)
x0 : BC
e,x : ErrorI
H7 : eq (inf (convI h)) (I ne se)
H6 : le se (length tl)
H2 : le ne (length rl)
H4 : forall (r : BC) (_ : In r tl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n) (and (le s' s) (eq (inf (convI r)) (I n' s')))))
H3 : forall (r : BC) (_ : In r rl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n)\n (and (le s' Datatypes.O) (eq (inf (convI r)) (I n' s')))))
ne,se : nat
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl),\neq (arities e) (ok_arities n Datatypes.O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
False
+++++
decompose [and] H9.
-----
Lemma convI_inf_correct : forall (e : BC) n s, arities e = ok_arities n s -> exists n', exists s', n' <= n /\\ s' <= s /\\ inf (convI e) = I n' s'.
Proof.
apply BC_ind_inf; simpl; intros.
exists 0; exists 0; auto.
destruct n; simpl.
exists 0; exists (S (i - 0)).
repeat (split; try omega).
case_eq (leb i n); intros; simpl.
apply leb_complete in H0.
exists (S i); exists 0.
repeat (split; try omega).
apply leb_complete_conv in H0.
exists 0; exists (S (i - S n)).
repeat (split; try omega).
exists 0; exists 1; auto.
exists 0; exists 1; auto.
exists 0; exists 4; auto.
destruct H2 as (ne1 & se1 & He1).
destruct H3 as (ne2 & se2 & He2).
destruct H4 as (ne3 & se3 & He3).
decompose [and] He1; decompose [and] He2; decompose [and] He3.
clear He1 He2 He3.
rewrite H5, H8, H11.
eexists; eexists.
split; try split.
3: eauto.
apply maxl_bound; omega.
apply maxl_bound; omega.
destruct H2 as (ne & se & He).
decompose [and] He; clear He.
rewrite H7.
repeat rewrite leb_correct.
simpl.
case_eq ( inf_list (map inf (map convI rl)) ) ; intros.
case_eq ( inf_list (map inf (map convI tl)) ) ; intros.
case_eq (beq_nat n1 0); intros.
eexists; eexists; split; try split.
3: eauto.
apply Nat.max_lub.
apply inf_list_maxl_l in H5.
rewrite H5.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.
destruct H10 as [? [? ?]].
destruct (H3 x H11) as (? & ? & ?).
decompose [and] H12.
subst.
rewrite H16; simpl; trivial.
apply inf_list_maxl_l in H8.
rewrite H8.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.
destruct H10 as [? [? ?]].
destruct (H4 x H11) as (? & ? & ?).
decompose [and] H12.
subst.
rewrite H16; simpl; trivial.
apply inf_list_maxl_r in H8.
rewrite H8.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.
destruct H10 as [? [? ?]].
destruct (H4 x H11) as (? & ? & ?).
decompose [and] H12.
subst.
rewrite H16; simpl; trivial.
apply beq_nat_false in H9.
elim H9.
apply inf_list_maxl_r in H5.
rewrite H5, map_map, map_map.
apply maxl_map_0.
intros.
destruct (H3 x H10) as (? & ? & ?).
decompose [and] H11.
subst.
rewrite H15; simpl; trivial.
omega.
elimtype False.
apply in_inf_list_err_conv in H8.
destruct H8.
rewrite map_map in H8.
apply in_map_iff in H8.
destruct H8 as [? [? ?]].
destruct (H4 x0 H9) as (? & ? & ?).
decompose [and] H10.
rewrite H8 in H14; discriminate.
elimtype False.
apply in_inf_list_err_conv in H5.
destruct H5.
rewrite map_map in H5.
apply in_map_iff in H5.
destruct H5 as [? [? ?]].
destruct (H3 x0 H8) as (? & ? & ?).
decompose [and] H9.

*****
H13 : eq (inf (convI x0)) (I x1 x2)
H12 : le x2 Datatypes.O
H10 : le x1 n
H9 : and (le x1 n) (and (le x2 Datatypes.O) (eq (inf (convI x0)) (I x1 x2)))
x1,x2 : nat
H8 : In x0 rl
H5 : eq (inf (convI x0)) (E x)
x0 : BC
e,x : ErrorI
H7 : eq (inf (convI h)) (I ne se)
H6 : le se (length tl)
H2 : le ne (length rl)
H4 : forall (r : BC) (_ : In r tl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n) (and (le s' s) (eq (inf (convI r)) (I n' s')))))
H3 : forall (r : BC) (_ : In r rl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n)\n (and (le s' Datatypes.O) (eq (inf (convI r)) (I n' s')))))
ne,se : nat
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl),\neq (arities e) (ok_arities n Datatypes.O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
False
+++++
rewrite H5 in H13; discriminate.
-----
Lemma convI_inf_correct : forall (e : BC) n s, arities e = ok_arities n s -> exists n', exists s', n' <= n /\\ s' <= s /\\ inf (convI e) = I n' s'.
Proof.
apply BC_ind_inf; simpl; intros.
exists 0; exists 0; auto.
destruct n; simpl.
exists 0; exists (S (i - 0)).
repeat (split; try omega).
case_eq (leb i n); intros; simpl.
apply leb_complete in H0.
exists (S i); exists 0.
repeat (split; try omega).
apply leb_complete_conv in H0.
exists 0; exists (S (i - S n)).
repeat (split; try omega).
exists 0; exists 1; auto.
exists 0; exists 1; auto.
exists 0; exists 4; auto.
destruct H2 as (ne1 & se1 & He1).
destruct H3 as (ne2 & se2 & He2).
destruct H4 as (ne3 & se3 & He3).
decompose [and] He1; decompose [and] He2; decompose [and] He3.
clear He1 He2 He3.
rewrite H5, H8, H11.
eexists; eexists.
split; try split.
3: eauto.
apply maxl_bound; omega.
apply maxl_bound; omega.
destruct H2 as (ne & se & He).
decompose [and] He; clear He.
rewrite H7.
repeat rewrite leb_correct.
simpl.
case_eq ( inf_list (map inf (map convI rl)) ) ; intros.
case_eq ( inf_list (map inf (map convI tl)) ) ; intros.
case_eq (beq_nat n1 0); intros.
eexists; eexists; split; try split.
3: eauto.
apply Nat.max_lub.
apply inf_list_maxl_l in H5.
rewrite H5.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.
destruct H10 as [? [? ?]].
destruct (H3 x H11) as (? & ? & ?).
decompose [and] H12.
subst.
rewrite H16; simpl; trivial.
apply inf_list_maxl_l in H8.
rewrite H8.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.
destruct H10 as [? [? ?]].
destruct (H4 x H11) as (? & ? & ?).
decompose [and] H12.
subst.
rewrite H16; simpl; trivial.
apply inf_list_maxl_r in H8.
rewrite H8.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.
destruct H10 as [? [? ?]].
destruct (H4 x H11) as (? & ? & ?).
decompose [and] H12.
subst.
rewrite H16; simpl; trivial.
apply beq_nat_false in H9.
elim H9.
apply inf_list_maxl_r in H5.
rewrite H5, map_map, map_map.
apply maxl_map_0.
intros.
destruct (H3 x H10) as (? & ? & ?).
decompose [and] H11.
subst.
rewrite H15; simpl; trivial.
omega.
elimtype False.
apply in_inf_list_err_conv in H8.
destruct H8.
rewrite map_map in H8.
apply in_map_iff in H8.
destruct H8 as [? [? ?]].
destruct (H4 x0 H9) as (? & ? & ?).
decompose [and] H10.
rewrite H8 in H14; discriminate.
elimtype False.
apply in_inf_list_err_conv in H5.
destruct H5.
rewrite map_map in H5.
apply in_map_iff in H5.
destruct H5 as [? [? ?]].
destruct (H3 x0 H8) as (? & ? & ?).
decompose [and] H9.
rewrite H5 in H13; discriminate.

*****
H7 : eq (inf (convI h)) (I ne se)
H6 : le se (length tl)
H2 : le ne (length rl)
H4 : forall (r : BC) (_ : In r tl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n) (and (le s' s) (eq (inf (convI r)) (I n' s')))))
H3 : forall (r : BC) (_ : In r rl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n)\n (and (le s' Datatypes.O) (eq (inf (convI r)) (I n' s')))))
ne,se : nat
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl),\neq (arities e) (ok_arities n Datatypes.O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
le se (length (map convI tl))
+++++
rewrite map_length; omega.
-----
Lemma convI_inf_correct : forall (e : BC) n s, arities e = ok_arities n s -> exists n', exists s', n' <= n /\\ s' <= s /\\ inf (convI e) = I n' s'.
Proof.
apply BC_ind_inf; simpl; intros.
exists 0; exists 0; auto.
destruct n; simpl.
exists 0; exists (S (i - 0)).
repeat (split; try omega).
case_eq (leb i n); intros; simpl.
apply leb_complete in H0.
exists (S i); exists 0.
repeat (split; try omega).
apply leb_complete_conv in H0.
exists 0; exists (S (i - S n)).
repeat (split; try omega).
exists 0; exists 1; auto.
exists 0; exists 1; auto.
exists 0; exists 4; auto.
destruct H2 as (ne1 & se1 & He1).
destruct H3 as (ne2 & se2 & He2).
destruct H4 as (ne3 & se3 & He3).
decompose [and] He1; decompose [and] He2; decompose [and] He3.
clear He1 He2 He3.
rewrite H5, H8, H11.
eexists; eexists.
split; try split.
3: eauto.
apply maxl_bound; omega.
apply maxl_bound; omega.
destruct H2 as (ne & se & He).
decompose [and] He; clear He.
rewrite H7.
repeat rewrite leb_correct.
simpl.
case_eq ( inf_list (map inf (map convI rl)) ) ; intros.
case_eq ( inf_list (map inf (map convI tl)) ) ; intros.
case_eq (beq_nat n1 0); intros.
eexists; eexists; split; try split.
3: eauto.
apply Nat.max_lub.
apply inf_list_maxl_l in H5.
rewrite H5.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.
destruct H10 as [? [? ?]].
destruct (H3 x H11) as (? & ? & ?).
decompose [and] H12.
subst.
rewrite H16; simpl; trivial.
apply inf_list_maxl_l in H8.
rewrite H8.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.
destruct H10 as [? [? ?]].
destruct (H4 x H11) as (? & ? & ?).
decompose [and] H12.
subst.
rewrite H16; simpl; trivial.
apply inf_list_maxl_r in H8.
rewrite H8.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.
destruct H10 as [? [? ?]].
destruct (H4 x H11) as (? & ? & ?).
decompose [and] H12.
subst.
rewrite H16; simpl; trivial.
apply beq_nat_false in H9.
elim H9.
apply inf_list_maxl_r in H5.
rewrite H5, map_map, map_map.
apply maxl_map_0.
intros.
destruct (H3 x H10) as (? & ? & ?).
decompose [and] H11.
subst.
rewrite H15; simpl; trivial.
omega.
elimtype False.
apply in_inf_list_err_conv in H8.
destruct H8.
rewrite map_map in H8.
apply in_map_iff in H8.
destruct H8 as [? [? ?]].
destruct (H4 x0 H9) as (? & ? & ?).
decompose [and] H10.
rewrite H8 in H14; discriminate.
elimtype False.
apply in_inf_list_err_conv in H5.
destruct H5.
rewrite map_map in H5.
apply in_map_iff in H5.
destruct H5 as [? [? ?]].
destruct (H3 x0 H8) as (? & ? & ?).
decompose [and] H9.
rewrite H5 in H13; discriminate.
rewrite map_length; omega.

*****
H7 : eq (inf (convI h)) (I ne se)
H6 : le se (length tl)
H2 : le ne (length rl)
H4 : forall (r : BC) (_ : In r tl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n) (and (le s' s) (eq (inf (convI r)) (I n' s')))))
H3 : forall (r : BC) (_ : In r rl),\nex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n)\n (and (le s' Datatypes.O) (eq (inf (convI r)) (I n' s')))))
ne,se : nat
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl),\neq (arities e) (ok_arities n Datatypes.O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
le ne (length (map convI rl))
+++++
rewrite map_length; omega.
-----
Lemma convI_inf_correct : forall (e : BC) n s, arities e = ok_arities n s -> exists n', exists s', n' <= n /\\ s' <= s /\\ inf (convI e) = I n' s'.
Proof.
apply BC_ind_inf; simpl; intros.
exists 0; exists 0; auto.
destruct n; simpl.
exists 0; exists (S (i - 0)).
repeat (split; try omega).
case_eq (leb i n); intros; simpl.
apply leb_complete in H0.
exists (S i); exists 0.
repeat (split; try omega).
apply leb_complete_conv in H0.
exists 0; exists (S (i - S n)).
repeat (split; try omega).
exists 0; exists 1; auto.
exists 0; exists 1; auto.
exists 0; exists 4; auto.
destruct H2 as (ne1 & se1 & He1).
destruct H3 as (ne2 & se2 & He2).
destruct H4 as (ne3 & se3 & He3).
decompose [and] He1; decompose [and] He2; decompose [and] He3.
clear He1 He2 He3.
rewrite H5, H8, H11.
eexists; eexists.
split; try split.
3: eauto.
apply maxl_bound; omega.
apply maxl_bound; omega.
destruct H2 as (ne & se & He).
decompose [and] He; clear He.
rewrite H7.
repeat rewrite leb_correct.
simpl.
case_eq ( inf_list (map inf (map convI rl)) ) ; intros.
case_eq ( inf_list (map inf (map convI tl)) ) ; intros.
case_eq (beq_nat n1 0); intros.
eexists; eexists; split; try split.
3: eauto.
apply Nat.max_lub.
apply inf_list_maxl_l in H5.
rewrite H5.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.
destruct H10 as [? [? ?]].
destruct (H3 x H11) as (? & ? & ?).
decompose [and] H12.
subst.
rewrite H16; simpl; trivial.
apply inf_list_maxl_l in H8.
rewrite H8.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.
destruct H10 as [? [? ?]].
destruct (H4 x H11) as (? & ? & ?).
decompose [and] H12.
subst.
rewrite H16; simpl; trivial.
apply inf_list_maxl_r in H8.
rewrite H8.
rewrite map_map.
rewrite map_map.
apply maxl_bound_in.
intros.
apply in_map_iff in H10.
destruct H10 as [? [? ?]].
destruct (H4 x H11) as (? & ? & ?).
decompose [and] H12.
subst.
rewrite H16; simpl; trivial.
apply beq_nat_false in H9.
elim H9.
apply inf_list_maxl_r in H5.
rewrite H5, map_map, map_map.
apply maxl_map_0.
intros.
destruct (H3 x H10) as (? & ? & ?).
decompose [and] H11.
subst.
rewrite H15; simpl; trivial.
omega.
elimtype False.
apply in_inf_list_err_conv in H8.
destruct H8.
rewrite map_map in H8.
apply in_map_iff in H8.
destruct H8 as [? [? ?]].
destruct (H4 x0 H9) as (? & ? & ?).
decompose [and] H10.
rewrite H8 in H14; discriminate.
elimtype False.
apply in_inf_list_err_conv in H5.
destruct H5.
rewrite map_map in H5.
apply in_map_iff in H5.
destruct H5 as [? [? ?]].
destruct (H3 x0 H8) as (? & ? & ?).
decompose [and] H9.
rewrite H5 in H13; discriminate.
rewrite map_length; omega.
rewrite map_length; omega.

*****

*****

+++++
Qed.
-----
Lemma convI_correct : forall e n s,\n  arities e = ok_arities n s ->\n  forall vnl vsl,\n  semI (convI e) vnl vsl = sem e vnl vsl.
-----
Lemma convI_correct : forall e n s, arities e = ok_arities n s -> forall vnl vsl, semI (convI e) vnl vsl = sem e vnl vsl.

*****

*****
forall (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)) (vnl vsl : list (list bool)), eq (semI (convI e) vnl vsl) (sem e vnl vsl)
+++++
Proof.
-----
Lemma convI_correct : forall e n s, arities e = ok_arities n s -> forall vnl vsl, semI (convI e) vnl vsl = sem e vnl vsl.
Proof.

*****

*****
forall (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)) (vnl vsl : list (list bool)), eq (semI (convI e) vnl vsl) (sem e vnl vsl)
+++++
refine (BC_ind_inf _ _ _ _ _ _ _ _).
-----
Lemma convI_correct : forall e n s, arities e = ok_arities n s -> forall vnl vsl, semI (convI e) vnl vsl = sem e vnl vsl.
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _).

*****

*****
forall vnl vsl : list (list bool), eq (semI (convI zero) vnl vsl) (sem zero vnl vsl)
+++++
simpl.
-----
Lemma convI_correct : forall e n s, arities e = ok_arities n s -> forall vnl vsl, semI (convI e) vnl vsl = sem e vnl vsl.
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.

*****

*****
forall (_ : list (list bool)) (_ : list (list bool)), eq nil nil
+++++
intros.
-----
Lemma convI_correct : forall e n s, arities e = ok_arities n s -> forall vnl vsl, semI (convI e) vnl vsl = sem e vnl vsl.
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.

*****
vnl,vsl : list (list bool)
*****
eq nil nil
+++++
trivial.
-----
Lemma convI_correct : forall e n s, arities e = ok_arities n s -> forall vnl vsl, semI (convI e) vnl vsl = sem e vnl vsl.
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _).

*****

*****
forall (n s i : nat) (_ : lt i (Init.Nat.add n s)) (vnl vsl : list (list bool)), eq (semI (convI (proj n s i)) vnl vsl) (sem (proj n s i) vnl vsl)
+++++
simpl.
-----
Lemma convI_correct : forall e n s, arities e = ok_arities n s -> forall vnl vsl, semI (convI e) vnl vsl = sem e vnl vsl.
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.

*****

*****
forall (n s i : nat) (_ : lt i (Init.Nat.add n s)) (vnl vsl : list (list bool)), eq (semI (if match n with | Datatypes.O => false | S m' => Nat.leb i m' end then projIn i else projIs (Init.Nat.sub i n)) vnl vsl) (if match n with | Datatypes.O => false | S m' => Nat.leb i m' end then nth i vnl nil else nth (Init.Nat.sub i n) vsl nil)
+++++
intros.
-----
Lemma convI_correct : forall e n s, arities e = ok_arities n s -> forall vnl vsl, semI (convI e) vnl vsl = sem e vnl vsl.
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.

*****
vnl,vsl : list (list bool)
H : lt i (Init.Nat.add n s)
n,s,i : nat
*****
eq (semI (if match n with | Datatypes.O => false | S m' => Nat.leb i m' end then projIn i else projIs (Init.Nat.sub i n)) vnl vsl) (if match n with | Datatypes.O => false | S m' => Nat.leb i m' end then nth i vnl nil else nth (Init.Nat.sub i n) vsl nil)
+++++
trivial.
-----
Lemma convI_correct : forall e n s, arities e = ok_arities n s -> forall vnl vsl, semI (convI e) vnl vsl = sem e vnl vsl.
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.
trivial.

*****
vnl,vsl : list (list bool)
H : lt i (Init.Nat.add n s)
n,s,i : nat
*****
eq (semI (if match n with | Datatypes.O => false | S m' => Nat.leb i m' end then projIn i else projIs (Init.Nat.sub i n)) vnl vsl) (if match n with | Datatypes.O => false | S m' => Nat.leb i m' end then nth i vnl nil else nth (Init.Nat.sub i n) vsl nil)
+++++
destruct n.
-----
Lemma convI_correct : forall e n s, arities e = ok_arities n s -> forall vnl vsl, semI (convI e) vnl vsl = sem e vnl vsl.
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.
trivial.
destruct n.

*****
vnl,vsl : list (list bool)
H : lt i (Init.Nat.add Datatypes.O s)
s,i : nat
*****
eq (semI (projIs (Init.Nat.sub i Datatypes.O)) vnl vsl) (nth (Init.Nat.sub i Datatypes.O) vsl nil)
+++++
simpl.
-----
Lemma convI_correct : forall e n s, arities e = ok_arities n s -> forall vnl vsl, semI (convI e) vnl vsl = sem e vnl vsl.
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.
trivial.
destruct n.
simpl.

*****
vnl,vsl : list (list bool)
H : lt i (Init.Nat.add Datatypes.O s)
s,i : nat
*****
eq (nth (Init.Nat.sub i Datatypes.O) vsl nil) (nth (Init.Nat.sub i Datatypes.O) vsl nil)
+++++
trivial.
-----
Lemma convI_correct : forall e n s, arities e = ok_arities n s -> forall vnl vsl, semI (convI e) vnl vsl = sem e vnl vsl.
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.
trivial.
destruct n.

*****
vnl,vsl : list (list bool)
H : lt i (Init.Nat.add (S n) s)
n,s,i : nat
*****
eq (semI (if Nat.leb i n then projIn i else projIs (Init.Nat.sub i (S n))) vnl vsl) (if Nat.leb i n then nth i vnl nil else nth (Init.Nat.sub i (S n)) vsl nil)
+++++
simpl.
-----
Lemma convI_correct : forall e n s, arities e = ok_arities n s -> forall vnl vsl, semI (convI e) vnl vsl = sem e vnl vsl.
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.
trivial.
destruct n.
simpl.

*****
vnl,vsl : list (list bool)
H : lt i (Init.Nat.add (S n) s)
n,s,i : nat
*****
eq (semI (if Nat.leb i n then projIn i else projIs (Init.Nat.sub i (S n))) vnl vsl) (if Nat.leb i n then nth i vnl nil else nth (Init.Nat.sub i (S n)) vsl nil)
+++++
trivial.
-----
Lemma convI_correct : forall e n s, arities e = ok_arities n s -> forall vnl vsl, semI (convI e) vnl vsl = sem e vnl vsl.
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.
trivial.
destruct n.
simpl.
trivial.

*****
vnl,vsl : list (list bool)
H : lt i (Init.Nat.add (S n) s)
n,s,i : nat
*****
eq (semI (if Nat.leb i n then projIn i else projIs (Init.Nat.sub i (S n))) vnl vsl) (if Nat.leb i n then nth i vnl nil else nth (Init.Nat.sub i (S n)) vsl nil)
+++++
case_eq (leb i n).
-----
Lemma convI_correct : forall e n s, arities e = ok_arities n s -> forall vnl vsl, semI (convI e) vnl vsl = sem e vnl vsl.
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.
trivial.
destruct n.
simpl.
trivial.
case_eq (leb i n).

*****
vnl,vsl : list (list bool)
H : lt i (Init.Nat.add (S n) s)
n,s,i : nat
*****
forall _ : eq (Nat.leb i n) true, eq (semI (projIn i) vnl vsl) (nth i vnl nil)
+++++
intros.
-----
Lemma convI_correct : forall e n s, arities e = ok_arities n s -> forall vnl vsl, semI (convI e) vnl vsl = sem e vnl vsl.
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.
trivial.
destruct n.
simpl.
trivial.
case_eq (leb i n).
intros.

*****
H0 : eq (Nat.leb i n) true
vnl,vsl : list (list bool)
H : lt i (Init.Nat.add (S n) s)
n,s,i : nat
*****
eq (semI (projIn i) vnl vsl) (nth i vnl nil)
+++++
simpl.
-----
Lemma convI_correct : forall e n s, arities e = ok_arities n s -> forall vnl vsl, semI (convI e) vnl vsl = sem e vnl vsl.
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.
trivial.
destruct n.
simpl.
trivial.
case_eq (leb i n).
intros.
simpl.

*****
H0 : eq (Nat.leb i n) true
vnl,vsl : list (list bool)
H : lt i (Init.Nat.add (S n) s)
n,s,i : nat
*****
eq (nth i vnl nil) (nth i vnl nil)
+++++
trivial.
-----
Lemma convI_correct : forall e n s, arities e = ok_arities n s -> forall vnl vsl, semI (convI e) vnl vsl = sem e vnl vsl.
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.
trivial.
destruct n.
simpl.
trivial.
case_eq (leb i n).

*****
vnl,vsl : list (list bool)
H : lt i (Init.Nat.add (S n) s)
n,s,i : nat
*****
forall _ : eq (Nat.leb i n) false, eq (semI (projIs (Init.Nat.sub i (S n))) vnl vsl) (nth (Init.Nat.sub i (S n)) vsl nil)
+++++
intros.
-----
Lemma convI_correct : forall e n s, arities e = ok_arities n s -> forall vnl vsl, semI (convI e) vnl vsl = sem e vnl vsl.
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.
trivial.
destruct n.
simpl.
trivial.
case_eq (leb i n).
intros.

*****
H0 : eq (Nat.leb i n) false
vnl,vsl : list (list bool)
H : lt i (Init.Nat.add (S n) s)
n,s,i : nat
*****
eq (semI (projIs (Init.Nat.sub i (S n))) vnl vsl) (nth (Init.Nat.sub i (S n)) vsl nil)
+++++
simpl.
-----
Lemma convI_correct : forall e n s, arities e = ok_arities n s -> forall vnl vsl, semI (convI e) vnl vsl = sem e vnl vsl.
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.
trivial.
destruct n.
simpl.
trivial.
case_eq (leb i n).
intros.
simpl.

*****
H0 : eq (Nat.leb i n) false
vnl,vsl : list (list bool)
H : lt i (Init.Nat.add (S n) s)
n,s,i : nat
*****
eq (nth (Init.Nat.sub i (S n)) vsl nil) (nth (Init.Nat.sub i (S n)) vsl nil)
+++++
trivial.
-----
Lemma convI_correct : forall e n s, arities e = ok_arities n s -> forall vnl vsl, semI (convI e) vnl vsl = sem e vnl vsl.
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _).

*****

*****
forall (b : bool) (vnl vsl : list (list bool)), eq (semI (convI (succ b)) vnl vsl) (sem (succ b) vnl vsl)
+++++
simpl.
-----
Lemma convI_correct : forall e n s, arities e = ok_arities n s -> forall vnl vsl, semI (convI e) vnl vsl = sem e vnl vsl.
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.

*****

*****
forall (b : bool) (_ : list (list bool)) (vsl : list (list bool)), eq (cons b (hd nil vsl)) (cons b (hd nil vsl))
+++++
intros.
-----
Lemma convI_correct : forall e n s, arities e = ok_arities n s -> forall vnl vsl, semI (convI e) vnl vsl = sem e vnl vsl.
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.

*****
vnl,vsl : list (list bool)
b : bool
*****
eq (cons b (hd nil vsl)) (cons b (hd nil vsl))
+++++
trivial.
-----
Lemma convI_correct : forall e n s, arities e = ok_arities n s -> forall vnl vsl, semI (convI e) vnl vsl = sem e vnl vsl.
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _).

*****

*****
forall vnl vsl : list (list bool), eq (semI (convI pred) vnl vsl) (sem pred vnl vsl)
+++++
simpl.
-----
Lemma convI_correct : forall e n s, arities e = ok_arities n s -> forall vnl vsl, semI (convI e) vnl vsl = sem e vnl vsl.
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.

*****

*****
forall (_ : list (list bool)) (vsl : list (list bool)), eq (tl (hd nil vsl)) (tl (hd nil vsl))
+++++
intros.
-----
Lemma convI_correct : forall e n s, arities e = ok_arities n s -> forall vnl vsl, semI (convI e) vnl vsl = sem e vnl vsl.
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.

*****
vnl,vsl : list (list bool)
*****
eq (tl (hd nil vsl)) (tl (hd nil vsl))
+++++
trivial.
-----
Lemma convI_correct : forall e n s, arities e = ok_arities n s -> forall vnl vsl, semI (convI e) vnl vsl = sem e vnl vsl.
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _).

*****

*****
forall vnl vsl : list (list bool), eq (semI (convI cond) vnl vsl) (sem cond vnl vsl)
+++++
simpl.
-----
Lemma convI_correct : forall e n s, arities e = ok_arities n s -> forall vnl vsl, semI (convI e) vnl vsl = sem e vnl vsl.
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.

*****

*****
forall (_ : list (list bool)) (vsl : list (list bool)), eq match vsl with | nil => nil | cons a nil => nil | cons a (cons b nil) => match a with | nil => b | cons _ _ => nil end | cons a (cons b (cons c nil)) => match a with | nil => b | cons true _ => c | cons false _ => nil end | cons a (cons b (cons c (cons d _))) => match a with | nil => b | cons true _ => c | cons false _ => d end end match vsl with | nil => nil | cons a nil => nil | cons a (cons b nil) => match a with | nil => b | cons _ _ => nil end | cons a (cons b (cons c nil)) => match a with | nil => b | cons true _ => c | cons false _ => nil end | cons a (cons b (cons c (cons d _))) => match a with | nil => b | cons true _ => c | cons false _ => d end end
+++++
intros.
-----
Lemma convI_correct : forall e n s, arities e = ok_arities n s -> forall vnl vsl, semI (convI e) vnl vsl = sem e vnl vsl.
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.

*****
vnl,vsl : list (list bool)
*****
eq match vsl with | nil => nil | cons a nil => nil | cons a (cons b nil) => match a with | nil => b | cons _ _ => nil end | cons a (cons b (cons c nil)) => match a with | nil => b | cons true _ => c | cons false _ => nil end | cons a (cons b (cons c (cons d _))) => match a with | nil => b | cons true _ => c | cons false _ => d end end match vsl with | nil => nil | cons a nil => nil | cons a (cons b nil) => match a with | nil => b | cons _ _ => nil end | cons a (cons b (cons c nil)) => match a with | nil => b | cons true _ => c | cons false _ => nil end | cons a (cons b (cons c (cons d _))) => match a with | nil => b | cons true _ => c | cons false _ => d end end
+++++
trivial.
-----
Lemma convI_correct : forall e n s, arities e = ok_arities n s -> forall vnl vsl, semI (convI e) vnl vsl = sem e vnl vsl.
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _).

*****

*****
forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s)) (_ : eq (arities h0) (ok_arities (S n) (S s))) (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : forall vnl vsl : list (list bool), eq (semI (convI g) vnl vsl) (sem g vnl vsl)) (_ : forall vnl vsl : list (list bool), eq (semI (convI h0) vnl vsl) (sem h0 vnl vsl)) (_ : forall vnl vsl : list (list bool), eq (semI (convI h1) vnl vsl) (sem h1 vnl vsl)) (vnl vsl : list (list bool)), eq (semI (convI (rec g h0 h1)) vnl vsl) (sem (rec g h0 h1) vnl vsl)
+++++
simpl.
-----
Lemma convI_correct : forall e n s, arities e = ok_arities n s -> forall vnl vsl, semI (convI e) vnl vsl = sem e vnl vsl.
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.

*****

*****
forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s)) (_ : eq (arities h0) (ok_arities (S n) (S s))) (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : forall vnl vsl : list (list bool), eq (semI (convI g) vnl vsl) (sem g vnl vsl)) (_ : forall vnl vsl : list (list bool), eq (semI (convI h0) vnl vsl) (sem h0 vnl vsl)) (_ : forall vnl vsl : list (list bool), eq (semI (convI h1) vnl vsl) (sem h1 vnl vsl)) (vnl vsl : list (list bool)), eq (sem_rec (semI (convI g)) (semI (convI h0)) (semI (convI h1)) (hd nil vnl) (tl vnl) vsl) (sem_rec (sem g) (sem h0) (sem h1) (hd nil vnl) (tl vnl) vsl)
+++++
intros.
-----
Lemma convI_correct : forall e n s, arities e = ok_arities n s -> forall vnl vsl, semI (convI e) vnl vsl = sem e vnl vsl.
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.

*****
vnl,vsl : list (list bool)
H4 : forall vnl vsl : list (list bool),\neq (semI (convI h1) vnl vsl) (sem h1 vnl vsl)
H3 : forall vnl vsl : list (list bool),\neq (semI (convI h0) vnl vsl) (sem h0 vnl vsl)
H2 : forall vnl vsl : list (list bool),\neq (semI (convI g) vnl vsl) (sem g vnl vsl)
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
*****
eq (sem_rec (semI (convI g)) (semI (convI h0)) (semI (convI h1)) (hd nil vnl) (tl vnl) vsl) (sem_rec (sem g) (sem h0) (sem h1) (hd nil vnl) (tl vnl) vsl)
+++++
trivial.
-----
Lemma convI_correct : forall e n s, arities e = ok_arities n s -> forall vnl vsl, semI (convI e) vnl vsl = sem e vnl vsl.
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.
trivial.

*****
vnl,vsl : list (list bool)
H4 : forall vnl vsl : list (list bool),\neq (semI (convI h1) vnl vsl) (sem h1 vnl vsl)
H3 : forall vnl vsl : list (list bool),\neq (semI (convI h0) vnl vsl) (sem h0 vnl vsl)
H2 : forall vnl vsl : list (list bool),\neq (semI (convI g) vnl vsl) (sem g vnl vsl)
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
*****
eq (sem_rec (semI (convI g)) (semI (convI h0)) (semI (convI h1)) (hd nil vnl) (tl vnl) vsl) (sem_rec (sem g) (sem h0) (sem h1) (hd nil vnl) (tl vnl) vsl)
+++++
induction (hd nil vnl).
-----
Lemma convI_correct : forall e n s, arities e = ok_arities n s -> forall vnl vsl, semI (convI e) vnl vsl = sem e vnl vsl.
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.
trivial.
induction (hd nil vnl).

*****
vnl,vsl : list (list bool)
H4 : forall vnl vsl : list (list bool),\neq (semI (convI h1) vnl vsl) (sem h1 vnl vsl)
H3 : forall vnl vsl : list (list bool),\neq (semI (convI h0) vnl vsl) (sem h0 vnl vsl)
H2 : forall vnl vsl : list (list bool),\neq (semI (convI g) vnl vsl) (sem g vnl vsl)
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
*****
eq (sem_rec (semI (convI g)) (semI (convI h0)) (semI (convI h1)) nil (tl vnl) vsl) (sem_rec (sem g) (sem h0) (sem h1) nil (tl vnl) vsl)
+++++
simpl.
-----
Lemma convI_correct : forall e n s, arities e = ok_arities n s -> forall vnl vsl, semI (convI e) vnl vsl = sem e vnl vsl.
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.
trivial.
induction (hd nil vnl).
simpl.

*****
vnl,vsl : list (list bool)
H4 : forall vnl vsl : list (list bool),\neq (semI (convI h1) vnl vsl) (sem h1 vnl vsl)
H3 : forall vnl vsl : list (list bool),\neq (semI (convI h0) vnl vsl) (sem h0 vnl vsl)
H2 : forall vnl vsl : list (list bool),\neq (semI (convI g) vnl vsl) (sem g vnl vsl)
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
*****
eq (semI (convI g) (tl vnl) vsl) (sem g (tl vnl) vsl)
+++++
intros.
-----
Lemma convI_correct : forall e n s, arities e = ok_arities n s -> forall vnl vsl, semI (convI e) vnl vsl = sem e vnl vsl.
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.
trivial.
induction (hd nil vnl).
simpl.
intros.

*****
vnl,vsl : list (list bool)
H4 : forall vnl vsl : list (list bool),\neq (semI (convI h1) vnl vsl) (sem h1 vnl vsl)
H3 : forall vnl vsl : list (list bool),\neq (semI (convI h0) vnl vsl) (sem h0 vnl vsl)
H2 : forall vnl vsl : list (list bool),\neq (semI (convI g) vnl vsl) (sem g vnl vsl)
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
*****
eq (semI (convI g) (tl vnl) vsl) (sem g (tl vnl) vsl)
+++++
auto.
-----
Lemma convI_correct : forall e n s, arities e = ok_arities n s -> forall vnl vsl, semI (convI e) vnl vsl = sem e vnl vsl.
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.
trivial.
induction (hd nil vnl).

*****
IHl : eq\n (sem_rec (semI (convI g)) (semI (convI h0)) (semI (convI h1)) l\n (tl vnl) vsl) (sem_rec (sem g) (sem h0) (sem h1) l (tl vnl) vsl)
l : list bool
a : bool
vnl,vsl : list (list bool)
H4 : forall vnl vsl : list (list bool),\neq (semI (convI h1) vnl vsl) (sem h1 vnl vsl)
H3 : forall vnl vsl : list (list bool),\neq (semI (convI h0) vnl vsl) (sem h0 vnl vsl)
H2 : forall vnl vsl : list (list bool),\neq (semI (convI g) vnl vsl) (sem g vnl vsl)
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
*****
eq (sem_rec (semI (convI g)) (semI (convI h0)) (semI (convI h1)) (cons a l) (tl vnl) vsl) (sem_rec (sem g) (sem h0) (sem h1) (cons a l) (tl vnl) vsl)
+++++
simpl.
-----
Lemma convI_correct : forall e n s, arities e = ok_arities n s -> forall vnl vsl, semI (convI e) vnl vsl = sem e vnl vsl.
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.
trivial.
induction (hd nil vnl).
simpl.

*****
IHl : eq\n (sem_rec (semI (convI g)) (semI (convI h0)) (semI (convI h1)) l\n (tl vnl) vsl) (sem_rec (sem g) (sem h0) (sem h1) l (tl vnl) vsl)
l : list bool
a : bool
vnl,vsl : list (list bool)
H4 : forall vnl vsl : list (list bool),\neq (semI (convI h1) vnl vsl) (sem h1 vnl vsl)
H3 : forall vnl vsl : list (list bool),\neq (semI (convI h0) vnl vsl) (sem h0 vnl vsl)
H2 : forall vnl vsl : list (list bool),\neq (semI (convI g) vnl vsl) (sem g vnl vsl)
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
*****
eq (if a then semI (convI h1) (cons l (tl vnl)) (cons (sem_rec (semI (convI g)) (semI (convI h0)) (semI (convI h1)) l (tl vnl) vsl) vsl) else semI (convI h0) (cons l (tl vnl)) (cons (sem_rec (semI (convI g)) (semI (convI h0)) (semI (convI h1)) l (tl vnl) vsl) vsl)) (if a then sem h1 (cons l (tl vnl)) (cons (sem_rec (sem g) (sem h0) (sem h1) l (tl vnl) vsl) vsl) else sem h0 (cons l (tl vnl)) (cons (sem_rec (sem g) (sem h0) (sem h1) l (tl vnl) vsl) vsl))
+++++
intros.
-----
Lemma convI_correct : forall e n s, arities e = ok_arities n s -> forall vnl vsl, semI (convI e) vnl vsl = sem e vnl vsl.
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.
trivial.
induction (hd nil vnl).
simpl.
intros.

*****
IHl : eq\n (sem_rec (semI (convI g)) (semI (convI h0)) (semI (convI h1)) l\n (tl vnl) vsl) (sem_rec (sem g) (sem h0) (sem h1) l (tl vnl) vsl)
l : list bool
a : bool
vnl,vsl : list (list bool)
H4 : forall vnl vsl : list (list bool),\neq (semI (convI h1) vnl vsl) (sem h1 vnl vsl)
H3 : forall vnl vsl : list (list bool),\neq (semI (convI h0) vnl vsl) (sem h0 vnl vsl)
H2 : forall vnl vsl : list (list bool),\neq (semI (convI g) vnl vsl) (sem g vnl vsl)
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
*****
eq (if a then semI (convI h1) (cons l (tl vnl)) (cons (sem_rec (semI (convI g)) (semI (convI h0)) (semI (convI h1)) l (tl vnl) vsl) vsl) else semI (convI h0) (cons l (tl vnl)) (cons (sem_rec (semI (convI g)) (semI (convI h0)) (semI (convI h1)) l (tl vnl) vsl) vsl)) (if a then sem h1 (cons l (tl vnl)) (cons (sem_rec (sem g) (sem h0) (sem h1) l (tl vnl) vsl) vsl) else sem h0 (cons l (tl vnl)) (cons (sem_rec (sem g) (sem h0) (sem h1) l (tl vnl) vsl) vsl))
+++++
auto.
-----
Lemma convI_correct : forall e n s, arities e = ok_arities n s -> forall vnl vsl, semI (convI e) vnl vsl = sem e vnl vsl.
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.
trivial.
induction (hd nil vnl).
simpl.
intros.
auto.

*****
IHl : eq\n (sem_rec (semI (convI g)) (semI (convI h0)) (semI (convI h1)) l\n (tl vnl) vsl) (sem_rec (sem g) (sem h0) (sem h1) l (tl vnl) vsl)
l : list bool
a : bool
vnl,vsl : list (list bool)
H4 : forall vnl vsl : list (list bool),\neq (semI (convI h1) vnl vsl) (sem h1 vnl vsl)
H3 : forall vnl vsl : list (list bool),\neq (semI (convI h0) vnl vsl) (sem h0 vnl vsl)
H2 : forall vnl vsl : list (list bool),\neq (semI (convI g) vnl vsl) (sem g vnl vsl)
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
*****
eq (if a then semI (convI h1) (cons l (tl vnl)) (cons (sem_rec (semI (convI g)) (semI (convI h0)) (semI (convI h1)) l (tl vnl) vsl) vsl) else semI (convI h0) (cons l (tl vnl)) (cons (sem_rec (semI (convI g)) (semI (convI h0)) (semI (convI h1)) l (tl vnl) vsl) vsl)) (if a then sem h1 (cons l (tl vnl)) (cons (sem_rec (sem g) (sem h0) (sem h1) l (tl vnl) vsl) vsl) else sem h0 (cons l (tl vnl)) (cons (sem_rec (sem g) (sem h0) (sem h1) l (tl vnl) vsl) vsl))
+++++
rewrite IHl.
-----
Lemma convI_correct : forall e n s, arities e = ok_arities n s -> forall vnl vsl, semI (convI e) vnl vsl = sem e vnl vsl.
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.
trivial.
induction (hd nil vnl).
simpl.
intros.
auto.
rewrite IHl.

*****
IHl : eq\n (sem_rec (semI (convI g)) (semI (convI h0)) (semI (convI h1)) l\n (tl vnl) vsl) (sem_rec (sem g) (sem h0) (sem h1) l (tl vnl) vsl)
l : list bool
a : bool
vnl,vsl : list (list bool)
H4 : forall vnl vsl : list (list bool),\neq (semI (convI h1) vnl vsl) (sem h1 vnl vsl)
H3 : forall vnl vsl : list (list bool),\neq (semI (convI h0) vnl vsl) (sem h0 vnl vsl)
H2 : forall vnl vsl : list (list bool),\neq (semI (convI g) vnl vsl) (sem g vnl vsl)
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
*****
eq (if a then semI (convI h1) (cons l (tl vnl)) (cons (sem_rec (sem g) (sem h0) (sem h1) l (tl vnl) vsl) vsl) else semI (convI h0) (cons l (tl vnl)) (cons (sem_rec (sem g) (sem h0) (sem h1) l (tl vnl) vsl) vsl)) (if a then sem h1 (cons l (tl vnl)) (cons (sem_rec (sem g) (sem h0) (sem h1) l (tl vnl) vsl) vsl) else sem h0 (cons l (tl vnl)) (cons (sem_rec (sem g) (sem h0) (sem h1) l (tl vnl) vsl) vsl))
+++++
case a.
-----
Lemma convI_correct : forall e n s, arities e = ok_arities n s -> forall vnl vsl, semI (convI e) vnl vsl = sem e vnl vsl.
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.
trivial.
induction (hd nil vnl).
simpl.
intros.
auto.
rewrite IHl.
case a.

*****
IHl : eq\n (sem_rec (semI (convI g)) (semI (convI h0)) (semI (convI h1)) l\n (tl vnl) vsl) (sem_rec (sem g) (sem h0) (sem h1) l (tl vnl) vsl)
l : list bool
a : bool
vnl,vsl : list (list bool)
H4 : forall vnl vsl : list (list bool),\neq (semI (convI h1) vnl vsl) (sem h1 vnl vsl)
H3 : forall vnl vsl : list (list bool),\neq (semI (convI h0) vnl vsl) (sem h0 vnl vsl)
H2 : forall vnl vsl : list (list bool),\neq (semI (convI g) vnl vsl) (sem g vnl vsl)
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
*****
eq (semI (convI h1) (cons l (tl vnl)) (cons (sem_rec (sem g) (sem h0) (sem h1) l (tl vnl) vsl) vsl)) (sem h1 (cons l (tl vnl)) (cons (sem_rec (sem g) (sem h0) (sem h1) l (tl vnl) vsl) vsl))
+++++
auto.
-----
Lemma convI_correct : forall e n s, arities e = ok_arities n s -> forall vnl vsl, semI (convI e) vnl vsl = sem e vnl vsl.
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.
trivial.
induction (hd nil vnl).
simpl.
intros.
auto.
rewrite IHl.
case a.

*****
IHl : eq\n (sem_rec (semI (convI g)) (semI (convI h0)) (semI (convI h1)) l\n (tl vnl) vsl) (sem_rec (sem g) (sem h0) (sem h1) l (tl vnl) vsl)
l : list bool
a : bool
vnl,vsl : list (list bool)
H4 : forall vnl vsl : list (list bool),\neq (semI (convI h1) vnl vsl) (sem h1 vnl vsl)
H3 : forall vnl vsl : list (list bool),\neq (semI (convI h0) vnl vsl) (sem h0 vnl vsl)
H2 : forall vnl vsl : list (list bool),\neq (semI (convI g) vnl vsl) (sem g vnl vsl)
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
*****
eq (semI (convI h0) (cons l (tl vnl)) (cons (sem_rec (sem g) (sem h0) (sem h1) l (tl vnl) vsl) vsl)) (sem h0 (cons l (tl vnl)) (cons (sem_rec (sem g) (sem h0) (sem h1) l (tl vnl) vsl) vsl))
+++++
auto.
-----
Lemma convI_correct : forall e n s, arities e = ok_arities n s -> forall vnl vsl, semI (convI e) vnl vsl = sem e vnl vsl.
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _).

*****

*****
forall (n s : nat) (h : BC) (rl tl : list BC) (_ : eq (arities h) (ok_arities (length rl) (length tl))) (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n Datatypes.O)) (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)) (_ : forall vnl vsl : list (list bool), eq (semI (convI h) vnl vsl) (sem h vnl vsl)) (_ : forall (r : BC) (_ : In r rl) (vnl vsl : list (list bool)), eq (semI (convI r) vnl vsl) (sem r vnl vsl)) (_ : forall (r : BC) (_ : In r tl) (vnl vsl : list (list bool)), eq (semI (convI r) vnl vsl) (sem r vnl vsl)) (vnl vsl : list (list bool)), eq (semI (convI (comp n s h rl tl)) vnl vsl) (sem (comp n s h rl tl) vnl vsl)
+++++
simpl.
-----
Lemma convI_correct : forall e n s, arities e = ok_arities n s -> forall vnl vsl, semI (convI e) vnl vsl = sem e vnl vsl.
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.

*****

*****
forall (n s : nat) (h : BC) (rl tl : list BC) (_ : eq (arities h) (ok_arities (length rl) (length tl))) (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n Datatypes.O)) (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)) (_ : forall vnl vsl : list (list bool), eq (semI (convI h) vnl vsl) (sem h vnl vsl)) (_ : forall (r : BC) (_ : In r rl) (vnl vsl : list (list bool)), eq (semI (convI r) vnl vsl) (sem r vnl vsl)) (_ : forall (r : BC) (_ : In r tl) (vnl vsl : list (list bool)), eq (semI (convI r) vnl vsl) (sem r vnl vsl)) (vnl vsl : list (list bool)), eq (semI (convI h) (map (fun ne : BCI => semI ne vnl nil) (map convI rl)) (map (fun se : BCI => semI se vnl vsl) (map convI tl))) (sem h (map (fun ne : BC => sem ne vnl nil) rl) (map (fun se : BC => sem se vnl vsl) tl))
+++++
intros.
-----
Lemma convI_correct : forall e n s, arities e = ok_arities n s -> forall vnl vsl, semI (convI e) vnl vsl = sem e vnl vsl.
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.

*****
vnl,vsl : list (list bool)
H4 : forall (r : BC) (_ : In r tl) (vnl vsl : list (list bool)),\neq (semI (convI r) vnl vsl) (sem r vnl vsl)
H3 : forall (r : BC) (_ : In r rl) (vnl vsl : list (list bool)),\neq (semI (convI r) vnl vsl) (sem r vnl vsl)
H2 : forall vnl vsl : list (list bool),\neq (semI (convI h) vnl vsl) (sem h vnl vsl)
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl),\neq (arities e) (ok_arities n Datatypes.O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
eq (semI (convI h) (map (fun ne : BCI => semI ne vnl nil) (map convI rl)) (map (fun se : BCI => semI se vnl vsl) (map convI tl))) (sem h (map (fun ne : BC => sem ne vnl nil) rl) (map (fun se : BC => sem se vnl vsl) tl))
+++++
trivial.
-----
Lemma convI_correct : forall e n s, arities e = ok_arities n s -> forall vnl vsl, semI (convI e) vnl vsl = sem e vnl vsl.
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.
trivial.

*****
vnl,vsl : list (list bool)
H4 : forall (r : BC) (_ : In r tl) (vnl vsl : list (list bool)),\neq (semI (convI r) vnl vsl) (sem r vnl vsl)
H3 : forall (r : BC) (_ : In r rl) (vnl vsl : list (list bool)),\neq (semI (convI r) vnl vsl) (sem r vnl vsl)
H2 : forall vnl vsl : list (list bool),\neq (semI (convI h) vnl vsl) (sem h vnl vsl)
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl),\neq (arities e) (ok_arities n Datatypes.O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
eq (semI (convI h) (map (fun ne : BCI => semI ne vnl nil) (map convI rl)) (map (fun se : BCI => semI se vnl vsl) (map convI tl))) (sem h (map (fun ne : BC => sem ne vnl nil) rl) (map (fun se : BC => sem se vnl vsl) tl))
+++++
rewrite H2.
-----
Lemma convI_correct : forall e n s, arities e = ok_arities n s -> forall vnl vsl, semI (convI e) vnl vsl = sem e vnl vsl.
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.
trivial.
rewrite H2.

*****
vnl,vsl : list (list bool)
H4 : forall (r : BC) (_ : In r tl) (vnl vsl : list (list bool)),\neq (semI (convI r) vnl vsl) (sem r vnl vsl)
H3 : forall (r : BC) (_ : In r rl) (vnl vsl : list (list bool)),\neq (semI (convI r) vnl vsl) (sem r vnl vsl)
H2 : forall vnl vsl : list (list bool),\neq (semI (convI h) vnl vsl) (sem h vnl vsl)
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl),\neq (arities e) (ok_arities n Datatypes.O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
eq (sem h (map (fun ne : BCI => semI ne vnl nil) (map convI rl)) (map (fun se : BCI => semI se vnl vsl) (map convI tl))) (sem h (map (fun ne : BC => sem ne vnl nil) rl) (map (fun se : BC => sem se vnl vsl) tl))
+++++
f_equal.
-----
Lemma convI_correct : forall e n s, arities e = ok_arities n s -> forall vnl vsl, semI (convI e) vnl vsl = sem e vnl vsl.
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.
trivial.
rewrite H2.
f_equal.

*****
vnl,vsl : list (list bool)
H4 : forall (r : BC) (_ : In r tl) (vnl vsl : list (list bool)),\neq (semI (convI r) vnl vsl) (sem r vnl vsl)
H3 : forall (r : BC) (_ : In r rl) (vnl vsl : list (list bool)),\neq (semI (convI r) vnl vsl) (sem r vnl vsl)
H2 : forall vnl vsl : list (list bool),\neq (semI (convI h) vnl vsl) (sem h vnl vsl)
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl),\neq (arities e) (ok_arities n Datatypes.O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
eq (map (fun ne : BCI => semI ne vnl nil) (map convI rl)) (map (fun ne : BC => sem ne vnl nil) rl)
+++++
rewrite map_map.
-----
Lemma convI_correct : forall e n s, arities e = ok_arities n s -> forall vnl vsl, semI (convI e) vnl vsl = sem e vnl vsl.
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.
trivial.
rewrite H2.
f_equal.
rewrite map_map.

*****
vnl,vsl : list (list bool)
H4 : forall (r : BC) (_ : In r tl) (vnl vsl : list (list bool)),\neq (semI (convI r) vnl vsl) (sem r vnl vsl)
H3 : forall (r : BC) (_ : In r rl) (vnl vsl : list (list bool)),\neq (semI (convI r) vnl vsl) (sem r vnl vsl)
H2 : forall vnl vsl : list (list bool),\neq (semI (convI h) vnl vsl) (sem h vnl vsl)
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl),\neq (arities e) (ok_arities n Datatypes.O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
eq (map (fun x : BC => semI (convI x) vnl nil) rl) (map (fun ne : BC => sem ne vnl nil) rl)
+++++
apply map_ext2.
-----
Lemma convI_correct : forall e n s, arities e = ok_arities n s -> forall vnl vsl, semI (convI e) vnl vsl = sem e vnl vsl.
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.
trivial.
rewrite H2.
f_equal.
rewrite map_map.
apply map_ext2.

*****
vnl,vsl : list (list bool)
H4 : forall (r : BC) (_ : In r tl) (vnl vsl : list (list bool)),\neq (semI (convI r) vnl vsl) (sem r vnl vsl)
H3 : forall (r : BC) (_ : In r rl) (vnl vsl : list (list bool)),\neq (semI (convI r) vnl vsl) (sem r vnl vsl)
H2 : forall vnl vsl : list (list bool),\neq (semI (convI h) vnl vsl) (sem h vnl vsl)
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl),\neq (arities e) (ok_arities n Datatypes.O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
forall (a : BC) (_ : In a rl), eq (semI (convI a) vnl nil) (sem a vnl nil)
+++++
auto.
-----
Lemma convI_correct : forall e n s, arities e = ok_arities n s -> forall vnl vsl, semI (convI e) vnl vsl = sem e vnl vsl.
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.
trivial.
rewrite H2.
f_equal.

*****
vnl,vsl : list (list bool)
H4 : forall (r : BC) (_ : In r tl) (vnl vsl : list (list bool)),\neq (semI (convI r) vnl vsl) (sem r vnl vsl)
H3 : forall (r : BC) (_ : In r rl) (vnl vsl : list (list bool)),\neq (semI (convI r) vnl vsl) (sem r vnl vsl)
H2 : forall vnl vsl : list (list bool),\neq (semI (convI h) vnl vsl) (sem h vnl vsl)
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl),\neq (arities e) (ok_arities n Datatypes.O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
eq (map (fun se : BCI => semI se vnl vsl) (map convI tl)) (map (fun se : BC => sem se vnl vsl) tl)
+++++
rewrite map_map.
-----
Lemma convI_correct : forall e n s, arities e = ok_arities n s -> forall vnl vsl, semI (convI e) vnl vsl = sem e vnl vsl.
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.
trivial.
rewrite H2.
f_equal.
rewrite map_map.

*****
vnl,vsl : list (list bool)
H4 : forall (r : BC) (_ : In r tl) (vnl vsl : list (list bool)),\neq (semI (convI r) vnl vsl) (sem r vnl vsl)
H3 : forall (r : BC) (_ : In r rl) (vnl vsl : list (list bool)),\neq (semI (convI r) vnl vsl) (sem r vnl vsl)
H2 : forall vnl vsl : list (list bool),\neq (semI (convI h) vnl vsl) (sem h vnl vsl)
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl),\neq (arities e) (ok_arities n Datatypes.O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
eq (map (fun x : BC => semI (convI x) vnl vsl) tl) (map (fun se : BC => sem se vnl vsl) tl)
+++++
apply map_ext2.
-----
Lemma convI_correct : forall e n s, arities e = ok_arities n s -> forall vnl vsl, semI (convI e) vnl vsl = sem e vnl vsl.
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.
trivial.
rewrite H2.
f_equal.
rewrite map_map.
apply map_ext2.

*****
vnl,vsl : list (list bool)
H4 : forall (r : BC) (_ : In r tl) (vnl vsl : list (list bool)),\neq (semI (convI r) vnl vsl) (sem r vnl vsl)
H3 : forall (r : BC) (_ : In r rl) (vnl vsl : list (list bool)),\neq (semI (convI r) vnl vsl) (sem r vnl vsl)
H2 : forall vnl vsl : list (list bool),\neq (semI (convI h) vnl vsl) (sem h vnl vsl)
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl),\neq (arities e) (ok_arities n Datatypes.O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
forall (a : BC) (_ : In a tl), eq (semI (convI a) vnl vsl) (sem a vnl vsl)
+++++
auto.
-----
Lemma convI_correct : forall e n s, arities e = ok_arities n s -> forall vnl vsl, semI (convI e) vnl vsl = sem e vnl vsl.
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _).

*****

*****

+++++
Qed.
-----
