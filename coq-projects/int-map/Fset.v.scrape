From Coq Require Import Bool.
-----
Require Import Coq.Bool.Sumbool.
-----
Require Import Coq.NArith.NArith.
-----
Require Import Coq.NArith.Ndigits.
-----
Require Import Coq.NArith.Ndec.
-----
Require Import Map.
-----
Section Dom.
-----
Variables A B : Type.
-----
Fixpoint MapDomRestrTo (m:Map A) : Map B -> Map A :=\n    match m with\n    | M0 => fun _:Map B => M0 A\n    | M1 a y =>\n        fun m':Map B => match MapGet B m' a with\n                        | None => M0 A\n                        | _ => m\n                        end\n    | M2 m1 m2 =>\n        fun m':Map B =>\n          match m' with\n          | M0 => M0 A\n          | M1 a' y' =>\n              match MapGet A m a' with\n              | None => M0 A\n              | Some y => M1 A a' y\n              end\n          | M2 m'1 m'2 =>\n              makeM2 A (MapDomRestrTo m1 m'1) (MapDomRestrTo m2 m'2)\n          end\n    end.
-----
Lemma MapDomRestrTo_semantics :\n   forall (m:Map A) (m':Map B),\n     eqm A (MapGet A (MapDomRestrTo m m'))\n       (fun a0:ad =>\n          match MapGet B m' a0 with\n          | None => None\n          | _ => MapGet A m a0\n          end).
-----
Lemma MapDomRestrTo_semantics : forall (m:Map A) (m':Map B), eqm A (MapGet A (MapDomRestrTo m m')) (fun a0:ad => match MapGet B m' a0 with | None => None | _ => MapGet A m a0 end).

*****
A,B : Type
*****
forall (m : Map A) (m' : Map B), eqm A (MapGet A (MapDomRestrTo m m')) (fun a0 : ad => match MapGet B m' a0 with | Some _ => MapGet A m a0 | None => None end)
+++++
Proof.
-----
Lemma MapDomRestrTo_semantics : forall (m:Map A) (m':Map B), eqm A (MapGet A (MapDomRestrTo m m')) (fun a0:ad => match MapGet B m' a0 with | None => None | _ => MapGet A m a0 end).
Proof.

*****
A,B : Type
*****
forall (m : Map A) (m' : Map B), eqm A (MapGet A (MapDomRestrTo m m')) (fun a0 : ad => match MapGet B m' a0 with | Some _ => MapGet A m a0 | None => None end)
+++++
unfold eqm in |- *.
-----
Lemma MapDomRestrTo_semantics : forall (m:Map A) (m':Map B), eqm A (MapGet A (MapDomRestrTo m m')) (fun a0:ad => match MapGet B m' a0 with | None => None | _ => MapGet A m a0 end).
Proof.
unfold eqm in |- *.

*****
A,B : Type
*****
forall (m : Map A) (m' : Map B) (a : ad), eq (MapGet A (MapDomRestrTo m m') a) match MapGet B m' a with | Some _ => MapGet A m a | None => None end
+++++
simple induction m.
-----
Lemma MapDomRestrTo_semantics : forall (m:Map A) (m':Map B), eqm A (MapGet A (MapDomRestrTo m m')) (fun a0:ad => match MapGet B m' a0 with | None => None | _ => MapGet A m a0 end).
Proof.
unfold eqm in |- *.
simple induction m.

*****
m : Map A
A,B : Type
*****
forall (m' : Map B) (a : ad), eq (MapGet A (MapDomRestrTo (M0 A) m') a) match MapGet B m' a with | Some _ => MapGet A (M0 A) a | None => None end
+++++
simpl in |- *.
-----
Lemma MapDomRestrTo_semantics : forall (m:Map A) (m':Map B), eqm A (MapGet A (MapDomRestrTo m m')) (fun a0:ad => match MapGet B m' a0 with | None => None | _ => MapGet A m a0 end).
Proof.
unfold eqm in |- *.
simple induction m.
simpl in |- *.

*****
m : Map A
A,B : Type
*****
forall (m' : Map B) (a : ad), eq None match MapGet B m' a with | Some _ | _ => None end
+++++
intros.
-----
Lemma MapDomRestrTo_semantics : forall (m:Map A) (m':Map B), eqm A (MapGet A (MapDomRestrTo m m')) (fun a0:ad => match MapGet B m' a0 with | None => None | _ => MapGet A m a0 end).
Proof.
unfold eqm in |- *.
simple induction m.
simpl in |- *.
intros.

*****
a : ad
m' : Map B
m : Map A
A,B : Type
*****
eq None match MapGet B m' a with | Some _ | _ => None end
+++++
case (MapGet B m' a).
-----
Lemma MapDomRestrTo_semantics : forall (m:Map A) (m':Map B), eqm A (MapGet A (MapDomRestrTo m m')) (fun a0:ad => match MapGet B m' a0 with | None => None | _ => MapGet A m a0 end).
Proof.
unfold eqm in |- *.
simple induction m.
simpl in |- *.
intros.
case (MapGet B m' a).

*****
a : ad
m' : Map B
m : Map A
A,B : Type
*****
forall _ : B, eq None None
+++++
trivial.
-----
Lemma MapDomRestrTo_semantics : forall (m:Map A) (m':Map B), eqm A (MapGet A (MapDomRestrTo m m')) (fun a0:ad => match MapGet B m' a0 with | None => None | _ => MapGet A m a0 end).
Proof.
unfold eqm in |- *.
simple induction m.
simpl in |- *.
intros.
case (MapGet B m' a).

*****
a : ad
m' : Map B
m : Map A
A,B : Type
*****
eq None None
+++++
trivial.
-----
Lemma MapDomRestrTo_semantics : forall (m:Map A) (m':Map B), eqm A (MapGet A (MapDomRestrTo m m')) (fun a0:ad => match MapGet B m' a0 with | None => None | _ => MapGet A m a0 end).
Proof.
unfold eqm in |- *.
simple induction m.

*****
m : Map A
A,B : Type
*****
forall (a : ad) (a0 : A) (m' : Map B) (a1 : ad), eq (MapGet A (MapDomRestrTo (M1 A a a0) m') a1) match MapGet B m' a1 with | Some _ => MapGet A (M1 A a a0) a1 | None => None end
+++++
intros.
-----
Lemma MapDomRestrTo_semantics : forall (m:Map A) (m':Map B), eqm A (MapGet A (MapDomRestrTo m m')) (fun a0:ad => match MapGet B m' a0 with | None => None | _ => MapGet A m a0 end).
Proof.
unfold eqm in |- *.
simple induction m.
intros.

*****
a1 : ad
m' : Map B
a0 : A
a : ad
m : Map A
A,B : Type
*****
eq (MapGet A (MapDomRestrTo (M1 A a a0) m') a1) match MapGet B m' a1 with | Some _ => MapGet A (M1 A a a0) a1 | None => None end
+++++
simpl in |- *.
-----
Lemma MapDomRestrTo_semantics : forall (m:Map A) (m':Map B), eqm A (MapGet A (MapDomRestrTo m m')) (fun a0:ad => match MapGet B m' a0 with | None => None | _ => MapGet A m a0 end).
Proof.
unfold eqm in |- *.
simple induction m.
intros.
simpl in |- *.

*****
a1 : ad
m' : Map B
a0 : A
a : ad
m : Map A
A,B : Type
*****
eq (MapGet A match MapGet B m' a with | Some _ => M1 A a a0 | None => M0 A end a1) match MapGet B m' a1 with | Some _ => if N.eqb a a1 then Some a0 else None | None => None end
+++++
elim (sumbool_of_bool (Neqb a a1)).
-----
Lemma MapDomRestrTo_semantics : forall (m:Map A) (m':Map B), eqm A (MapGet A (MapDomRestrTo m m')) (fun a0:ad => match MapGet B m' a0 with | None => None | _ => MapGet A m a0 end).
Proof.
unfold eqm in |- *.
simple induction m.
intros.
simpl in |- *.
elim (sumbool_of_bool (Neqb a a1)).

*****
a1 : ad
m' : Map B
a0 : A
a : ad
m : Map A
A,B : Type
*****
forall _ : eq (N.eqb a a1) true, eq (MapGet A match MapGet B m' a with | Some _ => M1 A a a0 | None => M0 A end a1) match MapGet B m' a1 with | Some _ => if N.eqb a a1 then Some a0 else None | None => None end
+++++
intro H.
-----
Lemma MapDomRestrTo_semantics : forall (m:Map A) (m':Map B), eqm A (MapGet A (MapDomRestrTo m m')) (fun a0:ad => match MapGet B m' a0 with | None => None | _ => MapGet A m a0 end).
Proof.
unfold eqm in |- *.
simple induction m.
intros.
simpl in |- *.
elim (sumbool_of_bool (Neqb a a1)).
intro H.

*****
H : eq (N.eqb a a1) true
a1 : ad
m' : Map B
a0 : A
a : ad
m : Map A
A,B : Type
*****
eq (MapGet A match MapGet B m' a with | Some _ => M1 A a a0 | None => M0 A end a1) match MapGet B m' a1 with | Some _ => if N.eqb a a1 then Some a0 else None | None => None end
+++++
rewrite H.
-----
Lemma MapDomRestrTo_semantics : forall (m:Map A) (m':Map B), eqm A (MapGet A (MapDomRestrTo m m')) (fun a0:ad => match MapGet B m' a0 with | None => None | _ => MapGet A m a0 end).
Proof.
unfold eqm in |- *.
simple induction m.
intros.
simpl in |- *.
elim (sumbool_of_bool (Neqb a a1)).
intro H.
rewrite H.

*****
H : eq (N.eqb a a1) true
a1 : ad
m' : Map B
a0 : A
a : ad
m : Map A
A,B : Type
*****
eq (MapGet A match MapGet B m' a with | Some _ => M1 A a a0 | None => M0 A end a1) match MapGet B m' a1 with | Some _ => Some a0 | None => None end
+++++
rewrite <- (Neqb_complete _ _ H).
-----
Lemma MapDomRestrTo_semantics : forall (m:Map A) (m':Map B), eqm A (MapGet A (MapDomRestrTo m m')) (fun a0:ad => match MapGet B m' a0 with | None => None | _ => MapGet A m a0 end).
Proof.
unfold eqm in |- *.
simple induction m.
intros.
simpl in |- *.
elim (sumbool_of_bool (Neqb a a1)).
intro H.
rewrite H.
rewrite <- (Neqb_complete _ _ H).

*****
H : eq (N.eqb a a1) true
a1 : ad
m' : Map B
a0 : A
a : ad
m : Map A
A,B : Type
*****
eq (MapGet A match MapGet B m' a with | Some _ => M1 A a a0 | None => M0 A end a) match MapGet B m' a with | Some _ => Some a0 | None => None end
+++++
case (MapGet B m' a).
-----
Lemma MapDomRestrTo_semantics : forall (m:Map A) (m':Map B), eqm A (MapGet A (MapDomRestrTo m m')) (fun a0:ad => match MapGet B m' a0 with | None => None | _ => MapGet A m a0 end).
Proof.
unfold eqm in |- *.
simple induction m.
intros.
simpl in |- *.
elim (sumbool_of_bool (Neqb a a1)).
intro H.
rewrite H.
rewrite <- (Neqb_complete _ _ H).
case (MapGet B m' a).

*****
H : eq (N.eqb a a1) true
a1 : ad
m' : Map B
a0 : A
a : ad
m : Map A
A,B : Type
*****
forall _ : B, eq (MapGet A (M1 A a a0) a) (Some a0)
+++++
try reflexivity.
-----
Lemma MapDomRestrTo_semantics : forall (m:Map A) (m':Map B), eqm A (MapGet A (MapDomRestrTo m m')) (fun a0:ad => match MapGet B m' a0 with | None => None | _ => MapGet A m a0 end).
Proof.
unfold eqm in |- *.
simple induction m.
intros.
simpl in |- *.
elim (sumbool_of_bool (Neqb a a1)).
intro H.
rewrite H.
rewrite <- (Neqb_complete _ _ H).
case (MapGet B m' a).
try reflexivity.

*****
H : eq (N.eqb a a1) true
a1 : ad
m' : Map B
a0 : A
a : ad
m : Map A
A,B : Type
*****
forall _ : B, eq (MapGet A (M1 A a a0) a) (Some a0)
+++++
intro.
-----
Lemma MapDomRestrTo_semantics : forall (m:Map A) (m':Map B), eqm A (MapGet A (MapDomRestrTo m m')) (fun a0:ad => match MapGet B m' a0 with | None => None | _ => MapGet A m a0 end).
Proof.
unfold eqm in |- *.
simple induction m.
intros.
simpl in |- *.
elim (sumbool_of_bool (Neqb a a1)).
intro H.
rewrite H.
rewrite <- (Neqb_complete _ _ H).
case (MapGet B m' a).
try reflexivity.
intro.

*****
b : B
H : eq (N.eqb a a1) true
a1 : ad
m' : Map B
a0 : A
a : ad
m : Map A
A,B : Type
*****
eq (MapGet A (M1 A a a0) a) (Some a0)
+++++
apply M1_semantics_1.
-----
Lemma MapDomRestrTo_semantics : forall (m:Map A) (m':Map B), eqm A (MapGet A (MapDomRestrTo m m')) (fun a0:ad => match MapGet B m' a0 with | None => None | _ => MapGet A m a0 end).
Proof.
unfold eqm in |- *.
simple induction m.
intros.
simpl in |- *.
elim (sumbool_of_bool (Neqb a a1)).
intro H.
rewrite H.
rewrite <- (Neqb_complete _ _ H).
case (MapGet B m' a).

*****
H : eq (N.eqb a a1) true
a1 : ad
m' : Map B
a0 : A
a : ad
m : Map A
A,B : Type
*****
eq (MapGet A (M0 A) a) None
+++++
try reflexivity.
-----
Lemma MapDomRestrTo_semantics : forall (m:Map A) (m':Map B), eqm A (MapGet A (MapDomRestrTo m m')) (fun a0:ad => match MapGet B m' a0 with | None => None | _ => MapGet A m a0 end).
Proof.
unfold eqm in |- *.
simple induction m.
intros.
simpl in |- *.
elim (sumbool_of_bool (Neqb a a1)).

*****
a1 : ad
m' : Map B
a0 : A
a : ad
m : Map A
A,B : Type
*****
forall _ : eq (N.eqb a a1) false, eq (MapGet A match MapGet B m' a with | Some _ => M1 A a a0 | None => M0 A end a1) match MapGet B m' a1 with | Some _ => if N.eqb a a1 then Some a0 else None | None => None end
+++++
intro H.
-----
Lemma MapDomRestrTo_semantics : forall (m:Map A) (m':Map B), eqm A (MapGet A (MapDomRestrTo m m')) (fun a0:ad => match MapGet B m' a0 with | None => None | _ => MapGet A m a0 end).
Proof.
unfold eqm in |- *.
simple induction m.
intros.
simpl in |- *.
elim (sumbool_of_bool (Neqb a a1)).
intro H.

*****
H : eq (N.eqb a a1) false
a1 : ad
m' : Map B
a0 : A
a : ad
m : Map A
A,B : Type
*****
eq (MapGet A match MapGet B m' a with | Some _ => M1 A a a0 | None => M0 A end a1) match MapGet B m' a1 with | Some _ => if N.eqb a a1 then Some a0 else None | None => None end
+++++
rewrite H.
-----
Lemma MapDomRestrTo_semantics : forall (m:Map A) (m':Map B), eqm A (MapGet A (MapDomRestrTo m m')) (fun a0:ad => match MapGet B m' a0 with | None => None | _ => MapGet A m a0 end).
Proof.
unfold eqm in |- *.
simple induction m.
intros.
simpl in |- *.
elim (sumbool_of_bool (Neqb a a1)).
intro H.
rewrite H.

*****
H : eq (N.eqb a a1) false
a1 : ad
m' : Map B
a0 : A
a : ad
m : Map A
A,B : Type
*****
eq (MapGet A match MapGet B m' a with | Some _ => M1 A a a0 | None => M0 A end a1) match MapGet B m' a1 with | Some _ | _ => None end
+++++
case (MapGet B m' a).
-----
Lemma MapDomRestrTo_semantics : forall (m:Map A) (m':Map B), eqm A (MapGet A (MapDomRestrTo m m')) (fun a0:ad => match MapGet B m' a0 with | None => None | _ => MapGet A m a0 end).
Proof.
unfold eqm in |- *.
simple induction m.
intros.
simpl in |- *.
elim (sumbool_of_bool (Neqb a a1)).
intro H.
rewrite H.
case (MapGet B m' a).

*****
H : eq (N.eqb a a1) false
a1 : ad
m' : Map B
a0 : A
a : ad
m : Map A
A,B : Type
*****
forall _ : B, eq (MapGet A (M1 A a a0) a1) match MapGet B m' a1 with | Some _ | _ => None end
+++++
case (MapGet B m' a1).
-----
Lemma MapDomRestrTo_semantics : forall (m:Map A) (m':Map B), eqm A (MapGet A (MapDomRestrTo m m')) (fun a0:ad => match MapGet B m' a0 with | None => None | _ => MapGet A m a0 end).
Proof.
unfold eqm in |- *.
simple induction m.
intros.
simpl in |- *.
elim (sumbool_of_bool (Neqb a a1)).
intro H.
rewrite H.
case (MapGet B m' a).
case (MapGet B m' a1).

*****
H : eq (N.eqb a a1) false
a1 : ad
m' : Map B
a0 : A
a : ad
m : Map A
A,B : Type
*****
forall (_ : B) (_ : B), eq (MapGet A (M1 A a a0) a1) None
+++++
intros.
-----
Lemma MapDomRestrTo_semantics : forall (m:Map A) (m':Map B), eqm A (MapGet A (MapDomRestrTo m m')) (fun a0:ad => match MapGet B m' a0 with | None => None | _ => MapGet A m a0 end).
Proof.
unfold eqm in |- *.
simple induction m.
intros.
simpl in |- *.
elim (sumbool_of_bool (Neqb a a1)).
intro H.
rewrite H.
case (MapGet B m' a).
case (MapGet B m' a1).
intros.

*****
b,b0 : B
H : eq (N.eqb a a1) false
a1 : ad
m' : Map B
a0 : A
a : ad
m : Map A
A,B : Type
*****
eq (MapGet A (M1 A a a0) a1) None
+++++
exact (M1_semantics_2 A a a1 a0 H).
-----
Lemma MapDomRestrTo_semantics : forall (m:Map A) (m':Map B), eqm A (MapGet A (MapDomRestrTo m m')) (fun a0:ad => match MapGet B m' a0 with | None => None | _ => MapGet A m a0 end).
Proof.
unfold eqm in |- *.
simple induction m.
intros.
simpl in |- *.
elim (sumbool_of_bool (Neqb a a1)).
intro H.
rewrite H.
case (MapGet B m' a).
case (MapGet B m' a1).

*****
H : eq (N.eqb a a1) false
a1 : ad
m' : Map B
a0 : A
a : ad
m : Map A
A,B : Type
*****
forall _ : B, eq (MapGet A (M1 A a a0) a1) None
+++++
intros.
-----
Lemma MapDomRestrTo_semantics : forall (m:Map A) (m':Map B), eqm A (MapGet A (MapDomRestrTo m m')) (fun a0:ad => match MapGet B m' a0 with | None => None | _ => MapGet A m a0 end).
Proof.
unfold eqm in |- *.
simple induction m.
intros.
simpl in |- *.
elim (sumbool_of_bool (Neqb a a1)).
intro H.
rewrite H.
case (MapGet B m' a).
case (MapGet B m' a1).
intros.

*****
b : B
H : eq (N.eqb a a1) false
a1 : ad
m' : Map B
a0 : A
a : ad
m : Map A
A,B : Type
*****
eq (MapGet A (M1 A a a0) a1) None
+++++
exact (M1_semantics_2 A a a1 a0 H).
-----
Lemma MapDomRestrTo_semantics : forall (m:Map A) (m':Map B), eqm A (MapGet A (MapDomRestrTo m m')) (fun a0:ad => match MapGet B m' a0 with | None => None | _ => MapGet A m a0 end).
Proof.
unfold eqm in |- *.
simple induction m.
intros.
simpl in |- *.
elim (sumbool_of_bool (Neqb a a1)).
intro H.
rewrite H.
case (MapGet B m' a).

*****
H : eq (N.eqb a a1) false
a1 : ad
m' : Map B
a0 : A
a : ad
m : Map A
A,B : Type
*****
eq (MapGet A (M0 A) a1) match MapGet B m' a1 with | Some _ | _ => None end
+++++
case (MapGet B m' a1).
-----
Lemma MapDomRestrTo_semantics : forall (m:Map A) (m':Map B), eqm A (MapGet A (MapDomRestrTo m m')) (fun a0:ad => match MapGet B m' a0 with | None => None | _ => MapGet A m a0 end).
Proof.
unfold eqm in |- *.
simple induction m.
intros.
simpl in |- *.
elim (sumbool_of_bool (Neqb a a1)).
intro H.
rewrite H.
case (MapGet B m' a).
case (MapGet B m' a1).

*****
H : eq (N.eqb a a1) false
a1 : ad
m' : Map B
a0 : A
a : ad
m : Map A
A,B : Type
*****
forall _ : B, eq (MapGet A (M0 A) a1) None
+++++
reflexivity.
-----
Lemma MapDomRestrTo_semantics : forall (m:Map A) (m':Map B), eqm A (MapGet A (MapDomRestrTo m m')) (fun a0:ad => match MapGet B m' a0 with | None => None | _ => MapGet A m a0 end).
Proof.
unfold eqm in |- *.
simple induction m.
intros.
simpl in |- *.
elim (sumbool_of_bool (Neqb a a1)).
intro H.
rewrite H.
case (MapGet B m' a).
case (MapGet B m' a1).

*****
H : eq (N.eqb a a1) false
a1 : ad
m' : Map B
a0 : A
a : ad
m : Map A
A,B : Type
*****
eq (MapGet A (M0 A) a1) None
+++++
reflexivity.
-----
Lemma MapDomRestrTo_semantics : forall (m:Map A) (m':Map B), eqm A (MapGet A (MapDomRestrTo m m')) (fun a0:ad => match MapGet B m' a0 with | None => None | _ => MapGet A m a0 end).
Proof.
unfold eqm in |- *.
simple induction m.

*****
m : Map A
A,B : Type
*****
forall (m : Map A) (_ : forall (m' : Map B) (a : ad), eq (MapGet A (MapDomRestrTo m m') a) match MapGet B m' a with | Some _ => MapGet A m a | None => None end) (m0 : Map A) (_ : forall (m' : Map B) (a : ad), eq (MapGet A (MapDomRestrTo m0 m') a) match MapGet B m' a with | Some _ => MapGet A m0 a | None => None end) (m' : Map B) (a : ad), eq (MapGet A (MapDomRestrTo (M2 A m m0) m') a) match MapGet B m' a with | Some _ => MapGet A (M2 A m m0) a | None => None end
+++++
simple induction m'.
-----
Lemma MapDomRestrTo_semantics : forall (m:Map A) (m':Map B), eqm A (MapGet A (MapDomRestrTo m m')) (fun a0:ad => match MapGet B m' a0 with | None => None | _ => MapGet A m a0 end).
Proof.
unfold eqm in |- *.
simple induction m.
simple induction m'.

*****
m' : Map B
H0 : forall (m' : Map B) (a : ad),\neq (MapGet A (MapDomRestrTo m1 m') a)\n match MapGet B m' a with\n | Some _ => MapGet A m1 a\n | None => None\n end
m1 : Map A
H : forall (m' : Map B) (a : ad),\neq (MapGet A (MapDomRestrTo m0 m') a)\n match MapGet B m' a with\n | Some _ => MapGet A m0 a\n | None => None\n end
m,m0 : Map A
A,B : Type
*****
forall a : ad, eq (MapGet A (MapDomRestrTo (M2 A m0 m1) (M0 B)) a) match MapGet B (M0 B) a with | Some _ => MapGet A (M2 A m0 m1) a | None => None end
+++++
trivial.
-----
Lemma MapDomRestrTo_semantics : forall (m:Map A) (m':Map B), eqm A (MapGet A (MapDomRestrTo m m')) (fun a0:ad => match MapGet B m' a0 with | None => None | _ => MapGet A m a0 end).
Proof.
unfold eqm in |- *.
simple induction m.
simple induction m'.

*****
m' : Map B
H0 : forall (m' : Map B) (a : ad),\neq (MapGet A (MapDomRestrTo m1 m') a)\n match MapGet B m' a with\n | Some _ => MapGet A m1 a\n | None => None\n end
m1 : Map A
H : forall (m' : Map B) (a : ad),\neq (MapGet A (MapDomRestrTo m0 m') a)\n match MapGet B m' a with\n | Some _ => MapGet A m0 a\n | None => None\n end
m,m0 : Map A
A,B : Type
*****
forall (a : ad) (a0 : B) (a1 : ad), eq (MapGet A (MapDomRestrTo (M2 A m0 m1) (M1 B a a0)) a1) match MapGet B (M1 B a a0) a1 with | Some _ => MapGet A (M2 A m0 m1) a1 | None => None end
+++++
unfold MapDomRestrTo in |- *.
-----
Lemma MapDomRestrTo_semantics : forall (m:Map A) (m':Map B), eqm A (MapGet A (MapDomRestrTo m m')) (fun a0:ad => match MapGet B m' a0 with | None => None | _ => MapGet A m a0 end).
Proof.
unfold eqm in |- *.
simple induction m.
simple induction m'.
unfold MapDomRestrTo in |- *.

*****
m' : Map B
H0 : forall (m' : Map B) (a : ad),\neq (MapGet A (MapDomRestrTo m1 m') a)\n match MapGet B m' a with\n | Some _ => MapGet A m1 a\n | None => None\n end
m1 : Map A
H : forall (m' : Map B) (a : ad),\neq (MapGet A (MapDomRestrTo m0 m') a)\n match MapGet B m' a with\n | Some _ => MapGet A m0 a\n | None => None\n end
m,m0 : Map A
A,B : Type
*****
forall (a : ad) (a0 : B) (a1 : ad), eq (MapGet A match MapGet A (M2 A m0 m1) a with | Some y => M1 A a y | None => M0 A end a1) match MapGet B (M1 B a a0) a1 with | Some _ => MapGet A (M2 A m0 m1) a1 | None => None end
+++++
intros.
-----
Lemma MapDomRestrTo_semantics : forall (m:Map A) (m':Map B), eqm A (MapGet A (MapDomRestrTo m m')) (fun a0:ad => match MapGet B m' a0 with | None => None | _ => MapGet A m a0 end).
Proof.
unfold eqm in |- *.
simple induction m.
simple induction m'.
unfold MapDomRestrTo in |- *.
intros.

*****
a1 : ad
a0 : B
a : ad
m' : Map B
H0 : forall (m' : Map B) (a : ad),\neq (MapGet A (MapDomRestrTo m1 m') a)\n match MapGet B m' a with\n | Some _ => MapGet A m1 a\n | None => None\n end
m1 : Map A
H : forall (m' : Map B) (a : ad),\neq (MapGet A (MapDomRestrTo m0 m') a)\n match MapGet B m' a with\n | Some _ => MapGet A m0 a\n | None => None\n end
m,m0 : Map A
A,B : Type
*****
eq (MapGet A match MapGet A (M2 A m0 m1) a with | Some y => M1 A a y | None => M0 A end a1) match MapGet B (M1 B a a0) a1 with | Some _ => MapGet A (M2 A m0 m1) a1 | None => None end
+++++
elim (sumbool_of_bool (Neqb a a1)).
-----
Lemma MapDomRestrTo_semantics : forall (m:Map A) (m':Map B), eqm A (MapGet A (MapDomRestrTo m m')) (fun a0:ad => match MapGet B m' a0 with | None => None | _ => MapGet A m a0 end).
Proof.
unfold eqm in |- *.
simple induction m.
simple induction m'.
unfold MapDomRestrTo in |- *.
intros.
elim (sumbool_of_bool (Neqb a a1)).

*****
a1 : ad
a0 : B
a : ad
m' : Map B
H0 : forall (m' : Map B) (a : ad),\neq (MapGet A (MapDomRestrTo m1 m') a)\n match MapGet B m' a with\n | Some _ => MapGet A m1 a\n | None => None\n end
m1 : Map A
H : forall (m' : Map B) (a : ad),\neq (MapGet A (MapDomRestrTo m0 m') a)\n match MapGet B m' a with\n | Some _ => MapGet A m0 a\n | None => None\n end
m,m0 : Map A
A,B : Type
*****
forall _ : eq (N.eqb a a1) true, eq (MapGet A match MapGet A (M2 A m0 m1) a with | Some y => M1 A a y | None => M0 A end a1) match MapGet B (M1 B a a0) a1 with | Some _ => MapGet A (M2 A m0 m1) a1 | None => None end
+++++
intro H1.
-----
Lemma MapDomRestrTo_semantics : forall (m:Map A) (m':Map B), eqm A (MapGet A (MapDomRestrTo m m')) (fun a0:ad => match MapGet B m' a0 with | None => None | _ => MapGet A m a0 end).
Proof.
unfold eqm in |- *.
simple induction m.
simple induction m'.
unfold MapDomRestrTo in |- *.
intros.
elim (sumbool_of_bool (Neqb a a1)).
intro H1.

*****
H1 : eq (N.eqb a a1) true
a1 : ad
a0 : B
a : ad
m' : Map B
H0 : forall (m' : Map B) (a : ad),\neq (MapGet A (MapDomRestrTo m1 m') a)\n match MapGet B m' a with\n | Some _ => MapGet A m1 a\n | None => None\n end
m1 : Map A
H : forall (m' : Map B) (a : ad),\neq (MapGet A (MapDomRestrTo m0 m') a)\n match MapGet B m' a with\n | Some _ => MapGet A m0 a\n | None => None\n end
m,m0 : Map A
A,B : Type
*****
eq (MapGet A match MapGet A (M2 A m0 m1) a with | Some y => M1 A a y | None => M0 A end a1) match MapGet B (M1 B a a0) a1 with | Some _ => MapGet A (M2 A m0 m1) a1 | None => None end
+++++
rewrite (Neqb_complete _ _ H1).
-----
Lemma MapDomRestrTo_semantics : forall (m:Map A) (m':Map B), eqm A (MapGet A (MapDomRestrTo m m')) (fun a0:ad => match MapGet B m' a0 with | None => None | _ => MapGet A m a0 end).
Proof.
unfold eqm in |- *.
simple induction m.
simple induction m'.
unfold MapDomRestrTo in |- *.
intros.
elim (sumbool_of_bool (Neqb a a1)).
intro H1.
rewrite (Neqb_complete _ _ H1).

*****
H1 : eq (N.eqb a a1) true
a1 : ad
a0 : B
a : ad
m' : Map B
H0 : forall (m' : Map B) (a : ad),\neq (MapGet A (MapDomRestrTo m1 m') a)\n match MapGet B m' a with\n | Some _ => MapGet A m1 a\n | None => None\n end
m1 : Map A
H : forall (m' : Map B) (a : ad),\neq (MapGet A (MapDomRestrTo m0 m') a)\n match MapGet B m' a with\n | Some _ => MapGet A m0 a\n | None => None\n end
m,m0 : Map A
A,B : Type
*****
eq (MapGet A match MapGet A (M2 A m0 m1) a1 with | Some y => M1 A a1 y | None => M0 A end a1) match MapGet B (M1 B a1 a0) a1 with | Some _ => MapGet A (M2 A m0 m1) a1 | None => None end
+++++
rewrite (M1_semantics_1 B a1 a0).
-----
Lemma MapDomRestrTo_semantics : forall (m:Map A) (m':Map B), eqm A (MapGet A (MapDomRestrTo m m')) (fun a0:ad => match MapGet B m' a0 with | None => None | _ => MapGet A m a0 end).
Proof.
unfold eqm in |- *.
simple induction m.
simple induction m'.
unfold MapDomRestrTo in |- *.
intros.
elim (sumbool_of_bool (Neqb a a1)).
intro H1.
rewrite (Neqb_complete _ _ H1).
rewrite (M1_semantics_1 B a1 a0).

*****
H1 : eq (N.eqb a a1) true
a1 : ad
a0 : B
a : ad
m' : Map B
H0 : forall (m' : Map B) (a : ad),\neq (MapGet A (MapDomRestrTo m1 m') a)\n match MapGet B m' a with\n | Some _ => MapGet A m1 a\n | None => None\n end
m1 : Map A
H : forall (m' : Map B) (a : ad),\neq (MapGet A (MapDomRestrTo m0 m') a)\n match MapGet B m' a with\n | Some _ => MapGet A m0 a\n | None => None\n end
m,m0 : Map A
A,B : Type
*****
eq (MapGet A match MapGet A (M2 A m0 m1) a1 with | Some y => M1 A a1 y | None => M0 A end a1) (MapGet A (M2 A m0 m1) a1)
+++++
case (MapGet A (M2 A m0 m1) a1).
-----
Lemma MapDomRestrTo_semantics : forall (m:Map A) (m':Map B), eqm A (MapGet A (MapDomRestrTo m m')) (fun a0:ad => match MapGet B m' a0 with | None => None | _ => MapGet A m a0 end).
Proof.
unfold eqm in |- *.
simple induction m.
simple induction m'.
unfold MapDomRestrTo in |- *.
intros.
elim (sumbool_of_bool (Neqb a a1)).
intro H1.
rewrite (Neqb_complete _ _ H1).
rewrite (M1_semantics_1 B a1 a0).
case (MapGet A (M2 A m0 m1) a1).

*****
H1 : eq (N.eqb a a1) true
a1 : ad
a0 : B
a : ad
m' : Map B
H0 : forall (m' : Map B) (a : ad),\neq (MapGet A (MapDomRestrTo m1 m') a)\n match MapGet B m' a with\n | Some _ => MapGet A m1 a\n | None => None\n end
m1 : Map A
H : forall (m' : Map B) (a : ad),\neq (MapGet A (MapDomRestrTo m0 m') a)\n match MapGet B m' a with\n | Some _ => MapGet A m0 a\n | None => None\n end
m,m0 : Map A
A,B : Type
*****
forall a : A, eq (MapGet A (M1 A a1 a) a1) (Some a)
+++++
try reflexivity.
-----
Lemma MapDomRestrTo_semantics : forall (m:Map A) (m':Map B), eqm A (MapGet A (MapDomRestrTo m m')) (fun a0:ad => match MapGet B m' a0 with | None => None | _ => MapGet A m a0 end).
Proof.
unfold eqm in |- *.
simple induction m.
simple induction m'.
unfold MapDomRestrTo in |- *.
intros.
elim (sumbool_of_bool (Neqb a a1)).
intro H1.
rewrite (Neqb_complete _ _ H1).
rewrite (M1_semantics_1 B a1 a0).
case (MapGet A (M2 A m0 m1) a1).
try reflexivity.

*****
H1 : eq (N.eqb a a1) true
a1 : ad
a0 : B
a : ad
m' : Map B
H0 : forall (m' : Map B) (a : ad),\neq (MapGet A (MapDomRestrTo m1 m') a)\n match MapGet B m' a with\n | Some _ => MapGet A m1 a\n | None => None\n end
m1 : Map A
H : forall (m' : Map B) (a : ad),\neq (MapGet A (MapDomRestrTo m0 m') a)\n match MapGet B m' a with\n | Some _ => MapGet A m0 a\n | None => None\n end
m,m0 : Map A
A,B : Type
*****
forall a : A, eq (MapGet A (M1 A a1 a) a1) (Some a)
+++++
intro.
-----
Lemma MapDomRestrTo_semantics : forall (m:Map A) (m':Map B), eqm A (MapGet A (MapDomRestrTo m m')) (fun a0:ad => match MapGet B m' a0 with | None => None | _ => MapGet A m a0 end).
Proof.
unfold eqm in |- *.
simple induction m.
simple induction m'.
unfold MapDomRestrTo in |- *.
intros.
elim (sumbool_of_bool (Neqb a a1)).
intro H1.
rewrite (Neqb_complete _ _ H1).
rewrite (M1_semantics_1 B a1 a0).
case (MapGet A (M2 A m0 m1) a1).
try reflexivity.
intro.

*****
a2 : A
H1 : eq (N.eqb a a1) true
a1 : ad
a0 : B
a : ad
m' : Map B
H0 : forall (m' : Map B) (a : ad),\neq (MapGet A (MapDomRestrTo m1 m') a)\n match MapGet B m' a with\n | Some _ => MapGet A m1 a\n | None => None\n end
m1 : Map A
H : forall (m' : Map B) (a : ad),\neq (MapGet A (MapDomRestrTo m0 m') a)\n match MapGet B m' a with\n | Some _ => MapGet A m0 a\n | None => None\n end
m,m0 : Map A
A,B : Type
*****
eq (MapGet A (M1 A a1 a2) a1) (Some a2)
+++++
apply M1_semantics_1.
-----
Lemma MapDomRestrTo_semantics : forall (m:Map A) (m':Map B), eqm A (MapGet A (MapDomRestrTo m m')) (fun a0:ad => match MapGet B m' a0 with | None => None | _ => MapGet A m a0 end).
Proof.
unfold eqm in |- *.
simple induction m.
simple induction m'.
unfold MapDomRestrTo in |- *.
intros.
elim (sumbool_of_bool (Neqb a a1)).
intro H1.
rewrite (Neqb_complete _ _ H1).
rewrite (M1_semantics_1 B a1 a0).
case (MapGet A (M2 A m0 m1) a1).

*****
H1 : eq (N.eqb a a1) true
a1 : ad
a0 : B
a : ad
m' : Map B
H0 : forall (m' : Map B) (a : ad),\neq (MapGet A (MapDomRestrTo m1 m') a)\n match MapGet B m' a with\n | Some _ => MapGet A m1 a\n | None => None\n end
m1 : Map A
H : forall (m' : Map B) (a : ad),\neq (MapGet A (MapDomRestrTo m0 m') a)\n match MapGet B m' a with\n | Some _ => MapGet A m0 a\n | None => None\n end
m,m0 : Map A
A,B : Type
*****
eq (MapGet A (M0 A) a1) None
+++++
try reflexivity.
-----
Lemma MapDomRestrTo_semantics : forall (m:Map A) (m':Map B), eqm A (MapGet A (MapDomRestrTo m m')) (fun a0:ad => match MapGet B m' a0 with | None => None | _ => MapGet A m a0 end).
Proof.
unfold eqm in |- *.
simple induction m.
simple induction m'.
unfold MapDomRestrTo in |- *.
intros.
elim (sumbool_of_bool (Neqb a a1)).

*****
a1 : ad
a0 : B
a : ad
m' : Map B
H0 : forall (m' : Map B) (a : ad),\neq (MapGet A (MapDomRestrTo m1 m') a)\n match MapGet B m' a with\n | Some _ => MapGet A m1 a\n | None => None\n end
m1 : Map A
H : forall (m' : Map B) (a : ad),\neq (MapGet A (MapDomRestrTo m0 m') a)\n match MapGet B m' a with\n | Some _ => MapGet A m0 a\n | None => None\n end
m,m0 : Map A
A,B : Type
*****
forall _ : eq (N.eqb a a1) false, eq (MapGet A match MapGet A (M2 A m0 m1) a with | Some y => M1 A a y | None => M0 A end a1) match MapGet B (M1 B a a0) a1 with | Some _ => MapGet A (M2 A m0 m1) a1 | None => None end
+++++
intro H1.
-----
Lemma MapDomRestrTo_semantics : forall (m:Map A) (m':Map B), eqm A (MapGet A (MapDomRestrTo m m')) (fun a0:ad => match MapGet B m' a0 with | None => None | _ => MapGet A m a0 end).
Proof.
unfold eqm in |- *.
simple induction m.
simple induction m'.
unfold MapDomRestrTo in |- *.
intros.
elim (sumbool_of_bool (Neqb a a1)).
intro H1.

*****
H1 : eq (N.eqb a a1) false
a1 : ad
a0 : B
a : ad
m' : Map B
H0 : forall (m' : Map B) (a : ad),\neq (MapGet A (MapDomRestrTo m1 m') a)\n match MapGet B m' a with\n | Some _ => MapGet A m1 a\n | None => None\n end
m1 : Map A
H : forall (m' : Map B) (a : ad),\neq (MapGet A (MapDomRestrTo m0 m') a)\n match MapGet B m' a with\n | Some _ => MapGet A m0 a\n | None => None\n end
m,m0 : Map A
A,B : Type
*****
eq (MapGet A match MapGet A (M2 A m0 m1) a with | Some y => M1 A a y | None => M0 A end a1) match MapGet B (M1 B a a0) a1 with | Some _ => MapGet A (M2 A m0 m1) a1 | None => None end
+++++
rewrite (M1_semantics_2 B a a1 a0 H1).
-----
Lemma MapDomRestrTo_semantics : forall (m:Map A) (m':Map B), eqm A (MapGet A (MapDomRestrTo m m')) (fun a0:ad => match MapGet B m' a0 with | None => None | _ => MapGet A m a0 end).
Proof.
unfold eqm in |- *.
simple induction m.
simple induction m'.
unfold MapDomRestrTo in |- *.
intros.
elim (sumbool_of_bool (Neqb a a1)).
intro H1.
rewrite (M1_semantics_2 B a a1 a0 H1).

*****
H1 : eq (N.eqb a a1) false
a1 : ad
a0 : B
a : ad
m' : Map B
H0 : forall (m' : Map B) (a : ad),\neq (MapGet A (MapDomRestrTo m1 m') a)\n match MapGet B m' a with\n | Some _ => MapGet A m1 a\n | None => None\n end
m1 : Map A
H : forall (m' : Map B) (a : ad),\neq (MapGet A (MapDomRestrTo m0 m') a)\n match MapGet B m' a with\n | Some _ => MapGet A m0 a\n | None => None\n end
m,m0 : Map A
A,B : Type
*****
eq (MapGet A match MapGet A (M2 A m0 m1) a with | Some y => M1 A a y | None => M0 A end a1) None
+++++
case (MapGet A (M2 A m0 m1) a).
-----
Lemma MapDomRestrTo_semantics : forall (m:Map A) (m':Map B), eqm A (MapGet A (MapDomRestrTo m m')) (fun a0:ad => match MapGet B m' a0 with | None => None | _ => MapGet A m a0 end).
Proof.
unfold eqm in |- *.
simple induction m.
simple induction m'.
unfold MapDomRestrTo in |- *.
intros.
elim (sumbool_of_bool (Neqb a a1)).
intro H1.
rewrite (M1_semantics_2 B a a1 a0 H1).
case (MapGet A (M2 A m0 m1) a).

*****
H1 : eq (N.eqb a a1) false
a1 : ad
a0 : B
a : ad
m' : Map B
H0 : forall (m' : Map B) (a : ad),\neq (MapGet A (MapDomRestrTo m1 m') a)\n match MapGet B m' a with\n | Some _ => MapGet A m1 a\n | None => None\n end
m1 : Map A
H : forall (m' : Map B) (a : ad),\neq (MapGet A (MapDomRestrTo m0 m') a)\n match MapGet B m' a with\n | Some _ => MapGet A m0 a\n | None => None\n end
m,m0 : Map A
A,B : Type
*****
forall a0 : A, eq (MapGet A (M1 A a a0) a1) None
+++++
try reflexivity.
-----
Lemma MapDomRestrTo_semantics : forall (m:Map A) (m':Map B), eqm A (MapGet A (MapDomRestrTo m m')) (fun a0:ad => match MapGet B m' a0 with | None => None | _ => MapGet A m a0 end).
Proof.
unfold eqm in |- *.
simple induction m.
simple induction m'.
unfold MapDomRestrTo in |- *.
intros.
elim (sumbool_of_bool (Neqb a a1)).
intro H1.
rewrite (M1_semantics_2 B a a1 a0 H1).
case (MapGet A (M2 A m0 m1) a).
try reflexivity.

*****
H1 : eq (N.eqb a a1) false
a1 : ad
a0 : B
a : ad
m' : Map B
H0 : forall (m' : Map B) (a : ad),\neq (MapGet A (MapDomRestrTo m1 m') a)\n match MapGet B m' a with\n | Some _ => MapGet A m1 a\n | None => None\n end
m1 : Map A
H : forall (m' : Map B) (a : ad),\neq (MapGet A (MapDomRestrTo m0 m') a)\n match MapGet B m' a with\n | Some _ => MapGet A m0 a\n | None => None\n end
m,m0 : Map A
A,B : Type
*****
forall a0 : A, eq (MapGet A (M1 A a a0) a1) None
+++++
intro.
-----
Lemma MapDomRestrTo_semantics : forall (m:Map A) (m':Map B), eqm A (MapGet A (MapDomRestrTo m m')) (fun a0:ad => match MapGet B m' a0 with | None => None | _ => MapGet A m a0 end).
Proof.
unfold eqm in |- *.
simple induction m.
simple induction m'.
unfold MapDomRestrTo in |- *.
intros.
elim (sumbool_of_bool (Neqb a a1)).
intro H1.
rewrite (M1_semantics_2 B a a1 a0 H1).
case (MapGet A (M2 A m0 m1) a).
try reflexivity.
intro.

*****
a2 : A
H1 : eq (N.eqb a a1) false
a1 : ad
a0 : B
a : ad
m' : Map B
H0 : forall (m' : Map B) (a : ad),\neq (MapGet A (MapDomRestrTo m1 m') a)\n match MapGet B m' a with\n | Some _ => MapGet A m1 a\n | None => None\n end
m1 : Map A
H : forall (m' : Map B) (a : ad),\neq (MapGet A (MapDomRestrTo m0 m') a)\n match MapGet B m' a with\n | Some _ => MapGet A m0 a\n | None => None\n end
m,m0 : Map A
A,B : Type
*****
eq (MapGet A (M1 A a a2) a1) None
+++++
exact (M1_semantics_2 A a a1 a2 H1).
-----
Lemma MapDomRestrTo_semantics : forall (m:Map A) (m':Map B), eqm A (MapGet A (MapDomRestrTo m m')) (fun a0:ad => match MapGet B m' a0 with | None => None | _ => MapGet A m a0 end).
Proof.
unfold eqm in |- *.
simple induction m.
simple induction m'.
unfold MapDomRestrTo in |- *.
intros.
elim (sumbool_of_bool (Neqb a a1)).
intro H1.
rewrite (M1_semantics_2 B a a1 a0 H1).
case (MapGet A (M2 A m0 m1) a).

*****
H1 : eq (N.eqb a a1) false
a1 : ad
a0 : B
a : ad
m' : Map B
H0 : forall (m' : Map B) (a : ad),\neq (MapGet A (MapDomRestrTo m1 m') a)\n match MapGet B m' a with\n | Some _ => MapGet A m1 a\n | None => None\n end
m1 : Map A
H : forall (m' : Map B) (a : ad),\neq (MapGet A (MapDomRestrTo m0 m') a)\n match MapGet B m' a with\n | Some _ => MapGet A m0 a\n | None => None\n end
m,m0 : Map A
A,B : Type
*****
eq (MapGet A (M0 A) a1) None
+++++
try reflexivity.
-----
Lemma MapDomRestrTo_semantics : forall (m:Map A) (m':Map B), eqm A (MapGet A (MapDomRestrTo m m')) (fun a0:ad => match MapGet B m' a0 with | None => None | _ => MapGet A m a0 end).
Proof.
unfold eqm in |- *.
simple induction m.
simple induction m'.

*****
m' : Map B
H0 : forall (m' : Map B) (a : ad),\neq (MapGet A (MapDomRestrTo m1 m') a)\n match MapGet B m' a with\n | Some _ => MapGet A m1 a\n | None => None\n end
m1 : Map A
H : forall (m' : Map B) (a : ad),\neq (MapGet A (MapDomRestrTo m0 m') a)\n match MapGet B m' a with\n | Some _ => MapGet A m0 a\n | None => None\n end
m,m0 : Map A
A,B : Type
*****
forall (m : Map B) (_ : forall a : ad, eq (MapGet A (MapDomRestrTo (M2 A m0 m1) m) a) match MapGet B m a with | Some _ => MapGet A (M2 A m0 m1) a | None => None end) (m2 : Map B) (_ : forall a : ad, eq (MapGet A (MapDomRestrTo (M2 A m0 m1) m2) a) match MapGet B m2 a with | Some _ => MapGet A (M2 A m0 m1) a | None => None end) (a : ad), eq (MapGet A (MapDomRestrTo (M2 A m0 m1) (M2 B m m2)) a) match MapGet B (M2 B m m2) a with | Some _ => MapGet A (M2 A m0 m1) a | None => None end
+++++
intros.
-----
Lemma MapDomRestrTo_semantics : forall (m:Map A) (m':Map B), eqm A (MapGet A (MapDomRestrTo m m')) (fun a0:ad => match MapGet B m' a0 with | None => None | _ => MapGet A m a0 end).
Proof.
unfold eqm in |- *.
simple induction m.
simple induction m'.
intros.

*****
a : ad
H2 : forall a : ad,\neq (MapGet A (MapDomRestrTo (M2 A m0 m1) m3) a)\n match MapGet B m3 a with\n | Some _ => MapGet A (M2 A m0 m1) a\n | None => None\n end
m3 : Map B
H1 : forall a : ad,\neq (MapGet A (MapDomRestrTo (M2 A m0 m1) m2) a)\n match MapGet B m2 a with\n | Some _ => MapGet A (M2 A m0 m1) a\n | None => None\n end
m',m2 : Map B
H0 : forall (m' : Map B) (a : ad),\neq (MapGet A (MapDomRestrTo m1 m') a)\n match MapGet B m' a with\n | Some _ => MapGet A m1 a\n | None => None\n end
m1 : Map A
H : forall (m' : Map B) (a : ad),\neq (MapGet A (MapDomRestrTo m0 m') a)\n match MapGet B m' a with\n | Some _ => MapGet A m0 a\n | None => None\n end
m,m0 : Map A
A,B : Type
*****
eq (MapGet A (MapDomRestrTo (M2 A m0 m1) (M2 B m2 m3)) a) match MapGet B (M2 B m2 m3) a with | Some _ => MapGet A (M2 A m0 m1) a | None => None end
+++++
change (MapGet A (makeM2 A (MapDomRestrTo m0 m2) (MapDomRestrTo m1 m3)) a = match MapGet B (M2 B m2 m3) a with | None => None | Some _ => MapGet A (M2 A m0 m1) a end) in |- *.
-----
Lemma MapDomRestrTo_semantics : forall (m:Map A) (m':Map B), eqm A (MapGet A (MapDomRestrTo m m')) (fun a0:ad => match MapGet B m' a0 with | None => None | _ => MapGet A m a0 end).
Proof.
unfold eqm in |- *.
simple induction m.
simple induction m'.
intros.
change (MapGet A (makeM2 A (MapDomRestrTo m0 m2) (MapDomRestrTo m1 m3)) a = match MapGet B (M2 B m2 m3) a with | None => None | Some _ => MapGet A (M2 A m0 m1) a end) in |- *.

*****
a : ad
H2 : forall a : ad,\neq (MapGet A (MapDomRestrTo (M2 A m0 m1) m3) a)\n match MapGet B m3 a with\n | Some _ => MapGet A (M2 A m0 m1) a\n | None => None\n end
m3 : Map B
H1 : forall a : ad,\neq (MapGet A (MapDomRestrTo (M2 A m0 m1) m2) a)\n match MapGet B m2 a with\n | Some _ => MapGet A (M2 A m0 m1) a\n | None => None\n end
m',m2 : Map B
H0 : forall (m' : Map B) (a : ad),\neq (MapGet A (MapDomRestrTo m1 m') a)\n match MapGet B m' a with\n | Some _ => MapGet A m1 a\n | None => None\n end
m1 : Map A
H : forall (m' : Map B) (a : ad),\neq (MapGet A (MapDomRestrTo m0 m') a)\n match MapGet B m' a with\n | Some _ => MapGet A m0 a\n | None => None\n end
m,m0 : Map A
A,B : Type
*****
eq (MapGet A (makeM2 A (MapDomRestrTo m0 m2) (MapDomRestrTo m1 m3)) a) match MapGet B (M2 B m2 m3) a with | Some _ => MapGet A (M2 A m0 m1) a | None => None end
+++++
rewrite (makeM2_M2 A (MapDomRestrTo m0 m2) (MapDomRestrTo m1 m3) a).
-----
Lemma MapDomRestrTo_semantics : forall (m:Map A) (m':Map B), eqm A (MapGet A (MapDomRestrTo m m')) (fun a0:ad => match MapGet B m' a0 with | None => None | _ => MapGet A m a0 end).
Proof.
unfold eqm in |- *.
simple induction m.
simple induction m'.
intros.
change (MapGet A (makeM2 A (MapDomRestrTo m0 m2) (MapDomRestrTo m1 m3)) a = match MapGet B (M2 B m2 m3) a with | None => None | Some _ => MapGet A (M2 A m0 m1) a end) in |- *.
rewrite (makeM2_M2 A (MapDomRestrTo m0 m2) (MapDomRestrTo m1 m3) a).

*****
a : ad
H2 : forall a : ad,\neq (MapGet A (MapDomRestrTo (M2 A m0 m1) m3) a)\n match MapGet B m3 a with\n | Some _ => MapGet A (M2 A m0 m1) a\n | None => None\n end
m3 : Map B
H1 : forall a : ad,\neq (MapGet A (MapDomRestrTo (M2 A m0 m1) m2) a)\n match MapGet B m2 a with\n | Some _ => MapGet A (M2 A m0 m1) a\n | None => None\n end
m',m2 : Map B
H0 : forall (m' : Map B) (a : ad),\neq (MapGet A (MapDomRestrTo m1 m') a)\n match MapGet B m' a with\n | Some _ => MapGet A m1 a\n | None => None\n end
m1 : Map A
H : forall (m' : Map B) (a : ad),\neq (MapGet A (MapDomRestrTo m0 m') a)\n match MapGet B m' a with\n | Some _ => MapGet A m0 a\n | None => None\n end
m,m0 : Map A
A,B : Type
*****
eq (MapGet A (M2 A (MapDomRestrTo m0 m2) (MapDomRestrTo m1 m3)) a) match MapGet B (M2 B m2 m3) a with | Some _ => MapGet A (M2 A m0 m1) a | None => None end
+++++
rewrite MapGet_M2_bit_0_if.
-----
Lemma MapDomRestrTo_semantics : forall (m:Map A) (m':Map B), eqm A (MapGet A (MapDomRestrTo m m')) (fun a0:ad => match MapGet B m' a0 with | None => None | _ => MapGet A m a0 end).
Proof.
unfold eqm in |- *.
simple induction m.
simple induction m'.
intros.
change (MapGet A (makeM2 A (MapDomRestrTo m0 m2) (MapDomRestrTo m1 m3)) a = match MapGet B (M2 B m2 m3) a with | None => None | Some _ => MapGet A (M2 A m0 m1) a end) in |- *.
rewrite (makeM2_M2 A (MapDomRestrTo m0 m2) (MapDomRestrTo m1 m3) a).
rewrite MapGet_M2_bit_0_if.

*****
a : ad
H2 : forall a : ad,\neq (MapGet A (MapDomRestrTo (M2 A m0 m1) m3) a)\n match MapGet B m3 a with\n | Some _ => MapGet A (M2 A m0 m1) a\n | None => None\n end
m3 : Map B
H1 : forall a : ad,\neq (MapGet A (MapDomRestrTo (M2 A m0 m1) m2) a)\n match MapGet B m2 a with\n | Some _ => MapGet A (M2 A m0 m1) a\n | None => None\n end
m',m2 : Map B
H0 : forall (m' : Map B) (a : ad),\neq (MapGet A (MapDomRestrTo m1 m') a)\n match MapGet B m' a with\n | Some _ => MapGet A m1 a\n | None => None\n end
m1 : Map A
H : forall (m' : Map B) (a : ad),\neq (MapGet A (MapDomRestrTo m0 m') a)\n match MapGet B m' a with\n | Some _ => MapGet A m0 a\n | None => None\n end
m,m0 : Map A
A,B : Type
*****
eq (if N.odd a then MapGet A (MapDomRestrTo m1 m3) (N.div2 a) else MapGet A (MapDomRestrTo m0 m2) (N.div2 a)) match MapGet B (M2 B m2 m3) a with | Some _ => MapGet A (M2 A m0 m1) a | None => None end
+++++
rewrite (H0 m3 (Ndiv2 a)).
-----
Lemma MapDomRestrTo_semantics : forall (m:Map A) (m':Map B), eqm A (MapGet A (MapDomRestrTo m m')) (fun a0:ad => match MapGet B m' a0 with | None => None | _ => MapGet A m a0 end).
Proof.
unfold eqm in |- *.
simple induction m.
simple induction m'.
intros.
change (MapGet A (makeM2 A (MapDomRestrTo m0 m2) (MapDomRestrTo m1 m3)) a = match MapGet B (M2 B m2 m3) a with | None => None | Some _ => MapGet A (M2 A m0 m1) a end) in |- *.
rewrite (makeM2_M2 A (MapDomRestrTo m0 m2) (MapDomRestrTo m1 m3) a).
rewrite MapGet_M2_bit_0_if.
rewrite (H0 m3 (Ndiv2 a)).

*****
a : ad
H2 : forall a : ad,\neq (MapGet A (MapDomRestrTo (M2 A m0 m1) m3) a)\n match MapGet B m3 a with\n | Some _ => MapGet A (M2 A m0 m1) a\n | None => None\n end
m3 : Map B
H1 : forall a : ad,\neq (MapGet A (MapDomRestrTo (M2 A m0 m1) m2) a)\n match MapGet B m2 a with\n | Some _ => MapGet A (M2 A m0 m1) a\n | None => None\n end
m',m2 : Map B
H0 : forall (m' : Map B) (a : ad),\neq (MapGet A (MapDomRestrTo m1 m') a)\n match MapGet B m' a with\n | Some _ => MapGet A m1 a\n | None => None\n end
m1 : Map A
H : forall (m' : Map B) (a : ad),\neq (MapGet A (MapDomRestrTo m0 m') a)\n match MapGet B m' a with\n | Some _ => MapGet A m0 a\n | None => None\n end
m,m0 : Map A
A,B : Type
*****
eq (if N.odd a then match MapGet B m3 (N.div2 a) with | Some _ => MapGet A m1 (N.div2 a) | None => None end else MapGet A (MapDomRestrTo m0 m2) (N.div2 a)) match MapGet B (M2 B m2 m3) a with | Some _ => MapGet A (M2 A m0 m1) a | None => None end
+++++
rewrite (H m2 (Ndiv2 a)).
-----
Lemma MapDomRestrTo_semantics : forall (m:Map A) (m':Map B), eqm A (MapGet A (MapDomRestrTo m m')) (fun a0:ad => match MapGet B m' a0 with | None => None | _ => MapGet A m a0 end).
Proof.
unfold eqm in |- *.
simple induction m.
simple induction m'.
intros.
change (MapGet A (makeM2 A (MapDomRestrTo m0 m2) (MapDomRestrTo m1 m3)) a = match MapGet B (M2 B m2 m3) a with | None => None | Some _ => MapGet A (M2 A m0 m1) a end) in |- *.
rewrite (makeM2_M2 A (MapDomRestrTo m0 m2) (MapDomRestrTo m1 m3) a).
rewrite MapGet_M2_bit_0_if.
rewrite (H0 m3 (Ndiv2 a)).
rewrite (H m2 (Ndiv2 a)).

*****
a : ad
H2 : forall a : ad,\neq (MapGet A (MapDomRestrTo (M2 A m0 m1) m3) a)\n match MapGet B m3 a with\n | Some _ => MapGet A (M2 A m0 m1) a\n | None => None\n end
m3 : Map B
H1 : forall a : ad,\neq (MapGet A (MapDomRestrTo (M2 A m0 m1) m2) a)\n match MapGet B m2 a with\n | Some _ => MapGet A (M2 A m0 m1) a\n | None => None\n end
m',m2 : Map B
H0 : forall (m' : Map B) (a : ad),\neq (MapGet A (MapDomRestrTo m1 m') a)\n match MapGet B m' a with\n | Some _ => MapGet A m1 a\n | None => None\n end
m1 : Map A
H : forall (m' : Map B) (a : ad),\neq (MapGet A (MapDomRestrTo m0 m') a)\n match MapGet B m' a with\n | Some _ => MapGet A m0 a\n | None => None\n end
m,m0 : Map A
A,B : Type
*****
eq (if N.odd a then match MapGet B m3 (N.div2 a) with | Some _ => MapGet A m1 (N.div2 a) | None => None end else match MapGet B m2 (N.div2 a) with | Some _ => MapGet A m0 (N.div2 a) | None => None end) match MapGet B (M2 B m2 m3) a with | Some _ => MapGet A (M2 A m0 m1) a | None => None end
+++++
rewrite (MapGet_M2_bit_0_if B m2 m3 a).
-----
Lemma MapDomRestrTo_semantics : forall (m:Map A) (m':Map B), eqm A (MapGet A (MapDomRestrTo m m')) (fun a0:ad => match MapGet B m' a0 with | None => None | _ => MapGet A m a0 end).
Proof.
unfold eqm in |- *.
simple induction m.
simple induction m'.
intros.
change (MapGet A (makeM2 A (MapDomRestrTo m0 m2) (MapDomRestrTo m1 m3)) a = match MapGet B (M2 B m2 m3) a with | None => None | Some _ => MapGet A (M2 A m0 m1) a end) in |- *.
rewrite (makeM2_M2 A (MapDomRestrTo m0 m2) (MapDomRestrTo m1 m3) a).
rewrite MapGet_M2_bit_0_if.
rewrite (H0 m3 (Ndiv2 a)).
rewrite (H m2 (Ndiv2 a)).
rewrite (MapGet_M2_bit_0_if B m2 m3 a).

*****
a : ad
H2 : forall a : ad,\neq (MapGet A (MapDomRestrTo (M2 A m0 m1) m3) a)\n match MapGet B m3 a with\n | Some _ => MapGet A (M2 A m0 m1) a\n | None => None\n end
m3 : Map B
H1 : forall a : ad,\neq (MapGet A (MapDomRestrTo (M2 A m0 m1) m2) a)\n match MapGet B m2 a with\n | Some _ => MapGet A (M2 A m0 m1) a\n | None => None\n end
m',m2 : Map B
H0 : forall (m' : Map B) (a : ad),\neq (MapGet A (MapDomRestrTo m1 m') a)\n match MapGet B m' a with\n | Some _ => MapGet A m1 a\n | None => None\n end
m1 : Map A
H : forall (m' : Map B) (a : ad),\neq (MapGet A (MapDomRestrTo m0 m') a)\n match MapGet B m' a with\n | Some _ => MapGet A m0 a\n | None => None\n end
m,m0 : Map A
A,B : Type
*****
eq (if N.odd a then match MapGet B m3 (N.div2 a) with | Some _ => MapGet A m1 (N.div2 a) | None => None end else match MapGet B m2 (N.div2 a) with | Some _ => MapGet A m0 (N.div2 a) | None => None end) match (if N.odd a then MapGet B m3 (N.div2 a) else MapGet B m2 (N.div2 a)) with | Some _ => MapGet A (M2 A m0 m1) a | None => None end
+++++
rewrite (MapGet_M2_bit_0_if A m0 m1 a).
-----
Lemma MapDomRestrTo_semantics : forall (m:Map A) (m':Map B), eqm A (MapGet A (MapDomRestrTo m m')) (fun a0:ad => match MapGet B m' a0 with | None => None | _ => MapGet A m a0 end).
Proof.
unfold eqm in |- *.
simple induction m.
simple induction m'.
intros.
change (MapGet A (makeM2 A (MapDomRestrTo m0 m2) (MapDomRestrTo m1 m3)) a = match MapGet B (M2 B m2 m3) a with | None => None | Some _ => MapGet A (M2 A m0 m1) a end) in |- *.
rewrite (makeM2_M2 A (MapDomRestrTo m0 m2) (MapDomRestrTo m1 m3) a).
rewrite MapGet_M2_bit_0_if.
rewrite (H0 m3 (Ndiv2 a)).
rewrite (H m2 (Ndiv2 a)).
rewrite (MapGet_M2_bit_0_if B m2 m3 a).
rewrite (MapGet_M2_bit_0_if A m0 m1 a).

*****
a : ad
H2 : forall a : ad,\neq (MapGet A (MapDomRestrTo (M2 A m0 m1) m3) a)\n match MapGet B m3 a with\n | Some _ => MapGet A (M2 A m0 m1) a\n | None => None\n end
m3 : Map B
H1 : forall a : ad,\neq (MapGet A (MapDomRestrTo (M2 A m0 m1) m2) a)\n match MapGet B m2 a with\n | Some _ => MapGet A (M2 A m0 m1) a\n | None => None\n end
m',m2 : Map B
H0 : forall (m' : Map B) (a : ad),\neq (MapGet A (MapDomRestrTo m1 m') a)\n match MapGet B m' a with\n | Some _ => MapGet A m1 a\n | None => None\n end
m1 : Map A
H : forall (m' : Map B) (a : ad),\neq (MapGet A (MapDomRestrTo m0 m') a)\n match MapGet B m' a with\n | Some _ => MapGet A m0 a\n | None => None\n end
m,m0 : Map A
A,B : Type
*****
eq (if N.odd a then match MapGet B m3 (N.div2 a) with | Some _ => MapGet A m1 (N.div2 a) | None => None end else match MapGet B m2 (N.div2 a) with | Some _ => MapGet A m0 (N.div2 a) | None => None end) match (if N.odd a then MapGet B m3 (N.div2 a) else MapGet B m2 (N.div2 a)) with | Some _ => if N.odd a then MapGet A m1 (N.div2 a) else MapGet A m0 (N.div2 a) | None => None end
+++++
case (Nbit0 a).
-----
Lemma MapDomRestrTo_semantics : forall (m:Map A) (m':Map B), eqm A (MapGet A (MapDomRestrTo m m')) (fun a0:ad => match MapGet B m' a0 with | None => None | _ => MapGet A m a0 end).
Proof.
unfold eqm in |- *.
simple induction m.
simple induction m'.
intros.
change (MapGet A (makeM2 A (MapDomRestrTo m0 m2) (MapDomRestrTo m1 m3)) a = match MapGet B (M2 B m2 m3) a with | None => None | Some _ => MapGet A (M2 A m0 m1) a end) in |- *.
rewrite (makeM2_M2 A (MapDomRestrTo m0 m2) (MapDomRestrTo m1 m3) a).
rewrite MapGet_M2_bit_0_if.
rewrite (H0 m3 (Ndiv2 a)).
rewrite (H m2 (Ndiv2 a)).
rewrite (MapGet_M2_bit_0_if B m2 m3 a).
rewrite (MapGet_M2_bit_0_if A m0 m1 a).
case (Nbit0 a).

*****
a : ad
H2 : forall a : ad,\neq (MapGet A (MapDomRestrTo (M2 A m0 m1) m3) a)\n match MapGet B m3 a with\n | Some _ => MapGet A (M2 A m0 m1) a\n | None => None\n end
m3 : Map B
H1 : forall a : ad,\neq (MapGet A (MapDomRestrTo (M2 A m0 m1) m2) a)\n match MapGet B m2 a with\n | Some _ => MapGet A (M2 A m0 m1) a\n | None => None\n end
m',m2 : Map B
H0 : forall (m' : Map B) (a : ad),\neq (MapGet A (MapDomRestrTo m1 m') a)\n match MapGet B m' a with\n | Some _ => MapGet A m1 a\n | None => None\n end
m1 : Map A
H : forall (m' : Map B) (a : ad),\neq (MapGet A (MapDomRestrTo m0 m') a)\n match MapGet B m' a with\n | Some _ => MapGet A m0 a\n | None => None\n end
m,m0 : Map A
A,B : Type
*****
eq match MapGet B m3 (N.div2 a) with | Some _ => MapGet A m1 (N.div2 a) | None => None end match MapGet B m3 (N.div2 a) with | Some _ => MapGet A m1 (N.div2 a) | None => None end
+++++
reflexivity.
-----
Lemma MapDomRestrTo_semantics : forall (m:Map A) (m':Map B), eqm A (MapGet A (MapDomRestrTo m m')) (fun a0:ad => match MapGet B m' a0 with | None => None | _ => MapGet A m a0 end).
Proof.
unfold eqm in |- *.
simple induction m.
simple induction m'.
intros.
change (MapGet A (makeM2 A (MapDomRestrTo m0 m2) (MapDomRestrTo m1 m3)) a = match MapGet B (M2 B m2 m3) a with | None => None | Some _ => MapGet A (M2 A m0 m1) a end) in |- *.
rewrite (makeM2_M2 A (MapDomRestrTo m0 m2) (MapDomRestrTo m1 m3) a).
rewrite MapGet_M2_bit_0_if.
rewrite (H0 m3 (Ndiv2 a)).
rewrite (H m2 (Ndiv2 a)).
rewrite (MapGet_M2_bit_0_if B m2 m3 a).
rewrite (MapGet_M2_bit_0_if A m0 m1 a).
case (Nbit0 a).

*****
a : ad
H2 : forall a : ad,\neq (MapGet A (MapDomRestrTo (M2 A m0 m1) m3) a)\n match MapGet B m3 a with\n | Some _ => MapGet A (M2 A m0 m1) a\n | None => None\n end
m3 : Map B
H1 : forall a : ad,\neq (MapGet A (MapDomRestrTo (M2 A m0 m1) m2) a)\n match MapGet B m2 a with\n | Some _ => MapGet A (M2 A m0 m1) a\n | None => None\n end
m',m2 : Map B
H0 : forall (m' : Map B) (a : ad),\neq (MapGet A (MapDomRestrTo m1 m') a)\n match MapGet B m' a with\n | Some _ => MapGet A m1 a\n | None => None\n end
m1 : Map A
H : forall (m' : Map B) (a : ad),\neq (MapGet A (MapDomRestrTo m0 m') a)\n match MapGet B m' a with\n | Some _ => MapGet A m0 a\n | None => None\n end
m,m0 : Map A
A,B : Type
*****
eq match MapGet B m2 (N.div2 a) with | Some _ => MapGet A m0 (N.div2 a) | None => None end match MapGet B m2 (N.div2 a) with | Some _ => MapGet A m0 (N.div2 a) | None => None end
+++++
reflexivity.
-----
Lemma MapDomRestrTo_semantics : forall (m:Map A) (m':Map B), eqm A (MapGet A (MapDomRestrTo m m')) (fun a0:ad => match MapGet B m' a0 with | None => None | _ => MapGet A m a0 end).
Proof.
unfold eqm in |- *.
simple induction m.

*****

*****

+++++
Qed.
-----
Fixpoint MapDomRestrBy (m:Map A) : Map B -> Map A :=\n    match m with\n    | M0 => fun _:Map B => M0 A\n    | M1 a y =>\n        fun m':Map B => match MapGet B m' a with\n                        | None => m\n                        | _ => M0 A\n                        end\n    | M2 m1 m2 =>\n        fun m':Map B =>\n          match m' with\n          | M0 => m\n          | M1 a' y' => MapRemove A m a'\n          | M2 m'1 m'2 =>\n              makeM2 A (MapDomRestrBy m1 m'1) (MapDomRestrBy m2 m'2)\n          end\n    end.
-----
Lemma MapDomRestrBy_semantics :\n   forall (m:Map A) (m':Map B),\n     eqm A (MapGet A (MapDomRestrBy m m'))\n       (fun a0:ad =>\n          match MapGet B m' a0 with\n          | None => MapGet A m a0\n          | _ => None\n          end).
-----
Lemma MapDomRestrBy_semantics : forall (m:Map A) (m':Map B), eqm A (MapGet A (MapDomRestrBy m m')) (fun a0:ad => match MapGet B m' a0 with | None => MapGet A m a0 | _ => None end).

*****
A,B : Type
*****
forall (m : Map A) (m' : Map B), eqm A (MapGet A (MapDomRestrBy m m')) (fun a0 : ad => match MapGet B m' a0 with | Some _ => None | None => MapGet A m a0 end)
+++++
Proof.
-----
Lemma MapDomRestrBy_semantics : forall (m:Map A) (m':Map B), eqm A (MapGet A (MapDomRestrBy m m')) (fun a0:ad => match MapGet B m' a0 with | None => MapGet A m a0 | _ => None end).
Proof.

*****
A,B : Type
*****
forall (m : Map A) (m' : Map B), eqm A (MapGet A (MapDomRestrBy m m')) (fun a0 : ad => match MapGet B m' a0 with | Some _ => None | None => MapGet A m a0 end)
+++++
unfold eqm in |- *.
-----
Lemma MapDomRestrBy_semantics : forall (m:Map A) (m':Map B), eqm A (MapGet A (MapDomRestrBy m m')) (fun a0:ad => match MapGet B m' a0 with | None => MapGet A m a0 | _ => None end).
Proof.
unfold eqm in |- *.

*****
A,B : Type
*****
forall (m : Map A) (m' : Map B) (a : ad), eq (MapGet A (MapDomRestrBy m m') a) match MapGet B m' a with | Some _ => None | None => MapGet A m a end
+++++
simple induction m.
-----
Lemma MapDomRestrBy_semantics : forall (m:Map A) (m':Map B), eqm A (MapGet A (MapDomRestrBy m m')) (fun a0:ad => match MapGet B m' a0 with | None => MapGet A m a0 | _ => None end).
Proof.
unfold eqm in |- *.
simple induction m.

*****
m : Map A
A,B : Type
*****
forall (m' : Map B) (a : ad), eq (MapGet A (MapDomRestrBy (M0 A) m') a) match MapGet B m' a with | Some _ => None | None => MapGet A (M0 A) a end
+++++
simpl in |- *.
-----
Lemma MapDomRestrBy_semantics : forall (m:Map A) (m':Map B), eqm A (MapGet A (MapDomRestrBy m m')) (fun a0:ad => match MapGet B m' a0 with | None => MapGet A m a0 | _ => None end).
Proof.
unfold eqm in |- *.
simple induction m.
simpl in |- *.

*****
m : Map A
A,B : Type
*****
forall (m' : Map B) (a : ad), eq None match MapGet B m' a with | Some _ | _ => None end
+++++
intros.
-----
Lemma MapDomRestrBy_semantics : forall (m:Map A) (m':Map B), eqm A (MapGet A (MapDomRestrBy m m')) (fun a0:ad => match MapGet B m' a0 with | None => MapGet A m a0 | _ => None end).
Proof.
unfold eqm in |- *.
simple induction m.
simpl in |- *.
intros.

*****
a : ad
m' : Map B
m : Map A
A,B : Type
*****
eq None match MapGet B m' a with | Some _ | _ => None end
+++++
case (MapGet B m' a).
-----
Lemma MapDomRestrBy_semantics : forall (m:Map A) (m':Map B), eqm A (MapGet A (MapDomRestrBy m m')) (fun a0:ad => match MapGet B m' a0 with | None => MapGet A m a0 | _ => None end).
Proof.
unfold eqm in |- *.
simple induction m.
simpl in |- *.
intros.
case (MapGet B m' a).

*****
a : ad
m' : Map B
m : Map A
A,B : Type
*****
forall _ : B, eq None None
+++++
trivial.
-----
Lemma MapDomRestrBy_semantics : forall (m:Map A) (m':Map B), eqm A (MapGet A (MapDomRestrBy m m')) (fun a0:ad => match MapGet B m' a0 with | None => MapGet A m a0 | _ => None end).
Proof.
unfold eqm in |- *.
simple induction m.
simpl in |- *.
intros.
case (MapGet B m' a).

*****
a : ad
m' : Map B
m : Map A
A,B : Type
*****
eq None None
+++++
trivial.
-----
Lemma MapDomRestrBy_semantics : forall (m:Map A) (m':Map B), eqm A (MapGet A (MapDomRestrBy m m')) (fun a0:ad => match MapGet B m' a0 with | None => MapGet A m a0 | _ => None end).
Proof.
unfold eqm in |- *.
simple induction m.

*****
m : Map A
A,B : Type
*****
forall (a : ad) (a0 : A) (m' : Map B) (a1 : ad), eq (MapGet A (MapDomRestrBy (M1 A a a0) m') a1) match MapGet B m' a1 with | Some _ => None | None => MapGet A (M1 A a a0) a1 end
+++++
intros.
-----
Lemma MapDomRestrBy_semantics : forall (m:Map A) (m':Map B), eqm A (MapGet A (MapDomRestrBy m m')) (fun a0:ad => match MapGet B m' a0 with | None => MapGet A m a0 | _ => None end).
Proof.
unfold eqm in |- *.
simple induction m.
intros.

*****
a1 : ad
m' : Map B
a0 : A
a : ad
m : Map A
A,B : Type
*****
eq (MapGet A (MapDomRestrBy (M1 A a a0) m') a1) match MapGet B m' a1 with | Some _ => None | None => MapGet A (M1 A a a0) a1 end
+++++
simpl in |- *.
-----
Lemma MapDomRestrBy_semantics : forall (m:Map A) (m':Map B), eqm A (MapGet A (MapDomRestrBy m m')) (fun a0:ad => match MapGet B m' a0 with | None => MapGet A m a0 | _ => None end).
Proof.
unfold eqm in |- *.
simple induction m.
intros.
simpl in |- *.

*****
a1 : ad
m' : Map B
a0 : A
a : ad
m : Map A
A,B : Type
*****
eq (MapGet A match MapGet B m' a with | Some _ => M0 A | None => M1 A a a0 end a1) match MapGet B m' a1 with | Some _ => None | None => if N.eqb a a1 then Some a0 else None end
+++++
elim (sumbool_of_bool (Neqb a a1)).
-----
Lemma MapDomRestrBy_semantics : forall (m:Map A) (m':Map B), eqm A (MapGet A (MapDomRestrBy m m')) (fun a0:ad => match MapGet B m' a0 with | None => MapGet A m a0 | _ => None end).
Proof.
unfold eqm in |- *.
simple induction m.
intros.
simpl in |- *.
elim (sumbool_of_bool (Neqb a a1)).

*****
a1 : ad
m' : Map B
a0 : A
a : ad
m : Map A
A,B : Type
*****
forall _ : eq (N.eqb a a1) true, eq (MapGet A match MapGet B m' a with | Some _ => M0 A | None => M1 A a a0 end a1) match MapGet B m' a1 with | Some _ => None | None => if N.eqb a a1 then Some a0 else None end
+++++
intro H.
-----
Lemma MapDomRestrBy_semantics : forall (m:Map A) (m':Map B), eqm A (MapGet A (MapDomRestrBy m m')) (fun a0:ad => match MapGet B m' a0 with | None => MapGet A m a0 | _ => None end).
Proof.
unfold eqm in |- *.
simple induction m.
intros.
simpl in |- *.
elim (sumbool_of_bool (Neqb a a1)).
intro H.

*****
H : eq (N.eqb a a1) true
a1 : ad
m' : Map B
a0 : A
a : ad
m : Map A
A,B : Type
*****
eq (MapGet A match MapGet B m' a with | Some _ => M0 A | None => M1 A a a0 end a1) match MapGet B m' a1 with | Some _ => None | None => if N.eqb a a1 then Some a0 else None end
+++++
rewrite H.
-----
Lemma MapDomRestrBy_semantics : forall (m:Map A) (m':Map B), eqm A (MapGet A (MapDomRestrBy m m')) (fun a0:ad => match MapGet B m' a0 with | None => MapGet A m a0 | _ => None end).
Proof.
unfold eqm in |- *.
simple induction m.
intros.
simpl in |- *.
elim (sumbool_of_bool (Neqb a a1)).
intro H.
rewrite H.

*****
H : eq (N.eqb a a1) true
a1 : ad
m' : Map B
a0 : A
a : ad
m : Map A
A,B : Type
*****
eq (MapGet A match MapGet B m' a with | Some _ => M0 A | None => M1 A a a0 end a1) match MapGet B m' a1 with | Some _ => None | None => Some a0 end
+++++
rewrite (Neqb_complete _ _ H).
-----
Lemma MapDomRestrBy_semantics : forall (m:Map A) (m':Map B), eqm A (MapGet A (MapDomRestrBy m m')) (fun a0:ad => match MapGet B m' a0 with | None => MapGet A m a0 | _ => None end).
Proof.
unfold eqm in |- *.
simple induction m.
intros.
simpl in |- *.
elim (sumbool_of_bool (Neqb a a1)).
intro H.
rewrite H.
rewrite (Neqb_complete _ _ H).

*****
H : eq (N.eqb a a1) true
a1 : ad
m' : Map B
a0 : A
a : ad
m : Map A
A,B : Type
*****
eq (MapGet A match MapGet B m' a1 with | Some _ => M0 A | None => M1 A a1 a0 end a1) match MapGet B m' a1 with | Some _ => None | None => Some a0 end
+++++
case (MapGet B m' a1).
-----
Lemma MapDomRestrBy_semantics : forall (m:Map A) (m':Map B), eqm A (MapGet A (MapDomRestrBy m m')) (fun a0:ad => match MapGet B m' a0 with | None => MapGet A m a0 | _ => None end).
Proof.
unfold eqm in |- *.
simple induction m.
intros.
simpl in |- *.
elim (sumbool_of_bool (Neqb a a1)).
intro H.
rewrite H.
rewrite (Neqb_complete _ _ H).
case (MapGet B m' a1).

*****
H : eq (N.eqb a a1) true
a1 : ad
m' : Map B
a0 : A
a : ad
m : Map A
A,B : Type
*****
forall _ : B, eq (MapGet A (M0 A) a1) None
+++++
trivial.
-----
Lemma MapDomRestrBy_semantics : forall (m:Map A) (m':Map B), eqm A (MapGet A (MapDomRestrBy m m')) (fun a0:ad => match MapGet B m' a0 with | None => MapGet A m a0 | _ => None end).
Proof.
unfold eqm in |- *.
simple induction m.
intros.
simpl in |- *.
elim (sumbool_of_bool (Neqb a a1)).
intro H.
rewrite H.
rewrite (Neqb_complete _ _ H).
case (MapGet B m' a1).

*****
H : eq (N.eqb a a1) true
a1 : ad
m' : Map B
a0 : A
a : ad
m : Map A
A,B : Type
*****
eq (MapGet A (M1 A a1 a0) a1) (Some a0)
+++++
apply M1_semantics_1.
-----
Lemma MapDomRestrBy_semantics : forall (m:Map A) (m':Map B), eqm A (MapGet A (MapDomRestrBy m m')) (fun a0:ad => match MapGet B m' a0 with | None => MapGet A m a0 | _ => None end).
Proof.
unfold eqm in |- *.
simple induction m.
intros.
simpl in |- *.
elim (sumbool_of_bool (Neqb a a1)).

*****
a1 : ad
m' : Map B
a0 : A
a : ad
m : Map A
A,B : Type
*****
forall _ : eq (N.eqb a a1) false, eq (MapGet A match MapGet B m' a with | Some _ => M0 A | None => M1 A a a0 end a1) match MapGet B m' a1 with | Some _ => None | None => if N.eqb a a1 then Some a0 else None end
+++++
intro H.
-----
Lemma MapDomRestrBy_semantics : forall (m:Map A) (m':Map B), eqm A (MapGet A (MapDomRestrBy m m')) (fun a0:ad => match MapGet B m' a0 with | None => MapGet A m a0 | _ => None end).
Proof.
unfold eqm in |- *.
simple induction m.
intros.
simpl in |- *.
elim (sumbool_of_bool (Neqb a a1)).
intro H.

*****
H : eq (N.eqb a a1) false
a1 : ad
m' : Map B
a0 : A
a : ad
m : Map A
A,B : Type
*****
eq (MapGet A match MapGet B m' a with | Some _ => M0 A | None => M1 A a a0 end a1) match MapGet B m' a1 with | Some _ => None | None => if N.eqb a a1 then Some a0 else None end
+++++
rewrite H.
-----
Lemma MapDomRestrBy_semantics : forall (m:Map A) (m':Map B), eqm A (MapGet A (MapDomRestrBy m m')) (fun a0:ad => match MapGet B m' a0 with | None => MapGet A m a0 | _ => None end).
Proof.
unfold eqm in |- *.
simple induction m.
intros.
simpl in |- *.
elim (sumbool_of_bool (Neqb a a1)).
intro H.
rewrite H.

*****
H : eq (N.eqb a a1) false
a1 : ad
m' : Map B
a0 : A
a : ad
m : Map A
A,B : Type
*****
eq (MapGet A match MapGet B m' a with | Some _ => M0 A | None => M1 A a a0 end a1) match MapGet B m' a1 with | Some _ | _ => None end
+++++
case (MapGet B m' a).
-----
Lemma MapDomRestrBy_semantics : forall (m:Map A) (m':Map B), eqm A (MapGet A (MapDomRestrBy m m')) (fun a0:ad => match MapGet B m' a0 with | None => MapGet A m a0 | _ => None end).
Proof.
unfold eqm in |- *.
simple induction m.
intros.
simpl in |- *.
elim (sumbool_of_bool (Neqb a a1)).
intro H.
rewrite H.
case (MapGet B m' a).

*****
H : eq (N.eqb a a1) false
a1 : ad
m' : Map B
a0 : A
a : ad
m : Map A
A,B : Type
*****
forall _ : B, eq (MapGet A (M0 A) a1) match MapGet B m' a1 with | Some _ | _ => None end
+++++
case (MapGet B m' a1).
-----
Lemma MapDomRestrBy_semantics : forall (m:Map A) (m':Map B), eqm A (MapGet A (MapDomRestrBy m m')) (fun a0:ad => match MapGet B m' a0 with | None => MapGet A m a0 | _ => None end).
Proof.
unfold eqm in |- *.
simple induction m.
intros.
simpl in |- *.
elim (sumbool_of_bool (Neqb a a1)).
intro H.
rewrite H.
case (MapGet B m' a).
case (MapGet B m' a1).

*****
H : eq (N.eqb a a1) false
a1 : ad
m' : Map B
a0 : A
a : ad
m : Map A
A,B : Type
*****
forall (_ : B) (_ : B), eq (MapGet A (M0 A) a1) None
+++++
trivial.
-----
Lemma MapDomRestrBy_semantics : forall (m:Map A) (m':Map B), eqm A (MapGet A (MapDomRestrBy m m')) (fun a0:ad => match MapGet B m' a0 with | None => MapGet A m a0 | _ => None end).
Proof.
unfold eqm in |- *.
simple induction m.
intros.
simpl in |- *.
elim (sumbool_of_bool (Neqb a a1)).
intro H.
rewrite H.
case (MapGet B m' a).
case (MapGet B m' a1).

*****
H : eq (N.eqb a a1) false
a1 : ad
m' : Map B
a0 : A
a : ad
m : Map A
A,B : Type
*****
forall _ : B, eq (MapGet A (M0 A) a1) None
+++++
trivial.
-----
Lemma MapDomRestrBy_semantics : forall (m:Map A) (m':Map B), eqm A (MapGet A (MapDomRestrBy m m')) (fun a0:ad => match MapGet B m' a0 with | None => MapGet A m a0 | _ => None end).
Proof.
unfold eqm in |- *.
simple induction m.
intros.
simpl in |- *.
elim (sumbool_of_bool (Neqb a a1)).
intro H.
rewrite H.
case (MapGet B m' a).

*****
H : eq (N.eqb a a1) false
a1 : ad
m' : Map B
a0 : A
a : ad
m : Map A
A,B : Type
*****
eq (MapGet A (M1 A a a0) a1) match MapGet B m' a1 with | Some _ | _ => None end
+++++
rewrite (M1_semantics_2 A a a1 a0 H).
-----
Lemma MapDomRestrBy_semantics : forall (m:Map A) (m':Map B), eqm A (MapGet A (MapDomRestrBy m m')) (fun a0:ad => match MapGet B m' a0 with | None => MapGet A m a0 | _ => None end).
Proof.
unfold eqm in |- *.
simple induction m.
intros.
simpl in |- *.
elim (sumbool_of_bool (Neqb a a1)).
intro H.
rewrite H.
case (MapGet B m' a).
rewrite (M1_semantics_2 A a a1 a0 H).

*****
H : eq (N.eqb a a1) false
a1 : ad
m' : Map B
a0 : A
a : ad
m : Map A
A,B : Type
*****
eq None match MapGet B m' a1 with | Some _ | _ => None end
+++++
case (MapGet B m' a1).
-----
Lemma MapDomRestrBy_semantics : forall (m:Map A) (m':Map B), eqm A (MapGet A (MapDomRestrBy m m')) (fun a0:ad => match MapGet B m' a0 with | None => MapGet A m a0 | _ => None end).
Proof.
unfold eqm in |- *.
simple induction m.
intros.
simpl in |- *.
elim (sumbool_of_bool (Neqb a a1)).
intro H.
rewrite H.
case (MapGet B m' a).
rewrite (M1_semantics_2 A a a1 a0 H).
case (MapGet B m' a1).

*****
H : eq (N.eqb a a1) false
a1 : ad
m' : Map B
a0 : A
a : ad
m : Map A
A,B : Type
*****
forall _ : B, eq None None
+++++
trivial.
-----
Lemma MapDomRestrBy_semantics : forall (m:Map A) (m':Map B), eqm A (MapGet A (MapDomRestrBy m m')) (fun a0:ad => match MapGet B m' a0 with | None => MapGet A m a0 | _ => None end).
Proof.
unfold eqm in |- *.
simple induction m.
intros.
simpl in |- *.
elim (sumbool_of_bool (Neqb a a1)).
intro H.
rewrite H.
case (MapGet B m' a).
rewrite (M1_semantics_2 A a a1 a0 H).
case (MapGet B m' a1).

*****
H : eq (N.eqb a a1) false
a1 : ad
m' : Map B
a0 : A
a : ad
m : Map A
A,B : Type
*****
eq None None
+++++
trivial.
-----
Lemma MapDomRestrBy_semantics : forall (m:Map A) (m':Map B), eqm A (MapGet A (MapDomRestrBy m m')) (fun a0:ad => match MapGet B m' a0 with | None => MapGet A m a0 | _ => None end).
Proof.
unfold eqm in |- *.
simple induction m.

*****
m : Map A
A,B : Type
*****
forall (m : Map A) (_ : forall (m' : Map B) (a : ad), eq (MapGet A (MapDomRestrBy m m') a) match MapGet B m' a with | Some _ => None | None => MapGet A m a end) (m0 : Map A) (_ : forall (m' : Map B) (a : ad), eq (MapGet A (MapDomRestrBy m0 m') a) match MapGet B m' a with | Some _ => None | None => MapGet A m0 a end) (m' : Map B) (a : ad), eq (MapGet A (MapDomRestrBy (M2 A m m0) m') a) match MapGet B m' a with | Some _ => None | None => MapGet A (M2 A m m0) a end
+++++
simple induction m'.
-----
Lemma MapDomRestrBy_semantics : forall (m:Map A) (m':Map B), eqm A (MapGet A (MapDomRestrBy m m')) (fun a0:ad => match MapGet B m' a0 with | None => MapGet A m a0 | _ => None end).
Proof.
unfold eqm in |- *.
simple induction m.
simple induction m'.

*****
m' : Map B
H0 : forall (m' : Map B) (a : ad),\neq (MapGet A (MapDomRestrBy m1 m') a)\n match MapGet B m' a with\n | Some _ => None\n | None => MapGet A m1 a\n end
m1 : Map A
H : forall (m' : Map B) (a : ad),\neq (MapGet A (MapDomRestrBy m0 m') a)\n match MapGet B m' a with\n | Some _ => None\n | None => MapGet A m0 a\n end
m,m0 : Map A
A,B : Type
*****
forall a : ad, eq (MapGet A (MapDomRestrBy (M2 A m0 m1) (M0 B)) a) match MapGet B (M0 B) a with | Some _ => None | None => MapGet A (M2 A m0 m1) a end
+++++
trivial.
-----
Lemma MapDomRestrBy_semantics : forall (m:Map A) (m':Map B), eqm A (MapGet A (MapDomRestrBy m m')) (fun a0:ad => match MapGet B m' a0 with | None => MapGet A m a0 | _ => None end).
Proof.
unfold eqm in |- *.
simple induction m.
simple induction m'.

*****
m' : Map B
H0 : forall (m' : Map B) (a : ad),\neq (MapGet A (MapDomRestrBy m1 m') a)\n match MapGet B m' a with\n | Some _ => None\n | None => MapGet A m1 a\n end
m1 : Map A
H : forall (m' : Map B) (a : ad),\neq (MapGet A (MapDomRestrBy m0 m') a)\n match MapGet B m' a with\n | Some _ => None\n | None => MapGet A m0 a\n end
m,m0 : Map A
A,B : Type
*****
forall (a : ad) (a0 : B) (a1 : ad), eq (MapGet A (MapDomRestrBy (M2 A m0 m1) (M1 B a a0)) a1) match MapGet B (M1 B a a0) a1 with | Some _ => None | None => MapGet A (M2 A m0 m1) a1 end
+++++
unfold MapDomRestrBy in |- *.
-----
Lemma MapDomRestrBy_semantics : forall (m:Map A) (m':Map B), eqm A (MapGet A (MapDomRestrBy m m')) (fun a0:ad => match MapGet B m' a0 with | None => MapGet A m a0 | _ => None end).
Proof.
unfold eqm in |- *.
simple induction m.
simple induction m'.
unfold MapDomRestrBy in |- *.

*****
m' : Map B
H0 : forall (m' : Map B) (a : ad),\neq (MapGet A (MapDomRestrBy m1 m') a)\n match MapGet B m' a with\n | Some _ => None\n | None => MapGet A m1 a\n end
m1 : Map A
H : forall (m' : Map B) (a : ad),\neq (MapGet A (MapDomRestrBy m0 m') a)\n match MapGet B m' a with\n | Some _ => None\n | None => MapGet A m0 a\n end
m,m0 : Map A
A,B : Type
*****
forall (a : ad) (a0 : B) (a1 : ad), eq (MapGet A (MapRemove A (M2 A m0 m1) a) a1) match MapGet B (M1 B a a0) a1 with | Some _ => None | None => MapGet A (M2 A m0 m1) a1 end
+++++
intros.
-----
Lemma MapDomRestrBy_semantics : forall (m:Map A) (m':Map B), eqm A (MapGet A (MapDomRestrBy m m')) (fun a0:ad => match MapGet B m' a0 with | None => MapGet A m a0 | _ => None end).
Proof.
unfold eqm in |- *.
simple induction m.
simple induction m'.
unfold MapDomRestrBy in |- *.
intros.

*****
a1 : ad
a0 : B
a : ad
m' : Map B
H0 : forall (m' : Map B) (a : ad),\neq (MapGet A (MapDomRestrBy m1 m') a)\n match MapGet B m' a with\n | Some _ => None\n | None => MapGet A m1 a\n end
m1 : Map A
H : forall (m' : Map B) (a : ad),\neq (MapGet A (MapDomRestrBy m0 m') a)\n match MapGet B m' a with\n | Some _ => None\n | None => MapGet A m0 a\n end
m,m0 : Map A
A,B : Type
*****
eq (MapGet A (MapRemove A (M2 A m0 m1) a) a1) match MapGet B (M1 B a a0) a1 with | Some _ => None | None => MapGet A (M2 A m0 m1) a1 end
+++++
rewrite (MapRemove_semantics A (M2 A m0 m1) a a1).
-----
Lemma MapDomRestrBy_semantics : forall (m:Map A) (m':Map B), eqm A (MapGet A (MapDomRestrBy m m')) (fun a0:ad => match MapGet B m' a0 with | None => MapGet A m a0 | _ => None end).
Proof.
unfold eqm in |- *.
simple induction m.
simple induction m'.
unfold MapDomRestrBy in |- *.
intros.
rewrite (MapRemove_semantics A (M2 A m0 m1) a a1).

*****
a1 : ad
a0 : B
a : ad
m' : Map B
H0 : forall (m' : Map B) (a : ad),\neq (MapGet A (MapDomRestrBy m1 m') a)\n match MapGet B m' a with\n | Some _ => None\n | None => MapGet A m1 a\n end
m1 : Map A
H : forall (m' : Map B) (a : ad),\neq (MapGet A (MapDomRestrBy m0 m') a)\n match MapGet B m' a with\n | Some _ => None\n | None => MapGet A m0 a\n end
m,m0 : Map A
A,B : Type
*****
eq (if N.eqb a a1 then None else MapGet A (M2 A m0 m1) a1) match MapGet B (M1 B a a0) a1 with | Some _ => None | None => MapGet A (M2 A m0 m1) a1 end
+++++
elim (sumbool_of_bool (Neqb a a1)).
-----
Lemma MapDomRestrBy_semantics : forall (m:Map A) (m':Map B), eqm A (MapGet A (MapDomRestrBy m m')) (fun a0:ad => match MapGet B m' a0 with | None => MapGet A m a0 | _ => None end).
Proof.
unfold eqm in |- *.
simple induction m.
simple induction m'.
unfold MapDomRestrBy in |- *.
intros.
rewrite (MapRemove_semantics A (M2 A m0 m1) a a1).
elim (sumbool_of_bool (Neqb a a1)).

*****
a1 : ad
a0 : B
a : ad
m' : Map B
H0 : forall (m' : Map B) (a : ad),\neq (MapGet A (MapDomRestrBy m1 m') a)\n match MapGet B m' a with\n | Some _ => None\n | None => MapGet A m1 a\n end
m1 : Map A
H : forall (m' : Map B) (a : ad),\neq (MapGet A (MapDomRestrBy m0 m') a)\n match MapGet B m' a with\n | Some _ => None\n | None => MapGet A m0 a\n end
m,m0 : Map A
A,B : Type
*****
forall _ : eq (N.eqb a a1) true, eq (if N.eqb a a1 then None else MapGet A (M2 A m0 m1) a1) match MapGet B (M1 B a a0) a1 with | Some _ => None | None => MapGet A (M2 A m0 m1) a1 end
+++++
intro H1.
-----
Lemma MapDomRestrBy_semantics : forall (m:Map A) (m':Map B), eqm A (MapGet A (MapDomRestrBy m m')) (fun a0:ad => match MapGet B m' a0 with | None => MapGet A m a0 | _ => None end).
Proof.
unfold eqm in |- *.
simple induction m.
simple induction m'.
unfold MapDomRestrBy in |- *.
intros.
rewrite (MapRemove_semantics A (M2 A m0 m1) a a1).
elim (sumbool_of_bool (Neqb a a1)).
intro H1.

*****
H1 : eq (N.eqb a a1) true
a1 : ad
a0 : B
a : ad
m' : Map B
H0 : forall (m' : Map B) (a : ad),\neq (MapGet A (MapDomRestrBy m1 m') a)\n match MapGet B m' a with\n | Some _ => None\n | None => MapGet A m1 a\n end
m1 : Map A
H : forall (m' : Map B) (a : ad),\neq (MapGet A (MapDomRestrBy m0 m') a)\n match MapGet B m' a with\n | Some _ => None\n | None => MapGet A m0 a\n end
m,m0 : Map A
A,B : Type
*****
eq (if N.eqb a a1 then None else MapGet A (M2 A m0 m1) a1) match MapGet B (M1 B a a0) a1 with | Some _ => None | None => MapGet A (M2 A m0 m1) a1 end
+++++
rewrite H1.
-----
Lemma MapDomRestrBy_semantics : forall (m:Map A) (m':Map B), eqm A (MapGet A (MapDomRestrBy m m')) (fun a0:ad => match MapGet B m' a0 with | None => MapGet A m a0 | _ => None end).
Proof.
unfold eqm in |- *.
simple induction m.
simple induction m'.
unfold MapDomRestrBy in |- *.
intros.
rewrite (MapRemove_semantics A (M2 A m0 m1) a a1).
elim (sumbool_of_bool (Neqb a a1)).
intro H1.
rewrite H1.

*****
H1 : eq (N.eqb a a1) true
a1 : ad
a0 : B
a : ad
m' : Map B
H0 : forall (m' : Map B) (a : ad),\neq (MapGet A (MapDomRestrBy m1 m') a)\n match MapGet B m' a with\n | Some _ => None\n | None => MapGet A m1 a\n end
m1 : Map A
H : forall (m' : Map B) (a : ad),\neq (MapGet A (MapDomRestrBy m0 m') a)\n match MapGet B m' a with\n | Some _ => None\n | None => MapGet A m0 a\n end
m,m0 : Map A
A,B : Type
*****
eq None match MapGet B (M1 B a a0) a1 with | Some _ => None | None => MapGet A (M2 A m0 m1) a1 end
+++++
rewrite (Neqb_complete _ _ H1).
-----
Lemma MapDomRestrBy_semantics : forall (m:Map A) (m':Map B), eqm A (MapGet A (MapDomRestrBy m m')) (fun a0:ad => match MapGet B m' a0 with | None => MapGet A m a0 | _ => None end).
Proof.
unfold eqm in |- *.
simple induction m.
simple induction m'.
unfold MapDomRestrBy in |- *.
intros.
rewrite (MapRemove_semantics A (M2 A m0 m1) a a1).
elim (sumbool_of_bool (Neqb a a1)).
intro H1.
rewrite H1.
rewrite (Neqb_complete _ _ H1).

*****
H1 : eq (N.eqb a a1) true
a1 : ad
a0 : B
a : ad
m' : Map B
H0 : forall (m' : Map B) (a : ad),\neq (MapGet A (MapDomRestrBy m1 m') a)\n match MapGet B m' a with\n | Some _ => None\n | None => MapGet A m1 a\n end
m1 : Map A
H : forall (m' : Map B) (a : ad),\neq (MapGet A (MapDomRestrBy m0 m') a)\n match MapGet B m' a with\n | Some _ => None\n | None => MapGet A m0 a\n end
m,m0 : Map A
A,B : Type
*****
eq None match MapGet B (M1 B a1 a0) a1 with | Some _ => None | None => MapGet A (M2 A m0 m1) a1 end
+++++
rewrite (M1_semantics_1 B a1 a0).
-----
Lemma MapDomRestrBy_semantics : forall (m:Map A) (m':Map B), eqm A (MapGet A (MapDomRestrBy m m')) (fun a0:ad => match MapGet B m' a0 with | None => MapGet A m a0 | _ => None end).
Proof.
unfold eqm in |- *.
simple induction m.
simple induction m'.
unfold MapDomRestrBy in |- *.
intros.
rewrite (MapRemove_semantics A (M2 A m0 m1) a a1).
elim (sumbool_of_bool (Neqb a a1)).
intro H1.
rewrite H1.
rewrite (Neqb_complete _ _ H1).
rewrite (M1_semantics_1 B a1 a0).

*****
H1 : eq (N.eqb a a1) true
a1 : ad
a0 : B
a : ad
m' : Map B
H0 : forall (m' : Map B) (a : ad),\neq (MapGet A (MapDomRestrBy m1 m') a)\n match MapGet B m' a with\n | Some _ => None\n | None => MapGet A m1 a\n end
m1 : Map A
H : forall (m' : Map B) (a : ad),\neq (MapGet A (MapDomRestrBy m0 m') a)\n match MapGet B m' a with\n | Some _ => None\n | None => MapGet A m0 a\n end
m,m0 : Map A
A,B : Type
*****
eq None None
+++++
reflexivity.
-----
Lemma MapDomRestrBy_semantics : forall (m:Map A) (m':Map B), eqm A (MapGet A (MapDomRestrBy m m')) (fun a0:ad => match MapGet B m' a0 with | None => MapGet A m a0 | _ => None end).
Proof.
unfold eqm in |- *.
simple induction m.
simple induction m'.
unfold MapDomRestrBy in |- *.
intros.
rewrite (MapRemove_semantics A (M2 A m0 m1) a a1).
elim (sumbool_of_bool (Neqb a a1)).

*****
a1 : ad
a0 : B
a : ad
m' : Map B
H0 : forall (m' : Map B) (a : ad),\neq (MapGet A (MapDomRestrBy m1 m') a)\n match MapGet B m' a with\n | Some _ => None\n | None => MapGet A m1 a\n end
m1 : Map A
H : forall (m' : Map B) (a : ad),\neq (MapGet A (MapDomRestrBy m0 m') a)\n match MapGet B m' a with\n | Some _ => None\n | None => MapGet A m0 a\n end
m,m0 : Map A
A,B : Type
*****
forall _ : eq (N.eqb a a1) false, eq (if N.eqb a a1 then None else MapGet A (M2 A m0 m1) a1) match MapGet B (M1 B a a0) a1 with | Some _ => None | None => MapGet A (M2 A m0 m1) a1 end
+++++
intro H1.
-----
Lemma MapDomRestrBy_semantics : forall (m:Map A) (m':Map B), eqm A (MapGet A (MapDomRestrBy m m')) (fun a0:ad => match MapGet B m' a0 with | None => MapGet A m a0 | _ => None end).
Proof.
unfold eqm in |- *.
simple induction m.
simple induction m'.
unfold MapDomRestrBy in |- *.
intros.
rewrite (MapRemove_semantics A (M2 A m0 m1) a a1).
elim (sumbool_of_bool (Neqb a a1)).
intro H1.

*****
H1 : eq (N.eqb a a1) false
a1 : ad
a0 : B
a : ad
m' : Map B
H0 : forall (m' : Map B) (a : ad),\neq (MapGet A (MapDomRestrBy m1 m') a)\n match MapGet B m' a with\n | Some _ => None\n | None => MapGet A m1 a\n end
m1 : Map A
H : forall (m' : Map B) (a : ad),\neq (MapGet A (MapDomRestrBy m0 m') a)\n match MapGet B m' a with\n | Some _ => None\n | None => MapGet A m0 a\n end
m,m0 : Map A
A,B : Type
*****
eq (if N.eqb a a1 then None else MapGet A (M2 A m0 m1) a1) match MapGet B (M1 B a a0) a1 with | Some _ => None | None => MapGet A (M2 A m0 m1) a1 end
+++++
rewrite H1.
-----
Lemma MapDomRestrBy_semantics : forall (m:Map A) (m':Map B), eqm A (MapGet A (MapDomRestrBy m m')) (fun a0:ad => match MapGet B m' a0 with | None => MapGet A m a0 | _ => None end).
Proof.
unfold eqm in |- *.
simple induction m.
simple induction m'.
unfold MapDomRestrBy in |- *.
intros.
rewrite (MapRemove_semantics A (M2 A m0 m1) a a1).
elim (sumbool_of_bool (Neqb a a1)).
intro H1.
rewrite H1.

*****
H1 : eq (N.eqb a a1) false
a1 : ad
a0 : B
a : ad
m' : Map B
H0 : forall (m' : Map B) (a : ad),\neq (MapGet A (MapDomRestrBy m1 m') a)\n match MapGet B m' a with\n | Some _ => None\n | None => MapGet A m1 a\n end
m1 : Map A
H : forall (m' : Map B) (a : ad),\neq (MapGet A (MapDomRestrBy m0 m') a)\n match MapGet B m' a with\n | Some _ => None\n | None => MapGet A m0 a\n end
m,m0 : Map A
A,B : Type
*****
eq (MapGet A (M2 A m0 m1) a1) match MapGet B (M1 B a a0) a1 with | Some _ => None | None => MapGet A (M2 A m0 m1) a1 end
+++++
rewrite (M1_semantics_2 B a a1 a0 H1).
-----
Lemma MapDomRestrBy_semantics : forall (m:Map A) (m':Map B), eqm A (MapGet A (MapDomRestrBy m m')) (fun a0:ad => match MapGet B m' a0 with | None => MapGet A m a0 | _ => None end).
Proof.
unfold eqm in |- *.
simple induction m.
simple induction m'.
unfold MapDomRestrBy in |- *.
intros.
rewrite (MapRemove_semantics A (M2 A m0 m1) a a1).
elim (sumbool_of_bool (Neqb a a1)).
intro H1.
rewrite H1.
rewrite (M1_semantics_2 B a a1 a0 H1).

*****
H1 : eq (N.eqb a a1) false
a1 : ad
a0 : B
a : ad
m' : Map B
H0 : forall (m' : Map B) (a : ad),\neq (MapGet A (MapDomRestrBy m1 m') a)\n match MapGet B m' a with\n | Some _ => None\n | None => MapGet A m1 a\n end
m1 : Map A
H : forall (m' : Map B) (a : ad),\neq (MapGet A (MapDomRestrBy m0 m') a)\n match MapGet B m' a with\n | Some _ => None\n | None => MapGet A m0 a\n end
m,m0 : Map A
A,B : Type
*****
eq (MapGet A (M2 A m0 m1) a1) (MapGet A (M2 A m0 m1) a1)
+++++
reflexivity.
-----
Lemma MapDomRestrBy_semantics : forall (m:Map A) (m':Map B), eqm A (MapGet A (MapDomRestrBy m m')) (fun a0:ad => match MapGet B m' a0 with | None => MapGet A m a0 | _ => None end).
Proof.
unfold eqm in |- *.
simple induction m.
simple induction m'.

*****
m' : Map B
H0 : forall (m' : Map B) (a : ad),\neq (MapGet A (MapDomRestrBy m1 m') a)\n match MapGet B m' a with\n | Some _ => None\n | None => MapGet A m1 a\n end
m1 : Map A
H : forall (m' : Map B) (a : ad),\neq (MapGet A (MapDomRestrBy m0 m') a)\n match MapGet B m' a with\n | Some _ => None\n | None => MapGet A m0 a\n end
m,m0 : Map A
A,B : Type
*****
forall (m : Map B) (_ : forall a : ad, eq (MapGet A (MapDomRestrBy (M2 A m0 m1) m) a) match MapGet B m a with | Some _ => None | None => MapGet A (M2 A m0 m1) a end) (m2 : Map B) (_ : forall a : ad, eq (MapGet A (MapDomRestrBy (M2 A m0 m1) m2) a) match MapGet B m2 a with | Some _ => None | None => MapGet A (M2 A m0 m1) a end) (a : ad), eq (MapGet A (MapDomRestrBy (M2 A m0 m1) (M2 B m m2)) a) match MapGet B (M2 B m m2) a with | Some _ => None | None => MapGet A (M2 A m0 m1) a end
+++++
intros.
-----
Lemma MapDomRestrBy_semantics : forall (m:Map A) (m':Map B), eqm A (MapGet A (MapDomRestrBy m m')) (fun a0:ad => match MapGet B m' a0 with | None => MapGet A m a0 | _ => None end).
Proof.
unfold eqm in |- *.
simple induction m.
simple induction m'.
intros.

*****
a : ad
H2 : forall a : ad,\neq (MapGet A (MapDomRestrBy (M2 A m0 m1) m3) a)\n match MapGet B m3 a with\n | Some _ => None\n | None => MapGet A (M2 A m0 m1) a\n end
m3 : Map B
H1 : forall a : ad,\neq (MapGet A (MapDomRestrBy (M2 A m0 m1) m2) a)\n match MapGet B m2 a with\n | Some _ => None\n | None => MapGet A (M2 A m0 m1) a\n end
m',m2 : Map B
H0 : forall (m' : Map B) (a : ad),\neq (MapGet A (MapDomRestrBy m1 m') a)\n match MapGet B m' a with\n | Some _ => None\n | None => MapGet A m1 a\n end
m1 : Map A
H : forall (m' : Map B) (a : ad),\neq (MapGet A (MapDomRestrBy m0 m') a)\n match MapGet B m' a with\n | Some _ => None\n | None => MapGet A m0 a\n end
m,m0 : Map A
A,B : Type
*****
eq (MapGet A (MapDomRestrBy (M2 A m0 m1) (M2 B m2 m3)) a) match MapGet B (M2 B m2 m3) a with | Some _ => None | None => MapGet A (M2 A m0 m1) a end
+++++
change (MapGet A (makeM2 A (MapDomRestrBy m0 m2) (MapDomRestrBy m1 m3)) a = match MapGet B (M2 B m2 m3) a with | None => MapGet A (M2 A m0 m1) a | Some _ => None end) in |- *.
-----
Lemma MapDomRestrBy_semantics : forall (m:Map A) (m':Map B), eqm A (MapGet A (MapDomRestrBy m m')) (fun a0:ad => match MapGet B m' a0 with | None => MapGet A m a0 | _ => None end).
Proof.
unfold eqm in |- *.
simple induction m.
simple induction m'.
intros.
change (MapGet A (makeM2 A (MapDomRestrBy m0 m2) (MapDomRestrBy m1 m3)) a = match MapGet B (M2 B m2 m3) a with | None => MapGet A (M2 A m0 m1) a | Some _ => None end) in |- *.

*****
a : ad
H2 : forall a : ad,\neq (MapGet A (MapDomRestrBy (M2 A m0 m1) m3) a)\n match MapGet B m3 a with\n | Some _ => None\n | None => MapGet A (M2 A m0 m1) a\n end
m3 : Map B
H1 : forall a : ad,\neq (MapGet A (MapDomRestrBy (M2 A m0 m1) m2) a)\n match MapGet B m2 a with\n | Some _ => None\n | None => MapGet A (M2 A m0 m1) a\n end
m',m2 : Map B
H0 : forall (m' : Map B) (a : ad),\neq (MapGet A (MapDomRestrBy m1 m') a)\n match MapGet B m' a with\n | Some _ => None\n | None => MapGet A m1 a\n end
m1 : Map A
H : forall (m' : Map B) (a : ad),\neq (MapGet A (MapDomRestrBy m0 m') a)\n match MapGet B m' a with\n | Some _ => None\n | None => MapGet A m0 a\n end
m,m0 : Map A
A,B : Type
*****
eq (MapGet A (makeM2 A (MapDomRestrBy m0 m2) (MapDomRestrBy m1 m3)) a) match MapGet B (M2 B m2 m3) a with | Some _ => None | None => MapGet A (M2 A m0 m1) a end
+++++
rewrite (makeM2_M2 A (MapDomRestrBy m0 m2) (MapDomRestrBy m1 m3) a).
-----
Lemma MapDomRestrBy_semantics : forall (m:Map A) (m':Map B), eqm A (MapGet A (MapDomRestrBy m m')) (fun a0:ad => match MapGet B m' a0 with | None => MapGet A m a0 | _ => None end).
Proof.
unfold eqm in |- *.
simple induction m.
simple induction m'.
intros.
change (MapGet A (makeM2 A (MapDomRestrBy m0 m2) (MapDomRestrBy m1 m3)) a = match MapGet B (M2 B m2 m3) a with | None => MapGet A (M2 A m0 m1) a | Some _ => None end) in |- *.
rewrite (makeM2_M2 A (MapDomRestrBy m0 m2) (MapDomRestrBy m1 m3) a).

*****
a : ad
H2 : forall a : ad,\neq (MapGet A (MapDomRestrBy (M2 A m0 m1) m3) a)\n match MapGet B m3 a with\n | Some _ => None\n | None => MapGet A (M2 A m0 m1) a\n end
m3 : Map B
H1 : forall a : ad,\neq (MapGet A (MapDomRestrBy (M2 A m0 m1) m2) a)\n match MapGet B m2 a with\n | Some _ => None\n | None => MapGet A (M2 A m0 m1) a\n end
m',m2 : Map B
H0 : forall (m' : Map B) (a : ad),\neq (MapGet A (MapDomRestrBy m1 m') a)\n match MapGet B m' a with\n | Some _ => None\n | None => MapGet A m1 a\n end
m1 : Map A
H : forall (m' : Map B) (a : ad),\neq (MapGet A (MapDomRestrBy m0 m') a)\n match MapGet B m' a with\n | Some _ => None\n | None => MapGet A m0 a\n end
m,m0 : Map A
A,B : Type
*****
eq (MapGet A (M2 A (MapDomRestrBy m0 m2) (MapDomRestrBy m1 m3)) a) match MapGet B (M2 B m2 m3) a with | Some _ => None | None => MapGet A (M2 A m0 m1) a end
+++++
rewrite MapGet_M2_bit_0_if.
-----
Lemma MapDomRestrBy_semantics : forall (m:Map A) (m':Map B), eqm A (MapGet A (MapDomRestrBy m m')) (fun a0:ad => match MapGet B m' a0 with | None => MapGet A m a0 | _ => None end).
Proof.
unfold eqm in |- *.
simple induction m.
simple induction m'.
intros.
change (MapGet A (makeM2 A (MapDomRestrBy m0 m2) (MapDomRestrBy m1 m3)) a = match MapGet B (M2 B m2 m3) a with | None => MapGet A (M2 A m0 m1) a | Some _ => None end) in |- *.
rewrite (makeM2_M2 A (MapDomRestrBy m0 m2) (MapDomRestrBy m1 m3) a).
rewrite MapGet_M2_bit_0_if.

*****
a : ad
H2 : forall a : ad,\neq (MapGet A (MapDomRestrBy (M2 A m0 m1) m3) a)\n match MapGet B m3 a with\n | Some _ => None\n | None => MapGet A (M2 A m0 m1) a\n end
m3 : Map B
H1 : forall a : ad,\neq (MapGet A (MapDomRestrBy (M2 A m0 m1) m2) a)\n match MapGet B m2 a with\n | Some _ => None\n | None => MapGet A (M2 A m0 m1) a\n end
m',m2 : Map B
H0 : forall (m' : Map B) (a : ad),\neq (MapGet A (MapDomRestrBy m1 m') a)\n match MapGet B m' a with\n | Some _ => None\n | None => MapGet A m1 a\n end
m1 : Map A
H : forall (m' : Map B) (a : ad),\neq (MapGet A (MapDomRestrBy m0 m') a)\n match MapGet B m' a with\n | Some _ => None\n | None => MapGet A m0 a\n end
m,m0 : Map A
A,B : Type
*****
eq (if N.odd a then MapGet A (MapDomRestrBy m1 m3) (N.div2 a) else MapGet A (MapDomRestrBy m0 m2) (N.div2 a)) match MapGet B (M2 B m2 m3) a with | Some _ => None | None => MapGet A (M2 A m0 m1) a end
+++++
rewrite (H0 m3 (Ndiv2 a)).
-----
Lemma MapDomRestrBy_semantics : forall (m:Map A) (m':Map B), eqm A (MapGet A (MapDomRestrBy m m')) (fun a0:ad => match MapGet B m' a0 with | None => MapGet A m a0 | _ => None end).
Proof.
unfold eqm in |- *.
simple induction m.
simple induction m'.
intros.
change (MapGet A (makeM2 A (MapDomRestrBy m0 m2) (MapDomRestrBy m1 m3)) a = match MapGet B (M2 B m2 m3) a with | None => MapGet A (M2 A m0 m1) a | Some _ => None end) in |- *.
rewrite (makeM2_M2 A (MapDomRestrBy m0 m2) (MapDomRestrBy m1 m3) a).
rewrite MapGet_M2_bit_0_if.
rewrite (H0 m3 (Ndiv2 a)).

*****
a : ad
H2 : forall a : ad,\neq (MapGet A (MapDomRestrBy (M2 A m0 m1) m3) a)\n match MapGet B m3 a with\n | Some _ => None\n | None => MapGet A (M2 A m0 m1) a\n end
m3 : Map B
H1 : forall a : ad,\neq (MapGet A (MapDomRestrBy (M2 A m0 m1) m2) a)\n match MapGet B m2 a with\n | Some _ => None\n | None => MapGet A (M2 A m0 m1) a\n end
m',m2 : Map B
H0 : forall (m' : Map B) (a : ad),\neq (MapGet A (MapDomRestrBy m1 m') a)\n match MapGet B m' a with\n | Some _ => None\n | None => MapGet A m1 a\n end
m1 : Map A
H : forall (m' : Map B) (a : ad),\neq (MapGet A (MapDomRestrBy m0 m') a)\n match MapGet B m' a with\n | Some _ => None\n | None => MapGet A m0 a\n end
m,m0 : Map A
A,B : Type
*****
eq (if N.odd a then match MapGet B m3 (N.div2 a) with | Some _ => None | None => MapGet A m1 (N.div2 a) end else MapGet A (MapDomRestrBy m0 m2) (N.div2 a)) match MapGet B (M2 B m2 m3) a with | Some _ => None | None => MapGet A (M2 A m0 m1) a end
+++++
rewrite (H m2 (Ndiv2 a)).
-----
Lemma MapDomRestrBy_semantics : forall (m:Map A) (m':Map B), eqm A (MapGet A (MapDomRestrBy m m')) (fun a0:ad => match MapGet B m' a0 with | None => MapGet A m a0 | _ => None end).
Proof.
unfold eqm in |- *.
simple induction m.
simple induction m'.
intros.
change (MapGet A (makeM2 A (MapDomRestrBy m0 m2) (MapDomRestrBy m1 m3)) a = match MapGet B (M2 B m2 m3) a with | None => MapGet A (M2 A m0 m1) a | Some _ => None end) in |- *.
rewrite (makeM2_M2 A (MapDomRestrBy m0 m2) (MapDomRestrBy m1 m3) a).
rewrite MapGet_M2_bit_0_if.
rewrite (H0 m3 (Ndiv2 a)).
rewrite (H m2 (Ndiv2 a)).

*****
a : ad
H2 : forall a : ad,\neq (MapGet A (MapDomRestrBy (M2 A m0 m1) m3) a)\n match MapGet B m3 a with\n | Some _ => None\n | None => MapGet A (M2 A m0 m1) a\n end
m3 : Map B
H1 : forall a : ad,\neq (MapGet A (MapDomRestrBy (M2 A m0 m1) m2) a)\n match MapGet B m2 a with\n | Some _ => None\n | None => MapGet A (M2 A m0 m1) a\n end
m',m2 : Map B
H0 : forall (m' : Map B) (a : ad),\neq (MapGet A (MapDomRestrBy m1 m') a)\n match MapGet B m' a with\n | Some _ => None\n | None => MapGet A m1 a\n end
m1 : Map A
H : forall (m' : Map B) (a : ad),\neq (MapGet A (MapDomRestrBy m0 m') a)\n match MapGet B m' a with\n | Some _ => None\n | None => MapGet A m0 a\n end
m,m0 : Map A
A,B : Type
*****
eq (if N.odd a then match MapGet B m3 (N.div2 a) with | Some _ => None | None => MapGet A m1 (N.div2 a) end else match MapGet B m2 (N.div2 a) with | Some _ => None | None => MapGet A m0 (N.div2 a) end) match MapGet B (M2 B m2 m3) a with | Some _ => None | None => MapGet A (M2 A m0 m1) a end
+++++
rewrite (MapGet_M2_bit_0_if B m2 m3 a).
-----
Lemma MapDomRestrBy_semantics : forall (m:Map A) (m':Map B), eqm A (MapGet A (MapDomRestrBy m m')) (fun a0:ad => match MapGet B m' a0 with | None => MapGet A m a0 | _ => None end).
Proof.
unfold eqm in |- *.
simple induction m.
simple induction m'.
intros.
change (MapGet A (makeM2 A (MapDomRestrBy m0 m2) (MapDomRestrBy m1 m3)) a = match MapGet B (M2 B m2 m3) a with | None => MapGet A (M2 A m0 m1) a | Some _ => None end) in |- *.
rewrite (makeM2_M2 A (MapDomRestrBy m0 m2) (MapDomRestrBy m1 m3) a).
rewrite MapGet_M2_bit_0_if.
rewrite (H0 m3 (Ndiv2 a)).
rewrite (H m2 (Ndiv2 a)).
rewrite (MapGet_M2_bit_0_if B m2 m3 a).

*****
a : ad
H2 : forall a : ad,\neq (MapGet A (MapDomRestrBy (M2 A m0 m1) m3) a)\n match MapGet B m3 a with\n | Some _ => None\n | None => MapGet A (M2 A m0 m1) a\n end
m3 : Map B
H1 : forall a : ad,\neq (MapGet A (MapDomRestrBy (M2 A m0 m1) m2) a)\n match MapGet B m2 a with\n | Some _ => None\n | None => MapGet A (M2 A m0 m1) a\n end
m',m2 : Map B
H0 : forall (m' : Map B) (a : ad),\neq (MapGet A (MapDomRestrBy m1 m') a)\n match MapGet B m' a with\n | Some _ => None\n | None => MapGet A m1 a\n end
m1 : Map A
H : forall (m' : Map B) (a : ad),\neq (MapGet A (MapDomRestrBy m0 m') a)\n match MapGet B m' a with\n | Some _ => None\n | None => MapGet A m0 a\n end
m,m0 : Map A
A,B : Type
*****
eq (if N.odd a then match MapGet B m3 (N.div2 a) with | Some _ => None | None => MapGet A m1 (N.div2 a) end else match MapGet B m2 (N.div2 a) with | Some _ => None | None => MapGet A m0 (N.div2 a) end) match (if N.odd a then MapGet B m3 (N.div2 a) else MapGet B m2 (N.div2 a)) with | Some _ => None | None => MapGet A (M2 A m0 m1) a end
+++++
rewrite (MapGet_M2_bit_0_if A m0 m1 a).
-----
Lemma MapDomRestrBy_semantics : forall (m:Map A) (m':Map B), eqm A (MapGet A (MapDomRestrBy m m')) (fun a0:ad => match MapGet B m' a0 with | None => MapGet A m a0 | _ => None end).
Proof.
unfold eqm in |- *.
simple induction m.
simple induction m'.
intros.
change (MapGet A (makeM2 A (MapDomRestrBy m0 m2) (MapDomRestrBy m1 m3)) a = match MapGet B (M2 B m2 m3) a with | None => MapGet A (M2 A m0 m1) a | Some _ => None end) in |- *.
rewrite (makeM2_M2 A (MapDomRestrBy m0 m2) (MapDomRestrBy m1 m3) a).
rewrite MapGet_M2_bit_0_if.
rewrite (H0 m3 (Ndiv2 a)).
rewrite (H m2 (Ndiv2 a)).
rewrite (MapGet_M2_bit_0_if B m2 m3 a).
rewrite (MapGet_M2_bit_0_if A m0 m1 a).

*****
a : ad
H2 : forall a : ad,\neq (MapGet A (MapDomRestrBy (M2 A m0 m1) m3) a)\n match MapGet B m3 a with\n | Some _ => None\n | None => MapGet A (M2 A m0 m1) a\n end
m3 : Map B
H1 : forall a : ad,\neq (MapGet A (MapDomRestrBy (M2 A m0 m1) m2) a)\n match MapGet B m2 a with\n | Some _ => None\n | None => MapGet A (M2 A m0 m1) a\n end
m',m2 : Map B
H0 : forall (m' : Map B) (a : ad),\neq (MapGet A (MapDomRestrBy m1 m') a)\n match MapGet B m' a with\n | Some _ => None\n | None => MapGet A m1 a\n end
m1 : Map A
H : forall (m' : Map B) (a : ad),\neq (MapGet A (MapDomRestrBy m0 m') a)\n match MapGet B m' a with\n | Some _ => None\n | None => MapGet A m0 a\n end
m,m0 : Map A
A,B : Type
*****
eq (if N.odd a then match MapGet B m3 (N.div2 a) with | Some _ => None | None => MapGet A m1 (N.div2 a) end else match MapGet B m2 (N.div2 a) with | Some _ => None | None => MapGet A m0 (N.div2 a) end) match (if N.odd a then MapGet B m3 (N.div2 a) else MapGet B m2 (N.div2 a)) with | Some _ => None | None => if N.odd a then MapGet A m1 (N.div2 a) else MapGet A m0 (N.div2 a) end
+++++
case (Nbit0 a).
-----
Lemma MapDomRestrBy_semantics : forall (m:Map A) (m':Map B), eqm A (MapGet A (MapDomRestrBy m m')) (fun a0:ad => match MapGet B m' a0 with | None => MapGet A m a0 | _ => None end).
Proof.
unfold eqm in |- *.
simple induction m.
simple induction m'.
intros.
change (MapGet A (makeM2 A (MapDomRestrBy m0 m2) (MapDomRestrBy m1 m3)) a = match MapGet B (M2 B m2 m3) a with | None => MapGet A (M2 A m0 m1) a | Some _ => None end) in |- *.
rewrite (makeM2_M2 A (MapDomRestrBy m0 m2) (MapDomRestrBy m1 m3) a).
rewrite MapGet_M2_bit_0_if.
rewrite (H0 m3 (Ndiv2 a)).
rewrite (H m2 (Ndiv2 a)).
rewrite (MapGet_M2_bit_0_if B m2 m3 a).
rewrite (MapGet_M2_bit_0_if A m0 m1 a).
case (Nbit0 a).

*****
a : ad
H2 : forall a : ad,\neq (MapGet A (MapDomRestrBy (M2 A m0 m1) m3) a)\n match MapGet B m3 a with\n | Some _ => None\n | None => MapGet A (M2 A m0 m1) a\n end
m3 : Map B
H1 : forall a : ad,\neq (MapGet A (MapDomRestrBy (M2 A m0 m1) m2) a)\n match MapGet B m2 a with\n | Some _ => None\n | None => MapGet A (M2 A m0 m1) a\n end
m',m2 : Map B
H0 : forall (m' : Map B) (a : ad),\neq (MapGet A (MapDomRestrBy m1 m') a)\n match MapGet B m' a with\n | Some _ => None\n | None => MapGet A m1 a\n end
m1 : Map A
H : forall (m' : Map B) (a : ad),\neq (MapGet A (MapDomRestrBy m0 m') a)\n match MapGet B m' a with\n | Some _ => None\n | None => MapGet A m0 a\n end
m,m0 : Map A
A,B : Type
*****
eq match MapGet B m3 (N.div2 a) with | Some _ => None | None => MapGet A m1 (N.div2 a) end match MapGet B m3 (N.div2 a) with | Some _ => None | None => MapGet A m1 (N.div2 a) end
+++++
reflexivity.
-----
Lemma MapDomRestrBy_semantics : forall (m:Map A) (m':Map B), eqm A (MapGet A (MapDomRestrBy m m')) (fun a0:ad => match MapGet B m' a0 with | None => MapGet A m a0 | _ => None end).
Proof.
unfold eqm in |- *.
simple induction m.
simple induction m'.
intros.
change (MapGet A (makeM2 A (MapDomRestrBy m0 m2) (MapDomRestrBy m1 m3)) a = match MapGet B (M2 B m2 m3) a with | None => MapGet A (M2 A m0 m1) a | Some _ => None end) in |- *.
rewrite (makeM2_M2 A (MapDomRestrBy m0 m2) (MapDomRestrBy m1 m3) a).
rewrite MapGet_M2_bit_0_if.
rewrite (H0 m3 (Ndiv2 a)).
rewrite (H m2 (Ndiv2 a)).
rewrite (MapGet_M2_bit_0_if B m2 m3 a).
rewrite (MapGet_M2_bit_0_if A m0 m1 a).
case (Nbit0 a).

*****
a : ad
H2 : forall a : ad,\neq (MapGet A (MapDomRestrBy (M2 A m0 m1) m3) a)\n match MapGet B m3 a with\n | Some _ => None\n | None => MapGet A (M2 A m0 m1) a\n end
m3 : Map B
H1 : forall a : ad,\neq (MapGet A (MapDomRestrBy (M2 A m0 m1) m2) a)\n match MapGet B m2 a with\n | Some _ => None\n | None => MapGet A (M2 A m0 m1) a\n end
m',m2 : Map B
H0 : forall (m' : Map B) (a : ad),\neq (MapGet A (MapDomRestrBy m1 m') a)\n match MapGet B m' a with\n | Some _ => None\n | None => MapGet A m1 a\n end
m1 : Map A
H : forall (m' : Map B) (a : ad),\neq (MapGet A (MapDomRestrBy m0 m') a)\n match MapGet B m' a with\n | Some _ => None\n | None => MapGet A m0 a\n end
m,m0 : Map A
A,B : Type
*****
eq match MapGet B m2 (N.div2 a) with | Some _ => None | None => MapGet A m0 (N.div2 a) end match MapGet B m2 (N.div2 a) with | Some _ => None | None => MapGet A m0 (N.div2 a) end
+++++
reflexivity.
-----
Lemma MapDomRestrBy_semantics : forall (m:Map A) (m':Map B), eqm A (MapGet A (MapDomRestrBy m m')) (fun a0:ad => match MapGet B m' a0 with | None => MapGet A m a0 | _ => None end).
Proof.
unfold eqm in |- *.
simple induction m.

*****

*****

+++++
Qed.
-----
Definition in_dom (a:ad) (m:Map A) :=\n    match MapGet A m a with\n    | None => false\n    | _ => true\n    end.
-----
Lemma in_dom_M0 : forall a:ad, in_dom a (M0 A) = false.
-----
Lemma in_dom_M0 : forall a:ad, in_dom a (M0 A) = false.

*****
A,B : Type
*****
forall a : ad, eq (in_dom a (M0 A)) false
+++++
Proof.
-----
Lemma in_dom_M0 : forall a:ad, in_dom a (M0 A) = false.
Proof.

*****
A,B : Type
*****
forall a : ad, eq (in_dom a (M0 A)) false
+++++
trivial.
-----
Lemma in_dom_M0 : forall a:ad, in_dom a (M0 A) = false.
Proof.
trivial.

*****

*****

+++++
Qed.
-----
Lemma in_dom_M1 : forall (a a0:ad) (y:A), in_dom a0 (M1 A a y) = Neqb a a0.
-----
Lemma in_dom_M1 : forall (a a0:ad) (y:A), in_dom a0 (M1 A a y) = Neqb a a0.

*****
A,B : Type
*****
forall (a a0 : ad) (y : A), eq (in_dom a0 (M1 A a y)) (N.eqb a a0)
+++++
Proof.
-----
Lemma in_dom_M1 : forall (a a0:ad) (y:A), in_dom a0 (M1 A a y) = Neqb a a0.
Proof.

*****
A,B : Type
*****
forall (a a0 : ad) (y : A), eq (in_dom a0 (M1 A a y)) (N.eqb a a0)
+++++
unfold in_dom in |- *.
-----
Lemma in_dom_M1 : forall (a a0:ad) (y:A), in_dom a0 (M1 A a y) = Neqb a a0.
Proof.
unfold in_dom in |- *.

*****
A,B : Type
*****
forall (a a0 : ad) (y : A), eq match MapGet A (M1 A a y) a0 with | Some _ => true | None => false end (N.eqb a a0)
+++++
intros.
-----
Lemma in_dom_M1 : forall (a a0:ad) (y:A), in_dom a0 (M1 A a y) = Neqb a a0.
Proof.
unfold in_dom in |- *.
intros.

*****
y : A
a,a0 : ad
A,B : Type
*****
eq match MapGet A (M1 A a y) a0 with | Some _ => true | None => false end (N.eqb a a0)
+++++
simpl in |- *.
-----
Lemma in_dom_M1 : forall (a a0:ad) (y:A), in_dom a0 (M1 A a y) = Neqb a a0.
Proof.
unfold in_dom in |- *.
intros.
simpl in |- *.

*****
y : A
a,a0 : ad
A,B : Type
*****
eq match (if N.eqb a a0 then Some y else None) with | Some _ => true | None => false end (N.eqb a a0)
+++++
case (Neqb a a0).
-----
Lemma in_dom_M1 : forall (a a0:ad) (y:A), in_dom a0 (M1 A a y) = Neqb a a0.
Proof.
unfold in_dom in |- *.
intros.
simpl in |- *.
case (Neqb a a0).

*****
y : A
a,a0 : ad
A,B : Type
*****
eq true true
+++++
reflexivity.
-----
Lemma in_dom_M1 : forall (a a0:ad) (y:A), in_dom a0 (M1 A a y) = Neqb a a0.
Proof.
unfold in_dom in |- *.
intros.
simpl in |- *.
case (Neqb a a0).

*****
y : A
a,a0 : ad
A,B : Type
*****
eq false false
+++++
reflexivity.
-----
Lemma in_dom_M1 : forall (a a0:ad) (y:A), in_dom a0 (M1 A a y) = Neqb a a0.
Proof.
unfold in_dom in |- *.
intros.
simpl in |- *.
case (Neqb a a0).

*****

*****

+++++
Qed.
-----
Lemma in_dom_M1_1 : forall (a:ad) (y:A), in_dom a (M1 A a y) = true.
-----
Lemma in_dom_M1_1 : forall (a:ad) (y:A), in_dom a (M1 A a y) = true.

*****
A,B : Type
*****
forall (a : ad) (y : A), eq (in_dom a (M1 A a y)) true
+++++
Proof.
-----
Lemma in_dom_M1_1 : forall (a:ad) (y:A), in_dom a (M1 A a y) = true.
Proof.

*****
A,B : Type
*****
forall (a : ad) (y : A), eq (in_dom a (M1 A a y)) true
+++++
intros.
-----
Lemma in_dom_M1_1 : forall (a:ad) (y:A), in_dom a (M1 A a y) = true.
Proof.
intros.

*****
y : A
a : ad
A,B : Type
*****
eq (in_dom a (M1 A a y)) true
+++++
rewrite in_dom_M1.
-----
Lemma in_dom_M1_1 : forall (a:ad) (y:A), in_dom a (M1 A a y) = true.
Proof.
intros.
rewrite in_dom_M1.

*****
y : A
a : ad
A,B : Type
*****
eq (N.eqb a a) true
+++++
apply Neqb_correct.
-----
Lemma in_dom_M1_1 : forall (a:ad) (y:A), in_dom a (M1 A a y) = true.
Proof.
intros.
rewrite in_dom_M1.
apply Neqb_correct.

*****

*****

+++++
Qed.
-----
Lemma in_dom_M1_2 :\n   forall (a a0:ad) (y:A), in_dom a0 (M1 A a y) = true -> a = a0.
-----
Lemma in_dom_M1_2 : forall (a a0:ad) (y:A), in_dom a0 (M1 A a y) = true -> a = a0.

*****
A,B : Type
*****
forall (a a0 : ad) (y : A) (_ : eq (in_dom a0 (M1 A a y)) true), eq a a0
+++++
Proof.
-----
Lemma in_dom_M1_2 : forall (a a0:ad) (y:A), in_dom a0 (M1 A a y) = true -> a = a0.
Proof.

*****
A,B : Type
*****
forall (a a0 : ad) (y : A) (_ : eq (in_dom a0 (M1 A a y)) true), eq a a0
+++++
intros.
-----
Lemma in_dom_M1_2 : forall (a a0:ad) (y:A), in_dom a0 (M1 A a y) = true -> a = a0.
Proof.
intros.

*****
H : eq (in_dom a0 (M1 A a y)) true
y : A
a,a0 : ad
A,B : Type
*****
eq a a0
+++++
apply (Neqb_complete a a0).
-----
Lemma in_dom_M1_2 : forall (a a0:ad) (y:A), in_dom a0 (M1 A a y) = true -> a = a0.
Proof.
intros.
apply (Neqb_complete a a0).

*****
H : eq (in_dom a0 (M1 A a y)) true
y : A
a,a0 : ad
A,B : Type
*****
eq (N.eqb a a0) true
+++++
rewrite (in_dom_M1 a a0 y) in H.
-----
Lemma in_dom_M1_2 : forall (a a0:ad) (y:A), in_dom a0 (M1 A a y) = true -> a = a0.
Proof.
intros.
apply (Neqb_complete a a0).
rewrite (in_dom_M1 a a0 y) in H.

*****
H : eq (N.eqb a a0) true
y : A
a,a0 : ad
A,B : Type
*****
eq (N.eqb a a0) true
+++++
assumption.
-----
Lemma in_dom_M1_2 : forall (a a0:ad) (y:A), in_dom a0 (M1 A a y) = true -> a = a0.
Proof.
intros.
apply (Neqb_complete a a0).
rewrite (in_dom_M1 a a0 y) in H.
assumption.

*****

*****

+++++
Qed.
-----
Lemma in_dom_some :\n   forall (m:Map A) (a:ad),\n     in_dom a m = true -> {y : A | MapGet A m a = Some y}.
-----
Lemma in_dom_some : forall (m:Map A) (a:ad), in_dom a m = true -> {y : A | MapGet A m a = Some y}.

*****
A,B : Type
*****
forall (m : Map A) (a : ad) (_ : eq (in_dom a m) true), sig (fun y : A => eq (MapGet A m a) (Some y))
+++++
Proof.
-----
Lemma in_dom_some : forall (m:Map A) (a:ad), in_dom a m = true -> {y : A | MapGet A m a = Some y}.
Proof.

*****
A,B : Type
*****
forall (m : Map A) (a : ad) (_ : eq (in_dom a m) true), sig (fun y : A => eq (MapGet A m a) (Some y))
+++++
unfold in_dom in |- *.
-----
Lemma in_dom_some : forall (m:Map A) (a:ad), in_dom a m = true -> {y : A | MapGet A m a = Some y}.
Proof.
unfold in_dom in |- *.

*****
A,B : Type
*****
forall (m : Map A) (a : ad) (_ : eq match MapGet A m a with | Some _ => true | None => false end true), sig (fun y : A => eq (MapGet A m a) (Some y))
+++++
intros.
-----
Lemma in_dom_some : forall (m:Map A) (a:ad), in_dom a m = true -> {y : A | MapGet A m a = Some y}.
Proof.
unfold in_dom in |- *.
intros.

*****
H : eq match MapGet A m a with\n | Some _ => true\n | None => false\n end true
a : ad
m : Map A
A,B : Type
*****
sig (fun y : A => eq (MapGet A m a) (Some y))
+++++
elim (option_sum _ (MapGet A m a)).
-----
Lemma in_dom_some : forall (m:Map A) (a:ad), in_dom a m = true -> {y : A | MapGet A m a = Some y}.
Proof.
unfold in_dom in |- *.
intros.
elim (option_sum _ (MapGet A m a)).

*****
H : eq match MapGet A m a with\n | Some _ => true\n | None => false\n end true
a : ad
m : Map A
A,B : Type
*****
forall _ : sig (fun y : A => eq (MapGet A m a) (Some y)), sig (fun y : A => eq (MapGet A m a) (Some y))
+++++
trivial.
-----
Lemma in_dom_some : forall (m:Map A) (a:ad), in_dom a m = true -> {y : A | MapGet A m a = Some y}.
Proof.
unfold in_dom in |- *.
intros.
elim (option_sum _ (MapGet A m a)).

*****
H : eq match MapGet A m a with\n | Some _ => true\n | None => false\n end true
a : ad
m : Map A
A,B : Type
*****
forall _ : eq (MapGet A m a) None, sig (fun y : A => eq (MapGet A m a) (Some y))
+++++
intro H0.
-----
Lemma in_dom_some : forall (m:Map A) (a:ad), in_dom a m = true -> {y : A | MapGet A m a = Some y}.
Proof.
unfold in_dom in |- *.
intros.
elim (option_sum _ (MapGet A m a)).
intro H0.

*****
H0 : eq (MapGet A m a) None
H : eq match MapGet A m a with\n | Some _ => true\n | None => false\n end true
a : ad
m : Map A
A,B : Type
*****
sig (fun y : A => eq (MapGet A m a) (Some y))
+++++
rewrite H0 in H.
-----
Lemma in_dom_some : forall (m:Map A) (a:ad), in_dom a m = true -> {y : A | MapGet A m a = Some y}.
Proof.
unfold in_dom in |- *.
intros.
elim (option_sum _ (MapGet A m a)).
intro H0.
rewrite H0 in H.

*****
H0 : eq (MapGet A m a) None
H : eq false true
a : ad
m : Map A
A,B : Type
*****
sig (fun y : A => eq (MapGet A m a) (Some y))
+++++
discriminate H.
-----
Lemma in_dom_some : forall (m:Map A) (a:ad), in_dom a m = true -> {y : A | MapGet A m a = Some y}.
Proof.
unfold in_dom in |- *.
intros.
elim (option_sum _ (MapGet A m a)).

*****

*****

+++++
Qed.
-----
Lemma in_dom_none :\n   forall (m:Map A) (a:ad), in_dom a m = false -> MapGet A m a = None.
-----
Lemma in_dom_none : forall (m:Map A) (a:ad), in_dom a m = false -> MapGet A m a = None.

*****
A,B : Type
*****
forall (m : Map A) (a : ad) (_ : eq (in_dom a m) false), eq (MapGet A m a) None
+++++
Proof.
-----
Lemma in_dom_none : forall (m:Map A) (a:ad), in_dom a m = false -> MapGet A m a = None.
Proof.

*****
A,B : Type
*****
forall (m : Map A) (a : ad) (_ : eq (in_dom a m) false), eq (MapGet A m a) None
+++++
unfold in_dom in |- *.
-----
Lemma in_dom_none : forall (m:Map A) (a:ad), in_dom a m = false -> MapGet A m a = None.
Proof.
unfold in_dom in |- *.

*****
A,B : Type
*****
forall (m : Map A) (a : ad) (_ : eq match MapGet A m a with | Some _ => true | None => false end false), eq (MapGet A m a) None
+++++
intros.
-----
Lemma in_dom_none : forall (m:Map A) (a:ad), in_dom a m = false -> MapGet A m a = None.
Proof.
unfold in_dom in |- *.
intros.

*****
H : eq match MapGet A m a with\n | Some _ => true\n | None => false\n end false
a : ad
m : Map A
A,B : Type
*****
eq (MapGet A m a) None
+++++
elim (option_sum _ (MapGet A m a)).
-----
Lemma in_dom_none : forall (m:Map A) (a:ad), in_dom a m = false -> MapGet A m a = None.
Proof.
unfold in_dom in |- *.
intros.
elim (option_sum _ (MapGet A m a)).

*****
H : eq match MapGet A m a with\n | Some _ => true\n | None => false\n end false
a : ad
m : Map A
A,B : Type
*****
forall _ : sig (fun y : A => eq (MapGet A m a) (Some y)), eq (MapGet A m a) None
+++++
intro H0.
-----
Lemma in_dom_none : forall (m:Map A) (a:ad), in_dom a m = false -> MapGet A m a = None.
Proof.
unfold in_dom in |- *.
intros.
elim (option_sum _ (MapGet A m a)).
intro H0.

*****
H0 : sig (fun y : A => eq (MapGet A m a) (Some y))
H : eq match MapGet A m a with\n | Some _ => true\n | None => false\n end false
a : ad
m : Map A
A,B : Type
*****
eq (MapGet A m a) None
+++++
elim H0.
-----
Lemma in_dom_none : forall (m:Map A) (a:ad), in_dom a m = false -> MapGet A m a = None.
Proof.
unfold in_dom in |- *.
intros.
elim (option_sum _ (MapGet A m a)).
intro H0.
elim H0.

*****
H0 : sig (fun y : A => eq (MapGet A m a) (Some y))
H : eq match MapGet A m a with\n | Some _ => true\n | None => false\n end false
a : ad
m : Map A
A,B : Type
*****
forall (x : A) (_ : eq (MapGet A m a) (Some x)), eq (MapGet A m a) None
+++++
intros y H1.
-----
Lemma in_dom_none : forall (m:Map A) (a:ad), in_dom a m = false -> MapGet A m a = None.
Proof.
unfold in_dom in |- *.
intros.
elim (option_sum _ (MapGet A m a)).
intro H0.
elim H0.
intros y H1.

*****
H1 : eq (MapGet A m a) (Some y)
y : A
H0 : sig (fun y : A => eq (MapGet A m a) (Some y))
H : eq match MapGet A m a with\n | Some _ => true\n | None => false\n end false
a : ad
m : Map A
A,B : Type
*****
eq (MapGet A m a) None
+++++
rewrite H1 in H.
-----
Lemma in_dom_none : forall (m:Map A) (a:ad), in_dom a m = false -> MapGet A m a = None.
Proof.
unfold in_dom in |- *.
intros.
elim (option_sum _ (MapGet A m a)).
intro H0.
elim H0.
intros y H1.
rewrite H1 in H.

*****
H1 : eq (MapGet A m a) (Some y)
y : A
H0 : sig (fun y : A => eq (MapGet A m a) (Some y))
H : eq true false
a : ad
m : Map A
A,B : Type
*****
eq (MapGet A m a) None
+++++
discriminate H.
-----
Lemma in_dom_none : forall (m:Map A) (a:ad), in_dom a m = false -> MapGet A m a = None.
Proof.
unfold in_dom in |- *.
intros.
elim (option_sum _ (MapGet A m a)).

*****
H : eq match MapGet A m a with\n | Some _ => true\n | None => false\n end false
a : ad
m : Map A
A,B : Type
*****
forall _ : eq (MapGet A m a) None, eq (MapGet A m a) None
+++++
trivial.
-----
Lemma in_dom_none : forall (m:Map A) (a:ad), in_dom a m = false -> MapGet A m a = None.
Proof.
unfold in_dom in |- *.
intros.
elim (option_sum _ (MapGet A m a)).

*****

*****

+++++
Qed.
-----
Lemma in_dom_put :\n   forall (m:Map A) (a0:ad) (y0:A) (a:ad),\n     in_dom a (MapPut A m a0 y0) = orb (Neqb a a0) (in_dom a m).
-----
Lemma in_dom_put : forall (m:Map A) (a0:ad) (y0:A) (a:ad), in_dom a (MapPut A m a0 y0) = orb (Neqb a a0) (in_dom a m).

*****
A,B : Type
*****
forall (m : Map A) (a0 : ad) (y0 : A) (a : ad), eq (in_dom a (MapPut A m a0 y0)) (orb (N.eqb a a0) (in_dom a m))
+++++
Proof.
-----
Lemma in_dom_put : forall (m:Map A) (a0:ad) (y0:A) (a:ad), in_dom a (MapPut A m a0 y0) = orb (Neqb a a0) (in_dom a m).
Proof.

*****
A,B : Type
*****
forall (m : Map A) (a0 : ad) (y0 : A) (a : ad), eq (in_dom a (MapPut A m a0 y0)) (orb (N.eqb a a0) (in_dom a m))
+++++
unfold in_dom in |- *.
-----
Lemma in_dom_put : forall (m:Map A) (a0:ad) (y0:A) (a:ad), in_dom a (MapPut A m a0 y0) = orb (Neqb a a0) (in_dom a m).
Proof.
unfold in_dom in |- *.

*****
A,B : Type
*****
forall (m : Map A) (a0 : ad) (y0 : A) (a : ad), eq match MapGet A (MapPut A m a0 y0) a with | Some _ => true | None => false end (orb (N.eqb a a0) match MapGet A m a with | Some _ => true | None => false end)
+++++
intros.
-----
Lemma in_dom_put : forall (m:Map A) (a0:ad) (y0:A) (a:ad), in_dom a (MapPut A m a0 y0) = orb (Neqb a a0) (in_dom a m).
Proof.
unfold in_dom in |- *.
intros.

*****
a : ad
y0 : A
a0 : ad
m : Map A
A,B : Type
*****
eq match MapGet A (MapPut A m a0 y0) a with | Some _ => true | None => false end (orb (N.eqb a a0) match MapGet A m a with | Some _ => true | None => false end)
+++++
rewrite (MapPut_semantics A m a0 y0 a).
-----
Lemma in_dom_put : forall (m:Map A) (a0:ad) (y0:A) (a:ad), in_dom a (MapPut A m a0 y0) = orb (Neqb a a0) (in_dom a m).
Proof.
unfold in_dom in |- *.
intros.
rewrite (MapPut_semantics A m a0 y0 a).

*****
a : ad
y0 : A
a0 : ad
m : Map A
A,B : Type
*****
eq match (if N.eqb a0 a then Some y0 else MapGet A m a) with | Some _ => true | None => false end (orb (N.eqb a a0) match MapGet A m a with | Some _ => true | None => false end)
+++++
elim (sumbool_of_bool (Neqb a a0)).
-----
Lemma in_dom_put : forall (m:Map A) (a0:ad) (y0:A) (a:ad), in_dom a (MapPut A m a0 y0) = orb (Neqb a a0) (in_dom a m).
Proof.
unfold in_dom in |- *.
intros.
rewrite (MapPut_semantics A m a0 y0 a).
elim (sumbool_of_bool (Neqb a a0)).

*****
a : ad
y0 : A
a0 : ad
m : Map A
A,B : Type
*****
forall _ : eq (N.eqb a a0) true, eq match (if N.eqb a0 a then Some y0 else MapGet A m a) with | Some _ => true | None => false end (orb (N.eqb a a0) match MapGet A m a with | Some _ => true | None => false end)
+++++
intro H.
-----
Lemma in_dom_put : forall (m:Map A) (a0:ad) (y0:A) (a:ad), in_dom a (MapPut A m a0 y0) = orb (Neqb a a0) (in_dom a m).
Proof.
unfold in_dom in |- *.
intros.
rewrite (MapPut_semantics A m a0 y0 a).
elim (sumbool_of_bool (Neqb a a0)).
intro H.

*****
H : eq (N.eqb a a0) true
a : ad
y0 : A
a0 : ad
m : Map A
A,B : Type
*****
eq match (if N.eqb a0 a then Some y0 else MapGet A m a) with | Some _ => true | None => false end (orb (N.eqb a a0) match MapGet A m a with | Some _ => true | None => false end)
+++++
rewrite H.
-----
Lemma in_dom_put : forall (m:Map A) (a0:ad) (y0:A) (a:ad), in_dom a (MapPut A m a0 y0) = orb (Neqb a a0) (in_dom a m).
Proof.
unfold in_dom in |- *.
intros.
rewrite (MapPut_semantics A m a0 y0 a).
elim (sumbool_of_bool (Neqb a a0)).
intro H.
rewrite H.

*****
H : eq (N.eqb a a0) true
a : ad
y0 : A
a0 : ad
m : Map A
A,B : Type
*****
eq match (if N.eqb a0 a then Some y0 else MapGet A m a) with | Some _ => true | None => false end (orb true match MapGet A m a with | Some _ => true | None => false end)
+++++
rewrite (Neqb_comm a a0) in H.
-----
Lemma in_dom_put : forall (m:Map A) (a0:ad) (y0:A) (a:ad), in_dom a (MapPut A m a0 y0) = orb (Neqb a a0) (in_dom a m).
Proof.
unfold in_dom in |- *.
intros.
rewrite (MapPut_semantics A m a0 y0 a).
elim (sumbool_of_bool (Neqb a a0)).
intro H.
rewrite H.
rewrite (Neqb_comm a a0) in H.

*****
H : eq (N.eqb a0 a) true
a : ad
y0 : A
a0 : ad
m : Map A
A,B : Type
*****
eq match (if N.eqb a0 a then Some y0 else MapGet A m a) with | Some _ => true | None => false end (orb true match MapGet A m a with | Some _ => true | None => false end)
+++++
rewrite H.
-----
Lemma in_dom_put : forall (m:Map A) (a0:ad) (y0:A) (a:ad), in_dom a (MapPut A m a0 y0) = orb (Neqb a a0) (in_dom a m).
Proof.
unfold in_dom in |- *.
intros.
rewrite (MapPut_semantics A m a0 y0 a).
elim (sumbool_of_bool (Neqb a a0)).
intro H.
rewrite H.
rewrite (Neqb_comm a a0) in H.
rewrite H.

*****
H : eq (N.eqb a0 a) true
a : ad
y0 : A
a0 : ad
m : Map A
A,B : Type
*****
eq true (orb true match MapGet A m a with | Some _ => true | None => false end)
+++++
rewrite orb_true_b.
-----
Lemma in_dom_put : forall (m:Map A) (a0:ad) (y0:A) (a:ad), in_dom a (MapPut A m a0 y0) = orb (Neqb a a0) (in_dom a m).
Proof.
unfold in_dom in |- *.
intros.
rewrite (MapPut_semantics A m a0 y0 a).
elim (sumbool_of_bool (Neqb a a0)).
intro H.
rewrite H.
rewrite (Neqb_comm a a0) in H.
rewrite H.
rewrite orb_true_b.

*****
H : eq (N.eqb a0 a) true
a : ad
y0 : A
a0 : ad
m : Map A
A,B : Type
*****
eq true true
+++++
reflexivity.
-----
Lemma in_dom_put : forall (m:Map A) (a0:ad) (y0:A) (a:ad), in_dom a (MapPut A m a0 y0) = orb (Neqb a a0) (in_dom a m).
Proof.
unfold in_dom in |- *.
intros.
rewrite (MapPut_semantics A m a0 y0 a).
elim (sumbool_of_bool (Neqb a a0)).

*****
a : ad
y0 : A
a0 : ad
m : Map A
A,B : Type
*****
forall _ : eq (N.eqb a a0) false, eq match (if N.eqb a0 a then Some y0 else MapGet A m a) with | Some _ => true | None => false end (orb (N.eqb a a0) match MapGet A m a with | Some _ => true | None => false end)
+++++
intro H.
-----
Lemma in_dom_put : forall (m:Map A) (a0:ad) (y0:A) (a:ad), in_dom a (MapPut A m a0 y0) = orb (Neqb a a0) (in_dom a m).
Proof.
unfold in_dom in |- *.
intros.
rewrite (MapPut_semantics A m a0 y0 a).
elim (sumbool_of_bool (Neqb a a0)).
intro H.

*****
H : eq (N.eqb a a0) false
a : ad
y0 : A
a0 : ad
m : Map A
A,B : Type
*****
eq match (if N.eqb a0 a then Some y0 else MapGet A m a) with | Some _ => true | None => false end (orb (N.eqb a a0) match MapGet A m a with | Some _ => true | None => false end)
+++++
rewrite H.
-----
Lemma in_dom_put : forall (m:Map A) (a0:ad) (y0:A) (a:ad), in_dom a (MapPut A m a0 y0) = orb (Neqb a a0) (in_dom a m).
Proof.
unfold in_dom in |- *.
intros.
rewrite (MapPut_semantics A m a0 y0 a).
elim (sumbool_of_bool (Neqb a a0)).
intro H.
rewrite H.

*****
H : eq (N.eqb a a0) false
a : ad
y0 : A
a0 : ad
m : Map A
A,B : Type
*****
eq match (if N.eqb a0 a then Some y0 else MapGet A m a) with | Some _ => true | None => false end (orb false match MapGet A m a with | Some _ => true | None => false end)
+++++
rewrite (Neqb_comm a a0) in H.
-----
Lemma in_dom_put : forall (m:Map A) (a0:ad) (y0:A) (a:ad), in_dom a (MapPut A m a0 y0) = orb (Neqb a a0) (in_dom a m).
Proof.
unfold in_dom in |- *.
intros.
rewrite (MapPut_semantics A m a0 y0 a).
elim (sumbool_of_bool (Neqb a a0)).
intro H.
rewrite H.
rewrite (Neqb_comm a a0) in H.

*****
H : eq (N.eqb a0 a) false
a : ad
y0 : A
a0 : ad
m : Map A
A,B : Type
*****
eq match (if N.eqb a0 a then Some y0 else MapGet A m a) with | Some _ => true | None => false end (orb false match MapGet A m a with | Some _ => true | None => false end)
+++++
rewrite H.
-----
Lemma in_dom_put : forall (m:Map A) (a0:ad) (y0:A) (a:ad), in_dom a (MapPut A m a0 y0) = orb (Neqb a a0) (in_dom a m).
Proof.
unfold in_dom in |- *.
intros.
rewrite (MapPut_semantics A m a0 y0 a).
elim (sumbool_of_bool (Neqb a a0)).
intro H.
rewrite H.
rewrite (Neqb_comm a a0) in H.
rewrite H.

*****
H : eq (N.eqb a0 a) false
a : ad
y0 : A
a0 : ad
m : Map A
A,B : Type
*****
eq match MapGet A m a with | Some _ => true | None => false end (orb false match MapGet A m a with | Some _ => true | None => false end)
+++++
rewrite orb_false_b.
-----
Lemma in_dom_put : forall (m:Map A) (a0:ad) (y0:A) (a:ad), in_dom a (MapPut A m a0 y0) = orb (Neqb a a0) (in_dom a m).
Proof.
unfold in_dom in |- *.
intros.
rewrite (MapPut_semantics A m a0 y0 a).
elim (sumbool_of_bool (Neqb a a0)).
intro H.
rewrite H.
rewrite (Neqb_comm a a0) in H.
rewrite H.
rewrite orb_false_b.

*****
H : eq (N.eqb a0 a) false
a : ad
y0 : A
a0 : ad
m : Map A
A,B : Type
*****
eq match MapGet A m a with | Some _ => true | None => false end match MapGet A m a with | Some _ => true | None => false end
+++++
reflexivity.
-----
Lemma in_dom_put : forall (m:Map A) (a0:ad) (y0:A) (a:ad), in_dom a (MapPut A m a0 y0) = orb (Neqb a a0) (in_dom a m).
Proof.
unfold in_dom in |- *.
intros.
rewrite (MapPut_semantics A m a0 y0 a).
elim (sumbool_of_bool (Neqb a a0)).

*****

*****

+++++
Qed.
-----
Lemma in_dom_put_behind :\n   forall (m:Map A) (a0:ad) (y0:A) (a:ad),\n     in_dom a (MapPut_behind A m a0 y0) = orb (Neqb a a0) (in_dom a m).
-----
Lemma in_dom_put_behind : forall (m:Map A) (a0:ad) (y0:A) (a:ad), in_dom a (MapPut_behind A m a0 y0) = orb (Neqb a a0) (in_dom a m).

*****
A,B : Type
*****
forall (m : Map A) (a0 : ad) (y0 : A) (a : ad), eq (in_dom a (MapPut_behind A m a0 y0)) (orb (N.eqb a a0) (in_dom a m))
+++++
Proof.
-----
Lemma in_dom_put_behind : forall (m:Map A) (a0:ad) (y0:A) (a:ad), in_dom a (MapPut_behind A m a0 y0) = orb (Neqb a a0) (in_dom a m).
Proof.

*****
A,B : Type
*****
forall (m : Map A) (a0 : ad) (y0 : A) (a : ad), eq (in_dom a (MapPut_behind A m a0 y0)) (orb (N.eqb a a0) (in_dom a m))
+++++
unfold in_dom in |- *.
-----
Lemma in_dom_put_behind : forall (m:Map A) (a0:ad) (y0:A) (a:ad), in_dom a (MapPut_behind A m a0 y0) = orb (Neqb a a0) (in_dom a m).
Proof.
unfold in_dom in |- *.

*****
A,B : Type
*****
forall (m : Map A) (a0 : ad) (y0 : A) (a : ad), eq match MapGet A (MapPut_behind A m a0 y0) a with | Some _ => true | None => false end (orb (N.eqb a a0) match MapGet A m a with | Some _ => true | None => false end)
+++++
intros.
-----
Lemma in_dom_put_behind : forall (m:Map A) (a0:ad) (y0:A) (a:ad), in_dom a (MapPut_behind A m a0 y0) = orb (Neqb a a0) (in_dom a m).
Proof.
unfold in_dom in |- *.
intros.

*****
a : ad
y0 : A
a0 : ad
m : Map A
A,B : Type
*****
eq match MapGet A (MapPut_behind A m a0 y0) a with | Some _ => true | None => false end (orb (N.eqb a a0) match MapGet A m a with | Some _ => true | None => false end)
+++++
rewrite (MapPut_behind_semantics A m a0 y0 a).
-----
Lemma in_dom_put_behind : forall (m:Map A) (a0:ad) (y0:A) (a:ad), in_dom a (MapPut_behind A m a0 y0) = orb (Neqb a a0) (in_dom a m).
Proof.
unfold in_dom in |- *.
intros.
rewrite (MapPut_behind_semantics A m a0 y0 a).

*****
a : ad
y0 : A
a0 : ad
m : Map A
A,B : Type
*****
eq match match MapGet A m a with | Some y' => Some y' | None => if N.eqb a0 a then Some y0 else None end with | Some _ => true | None => false end (orb (N.eqb a a0) match MapGet A m a with | Some _ => true | None => false end)
+++++
elim (sumbool_of_bool (Neqb a a0)).
-----
Lemma in_dom_put_behind : forall (m:Map A) (a0:ad) (y0:A) (a:ad), in_dom a (MapPut_behind A m a0 y0) = orb (Neqb a a0) (in_dom a m).
Proof.
unfold in_dom in |- *.
intros.
rewrite (MapPut_behind_semantics A m a0 y0 a).
elim (sumbool_of_bool (Neqb a a0)).

*****
a : ad
y0 : A
a0 : ad
m : Map A
A,B : Type
*****
forall _ : eq (N.eqb a a0) true, eq match match MapGet A m a with | Some y' => Some y' | None => if N.eqb a0 a then Some y0 else None end with | Some _ => true | None => false end (orb (N.eqb a a0) match MapGet A m a with | Some _ => true | None => false end)
+++++
intro H.
-----
Lemma in_dom_put_behind : forall (m:Map A) (a0:ad) (y0:A) (a:ad), in_dom a (MapPut_behind A m a0 y0) = orb (Neqb a a0) (in_dom a m).
Proof.
unfold in_dom in |- *.
intros.
rewrite (MapPut_behind_semantics A m a0 y0 a).
elim (sumbool_of_bool (Neqb a a0)).
intro H.

*****
H : eq (N.eqb a a0) true
a : ad
y0 : A
a0 : ad
m : Map A
A,B : Type
*****
eq match match MapGet A m a with | Some y' => Some y' | None => if N.eqb a0 a then Some y0 else None end with | Some _ => true | None => false end (orb (N.eqb a a0) match MapGet A m a with | Some _ => true | None => false end)
+++++
rewrite H.
-----
Lemma in_dom_put_behind : forall (m:Map A) (a0:ad) (y0:A) (a:ad), in_dom a (MapPut_behind A m a0 y0) = orb (Neqb a a0) (in_dom a m).
Proof.
unfold in_dom in |- *.
intros.
rewrite (MapPut_behind_semantics A m a0 y0 a).
elim (sumbool_of_bool (Neqb a a0)).
intro H.
rewrite H.

*****
H : eq (N.eqb a a0) true
a : ad
y0 : A
a0 : ad
m : Map A
A,B : Type
*****
eq match match MapGet A m a with | Some y' => Some y' | None => if N.eqb a0 a then Some y0 else None end with | Some _ => true | None => false end (orb true match MapGet A m a with | Some _ => true | None => false end)
+++++
rewrite (Neqb_comm a a0) in H.
-----
Lemma in_dom_put_behind : forall (m:Map A) (a0:ad) (y0:A) (a:ad), in_dom a (MapPut_behind A m a0 y0) = orb (Neqb a a0) (in_dom a m).
Proof.
unfold in_dom in |- *.
intros.
rewrite (MapPut_behind_semantics A m a0 y0 a).
elim (sumbool_of_bool (Neqb a a0)).
intro H.
rewrite H.
rewrite (Neqb_comm a a0) in H.

*****
H : eq (N.eqb a0 a) true
a : ad
y0 : A
a0 : ad
m : Map A
A,B : Type
*****
eq match match MapGet A m a with | Some y' => Some y' | None => if N.eqb a0 a then Some y0 else None end with | Some _ => true | None => false end (orb true match MapGet A m a with | Some _ => true | None => false end)
+++++
rewrite H.
-----
Lemma in_dom_put_behind : forall (m:Map A) (a0:ad) (y0:A) (a:ad), in_dom a (MapPut_behind A m a0 y0) = orb (Neqb a a0) (in_dom a m).
Proof.
unfold in_dom in |- *.
intros.
rewrite (MapPut_behind_semantics A m a0 y0 a).
elim (sumbool_of_bool (Neqb a a0)).
intro H.
rewrite H.
rewrite (Neqb_comm a a0) in H.
rewrite H.

*****
H : eq (N.eqb a0 a) true
a : ad
y0 : A
a0 : ad
m : Map A
A,B : Type
*****
eq match match MapGet A m a with | Some y' => Some y' | None => Some y0 end with | Some _ => true | None => false end (orb true match MapGet A m a with | Some _ => true | None => false end)
+++++
case (MapGet A m a).
-----
Lemma in_dom_put_behind : forall (m:Map A) (a0:ad) (y0:A) (a:ad), in_dom a (MapPut_behind A m a0 y0) = orb (Neqb a a0) (in_dom a m).
Proof.
unfold in_dom in |- *.
intros.
rewrite (MapPut_behind_semantics A m a0 y0 a).
elim (sumbool_of_bool (Neqb a a0)).
intro H.
rewrite H.
rewrite (Neqb_comm a a0) in H.
rewrite H.
case (MapGet A m a).

*****
H : eq (N.eqb a0 a) true
a : ad
y0 : A
a0 : ad
m : Map A
A,B : Type
*****
forall _ : A, eq true (orb true true)
+++++
reflexivity.
-----
Lemma in_dom_put_behind : forall (m:Map A) (a0:ad) (y0:A) (a:ad), in_dom a (MapPut_behind A m a0 y0) = orb (Neqb a a0) (in_dom a m).
Proof.
unfold in_dom in |- *.
intros.
rewrite (MapPut_behind_semantics A m a0 y0 a).
elim (sumbool_of_bool (Neqb a a0)).
intro H.
rewrite H.
rewrite (Neqb_comm a a0) in H.
rewrite H.
case (MapGet A m a).

*****
H : eq (N.eqb a0 a) true
a : ad
y0 : A
a0 : ad
m : Map A
A,B : Type
*****
eq true (orb true false)
+++++
reflexivity.
-----
Lemma in_dom_put_behind : forall (m:Map A) (a0:ad) (y0:A) (a:ad), in_dom a (MapPut_behind A m a0 y0) = orb (Neqb a a0) (in_dom a m).
Proof.
unfold in_dom in |- *.
intros.
rewrite (MapPut_behind_semantics A m a0 y0 a).
elim (sumbool_of_bool (Neqb a a0)).

*****
a : ad
y0 : A
a0 : ad
m : Map A
A,B : Type
*****
forall _ : eq (N.eqb a a0) false, eq match match MapGet A m a with | Some y' => Some y' | None => if N.eqb a0 a then Some y0 else None end with | Some _ => true | None => false end (orb (N.eqb a a0) match MapGet A m a with | Some _ => true | None => false end)
+++++
intro H.
-----
Lemma in_dom_put_behind : forall (m:Map A) (a0:ad) (y0:A) (a:ad), in_dom a (MapPut_behind A m a0 y0) = orb (Neqb a a0) (in_dom a m).
Proof.
unfold in_dom in |- *.
intros.
rewrite (MapPut_behind_semantics A m a0 y0 a).
elim (sumbool_of_bool (Neqb a a0)).
intro H.

*****
H : eq (N.eqb a a0) false
a : ad
y0 : A
a0 : ad
m : Map A
A,B : Type
*****
eq match match MapGet A m a with | Some y' => Some y' | None => if N.eqb a0 a then Some y0 else None end with | Some _ => true | None => false end (orb (N.eqb a a0) match MapGet A m a with | Some _ => true | None => false end)
+++++
rewrite H.
-----
Lemma in_dom_put_behind : forall (m:Map A) (a0:ad) (y0:A) (a:ad), in_dom a (MapPut_behind A m a0 y0) = orb (Neqb a a0) (in_dom a m).
Proof.
unfold in_dom in |- *.
intros.
rewrite (MapPut_behind_semantics A m a0 y0 a).
elim (sumbool_of_bool (Neqb a a0)).
intro H.
rewrite H.

*****
H : eq (N.eqb a a0) false
a : ad
y0 : A
a0 : ad
m : Map A
A,B : Type
*****
eq match match MapGet A m a with | Some y' => Some y' | None => if N.eqb a0 a then Some y0 else None end with | Some _ => true | None => false end (orb false match MapGet A m a with | Some _ => true | None => false end)
+++++
rewrite (Neqb_comm a a0) in H.
-----
Lemma in_dom_put_behind : forall (m:Map A) (a0:ad) (y0:A) (a:ad), in_dom a (MapPut_behind A m a0 y0) = orb (Neqb a a0) (in_dom a m).
Proof.
unfold in_dom in |- *.
intros.
rewrite (MapPut_behind_semantics A m a0 y0 a).
elim (sumbool_of_bool (Neqb a a0)).
intro H.
rewrite H.
rewrite (Neqb_comm a a0) in H.

*****
H : eq (N.eqb a0 a) false
a : ad
y0 : A
a0 : ad
m : Map A
A,B : Type
*****
eq match match MapGet A m a with | Some y' => Some y' | None => if N.eqb a0 a then Some y0 else None end with | Some _ => true | None => false end (orb false match MapGet A m a with | Some _ => true | None => false end)
+++++
rewrite H.
-----
Lemma in_dom_put_behind : forall (m:Map A) (a0:ad) (y0:A) (a:ad), in_dom a (MapPut_behind A m a0 y0) = orb (Neqb a a0) (in_dom a m).
Proof.
unfold in_dom in |- *.
intros.
rewrite (MapPut_behind_semantics A m a0 y0 a).
elim (sumbool_of_bool (Neqb a a0)).
intro H.
rewrite H.
rewrite (Neqb_comm a a0) in H.
rewrite H.

*****
H : eq (N.eqb a0 a) false
a : ad
y0 : A
a0 : ad
m : Map A
A,B : Type
*****
eq match match MapGet A m a with | Some y' => Some y' | None => None end with | Some _ => true | None => false end (orb false match MapGet A m a with | Some _ => true | None => false end)
+++++
case (MapGet A m a).
-----
Lemma in_dom_put_behind : forall (m:Map A) (a0:ad) (y0:A) (a:ad), in_dom a (MapPut_behind A m a0 y0) = orb (Neqb a a0) (in_dom a m).
Proof.
unfold in_dom in |- *.
intros.
rewrite (MapPut_behind_semantics A m a0 y0 a).
elim (sumbool_of_bool (Neqb a a0)).
intro H.
rewrite H.
rewrite (Neqb_comm a a0) in H.
rewrite H.
case (MapGet A m a).

*****
H : eq (N.eqb a0 a) false
a : ad
y0 : A
a0 : ad
m : Map A
A,B : Type
*****
forall _ : A, eq true (orb false true)
+++++
trivial.
-----
Lemma in_dom_put_behind : forall (m:Map A) (a0:ad) (y0:A) (a:ad), in_dom a (MapPut_behind A m a0 y0) = orb (Neqb a a0) (in_dom a m).
Proof.
unfold in_dom in |- *.
intros.
rewrite (MapPut_behind_semantics A m a0 y0 a).
elim (sumbool_of_bool (Neqb a a0)).
intro H.
rewrite H.
rewrite (Neqb_comm a a0) in H.
rewrite H.
case (MapGet A m a).

*****
H : eq (N.eqb a0 a) false
a : ad
y0 : A
a0 : ad
m : Map A
A,B : Type
*****
eq false (orb false false)
+++++
trivial.
-----
Lemma in_dom_put_behind : forall (m:Map A) (a0:ad) (y0:A) (a:ad), in_dom a (MapPut_behind A m a0 y0) = orb (Neqb a a0) (in_dom a m).
Proof.
unfold in_dom in |- *.
intros.
rewrite (MapPut_behind_semantics A m a0 y0 a).
elim (sumbool_of_bool (Neqb a a0)).

*****

*****

+++++
Qed.
-----
Lemma in_dom_remove :\n   forall (m:Map A) (a0 a:ad),\n     in_dom a (MapRemove A m a0) = andb (negb (Neqb a a0)) (in_dom a m).
-----
Lemma in_dom_remove : forall (m:Map A) (a0 a:ad), in_dom a (MapRemove A m a0) = andb (negb (Neqb a a0)) (in_dom a m).

*****
A,B : Type
*****
forall (m : Map A) (a0 a : ad), eq (in_dom a (MapRemove A m a0)) (andb (negb (N.eqb a a0)) (in_dom a m))
+++++
Proof.
-----
Lemma in_dom_remove : forall (m:Map A) (a0 a:ad), in_dom a (MapRemove A m a0) = andb (negb (Neqb a a0)) (in_dom a m).
Proof.

*****
A,B : Type
*****
forall (m : Map A) (a0 a : ad), eq (in_dom a (MapRemove A m a0)) (andb (negb (N.eqb a a0)) (in_dom a m))
+++++
unfold in_dom in |- *.
-----
Lemma in_dom_remove : forall (m:Map A) (a0 a:ad), in_dom a (MapRemove A m a0) = andb (negb (Neqb a a0)) (in_dom a m).
Proof.
unfold in_dom in |- *.

*****
A,B : Type
*****
forall (m : Map A) (a0 a : ad), eq match MapGet A (MapRemove A m a0) a with | Some _ => true | None => false end (andb (negb (N.eqb a a0)) match MapGet A m a with | Some _ => true | None => false end)
+++++
intros.
-----
Lemma in_dom_remove : forall (m:Map A) (a0 a:ad), in_dom a (MapRemove A m a0) = andb (negb (Neqb a a0)) (in_dom a m).
Proof.
unfold in_dom in |- *.
intros.

*****
a0,a : ad
m : Map A
A,B : Type
*****
eq match MapGet A (MapRemove A m a0) a with | Some _ => true | None => false end (andb (negb (N.eqb a a0)) match MapGet A m a with | Some _ => true | None => false end)
+++++
rewrite (MapRemove_semantics A m a0 a).
-----
Lemma in_dom_remove : forall (m:Map A) (a0 a:ad), in_dom a (MapRemove A m a0) = andb (negb (Neqb a a0)) (in_dom a m).
Proof.
unfold in_dom in |- *.
intros.
rewrite (MapRemove_semantics A m a0 a).

*****
a0,a : ad
m : Map A
A,B : Type
*****
eq match (if N.eqb a0 a then None else MapGet A m a) with | Some _ => true | None => false end (andb (negb (N.eqb a a0)) match MapGet A m a with | Some _ => true | None => false end)
+++++
elim (sumbool_of_bool (Neqb a a0)).
-----
Lemma in_dom_remove : forall (m:Map A) (a0 a:ad), in_dom a (MapRemove A m a0) = andb (negb (Neqb a a0)) (in_dom a m).
Proof.
unfold in_dom in |- *.
intros.
rewrite (MapRemove_semantics A m a0 a).
elim (sumbool_of_bool (Neqb a a0)).

*****
a0,a : ad
m : Map A
A,B : Type
*****
forall _ : eq (N.eqb a a0) true, eq match (if N.eqb a0 a then None else MapGet A m a) with | Some _ => true | None => false end (andb (negb (N.eqb a a0)) match MapGet A m a with | Some _ => true | None => false end)
+++++
intro H.
-----
Lemma in_dom_remove : forall (m:Map A) (a0 a:ad), in_dom a (MapRemove A m a0) = andb (negb (Neqb a a0)) (in_dom a m).
Proof.
unfold in_dom in |- *.
intros.
rewrite (MapRemove_semantics A m a0 a).
elim (sumbool_of_bool (Neqb a a0)).
intro H.

*****
H : eq (N.eqb a a0) true
a0,a : ad
m : Map A
A,B : Type
*****
eq match (if N.eqb a0 a then None else MapGet A m a) with | Some _ => true | None => false end (andb (negb (N.eqb a a0)) match MapGet A m a with | Some _ => true | None => false end)
+++++
rewrite H.
-----
Lemma in_dom_remove : forall (m:Map A) (a0 a:ad), in_dom a (MapRemove A m a0) = andb (negb (Neqb a a0)) (in_dom a m).
Proof.
unfold in_dom in |- *.
intros.
rewrite (MapRemove_semantics A m a0 a).
elim (sumbool_of_bool (Neqb a a0)).
intro H.
rewrite H.

*****
H : eq (N.eqb a a0) true
a0,a : ad
m : Map A
A,B : Type
*****
eq match (if N.eqb a0 a then None else MapGet A m a) with | Some _ => true | None => false end (andb (negb true) match MapGet A m a with | Some _ => true | None => false end)
+++++
rewrite (Neqb_comm a a0) in H.
-----
Lemma in_dom_remove : forall (m:Map A) (a0 a:ad), in_dom a (MapRemove A m a0) = andb (negb (Neqb a a0)) (in_dom a m).
Proof.
unfold in_dom in |- *.
intros.
rewrite (MapRemove_semantics A m a0 a).
elim (sumbool_of_bool (Neqb a a0)).
intro H.
rewrite H.
rewrite (Neqb_comm a a0) in H.

*****
H : eq (N.eqb a0 a) true
a0,a : ad
m : Map A
A,B : Type
*****
eq match (if N.eqb a0 a then None else MapGet A m a) with | Some _ => true | None => false end (andb (negb true) match MapGet A m a with | Some _ => true | None => false end)
+++++
rewrite H.
-----
Lemma in_dom_remove : forall (m:Map A) (a0 a:ad), in_dom a (MapRemove A m a0) = andb (negb (Neqb a a0)) (in_dom a m).
Proof.
unfold in_dom in |- *.
intros.
rewrite (MapRemove_semantics A m a0 a).
elim (sumbool_of_bool (Neqb a a0)).
intro H.
rewrite H.
rewrite (Neqb_comm a a0) in H.
rewrite H.

*****
H : eq (N.eqb a0 a) true
a0,a : ad
m : Map A
A,B : Type
*****
eq false (andb (negb true) match MapGet A m a with | Some _ => true | None => false end)
+++++
reflexivity.
-----
Lemma in_dom_remove : forall (m:Map A) (a0 a:ad), in_dom a (MapRemove A m a0) = andb (negb (Neqb a a0)) (in_dom a m).
Proof.
unfold in_dom in |- *.
intros.
rewrite (MapRemove_semantics A m a0 a).
elim (sumbool_of_bool (Neqb a a0)).

*****
a0,a : ad
m : Map A
A,B : Type
*****
forall _ : eq (N.eqb a a0) false, eq match (if N.eqb a0 a then None else MapGet A m a) with | Some _ => true | None => false end (andb (negb (N.eqb a a0)) match MapGet A m a with | Some _ => true | None => false end)
+++++
intro H.
-----
Lemma in_dom_remove : forall (m:Map A) (a0 a:ad), in_dom a (MapRemove A m a0) = andb (negb (Neqb a a0)) (in_dom a m).
Proof.
unfold in_dom in |- *.
intros.
rewrite (MapRemove_semantics A m a0 a).
elim (sumbool_of_bool (Neqb a a0)).
intro H.

*****
H : eq (N.eqb a a0) false
a0,a : ad
m : Map A
A,B : Type
*****
eq match (if N.eqb a0 a then None else MapGet A m a) with | Some _ => true | None => false end (andb (negb (N.eqb a a0)) match MapGet A m a with | Some _ => true | None => false end)
+++++
rewrite H.
-----
Lemma in_dom_remove : forall (m:Map A) (a0 a:ad), in_dom a (MapRemove A m a0) = andb (negb (Neqb a a0)) (in_dom a m).
Proof.
unfold in_dom in |- *.
intros.
rewrite (MapRemove_semantics A m a0 a).
elim (sumbool_of_bool (Neqb a a0)).
intro H.
rewrite H.

*****
H : eq (N.eqb a a0) false
a0,a : ad
m : Map A
A,B : Type
*****
eq match (if N.eqb a0 a then None else MapGet A m a) with | Some _ => true | None => false end (andb (negb false) match MapGet A m a with | Some _ => true | None => false end)
+++++
rewrite (Neqb_comm a a0) in H.
-----
Lemma in_dom_remove : forall (m:Map A) (a0 a:ad), in_dom a (MapRemove A m a0) = andb (negb (Neqb a a0)) (in_dom a m).
Proof.
unfold in_dom in |- *.
intros.
rewrite (MapRemove_semantics A m a0 a).
elim (sumbool_of_bool (Neqb a a0)).
intro H.
rewrite H.
rewrite (Neqb_comm a a0) in H.

*****
H : eq (N.eqb a0 a) false
a0,a : ad
m : Map A
A,B : Type
*****
eq match (if N.eqb a0 a then None else MapGet A m a) with | Some _ => true | None => false end (andb (negb false) match MapGet A m a with | Some _ => true | None => false end)
+++++
rewrite H.
-----
Lemma in_dom_remove : forall (m:Map A) (a0 a:ad), in_dom a (MapRemove A m a0) = andb (negb (Neqb a a0)) (in_dom a m).
Proof.
unfold in_dom in |- *.
intros.
rewrite (MapRemove_semantics A m a0 a).
elim (sumbool_of_bool (Neqb a a0)).
intro H.
rewrite H.
rewrite (Neqb_comm a a0) in H.
rewrite H.

*****
H : eq (N.eqb a0 a) false
a0,a : ad
m : Map A
A,B : Type
*****
eq match MapGet A m a with | Some _ => true | None => false end (andb (negb false) match MapGet A m a with | Some _ => true | None => false end)
+++++
case (MapGet A m a).
-----
Lemma in_dom_remove : forall (m:Map A) (a0 a:ad), in_dom a (MapRemove A m a0) = andb (negb (Neqb a a0)) (in_dom a m).
Proof.
unfold in_dom in |- *.
intros.
rewrite (MapRemove_semantics A m a0 a).
elim (sumbool_of_bool (Neqb a a0)).
intro H.
rewrite H.
rewrite (Neqb_comm a a0) in H.
rewrite H.
case (MapGet A m a).

*****
H : eq (N.eqb a0 a) false
a0,a : ad
m : Map A
A,B : Type
*****
forall _ : A, eq true (andb (negb false) true)
+++++
reflexivity.
-----
Lemma in_dom_remove : forall (m:Map A) (a0 a:ad), in_dom a (MapRemove A m a0) = andb (negb (Neqb a a0)) (in_dom a m).
Proof.
unfold in_dom in |- *.
intros.
rewrite (MapRemove_semantics A m a0 a).
elim (sumbool_of_bool (Neqb a a0)).
intro H.
rewrite H.
rewrite (Neqb_comm a a0) in H.
rewrite H.
case (MapGet A m a).

*****
H : eq (N.eqb a0 a) false
a0,a : ad
m : Map A
A,B : Type
*****
eq false (andb (negb false) false)
+++++
reflexivity.
-----
Lemma in_dom_remove : forall (m:Map A) (a0 a:ad), in_dom a (MapRemove A m a0) = andb (negb (Neqb a a0)) (in_dom a m).
Proof.
unfold in_dom in |- *.
intros.
rewrite (MapRemove_semantics A m a0 a).
elim (sumbool_of_bool (Neqb a a0)).

*****

*****

+++++
Qed.
-----
Lemma in_dom_merge :\n   forall (m m':Map A) (a:ad),\n     in_dom a (MapMerge A m m') = orb (in_dom a m) (in_dom a m').
-----
Lemma in_dom_merge : forall (m m':Map A) (a:ad), in_dom a (MapMerge A m m') = orb (in_dom a m) (in_dom a m').

*****
A,B : Type
*****
forall (m m' : Map A) (a : ad), eq (in_dom a (MapMerge A m m')) (orb (in_dom a m) (in_dom a m'))
+++++
Proof.
-----
Lemma in_dom_merge : forall (m m':Map A) (a:ad), in_dom a (MapMerge A m m') = orb (in_dom a m) (in_dom a m').
Proof.

*****
A,B : Type
*****
forall (m m' : Map A) (a : ad), eq (in_dom a (MapMerge A m m')) (orb (in_dom a m) (in_dom a m'))
+++++
unfold in_dom in |- *.
-----
Lemma in_dom_merge : forall (m m':Map A) (a:ad), in_dom a (MapMerge A m m') = orb (in_dom a m) (in_dom a m').
Proof.
unfold in_dom in |- *.

*****
A,B : Type
*****
forall (m m' : Map A) (a : ad), eq match MapGet A (MapMerge A m m') a with | Some _ => true | None => false end (orb match MapGet A m a with | Some _ => true | None => false end match MapGet A m' a with | Some _ => true | None => false end)
+++++
intros.
-----
Lemma in_dom_merge : forall (m m':Map A) (a:ad), in_dom a (MapMerge A m m') = orb (in_dom a m) (in_dom a m').
Proof.
unfold in_dom in |- *.
intros.

*****
a : ad
m,m' : Map A
A,B : Type
*****
eq match MapGet A (MapMerge A m m') a with | Some _ => true | None => false end (orb match MapGet A m a with | Some _ => true | None => false end match MapGet A m' a with | Some _ => true | None => false end)
+++++
rewrite (MapMerge_semantics A m m' a).
-----
Lemma in_dom_merge : forall (m m':Map A) (a:ad), in_dom a (MapMerge A m m') = orb (in_dom a m) (in_dom a m').
Proof.
unfold in_dom in |- *.
intros.
rewrite (MapMerge_semantics A m m' a).

*****
a : ad
m,m' : Map A
A,B : Type
*****
eq match match MapGet A m' a with | Some y' => Some y' | None => MapGet A m a end with | Some _ => true | None => false end (orb match MapGet A m a with | Some _ => true | None => false end match MapGet A m' a with | Some _ => true | None => false end)
+++++
elim (option_sum A (MapGet A m' a)).
-----
Lemma in_dom_merge : forall (m m':Map A) (a:ad), in_dom a (MapMerge A m m') = orb (in_dom a m) (in_dom a m').
Proof.
unfold in_dom in |- *.
intros.
rewrite (MapMerge_semantics A m m' a).
elim (option_sum A (MapGet A m' a)).

*****
a : ad
m,m' : Map A
A,B : Type
*****
forall _ : sig (fun y : A => eq (MapGet A m' a) (Some y)), eq match match MapGet A m' a with | Some y' => Some y' | None => MapGet A m a end with | Some _ => true | None => false end (orb match MapGet A m a with | Some _ => true | None => false end match MapGet A m' a with | Some _ => true | None => false end)
+++++
intro H.
-----
Lemma in_dom_merge : forall (m m':Map A) (a:ad), in_dom a (MapMerge A m m') = orb (in_dom a m) (in_dom a m').
Proof.
unfold in_dom in |- *.
intros.
rewrite (MapMerge_semantics A m m' a).
elim (option_sum A (MapGet A m' a)).
intro H.

*****
H : sig (fun y : A => eq (MapGet A m' a) (Some y))
a : ad
m,m' : Map A
A,B : Type
*****
eq match match MapGet A m' a with | Some y' => Some y' | None => MapGet A m a end with | Some _ => true | None => false end (orb match MapGet A m a with | Some _ => true | None => false end match MapGet A m' a with | Some _ => true | None => false end)
+++++
elim H.
-----
Lemma in_dom_merge : forall (m m':Map A) (a:ad), in_dom a (MapMerge A m m') = orb (in_dom a m) (in_dom a m').
Proof.
unfold in_dom in |- *.
intros.
rewrite (MapMerge_semantics A m m' a).
elim (option_sum A (MapGet A m' a)).
intro H.
elim H.

*****
H : sig (fun y : A => eq (MapGet A m' a) (Some y))
a : ad
m,m' : Map A
A,B : Type
*****
forall (x : A) (_ : eq (MapGet A m' a) (Some x)), eq match match MapGet A m' a with | Some y' => Some y' | None => MapGet A m a end with | Some _ => true | None => false end (orb match MapGet A m a with | Some _ => true | None => false end match MapGet A m' a with | Some _ => true | None => false end)
+++++
intros y H0.
-----
Lemma in_dom_merge : forall (m m':Map A) (a:ad), in_dom a (MapMerge A m m') = orb (in_dom a m) (in_dom a m').
Proof.
unfold in_dom in |- *.
intros.
rewrite (MapMerge_semantics A m m' a).
elim (option_sum A (MapGet A m' a)).
intro H.
elim H.
intros y H0.

*****
H0 : eq (MapGet A m' a) (Some y)
y : A
H : sig (fun y : A => eq (MapGet A m' a) (Some y))
a : ad
m,m' : Map A
A,B : Type
*****
eq match match MapGet A m' a with | Some y' => Some y' | None => MapGet A m a end with | Some _ => true | None => false end (orb match MapGet A m a with | Some _ => true | None => false end match MapGet A m' a with | Some _ => true | None => false end)
+++++
rewrite H0.
-----
Lemma in_dom_merge : forall (m m':Map A) (a:ad), in_dom a (MapMerge A m m') = orb (in_dom a m) (in_dom a m').
Proof.
unfold in_dom in |- *.
intros.
rewrite (MapMerge_semantics A m m' a).
elim (option_sum A (MapGet A m' a)).
intro H.
elim H.
intros y H0.
rewrite H0.

*****
H0 : eq (MapGet A m' a) (Some y)
y : A
H : sig (fun y : A => eq (MapGet A m' a) (Some y))
a : ad
m,m' : Map A
A,B : Type
*****
eq true (orb match MapGet A m a with | Some _ => true | None => false end true)
+++++
case (MapGet A m a).
-----
Lemma in_dom_merge : forall (m m':Map A) (a:ad), in_dom a (MapMerge A m m') = orb (in_dom a m) (in_dom a m').
Proof.
unfold in_dom in |- *.
intros.
rewrite (MapMerge_semantics A m m' a).
elim (option_sum A (MapGet A m' a)).
intro H.
elim H.
intros y H0.
rewrite H0.
case (MapGet A m a).

*****
H0 : eq (MapGet A m' a) (Some y)
y : A
H : sig (fun y : A => eq (MapGet A m' a) (Some y))
a : ad
m,m' : Map A
A,B : Type
*****
forall _ : A, eq true (orb true true)
+++++
reflexivity.
-----
Lemma in_dom_merge : forall (m m':Map A) (a:ad), in_dom a (MapMerge A m m') = orb (in_dom a m) (in_dom a m').
Proof.
unfold in_dom in |- *.
intros.
rewrite (MapMerge_semantics A m m' a).
elim (option_sum A (MapGet A m' a)).
intro H.
elim H.
intros y H0.
rewrite H0.
case (MapGet A m a).

*****
H0 : eq (MapGet A m' a) (Some y)
y : A
H : sig (fun y : A => eq (MapGet A m' a) (Some y))
a : ad
m,m' : Map A
A,B : Type
*****
eq true (orb false true)
+++++
reflexivity.
-----
Lemma in_dom_merge : forall (m m':Map A) (a:ad), in_dom a (MapMerge A m m') = orb (in_dom a m) (in_dom a m').
Proof.
unfold in_dom in |- *.
intros.
rewrite (MapMerge_semantics A m m' a).
elim (option_sum A (MapGet A m' a)).

*****
a : ad
m,m' : Map A
A,B : Type
*****
forall _ : eq (MapGet A m' a) None, eq match match MapGet A m' a with | Some y' => Some y' | None => MapGet A m a end with | Some _ => true | None => false end (orb match MapGet A m a with | Some _ => true | None => false end match MapGet A m' a with | Some _ => true | None => false end)
+++++
intro H.
-----
Lemma in_dom_merge : forall (m m':Map A) (a:ad), in_dom a (MapMerge A m m') = orb (in_dom a m) (in_dom a m').
Proof.
unfold in_dom in |- *.
intros.
rewrite (MapMerge_semantics A m m' a).
elim (option_sum A (MapGet A m' a)).
intro H.

*****
H : eq (MapGet A m' a) None
a : ad
m,m' : Map A
A,B : Type
*****
eq match match MapGet A m' a with | Some y' => Some y' | None => MapGet A m a end with | Some _ => true | None => false end (orb match MapGet A m a with | Some _ => true | None => false end match MapGet A m' a with | Some _ => true | None => false end)
+++++
rewrite H.
-----
Lemma in_dom_merge : forall (m m':Map A) (a:ad), in_dom a (MapMerge A m m') = orb (in_dom a m) (in_dom a m').
Proof.
unfold in_dom in |- *.
intros.
rewrite (MapMerge_semantics A m m' a).
elim (option_sum A (MapGet A m' a)).
intro H.
rewrite H.

*****
H : eq (MapGet A m' a) None
a : ad
m,m' : Map A
A,B : Type
*****
eq match MapGet A m a with | Some _ => true | None => false end (orb match MapGet A m a with | Some _ => true | None => false end false)
+++++
rewrite orb_b_false.
-----
Lemma in_dom_merge : forall (m m':Map A) (a:ad), in_dom a (MapMerge A m m') = orb (in_dom a m) (in_dom a m').
Proof.
unfold in_dom in |- *.
intros.
rewrite (MapMerge_semantics A m m' a).
elim (option_sum A (MapGet A m' a)).
intro H.
rewrite H.
rewrite orb_b_false.

*****
H : eq (MapGet A m' a) None
a : ad
m,m' : Map A
A,B : Type
*****
eq match MapGet A m a with | Some _ => true | None => false end match MapGet A m a with | Some _ => true | None => false end
+++++
reflexivity.
-----
Lemma in_dom_merge : forall (m m':Map A) (a:ad), in_dom a (MapMerge A m m') = orb (in_dom a m) (in_dom a m').
Proof.
unfold in_dom in |- *.
intros.
rewrite (MapMerge_semantics A m m' a).
elim (option_sum A (MapGet A m' a)).

*****

*****

+++++
Qed.
-----
Lemma in_dom_delta :\n   forall (m m':Map A) (a:ad),\n     in_dom a (MapDelta A m m') = xorb (in_dom a m) (in_dom a m').
-----
Lemma in_dom_delta : forall (m m':Map A) (a:ad), in_dom a (MapDelta A m m') = xorb (in_dom a m) (in_dom a m').

*****
A,B : Type
*****
forall (m m' : Map A) (a : ad), eq (in_dom a (MapDelta A m m')) (xorb (in_dom a m) (in_dom a m'))
+++++
Proof.
-----
Lemma in_dom_delta : forall (m m':Map A) (a:ad), in_dom a (MapDelta A m m') = xorb (in_dom a m) (in_dom a m').
Proof.

*****
A,B : Type
*****
forall (m m' : Map A) (a : ad), eq (in_dom a (MapDelta A m m')) (xorb (in_dom a m) (in_dom a m'))
+++++
unfold in_dom in |- *.
-----
Lemma in_dom_delta : forall (m m':Map A) (a:ad), in_dom a (MapDelta A m m') = xorb (in_dom a m) (in_dom a m').
Proof.
unfold in_dom in |- *.

*****
A,B : Type
*****
forall (m m' : Map A) (a : ad), eq match MapGet A (MapDelta A m m') a with | Some _ => true | None => false end (xorb match MapGet A m a with | Some _ => true | None => false end match MapGet A m' a with | Some _ => true | None => false end)
+++++
intros.
-----
Lemma in_dom_delta : forall (m m':Map A) (a:ad), in_dom a (MapDelta A m m') = xorb (in_dom a m) (in_dom a m').
Proof.
unfold in_dom in |- *.
intros.

*****
a : ad
m,m' : Map A
A,B : Type
*****
eq match MapGet A (MapDelta A m m') a with | Some _ => true | None => false end (xorb match MapGet A m a with | Some _ => true | None => false end match MapGet A m' a with | Some _ => true | None => false end)
+++++
rewrite (MapDelta_semantics A m m' a).
-----
Lemma in_dom_delta : forall (m m':Map A) (a:ad), in_dom a (MapDelta A m m') = xorb (in_dom a m) (in_dom a m').
Proof.
unfold in_dom in |- *.
intros.
rewrite (MapDelta_semantics A m m' a).

*****
a : ad
m,m' : Map A
A,B : Type
*****
eq match match MapGet A m a with | Some y => match MapGet A m' a with | Some _ => None | None => Some y end | None => match MapGet A m' a with | Some y' => Some y' | None => None end end with | Some _ => true | None => false end (xorb match MapGet A m a with | Some _ => true | None => false end match MapGet A m' a with | Some _ => true | None => false end)
+++++
elim (option_sum A (MapGet A m' a)).
-----
Lemma in_dom_delta : forall (m m':Map A) (a:ad), in_dom a (MapDelta A m m') = xorb (in_dom a m) (in_dom a m').
Proof.
unfold in_dom in |- *.
intros.
rewrite (MapDelta_semantics A m m' a).
elim (option_sum A (MapGet A m' a)).

*****
a : ad
m,m' : Map A
A,B : Type
*****
forall _ : sig (fun y : A => eq (MapGet A m' a) (Some y)), eq match match MapGet A m a with | Some y => match MapGet A m' a with | Some _ => None | None => Some y end | None => match MapGet A m' a with | Some y' => Some y' | None => None end end with | Some _ => true | None => false end (xorb match MapGet A m a with | Some _ => true | None => false end match MapGet A m' a with | Some _ => true | None => false end)
+++++
intro H.
-----
Lemma in_dom_delta : forall (m m':Map A) (a:ad), in_dom a (MapDelta A m m') = xorb (in_dom a m) (in_dom a m').
Proof.
unfold in_dom in |- *.
intros.
rewrite (MapDelta_semantics A m m' a).
elim (option_sum A (MapGet A m' a)).
intro H.

*****
H : sig (fun y : A => eq (MapGet A m' a) (Some y))
a : ad
m,m' : Map A
A,B : Type
*****
eq match match MapGet A m a with | Some y => match MapGet A m' a with | Some _ => None | None => Some y end | None => match MapGet A m' a with | Some y' => Some y' | None => None end end with | Some _ => true | None => false end (xorb match MapGet A m a with | Some _ => true | None => false end match MapGet A m' a with | Some _ => true | None => false end)
+++++
elim H.
-----
Lemma in_dom_delta : forall (m m':Map A) (a:ad), in_dom a (MapDelta A m m') = xorb (in_dom a m) (in_dom a m').
Proof.
unfold in_dom in |- *.
intros.
rewrite (MapDelta_semantics A m m' a).
elim (option_sum A (MapGet A m' a)).
intro H.
elim H.

*****
H : sig (fun y : A => eq (MapGet A m' a) (Some y))
a : ad
m,m' : Map A
A,B : Type
*****
forall (x : A) (_ : eq (MapGet A m' a) (Some x)), eq match match MapGet A m a with | Some y => match MapGet A m' a with | Some _ => None | None => Some y end | None => match MapGet A m' a with | Some y' => Some y' | None => None end end with | Some _ => true | None => false end (xorb match MapGet A m a with | Some _ => true | None => false end match MapGet A m' a with | Some _ => true | None => false end)
+++++
intros y H0.
-----
Lemma in_dom_delta : forall (m m':Map A) (a:ad), in_dom a (MapDelta A m m') = xorb (in_dom a m) (in_dom a m').
Proof.
unfold in_dom in |- *.
intros.
rewrite (MapDelta_semantics A m m' a).
elim (option_sum A (MapGet A m' a)).
intro H.
elim H.
intros y H0.

*****
H0 : eq (MapGet A m' a) (Some y)
y : A
H : sig (fun y : A => eq (MapGet A m' a) (Some y))
a : ad
m,m' : Map A
A,B : Type
*****
eq match match MapGet A m a with | Some y => match MapGet A m' a with | Some _ => None | None => Some y end | None => match MapGet A m' a with | Some y' => Some y' | None => None end end with | Some _ => true | None => false end (xorb match MapGet A m a with | Some _ => true | None => false end match MapGet A m' a with | Some _ => true | None => false end)
+++++
rewrite H0.
-----
Lemma in_dom_delta : forall (m m':Map A) (a:ad), in_dom a (MapDelta A m m') = xorb (in_dom a m) (in_dom a m').
Proof.
unfold in_dom in |- *.
intros.
rewrite (MapDelta_semantics A m m' a).
elim (option_sum A (MapGet A m' a)).
intro H.
elim H.
intros y H0.
rewrite H0.

*****
H0 : eq (MapGet A m' a) (Some y)
y : A
H : sig (fun y : A => eq (MapGet A m' a) (Some y))
a : ad
m,m' : Map A
A,B : Type
*****
eq match match MapGet A m a with | Some _ => None | None => Some y end with | Some _ => true | None => false end (xorb match MapGet A m a with | Some _ => true | None => false end true)
+++++
case (MapGet A m a).
-----
Lemma in_dom_delta : forall (m m':Map A) (a:ad), in_dom a (MapDelta A m m') = xorb (in_dom a m) (in_dom a m').
Proof.
unfold in_dom in |- *.
intros.
rewrite (MapDelta_semantics A m m' a).
elim (option_sum A (MapGet A m' a)).
intro H.
elim H.
intros y H0.
rewrite H0.
case (MapGet A m a).

*****
H0 : eq (MapGet A m' a) (Some y)
y : A
H : sig (fun y : A => eq (MapGet A m' a) (Some y))
a : ad
m,m' : Map A
A,B : Type
*****
forall _ : A, eq false (xorb true true)
+++++
reflexivity.
-----
Lemma in_dom_delta : forall (m m':Map A) (a:ad), in_dom a (MapDelta A m m') = xorb (in_dom a m) (in_dom a m').
Proof.
unfold in_dom in |- *.
intros.
rewrite (MapDelta_semantics A m m' a).
elim (option_sum A (MapGet A m' a)).
intro H.
elim H.
intros y H0.
rewrite H0.
case (MapGet A m a).

*****
H0 : eq (MapGet A m' a) (Some y)
y : A
H : sig (fun y : A => eq (MapGet A m' a) (Some y))
a : ad
m,m' : Map A
A,B : Type
*****
eq true (xorb false true)
+++++
reflexivity.
-----
Lemma in_dom_delta : forall (m m':Map A) (a:ad), in_dom a (MapDelta A m m') = xorb (in_dom a m) (in_dom a m').
Proof.
unfold in_dom in |- *.
intros.
rewrite (MapDelta_semantics A m m' a).
elim (option_sum A (MapGet A m' a)).

*****
a : ad
m,m' : Map A
A,B : Type
*****
forall _ : eq (MapGet A m' a) None, eq match match MapGet A m a with | Some y => match MapGet A m' a with | Some _ => None | None => Some y end | None => match MapGet A m' a with | Some y' => Some y' | None => None end end with | Some _ => true | None => false end (xorb match MapGet A m a with | Some _ => true | None => false end match MapGet A m' a with | Some _ => true | None => false end)
+++++
intro H.
-----
Lemma in_dom_delta : forall (m m':Map A) (a:ad), in_dom a (MapDelta A m m') = xorb (in_dom a m) (in_dom a m').
Proof.
unfold in_dom in |- *.
intros.
rewrite (MapDelta_semantics A m m' a).
elim (option_sum A (MapGet A m' a)).
intro H.

*****
H : eq (MapGet A m' a) None
a : ad
m,m' : Map A
A,B : Type
*****
eq match match MapGet A m a with | Some y => match MapGet A m' a with | Some _ => None | None => Some y end | None => match MapGet A m' a with | Some y' => Some y' | None => None end end with | Some _ => true | None => false end (xorb match MapGet A m a with | Some _ => true | None => false end match MapGet A m' a with | Some _ => true | None => false end)
+++++
rewrite H.
-----
Lemma in_dom_delta : forall (m m':Map A) (a:ad), in_dom a (MapDelta A m m') = xorb (in_dom a m) (in_dom a m').
Proof.
unfold in_dom in |- *.
intros.
rewrite (MapDelta_semantics A m m' a).
elim (option_sum A (MapGet A m' a)).
intro H.
rewrite H.

*****
H : eq (MapGet A m' a) None
a : ad
m,m' : Map A
A,B : Type
*****
eq match match MapGet A m a with | Some y => Some y | None => None end with | Some _ => true | None => false end (xorb match MapGet A m a with | Some _ => true | None => false end false)
+++++
case (MapGet A m a).
-----
Lemma in_dom_delta : forall (m m':Map A) (a:ad), in_dom a (MapDelta A m m') = xorb (in_dom a m) (in_dom a m').
Proof.
unfold in_dom in |- *.
intros.
rewrite (MapDelta_semantics A m m' a).
elim (option_sum A (MapGet A m' a)).
intro H.
rewrite H.
case (MapGet A m a).

*****
H : eq (MapGet A m' a) None
a : ad
m,m' : Map A
A,B : Type
*****
forall _ : A, eq true (xorb true false)
+++++
reflexivity.
-----
Lemma in_dom_delta : forall (m m':Map A) (a:ad), in_dom a (MapDelta A m m') = xorb (in_dom a m) (in_dom a m').
Proof.
unfold in_dom in |- *.
intros.
rewrite (MapDelta_semantics A m m' a).
elim (option_sum A (MapGet A m' a)).
intro H.
rewrite H.
case (MapGet A m a).

*****
H : eq (MapGet A m' a) None
a : ad
m,m' : Map A
A,B : Type
*****
eq false (xorb false false)
+++++
reflexivity.
-----
Lemma in_dom_delta : forall (m m':Map A) (a:ad), in_dom a (MapDelta A m m') = xorb (in_dom a m) (in_dom a m').
Proof.
unfold in_dom in |- *.
intros.
rewrite (MapDelta_semantics A m m' a).
elim (option_sum A (MapGet A m' a)).

*****

*****

+++++
Qed.
-----
End Dom.
-----
Section InDom.
-----
Variables A B : Type.
-----
Lemma in_dom_restrto :\n   forall (m:Map A) (m':Map B) (a:ad),\n     in_dom A a (MapDomRestrTo A B m m') =\n     andb (in_dom A a m) (in_dom B a m').
-----
Lemma in_dom_restrto : forall (m:Map A) (m':Map B) (a:ad), in_dom A a (MapDomRestrTo A B m m') = andb (in_dom A a m) (in_dom B a m').

*****
A,B : Type
*****
forall (m : Map A) (m' : Map B) (a : ad), eq (in_dom A a (MapDomRestrTo A B m m')) (andb (in_dom A a m) (in_dom B a m'))
+++++
Proof.
-----
Lemma in_dom_restrto : forall (m:Map A) (m':Map B) (a:ad), in_dom A a (MapDomRestrTo A B m m') = andb (in_dom A a m) (in_dom B a m').
Proof.

*****
A,B : Type
*****
forall (m : Map A) (m' : Map B) (a : ad), eq (in_dom A a (MapDomRestrTo A B m m')) (andb (in_dom A a m) (in_dom B a m'))
+++++
unfold in_dom in |- *.
-----
Lemma in_dom_restrto : forall (m:Map A) (m':Map B) (a:ad), in_dom A a (MapDomRestrTo A B m m') = andb (in_dom A a m) (in_dom B a m').
Proof.
unfold in_dom in |- *.

*****
A,B : Type
*****
forall (m : Map A) (m' : Map B) (a : ad), eq match MapGet A (MapDomRestrTo A B m m') a with | Some _ => true | None => false end (andb match MapGet A m a with | Some _ => true | None => false end match MapGet B m' a with | Some _ => true | None => false end)
+++++
intros.
-----
Lemma in_dom_restrto : forall (m:Map A) (m':Map B) (a:ad), in_dom A a (MapDomRestrTo A B m m') = andb (in_dom A a m) (in_dom B a m').
Proof.
unfold in_dom in |- *.
intros.

*****
a : ad
m' : Map B
m : Map A
A,B : Type
*****
eq match MapGet A (MapDomRestrTo A B m m') a with | Some _ => true | None => false end (andb match MapGet A m a with | Some _ => true | None => false end match MapGet B m' a with | Some _ => true | None => false end)
+++++
rewrite (MapDomRestrTo_semantics A B m m' a).
-----
Lemma in_dom_restrto : forall (m:Map A) (m':Map B) (a:ad), in_dom A a (MapDomRestrTo A B m m') = andb (in_dom A a m) (in_dom B a m').
Proof.
unfold in_dom in |- *.
intros.
rewrite (MapDomRestrTo_semantics A B m m' a).

*****
a : ad
m' : Map B
m : Map A
A,B : Type
*****
eq match match MapGet B m' a with | Some _ => MapGet A m a | None => None end with | Some _ => true | None => false end (andb match MapGet A m a with | Some _ => true | None => false end match MapGet B m' a with | Some _ => true | None => false end)
+++++
elim (option_sum B (MapGet B m' a)).
-----
Lemma in_dom_restrto : forall (m:Map A) (m':Map B) (a:ad), in_dom A a (MapDomRestrTo A B m m') = andb (in_dom A a m) (in_dom B a m').
Proof.
unfold in_dom in |- *.
intros.
rewrite (MapDomRestrTo_semantics A B m m' a).
elim (option_sum B (MapGet B m' a)).

*****
a : ad
m' : Map B
m : Map A
A,B : Type
*****
forall _ : sig (fun y : B => eq (MapGet B m' a) (Some y)), eq match match MapGet B m' a with | Some _ => MapGet A m a | None => None end with | Some _ => true | None => false end (andb match MapGet A m a with | Some _ => true | None => false end match MapGet B m' a with | Some _ => true | None => false end)
+++++
intro H.
-----
Lemma in_dom_restrto : forall (m:Map A) (m':Map B) (a:ad), in_dom A a (MapDomRestrTo A B m m') = andb (in_dom A a m) (in_dom B a m').
Proof.
unfold in_dom in |- *.
intros.
rewrite (MapDomRestrTo_semantics A B m m' a).
elim (option_sum B (MapGet B m' a)).
intro H.

*****
H : sig (fun y : B => eq (MapGet B m' a) (Some y))
a : ad
m' : Map B
m : Map A
A,B : Type
*****
eq match match MapGet B m' a with | Some _ => MapGet A m a | None => None end with | Some _ => true | None => false end (andb match MapGet A m a with | Some _ => true | None => false end match MapGet B m' a with | Some _ => true | None => false end)
+++++
elim H.
-----
Lemma in_dom_restrto : forall (m:Map A) (m':Map B) (a:ad), in_dom A a (MapDomRestrTo A B m m') = andb (in_dom A a m) (in_dom B a m').
Proof.
unfold in_dom in |- *.
intros.
rewrite (MapDomRestrTo_semantics A B m m' a).
elim (option_sum B (MapGet B m' a)).
intro H.
elim H.

*****
H : sig (fun y : B => eq (MapGet B m' a) (Some y))
a : ad
m' : Map B
m : Map A
A,B : Type
*****
forall (x : B) (_ : eq (MapGet B m' a) (Some x)), eq match match MapGet B m' a with | Some _ => MapGet A m a | None => None end with | Some _ => true | None => false end (andb match MapGet A m a with | Some _ => true | None => false end match MapGet B m' a with | Some _ => true | None => false end)
+++++
intros y H0.
-----
Lemma in_dom_restrto : forall (m:Map A) (m':Map B) (a:ad), in_dom A a (MapDomRestrTo A B m m') = andb (in_dom A a m) (in_dom B a m').
Proof.
unfold in_dom in |- *.
intros.
rewrite (MapDomRestrTo_semantics A B m m' a).
elim (option_sum B (MapGet B m' a)).
intro H.
elim H.
intros y H0.

*****
H0 : eq (MapGet B m' a) (Some y)
y : B
H : sig (fun y : B => eq (MapGet B m' a) (Some y))
a : ad
m' : Map B
m : Map A
A,B : Type
*****
eq match match MapGet B m' a with | Some _ => MapGet A m a | None => None end with | Some _ => true | None => false end (andb match MapGet A m a with | Some _ => true | None => false end match MapGet B m' a with | Some _ => true | None => false end)
+++++
rewrite H0.
-----
Lemma in_dom_restrto : forall (m:Map A) (m':Map B) (a:ad), in_dom A a (MapDomRestrTo A B m m') = andb (in_dom A a m) (in_dom B a m').
Proof.
unfold in_dom in |- *.
intros.
rewrite (MapDomRestrTo_semantics A B m m' a).
elim (option_sum B (MapGet B m' a)).
intro H.
elim H.
intros y H0.
rewrite H0.

*****
H0 : eq (MapGet B m' a) (Some y)
y : B
H : sig (fun y : B => eq (MapGet B m' a) (Some y))
a : ad
m' : Map B
m : Map A
A,B : Type
*****
eq match MapGet A m a with | Some _ => true | None => false end (andb match MapGet A m a with | Some _ => true | None => false end true)
+++++
rewrite andb_b_true.
-----
Lemma in_dom_restrto : forall (m:Map A) (m':Map B) (a:ad), in_dom A a (MapDomRestrTo A B m m') = andb (in_dom A a m) (in_dom B a m').
Proof.
unfold in_dom in |- *.
intros.
rewrite (MapDomRestrTo_semantics A B m m' a).
elim (option_sum B (MapGet B m' a)).
intro H.
elim H.
intros y H0.
rewrite H0.
rewrite andb_b_true.

*****
H0 : eq (MapGet B m' a) (Some y)
y : B
H : sig (fun y : B => eq (MapGet B m' a) (Some y))
a : ad
m' : Map B
m : Map A
A,B : Type
*****
eq match MapGet A m a with | Some _ => true | None => false end match MapGet A m a with | Some _ => true | None => false end
+++++
reflexivity.
-----
Lemma in_dom_restrto : forall (m:Map A) (m':Map B) (a:ad), in_dom A a (MapDomRestrTo A B m m') = andb (in_dom A a m) (in_dom B a m').
Proof.
unfold in_dom in |- *.
intros.
rewrite (MapDomRestrTo_semantics A B m m' a).
elim (option_sum B (MapGet B m' a)).

*****
a : ad
m' : Map B
m : Map A
A,B : Type
*****
forall _ : eq (MapGet B m' a) None, eq match match MapGet B m' a with | Some _ => MapGet A m a | None => None end with | Some _ => true | None => false end (andb match MapGet A m a with | Some _ => true | None => false end match MapGet B m' a with | Some _ => true | None => false end)
+++++
intro H.
-----
Lemma in_dom_restrto : forall (m:Map A) (m':Map B) (a:ad), in_dom A a (MapDomRestrTo A B m m') = andb (in_dom A a m) (in_dom B a m').
Proof.
unfold in_dom in |- *.
intros.
rewrite (MapDomRestrTo_semantics A B m m' a).
elim (option_sum B (MapGet B m' a)).
intro H.

*****
H : eq (MapGet B m' a) None
a : ad
m' : Map B
m : Map A
A,B : Type
*****
eq match match MapGet B m' a with | Some _ => MapGet A m a | None => None end with | Some _ => true | None => false end (andb match MapGet A m a with | Some _ => true | None => false end match MapGet B m' a with | Some _ => true | None => false end)
+++++
rewrite H.
-----
Lemma in_dom_restrto : forall (m:Map A) (m':Map B) (a:ad), in_dom A a (MapDomRestrTo A B m m') = andb (in_dom A a m) (in_dom B a m').
Proof.
unfold in_dom in |- *.
intros.
rewrite (MapDomRestrTo_semantics A B m m' a).
elim (option_sum B (MapGet B m' a)).
intro H.
rewrite H.

*****
H : eq (MapGet B m' a) None
a : ad
m' : Map B
m : Map A
A,B : Type
*****
eq false (andb match MapGet A m a with | Some _ => true | None => false end false)
+++++
rewrite andb_b_false.
-----
Lemma in_dom_restrto : forall (m:Map A) (m':Map B) (a:ad), in_dom A a (MapDomRestrTo A B m m') = andb (in_dom A a m) (in_dom B a m').
Proof.
unfold in_dom in |- *.
intros.
rewrite (MapDomRestrTo_semantics A B m m' a).
elim (option_sum B (MapGet B m' a)).
intro H.
rewrite H.
rewrite andb_b_false.

*****
H : eq (MapGet B m' a) None
a : ad
m' : Map B
m : Map A
A,B : Type
*****
eq false false
+++++
reflexivity.
-----
Lemma in_dom_restrto : forall (m:Map A) (m':Map B) (a:ad), in_dom A a (MapDomRestrTo A B m m') = andb (in_dom A a m) (in_dom B a m').
Proof.
unfold in_dom in |- *.
intros.
rewrite (MapDomRestrTo_semantics A B m m' a).
elim (option_sum B (MapGet B m' a)).

*****

*****

+++++
Qed.
-----
Lemma in_dom_restrby :\n   forall (m:Map A) (m':Map B) (a:ad),\n     in_dom A a (MapDomRestrBy A B m m') =\n     andb (in_dom A a m) (negb (in_dom B a m')).
-----
Lemma in_dom_restrby : forall (m:Map A) (m':Map B) (a:ad), in_dom A a (MapDomRestrBy A B m m') = andb (in_dom A a m) (negb (in_dom B a m')).

*****
A,B : Type
*****
forall (m : Map A) (m' : Map B) (a : ad), eq (in_dom A a (MapDomRestrBy A B m m')) (andb (in_dom A a m) (negb (in_dom B a m')))
+++++
Proof.
-----
Lemma in_dom_restrby : forall (m:Map A) (m':Map B) (a:ad), in_dom A a (MapDomRestrBy A B m m') = andb (in_dom A a m) (negb (in_dom B a m')).
Proof.

*****
A,B : Type
*****
forall (m : Map A) (m' : Map B) (a : ad), eq (in_dom A a (MapDomRestrBy A B m m')) (andb (in_dom A a m) (negb (in_dom B a m')))
+++++
unfold in_dom in |- *.
-----
Lemma in_dom_restrby : forall (m:Map A) (m':Map B) (a:ad), in_dom A a (MapDomRestrBy A B m m') = andb (in_dom A a m) (negb (in_dom B a m')).
Proof.
unfold in_dom in |- *.

*****
A,B : Type
*****
forall (m : Map A) (m' : Map B) (a : ad), eq match MapGet A (MapDomRestrBy A B m m') a with | Some _ => true | None => false end (andb match MapGet A m a with | Some _ => true | None => false end (negb match MapGet B m' a with | Some _ => true | None => false end))
+++++
intros.
-----
Lemma in_dom_restrby : forall (m:Map A) (m':Map B) (a:ad), in_dom A a (MapDomRestrBy A B m m') = andb (in_dom A a m) (negb (in_dom B a m')).
Proof.
unfold in_dom in |- *.
intros.

*****
a : ad
m' : Map B
m : Map A
A,B : Type
*****
eq match MapGet A (MapDomRestrBy A B m m') a with | Some _ => true | None => false end (andb match MapGet A m a with | Some _ => true | None => false end (negb match MapGet B m' a with | Some _ => true | None => false end))
+++++
rewrite (MapDomRestrBy_semantics A B m m' a).
-----
Lemma in_dom_restrby : forall (m:Map A) (m':Map B) (a:ad), in_dom A a (MapDomRestrBy A B m m') = andb (in_dom A a m) (negb (in_dom B a m')).
Proof.
unfold in_dom in |- *.
intros.
rewrite (MapDomRestrBy_semantics A B m m' a).

*****
a : ad
m' : Map B
m : Map A
A,B : Type
*****
eq match match MapGet B m' a with | Some _ => None | None => MapGet A m a end with | Some _ => true | None => false end (andb match MapGet A m a with | Some _ => true | None => false end (negb match MapGet B m' a with | Some _ => true | None => false end))
+++++
elim (option_sum B (MapGet B m' a)).
-----
Lemma in_dom_restrby : forall (m:Map A) (m':Map B) (a:ad), in_dom A a (MapDomRestrBy A B m m') = andb (in_dom A a m) (negb (in_dom B a m')).
Proof.
unfold in_dom in |- *.
intros.
rewrite (MapDomRestrBy_semantics A B m m' a).
elim (option_sum B (MapGet B m' a)).

*****
a : ad
m' : Map B
m : Map A
A,B : Type
*****
forall _ : sig (fun y : B => eq (MapGet B m' a) (Some y)), eq match match MapGet B m' a with | Some _ => None | None => MapGet A m a end with | Some _ => true | None => false end (andb match MapGet A m a with | Some _ => true | None => false end (negb match MapGet B m' a with | Some _ => true | None => false end))
+++++
intro H.
-----
Lemma in_dom_restrby : forall (m:Map A) (m':Map B) (a:ad), in_dom A a (MapDomRestrBy A B m m') = andb (in_dom A a m) (negb (in_dom B a m')).
Proof.
unfold in_dom in |- *.
intros.
rewrite (MapDomRestrBy_semantics A B m m' a).
elim (option_sum B (MapGet B m' a)).
intro H.

*****
H : sig (fun y : B => eq (MapGet B m' a) (Some y))
a : ad
m' : Map B
m : Map A
A,B : Type
*****
eq match match MapGet B m' a with | Some _ => None | None => MapGet A m a end with | Some _ => true | None => false end (andb match MapGet A m a with | Some _ => true | None => false end (negb match MapGet B m' a with | Some _ => true | None => false end))
+++++
elim H.
-----
Lemma in_dom_restrby : forall (m:Map A) (m':Map B) (a:ad), in_dom A a (MapDomRestrBy A B m m') = andb (in_dom A a m) (negb (in_dom B a m')).
Proof.
unfold in_dom in |- *.
intros.
rewrite (MapDomRestrBy_semantics A B m m' a).
elim (option_sum B (MapGet B m' a)).
intro H.
elim H.

*****
H : sig (fun y : B => eq (MapGet B m' a) (Some y))
a : ad
m' : Map B
m : Map A
A,B : Type
*****
forall (x : B) (_ : eq (MapGet B m' a) (Some x)), eq match match MapGet B m' a with | Some _ => None | None => MapGet A m a end with | Some _ => true | None => false end (andb match MapGet A m a with | Some _ => true | None => false end (negb match MapGet B m' a with | Some _ => true | None => false end))
+++++
intros y H0.
-----
Lemma in_dom_restrby : forall (m:Map A) (m':Map B) (a:ad), in_dom A a (MapDomRestrBy A B m m') = andb (in_dom A a m) (negb (in_dom B a m')).
Proof.
unfold in_dom in |- *.
intros.
rewrite (MapDomRestrBy_semantics A B m m' a).
elim (option_sum B (MapGet B m' a)).
intro H.
elim H.
intros y H0.

*****
H0 : eq (MapGet B m' a) (Some y)
y : B
H : sig (fun y : B => eq (MapGet B m' a) (Some y))
a : ad
m' : Map B
m : Map A
A,B : Type
*****
eq match match MapGet B m' a with | Some _ => None | None => MapGet A m a end with | Some _ => true | None => false end (andb match MapGet A m a with | Some _ => true | None => false end (negb match MapGet B m' a with | Some _ => true | None => false end))
+++++
rewrite H0.
-----
Lemma in_dom_restrby : forall (m:Map A) (m':Map B) (a:ad), in_dom A a (MapDomRestrBy A B m m') = andb (in_dom A a m) (negb (in_dom B a m')).
Proof.
unfold in_dom in |- *.
intros.
rewrite (MapDomRestrBy_semantics A B m m' a).
elim (option_sum B (MapGet B m' a)).
intro H.
elim H.
intros y H0.
rewrite H0.

*****
H0 : eq (MapGet B m' a) (Some y)
y : B
H : sig (fun y : B => eq (MapGet B m' a) (Some y))
a : ad
m' : Map B
m : Map A
A,B : Type
*****
eq false (andb match MapGet A m a with | Some _ => true | None => false end (negb true))
+++++
unfold negb in |- *.
-----
Lemma in_dom_restrby : forall (m:Map A) (m':Map B) (a:ad), in_dom A a (MapDomRestrBy A B m m') = andb (in_dom A a m) (negb (in_dom B a m')).
Proof.
unfold in_dom in |- *.
intros.
rewrite (MapDomRestrBy_semantics A B m m' a).
elim (option_sum B (MapGet B m' a)).
intro H.
elim H.
intros y H0.
rewrite H0.
unfold negb in |- *.

*****
H0 : eq (MapGet B m' a) (Some y)
y : B
H : sig (fun y : B => eq (MapGet B m' a) (Some y))
a : ad
m' : Map B
m : Map A
A,B : Type
*****
eq false (andb match MapGet A m a with | Some _ => true | None => false end false)
+++++
rewrite andb_b_false.
-----
Lemma in_dom_restrby : forall (m:Map A) (m':Map B) (a:ad), in_dom A a (MapDomRestrBy A B m m') = andb (in_dom A a m) (negb (in_dom B a m')).
Proof.
unfold in_dom in |- *.
intros.
rewrite (MapDomRestrBy_semantics A B m m' a).
elim (option_sum B (MapGet B m' a)).
intro H.
elim H.
intros y H0.
rewrite H0.
unfold negb in |- *.
rewrite andb_b_false.

*****
H0 : eq (MapGet B m' a) (Some y)
y : B
H : sig (fun y : B => eq (MapGet B m' a) (Some y))
a : ad
m' : Map B
m : Map A
A,B : Type
*****
eq false false
+++++
reflexivity.
-----
Lemma in_dom_restrby : forall (m:Map A) (m':Map B) (a:ad), in_dom A a (MapDomRestrBy A B m m') = andb (in_dom A a m) (negb (in_dom B a m')).
Proof.
unfold in_dom in |- *.
intros.
rewrite (MapDomRestrBy_semantics A B m m' a).
elim (option_sum B (MapGet B m' a)).

*****
a : ad
m' : Map B
m : Map A
A,B : Type
*****
forall _ : eq (MapGet B m' a) None, eq match match MapGet B m' a with | Some _ => None | None => MapGet A m a end with | Some _ => true | None => false end (andb match MapGet A m a with | Some _ => true | None => false end (negb match MapGet B m' a with | Some _ => true | None => false end))
+++++
intro H.
-----
Lemma in_dom_restrby : forall (m:Map A) (m':Map B) (a:ad), in_dom A a (MapDomRestrBy A B m m') = andb (in_dom A a m) (negb (in_dom B a m')).
Proof.
unfold in_dom in |- *.
intros.
rewrite (MapDomRestrBy_semantics A B m m' a).
elim (option_sum B (MapGet B m' a)).
intro H.

*****
H : eq (MapGet B m' a) None
a : ad
m' : Map B
m : Map A
A,B : Type
*****
eq match match MapGet B m' a with | Some _ => None | None => MapGet A m a end with | Some _ => true | None => false end (andb match MapGet A m a with | Some _ => true | None => false end (negb match MapGet B m' a with | Some _ => true | None => false end))
+++++
rewrite H.
-----
Lemma in_dom_restrby : forall (m:Map A) (m':Map B) (a:ad), in_dom A a (MapDomRestrBy A B m m') = andb (in_dom A a m) (negb (in_dom B a m')).
Proof.
unfold in_dom in |- *.
intros.
rewrite (MapDomRestrBy_semantics A B m m' a).
elim (option_sum B (MapGet B m' a)).
intro H.
rewrite H.

*****
H : eq (MapGet B m' a) None
a : ad
m' : Map B
m : Map A
A,B : Type
*****
eq match MapGet A m a with | Some _ => true | None => false end (andb match MapGet A m a with | Some _ => true | None => false end (negb false))
+++++
unfold negb in |- *.
-----
Lemma in_dom_restrby : forall (m:Map A) (m':Map B) (a:ad), in_dom A a (MapDomRestrBy A B m m') = andb (in_dom A a m) (negb (in_dom B a m')).
Proof.
unfold in_dom in |- *.
intros.
rewrite (MapDomRestrBy_semantics A B m m' a).
elim (option_sum B (MapGet B m' a)).
intro H.
rewrite H.
unfold negb in |- *.

*****
H : eq (MapGet B m' a) None
a : ad
m' : Map B
m : Map A
A,B : Type
*****
eq match MapGet A m a with | Some _ => true | None => false end (andb match MapGet A m a with | Some _ => true | None => false end true)
+++++
rewrite andb_b_true.
-----
Lemma in_dom_restrby : forall (m:Map A) (m':Map B) (a:ad), in_dom A a (MapDomRestrBy A B m m') = andb (in_dom A a m) (negb (in_dom B a m')).
Proof.
unfold in_dom in |- *.
intros.
rewrite (MapDomRestrBy_semantics A B m m' a).
elim (option_sum B (MapGet B m' a)).
intro H.
rewrite H.
unfold negb in |- *.
rewrite andb_b_true.

*****
H : eq (MapGet B m' a) None
a : ad
m' : Map B
m : Map A
A,B : Type
*****
eq match MapGet A m a with | Some _ => true | None => false end match MapGet A m a with | Some _ => true | None => false end
+++++
reflexivity.
-----
Lemma in_dom_restrby : forall (m:Map A) (m':Map B) (a:ad), in_dom A a (MapDomRestrBy A B m m') = andb (in_dom A a m) (negb (in_dom B a m')).
Proof.
unfold in_dom in |- *.
intros.
rewrite (MapDomRestrBy_semantics A B m m' a).
elim (option_sum B (MapGet B m' a)).

*****

*****

+++++
Qed.
-----
End InDom.
-----
Definition FSet := Map unit.
-----
Section FSetDefs.
-----
Variable A : Type.
-----
Definition in_FSet : ad -> FSet -> bool := in_dom unit.
-----
Fixpoint MapDom (m:Map A) : FSet :=\n    match m with\n    | M0 => M0 unit\n    | M1 a _ => M1 unit a tt\n    | M2 m m' => M2 unit (MapDom m) (MapDom m')\n    end.
-----
Lemma MapDom_semantics_1 :\n   forall (m:Map A) (a:ad) (y:A),\n     MapGet A m a = Some y -> in_FSet a (MapDom m) = true.
-----
Lemma MapDom_semantics_1 : forall (m:Map A) (a:ad) (y:A), MapGet A m a = Some y -> in_FSet a (MapDom m) = true.

*****
A : Type
*****
forall (m : Map A) (a : ad) (y : A) (_ : eq (MapGet A m a) (Some y)), eq (in_FSet a (MapDom m)) true
+++++
Proof.
-----
Lemma MapDom_semantics_1 : forall (m:Map A) (a:ad) (y:A), MapGet A m a = Some y -> in_FSet a (MapDom m) = true.
Proof.

*****
A : Type
*****
forall (m : Map A) (a : ad) (y : A) (_ : eq (MapGet A m a) (Some y)), eq (in_FSet a (MapDom m)) true
+++++
simple induction m.
-----
Lemma MapDom_semantics_1 : forall (m:Map A) (a:ad) (y:A), MapGet A m a = Some y -> in_FSet a (MapDom m) = true.
Proof.
simple induction m.

*****
m : Map A
A : Type
*****
forall (a : ad) (y : A) (_ : eq (MapGet A (M0 A) a) (Some y)), eq (in_FSet a (MapDom (M0 A))) true
+++++
intros.
-----
Lemma MapDom_semantics_1 : forall (m:Map A) (a:ad) (y:A), MapGet A m a = Some y -> in_FSet a (MapDom m) = true.
Proof.
simple induction m.
intros.

*****
H : eq (MapGet A (M0 A) a) (Some y)
y : A
a : ad
m : Map A
A : Type
*****
eq (in_FSet a (MapDom (M0 A))) true
+++++
discriminate H.
-----
Lemma MapDom_semantics_1 : forall (m:Map A) (a:ad) (y:A), MapGet A m a = Some y -> in_FSet a (MapDom m) = true.
Proof.
simple induction m.

*****
m : Map A
A : Type
*****
forall (a : ad) (a0 : A) (a1 : ad) (y : A) (_ : eq (MapGet A (M1 A a a0) a1) (Some y)), eq (in_FSet a1 (MapDom (M1 A a a0))) true
+++++
unfold MapDom in |- *.
-----
Lemma MapDom_semantics_1 : forall (m:Map A) (a:ad) (y:A), MapGet A m a = Some y -> in_FSet a (MapDom m) = true.
Proof.
simple induction m.
unfold MapDom in |- *.

*****
m : Map A
A : Type
*****
forall (a : ad) (a0 : A) (a1 : ad) (y : A) (_ : eq (MapGet A (M1 A a a0) a1) (Some y)), eq (in_FSet a1 (M1 unit a tt)) true
+++++
unfold in_FSet in |- *.
-----
Lemma MapDom_semantics_1 : forall (m:Map A) (a:ad) (y:A), MapGet A m a = Some y -> in_FSet a (MapDom m) = true.
Proof.
simple induction m.
unfold MapDom in |- *.
unfold in_FSet in |- *.

*****
m : Map A
A : Type
*****
forall (a : ad) (a0 : A) (a1 : ad) (y : A) (_ : eq (MapGet A (M1 A a a0) a1) (Some y)), eq (in_dom unit a1 (M1 unit a tt)) true
+++++
unfold in_dom in |- *.
-----
Lemma MapDom_semantics_1 : forall (m:Map A) (a:ad) (y:A), MapGet A m a = Some y -> in_FSet a (MapDom m) = true.
Proof.
simple induction m.
unfold MapDom in |- *.
unfold in_FSet in |- *.
unfold in_dom in |- *.

*****
m : Map A
A : Type
*****
forall (a : ad) (a0 : A) (a1 : ad) (y : A) (_ : eq (MapGet A (M1 A a a0) a1) (Some y)), eq match MapGet unit (M1 unit a tt) a1 with | Some _ => true | None => false end true
+++++
unfold MapGet in |- *.
-----
Lemma MapDom_semantics_1 : forall (m:Map A) (a:ad) (y:A), MapGet A m a = Some y -> in_FSet a (MapDom m) = true.
Proof.
simple induction m.
unfold MapDom in |- *.
unfold in_FSet in |- *.
unfold in_dom in |- *.
unfold MapGet in |- *.

*****
m : Map A
A : Type
*****
forall (a : ad) (a0 : A) (a1 : ad) (y : A) (_ : eq (if N.eqb a a1 then Some a0 else None) (Some y)), eq match (if N.eqb a a1 then Some tt else None) with | Some _ => true | None => false end true
+++++
intros a y a0 y0.
-----
Lemma MapDom_semantics_1 : forall (m:Map A) (a:ad) (y:A), MapGet A m a = Some y -> in_FSet a (MapDom m) = true.
Proof.
simple induction m.
unfold MapDom in |- *.
unfold in_FSet in |- *.
unfold in_dom in |- *.
unfold MapGet in |- *.
intros a y a0 y0.

*****
y0 : A
a0 : ad
y : A
a : ad
m : Map A
A : Type
*****
forall _ : eq (if N.eqb a a0 then Some y else None) (Some y0), eq match (if N.eqb a a0 then Some tt else None) with | Some _ => true | None => false end true
+++++
case (Neqb a a0).
-----
Lemma MapDom_semantics_1 : forall (m:Map A) (a:ad) (y:A), MapGet A m a = Some y -> in_FSet a (MapDom m) = true.
Proof.
simple induction m.
unfold MapDom in |- *.
unfold in_FSet in |- *.
unfold in_dom in |- *.
unfold MapGet in |- *.
intros a y a0 y0.
case (Neqb a a0).

*****
y0 : A
a0 : ad
y : A
a : ad
m : Map A
A : Type
*****
forall _ : eq (Some y) (Some y0), eq true true
+++++
trivial.
-----
Lemma MapDom_semantics_1 : forall (m:Map A) (a:ad) (y:A), MapGet A m a = Some y -> in_FSet a (MapDom m) = true.
Proof.
simple induction m.
unfold MapDom in |- *.
unfold in_FSet in |- *.
unfold in_dom in |- *.
unfold MapGet in |- *.
intros a y a0 y0.
case (Neqb a a0).

*****
y0 : A
a0 : ad
y : A
a : ad
m : Map A
A : Type
*****
forall _ : eq None (Some y0), eq false true
+++++
intro.
-----
Lemma MapDom_semantics_1 : forall (m:Map A) (a:ad) (y:A), MapGet A m a = Some y -> in_FSet a (MapDom m) = true.
Proof.
simple induction m.
unfold MapDom in |- *.
unfold in_FSet in |- *.
unfold in_dom in |- *.
unfold MapGet in |- *.
intros a y a0 y0.
case (Neqb a a0).
intro.

*****
H : eq None (Some y0)
y0 : A
a0 : ad
y : A
a : ad
m : Map A
A : Type
*****
eq false true
+++++
discriminate H.
-----
Lemma MapDom_semantics_1 : forall (m:Map A) (a:ad) (y:A), MapGet A m a = Some y -> in_FSet a (MapDom m) = true.
Proof.
simple induction m.

*****
m : Map A
A : Type
*****
forall (m : Map A) (_ : forall (a : ad) (y : A) (_ : eq (MapGet A m a) (Some y)), eq (in_FSet a (MapDom m)) true) (m0 : Map A) (_ : forall (a : ad) (y : A) (_ : eq (MapGet A m0 a) (Some y)), eq (in_FSet a (MapDom m0)) true) (a : ad) (y : A) (_ : eq (MapGet A (M2 A m m0) a) (Some y)), eq (in_FSet a (MapDom (M2 A m m0))) true
+++++
intros m0 H m1 H0 a y.
-----
Lemma MapDom_semantics_1 : forall (m:Map A) (a:ad) (y:A), MapGet A m a = Some y -> in_FSet a (MapDom m) = true.
Proof.
simple induction m.
intros m0 H m1 H0 a y.

*****
y : A
a : ad
H0 : forall (a : ad) (y : A) (_ : eq (MapGet A m1 a) (Some y)),\neq (in_FSet a (MapDom m1)) true
m1 : Map A
H : forall (a : ad) (y : A) (_ : eq (MapGet A m0 a) (Some y)),\neq (in_FSet a (MapDom m0)) true
m,m0 : Map A
A : Type
*****
forall _ : eq (MapGet A (M2 A m0 m1) a) (Some y), eq (in_FSet a (MapDom (M2 A m0 m1))) true
+++++
rewrite (MapGet_M2_bit_0_if A m0 m1 a).
-----
Lemma MapDom_semantics_1 : forall (m:Map A) (a:ad) (y:A), MapGet A m a = Some y -> in_FSet a (MapDom m) = true.
Proof.
simple induction m.
intros m0 H m1 H0 a y.
rewrite (MapGet_M2_bit_0_if A m0 m1 a).

*****
y : A
a : ad
H0 : forall (a : ad) (y : A) (_ : eq (MapGet A m1 a) (Some y)),\neq (in_FSet a (MapDom m1)) true
m1 : Map A
H : forall (a : ad) (y : A) (_ : eq (MapGet A m0 a) (Some y)),\neq (in_FSet a (MapDom m0)) true
m,m0 : Map A
A : Type
*****
forall _ : eq (if N.odd a then MapGet A m1 (N.div2 a) else MapGet A m0 (N.div2 a)) (Some y), eq (in_FSet a (MapDom (M2 A m0 m1))) true
+++++
simpl in |- *.
-----
Lemma MapDom_semantics_1 : forall (m:Map A) (a:ad) (y:A), MapGet A m a = Some y -> in_FSet a (MapDom m) = true.
Proof.
simple induction m.
intros m0 H m1 H0 a y.
rewrite (MapGet_M2_bit_0_if A m0 m1 a).
simpl in |- *.

*****
y : A
a : ad
H0 : forall (a : ad) (y : A) (_ : eq (MapGet A m1 a) (Some y)),\neq (in_FSet a (MapDom m1)) true
m1 : Map A
H : forall (a : ad) (y : A) (_ : eq (MapGet A m0 a) (Some y)),\neq (in_FSet a (MapDom m0)) true
m,m0 : Map A
A : Type
*****
forall _ : eq (if N.odd a then MapGet A m1 (N.div2 a) else MapGet A m0 (N.div2 a)) (Some y), eq (in_FSet a (M2 unit (MapDom m0) (MapDom m1))) true
+++++
unfold in_FSet in |- *.
-----
Lemma MapDom_semantics_1 : forall (m:Map A) (a:ad) (y:A), MapGet A m a = Some y -> in_FSet a (MapDom m) = true.
Proof.
simple induction m.
intros m0 H m1 H0 a y.
rewrite (MapGet_M2_bit_0_if A m0 m1 a).
simpl in |- *.
unfold in_FSet in |- *.

*****
y : A
a : ad
H0 : forall (a : ad) (y : A) (_ : eq (MapGet A m1 a) (Some y)),\neq (in_FSet a (MapDom m1)) true
m1 : Map A
H : forall (a : ad) (y : A) (_ : eq (MapGet A m0 a) (Some y)),\neq (in_FSet a (MapDom m0)) true
m,m0 : Map A
A : Type
*****
forall _ : eq (if N.odd a then MapGet A m1 (N.div2 a) else MapGet A m0 (N.div2 a)) (Some y), eq (in_dom unit a (M2 unit (MapDom m0) (MapDom m1))) true
+++++
unfold in_dom in |- *.
-----
Lemma MapDom_semantics_1 : forall (m:Map A) (a:ad) (y:A), MapGet A m a = Some y -> in_FSet a (MapDom m) = true.
Proof.
simple induction m.
intros m0 H m1 H0 a y.
rewrite (MapGet_M2_bit_0_if A m0 m1 a).
simpl in |- *.
unfold in_FSet in |- *.
unfold in_dom in |- *.

*****
y : A
a : ad
H0 : forall (a : ad) (y : A) (_ : eq (MapGet A m1 a) (Some y)),\neq (in_FSet a (MapDom m1)) true
m1 : Map A
H : forall (a : ad) (y : A) (_ : eq (MapGet A m0 a) (Some y)),\neq (in_FSet a (MapDom m0)) true
m,m0 : Map A
A : Type
*****
forall _ : eq (if N.odd a then MapGet A m1 (N.div2 a) else MapGet A m0 (N.div2 a)) (Some y), eq match MapGet unit (M2 unit (MapDom m0) (MapDom m1)) a with | Some _ => true | None => false end true
+++++
rewrite (MapGet_M2_bit_0_if unit (MapDom m0) (MapDom m1) a).
-----
Lemma MapDom_semantics_1 : forall (m:Map A) (a:ad) (y:A), MapGet A m a = Some y -> in_FSet a (MapDom m) = true.
Proof.
simple induction m.
intros m0 H m1 H0 a y.
rewrite (MapGet_M2_bit_0_if A m0 m1 a).
simpl in |- *.
unfold in_FSet in |- *.
unfold in_dom in |- *.
rewrite (MapGet_M2_bit_0_if unit (MapDom m0) (MapDom m1) a).

*****
y : A
a : ad
H0 : forall (a : ad) (y : A) (_ : eq (MapGet A m1 a) (Some y)),\neq (in_FSet a (MapDom m1)) true
m1 : Map A
H : forall (a : ad) (y : A) (_ : eq (MapGet A m0 a) (Some y)),\neq (in_FSet a (MapDom m0)) true
m,m0 : Map A
A : Type
*****
forall _ : eq (if N.odd a then MapGet A m1 (N.div2 a) else MapGet A m0 (N.div2 a)) (Some y), eq match (if N.odd a then MapGet unit (MapDom m1) (N.div2 a) else MapGet unit (MapDom m0) (N.div2 a)) with | Some _ => true | None => false end true
+++++
case (Nbit0 a).
-----
Lemma MapDom_semantics_1 : forall (m:Map A) (a:ad) (y:A), MapGet A m a = Some y -> in_FSet a (MapDom m) = true.
Proof.
simple induction m.
intros m0 H m1 H0 a y.
rewrite (MapGet_M2_bit_0_if A m0 m1 a).
simpl in |- *.
unfold in_FSet in |- *.
unfold in_dom in |- *.
rewrite (MapGet_M2_bit_0_if unit (MapDom m0) (MapDom m1) a).
case (Nbit0 a).

*****
y : A
a : ad
H0 : forall (a : ad) (y : A) (_ : eq (MapGet A m1 a) (Some y)),\neq (in_FSet a (MapDom m1)) true
m1 : Map A
H : forall (a : ad) (y : A) (_ : eq (MapGet A m0 a) (Some y)),\neq (in_FSet a (MapDom m0)) true
m,m0 : Map A
A : Type
*****
forall _ : eq (MapGet A m1 (N.div2 a)) (Some y), eq match MapGet unit (MapDom m1) (N.div2 a) with | Some _ => true | None => false end true
+++++
unfold in_FSet.
-----
Lemma MapDom_semantics_1 : forall (m:Map A) (a:ad) (y:A), MapGet A m a = Some y -> in_FSet a (MapDom m) = true.
Proof.
simple induction m.
intros m0 H m1 H0 a y.
rewrite (MapGet_M2_bit_0_if A m0 m1 a).
simpl in |- *.
unfold in_FSet in |- *.
unfold in_dom in |- *.
rewrite (MapGet_M2_bit_0_if unit (MapDom m0) (MapDom m1) a).
case (Nbit0 a).
unfold in_FSet.

*****
y : A
a : ad
H0 : forall (a : ad) (y : A) (_ : eq (MapGet A m1 a) (Some y)),\neq (in_FSet a (MapDom m1)) true
m1 : Map A
H : forall (a : ad) (y : A) (_ : eq (MapGet A m0 a) (Some y)),\neq (in_FSet a (MapDom m0)) true
m,m0 : Map A
A : Type
*****
forall _ : eq (MapGet A m1 (N.div2 a)) (Some y), eq match MapGet unit (MapDom m1) (N.div2 a) with | Some _ => true | None => false end true
+++++
unfold in_dom in H0.
-----
Lemma MapDom_semantics_1 : forall (m:Map A) (a:ad) (y:A), MapGet A m a = Some y -> in_FSet a (MapDom m) = true.
Proof.
simple induction m.
intros m0 H m1 H0 a y.
rewrite (MapGet_M2_bit_0_if A m0 m1 a).
simpl in |- *.
unfold in_FSet in |- *.
unfold in_dom in |- *.
rewrite (MapGet_M2_bit_0_if unit (MapDom m0) (MapDom m1) a).
case (Nbit0 a).
unfold in_FSet.
unfold in_dom in H0.

*****
y : A
a : ad
H0 : forall (a : ad) (y : A) (_ : eq (MapGet A m1 a) (Some y)),\neq (in_FSet a (MapDom m1)) true
m1 : Map A
H : forall (a : ad) (y : A) (_ : eq (MapGet A m0 a) (Some y)),\neq (in_FSet a (MapDom m0)) true
m,m0 : Map A
A : Type
*****
forall _ : eq (MapGet A m1 (N.div2 a)) (Some y), eq match MapGet unit (MapDom m1) (N.div2 a) with | Some _ => true | None => false end true
+++++
intro.
-----
Lemma MapDom_semantics_1 : forall (m:Map A) (a:ad) (y:A), MapGet A m a = Some y -> in_FSet a (MapDom m) = true.
Proof.
simple induction m.
intros m0 H m1 H0 a y.
rewrite (MapGet_M2_bit_0_if A m0 m1 a).
simpl in |- *.
unfold in_FSet in |- *.
unfold in_dom in |- *.
rewrite (MapGet_M2_bit_0_if unit (MapDom m0) (MapDom m1) a).
case (Nbit0 a).
unfold in_FSet.
unfold in_dom in H0.
intro.

*****
H1 : eq (MapGet A m1 (N.div2 a)) (Some y)
y : A
a : ad
H0 : forall (a : ad) (y : A) (_ : eq (MapGet A m1 a) (Some y)),\neq (in_FSet a (MapDom m1)) true
m1 : Map A
H : forall (a : ad) (y : A) (_ : eq (MapGet A m0 a) (Some y)),\neq (in_FSet a (MapDom m0)) true
m,m0 : Map A
A : Type
*****
eq match MapGet unit (MapDom m1) (N.div2 a) with | Some _ => true | None => false end true
+++++
apply H0 with (y := y).
-----
Lemma MapDom_semantics_1 : forall (m:Map A) (a:ad) (y:A), MapGet A m a = Some y -> in_FSet a (MapDom m) = true.
Proof.
simple induction m.
intros m0 H m1 H0 a y.
rewrite (MapGet_M2_bit_0_if A m0 m1 a).
simpl in |- *.
unfold in_FSet in |- *.
unfold in_dom in |- *.
rewrite (MapGet_M2_bit_0_if unit (MapDom m0) (MapDom m1) a).
case (Nbit0 a).
unfold in_FSet.
unfold in_dom in H0.
intro.
apply H0 with (y := y).

*****
H1 : eq (MapGet A m1 (N.div2 a)) (Some y)
y : A
a : ad
H0 : forall (a : ad) (y : A) (_ : eq (MapGet A m1 a) (Some y)),\neq (in_FSet a (MapDom m1)) true
m1 : Map A
H : forall (a : ad) (y : A) (_ : eq (MapGet A m0 a) (Some y)),\neq (in_FSet a (MapDom m0)) true
m,m0 : Map A
A : Type
*****
eq (MapGet A m1 (N.div2 a)) (Some y)
+++++
assumption.
-----
Lemma MapDom_semantics_1 : forall (m:Map A) (a:ad) (y:A), MapGet A m a = Some y -> in_FSet a (MapDom m) = true.
Proof.
simple induction m.
intros m0 H m1 H0 a y.
rewrite (MapGet_M2_bit_0_if A m0 m1 a).
simpl in |- *.
unfold in_FSet in |- *.
unfold in_dom in |- *.
rewrite (MapGet_M2_bit_0_if unit (MapDom m0) (MapDom m1) a).
case (Nbit0 a).

*****
y : A
a : ad
H0 : forall (a : ad) (y : A) (_ : eq (MapGet A m1 a) (Some y)),\neq (in_FSet a (MapDom m1)) true
m1 : Map A
H : forall (a : ad) (y : A) (_ : eq (MapGet A m0 a) (Some y)),\neq (in_FSet a (MapDom m0)) true
m,m0 : Map A
A : Type
*****
forall _ : eq (MapGet A m0 (N.div2 a)) (Some y), eq match MapGet unit (MapDom m0) (N.div2 a) with | Some _ => true | None => false end true
+++++
unfold in_FSet.
-----
Lemma MapDom_semantics_1 : forall (m:Map A) (a:ad) (y:A), MapGet A m a = Some y -> in_FSet a (MapDom m) = true.
Proof.
simple induction m.
intros m0 H m1 H0 a y.
rewrite (MapGet_M2_bit_0_if A m0 m1 a).
simpl in |- *.
unfold in_FSet in |- *.
unfold in_dom in |- *.
rewrite (MapGet_M2_bit_0_if unit (MapDom m0) (MapDom m1) a).
case (Nbit0 a).
unfold in_FSet.

*****
y : A
a : ad
H0 : forall (a : ad) (y : A) (_ : eq (MapGet A m1 a) (Some y)),\neq (in_FSet a (MapDom m1)) true
m1 : Map A
H : forall (a : ad) (y : A) (_ : eq (MapGet A m0 a) (Some y)),\neq (in_FSet a (MapDom m0)) true
m,m0 : Map A
A : Type
*****
forall _ : eq (MapGet A m0 (N.div2 a)) (Some y), eq match MapGet unit (MapDom m0) (N.div2 a) with | Some _ => true | None => false end true
+++++
unfold in_dom in H.
-----
Lemma MapDom_semantics_1 : forall (m:Map A) (a:ad) (y:A), MapGet A m a = Some y -> in_FSet a (MapDom m) = true.
Proof.
simple induction m.
intros m0 H m1 H0 a y.
rewrite (MapGet_M2_bit_0_if A m0 m1 a).
simpl in |- *.
unfold in_FSet in |- *.
unfold in_dom in |- *.
rewrite (MapGet_M2_bit_0_if unit (MapDom m0) (MapDom m1) a).
case (Nbit0 a).
unfold in_FSet.
unfold in_dom in H.

*****
y : A
a : ad
H0 : forall (a : ad) (y : A) (_ : eq (MapGet A m1 a) (Some y)),\neq (in_FSet a (MapDom m1)) true
m1 : Map A
H : forall (a : ad) (y : A) (_ : eq (MapGet A m0 a) (Some y)),\neq (in_FSet a (MapDom m0)) true
m,m0 : Map A
A : Type
*****
forall _ : eq (MapGet A m0 (N.div2 a)) (Some y), eq match MapGet unit (MapDom m0) (N.div2 a) with | Some _ => true | None => false end true
+++++
intro.
-----
Lemma MapDom_semantics_1 : forall (m:Map A) (a:ad) (y:A), MapGet A m a = Some y -> in_FSet a (MapDom m) = true.
Proof.
simple induction m.
intros m0 H m1 H0 a y.
rewrite (MapGet_M2_bit_0_if A m0 m1 a).
simpl in |- *.
unfold in_FSet in |- *.
unfold in_dom in |- *.
rewrite (MapGet_M2_bit_0_if unit (MapDom m0) (MapDom m1) a).
case (Nbit0 a).
unfold in_FSet.
unfold in_dom in H.
intro.

*****
H1 : eq (MapGet A m0 (N.div2 a)) (Some y)
y : A
a : ad
H0 : forall (a : ad) (y : A) (_ : eq (MapGet A m1 a) (Some y)),\neq (in_FSet a (MapDom m1)) true
m1 : Map A
H : forall (a : ad) (y : A) (_ : eq (MapGet A m0 a) (Some y)),\neq (in_FSet a (MapDom m0)) true
m,m0 : Map A
A : Type
*****
eq match MapGet unit (MapDom m0) (N.div2 a) with | Some _ => true | None => false end true
+++++
apply H with (y := y).
-----
Lemma MapDom_semantics_1 : forall (m:Map A) (a:ad) (y:A), MapGet A m a = Some y -> in_FSet a (MapDom m) = true.
Proof.
simple induction m.
intros m0 H m1 H0 a y.
rewrite (MapGet_M2_bit_0_if A m0 m1 a).
simpl in |- *.
unfold in_FSet in |- *.
unfold in_dom in |- *.
rewrite (MapGet_M2_bit_0_if unit (MapDom m0) (MapDom m1) a).
case (Nbit0 a).
unfold in_FSet.
unfold in_dom in H.
intro.
apply H with (y := y).

*****
H1 : eq (MapGet A m0 (N.div2 a)) (Some y)
y : A
a : ad
H0 : forall (a : ad) (y : A) (_ : eq (MapGet A m1 a) (Some y)),\neq (in_FSet a (MapDom m1)) true
m1 : Map A
H : forall (a : ad) (y : A) (_ : eq (MapGet A m0 a) (Some y)),\neq (in_FSet a (MapDom m0)) true
m,m0 : Map A
A : Type
*****
eq (MapGet A m0 (N.div2 a)) (Some y)
+++++
assumption.
-----
Lemma MapDom_semantics_1 : forall (m:Map A) (a:ad) (y:A), MapGet A m a = Some y -> in_FSet a (MapDom m) = true.
Proof.
simple induction m.

*****

*****

+++++
Qed.
-----
Lemma MapDom_semantics_2 :\n   forall (m:Map A) (a:ad),\n     in_FSet a (MapDom m) = true -> {y : A | MapGet A m a = Some y}.
-----
Lemma MapDom_semantics_2 : forall (m:Map A) (a:ad), in_FSet a (MapDom m) = true -> {y : A | MapGet A m a = Some y}.

*****
A : Type
*****
forall (m : Map A) (a : ad) (_ : eq (in_FSet a (MapDom m)) true), sig (fun y : A => eq (MapGet A m a) (Some y))
+++++
Proof.
-----
Lemma MapDom_semantics_2 : forall (m:Map A) (a:ad), in_FSet a (MapDom m) = true -> {y : A | MapGet A m a = Some y}.
Proof.

*****
A : Type
*****
forall (m : Map A) (a : ad) (_ : eq (in_FSet a (MapDom m)) true), sig (fun y : A => eq (MapGet A m a) (Some y))
+++++
simple induction m.
-----
Lemma MapDom_semantics_2 : forall (m:Map A) (a:ad), in_FSet a (MapDom m) = true -> {y : A | MapGet A m a = Some y}.
Proof.
simple induction m.

*****
m : Map A
A : Type
*****
forall (a : ad) (_ : eq (in_FSet a (MapDom (M0 A))) true), sig (fun y : A => eq (MapGet A (M0 A) a) (Some y))
+++++
intros.
-----
Lemma MapDom_semantics_2 : forall (m:Map A) (a:ad), in_FSet a (MapDom m) = true -> {y : A | MapGet A m a = Some y}.
Proof.
simple induction m.
intros.

*****
H : eq (in_FSet a (MapDom (M0 A))) true
a : ad
m : Map A
A : Type
*****
sig (fun y : A => eq (MapGet A (M0 A) a) (Some y))
+++++
discriminate H.
-----
Lemma MapDom_semantics_2 : forall (m:Map A) (a:ad), in_FSet a (MapDom m) = true -> {y : A | MapGet A m a = Some y}.
Proof.
simple induction m.

*****
m : Map A
A : Type
*****
forall (a : ad) (a0 : A) (a1 : ad) (_ : eq (in_FSet a1 (MapDom (M1 A a a0))) true), sig (fun y : A => eq (MapGet A (M1 A a a0) a1) (Some y))
+++++
unfold MapDom in |- *.
-----
Lemma MapDom_semantics_2 : forall (m:Map A) (a:ad), in_FSet a (MapDom m) = true -> {y : A | MapGet A m a = Some y}.
Proof.
simple induction m.
unfold MapDom in |- *.

*****
m : Map A
A : Type
*****
forall (a : ad) (a0 : A) (a1 : ad) (_ : eq (in_FSet a1 (M1 unit a tt)) true), sig (fun y : A => eq (MapGet A (M1 A a a0) a1) (Some y))
+++++
unfold in_FSet in |- *.
-----
Lemma MapDom_semantics_2 : forall (m:Map A) (a:ad), in_FSet a (MapDom m) = true -> {y : A | MapGet A m a = Some y}.
Proof.
simple induction m.
unfold MapDom in |- *.
unfold in_FSet in |- *.

*****
m : Map A
A : Type
*****
forall (a : ad) (a0 : A) (a1 : ad) (_ : eq (in_dom unit a1 (M1 unit a tt)) true), sig (fun y : A => eq (MapGet A (M1 A a a0) a1) (Some y))
+++++
unfold in_dom in |- *.
-----
Lemma MapDom_semantics_2 : forall (m:Map A) (a:ad), in_FSet a (MapDom m) = true -> {y : A | MapGet A m a = Some y}.
Proof.
simple induction m.
unfold MapDom in |- *.
unfold in_FSet in |- *.
unfold in_dom in |- *.

*****
m : Map A
A : Type
*****
forall (a : ad) (a0 : A) (a1 : ad) (_ : eq match MapGet unit (M1 unit a tt) a1 with | Some _ => true | None => false end true), sig (fun y : A => eq (MapGet A (M1 A a a0) a1) (Some y))
+++++
unfold MapGet in |- *.
-----
Lemma MapDom_semantics_2 : forall (m:Map A) (a:ad), in_FSet a (MapDom m) = true -> {y : A | MapGet A m a = Some y}.
Proof.
simple induction m.
unfold MapDom in |- *.
unfold in_FSet in |- *.
unfold in_dom in |- *.
unfold MapGet in |- *.

*****
m : Map A
A : Type
*****
forall (a : ad) (a0 : A) (a1 : ad) (_ : eq match (if N.eqb a a1 then Some tt else None) with | Some _ => true | None => false end true), sig (fun y : A => eq (if N.eqb a a1 then Some a0 else None) (Some y))
+++++
intros a y a0.
-----
Lemma MapDom_semantics_2 : forall (m:Map A) (a:ad), in_FSet a (MapDom m) = true -> {y : A | MapGet A m a = Some y}.
Proof.
simple induction m.
unfold MapDom in |- *.
unfold in_FSet in |- *.
unfold in_dom in |- *.
unfold MapGet in |- *.
intros a y a0.

*****
a0 : ad
y : A
a : ad
m : Map A
A : Type
*****
forall _ : eq match (if N.eqb a a0 then Some tt else None) with | Some _ => true | None => false end true, sig (fun y0 : A => eq (if N.eqb a a0 then Some y else None) (Some y0))
+++++
case (Neqb a a0).
-----
Lemma MapDom_semantics_2 : forall (m:Map A) (a:ad), in_FSet a (MapDom m) = true -> {y : A | MapGet A m a = Some y}.
Proof.
simple induction m.
unfold MapDom in |- *.
unfold in_FSet in |- *.
unfold in_dom in |- *.
unfold MapGet in |- *.
intros a y a0.
case (Neqb a a0).

*****
a0 : ad
y : A
a : ad
m : Map A
A : Type
*****
forall _ : eq true true, sig (fun y0 : A => eq (Some y) (Some y0))
+++++
intro.
-----
Lemma MapDom_semantics_2 : forall (m:Map A) (a:ad), in_FSet a (MapDom m) = true -> {y : A | MapGet A m a = Some y}.
Proof.
simple induction m.
unfold MapDom in |- *.
unfold in_FSet in |- *.
unfold in_dom in |- *.
unfold MapGet in |- *.
intros a y a0.
case (Neqb a a0).
intro.

*****
H : eq true true
a0 : ad
y : A
a : ad
m : Map A
A : Type
*****
sig (fun y0 : A => eq (Some y) (Some y0))
+++++
split with y.
-----
Lemma MapDom_semantics_2 : forall (m:Map A) (a:ad), in_FSet a (MapDom m) = true -> {y : A | MapGet A m a = Some y}.
Proof.
simple induction m.
unfold MapDom in |- *.
unfold in_FSet in |- *.
unfold in_dom in |- *.
unfold MapGet in |- *.
intros a y a0.
case (Neqb a a0).
intro.
split with y.

*****
H : eq true true
a0 : ad
y : A
a : ad
m : Map A
A : Type
*****
eq (Some y) (Some y)
+++++
reflexivity.
-----
Lemma MapDom_semantics_2 : forall (m:Map A) (a:ad), in_FSet a (MapDom m) = true -> {y : A | MapGet A m a = Some y}.
Proof.
simple induction m.
unfold MapDom in |- *.
unfold in_FSet in |- *.
unfold in_dom in |- *.
unfold MapGet in |- *.
intros a y a0.
case (Neqb a a0).

*****
a0 : ad
y : A
a : ad
m : Map A
A : Type
*****
forall _ : eq false true, sig (fun y : A => eq None (Some y))
+++++
intro.
-----
Lemma MapDom_semantics_2 : forall (m:Map A) (a:ad), in_FSet a (MapDom m) = true -> {y : A | MapGet A m a = Some y}.
Proof.
simple induction m.
unfold MapDom in |- *.
unfold in_FSet in |- *.
unfold in_dom in |- *.
unfold MapGet in |- *.
intros a y a0.
case (Neqb a a0).
intro.

*****
H : eq false true
a0 : ad
y : A
a : ad
m : Map A
A : Type
*****
sig (fun y : A => eq None (Some y))
+++++
discriminate H.
-----
Lemma MapDom_semantics_2 : forall (m:Map A) (a:ad), in_FSet a (MapDom m) = true -> {y : A | MapGet A m a = Some y}.
Proof.
simple induction m.

*****
m : Map A
A : Type
*****
forall (m : Map A) (_ : forall (a : ad) (_ : eq (in_FSet a (MapDom m)) true), sig (fun y : A => eq (MapGet A m a) (Some y))) (m0 : Map A) (_ : forall (a : ad) (_ : eq (in_FSet a (MapDom m0)) true), sig (fun y : A => eq (MapGet A m0 a) (Some y))) (a : ad) (_ : eq (in_FSet a (MapDom (M2 A m m0))) true), sig (fun y : A => eq (MapGet A (M2 A m m0) a) (Some y))
+++++
intros m0 H m1 H0 a.
-----
Lemma MapDom_semantics_2 : forall (m:Map A) (a:ad), in_FSet a (MapDom m) = true -> {y : A | MapGet A m a = Some y}.
Proof.
simple induction m.
intros m0 H m1 H0 a.

*****
a : ad
H0 : forall (a : ad) (_ : eq (in_FSet a (MapDom m1)) true),\nsig (fun y : A => eq (MapGet A m1 a) (Some y))
m1 : Map A
H : forall (a : ad) (_ : eq (in_FSet a (MapDom m0)) true),\nsig (fun y : A => eq (MapGet A m0 a) (Some y))
m,m0 : Map A
A : Type
*****
forall _ : eq (in_FSet a (MapDom (M2 A m0 m1))) true, sig (fun y : A => eq (MapGet A (M2 A m0 m1) a) (Some y))
+++++
rewrite (MapGet_M2_bit_0_if A m0 m1 a).
-----
Lemma MapDom_semantics_2 : forall (m:Map A) (a:ad), in_FSet a (MapDom m) = true -> {y : A | MapGet A m a = Some y}.
Proof.
simple induction m.
intros m0 H m1 H0 a.
rewrite (MapGet_M2_bit_0_if A m0 m1 a).

*****
a : ad
H0 : forall (a : ad) (_ : eq (in_FSet a (MapDom m1)) true),\nsig (fun y : A => eq (MapGet A m1 a) (Some y))
m1 : Map A
H : forall (a : ad) (_ : eq (in_FSet a (MapDom m0)) true),\nsig (fun y : A => eq (MapGet A m0 a) (Some y))
m,m0 : Map A
A : Type
*****
forall _ : eq (in_FSet a (MapDom (M2 A m0 m1))) true, sig (fun y : A => eq (if N.odd a then MapGet A m1 (N.div2 a) else MapGet A m0 (N.div2 a)) (Some y))
+++++
simpl in |- *.
-----
Lemma MapDom_semantics_2 : forall (m:Map A) (a:ad), in_FSet a (MapDom m) = true -> {y : A | MapGet A m a = Some y}.
Proof.
simple induction m.
intros m0 H m1 H0 a.
rewrite (MapGet_M2_bit_0_if A m0 m1 a).
simpl in |- *.

*****
a : ad
H0 : forall (a : ad) (_ : eq (in_FSet a (MapDom m1)) true),\nsig (fun y : A => eq (MapGet A m1 a) (Some y))
m1 : Map A
H : forall (a : ad) (_ : eq (in_FSet a (MapDom m0)) true),\nsig (fun y : A => eq (MapGet A m0 a) (Some y))
m,m0 : Map A
A : Type
*****
forall _ : eq (in_FSet a (M2 unit (MapDom m0) (MapDom m1))) true, sig (fun y : A => eq (if N.odd a then MapGet A m1 (N.div2 a) else MapGet A m0 (N.div2 a)) (Some y))
+++++
unfold in_FSet in |- *.
-----
Lemma MapDom_semantics_2 : forall (m:Map A) (a:ad), in_FSet a (MapDom m) = true -> {y : A | MapGet A m a = Some y}.
Proof.
simple induction m.
intros m0 H m1 H0 a.
rewrite (MapGet_M2_bit_0_if A m0 m1 a).
simpl in |- *.
unfold in_FSet in |- *.

*****
a : ad
H0 : forall (a : ad) (_ : eq (in_FSet a (MapDom m1)) true),\nsig (fun y : A => eq (MapGet A m1 a) (Some y))
m1 : Map A
H : forall (a : ad) (_ : eq (in_FSet a (MapDom m0)) true),\nsig (fun y : A => eq (MapGet A m0 a) (Some y))
m,m0 : Map A
A : Type
*****
forall _ : eq (in_dom unit a (M2 unit (MapDom m0) (MapDom m1))) true, sig (fun y : A => eq (if N.odd a then MapGet A m1 (N.div2 a) else MapGet A m0 (N.div2 a)) (Some y))
+++++
unfold in_dom in |- *.
-----
Lemma MapDom_semantics_2 : forall (m:Map A) (a:ad), in_FSet a (MapDom m) = true -> {y : A | MapGet A m a = Some y}.
Proof.
simple induction m.
intros m0 H m1 H0 a.
rewrite (MapGet_M2_bit_0_if A m0 m1 a).
simpl in |- *.
unfold in_FSet in |- *.
unfold in_dom in |- *.

*****
a : ad
H0 : forall (a : ad) (_ : eq (in_FSet a (MapDom m1)) true),\nsig (fun y : A => eq (MapGet A m1 a) (Some y))
m1 : Map A
H : forall (a : ad) (_ : eq (in_FSet a (MapDom m0)) true),\nsig (fun y : A => eq (MapGet A m0 a) (Some y))
m,m0 : Map A
A : Type
*****
forall _ : eq match MapGet unit (M2 unit (MapDom m0) (MapDom m1)) a with | Some _ => true | None => false end true, sig (fun y : A => eq (if N.odd a then MapGet A m1 (N.div2 a) else MapGet A m0 (N.div2 a)) (Some y))
+++++
rewrite (MapGet_M2_bit_0_if unit (MapDom m0) (MapDom m1) a).
-----
Lemma MapDom_semantics_2 : forall (m:Map A) (a:ad), in_FSet a (MapDom m) = true -> {y : A | MapGet A m a = Some y}.
Proof.
simple induction m.
intros m0 H m1 H0 a.
rewrite (MapGet_M2_bit_0_if A m0 m1 a).
simpl in |- *.
unfold in_FSet in |- *.
unfold in_dom in |- *.
rewrite (MapGet_M2_bit_0_if unit (MapDom m0) (MapDom m1) a).

*****
a : ad
H0 : forall (a : ad) (_ : eq (in_FSet a (MapDom m1)) true),\nsig (fun y : A => eq (MapGet A m1 a) (Some y))
m1 : Map A
H : forall (a : ad) (_ : eq (in_FSet a (MapDom m0)) true),\nsig (fun y : A => eq (MapGet A m0 a) (Some y))
m,m0 : Map A
A : Type
*****
forall _ : eq match (if N.odd a then MapGet unit (MapDom m1) (N.div2 a) else MapGet unit (MapDom m0) (N.div2 a)) with | Some _ => true | None => false end true, sig (fun y : A => eq (if N.odd a then MapGet A m1 (N.div2 a) else MapGet A m0 (N.div2 a)) (Some y))
+++++
case (Nbit0 a).
-----
Lemma MapDom_semantics_2 : forall (m:Map A) (a:ad), in_FSet a (MapDom m) = true -> {y : A | MapGet A m a = Some y}.
Proof.
simple induction m.
intros m0 H m1 H0 a.
rewrite (MapGet_M2_bit_0_if A m0 m1 a).
simpl in |- *.
unfold in_FSet in |- *.
unfold in_dom in |- *.
rewrite (MapGet_M2_bit_0_if unit (MapDom m0) (MapDom m1) a).
case (Nbit0 a).

*****
a : ad
H0 : forall (a : ad) (_ : eq (in_FSet a (MapDom m1)) true),\nsig (fun y : A => eq (MapGet A m1 a) (Some y))
m1 : Map A
H : forall (a : ad) (_ : eq (in_FSet a (MapDom m0)) true),\nsig (fun y : A => eq (MapGet A m0 a) (Some y))
m,m0 : Map A
A : Type
*****
forall _ : eq match MapGet unit (MapDom m1) (N.div2 a) with | Some _ => true | None => false end true, sig (fun y : A => eq (MapGet A m1 (N.div2 a)) (Some y))
+++++
unfold in_FSet.
-----
Lemma MapDom_semantics_2 : forall (m:Map A) (a:ad), in_FSet a (MapDom m) = true -> {y : A | MapGet A m a = Some y}.
Proof.
simple induction m.
intros m0 H m1 H0 a.
rewrite (MapGet_M2_bit_0_if A m0 m1 a).
simpl in |- *.
unfold in_FSet in |- *.
unfold in_dom in |- *.
rewrite (MapGet_M2_bit_0_if unit (MapDom m0) (MapDom m1) a).
case (Nbit0 a).
unfold in_FSet.

*****
a : ad
H0 : forall (a : ad) (_ : eq (in_FSet a (MapDom m1)) true),\nsig (fun y : A => eq (MapGet A m1 a) (Some y))
m1 : Map A
H : forall (a : ad) (_ : eq (in_FSet a (MapDom m0)) true),\nsig (fun y : A => eq (MapGet A m0 a) (Some y))
m,m0 : Map A
A : Type
*****
forall _ : eq match MapGet unit (MapDom m1) (N.div2 a) with | Some _ => true | None => false end true, sig (fun y : A => eq (MapGet A m1 (N.div2 a)) (Some y))
+++++
unfold in_dom in H0.
-----
Lemma MapDom_semantics_2 : forall (m:Map A) (a:ad), in_FSet a (MapDom m) = true -> {y : A | MapGet A m a = Some y}.
Proof.
simple induction m.
intros m0 H m1 H0 a.
rewrite (MapGet_M2_bit_0_if A m0 m1 a).
simpl in |- *.
unfold in_FSet in |- *.
unfold in_dom in |- *.
rewrite (MapGet_M2_bit_0_if unit (MapDom m0) (MapDom m1) a).
case (Nbit0 a).
unfold in_FSet.
unfold in_dom in H0.

*****
a : ad
H0 : forall (a : ad) (_ : eq (in_FSet a (MapDom m1)) true),\nsig (fun y : A => eq (MapGet A m1 a) (Some y))
m1 : Map A
H : forall (a : ad) (_ : eq (in_FSet a (MapDom m0)) true),\nsig (fun y : A => eq (MapGet A m0 a) (Some y))
m,m0 : Map A
A : Type
*****
forall _ : eq match MapGet unit (MapDom m1) (N.div2 a) with | Some _ => true | None => false end true, sig (fun y : A => eq (MapGet A m1 (N.div2 a)) (Some y))
+++++
intro.
-----
Lemma MapDom_semantics_2 : forall (m:Map A) (a:ad), in_FSet a (MapDom m) = true -> {y : A | MapGet A m a = Some y}.
Proof.
simple induction m.
intros m0 H m1 H0 a.
rewrite (MapGet_M2_bit_0_if A m0 m1 a).
simpl in |- *.
unfold in_FSet in |- *.
unfold in_dom in |- *.
rewrite (MapGet_M2_bit_0_if unit (MapDom m0) (MapDom m1) a).
case (Nbit0 a).
unfold in_FSet.
unfold in_dom in H0.
intro.

*****
H1 : eq\n match MapGet unit (MapDom m1) (N.div2 a) with\n | Some _ => true\n | None => false\n end true
a : ad
H0 : forall (a : ad) (_ : eq (in_FSet a (MapDom m1)) true),\nsig (fun y : A => eq (MapGet A m1 a) (Some y))
m1 : Map A
H : forall (a : ad) (_ : eq (in_FSet a (MapDom m0)) true),\nsig (fun y : A => eq (MapGet A m0 a) (Some y))
m,m0 : Map A
A : Type
*****
sig (fun y : A => eq (MapGet A m1 (N.div2 a)) (Some y))
+++++
apply H0.
-----
Lemma MapDom_semantics_2 : forall (m:Map A) (a:ad), in_FSet a (MapDom m) = true -> {y : A | MapGet A m a = Some y}.
Proof.
simple induction m.
intros m0 H m1 H0 a.
rewrite (MapGet_M2_bit_0_if A m0 m1 a).
simpl in |- *.
unfold in_FSet in |- *.
unfold in_dom in |- *.
rewrite (MapGet_M2_bit_0_if unit (MapDom m0) (MapDom m1) a).
case (Nbit0 a).
unfold in_FSet.
unfold in_dom in H0.
intro.
apply H0.

*****
H1 : eq\n match MapGet unit (MapDom m1) (N.div2 a) with\n | Some _ => true\n | None => false\n end true
a : ad
H0 : forall (a : ad) (_ : eq (in_FSet a (MapDom m1)) true),\nsig (fun y : A => eq (MapGet A m1 a) (Some y))
m1 : Map A
H : forall (a : ad) (_ : eq (in_FSet a (MapDom m0)) true),\nsig (fun y : A => eq (MapGet A m0 a) (Some y))
m,m0 : Map A
A : Type
*****
eq (in_FSet (N.div2 a) (MapDom m1)) true
+++++
assumption.
-----
Lemma MapDom_semantics_2 : forall (m:Map A) (a:ad), in_FSet a (MapDom m) = true -> {y : A | MapGet A m a = Some y}.
Proof.
simple induction m.
intros m0 H m1 H0 a.
rewrite (MapGet_M2_bit_0_if A m0 m1 a).
simpl in |- *.
unfold in_FSet in |- *.
unfold in_dom in |- *.
rewrite (MapGet_M2_bit_0_if unit (MapDom m0) (MapDom m1) a).
case (Nbit0 a).

*****
a : ad
H0 : forall (a : ad) (_ : eq (in_FSet a (MapDom m1)) true),\nsig (fun y : A => eq (MapGet A m1 a) (Some y))
m1 : Map A
H : forall (a : ad) (_ : eq (in_FSet a (MapDom m0)) true),\nsig (fun y : A => eq (MapGet A m0 a) (Some y))
m,m0 : Map A
A : Type
*****
forall _ : eq match MapGet unit (MapDom m0) (N.div2 a) with | Some _ => true | None => false end true, sig (fun y : A => eq (MapGet A m0 (N.div2 a)) (Some y))
+++++
unfold in_FSet.
-----
Lemma MapDom_semantics_2 : forall (m:Map A) (a:ad), in_FSet a (MapDom m) = true -> {y : A | MapGet A m a = Some y}.
Proof.
simple induction m.
intros m0 H m1 H0 a.
rewrite (MapGet_M2_bit_0_if A m0 m1 a).
simpl in |- *.
unfold in_FSet in |- *.
unfold in_dom in |- *.
rewrite (MapGet_M2_bit_0_if unit (MapDom m0) (MapDom m1) a).
case (Nbit0 a).
unfold in_FSet.

*****
a : ad
H0 : forall (a : ad) (_ : eq (in_FSet a (MapDom m1)) true),\nsig (fun y : A => eq (MapGet A m1 a) (Some y))
m1 : Map A
H : forall (a : ad) (_ : eq (in_FSet a (MapDom m0)) true),\nsig (fun y : A => eq (MapGet A m0 a) (Some y))
m,m0 : Map A
A : Type
*****
forall _ : eq match MapGet unit (MapDom m0) (N.div2 a) with | Some _ => true | None => false end true, sig (fun y : A => eq (MapGet A m0 (N.div2 a)) (Some y))
+++++
unfold in_dom in H.
-----
Lemma MapDom_semantics_2 : forall (m:Map A) (a:ad), in_FSet a (MapDom m) = true -> {y : A | MapGet A m a = Some y}.
Proof.
simple induction m.
intros m0 H m1 H0 a.
rewrite (MapGet_M2_bit_0_if A m0 m1 a).
simpl in |- *.
unfold in_FSet in |- *.
unfold in_dom in |- *.
rewrite (MapGet_M2_bit_0_if unit (MapDom m0) (MapDom m1) a).
case (Nbit0 a).
unfold in_FSet.
unfold in_dom in H.

*****
a : ad
H0 : forall (a : ad) (_ : eq (in_FSet a (MapDom m1)) true),\nsig (fun y : A => eq (MapGet A m1 a) (Some y))
m1 : Map A
H : forall (a : ad) (_ : eq (in_FSet a (MapDom m0)) true),\nsig (fun y : A => eq (MapGet A m0 a) (Some y))
m,m0 : Map A
A : Type
*****
forall _ : eq match MapGet unit (MapDom m0) (N.div2 a) with | Some _ => true | None => false end true, sig (fun y : A => eq (MapGet A m0 (N.div2 a)) (Some y))
+++++
intro.
-----
Lemma MapDom_semantics_2 : forall (m:Map A) (a:ad), in_FSet a (MapDom m) = true -> {y : A | MapGet A m a = Some y}.
Proof.
simple induction m.
intros m0 H m1 H0 a.
rewrite (MapGet_M2_bit_0_if A m0 m1 a).
simpl in |- *.
unfold in_FSet in |- *.
unfold in_dom in |- *.
rewrite (MapGet_M2_bit_0_if unit (MapDom m0) (MapDom m1) a).
case (Nbit0 a).
unfold in_FSet.
unfold in_dom in H.
intro.

*****
H1 : eq\n match MapGet unit (MapDom m0) (N.div2 a) with\n | Some _ => true\n | None => false\n end true
a : ad
H0 : forall (a : ad) (_ : eq (in_FSet a (MapDom m1)) true),\nsig (fun y : A => eq (MapGet A m1 a) (Some y))
m1 : Map A
H : forall (a : ad) (_ : eq (in_FSet a (MapDom m0)) true),\nsig (fun y : A => eq (MapGet A m0 a) (Some y))
m,m0 : Map A
A : Type
*****
sig (fun y : A => eq (MapGet A m0 (N.div2 a)) (Some y))
+++++
apply H.
-----
Lemma MapDom_semantics_2 : forall (m:Map A) (a:ad), in_FSet a (MapDom m) = true -> {y : A | MapGet A m a = Some y}.
Proof.
simple induction m.
intros m0 H m1 H0 a.
rewrite (MapGet_M2_bit_0_if A m0 m1 a).
simpl in |- *.
unfold in_FSet in |- *.
unfold in_dom in |- *.
rewrite (MapGet_M2_bit_0_if unit (MapDom m0) (MapDom m1) a).
case (Nbit0 a).
unfold in_FSet.
unfold in_dom in H.
intro.
apply H.

*****
H1 : eq\n match MapGet unit (MapDom m0) (N.div2 a) with\n | Some _ => true\n | None => false\n end true
a : ad
H0 : forall (a : ad) (_ : eq (in_FSet a (MapDom m1)) true),\nsig (fun y : A => eq (MapGet A m1 a) (Some y))
m1 : Map A
H : forall (a : ad) (_ : eq (in_FSet a (MapDom m0)) true),\nsig (fun y : A => eq (MapGet A m0 a) (Some y))
m,m0 : Map A
A : Type
*****
eq (in_FSet (N.div2 a) (MapDom m0)) true
+++++
assumption.
-----
Lemma MapDom_semantics_2 : forall (m:Map A) (a:ad), in_FSet a (MapDom m) = true -> {y : A | MapGet A m a = Some y}.
Proof.
simple induction m.

*****

*****

+++++
Qed.
-----
Lemma MapDom_semantics_3 :\n   forall (m:Map A) (a:ad),\n     MapGet A m a = None -> in_FSet a (MapDom m) = false.
-----
Lemma MapDom_semantics_3 : forall (m:Map A) (a:ad), MapGet A m a = None -> in_FSet a (MapDom m) = false.

*****
A : Type
*****
forall (m : Map A) (a : ad) (_ : eq (MapGet A m a) None), eq (in_FSet a (MapDom m)) false
+++++
Proof.
-----
Lemma MapDom_semantics_3 : forall (m:Map A) (a:ad), MapGet A m a = None -> in_FSet a (MapDom m) = false.
Proof.

*****
A : Type
*****
forall (m : Map A) (a : ad) (_ : eq (MapGet A m a) None), eq (in_FSet a (MapDom m)) false
+++++
intros.
-----
Lemma MapDom_semantics_3 : forall (m:Map A) (a:ad), MapGet A m a = None -> in_FSet a (MapDom m) = false.
Proof.
intros.

*****
H : eq (MapGet A m a) None
a : ad
m : Map A
A : Type
*****
eq (in_FSet a (MapDom m)) false
+++++
elim (sumbool_of_bool (in_FSet a (MapDom m))).
-----
Lemma MapDom_semantics_3 : forall (m:Map A) (a:ad), MapGet A m a = None -> in_FSet a (MapDom m) = false.
Proof.
intros.
elim (sumbool_of_bool (in_FSet a (MapDom m))).

*****
H : eq (MapGet A m a) None
a : ad
m : Map A
A : Type
*****
forall _ : eq (in_FSet a (MapDom m)) true, eq (in_FSet a (MapDom m)) false
+++++
intro H0.
-----
Lemma MapDom_semantics_3 : forall (m:Map A) (a:ad), MapGet A m a = None -> in_FSet a (MapDom m) = false.
Proof.
intros.
elim (sumbool_of_bool (in_FSet a (MapDom m))).
intro H0.

*****
H0 : eq (in_FSet a (MapDom m)) true
H : eq (MapGet A m a) None
a : ad
m : Map A
A : Type
*****
eq (in_FSet a (MapDom m)) false
+++++
elim (MapDom_semantics_2 m a H0).
-----
Lemma MapDom_semantics_3 : forall (m:Map A) (a:ad), MapGet A m a = None -> in_FSet a (MapDom m) = false.
Proof.
intros.
elim (sumbool_of_bool (in_FSet a (MapDom m))).
intro H0.
elim (MapDom_semantics_2 m a H0).

*****
H0 : eq (in_FSet a (MapDom m)) true
H : eq (MapGet A m a) None
a : ad
m : Map A
A : Type
*****
forall (x : A) (_ : eq (MapGet A m a) (Some x)), eq (in_FSet a (MapDom m)) false
+++++
intros y H1.
-----
Lemma MapDom_semantics_3 : forall (m:Map A) (a:ad), MapGet A m a = None -> in_FSet a (MapDom m) = false.
Proof.
intros.
elim (sumbool_of_bool (in_FSet a (MapDom m))).
intro H0.
elim (MapDom_semantics_2 m a H0).
intros y H1.

*****
H1 : eq (MapGet A m a) (Some y)
y : A
H0 : eq (in_FSet a (MapDom m)) true
H : eq (MapGet A m a) None
a : ad
m : Map A
A : Type
*****
eq (in_FSet a (MapDom m)) false
+++++
rewrite H in H1.
-----
Lemma MapDom_semantics_3 : forall (m:Map A) (a:ad), MapGet A m a = None -> in_FSet a (MapDom m) = false.
Proof.
intros.
elim (sumbool_of_bool (in_FSet a (MapDom m))).
intro H0.
elim (MapDom_semantics_2 m a H0).
intros y H1.
rewrite H in H1.

*****
H1 : eq None (Some y)
y : A
H0 : eq (in_FSet a (MapDom m)) true
H : eq (MapGet A m a) None
a : ad
m : Map A
A : Type
*****
eq (in_FSet a (MapDom m)) false
+++++
discriminate H1.
-----
Lemma MapDom_semantics_3 : forall (m:Map A) (a:ad), MapGet A m a = None -> in_FSet a (MapDom m) = false.
Proof.
intros.
elim (sumbool_of_bool (in_FSet a (MapDom m))).

*****
H : eq (MapGet A m a) None
a : ad
m : Map A
A : Type
*****
forall _ : eq (in_FSet a (MapDom m)) false, eq (in_FSet a (MapDom m)) false
+++++
trivial.
-----
Lemma MapDom_semantics_3 : forall (m:Map A) (a:ad), MapGet A m a = None -> in_FSet a (MapDom m) = false.
Proof.
intros.
elim (sumbool_of_bool (in_FSet a (MapDom m))).

*****

*****

+++++
Qed.
-----
Lemma MapDom_semantics_4 :\n   forall (m:Map A) (a:ad),\n     in_FSet a (MapDom m) = false -> MapGet A m a = None.
-----
Lemma MapDom_semantics_4 : forall (m:Map A) (a:ad), in_FSet a (MapDom m) = false -> MapGet A m a = None.

*****
A : Type
*****
forall (m : Map A) (a : ad) (_ : eq (in_FSet a (MapDom m)) false), eq (MapGet A m a) None
+++++
Proof.
-----
Lemma MapDom_semantics_4 : forall (m:Map A) (a:ad), in_FSet a (MapDom m) = false -> MapGet A m a = None.
Proof.

*****
A : Type
*****
forall (m : Map A) (a : ad) (_ : eq (in_FSet a (MapDom m)) false), eq (MapGet A m a) None
+++++
intros.
-----
Lemma MapDom_semantics_4 : forall (m:Map A) (a:ad), in_FSet a (MapDom m) = false -> MapGet A m a = None.
Proof.
intros.

*****
H : eq (in_FSet a (MapDom m)) false
a : ad
m : Map A
A : Type
*****
eq (MapGet A m a) None
+++++
elim (option_sum A (MapGet A m a)).
-----
Lemma MapDom_semantics_4 : forall (m:Map A) (a:ad), in_FSet a (MapDom m) = false -> MapGet A m a = None.
Proof.
intros.
elim (option_sum A (MapGet A m a)).

*****
H : eq (in_FSet a (MapDom m)) false
a : ad
m : Map A
A : Type
*****
forall _ : sig (fun y : A => eq (MapGet A m a) (Some y)), eq (MapGet A m a) None
+++++
intro H0.
-----
Lemma MapDom_semantics_4 : forall (m:Map A) (a:ad), in_FSet a (MapDom m) = false -> MapGet A m a = None.
Proof.
intros.
elim (option_sum A (MapGet A m a)).
intro H0.

*****
H0 : sig (fun y : A => eq (MapGet A m a) (Some y))
H : eq (in_FSet a (MapDom m)) false
a : ad
m : Map A
A : Type
*****
eq (MapGet A m a) None
+++++
elim H0.
-----
Lemma MapDom_semantics_4 : forall (m:Map A) (a:ad), in_FSet a (MapDom m) = false -> MapGet A m a = None.
Proof.
intros.
elim (option_sum A (MapGet A m a)).
intro H0.
elim H0.

*****
H0 : sig (fun y : A => eq (MapGet A m a) (Some y))
H : eq (in_FSet a (MapDom m)) false
a : ad
m : Map A
A : Type
*****
forall (x : A) (_ : eq (MapGet A m a) (Some x)), eq (MapGet A m a) None
+++++
intros y H1.
-----
Lemma MapDom_semantics_4 : forall (m:Map A) (a:ad), in_FSet a (MapDom m) = false -> MapGet A m a = None.
Proof.
intros.
elim (option_sum A (MapGet A m a)).
intro H0.
elim H0.
intros y H1.

*****
H1 : eq (MapGet A m a) (Some y)
y : A
H0 : sig (fun y : A => eq (MapGet A m a) (Some y))
H : eq (in_FSet a (MapDom m)) false
a : ad
m : Map A
A : Type
*****
eq (MapGet A m a) None
+++++
rewrite (MapDom_semantics_1 m a y H1) in H.
-----
Lemma MapDom_semantics_4 : forall (m:Map A) (a:ad), in_FSet a (MapDom m) = false -> MapGet A m a = None.
Proof.
intros.
elim (option_sum A (MapGet A m a)).
intro H0.
elim H0.
intros y H1.
rewrite (MapDom_semantics_1 m a y H1) in H.

*****
H1 : eq (MapGet A m a) (Some y)
y : A
H0 : sig (fun y : A => eq (MapGet A m a) (Some y))
H : eq true false
a : ad
m : Map A
A : Type
*****
eq (MapGet A m a) None
+++++
discriminate H.
-----
Lemma MapDom_semantics_4 : forall (m:Map A) (a:ad), in_FSet a (MapDom m) = false -> MapGet A m a = None.
Proof.
intros.
elim (option_sum A (MapGet A m a)).

*****
H : eq (in_FSet a (MapDom m)) false
a : ad
m : Map A
A : Type
*****
forall _ : eq (MapGet A m a) None, eq (MapGet A m a) None
+++++
trivial.
-----
Lemma MapDom_semantics_4 : forall (m:Map A) (a:ad), in_FSet a (MapDom m) = false -> MapGet A m a = None.
Proof.
intros.
elim (option_sum A (MapGet A m a)).

*****

*****

+++++
Qed.
-----
Lemma MapDom_Dom :\n   forall (m:Map A) (a:ad), in_dom A a m = in_FSet a (MapDom m).
-----
Lemma MapDom_Dom : forall (m:Map A) (a:ad), in_dom A a m = in_FSet a (MapDom m).

*****
A : Type
*****
forall (m : Map A) (a : ad), eq (in_dom A a m) (in_FSet a (MapDom m))
+++++
Proof.
-----
Lemma MapDom_Dom : forall (m:Map A) (a:ad), in_dom A a m = in_FSet a (MapDom m).
Proof.

*****
A : Type
*****
forall (m : Map A) (a : ad), eq (in_dom A a m) (in_FSet a (MapDom m))
+++++
intros.
-----
Lemma MapDom_Dom : forall (m:Map A) (a:ad), in_dom A a m = in_FSet a (MapDom m).
Proof.
intros.

*****
a : ad
m : Map A
A : Type
*****
eq (in_dom A a m) (in_FSet a (MapDom m))
+++++
elim (sumbool_of_bool (in_FSet a (MapDom m))).
-----
Lemma MapDom_Dom : forall (m:Map A) (a:ad), in_dom A a m = in_FSet a (MapDom m).
Proof.
intros.
elim (sumbool_of_bool (in_FSet a (MapDom m))).

*****
a : ad
m : Map A
A : Type
*****
forall _ : eq (in_FSet a (MapDom m)) true, eq (in_dom A a m) (in_FSet a (MapDom m))
+++++
intro H.
-----
Lemma MapDom_Dom : forall (m:Map A) (a:ad), in_dom A a m = in_FSet a (MapDom m).
Proof.
intros.
elim (sumbool_of_bool (in_FSet a (MapDom m))).
intro H.

*****
H : eq (in_FSet a (MapDom m)) true
a : ad
m : Map A
A : Type
*****
eq (in_dom A a m) (in_FSet a (MapDom m))
+++++
elim (MapDom_semantics_2 m a H).
-----
Lemma MapDom_Dom : forall (m:Map A) (a:ad), in_dom A a m = in_FSet a (MapDom m).
Proof.
intros.
elim (sumbool_of_bool (in_FSet a (MapDom m))).
intro H.
elim (MapDom_semantics_2 m a H).

*****
H : eq (in_FSet a (MapDom m)) true
a : ad
m : Map A
A : Type
*****
forall (x : A) (_ : eq (MapGet A m a) (Some x)), eq (in_dom A a m) (in_FSet a (MapDom m))
+++++
intros y H0.
-----
Lemma MapDom_Dom : forall (m:Map A) (a:ad), in_dom A a m = in_FSet a (MapDom m).
Proof.
intros.
elim (sumbool_of_bool (in_FSet a (MapDom m))).
intro H.
elim (MapDom_semantics_2 m a H).
intros y H0.

*****
H0 : eq (MapGet A m a) (Some y)
y : A
H : eq (in_FSet a (MapDom m)) true
a : ad
m : Map A
A : Type
*****
eq (in_dom A a m) (in_FSet a (MapDom m))
+++++
rewrite H.
-----
Lemma MapDom_Dom : forall (m:Map A) (a:ad), in_dom A a m = in_FSet a (MapDom m).
Proof.
intros.
elim (sumbool_of_bool (in_FSet a (MapDom m))).
intro H.
elim (MapDom_semantics_2 m a H).
intros y H0.
rewrite H.

*****
H0 : eq (MapGet A m a) (Some y)
y : A
H : eq (in_FSet a (MapDom m)) true
a : ad
m : Map A
A : Type
*****
eq (in_dom A a m) true
+++++
unfold in_dom in |- *.
-----
Lemma MapDom_Dom : forall (m:Map A) (a:ad), in_dom A a m = in_FSet a (MapDom m).
Proof.
intros.
elim (sumbool_of_bool (in_FSet a (MapDom m))).
intro H.
elim (MapDom_semantics_2 m a H).
intros y H0.
rewrite H.
unfold in_dom in |- *.

*****
H0 : eq (MapGet A m a) (Some y)
y : A
H : eq (in_FSet a (MapDom m)) true
a : ad
m : Map A
A : Type
*****
eq match MapGet A m a with | Some _ => true | None => false end true
+++++
rewrite H0.
-----
Lemma MapDom_Dom : forall (m:Map A) (a:ad), in_dom A a m = in_FSet a (MapDom m).
Proof.
intros.
elim (sumbool_of_bool (in_FSet a (MapDom m))).
intro H.
elim (MapDom_semantics_2 m a H).
intros y H0.
rewrite H.
unfold in_dom in |- *.
rewrite H0.

*****
H0 : eq (MapGet A m a) (Some y)
y : A
H : eq (in_FSet a (MapDom m)) true
a : ad
m : Map A
A : Type
*****
eq true true
+++++
reflexivity.
-----
Lemma MapDom_Dom : forall (m:Map A) (a:ad), in_dom A a m = in_FSet a (MapDom m).
Proof.
intros.
elim (sumbool_of_bool (in_FSet a (MapDom m))).

*****
a : ad
m : Map A
A : Type
*****
forall _ : eq (in_FSet a (MapDom m)) false, eq (in_dom A a m) (in_FSet a (MapDom m))
+++++
intro H.
-----
Lemma MapDom_Dom : forall (m:Map A) (a:ad), in_dom A a m = in_FSet a (MapDom m).
Proof.
intros.
elim (sumbool_of_bool (in_FSet a (MapDom m))).
intro H.

*****
H : eq (in_FSet a (MapDom m)) false
a : ad
m : Map A
A : Type
*****
eq (in_dom A a m) (in_FSet a (MapDom m))
+++++
rewrite H.
-----
Lemma MapDom_Dom : forall (m:Map A) (a:ad), in_dom A a m = in_FSet a (MapDom m).
Proof.
intros.
elim (sumbool_of_bool (in_FSet a (MapDom m))).
intro H.
rewrite H.

*****
H : eq (in_FSet a (MapDom m)) false
a : ad
m : Map A
A : Type
*****
eq (in_dom A a m) false
+++++
unfold in_dom in |- *.
-----
Lemma MapDom_Dom : forall (m:Map A) (a:ad), in_dom A a m = in_FSet a (MapDom m).
Proof.
intros.
elim (sumbool_of_bool (in_FSet a (MapDom m))).
intro H.
rewrite H.
unfold in_dom in |- *.

*****
H : eq (in_FSet a (MapDom m)) false
a : ad
m : Map A
A : Type
*****
eq match MapGet A m a with | Some _ => true | None => false end false
+++++
rewrite (MapDom_semantics_4 m a H).
-----
Lemma MapDom_Dom : forall (m:Map A) (a:ad), in_dom A a m = in_FSet a (MapDom m).
Proof.
intros.
elim (sumbool_of_bool (in_FSet a (MapDom m))).
intro H.
rewrite H.
unfold in_dom in |- *.
rewrite (MapDom_semantics_4 m a H).

*****
H : eq (in_FSet a (MapDom m)) false
a : ad
m : Map A
A : Type
*****
eq false false
+++++
reflexivity.
-----
Lemma MapDom_Dom : forall (m:Map A) (a:ad), in_dom A a m = in_FSet a (MapDom m).
Proof.
intros.
elim (sumbool_of_bool (in_FSet a (MapDom m))).

*****

*****

+++++
Qed.
-----
Definition FSetUnion (s s':FSet) : FSet := MapMerge unit s s'.
-----
Lemma in_FSet_union :\n   forall (s s':FSet) (a:ad),\n     in_FSet a (FSetUnion s s') = orb (in_FSet a s) (in_FSet a s').
-----
Lemma in_FSet_union : forall (s s':FSet) (a:ad), in_FSet a (FSetUnion s s') = orb (in_FSet a s) (in_FSet a s').

*****
A : Type
*****
forall (s s' : FSet) (a : ad), eq (in_FSet a (FSetUnion s s')) (orb (in_FSet a s) (in_FSet a s'))
+++++
Proof.
-----
Lemma in_FSet_union : forall (s s':FSet) (a:ad), in_FSet a (FSetUnion s s') = orb (in_FSet a s) (in_FSet a s').
Proof.

*****
A : Type
*****
forall (s s' : FSet) (a : ad), eq (in_FSet a (FSetUnion s s')) (orb (in_FSet a s) (in_FSet a s'))
+++++
exact (in_dom_merge unit).
-----
Lemma in_FSet_union : forall (s s':FSet) (a:ad), in_FSet a (FSetUnion s s') = orb (in_FSet a s) (in_FSet a s').
Proof.
exact (in_dom_merge unit).

*****

*****

+++++
Qed.
-----
Definition FSetInter (s s':FSet) : FSet := MapDomRestrTo unit unit s s'.
-----
Lemma in_FSet_inter :\n   forall (s s':FSet) (a:ad),\n     in_FSet a (FSetInter s s') = andb (in_FSet a s) (in_FSet a s').
-----
Lemma in_FSet_inter : forall (s s':FSet) (a:ad), in_FSet a (FSetInter s s') = andb (in_FSet a s) (in_FSet a s').

*****
A : Type
*****
forall (s s' : FSet) (a : ad), eq (in_FSet a (FSetInter s s')) (andb (in_FSet a s) (in_FSet a s'))
+++++
Proof.
-----
Lemma in_FSet_inter : forall (s s':FSet) (a:ad), in_FSet a (FSetInter s s') = andb (in_FSet a s) (in_FSet a s').
Proof.

*****
A : Type
*****
forall (s s' : FSet) (a : ad), eq (in_FSet a (FSetInter s s')) (andb (in_FSet a s) (in_FSet a s'))
+++++
exact (in_dom_restrto unit unit).
-----
Lemma in_FSet_inter : forall (s s':FSet) (a:ad), in_FSet a (FSetInter s s') = andb (in_FSet a s) (in_FSet a s').
Proof.
exact (in_dom_restrto unit unit).

*****

*****

+++++
Qed.
-----
Definition FSetDiff (s s':FSet) : FSet := MapDomRestrBy unit unit s s'.
-----
Lemma in_FSet_diff :\n   forall (s s':FSet) (a:ad),\n     in_FSet a (FSetDiff s s') = andb (in_FSet a s) (negb (in_FSet a s')).
-----
Lemma in_FSet_diff : forall (s s':FSet) (a:ad), in_FSet a (FSetDiff s s') = andb (in_FSet a s) (negb (in_FSet a s')).

*****
A : Type
*****
forall (s s' : FSet) (a : ad), eq (in_FSet a (FSetDiff s s')) (andb (in_FSet a s) (negb (in_FSet a s')))
+++++
Proof.
-----
Lemma in_FSet_diff : forall (s s':FSet) (a:ad), in_FSet a (FSetDiff s s') = andb (in_FSet a s) (negb (in_FSet a s')).
Proof.

*****
A : Type
*****
forall (s s' : FSet) (a : ad), eq (in_FSet a (FSetDiff s s')) (andb (in_FSet a s) (negb (in_FSet a s')))
+++++
exact (in_dom_restrby unit unit).
-----
Lemma in_FSet_diff : forall (s s':FSet) (a:ad), in_FSet a (FSetDiff s s') = andb (in_FSet a s) (negb (in_FSet a s')).
Proof.
exact (in_dom_restrby unit unit).

*****

*****

+++++
Qed.
-----
Definition FSetDelta (s s':FSet) : FSet := MapDelta unit s s'.
-----
Lemma in_FSet_delta :\n   forall (s s':FSet) (a:ad),\n     in_FSet a (FSetDelta s s') = xorb (in_FSet a s) (in_FSet a s').
-----
Lemma in_FSet_delta : forall (s s':FSet) (a:ad), in_FSet a (FSetDelta s s') = xorb (in_FSet a s) (in_FSet a s').

*****
A : Type
*****
forall (s s' : FSet) (a : ad), eq (in_FSet a (FSetDelta s s')) (xorb (in_FSet a s) (in_FSet a s'))
+++++
Proof.
-----
Lemma in_FSet_delta : forall (s s':FSet) (a:ad), in_FSet a (FSetDelta s s') = xorb (in_FSet a s) (in_FSet a s').
Proof.

*****
A : Type
*****
forall (s s' : FSet) (a : ad), eq (in_FSet a (FSetDelta s s')) (xorb (in_FSet a s) (in_FSet a s'))
+++++
exact (in_dom_delta unit).
-----
Lemma in_FSet_delta : forall (s s':FSet) (a:ad), in_FSet a (FSetDelta s s') = xorb (in_FSet a s) (in_FSet a s').
Proof.
exact (in_dom_delta unit).

*****

*****

+++++
Qed.
-----
End FSetDefs.
-----
Lemma FSet_Dom : forall s:FSet, MapDom unit s = s.
-----
Lemma FSet_Dom : forall s:FSet, MapDom unit s = s.

*****

*****
forall s : FSet, eq (MapDom unit s) s
+++++
Proof.
-----
Lemma FSet_Dom : forall s:FSet, MapDom unit s = s.
Proof.

*****

*****
forall s : FSet, eq (MapDom unit s) s
+++++
simple induction s.
-----
Lemma FSet_Dom : forall s:FSet, MapDom unit s = s.
Proof.
simple induction s.

*****
s : FSet
*****
eq (MapDom unit (M0 unit)) (M0 unit)
+++++
trivial.
-----
Lemma FSet_Dom : forall s:FSet, MapDom unit s = s.
Proof.
simple induction s.

*****
s : FSet
*****
forall (a : ad) (a0 : unit), eq (MapDom unit (M1 unit a a0)) (M1 unit a a0)
+++++
simpl in |- *.
-----
Lemma FSet_Dom : forall s:FSet, MapDom unit s = s.
Proof.
simple induction s.
simpl in |- *.

*****
s : FSet
*****
forall (a : ad) (a0 : unit), eq (M1 unit a tt) (M1 unit a a0)
+++++
intros a t.
-----
Lemma FSet_Dom : forall s:FSet, MapDom unit s = s.
Proof.
simple induction s.
simpl in |- *.
intros a t.

*****
t : unit
a : ad
s : FSet
*****
eq (M1 unit a tt) (M1 unit a t)
+++++
elim t.
-----
Lemma FSet_Dom : forall s:FSet, MapDom unit s = s.
Proof.
simple induction s.
simpl in |- *.
intros a t.
elim t.

*****
t : unit
a : ad
s : FSet
*****
eq (M1 unit a tt) (M1 unit a tt)
+++++
reflexivity.
-----
Lemma FSet_Dom : forall s:FSet, MapDom unit s = s.
Proof.
simple induction s.

*****
s : FSet
*****
forall (m : Map unit) (_ : eq (MapDom unit m) m) (m0 : Map unit) (_ : eq (MapDom unit m0) m0), eq (MapDom unit (M2 unit m m0)) (M2 unit m m0)
+++++
intros.
-----
Lemma FSet_Dom : forall s:FSet, MapDom unit s = s.
Proof.
simple induction s.
intros.

*****
H0 : eq (MapDom unit m0) m0
m0 : Map unit
H : eq (MapDom unit m) m
m : Map unit
s : FSet
*****
eq (MapDom unit (M2 unit m m0)) (M2 unit m m0)
+++++
simpl in |- *.
-----
Lemma FSet_Dom : forall s:FSet, MapDom unit s = s.
Proof.
simple induction s.
intros.
simpl in |- *.

*****
H0 : eq (MapDom unit m0) m0
m0 : Map unit
H : eq (MapDom unit m) m
m : Map unit
s : FSet
*****
eq (M2 unit (MapDom unit m) (MapDom unit m0)) (M2 unit m m0)
+++++
rewrite H.
-----
Lemma FSet_Dom : forall s:FSet, MapDom unit s = s.
Proof.
simple induction s.
intros.
simpl in |- *.
rewrite H.

*****
H0 : eq (MapDom unit m0) m0
m0 : Map unit
H : eq (MapDom unit m) m
m : Map unit
s : FSet
*****
eq (M2 unit m (MapDom unit m0)) (M2 unit m m0)
+++++
rewrite H0.
-----
Lemma FSet_Dom : forall s:FSet, MapDom unit s = s.
Proof.
simple induction s.
intros.
simpl in |- *.
rewrite H.
rewrite H0.

*****
H0 : eq (MapDom unit m0) m0
m0 : Map unit
H : eq (MapDom unit m) m
m : Map unit
s : FSet
*****
eq (M2 unit m m0) (M2 unit m m0)
+++++
reflexivity.
-----
Lemma FSet_Dom : forall s:FSet, MapDom unit s = s.
Proof.
simple induction s.

*****

*****

+++++
Qed.
-----
