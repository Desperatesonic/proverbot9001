Require Import GeoCoq.Axioms.parallel_postulates.
-----
Require Import GeoCoq.Tarski_dev.Annexes.suma.
-----
Require Import GeoCoq.Tarski_dev.Annexes.perp_bisect.
-----
Require Import GeoCoq.Tarski_dev.Ch13_1.
-----
Section bachmann_s_lotschnittaxiom_legendre_s_parallel_postulate.
-----
Context `{TnEQD:Tarski_neutral_dimensionless_with_decidable_point_equality}.
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate :\n  bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : bachmann_s_lotschnittaxiom, legendre_s_parallel_postulate
+++++
Proof.
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : bachmann_s_lotschnittaxiom, legendre_s_parallel_postulate
+++++
intro bla.
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.

*****
bla : bachmann_s_lotschnittaxiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
legendre_s_parallel_postulate
+++++
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\ Col D1 D2 I).
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).

*****
bla : bachmann_s_lotschnittaxiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint) (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2) (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC) (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD) (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2) (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2) (_ : not (Col IAB IAC IBD)), ex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I)), legendre_s_parallel_postulate
+++++
clear bla; intro bla.
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro bla.

*****
bla : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
legendre_s_parallel_postulate
+++++
cut (exists A B C, ~ Col A B C /\ Acute A B C /\ forall P Q, Out B A P -> P <> Q -> Per B P Q -> Coplanar A B C Q -> exists Y, Out B C Y /\ Col P Q Y).
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro bla.
cut (exists A B C, ~ Col A B C /\\ Acute A B C /\\ forall P Q, Out B A P -> P <> Q -> Per B P Q -> Coplanar A B C Q -> exists Y, Out B C Y /\\ Col P Q Y).

*****
bla : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : ex (fun A : Tpoint => ex (fun B : Tpoint => ex (fun C : Tpoint => and (not (Col A B C)) (and (Acute A B C) (forall (P Q : Tpoint) (_ : Out B A P) (_ : not (eq P Q)) (_ : Per B P Q) (_ : Coplanar A B C Q), ex (fun Y : Tpoint => and (Out B C Y) (Col P Q Y))))))), legendre_s_parallel_postulate
+++++
intros [A [B [C [HNC [HAcute HP]]]]]; exists A, B, C; split; try split; Col.
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro bla.
cut (exists A B C, ~ Col A B C /\\ Acute A B C /\\ forall P Q, Out B A P -> P <> Q -> Per B P Q -> Coplanar A B C Q -> exists Y, Out B C Y /\\ Col P Q Y).
intros [A [B [C [HNC [HAcute HP]]]]]; exists A, B, C; split; try split; Col.

*****
HP : forall (P Q : Tpoint) (_ : Out B A P) (_ : not (eq P Q))\n (_ : Per B P Q) (_ : Coplanar A B C Q),\nex (fun Y : Tpoint => and (Out B C Y) (Col P Q Y))
HAcute : Acute A B C
HNC : not (Col A B C)
A,B,C : Tpoint
bla : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (T : Tpoint) (_ : InAngle T A B C), ex (fun X : Tpoint => ex (fun Y : Tpoint => and (Out B A X) (and (Out B C Y) (Bet X T Y))))
+++++
intros T HInAngle; elim (col_dec A B T); intro HABT.
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro bla.
cut (exists A B C, ~ Col A B C /\\ Acute A B C /\\ forall P Q, Out B A P -> P <> Q -> Per B P Q -> Coplanar A B C Q -> exists Y, Out B C Y /\\ Col P Q Y).
intros [A [B [C [HNC [HAcute HP]]]]]; exists A, B, C; split; try split; Col.
intros T HInAngle; elim (col_dec A B T); intro HABT.

*****
HABT : Col A B T
HInAngle : InAngle T A B C
T : Tpoint
HP : forall (P Q : Tpoint) (_ : Out B A P) (_ : not (eq P Q))\n (_ : Per B P Q) (_ : Coplanar A B C Q),\nex (fun Y : Tpoint => and (Out B C Y) (Col P Q Y))
HAcute : Acute A B C
HNC : not (Col A B C)
A,B,C : Tpoint
bla : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => ex (fun Y : Tpoint => and (Out B A X) (and (Out B C Y) (Bet X T Y))))
+++++
assert (HNC' : ~ Col B C T) by (intro; apply HNC; unfold InAngle in *; spliter; ColR).
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro bla.
cut (exists A B C, ~ Col A B C /\\ Acute A B C /\\ forall P Q, Out B A P -> P <> Q -> Per B P Q -> Coplanar A B C Q -> exists Y, Out B C Y /\\ Col P Q Y).
intros [A [B [C [HNC [HAcute HP]]]]]; exists A, B, C; split; try split; Col.
intros T HInAngle; elim (col_dec A B T); intro HABT.
assert (HNC' : ~ Col B C T) by (intro; apply HNC; unfold InAngle in *; spliter; ColR).

*****
HNC' : not (Col B C T)
HABT : Col A B T
HInAngle : InAngle T A B C
T : Tpoint
HP : forall (P Q : Tpoint) (_ : Out B A P) (_ : not (eq P Q))\n (_ : Per B P Q) (_ : Coplanar A B C Q),\nex (fun Y : Tpoint => and (Out B C Y) (Col P Q Y))
HAcute : Acute A B C
HNC : not (Col A B C)
A,B,C : Tpoint
bla : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => ex (fun Y : Tpoint => and (Out B A X) (and (Out B C Y) (Bet X T Y))))
+++++
destruct (l8_18_existence B C T) as [Y [HC HPerp]]; [auto|exists T, Y].
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro bla.
cut (exists A B C, ~ Col A B C /\\ Acute A B C /\\ forall P Q, Out B A P -> P <> Q -> Per B P Q -> Coplanar A B C Q -> exists Y, Out B C Y /\\ Col P Q Y).
intros [A [B [C [HNC [HAcute HP]]]]]; exists A, B, C; split; try split; Col.
intros T HInAngle; elim (col_dec A B T); intro HABT.
assert (HNC' : ~ Col B C T) by (intro; apply HNC; unfold InAngle in *; spliter; ColR).
destruct (l8_18_existence B C T) as [Y [HC HPerp]]; [auto|exists T, Y].

*****
HPerp : Perp B C T Y
HC : Col B C Y
Y : Tpoint
HNC' : not (Col B C T)
HABT : Col A B T
HInAngle : InAngle T A B C
T : Tpoint
HP : forall (P Q : Tpoint) (_ : Out B A P) (_ : not (eq P Q))\n (_ : Per B P Q) (_ : Coplanar A B C Q),\nex (fun Y : Tpoint => and (Out B C Y) (Col P Q Y))
HAcute : Acute A B C
HNC : not (Col A B C)
A,B,C : Tpoint
bla : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Out B A T) (and (Out B C Y) (Bet T T Y))
+++++
assert (HOut : Out B A T).
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro bla.
cut (exists A B C, ~ Col A B C /\\ Acute A B C /\\ forall P Q, Out B A P -> P <> Q -> Per B P Q -> Coplanar A B C Q -> exists Y, Out B C Y /\\ Col P Q Y).
intros [A [B [C [HNC [HAcute HP]]]]]; exists A, B, C; split; try split; Col.
intros T HInAngle; elim (col_dec A B T); intro HABT.
assert (HNC' : ~ Col B C T) by (intro; apply HNC; unfold InAngle in *; spliter; ColR).
destruct (l8_18_existence B C T) as [Y [HC HPerp]]; [auto|exists T, Y].
assert (HOut : Out B A T).

*****
HPerp : Perp B C T Y
HC : Col B C Y
Y : Tpoint
HNC' : not (Col B C T)
HABT : Col A B T
HInAngle : InAngle T A B C
T : Tpoint
HP : forall (P Q : Tpoint) (_ : Out B A P) (_ : not (eq P Q))\n (_ : Per B P Q) (_ : Coplanar A B C Q),\nex (fun Y : Tpoint => and (Out B C Y) (Col P Q Y))
HAcute : Acute A B C
HNC : not (Col A B C)
A,B,C : Tpoint
bla : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out B A T
+++++
apply col_in_angle_out with C; try (intro; apply HNC; assert_cols); Col.
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro bla.
cut (exists A B C, ~ Col A B C /\\ Acute A B C /\\ forall P Q, Out B A P -> P <> Q -> Per B P Q -> Coplanar A B C Q -> exists Y, Out B C Y /\\ Col P Q Y).
intros [A [B [C [HNC [HAcute HP]]]]]; exists A, B, C; split; try split; Col.
intros T HInAngle; elim (col_dec A B T); intro HABT.
assert (HNC' : ~ Col B C T) by (intro; apply HNC; unfold InAngle in *; spliter; ColR).
destruct (l8_18_existence B C T) as [Y [HC HPerp]]; [auto|exists T, Y].
assert (HOut : Out B A T).

*****
HOut : Out B A T
HPerp : Perp B C T Y
HC : Col B C Y
Y : Tpoint
HNC' : not (Col B C T)
HABT : Col A B T
HInAngle : InAngle T A B C
T : Tpoint
HP : forall (P Q : Tpoint) (_ : Out B A P) (_ : not (eq P Q))\n (_ : Per B P Q) (_ : Coplanar A B C Q),\nex (fun Y : Tpoint => and (Out B C Y) (Col P Q Y))
HAcute : Acute A B C
HNC : not (Col A B C)
A,B,C : Tpoint
bla : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Out B A T) (and (Out B C Y) (Bet T T Y))
+++++
split; [|split]; Between.
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro bla.
cut (exists A B C, ~ Col A B C /\\ Acute A B C /\\ forall P Q, Out B A P -> P <> Q -> Per B P Q -> Coplanar A B C Q -> exists Y, Out B C Y /\\ Col P Q Y).
intros [A [B [C [HNC [HAcute HP]]]]]; exists A, B, C; split; try split; Col.
intros T HInAngle; elim (col_dec A B T); intro HABT.
assert (HNC' : ~ Col B C T) by (intro; apply HNC; unfold InAngle in *; spliter; ColR).
destruct (l8_18_existence B C T) as [Y [HC HPerp]]; [auto|exists T, Y].
assert (HOut : Out B A T).
split; [|split]; Between.

*****
HOut : Out B A T
HPerp : Perp B C T Y
HC : Col B C Y
Y : Tpoint
HNC' : not (Col B C T)
HABT : Col A B T
HInAngle : InAngle T A B C
T : Tpoint
HP : forall (P Q : Tpoint) (_ : Out B A P) (_ : not (eq P Q))\n (_ : Per B P Q) (_ : Coplanar A B C Q),\nex (fun Y : Tpoint => and (Out B C Y) (Col P Q Y))
HAcute : Acute A B C
HNC : not (Col A B C)
A,B,C : Tpoint
bla : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out B C Y
+++++
apply l6_6; apply acute_col_perp__out with T; Col.
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro bla.
cut (exists A B C, ~ Col A B C /\\ Acute A B C /\\ forall P Q, Out B A P -> P <> Q -> Per B P Q -> Coplanar A B C Q -> exists Y, Out B C Y /\\ Col P Q Y).
intros [A [B [C [HNC [HAcute HP]]]]]; exists A, B, C; split; try split; Col.
intros T HInAngle; elim (col_dec A B T); intro HABT.
assert (HNC' : ~ Col B C T) by (intro; apply HNC; unfold InAngle in *; spliter; ColR).
destruct (l8_18_existence B C T) as [Y [HC HPerp]]; [auto|exists T, Y].
assert (HOut : Out B A T).
split; [|split]; Between.
apply l6_6; apply acute_col_perp__out with T; Col.

*****
HOut : Out B A T
HPerp : Perp B C T Y
HC : Col B C Y
Y : Tpoint
HNC' : not (Col B C T)
HABT : Col A B T
HInAngle : InAngle T A B C
T : Tpoint
HP : forall (P Q : Tpoint) (_ : Out B A P) (_ : not (eq P Q))\n (_ : Per B P Q) (_ : Coplanar A B C Q),\nex (fun Y : Tpoint => and (Out B C Y) (Col P Q Y))
HAcute : Acute A B C
HNC : not (Col A B C)
A,B,C : Tpoint
bla : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Acute T B C
+++++
apply acute_conga__acute with A B C; auto.
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro bla.
cut (exists A B C, ~ Col A B C /\\ Acute A B C /\\ forall P Q, Out B A P -> P <> Q -> Per B P Q -> Coplanar A B C Q -> exists Y, Out B C Y /\\ Col P Q Y).
intros [A [B [C [HNC [HAcute HP]]]]]; exists A, B, C; split; try split; Col.
intros T HInAngle; elim (col_dec A B T); intro HABT.
assert (HNC' : ~ Col B C T) by (intro; apply HNC; unfold InAngle in *; spliter; ColR).
destruct (l8_18_existence B C T) as [Y [HC HPerp]]; [auto|exists T, Y].
assert (HOut : Out B A T).
split; [|split]; Between.
apply l6_6; apply acute_col_perp__out with T; Col.
apply acute_conga__acute with A B C; auto.

*****
HOut : Out B A T
HPerp : Perp B C T Y
HC : Col B C Y
Y : Tpoint
HNC' : not (Col B C T)
HABT : Col A B T
HInAngle : InAngle T A B C
T : Tpoint
HP : forall (P Q : Tpoint) (_ : Out B A P) (_ : not (eq P Q))\n (_ : Per B P Q) (_ : Coplanar A B C Q),\nex (fun Y : Tpoint => and (Out B C Y) (Col P Q Y))
HAcute : Acute A B C
HNC : not (Col A B C)
A,B,C : Tpoint
bla : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
CongA A B C T B C
+++++
apply out213_suma__conga with T B A; try apply l6_6; auto.
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro bla.
cut (exists A B C, ~ Col A B C /\\ Acute A B C /\\ forall P Q, Out B A P -> P <> Q -> Per B P Q -> Coplanar A B C Q -> exists Y, Out B C Y /\\ Col P Q Y).
intros [A [B [C [HNC [HAcute HP]]]]]; exists A, B, C; split; try split; Col.
intros T HInAngle; elim (col_dec A B T); intro HABT.
assert (HNC' : ~ Col B C T) by (intro; apply HNC; unfold InAngle in *; spliter; ColR).
destruct (l8_18_existence B C T) as [Y [HC HPerp]]; [auto|exists T, Y].
assert (HOut : Out B A T).
split; [|split]; Between.
apply l6_6; apply acute_col_perp__out with T; Col.
apply acute_conga__acute with A B C; auto.
apply out213_suma__conga with T B A; try apply l6_6; auto.

*****
HOut : Out B A T
HPerp : Perp B C T Y
HC : Col B C Y
Y : Tpoint
HNC' : not (Col B C T)
HABT : Col A B T
HInAngle : InAngle T A B C
T : Tpoint
HP : forall (P Q : Tpoint) (_ : Out B A P) (_ : not (eq P Q))\n (_ : Per B P Q) (_ : Coplanar A B C Q),\nex (fun Y : Tpoint => and (Out B C Y) (Col P Q Y))
HAcute : Acute A B C
HNC : not (Col A B C)
A,B,C : Tpoint
bla : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
SumA T B A A B C T B C
+++++
assert_diffs.
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro bla.
cut (exists A B C, ~ Col A B C /\\ Acute A B C /\\ forall P Q, Out B A P -> P <> Q -> Per B P Q -> Coplanar A B C Q -> exists Y, Out B C Y /\\ Col P Q Y).
intros [A [B [C [HNC [HAcute HP]]]]]; exists A, B, C; split; try split; Col.
intros T HInAngle; elim (col_dec A B T); intro HABT.
assert (HNC' : ~ Col B C T) by (intro; apply HNC; unfold InAngle in *; spliter; ColR).
destruct (l8_18_existence B C T) as [Y [HC HPerp]]; [auto|exists T, Y].
assert (HOut : Out B A T).
split; [|split]; Between.
apply l6_6; apply acute_col_perp__out with T; Col.
apply acute_conga__acute with A B C; auto.
apply out213_suma__conga with T B A; try apply l6_6; auto.
assert_diffs.

*****
H3 : not (eq T Y)
H7 : not (eq A C)
H5 : not (eq A B)
H4 : not (eq B T)
H1 : not (eq C T)
H2 : not (eq B C)
HOut : Out B A T
HPerp : Perp B C T Y
HC : Col B C Y
Y : Tpoint
HNC' : not (Col B C T)
HABT : Col A B T
HInAngle : InAngle T A B C
T : Tpoint
HP : forall (P Q : Tpoint) (_ : Out B A P) (_ : not (eq P Q))\n (_ : Per B P Q) (_ : Coplanar A B C Q),\nex (fun Y : Tpoint => and (Out B C Y) (Col P Q Y))
HAcute : Acute A B C
HNC : not (Col A B C)
A,B,C : Tpoint
bla : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
SumA T B A A B C T B C
+++++
exists C; repeat (split; CongA); Cop.
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro bla.
cut (exists A B C, ~ Col A B C /\\ Acute A B C /\\ forall P Q, Out B A P -> P <> Q -> Per B P Q -> Coplanar A B C Q -> exists Y, Out B C Y /\\ Col P Q Y).
intros [A [B [C [HNC [HAcute HP]]]]]; exists A, B, C; split; try split; Col.
intros T HInAngle; elim (col_dec A B T); intro HABT.
assert (HNC' : ~ Col B C T) by (intro; apply HNC; unfold InAngle in *; spliter; ColR).
destruct (l8_18_existence B C T) as [Y [HC HPerp]]; [auto|exists T, Y].
assert (HOut : Out B A T).
split; [|split]; Between.
apply l6_6; apply acute_col_perp__out with T; Col.
apply acute_conga__acute with A B C; auto.
apply out213_suma__conga with T B A; try apply l6_6; auto.
assert_diffs.
exists C; repeat (split; CongA); Cop.

*****
H3 : not (eq T Y)
H7 : not (eq A C)
H5 : not (eq A B)
H4 : not (eq B T)
H1 : not (eq C T)
H2 : not (eq B C)
HOut : Out B A T
HPerp : Perp B C T Y
HC : Col B C Y
Y : Tpoint
HNC' : not (Col B C T)
HABT : Col A B T
HInAngle : InAngle T A B C
T : Tpoint
HP : forall (P Q : Tpoint) (_ : Out B A P) (_ : not (eq P Q))\n (_ : Per B P Q) (_ : Coplanar A B C Q),\nex (fun Y : Tpoint => and (Out B C Y) (Col P Q Y))
HAcute : Acute A B C
HNC : not (Col A B C)
A,B,C : Tpoint
bla : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (OS B A T C)
+++++
apply col123__nos; Col.
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro bla.
cut (exists A B C, ~ Col A B C /\\ Acute A B C /\\ forall P Q, Out B A P -> P <> Q -> Per B P Q -> Coplanar A B C Q -> exists Y, Out B C Y /\\ Col P Q Y).
intros [A [B [C [HNC [HAcute HP]]]]]; exists A, B, C; split; try split; Col.
intros T HInAngle; elim (col_dec A B T); intro HABT.

*****
HABT : not (Col A B T)
HInAngle : InAngle T A B C
T : Tpoint
HP : forall (P Q : Tpoint) (_ : Out B A P) (_ : not (eq P Q))\n (_ : Per B P Q) (_ : Coplanar A B C Q),\nex (fun Y : Tpoint => and (Out B C Y) (Col P Q Y))
HAcute : Acute A B C
HNC : not (Col A B C)
A,B,C : Tpoint
bla : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => ex (fun Y : Tpoint => and (Out B A X) (and (Out B C Y) (Bet X T Y))))
+++++
destruct (l8_18_existence A B T) as [X [HC HPerp]]; Col.
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro bla.
cut (exists A B C, ~ Col A B C /\\ Acute A B C /\\ forall P Q, Out B A P -> P <> Q -> Per B P Q -> Coplanar A B C Q -> exists Y, Out B C Y /\\ Col P Q Y).
intros [A [B [C [HNC [HAcute HP]]]]]; exists A, B, C; split; try split; Col.
intros T HInAngle; elim (col_dec A B T); intro HABT.
destruct (l8_18_existence A B T) as [X [HC HPerp]]; Col.

*****
HPerp : Perp A B T X
HC : Col A B X
X : Tpoint
HABT : not (Col A B T)
HInAngle : InAngle T A B C
T : Tpoint
HP : forall (P Q : Tpoint) (_ : Out B A P) (_ : not (eq P Q))\n (_ : Per B P Q) (_ : Coplanar A B C Q),\nex (fun Y : Tpoint => and (Out B C Y) (Col P Q Y))
HAcute : Acute A B C
HNC : not (Col A B C)
A,B,C : Tpoint
bla : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => ex (fun Y : Tpoint => and (Out B A X) (and (Out B C Y) (Bet X T Y))))
+++++
assert (HOut1 : Out B A X).
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro bla.
cut (exists A B C, ~ Col A B C /\\ Acute A B C /\\ forall P Q, Out B A P -> P <> Q -> Per B P Q -> Coplanar A B C Q -> exists Y, Out B C Y /\\ Col P Q Y).
intros [A [B [C [HNC [HAcute HP]]]]]; exists A, B, C; split; try split; Col.
intros T HInAngle; elim (col_dec A B T); intro HABT.
destruct (l8_18_existence A B T) as [X [HC HPerp]]; Col.
assert (HOut1 : Out B A X).

*****
HPerp : Perp A B T X
HC : Col A B X
X : Tpoint
HABT : not (Col A B T)
HInAngle : InAngle T A B C
T : Tpoint
HP : forall (P Q : Tpoint) (_ : Out B A P) (_ : not (eq P Q))\n (_ : Per B P Q) (_ : Coplanar A B C Q),\nex (fun Y : Tpoint => and (Out B C Y) (Col P Q Y))
HAcute : Acute A B C
HNC : not (Col A B C)
A,B,C : Tpoint
bla : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out B A X
+++++
apply l6_6; apply acute_col_perp__out with T; Col; Perp.
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro bla.
cut (exists A B C, ~ Col A B C /\\ Acute A B C /\\ forall P Q, Out B A P -> P <> Q -> Per B P Q -> Coplanar A B C Q -> exists Y, Out B C Y /\\ Col P Q Y).
intros [A [B [C [HNC [HAcute HP]]]]]; exists A, B, C; split; try split; Col.
intros T HInAngle; elim (col_dec A B T); intro HABT.
destruct (l8_18_existence A B T) as [X [HC HPerp]]; Col.
assert (HOut1 : Out B A X).
apply l6_6; apply acute_col_perp__out with T; Col; Perp.

*****
HPerp : Perp A B T X
HC : Col A B X
X : Tpoint
HABT : not (Col A B T)
HInAngle : InAngle T A B C
T : Tpoint
HP : forall (P Q : Tpoint) (_ : Out B A P) (_ : not (eq P Q))\n (_ : Per B P Q) (_ : Coplanar A B C Q),\nex (fun Y : Tpoint => and (Out B C Y) (Col P Q Y))
HAcute : Acute A B C
HNC : not (Col A B C)
A,B,C : Tpoint
bla : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Acute T B A
+++++
apply acute_lea_acute with A B C; auto.
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro bla.
cut (exists A B C, ~ Col A B C /\\ Acute A B C /\\ forall P Q, Out B A P -> P <> Q -> Per B P Q -> Coplanar A B C Q -> exists Y, Out B C Y /\\ Col P Q Y).
intros [A [B [C [HNC [HAcute HP]]]]]; exists A, B, C; split; try split; Col.
intros T HInAngle; elim (col_dec A B T); intro HABT.
destruct (l8_18_existence A B T) as [X [HC HPerp]]; Col.
assert (HOut1 : Out B A X).
apply l6_6; apply acute_col_perp__out with T; Col; Perp.
apply acute_lea_acute with A B C; auto.

*****
HPerp : Perp A B T X
HC : Col A B X
X : Tpoint
HABT : not (Col A B T)
HInAngle : InAngle T A B C
T : Tpoint
HP : forall (P Q : Tpoint) (_ : Out B A P) (_ : not (eq P Q))\n (_ : Per B P Q) (_ : Coplanar A B C Q),\nex (fun Y : Tpoint => and (Out B C Y) (Col P Q Y))
HAcute : Acute A B C
HNC : not (Col A B C)
A,B,C : Tpoint
bla : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
LeA T B A A B C
+++++
apply lea_left_comm; apply l11_29_b; exists C; split; auto; apply conga_refl; assert_diffs; auto.
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro bla.
cut (exists A B C, ~ Col A B C /\\ Acute A B C /\\ forall P Q, Out B A P -> P <> Q -> Per B P Q -> Coplanar A B C Q -> exists Y, Out B C Y /\\ Col P Q Y).
intros [A [B [C [HNC [HAcute HP]]]]]; exists A, B, C; split; try split; Col.
intros T HInAngle; elim (col_dec A B T); intro HABT.
destruct (l8_18_existence A B T) as [X [HC HPerp]]; Col.
assert (HOut1 : Out B A X).

*****
HOut1 : Out B A X
HPerp : Perp A B T X
HC : Col A B X
X : Tpoint
HABT : not (Col A B T)
HInAngle : InAngle T A B C
T : Tpoint
HP : forall (P Q : Tpoint) (_ : Out B A P) (_ : not (eq P Q))\n (_ : Per B P Q) (_ : Coplanar A B C Q),\nex (fun Y : Tpoint => and (Out B C Y) (Col P Q Y))
HAcute : Acute A B C
HNC : not (Col A B C)
A,B,C : Tpoint
bla : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => ex (fun Y : Tpoint => and (Out B A X) (and (Out B C Y) (Bet X T Y))))
+++++
destruct (HP X T) as [Y [HOut2 H]]; try apply perp_per_1; try solve[assert_diffs; auto]; try apply perp_sym; try apply perp_col0 with A B; try solve[assert_diffs; assert_cols; Col]; Cop.
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro bla.
cut (exists A B C, ~ Col A B C /\\ Acute A B C /\\ forall P Q, Out B A P -> P <> Q -> Per B P Q -> Coplanar A B C Q -> exists Y, Out B C Y /\\ Col P Q Y).
intros [A [B [C [HNC [HAcute HP]]]]]; exists A, B, C; split; try split; Col.
intros T HInAngle; elim (col_dec A B T); intro HABT.
destruct (l8_18_existence A B T) as [X [HC HPerp]]; Col.
assert (HOut1 : Out B A X).
destruct (HP X T) as [Y [HOut2 H]]; try apply perp_per_1; try solve[assert_diffs; auto]; try apply perp_sym; try apply perp_col0 with A B; try solve[assert_diffs; assert_cols; Col]; Cop.

*****
H : Col X T Y
HOut2 : Out B C Y
Y : Tpoint
HOut1 : Out B A X
HPerp : Perp A B T X
HC : Col A B X
X : Tpoint
HABT : not (Col A B T)
HInAngle : InAngle T A B C
T : Tpoint
HP : forall (P Q : Tpoint) (_ : Out B A P) (_ : not (eq P Q))\n (_ : Per B P Q) (_ : Coplanar A B C Q),\nex (fun Y : Tpoint => and (Out B C Y) (Col P Q Y))
HAcute : Acute A B C
HNC : not (Col A B C)
A,B,C : Tpoint
bla : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => ex (fun Y : Tpoint => and (Out B A X) (and (Out B C Y) (Bet X T Y))))
+++++
exists X, Y; repeat (split; auto); elim H; clear H; intro H; auto.
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro bla.
cut (exists A B C, ~ Col A B C /\\ Acute A B C /\\ forall P Q, Out B A P -> P <> Q -> Per B P Q -> Coplanar A B C Q -> exists Y, Out B C Y /\\ Col P Q Y).
intros [A [B [C [HNC [HAcute HP]]]]]; exists A, B, C; split; try split; Col.
intros T HInAngle; elim (col_dec A B T); intro HABT.
destruct (l8_18_existence A B T) as [X [HC HPerp]]; Col.
assert (HOut1 : Out B A X).
destruct (HP X T) as [Y [HOut2 H]]; try apply perp_per_1; try solve[assert_diffs; auto]; try apply perp_sym; try apply perp_col0 with A B; try solve[assert_diffs; assert_cols; Col]; Cop.
exists X, Y; repeat (split; auto); elim H; clear H; intro H; auto.

*****
H : or (Bet T Y X) (Bet Y X T)
HOut2 : Out B C Y
Y : Tpoint
HOut1 : Out B A X
HPerp : Perp A B T X
HC : Col A B X
X : Tpoint
HABT : not (Col A B T)
HInAngle : InAngle T A B C
T : Tpoint
HP : forall (P Q : Tpoint) (_ : Out B A P) (_ : not (eq P Q))\n (_ : Per B P Q) (_ : Coplanar A B C Q),\nex (fun Y : Tpoint => and (Out B C Y) (Col P Q Y))
HAcute : Acute A B C
HNC : not (Col A B C)
A,B,C : Tpoint
bla : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet X T Y
+++++
elim (eq_dec_points T Y); intro HTY; treat_equalities; Between.
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro bla.
cut (exists A B C, ~ Col A B C /\\ Acute A B C /\\ forall P Q, Out B A P -> P <> Q -> Per B P Q -> Coplanar A B C Q -> exists Y, Out B C Y /\\ Col P Q Y).
intros [A [B [C [HNC [HAcute HP]]]]]; exists A, B, C; split; try split; Col.
intros T HInAngle; elim (col_dec A B T); intro HABT.
destruct (l8_18_existence A B T) as [X [HC HPerp]]; Col.
assert (HOut1 : Out B A X).
destruct (HP X T) as [Y [HOut2 H]]; try apply perp_per_1; try solve[assert_diffs; auto]; try apply perp_sym; try apply perp_col0 with A B; try solve[assert_diffs; assert_cols; Col]; Cop.
exists X, Y; repeat (split; auto); elim H; clear H; intro H; auto.
elim (eq_dec_points T Y); intro HTY; treat_equalities; Between.

*****
HTY : not (eq T Y)
H : or (Bet T Y X) (Bet Y X T)
HOut2 : Out B C Y
Y : Tpoint
HOut1 : Out B A X
HPerp : Perp A B T X
HC : Col A B X
X : Tpoint
HABT : not (Col A B T)
HInAngle : InAngle T A B C
T : Tpoint
HP : forall (P Q : Tpoint) (_ : Out B A P) (_ : not (eq P Q))\n (_ : Per B P Q) (_ : Coplanar A B C Q),\nex (fun Y : Tpoint => and (Out B C Y) (Col P Q Y))
HAcute : Acute A B C
HNC : not (Col A B C)
A,B,C : Tpoint
bla : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet X T Y
+++++
assert (HACT : ~ Col B C T).
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro bla.
cut (exists A B C, ~ Col A B C /\\ Acute A B C /\\ forall P Q, Out B A P -> P <> Q -> Per B P Q -> Coplanar A B C Q -> exists Y, Out B C Y /\\ Col P Q Y).
intros [A [B [C [HNC [HAcute HP]]]]]; exists A, B, C; split; try split; Col.
intros T HInAngle; elim (col_dec A B T); intro HABT.
destruct (l8_18_existence A B T) as [X [HC HPerp]]; Col.
assert (HOut1 : Out B A X).
destruct (HP X T) as [Y [HOut2 H]]; try apply perp_per_1; try solve[assert_diffs; auto]; try apply perp_sym; try apply perp_col0 with A B; try solve[assert_diffs; assert_cols; Col]; Cop.
exists X, Y; repeat (split; auto); elim H; clear H; intro H; auto.
elim (eq_dec_points T Y); intro HTY; treat_equalities; Between.
assert (HACT : ~ Col B C T).

*****
HTY : not (eq T Y)
H : or (Bet T Y X) (Bet Y X T)
HOut2 : Out B C Y
Y : Tpoint
HOut1 : Out B A X
HPerp : Perp A B T X
HC : Col A B X
X : Tpoint
HABT : not (Col A B T)
HInAngle : InAngle T A B C
T : Tpoint
HP : forall (P Q : Tpoint) (_ : Out B A P) (_ : not (eq P Q))\n (_ : Per B P Q) (_ : Coplanar A B C Q),\nex (fun Y : Tpoint => and (Out B C Y) (Col P Q Y))
HAcute : Acute A B C
HNC : not (Col A B C)
A,B,C : Tpoint
bla : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col B C T)
+++++
intro; apply HTY; apply l6_21 with B C X T; Col; try solve[assert_diffs; auto]; try (intro; apply HNC; assert_diffs; ColR).
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro bla.
cut (exists A B C, ~ Col A B C /\\ Acute A B C /\\ forall P Q, Out B A P -> P <> Q -> Per B P Q -> Coplanar A B C Q -> exists Y, Out B C Y /\\ Col P Q Y).
intros [A [B [C [HNC [HAcute HP]]]]]; exists A, B, C; split; try split; Col.
intros T HInAngle; elim (col_dec A B T); intro HABT.
destruct (l8_18_existence A B T) as [X [HC HPerp]]; Col.
assert (HOut1 : Out B A X).
destruct (HP X T) as [Y [HOut2 H]]; try apply perp_per_1; try solve[assert_diffs; auto]; try apply perp_sym; try apply perp_col0 with A B; try solve[assert_diffs; assert_cols; Col]; Cop.
exists X, Y; repeat (split; auto); elim H; clear H; intro H; auto.
elim (eq_dec_points T Y); intro HTY; treat_equalities; Between.
assert (HACT : ~ Col B C T).
intro; apply HTY; apply l6_21 with B C X T; Col; try solve[assert_diffs; auto]; try (intro; apply HNC; assert_diffs; ColR).

*****
H0 : Col B C T
HTY : not (eq T Y)
H : or (Bet T Y X) (Bet Y X T)
HOut2 : Out B C Y
Y : Tpoint
HOut1 : Out B A X
HPerp : Perp A B T X
HC : Col A B X
X : Tpoint
HABT : not (Col A B T)
HInAngle : InAngle T A B C
T : Tpoint
HP : forall (P Q : Tpoint) (_ : Out B A P) (_ : not (eq P Q))\n (_ : Per B P Q) (_ : Coplanar A B C Q),\nex (fun Y : Tpoint => and (Out B C Y) (Col P Q Y))
HAcute : Acute A B C
HNC : not (Col A B C)
A,B,C : Tpoint
bla : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col X T Y
+++++
elim H; assert_cols; Col.
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro bla.
cut (exists A B C, ~ Col A B C /\\ Acute A B C /\\ forall P Q, Out B A P -> P <> Q -> Per B P Q -> Coplanar A B C Q -> exists Y, Out B C Y /\\ Col P Q Y).
intros [A [B [C [HNC [HAcute HP]]]]]; exists A, B, C; split; try split; Col.
intros T HInAngle; elim (col_dec A B T); intro HABT.
destruct (l8_18_existence A B T) as [X [HC HPerp]]; Col.
assert (HOut1 : Out B A X).
destruct (HP X T) as [Y [HOut2 H]]; try apply perp_per_1; try solve[assert_diffs; auto]; try apply perp_sym; try apply perp_col0 with A B; try solve[assert_diffs; assert_cols; Col]; Cop.
exists X, Y; repeat (split; auto); elim H; clear H; intro H; auto.
elim (eq_dec_points T Y); intro HTY; treat_equalities; Between.
assert (HACT : ~ Col B C T).

*****
HACT : not (Col B C T)
HTY : not (eq T Y)
H : or (Bet T Y X) (Bet Y X T)
HOut2 : Out B C Y
Y : Tpoint
HOut1 : Out B A X
HPerp : Perp A B T X
HC : Col A B X
X : Tpoint
HABT : not (Col A B T)
HInAngle : InAngle T A B C
T : Tpoint
HP : forall (P Q : Tpoint) (_ : Out B A P) (_ : not (eq P Q))\n (_ : Per B P Q) (_ : Coplanar A B C Q),\nex (fun Y : Tpoint => and (Out B C Y) (Col P Q Y))
HAcute : Acute A B C
HNC : not (Col A B C)
A,B,C : Tpoint
bla : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet X T Y
+++++
elim H; clear H; intro HBet.
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro bla.
cut (exists A B C, ~ Col A B C /\\ Acute A B C /\\ forall P Q, Out B A P -> P <> Q -> Per B P Q -> Coplanar A B C Q -> exists Y, Out B C Y /\\ Col P Q Y).
intros [A [B [C [HNC [HAcute HP]]]]]; exists A, B, C; split; try split; Col.
intros T HInAngle; elim (col_dec A B T); intro HABT.
destruct (l8_18_existence A B T) as [X [HC HPerp]]; Col.
assert (HOut1 : Out B A X).
destruct (HP X T) as [Y [HOut2 H]]; try apply perp_per_1; try solve[assert_diffs; auto]; try apply perp_sym; try apply perp_col0 with A B; try solve[assert_diffs; assert_cols; Col]; Cop.
exists X, Y; repeat (split; auto); elim H; clear H; intro H; auto.
elim (eq_dec_points T Y); intro HTY; treat_equalities; Between.
assert (HACT : ~ Col B C T).
elim H; clear H; intro HBet.

*****
HBet : Bet T Y X
HACT : not (Col B C T)
HTY : not (eq T Y)
HOut2 : Out B C Y
Y : Tpoint
HOut1 : Out B A X
HPerp : Perp A B T X
HC : Col A B X
X : Tpoint
HABT : not (Col A B T)
HInAngle : InAngle T A B C
T : Tpoint
HP : forall (P Q : Tpoint) (_ : Out B A P) (_ : not (eq P Q))\n (_ : Per B P Q) (_ : Coplanar A B C Q),\nex (fun Y : Tpoint => and (Out B C Y) (Col P Q Y))
HAcute : Acute A B C
HNC : not (Col A B C)
A,B,C : Tpoint
bla : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet X T Y
+++++
assert (HOS : OS C B T A) by (apply in_angle_one_side; try apply l11_24; Col).
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro bla.
cut (exists A B C, ~ Col A B C /\\ Acute A B C /\\ forall P Q, Out B A P -> P <> Q -> Per B P Q -> Coplanar A B C Q -> exists Y, Out B C Y /\\ Col P Q Y).
intros [A [B [C [HNC [HAcute HP]]]]]; exists A, B, C; split; try split; Col.
intros T HInAngle; elim (col_dec A B T); intro HABT.
destruct (l8_18_existence A B T) as [X [HC HPerp]]; Col.
assert (HOut1 : Out B A X).
destruct (HP X T) as [Y [HOut2 H]]; try apply perp_per_1; try solve[assert_diffs; auto]; try apply perp_sym; try apply perp_col0 with A B; try solve[assert_diffs; assert_cols; Col]; Cop.
exists X, Y; repeat (split; auto); elim H; clear H; intro H; auto.
elim (eq_dec_points T Y); intro HTY; treat_equalities; Between.
assert (HACT : ~ Col B C T).
elim H; clear H; intro HBet.
assert (HOS : OS C B T A) by (apply in_angle_one_side; try apply l11_24; Col).

*****
HOS : OS C B T A
HBet : Bet T Y X
HACT : not (Col B C T)
HTY : not (eq T Y)
HOut2 : Out B C Y
Y : Tpoint
HOut1 : Out B A X
HPerp : Perp A B T X
HC : Col A B X
X : Tpoint
HABT : not (Col A B T)
HInAngle : InAngle T A B C
T : Tpoint
HP : forall (P Q : Tpoint) (_ : Out B A P) (_ : not (eq P Q))\n (_ : Per B P Q) (_ : Coplanar A B C Q),\nex (fun Y : Tpoint => and (Out B C Y) (Col P Q Y))
HAcute : Acute A B C
HNC : not (Col A B C)
A,B,C : Tpoint
bla : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet X T Y
+++++
exfalso; apply (l9_9_bis _ _ _ _ HOS).
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro bla.
cut (exists A B C, ~ Col A B C /\\ Acute A B C /\\ forall P Q, Out B A P -> P <> Q -> Per B P Q -> Coplanar A B C Q -> exists Y, Out B C Y /\\ Col P Q Y).
intros [A [B [C [HNC [HAcute HP]]]]]; exists A, B, C; split; try split; Col.
intros T HInAngle; elim (col_dec A B T); intro HABT.
destruct (l8_18_existence A B T) as [X [HC HPerp]]; Col.
assert (HOut1 : Out B A X).
destruct (HP X T) as [Y [HOut2 H]]; try apply perp_per_1; try solve[assert_diffs; auto]; try apply perp_sym; try apply perp_col0 with A B; try solve[assert_diffs; assert_cols; Col]; Cop.
exists X, Y; repeat (split; auto); elim H; clear H; intro H; auto.
elim (eq_dec_points T Y); intro HTY; treat_equalities; Between.
assert (HACT : ~ Col B C T).
elim H; clear H; intro HBet.
assert (HOS : OS C B T A) by (apply in_angle_one_side; try apply l11_24; Col).
exfalso; apply (l9_9_bis _ _ _ _ HOS).

*****
HOS : OS C B T A
HBet : Bet T Y X
HACT : not (Col B C T)
HTY : not (eq T Y)
HOut2 : Out B C Y
Y : Tpoint
HOut1 : Out B A X
HPerp : Perp A B T X
HC : Col A B X
X : Tpoint
HABT : not (Col A B T)
HInAngle : InAngle T A B C
T : Tpoint
HP : forall (P Q : Tpoint) (_ : Out B A P) (_ : not (eq P Q))\n (_ : Per B P Q) (_ : Coplanar A B C Q),\nex (fun Y : Tpoint => and (Out B C Y) (Col P Q Y))
HAcute : Acute A B C
HNC : not (Col A B C)
A,B,C : Tpoint
bla : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
TS C B T A
+++++
apply l9_2; apply l9_8_2 with X.
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro bla.
cut (exists A B C, ~ Col A B C /\\ Acute A B C /\\ forall P Q, Out B A P -> P <> Q -> Per B P Q -> Coplanar A B C Q -> exists Y, Out B C Y /\\ Col P Q Y).
intros [A [B [C [HNC [HAcute HP]]]]]; exists A, B, C; split; try split; Col.
intros T HInAngle; elim (col_dec A B T); intro HABT.
destruct (l8_18_existence A B T) as [X [HC HPerp]]; Col.
assert (HOut1 : Out B A X).
destruct (HP X T) as [Y [HOut2 H]]; try apply perp_per_1; try solve[assert_diffs; auto]; try apply perp_sym; try apply perp_col0 with A B; try solve[assert_diffs; assert_cols; Col]; Cop.
exists X, Y; repeat (split; auto); elim H; clear H; intro H; auto.
elim (eq_dec_points T Y); intro HTY; treat_equalities; Between.
assert (HACT : ~ Col B C T).
elim H; clear H; intro HBet.
assert (HOS : OS C B T A) by (apply in_angle_one_side; try apply l11_24; Col).
exfalso; apply (l9_9_bis _ _ _ _ HOS).
apply l9_2; apply l9_8_2 with X.

*****
HOS : OS C B T A
HBet : Bet T Y X
HACT : not (Col B C T)
HTY : not (eq T Y)
HOut2 : Out B C Y
Y : Tpoint
HOut1 : Out B A X
HPerp : Perp A B T X
HC : Col A B X
X : Tpoint
HABT : not (Col A B T)
HInAngle : InAngle T A B C
T : Tpoint
HP : forall (P Q : Tpoint) (_ : Out B A P) (_ : not (eq P Q))\n (_ : Per B P Q) (_ : Coplanar A B C Q),\nex (fun Y : Tpoint => and (Out B C Y) (Col P Q Y))
HAcute : Acute A B C
HNC : not (Col A B C)
A,B,C : Tpoint
bla : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
TS C B X T
+++++
split; [intro; assert_diffs; assert_cols; apply HNC; ColR|].
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro bla.
cut (exists A B C, ~ Col A B C /\\ Acute A B C /\\ forall P Q, Out B A P -> P <> Q -> Per B P Q -> Coplanar A B C Q -> exists Y, Out B C Y /\\ Col P Q Y).
intros [A [B [C [HNC [HAcute HP]]]]]; exists A, B, C; split; try split; Col.
intros T HInAngle; elim (col_dec A B T); intro HABT.
destruct (l8_18_existence A B T) as [X [HC HPerp]]; Col.
assert (HOut1 : Out B A X).
destruct (HP X T) as [Y [HOut2 H]]; try apply perp_per_1; try solve[assert_diffs; auto]; try apply perp_sym; try apply perp_col0 with A B; try solve[assert_diffs; assert_cols; Col]; Cop.
exists X, Y; repeat (split; auto); elim H; clear H; intro H; auto.
elim (eq_dec_points T Y); intro HTY; treat_equalities; Between.
assert (HACT : ~ Col B C T).
elim H; clear H; intro HBet.
assert (HOS : OS C B T A) by (apply in_angle_one_side; try apply l11_24; Col).
exfalso; apply (l9_9_bis _ _ _ _ HOS).
apply l9_2; apply l9_8_2 with X.
split; [intro; assert_diffs; assert_cols; apply HNC; ColR|].

*****
HOS : OS C B T A
HBet : Bet T Y X
HACT : not (Col B C T)
HTY : not (eq T Y)
HOut2 : Out B C Y
Y : Tpoint
HOut1 : Out B A X
HPerp : Perp A B T X
HC : Col A B X
X : Tpoint
HABT : not (Col A B T)
HInAngle : InAngle T A B C
T : Tpoint
HP : forall (P Q : Tpoint) (_ : Out B A P) (_ : not (eq P Q))\n (_ : Per B P Q) (_ : Coplanar A B C Q),\nex (fun Y : Tpoint => and (Out B C Y) (Col P Q Y))
HAcute : Acute A B C
HNC : not (Col A B C)
A,B,C : Tpoint
bla : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (not (Col T C B)) (ex (fun T0 : Tpoint => and (Col T0 C B) (Bet X T0 T)))
+++++
split; [intro; assert_diffs; assert_cols; apply HNC; ColR|].
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro bla.
cut (exists A B C, ~ Col A B C /\\ Acute A B C /\\ forall P Q, Out B A P -> P <> Q -> Per B P Q -> Coplanar A B C Q -> exists Y, Out B C Y /\\ Col P Q Y).
intros [A [B [C [HNC [HAcute HP]]]]]; exists A, B, C; split; try split; Col.
intros T HInAngle; elim (col_dec A B T); intro HABT.
destruct (l8_18_existence A B T) as [X [HC HPerp]]; Col.
assert (HOut1 : Out B A X).
destruct (HP X T) as [Y [HOut2 H]]; try apply perp_per_1; try solve[assert_diffs; auto]; try apply perp_sym; try apply perp_col0 with A B; try solve[assert_diffs; assert_cols; Col]; Cop.
exists X, Y; repeat (split; auto); elim H; clear H; intro H; auto.
elim (eq_dec_points T Y); intro HTY; treat_equalities; Between.
assert (HACT : ~ Col B C T).
elim H; clear H; intro HBet.
assert (HOS : OS C B T A) by (apply in_angle_one_side; try apply l11_24; Col).
exfalso; apply (l9_9_bis _ _ _ _ HOS).
apply l9_2; apply l9_8_2 with X.
split; [intro; assert_diffs; assert_cols; apply HNC; ColR|].
split; [intro; assert_diffs; assert_cols; apply HNC; ColR|].

*****
HOS : OS C B T A
HBet : Bet T Y X
HACT : not (Col B C T)
HTY : not (eq T Y)
HOut2 : Out B C Y
Y : Tpoint
HOut1 : Out B A X
HPerp : Perp A B T X
HC : Col A B X
X : Tpoint
HABT : not (Col A B T)
HInAngle : InAngle T A B C
T : Tpoint
HP : forall (P Q : Tpoint) (_ : Out B A P) (_ : not (eq P Q))\n (_ : Per B P Q) (_ : Coplanar A B C Q),\nex (fun Y : Tpoint => and (Out B C Y) (Col P Q Y))
HAcute : Acute A B C
HNC : not (Col A B C)
A,B,C : Tpoint
bla : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun T0 : Tpoint => and (Col T0 C B) (Bet X T0 T))
+++++
exists Y; assert_cols; split; Col; Between.
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro bla.
cut (exists A B C, ~ Col A B C /\\ Acute A B C /\\ forall P Q, Out B A P -> P <> Q -> Per B P Q -> Coplanar A B C Q -> exists Y, Out B C Y /\\ Col P Q Y).
intros [A [B [C [HNC [HAcute HP]]]]]; exists A, B, C; split; try split; Col.
intros T HInAngle; elim (col_dec A B T); intro HABT.
destruct (l8_18_existence A B T) as [X [HC HPerp]]; Col.
assert (HOut1 : Out B A X).
destruct (HP X T) as [Y [HOut2 H]]; try apply perp_per_1; try solve[assert_diffs; auto]; try apply perp_sym; try apply perp_col0 with A B; try solve[assert_diffs; assert_cols; Col]; Cop.
exists X, Y; repeat (split; auto); elim H; clear H; intro H; auto.
elim (eq_dec_points T Y); intro HTY; treat_equalities; Between.
assert (HACT : ~ Col B C T).
elim H; clear H; intro HBet.
assert (HOS : OS C B T A) by (apply in_angle_one_side; try apply l11_24; Col).
exfalso; apply (l9_9_bis _ _ _ _ HOS).
apply l9_2; apply l9_8_2 with X.

*****
HOS : OS C B T A
HBet : Bet T Y X
HACT : not (Col B C T)
HTY : not (eq T Y)
HOut2 : Out B C Y
Y : Tpoint
HOut1 : Out B A X
HPerp : Perp A B T X
HC : Col A B X
X : Tpoint
HABT : not (Col A B T)
HInAngle : InAngle T A B C
T : Tpoint
HP : forall (P Q : Tpoint) (_ : Out B A P) (_ : not (eq P Q))\n (_ : Per B P Q) (_ : Coplanar A B C Q),\nex (fun Y : Tpoint => and (Out B C Y) (Col P Q Y))
HAcute : Acute A B C
HNC : not (Col A B C)
A,B,C : Tpoint
bla : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OS C B X A
+++++
apply l9_19 with B; try split; try apply l6_6; assert_diffs; assert_cols; Col; intro; apply HNC; ColR.
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro bla.
cut (exists A B C, ~ Col A B C /\\ Acute A B C /\\ forall P Q, Out B A P -> P <> Q -> Per B P Q -> Coplanar A B C Q -> exists Y, Out B C Y /\\ Col P Q Y).
intros [A [B [C [HNC [HAcute HP]]]]]; exists A, B, C; split; try split; Col.
intros T HInAngle; elim (col_dec A B T); intro HABT.
destruct (l8_18_existence A B T) as [X [HC HPerp]]; Col.
assert (HOut1 : Out B A X).
destruct (HP X T) as [Y [HOut2 H]]; try apply perp_per_1; try solve[assert_diffs; auto]; try apply perp_sym; try apply perp_col0 with A B; try solve[assert_diffs; assert_cols; Col]; Cop.
exists X, Y; repeat (split; auto); elim H; clear H; intro H; auto.
elim (eq_dec_points T Y); intro HTY; treat_equalities; Between.
assert (HACT : ~ Col B C T).
elim H; clear H; intro HBet.

*****
HBet : Bet Y X T
HACT : not (Col B C T)
HTY : not (eq T Y)
HOut2 : Out B C Y
Y : Tpoint
HOut1 : Out B A X
HPerp : Perp A B T X
HC : Col A B X
X : Tpoint
HABT : not (Col A B T)
HInAngle : InAngle T A B C
T : Tpoint
HP : forall (P Q : Tpoint) (_ : Out B A P) (_ : not (eq P Q))\n (_ : Per B P Q) (_ : Coplanar A B C Q),\nex (fun Y : Tpoint => and (Out B C Y) (Col P Q Y))
HAcute : Acute A B C
HNC : not (Col A B C)
A,B,C : Tpoint
bla : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet X T Y
+++++
assert (HOS : OS A B T C) by (apply in_angle_one_side; Col).
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro bla.
cut (exists A B C, ~ Col A B C /\\ Acute A B C /\\ forall P Q, Out B A P -> P <> Q -> Per B P Q -> Coplanar A B C Q -> exists Y, Out B C Y /\\ Col P Q Y).
intros [A [B [C [HNC [HAcute HP]]]]]; exists A, B, C; split; try split; Col.
intros T HInAngle; elim (col_dec A B T); intro HABT.
destruct (l8_18_existence A B T) as [X [HC HPerp]]; Col.
assert (HOut1 : Out B A X).
destruct (HP X T) as [Y [HOut2 H]]; try apply perp_per_1; try solve[assert_diffs; auto]; try apply perp_sym; try apply perp_col0 with A B; try solve[assert_diffs; assert_cols; Col]; Cop.
exists X, Y; repeat (split; auto); elim H; clear H; intro H; auto.
elim (eq_dec_points T Y); intro HTY; treat_equalities; Between.
assert (HACT : ~ Col B C T).
elim H; clear H; intro HBet.
assert (HOS : OS A B T C) by (apply in_angle_one_side; Col).

*****
HOS : OS A B T C
HBet : Bet Y X T
HACT : not (Col B C T)
HTY : not (eq T Y)
HOut2 : Out B C Y
Y : Tpoint
HOut1 : Out B A X
HPerp : Perp A B T X
HC : Col A B X
X : Tpoint
HABT : not (Col A B T)
HInAngle : InAngle T A B C
T : Tpoint
HP : forall (P Q : Tpoint) (_ : Out B A P) (_ : not (eq P Q))\n (_ : Per B P Q) (_ : Coplanar A B C Q),\nex (fun Y : Tpoint => and (Out B C Y) (Col P Q Y))
HAcute : Acute A B C
HNC : not (Col A B C)
A,B,C : Tpoint
bla : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet X T Y
+++++
exfalso; apply (l9_9_bis _ _ _ _ HOS).
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro bla.
cut (exists A B C, ~ Col A B C /\\ Acute A B C /\\ forall P Q, Out B A P -> P <> Q -> Per B P Q -> Coplanar A B C Q -> exists Y, Out B C Y /\\ Col P Q Y).
intros [A [B [C [HNC [HAcute HP]]]]]; exists A, B, C; split; try split; Col.
intros T HInAngle; elim (col_dec A B T); intro HABT.
destruct (l8_18_existence A B T) as [X [HC HPerp]]; Col.
assert (HOut1 : Out B A X).
destruct (HP X T) as [Y [HOut2 H]]; try apply perp_per_1; try solve[assert_diffs; auto]; try apply perp_sym; try apply perp_col0 with A B; try solve[assert_diffs; assert_cols; Col]; Cop.
exists X, Y; repeat (split; auto); elim H; clear H; intro H; auto.
elim (eq_dec_points T Y); intro HTY; treat_equalities; Between.
assert (HACT : ~ Col B C T).
elim H; clear H; intro HBet.
assert (HOS : OS A B T C) by (apply in_angle_one_side; Col).
exfalso; apply (l9_9_bis _ _ _ _ HOS).

*****
HOS : OS A B T C
HBet : Bet Y X T
HACT : not (Col B C T)
HTY : not (eq T Y)
HOut2 : Out B C Y
Y : Tpoint
HOut1 : Out B A X
HPerp : Perp A B T X
HC : Col A B X
X : Tpoint
HABT : not (Col A B T)
HInAngle : InAngle T A B C
T : Tpoint
HP : forall (P Q : Tpoint) (_ : Out B A P) (_ : not (eq P Q))\n (_ : Per B P Q) (_ : Coplanar A B C Q),\nex (fun Y : Tpoint => and (Out B C Y) (Col P Q Y))
HAcute : Acute A B C
HNC : not (Col A B C)
A,B,C : Tpoint
bla : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
TS A B T C
+++++
apply l9_2; apply l9_8_2 with Y.
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro bla.
cut (exists A B C, ~ Col A B C /\\ Acute A B C /\\ forall P Q, Out B A P -> P <> Q -> Per B P Q -> Coplanar A B C Q -> exists Y, Out B C Y /\\ Col P Q Y).
intros [A [B [C [HNC [HAcute HP]]]]]; exists A, B, C; split; try split; Col.
intros T HInAngle; elim (col_dec A B T); intro HABT.
destruct (l8_18_existence A B T) as [X [HC HPerp]]; Col.
assert (HOut1 : Out B A X).
destruct (HP X T) as [Y [HOut2 H]]; try apply perp_per_1; try solve[assert_diffs; auto]; try apply perp_sym; try apply perp_col0 with A B; try solve[assert_diffs; assert_cols; Col]; Cop.
exists X, Y; repeat (split; auto); elim H; clear H; intro H; auto.
elim (eq_dec_points T Y); intro HTY; treat_equalities; Between.
assert (HACT : ~ Col B C T).
elim H; clear H; intro HBet.
assert (HOS : OS A B T C) by (apply in_angle_one_side; Col).
exfalso; apply (l9_9_bis _ _ _ _ HOS).
apply l9_2; apply l9_8_2 with Y.

*****
HOS : OS A B T C
HBet : Bet Y X T
HACT : not (Col B C T)
HTY : not (eq T Y)
HOut2 : Out B C Y
Y : Tpoint
HOut1 : Out B A X
HPerp : Perp A B T X
HC : Col A B X
X : Tpoint
HABT : not (Col A B T)
HInAngle : InAngle T A B C
T : Tpoint
HP : forall (P Q : Tpoint) (_ : Out B A P) (_ : not (eq P Q))\n (_ : Per B P Q) (_ : Coplanar A B C Q),\nex (fun Y : Tpoint => and (Out B C Y) (Col P Q Y))
HAcute : Acute A B C
HNC : not (Col A B C)
A,B,C : Tpoint
bla : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
TS A B Y T
+++++
split; [intro; assert_diffs; assert_cols; apply HNC; ColR|].
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro bla.
cut (exists A B C, ~ Col A B C /\\ Acute A B C /\\ forall P Q, Out B A P -> P <> Q -> Per B P Q -> Coplanar A B C Q -> exists Y, Out B C Y /\\ Col P Q Y).
intros [A [B [C [HNC [HAcute HP]]]]]; exists A, B, C; split; try split; Col.
intros T HInAngle; elim (col_dec A B T); intro HABT.
destruct (l8_18_existence A B T) as [X [HC HPerp]]; Col.
assert (HOut1 : Out B A X).
destruct (HP X T) as [Y [HOut2 H]]; try apply perp_per_1; try solve[assert_diffs; auto]; try apply perp_sym; try apply perp_col0 with A B; try solve[assert_diffs; assert_cols; Col]; Cop.
exists X, Y; repeat (split; auto); elim H; clear H; intro H; auto.
elim (eq_dec_points T Y); intro HTY; treat_equalities; Between.
assert (HACT : ~ Col B C T).
elim H; clear H; intro HBet.
assert (HOS : OS A B T C) by (apply in_angle_one_side; Col).
exfalso; apply (l9_9_bis _ _ _ _ HOS).
apply l9_2; apply l9_8_2 with Y.
split; [intro; assert_diffs; assert_cols; apply HNC; ColR|].

*****
HOS : OS A B T C
HBet : Bet Y X T
HACT : not (Col B C T)
HTY : not (eq T Y)
HOut2 : Out B C Y
Y : Tpoint
HOut1 : Out B A X
HPerp : Perp A B T X
HC : Col A B X
X : Tpoint
HABT : not (Col A B T)
HInAngle : InAngle T A B C
T : Tpoint
HP : forall (P Q : Tpoint) (_ : Out B A P) (_ : not (eq P Q))\n (_ : Per B P Q) (_ : Coplanar A B C Q),\nex (fun Y : Tpoint => and (Out B C Y) (Col P Q Y))
HAcute : Acute A B C
HNC : not (Col A B C)
A,B,C : Tpoint
bla : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (not (Col T A B)) (ex (fun T0 : Tpoint => and (Col T0 A B) (Bet Y T0 T)))
+++++
split; [intro; assert_diffs; assert_cols; apply HNC; ColR|].
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro bla.
cut (exists A B C, ~ Col A B C /\\ Acute A B C /\\ forall P Q, Out B A P -> P <> Q -> Per B P Q -> Coplanar A B C Q -> exists Y, Out B C Y /\\ Col P Q Y).
intros [A [B [C [HNC [HAcute HP]]]]]; exists A, B, C; split; try split; Col.
intros T HInAngle; elim (col_dec A B T); intro HABT.
destruct (l8_18_existence A B T) as [X [HC HPerp]]; Col.
assert (HOut1 : Out B A X).
destruct (HP X T) as [Y [HOut2 H]]; try apply perp_per_1; try solve[assert_diffs; auto]; try apply perp_sym; try apply perp_col0 with A B; try solve[assert_diffs; assert_cols; Col]; Cop.
exists X, Y; repeat (split; auto); elim H; clear H; intro H; auto.
elim (eq_dec_points T Y); intro HTY; treat_equalities; Between.
assert (HACT : ~ Col B C T).
elim H; clear H; intro HBet.
assert (HOS : OS A B T C) by (apply in_angle_one_side; Col).
exfalso; apply (l9_9_bis _ _ _ _ HOS).
apply l9_2; apply l9_8_2 with Y.
split; [intro; assert_diffs; assert_cols; apply HNC; ColR|].
split; [intro; assert_diffs; assert_cols; apply HNC; ColR|].

*****
HOS : OS A B T C
HBet : Bet Y X T
HACT : not (Col B C T)
HTY : not (eq T Y)
HOut2 : Out B C Y
Y : Tpoint
HOut1 : Out B A X
HPerp : Perp A B T X
HC : Col A B X
X : Tpoint
HABT : not (Col A B T)
HInAngle : InAngle T A B C
T : Tpoint
HP : forall (P Q : Tpoint) (_ : Out B A P) (_ : not (eq P Q))\n (_ : Per B P Q) (_ : Coplanar A B C Q),\nex (fun Y : Tpoint => and (Out B C Y) (Col P Q Y))
HAcute : Acute A B C
HNC : not (Col A B C)
A,B,C : Tpoint
bla : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun T0 : Tpoint => and (Col T0 A B) (Bet Y T0 T))
+++++
exists X; assert_cols; split; Col; Between.
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro bla.
cut (exists A B C, ~ Col A B C /\\ Acute A B C /\\ forall P Q, Out B A P -> P <> Q -> Per B P Q -> Coplanar A B C Q -> exists Y, Out B C Y /\\ Col P Q Y).
intros [A [B [C [HNC [HAcute HP]]]]]; exists A, B, C; split; try split; Col.
intros T HInAngle; elim (col_dec A B T); intro HABT.
destruct (l8_18_existence A B T) as [X [HC HPerp]]; Col.
assert (HOut1 : Out B A X).
destruct (HP X T) as [Y [HOut2 H]]; try apply perp_per_1; try solve[assert_diffs; auto]; try apply perp_sym; try apply perp_col0 with A B; try solve[assert_diffs; assert_cols; Col]; Cop.
exists X, Y; repeat (split; auto); elim H; clear H; intro H; auto.
elim (eq_dec_points T Y); intro HTY; treat_equalities; Between.
assert (HACT : ~ Col B C T).
elim H; clear H; intro HBet.
assert (HOS : OS A B T C) by (apply in_angle_one_side; Col).
exfalso; apply (l9_9_bis _ _ _ _ HOS).
apply l9_2; apply l9_8_2 with Y.

*****
HOS : OS A B T C
HBet : Bet Y X T
HACT : not (Col B C T)
HTY : not (eq T Y)
HOut2 : Out B C Y
Y : Tpoint
HOut1 : Out B A X
HPerp : Perp A B T X
HC : Col A B X
X : Tpoint
HABT : not (Col A B T)
HInAngle : InAngle T A B C
T : Tpoint
HP : forall (P Q : Tpoint) (_ : Out B A P) (_ : not (eq P Q))\n (_ : Per B P Q) (_ : Coplanar A B C Q),\nex (fun Y : Tpoint => and (Out B C Y) (Col P Q Y))
HAcute : Acute A B C
HNC : not (Col A B C)
A,B,C : Tpoint
bla : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OS A B Y C
+++++
apply l9_19 with B; try split; try apply l6_6; assert_diffs; assert_cols; Col; intro; apply HNC; ColR.
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro bla.
cut (exists A B C, ~ Col A B C /\\ Acute A B C /\\ forall P Q, Out B A P -> P <> Q -> Per B P Q -> Coplanar A B C Q -> exists Y, Out B C Y /\\ Col P Q Y).

*****
bla : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun A : Tpoint => ex (fun B : Tpoint => ex (fun C : Tpoint => and (not (Col A B C)) (and (Acute A B C) (forall (P Q : Tpoint) (_ : Out B A P) (_ : not (eq P Q)) (_ : Per B P Q) (_ : Coplanar A B C Q), ex (fun Y : Tpoint => and (Out B C Y) (Col P Q Y)))))))
+++++
destruct lower_dim_ex as [C [E [D H]]].
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro bla.
cut (exists A B C, ~ Col A B C /\\ Acute A B C /\\ forall P Q, Out B A P -> P <> Q -> Per B P Q -> Coplanar A B C Q -> exists Y, Out B C Y /\\ Col P Q Y).
destruct lower_dim_ex as [C [E [D H]]].

*****
H : not (or (Bet C E D) (or (Bet E D C) (Bet D C E)))
C,E,D : Tpoint
bla : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun A : Tpoint => ex (fun B : Tpoint => ex (fun C : Tpoint => and (not (Col A B C)) (and (Acute A B C) (forall (P Q : Tpoint) (_ : Out B A P) (_ : not (eq P Q)) (_ : Per B P Q) (_ : Coplanar A B C Q), ex (fun Y : Tpoint => and (Out B C Y) (Col P Q Y)))))))
+++++
assert (HNC : ~ Col C E D) by auto; clear H.
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro bla.
cut (exists A B C, ~ Col A B C /\\ Acute A B C /\\ forall P Q, Out B A P -> P <> Q -> Per B P Q -> Coplanar A B C Q -> exists Y, Out B C Y /\\ Col P Q Y).
destruct lower_dim_ex as [C [E [D H]]].
assert (HNC : ~ Col C E D) by auto; clear H.

*****
HNC : not (Col C E D)
C,E,D : Tpoint
bla : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun A : Tpoint => ex (fun B : Tpoint => ex (fun C : Tpoint => and (not (Col A B C)) (and (Acute A B C) (forall (P Q : Tpoint) (_ : Out B A P) (_ : not (eq P Q)) (_ : Per B P Q) (_ : Coplanar A B C Q), ex (fun Y : Tpoint => and (Out B C Y) (Col P Q Y)))))))
+++++
destruct (l8_18_existence D E C) as [B [HC1 HPerp]]; Col.
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro bla.
cut (exists A B C, ~ Col A B C /\\ Acute A B C /\\ forall P Q, Out B A P -> P <> Q -> Per B P Q -> Coplanar A B C Q -> exists Y, Out B C Y /\\ Col P Q Y).
destruct lower_dim_ex as [C [E [D H]]].
assert (HNC : ~ Col C E D) by auto; clear H.
destruct (l8_18_existence D E C) as [B [HC1 HPerp]]; Col.

*****
HPerp : Perp D E C B
HC1 : Col D E B
B : Tpoint
HNC : not (Col C E D)
C,E,D : Tpoint
bla : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun A : Tpoint => ex (fun B : Tpoint => ex (fun C : Tpoint => and (not (Col A B C)) (and (Acute A B C) (forall (P Q : Tpoint) (_ : Out B A P) (_ : not (eq P Q)) (_ : Per B P Q) (_ : Coplanar A B C Q), ex (fun Y : Tpoint => and (Out B C Y) (Col P Q Y)))))))
+++++
assert (HF : exists F, Col D E F /\ B <> F); [|destruct HF as [F [HC2 HNE]]].
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro bla.
cut (exists A B C, ~ Col A B C /\\ Acute A B C /\\ forall P Q, Out B A P -> P <> Q -> Per B P Q -> Coplanar A B C Q -> exists Y, Out B C Y /\\ Col P Q Y).
destruct lower_dim_ex as [C [E [D H]]].
assert (HNC : ~ Col C E D) by auto; clear H.
destruct (l8_18_existence D E C) as [B [HC1 HPerp]]; Col.
assert (HF : exists F, Col D E F /\\ B <> F); [|destruct HF as [F [HC2 HNE]]].

*****
HPerp : Perp D E C B
HC1 : Col D E B
B : Tpoint
HNC : not (Col C E D)
C,E,D : Tpoint
bla : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun F : Tpoint => and (Col D E F) (not (eq B F)))
+++++
elim (perp_not_col2 _ _ _ _ (perp_sym _ _ _ _ HPerp)); intro; [exists D|exists E]; split; assert_diffs; Col.
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro bla.
cut (exists A B C, ~ Col A B C /\\ Acute A B C /\\ forall P Q, Out B A P -> P <> Q -> Per B P Q -> Coplanar A B C Q -> exists Y, Out B C Y /\\ Col P Q Y).
destruct lower_dim_ex as [C [E [D H]]].
assert (HNC : ~ Col C E D) by auto; clear H.
destruct (l8_18_existence D E C) as [B [HC1 HPerp]]; Col.
assert (HF : exists F, Col D E F /\\ B <> F); [|destruct HF as [F [HC2 HNE]]].

*****
HNE : not (eq B F)
HC2 : Col D E F
F : Tpoint
HPerp : Perp D E C B
HC1 : Col D E B
B : Tpoint
HNC : not (Col C E D)
C,E,D : Tpoint
bla : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun A : Tpoint => ex (fun B : Tpoint => ex (fun C : Tpoint => and (not (Col A B C)) (and (Acute A B C) (forall (P Q : Tpoint) (_ : Out B A P) (_ : not (eq P Q)) (_ : Per B P Q) (_ : Coplanar A B C Q), ex (fun Y : Tpoint => and (Out B C Y) (Col P Q Y)))))))
+++++
destruct (segment_construction_2 F B B C) as [A [H HCong1]]; auto.
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro bla.
cut (exists A B C, ~ Col A B C /\\ Acute A B C /\\ forall P Q, Out B A P -> P <> Q -> Per B P Q -> Coplanar A B C Q -> exists Y, Out B C Y /\\ Col P Q Y).
destruct lower_dim_ex as [C [E [D H]]].
assert (HNC : ~ Col C E D) by auto; clear H.
destruct (l8_18_existence D E C) as [B [HC1 HPerp]]; Col.
assert (HF : exists F, Col D E F /\\ B <> F); [|destruct HF as [F [HC2 HNE]]].
destruct (segment_construction_2 F B B C) as [A [H HCong1]]; auto.

*****
HCong1 : Cong B A B C
H : or (Bet B F A) (Bet B A F)
A : Tpoint
HNE : not (eq B F)
HC2 : Col D E F
F : Tpoint
HPerp : Perp D E C B
HC1 : Col D E B
B : Tpoint
HNC : not (Col C E D)
C,E,D : Tpoint
bla : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun A : Tpoint => ex (fun B : Tpoint => ex (fun C : Tpoint => and (not (Col A B C)) (and (Acute A B C) (forall (P Q : Tpoint) (_ : Out B A P) (_ : not (eq P Q)) (_ : Per B P Q) (_ : Coplanar A B C Q), ex (fun Y : Tpoint => and (Out B C Y) (Col P Q Y)))))))
+++++
assert (HC3 : Col D E A) by (induction H; assert_diffs; assert_cols; ColR).
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro bla.
cut (exists A B C, ~ Col A B C /\\ Acute A B C /\\ forall P Q, Out B A P -> P <> Q -> Per B P Q -> Coplanar A B C Q -> exists Y, Out B C Y /\\ Col P Q Y).
destruct lower_dim_ex as [C [E [D H]]].
assert (HNC : ~ Col C E D) by auto; clear H.
destruct (l8_18_existence D E C) as [B [HC1 HPerp]]; Col.
assert (HF : exists F, Col D E F /\\ B <> F); [|destruct HF as [F [HC2 HNE]]].
destruct (segment_construction_2 F B B C) as [A [H HCong1]]; auto.
assert (HC3 : Col D E A) by (induction H; assert_diffs; assert_cols; ColR).

*****
HC3 : Col D E A
HCong1 : Cong B A B C
H : or (Bet B F A) (Bet B A F)
A : Tpoint
HNE : not (eq B F)
HC2 : Col D E F
F : Tpoint
HPerp : Perp D E C B
HC1 : Col D E B
B : Tpoint
HNC : not (Col C E D)
C,E,D : Tpoint
bla : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun A : Tpoint => ex (fun B : Tpoint => ex (fun C : Tpoint => and (not (Col A B C)) (and (Acute A B C) (forall (P Q : Tpoint) (_ : Out B A P) (_ : not (eq P Q)) (_ : Per B P Q) (_ : Coplanar A B C Q), ex (fun Y : Tpoint => and (Out B C Y) (Col P Q Y)))))))
+++++
clear H; assert (HPerp1 : Perp B A C B) by (apply perp_sym; apply perp_col0 with D E; assert_diffs; Perp).
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro bla.
cut (exists A B C, ~ Col A B C /\\ Acute A B C /\\ forall P Q, Out B A P -> P <> Q -> Per B P Q -> Coplanar A B C Q -> exists Y, Out B C Y /\\ Col P Q Y).
destruct lower_dim_ex as [C [E [D H]]].
assert (HNC : ~ Col C E D) by auto; clear H.
destruct (l8_18_existence D E C) as [B [HC1 HPerp]]; Col.
assert (HF : exists F, Col D E F /\\ B <> F); [|destruct HF as [F [HC2 HNE]]].
destruct (segment_construction_2 F B B C) as [A [H HCong1]]; auto.
assert (HC3 : Col D E A) by (induction H; assert_diffs; assert_cols; ColR).
clear H; assert (HPerp1 : Perp B A C B) by (apply perp_sym; apply perp_col0 with D E; assert_diffs; Perp).

*****
HPerp1 : Perp B A C B
HC3 : Col D E A
HCong1 : Cong B A B C
A : Tpoint
HNE : not (eq B F)
HC2 : Col D E F
F : Tpoint
HPerp : Perp D E C B
HC1 : Col D E B
B : Tpoint
HNC : not (Col C E D)
C,E,D : Tpoint
bla : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun A : Tpoint => ex (fun B : Tpoint => ex (fun C : Tpoint => and (not (Col A B C)) (and (Acute A B C) (forall (P Q : Tpoint) (_ : Out B A P) (_ : not (eq P Q)) (_ : Per B P Q) (_ : Coplanar A B C Q), ex (fun Y : Tpoint => and (Out B C Y) (Col P Q Y)))))))
+++++
clear HPerp; clear HC1; clear HC2; clear HC3; clear HNE; clear HNC; clear D; clear E; clear F.
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro bla.
cut (exists A B C, ~ Col A B C /\\ Acute A B C /\\ forall P Q, Out B A P -> P <> Q -> Per B P Q -> Coplanar A B C Q -> exists Y, Out B C Y /\\ Col P Q Y).
destruct lower_dim_ex as [C [E [D H]]].
assert (HNC : ~ Col C E D) by auto; clear H.
destruct (l8_18_existence D E C) as [B [HC1 HPerp]]; Col.
assert (HF : exists F, Col D E F /\\ B <> F); [|destruct HF as [F [HC2 HNE]]].
destruct (segment_construction_2 F B B C) as [A [H HCong1]]; auto.
assert (HC3 : Col D E A) by (induction H; assert_diffs; assert_cols; ColR).
clear H; assert (HPerp1 : Perp B A C B) by (apply perp_sym; apply perp_col0 with D E; assert_diffs; Perp).
clear HPerp; clear HC1; clear HC2; clear HC3; clear HNE; clear HNC; clear D; clear E; clear F.

*****
HPerp1 : Perp B A C B
HCong1 : Cong B A B C
C,B,A : Tpoint
bla : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun A : Tpoint => ex (fun B : Tpoint => ex (fun C : Tpoint => and (not (Col A B C)) (and (Acute A B C) (forall (P Q : Tpoint) (_ : Out B A P) (_ : not (eq P Q)) (_ : Per B P Q) (_ : Coplanar A B C Q), ex (fun Y : Tpoint => and (Out B C Y) (Col P Q Y)))))))
+++++
assert (HNC := perp_not_col _ _ _ HPerp1).
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro bla.
cut (exists A B C, ~ Col A B C /\\ Acute A B C /\\ forall P Q, Out B A P -> P <> Q -> Per B P Q -> Coplanar A B C Q -> exists Y, Out B C Y /\\ Col P Q Y).
destruct lower_dim_ex as [C [E [D H]]].
assert (HNC : ~ Col C E D) by auto; clear H.
destruct (l8_18_existence D E C) as [B [HC1 HPerp]]; Col.
assert (HF : exists F, Col D E F /\\ B <> F); [|destruct HF as [F [HC2 HNE]]].
destruct (segment_construction_2 F B B C) as [A [H HCong1]]; auto.
assert (HC3 : Col D E A) by (induction H; assert_diffs; assert_cols; ColR).
clear H; assert (HPerp1 : Perp B A C B) by (apply perp_sym; apply perp_col0 with D E; assert_diffs; Perp).
clear HPerp; clear HC1; clear HC2; clear HC3; clear HNE; clear HNC; clear D; clear E; clear F.
assert (HNC := perp_not_col _ _ _ HPerp1).

*****
HNC : not (Col B A C)
HPerp1 : Perp B A C B
HCong1 : Cong B A B C
C,B,A : Tpoint
bla : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun A : Tpoint => ex (fun B : Tpoint => ex (fun C : Tpoint => and (not (Col A B C)) (and (Acute A B C) (forall (P Q : Tpoint) (_ : Out B A P) (_ : not (eq P Q)) (_ : Per B P Q) (_ : Coplanar A B C Q), ex (fun Y : Tpoint => and (Out B C Y) (Col P Q Y)))))))
+++++
destruct (midpoint_existence A C) as [D HD]; exists A, B, D.
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro bla.
cut (exists A B C, ~ Col A B C /\\ Acute A B C /\\ forall P Q, Out B A P -> P <> Q -> Per B P Q -> Coplanar A B C Q -> exists Y, Out B C Y /\\ Col P Q Y).
destruct lower_dim_ex as [C [E [D H]]].
assert (HNC : ~ Col C E D) by auto; clear H.
destruct (l8_18_existence D E C) as [B [HC1 HPerp]]; Col.
assert (HF : exists F, Col D E F /\\ B <> F); [|destruct HF as [F [HC2 HNE]]].
destruct (segment_construction_2 F B B C) as [A [H HCong1]]; auto.
assert (HC3 : Col D E A) by (induction H; assert_diffs; assert_cols; ColR).
clear H; assert (HPerp1 : Perp B A C B) by (apply perp_sym; apply perp_col0 with D E; assert_diffs; Perp).
clear HPerp; clear HC1; clear HC2; clear HC3; clear HNE; clear HNC; clear D; clear E; clear F.
assert (HNC := perp_not_col _ _ _ HPerp1).
destruct (midpoint_existence A C) as [D HD]; exists A, B, D.

*****
HD : Midpoint D A C
D : Tpoint
HNC : not (Col B A C)
HPerp1 : Perp B A C B
HCong1 : Cong B A B C
C,B,A : Tpoint
bla : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (not (Col A B D)) (and (Acute A B D) (forall (P Q : Tpoint) (_ : Out B A P) (_ : not (eq P Q)) (_ : Per B P Q) (_ : Coplanar A B D Q), ex (fun Y : Tpoint => and (Out B D Y) (Col P Q Y))))
+++++
split; [intro; apply HNC; assert_diffs; assert_cols; ColR|split].
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro bla.
cut (exists A B C, ~ Col A B C /\\ Acute A B C /\\ forall P Q, Out B A P -> P <> Q -> Per B P Q -> Coplanar A B C Q -> exists Y, Out B C Y /\\ Col P Q Y).
destruct lower_dim_ex as [C [E [D H]]].
assert (HNC : ~ Col C E D) by auto; clear H.
destruct (l8_18_existence D E C) as [B [HC1 HPerp]]; Col.
assert (HF : exists F, Col D E F /\\ B <> F); [|destruct HF as [F [HC2 HNE]]].
destruct (segment_construction_2 F B B C) as [A [H HCong1]]; auto.
assert (HC3 : Col D E A) by (induction H; assert_diffs; assert_cols; ColR).
clear H; assert (HPerp1 : Perp B A C B) by (apply perp_sym; apply perp_col0 with D E; assert_diffs; Perp).
clear HPerp; clear HC1; clear HC2; clear HC3; clear HNE; clear HNC; clear D; clear E; clear F.
assert (HNC := perp_not_col _ _ _ HPerp1).
destruct (midpoint_existence A C) as [D HD]; exists A, B, D.
split; [intro; apply HNC; assert_diffs; assert_cols; ColR|split].

*****
HD : Midpoint D A C
D : Tpoint
HNC : not (Col B A C)
HPerp1 : Perp B A C B
HCong1 : Cong B A B C
C,B,A : Tpoint
bla : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Acute A B D
+++++
exists A, B, C; split; [apply perp_per_1; assert_diffs; auto|split].
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro bla.
cut (exists A B C, ~ Col A B C /\\ Acute A B C /\\ forall P Q, Out B A P -> P <> Q -> Per B P Q -> Coplanar A B C Q -> exists Y, Out B C Y /\\ Col P Q Y).
destruct lower_dim_ex as [C [E [D H]]].
assert (HNC : ~ Col C E D) by auto; clear H.
destruct (l8_18_existence D E C) as [B [HC1 HPerp]]; Col.
assert (HF : exists F, Col D E F /\\ B <> F); [|destruct HF as [F [HC2 HNE]]].
destruct (segment_construction_2 F B B C) as [A [H HCong1]]; auto.
assert (HC3 : Col D E A) by (induction H; assert_diffs; assert_cols; ColR).
clear H; assert (HPerp1 : Perp B A C B) by (apply perp_sym; apply perp_col0 with D E; assert_diffs; Perp).
clear HPerp; clear HC1; clear HC2; clear HC3; clear HNE; clear HNC; clear D; clear E; clear F.
assert (HNC := perp_not_col _ _ _ HPerp1).
destruct (midpoint_existence A C) as [D HD]; exists A, B, D.
split; [intro; apply HNC; assert_diffs; assert_cols; ColR|split].
exists A, B, C; split; [apply perp_per_1; assert_diffs; auto|split].

*****
HD : Midpoint D A C
D : Tpoint
HNC : not (Col B A C)
HPerp1 : Perp B A C B
HCong1 : Cong B A B C
C,B,A : Tpoint
bla : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
LeA A B D A B C
+++++
exists D; split; try apply conga_refl; repeat split; try (intro; treat_equalities; apply HNC; assert_cols; Col); exists D; split; [unfold Midpoint in *; spliter; auto|right; apply out_trivial].
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro bla.
cut (exists A B C, ~ Col A B C /\\ Acute A B C /\\ forall P Q, Out B A P -> P <> Q -> Per B P Q -> Coplanar A B C Q -> exists Y, Out B C Y /\\ Col P Q Y).
destruct lower_dim_ex as [C [E [D H]]].
assert (HNC : ~ Col C E D) by auto; clear H.
destruct (l8_18_existence D E C) as [B [HC1 HPerp]]; Col.
assert (HF : exists F, Col D E F /\\ B <> F); [|destruct HF as [F [HC2 HNE]]].
destruct (segment_construction_2 F B B C) as [A [H HCong1]]; auto.
assert (HC3 : Col D E A) by (induction H; assert_diffs; assert_cols; ColR).
clear H; assert (HPerp1 : Perp B A C B) by (apply perp_sym; apply perp_col0 with D E; assert_diffs; Perp).
clear HPerp; clear HC1; clear HC2; clear HC3; clear HNE; clear HNC; clear D; clear E; clear F.
assert (HNC := perp_not_col _ _ _ HPerp1).
destruct (midpoint_existence A C) as [D HD]; exists A, B, D.
split; [intro; apply HNC; assert_diffs; assert_cols; ColR|split].
exists A, B, C; split; [apply perp_per_1; assert_diffs; auto|split].
exists D; split; try apply conga_refl; repeat split; try (intro; treat_equalities; apply HNC; assert_cols; Col); exists D; split; [unfold Midpoint in *; spliter; auto|right; apply out_trivial].

*****
HD : Midpoint D A C
D : Tpoint
HNC : not (Col B A C)
HPerp1 : Perp B A C B
HCong1 : Cong B A B C
C,B,A : Tpoint
bla : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq D B)
+++++
intro; treat_equalities; apply HNC; Col.
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro bla.
cut (exists A B C, ~ Col A B C /\\ Acute A B C /\\ forall P Q, Out B A P -> P <> Q -> Per B P Q -> Coplanar A B C Q -> exists Y, Out B C Y /\\ Col P Q Y).
destruct lower_dim_ex as [C [E [D H]]].
assert (HNC : ~ Col C E D) by auto; clear H.
destruct (l8_18_existence D E C) as [B [HC1 HPerp]]; Col.
assert (HF : exists F, Col D E F /\\ B <> F); [|destruct HF as [F [HC2 HNE]]].
destruct (segment_construction_2 F B B C) as [A [H HCong1]]; auto.
assert (HC3 : Col D E A) by (induction H; assert_diffs; assert_cols; ColR).
clear H; assert (HPerp1 : Perp B A C B) by (apply perp_sym; apply perp_col0 with D E; assert_diffs; Perp).
clear HPerp; clear HC1; clear HC2; clear HC3; clear HNE; clear HNC; clear D; clear E; clear F.
assert (HNC := perp_not_col _ _ _ HPerp1).
destruct (midpoint_existence A C) as [D HD]; exists A, B, D.
split; [intro; apply HNC; assert_diffs; assert_cols; ColR|split].
exists A, B, C; split; [apply perp_per_1; assert_diffs; auto|split].

*****
HD : Midpoint D A C
D : Tpoint
HNC : not (Col B A C)
HPerp1 : Perp B A C B
HCong1 : Cong B A B C
C,B,A : Tpoint
bla : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (CongA A B D A B C)
+++++
intro HCongA; assert (HPer1 : Per A B D).
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro bla.
cut (exists A B C, ~ Col A B C /\\ Acute A B C /\\ forall P Q, Out B A P -> P <> Q -> Per B P Q -> Coplanar A B C Q -> exists Y, Out B C Y /\\ Col P Q Y).
destruct lower_dim_ex as [C [E [D H]]].
assert (HNC : ~ Col C E D) by auto; clear H.
destruct (l8_18_existence D E C) as [B [HC1 HPerp]]; Col.
assert (HF : exists F, Col D E F /\\ B <> F); [|destruct HF as [F [HC2 HNE]]].
destruct (segment_construction_2 F B B C) as [A [H HCong1]]; auto.
assert (HC3 : Col D E A) by (induction H; assert_diffs; assert_cols; ColR).
clear H; assert (HPerp1 : Perp B A C B) by (apply perp_sym; apply perp_col0 with D E; assert_diffs; Perp).
clear HPerp; clear HC1; clear HC2; clear HC3; clear HNE; clear HNC; clear D; clear E; clear F.
assert (HNC := perp_not_col _ _ _ HPerp1).
destruct (midpoint_existence A C) as [D HD]; exists A, B, D.
split; [intro; apply HNC; assert_diffs; assert_cols; ColR|split].
exists A, B, C; split; [apply perp_per_1; assert_diffs; auto|split].
intro HCongA; assert (HPer1 : Per A B D).

*****
HCongA : CongA A B D A B C
HD : Midpoint D A C
D : Tpoint
HNC : not (Col B A C)
HPerp1 : Perp B A C B
HCong1 : Cong B A B C
C,B,A : Tpoint
bla : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Per A B D
+++++
apply l11_17 with A B C; CongA; apply perp_per_1; assert_diffs; Perp.
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro bla.
cut (exists A B C, ~ Col A B C /\\ Acute A B C /\\ forall P Q, Out B A P -> P <> Q -> Per B P Q -> Coplanar A B C Q -> exists Y, Out B C Y /\\ Col P Q Y).
destruct lower_dim_ex as [C [E [D H]]].
assert (HNC : ~ Col C E D) by auto; clear H.
destruct (l8_18_existence D E C) as [B [HC1 HPerp]]; Col.
assert (HF : exists F, Col D E F /\\ B <> F); [|destruct HF as [F [HC2 HNE]]].
destruct (segment_construction_2 F B B C) as [A [H HCong1]]; auto.
assert (HC3 : Col D E A) by (induction H; assert_diffs; assert_cols; ColR).
clear H; assert (HPerp1 : Perp B A C B) by (apply perp_sym; apply perp_col0 with D E; assert_diffs; Perp).
clear HPerp; clear HC1; clear HC2; clear HC3; clear HNE; clear HNC; clear D; clear E; clear F.
assert (HNC := perp_not_col _ _ _ HPerp1).
destruct (midpoint_existence A C) as [D HD]; exists A, B, D.
split; [intro; apply HNC; assert_diffs; assert_cols; ColR|split].
exists A, B, C; split; [apply perp_per_1; assert_diffs; auto|split].
intro HCongA; assert (HPer1 : Per A B D).

*****
HPer1 : Per A B D
HCongA : CongA A B D A B C
HD : Midpoint D A C
D : Tpoint
HNC : not (Col B A C)
HPerp1 : Perp B A C B
HCong1 : Cong B A B C
C,B,A : Tpoint
bla : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
assert (HPer2 : Per C B D).
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro bla.
cut (exists A B C, ~ Col A B C /\\ Acute A B C /\\ forall P Q, Out B A P -> P <> Q -> Per B P Q -> Coplanar A B C Q -> exists Y, Out B C Y /\\ Col P Q Y).
destruct lower_dim_ex as [C [E [D H]]].
assert (HNC : ~ Col C E D) by auto; clear H.
destruct (l8_18_existence D E C) as [B [HC1 HPerp]]; Col.
assert (HF : exists F, Col D E F /\\ B <> F); [|destruct HF as [F [HC2 HNE]]].
destruct (segment_construction_2 F B B C) as [A [H HCong1]]; auto.
assert (HC3 : Col D E A) by (induction H; assert_diffs; assert_cols; ColR).
clear H; assert (HPerp1 : Perp B A C B) by (apply perp_sym; apply perp_col0 with D E; assert_diffs; Perp).
clear HPerp; clear HC1; clear HC2; clear HC3; clear HNE; clear HNC; clear D; clear E; clear F.
assert (HNC := perp_not_col _ _ _ HPerp1).
destruct (midpoint_existence A C) as [D HD]; exists A, B, D.
split; [intro; apply HNC; assert_diffs; assert_cols; ColR|split].
exists A, B, C; split; [apply perp_per_1; assert_diffs; auto|split].
intro HCongA; assert (HPer1 : Per A B D).
assert (HPer2 : Per C B D).

*****
HPer1 : Per A B D
HCongA : CongA A B D A B C
HD : Midpoint D A C
D : Tpoint
HNC : not (Col B A C)
HPerp1 : Perp B A C B
HCong1 : Cong B A B C
C,B,A : Tpoint
bla : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Per C B D
+++++
apply l11_17 with A B D; auto; apply cong3_conga; try (intro; treat_equalities; apply HNC; assert_cols; Col).
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro bla.
cut (exists A B C, ~ Col A B C /\\ Acute A B C /\\ forall P Q, Out B A P -> P <> Q -> Per B P Q -> Coplanar A B C Q -> exists Y, Out B C Y /\\ Col P Q Y).
destruct lower_dim_ex as [C [E [D H]]].
assert (HNC : ~ Col C E D) by auto; clear H.
destruct (l8_18_existence D E C) as [B [HC1 HPerp]]; Col.
assert (HF : exists F, Col D E F /\\ B <> F); [|destruct HF as [F [HC2 HNE]]].
destruct (segment_construction_2 F B B C) as [A [H HCong1]]; auto.
assert (HC3 : Col D E A) by (induction H; assert_diffs; assert_cols; ColR).
clear H; assert (HPerp1 : Perp B A C B) by (apply perp_sym; apply perp_col0 with D E; assert_diffs; Perp).
clear HPerp; clear HC1; clear HC2; clear HC3; clear HNE; clear HNC; clear D; clear E; clear F.
assert (HNC := perp_not_col _ _ _ HPerp1).
destruct (midpoint_existence A C) as [D HD]; exists A, B, D.
split; [intro; apply HNC; assert_diffs; assert_cols; ColR|split].
exists A, B, C; split; [apply perp_per_1; assert_diffs; auto|split].
intro HCongA; assert (HPer1 : Per A B D).
assert (HPer2 : Per C B D).
apply l11_17 with A B D; auto; apply cong3_conga; try (intro; treat_equalities; apply HNC; assert_cols; Col).

*****
HPer1 : Per A B D
HCongA : CongA A B D A B C
HD : Midpoint D A C
D : Tpoint
HNC : not (Col B A C)
HPerp1 : Perp B A C B
HCong1 : Cong B A B C
C,B,A : Tpoint
bla : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong_3 A B D C B D
+++++
repeat split; try solve[unfold Midpoint in *; spliter; Cong].
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro bla.
cut (exists A B C, ~ Col A B C /\\ Acute A B C /\\ forall P Q, Out B A P -> P <> Q -> Per B P Q -> Coplanar A B C Q -> exists Y, Out B C Y /\\ Col P Q Y).
destruct lower_dim_ex as [C [E [D H]]].
assert (HNC : ~ Col C E D) by auto; clear H.
destruct (l8_18_existence D E C) as [B [HC1 HPerp]]; Col.
assert (HF : exists F, Col D E F /\\ B <> F); [|destruct HF as [F [HC2 HNE]]].
destruct (segment_construction_2 F B B C) as [A [H HCong1]]; auto.
assert (HC3 : Col D E A) by (induction H; assert_diffs; assert_cols; ColR).
clear H; assert (HPerp1 : Perp B A C B) by (apply perp_sym; apply perp_col0 with D E; assert_diffs; Perp).
clear HPerp; clear HC1; clear HC2; clear HC3; clear HNE; clear HNC; clear D; clear E; clear F.
assert (HNC := perp_not_col _ _ _ HPerp1).
destruct (midpoint_existence A C) as [D HD]; exists A, B, D.
split; [intro; apply HNC; assert_diffs; assert_cols; ColR|split].
exists A, B, C; split; [apply perp_per_1; assert_diffs; auto|split].
intro HCongA; assert (HPer1 : Per A B D).
assert (HPer2 : Per C B D).

*****
HPer2 : Per C B D
HPer1 : Per A B D
HCongA : CongA A B D A B C
HD : Midpoint D A C
D : Tpoint
HNC : not (Col B A C)
HPerp1 : Perp B A C B
HCong1 : Cong B A B C
C,B,A : Tpoint
bla : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
assert (HSumA : SumA A B D C B D A B C).
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro bla.
cut (exists A B C, ~ Col A B C /\\ Acute A B C /\\ forall P Q, Out B A P -> P <> Q -> Per B P Q -> Coplanar A B C Q -> exists Y, Out B C Y /\\ Col P Q Y).
destruct lower_dim_ex as [C [E [D H]]].
assert (HNC : ~ Col C E D) by auto; clear H.
destruct (l8_18_existence D E C) as [B [HC1 HPerp]]; Col.
assert (HF : exists F, Col D E F /\\ B <> F); [|destruct HF as [F [HC2 HNE]]].
destruct (segment_construction_2 F B B C) as [A [H HCong1]]; auto.
assert (HC3 : Col D E A) by (induction H; assert_diffs; assert_cols; ColR).
clear H; assert (HPerp1 : Perp B A C B) by (apply perp_sym; apply perp_col0 with D E; assert_diffs; Perp).
clear HPerp; clear HC1; clear HC2; clear HC3; clear HNE; clear HNC; clear D; clear E; clear F.
assert (HNC := perp_not_col _ _ _ HPerp1).
destruct (midpoint_existence A C) as [D HD]; exists A, B, D.
split; [intro; apply HNC; assert_diffs; assert_cols; ColR|split].
exists A, B, C; split; [apply perp_per_1; assert_diffs; auto|split].
intro HCongA; assert (HPer1 : Per A B D).
assert (HPer2 : Per C B D).
assert (HSumA : SumA A B D C B D A B C).

*****
HPer2 : Per C B D
HPer1 : Per A B D
HCongA : CongA A B D A B C
HD : Midpoint D A C
D : Tpoint
HNC : not (Col B A C)
HPerp1 : Perp B A C B
HCong1 : Cong B A B C
C,B,A : Tpoint
bla : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
SumA A B D C B D A B C
+++++
assert_diffs.
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro bla.
cut (exists A B C, ~ Col A B C /\\ Acute A B C /\\ forall P Q, Out B A P -> P <> Q -> Per B P Q -> Coplanar A B C Q -> exists Y, Out B C Y /\\ Col P Q Y).
destruct lower_dim_ex as [C [E [D H]]].
assert (HNC : ~ Col C E D) by auto; clear H.
destruct (l8_18_existence D E C) as [B [HC1 HPerp]]; Col.
assert (HF : exists F, Col D E F /\\ B <> F); [|destruct HF as [F [HC2 HNE]]].
destruct (segment_construction_2 F B B C) as [A [H HCong1]]; auto.
assert (HC3 : Col D E A) by (induction H; assert_diffs; assert_cols; ColR).
clear H; assert (HPerp1 : Perp B A C B) by (apply perp_sym; apply perp_col0 with D E; assert_diffs; Perp).
clear HPerp; clear HC1; clear HC2; clear HC3; clear HNE; clear HNC; clear D; clear E; clear F.
assert (HNC := perp_not_col _ _ _ HPerp1).
destruct (midpoint_existence A C) as [D HD]; exists A, B, D.
split; [intro; apply HNC; assert_diffs; assert_cols; ColR|split].
exists A, B, C; split; [apply perp_per_1; assert_diffs; auto|split].
intro HCongA; assert (HPer1 : Per A B D).
assert (HPer2 : Per C B D).
assert (HSumA : SumA A B D C B D A B C).
assert_diffs.

*****
H : not (eq D B)
H3 : not (eq D C)
H0 : not (eq D A)
H4 : not (eq B C)
H1 : not (eq A C)
H2 : not (eq B A)
HPer2 : Per C B D
HPer1 : Per A B D
HCongA : CongA A B D A B C
HD : Midpoint D A C
D : Tpoint
HNC : not (Col B A C)
HPerp1 : Perp B A C B
HCong1 : Cong B A B C
C,B,A : Tpoint
bla : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
SumA A B D C B D A B C
+++++
exists C; repeat (split; CongA); Cop.
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro bla.
cut (exists A B C, ~ Col A B C /\\ Acute A B C /\\ forall P Q, Out B A P -> P <> Q -> Per B P Q -> Coplanar A B C Q -> exists Y, Out B C Y /\\ Col P Q Y).
destruct lower_dim_ex as [C [E [D H]]].
assert (HNC : ~ Col C E D) by auto; clear H.
destruct (l8_18_existence D E C) as [B [HC1 HPerp]]; Col.
assert (HF : exists F, Col D E F /\\ B <> F); [|destruct HF as [F [HC2 HNE]]].
destruct (segment_construction_2 F B B C) as [A [H HCong1]]; auto.
assert (HC3 : Col D E A) by (induction H; assert_diffs; assert_cols; ColR).
clear H; assert (HPerp1 : Perp B A C B) by (apply perp_sym; apply perp_col0 with D E; assert_diffs; Perp).
clear HPerp; clear HC1; clear HC2; clear HC3; clear HNE; clear HNC; clear D; clear E; clear F.
assert (HNC := perp_not_col _ _ _ HPerp1).
destruct (midpoint_existence A C) as [D HD]; exists A, B, D.
split; [intro; apply HNC; assert_diffs; assert_cols; ColR|split].
exists A, B, C; split; [apply perp_per_1; assert_diffs; auto|split].
intro HCongA; assert (HPer1 : Per A B D).
assert (HPer2 : Per C B D).
assert (HSumA : SumA A B D C B D A B C).
assert_diffs.
exists C; repeat (split; CongA); Cop.

*****
H : not (eq D B)
H3 : not (eq D C)
H0 : not (eq D A)
H4 : not (eq B C)
H1 : not (eq A C)
H2 : not (eq B A)
HPer2 : Per C B D
HPer1 : Per A B D
HCongA : CongA A B D A B C
HD : Midpoint D A C
D : Tpoint
HNC : not (Col B A C)
HPerp1 : Perp B A C B
HCong1 : Cong B A B C
C,B,A : Tpoint
bla : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (OS B D A C)
+++++
apply l9_9.
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro bla.
cut (exists A B C, ~ Col A B C /\\ Acute A B C /\\ forall P Q, Out B A P -> P <> Q -> Per B P Q -> Coplanar A B C Q -> exists Y, Out B C Y /\\ Col P Q Y).
destruct lower_dim_ex as [C [E [D H]]].
assert (HNC : ~ Col C E D) by auto; clear H.
destruct (l8_18_existence D E C) as [B [HC1 HPerp]]; Col.
assert (HF : exists F, Col D E F /\\ B <> F); [|destruct HF as [F [HC2 HNE]]].
destruct (segment_construction_2 F B B C) as [A [H HCong1]]; auto.
assert (HC3 : Col D E A) by (induction H; assert_diffs; assert_cols; ColR).
clear H; assert (HPerp1 : Perp B A C B) by (apply perp_sym; apply perp_col0 with D E; assert_diffs; Perp).
clear HPerp; clear HC1; clear HC2; clear HC3; clear HNE; clear HNC; clear D; clear E; clear F.
assert (HNC := perp_not_col _ _ _ HPerp1).
destruct (midpoint_existence A C) as [D HD]; exists A, B, D.
split; [intro; apply HNC; assert_diffs; assert_cols; ColR|split].
exists A, B, C; split; [apply perp_per_1; assert_diffs; auto|split].
intro HCongA; assert (HPer1 : Per A B D).
assert (HPer2 : Per C B D).
assert (HSumA : SumA A B D C B D A B C).
assert_diffs.
exists C; repeat (split; CongA); Cop.
apply l9_9.

*****
H : not (eq D B)
H3 : not (eq D C)
H0 : not (eq D A)
H4 : not (eq B C)
H1 : not (eq A C)
H2 : not (eq B A)
HPer2 : Per C B D
HPer1 : Per A B D
HCongA : CongA A B D A B C
HD : Midpoint D A C
D : Tpoint
HNC : not (Col B A C)
HPerp1 : Perp B A C B
HCong1 : Cong B A B C
C,B,A : Tpoint
bla : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
TS B D A C
+++++
repeat split; [apply per_not_col; auto..|].
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro bla.
cut (exists A B C, ~ Col A B C /\\ Acute A B C /\\ forall P Q, Out B A P -> P <> Q -> Per B P Q -> Coplanar A B C Q -> exists Y, Out B C Y /\\ Col P Q Y).
destruct lower_dim_ex as [C [E [D H]]].
assert (HNC : ~ Col C E D) by auto; clear H.
destruct (l8_18_existence D E C) as [B [HC1 HPerp]]; Col.
assert (HF : exists F, Col D E F /\\ B <> F); [|destruct HF as [F [HC2 HNE]]].
destruct (segment_construction_2 F B B C) as [A [H HCong1]]; auto.
assert (HC3 : Col D E A) by (induction H; assert_diffs; assert_cols; ColR).
clear H; assert (HPerp1 : Perp B A C B) by (apply perp_sym; apply perp_col0 with D E; assert_diffs; Perp).
clear HPerp; clear HC1; clear HC2; clear HC3; clear HNE; clear HNC; clear D; clear E; clear F.
assert (HNC := perp_not_col _ _ _ HPerp1).
destruct (midpoint_existence A C) as [D HD]; exists A, B, D.
split; [intro; apply HNC; assert_diffs; assert_cols; ColR|split].
exists A, B, C; split; [apply perp_per_1; assert_diffs; auto|split].
intro HCongA; assert (HPer1 : Per A B D).
assert (HPer2 : Per C B D).
assert (HSumA : SumA A B D C B D A B C).
assert_diffs.
exists C; repeat (split; CongA); Cop.
apply l9_9.
repeat split; [apply per_not_col; auto..|].

*****
H : not (eq D B)
H3 : not (eq D C)
H0 : not (eq D A)
H4 : not (eq B C)
H1 : not (eq A C)
H2 : not (eq B A)
HPer2 : Per C B D
HPer1 : Per A B D
HCongA : CongA A B D A B C
HD : Midpoint D A C
D : Tpoint
HNC : not (Col B A C)
HPerp1 : Perp B A C B
HCong1 : Cong B A B C
C,B,A : Tpoint
bla : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun T : Tpoint => and (Col T B D) (Bet A T C))
+++++
exists D; split; Col; Between.
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro bla.
cut (exists A B C, ~ Col A B C /\\ Acute A B C /\\ forall P Q, Out B A P -> P <> Q -> Per B P Q -> Coplanar A B C Q -> exists Y, Out B C Y /\\ Col P Q Y).
destruct lower_dim_ex as [C [E [D H]]].
assert (HNC : ~ Col C E D) by auto; clear H.
destruct (l8_18_existence D E C) as [B [HC1 HPerp]]; Col.
assert (HF : exists F, Col D E F /\\ B <> F); [|destruct HF as [F [HC2 HNE]]].
destruct (segment_construction_2 F B B C) as [A [H HCong1]]; auto.
assert (HC3 : Col D E A) by (induction H; assert_diffs; assert_cols; ColR).
clear H; assert (HPerp1 : Perp B A C B) by (apply perp_sym; apply perp_col0 with D E; assert_diffs; Perp).
clear HPerp; clear HC1; clear HC2; clear HC3; clear HNE; clear HNC; clear D; clear E; clear F.
assert (HNC := perp_not_col _ _ _ HPerp1).
destruct (midpoint_existence A C) as [D HD]; exists A, B, D.
split; [intro; apply HNC; assert_diffs; assert_cols; ColR|split].
exists A, B, C; split; [apply perp_per_1; assert_diffs; auto|split].
intro HCongA; assert (HPer1 : Per A B D).
assert (HPer2 : Per C B D).
assert (HSumA : SumA A B D C B D A B C).

*****
HSumA : SumA A B D C B D A B C
HPer2 : Per C B D
HPer1 : Per A B D
HCongA : CongA A B D A B C
HD : Midpoint D A C
D : Tpoint
HNC : not (Col B A C)
HPerp1 : Perp B A C B
HCong1 : Cong B A B C
C,B,A : Tpoint
bla : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
assert (HC := per2_suma__bet _ _ _ _ _ _ _ _ _ HPer1 HPer2 HSumA); apply HNC; assert_cols; Col.
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro bla.
cut (exists A B C, ~ Col A B C /\\ Acute A B C /\\ forall P Q, Out B A P -> P <> Q -> Per B P Q -> Coplanar A B C Q -> exists Y, Out B C Y /\\ Col P Q Y).
destruct lower_dim_ex as [C [E [D H]]].
assert (HNC : ~ Col C E D) by auto; clear H.
destruct (l8_18_existence D E C) as [B [HC1 HPerp]]; Col.
assert (HF : exists F, Col D E F /\\ B <> F); [|destruct HF as [F [HC2 HNE]]].
destruct (segment_construction_2 F B B C) as [A [H HCong1]]; auto.
assert (HC3 : Col D E A) by (induction H; assert_diffs; assert_cols; ColR).
clear H; assert (HPerp1 : Perp B A C B) by (apply perp_sym; apply perp_col0 with D E; assert_diffs; Perp).
clear HPerp; clear HC1; clear HC2; clear HC3; clear HNE; clear HNC; clear D; clear E; clear F.
assert (HNC := perp_not_col _ _ _ HPerp1).
destruct (midpoint_existence A C) as [D HD]; exists A, B, D.
split; [intro; apply HNC; assert_diffs; assert_cols; ColR|split].

*****
HD : Midpoint D A C
D : Tpoint
HNC : not (Col B A C)
HPerp1 : Perp B A C B
HCong1 : Cong B A B C
C,B,A : Tpoint
bla : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (P Q : Tpoint) (_ : Out B A P) (_ : not (eq P Q)) (_ : Per B P Q) (_ : Coplanar A B D Q), ex (fun Y : Tpoint => and (Out B D Y) (Col P Q Y))
+++++
intros P Q HOut1 HNE1 HPer HCop1.
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro bla.
cut (exists A B C, ~ Col A B C /\\ Acute A B C /\\ forall P Q, Out B A P -> P <> Q -> Per B P Q -> Coplanar A B C Q -> exists Y, Out B C Y /\\ Col P Q Y).
destruct lower_dim_ex as [C [E [D H]]].
assert (HNC : ~ Col C E D) by auto; clear H.
destruct (l8_18_existence D E C) as [B [HC1 HPerp]]; Col.
assert (HF : exists F, Col D E F /\\ B <> F); [|destruct HF as [F [HC2 HNE]]].
destruct (segment_construction_2 F B B C) as [A [H HCong1]]; auto.
assert (HC3 : Col D E A) by (induction H; assert_diffs; assert_cols; ColR).
clear H; assert (HPerp1 : Perp B A C B) by (apply perp_sym; apply perp_col0 with D E; assert_diffs; Perp).
clear HPerp; clear HC1; clear HC2; clear HC3; clear HNE; clear HNC; clear D; clear E; clear F.
assert (HNC := perp_not_col _ _ _ HPerp1).
destruct (midpoint_existence A C) as [D HD]; exists A, B, D.
split; [intro; apply HNC; assert_diffs; assert_cols; ColR|split].
intros P Q HOut1 HNE1 HPer HCop1.

*****
HCop1 : Coplanar A B D Q
HPer : Per B P Q
HNE1 : not (eq P Q)
HOut1 : Out B A P
P,Q : Tpoint
HD : Midpoint D A C
D : Tpoint
HNC : not (Col B A C)
HPerp1 : Perp B A C B
HCong1 : Cong B A B C
C,B,A : Tpoint
bla : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Y : Tpoint => and (Out B D Y) (Col P Q Y))
+++++
destruct (segment_construction_2 C B B P) as [P' [H HCong2]]; [assert_diffs; auto|].
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro bla.
cut (exists A B C, ~ Col A B C /\\ Acute A B C /\\ forall P Q, Out B A P -> P <> Q -> Per B P Q -> Coplanar A B C Q -> exists Y, Out B C Y /\\ Col P Q Y).
destruct lower_dim_ex as [C [E [D H]]].
assert (HNC : ~ Col C E D) by auto; clear H.
destruct (l8_18_existence D E C) as [B [HC1 HPerp]]; Col.
assert (HF : exists F, Col D E F /\\ B <> F); [|destruct HF as [F [HC2 HNE]]].
destruct (segment_construction_2 F B B C) as [A [H HCong1]]; auto.
assert (HC3 : Col D E A) by (induction H; assert_diffs; assert_cols; ColR).
clear H; assert (HPerp1 : Perp B A C B) by (apply perp_sym; apply perp_col0 with D E; assert_diffs; Perp).
clear HPerp; clear HC1; clear HC2; clear HC3; clear HNE; clear HNC; clear D; clear E; clear F.
assert (HNC := perp_not_col _ _ _ HPerp1).
destruct (midpoint_existence A C) as [D HD]; exists A, B, D.
split; [intro; apply HNC; assert_diffs; assert_cols; ColR|split].
intros P Q HOut1 HNE1 HPer HCop1.
destruct (segment_construction_2 C B B P) as [P' [H HCong2]]; [assert_diffs; auto|].

*****
HCong2 : Cong B P' B P
H : or (Bet B C P') (Bet B P' C)
P' : Tpoint
HCop1 : Coplanar A B D Q
HPer : Per B P Q
HNE1 : not (eq P Q)
HOut1 : Out B A P
P,Q : Tpoint
HD : Midpoint D A C
D : Tpoint
HNC : not (Col B A C)
HPerp1 : Perp B A C B
HCong1 : Cong B A B C
C,B,A : Tpoint
bla : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Y : Tpoint => and (Out B D Y) (Col P Q Y))
+++++
assert (HOut2 : Out B C P') by (assert_diffs; repeat (split; auto)); clear H.
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro bla.
cut (exists A B C, ~ Col A B C /\\ Acute A B C /\\ forall P Q, Out B A P -> P <> Q -> Per B P Q -> Coplanar A B C Q -> exists Y, Out B C Y /\\ Col P Q Y).
destruct lower_dim_ex as [C [E [D H]]].
assert (HNC : ~ Col C E D) by auto; clear H.
destruct (l8_18_existence D E C) as [B [HC1 HPerp]]; Col.
assert (HF : exists F, Col D E F /\\ B <> F); [|destruct HF as [F [HC2 HNE]]].
destruct (segment_construction_2 F B B C) as [A [H HCong1]]; auto.
assert (HC3 : Col D E A) by (induction H; assert_diffs; assert_cols; ColR).
clear H; assert (HPerp1 : Perp B A C B) by (apply perp_sym; apply perp_col0 with D E; assert_diffs; Perp).
clear HPerp; clear HC1; clear HC2; clear HC3; clear HNE; clear HNC; clear D; clear E; clear F.
assert (HNC := perp_not_col _ _ _ HPerp1).
destruct (midpoint_existence A C) as [D HD]; exists A, B, D.
split; [intro; apply HNC; assert_diffs; assert_cols; ColR|split].
intros P Q HOut1 HNE1 HPer HCop1.
destruct (segment_construction_2 C B B P) as [P' [H HCong2]]; [assert_diffs; auto|].
assert (HOut2 : Out B C P') by (assert_diffs; repeat (split; auto)); clear H.

*****
HOut2 : Out B C P'
HCong2 : Cong B P' B P
P' : Tpoint
HCop1 : Coplanar A B D Q
HPer : Per B P Q
HNE1 : not (eq P Q)
HOut1 : Out B A P
P,Q : Tpoint
HD : Midpoint D A C
D : Tpoint
HNC : not (Col B A C)
HPerp1 : Perp B A C B
HCong1 : Cong B A B C
C,B,A : Tpoint
bla : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Y : Tpoint => and (Out B D Y) (Col P Q Y))
+++++
destruct (ex_perp_cop B C P' A) as [Q' [HPerp2 HCop2]]; [assert_diffs; auto|].
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro bla.
cut (exists A B C, ~ Col A B C /\\ Acute A B C /\\ forall P Q, Out B A P -> P <> Q -> Per B P Q -> Coplanar A B C Q -> exists Y, Out B C Y /\\ Col P Q Y).
destruct lower_dim_ex as [C [E [D H]]].
assert (HNC : ~ Col C E D) by auto; clear H.
destruct (l8_18_existence D E C) as [B [HC1 HPerp]]; Col.
assert (HF : exists F, Col D E F /\\ B <> F); [|destruct HF as [F [HC2 HNE]]].
destruct (segment_construction_2 F B B C) as [A [H HCong1]]; auto.
assert (HC3 : Col D E A) by (induction H; assert_diffs; assert_cols; ColR).
clear H; assert (HPerp1 : Perp B A C B) by (apply perp_sym; apply perp_col0 with D E; assert_diffs; Perp).
clear HPerp; clear HC1; clear HC2; clear HC3; clear HNE; clear HNC; clear D; clear E; clear F.
assert (HNC := perp_not_col _ _ _ HPerp1).
destruct (midpoint_existence A C) as [D HD]; exists A, B, D.
split; [intro; apply HNC; assert_diffs; assert_cols; ColR|split].
intros P Q HOut1 HNE1 HPer HCop1.
destruct (segment_construction_2 C B B P) as [P' [H HCong2]]; [assert_diffs; auto|].
assert (HOut2 : Out B C P') by (assert_diffs; repeat (split; auto)); clear H.
destruct (ex_perp_cop B C P' A) as [Q' [HPerp2 HCop2]]; [assert_diffs; auto|].

*****
HCop2 : Coplanar B C A Q'
HPerp2 : Perp B C Q' P'
Q' : Tpoint
HOut2 : Out B C P'
HCong2 : Cong B P' B P
P' : Tpoint
HCop1 : Coplanar A B D Q
HPer : Per B P Q
HNE1 : not (eq P Q)
HOut1 : Out B A P
P,Q : Tpoint
HD : Midpoint D A C
D : Tpoint
HNC : not (Col B A C)
HPerp1 : Perp B A C B
HCong1 : Cong B A B C
C,B,A : Tpoint
bla : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Y : Tpoint => and (Out B D Y) (Col P Q Y))
+++++
assert (HPerp3 : Perp B A Q P).
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro bla.
cut (exists A B C, ~ Col A B C /\\ Acute A B C /\\ forall P Q, Out B A P -> P <> Q -> Per B P Q -> Coplanar A B C Q -> exists Y, Out B C Y /\\ Col P Q Y).
destruct lower_dim_ex as [C [E [D H]]].
assert (HNC : ~ Col C E D) by auto; clear H.
destruct (l8_18_existence D E C) as [B [HC1 HPerp]]; Col.
assert (HF : exists F, Col D E F /\\ B <> F); [|destruct HF as [F [HC2 HNE]]].
destruct (segment_construction_2 F B B C) as [A [H HCong1]]; auto.
assert (HC3 : Col D E A) by (induction H; assert_diffs; assert_cols; ColR).
clear H; assert (HPerp1 : Perp B A C B) by (apply perp_sym; apply perp_col0 with D E; assert_diffs; Perp).
clear HPerp; clear HC1; clear HC2; clear HC3; clear HNE; clear HNC; clear D; clear E; clear F.
assert (HNC := perp_not_col _ _ _ HPerp1).
destruct (midpoint_existence A C) as [D HD]; exists A, B, D.
split; [intro; apply HNC; assert_diffs; assert_cols; ColR|split].
intros P Q HOut1 HNE1 HPer HCop1.
destruct (segment_construction_2 C B B P) as [P' [H HCong2]]; [assert_diffs; auto|].
assert (HOut2 : Out B C P') by (assert_diffs; repeat (split; auto)); clear H.
destruct (ex_perp_cop B C P' A) as [Q' [HPerp2 HCop2]]; [assert_diffs; auto|].
assert (HPerp3 : Perp B A Q P).

*****
HCop2 : Coplanar B C A Q'
HPerp2 : Perp B C Q' P'
Q' : Tpoint
HOut2 : Out B C P'
HCong2 : Cong B P' B P
P' : Tpoint
HCop1 : Coplanar A B D Q
HPer : Per B P Q
HNE1 : not (eq P Q)
HOut1 : Out B A P
P,Q : Tpoint
HD : Midpoint D A C
D : Tpoint
HNC : not (Col B A C)
HPerp1 : Perp B A C B
HCong1 : Cong B A B C
C,B,A : Tpoint
bla : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Perp B A Q P
+++++
apply l8_16_2 with B; assert_diffs; Col; Perp.
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro bla.
cut (exists A B C, ~ Col A B C /\\ Acute A B C /\\ forall P Q, Out B A P -> P <> Q -> Per B P Q -> Coplanar A B C Q -> exists Y, Out B C Y /\\ Col P Q Y).
destruct lower_dim_ex as [C [E [D H]]].
assert (HNC : ~ Col C E D) by auto; clear H.
destruct (l8_18_existence D E C) as [B [HC1 HPerp]]; Col.
assert (HF : exists F, Col D E F /\\ B <> F); [|destruct HF as [F [HC2 HNE]]].
destruct (segment_construction_2 F B B C) as [A [H HCong1]]; auto.
assert (HC3 : Col D E A) by (induction H; assert_diffs; assert_cols; ColR).
clear H; assert (HPerp1 : Perp B A C B) by (apply perp_sym; apply perp_col0 with D E; assert_diffs; Perp).
clear HPerp; clear HC1; clear HC2; clear HC3; clear HNE; clear HNC; clear D; clear E; clear F.
assert (HNC := perp_not_col _ _ _ HPerp1).
destruct (midpoint_existence A C) as [D HD]; exists A, B, D.
split; [intro; apply HNC; assert_diffs; assert_cols; ColR|split].
intros P Q HOut1 HNE1 HPer HCop1.
destruct (segment_construction_2 C B B P) as [P' [H HCong2]]; [assert_diffs; auto|].
assert (HOut2 : Out B C P') by (assert_diffs; repeat (split; auto)); clear H.
destruct (ex_perp_cop B C P' A) as [Q' [HPerp2 HCop2]]; [assert_diffs; auto|].
assert (HPerp3 : Perp B A Q P).
apply l8_16_2 with B; assert_diffs; Col; Perp.

*****
H5 : not (eq B P)
H8 : not (eq P' B)
H7 : not (eq Q' P')
H : not (eq B Q)
H3 : not (eq D C)
H0 : not (eq D A)
H4 : not (eq B C)
H1 : not (eq A C)
H2 : not (eq B A)
HCop2 : Coplanar B C A Q'
HPerp2 : Perp B C Q' P'
Q' : Tpoint
HOut2 : Out B C P'
HCong2 : Cong B P' B P
P' : Tpoint
HCop1 : Coplanar A B D Q
HPer : Per B P Q
HNE1 : not (eq P Q)
HOut1 : Out B A P
P,Q : Tpoint
HD : Midpoint D A C
D : Tpoint
HNC : not (Col B A C)
HPerp1 : Perp B A C B
HCong1 : Cong B A B C
C,B,A : Tpoint
bla : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col B A Q)
+++++
apply per_not_col in HPer; auto.
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro bla.
cut (exists A B C, ~ Col A B C /\\ Acute A B C /\\ forall P Q, Out B A P -> P <> Q -> Per B P Q -> Coplanar A B C Q -> exists Y, Out B C Y /\\ Col P Q Y).
destruct lower_dim_ex as [C [E [D H]]].
assert (HNC : ~ Col C E D) by auto; clear H.
destruct (l8_18_existence D E C) as [B [HC1 HPerp]]; Col.
assert (HF : exists F, Col D E F /\\ B <> F); [|destruct HF as [F [HC2 HNE]]].
destruct (segment_construction_2 F B B C) as [A [H HCong1]]; auto.
assert (HC3 : Col D E A) by (induction H; assert_diffs; assert_cols; ColR).
clear H; assert (HPerp1 : Perp B A C B) by (apply perp_sym; apply perp_col0 with D E; assert_diffs; Perp).
clear HPerp; clear HC1; clear HC2; clear HC3; clear HNE; clear HNC; clear D; clear E; clear F.
assert (HNC := perp_not_col _ _ _ HPerp1).
destruct (midpoint_existence A C) as [D HD]; exists A, B, D.
split; [intro; apply HNC; assert_diffs; assert_cols; ColR|split].
intros P Q HOut1 HNE1 HPer HCop1.
destruct (segment_construction_2 C B B P) as [P' [H HCong2]]; [assert_diffs; auto|].
assert (HOut2 : Out B C P') by (assert_diffs; repeat (split; auto)); clear H.
destruct (ex_perp_cop B C P' A) as [Q' [HPerp2 HCop2]]; [assert_diffs; auto|].
assert (HPerp3 : Perp B A Q P).
apply l8_16_2 with B; assert_diffs; Col; Perp.
apply per_not_col in HPer; auto.

*****
H5 : not (eq B P)
H8 : not (eq P' B)
H7 : not (eq Q' P')
H : not (eq B Q)
H3 : not (eq D C)
H0 : not (eq D A)
H4 : not (eq B C)
H1 : not (eq A C)
H2 : not (eq B A)
HCop2 : Coplanar B C A Q'
HPerp2 : Perp B C Q' P'
Q' : Tpoint
HOut2 : Out B C P'
HCong2 : Cong B P' B P
P' : Tpoint
HCop1 : Coplanar A B D Q
HPer : not (Col B P Q)
HNE1 : not (eq P Q)
HOut1 : Out B A P
P,Q : Tpoint
HD : Midpoint D A C
D : Tpoint
HNC : not (Col B A C)
HPerp1 : Perp B A C B
HCong1 : Cong B A B C
C,B,A : Tpoint
bla : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col B A Q)
+++++
intro; apply HPer; assert_cols; ColR.
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro bla.
cut (exists A B C, ~ Col A B C /\\ Acute A B C /\\ forall P Q, Out B A P -> P <> Q -> Per B P Q -> Coplanar A B C Q -> exists Y, Out B C Y /\\ Col P Q Y).
destruct lower_dim_ex as [C [E [D H]]].
assert (HNC : ~ Col C E D) by auto; clear H.
destruct (l8_18_existence D E C) as [B [HC1 HPerp]]; Col.
assert (HF : exists F, Col D E F /\\ B <> F); [|destruct HF as [F [HC2 HNE]]].
destruct (segment_construction_2 F B B C) as [A [H HCong1]]; auto.
assert (HC3 : Col D E A) by (induction H; assert_diffs; assert_cols; ColR).
clear H; assert (HPerp1 : Perp B A C B) by (apply perp_sym; apply perp_col0 with D E; assert_diffs; Perp).
clear HPerp; clear HC1; clear HC2; clear HC3; clear HNE; clear HNC; clear D; clear E; clear F.
assert (HNC := perp_not_col _ _ _ HPerp1).
destruct (midpoint_existence A C) as [D HD]; exists A, B, D.
split; [intro; apply HNC; assert_diffs; assert_cols; ColR|split].
intros P Q HOut1 HNE1 HPer HCop1.
destruct (segment_construction_2 C B B P) as [P' [H HCong2]]; [assert_diffs; auto|].
assert (HOut2 : Out B C P') by (assert_diffs; repeat (split; auto)); clear H.
destruct (ex_perp_cop B C P' A) as [Q' [HPerp2 HCop2]]; [assert_diffs; auto|].
assert (HPerp3 : Perp B A Q P).

*****
HPerp3 : Perp B A Q P
HCop2 : Coplanar B C A Q'
HPerp2 : Perp B C Q' P'
Q' : Tpoint
HOut2 : Out B C P'
HCong2 : Cong B P' B P
P' : Tpoint
HCop1 : Coplanar A B D Q
HPer : Per B P Q
HNE1 : not (eq P Q)
HOut1 : Out B A P
P,Q : Tpoint
HD : Midpoint D A C
D : Tpoint
HNC : not (Col B A C)
HPerp1 : Perp B A C B
HCong1 : Cong B A B C
C,B,A : Tpoint
bla : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Y : Tpoint => and (Out B D Y) (Col P Q Y))
+++++
assert (Coplanar B P P' P) by Cop.
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro bla.
cut (exists A B C, ~ Col A B C /\\ Acute A B C /\\ forall P Q, Out B A P -> P <> Q -> Per B P Q -> Coplanar A B C Q -> exists Y, Out B C Y /\\ Col P Q Y).
destruct lower_dim_ex as [C [E [D H]]].
assert (HNC : ~ Col C E D) by auto; clear H.
destruct (l8_18_existence D E C) as [B [HC1 HPerp]]; Col.
assert (HF : exists F, Col D E F /\\ B <> F); [|destruct HF as [F [HC2 HNE]]].
destruct (segment_construction_2 F B B C) as [A [H HCong1]]; auto.
assert (HC3 : Col D E A) by (induction H; assert_diffs; assert_cols; ColR).
clear H; assert (HPerp1 : Perp B A C B) by (apply perp_sym; apply perp_col0 with D E; assert_diffs; Perp).
clear HPerp; clear HC1; clear HC2; clear HC3; clear HNE; clear HNC; clear D; clear E; clear F.
assert (HNC := perp_not_col _ _ _ HPerp1).
destruct (midpoint_existence A C) as [D HD]; exists A, B, D.
split; [intro; apply HNC; assert_diffs; assert_cols; ColR|split].
intros P Q HOut1 HNE1 HPer HCop1.
destruct (segment_construction_2 C B B P) as [P' [H HCong2]]; [assert_diffs; auto|].
assert (HOut2 : Out B C P') by (assert_diffs; repeat (split; auto)); clear H.
destruct (ex_perp_cop B C P' A) as [Q' [HPerp2 HCop2]]; [assert_diffs; auto|].
assert (HPerp3 : Perp B A Q P).
assert (Coplanar B P P' P) by Cop.

*****
H : Coplanar B P P' P
HPerp3 : Perp B A Q P
HCop2 : Coplanar B C A Q'
HPerp2 : Perp B C Q' P'
Q' : Tpoint
HOut2 : Out B C P'
HCong2 : Cong B P' B P
P' : Tpoint
HCop1 : Coplanar A B D Q
HPer : Per B P Q
HNE1 : not (eq P Q)
HOut1 : Out B A P
P,Q : Tpoint
HD : Midpoint D A C
D : Tpoint
HNC : not (Col B A C)
HPerp1 : Perp B A C B
HCong1 : Cong B A B C
C,B,A : Tpoint
bla : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Y : Tpoint => and (Out B D Y) (Col P Q Y))
+++++
assert (Coplanar A B C P) by Cop.
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro bla.
cut (exists A B C, ~ Col A B C /\\ Acute A B C /\\ forall P Q, Out B A P -> P <> Q -> Per B P Q -> Coplanar A B C Q -> exists Y, Out B C Y /\\ Col P Q Y).
destruct lower_dim_ex as [C [E [D H]]].
assert (HNC : ~ Col C E D) by auto; clear H.
destruct (l8_18_existence D E C) as [B [HC1 HPerp]]; Col.
assert (HF : exists F, Col D E F /\\ B <> F); [|destruct HF as [F [HC2 HNE]]].
destruct (segment_construction_2 F B B C) as [A [H HCong1]]; auto.
assert (HC3 : Col D E A) by (induction H; assert_diffs; assert_cols; ColR).
clear H; assert (HPerp1 : Perp B A C B) by (apply perp_sym; apply perp_col0 with D E; assert_diffs; Perp).
clear HPerp; clear HC1; clear HC2; clear HC3; clear HNE; clear HNC; clear D; clear E; clear F.
assert (HNC := perp_not_col _ _ _ HPerp1).
destruct (midpoint_existence A C) as [D HD]; exists A, B, D.
split; [intro; apply HNC; assert_diffs; assert_cols; ColR|split].
intros P Q HOut1 HNE1 HPer HCop1.
destruct (segment_construction_2 C B B P) as [P' [H HCong2]]; [assert_diffs; auto|].
assert (HOut2 : Out B C P') by (assert_diffs; repeat (split; auto)); clear H.
destruct (ex_perp_cop B C P' A) as [Q' [HPerp2 HCop2]]; [assert_diffs; auto|].
assert (HPerp3 : Perp B A Q P).
assert (Coplanar B P P' P) by Cop.
assert (Coplanar A B C P) by Cop.

*****
H0 : Coplanar A B C P
H : Coplanar B P P' P
HPerp3 : Perp B A Q P
HCop2 : Coplanar B C A Q'
HPerp2 : Perp B C Q' P'
Q' : Tpoint
HOut2 : Out B C P'
HCong2 : Cong B P' B P
P' : Tpoint
HCop1 : Coplanar A B D Q
HPer : Per B P Q
HNE1 : not (eq P Q)
HOut1 : Out B A P
P,Q : Tpoint
HD : Midpoint D A C
D : Tpoint
HNC : not (Col B A C)
HPerp1 : Perp B A C B
HCong1 : Cong B A B C
C,B,A : Tpoint
bla : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Y : Tpoint => and (Out B D Y) (Col P Q Y))
+++++
assert (Coplanar B Q A C) by (assert_diffs; apply col2_cop__cop with A D; Col; Cop).
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro bla.
cut (exists A B C, ~ Col A B C /\\ Acute A B C /\\ forall P Q, Out B A P -> P <> Q -> Per B P Q -> Coplanar A B C Q -> exists Y, Out B C Y /\\ Col P Q Y).
destruct lower_dim_ex as [C [E [D H]]].
assert (HNC : ~ Col C E D) by auto; clear H.
destruct (l8_18_existence D E C) as [B [HC1 HPerp]]; Col.
assert (HF : exists F, Col D E F /\\ B <> F); [|destruct HF as [F [HC2 HNE]]].
destruct (segment_construction_2 F B B C) as [A [H HCong1]]; auto.
assert (HC3 : Col D E A) by (induction H; assert_diffs; assert_cols; ColR).
clear H; assert (HPerp1 : Perp B A C B) by (apply perp_sym; apply perp_col0 with D E; assert_diffs; Perp).
clear HPerp; clear HC1; clear HC2; clear HC3; clear HNE; clear HNC; clear D; clear E; clear F.
assert (HNC := perp_not_col _ _ _ HPerp1).
destruct (midpoint_existence A C) as [D HD]; exists A, B, D.
split; [intro; apply HNC; assert_diffs; assert_cols; ColR|split].
intros P Q HOut1 HNE1 HPer HCop1.
destruct (segment_construction_2 C B B P) as [P' [H HCong2]]; [assert_diffs; auto|].
assert (HOut2 : Out B C P') by (assert_diffs; repeat (split; auto)); clear H.
destruct (ex_perp_cop B C P' A) as [Q' [HPerp2 HCop2]]; [assert_diffs; auto|].
assert (HPerp3 : Perp B A Q P).
assert (Coplanar B P P' P) by Cop.
assert (Coplanar A B C P) by Cop.
assert (Coplanar B Q A C) by (assert_diffs; apply col2_cop__cop with A D; Col; Cop).

*****
H1 : Coplanar B Q A C
H0 : Coplanar A B C P
H : Coplanar B P P' P
HPerp3 : Perp B A Q P
HCop2 : Coplanar B C A Q'
HPerp2 : Perp B C Q' P'
Q' : Tpoint
HOut2 : Out B C P'
HCong2 : Cong B P' B P
P' : Tpoint
HCop1 : Coplanar A B D Q
HPer : Per B P Q
HNE1 : not (eq P Q)
HOut1 : Out B A P
P,Q : Tpoint
HD : Midpoint D A C
D : Tpoint
HNC : not (Col B A C)
HPerp1 : Perp B A C B
HCong1 : Cong B A B C
C,B,A : Tpoint
bla : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Y : Tpoint => and (Out B D Y) (Col P Q Y))
+++++
assert (Coplanar A B C P') by Cop.
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro bla.
cut (exists A B C, ~ Col A B C /\\ Acute A B C /\\ forall P Q, Out B A P -> P <> Q -> Per B P Q -> Coplanar A B C Q -> exists Y, Out B C Y /\\ Col P Q Y).
destruct lower_dim_ex as [C [E [D H]]].
assert (HNC : ~ Col C E D) by auto; clear H.
destruct (l8_18_existence D E C) as [B [HC1 HPerp]]; Col.
assert (HF : exists F, Col D E F /\\ B <> F); [|destruct HF as [F [HC2 HNE]]].
destruct (segment_construction_2 F B B C) as [A [H HCong1]]; auto.
assert (HC3 : Col D E A) by (induction H; assert_diffs; assert_cols; ColR).
clear H; assert (HPerp1 : Perp B A C B) by (apply perp_sym; apply perp_col0 with D E; assert_diffs; Perp).
clear HPerp; clear HC1; clear HC2; clear HC3; clear HNE; clear HNC; clear D; clear E; clear F.
assert (HNC := perp_not_col _ _ _ HPerp1).
destruct (midpoint_existence A C) as [D HD]; exists A, B, D.
split; [intro; apply HNC; assert_diffs; assert_cols; ColR|split].
intros P Q HOut1 HNE1 HPer HCop1.
destruct (segment_construction_2 C B B P) as [P' [H HCong2]]; [assert_diffs; auto|].
assert (HOut2 : Out B C P') by (assert_diffs; repeat (split; auto)); clear H.
destruct (ex_perp_cop B C P' A) as [Q' [HPerp2 HCop2]]; [assert_diffs; auto|].
assert (HPerp3 : Perp B A Q P).
assert (Coplanar B P P' P) by Cop.
assert (Coplanar A B C P) by Cop.
assert (Coplanar B Q A C) by (assert_diffs; apply col2_cop__cop with A D; Col; Cop).
assert (Coplanar A B C P') by Cop.

*****
H2 : Coplanar A B C P'
H1 : Coplanar B Q A C
H0 : Coplanar A B C P
H : Coplanar B P P' P
HPerp3 : Perp B A Q P
HCop2 : Coplanar B C A Q'
HPerp2 : Perp B C Q' P'
Q' : Tpoint
HOut2 : Out B C P'
HCong2 : Cong B P' B P
P' : Tpoint
HCop1 : Coplanar A B D Q
HPer : Per B P Q
HNE1 : not (eq P Q)
HOut1 : Out B A P
P,Q : Tpoint
HD : Midpoint D A C
D : Tpoint
HNC : not (Col B A C)
HPerp1 : Perp B A C B
HCong1 : Cong B A B C
C,B,A : Tpoint
bla : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Y : Tpoint => and (Out B D Y) (Col P Q Y))
+++++
assert (Coplanar B P P' Q) by CopR.
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro bla.
cut (exists A B C, ~ Col A B C /\\ Acute A B C /\\ forall P Q, Out B A P -> P <> Q -> Per B P Q -> Coplanar A B C Q -> exists Y, Out B C Y /\\ Col P Q Y).
destruct lower_dim_ex as [C [E [D H]]].
assert (HNC : ~ Col C E D) by auto; clear H.
destruct (l8_18_existence D E C) as [B [HC1 HPerp]]; Col.
assert (HF : exists F, Col D E F /\\ B <> F); [|destruct HF as [F [HC2 HNE]]].
destruct (segment_construction_2 F B B C) as [A [H HCong1]]; auto.
assert (HC3 : Col D E A) by (induction H; assert_diffs; assert_cols; ColR).
clear H; assert (HPerp1 : Perp B A C B) by (apply perp_sym; apply perp_col0 with D E; assert_diffs; Perp).
clear HPerp; clear HC1; clear HC2; clear HC3; clear HNE; clear HNC; clear D; clear E; clear F.
assert (HNC := perp_not_col _ _ _ HPerp1).
destruct (midpoint_existence A C) as [D HD]; exists A, B, D.
split; [intro; apply HNC; assert_diffs; assert_cols; ColR|split].
intros P Q HOut1 HNE1 HPer HCop1.
destruct (segment_construction_2 C B B P) as [P' [H HCong2]]; [assert_diffs; auto|].
assert (HOut2 : Out B C P') by (assert_diffs; repeat (split; auto)); clear H.
destruct (ex_perp_cop B C P' A) as [Q' [HPerp2 HCop2]]; [assert_diffs; auto|].
assert (HPerp3 : Perp B A Q P).
assert (Coplanar B P P' P) by Cop.
assert (Coplanar A B C P) by Cop.
assert (Coplanar B Q A C) by (assert_diffs; apply col2_cop__cop with A D; Col; Cop).
assert (Coplanar A B C P') by Cop.
assert (Coplanar B P P' Q) by CopR.

*****
H3 : Coplanar B P P' Q
H2 : Coplanar A B C P'
H1 : Coplanar B Q A C
H0 : Coplanar A B C P
H : Coplanar B P P' P
HPerp3 : Perp B A Q P
HCop2 : Coplanar B C A Q'
HPerp2 : Perp B C Q' P'
Q' : Tpoint
HOut2 : Out B C P'
HCong2 : Cong B P' B P
P' : Tpoint
HCop1 : Coplanar A B D Q
HPer : Per B P Q
HNE1 : not (eq P Q)
HOut1 : Out B A P
P,Q : Tpoint
HD : Midpoint D A C
D : Tpoint
HNC : not (Col B A C)
HPerp1 : Perp B A C B
HCong1 : Cong B A B C
C,B,A : Tpoint
bla : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Y : Tpoint => and (Out B D Y) (Col P Q Y))
+++++
assert (Coplanar B P P' Q') by CopR.
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro bla.
cut (exists A B C, ~ Col A B C /\\ Acute A B C /\\ forall P Q, Out B A P -> P <> Q -> Per B P Q -> Coplanar A B C Q -> exists Y, Out B C Y /\\ Col P Q Y).
destruct lower_dim_ex as [C [E [D H]]].
assert (HNC : ~ Col C E D) by auto; clear H.
destruct (l8_18_existence D E C) as [B [HC1 HPerp]]; Col.
assert (HF : exists F, Col D E F /\\ B <> F); [|destruct HF as [F [HC2 HNE]]].
destruct (segment_construction_2 F B B C) as [A [H HCong1]]; auto.
assert (HC3 : Col D E A) by (induction H; assert_diffs; assert_cols; ColR).
clear H; assert (HPerp1 : Perp B A C B) by (apply perp_sym; apply perp_col0 with D E; assert_diffs; Perp).
clear HPerp; clear HC1; clear HC2; clear HC3; clear HNE; clear HNC; clear D; clear E; clear F.
assert (HNC := perp_not_col _ _ _ HPerp1).
destruct (midpoint_existence A C) as [D HD]; exists A, B, D.
split; [intro; apply HNC; assert_diffs; assert_cols; ColR|split].
intros P Q HOut1 HNE1 HPer HCop1.
destruct (segment_construction_2 C B B P) as [P' [H HCong2]]; [assert_diffs; auto|].
assert (HOut2 : Out B C P') by (assert_diffs; repeat (split; auto)); clear H.
destruct (ex_perp_cop B C P' A) as [Q' [HPerp2 HCop2]]; [assert_diffs; auto|].
assert (HPerp3 : Perp B A Q P).
assert (Coplanar B P P' P) by Cop.
assert (Coplanar A B C P) by Cop.
assert (Coplanar B Q A C) by (assert_diffs; apply col2_cop__cop with A D; Col; Cop).
assert (Coplanar A B C P') by Cop.
assert (Coplanar B P P' Q) by CopR.
assert (Coplanar B P P' Q') by CopR.

*****
H4 : Coplanar B P P' Q'
H3 : Coplanar B P P' Q
H2 : Coplanar A B C P'
H1 : Coplanar B Q A C
H0 : Coplanar A B C P
H : Coplanar B P P' P
HPerp3 : Perp B A Q P
HCop2 : Coplanar B C A Q'
HPerp2 : Perp B C Q' P'
Q' : Tpoint
HOut2 : Out B C P'
HCong2 : Cong B P' B P
P' : Tpoint
HCop1 : Coplanar A B D Q
HPer : Per B P Q
HNE1 : not (eq P Q)
HOut1 : Out B A P
P,Q : Tpoint
HD : Midpoint D A C
D : Tpoint
HNC : not (Col B A C)
HPerp1 : Perp B A C B
HCong1 : Cong B A B C
C,B,A : Tpoint
bla : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Y : Tpoint => and (Out B D Y) (Col P Q Y))
+++++
destruct (bla B A B C P Q P' Q' B P P') as [I [HC1 HC2]]; Col; Perp; Cop; try (intro; apply HNC; assert_diffs; assert_cols; ColR).
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro bla.
cut (exists A B C, ~ Col A B C /\\ Acute A B C /\\ forall P Q, Out B A P -> P <> Q -> Per B P Q -> Coplanar A B C Q -> exists Y, Out B C Y /\\ Col P Q Y).
destruct lower_dim_ex as [C [E [D H]]].
assert (HNC : ~ Col C E D) by auto; clear H.
destruct (l8_18_existence D E C) as [B [HC1 HPerp]]; Col.
assert (HF : exists F, Col D E F /\\ B <> F); [|destruct HF as [F [HC2 HNE]]].
destruct (segment_construction_2 F B B C) as [A [H HCong1]]; auto.
assert (HC3 : Col D E A) by (induction H; assert_diffs; assert_cols; ColR).
clear H; assert (HPerp1 : Perp B A C B) by (apply perp_sym; apply perp_col0 with D E; assert_diffs; Perp).
clear HPerp; clear HC1; clear HC2; clear HC3; clear HNE; clear HNC; clear D; clear E; clear F.
assert (HNC := perp_not_col _ _ _ HPerp1).
destruct (midpoint_existence A C) as [D HD]; exists A, B, D.
split; [intro; apply HNC; assert_diffs; assert_cols; ColR|split].
intros P Q HOut1 HNE1 HPer HCop1.
destruct (segment_construction_2 C B B P) as [P' [H HCong2]]; [assert_diffs; auto|].
assert (HOut2 : Out B C P') by (assert_diffs; repeat (split; auto)); clear H.
destruct (ex_perp_cop B C P' A) as [Q' [HPerp2 HCop2]]; [assert_diffs; auto|].
assert (HPerp3 : Perp B A Q P).
assert (Coplanar B P P' P) by Cop.
assert (Coplanar A B C P) by Cop.
assert (Coplanar B Q A C) by (assert_diffs; apply col2_cop__cop with A D; Col; Cop).
assert (Coplanar A B C P') by Cop.
assert (Coplanar B P P' Q) by CopR.
assert (Coplanar B P P' Q') by CopR.
destruct (bla B A B C P Q P' Q' B P P') as [I [HC1 HC2]]; Col; Perp; Cop; try (intro; apply HNC; assert_diffs; assert_cols; ColR).

*****
HC2 : Col P' Q' I
HC1 : Col P Q I
I : Tpoint
H4 : Coplanar B P P' Q'
H3 : Coplanar B P P' Q
H2 : Coplanar A B C P'
H1 : Coplanar B Q A C
H0 : Coplanar A B C P
H : Coplanar B P P' P
HPerp3 : Perp B A Q P
HCop2 : Coplanar B C A Q'
HPerp2 : Perp B C Q' P'
Q' : Tpoint
HOut2 : Out B C P'
HCong2 : Cong B P' B P
P' : Tpoint
HCop1 : Coplanar A B D Q
HPer : Per B P Q
HNE1 : not (eq P Q)
HOut1 : Out B A P
P,Q : Tpoint
HD : Midpoint D A C
D : Tpoint
HNC : not (Col B A C)
HPerp1 : Perp B A C B
HCong1 : Cong B A B C
C,B,A : Tpoint
bla : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Y : Tpoint => and (Out B D Y) (Col P Q Y))
+++++
assert (HNE2 : B <> D) by (intro; treat_equalities; apply HNC; assert_cols; Col).
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro bla.
cut (exists A B C, ~ Col A B C /\\ Acute A B C /\\ forall P Q, Out B A P -> P <> Q -> Per B P Q -> Coplanar A B C Q -> exists Y, Out B C Y /\\ Col P Q Y).
destruct lower_dim_ex as [C [E [D H]]].
assert (HNC : ~ Col C E D) by auto; clear H.
destruct (l8_18_existence D E C) as [B [HC1 HPerp]]; Col.
assert (HF : exists F, Col D E F /\\ B <> F); [|destruct HF as [F [HC2 HNE]]].
destruct (segment_construction_2 F B B C) as [A [H HCong1]]; auto.
assert (HC3 : Col D E A) by (induction H; assert_diffs; assert_cols; ColR).
clear H; assert (HPerp1 : Perp B A C B) by (apply perp_sym; apply perp_col0 with D E; assert_diffs; Perp).
clear HPerp; clear HC1; clear HC2; clear HC3; clear HNE; clear HNC; clear D; clear E; clear F.
assert (HNC := perp_not_col _ _ _ HPerp1).
destruct (midpoint_existence A C) as [D HD]; exists A, B, D.
split; [intro; apply HNC; assert_diffs; assert_cols; ColR|split].
intros P Q HOut1 HNE1 HPer HCop1.
destruct (segment_construction_2 C B B P) as [P' [H HCong2]]; [assert_diffs; auto|].
assert (HOut2 : Out B C P') by (assert_diffs; repeat (split; auto)); clear H.
destruct (ex_perp_cop B C P' A) as [Q' [HPerp2 HCop2]]; [assert_diffs; auto|].
assert (HPerp3 : Perp B A Q P).
assert (Coplanar B P P' P) by Cop.
assert (Coplanar A B C P) by Cop.
assert (Coplanar B Q A C) by (assert_diffs; apply col2_cop__cop with A D; Col; Cop).
assert (Coplanar A B C P') by Cop.
assert (Coplanar B P P' Q) by CopR.
assert (Coplanar B P P' Q') by CopR.
destruct (bla B A B C P Q P' Q' B P P') as [I [HC1 HC2]]; Col; Perp; Cop; try (intro; apply HNC; assert_diffs; assert_cols; ColR).
assert (HNE2 : B <> D) by (intro; treat_equalities; apply HNC; assert_cols; Col).

*****
HNE2 : not (eq B D)
HC2 : Col P' Q' I
HC1 : Col P Q I
I : Tpoint
H4 : Coplanar B P P' Q'
H3 : Coplanar B P P' Q
H2 : Coplanar A B C P'
H1 : Coplanar B Q A C
H0 : Coplanar A B C P
H : Coplanar B P P' P
HPerp3 : Perp B A Q P
HCop2 : Coplanar B C A Q'
HPerp2 : Perp B C Q' P'
Q' : Tpoint
HOut2 : Out B C P'
HCong2 : Cong B P' B P
P' : Tpoint
HCop1 : Coplanar A B D Q
HPer : Per B P Q
HNE1 : not (eq P Q)
HOut1 : Out B A P
P,Q : Tpoint
HD : Midpoint D A C
D : Tpoint
HNC : not (Col B A C)
HPerp1 : Perp B A C B
HCong1 : Cong B A B C
C,B,A : Tpoint
bla : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Y : Tpoint => and (Out B D Y) (Col P Q Y))
+++++
assert (HOS : OS B C P I).
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro bla.
cut (exists A B C, ~ Col A B C /\\ Acute A B C /\\ forall P Q, Out B A P -> P <> Q -> Per B P Q -> Coplanar A B C Q -> exists Y, Out B C Y /\\ Col P Q Y).
destruct lower_dim_ex as [C [E [D H]]].
assert (HNC : ~ Col C E D) by auto; clear H.
destruct (l8_18_existence D E C) as [B [HC1 HPerp]]; Col.
assert (HF : exists F, Col D E F /\\ B <> F); [|destruct HF as [F [HC2 HNE]]].
destruct (segment_construction_2 F B B C) as [A [H HCong1]]; auto.
assert (HC3 : Col D E A) by (induction H; assert_diffs; assert_cols; ColR).
clear H; assert (HPerp1 : Perp B A C B) by (apply perp_sym; apply perp_col0 with D E; assert_diffs; Perp).
clear HPerp; clear HC1; clear HC2; clear HC3; clear HNE; clear HNC; clear D; clear E; clear F.
assert (HNC := perp_not_col _ _ _ HPerp1).
destruct (midpoint_existence A C) as [D HD]; exists A, B, D.
split; [intro; apply HNC; assert_diffs; assert_cols; ColR|split].
intros P Q HOut1 HNE1 HPer HCop1.
destruct (segment_construction_2 C B B P) as [P' [H HCong2]]; [assert_diffs; auto|].
assert (HOut2 : Out B C P') by (assert_diffs; repeat (split; auto)); clear H.
destruct (ex_perp_cop B C P' A) as [Q' [HPerp2 HCop2]]; [assert_diffs; auto|].
assert (HPerp3 : Perp B A Q P).
assert (Coplanar B P P' P) by Cop.
assert (Coplanar A B C P) by Cop.
assert (Coplanar B Q A C) by (assert_diffs; apply col2_cop__cop with A D; Col; Cop).
assert (Coplanar A B C P') by Cop.
assert (Coplanar B P P' Q) by CopR.
assert (Coplanar B P P' Q') by CopR.
destruct (bla B A B C P Q P' Q' B P P') as [I [HC1 HC2]]; Col; Perp; Cop; try (intro; apply HNC; assert_diffs; assert_cols; ColR).
assert (HNE2 : B <> D) by (intro; treat_equalities; apply HNC; assert_cols; Col).
assert (HOS : OS B C P I).

*****
HNE2 : not (eq B D)
HC2 : Col P' Q' I
HC1 : Col P Q I
I : Tpoint
H4 : Coplanar B P P' Q'
H3 : Coplanar B P P' Q
H2 : Coplanar A B C P'
H1 : Coplanar B Q A C
H0 : Coplanar A B C P
H : Coplanar B P P' P
HPerp3 : Perp B A Q P
HCop2 : Coplanar B C A Q'
HPerp2 : Perp B C Q' P'
Q' : Tpoint
HOut2 : Out B C P'
HCong2 : Cong B P' B P
P' : Tpoint
HCop1 : Coplanar A B D Q
HPer : Per B P Q
HNE1 : not (eq P Q)
HOut1 : Out B A P
P,Q : Tpoint
HD : Midpoint D A C
D : Tpoint
HNC : not (Col B A C)
HPerp1 : Perp B A C B
HCong1 : Cong B A B C
C,B,A : Tpoint
bla : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OS B C P I
+++++
apply l12_6; apply par_strict_col_par_strict with Q; Col.
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro bla.
cut (exists A B C, ~ Col A B C /\\ Acute A B C /\\ forall P Q, Out B A P -> P <> Q -> Per B P Q -> Coplanar A B C Q -> exists Y, Out B C Y /\\ Col P Q Y).
destruct lower_dim_ex as [C [E [D H]]].
assert (HNC : ~ Col C E D) by auto; clear H.
destruct (l8_18_existence D E C) as [B [HC1 HPerp]]; Col.
assert (HF : exists F, Col D E F /\\ B <> F); [|destruct HF as [F [HC2 HNE]]].
destruct (segment_construction_2 F B B C) as [A [H HCong1]]; auto.
assert (HC3 : Col D E A) by (induction H; assert_diffs; assert_cols; ColR).
clear H; assert (HPerp1 : Perp B A C B) by (apply perp_sym; apply perp_col0 with D E; assert_diffs; Perp).
clear HPerp; clear HC1; clear HC2; clear HC3; clear HNE; clear HNC; clear D; clear E; clear F.
assert (HNC := perp_not_col _ _ _ HPerp1).
destruct (midpoint_existence A C) as [D HD]; exists A, B, D.
split; [intro; apply HNC; assert_diffs; assert_cols; ColR|split].
intros P Q HOut1 HNE1 HPer HCop1.
destruct (segment_construction_2 C B B P) as [P' [H HCong2]]; [assert_diffs; auto|].
assert (HOut2 : Out B C P') by (assert_diffs; repeat (split; auto)); clear H.
destruct (ex_perp_cop B C P' A) as [Q' [HPerp2 HCop2]]; [assert_diffs; auto|].
assert (HPerp3 : Perp B A Q P).
assert (Coplanar B P P' P) by Cop.
assert (Coplanar A B C P) by Cop.
assert (Coplanar B Q A C) by (assert_diffs; apply col2_cop__cop with A D; Col; Cop).
assert (Coplanar A B C P') by Cop.
assert (Coplanar B P P' Q) by CopR.
assert (Coplanar B P P' Q') by CopR.
destruct (bla B A B C P Q P' Q' B P P') as [I [HC1 HC2]]; Col; Perp; Cop; try (intro; apply HNC; assert_diffs; assert_cols; ColR).
assert (HNE2 : B <> D) by (intro; treat_equalities; apply HNC; assert_cols; Col).
assert (HOS : OS B C P I).
apply l12_6; apply par_strict_col_par_strict with Q; Col.

*****
HNE2 : not (eq B D)
HC2 : Col P' Q' I
HC1 : Col P Q I
I : Tpoint
H4 : Coplanar B P P' Q'
H3 : Coplanar B P P' Q
H2 : Coplanar A B C P'
H1 : Coplanar B Q A C
H0 : Coplanar A B C P
H : Coplanar B P P' P
HPerp3 : Perp B A Q P
HCop2 : Coplanar B C A Q'
HPerp2 : Perp B C Q' P'
Q' : Tpoint
HOut2 : Out B C P'
HCong2 : Cong B P' B P
P' : Tpoint
HCop1 : Coplanar A B D Q
HPer : Per B P Q
HNE1 : not (eq P Q)
HOut1 : Out B A P
P,Q : Tpoint
HD : Midpoint D A C
D : Tpoint
HNC : not (Col B A C)
HPerp1 : Perp B A C B
HCong1 : Cong B A B C
C,B,A : Tpoint
bla : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq P I)
+++++
intro; treat_equalities; apply (perp_not_col _ _ _ HPerp1).
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro bla.
cut (exists A B C, ~ Col A B C /\\ Acute A B C /\\ forall P Q, Out B A P -> P <> Q -> Per B P Q -> Coplanar A B C Q -> exists Y, Out B C Y /\\ Col P Q Y).
destruct lower_dim_ex as [C [E [D H]]].
assert (HNC : ~ Col C E D) by auto; clear H.
destruct (l8_18_existence D E C) as [B [HC1 HPerp]]; Col.
assert (HF : exists F, Col D E F /\\ B <> F); [|destruct HF as [F [HC2 HNE]]].
destruct (segment_construction_2 F B B C) as [A [H HCong1]]; auto.
assert (HC3 : Col D E A) by (induction H; assert_diffs; assert_cols; ColR).
clear H; assert (HPerp1 : Perp B A C B) by (apply perp_sym; apply perp_col0 with D E; assert_diffs; Perp).
clear HPerp; clear HC1; clear HC2; clear HC3; clear HNE; clear HNC; clear D; clear E; clear F.
assert (HNC := perp_not_col _ _ _ HPerp1).
destruct (midpoint_existence A C) as [D HD]; exists A, B, D.
split; [intro; apply HNC; assert_diffs; assert_cols; ColR|split].
intros P Q HOut1 HNE1 HPer HCop1.
destruct (segment_construction_2 C B B P) as [P' [H HCong2]]; [assert_diffs; auto|].
assert (HOut2 : Out B C P') by (assert_diffs; repeat (split; auto)); clear H.
destruct (ex_perp_cop B C P' A) as [Q' [HPerp2 HCop2]]; [assert_diffs; auto|].
assert (HPerp3 : Perp B A Q P).
assert (Coplanar B P P' P) by Cop.
assert (Coplanar A B C P) by Cop.
assert (Coplanar B Q A C) by (assert_diffs; apply col2_cop__cop with A D; Col; Cop).
assert (Coplanar A B C P') by Cop.
assert (Coplanar B P P' Q) by CopR.
assert (Coplanar B P P' Q') by CopR.
destruct (bla B A B C P Q P' Q' B P P') as [I [HC1 HC2]]; Col; Perp; Cop; try (intro; apply HNC; assert_diffs; assert_cols; ColR).
assert (HNE2 : B <> D) by (intro; treat_equalities; apply HNC; assert_cols; Col).
assert (HOS : OS B C P I).
apply l12_6; apply par_strict_col_par_strict with Q; Col.
intro; treat_equalities; apply (perp_not_col _ _ _ HPerp1).

*****
HNE2 : not (eq B D)
HC2 : Col P' Q' P
H4 : Coplanar B P P' Q'
H3 : Coplanar B P P' Q
H2 : Coplanar A B C P'
H1 : Coplanar B Q A C
H0 : Coplanar A B C P
H : Coplanar B P P' P
HPerp3 : Perp B A Q P
HCop2 : Coplanar B C A Q'
HPerp2 : Perp B C Q' P'
Q' : Tpoint
HOut2 : Out B C P'
HCong2 : Cong B P' B P
P' : Tpoint
HCop1 : Coplanar A B D Q
HPer : Per B P Q
HNE1 : not (eq P Q)
HOut1 : Out B A P
P,Q : Tpoint
HD : Midpoint D A C
D : Tpoint
HNC : not (Col B A C)
HPerp1 : Perp B A C B
HCong1 : Cong B A B C
C,B,A : Tpoint
bla : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col B A C
+++++
destruct (not_strict_par A B P' Q' P) as [HC3 HC4]; try apply l12_9 with B C; Perp; try solve[assert_cols; Col]; Cop.
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro bla.
cut (exists A B C, ~ Col A B C /\\ Acute A B C /\\ forall P Q, Out B A P -> P <> Q -> Per B P Q -> Coplanar A B C Q -> exists Y, Out B C Y /\\ Col P Q Y).
destruct lower_dim_ex as [C [E [D H]]].
assert (HNC : ~ Col C E D) by auto; clear H.
destruct (l8_18_existence D E C) as [B [HC1 HPerp]]; Col.
assert (HF : exists F, Col D E F /\\ B <> F); [|destruct HF as [F [HC2 HNE]]].
destruct (segment_construction_2 F B B C) as [A [H HCong1]]; auto.
assert (HC3 : Col D E A) by (induction H; assert_diffs; assert_cols; ColR).
clear H; assert (HPerp1 : Perp B A C B) by (apply perp_sym; apply perp_col0 with D E; assert_diffs; Perp).
clear HPerp; clear HC1; clear HC2; clear HC3; clear HNE; clear HNC; clear D; clear E; clear F.
assert (HNC := perp_not_col _ _ _ HPerp1).
destruct (midpoint_existence A C) as [D HD]; exists A, B, D.
split; [intro; apply HNC; assert_diffs; assert_cols; ColR|split].
intros P Q HOut1 HNE1 HPer HCop1.
destruct (segment_construction_2 C B B P) as [P' [H HCong2]]; [assert_diffs; auto|].
assert (HOut2 : Out B C P') by (assert_diffs; repeat (split; auto)); clear H.
destruct (ex_perp_cop B C P' A) as [Q' [HPerp2 HCop2]]; [assert_diffs; auto|].
assert (HPerp3 : Perp B A Q P).
assert (Coplanar B P P' P) by Cop.
assert (Coplanar A B C P) by Cop.
assert (Coplanar B Q A C) by (assert_diffs; apply col2_cop__cop with A D; Col; Cop).
assert (Coplanar A B C P') by Cop.
assert (Coplanar B P P' Q) by CopR.
assert (Coplanar B P P' Q') by CopR.
destruct (bla B A B C P Q P' Q' B P P') as [I [HC1 HC2]]; Col; Perp; Cop; try (intro; apply HNC; assert_diffs; assert_cols; ColR).
assert (HNE2 : B <> D) by (intro; treat_equalities; apply HNC; assert_cols; Col).
assert (HOS : OS B C P I).
apply l12_6; apply par_strict_col_par_strict with Q; Col.
intro; treat_equalities; apply (perp_not_col _ _ _ HPerp1).
destruct (not_strict_par A B P' Q' P) as [HC3 HC4]; try apply l12_9 with B C; Perp; try solve[assert_cols; Col]; Cop.

*****
HC4 : Col A B Q'
HC3 : Col A B P'
HNE2 : not (eq B D)
HC2 : Col P' Q' P
H4 : Coplanar B P P' Q'
H3 : Coplanar B P P' Q
H2 : Coplanar A B C P'
H1 : Coplanar B Q A C
H0 : Coplanar A B C P
H : Coplanar B P P' P
HPerp3 : Perp B A Q P
HCop2 : Coplanar B C A Q'
HPerp2 : Perp B C Q' P'
Q' : Tpoint
HOut2 : Out B C P'
HCong2 : Cong B P' B P
P' : Tpoint
HCop1 : Coplanar A B D Q
HPer : Per B P Q
HNE1 : not (eq P Q)
HOut1 : Out B A P
P,Q : Tpoint
HD : Midpoint D A C
D : Tpoint
HNC : not (Col B A C)
HPerp1 : Perp B A C B
HCong1 : Cong B A B C
C,B,A : Tpoint
bla : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col B A C
+++++
assert_diffs; assert_cols; ColR.
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro bla.
cut (exists A B C, ~ Col A B C /\\ Acute A B C /\\ forall P Q, Out B A P -> P <> Q -> Per B P Q -> Coplanar A B C Q -> exists Y, Out B C Y /\\ Col P Q Y).
destruct lower_dim_ex as [C [E [D H]]].
assert (HNC : ~ Col C E D) by auto; clear H.
destruct (l8_18_existence D E C) as [B [HC1 HPerp]]; Col.
assert (HF : exists F, Col D E F /\\ B <> F); [|destruct HF as [F [HC2 HNE]]].
destruct (segment_construction_2 F B B C) as [A [H HCong1]]; auto.
assert (HC3 : Col D E A) by (induction H; assert_diffs; assert_cols; ColR).
clear H; assert (HPerp1 : Perp B A C B) by (apply perp_sym; apply perp_col0 with D E; assert_diffs; Perp).
clear HPerp; clear HC1; clear HC2; clear HC3; clear HNE; clear HNC; clear D; clear E; clear F.
assert (HNC := perp_not_col _ _ _ HPerp1).
destruct (midpoint_existence A C) as [D HD]; exists A, B, D.
split; [intro; apply HNC; assert_diffs; assert_cols; ColR|split].
intros P Q HOut1 HNE1 HPer HCop1.
destruct (segment_construction_2 C B B P) as [P' [H HCong2]]; [assert_diffs; auto|].
assert (HOut2 : Out B C P') by (assert_diffs; repeat (split; auto)); clear H.
destruct (ex_perp_cop B C P' A) as [Q' [HPerp2 HCop2]]; [assert_diffs; auto|].
assert (HPerp3 : Perp B A Q P).
assert (Coplanar B P P' P) by Cop.
assert (Coplanar A B C P) by Cop.
assert (Coplanar B Q A C) by (assert_diffs; apply col2_cop__cop with A D; Col; Cop).
assert (Coplanar A B C P') by Cop.
assert (Coplanar B P P' Q) by CopR.
assert (Coplanar B P P' Q') by CopR.
destruct (bla B A B C P Q P' Q' B P P') as [I [HC1 HC2]]; Col; Perp; Cop; try (intro; apply HNC; assert_diffs; assert_cols; ColR).
assert (HNE2 : B <> D) by (intro; treat_equalities; apply HNC; assert_cols; Col).
assert (HOS : OS B C P I).
apply l12_6; apply par_strict_col_par_strict with Q; Col.

*****
HNE2 : not (eq B D)
HC2 : Col P' Q' I
HC1 : Col P Q I
I : Tpoint
H4 : Coplanar B P P' Q'
H3 : Coplanar B P P' Q
H2 : Coplanar A B C P'
H1 : Coplanar B Q A C
H0 : Coplanar A B C P
H : Coplanar B P P' P
HPerp3 : Perp B A Q P
HCop2 : Coplanar B C A Q'
HPerp2 : Perp B C Q' P'
Q' : Tpoint
HOut2 : Out B C P'
HCong2 : Cong B P' B P
P' : Tpoint
HCop1 : Coplanar A B D Q
HPer : Per B P Q
HNE1 : not (eq P Q)
HOut1 : Out B A P
P,Q : Tpoint
HD : Midpoint D A C
D : Tpoint
HNC : not (Col B A C)
HPerp1 : Perp B A C B
HCong1 : Cong B A B C
C,B,A : Tpoint
bla : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Par_strict B C P Q
+++++
apply par_not_col_strict with P; try apply l12_9 with A B; Perp; Col; Cop.
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro bla.
cut (exists A B C, ~ Col A B C /\\ Acute A B C /\\ forall P Q, Out B A P -> P <> Q -> Per B P Q -> Coplanar A B C Q -> exists Y, Out B C Y /\\ Col P Q Y).
destruct lower_dim_ex as [C [E [D H]]].
assert (HNC : ~ Col C E D) by auto; clear H.
destruct (l8_18_existence D E C) as [B [HC1 HPerp]]; Col.
assert (HF : exists F, Col D E F /\\ B <> F); [|destruct HF as [F [HC2 HNE]]].
destruct (segment_construction_2 F B B C) as [A [H HCong1]]; auto.
assert (HC3 : Col D E A) by (induction H; assert_diffs; assert_cols; ColR).
clear H; assert (HPerp1 : Perp B A C B) by (apply perp_sym; apply perp_col0 with D E; assert_diffs; Perp).
clear HPerp; clear HC1; clear HC2; clear HC3; clear HNE; clear HNC; clear D; clear E; clear F.
assert (HNC := perp_not_col _ _ _ HPerp1).
destruct (midpoint_existence A C) as [D HD]; exists A, B, D.
split; [intro; apply HNC; assert_diffs; assert_cols; ColR|split].
intros P Q HOut1 HNE1 HPer HCop1.
destruct (segment_construction_2 C B B P) as [P' [H HCong2]]; [assert_diffs; auto|].
assert (HOut2 : Out B C P') by (assert_diffs; repeat (split; auto)); clear H.
destruct (ex_perp_cop B C P' A) as [Q' [HPerp2 HCop2]]; [assert_diffs; auto|].
assert (HPerp3 : Perp B A Q P).
assert (Coplanar B P P' P) by Cop.
assert (Coplanar A B C P) by Cop.
assert (Coplanar B Q A C) by (assert_diffs; apply col2_cop__cop with A D; Col; Cop).
assert (Coplanar A B C P') by Cop.
assert (Coplanar B P P' Q) by CopR.
assert (Coplanar B P P' Q') by CopR.
destruct (bla B A B C P Q P' Q' B P P') as [I [HC1 HC2]]; Col; Perp; Cop; try (intro; apply HNC; assert_diffs; assert_cols; ColR).
assert (HNE2 : B <> D) by (intro; treat_equalities; apply HNC; assert_cols; Col).
assert (HOS : OS B C P I).
apply l12_6; apply par_strict_col_par_strict with Q; Col.
apply par_not_col_strict with P; try apply l12_9 with A B; Perp; Col; Cop.

*****
HNE2 : not (eq B D)
HC2 : Col P' Q' I
HC1 : Col P Q I
I : Tpoint
H4 : Coplanar B P P' Q'
H3 : Coplanar B P P' Q
H2 : Coplanar A B C P'
H1 : Coplanar B Q A C
H0 : Coplanar A B C P
H : Coplanar B P P' P
HPerp3 : Perp B A Q P
HCop2 : Coplanar B C A Q'
HPerp2 : Perp B C Q' P'
Q' : Tpoint
HOut2 : Out B C P'
HCong2 : Cong B P' B P
P' : Tpoint
HCop1 : Coplanar A B D Q
HPer : Per B P Q
HNE1 : not (eq P Q)
HOut1 : Out B A P
P,Q : Tpoint
HD : Midpoint D A C
D : Tpoint
HNC : not (Col B A C)
HPerp1 : Perp B A C B
HCong1 : Cong B A B C
C,B,A : Tpoint
bla : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col B C P)
+++++
intro; apply HNC; assert_diffs; assert_cols; ColR.
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro bla.
cut (exists A B C, ~ Col A B C /\\ Acute A B C /\\ forall P Q, Out B A P -> P <> Q -> Per B P Q -> Coplanar A B C Q -> exists Y, Out B C Y /\\ Col P Q Y).
destruct lower_dim_ex as [C [E [D H]]].
assert (HNC : ~ Col C E D) by auto; clear H.
destruct (l8_18_existence D E C) as [B [HC1 HPerp]]; Col.
assert (HF : exists F, Col D E F /\\ B <> F); [|destruct HF as [F [HC2 HNE]]].
destruct (segment_construction_2 F B B C) as [A [H HCong1]]; auto.
assert (HC3 : Col D E A) by (induction H; assert_diffs; assert_cols; ColR).
clear H; assert (HPerp1 : Perp B A C B) by (apply perp_sym; apply perp_col0 with D E; assert_diffs; Perp).
clear HPerp; clear HC1; clear HC2; clear HC3; clear HNE; clear HNC; clear D; clear E; clear F.
assert (HNC := perp_not_col _ _ _ HPerp1).
destruct (midpoint_existence A C) as [D HD]; exists A, B, D.
split; [intro; apply HNC; assert_diffs; assert_cols; ColR|split].
intros P Q HOut1 HNE1 HPer HCop1.
destruct (segment_construction_2 C B B P) as [P' [H HCong2]]; [assert_diffs; auto|].
assert (HOut2 : Out B C P') by (assert_diffs; repeat (split; auto)); clear H.
destruct (ex_perp_cop B C P' A) as [Q' [HPerp2 HCop2]]; [assert_diffs; auto|].
assert (HPerp3 : Perp B A Q P).
assert (Coplanar B P P' P) by Cop.
assert (Coplanar A B C P) by Cop.
assert (Coplanar B Q A C) by (assert_diffs; apply col2_cop__cop with A D; Col; Cop).
assert (Coplanar A B C P') by Cop.
assert (Coplanar B P P' Q) by CopR.
assert (Coplanar B P P' Q') by CopR.
destruct (bla B A B C P Q P' Q' B P P') as [I [HC1 HC2]]; Col; Perp; Cop; try (intro; apply HNC; assert_diffs; assert_cols; ColR).
assert (HNE2 : B <> D) by (intro; treat_equalities; apply HNC; assert_cols; Col).
assert (HOS : OS B C P I).

*****
HOS : OS B C P I
HNE2 : not (eq B D)
HC2 : Col P' Q' I
HC1 : Col P Q I
I : Tpoint
H4 : Coplanar B P P' Q'
H3 : Coplanar B P P' Q
H2 : Coplanar A B C P'
H1 : Coplanar B Q A C
H0 : Coplanar A B C P
H : Coplanar B P P' P
HPerp3 : Perp B A Q P
HCop2 : Coplanar B C A Q'
HPerp2 : Perp B C Q' P'
Q' : Tpoint
HOut2 : Out B C P'
HCong2 : Cong B P' B P
P' : Tpoint
HCop1 : Coplanar A B D Q
HPer : Per B P Q
HNE1 : not (eq P Q)
HOut1 : Out B A P
P,Q : Tpoint
HD : Midpoint D A C
D : Tpoint
HNC : not (Col B A C)
HPerp1 : Perp B A C B
HCong1 : Cong B A B C
C,B,A : Tpoint
bla : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Y : Tpoint => and (Out B D Y) (Col P Q Y))
+++++
exists I; split; Col; apply l6_4_2; split; try (intro; apply (l9_9_bis _ _ _ _ HOS)).
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro bla.
cut (exists A B C, ~ Col A B C /\\ Acute A B C /\\ forall P Q, Out B A P -> P <> Q -> Per B P Q -> Coplanar A B C Q -> exists Y, Out B C Y /\\ Col P Q Y).
destruct lower_dim_ex as [C [E [D H]]].
assert (HNC : ~ Col C E D) by auto; clear H.
destruct (l8_18_existence D E C) as [B [HC1 HPerp]]; Col.
assert (HF : exists F, Col D E F /\\ B <> F); [|destruct HF as [F [HC2 HNE]]].
destruct (segment_construction_2 F B B C) as [A [H HCong1]]; auto.
assert (HC3 : Col D E A) by (induction H; assert_diffs; assert_cols; ColR).
clear H; assert (HPerp1 : Perp B A C B) by (apply perp_sym; apply perp_col0 with D E; assert_diffs; Perp).
clear HPerp; clear HC1; clear HC2; clear HC3; clear HNE; clear HNC; clear D; clear E; clear F.
assert (HNC := perp_not_col _ _ _ HPerp1).
destruct (midpoint_existence A C) as [D HD]; exists A, B, D.
split; [intro; apply HNC; assert_diffs; assert_cols; ColR|split].
intros P Q HOut1 HNE1 HPer HCop1.
destruct (segment_construction_2 C B B P) as [P' [H HCong2]]; [assert_diffs; auto|].
assert (HOut2 : Out B C P') by (assert_diffs; repeat (split; auto)); clear H.
destruct (ex_perp_cop B C P' A) as [Q' [HPerp2 HCop2]]; [assert_diffs; auto|].
assert (HPerp3 : Perp B A Q P).
assert (Coplanar B P P' P) by Cop.
assert (Coplanar A B C P) by Cop.
assert (Coplanar B Q A C) by (assert_diffs; apply col2_cop__cop with A D; Col; Cop).
assert (Coplanar A B C P') by Cop.
assert (Coplanar B P P' Q) by CopR.
assert (Coplanar B P P' Q') by CopR.
destruct (bla B A B C P Q P' Q' B P P') as [I [HC1 HC2]]; Col; Perp; Cop; try (intro; apply HNC; assert_diffs; assert_cols; ColR).
assert (HNE2 : B <> D) by (intro; treat_equalities; apply HNC; assert_cols; Col).
assert (HOS : OS B C P I).
exists I; split; Col; apply l6_4_2; split; try (intro; apply (l9_9_bis _ _ _ _ HOS)).

*****
HOS : OS B C P I
HNE2 : not (eq B D)
HC2 : Col P' Q' I
HC1 : Col P Q I
I : Tpoint
H4 : Coplanar B P P' Q'
H3 : Coplanar B P P' Q
H2 : Coplanar A B C P'
H1 : Coplanar B Q A C
H0 : Coplanar A B C P
H : Coplanar B P P' P
HPerp3 : Perp B A Q P
HCop2 : Coplanar B C A Q'
HPerp2 : Perp B C Q' P'
Q' : Tpoint
HOut2 : Out B C P'
HCong2 : Cong B P' B P
P' : Tpoint
HCop1 : Coplanar A B D Q
HPer : Per B P Q
HNE1 : not (eq P Q)
HOut1 : Out B A P
P,Q : Tpoint
HD : Midpoint D A C
D : Tpoint
HNC : not (Col B A C)
HPerp1 : Perp B A C B
HCong1 : Cong B A B C
C,B,A : Tpoint
bla : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col D B I
+++++
assert (Coplanar A B C I) by (apply col_cop2__cop with P Q; Cop).
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro bla.
cut (exists A B C, ~ Col A B C /\\ Acute A B C /\\ forall P Q, Out B A P -> P <> Q -> Per B P Q -> Coplanar A B C Q -> exists Y, Out B C Y /\\ Col P Q Y).
destruct lower_dim_ex as [C [E [D H]]].
assert (HNC : ~ Col C E D) by auto; clear H.
destruct (l8_18_existence D E C) as [B [HC1 HPerp]]; Col.
assert (HF : exists F, Col D E F /\\ B <> F); [|destruct HF as [F [HC2 HNE]]].
destruct (segment_construction_2 F B B C) as [A [H HCong1]]; auto.
assert (HC3 : Col D E A) by (induction H; assert_diffs; assert_cols; ColR).
clear H; assert (HPerp1 : Perp B A C B) by (apply perp_sym; apply perp_col0 with D E; assert_diffs; Perp).
clear HPerp; clear HC1; clear HC2; clear HC3; clear HNE; clear HNC; clear D; clear E; clear F.
assert (HNC := perp_not_col _ _ _ HPerp1).
destruct (midpoint_existence A C) as [D HD]; exists A, B, D.
split; [intro; apply HNC; assert_diffs; assert_cols; ColR|split].
intros P Q HOut1 HNE1 HPer HCop1.
destruct (segment_construction_2 C B B P) as [P' [H HCong2]]; [assert_diffs; auto|].
assert (HOut2 : Out B C P') by (assert_diffs; repeat (split; auto)); clear H.
destruct (ex_perp_cop B C P' A) as [Q' [HPerp2 HCop2]]; [assert_diffs; auto|].
assert (HPerp3 : Perp B A Q P).
assert (Coplanar B P P' P) by Cop.
assert (Coplanar A B C P) by Cop.
assert (Coplanar B Q A C) by (assert_diffs; apply col2_cop__cop with A D; Col; Cop).
assert (Coplanar A B C P') by Cop.
assert (Coplanar B P P' Q) by CopR.
assert (Coplanar B P P' Q') by CopR.
destruct (bla B A B C P Q P' Q' B P P') as [I [HC1 HC2]]; Col; Perp; Cop; try (intro; apply HNC; assert_diffs; assert_cols; ColR).
assert (HNE2 : B <> D) by (intro; treat_equalities; apply HNC; assert_cols; Col).
assert (HOS : OS B C P I).
exists I; split; Col; apply l6_4_2; split; try (intro; apply (l9_9_bis _ _ _ _ HOS)).
assert (Coplanar A B C I) by (apply col_cop2__cop with P Q; Cop).

*****
H5 : Coplanar A B C I
HOS : OS B C P I
HNE2 : not (eq B D)
HC2 : Col P' Q' I
HC1 : Col P Q I
I : Tpoint
H4 : Coplanar B P P' Q'
H3 : Coplanar B P P' Q
H2 : Coplanar A B C P'
H1 : Coplanar B Q A C
H0 : Coplanar A B C P
H : Coplanar B P P' P
HPerp3 : Perp B A Q P
HCop2 : Coplanar B C A Q'
HPerp2 : Perp B C Q' P'
Q' : Tpoint
HOut2 : Out B C P'
HCong2 : Cong B P' B P
P' : Tpoint
HCop1 : Coplanar A B D Q
HPer : Per B P Q
HNE1 : not (eq P Q)
HOut1 : Out B A P
P,Q : Tpoint
HD : Midpoint D A C
D : Tpoint
HNC : not (Col B A C)
HPerp1 : Perp B A C B
HCong1 : Cong B A B C
C,B,A : Tpoint
bla : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col D B I
+++++
assert (Coplanar A B C D) by Cop.
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro bla.
cut (exists A B C, ~ Col A B C /\\ Acute A B C /\\ forall P Q, Out B A P -> P <> Q -> Per B P Q -> Coplanar A B C Q -> exists Y, Out B C Y /\\ Col P Q Y).
destruct lower_dim_ex as [C [E [D H]]].
assert (HNC : ~ Col C E D) by auto; clear H.
destruct (l8_18_existence D E C) as [B [HC1 HPerp]]; Col.
assert (HF : exists F, Col D E F /\\ B <> F); [|destruct HF as [F [HC2 HNE]]].
destruct (segment_construction_2 F B B C) as [A [H HCong1]]; auto.
assert (HC3 : Col D E A) by (induction H; assert_diffs; assert_cols; ColR).
clear H; assert (HPerp1 : Perp B A C B) by (apply perp_sym; apply perp_col0 with D E; assert_diffs; Perp).
clear HPerp; clear HC1; clear HC2; clear HC3; clear HNE; clear HNC; clear D; clear E; clear F.
assert (HNC := perp_not_col _ _ _ HPerp1).
destruct (midpoint_existence A C) as [D HD]; exists A, B, D.
split; [intro; apply HNC; assert_diffs; assert_cols; ColR|split].
intros P Q HOut1 HNE1 HPer HCop1.
destruct (segment_construction_2 C B B P) as [P' [H HCong2]]; [assert_diffs; auto|].
assert (HOut2 : Out B C P') by (assert_diffs; repeat (split; auto)); clear H.
destruct (ex_perp_cop B C P' A) as [Q' [HPerp2 HCop2]]; [assert_diffs; auto|].
assert (HPerp3 : Perp B A Q P).
assert (Coplanar B P P' P) by Cop.
assert (Coplanar A B C P) by Cop.
assert (Coplanar B Q A C) by (assert_diffs; apply col2_cop__cop with A D; Col; Cop).
assert (Coplanar A B C P') by Cop.
assert (Coplanar B P P' Q) by CopR.
assert (Coplanar B P P' Q') by CopR.
destruct (bla B A B C P Q P' Q' B P P') as [I [HC1 HC2]]; Col; Perp; Cop; try (intro; apply HNC; assert_diffs; assert_cols; ColR).
assert (HNE2 : B <> D) by (intro; treat_equalities; apply HNC; assert_cols; Col).
assert (HOS : OS B C P I).
exists I; split; Col; apply l6_4_2; split; try (intro; apply (l9_9_bis _ _ _ _ HOS)).
assert (Coplanar A B C I) by (apply col_cop2__cop with P Q; Cop).
assert (Coplanar A B C D) by Cop.

*****
H6 : Coplanar A B C D
H5 : Coplanar A B C I
HOS : OS B C P I
HNE2 : not (eq B D)
HC2 : Col P' Q' I
HC1 : Col P Q I
I : Tpoint
H4 : Coplanar B P P' Q'
H3 : Coplanar B P P' Q
H2 : Coplanar A B C P'
H1 : Coplanar B Q A C
H0 : Coplanar A B C P
H : Coplanar B P P' P
HPerp3 : Perp B A Q P
HCop2 : Coplanar B C A Q'
HPerp2 : Perp B C Q' P'
Q' : Tpoint
HOut2 : Out B C P'
HCong2 : Cong B P' B P
P' : Tpoint
HCop1 : Coplanar A B D Q
HPer : Per B P Q
HNE1 : not (eq P Q)
HOut1 : Out B A P
P,Q : Tpoint
HD : Midpoint D A C
D : Tpoint
HNC : not (Col B A C)
HPerp1 : Perp B A C B
HCong1 : Cong B A B C
C,B,A : Tpoint
bla : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col D B I
+++++
elim (eq_dec_points D I); intro HNE3; treat_equalities; Col.
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro bla.
cut (exists A B C, ~ Col A B C /\\ Acute A B C /\\ forall P Q, Out B A P -> P <> Q -> Per B P Q -> Coplanar A B C Q -> exists Y, Out B C Y /\\ Col P Q Y).
destruct lower_dim_ex as [C [E [D H]]].
assert (HNC : ~ Col C E D) by auto; clear H.
destruct (l8_18_existence D E C) as [B [HC1 HPerp]]; Col.
assert (HF : exists F, Col D E F /\\ B <> F); [|destruct HF as [F [HC2 HNE]]].
destruct (segment_construction_2 F B B C) as [A [H HCong1]]; auto.
assert (HC3 : Col D E A) by (induction H; assert_diffs; assert_cols; ColR).
clear H; assert (HPerp1 : Perp B A C B) by (apply perp_sym; apply perp_col0 with D E; assert_diffs; Perp).
clear HPerp; clear HC1; clear HC2; clear HC3; clear HNE; clear HNC; clear D; clear E; clear F.
assert (HNC := perp_not_col _ _ _ HPerp1).
destruct (midpoint_existence A C) as [D HD]; exists A, B, D.
split; [intro; apply HNC; assert_diffs; assert_cols; ColR|split].
intros P Q HOut1 HNE1 HPer HCop1.
destruct (segment_construction_2 C B B P) as [P' [H HCong2]]; [assert_diffs; auto|].
assert (HOut2 : Out B C P') by (assert_diffs; repeat (split; auto)); clear H.
destruct (ex_perp_cop B C P' A) as [Q' [HPerp2 HCop2]]; [assert_diffs; auto|].
assert (HPerp3 : Perp B A Q P).
assert (Coplanar B P P' P) by Cop.
assert (Coplanar A B C P) by Cop.
assert (Coplanar B Q A C) by (assert_diffs; apply col2_cop__cop with A D; Col; Cop).
assert (Coplanar A B C P') by Cop.
assert (Coplanar B P P' Q) by CopR.
assert (Coplanar B P P' Q') by CopR.
destruct (bla B A B C P Q P' Q' B P P') as [I [HC1 HC2]]; Col; Perp; Cop; try (intro; apply HNC; assert_diffs; assert_cols; ColR).
assert (HNE2 : B <> D) by (intro; treat_equalities; apply HNC; assert_cols; Col).
assert (HOS : OS B C P I).
exists I; split; Col; apply l6_4_2; split; try (intro; apply (l9_9_bis _ _ _ _ HOS)).
assert (Coplanar A B C I) by (apply col_cop2__cop with P Q; Cop).
assert (Coplanar A B C D) by Cop.
elim (eq_dec_points D I); intro HNE3; treat_equalities; Col.

*****
HNE3 : not (eq D I)
H6 : Coplanar A B C D
H5 : Coplanar A B C I
HOS : OS B C P I
HNE2 : not (eq B D)
HC2 : Col P' Q' I
HC1 : Col P Q I
I : Tpoint
H4 : Coplanar B P P' Q'
H3 : Coplanar B P P' Q
H2 : Coplanar A B C P'
H1 : Coplanar B Q A C
H0 : Coplanar A B C P
H : Coplanar B P P' P
HPerp3 : Perp B A Q P
HCop2 : Coplanar B C A Q'
HPerp2 : Perp B C Q' P'
Q' : Tpoint
HOut2 : Out B C P'
HCong2 : Cong B P' B P
P' : Tpoint
HCop1 : Coplanar A B D Q
HPer : Per B P Q
HNE1 : not (eq P Q)
HOut1 : Out B A P
P,Q : Tpoint
HD : Midpoint D A C
D : Tpoint
HNC : not (Col B A C)
HPerp1 : Perp B A C B
HCong1 : Cong B A B C
C,B,A : Tpoint
bla : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col D B I
+++++
destruct HD as [_ HD]; apply cop_perp2__col with A C; Cop; apply perp_bisect_perp; apply cong_cop_perp_bisect; try solve[assert_diffs; Cong]; try CopR.
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro bla.
cut (exists A B C, ~ Col A B C /\\ Acute A B C /\\ forall P Q, Out B A P -> P <> Q -> Per B P Q -> Coplanar A B C Q -> exists Y, Out B C Y /\\ Col P Q Y).
destruct lower_dim_ex as [C [E [D H]]].
assert (HNC : ~ Col C E D) by auto; clear H.
destruct (l8_18_existence D E C) as [B [HC1 HPerp]]; Col.
assert (HF : exists F, Col D E F /\\ B <> F); [|destruct HF as [F [HC2 HNE]]].
destruct (segment_construction_2 F B B C) as [A [H HCong1]]; auto.
assert (HC3 : Col D E A) by (induction H; assert_diffs; assert_cols; ColR).
clear H; assert (HPerp1 : Perp B A C B) by (apply perp_sym; apply perp_col0 with D E; assert_diffs; Perp).
clear HPerp; clear HC1; clear HC2; clear HC3; clear HNE; clear HNC; clear D; clear E; clear F.
assert (HNC := perp_not_col _ _ _ HPerp1).
destruct (midpoint_existence A C) as [D HD]; exists A, B, D.
split; [intro; apply HNC; assert_diffs; assert_cols; ColR|split].
intros P Q HOut1 HNE1 HPer HCop1.
destruct (segment_construction_2 C B B P) as [P' [H HCong2]]; [assert_diffs; auto|].
assert (HOut2 : Out B C P') by (assert_diffs; repeat (split; auto)); clear H.
destruct (ex_perp_cop B C P' A) as [Q' [HPerp2 HCop2]]; [assert_diffs; auto|].
assert (HPerp3 : Perp B A Q P).
assert (Coplanar B P P' P) by Cop.
assert (Coplanar A B C P) by Cop.
assert (Coplanar B Q A C) by (assert_diffs; apply col2_cop__cop with A D; Col; Cop).
assert (Coplanar A B C P') by Cop.
assert (Coplanar B P P' Q) by CopR.
assert (Coplanar B P P' Q') by CopR.
destruct (bla B A B C P Q P' Q' B P P') as [I [HC1 HC2]]; Col; Perp; Cop; try (intro; apply HNC; assert_diffs; assert_cols; ColR).
assert (HNE2 : B <> D) by (intro; treat_equalities; apply HNC; assert_cols; Col).
assert (HOS : OS B C P I).
exists I; split; Col; apply l6_4_2; split; try (intro; apply (l9_9_bis _ _ _ _ HOS)).
assert (Coplanar A B C I) by (apply col_cop2__cop with P Q; Cop).
assert (Coplanar A B C D) by Cop.
elim (eq_dec_points D I); intro HNE3; treat_equalities; Col.
destruct HD as [_ HD]; apply cop_perp2__col with A C; Cop; apply perp_bisect_perp; apply cong_cop_perp_bisect; try solve[assert_diffs; Cong]; try CopR.

*****
HNE3 : not (eq D I)
H6 : Coplanar A B C D
H5 : Coplanar A B C I
HOS : OS B C P I
HNE2 : not (eq B D)
HC2 : Col P' Q' I
HC1 : Col P Q I
I : Tpoint
H4 : Coplanar B P P' Q'
H3 : Coplanar B P P' Q
H2 : Coplanar A B C P'
H1 : Coplanar B Q A C
H0 : Coplanar A B C P
H : Coplanar B P P' P
HPerp3 : Perp B A Q P
HCop2 : Coplanar B C A Q'
HPerp2 : Perp B C Q' P'
Q' : Tpoint
HOut2 : Out B C P'
HCong2 : Cong B P' B P
P' : Tpoint
HCop1 : Coplanar A B D Q
HPer : Per B P Q
HNE1 : not (eq P Q)
HOut1 : Out B A P
P,Q : Tpoint
HD : Cong A D D C
D : Tpoint
HNC : not (Col B A C)
HPerp1 : Perp B A C B
HCong1 : Cong B A B C
C,B,A : Tpoint
bla : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong A I C I
+++++
assert (HPerp4 : Perp P I B P).
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro bla.
cut (exists A B C, ~ Col A B C /\\ Acute A B C /\\ forall P Q, Out B A P -> P <> Q -> Per B P Q -> Coplanar A B C Q -> exists Y, Out B C Y /\\ Col P Q Y).
destruct lower_dim_ex as [C [E [D H]]].
assert (HNC : ~ Col C E D) by auto; clear H.
destruct (l8_18_existence D E C) as [B [HC1 HPerp]]; Col.
assert (HF : exists F, Col D E F /\\ B <> F); [|destruct HF as [F [HC2 HNE]]].
destruct (segment_construction_2 F B B C) as [A [H HCong1]]; auto.
assert (HC3 : Col D E A) by (induction H; assert_diffs; assert_cols; ColR).
clear H; assert (HPerp1 : Perp B A C B) by (apply perp_sym; apply perp_col0 with D E; assert_diffs; Perp).
clear HPerp; clear HC1; clear HC2; clear HC3; clear HNE; clear HNC; clear D; clear E; clear F.
assert (HNC := perp_not_col _ _ _ HPerp1).
destruct (midpoint_existence A C) as [D HD]; exists A, B, D.
split; [intro; apply HNC; assert_diffs; assert_cols; ColR|split].
intros P Q HOut1 HNE1 HPer HCop1.
destruct (segment_construction_2 C B B P) as [P' [H HCong2]]; [assert_diffs; auto|].
assert (HOut2 : Out B C P') by (assert_diffs; repeat (split; auto)); clear H.
destruct (ex_perp_cop B C P' A) as [Q' [HPerp2 HCop2]]; [assert_diffs; auto|].
assert (HPerp3 : Perp B A Q P).
assert (Coplanar B P P' P) by Cop.
assert (Coplanar A B C P) by Cop.
assert (Coplanar B Q A C) by (assert_diffs; apply col2_cop__cop with A D; Col; Cop).
assert (Coplanar A B C P') by Cop.
assert (Coplanar B P P' Q) by CopR.
assert (Coplanar B P P' Q') by CopR.
destruct (bla B A B C P Q P' Q' B P P') as [I [HC1 HC2]]; Col; Perp; Cop; try (intro; apply HNC; assert_diffs; assert_cols; ColR).
assert (HNE2 : B <> D) by (intro; treat_equalities; apply HNC; assert_cols; Col).
assert (HOS : OS B C P I).
exists I; split; Col; apply l6_4_2; split; try (intro; apply (l9_9_bis _ _ _ _ HOS)).
assert (Coplanar A B C I) by (apply col_cop2__cop with P Q; Cop).
assert (Coplanar A B C D) by Cop.
elim (eq_dec_points D I); intro HNE3; treat_equalities; Col.
destruct HD as [_ HD]; apply cop_perp2__col with A C; Cop; apply perp_bisect_perp; apply cong_cop_perp_bisect; try solve[assert_diffs; Cong]; try CopR.
assert (HPerp4 : Perp P I B P).

*****
HNE3 : not (eq D I)
H6 : Coplanar A B C D
H5 : Coplanar A B C I
HOS : OS B C P I
HNE2 : not (eq B D)
HC2 : Col P' Q' I
HC1 : Col P Q I
I : Tpoint
H4 : Coplanar B P P' Q'
H3 : Coplanar B P P' Q
H2 : Coplanar A B C P'
H1 : Coplanar B Q A C
H0 : Coplanar A B C P
H : Coplanar B P P' P
HPerp3 : Perp B A Q P
HCop2 : Coplanar B C A Q'
HPerp2 : Perp B C Q' P'
Q' : Tpoint
HOut2 : Out B C P'
HCong2 : Cong B P' B P
P' : Tpoint
HCop1 : Coplanar A B D Q
HPer : Per B P Q
HNE1 : not (eq P Q)
HOut1 : Out B A P
P,Q : Tpoint
HD : Cong A D D C
D : Tpoint
HNC : not (Col B A C)
HPerp1 : Perp B A C B
HCong1 : Cong B A B C
C,B,A : Tpoint
bla : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Perp P I B P
+++++
apply perp_col0 with A B; try apply perp_col0 with P Q; try solve[assert_diffs; assert_cols; Col; Perp].
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro bla.
cut (exists A B C, ~ Col A B C /\\ Acute A B C /\\ forall P Q, Out B A P -> P <> Q -> Per B P Q -> Coplanar A B C Q -> exists Y, Out B C Y /\\ Col P Q Y).
destruct lower_dim_ex as [C [E [D H]]].
assert (HNC : ~ Col C E D) by auto; clear H.
destruct (l8_18_existence D E C) as [B [HC1 HPerp]]; Col.
assert (HF : exists F, Col D E F /\\ B <> F); [|destruct HF as [F [HC2 HNE]]].
destruct (segment_construction_2 F B B C) as [A [H HCong1]]; auto.
assert (HC3 : Col D E A) by (induction H; assert_diffs; assert_cols; ColR).
clear H; assert (HPerp1 : Perp B A C B) by (apply perp_sym; apply perp_col0 with D E; assert_diffs; Perp).
clear HPerp; clear HC1; clear HC2; clear HC3; clear HNE; clear HNC; clear D; clear E; clear F.
assert (HNC := perp_not_col _ _ _ HPerp1).
destruct (midpoint_existence A C) as [D HD]; exists A, B, D.
split; [intro; apply HNC; assert_diffs; assert_cols; ColR|split].
intros P Q HOut1 HNE1 HPer HCop1.
destruct (segment_construction_2 C B B P) as [P' [H HCong2]]; [assert_diffs; auto|].
assert (HOut2 : Out B C P') by (assert_diffs; repeat (split; auto)); clear H.
destruct (ex_perp_cop B C P' A) as [Q' [HPerp2 HCop2]]; [assert_diffs; auto|].
assert (HPerp3 : Perp B A Q P).
assert (Coplanar B P P' P) by Cop.
assert (Coplanar A B C P) by Cop.
assert (Coplanar B Q A C) by (assert_diffs; apply col2_cop__cop with A D; Col; Cop).
assert (Coplanar A B C P') by Cop.
assert (Coplanar B P P' Q) by CopR.
assert (Coplanar B P P' Q') by CopR.
destruct (bla B A B C P Q P' Q' B P P') as [I [HC1 HC2]]; Col; Perp; Cop; try (intro; apply HNC; assert_diffs; assert_cols; ColR).
assert (HNE2 : B <> D) by (intro; treat_equalities; apply HNC; assert_cols; Col).
assert (HOS : OS B C P I).
exists I; split; Col; apply l6_4_2; split; try (intro; apply (l9_9_bis _ _ _ _ HOS)).
assert (Coplanar A B C I) by (apply col_cop2__cop with P Q; Cop).
assert (Coplanar A B C D) by Cop.
elim (eq_dec_points D I); intro HNE3; treat_equalities; Col.
destruct HD as [_ HD]; apply cop_perp2__col with A C; Cop; apply perp_bisect_perp; apply cong_cop_perp_bisect; try solve[assert_diffs; Cong]; try CopR.
assert (HPerp4 : Perp P I B P).
apply perp_col0 with A B; try apply perp_col0 with P Q; try solve[assert_diffs; assert_cols; Col; Perp].

*****
HNE3 : not (eq D I)
H6 : Coplanar A B C D
H5 : Coplanar A B C I
HOS : OS B C P I
HNE2 : not (eq B D)
HC2 : Col P' Q' I
HC1 : Col P Q I
I : Tpoint
H4 : Coplanar B P P' Q'
H3 : Coplanar B P P' Q
H2 : Coplanar A B C P'
H1 : Coplanar B Q A C
H0 : Coplanar A B C P
H : Coplanar B P P' P
HPerp3 : Perp B A Q P
HCop2 : Coplanar B C A Q'
HPerp2 : Perp B C Q' P'
Q' : Tpoint
HOut2 : Out B C P'
HCong2 : Cong B P' B P
P' : Tpoint
HCop1 : Coplanar A B D Q
HPer : Per B P Q
HNE1 : not (eq P Q)
HOut1 : Out B A P
P,Q : Tpoint
HD : Cong A D D C
D : Tpoint
HNC : not (Col B A C)
HPerp1 : Perp B A C B
HCong1 : Cong B A B C
C,B,A : Tpoint
bla : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq P I)
+++++
intro; treat_equalities; apply HNC.
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro bla.
cut (exists A B C, ~ Col A B C /\\ Acute A B C /\\ forall P Q, Out B A P -> P <> Q -> Per B P Q -> Coplanar A B C Q -> exists Y, Out B C Y /\\ Col P Q Y).
destruct lower_dim_ex as [C [E [D H]]].
assert (HNC : ~ Col C E D) by auto; clear H.
destruct (l8_18_existence D E C) as [B [HC1 HPerp]]; Col.
assert (HF : exists F, Col D E F /\\ B <> F); [|destruct HF as [F [HC2 HNE]]].
destruct (segment_construction_2 F B B C) as [A [H HCong1]]; auto.
assert (HC3 : Col D E A) by (induction H; assert_diffs; assert_cols; ColR).
clear H; assert (HPerp1 : Perp B A C B) by (apply perp_sym; apply perp_col0 with D E; assert_diffs; Perp).
clear HPerp; clear HC1; clear HC2; clear HC3; clear HNE; clear HNC; clear D; clear E; clear F.
assert (HNC := perp_not_col _ _ _ HPerp1).
destruct (midpoint_existence A C) as [D HD]; exists A, B, D.
split; [intro; apply HNC; assert_diffs; assert_cols; ColR|split].
intros P Q HOut1 HNE1 HPer HCop1.
destruct (segment_construction_2 C B B P) as [P' [H HCong2]]; [assert_diffs; auto|].
assert (HOut2 : Out B C P') by (assert_diffs; repeat (split; auto)); clear H.
destruct (ex_perp_cop B C P' A) as [Q' [HPerp2 HCop2]]; [assert_diffs; auto|].
assert (HPerp3 : Perp B A Q P).
assert (Coplanar B P P' P) by Cop.
assert (Coplanar A B C P) by Cop.
assert (Coplanar B Q A C) by (assert_diffs; apply col2_cop__cop with A D; Col; Cop).
assert (Coplanar A B C P') by Cop.
assert (Coplanar B P P' Q) by CopR.
assert (Coplanar B P P' Q') by CopR.
destruct (bla B A B C P Q P' Q' B P P') as [I [HC1 HC2]]; Col; Perp; Cop; try (intro; apply HNC; assert_diffs; assert_cols; ColR).
assert (HNE2 : B <> D) by (intro; treat_equalities; apply HNC; assert_cols; Col).
assert (HOS : OS B C P I).
exists I; split; Col; apply l6_4_2; split; try (intro; apply (l9_9_bis _ _ _ _ HOS)).
assert (Coplanar A B C I) by (apply col_cop2__cop with P Q; Cop).
assert (Coplanar A B C D) by Cop.
elim (eq_dec_points D I); intro HNE3; treat_equalities; Col.
destruct HD as [_ HD]; apply cop_perp2__col with A C; Cop; apply perp_bisect_perp; apply cong_cop_perp_bisect; try solve[assert_diffs; Cong]; try CopR.
assert (HPerp4 : Perp P I B P).
apply perp_col0 with A B; try apply perp_col0 with P Q; try solve[assert_diffs; assert_cols; Col; Perp].
intro; treat_equalities; apply HNC.

*****
HNE3 : not (eq D P)
H6 : Coplanar A B C D
HOS : OS B C P P
HNE2 : not (eq B D)
HC2 : Col P' Q' P
H4 : Coplanar B P P' Q'
H3 : Coplanar B P P' Q
H2 : Coplanar A B C P'
H1 : Coplanar B Q A C
H0 : Coplanar A B C P
H : Coplanar B P P' P
HPerp3 : Perp B A Q P
HCop2 : Coplanar B C A Q'
HPerp2 : Perp B C Q' P'
Q' : Tpoint
HOut2 : Out B C P'
HCong2 : Cong B P' B P
P' : Tpoint
HCop1 : Coplanar A B D Q
HPer : Per B P Q
HNE1 : not (eq P Q)
HOut1 : Out B A P
P,Q : Tpoint
HD : Cong A D D C
D : Tpoint
HNC : not (Col B A C)
HPerp1 : Perp B A C B
HCong1 : Cong B A B C
C,B,A : Tpoint
bla : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col B A C
+++++
assert (HPar : Par B A P' Q') by (apply l12_9 with B C; Perp; Cop).
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro bla.
cut (exists A B C, ~ Col A B C /\\ Acute A B C /\\ forall P Q, Out B A P -> P <> Q -> Per B P Q -> Coplanar A B C Q -> exists Y, Out B C Y /\\ Col P Q Y).
destruct lower_dim_ex as [C [E [D H]]].
assert (HNC : ~ Col C E D) by auto; clear H.
destruct (l8_18_existence D E C) as [B [HC1 HPerp]]; Col.
assert (HF : exists F, Col D E F /\\ B <> F); [|destruct HF as [F [HC2 HNE]]].
destruct (segment_construction_2 F B B C) as [A [H HCong1]]; auto.
assert (HC3 : Col D E A) by (induction H; assert_diffs; assert_cols; ColR).
clear H; assert (HPerp1 : Perp B A C B) by (apply perp_sym; apply perp_col0 with D E; assert_diffs; Perp).
clear HPerp; clear HC1; clear HC2; clear HC3; clear HNE; clear HNC; clear D; clear E; clear F.
assert (HNC := perp_not_col _ _ _ HPerp1).
destruct (midpoint_existence A C) as [D HD]; exists A, B, D.
split; [intro; apply HNC; assert_diffs; assert_cols; ColR|split].
intros P Q HOut1 HNE1 HPer HCop1.
destruct (segment_construction_2 C B B P) as [P' [H HCong2]]; [assert_diffs; auto|].
assert (HOut2 : Out B C P') by (assert_diffs; repeat (split; auto)); clear H.
destruct (ex_perp_cop B C P' A) as [Q' [HPerp2 HCop2]]; [assert_diffs; auto|].
assert (HPerp3 : Perp B A Q P).
assert (Coplanar B P P' P) by Cop.
assert (Coplanar A B C P) by Cop.
assert (Coplanar B Q A C) by (assert_diffs; apply col2_cop__cop with A D; Col; Cop).
assert (Coplanar A B C P') by Cop.
assert (Coplanar B P P' Q) by CopR.
assert (Coplanar B P P' Q') by CopR.
destruct (bla B A B C P Q P' Q' B P P') as [I [HC1 HC2]]; Col; Perp; Cop; try (intro; apply HNC; assert_diffs; assert_cols; ColR).
assert (HNE2 : B <> D) by (intro; treat_equalities; apply HNC; assert_cols; Col).
assert (HOS : OS B C P I).
exists I; split; Col; apply l6_4_2; split; try (intro; apply (l9_9_bis _ _ _ _ HOS)).
assert (Coplanar A B C I) by (apply col_cop2__cop with P Q; Cop).
assert (Coplanar A B C D) by Cop.
elim (eq_dec_points D I); intro HNE3; treat_equalities; Col.
destruct HD as [_ HD]; apply cop_perp2__col with A C; Cop; apply perp_bisect_perp; apply cong_cop_perp_bisect; try solve[assert_diffs; Cong]; try CopR.
assert (HPerp4 : Perp P I B P).
apply perp_col0 with A B; try apply perp_col0 with P Q; try solve[assert_diffs; assert_cols; Col; Perp].
intro; treat_equalities; apply HNC.
assert (HPar : Par B A P' Q') by (apply l12_9 with B C; Perp; Cop).

*****
HPar : Par B A P' Q'
HNE3 : not (eq D P)
H6 : Coplanar A B C D
HOS : OS B C P P
HNE2 : not (eq B D)
HC2 : Col P' Q' P
H4 : Coplanar B P P' Q'
H3 : Coplanar B P P' Q
H2 : Coplanar A B C P'
H1 : Coplanar B Q A C
H0 : Coplanar A B C P
H : Coplanar B P P' P
HPerp3 : Perp B A Q P
HCop2 : Coplanar B C A Q'
HPerp2 : Perp B C Q' P'
Q' : Tpoint
HOut2 : Out B C P'
HCong2 : Cong B P' B P
P' : Tpoint
HCop1 : Coplanar A B D Q
HPer : Per B P Q
HNE1 : not (eq P Q)
HOut1 : Out B A P
P,Q : Tpoint
HD : Cong A D D C
D : Tpoint
HNC : not (Col B A C)
HPerp1 : Perp B A C B
HCong1 : Cong B A B C
C,B,A : Tpoint
bla : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col B A C
+++++
destruct (not_strict_par B A P' Q' P); assert_diffs; assert_cols; Col; ColR.
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro bla.
cut (exists A B C, ~ Col A B C /\\ Acute A B C /\\ forall P Q, Out B A P -> P <> Q -> Per B P Q -> Coplanar A B C Q -> exists Y, Out B C Y /\\ Col P Q Y).
destruct lower_dim_ex as [C [E [D H]]].
assert (HNC : ~ Col C E D) by auto; clear H.
destruct (l8_18_existence D E C) as [B [HC1 HPerp]]; Col.
assert (HF : exists F, Col D E F /\\ B <> F); [|destruct HF as [F [HC2 HNE]]].
destruct (segment_construction_2 F B B C) as [A [H HCong1]]; auto.
assert (HC3 : Col D E A) by (induction H; assert_diffs; assert_cols; ColR).
clear H; assert (HPerp1 : Perp B A C B) by (apply perp_sym; apply perp_col0 with D E; assert_diffs; Perp).
clear HPerp; clear HC1; clear HC2; clear HC3; clear HNE; clear HNC; clear D; clear E; clear F.
assert (HNC := perp_not_col _ _ _ HPerp1).
destruct (midpoint_existence A C) as [D HD]; exists A, B, D.
split; [intro; apply HNC; assert_diffs; assert_cols; ColR|split].
intros P Q HOut1 HNE1 HPer HCop1.
destruct (segment_construction_2 C B B P) as [P' [H HCong2]]; [assert_diffs; auto|].
assert (HOut2 : Out B C P') by (assert_diffs; repeat (split; auto)); clear H.
destruct (ex_perp_cop B C P' A) as [Q' [HPerp2 HCop2]]; [assert_diffs; auto|].
assert (HPerp3 : Perp B A Q P).
assert (Coplanar B P P' P) by Cop.
assert (Coplanar A B C P) by Cop.
assert (Coplanar B Q A C) by (assert_diffs; apply col2_cop__cop with A D; Col; Cop).
assert (Coplanar A B C P') by Cop.
assert (Coplanar B P P' Q) by CopR.
assert (Coplanar B P P' Q') by CopR.
destruct (bla B A B C P Q P' Q' B P P') as [I [HC1 HC2]]; Col; Perp; Cop; try (intro; apply HNC; assert_diffs; assert_cols; ColR).
assert (HNE2 : B <> D) by (intro; treat_equalities; apply HNC; assert_cols; Col).
assert (HOS : OS B C P I).
exists I; split; Col; apply l6_4_2; split; try (intro; apply (l9_9_bis _ _ _ _ HOS)).
assert (Coplanar A B C I) by (apply col_cop2__cop with P Q; Cop).
assert (Coplanar A B C D) by Cop.
elim (eq_dec_points D I); intro HNE3; treat_equalities; Col.
destruct HD as [_ HD]; apply cop_perp2__col with A C; Cop; apply perp_bisect_perp; apply cong_cop_perp_bisect; try solve[assert_diffs; Cong]; try CopR.
assert (HPerp4 : Perp P I B P).

*****
HPerp4 : Perp P I B P
HNE3 : not (eq D I)
H6 : Coplanar A B C D
H5 : Coplanar A B C I
HOS : OS B C P I
HNE2 : not (eq B D)
HC2 : Col P' Q' I
HC1 : Col P Q I
I : Tpoint
H4 : Coplanar B P P' Q'
H3 : Coplanar B P P' Q
H2 : Coplanar A B C P'
H1 : Coplanar B Q A C
H0 : Coplanar A B C P
H : Coplanar B P P' P
HPerp3 : Perp B A Q P
HCop2 : Coplanar B C A Q'
HPerp2 : Perp B C Q' P'
Q' : Tpoint
HOut2 : Out B C P'
HCong2 : Cong B P' B P
P' : Tpoint
HCop1 : Coplanar A B D Q
HPer : Per B P Q
HNE1 : not (eq P Q)
HOut1 : Out B A P
P,Q : Tpoint
HD : Cong A D D C
D : Tpoint
HNC : not (Col B A C)
HPerp1 : Perp B A C B
HCong1 : Cong B A B C
C,B,A : Tpoint
bla : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong A I C I
+++++
assert (HPerp5 : Perp P' I B P').
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro bla.
cut (exists A B C, ~ Col A B C /\\ Acute A B C /\\ forall P Q, Out B A P -> P <> Q -> Per B P Q -> Coplanar A B C Q -> exists Y, Out B C Y /\\ Col P Q Y).
destruct lower_dim_ex as [C [E [D H]]].
assert (HNC : ~ Col C E D) by auto; clear H.
destruct (l8_18_existence D E C) as [B [HC1 HPerp]]; Col.
assert (HF : exists F, Col D E F /\\ B <> F); [|destruct HF as [F [HC2 HNE]]].
destruct (segment_construction_2 F B B C) as [A [H HCong1]]; auto.
assert (HC3 : Col D E A) by (induction H; assert_diffs; assert_cols; ColR).
clear H; assert (HPerp1 : Perp B A C B) by (apply perp_sym; apply perp_col0 with D E; assert_diffs; Perp).
clear HPerp; clear HC1; clear HC2; clear HC3; clear HNE; clear HNC; clear D; clear E; clear F.
assert (HNC := perp_not_col _ _ _ HPerp1).
destruct (midpoint_existence A C) as [D HD]; exists A, B, D.
split; [intro; apply HNC; assert_diffs; assert_cols; ColR|split].
intros P Q HOut1 HNE1 HPer HCop1.
destruct (segment_construction_2 C B B P) as [P' [H HCong2]]; [assert_diffs; auto|].
assert (HOut2 : Out B C P') by (assert_diffs; repeat (split; auto)); clear H.
destruct (ex_perp_cop B C P' A) as [Q' [HPerp2 HCop2]]; [assert_diffs; auto|].
assert (HPerp3 : Perp B A Q P).
assert (Coplanar B P P' P) by Cop.
assert (Coplanar A B C P) by Cop.
assert (Coplanar B Q A C) by (assert_diffs; apply col2_cop__cop with A D; Col; Cop).
assert (Coplanar A B C P') by Cop.
assert (Coplanar B P P' Q) by CopR.
assert (Coplanar B P P' Q') by CopR.
destruct (bla B A B C P Q P' Q' B P P') as [I [HC1 HC2]]; Col; Perp; Cop; try (intro; apply HNC; assert_diffs; assert_cols; ColR).
assert (HNE2 : B <> D) by (intro; treat_equalities; apply HNC; assert_cols; Col).
assert (HOS : OS B C P I).
exists I; split; Col; apply l6_4_2; split; try (intro; apply (l9_9_bis _ _ _ _ HOS)).
assert (Coplanar A B C I) by (apply col_cop2__cop with P Q; Cop).
assert (Coplanar A B C D) by Cop.
elim (eq_dec_points D I); intro HNE3; treat_equalities; Col.
destruct HD as [_ HD]; apply cop_perp2__col with A C; Cop; apply perp_bisect_perp; apply cong_cop_perp_bisect; try solve[assert_diffs; Cong]; try CopR.
assert (HPerp4 : Perp P I B P).
assert (HPerp5 : Perp P' I B P').

*****
HPerp4 : Perp P I B P
HNE3 : not (eq D I)
H6 : Coplanar A B C D
H5 : Coplanar A B C I
HOS : OS B C P I
HNE2 : not (eq B D)
HC2 : Col P' Q' I
HC1 : Col P Q I
I : Tpoint
H4 : Coplanar B P P' Q'
H3 : Coplanar B P P' Q
H2 : Coplanar A B C P'
H1 : Coplanar B Q A C
H0 : Coplanar A B C P
H : Coplanar B P P' P
HPerp3 : Perp B A Q P
HCop2 : Coplanar B C A Q'
HPerp2 : Perp B C Q' P'
Q' : Tpoint
HOut2 : Out B C P'
HCong2 : Cong B P' B P
P' : Tpoint
HCop1 : Coplanar A B D Q
HPer : Per B P Q
HNE1 : not (eq P Q)
HOut1 : Out B A P
P,Q : Tpoint
HD : Cong A D D C
D : Tpoint
HNC : not (Col B A C)
HPerp1 : Perp B A C B
HCong1 : Cong B A B C
C,B,A : Tpoint
bla : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Perp P' I B P'
+++++
apply perp_col0 with B C; try apply perp_col0 with P' Q'; try solve[assert_diffs; assert_cols; Col; Perp].
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro bla.
cut (exists A B C, ~ Col A B C /\\ Acute A B C /\\ forall P Q, Out B A P -> P <> Q -> Per B P Q -> Coplanar A B C Q -> exists Y, Out B C Y /\\ Col P Q Y).
destruct lower_dim_ex as [C [E [D H]]].
assert (HNC : ~ Col C E D) by auto; clear H.
destruct (l8_18_existence D E C) as [B [HC1 HPerp]]; Col.
assert (HF : exists F, Col D E F /\\ B <> F); [|destruct HF as [F [HC2 HNE]]].
destruct (segment_construction_2 F B B C) as [A [H HCong1]]; auto.
assert (HC3 : Col D E A) by (induction H; assert_diffs; assert_cols; ColR).
clear H; assert (HPerp1 : Perp B A C B) by (apply perp_sym; apply perp_col0 with D E; assert_diffs; Perp).
clear HPerp; clear HC1; clear HC2; clear HC3; clear HNE; clear HNC; clear D; clear E; clear F.
assert (HNC := perp_not_col _ _ _ HPerp1).
destruct (midpoint_existence A C) as [D HD]; exists A, B, D.
split; [intro; apply HNC; assert_diffs; assert_cols; ColR|split].
intros P Q HOut1 HNE1 HPer HCop1.
destruct (segment_construction_2 C B B P) as [P' [H HCong2]]; [assert_diffs; auto|].
assert (HOut2 : Out B C P') by (assert_diffs; repeat (split; auto)); clear H.
destruct (ex_perp_cop B C P' A) as [Q' [HPerp2 HCop2]]; [assert_diffs; auto|].
assert (HPerp3 : Perp B A Q P).
assert (Coplanar B P P' P) by Cop.
assert (Coplanar A B C P) by Cop.
assert (Coplanar B Q A C) by (assert_diffs; apply col2_cop__cop with A D; Col; Cop).
assert (Coplanar A B C P') by Cop.
assert (Coplanar B P P' Q) by CopR.
assert (Coplanar B P P' Q') by CopR.
destruct (bla B A B C P Q P' Q' B P P') as [I [HC1 HC2]]; Col; Perp; Cop; try (intro; apply HNC; assert_diffs; assert_cols; ColR).
assert (HNE2 : B <> D) by (intro; treat_equalities; apply HNC; assert_cols; Col).
assert (HOS : OS B C P I).
exists I; split; Col; apply l6_4_2; split; try (intro; apply (l9_9_bis _ _ _ _ HOS)).
assert (Coplanar A B C I) by (apply col_cop2__cop with P Q; Cop).
assert (Coplanar A B C D) by Cop.
elim (eq_dec_points D I); intro HNE3; treat_equalities; Col.
destruct HD as [_ HD]; apply cop_perp2__col with A C; Cop; apply perp_bisect_perp; apply cong_cop_perp_bisect; try solve[assert_diffs; Cong]; try CopR.
assert (HPerp4 : Perp P I B P).
assert (HPerp5 : Perp P' I B P').
apply perp_col0 with B C; try apply perp_col0 with P' Q'; try solve[assert_diffs; assert_cols; Col; Perp].

*****
HPerp4 : Perp P I B P
HNE3 : not (eq D I)
H6 : Coplanar A B C D
H5 : Coplanar A B C I
HOS : OS B C P I
HNE2 : not (eq B D)
HC2 : Col P' Q' I
HC1 : Col P Q I
I : Tpoint
H4 : Coplanar B P P' Q'
H3 : Coplanar B P P' Q
H2 : Coplanar A B C P'
H1 : Coplanar B Q A C
H0 : Coplanar A B C P
H : Coplanar B P P' P
HPerp3 : Perp B A Q P
HCop2 : Coplanar B C A Q'
HPerp2 : Perp B C Q' P'
Q' : Tpoint
HOut2 : Out B C P'
HCong2 : Cong B P' B P
P' : Tpoint
HCop1 : Coplanar A B D Q
HPer : Per B P Q
HNE1 : not (eq P Q)
HOut1 : Out B A P
P,Q : Tpoint
HD : Cong A D D C
D : Tpoint
HNC : not (Col B A C)
HPerp1 : Perp B A C B
HCong1 : Cong B A B C
C,B,A : Tpoint
bla : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq P' I)
+++++
intro; treat_equalities; apply HNC.
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro bla.
cut (exists A B C, ~ Col A B C /\\ Acute A B C /\\ forall P Q, Out B A P -> P <> Q -> Per B P Q -> Coplanar A B C Q -> exists Y, Out B C Y /\\ Col P Q Y).
destruct lower_dim_ex as [C [E [D H]]].
assert (HNC : ~ Col C E D) by auto; clear H.
destruct (l8_18_existence D E C) as [B [HC1 HPerp]]; Col.
assert (HF : exists F, Col D E F /\\ B <> F); [|destruct HF as [F [HC2 HNE]]].
destruct (segment_construction_2 F B B C) as [A [H HCong1]]; auto.
assert (HC3 : Col D E A) by (induction H; assert_diffs; assert_cols; ColR).
clear H; assert (HPerp1 : Perp B A C B) by (apply perp_sym; apply perp_col0 with D E; assert_diffs; Perp).
clear HPerp; clear HC1; clear HC2; clear HC3; clear HNE; clear HNC; clear D; clear E; clear F.
assert (HNC := perp_not_col _ _ _ HPerp1).
destruct (midpoint_existence A C) as [D HD]; exists A, B, D.
split; [intro; apply HNC; assert_diffs; assert_cols; ColR|split].
intros P Q HOut1 HNE1 HPer HCop1.
destruct (segment_construction_2 C B B P) as [P' [H HCong2]]; [assert_diffs; auto|].
assert (HOut2 : Out B C P') by (assert_diffs; repeat (split; auto)); clear H.
destruct (ex_perp_cop B C P' A) as [Q' [HPerp2 HCop2]]; [assert_diffs; auto|].
assert (HPerp3 : Perp B A Q P).
assert (Coplanar B P P' P) by Cop.
assert (Coplanar A B C P) by Cop.
assert (Coplanar B Q A C) by (assert_diffs; apply col2_cop__cop with A D; Col; Cop).
assert (Coplanar A B C P') by Cop.
assert (Coplanar B P P' Q) by CopR.
assert (Coplanar B P P' Q') by CopR.
destruct (bla B A B C P Q P' Q' B P P') as [I [HC1 HC2]]; Col; Perp; Cop; try (intro; apply HNC; assert_diffs; assert_cols; ColR).
assert (HNE2 : B <> D) by (intro; treat_equalities; apply HNC; assert_cols; Col).
assert (HOS : OS B C P I).
exists I; split; Col; apply l6_4_2; split; try (intro; apply (l9_9_bis _ _ _ _ HOS)).
assert (Coplanar A B C I) by (apply col_cop2__cop with P Q; Cop).
assert (Coplanar A B C D) by Cop.
elim (eq_dec_points D I); intro HNE3; treat_equalities; Col.
destruct HD as [_ HD]; apply cop_perp2__col with A C; Cop; apply perp_bisect_perp; apply cong_cop_perp_bisect; try solve[assert_diffs; Cong]; try CopR.
assert (HPerp4 : Perp P I B P).
assert (HPerp5 : Perp P' I B P').
apply perp_col0 with B C; try apply perp_col0 with P' Q'; try solve[assert_diffs; assert_cols; Col; Perp].
intro; treat_equalities; apply HNC.

*****
HNE3 : not (eq D P')
HPerp4 : Perp P P' B P
H6 : Coplanar A B C D
HOS : OS B C P P'
HNE2 : not (eq B D)
HC1 : Col P Q P'
H4 : Coplanar B P P' Q'
H3 : Coplanar B P P' Q
H2 : Coplanar A B C P'
H1 : Coplanar B Q A C
H0 : Coplanar A B C P
H : Coplanar B P P' P
HPerp3 : Perp B A Q P
HCop2 : Coplanar B C A Q'
HPerp2 : Perp B C Q' P'
Q' : Tpoint
HOut2 : Out B C P'
HCong2 : Cong B P' B P
P' : Tpoint
HCop1 : Coplanar A B D Q
HPer : Per B P Q
HNE1 : not (eq P Q)
HOut1 : Out B A P
P,Q : Tpoint
HD : Cong A D D C
D : Tpoint
HNC : not (Col B A C)
HPerp1 : Perp B A C B
HCong1 : Cong B A B C
C,B,A : Tpoint
bla : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col B A C
+++++
assert (HPar : Par B C P Q) by (apply l12_9 with B A; Perp; Cop).
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro bla.
cut (exists A B C, ~ Col A B C /\\ Acute A B C /\\ forall P Q, Out B A P -> P <> Q -> Per B P Q -> Coplanar A B C Q -> exists Y, Out B C Y /\\ Col P Q Y).
destruct lower_dim_ex as [C [E [D H]]].
assert (HNC : ~ Col C E D) by auto; clear H.
destruct (l8_18_existence D E C) as [B [HC1 HPerp]]; Col.
assert (HF : exists F, Col D E F /\\ B <> F); [|destruct HF as [F [HC2 HNE]]].
destruct (segment_construction_2 F B B C) as [A [H HCong1]]; auto.
assert (HC3 : Col D E A) by (induction H; assert_diffs; assert_cols; ColR).
clear H; assert (HPerp1 : Perp B A C B) by (apply perp_sym; apply perp_col0 with D E; assert_diffs; Perp).
clear HPerp; clear HC1; clear HC2; clear HC3; clear HNE; clear HNC; clear D; clear E; clear F.
assert (HNC := perp_not_col _ _ _ HPerp1).
destruct (midpoint_existence A C) as [D HD]; exists A, B, D.
split; [intro; apply HNC; assert_diffs; assert_cols; ColR|split].
intros P Q HOut1 HNE1 HPer HCop1.
destruct (segment_construction_2 C B B P) as [P' [H HCong2]]; [assert_diffs; auto|].
assert (HOut2 : Out B C P') by (assert_diffs; repeat (split; auto)); clear H.
destruct (ex_perp_cop B C P' A) as [Q' [HPerp2 HCop2]]; [assert_diffs; auto|].
assert (HPerp3 : Perp B A Q P).
assert (Coplanar B P P' P) by Cop.
assert (Coplanar A B C P) by Cop.
assert (Coplanar B Q A C) by (assert_diffs; apply col2_cop__cop with A D; Col; Cop).
assert (Coplanar A B C P') by Cop.
assert (Coplanar B P P' Q) by CopR.
assert (Coplanar B P P' Q') by CopR.
destruct (bla B A B C P Q P' Q' B P P') as [I [HC1 HC2]]; Col; Perp; Cop; try (intro; apply HNC; assert_diffs; assert_cols; ColR).
assert (HNE2 : B <> D) by (intro; treat_equalities; apply HNC; assert_cols; Col).
assert (HOS : OS B C P I).
exists I; split; Col; apply l6_4_2; split; try (intro; apply (l9_9_bis _ _ _ _ HOS)).
assert (Coplanar A B C I) by (apply col_cop2__cop with P Q; Cop).
assert (Coplanar A B C D) by Cop.
elim (eq_dec_points D I); intro HNE3; treat_equalities; Col.
destruct HD as [_ HD]; apply cop_perp2__col with A C; Cop; apply perp_bisect_perp; apply cong_cop_perp_bisect; try solve[assert_diffs; Cong]; try CopR.
assert (HPerp4 : Perp P I B P).
assert (HPerp5 : Perp P' I B P').
apply perp_col0 with B C; try apply perp_col0 with P' Q'; try solve[assert_diffs; assert_cols; Col; Perp].
intro; treat_equalities; apply HNC.
assert (HPar : Par B C P Q) by (apply l12_9 with B A; Perp; Cop).

*****
HPar : Par B C P Q
HNE3 : not (eq D P')
HPerp4 : Perp P P' B P
H6 : Coplanar A B C D
HOS : OS B C P P'
HNE2 : not (eq B D)
HC1 : Col P Q P'
H4 : Coplanar B P P' Q'
H3 : Coplanar B P P' Q
H2 : Coplanar A B C P'
H1 : Coplanar B Q A C
H0 : Coplanar A B C P
H : Coplanar B P P' P
HPerp3 : Perp B A Q P
HCop2 : Coplanar B C A Q'
HPerp2 : Perp B C Q' P'
Q' : Tpoint
HOut2 : Out B C P'
HCong2 : Cong B P' B P
P' : Tpoint
HCop1 : Coplanar A B D Q
HPer : Per B P Q
HNE1 : not (eq P Q)
HOut1 : Out B A P
P,Q : Tpoint
HD : Cong A D D C
D : Tpoint
HNC : not (Col B A C)
HPerp1 : Perp B A C B
HCong1 : Cong B A B C
C,B,A : Tpoint
bla : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col B A C
+++++
destruct (not_strict_par B C P Q P'); assert_diffs; assert_cols; Col; ColR.
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro bla.
cut (exists A B C, ~ Col A B C /\\ Acute A B C /\\ forall P Q, Out B A P -> P <> Q -> Per B P Q -> Coplanar A B C Q -> exists Y, Out B C Y /\\ Col P Q Y).
destruct lower_dim_ex as [C [E [D H]]].
assert (HNC : ~ Col C E D) by auto; clear H.
destruct (l8_18_existence D E C) as [B [HC1 HPerp]]; Col.
assert (HF : exists F, Col D E F /\\ B <> F); [|destruct HF as [F [HC2 HNE]]].
destruct (segment_construction_2 F B B C) as [A [H HCong1]]; auto.
assert (HC3 : Col D E A) by (induction H; assert_diffs; assert_cols; ColR).
clear H; assert (HPerp1 : Perp B A C B) by (apply perp_sym; apply perp_col0 with D E; assert_diffs; Perp).
clear HPerp; clear HC1; clear HC2; clear HC3; clear HNE; clear HNC; clear D; clear E; clear F.
assert (HNC := perp_not_col _ _ _ HPerp1).
destruct (midpoint_existence A C) as [D HD]; exists A, B, D.
split; [intro; apply HNC; assert_diffs; assert_cols; ColR|split].
intros P Q HOut1 HNE1 HPer HCop1.
destruct (segment_construction_2 C B B P) as [P' [H HCong2]]; [assert_diffs; auto|].
assert (HOut2 : Out B C P') by (assert_diffs; repeat (split; auto)); clear H.
destruct (ex_perp_cop B C P' A) as [Q' [HPerp2 HCop2]]; [assert_diffs; auto|].
assert (HPerp3 : Perp B A Q P).
assert (Coplanar B P P' P) by Cop.
assert (Coplanar A B C P) by Cop.
assert (Coplanar B Q A C) by (assert_diffs; apply col2_cop__cop with A D; Col; Cop).
assert (Coplanar A B C P') by Cop.
assert (Coplanar B P P' Q) by CopR.
assert (Coplanar B P P' Q') by CopR.
destruct (bla B A B C P Q P' Q' B P P') as [I [HC1 HC2]]; Col; Perp; Cop; try (intro; apply HNC; assert_diffs; assert_cols; ColR).
assert (HNE2 : B <> D) by (intro; treat_equalities; apply HNC; assert_cols; Col).
assert (HOS : OS B C P I).
exists I; split; Col; apply l6_4_2; split; try (intro; apply (l9_9_bis _ _ _ _ HOS)).
assert (Coplanar A B C I) by (apply col_cop2__cop with P Q; Cop).
assert (Coplanar A B C D) by Cop.
elim (eq_dec_points D I); intro HNE3; treat_equalities; Col.
destruct HD as [_ HD]; apply cop_perp2__col with A C; Cop; apply perp_bisect_perp; apply cong_cop_perp_bisect; try solve[assert_diffs; Cong]; try CopR.
assert (HPerp4 : Perp P I B P).
assert (HPerp5 : Perp P' I B P').

*****
HPerp5 : Perp P' I B P'
HPerp4 : Perp P I B P
HNE3 : not (eq D I)
H6 : Coplanar A B C D
H5 : Coplanar A B C I
HOS : OS B C P I
HNE2 : not (eq B D)
HC2 : Col P' Q' I
HC1 : Col P Q I
I : Tpoint
H4 : Coplanar B P P' Q'
H3 : Coplanar B P P' Q
H2 : Coplanar A B C P'
H1 : Coplanar B Q A C
H0 : Coplanar A B C P
H : Coplanar B P P' P
HPerp3 : Perp B A Q P
HCop2 : Coplanar B C A Q'
HPerp2 : Perp B C Q' P'
Q' : Tpoint
HOut2 : Out B C P'
HCong2 : Cong B P' B P
P' : Tpoint
HCop1 : Coplanar A B D Q
HPer : Per B P Q
HNE1 : not (eq P Q)
HOut1 : Out B A P
P,Q : Tpoint
HD : Cong A D D C
D : Tpoint
HNC : not (Col B A C)
HPerp1 : Perp B A C B
HCong1 : Cong B A B C
C,B,A : Tpoint
bla : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong A I C I
+++++
destruct (per_lt B P I) as [HLt _]; try solve[assert_diffs; try apply perp_per_1; Perp].
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro bla.
cut (exists A B C, ~ Col A B C /\\ Acute A B C /\\ forall P Q, Out B A P -> P <> Q -> Per B P Q -> Coplanar A B C Q -> exists Y, Out B C Y /\\ Col P Q Y).
destruct lower_dim_ex as [C [E [D H]]].
assert (HNC : ~ Col C E D) by auto; clear H.
destruct (l8_18_existence D E C) as [B [HC1 HPerp]]; Col.
assert (HF : exists F, Col D E F /\\ B <> F); [|destruct HF as [F [HC2 HNE]]].
destruct (segment_construction_2 F B B C) as [A [H HCong1]]; auto.
assert (HC3 : Col D E A) by (induction H; assert_diffs; assert_cols; ColR).
clear H; assert (HPerp1 : Perp B A C B) by (apply perp_sym; apply perp_col0 with D E; assert_diffs; Perp).
clear HPerp; clear HC1; clear HC2; clear HC3; clear HNE; clear HNC; clear D; clear E; clear F.
assert (HNC := perp_not_col _ _ _ HPerp1).
destruct (midpoint_existence A C) as [D HD]; exists A, B, D.
split; [intro; apply HNC; assert_diffs; assert_cols; ColR|split].
intros P Q HOut1 HNE1 HPer HCop1.
destruct (segment_construction_2 C B B P) as [P' [H HCong2]]; [assert_diffs; auto|].
assert (HOut2 : Out B C P') by (assert_diffs; repeat (split; auto)); clear H.
destruct (ex_perp_cop B C P' A) as [Q' [HPerp2 HCop2]]; [assert_diffs; auto|].
assert (HPerp3 : Perp B A Q P).
assert (Coplanar B P P' P) by Cop.
assert (Coplanar A B C P) by Cop.
assert (Coplanar B Q A C) by (assert_diffs; apply col2_cop__cop with A D; Col; Cop).
assert (Coplanar A B C P') by Cop.
assert (Coplanar B P P' Q) by CopR.
assert (Coplanar B P P' Q') by CopR.
destruct (bla B A B C P Q P' Q' B P P') as [I [HC1 HC2]]; Col; Perp; Cop; try (intro; apply HNC; assert_diffs; assert_cols; ColR).
assert (HNE2 : B <> D) by (intro; treat_equalities; apply HNC; assert_cols; Col).
assert (HOS : OS B C P I).
exists I; split; Col; apply l6_4_2; split; try (intro; apply (l9_9_bis _ _ _ _ HOS)).
assert (Coplanar A B C I) by (apply col_cop2__cop with P Q; Cop).
assert (Coplanar A B C D) by Cop.
elim (eq_dec_points D I); intro HNE3; treat_equalities; Col.
destruct HD as [_ HD]; apply cop_perp2__col with A C; Cop; apply perp_bisect_perp; apply cong_cop_perp_bisect; try solve[assert_diffs; Cong]; try CopR.
assert (HPerp4 : Perp P I B P).
assert (HPerp5 : Perp P' I B P').
destruct (per_lt B P I) as [HLt _]; try solve[assert_diffs; try apply perp_per_1; Perp].

*****
HLt : Lt B P B I
HPerp5 : Perp P' I B P'
HPerp4 : Perp P I B P
HNE3 : not (eq D I)
H6 : Coplanar A B C D
H5 : Coplanar A B C I
HOS : OS B C P I
HNE2 : not (eq B D)
HC2 : Col P' Q' I
HC1 : Col P Q I
I : Tpoint
H4 : Coplanar B P P' Q'
H3 : Coplanar B P P' Q
H2 : Coplanar A B C P'
H1 : Coplanar B Q A C
H0 : Coplanar A B C P
H : Coplanar B P P' P
HPerp3 : Perp B A Q P
HCop2 : Coplanar B C A Q'
HPerp2 : Perp B C Q' P'
Q' : Tpoint
HOut2 : Out B C P'
HCong2 : Cong B P' B P
P' : Tpoint
HCop1 : Coplanar A B D Q
HPer : Per B P Q
HNE1 : not (eq P Q)
HOut1 : Out B A P
P,Q : Tpoint
HD : Cong A D D C
D : Tpoint
HNC : not (Col B A C)
HPerp1 : Perp B A C B
HCong1 : Cong B A B C
C,B,A : Tpoint
bla : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong A I C I
+++++
destruct (l11_52 I P B I P' B) as [_ [_ HCongA2]]; Cong; try (apply l11_16; assert_diffs; try apply perp_per_1; auto); [apply lt__le; apply lt_comm; auto|clear HNE3; clear HLt; clear HOS].
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro bla.
cut (exists A B C, ~ Col A B C /\\ Acute A B C /\\ forall P Q, Out B A P -> P <> Q -> Per B P Q -> Coplanar A B C Q -> exists Y, Out B C Y /\\ Col P Q Y).
destruct lower_dim_ex as [C [E [D H]]].
assert (HNC : ~ Col C E D) by auto; clear H.
destruct (l8_18_existence D E C) as [B [HC1 HPerp]]; Col.
assert (HF : exists F, Col D E F /\\ B <> F); [|destruct HF as [F [HC2 HNE]]].
destruct (segment_construction_2 F B B C) as [A [H HCong1]]; auto.
assert (HC3 : Col D E A) by (induction H; assert_diffs; assert_cols; ColR).
clear H; assert (HPerp1 : Perp B A C B) by (apply perp_sym; apply perp_col0 with D E; assert_diffs; Perp).
clear HPerp; clear HC1; clear HC2; clear HC3; clear HNE; clear HNC; clear D; clear E; clear F.
assert (HNC := perp_not_col _ _ _ HPerp1).
destruct (midpoint_existence A C) as [D HD]; exists A, B, D.
split; [intro; apply HNC; assert_diffs; assert_cols; ColR|split].
intros P Q HOut1 HNE1 HPer HCop1.
destruct (segment_construction_2 C B B P) as [P' [H HCong2]]; [assert_diffs; auto|].
assert (HOut2 : Out B C P') by (assert_diffs; repeat (split; auto)); clear H.
destruct (ex_perp_cop B C P' A) as [Q' [HPerp2 HCop2]]; [assert_diffs; auto|].
assert (HPerp3 : Perp B A Q P).
assert (Coplanar B P P' P) by Cop.
assert (Coplanar A B C P) by Cop.
assert (Coplanar B Q A C) by (assert_diffs; apply col2_cop__cop with A D; Col; Cop).
assert (Coplanar A B C P') by Cop.
assert (Coplanar B P P' Q) by CopR.
assert (Coplanar B P P' Q') by CopR.
destruct (bla B A B C P Q P' Q' B P P') as [I [HC1 HC2]]; Col; Perp; Cop; try (intro; apply HNC; assert_diffs; assert_cols; ColR).
assert (HNE2 : B <> D) by (intro; treat_equalities; apply HNC; assert_cols; Col).
assert (HOS : OS B C P I).
exists I; split; Col; apply l6_4_2; split; try (intro; apply (l9_9_bis _ _ _ _ HOS)).
assert (Coplanar A B C I) by (apply col_cop2__cop with P Q; Cop).
assert (Coplanar A B C D) by Cop.
elim (eq_dec_points D I); intro HNE3; treat_equalities; Col.
destruct HD as [_ HD]; apply cop_perp2__col with A C; Cop; apply perp_bisect_perp; apply cong_cop_perp_bisect; try solve[assert_diffs; Cong]; try CopR.
assert (HPerp4 : Perp P I B P).
assert (HPerp5 : Perp P' I B P').
destruct (per_lt B P I) as [HLt _]; try solve[assert_diffs; try apply perp_per_1; Perp].
destruct (l11_52 I P B I P' B) as [_ [_ HCongA2]]; Cong; try (apply l11_16; assert_diffs; try apply perp_per_1; auto); [apply lt__le; apply lt_comm; auto|clear HNE3; clear HLt; clear HOS].

*****
HCongA2 : CongA P B I P' B I
HPerp5 : Perp P' I B P'
HPerp4 : Perp P I B P
H6 : Coplanar A B C D
H5 : Coplanar A B C I
HNE2 : not (eq B D)
HC2 : Col P' Q' I
HC1 : Col P Q I
I : Tpoint
H4 : Coplanar B P P' Q'
H3 : Coplanar B P P' Q
H2 : Coplanar A B C P'
H1 : Coplanar B Q A C
H0 : Coplanar A B C P
H : Coplanar B P P' P
HPerp3 : Perp B A Q P
HCop2 : Coplanar B C A Q'
HPerp2 : Perp B C Q' P'
Q' : Tpoint
HOut2 : Out B C P'
HCong2 : Cong B P' B P
P' : Tpoint
HCop1 : Coplanar A B D Q
HPer : Per B P Q
HNE1 : not (eq P Q)
HOut1 : Out B A P
P,Q : Tpoint
HD : Cong A D D C
D : Tpoint
HNC : not (Col B A C)
HPerp1 : Perp B A C B
HCong1 : Cong B A B C
C,B,A : Tpoint
bla : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong A I C I
+++++
apply cong2_conga_cong with B B; Cong; apply out_conga with P I P' I; auto; apply l6_6; auto; apply out_trivial; apply perp_not_col in HPerp4; assert_diffs; auto.
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro bla.
cut (exists A B C, ~ Col A B C /\\ Acute A B C /\\ forall P Q, Out B A P -> P <> Q -> Per B P Q -> Coplanar A B C Q -> exists Y, Out B C Y /\\ Col P Q Y).
destruct lower_dim_ex as [C [E [D H]]].
assert (HNC : ~ Col C E D) by auto; clear H.
destruct (l8_18_existence D E C) as [B [HC1 HPerp]]; Col.
assert (HF : exists F, Col D E F /\\ B <> F); [|destruct HF as [F [HC2 HNE]]].
destruct (segment_construction_2 F B B C) as [A [H HCong1]]; auto.
assert (HC3 : Col D E A) by (induction H; assert_diffs; assert_cols; ColR).
clear H; assert (HPerp1 : Perp B A C B) by (apply perp_sym; apply perp_col0 with D E; assert_diffs; Perp).
clear HPerp; clear HC1; clear HC2; clear HC3; clear HNE; clear HNC; clear D; clear E; clear F.
assert (HNC := perp_not_col _ _ _ HPerp1).
destruct (midpoint_existence A C) as [D HD]; exists A, B, D.
split; [intro; apply HNC; assert_diffs; assert_cols; ColR|split].
intros P Q HOut1 HNE1 HPer HCop1.
destruct (segment_construction_2 C B B P) as [P' [H HCong2]]; [assert_diffs; auto|].
assert (HOut2 : Out B C P') by (assert_diffs; repeat (split; auto)); clear H.
destruct (ex_perp_cop B C P' A) as [Q' [HPerp2 HCop2]]; [assert_diffs; auto|].
assert (HPerp3 : Perp B A Q P).
assert (Coplanar B P P' P) by Cop.
assert (Coplanar A B C P) by Cop.
assert (Coplanar B Q A C) by (assert_diffs; apply col2_cop__cop with A D; Col; Cop).
assert (Coplanar A B C P') by Cop.
assert (Coplanar B P P' Q) by CopR.
assert (Coplanar B P P' Q') by CopR.
destruct (bla B A B C P Q P' Q' B P P') as [I [HC1 HC2]]; Col; Perp; Cop; try (intro; apply HNC; assert_diffs; assert_cols; ColR).
assert (HNE2 : B <> D) by (intro; treat_equalities; apply HNC; assert_cols; Col).
assert (HOS : OS B C P I).
exists I; split; Col; apply l6_4_2; split; try (intro; apply (l9_9_bis _ _ _ _ HOS)).

*****
H5 : Bet D B I
HOS : OS B C P I
HNE2 : not (eq B D)
HC2 : Col P' Q' I
HC1 : Col P Q I
I : Tpoint
H4 : Coplanar B P P' Q'
H3 : Coplanar B P P' Q
H2 : Coplanar A B C P'
H1 : Coplanar B Q A C
H0 : Coplanar A B C P
H : Coplanar B P P' P
HPerp3 : Perp B A Q P
HCop2 : Coplanar B C A Q'
HPerp2 : Perp B C Q' P'
Q' : Tpoint
HOut2 : Out B C P'
HCong2 : Cong B P' B P
P' : Tpoint
HCop1 : Coplanar A B D Q
HPer : Per B P Q
HNE1 : not (eq P Q)
HOut1 : Out B A P
P,Q : Tpoint
HD : Midpoint D A C
D : Tpoint
HNC : not (Col B A C)
HPerp1 : Perp B A C B
HCong1 : Cong B A B C
C,B,A : Tpoint
bla : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
TS B C P I
+++++
apply l9_8_2 with D; try apply one_side_transitivity with A.
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro bla.
cut (exists A B C, ~ Col A B C /\\ Acute A B C /\\ forall P Q, Out B A P -> P <> Q -> Per B P Q -> Coplanar A B C Q -> exists Y, Out B C Y /\\ Col P Q Y).
destruct lower_dim_ex as [C [E [D H]]].
assert (HNC : ~ Col C E D) by auto; clear H.
destruct (l8_18_existence D E C) as [B [HC1 HPerp]]; Col.
assert (HF : exists F, Col D E F /\\ B <> F); [|destruct HF as [F [HC2 HNE]]].
destruct (segment_construction_2 F B B C) as [A [H HCong1]]; auto.
assert (HC3 : Col D E A) by (induction H; assert_diffs; assert_cols; ColR).
clear H; assert (HPerp1 : Perp B A C B) by (apply perp_sym; apply perp_col0 with D E; assert_diffs; Perp).
clear HPerp; clear HC1; clear HC2; clear HC3; clear HNE; clear HNC; clear D; clear E; clear F.
assert (HNC := perp_not_col _ _ _ HPerp1).
destruct (midpoint_existence A C) as [D HD]; exists A, B, D.
split; [intro; apply HNC; assert_diffs; assert_cols; ColR|split].
intros P Q HOut1 HNE1 HPer HCop1.
destruct (segment_construction_2 C B B P) as [P' [H HCong2]]; [assert_diffs; auto|].
assert (HOut2 : Out B C P') by (assert_diffs; repeat (split; auto)); clear H.
destruct (ex_perp_cop B C P' A) as [Q' [HPerp2 HCop2]]; [assert_diffs; auto|].
assert (HPerp3 : Perp B A Q P).
assert (Coplanar B P P' P) by Cop.
assert (Coplanar A B C P) by Cop.
assert (Coplanar B Q A C) by (assert_diffs; apply col2_cop__cop with A D; Col; Cop).
assert (Coplanar A B C P') by Cop.
assert (Coplanar B P P' Q) by CopR.
assert (Coplanar B P P' Q') by CopR.
destruct (bla B A B C P Q P' Q' B P P') as [I [HC1 HC2]]; Col; Perp; Cop; try (intro; apply HNC; assert_diffs; assert_cols; ColR).
assert (HNE2 : B <> D) by (intro; treat_equalities; apply HNC; assert_cols; Col).
assert (HOS : OS B C P I).
exists I; split; Col; apply l6_4_2; split; try (intro; apply (l9_9_bis _ _ _ _ HOS)).
apply l9_8_2 with D; try apply one_side_transitivity with A.

*****
H5 : Bet D B I
HOS : OS B C P I
HNE2 : not (eq B D)
HC2 : Col P' Q' I
HC1 : Col P Q I
I : Tpoint
H4 : Coplanar B P P' Q'
H3 : Coplanar B P P' Q
H2 : Coplanar A B C P'
H1 : Coplanar B Q A C
H0 : Coplanar A B C P
H : Coplanar B P P' P
HPerp3 : Perp B A Q P
HCop2 : Coplanar B C A Q'
HPerp2 : Perp B C Q' P'
Q' : Tpoint
HOut2 : Out B C P'
HCong2 : Cong B P' B P
P' : Tpoint
HCop1 : Coplanar A B D Q
HPer : Per B P Q
HNE1 : not (eq P Q)
HOut1 : Out B A P
P,Q : Tpoint
HD : Midpoint D A C
D : Tpoint
HNC : not (Col B A C)
HPerp1 : Perp B A C B
HCong1 : Cong B A B C
C,B,A : Tpoint
bla : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
TS B C D I
+++++
apply one_side_symmetry in HOS; apply one_side_not_col123 in HOS.
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro bla.
cut (exists A B C, ~ Col A B C /\\ Acute A B C /\\ forall P Q, Out B A P -> P <> Q -> Per B P Q -> Coplanar A B C Q -> exists Y, Out B C Y /\\ Col P Q Y).
destruct lower_dim_ex as [C [E [D H]]].
assert (HNC : ~ Col C E D) by auto; clear H.
destruct (l8_18_existence D E C) as [B [HC1 HPerp]]; Col.
assert (HF : exists F, Col D E F /\\ B <> F); [|destruct HF as [F [HC2 HNE]]].
destruct (segment_construction_2 F B B C) as [A [H HCong1]]; auto.
assert (HC3 : Col D E A) by (induction H; assert_diffs; assert_cols; ColR).
clear H; assert (HPerp1 : Perp B A C B) by (apply perp_sym; apply perp_col0 with D E; assert_diffs; Perp).
clear HPerp; clear HC1; clear HC2; clear HC3; clear HNE; clear HNC; clear D; clear E; clear F.
assert (HNC := perp_not_col _ _ _ HPerp1).
destruct (midpoint_existence A C) as [D HD]; exists A, B, D.
split; [intro; apply HNC; assert_diffs; assert_cols; ColR|split].
intros P Q HOut1 HNE1 HPer HCop1.
destruct (segment_construction_2 C B B P) as [P' [H HCong2]]; [assert_diffs; auto|].
assert (HOut2 : Out B C P') by (assert_diffs; repeat (split; auto)); clear H.
destruct (ex_perp_cop B C P' A) as [Q' [HPerp2 HCop2]]; [assert_diffs; auto|].
assert (HPerp3 : Perp B A Q P).
assert (Coplanar B P P' P) by Cop.
assert (Coplanar A B C P) by Cop.
assert (Coplanar B Q A C) by (assert_diffs; apply col2_cop__cop with A D; Col; Cop).
assert (Coplanar A B C P') by Cop.
assert (Coplanar B P P' Q) by CopR.
assert (Coplanar B P P' Q') by CopR.
destruct (bla B A B C P Q P' Q' B P P') as [I [HC1 HC2]]; Col; Perp; Cop; try (intro; apply HNC; assert_diffs; assert_cols; ColR).
assert (HNE2 : B <> D) by (intro; treat_equalities; apply HNC; assert_cols; Col).
assert (HOS : OS B C P I).
exists I; split; Col; apply l6_4_2; split; try (intro; apply (l9_9_bis _ _ _ _ HOS)).
apply l9_8_2 with D; try apply one_side_transitivity with A.
apply one_side_symmetry in HOS; apply one_side_not_col123 in HOS.

*****
H5 : Bet D B I
HOS : not (Col B C I)
HNE2 : not (eq B D)
HC2 : Col P' Q' I
HC1 : Col P Q I
I : Tpoint
H4 : Coplanar B P P' Q'
H3 : Coplanar B P P' Q
H2 : Coplanar A B C P'
H1 : Coplanar B Q A C
H0 : Coplanar A B C P
H : Coplanar B P P' P
HPerp3 : Perp B A Q P
HCop2 : Coplanar B C A Q'
HPerp2 : Perp B C Q' P'
Q' : Tpoint
HOut2 : Out B C P'
HCong2 : Cong B P' B P
P' : Tpoint
HCop1 : Coplanar A B D Q
HPer : Per B P Q
HNE1 : not (eq P Q)
HOut1 : Out B A P
P,Q : Tpoint
HD : Midpoint D A C
D : Tpoint
HNC : not (Col B A C)
HPerp1 : Perp B A C B
HCong1 : Cong B A B C
C,B,A : Tpoint
bla : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
TS B C D I
+++++
assert_diffs; assert_cols.
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro bla.
cut (exists A B C, ~ Col A B C /\\ Acute A B C /\\ forall P Q, Out B A P -> P <> Q -> Per B P Q -> Coplanar A B C Q -> exists Y, Out B C Y /\\ Col P Q Y).
destruct lower_dim_ex as [C [E [D H]]].
assert (HNC : ~ Col C E D) by auto; clear H.
destruct (l8_18_existence D E C) as [B [HC1 HPerp]]; Col.
assert (HF : exists F, Col D E F /\\ B <> F); [|destruct HF as [F [HC2 HNE]]].
destruct (segment_construction_2 F B B C) as [A [H HCong1]]; auto.
assert (HC3 : Col D E A) by (induction H; assert_diffs; assert_cols; ColR).
clear H; assert (HPerp1 : Perp B A C B) by (apply perp_sym; apply perp_col0 with D E; assert_diffs; Perp).
clear HPerp; clear HC1; clear HC2; clear HC3; clear HNE; clear HNC; clear D; clear E; clear F.
assert (HNC := perp_not_col _ _ _ HPerp1).
destruct (midpoint_existence A C) as [D HD]; exists A, B, D.
split; [intro; apply HNC; assert_diffs; assert_cols; ColR|split].
intros P Q HOut1 HNE1 HPer HCop1.
destruct (segment_construction_2 C B B P) as [P' [H HCong2]]; [assert_diffs; auto|].
assert (HOut2 : Out B C P') by (assert_diffs; repeat (split; auto)); clear H.
destruct (ex_perp_cop B C P' A) as [Q' [HPerp2 HCop2]]; [assert_diffs; auto|].
assert (HPerp3 : Perp B A Q P).
assert (Coplanar B P P' P) by Cop.
assert (Coplanar A B C P) by Cop.
assert (Coplanar B Q A C) by (assert_diffs; apply col2_cop__cop with A D; Col; Cop).
assert (Coplanar A B C P') by Cop.
assert (Coplanar B P P' Q) by CopR.
assert (Coplanar B P P' Q') by CopR.
destruct (bla B A B C P Q P' Q' B P P') as [I [HC1 HC2]]; Col; Perp; Cop; try (intro; apply HNC; assert_diffs; assert_cols; ColR).
assert (HNE2 : B <> D) by (intro; treat_equalities; apply HNC; assert_cols; Col).
assert (HOS : OS B C P I).
exists I; split; Col; apply l6_4_2; split; try (intro; apply (l9_9_bis _ _ _ _ HOS)).
apply l9_8_2 with D; try apply one_side_transitivity with A.
apply one_side_symmetry in HOS; apply one_side_not_col123 in HOS.
assert_diffs; assert_cols.

*****
H21 : Col B A P
H20 : Col B C P'
H19 : Col D A C
H16 : Col D B I
H15 : not (eq B P)
H18 : not (eq P' B)
H17 : not (eq Q' P')
H7 : not (eq B Q)
H14 : not (eq D C)
H13 : not (eq D A)
H6 : not (eq D I)
H10 : not (eq A C)
H12 : not (eq B A)
H11 : not (eq B I)
H8 : not (eq C I)
H9 : not (eq B C)
H5 : Bet D B I
HOS : not (Col B C I)
HNE2 : not (eq B D)
HC2 : Col P' Q' I
HC1 : Col P Q I
I : Tpoint
H4 : Coplanar B P P' Q'
H3 : Coplanar B P P' Q
H2 : Coplanar A B C P'
H1 : Coplanar B Q A C
H0 : Coplanar A B C P
H : Coplanar B P P' P
HPerp3 : Perp B A Q P
HCop2 : Coplanar B C A Q'
HPerp2 : Perp B C Q' P'
Q' : Tpoint
HOut2 : Out B C P'
HCong2 : Cong B P' B P
P' : Tpoint
HCop1 : Coplanar A B D Q
HPer : Per B P Q
HNE1 : not (eq P Q)
HOut1 : Out B A P
P,Q : Tpoint
HD : Midpoint D A C
D : Tpoint
HNC : not (Col B A C)
HPerp1 : Perp B A C B
HCong1 : Cong B A B C
C,B,A : Tpoint
bla : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
TS B C D I
+++++
split; [intro; apply HNC; ColR|split; Col].
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro bla.
cut (exists A B C, ~ Col A B C /\\ Acute A B C /\\ forall P Q, Out B A P -> P <> Q -> Per B P Q -> Coplanar A B C Q -> exists Y, Out B C Y /\\ Col P Q Y).
destruct lower_dim_ex as [C [E [D H]]].
assert (HNC : ~ Col C E D) by auto; clear H.
destruct (l8_18_existence D E C) as [B [HC1 HPerp]]; Col.
assert (HF : exists F, Col D E F /\\ B <> F); [|destruct HF as [F [HC2 HNE]]].
destruct (segment_construction_2 F B B C) as [A [H HCong1]]; auto.
assert (HC3 : Col D E A) by (induction H; assert_diffs; assert_cols; ColR).
clear H; assert (HPerp1 : Perp B A C B) by (apply perp_sym; apply perp_col0 with D E; assert_diffs; Perp).
clear HPerp; clear HC1; clear HC2; clear HC3; clear HNE; clear HNC; clear D; clear E; clear F.
assert (HNC := perp_not_col _ _ _ HPerp1).
destruct (midpoint_existence A C) as [D HD]; exists A, B, D.
split; [intro; apply HNC; assert_diffs; assert_cols; ColR|split].
intros P Q HOut1 HNE1 HPer HCop1.
destruct (segment_construction_2 C B B P) as [P' [H HCong2]]; [assert_diffs; auto|].
assert (HOut2 : Out B C P') by (assert_diffs; repeat (split; auto)); clear H.
destruct (ex_perp_cop B C P' A) as [Q' [HPerp2 HCop2]]; [assert_diffs; auto|].
assert (HPerp3 : Perp B A Q P).
assert (Coplanar B P P' P) by Cop.
assert (Coplanar A B C P) by Cop.
assert (Coplanar B Q A C) by (assert_diffs; apply col2_cop__cop with A D; Col; Cop).
assert (Coplanar A B C P') by Cop.
assert (Coplanar B P P' Q) by CopR.
assert (Coplanar B P P' Q') by CopR.
destruct (bla B A B C P Q P' Q' B P P') as [I [HC1 HC2]]; Col; Perp; Cop; try (intro; apply HNC; assert_diffs; assert_cols; ColR).
assert (HNE2 : B <> D) by (intro; treat_equalities; apply HNC; assert_cols; Col).
assert (HOS : OS B C P I).
exists I; split; Col; apply l6_4_2; split; try (intro; apply (l9_9_bis _ _ _ _ HOS)).
apply l9_8_2 with D; try apply one_side_transitivity with A.
apply one_side_symmetry in HOS; apply one_side_not_col123 in HOS.
assert_diffs; assert_cols.
split; [intro; apply HNC; ColR|split; Col].

*****
H21 : Col B A P
H20 : Col B C P'
H19 : Col D A C
H16 : Col D B I
H15 : not (eq B P)
H18 : not (eq P' B)
H17 : not (eq Q' P')
H7 : not (eq B Q)
H14 : not (eq D C)
H13 : not (eq D A)
H6 : not (eq D I)
H10 : not (eq A C)
H12 : not (eq B A)
H11 : not (eq B I)
H8 : not (eq C I)
H9 : not (eq B C)
H5 : Bet D B I
HOS : not (Col B C I)
HNE2 : not (eq B D)
HC2 : Col P' Q' I
HC1 : Col P Q I
I : Tpoint
H4 : Coplanar B P P' Q'
H3 : Coplanar B P P' Q
H2 : Coplanar A B C P'
H1 : Coplanar B Q A C
H0 : Coplanar A B C P
H : Coplanar B P P' P
HPerp3 : Perp B A Q P
HCop2 : Coplanar B C A Q'
HPerp2 : Perp B C Q' P'
Q' : Tpoint
HOut2 : Out B C P'
HCong2 : Cong B P' B P
P' : Tpoint
HCop1 : Coplanar A B D Q
HPer : Per B P Q
HNE1 : not (eq P Q)
HOut1 : Out B A P
P,Q : Tpoint
HD : Midpoint D A C
D : Tpoint
HNC : not (Col B A C)
HPerp1 : Perp B A C B
HCong1 : Cong B A B C
C,B,A : Tpoint
bla : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun T : Tpoint => and (Col T B C) (Bet D T I))
+++++
exists B; split; Col.
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro bla.
cut (exists A B C, ~ Col A B C /\\ Acute A B C /\\ forall P Q, Out B A P -> P <> Q -> Per B P Q -> Coplanar A B C Q -> exists Y, Out B C Y /\\ Col P Q Y).
destruct lower_dim_ex as [C [E [D H]]].
assert (HNC : ~ Col C E D) by auto; clear H.
destruct (l8_18_existence D E C) as [B [HC1 HPerp]]; Col.
assert (HF : exists F, Col D E F /\\ B <> F); [|destruct HF as [F [HC2 HNE]]].
destruct (segment_construction_2 F B B C) as [A [H HCong1]]; auto.
assert (HC3 : Col D E A) by (induction H; assert_diffs; assert_cols; ColR).
clear H; assert (HPerp1 : Perp B A C B) by (apply perp_sym; apply perp_col0 with D E; assert_diffs; Perp).
clear HPerp; clear HC1; clear HC2; clear HC3; clear HNE; clear HNC; clear D; clear E; clear F.
assert (HNC := perp_not_col _ _ _ HPerp1).
destruct (midpoint_existence A C) as [D HD]; exists A, B, D.
split; [intro; apply HNC; assert_diffs; assert_cols; ColR|split].
intros P Q HOut1 HNE1 HPer HCop1.
destruct (segment_construction_2 C B B P) as [P' [H HCong2]]; [assert_diffs; auto|].
assert (HOut2 : Out B C P') by (assert_diffs; repeat (split; auto)); clear H.
destruct (ex_perp_cop B C P' A) as [Q' [HPerp2 HCop2]]; [assert_diffs; auto|].
assert (HPerp3 : Perp B A Q P).
assert (Coplanar B P P' P) by Cop.
assert (Coplanar A B C P) by Cop.
assert (Coplanar B Q A C) by (assert_diffs; apply col2_cop__cop with A D; Col; Cop).
assert (Coplanar A B C P') by Cop.
assert (Coplanar B P P' Q) by CopR.
assert (Coplanar B P P' Q') by CopR.
destruct (bla B A B C P Q P' Q' B P P') as [I [HC1 HC2]]; Col; Perp; Cop; try (intro; apply HNC; assert_diffs; assert_cols; ColR).
assert (HNE2 : B <> D) by (intro; treat_equalities; apply HNC; assert_cols; Col).
assert (HOS : OS B C P I).
exists I; split; Col; apply l6_4_2; split; try (intro; apply (l9_9_bis _ _ _ _ HOS)).
apply l9_8_2 with D; try apply one_side_transitivity with A.

*****
H5 : Bet D B I
HOS : OS B C P I
HNE2 : not (eq B D)
HC2 : Col P' Q' I
HC1 : Col P Q I
I : Tpoint
H4 : Coplanar B P P' Q'
H3 : Coplanar B P P' Q
H2 : Coplanar A B C P'
H1 : Coplanar B Q A C
H0 : Coplanar A B C P
H : Coplanar B P P' P
HPerp3 : Perp B A Q P
HCop2 : Coplanar B C A Q'
HPerp2 : Perp B C Q' P'
Q' : Tpoint
HOut2 : Out B C P'
HCong2 : Cong B P' B P
P' : Tpoint
HCop1 : Coplanar A B D Q
HPer : Per B P Q
HNE1 : not (eq P Q)
HOut1 : Out B A P
P,Q : Tpoint
HD : Midpoint D A C
D : Tpoint
HNC : not (Col B A C)
HPerp1 : Perp B A C B
HCong1 : Cong B A B C
C,B,A : Tpoint
bla : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OS B C D A
+++++
assert_diffs; assert_cols; apply l9_19 with C; Col.
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro bla.
cut (exists A B C, ~ Col A B C /\\ Acute A B C /\\ forall P Q, Out B A P -> P <> Q -> Per B P Q -> Coplanar A B C Q -> exists Y, Out B C Y /\\ Col P Q Y).
destruct lower_dim_ex as [C [E [D H]]].
assert (HNC : ~ Col C E D) by auto; clear H.
destruct (l8_18_existence D E C) as [B [HC1 HPerp]]; Col.
assert (HF : exists F, Col D E F /\\ B <> F); [|destruct HF as [F [HC2 HNE]]].
destruct (segment_construction_2 F B B C) as [A [H HCong1]]; auto.
assert (HC3 : Col D E A) by (induction H; assert_diffs; assert_cols; ColR).
clear H; assert (HPerp1 : Perp B A C B) by (apply perp_sym; apply perp_col0 with D E; assert_diffs; Perp).
clear HPerp; clear HC1; clear HC2; clear HC3; clear HNE; clear HNC; clear D; clear E; clear F.
assert (HNC := perp_not_col _ _ _ HPerp1).
destruct (midpoint_existence A C) as [D HD]; exists A, B, D.
split; [intro; apply HNC; assert_diffs; assert_cols; ColR|split].
intros P Q HOut1 HNE1 HPer HCop1.
destruct (segment_construction_2 C B B P) as [P' [H HCong2]]; [assert_diffs; auto|].
assert (HOut2 : Out B C P') by (assert_diffs; repeat (split; auto)); clear H.
destruct (ex_perp_cop B C P' A) as [Q' [HPerp2 HCop2]]; [assert_diffs; auto|].
assert (HPerp3 : Perp B A Q P).
assert (Coplanar B P P' P) by Cop.
assert (Coplanar A B C P) by Cop.
assert (Coplanar B Q A C) by (assert_diffs; apply col2_cop__cop with A D; Col; Cop).
assert (Coplanar A B C P') by Cop.
assert (Coplanar B P P' Q) by CopR.
assert (Coplanar B P P' Q') by CopR.
destruct (bla B A B C P Q P' Q' B P P') as [I [HC1 HC2]]; Col; Perp; Cop; try (intro; apply HNC; assert_diffs; assert_cols; ColR).
assert (HNE2 : B <> D) by (intro; treat_equalities; apply HNC; assert_cols; Col).
assert (HOS : OS B C P I).
exists I; split; Col; apply l6_4_2; split; try (intro; apply (l9_9_bis _ _ _ _ HOS)).
apply l9_8_2 with D; try apply one_side_transitivity with A.
assert_diffs; assert_cols; apply l9_19 with C; Col.

*****
H21 : Col B A P
H19 : Col B C P'
H17 : Col D A C
H14 : Col D B I
H22 : not (eq C I)
H20 : not (eq C P)
H18 : not (eq B I)
H13 : not (eq B P)
H16 : not (eq P' B)
H15 : not (eq Q' P')
H7 : not (eq B Q)
H12 : not (eq D C)
H10 : not (eq D A)
H6 : not (eq D I)
H11 : not (eq B C)
H8 : not (eq A C)
H9 : not (eq B A)
H5 : Bet D B I
HOS : OS B C P I
HNE2 : not (eq B D)
HC2 : Col P' Q' I
HC1 : Col P Q I
I : Tpoint
H4 : Coplanar B P P' Q'
H3 : Coplanar B P P' Q
H2 : Coplanar A B C P'
H1 : Coplanar B Q A C
H0 : Coplanar A B C P
H : Coplanar B P P' P
HPerp3 : Perp B A Q P
HCop2 : Coplanar B C A Q'
HPerp2 : Perp B C Q' P'
Q' : Tpoint
HOut2 : Out B C P'
HCong2 : Cong B P' B P
P' : Tpoint
HCop1 : Coplanar A B D Q
HPer : Per B P Q
HNE1 : not (eq P Q)
HOut1 : Out B A P
P,Q : Tpoint
HD : Midpoint D A C
D : Tpoint
HNC : not (Col B A C)
HPerp1 : Perp B A C B
HCong1 : Cong B A B C
C,B,A : Tpoint
bla : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Out C D A) (not (Col B C D))
+++++
split; [repeat (split; Between)|intro; apply HNC; ColR].
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear bla; intro bla.
cut (exists A B C, ~ Col A B C /\\ Acute A B C /\\ forall P Q, Out B A P -> P <> Q -> Per B P Q -> Coplanar A B C Q -> exists Y, Out B C Y /\\ Col P Q Y).
destruct lower_dim_ex as [C [E [D H]]].
assert (HNC : ~ Col C E D) by auto; clear H.
destruct (l8_18_existence D E C) as [B [HC1 HPerp]]; Col.
assert (HF : exists F, Col D E F /\\ B <> F); [|destruct HF as [F [HC2 HNE]]].
destruct (segment_construction_2 F B B C) as [A [H HCong1]]; auto.
assert (HC3 : Col D E A) by (induction H; assert_diffs; assert_cols; ColR).
clear H; assert (HPerp1 : Perp B A C B) by (apply perp_sym; apply perp_col0 with D E; assert_diffs; Perp).
clear HPerp; clear HC1; clear HC2; clear HC3; clear HNE; clear HNC; clear D; clear E; clear F.
assert (HNC := perp_not_col _ _ _ HPerp1).
destruct (midpoint_existence A C) as [D HD]; exists A, B, D.
split; [intro; apply HNC; assert_diffs; assert_cols; ColR|split].
intros P Q HOut1 HNE1 HPer HCop1.
destruct (segment_construction_2 C B B P) as [P' [H HCong2]]; [assert_diffs; auto|].
assert (HOut2 : Out B C P') by (assert_diffs; repeat (split; auto)); clear H.
destruct (ex_perp_cop B C P' A) as [Q' [HPerp2 HCop2]]; [assert_diffs; auto|].
assert (HPerp3 : Perp B A Q P).
assert (Coplanar B P P' P) by Cop.
assert (Coplanar A B C P) by Cop.
assert (Coplanar B Q A C) by (assert_diffs; apply col2_cop__cop with A D; Col; Cop).
assert (Coplanar A B C P') by Cop.
assert (Coplanar B P P' Q) by CopR.
assert (Coplanar B P P' Q') by CopR.
destruct (bla B A B C P Q P' Q' B P P') as [I [HC1 HC2]]; Col; Perp; Cop; try (intro; apply HNC; assert_diffs; assert_cols; ColR).
assert (HNE2 : B <> D) by (intro; treat_equalities; apply HNC; assert_cols; Col).
assert (HOS : OS B C P I).
exists I; split; Col; apply l6_4_2; split; try (intro; apply (l9_9_bis _ _ _ _ HOS)).
apply l9_8_2 with D; try apply one_side_transitivity with A.

*****
H5 : Bet D B I
HOS : OS B C P I
HNE2 : not (eq B D)
HC2 : Col P' Q' I
HC1 : Col P Q I
I : Tpoint
H4 : Coplanar B P P' Q'
H3 : Coplanar B P P' Q
H2 : Coplanar A B C P'
H1 : Coplanar B Q A C
H0 : Coplanar A B C P
H : Coplanar B P P' P
HPerp3 : Perp B A Q P
HCop2 : Coplanar B C A Q'
HPerp2 : Perp B C Q' P'
Q' : Tpoint
HOut2 : Out B C P'
HCong2 : Cong B P' B P
P' : Tpoint
HCop1 : Coplanar A B D Q
HPer : Per B P Q
HNE1 : not (eq P Q)
HOut1 : Out B A P
P,Q : Tpoint
HD : Midpoint D A C
D : Tpoint
HNC : not (Col B A C)
HPerp1 : Perp B A C B
HCong1 : Cong B A B C
C,B,A : Tpoint
bla : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OS B C A P
+++++
assert_diffs; assert_cols; apply l9_19 with B; Col.
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).

*****
bla : bachmann_s_lotschnittaxiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint) (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2) (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC) (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD) (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2) (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2) (_ : not (Col IAB IAC IBD)), ex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
+++++
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.

*****
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,IAB,IAC,IBD : Tpoint
bla : bachmann_s_lotschnittaxiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC) (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD) (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2) (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2) (_ : not (Col IAB IAC IBD)), ex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
+++++
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HNCop1 HCop2 HCop3 HCop4 HNC1.
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HNCop1 HCop2 HCop3 HCop4 HNC1.

*****
HNC1 : not (Col IAB IAC IBD)
HCop4 : Coplanar IAB IAC IBD D2
HCop3 : Coplanar IAB IAC IBD D1
HCop2 : Coplanar IAB IAC IBD C2
HNCop1 : Coplanar IAB IAC IBD C1
HCol6 : Col D1 D2 IBD
HCol5 : Col B1 B2 IBD
HCol4 : Col C1 C2 IAC
HCol3 : Col A1 A2 IAC
HCol2 : Col B1 B2 IAB
HCol1 : Col A1 A2 IAB
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,IAB,IAC,IBD : Tpoint
bla : bachmann_s_lotschnittaxiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
+++++
assert (Col IAB IAC A1) by (assert_diffs; ColR).
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HNCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).

*****
H : Col IAB IAC A1
HNC1 : not (Col IAB IAC IBD)
HCop4 : Coplanar IAB IAC IBD D2
HCop3 : Coplanar IAB IAC IBD D1
HCop2 : Coplanar IAB IAC IBD C2
HNCop1 : Coplanar IAB IAC IBD C1
HCol6 : Col D1 D2 IBD
HCol5 : Col B1 B2 IBD
HCol4 : Col C1 C2 IAC
HCol3 : Col A1 A2 IAC
HCol2 : Col B1 B2 IAB
HCol1 : Col A1 A2 IAB
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,IAB,IAC,IBD : Tpoint
bla : bachmann_s_lotschnittaxiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
+++++
assert (Col IAB IAC A2) by (assert_diffs; ColR).
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HNCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).

*****
H0 : Col IAB IAC A2
H : Col IAB IAC A1
HNC1 : not (Col IAB IAC IBD)
HCop4 : Coplanar IAB IAC IBD D2
HCop3 : Coplanar IAB IAC IBD D1
HCop2 : Coplanar IAB IAC IBD C2
HNCop1 : Coplanar IAB IAC IBD C1
HCol6 : Col D1 D2 IBD
HCol5 : Col B1 B2 IBD
HCol4 : Col C1 C2 IAC
HCol3 : Col A1 A2 IAC
HCol2 : Col B1 B2 IAB
HCol1 : Col A1 A2 IAB
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,IAB,IAC,IBD : Tpoint
bla : bachmann_s_lotschnittaxiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
+++++
assert (Col IAB IBD B1) by (assert_diffs; ColR).
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HNCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).

*****
H1 : Col IAB IBD B1
H0 : Col IAB IAC A2
H : Col IAB IAC A1
HNC1 : not (Col IAB IAC IBD)
HCop4 : Coplanar IAB IAC IBD D2
HCop3 : Coplanar IAB IAC IBD D1
HCop2 : Coplanar IAB IAC IBD C2
HNCop1 : Coplanar IAB IAC IBD C1
HCol6 : Col D1 D2 IBD
HCol5 : Col B1 B2 IBD
HCol4 : Col C1 C2 IAC
HCol3 : Col A1 A2 IAC
HCol2 : Col B1 B2 IAB
HCol1 : Col A1 A2 IAB
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,IAB,IAC,IBD : Tpoint
bla : bachmann_s_lotschnittaxiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
+++++
assert (Col IAB IBD B2) by (assert_diffs; ColR).
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HNCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).

*****
H2 : Col IAB IBD B2
H1 : Col IAB IBD B1
H0 : Col IAB IAC A2
H : Col IAB IAC A1
HNC1 : not (Col IAB IAC IBD)
HCop4 : Coplanar IAB IAC IBD D2
HCop3 : Coplanar IAB IAC IBD D1
HCop2 : Coplanar IAB IAC IBD C2
HNCop1 : Coplanar IAB IAC IBD C1
HCol6 : Col D1 D2 IBD
HCol5 : Col B1 B2 IBD
HCol4 : Col C1 C2 IAC
HCol3 : Col A1 A2 IAC
HCol2 : Col B1 B2 IAB
HCol1 : Col A1 A2 IAB
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,IAB,IAC,IBD : Tpoint
bla : bachmann_s_lotschnittaxiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
+++++
assert (Coplanar IAB IAC IBD A1) by Cop.
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HNCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.

*****
H3 : Coplanar IAB IAC IBD A1
H2 : Col IAB IBD B2
H1 : Col IAB IBD B1
H0 : Col IAB IAC A2
H : Col IAB IAC A1
HNC1 : not (Col IAB IAC IBD)
HCop4 : Coplanar IAB IAC IBD D2
HCop3 : Coplanar IAB IAC IBD D1
HCop2 : Coplanar IAB IAC IBD C2
HNCop1 : Coplanar IAB IAC IBD C1
HCol6 : Col D1 D2 IBD
HCol5 : Col B1 B2 IBD
HCol4 : Col C1 C2 IAC
HCol3 : Col A1 A2 IAC
HCol2 : Col B1 B2 IAB
HCol1 : Col A1 A2 IAB
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,IAB,IAC,IBD : Tpoint
bla : bachmann_s_lotschnittaxiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
+++++
assert (Coplanar IAB IAC IBD A2) by Cop.
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HNCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.

*****
H4 : Coplanar IAB IAC IBD A2
H3 : Coplanar IAB IAC IBD A1
H2 : Col IAB IBD B2
H1 : Col IAB IBD B1
H0 : Col IAB IAC A2
H : Col IAB IAC A1
HNC1 : not (Col IAB IAC IBD)
HCop4 : Coplanar IAB IAC IBD D2
HCop3 : Coplanar IAB IAC IBD D1
HCop2 : Coplanar IAB IAC IBD C2
HNCop1 : Coplanar IAB IAC IBD C1
HCol6 : Col D1 D2 IBD
HCol5 : Col B1 B2 IBD
HCol4 : Col C1 C2 IAC
HCol3 : Col A1 A2 IAC
HCol2 : Col B1 B2 IAB
HCol1 : Col A1 A2 IAB
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,IAB,IAC,IBD : Tpoint
bla : bachmann_s_lotschnittaxiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
+++++
assert (Coplanar IAB IAC IBD B1) by Cop.
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HNCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.
assert (Coplanar IAB IAC IBD B1) by Cop.

*****
H5 : Coplanar IAB IAC IBD B1
H4 : Coplanar IAB IAC IBD A2
H3 : Coplanar IAB IAC IBD A1
H2 : Col IAB IBD B2
H1 : Col IAB IBD B1
H0 : Col IAB IAC A2
H : Col IAB IAC A1
HNC1 : not (Col IAB IAC IBD)
HCop4 : Coplanar IAB IAC IBD D2
HCop3 : Coplanar IAB IAC IBD D1
HCop2 : Coplanar IAB IAC IBD C2
HNCop1 : Coplanar IAB IAC IBD C1
HCol6 : Col D1 D2 IBD
HCol5 : Col B1 B2 IBD
HCol4 : Col C1 C2 IAC
HCol3 : Col A1 A2 IAC
HCol2 : Col B1 B2 IAB
HCol1 : Col A1 A2 IAB
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,IAB,IAC,IBD : Tpoint
bla : bachmann_s_lotschnittaxiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
+++++
assert (Coplanar IAB IAC IBD B2) by Cop.
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HNCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.
assert (Coplanar IAB IAC IBD B1) by Cop.
assert (Coplanar IAB IAC IBD B2) by Cop.

*****
H6 : Coplanar IAB IAC IBD B2
H5 : Coplanar IAB IAC IBD B1
H4 : Coplanar IAB IAC IBD A2
H3 : Coplanar IAB IAC IBD A1
H2 : Col IAB IBD B2
H1 : Col IAB IBD B1
H0 : Col IAB IAC A2
H : Col IAB IAC A1
HNC1 : not (Col IAB IAC IBD)
HCop4 : Coplanar IAB IAC IBD D2
HCop3 : Coplanar IAB IAC IBD D1
HCop2 : Coplanar IAB IAC IBD C2
HNCop1 : Coplanar IAB IAC IBD C1
HCol6 : Col D1 D2 IBD
HCol5 : Col B1 B2 IBD
HCol4 : Col C1 C2 IAC
HCol3 : Col A1 A2 IAC
HCol2 : Col B1 B2 IAB
HCol1 : Col A1 A2 IAB
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,IAB,IAC,IBD : Tpoint
bla : bachmann_s_lotschnittaxiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
+++++
assert (HNC2 : ~ Col A1 A2 D1).
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HNCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.
assert (Coplanar IAB IAC IBD B1) by Cop.
assert (Coplanar IAB IAC IBD B2) by Cop.
assert (HNC2 : ~ Col A1 A2 D1).

*****
H6 : Coplanar IAB IAC IBD B2
H5 : Coplanar IAB IAC IBD B1
H4 : Coplanar IAB IAC IBD A2
H3 : Coplanar IAB IAC IBD A1
H2 : Col IAB IBD B2
H1 : Col IAB IBD B1
H0 : Col IAB IAC A2
H : Col IAB IAC A1
HNC1 : not (Col IAB IAC IBD)
HCop4 : Coplanar IAB IAC IBD D2
HCop3 : Coplanar IAB IAC IBD D1
HCop2 : Coplanar IAB IAC IBD C2
HNCop1 : Coplanar IAB IAC IBD C1
HCol6 : Col D1 D2 IBD
HCol5 : Col B1 B2 IBD
HCol4 : Col C1 C2 IAC
HCol3 : Col A1 A2 IAC
HCol2 : Col B1 B2 IAB
HCol1 : Col A1 A2 IAB
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,IAB,IAC,IBD : Tpoint
bla : bachmann_s_lotschnittaxiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col A1 A2 D1)
+++++
apply par_strict_not_col_1 with D2; apply par_not_col_strict with IBD; Col; try (intro; apply HNC1; assert_diffs; ColR).
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HNCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.
assert (Coplanar IAB IAC IBD B1) by Cop.
assert (Coplanar IAB IAC IBD B2) by Cop.
assert (HNC2 : ~ Col A1 A2 D1).
apply par_strict_not_col_1 with D2; apply par_not_col_strict with IBD; Col; try (intro; apply HNC1; assert_diffs; ColR).

*****
H6 : Coplanar IAB IAC IBD B2
H5 : Coplanar IAB IAC IBD B1
H4 : Coplanar IAB IAC IBD A2
H3 : Coplanar IAB IAC IBD A1
H2 : Col IAB IBD B2
H1 : Col IAB IBD B1
H0 : Col IAB IAC A2
H : Col IAB IAC A1
HNC1 : not (Col IAB IAC IBD)
HCop4 : Coplanar IAB IAC IBD D2
HCop3 : Coplanar IAB IAC IBD D1
HCop2 : Coplanar IAB IAC IBD C2
HNCop1 : Coplanar IAB IAC IBD C1
HCol6 : Col D1 D2 IBD
HCol5 : Col B1 B2 IBD
HCol4 : Col C1 C2 IAC
HCol3 : Col A1 A2 IAC
HCol2 : Col B1 B2 IAB
HCol1 : Col A1 A2 IAB
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,IAB,IAC,IBD : Tpoint
bla : bachmann_s_lotschnittaxiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Par A1 A2 D1 D2
+++++
apply l12_9 with B1 B2; Perp; CopR.
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HNCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.
assert (Coplanar IAB IAC IBD B1) by Cop.
assert (Coplanar IAB IAC IBD B2) by Cop.
assert (HNC2 : ~ Col A1 A2 D1).

*****
HNC2 : not (Col A1 A2 D1)
H6 : Coplanar IAB IAC IBD B2
H5 : Coplanar IAB IAC IBD B1
H4 : Coplanar IAB IAC IBD A2
H3 : Coplanar IAB IAC IBD A1
H2 : Col IAB IBD B2
H1 : Col IAB IBD B1
H0 : Col IAB IAC A2
H : Col IAB IAC A1
HNC1 : not (Col IAB IAC IBD)
HCop4 : Coplanar IAB IAC IBD D2
HCop3 : Coplanar IAB IAC IBD D1
HCop2 : Coplanar IAB IAC IBD C2
HNCop1 : Coplanar IAB IAC IBD C1
HCol6 : Col D1 D2 IBD
HCol5 : Col B1 B2 IBD
HCol4 : Col C1 C2 IAC
HCol3 : Col A1 A2 IAC
HCol2 : Col B1 B2 IAB
HCol1 : Col A1 A2 IAB
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,IAB,IAC,IBD : Tpoint
bla : bachmann_s_lotschnittaxiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
+++++
assert (HNC3 : ~ Col B1 B2 C1).
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HNCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.
assert (Coplanar IAB IAC IBD B1) by Cop.
assert (Coplanar IAB IAC IBD B2) by Cop.
assert (HNC2 : ~ Col A1 A2 D1).
assert (HNC3 : ~ Col B1 B2 C1).

*****
HNC2 : not (Col A1 A2 D1)
H6 : Coplanar IAB IAC IBD B2
H5 : Coplanar IAB IAC IBD B1
H4 : Coplanar IAB IAC IBD A2
H3 : Coplanar IAB IAC IBD A1
H2 : Col IAB IBD B2
H1 : Col IAB IBD B1
H0 : Col IAB IAC A2
H : Col IAB IAC A1
HNC1 : not (Col IAB IAC IBD)
HCop4 : Coplanar IAB IAC IBD D2
HCop3 : Coplanar IAB IAC IBD D1
HCop2 : Coplanar IAB IAC IBD C2
HNCop1 : Coplanar IAB IAC IBD C1
HCol6 : Col D1 D2 IBD
HCol5 : Col B1 B2 IBD
HCol4 : Col C1 C2 IAC
HCol3 : Col A1 A2 IAC
HCol2 : Col B1 B2 IAB
HCol1 : Col A1 A2 IAB
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,IAB,IAC,IBD : Tpoint
bla : bachmann_s_lotschnittaxiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col B1 B2 C1)
+++++
apply par_strict_not_col_1 with C2; apply par_not_col_strict with IAC; Col; try (intro; apply HNC1; assert_diffs; ColR).
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HNCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.
assert (Coplanar IAB IAC IBD B1) by Cop.
assert (Coplanar IAB IAC IBD B2) by Cop.
assert (HNC2 : ~ Col A1 A2 D1).
assert (HNC3 : ~ Col B1 B2 C1).
apply par_strict_not_col_1 with C2; apply par_not_col_strict with IAC; Col; try (intro; apply HNC1; assert_diffs; ColR).

*****
HNC2 : not (Col A1 A2 D1)
H6 : Coplanar IAB IAC IBD B2
H5 : Coplanar IAB IAC IBD B1
H4 : Coplanar IAB IAC IBD A2
H3 : Coplanar IAB IAC IBD A1
H2 : Col IAB IBD B2
H1 : Col IAB IBD B1
H0 : Col IAB IAC A2
H : Col IAB IAC A1
HNC1 : not (Col IAB IAC IBD)
HCop4 : Coplanar IAB IAC IBD D2
HCop3 : Coplanar IAB IAC IBD D1
HCop2 : Coplanar IAB IAC IBD C2
HNCop1 : Coplanar IAB IAC IBD C1
HCol6 : Col D1 D2 IBD
HCol5 : Col B1 B2 IBD
HCol4 : Col C1 C2 IAC
HCol3 : Col A1 A2 IAC
HCol2 : Col B1 B2 IAB
HCol1 : Col A1 A2 IAB
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,IAB,IAC,IBD : Tpoint
bla : bachmann_s_lotschnittaxiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Par B1 B2 C1 C2
+++++
apply l12_9 with A1 A2; Perp; CopR.
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HNCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.
assert (Coplanar IAB IAC IBD B1) by Cop.
assert (Coplanar IAB IAC IBD B2) by Cop.
assert (HNC2 : ~ Col A1 A2 D1).
assert (HNC3 : ~ Col B1 B2 C1).

*****
HNC3 : not (Col B1 B2 C1)
HNC2 : not (Col A1 A2 D1)
H6 : Coplanar IAB IAC IBD B2
H5 : Coplanar IAB IAC IBD B1
H4 : Coplanar IAB IAC IBD A2
H3 : Coplanar IAB IAC IBD A1
H2 : Col IAB IBD B2
H1 : Col IAB IBD B1
H0 : Col IAB IAC A2
H : Col IAB IAC A1
HNC1 : not (Col IAB IAC IBD)
HCop4 : Coplanar IAB IAC IBD D2
HCop3 : Coplanar IAB IAC IBD D1
HCop2 : Coplanar IAB IAC IBD C2
HNCop1 : Coplanar IAB IAC IBD C1
HCol6 : Col D1 D2 IBD
HCol5 : Col B1 B2 IBD
HCol4 : Col C1 C2 IAC
HCol3 : Col A1 A2 IAC
HCol2 : Col B1 B2 IAB
HCol1 : Col A1 A2 IAB
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,IAB,IAC,IBD : Tpoint
bla : bachmann_s_lotschnittaxiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
+++++
assert (HParA : Par_strict A1 A2 D1 D2).
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HNCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.
assert (Coplanar IAB IAC IBD B1) by Cop.
assert (Coplanar IAB IAC IBD B2) by Cop.
assert (HNC2 : ~ Col A1 A2 D1).
assert (HNC3 : ~ Col B1 B2 C1).
assert (HParA : Par_strict A1 A2 D1 D2).

*****
HNC3 : not (Col B1 B2 C1)
HNC2 : not (Col A1 A2 D1)
H6 : Coplanar IAB IAC IBD B2
H5 : Coplanar IAB IAC IBD B1
H4 : Coplanar IAB IAC IBD A2
H3 : Coplanar IAB IAC IBD A1
H2 : Col IAB IBD B2
H1 : Col IAB IBD B1
H0 : Col IAB IAC A2
H : Col IAB IAC A1
HNC1 : not (Col IAB IAC IBD)
HCop4 : Coplanar IAB IAC IBD D2
HCop3 : Coplanar IAB IAC IBD D1
HCop2 : Coplanar IAB IAC IBD C2
HNCop1 : Coplanar IAB IAC IBD C1
HCol6 : Col D1 D2 IBD
HCol5 : Col B1 B2 IBD
HCol4 : Col C1 C2 IAC
HCol3 : Col A1 A2 IAC
HCol2 : Col B1 B2 IAB
HCol1 : Col A1 A2 IAB
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,IAB,IAC,IBD : Tpoint
bla : bachmann_s_lotschnittaxiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Par_strict A1 A2 D1 D2
+++++
apply par_not_col_strict with D1; Col; apply l12_9 with B1 B2; Perp; CopR.
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HNCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.
assert (Coplanar IAB IAC IBD B1) by Cop.
assert (Coplanar IAB IAC IBD B2) by Cop.
assert (HNC2 : ~ Col A1 A2 D1).
assert (HNC3 : ~ Col B1 B2 C1).
assert (HParA : Par_strict A1 A2 D1 D2).
apply par_not_col_strict with D1; Col; apply l12_9 with B1 B2; Perp; CopR.

*****
HParA : Par_strict A1 A2 D1 D2
HNC3 : not (Col B1 B2 C1)
HNC2 : not (Col A1 A2 D1)
H6 : Coplanar IAB IAC IBD B2
H5 : Coplanar IAB IAC IBD B1
H4 : Coplanar IAB IAC IBD A2
H3 : Coplanar IAB IAC IBD A1
H2 : Col IAB IBD B2
H1 : Col IAB IBD B1
H0 : Col IAB IAC A2
H : Col IAB IAC A1
HNC1 : not (Col IAB IAC IBD)
HCop4 : Coplanar IAB IAC IBD D2
HCop3 : Coplanar IAB IAC IBD D1
HCop2 : Coplanar IAB IAC IBD C2
HNCop1 : Coplanar IAB IAC IBD C1
HCol6 : Col D1 D2 IBD
HCol5 : Col B1 B2 IBD
HCol4 : Col C1 C2 IAC
HCol3 : Col A1 A2 IAC
HCol2 : Col B1 B2 IAB
HCol1 : Col A1 A2 IAB
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,IAB,IAC,IBD : Tpoint
bla : bachmann_s_lotschnittaxiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
+++++
assert (HParB : Par_strict B1 B2 C1 C2).
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HNCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.
assert (Coplanar IAB IAC IBD B1) by Cop.
assert (Coplanar IAB IAC IBD B2) by Cop.
assert (HNC2 : ~ Col A1 A2 D1).
assert (HNC3 : ~ Col B1 B2 C1).
assert (HParA : Par_strict A1 A2 D1 D2).
apply par_not_col_strict with D1; Col; apply l12_9 with B1 B2; Perp; CopR.
assert (HParB : Par_strict B1 B2 C1 C2).

*****
HParA : Par_strict A1 A2 D1 D2
HNC3 : not (Col B1 B2 C1)
HNC2 : not (Col A1 A2 D1)
H6 : Coplanar IAB IAC IBD B2
H5 : Coplanar IAB IAC IBD B1
H4 : Coplanar IAB IAC IBD A2
H3 : Coplanar IAB IAC IBD A1
H2 : Col IAB IBD B2
H1 : Col IAB IBD B1
H0 : Col IAB IAC A2
H : Col IAB IAC A1
HNC1 : not (Col IAB IAC IBD)
HCop4 : Coplanar IAB IAC IBD D2
HCop3 : Coplanar IAB IAC IBD D1
HCop2 : Coplanar IAB IAC IBD C2
HNCop1 : Coplanar IAB IAC IBD C1
HCol6 : Col D1 D2 IBD
HCol5 : Col B1 B2 IBD
HCol4 : Col C1 C2 IAC
HCol3 : Col A1 A2 IAC
HCol2 : Col B1 B2 IAB
HCol1 : Col A1 A2 IAB
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,IAB,IAC,IBD : Tpoint
bla : bachmann_s_lotschnittaxiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Par_strict B1 B2 C1 C2
+++++
apply par_not_col_strict with C1; Col; apply l12_9 with A1 A2; Perp; CopR.
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HNCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.
assert (Coplanar IAB IAC IBD B1) by Cop.
assert (Coplanar IAB IAC IBD B2) by Cop.
assert (HNC2 : ~ Col A1 A2 D1).
assert (HNC3 : ~ Col B1 B2 C1).
assert (HParA : Par_strict A1 A2 D1 D2).
apply par_not_col_strict with D1; Col; apply l12_9 with B1 B2; Perp; CopR.
assert (HParB : Par_strict B1 B2 C1 C2).
apply par_not_col_strict with C1; Col; apply l12_9 with A1 A2; Perp; CopR.

*****
HParB : Par_strict B1 B2 C1 C2
HParA : Par_strict A1 A2 D1 D2
HNC3 : not (Col B1 B2 C1)
HNC2 : not (Col A1 A2 D1)
H6 : Coplanar IAB IAC IBD B2
H5 : Coplanar IAB IAC IBD B1
H4 : Coplanar IAB IAC IBD A2
H3 : Coplanar IAB IAC IBD A1
H2 : Col IAB IBD B2
H1 : Col IAB IBD B1
H0 : Col IAB IAC A2
H : Col IAB IAC A1
HNC1 : not (Col IAB IAC IBD)
HCop4 : Coplanar IAB IAC IBD D2
HCop3 : Coplanar IAB IAC IBD D1
HCop2 : Coplanar IAB IAC IBD C2
HNCop1 : Coplanar IAB IAC IBD C1
HCol6 : Col D1 D2 IBD
HCol5 : Col B1 B2 IBD
HCol4 : Col C1 C2 IAC
HCol3 : Col A1 A2 IAC
HCol2 : Col B1 B2 IAB
HCol1 : Col A1 A2 IAB
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,IAB,IAC,IBD : Tpoint
bla : bachmann_s_lotschnittaxiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
+++++
assert (HNCol3 : ~ Col IAC B1 B2) by (apply par_not_col with C1 C2; Par; ColR).
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HNCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.
assert (Coplanar IAB IAC IBD B1) by Cop.
assert (Coplanar IAB IAC IBD B2) by Cop.
assert (HNC2 : ~ Col A1 A2 D1).
assert (HNC3 : ~ Col B1 B2 C1).
assert (HParA : Par_strict A1 A2 D1 D2).
apply par_not_col_strict with D1; Col; apply l12_9 with B1 B2; Perp; CopR.
assert (HParB : Par_strict B1 B2 C1 C2).
apply par_not_col_strict with C1; Col; apply l12_9 with A1 A2; Perp; CopR.
assert (HNCol3 : ~ Col IAC B1 B2) by (apply par_not_col with C1 C2; Par; ColR).

*****
HNCol3 : not (Col IAC B1 B2)
HParB : Par_strict B1 B2 C1 C2
HParA : Par_strict A1 A2 D1 D2
HNC3 : not (Col B1 B2 C1)
HNC2 : not (Col A1 A2 D1)
H6 : Coplanar IAB IAC IBD B2
H5 : Coplanar IAB IAC IBD B1
H4 : Coplanar IAB IAC IBD A2
H3 : Coplanar IAB IAC IBD A1
H2 : Col IAB IBD B2
H1 : Col IAB IBD B1
H0 : Col IAB IAC A2
H : Col IAB IAC A1
HNC1 : not (Col IAB IAC IBD)
HCop4 : Coplanar IAB IAC IBD D2
HCop3 : Coplanar IAB IAC IBD D1
HCop2 : Coplanar IAB IAC IBD C2
HNCop1 : Coplanar IAB IAC IBD C1
HCol6 : Col D1 D2 IBD
HCol5 : Col B1 B2 IBD
HCol4 : Col C1 C2 IAC
HCol3 : Col A1 A2 IAC
HCol2 : Col B1 B2 IAB
HCol1 : Col A1 A2 IAB
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,IAB,IAC,IBD : Tpoint
bla : bachmann_s_lotschnittaxiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
+++++
assert (HNCol4 : ~ Col IBD A1 A2) by (apply par_not_col with D1 D2; Par; ColR).
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HNCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.
assert (Coplanar IAB IAC IBD B1) by Cop.
assert (Coplanar IAB IAC IBD B2) by Cop.
assert (HNC2 : ~ Col A1 A2 D1).
assert (HNC3 : ~ Col B1 B2 C1).
assert (HParA : Par_strict A1 A2 D1 D2).
apply par_not_col_strict with D1; Col; apply l12_9 with B1 B2; Perp; CopR.
assert (HParB : Par_strict B1 B2 C1 C2).
apply par_not_col_strict with C1; Col; apply l12_9 with A1 A2; Perp; CopR.
assert (HNCol3 : ~ Col IAC B1 B2) by (apply par_not_col with C1 C2; Par; ColR).
assert (HNCol4 : ~ Col IBD A1 A2) by (apply par_not_col with D1 D2; Par; ColR).

*****
HNCol4 : not (Col IBD A1 A2)
HNCol3 : not (Col IAC B1 B2)
HParB : Par_strict B1 B2 C1 C2
HParA : Par_strict A1 A2 D1 D2
HNC3 : not (Col B1 B2 C1)
HNC2 : not (Col A1 A2 D1)
H6 : Coplanar IAB IAC IBD B2
H5 : Coplanar IAB IAC IBD B1
H4 : Coplanar IAB IAC IBD A2
H3 : Coplanar IAB IAC IBD A1
H2 : Col IAB IBD B2
H1 : Col IAB IBD B1
H0 : Col IAB IAC A2
H : Col IAB IAC A1
HNC1 : not (Col IAB IAC IBD)
HCop4 : Coplanar IAB IAC IBD D2
HCop3 : Coplanar IAB IAC IBD D1
HCop2 : Coplanar IAB IAC IBD C2
HNCop1 : Coplanar IAB IAC IBD C1
HCol6 : Col D1 D2 IBD
HCol5 : Col B1 B2 IBD
HCol4 : Col C1 C2 IAC
HCol3 : Col A1 A2 IAC
HCol2 : Col B1 B2 IAB
HCol1 : Col A1 A2 IAB
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,IAB,IAC,IBD : Tpoint
bla : bachmann_s_lotschnittaxiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
+++++
assert (HPQ : IAC <> IAB) by (assert_diffs; auto).
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HNCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.
assert (Coplanar IAB IAC IBD B1) by Cop.
assert (Coplanar IAB IAC IBD B2) by Cop.
assert (HNC2 : ~ Col A1 A2 D1).
assert (HNC3 : ~ Col B1 B2 C1).
assert (HParA : Par_strict A1 A2 D1 D2).
apply par_not_col_strict with D1; Col; apply l12_9 with B1 B2; Perp; CopR.
assert (HParB : Par_strict B1 B2 C1 C2).
apply par_not_col_strict with C1; Col; apply l12_9 with A1 A2; Perp; CopR.
assert (HNCol3 : ~ Col IAC B1 B2) by (apply par_not_col with C1 C2; Par; ColR).
assert (HNCol4 : ~ Col IBD A1 A2) by (apply par_not_col with D1 D2; Par; ColR).
assert (HPQ : IAC <> IAB) by (assert_diffs; auto).

*****
HPQ : not (eq IAC IAB)
HNCol4 : not (Col IBD A1 A2)
HNCol3 : not (Col IAC B1 B2)
HParB : Par_strict B1 B2 C1 C2
HParA : Par_strict A1 A2 D1 D2
HNC3 : not (Col B1 B2 C1)
HNC2 : not (Col A1 A2 D1)
H6 : Coplanar IAB IAC IBD B2
H5 : Coplanar IAB IAC IBD B1
H4 : Coplanar IAB IAC IBD A2
H3 : Coplanar IAB IAC IBD A1
H2 : Col IAB IBD B2
H1 : Col IAB IBD B1
H0 : Col IAB IAC A2
H : Col IAB IAC A1
HNC1 : not (Col IAB IAC IBD)
HCop4 : Coplanar IAB IAC IBD D2
HCop3 : Coplanar IAB IAC IBD D1
HCop2 : Coplanar IAB IAC IBD C2
HNCop1 : Coplanar IAB IAC IBD C1
HCol6 : Col D1 D2 IBD
HCol5 : Col B1 B2 IBD
HCol4 : Col C1 C2 IAC
HCol3 : Col A1 A2 IAC
HCol2 : Col B1 B2 IAB
HCol1 : Col A1 A2 IAB
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,IAB,IAC,IBD : Tpoint
bla : bachmann_s_lotschnittaxiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
+++++
assert (HQR : IAB <> IBD) by (assert_diffs; auto).
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HNCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.
assert (Coplanar IAB IAC IBD B1) by Cop.
assert (Coplanar IAB IAC IBD B2) by Cop.
assert (HNC2 : ~ Col A1 A2 D1).
assert (HNC3 : ~ Col B1 B2 C1).
assert (HParA : Par_strict A1 A2 D1 D2).
apply par_not_col_strict with D1; Col; apply l12_9 with B1 B2; Perp; CopR.
assert (HParB : Par_strict B1 B2 C1 C2).
apply par_not_col_strict with C1; Col; apply l12_9 with A1 A2; Perp; CopR.
assert (HNCol3 : ~ Col IAC B1 B2) by (apply par_not_col with C1 C2; Par; ColR).
assert (HNCol4 : ~ Col IBD A1 A2) by (apply par_not_col with D1 D2; Par; ColR).
assert (HPQ : IAC <> IAB) by (assert_diffs; auto).
assert (HQR : IAB <> IBD) by (assert_diffs; auto).

*****
HQR : not (eq IAB IBD)
HPQ : not (eq IAC IAB)
HNCol4 : not (Col IBD A1 A2)
HNCol3 : not (Col IAC B1 B2)
HParB : Par_strict B1 B2 C1 C2
HParA : Par_strict A1 A2 D1 D2
HNC3 : not (Col B1 B2 C1)
HNC2 : not (Col A1 A2 D1)
H6 : Coplanar IAB IAC IBD B2
H5 : Coplanar IAB IAC IBD B1
H4 : Coplanar IAB IAC IBD A2
H3 : Coplanar IAB IAC IBD A1
H2 : Col IAB IBD B2
H1 : Col IAB IBD B1
H0 : Col IAB IAC A2
H : Col IAB IAC A1
HNC1 : not (Col IAB IAC IBD)
HCop4 : Coplanar IAB IAC IBD D2
HCop3 : Coplanar IAB IAC IBD D1
HCop2 : Coplanar IAB IAC IBD C2
HNCop1 : Coplanar IAB IAC IBD C1
HCol6 : Col D1 D2 IBD
HCol5 : Col B1 B2 IBD
HCol4 : Col C1 C2 IAC
HCol3 : Col A1 A2 IAC
HCol2 : Col B1 B2 IAB
HCol1 : Col A1 A2 IAB
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,IAB,IAC,IBD : Tpoint
bla : bachmann_s_lotschnittaxiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
+++++
destruct (diff_col_ex3 C1 C2 IAC) as [P1 [HC1P1 [HC2P1 [HPP1 HCP1]]]]; Col.
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HNCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.
assert (Coplanar IAB IAC IBD B1) by Cop.
assert (Coplanar IAB IAC IBD B2) by Cop.
assert (HNC2 : ~ Col A1 A2 D1).
assert (HNC3 : ~ Col B1 B2 C1).
assert (HParA : Par_strict A1 A2 D1 D2).
apply par_not_col_strict with D1; Col; apply l12_9 with B1 B2; Perp; CopR.
assert (HParB : Par_strict B1 B2 C1 C2).
apply par_not_col_strict with C1; Col; apply l12_9 with A1 A2; Perp; CopR.
assert (HNCol3 : ~ Col IAC B1 B2) by (apply par_not_col with C1 C2; Par; ColR).
assert (HNCol4 : ~ Col IBD A1 A2) by (apply par_not_col with D1 D2; Par; ColR).
assert (HPQ : IAC <> IAB) by (assert_diffs; auto).
assert (HQR : IAB <> IBD) by (assert_diffs; auto).
destruct (diff_col_ex3 C1 C2 IAC) as [P1 [HC1P1 [HC2P1 [HPP1 HCP1]]]]; Col.

*****
HCP1 : Col C1 C2 P1
HPP1 : not (eq IAC P1)
HC2P1 : not (eq C2 P1)
HC1P1 : not (eq C1 P1)
P1 : Tpoint
HQR : not (eq IAB IBD)
HPQ : not (eq IAC IAB)
HNCol4 : not (Col IBD A1 A2)
HNCol3 : not (Col IAC B1 B2)
HParB : Par_strict B1 B2 C1 C2
HParA : Par_strict A1 A2 D1 D2
HNC3 : not (Col B1 B2 C1)
HNC2 : not (Col A1 A2 D1)
H6 : Coplanar IAB IAC IBD B2
H5 : Coplanar IAB IAC IBD B1
H4 : Coplanar IAB IAC IBD A2
H3 : Coplanar IAB IAC IBD A1
H2 : Col IAB IBD B2
H1 : Col IAB IBD B1
H0 : Col IAB IAC A2
H : Col IAB IAC A1
HNC1 : not (Col IAB IAC IBD)
HCop4 : Coplanar IAB IAC IBD D2
HCop3 : Coplanar IAB IAC IBD D1
HCop2 : Coplanar IAB IAC IBD C2
HNCop1 : Coplanar IAB IAC IBD C1
HCol6 : Col D1 D2 IBD
HCol5 : Col B1 B2 IBD
HCol4 : Col C1 C2 IAC
HCol3 : Col A1 A2 IAC
HCol2 : Col B1 B2 IAB
HCol1 : Col A1 A2 IAB
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,IAB,IAC,IBD : Tpoint
bla : bachmann_s_lotschnittaxiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
+++++
destruct (diff_col_ex3 D1 D2 IBD) as [R1 [HD1R1 [HD2R1 [HRR1 HDR1]]]]; Col.
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HNCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.
assert (Coplanar IAB IAC IBD B1) by Cop.
assert (Coplanar IAB IAC IBD B2) by Cop.
assert (HNC2 : ~ Col A1 A2 D1).
assert (HNC3 : ~ Col B1 B2 C1).
assert (HParA : Par_strict A1 A2 D1 D2).
apply par_not_col_strict with D1; Col; apply l12_9 with B1 B2; Perp; CopR.
assert (HParB : Par_strict B1 B2 C1 C2).
apply par_not_col_strict with C1; Col; apply l12_9 with A1 A2; Perp; CopR.
assert (HNCol3 : ~ Col IAC B1 B2) by (apply par_not_col with C1 C2; Par; ColR).
assert (HNCol4 : ~ Col IBD A1 A2) by (apply par_not_col with D1 D2; Par; ColR).
assert (HPQ : IAC <> IAB) by (assert_diffs; auto).
assert (HQR : IAB <> IBD) by (assert_diffs; auto).
destruct (diff_col_ex3 C1 C2 IAC) as [P1 [HC1P1 [HC2P1 [HPP1 HCP1]]]]; Col.
destruct (diff_col_ex3 D1 D2 IBD) as [R1 [HD1R1 [HD2R1 [HRR1 HDR1]]]]; Col.

*****
HDR1 : Col D1 D2 R1
HRR1 : not (eq IBD R1)
HD2R1 : not (eq D2 R1)
HD1R1 : not (eq D1 R1)
R1 : Tpoint
HCP1 : Col C1 C2 P1
HPP1 : not (eq IAC P1)
HC2P1 : not (eq C2 P1)
HC1P1 : not (eq C1 P1)
P1 : Tpoint
HQR : not (eq IAB IBD)
HPQ : not (eq IAC IAB)
HNCol4 : not (Col IBD A1 A2)
HNCol3 : not (Col IAC B1 B2)
HParB : Par_strict B1 B2 C1 C2
HParA : Par_strict A1 A2 D1 D2
HNC3 : not (Col B1 B2 C1)
HNC2 : not (Col A1 A2 D1)
H6 : Coplanar IAB IAC IBD B2
H5 : Coplanar IAB IAC IBD B1
H4 : Coplanar IAB IAC IBD A2
H3 : Coplanar IAB IAC IBD A1
H2 : Col IAB IBD B2
H1 : Col IAB IBD B1
H0 : Col IAB IAC A2
H : Col IAB IAC A1
HNC1 : not (Col IAB IAC IBD)
HCop4 : Coplanar IAB IAC IBD D2
HCop3 : Coplanar IAB IAC IBD D1
HCop2 : Coplanar IAB IAC IBD C2
HNCop1 : Coplanar IAB IAC IBD C1
HCol6 : Col D1 D2 IBD
HCol5 : Col B1 B2 IBD
HCol4 : Col C1 C2 IAC
HCol3 : Col A1 A2 IAC
HCol2 : Col B1 B2 IAB
HCol1 : Col A1 A2 IAB
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,IAB,IAC,IBD : Tpoint
bla : bachmann_s_lotschnittaxiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
+++++
destruct (bla IAC IAB IBD P1 R1) as [I [HI1 HI2]]; auto.
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HNCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.
assert (Coplanar IAB IAC IBD B1) by Cop.
assert (Coplanar IAB IAC IBD B2) by Cop.
assert (HNC2 : ~ Col A1 A2 D1).
assert (HNC3 : ~ Col B1 B2 C1).
assert (HParA : Par_strict A1 A2 D1 D2).
apply par_not_col_strict with D1; Col; apply l12_9 with B1 B2; Perp; CopR.
assert (HParB : Par_strict B1 B2 C1 C2).
apply par_not_col_strict with C1; Col; apply l12_9 with A1 A2; Perp; CopR.
assert (HNCol3 : ~ Col IAC B1 B2) by (apply par_not_col with C1 C2; Par; ColR).
assert (HNCol4 : ~ Col IBD A1 A2) by (apply par_not_col with D1 D2; Par; ColR).
assert (HPQ : IAC <> IAB) by (assert_diffs; auto).
assert (HQR : IAB <> IBD) by (assert_diffs; auto).
destruct (diff_col_ex3 C1 C2 IAC) as [P1 [HC1P1 [HC2P1 [HPP1 HCP1]]]]; Col.
destruct (diff_col_ex3 D1 D2 IBD) as [R1 [HD1R1 [HD2R1 [HRR1 HDR1]]]]; Col.
destruct (bla IAC IAB IBD P1 R1) as [I [HI1 HI2]]; auto.

*****
HDR1 : Col D1 D2 R1
HRR1 : not (eq IBD R1)
HD2R1 : not (eq D2 R1)
HD1R1 : not (eq D1 R1)
R1 : Tpoint
HCP1 : Col C1 C2 P1
HPP1 : not (eq IAC P1)
HC2P1 : not (eq C2 P1)
HC1P1 : not (eq C1 P1)
P1 : Tpoint
HQR : not (eq IAB IBD)
HPQ : not (eq IAC IAB)
HNCol4 : not (Col IBD A1 A2)
HNCol3 : not (Col IAC B1 B2)
HParB : Par_strict B1 B2 C1 C2
HParA : Par_strict A1 A2 D1 D2
HNC3 : not (Col B1 B2 C1)
HNC2 : not (Col A1 A2 D1)
H6 : Coplanar IAB IAC IBD B2
H5 : Coplanar IAB IAC IBD B1
H4 : Coplanar IAB IAC IBD A2
H3 : Coplanar IAB IAC IBD A1
H2 : Col IAB IBD B2
H1 : Col IAB IBD B1
H0 : Col IAB IAC A2
H : Col IAB IAC A1
HNC1 : not (Col IAB IAC IBD)
HCop4 : Coplanar IAB IAC IBD D2
HCop3 : Coplanar IAB IAC IBD D1
HCop2 : Coplanar IAB IAC IBD C2
HNCop1 : Coplanar IAB IAC IBD C1
HCol6 : Col D1 D2 IBD
HCol5 : Col B1 B2 IBD
HCol4 : Col C1 C2 IAC
HCol3 : Col A1 A2 IAC
HCol2 : Col B1 B2 IAB
HCol1 : Col A1 A2 IAB
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,IAB,IAC,IBD : Tpoint
bla : bachmann_s_lotschnittaxiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Per IAC IAB IBD
+++++
apply perp_per_2; apply perp_col2 with A1 A2; Col; apply perp_sym; apply perp_col2 with B1 B2; Col; Perp.
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HNCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.
assert (Coplanar IAB IAC IBD B1) by Cop.
assert (Coplanar IAB IAC IBD B2) by Cop.
assert (HNC2 : ~ Col A1 A2 D1).
assert (HNC3 : ~ Col B1 B2 C1).
assert (HParA : Par_strict A1 A2 D1 D2).
apply par_not_col_strict with D1; Col; apply l12_9 with B1 B2; Perp; CopR.
assert (HParB : Par_strict B1 B2 C1 C2).
apply par_not_col_strict with C1; Col; apply l12_9 with A1 A2; Perp; CopR.
assert (HNCol3 : ~ Col IAC B1 B2) by (apply par_not_col with C1 C2; Par; ColR).
assert (HNCol4 : ~ Col IBD A1 A2) by (apply par_not_col with D1 D2; Par; ColR).
assert (HPQ : IAC <> IAB) by (assert_diffs; auto).
assert (HQR : IAB <> IBD) by (assert_diffs; auto).
destruct (diff_col_ex3 C1 C2 IAC) as [P1 [HC1P1 [HC2P1 [HPP1 HCP1]]]]; Col.
destruct (diff_col_ex3 D1 D2 IBD) as [R1 [HD1R1 [HD2R1 [HRR1 HDR1]]]]; Col.
destruct (bla IAC IAB IBD P1 R1) as [I [HI1 HI2]]; auto.
apply perp_per_2; apply perp_col2 with A1 A2; Col; apply perp_sym; apply perp_col2 with B1 B2; Col; Perp.

*****
HDR1 : Col D1 D2 R1
HRR1 : not (eq IBD R1)
HD2R1 : not (eq D2 R1)
HD1R1 : not (eq D1 R1)
R1 : Tpoint
HCP1 : Col C1 C2 P1
HPP1 : not (eq IAC P1)
HC2P1 : not (eq C2 P1)
HC1P1 : not (eq C1 P1)
P1 : Tpoint
HQR : not (eq IAB IBD)
HPQ : not (eq IAC IAB)
HNCol4 : not (Col IBD A1 A2)
HNCol3 : not (Col IAC B1 B2)
HParB : Par_strict B1 B2 C1 C2
HParA : Par_strict A1 A2 D1 D2
HNC3 : not (Col B1 B2 C1)
HNC2 : not (Col A1 A2 D1)
H6 : Coplanar IAB IAC IBD B2
H5 : Coplanar IAB IAC IBD B1
H4 : Coplanar IAB IAC IBD A2
H3 : Coplanar IAB IAC IBD A1
H2 : Col IAB IBD B2
H1 : Col IAB IBD B1
H0 : Col IAB IAC A2
H : Col IAB IAC A1
HNC1 : not (Col IAB IAC IBD)
HCop4 : Coplanar IAB IAC IBD D2
HCop3 : Coplanar IAB IAC IBD D1
HCop2 : Coplanar IAB IAC IBD C2
HNCop1 : Coplanar IAB IAC IBD C1
HCol6 : Col D1 D2 IBD
HCol5 : Col B1 B2 IBD
HCol4 : Col C1 C2 IAC
HCol3 : Col A1 A2 IAC
HCol2 : Col B1 B2 IAB
HCol1 : Col A1 A2 IAB
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,IAB,IAC,IBD : Tpoint
bla : bachmann_s_lotschnittaxiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Per IAB IAC P1
+++++
apply perp_per_2; apply perp_col2 with A1 A2; Col; apply perp_sym; apply perp_col2 with C1 C2; Col; Perp.
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HNCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.
assert (Coplanar IAB IAC IBD B1) by Cop.
assert (Coplanar IAB IAC IBD B2) by Cop.
assert (HNC2 : ~ Col A1 A2 D1).
assert (HNC3 : ~ Col B1 B2 C1).
assert (HParA : Par_strict A1 A2 D1 D2).
apply par_not_col_strict with D1; Col; apply l12_9 with B1 B2; Perp; CopR.
assert (HParB : Par_strict B1 B2 C1 C2).
apply par_not_col_strict with C1; Col; apply l12_9 with A1 A2; Perp; CopR.
assert (HNCol3 : ~ Col IAC B1 B2) by (apply par_not_col with C1 C2; Par; ColR).
assert (HNCol4 : ~ Col IBD A1 A2) by (apply par_not_col with D1 D2; Par; ColR).
assert (HPQ : IAC <> IAB) by (assert_diffs; auto).
assert (HQR : IAB <> IBD) by (assert_diffs; auto).
destruct (diff_col_ex3 C1 C2 IAC) as [P1 [HC1P1 [HC2P1 [HPP1 HCP1]]]]; Col.
destruct (diff_col_ex3 D1 D2 IBD) as [R1 [HD1R1 [HD2R1 [HRR1 HDR1]]]]; Col.
destruct (bla IAC IAB IBD P1 R1) as [I [HI1 HI2]]; auto.
apply perp_per_2; apply perp_col2 with A1 A2; Col; apply perp_sym; apply perp_col2 with B1 B2; Col; Perp.
apply perp_per_2; apply perp_col2 with A1 A2; Col; apply perp_sym; apply perp_col2 with C1 C2; Col; Perp.

*****
HDR1 : Col D1 D2 R1
HRR1 : not (eq IBD R1)
HD2R1 : not (eq D2 R1)
HD1R1 : not (eq D1 R1)
R1 : Tpoint
HCP1 : Col C1 C2 P1
HPP1 : not (eq IAC P1)
HC2P1 : not (eq C2 P1)
HC1P1 : not (eq C1 P1)
P1 : Tpoint
HQR : not (eq IAB IBD)
HPQ : not (eq IAC IAB)
HNCol4 : not (Col IBD A1 A2)
HNCol3 : not (Col IAC B1 B2)
HParB : Par_strict B1 B2 C1 C2
HParA : Par_strict A1 A2 D1 D2
HNC3 : not (Col B1 B2 C1)
HNC2 : not (Col A1 A2 D1)
H6 : Coplanar IAB IAC IBD B2
H5 : Coplanar IAB IAC IBD B1
H4 : Coplanar IAB IAC IBD A2
H3 : Coplanar IAB IAC IBD A1
H2 : Col IAB IBD B2
H1 : Col IAB IBD B1
H0 : Col IAB IAC A2
H : Col IAB IAC A1
HNC1 : not (Col IAB IAC IBD)
HCop4 : Coplanar IAB IAC IBD D2
HCop3 : Coplanar IAB IAC IBD D1
HCop2 : Coplanar IAB IAC IBD C2
HNCop1 : Coplanar IAB IAC IBD C1
HCol6 : Col D1 D2 IBD
HCol5 : Col B1 B2 IBD
HCol4 : Col C1 C2 IAC
HCol3 : Col A1 A2 IAC
HCol2 : Col B1 B2 IAB
HCol1 : Col A1 A2 IAB
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,IAB,IAC,IBD : Tpoint
bla : bachmann_s_lotschnittaxiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Per IAB IBD R1
+++++
apply perp_per_2; apply perp_col2 with B1 B2; Col; apply perp_sym; apply perp_col2 with D1 D2; Col; Perp.
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HNCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.
assert (Coplanar IAB IAC IBD B1) by Cop.
assert (Coplanar IAB IAC IBD B2) by Cop.
assert (HNC2 : ~ Col A1 A2 D1).
assert (HNC3 : ~ Col B1 B2 C1).
assert (HParA : Par_strict A1 A2 D1 D2).
apply par_not_col_strict with D1; Col; apply l12_9 with B1 B2; Perp; CopR.
assert (HParB : Par_strict B1 B2 C1 C2).
apply par_not_col_strict with C1; Col; apply l12_9 with A1 A2; Perp; CopR.
assert (HNCol3 : ~ Col IAC B1 B2) by (apply par_not_col with C1 C2; Par; ColR).
assert (HNCol4 : ~ Col IBD A1 A2) by (apply par_not_col with D1 D2; Par; ColR).
assert (HPQ : IAC <> IAB) by (assert_diffs; auto).
assert (HQR : IAB <> IBD) by (assert_diffs; auto).
destruct (diff_col_ex3 C1 C2 IAC) as [P1 [HC1P1 [HC2P1 [HPP1 HCP1]]]]; Col.
destruct (diff_col_ex3 D1 D2 IBD) as [R1 [HD1R1 [HD2R1 [HRR1 HDR1]]]]; Col.
destruct (bla IAC IAB IBD P1 R1) as [I [HI1 HI2]]; auto.
apply perp_per_2; apply perp_col2 with A1 A2; Col; apply perp_sym; apply perp_col2 with B1 B2; Col; Perp.
apply perp_per_2; apply perp_col2 with A1 A2; Col; apply perp_sym; apply perp_col2 with C1 C2; Col; Perp.
apply perp_per_2; apply perp_col2 with B1 B2; Col; apply perp_sym; apply perp_col2 with D1 D2; Col; Perp.

*****
HDR1 : Col D1 D2 R1
HRR1 : not (eq IBD R1)
HD2R1 : not (eq D2 R1)
HD1R1 : not (eq D1 R1)
R1 : Tpoint
HCP1 : Col C1 C2 P1
HPP1 : not (eq IAC P1)
HC2P1 : not (eq C2 P1)
HC1P1 : not (eq C1 P1)
P1 : Tpoint
HQR : not (eq IAB IBD)
HPQ : not (eq IAC IAB)
HNCol4 : not (Col IBD A1 A2)
HNCol3 : not (Col IAC B1 B2)
HParB : Par_strict B1 B2 C1 C2
HParA : Par_strict A1 A2 D1 D2
HNC3 : not (Col B1 B2 C1)
HNC2 : not (Col A1 A2 D1)
H6 : Coplanar IAB IAC IBD B2
H5 : Coplanar IAB IAC IBD B1
H4 : Coplanar IAB IAC IBD A2
H3 : Coplanar IAB IAC IBD A1
H2 : Col IAB IBD B2
H1 : Col IAB IBD B1
H0 : Col IAB IAC A2
H : Col IAB IAC A1
HNC1 : not (Col IAB IAC IBD)
HCop4 : Coplanar IAB IAC IBD D2
HCop3 : Coplanar IAB IAC IBD D1
HCop2 : Coplanar IAB IAC IBD C2
HNCop1 : Coplanar IAB IAC IBD C1
HCol6 : Col D1 D2 IBD
HCol5 : Col B1 B2 IBD
HCol4 : Col C1 C2 IAC
HCol3 : Col A1 A2 IAC
HCol2 : Col B1 B2 IAB
HCol1 : Col A1 A2 IAB
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,IAB,IAC,IBD : Tpoint
bla : bachmann_s_lotschnittaxiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar IAC IAB IBD P1
+++++
assert_diffs; apply col_cop2__cop with C1 C2; Col; CopR.
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HNCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.
assert (Coplanar IAB IAC IBD B1) by Cop.
assert (Coplanar IAB IAC IBD B2) by Cop.
assert (HNC2 : ~ Col A1 A2 D1).
assert (HNC3 : ~ Col B1 B2 C1).
assert (HParA : Par_strict A1 A2 D1 D2).
apply par_not_col_strict with D1; Col; apply l12_9 with B1 B2; Perp; CopR.
assert (HParB : Par_strict B1 B2 C1 C2).
apply par_not_col_strict with C1; Col; apply l12_9 with A1 A2; Perp; CopR.
assert (HNCol3 : ~ Col IAC B1 B2) by (apply par_not_col with C1 C2; Par; ColR).
assert (HNCol4 : ~ Col IBD A1 A2) by (apply par_not_col with D1 D2; Par; ColR).
assert (HPQ : IAC <> IAB) by (assert_diffs; auto).
assert (HQR : IAB <> IBD) by (assert_diffs; auto).
destruct (diff_col_ex3 C1 C2 IAC) as [P1 [HC1P1 [HC2P1 [HPP1 HCP1]]]]; Col.
destruct (diff_col_ex3 D1 D2 IBD) as [R1 [HD1R1 [HD2R1 [HRR1 HDR1]]]]; Col.
destruct (bla IAC IAB IBD P1 R1) as [I [HI1 HI2]]; auto.
apply perp_per_2; apply perp_col2 with A1 A2; Col; apply perp_sym; apply perp_col2 with B1 B2; Col; Perp.
apply perp_per_2; apply perp_col2 with A1 A2; Col; apply perp_sym; apply perp_col2 with C1 C2; Col; Perp.
apply perp_per_2; apply perp_col2 with B1 B2; Col; apply perp_sym; apply perp_col2 with D1 D2; Col; Perp.
assert_diffs; apply col_cop2__cop with C1 C2; Col; CopR.

*****
HDR1 : Col D1 D2 R1
HRR1 : not (eq IBD R1)
HD2R1 : not (eq D2 R1)
HD1R1 : not (eq D1 R1)
R1 : Tpoint
HCP1 : Col C1 C2 P1
HPP1 : not (eq IAC P1)
HC2P1 : not (eq C2 P1)
HC1P1 : not (eq C1 P1)
P1 : Tpoint
HQR : not (eq IAB IBD)
HPQ : not (eq IAC IAB)
HNCol4 : not (Col IBD A1 A2)
HNCol3 : not (Col IAC B1 B2)
HParB : Par_strict B1 B2 C1 C2
HParA : Par_strict A1 A2 D1 D2
HNC3 : not (Col B1 B2 C1)
HNC2 : not (Col A1 A2 D1)
H6 : Coplanar IAB IAC IBD B2
H5 : Coplanar IAB IAC IBD B1
H4 : Coplanar IAB IAC IBD A2
H3 : Coplanar IAB IAC IBD A1
H2 : Col IAB IBD B2
H1 : Col IAB IBD B1
H0 : Col IAB IAC A2
H : Col IAB IAC A1
HNC1 : not (Col IAB IAC IBD)
HCop4 : Coplanar IAB IAC IBD D2
HCop3 : Coplanar IAB IAC IBD D1
HCop2 : Coplanar IAB IAC IBD C2
HNCop1 : Coplanar IAB IAC IBD C1
HCol6 : Col D1 D2 IBD
HCol5 : Col B1 B2 IBD
HCol4 : Col C1 C2 IAC
HCol3 : Col A1 A2 IAC
HCol2 : Col B1 B2 IAB
HCol1 : Col A1 A2 IAB
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,IAB,IAC,IBD : Tpoint
bla : bachmann_s_lotschnittaxiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar IAC IAB IBD R1
+++++
assert_diffs; apply col_cop2__cop with D1 D2; Col; CopR.
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HNCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.
assert (Coplanar IAB IAC IBD B1) by Cop.
assert (Coplanar IAB IAC IBD B2) by Cop.
assert (HNC2 : ~ Col A1 A2 D1).
assert (HNC3 : ~ Col B1 B2 C1).
assert (HParA : Par_strict A1 A2 D1 D2).
apply par_not_col_strict with D1; Col; apply l12_9 with B1 B2; Perp; CopR.
assert (HParB : Par_strict B1 B2 C1 C2).
apply par_not_col_strict with C1; Col; apply l12_9 with A1 A2; Perp; CopR.
assert (HNCol3 : ~ Col IAC B1 B2) by (apply par_not_col with C1 C2; Par; ColR).
assert (HNCol4 : ~ Col IBD A1 A2) by (apply par_not_col with D1 D2; Par; ColR).
assert (HPQ : IAC <> IAB) by (assert_diffs; auto).
assert (HQR : IAB <> IBD) by (assert_diffs; auto).
destruct (diff_col_ex3 C1 C2 IAC) as [P1 [HC1P1 [HC2P1 [HPP1 HCP1]]]]; Col.
destruct (diff_col_ex3 D1 D2 IBD) as [R1 [HD1R1 [HD2R1 [HRR1 HDR1]]]]; Col.
destruct (bla IAC IAB IBD P1 R1) as [I [HI1 HI2]]; auto.
apply perp_per_2; apply perp_col2 with A1 A2; Col; apply perp_sym; apply perp_col2 with B1 B2; Col; Perp.
apply perp_per_2; apply perp_col2 with A1 A2; Col; apply perp_sym; apply perp_col2 with C1 C2; Col; Perp.
apply perp_per_2; apply perp_col2 with B1 B2; Col; apply perp_sym; apply perp_col2 with D1 D2; Col; Perp.
assert_diffs; apply col_cop2__cop with C1 C2; Col; CopR.
assert_diffs; apply col_cop2__cop with D1 D2; Col; CopR.

*****
HI2 : Col IBD R1 I
HI1 : Col IAC P1 I
I : Tpoint
HDR1 : Col D1 D2 R1
HRR1 : not (eq IBD R1)
HD2R1 : not (eq D2 R1)
HD1R1 : not (eq D1 R1)
R1 : Tpoint
HCP1 : Col C1 C2 P1
HPP1 : not (eq IAC P1)
HC2P1 : not (eq C2 P1)
HC1P1 : not (eq C1 P1)
P1 : Tpoint
HQR : not (eq IAB IBD)
HPQ : not (eq IAC IAB)
HNCol4 : not (Col IBD A1 A2)
HNCol3 : not (Col IAC B1 B2)
HParB : Par_strict B1 B2 C1 C2
HParA : Par_strict A1 A2 D1 D2
HNC3 : not (Col B1 B2 C1)
HNC2 : not (Col A1 A2 D1)
H6 : Coplanar IAB IAC IBD B2
H5 : Coplanar IAB IAC IBD B1
H4 : Coplanar IAB IAC IBD A2
H3 : Coplanar IAB IAC IBD A1
H2 : Col IAB IBD B2
H1 : Col IAB IBD B1
H0 : Col IAB IAC A2
H : Col IAB IAC A1
HNC1 : not (Col IAB IAC IBD)
HCop4 : Coplanar IAB IAC IBD D2
HCop3 : Coplanar IAB IAC IBD D1
HCop2 : Coplanar IAB IAC IBD C2
HNCop1 : Coplanar IAB IAC IBD C1
HCol6 : Col D1 D2 IBD
HCol5 : Col B1 B2 IBD
HCol4 : Col C1 C2 IAC
HCol3 : Col A1 A2 IAC
HCol2 : Col B1 B2 IAB
HCol1 : Col A1 A2 IAB
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,IAB,IAC,IBD : Tpoint
bla : bachmann_s_lotschnittaxiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
+++++
exists I.
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HNCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.
assert (Coplanar IAB IAC IBD B1) by Cop.
assert (Coplanar IAB IAC IBD B2) by Cop.
assert (HNC2 : ~ Col A1 A2 D1).
assert (HNC3 : ~ Col B1 B2 C1).
assert (HParA : Par_strict A1 A2 D1 D2).
apply par_not_col_strict with D1; Col; apply l12_9 with B1 B2; Perp; CopR.
assert (HParB : Par_strict B1 B2 C1 C2).
apply par_not_col_strict with C1; Col; apply l12_9 with A1 A2; Perp; CopR.
assert (HNCol3 : ~ Col IAC B1 B2) by (apply par_not_col with C1 C2; Par; ColR).
assert (HNCol4 : ~ Col IBD A1 A2) by (apply par_not_col with D1 D2; Par; ColR).
assert (HPQ : IAC <> IAB) by (assert_diffs; auto).
assert (HQR : IAB <> IBD) by (assert_diffs; auto).
destruct (diff_col_ex3 C1 C2 IAC) as [P1 [HC1P1 [HC2P1 [HPP1 HCP1]]]]; Col.
destruct (diff_col_ex3 D1 D2 IBD) as [R1 [HD1R1 [HD2R1 [HRR1 HDR1]]]]; Col.
destruct (bla IAC IAB IBD P1 R1) as [I [HI1 HI2]]; auto.
apply perp_per_2; apply perp_col2 with A1 A2; Col; apply perp_sym; apply perp_col2 with B1 B2; Col; Perp.
apply perp_per_2; apply perp_col2 with A1 A2; Col; apply perp_sym; apply perp_col2 with C1 C2; Col; Perp.
apply perp_per_2; apply perp_col2 with B1 B2; Col; apply perp_sym; apply perp_col2 with D1 D2; Col; Perp.
assert_diffs; apply col_cop2__cop with C1 C2; Col; CopR.
assert_diffs; apply col_cop2__cop with D1 D2; Col; CopR.
exists I.

*****
HI2 : Col IBD R1 I
HI1 : Col IAC P1 I
I : Tpoint
HDR1 : Col D1 D2 R1
HRR1 : not (eq IBD R1)
HD2R1 : not (eq D2 R1)
HD1R1 : not (eq D1 R1)
R1 : Tpoint
HCP1 : Col C1 C2 P1
HPP1 : not (eq IAC P1)
HC2P1 : not (eq C2 P1)
HC1P1 : not (eq C1 P1)
P1 : Tpoint
HQR : not (eq IAB IBD)
HPQ : not (eq IAC IAB)
HNCol4 : not (Col IBD A1 A2)
HNCol3 : not (Col IAC B1 B2)
HParB : Par_strict B1 B2 C1 C2
HParA : Par_strict A1 A2 D1 D2
HNC3 : not (Col B1 B2 C1)
HNC2 : not (Col A1 A2 D1)
H6 : Coplanar IAB IAC IBD B2
H5 : Coplanar IAB IAC IBD B1
H4 : Coplanar IAB IAC IBD A2
H3 : Coplanar IAB IAC IBD A1
H2 : Col IAB IBD B2
H1 : Col IAB IBD B1
H0 : Col IAB IAC A2
H : Col IAB IAC A1
HNC1 : not (Col IAB IAC IBD)
HCop4 : Coplanar IAB IAC IBD D2
HCop3 : Coplanar IAB IAC IBD D1
HCop2 : Coplanar IAB IAC IBD C2
HNCop1 : Coplanar IAB IAC IBD C1
HCol6 : Col D1 D2 IBD
HCol5 : Col B1 B2 IBD
HCol4 : Col C1 C2 IAC
HCol3 : Col A1 A2 IAC
HCol2 : Col B1 B2 IAB
HCol1 : Col A1 A2 IAB
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,IAB,IAC,IBD : Tpoint
bla : bachmann_s_lotschnittaxiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Col C1 C2 I) (Col D1 D2 I)
+++++
split; assert_diffs; ColR.
-----
Lemma bachmann_s_lotschnittaxiom__legendre_s_parallel_postulate : bachmann_s_lotschnittaxiom -> legendre_s_parallel_postulate.
Proof.
intro bla.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).

*****

*****

+++++
Qed.
-----
End bachmann_s_lotschnittaxiom_legendre_s_parallel_postulate.
-----
