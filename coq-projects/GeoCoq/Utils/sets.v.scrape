Require Export MSets.
-----
From Coq Require Import Arith.
-----
Require Import NArith.
-----
Require Import Notations.
-----
Require Import Sorting.
-----
Require Import Coq.Program.Equality.
-----
Require Export GeoCoq.Tactics.Coinc.tactics_axioms.
-----
Module S := MSetList.Make PositiveOrderedTypeBits.
-----
Module SWP := WPropertiesOn PositiveOrderedTypeBits S.
-----
Module SetOfSetsOfPositiveOrderedType <: OrderedType.
-----
Definition t := S.t.
-----
Definition eq := S.Equal.
-----
Include IsEq.
-----
Definition eqb := S.equal.
-----
Definition eqb_eq := S.equal_spec.
-----
Include HasEqBool2Dec.
-----
Definition lt := S.lt.
-----
Instance lt_compat : Proper (eq==>eq==>iff) lt.
-----
Instance lt_compat : Proper (eq==>eq==>iff) lt.

*****

*****
Proper (respectful eq (respectful eq iff)) lt
+++++
Proof.
-----
Instance lt_compat : Proper (eq==>eq==>iff) lt.
Proof.

*****

*****
Proper (respectful eq (respectful eq iff)) lt
+++++
apply S.lt_compat.
-----
Instance lt_compat : Proper (eq==>eq==>iff) lt.
Proof.
apply S.lt_compat.

*****

*****

+++++
Qed.
-----
Instance lt_strorder : StrictOrder lt.
-----
Instance lt_strorder : StrictOrder lt.

*****

*****
StrictOrder lt
+++++
Proof.
-----
Instance lt_strorder : StrictOrder lt.
Proof.

*****

*****
StrictOrder lt
+++++
apply S.lt_strorder.
-----
Instance lt_strorder : StrictOrder lt.
Proof.
apply S.lt_strorder.

*****

*****

+++++
Qed.
-----
Definition compare := S.compare.
-----
Definition compare_spec := S.compare_spec.
-----
End SetOfSetsOfPositiveOrderedType.
-----
Module SS := MSetList.Make SetOfSetsOfPositiveOrderedType.
-----
Definition fstpp (pair : (positive * positive)) :=\n  match pair with\n    |(a,b) => Pos.min a b\n  end.
-----
Definition sndpp (pair : (positive * positive)) :=\n  match pair with\n    |(a,b) => Pos.max a b\n  end.
-----
Module SetOfPairsOfPositiveOrderedType <: OrderedType.
-----
Definition t:= (positive * positive).
-----
Definition eq (t1 t2 : t) :=\n    Pos.eq (fstpp(t1)) (fstpp(t2)) /\ Pos.eq (sndpp(t1)) (sndpp(t2)).
-----
Include IsEq.
-----
Definition eqb (t1 t2 : t) :=\n    Pos.eqb (fstpp(t1)) (fstpp(t2)) && Pos.eqb (sndpp(t1)) (sndpp(t2)).
-----
Lemma eqb_eq : forall t1 t2, eqb t1 t2 = true <-> eq t1 t2.
-----
Lemma eqb_eq : forall t1 t2, eqb t1 t2 = true <-> eq t1 t2.

*****

*****
forall t1 t2 : t, iff (Logic.eq (eqb t1 t2) true) (eq t1 t2)
+++++
Proof.
-----
Lemma eqb_eq : forall t1 t2, eqb t1 t2 = true <-> eq t1 t2.
Proof.

*****

*****
forall t1 t2 : t, iff (Logic.eq (eqb t1 t2) true) (eq t1 t2)
+++++
intros.
-----
Lemma eqb_eq : forall t1 t2, eqb t1 t2 = true <-> eq t1 t2.
Proof.
intros.

*****
t1,t2 : True
*****
iff (Logic.eq (eqb t1 t2) true) (eq t1 t2)
+++++
unfold eqb.
-----
Lemma eqb_eq : forall t1 t2, eqb t1 t2 = true <-> eq t1 t2.
Proof.
intros.
unfold eqb.

*****
t1,t2 : True
*****
iff (Logic.eq (andb (Pos.eqb (fstpp t1) (fstpp t2)) (Pos.eqb (sndpp t1) (sndpp t2))) true) (eq t1 t2)
+++++
unfold eq.
-----
Lemma eqb_eq : forall t1 t2, eqb t1 t2 = true <-> eq t1 t2.
Proof.
intros.
unfold eqb.
unfold eq.

*****
t1,t2 : True
*****
iff (Logic.eq (andb (Pos.eqb (fstpp t1) (fstpp t2)) (Pos.eqb (sndpp t1) (sndpp t2))) true) (and (Pos.eq (fstpp t1) (fstpp t2)) (Pos.eq (sndpp t1) (sndpp t2)))
+++++
split.
-----
Lemma eqb_eq : forall t1 t2, eqb t1 t2 = true <-> eq t1 t2.
Proof.
intros.
unfold eqb.
unfold eq.
split.

*****
t1,t2 : True
*****
forall _ : Logic.eq (andb (Pos.eqb (fstpp t1) (fstpp t2)) (Pos.eqb (sndpp t1) (sndpp t2))) true, and (Pos.eq (fstpp t1) (fstpp t2)) (Pos.eq (sndpp t1) (sndpp t2))
+++++
intro H.
-----
Lemma eqb_eq : forall t1 t2, eqb t1 t2 = true <-> eq t1 t2.
Proof.
intros.
unfold eqb.
unfold eq.
split.
intro H.

*****
H : Logic.eq\n (andb (Pos.eqb (fstpp t1) (fstpp t2)) (Pos.eqb (sndpp t1) (sndpp t2)))\n true
t1,t2 : True
*****
and (Pos.eq (fstpp t1) (fstpp t2)) (Pos.eq (sndpp t1) (sndpp t2))
+++++
apply andb_true_iff in H.
-----
Lemma eqb_eq : forall t1 t2, eqb t1 t2 = true <-> eq t1 t2.
Proof.
intros.
unfold eqb.
unfold eq.
split.
intro H.
apply andb_true_iff in H.

*****
H : and (Logic.eq (Pos.eqb (fstpp t1) (fstpp t2)) true)\n (Logic.eq (Pos.eqb (sndpp t1) (sndpp t2)) true)
t1,t2 : True
*****
and (Pos.eq (fstpp t1) (fstpp t2)) (Pos.eq (sndpp t1) (sndpp t2))
+++++
induction H.
-----
Lemma eqb_eq : forall t1 t2, eqb t1 t2 = true <-> eq t1 t2.
Proof.
intros.
unfold eqb.
unfold eq.
split.
intro H.
apply andb_true_iff in H.
induction H.

*****
H0 : Logic.eq (Pos.eqb (sndpp t1) (sndpp t2)) true
H : Logic.eq (Pos.eqb (fstpp t1) (fstpp t2)) true
t1,t2 : True
*****
and (Pos.eq (fstpp t1) (fstpp t2)) (Pos.eq (sndpp t1) (sndpp t2))
+++++
split.
-----
Lemma eqb_eq : forall t1 t2, eqb t1 t2 = true <-> eq t1 t2.
Proof.
intros.
unfold eqb.
unfold eq.
split.
intro H.
apply andb_true_iff in H.
induction H.
split.

*****
H0 : Logic.eq (Pos.eqb (sndpp t1) (sndpp t2)) true
H : Logic.eq (Pos.eqb (fstpp t1) (fstpp t2)) true
t1,t2 : True
*****
Pos.eq (fstpp t1) (fstpp t2)
+++++
apply Pos.eqb_eq.
-----
Lemma eqb_eq : forall t1 t2, eqb t1 t2 = true <-> eq t1 t2.
Proof.
intros.
unfold eqb.
unfold eq.
split.
intro H.
apply andb_true_iff in H.
induction H.
split.
apply Pos.eqb_eq.

*****
H0 : Logic.eq (Pos.eqb (sndpp t1) (sndpp t2)) true
H : Logic.eq (Pos.eqb (fstpp t1) (fstpp t2)) true
t1,t2 : True
*****
Logic.eq (Pos.eqb (fstpp t1) (fstpp t2)) true
+++++
assumption.
-----
Lemma eqb_eq : forall t1 t2, eqb t1 t2 = true <-> eq t1 t2.
Proof.
intros.
unfold eqb.
unfold eq.
split.
intro H.
apply andb_true_iff in H.
induction H.
split.

*****
H0 : Logic.eq (Pos.eqb (sndpp t1) (sndpp t2)) true
H : Logic.eq (Pos.eqb (fstpp t1) (fstpp t2)) true
t1,t2 : True
*****
Pos.eq (sndpp t1) (sndpp t2)
+++++
apply Pos.eqb_eq.
-----
Lemma eqb_eq : forall t1 t2, eqb t1 t2 = true <-> eq t1 t2.
Proof.
intros.
unfold eqb.
unfold eq.
split.
intro H.
apply andb_true_iff in H.
induction H.
split.
apply Pos.eqb_eq.

*****
H0 : Logic.eq (Pos.eqb (sndpp t1) (sndpp t2)) true
H : Logic.eq (Pos.eqb (fstpp t1) (fstpp t2)) true
t1,t2 : True
*****
Logic.eq (Pos.eqb (sndpp t1) (sndpp t2)) true
+++++
assumption.
-----
Lemma eqb_eq : forall t1 t2, eqb t1 t2 = true <-> eq t1 t2.
Proof.
intros.
unfold eqb.
unfold eq.
split.

*****
t1,t2 : True
*****
forall _ : and (Pos.eq (fstpp t1) (fstpp t2)) (Pos.eq (sndpp t1) (sndpp t2)), Logic.eq (andb (Pos.eqb (fstpp t1) (fstpp t2)) (Pos.eqb (sndpp t1) (sndpp t2))) true
+++++
intro H.
-----
Lemma eqb_eq : forall t1 t2, eqb t1 t2 = true <-> eq t1 t2.
Proof.
intros.
unfold eqb.
unfold eq.
split.
intro H.

*****
H : and (Pos.eq (fstpp t1) (fstpp t2)) (Pos.eq (sndpp t1) (sndpp t2))
t1,t2 : True
*****
Logic.eq (andb (Pos.eqb (fstpp t1) (fstpp t2)) (Pos.eqb (sndpp t1) (sndpp t2))) true
+++++
induction H.
-----
Lemma eqb_eq : forall t1 t2, eqb t1 t2 = true <-> eq t1 t2.
Proof.
intros.
unfold eqb.
unfold eq.
split.
intro H.
induction H.

*****
H0 : Pos.eq (sndpp t1) (sndpp t2)
H : Pos.eq (fstpp t1) (fstpp t2)
t1,t2 : True
*****
Logic.eq (andb (Pos.eqb (fstpp t1) (fstpp t2)) (Pos.eqb (sndpp t1) (sndpp t2))) true
+++++
apply andb_true_iff.
-----
Lemma eqb_eq : forall t1 t2, eqb t1 t2 = true <-> eq t1 t2.
Proof.
intros.
unfold eqb.
unfold eq.
split.
intro H.
induction H.
apply andb_true_iff.

*****
H0 : Pos.eq (sndpp t1) (sndpp t2)
H : Pos.eq (fstpp t1) (fstpp t2)
t1,t2 : True
*****
and (Logic.eq (Pos.eqb (fstpp t1) (fstpp t2)) true) (Logic.eq (Pos.eqb (sndpp t1) (sndpp t2)) true)
+++++
split.
-----
Lemma eqb_eq : forall t1 t2, eqb t1 t2 = true <-> eq t1 t2.
Proof.
intros.
unfold eqb.
unfold eq.
split.
intro H.
induction H.
apply andb_true_iff.
split.

*****
H0 : Pos.eq (sndpp t1) (sndpp t2)
H : Pos.eq (fstpp t1) (fstpp t2)
t1,t2 : True
*****
Logic.eq (Pos.eqb (fstpp t1) (fstpp t2)) true
+++++
apply Pos.eqb_eq.
-----
Lemma eqb_eq : forall t1 t2, eqb t1 t2 = true <-> eq t1 t2.
Proof.
intros.
unfold eqb.
unfold eq.
split.
intro H.
induction H.
apply andb_true_iff.
split.
apply Pos.eqb_eq.

*****
H0 : Pos.eq (sndpp t1) (sndpp t2)
H : Pos.eq (fstpp t1) (fstpp t2)
t1,t2 : True
*****
Logic.eq (fstpp t1) (fstpp t2)
+++++
assumption.
-----
Lemma eqb_eq : forall t1 t2, eqb t1 t2 = true <-> eq t1 t2.
Proof.
intros.
unfold eqb.
unfold eq.
split.
intro H.
induction H.
apply andb_true_iff.
split.

*****
H0 : Pos.eq (sndpp t1) (sndpp t2)
H : Pos.eq (fstpp t1) (fstpp t2)
t1,t2 : True
*****
Logic.eq (Pos.eqb (sndpp t1) (sndpp t2)) true
+++++
apply Pos.eqb_eq.
-----
Lemma eqb_eq : forall t1 t2, eqb t1 t2 = true <-> eq t1 t2.
Proof.
intros.
unfold eqb.
unfold eq.
split.
intro H.
induction H.
apply andb_true_iff.
split.
apply Pos.eqb_eq.

*****
H0 : Pos.eq (sndpp t1) (sndpp t2)
H : Pos.eq (fstpp t1) (fstpp t2)
t1,t2 : True
*****
Logic.eq (sndpp t1) (sndpp t2)
+++++
assumption.
-----
Lemma eqb_eq : forall t1 t2, eqb t1 t2 = true <-> eq t1 t2.
Proof.
intros.
unfold eqb.
unfold eq.
split.

*****

*****

+++++
Qed.
-----
Include HasEqBool2Dec.
-----
Definition lt (t1 t2 : t) :=\n    let ft1 := fstpp(t1) in\n    let ft2 := fstpp(t2) in\n    let st1 := sndpp(t1) in\n    let st2 := sndpp(t2) in\n    if Pos.eqb ft1 ft2 then Pos.lt st1 st2\n                       else Pos.lt ft1 ft2.
-----
Lemma lt_irrefl : Irreflexive lt.
-----
Lemma lt_irrefl : Irreflexive lt.

*****

*****
Irreflexive lt
+++++
Proof.
-----
Lemma lt_irrefl : Irreflexive lt.
Proof.

*****

*****
Irreflexive lt
+++++
assert (HIP : Irreflexive Pos.lt).
-----
Lemma lt_irrefl : Irreflexive lt.
Proof.
assert (HIP : Irreflexive Pos.lt).

*****

*****
Irreflexive Pos.lt
+++++
apply StrictOrder_Irreflexive.
-----
Lemma lt_irrefl : Irreflexive lt.
Proof.
assert (HIP : Irreflexive Pos.lt).

*****
HIP : Irreflexive Pos.lt
*****
Irreflexive lt
+++++
idtac.
-----
Lemma lt_irrefl : Irreflexive lt.
Proof.
assert (HIP : Irreflexive Pos.lt).
idtac.

*****
HIP : Irreflexive Pos.lt
*****
Irreflexive lt
+++++
unfold Irreflexive in *.
-----
Lemma lt_irrefl : Irreflexive lt.
Proof.
assert (HIP : Irreflexive Pos.lt).
idtac.
unfold Irreflexive in *.

*****
HIP : Reflexive (complement Pos.lt)
*****
Reflexive (complement lt)
+++++
unfold Reflexive in *.
-----
Lemma lt_irrefl : Irreflexive lt.
Proof.
assert (HIP : Irreflexive Pos.lt).
idtac.
unfold Irreflexive in *.
unfold Reflexive in *.

*****
HIP : forall x : positive, complement Pos.lt x x
*****
forall x : t, complement lt x x
+++++
unfold complement in *.
-----
Lemma lt_irrefl : Irreflexive lt.
Proof.
assert (HIP : Irreflexive Pos.lt).
idtac.
unfold Irreflexive in *.
unfold Reflexive in *.
unfold complement in *.

*****
HIP : forall (x : positive) (_ : Pos.lt x x), False
*****
forall (x : t) (_ : lt x x), False
+++++
intro x.
-----
Lemma lt_irrefl : Irreflexive lt.
Proof.
assert (HIP : Irreflexive Pos.lt).
idtac.
unfold Irreflexive in *.
unfold Reflexive in *.
unfold complement in *.
intro x.

*****
x : True
HIP : forall (x : positive) (_ : Pos.lt x x), False
*****
forall _ : lt x x, False
+++++
unfold lt.
-----
Lemma lt_irrefl : Irreflexive lt.
Proof.
assert (HIP : Irreflexive Pos.lt).
idtac.
unfold Irreflexive in *.
unfold Reflexive in *.
unfold complement in *.
intro x.
unfold lt.

*****
x : True
HIP : forall (x : positive) (_ : Pos.lt x x), False
*****
forall _ : if Pos.eqb (fstpp x) (fstpp x) then Pos.lt (sndpp x) (sndpp x) else Pos.lt (fstpp x) (fstpp x), False
+++++
assert (HEq : Pos.eqb (fstpp(x)) (fstpp(x)) = true).
-----
Lemma lt_irrefl : Irreflexive lt.
Proof.
assert (HIP : Irreflexive Pos.lt).
idtac.
unfold Irreflexive in *.
unfold Reflexive in *.
unfold complement in *.
intro x.
unfold lt.
assert (HEq : Pos.eqb (fstpp(x)) (fstpp(x)) = true).

*****
x : True
HIP : forall (x : positive) (_ : Pos.lt x x), False
*****
Logic.eq (Pos.eqb (fstpp x) (fstpp x)) true
+++++
apply Pos.eqb_eq.
-----
Lemma lt_irrefl : Irreflexive lt.
Proof.
assert (HIP : Irreflexive Pos.lt).
idtac.
unfold Irreflexive in *.
unfold Reflexive in *.
unfold complement in *.
intro x.
unfold lt.
assert (HEq : Pos.eqb (fstpp(x)) (fstpp(x)) = true).
apply Pos.eqb_eq.

*****
x : True
HIP : forall (x : positive) (_ : Pos.lt x x), False
*****
Logic.eq (fstpp x) (fstpp x)
+++++
intuition.
-----
Lemma lt_irrefl : Irreflexive lt.
Proof.
assert (HIP : Irreflexive Pos.lt).
idtac.
unfold Irreflexive in *.
unfold Reflexive in *.
unfold complement in *.
intro x.
unfold lt.
assert (HEq : Pos.eqb (fstpp(x)) (fstpp(x)) = true).

*****
HEq : Logic.eq (Pos.eqb (fstpp x) (fstpp x)) true
x : True
HIP : forall (x : positive) (_ : Pos.lt x x), False
*****
forall _ : if Pos.eqb (fstpp x) (fstpp x) then Pos.lt (sndpp x) (sndpp x) else Pos.lt (fstpp x) (fstpp x), False
+++++
idtac.
-----
Lemma lt_irrefl : Irreflexive lt.
Proof.
assert (HIP : Irreflexive Pos.lt).
idtac.
unfold Irreflexive in *.
unfold Reflexive in *.
unfold complement in *.
intro x.
unfold lt.
assert (HEq : Pos.eqb (fstpp(x)) (fstpp(x)) = true).
idtac.

*****
HEq : Logic.eq (Pos.eqb (fstpp x) (fstpp x)) true
x : True
HIP : forall (x : positive) (_ : Pos.lt x x), False
*****
forall _ : if Pos.eqb (fstpp x) (fstpp x) then Pos.lt (sndpp x) (sndpp x) else Pos.lt (fstpp x) (fstpp x), False
+++++
rewrite HEq.
-----
Lemma lt_irrefl : Irreflexive lt.
Proof.
assert (HIP : Irreflexive Pos.lt).
idtac.
unfold Irreflexive in *.
unfold Reflexive in *.
unfold complement in *.
intro x.
unfold lt.
assert (HEq : Pos.eqb (fstpp(x)) (fstpp(x)) = true).
idtac.
rewrite HEq.

*****
HEq : Logic.eq (Pos.eqb (fstpp x) (fstpp x)) true
x : True
HIP : forall (x : positive) (_ : Pos.lt x x), False
*****
forall _ : Pos.lt (sndpp x) (sndpp x), False
+++++
apply HIP.
-----
Lemma lt_irrefl : Irreflexive lt.
Proof.
assert (HIP : Irreflexive Pos.lt).

*****

*****

+++++
Qed.
-----
Lemma lt_antiref : forall x, ~ lt x x.
-----
Lemma lt_antiref : forall x, ~ lt x x.

*****

*****
forall x : t, not (lt x x)
+++++
Proof.
-----
Lemma lt_antiref : forall x, ~ lt x x.
Proof.

*****

*****
forall x : t, not (lt x x)
+++++
assert (HIL : Irreflexive lt).
-----
Lemma lt_antiref : forall x, ~ lt x x.
Proof.
assert (HIL : Irreflexive lt).

*****

*****
Irreflexive lt
+++++
apply lt_irrefl.
-----
Lemma lt_antiref : forall x, ~ lt x x.
Proof.
assert (HIL : Irreflexive lt).

*****
HIL : Irreflexive lt
*****
forall x : t, not (lt x x)
+++++
idtac.
-----
Lemma lt_antiref : forall x, ~ lt x x.
Proof.
assert (HIL : Irreflexive lt).
idtac.

*****
HIL : Irreflexive lt
*****
forall x : t, not (lt x x)
+++++
unfold Irreflexive in *.
-----
Lemma lt_antiref : forall x, ~ lt x x.
Proof.
assert (HIL : Irreflexive lt).
idtac.
unfold Irreflexive in *.

*****
HIL : Reflexive (complement lt)
*****
forall x : t, not (lt x x)
+++++
unfold Reflexive in *.
-----
Lemma lt_antiref : forall x, ~ lt x x.
Proof.
assert (HIL : Irreflexive lt).
idtac.
unfold Irreflexive in *.
unfold Reflexive in *.

*****
HIL : forall x : t, complement lt x x
*****
forall x : t, not (lt x x)
+++++
unfold complement in *.
-----
Lemma lt_antiref : forall x, ~ lt x x.
Proof.
assert (HIL : Irreflexive lt).
idtac.
unfold Irreflexive in *.
unfold Reflexive in *.
unfold complement in *.

*****
HIL : forall (x : t) (_ : lt x x), False
*****
forall x : t, not (lt x x)
+++++
intros x H.
-----
Lemma lt_antiref : forall x, ~ lt x x.
Proof.
assert (HIL : Irreflexive lt).
idtac.
unfold Irreflexive in *.
unfold Reflexive in *.
unfold complement in *.
intros x H.

*****
H : lt x x
x : True
HIL : forall (x : t) (_ : lt x x), False
*****
False
+++++
apply HIL with x.
-----
Lemma lt_antiref : forall x, ~ lt x x.
Proof.
assert (HIL : Irreflexive lt).
idtac.
unfold Irreflexive in *.
unfold Reflexive in *.
unfold complement in *.
intros x H.
apply HIL with x.

*****
H : lt x x
x : True
HIL : forall (x : t) (_ : lt x x), False
*****
lt x x
+++++
apply H.
-----
Lemma lt_antiref : forall x, ~ lt x x.
Proof.
assert (HIL : Irreflexive lt).

*****

*****

+++++
Qed.
-----
Lemma lt_trans : Transitive lt.
-----
Lemma lt_trans : Transitive lt.

*****

*****
Transitive lt
+++++
Proof.
-----
Lemma lt_trans : Transitive lt.
Proof.

*****

*****
Transitive lt
+++++
assert (HTP : Transitive Pos.lt).
-----
Lemma lt_trans : Transitive lt.
Proof.
assert (HTP : Transitive Pos.lt).

*****

*****
Transitive Pos.lt
+++++
apply StrictOrder_Transitive.
-----
Lemma lt_trans : Transitive lt.
Proof.
assert (HTP : Transitive Pos.lt).

*****
HTP : Transitive Pos.lt
*****
Transitive lt
+++++
idtac.
-----
Lemma lt_trans : Transitive lt.
Proof.
assert (HTP : Transitive Pos.lt).
idtac.

*****
HTP : Transitive Pos.lt
*****
Transitive lt
+++++
unfold Transitive in *.
-----
Lemma lt_trans : Transitive lt.
Proof.
assert (HTP : Transitive Pos.lt).
idtac.
unfold Transitive in *.

*****
HTP : forall (x y z : positive) (_ : Pos.lt x y) (_ : Pos.lt y z), Pos.lt x z
*****
forall (x y z : t) (_ : lt x y) (_ : lt y z), lt x z
+++++
intros x y z.
-----
Lemma lt_trans : Transitive lt.
Proof.
assert (HTP : Transitive Pos.lt).
idtac.
unfold Transitive in *.
intros x y z.

*****
x,y,z : True
HTP : forall (x y z : positive) (_ : Pos.lt x y) (_ : Pos.lt y z), Pos.lt x z
*****
forall (_ : lt x y) (_ : lt y z), lt x z
+++++
unfold lt.
-----
Lemma lt_trans : Transitive lt.
Proof.
assert (HTP : Transitive Pos.lt).
idtac.
unfold Transitive in *.
intros x y z.
unfold lt.

*****
x,y,z : True
HTP : forall (x y z : positive) (_ : Pos.lt x y) (_ : Pos.lt y z), Pos.lt x z
*****
forall (_ : if Pos.eqb (fstpp x) (fstpp y) then Pos.lt (sndpp x) (sndpp y) else Pos.lt (fstpp x) (fstpp y)) (_ : if Pos.eqb (fstpp y) (fstpp z) then Pos.lt (sndpp y) (sndpp z) else Pos.lt (fstpp y) (fstpp z)), if Pos.eqb (fstpp x) (fstpp z) then Pos.lt (sndpp x) (sndpp z) else Pos.lt (fstpp x) (fstpp z)
+++++
case_eq (Pos.eqb (fstpp(x)) (fstpp(y))).
-----
Lemma lt_trans : Transitive lt.
Proof.
assert (HTP : Transitive Pos.lt).
idtac.
unfold Transitive in *.
intros x y z.
unfold lt.
case_eq (Pos.eqb (fstpp(x)) (fstpp(y))).

*****
x,y,z : True
HTP : forall (x y z : positive) (_ : Pos.lt x y) (_ : Pos.lt y z), Pos.lt x z
*****
forall (_ : Logic.eq (Pos.eqb (fstpp x) (fstpp y)) true) (_ : Pos.lt (sndpp x) (sndpp y)) (_ : if Pos.eqb (fstpp y) (fstpp z) then Pos.lt (sndpp y) (sndpp z) else Pos.lt (fstpp y) (fstpp z)), if Pos.eqb (fstpp x) (fstpp z) then Pos.lt (sndpp x) (sndpp z) else Pos.lt (fstpp x) (fstpp z)
+++++
intro HEqXY.
-----
Lemma lt_trans : Transitive lt.
Proof.
assert (HTP : Transitive Pos.lt).
idtac.
unfold Transitive in *.
intros x y z.
unfold lt.
case_eq (Pos.eqb (fstpp(x)) (fstpp(y))).
intro HEqXY.

*****
HEqXY : Logic.eq (Pos.eqb (fstpp x) (fstpp y)) true
x,y,z : True
HTP : forall (x y z : positive) (_ : Pos.lt x y) (_ : Pos.lt y z), Pos.lt x z
*****
forall (_ : Pos.lt (sndpp x) (sndpp y)) (_ : if Pos.eqb (fstpp y) (fstpp z) then Pos.lt (sndpp y) (sndpp z) else Pos.lt (fstpp y) (fstpp z)), if Pos.eqb (fstpp x) (fstpp z) then Pos.lt (sndpp x) (sndpp z) else Pos.lt (fstpp x) (fstpp z)
+++++
case_eq (Pos.eqb (fstpp(y)) (fstpp(z))).
-----
Lemma lt_trans : Transitive lt.
Proof.
assert (HTP : Transitive Pos.lt).
idtac.
unfold Transitive in *.
intros x y z.
unfold lt.
case_eq (Pos.eqb (fstpp(x)) (fstpp(y))).
intro HEqXY.
case_eq (Pos.eqb (fstpp(y)) (fstpp(z))).

*****
HEqXY : Logic.eq (Pos.eqb (fstpp x) (fstpp y)) true
x,y,z : True
HTP : forall (x y z : positive) (_ : Pos.lt x y) (_ : Pos.lt y z), Pos.lt x z
*****
forall (_ : Logic.eq (Pos.eqb (fstpp y) (fstpp z)) true) (_ : Pos.lt (sndpp x) (sndpp y)) (_ : Pos.lt (sndpp y) (sndpp z)), if Pos.eqb (fstpp x) (fstpp z) then Pos.lt (sndpp x) (sndpp z) else Pos.lt (fstpp x) (fstpp z)
+++++
intro HEqYZ.
-----
Lemma lt_trans : Transitive lt.
Proof.
assert (HTP : Transitive Pos.lt).
idtac.
unfold Transitive in *.
intros x y z.
unfold lt.
case_eq (Pos.eqb (fstpp(x)) (fstpp(y))).
intro HEqXY.
case_eq (Pos.eqb (fstpp(y)) (fstpp(z))).
intro HEqYZ.

*****
HEqYZ : Logic.eq (Pos.eqb (fstpp y) (fstpp z)) true
HEqXY : Logic.eq (Pos.eqb (fstpp x) (fstpp y)) true
x,y,z : True
HTP : forall (x y z : positive) (_ : Pos.lt x y) (_ : Pos.lt y z), Pos.lt x z
*****
forall (_ : Pos.lt (sndpp x) (sndpp y)) (_ : Pos.lt (sndpp y) (sndpp z)), if Pos.eqb (fstpp x) (fstpp z) then Pos.lt (sndpp x) (sndpp z) else Pos.lt (fstpp x) (fstpp z)
+++++
assert (HEqXZ : Pos.eqb (fstpp(x)) (fstpp(z)) = true).
-----
Lemma lt_trans : Transitive lt.
Proof.
assert (HTP : Transitive Pos.lt).
idtac.
unfold Transitive in *.
intros x y z.
unfold lt.
case_eq (Pos.eqb (fstpp(x)) (fstpp(y))).
intro HEqXY.
case_eq (Pos.eqb (fstpp(y)) (fstpp(z))).
intro HEqYZ.
assert (HEqXZ : Pos.eqb (fstpp(x)) (fstpp(z)) = true).

*****
HEqYZ : Logic.eq (Pos.eqb (fstpp y) (fstpp z)) true
HEqXY : Logic.eq (Pos.eqb (fstpp x) (fstpp y)) true
x,y,z : True
HTP : forall (x y z : positive) (_ : Pos.lt x y) (_ : Pos.lt y z), Pos.lt x z
*****
Logic.eq (Pos.eqb (fstpp x) (fstpp z)) true
+++++
apply Pos.eqb_eq in HEqXY.
-----
Lemma lt_trans : Transitive lt.
Proof.
assert (HTP : Transitive Pos.lt).
idtac.
unfold Transitive in *.
intros x y z.
unfold lt.
case_eq (Pos.eqb (fstpp(x)) (fstpp(y))).
intro HEqXY.
case_eq (Pos.eqb (fstpp(y)) (fstpp(z))).
intro HEqYZ.
assert (HEqXZ : Pos.eqb (fstpp(x)) (fstpp(z)) = true).
apply Pos.eqb_eq in HEqXY.

*****
HEqYZ : Logic.eq (Pos.eqb (fstpp y) (fstpp z)) true
HEqXY : Logic.eq (fstpp x) (fstpp y)
x,y,z : True
HTP : forall (x y z : positive) (_ : Pos.lt x y) (_ : Pos.lt y z), Pos.lt x z
*****
Logic.eq (Pos.eqb (fstpp x) (fstpp z)) true
+++++
rewrite HEqXY.
-----
Lemma lt_trans : Transitive lt.
Proof.
assert (HTP : Transitive Pos.lt).
idtac.
unfold Transitive in *.
intros x y z.
unfold lt.
case_eq (Pos.eqb (fstpp(x)) (fstpp(y))).
intro HEqXY.
case_eq (Pos.eqb (fstpp(y)) (fstpp(z))).
intro HEqYZ.
assert (HEqXZ : Pos.eqb (fstpp(x)) (fstpp(z)) = true).
apply Pos.eqb_eq in HEqXY.
rewrite HEqXY.

*****
HEqYZ : Logic.eq (Pos.eqb (fstpp y) (fstpp z)) true
HEqXY : Logic.eq (fstpp x) (fstpp y)
x,y,z : True
HTP : forall (x y z : positive) (_ : Pos.lt x y) (_ : Pos.lt y z), Pos.lt x z
*****
Logic.eq (Pos.eqb (fstpp y) (fstpp z)) true
+++++
assumption.
-----
Lemma lt_trans : Transitive lt.
Proof.
assert (HTP : Transitive Pos.lt).
idtac.
unfold Transitive in *.
intros x y z.
unfold lt.
case_eq (Pos.eqb (fstpp(x)) (fstpp(y))).
intro HEqXY.
case_eq (Pos.eqb (fstpp(y)) (fstpp(z))).
intro HEqYZ.
assert (HEqXZ : Pos.eqb (fstpp(x)) (fstpp(z)) = true).

*****
HEqXZ : Logic.eq (Pos.eqb (fstpp x) (fstpp z)) true
HEqYZ : Logic.eq (Pos.eqb (fstpp y) (fstpp z)) true
HEqXY : Logic.eq (Pos.eqb (fstpp x) (fstpp y)) true
x,y,z : True
HTP : forall (x y z : positive) (_ : Pos.lt x y) (_ : Pos.lt y z), Pos.lt x z
*****
forall (_ : Pos.lt (sndpp x) (sndpp y)) (_ : Pos.lt (sndpp y) (sndpp z)), if Pos.eqb (fstpp x) (fstpp z) then Pos.lt (sndpp x) (sndpp z) else Pos.lt (fstpp x) (fstpp z)
+++++
idtac.
-----
Lemma lt_trans : Transitive lt.
Proof.
assert (HTP : Transitive Pos.lt).
idtac.
unfold Transitive in *.
intros x y z.
unfold lt.
case_eq (Pos.eqb (fstpp(x)) (fstpp(y))).
intro HEqXY.
case_eq (Pos.eqb (fstpp(y)) (fstpp(z))).
intro HEqYZ.
assert (HEqXZ : Pos.eqb (fstpp(x)) (fstpp(z)) = true).
idtac.

*****
HEqXZ : Logic.eq (Pos.eqb (fstpp x) (fstpp z)) true
HEqYZ : Logic.eq (Pos.eqb (fstpp y) (fstpp z)) true
HEqXY : Logic.eq (Pos.eqb (fstpp x) (fstpp y)) true
x,y,z : True
HTP : forall (x y z : positive) (_ : Pos.lt x y) (_ : Pos.lt y z), Pos.lt x z
*****
forall (_ : Pos.lt (sndpp x) (sndpp y)) (_ : Pos.lt (sndpp y) (sndpp z)), if Pos.eqb (fstpp x) (fstpp z) then Pos.lt (sndpp x) (sndpp z) else Pos.lt (fstpp x) (fstpp z)
+++++
rewrite HEqXZ.
-----
Lemma lt_trans : Transitive lt.
Proof.
assert (HTP : Transitive Pos.lt).
idtac.
unfold Transitive in *.
intros x y z.
unfold lt.
case_eq (Pos.eqb (fstpp(x)) (fstpp(y))).
intro HEqXY.
case_eq (Pos.eqb (fstpp(y)) (fstpp(z))).
intro HEqYZ.
assert (HEqXZ : Pos.eqb (fstpp(x)) (fstpp(z)) = true).
idtac.
rewrite HEqXZ.

*****
HEqXZ : Logic.eq (Pos.eqb (fstpp x) (fstpp z)) true
HEqYZ : Logic.eq (Pos.eqb (fstpp y) (fstpp z)) true
HEqXY : Logic.eq (Pos.eqb (fstpp x) (fstpp y)) true
x,y,z : True
HTP : forall (x y z : positive) (_ : Pos.lt x y) (_ : Pos.lt y z), Pos.lt x z
*****
forall (_ : Pos.lt (sndpp x) (sndpp y)) (_ : Pos.lt (sndpp y) (sndpp z)), Pos.lt (sndpp x) (sndpp z)
+++++
apply HTP.
-----
Lemma lt_trans : Transitive lt.
Proof.
assert (HTP : Transitive Pos.lt).
idtac.
unfold Transitive in *.
intros x y z.
unfold lt.
case_eq (Pos.eqb (fstpp(x)) (fstpp(y))).
intro HEqXY.
case_eq (Pos.eqb (fstpp(y)) (fstpp(z))).

*****
HEqXY : Logic.eq (Pos.eqb (fstpp x) (fstpp y)) true
x,y,z : True
HTP : forall (x y z : positive) (_ : Pos.lt x y) (_ : Pos.lt y z), Pos.lt x z
*****
forall (_ : Logic.eq (Pos.eqb (fstpp y) (fstpp z)) false) (_ : Pos.lt (sndpp x) (sndpp y)) (_ : Pos.lt (fstpp y) (fstpp z)), if Pos.eqb (fstpp x) (fstpp z) then Pos.lt (sndpp x) (sndpp z) else Pos.lt (fstpp x) (fstpp z)
+++++
intro HNEqYZ.
-----
Lemma lt_trans : Transitive lt.
Proof.
assert (HTP : Transitive Pos.lt).
idtac.
unfold Transitive in *.
intros x y z.
unfold lt.
case_eq (Pos.eqb (fstpp(x)) (fstpp(y))).
intro HEqXY.
case_eq (Pos.eqb (fstpp(y)) (fstpp(z))).
intro HNEqYZ.

*****
HNEqYZ : Logic.eq (Pos.eqb (fstpp y) (fstpp z)) false
HEqXY : Logic.eq (Pos.eqb (fstpp x) (fstpp y)) true
x,y,z : True
HTP : forall (x y z : positive) (_ : Pos.lt x y) (_ : Pos.lt y z), Pos.lt x z
*****
forall (_ : Pos.lt (sndpp x) (sndpp y)) (_ : Pos.lt (fstpp y) (fstpp z)), if Pos.eqb (fstpp x) (fstpp z) then Pos.lt (sndpp x) (sndpp z) else Pos.lt (fstpp x) (fstpp z)
+++++
assert (HNEqXZ : Pos.eqb (fstpp(x)) (fstpp(z)) = false).
-----
Lemma lt_trans : Transitive lt.
Proof.
assert (HTP : Transitive Pos.lt).
idtac.
unfold Transitive in *.
intros x y z.
unfold lt.
case_eq (Pos.eqb (fstpp(x)) (fstpp(y))).
intro HEqXY.
case_eq (Pos.eqb (fstpp(y)) (fstpp(z))).
intro HNEqYZ.
assert (HNEqXZ : Pos.eqb (fstpp(x)) (fstpp(z)) = false).

*****
HNEqYZ : Logic.eq (Pos.eqb (fstpp y) (fstpp z)) false
HEqXY : Logic.eq (Pos.eqb (fstpp x) (fstpp y)) true
x,y,z : True
HTP : forall (x y z : positive) (_ : Pos.lt x y) (_ : Pos.lt y z), Pos.lt x z
*****
Logic.eq (Pos.eqb (fstpp x) (fstpp z)) false
+++++
apply Pos.eqb_eq in HEqXY.
-----
Lemma lt_trans : Transitive lt.
Proof.
assert (HTP : Transitive Pos.lt).
idtac.
unfold Transitive in *.
intros x y z.
unfold lt.
case_eq (Pos.eqb (fstpp(x)) (fstpp(y))).
intro HEqXY.
case_eq (Pos.eqb (fstpp(y)) (fstpp(z))).
intro HNEqYZ.
assert (HNEqXZ : Pos.eqb (fstpp(x)) (fstpp(z)) = false).
apply Pos.eqb_eq in HEqXY.

*****
HNEqYZ : Logic.eq (Pos.eqb (fstpp y) (fstpp z)) false
HEqXY : Logic.eq (fstpp x) (fstpp y)
x,y,z : True
HTP : forall (x y z : positive) (_ : Pos.lt x y) (_ : Pos.lt y z), Pos.lt x z
*****
Logic.eq (Pos.eqb (fstpp x) (fstpp z)) false
+++++
rewrite HEqXY.
-----
Lemma lt_trans : Transitive lt.
Proof.
assert (HTP : Transitive Pos.lt).
idtac.
unfold Transitive in *.
intros x y z.
unfold lt.
case_eq (Pos.eqb (fstpp(x)) (fstpp(y))).
intro HEqXY.
case_eq (Pos.eqb (fstpp(y)) (fstpp(z))).
intro HNEqYZ.
assert (HNEqXZ : Pos.eqb (fstpp(x)) (fstpp(z)) = false).
apply Pos.eqb_eq in HEqXY.
rewrite HEqXY.

*****
HNEqYZ : Logic.eq (Pos.eqb (fstpp y) (fstpp z)) false
HEqXY : Logic.eq (fstpp x) (fstpp y)
x,y,z : True
HTP : forall (x y z : positive) (_ : Pos.lt x y) (_ : Pos.lt y z), Pos.lt x z
*****
Logic.eq (Pos.eqb (fstpp y) (fstpp z)) false
+++++
assumption.
-----
Lemma lt_trans : Transitive lt.
Proof.
assert (HTP : Transitive Pos.lt).
idtac.
unfold Transitive in *.
intros x y z.
unfold lt.
case_eq (Pos.eqb (fstpp(x)) (fstpp(y))).
intro HEqXY.
case_eq (Pos.eqb (fstpp(y)) (fstpp(z))).
intro HNEqYZ.
assert (HNEqXZ : Pos.eqb (fstpp(x)) (fstpp(z)) = false).

*****
HNEqXZ : Logic.eq (Pos.eqb (fstpp x) (fstpp z)) false
HNEqYZ : Logic.eq (Pos.eqb (fstpp y) (fstpp z)) false
HEqXY : Logic.eq (Pos.eqb (fstpp x) (fstpp y)) true
x,y,z : True
HTP : forall (x y z : positive) (_ : Pos.lt x y) (_ : Pos.lt y z), Pos.lt x z
*****
forall (_ : Pos.lt (sndpp x) (sndpp y)) (_ : Pos.lt (fstpp y) (fstpp z)), if Pos.eqb (fstpp x) (fstpp z) then Pos.lt (sndpp x) (sndpp z) else Pos.lt (fstpp x) (fstpp z)
+++++
idtac.
-----
Lemma lt_trans : Transitive lt.
Proof.
assert (HTP : Transitive Pos.lt).
idtac.
unfold Transitive in *.
intros x y z.
unfold lt.
case_eq (Pos.eqb (fstpp(x)) (fstpp(y))).
intro HEqXY.
case_eq (Pos.eqb (fstpp(y)) (fstpp(z))).
intro HNEqYZ.
assert (HNEqXZ : Pos.eqb (fstpp(x)) (fstpp(z)) = false).
idtac.

*****
HNEqXZ : Logic.eq (Pos.eqb (fstpp x) (fstpp z)) false
HNEqYZ : Logic.eq (Pos.eqb (fstpp y) (fstpp z)) false
HEqXY : Logic.eq (Pos.eqb (fstpp x) (fstpp y)) true
x,y,z : True
HTP : forall (x y z : positive) (_ : Pos.lt x y) (_ : Pos.lt y z), Pos.lt x z
*****
forall (_ : Pos.lt (sndpp x) (sndpp y)) (_ : Pos.lt (fstpp y) (fstpp z)), if Pos.eqb (fstpp x) (fstpp z) then Pos.lt (sndpp x) (sndpp z) else Pos.lt (fstpp x) (fstpp z)
+++++
rewrite HNEqXZ.
-----
Lemma lt_trans : Transitive lt.
Proof.
assert (HTP : Transitive Pos.lt).
idtac.
unfold Transitive in *.
intros x y z.
unfold lt.
case_eq (Pos.eqb (fstpp(x)) (fstpp(y))).
intro HEqXY.
case_eq (Pos.eqb (fstpp(y)) (fstpp(z))).
intro HNEqYZ.
assert (HNEqXZ : Pos.eqb (fstpp(x)) (fstpp(z)) = false).
idtac.
rewrite HNEqXZ.

*****
HNEqXZ : Logic.eq (Pos.eqb (fstpp x) (fstpp z)) false
HNEqYZ : Logic.eq (Pos.eqb (fstpp y) (fstpp z)) false
HEqXY : Logic.eq (Pos.eqb (fstpp x) (fstpp y)) true
x,y,z : True
HTP : forall (x y z : positive) (_ : Pos.lt x y) (_ : Pos.lt y z), Pos.lt x z
*****
forall (_ : Pos.lt (sndpp x) (sndpp y)) (_ : Pos.lt (fstpp y) (fstpp z)), Pos.lt (fstpp x) (fstpp z)
+++++
apply Pos.eqb_eq in HEqXY.
-----
Lemma lt_trans : Transitive lt.
Proof.
assert (HTP : Transitive Pos.lt).
idtac.
unfold Transitive in *.
intros x y z.
unfold lt.
case_eq (Pos.eqb (fstpp(x)) (fstpp(y))).
intro HEqXY.
case_eq (Pos.eqb (fstpp(y)) (fstpp(z))).
intro HNEqYZ.
assert (HNEqXZ : Pos.eqb (fstpp(x)) (fstpp(z)) = false).
idtac.
rewrite HNEqXZ.
apply Pos.eqb_eq in HEqXY.

*****
HNEqXZ : Logic.eq (Pos.eqb (fstpp x) (fstpp z)) false
HNEqYZ : Logic.eq (Pos.eqb (fstpp y) (fstpp z)) false
HEqXY : Logic.eq (fstpp x) (fstpp y)
x,y,z : True
HTP : forall (x y z : positive) (_ : Pos.lt x y) (_ : Pos.lt y z), Pos.lt x z
*****
forall (_ : Pos.lt (sndpp x) (sndpp y)) (_ : Pos.lt (fstpp y) (fstpp z)), Pos.lt (fstpp x) (fstpp z)
+++++
rewrite HEqXY.
-----
Lemma lt_trans : Transitive lt.
Proof.
assert (HTP : Transitive Pos.lt).
idtac.
unfold Transitive in *.
intros x y z.
unfold lt.
case_eq (Pos.eqb (fstpp(x)) (fstpp(y))).
intro HEqXY.
case_eq (Pos.eqb (fstpp(y)) (fstpp(z))).
intro HNEqYZ.
assert (HNEqXZ : Pos.eqb (fstpp(x)) (fstpp(z)) = false).
idtac.
rewrite HNEqXZ.
apply Pos.eqb_eq in HEqXY.
rewrite HEqXY.

*****
HNEqXZ : Logic.eq (Pos.eqb (fstpp x) (fstpp z)) false
HNEqYZ : Logic.eq (Pos.eqb (fstpp y) (fstpp z)) false
HEqXY : Logic.eq (fstpp x) (fstpp y)
x,y,z : True
HTP : forall (x y z : positive) (_ : Pos.lt x y) (_ : Pos.lt y z), Pos.lt x z
*****
forall (_ : Pos.lt (sndpp x) (sndpp y)) (_ : Pos.lt (fstpp y) (fstpp z)), Pos.lt (fstpp y) (fstpp z)
+++++
intro.
-----
Lemma lt_trans : Transitive lt.
Proof.
assert (HTP : Transitive Pos.lt).
idtac.
unfold Transitive in *.
intros x y z.
unfold lt.
case_eq (Pos.eqb (fstpp(x)) (fstpp(y))).
intro HEqXY.
case_eq (Pos.eqb (fstpp(y)) (fstpp(z))).
intro HNEqYZ.
assert (HNEqXZ : Pos.eqb (fstpp(x)) (fstpp(z)) = false).
idtac.
rewrite HNEqXZ.
apply Pos.eqb_eq in HEqXY.
rewrite HEqXY.
intro.

*****
H : Pos.lt (sndpp x) (sndpp y)
HNEqXZ : Logic.eq (Pos.eqb (fstpp x) (fstpp z)) false
HNEqYZ : Logic.eq (Pos.eqb (fstpp y) (fstpp z)) false
HEqXY : Logic.eq (fstpp x) (fstpp y)
x,y,z : True
HTP : forall (x y z : positive) (_ : Pos.lt x y) (_ : Pos.lt y z), Pos.lt x z
*****
forall _ : Pos.lt (fstpp y) (fstpp z), Pos.lt (fstpp y) (fstpp z)
+++++
intuition.
-----
Lemma lt_trans : Transitive lt.
Proof.
assert (HTP : Transitive Pos.lt).
idtac.
unfold Transitive in *.
intros x y z.
unfold lt.
case_eq (Pos.eqb (fstpp(x)) (fstpp(y))).

*****
x,y,z : True
HTP : forall (x y z : positive) (_ : Pos.lt x y) (_ : Pos.lt y z), Pos.lt x z
*****
forall (_ : Logic.eq (Pos.eqb (fstpp x) (fstpp y)) false) (_ : Pos.lt (fstpp x) (fstpp y)) (_ : if Pos.eqb (fstpp y) (fstpp z) then Pos.lt (sndpp y) (sndpp z) else Pos.lt (fstpp y) (fstpp z)), if Pos.eqb (fstpp x) (fstpp z) then Pos.lt (sndpp x) (sndpp z) else Pos.lt (fstpp x) (fstpp z)
+++++
intro HNEqXY.
-----
Lemma lt_trans : Transitive lt.
Proof.
assert (HTP : Transitive Pos.lt).
idtac.
unfold Transitive in *.
intros x y z.
unfold lt.
case_eq (Pos.eqb (fstpp(x)) (fstpp(y))).
intro HNEqXY.

*****
HNEqXY : Logic.eq (Pos.eqb (fstpp x) (fstpp y)) false
x,y,z : True
HTP : forall (x y z : positive) (_ : Pos.lt x y) (_ : Pos.lt y z), Pos.lt x z
*****
forall (_ : Pos.lt (fstpp x) (fstpp y)) (_ : if Pos.eqb (fstpp y) (fstpp z) then Pos.lt (sndpp y) (sndpp z) else Pos.lt (fstpp y) (fstpp z)), if Pos.eqb (fstpp x) (fstpp z) then Pos.lt (sndpp x) (sndpp z) else Pos.lt (fstpp x) (fstpp z)
+++++
case_eq (Pos.eqb (fstpp(y)) (fstpp(z))).
-----
Lemma lt_trans : Transitive lt.
Proof.
assert (HTP : Transitive Pos.lt).
idtac.
unfold Transitive in *.
intros x y z.
unfold lt.
case_eq (Pos.eqb (fstpp(x)) (fstpp(y))).
intro HNEqXY.
case_eq (Pos.eqb (fstpp(y)) (fstpp(z))).

*****
HNEqXY : Logic.eq (Pos.eqb (fstpp x) (fstpp y)) false
x,y,z : True
HTP : forall (x y z : positive) (_ : Pos.lt x y) (_ : Pos.lt y z), Pos.lt x z
*****
forall (_ : Logic.eq (Pos.eqb (fstpp y) (fstpp z)) true) (_ : Pos.lt (fstpp x) (fstpp y)) (_ : Pos.lt (sndpp y) (sndpp z)), if Pos.eqb (fstpp x) (fstpp z) then Pos.lt (sndpp x) (sndpp z) else Pos.lt (fstpp x) (fstpp z)
+++++
intro HEqYZ.
-----
Lemma lt_trans : Transitive lt.
Proof.
assert (HTP : Transitive Pos.lt).
idtac.
unfold Transitive in *.
intros x y z.
unfold lt.
case_eq (Pos.eqb (fstpp(x)) (fstpp(y))).
intro HNEqXY.
case_eq (Pos.eqb (fstpp(y)) (fstpp(z))).
intro HEqYZ.

*****
HEqYZ : Logic.eq (Pos.eqb (fstpp y) (fstpp z)) true
HNEqXY : Logic.eq (Pos.eqb (fstpp x) (fstpp y)) false
x,y,z : True
HTP : forall (x y z : positive) (_ : Pos.lt x y) (_ : Pos.lt y z), Pos.lt x z
*****
forall (_ : Pos.lt (fstpp x) (fstpp y)) (_ : Pos.lt (sndpp y) (sndpp z)), if Pos.eqb (fstpp x) (fstpp z) then Pos.lt (sndpp x) (sndpp z) else Pos.lt (fstpp x) (fstpp z)
+++++
assert (HNEqXZ : Pos.eqb (fstpp(x)) (fstpp(z)) = false).
-----
Lemma lt_trans : Transitive lt.
Proof.
assert (HTP : Transitive Pos.lt).
idtac.
unfold Transitive in *.
intros x y z.
unfold lt.
case_eq (Pos.eqb (fstpp(x)) (fstpp(y))).
intro HNEqXY.
case_eq (Pos.eqb (fstpp(y)) (fstpp(z))).
intro HEqYZ.
assert (HNEqXZ : Pos.eqb (fstpp(x)) (fstpp(z)) = false).

*****
HEqYZ : Logic.eq (Pos.eqb (fstpp y) (fstpp z)) true
HNEqXY : Logic.eq (Pos.eqb (fstpp x) (fstpp y)) false
x,y,z : True
HTP : forall (x y z : positive) (_ : Pos.lt x y) (_ : Pos.lt y z), Pos.lt x z
*****
Logic.eq (Pos.eqb (fstpp x) (fstpp z)) false
+++++
apply Pos.eqb_eq in HEqYZ.
-----
Lemma lt_trans : Transitive lt.
Proof.
assert (HTP : Transitive Pos.lt).
idtac.
unfold Transitive in *.
intros x y z.
unfold lt.
case_eq (Pos.eqb (fstpp(x)) (fstpp(y))).
intro HNEqXY.
case_eq (Pos.eqb (fstpp(y)) (fstpp(z))).
intro HEqYZ.
assert (HNEqXZ : Pos.eqb (fstpp(x)) (fstpp(z)) = false).
apply Pos.eqb_eq in HEqYZ.

*****
HEqYZ : Logic.eq (fstpp y) (fstpp z)
HNEqXY : Logic.eq (Pos.eqb (fstpp x) (fstpp y)) false
x,y,z : True
HTP : forall (x y z : positive) (_ : Pos.lt x y) (_ : Pos.lt y z), Pos.lt x z
*****
Logic.eq (Pos.eqb (fstpp x) (fstpp z)) false
+++++
rewrite <- HEqYZ.
-----
Lemma lt_trans : Transitive lt.
Proof.
assert (HTP : Transitive Pos.lt).
idtac.
unfold Transitive in *.
intros x y z.
unfold lt.
case_eq (Pos.eqb (fstpp(x)) (fstpp(y))).
intro HNEqXY.
case_eq (Pos.eqb (fstpp(y)) (fstpp(z))).
intro HEqYZ.
assert (HNEqXZ : Pos.eqb (fstpp(x)) (fstpp(z)) = false).
apply Pos.eqb_eq in HEqYZ.
rewrite <- HEqYZ.

*****
HEqYZ : Logic.eq (fstpp y) (fstpp z)
HNEqXY : Logic.eq (Pos.eqb (fstpp x) (fstpp y)) false
x,y,z : True
HTP : forall (x y z : positive) (_ : Pos.lt x y) (_ : Pos.lt y z), Pos.lt x z
*****
Logic.eq (Pos.eqb (fstpp x) (fstpp y)) false
+++++
assumption.
-----
Lemma lt_trans : Transitive lt.
Proof.
assert (HTP : Transitive Pos.lt).
idtac.
unfold Transitive in *.
intros x y z.
unfold lt.
case_eq (Pos.eqb (fstpp(x)) (fstpp(y))).
intro HNEqXY.
case_eq (Pos.eqb (fstpp(y)) (fstpp(z))).
intro HEqYZ.
assert (HNEqXZ : Pos.eqb (fstpp(x)) (fstpp(z)) = false).

*****
HNEqXZ : Logic.eq (Pos.eqb (fstpp x) (fstpp z)) false
HEqYZ : Logic.eq (Pos.eqb (fstpp y) (fstpp z)) true
HNEqXY : Logic.eq (Pos.eqb (fstpp x) (fstpp y)) false
x,y,z : True
HTP : forall (x y z : positive) (_ : Pos.lt x y) (_ : Pos.lt y z), Pos.lt x z
*****
forall (_ : Pos.lt (fstpp x) (fstpp y)) (_ : Pos.lt (sndpp y) (sndpp z)), if Pos.eqb (fstpp x) (fstpp z) then Pos.lt (sndpp x) (sndpp z) else Pos.lt (fstpp x) (fstpp z)
+++++
idtac.
-----
Lemma lt_trans : Transitive lt.
Proof.
assert (HTP : Transitive Pos.lt).
idtac.
unfold Transitive in *.
intros x y z.
unfold lt.
case_eq (Pos.eqb (fstpp(x)) (fstpp(y))).
intro HNEqXY.
case_eq (Pos.eqb (fstpp(y)) (fstpp(z))).
intro HEqYZ.
assert (HNEqXZ : Pos.eqb (fstpp(x)) (fstpp(z)) = false).
idtac.

*****
HNEqXZ : Logic.eq (Pos.eqb (fstpp x) (fstpp z)) false
HEqYZ : Logic.eq (Pos.eqb (fstpp y) (fstpp z)) true
HNEqXY : Logic.eq (Pos.eqb (fstpp x) (fstpp y)) false
x,y,z : True
HTP : forall (x y z : positive) (_ : Pos.lt x y) (_ : Pos.lt y z), Pos.lt x z
*****
forall (_ : Pos.lt (fstpp x) (fstpp y)) (_ : Pos.lt (sndpp y) (sndpp z)), if Pos.eqb (fstpp x) (fstpp z) then Pos.lt (sndpp x) (sndpp z) else Pos.lt (fstpp x) (fstpp z)
+++++
rewrite HNEqXZ.
-----
Lemma lt_trans : Transitive lt.
Proof.
assert (HTP : Transitive Pos.lt).
idtac.
unfold Transitive in *.
intros x y z.
unfold lt.
case_eq (Pos.eqb (fstpp(x)) (fstpp(y))).
intro HNEqXY.
case_eq (Pos.eqb (fstpp(y)) (fstpp(z))).
intro HEqYZ.
assert (HNEqXZ : Pos.eqb (fstpp(x)) (fstpp(z)) = false).
idtac.
rewrite HNEqXZ.

*****
HNEqXZ : Logic.eq (Pos.eqb (fstpp x) (fstpp z)) false
HEqYZ : Logic.eq (Pos.eqb (fstpp y) (fstpp z)) true
HNEqXY : Logic.eq (Pos.eqb (fstpp x) (fstpp y)) false
x,y,z : True
HTP : forall (x y z : positive) (_ : Pos.lt x y) (_ : Pos.lt y z), Pos.lt x z
*****
forall (_ : Pos.lt (fstpp x) (fstpp y)) (_ : Pos.lt (sndpp y) (sndpp z)), Pos.lt (fstpp x) (fstpp z)
+++++
apply Pos.eqb_eq in HEqYZ.
-----
Lemma lt_trans : Transitive lt.
Proof.
assert (HTP : Transitive Pos.lt).
idtac.
unfold Transitive in *.
intros x y z.
unfold lt.
case_eq (Pos.eqb (fstpp(x)) (fstpp(y))).
intro HNEqXY.
case_eq (Pos.eqb (fstpp(y)) (fstpp(z))).
intro HEqYZ.
assert (HNEqXZ : Pos.eqb (fstpp(x)) (fstpp(z)) = false).
idtac.
rewrite HNEqXZ.
apply Pos.eqb_eq in HEqYZ.

*****
HNEqXZ : Logic.eq (Pos.eqb (fstpp x) (fstpp z)) false
HEqYZ : Logic.eq (fstpp y) (fstpp z)
HNEqXY : Logic.eq (Pos.eqb (fstpp x) (fstpp y)) false
x,y,z : True
HTP : forall (x y z : positive) (_ : Pos.lt x y) (_ : Pos.lt y z), Pos.lt x z
*****
forall (_ : Pos.lt (fstpp x) (fstpp y)) (_ : Pos.lt (sndpp y) (sndpp z)), Pos.lt (fstpp x) (fstpp z)
+++++
rewrite HEqYZ.
-----
Lemma lt_trans : Transitive lt.
Proof.
assert (HTP : Transitive Pos.lt).
idtac.
unfold Transitive in *.
intros x y z.
unfold lt.
case_eq (Pos.eqb (fstpp(x)) (fstpp(y))).
intro HNEqXY.
case_eq (Pos.eqb (fstpp(y)) (fstpp(z))).
intro HEqYZ.
assert (HNEqXZ : Pos.eqb (fstpp(x)) (fstpp(z)) = false).
idtac.
rewrite HNEqXZ.
apply Pos.eqb_eq in HEqYZ.
rewrite HEqYZ.

*****
HNEqXZ : Logic.eq (Pos.eqb (fstpp x) (fstpp z)) false
HEqYZ : Logic.eq (fstpp y) (fstpp z)
HNEqXY : Logic.eq (Pos.eqb (fstpp x) (fstpp y)) false
x,y,z : True
HTP : forall (x y z : positive) (_ : Pos.lt x y) (_ : Pos.lt y z), Pos.lt x z
*****
forall (_ : Pos.lt (fstpp x) (fstpp z)) (_ : Pos.lt (sndpp y) (sndpp z)), Pos.lt (fstpp x) (fstpp z)
+++++
intros.
-----
Lemma lt_trans : Transitive lt.
Proof.
assert (HTP : Transitive Pos.lt).
idtac.
unfold Transitive in *.
intros x y z.
unfold lt.
case_eq (Pos.eqb (fstpp(x)) (fstpp(y))).
intro HNEqXY.
case_eq (Pos.eqb (fstpp(y)) (fstpp(z))).
intro HEqYZ.
assert (HNEqXZ : Pos.eqb (fstpp(x)) (fstpp(z)) = false).
idtac.
rewrite HNEqXZ.
apply Pos.eqb_eq in HEqYZ.
rewrite HEqYZ.
intros.

*****
H0 : Pos.lt (sndpp y) (sndpp z)
H : Pos.lt (fstpp x) (fstpp z)
HNEqXZ : Logic.eq (Pos.eqb (fstpp x) (fstpp z)) false
HEqYZ : Logic.eq (fstpp y) (fstpp z)
HNEqXY : Logic.eq (Pos.eqb (fstpp x) (fstpp y)) false
x,y,z : True
HTP : forall (x y z : positive) (_ : Pos.lt x y) (_ : Pos.lt y z), Pos.lt x z
*****
Pos.lt (fstpp x) (fstpp z)
+++++
assumption.
-----
Lemma lt_trans : Transitive lt.
Proof.
assert (HTP : Transitive Pos.lt).
idtac.
unfold Transitive in *.
intros x y z.
unfold lt.
case_eq (Pos.eqb (fstpp(x)) (fstpp(y))).
intro HNEqXY.
case_eq (Pos.eqb (fstpp(y)) (fstpp(z))).

*****
HNEqXY : Logic.eq (Pos.eqb (fstpp x) (fstpp y)) false
x,y,z : True
HTP : forall (x y z : positive) (_ : Pos.lt x y) (_ : Pos.lt y z), Pos.lt x z
*****
forall (_ : Logic.eq (Pos.eqb (fstpp y) (fstpp z)) false) (_ : Pos.lt (fstpp x) (fstpp y)) (_ : Pos.lt (fstpp y) (fstpp z)), if Pos.eqb (fstpp x) (fstpp z) then Pos.lt (sndpp x) (sndpp z) else Pos.lt (fstpp x) (fstpp z)
+++++
intro HNEqYZ.
-----
Lemma lt_trans : Transitive lt.
Proof.
assert (HTP : Transitive Pos.lt).
idtac.
unfold Transitive in *.
intros x y z.
unfold lt.
case_eq (Pos.eqb (fstpp(x)) (fstpp(y))).
intro HNEqXY.
case_eq (Pos.eqb (fstpp(y)) (fstpp(z))).
intro HNEqYZ.

*****
HNEqYZ : Logic.eq (Pos.eqb (fstpp y) (fstpp z)) false
HNEqXY : Logic.eq (Pos.eqb (fstpp x) (fstpp y)) false
x,y,z : True
HTP : forall (x y z : positive) (_ : Pos.lt x y) (_ : Pos.lt y z), Pos.lt x z
*****
forall (_ : Pos.lt (fstpp x) (fstpp y)) (_ : Pos.lt (fstpp y) (fstpp z)), if Pos.eqb (fstpp x) (fstpp z) then Pos.lt (sndpp x) (sndpp z) else Pos.lt (fstpp x) (fstpp z)
+++++
case_eq (Pos.eqb (fstpp(x)) (fstpp(z))).
-----
Lemma lt_trans : Transitive lt.
Proof.
assert (HTP : Transitive Pos.lt).
idtac.
unfold Transitive in *.
intros x y z.
unfold lt.
case_eq (Pos.eqb (fstpp(x)) (fstpp(y))).
intro HNEqXY.
case_eq (Pos.eqb (fstpp(y)) (fstpp(z))).
intro HNEqYZ.
case_eq (Pos.eqb (fstpp(x)) (fstpp(z))).

*****
HNEqYZ : Logic.eq (Pos.eqb (fstpp y) (fstpp z)) false
HNEqXY : Logic.eq (Pos.eqb (fstpp x) (fstpp y)) false
x,y,z : True
HTP : forall (x y z : positive) (_ : Pos.lt x y) (_ : Pos.lt y z), Pos.lt x z
*****
forall (_ : Logic.eq (Pos.eqb (fstpp x) (fstpp z)) true) (_ : Pos.lt (fstpp x) (fstpp y)) (_ : Pos.lt (fstpp y) (fstpp z)), Pos.lt (sndpp x) (sndpp z)
+++++
intro HEqXZ.
-----
Lemma lt_trans : Transitive lt.
Proof.
assert (HTP : Transitive Pos.lt).
idtac.
unfold Transitive in *.
intros x y z.
unfold lt.
case_eq (Pos.eqb (fstpp(x)) (fstpp(y))).
intro HNEqXY.
case_eq (Pos.eqb (fstpp(y)) (fstpp(z))).
intro HNEqYZ.
case_eq (Pos.eqb (fstpp(x)) (fstpp(z))).
intro HEqXZ.

*****
HEqXZ : Logic.eq (Pos.eqb (fstpp x) (fstpp z)) true
HNEqYZ : Logic.eq (Pos.eqb (fstpp y) (fstpp z)) false
HNEqXY : Logic.eq (Pos.eqb (fstpp x) (fstpp y)) false
x,y,z : True
HTP : forall (x y z : positive) (_ : Pos.lt x y) (_ : Pos.lt y z), Pos.lt x z
*****
forall (_ : Pos.lt (fstpp x) (fstpp y)) (_ : Pos.lt (fstpp y) (fstpp z)), Pos.lt (sndpp x) (sndpp z)
+++++
intros.
-----
Lemma lt_trans : Transitive lt.
Proof.
assert (HTP : Transitive Pos.lt).
idtac.
unfold Transitive in *.
intros x y z.
unfold lt.
case_eq (Pos.eqb (fstpp(x)) (fstpp(y))).
intro HNEqXY.
case_eq (Pos.eqb (fstpp(y)) (fstpp(z))).
intro HNEqYZ.
case_eq (Pos.eqb (fstpp(x)) (fstpp(z))).
intro HEqXZ.
intros.

*****
H0 : Pos.lt (fstpp y) (fstpp z)
H : Pos.lt (fstpp x) (fstpp y)
HEqXZ : Logic.eq (Pos.eqb (fstpp x) (fstpp z)) true
HNEqYZ : Logic.eq (Pos.eqb (fstpp y) (fstpp z)) false
HNEqXY : Logic.eq (Pos.eqb (fstpp x) (fstpp y)) false
x,y,z : True
HTP : forall (x y z : positive) (_ : Pos.lt x y) (_ : Pos.lt y z), Pos.lt x z
*****
Pos.lt (sndpp x) (sndpp z)
+++++
assert (HLtXZ : Pos.ltb (fstpp(x)) (fstpp(z)) = true).
-----
Lemma lt_trans : Transitive lt.
Proof.
assert (HTP : Transitive Pos.lt).
idtac.
unfold Transitive in *.
intros x y z.
unfold lt.
case_eq (Pos.eqb (fstpp(x)) (fstpp(y))).
intro HNEqXY.
case_eq (Pos.eqb (fstpp(y)) (fstpp(z))).
intro HNEqYZ.
case_eq (Pos.eqb (fstpp(x)) (fstpp(z))).
intro HEqXZ.
intros.
assert (HLtXZ : Pos.ltb (fstpp(x)) (fstpp(z)) = true).

*****
H0 : Pos.lt (fstpp y) (fstpp z)
H : Pos.lt (fstpp x) (fstpp y)
HEqXZ : Logic.eq (Pos.eqb (fstpp x) (fstpp z)) true
HNEqYZ : Logic.eq (Pos.eqb (fstpp y) (fstpp z)) false
HNEqXY : Logic.eq (Pos.eqb (fstpp x) (fstpp y)) false
x,y,z : True
HTP : forall (x y z : positive) (_ : Pos.lt x y) (_ : Pos.lt y z), Pos.lt x z
*****
Logic.eq (Pos.ltb (fstpp x) (fstpp z)) true
+++++
apply Pos.ltb_lt.
-----
Lemma lt_trans : Transitive lt.
Proof.
assert (HTP : Transitive Pos.lt).
idtac.
unfold Transitive in *.
intros x y z.
unfold lt.
case_eq (Pos.eqb (fstpp(x)) (fstpp(y))).
intro HNEqXY.
case_eq (Pos.eqb (fstpp(y)) (fstpp(z))).
intro HNEqYZ.
case_eq (Pos.eqb (fstpp(x)) (fstpp(z))).
intro HEqXZ.
intros.
assert (HLtXZ : Pos.ltb (fstpp(x)) (fstpp(z)) = true).
apply Pos.ltb_lt.

*****
H0 : Pos.lt (fstpp y) (fstpp z)
H : Pos.lt (fstpp x) (fstpp y)
HEqXZ : Logic.eq (Pos.eqb (fstpp x) (fstpp z)) true
HNEqYZ : Logic.eq (Pos.eqb (fstpp y) (fstpp z)) false
HNEqXY : Logic.eq (Pos.eqb (fstpp x) (fstpp y)) false
x,y,z : True
HTP : forall (x y z : positive) (_ : Pos.lt x y) (_ : Pos.lt y z), Pos.lt x z
*****
Pos.lt (fstpp x) (fstpp z)
+++++
apply HTP with (fstpp(y)).
-----
Lemma lt_trans : Transitive lt.
Proof.
assert (HTP : Transitive Pos.lt).
idtac.
unfold Transitive in *.
intros x y z.
unfold lt.
case_eq (Pos.eqb (fstpp(x)) (fstpp(y))).
intro HNEqXY.
case_eq (Pos.eqb (fstpp(y)) (fstpp(z))).
intro HNEqYZ.
case_eq (Pos.eqb (fstpp(x)) (fstpp(z))).
intro HEqXZ.
intros.
assert (HLtXZ : Pos.ltb (fstpp(x)) (fstpp(z)) = true).
apply Pos.ltb_lt.
apply HTP with (fstpp(y)).

*****
H0 : Pos.lt (fstpp y) (fstpp z)
H : Pos.lt (fstpp x) (fstpp y)
HEqXZ : Logic.eq (Pos.eqb (fstpp x) (fstpp z)) true
HNEqYZ : Logic.eq (Pos.eqb (fstpp y) (fstpp z)) false
HNEqXY : Logic.eq (Pos.eqb (fstpp x) (fstpp y)) false
x,y,z : True
HTP : forall (x y z : positive) (_ : Pos.lt x y) (_ : Pos.lt y z), Pos.lt x z
*****
Pos.lt (fstpp x) (fstpp y)
+++++
assumption.
-----
Lemma lt_trans : Transitive lt.
Proof.
assert (HTP : Transitive Pos.lt).
idtac.
unfold Transitive in *.
intros x y z.
unfold lt.
case_eq (Pos.eqb (fstpp(x)) (fstpp(y))).
intro HNEqXY.
case_eq (Pos.eqb (fstpp(y)) (fstpp(z))).
intro HNEqYZ.
case_eq (Pos.eqb (fstpp(x)) (fstpp(z))).
intro HEqXZ.
intros.
assert (HLtXZ : Pos.ltb (fstpp(x)) (fstpp(z)) = true).
apply Pos.ltb_lt.
apply HTP with (fstpp(y)).

*****
H0 : Pos.lt (fstpp y) (fstpp z)
H : Pos.lt (fstpp x) (fstpp y)
HEqXZ : Logic.eq (Pos.eqb (fstpp x) (fstpp z)) true
HNEqYZ : Logic.eq (Pos.eqb (fstpp y) (fstpp z)) false
HNEqXY : Logic.eq (Pos.eqb (fstpp x) (fstpp y)) false
x,y,z : True
HTP : forall (x y z : positive) (_ : Pos.lt x y) (_ : Pos.lt y z), Pos.lt x z
*****
Pos.lt (fstpp y) (fstpp z)
+++++
assumption.
-----
Lemma lt_trans : Transitive lt.
Proof.
assert (HTP : Transitive Pos.lt).
idtac.
unfold Transitive in *.
intros x y z.
unfold lt.
case_eq (Pos.eqb (fstpp(x)) (fstpp(y))).
intro HNEqXY.
case_eq (Pos.eqb (fstpp(y)) (fstpp(z))).
intro HNEqYZ.
case_eq (Pos.eqb (fstpp(x)) (fstpp(z))).
intro HEqXZ.
intros.
assert (HLtXZ : Pos.ltb (fstpp(x)) (fstpp(z)) = true).

*****
HLtXZ : Logic.eq (Pos.ltb (fstpp x) (fstpp z)) true
H0 : Pos.lt (fstpp y) (fstpp z)
H : Pos.lt (fstpp x) (fstpp y)
HEqXZ : Logic.eq (Pos.eqb (fstpp x) (fstpp z)) true
HNEqYZ : Logic.eq (Pos.eqb (fstpp y) (fstpp z)) false
HNEqXY : Logic.eq (Pos.eqb (fstpp x) (fstpp y)) false
x,y,z : True
HTP : forall (x y z : positive) (_ : Pos.lt x y) (_ : Pos.lt y z), Pos.lt x z
*****
Pos.lt (sndpp x) (sndpp z)
+++++
idtac.
-----
Lemma lt_trans : Transitive lt.
Proof.
assert (HTP : Transitive Pos.lt).
idtac.
unfold Transitive in *.
intros x y z.
unfold lt.
case_eq (Pos.eqb (fstpp(x)) (fstpp(y))).
intro HNEqXY.
case_eq (Pos.eqb (fstpp(y)) (fstpp(z))).
intro HNEqYZ.
case_eq (Pos.eqb (fstpp(x)) (fstpp(z))).
intro HEqXZ.
intros.
assert (HLtXZ : Pos.ltb (fstpp(x)) (fstpp(z)) = true).
idtac.

*****
HLtXZ : Logic.eq (Pos.ltb (fstpp x) (fstpp z)) true
H0 : Pos.lt (fstpp y) (fstpp z)
H : Pos.lt (fstpp x) (fstpp y)
HEqXZ : Logic.eq (Pos.eqb (fstpp x) (fstpp z)) true
HNEqYZ : Logic.eq (Pos.eqb (fstpp y) (fstpp z)) false
HNEqXY : Logic.eq (Pos.eqb (fstpp x) (fstpp y)) false
x,y,z : True
HTP : forall (x y z : positive) (_ : Pos.lt x y) (_ : Pos.lt y z), Pos.lt x z
*****
Pos.lt (sndpp x) (sndpp z)
+++++
apply Pos.eqb_eq in HEqXZ.
-----
Lemma lt_trans : Transitive lt.
Proof.
assert (HTP : Transitive Pos.lt).
idtac.
unfold Transitive in *.
intros x y z.
unfold lt.
case_eq (Pos.eqb (fstpp(x)) (fstpp(y))).
intro HNEqXY.
case_eq (Pos.eqb (fstpp(y)) (fstpp(z))).
intro HNEqYZ.
case_eq (Pos.eqb (fstpp(x)) (fstpp(z))).
intro HEqXZ.
intros.
assert (HLtXZ : Pos.ltb (fstpp(x)) (fstpp(z)) = true).
idtac.
apply Pos.eqb_eq in HEqXZ.

*****
HLtXZ : Logic.eq (Pos.ltb (fstpp x) (fstpp z)) true
H0 : Pos.lt (fstpp y) (fstpp z)
H : Pos.lt (fstpp x) (fstpp y)
HEqXZ : Logic.eq (fstpp x) (fstpp z)
HNEqYZ : Logic.eq (Pos.eqb (fstpp y) (fstpp z)) false
HNEqXY : Logic.eq (Pos.eqb (fstpp x) (fstpp y)) false
x,y,z : True
HTP : forall (x y z : positive) (_ : Pos.lt x y) (_ : Pos.lt y z), Pos.lt x z
*****
Pos.lt (sndpp x) (sndpp z)
+++++
rewrite HEqXZ in HLtXZ.
-----
Lemma lt_trans : Transitive lt.
Proof.
assert (HTP : Transitive Pos.lt).
idtac.
unfold Transitive in *.
intros x y z.
unfold lt.
case_eq (Pos.eqb (fstpp(x)) (fstpp(y))).
intro HNEqXY.
case_eq (Pos.eqb (fstpp(y)) (fstpp(z))).
intro HNEqYZ.
case_eq (Pos.eqb (fstpp(x)) (fstpp(z))).
intro HEqXZ.
intros.
assert (HLtXZ : Pos.ltb (fstpp(x)) (fstpp(z)) = true).
idtac.
apply Pos.eqb_eq in HEqXZ.
rewrite HEqXZ in HLtXZ.

*****
HLtXZ : Logic.eq (Pos.ltb (fstpp z) (fstpp z)) true
H0 : Pos.lt (fstpp y) (fstpp z)
H : Pos.lt (fstpp x) (fstpp y)
HEqXZ : Logic.eq (fstpp x) (fstpp z)
HNEqYZ : Logic.eq (Pos.eqb (fstpp y) (fstpp z)) false
HNEqXY : Logic.eq (Pos.eqb (fstpp x) (fstpp y)) false
x,y,z : True
HTP : forall (x y z : positive) (_ : Pos.lt x y) (_ : Pos.lt y z), Pos.lt x z
*****
Pos.lt (sndpp x) (sndpp z)
+++++
assert (HIP : Irreflexive Pos.lt).
-----
Lemma lt_trans : Transitive lt.
Proof.
assert (HTP : Transitive Pos.lt).
idtac.
unfold Transitive in *.
intros x y z.
unfold lt.
case_eq (Pos.eqb (fstpp(x)) (fstpp(y))).
intro HNEqXY.
case_eq (Pos.eqb (fstpp(y)) (fstpp(z))).
intro HNEqYZ.
case_eq (Pos.eqb (fstpp(x)) (fstpp(z))).
intro HEqXZ.
intros.
assert (HLtXZ : Pos.ltb (fstpp(x)) (fstpp(z)) = true).
idtac.
apply Pos.eqb_eq in HEqXZ.
rewrite HEqXZ in HLtXZ.
assert (HIP : Irreflexive Pos.lt).

*****
HLtXZ : Logic.eq (Pos.ltb (fstpp z) (fstpp z)) true
H0 : Pos.lt (fstpp y) (fstpp z)
H : Pos.lt (fstpp x) (fstpp y)
HEqXZ : Logic.eq (fstpp x) (fstpp z)
HNEqYZ : Logic.eq (Pos.eqb (fstpp y) (fstpp z)) false
HNEqXY : Logic.eq (Pos.eqb (fstpp x) (fstpp y)) false
x,y,z : True
HTP : forall (x y z : positive) (_ : Pos.lt x y) (_ : Pos.lt y z), Pos.lt x z
*****
Irreflexive Pos.lt
+++++
apply StrictOrder_Irreflexive.
-----
Lemma lt_trans : Transitive lt.
Proof.
assert (HTP : Transitive Pos.lt).
idtac.
unfold Transitive in *.
intros x y z.
unfold lt.
case_eq (Pos.eqb (fstpp(x)) (fstpp(y))).
intro HNEqXY.
case_eq (Pos.eqb (fstpp(y)) (fstpp(z))).
intro HNEqYZ.
case_eq (Pos.eqb (fstpp(x)) (fstpp(z))).
intro HEqXZ.
intros.
assert (HLtXZ : Pos.ltb (fstpp(x)) (fstpp(z)) = true).
idtac.
apply Pos.eqb_eq in HEqXZ.
rewrite HEqXZ in HLtXZ.
assert (HIP : Irreflexive Pos.lt).

*****
HIP : Irreflexive Pos.lt
HLtXZ : Logic.eq (Pos.ltb (fstpp z) (fstpp z)) true
H0 : Pos.lt (fstpp y) (fstpp z)
H : Pos.lt (fstpp x) (fstpp y)
HEqXZ : Logic.eq (fstpp x) (fstpp z)
HNEqYZ : Logic.eq (Pos.eqb (fstpp y) (fstpp z)) false
HNEqXY : Logic.eq (Pos.eqb (fstpp x) (fstpp y)) false
x,y,z : True
HTP : forall (x y z : positive) (_ : Pos.lt x y) (_ : Pos.lt y z), Pos.lt x z
*****
Pos.lt (sndpp x) (sndpp z)
+++++
idtac.
-----
Lemma lt_trans : Transitive lt.
Proof.
assert (HTP : Transitive Pos.lt).
idtac.
unfold Transitive in *.
intros x y z.
unfold lt.
case_eq (Pos.eqb (fstpp(x)) (fstpp(y))).
intro HNEqXY.
case_eq (Pos.eqb (fstpp(y)) (fstpp(z))).
intro HNEqYZ.
case_eq (Pos.eqb (fstpp(x)) (fstpp(z))).
intro HEqXZ.
intros.
assert (HLtXZ : Pos.ltb (fstpp(x)) (fstpp(z)) = true).
idtac.
apply Pos.eqb_eq in HEqXZ.
rewrite HEqXZ in HLtXZ.
assert (HIP : Irreflexive Pos.lt).
idtac.

*****
HIP : Irreflexive Pos.lt
HLtXZ : Logic.eq (Pos.ltb (fstpp z) (fstpp z)) true
H0 : Pos.lt (fstpp y) (fstpp z)
H : Pos.lt (fstpp x) (fstpp y)
HEqXZ : Logic.eq (fstpp x) (fstpp z)
HNEqYZ : Logic.eq (Pos.eqb (fstpp y) (fstpp z)) false
HNEqXY : Logic.eq (Pos.eqb (fstpp x) (fstpp y)) false
x,y,z : True
HTP : forall (x y z : positive) (_ : Pos.lt x y) (_ : Pos.lt y z), Pos.lt x z
*****
Pos.lt (sndpp x) (sndpp z)
+++++
unfold Irreflexive in HIP.
-----
Lemma lt_trans : Transitive lt.
Proof.
assert (HTP : Transitive Pos.lt).
idtac.
unfold Transitive in *.
intros x y z.
unfold lt.
case_eq (Pos.eqb (fstpp(x)) (fstpp(y))).
intro HNEqXY.
case_eq (Pos.eqb (fstpp(y)) (fstpp(z))).
intro HNEqYZ.
case_eq (Pos.eqb (fstpp(x)) (fstpp(z))).
intro HEqXZ.
intros.
assert (HLtXZ : Pos.ltb (fstpp(x)) (fstpp(z)) = true).
idtac.
apply Pos.eqb_eq in HEqXZ.
rewrite HEqXZ in HLtXZ.
assert (HIP : Irreflexive Pos.lt).
idtac.
unfold Irreflexive in HIP.

*****
HIP : Reflexive (complement Pos.lt)
HLtXZ : Logic.eq (Pos.ltb (fstpp z) (fstpp z)) true
H0 : Pos.lt (fstpp y) (fstpp z)
H : Pos.lt (fstpp x) (fstpp y)
HEqXZ : Logic.eq (fstpp x) (fstpp z)
HNEqYZ : Logic.eq (Pos.eqb (fstpp y) (fstpp z)) false
HNEqXY : Logic.eq (Pos.eqb (fstpp x) (fstpp y)) false
x,y,z : True
HTP : forall (x y z : positive) (_ : Pos.lt x y) (_ : Pos.lt y z), Pos.lt x z
*****
Pos.lt (sndpp x) (sndpp z)
+++++
unfold Reflexive in HIP.
-----
Lemma lt_trans : Transitive lt.
Proof.
assert (HTP : Transitive Pos.lt).
idtac.
unfold Transitive in *.
intros x y z.
unfold lt.
case_eq (Pos.eqb (fstpp(x)) (fstpp(y))).
intro HNEqXY.
case_eq (Pos.eqb (fstpp(y)) (fstpp(z))).
intro HNEqYZ.
case_eq (Pos.eqb (fstpp(x)) (fstpp(z))).
intro HEqXZ.
intros.
assert (HLtXZ : Pos.ltb (fstpp(x)) (fstpp(z)) = true).
idtac.
apply Pos.eqb_eq in HEqXZ.
rewrite HEqXZ in HLtXZ.
assert (HIP : Irreflexive Pos.lt).
idtac.
unfold Irreflexive in HIP.
unfold Reflexive in HIP.

*****
HIP : forall x : positive, complement Pos.lt x x
HLtXZ : Logic.eq (Pos.ltb (fstpp z) (fstpp z)) true
H0 : Pos.lt (fstpp y) (fstpp z)
H : Pos.lt (fstpp x) (fstpp y)
HEqXZ : Logic.eq (fstpp x) (fstpp z)
HNEqYZ : Logic.eq (Pos.eqb (fstpp y) (fstpp z)) false
HNEqXY : Logic.eq (Pos.eqb (fstpp x) (fstpp y)) false
x,y,z : True
HTP : forall (x y z : positive) (_ : Pos.lt x y) (_ : Pos.lt y z), Pos.lt x z
*****
Pos.lt (sndpp x) (sndpp z)
+++++
unfold complement in HIP.
-----
Lemma lt_trans : Transitive lt.
Proof.
assert (HTP : Transitive Pos.lt).
idtac.
unfold Transitive in *.
intros x y z.
unfold lt.
case_eq (Pos.eqb (fstpp(x)) (fstpp(y))).
intro HNEqXY.
case_eq (Pos.eqb (fstpp(y)) (fstpp(z))).
intro HNEqYZ.
case_eq (Pos.eqb (fstpp(x)) (fstpp(z))).
intro HEqXZ.
intros.
assert (HLtXZ : Pos.ltb (fstpp(x)) (fstpp(z)) = true).
idtac.
apply Pos.eqb_eq in HEqXZ.
rewrite HEqXZ in HLtXZ.
assert (HIP : Irreflexive Pos.lt).
idtac.
unfold Irreflexive in HIP.
unfold Reflexive in HIP.
unfold complement in HIP.

*****
HIP : forall (x : positive) (_ : Pos.lt x x), False
HLtXZ : Logic.eq (Pos.ltb (fstpp z) (fstpp z)) true
H0 : Pos.lt (fstpp y) (fstpp z)
H : Pos.lt (fstpp x) (fstpp y)
HEqXZ : Logic.eq (fstpp x) (fstpp z)
HNEqYZ : Logic.eq (Pos.eqb (fstpp y) (fstpp z)) false
HNEqXY : Logic.eq (Pos.eqb (fstpp x) (fstpp y)) false
x,y,z : True
HTP : forall (x y z : positive) (_ : Pos.lt x y) (_ : Pos.lt y z), Pos.lt x z
*****
Pos.lt (sndpp x) (sndpp z)
+++++
exfalso.
-----
Lemma lt_trans : Transitive lt.
Proof.
assert (HTP : Transitive Pos.lt).
idtac.
unfold Transitive in *.
intros x y z.
unfold lt.
case_eq (Pos.eqb (fstpp(x)) (fstpp(y))).
intro HNEqXY.
case_eq (Pos.eqb (fstpp(y)) (fstpp(z))).
intro HNEqYZ.
case_eq (Pos.eqb (fstpp(x)) (fstpp(z))).
intro HEqXZ.
intros.
assert (HLtXZ : Pos.ltb (fstpp(x)) (fstpp(z)) = true).
idtac.
apply Pos.eqb_eq in HEqXZ.
rewrite HEqXZ in HLtXZ.
assert (HIP : Irreflexive Pos.lt).
idtac.
unfold Irreflexive in HIP.
unfold Reflexive in HIP.
unfold complement in HIP.
exfalso.

*****
HIP : forall (x : positive) (_ : Pos.lt x x), False
HLtXZ : Logic.eq (Pos.ltb (fstpp z) (fstpp z)) true
H0 : Pos.lt (fstpp y) (fstpp z)
H : Pos.lt (fstpp x) (fstpp y)
HEqXZ : Logic.eq (fstpp x) (fstpp z)
HNEqYZ : Logic.eq (Pos.eqb (fstpp y) (fstpp z)) false
HNEqXY : Logic.eq (Pos.eqb (fstpp x) (fstpp y)) false
x,y,z : True
HTP : forall (x y z : positive) (_ : Pos.lt x y) (_ : Pos.lt y z), Pos.lt x z
*****
False
+++++
apply HIP with (fstpp(z)).
-----
Lemma lt_trans : Transitive lt.
Proof.
assert (HTP : Transitive Pos.lt).
idtac.
unfold Transitive in *.
intros x y z.
unfold lt.
case_eq (Pos.eqb (fstpp(x)) (fstpp(y))).
intro HNEqXY.
case_eq (Pos.eqb (fstpp(y)) (fstpp(z))).
intro HNEqYZ.
case_eq (Pos.eqb (fstpp(x)) (fstpp(z))).
intro HEqXZ.
intros.
assert (HLtXZ : Pos.ltb (fstpp(x)) (fstpp(z)) = true).
idtac.
apply Pos.eqb_eq in HEqXZ.
rewrite HEqXZ in HLtXZ.
assert (HIP : Irreflexive Pos.lt).
idtac.
unfold Irreflexive in HIP.
unfold Reflexive in HIP.
unfold complement in HIP.
exfalso.
apply HIP with (fstpp(z)).

*****
HIP : forall (x : positive) (_ : Pos.lt x x), False
HLtXZ : Logic.eq (Pos.ltb (fstpp z) (fstpp z)) true
H0 : Pos.lt (fstpp y) (fstpp z)
H : Pos.lt (fstpp x) (fstpp y)
HEqXZ : Logic.eq (fstpp x) (fstpp z)
HNEqYZ : Logic.eq (Pos.eqb (fstpp y) (fstpp z)) false
HNEqXY : Logic.eq (Pos.eqb (fstpp x) (fstpp y)) false
x,y,z : True
HTP : forall (x y z : positive) (_ : Pos.lt x y) (_ : Pos.lt y z), Pos.lt x z
*****
Pos.lt (fstpp z) (fstpp z)
+++++
apply Pos.ltb_lt in HLtXZ.
-----
Lemma lt_trans : Transitive lt.
Proof.
assert (HTP : Transitive Pos.lt).
idtac.
unfold Transitive in *.
intros x y z.
unfold lt.
case_eq (Pos.eqb (fstpp(x)) (fstpp(y))).
intro HNEqXY.
case_eq (Pos.eqb (fstpp(y)) (fstpp(z))).
intro HNEqYZ.
case_eq (Pos.eqb (fstpp(x)) (fstpp(z))).
intro HEqXZ.
intros.
assert (HLtXZ : Pos.ltb (fstpp(x)) (fstpp(z)) = true).
idtac.
apply Pos.eqb_eq in HEqXZ.
rewrite HEqXZ in HLtXZ.
assert (HIP : Irreflexive Pos.lt).
idtac.
unfold Irreflexive in HIP.
unfold Reflexive in HIP.
unfold complement in HIP.
exfalso.
apply HIP with (fstpp(z)).
apply Pos.ltb_lt in HLtXZ.

*****
HIP : forall (x : positive) (_ : Pos.lt x x), False
HLtXZ : Pos.lt (fstpp z) (fstpp z)
H0 : Pos.lt (fstpp y) (fstpp z)
H : Pos.lt (fstpp x) (fstpp y)
HEqXZ : Logic.eq (fstpp x) (fstpp z)
HNEqYZ : Logic.eq (Pos.eqb (fstpp y) (fstpp z)) false
HNEqXY : Logic.eq (Pos.eqb (fstpp x) (fstpp y)) false
x,y,z : True
HTP : forall (x y z : positive) (_ : Pos.lt x y) (_ : Pos.lt y z), Pos.lt x z
*****
Pos.lt (fstpp z) (fstpp z)
+++++
assumption.
-----
Lemma lt_trans : Transitive lt.
Proof.
assert (HTP : Transitive Pos.lt).
idtac.
unfold Transitive in *.
intros x y z.
unfold lt.
case_eq (Pos.eqb (fstpp(x)) (fstpp(y))).
intro HNEqXY.
case_eq (Pos.eqb (fstpp(y)) (fstpp(z))).
intro HNEqYZ.
case_eq (Pos.eqb (fstpp(x)) (fstpp(z))).

*****
HNEqYZ : Logic.eq (Pos.eqb (fstpp y) (fstpp z)) false
HNEqXY : Logic.eq (Pos.eqb (fstpp x) (fstpp y)) false
x,y,z : True
HTP : forall (x y z : positive) (_ : Pos.lt x y) (_ : Pos.lt y z), Pos.lt x z
*****
forall (_ : Logic.eq (Pos.eqb (fstpp x) (fstpp z)) false) (_ : Pos.lt (fstpp x) (fstpp y)) (_ : Pos.lt (fstpp y) (fstpp z)), Pos.lt (fstpp x) (fstpp z)
+++++
intro HNEqXZ.
-----
Lemma lt_trans : Transitive lt.
Proof.
assert (HTP : Transitive Pos.lt).
idtac.
unfold Transitive in *.
intros x y z.
unfold lt.
case_eq (Pos.eqb (fstpp(x)) (fstpp(y))).
intro HNEqXY.
case_eq (Pos.eqb (fstpp(y)) (fstpp(z))).
intro HNEqYZ.
case_eq (Pos.eqb (fstpp(x)) (fstpp(z))).
intro HNEqXZ.

*****
HNEqXZ : Logic.eq (Pos.eqb (fstpp x) (fstpp z)) false
HNEqYZ : Logic.eq (Pos.eqb (fstpp y) (fstpp z)) false
HNEqXY : Logic.eq (Pos.eqb (fstpp x) (fstpp y)) false
x,y,z : True
HTP : forall (x y z : positive) (_ : Pos.lt x y) (_ : Pos.lt y z), Pos.lt x z
*****
forall (_ : Pos.lt (fstpp x) (fstpp y)) (_ : Pos.lt (fstpp y) (fstpp z)), Pos.lt (fstpp x) (fstpp z)
+++++
intros.
-----
Lemma lt_trans : Transitive lt.
Proof.
assert (HTP : Transitive Pos.lt).
idtac.
unfold Transitive in *.
intros x y z.
unfold lt.
case_eq (Pos.eqb (fstpp(x)) (fstpp(y))).
intro HNEqXY.
case_eq (Pos.eqb (fstpp(y)) (fstpp(z))).
intro HNEqYZ.
case_eq (Pos.eqb (fstpp(x)) (fstpp(z))).
intro HNEqXZ.
intros.

*****
H0 : Pos.lt (fstpp y) (fstpp z)
H : Pos.lt (fstpp x) (fstpp y)
HNEqXZ : Logic.eq (Pos.eqb (fstpp x) (fstpp z)) false
HNEqYZ : Logic.eq (Pos.eqb (fstpp y) (fstpp z)) false
HNEqXY : Logic.eq (Pos.eqb (fstpp x) (fstpp y)) false
x,y,z : True
HTP : forall (x y z : positive) (_ : Pos.lt x y) (_ : Pos.lt y z), Pos.lt x z
*****
Pos.lt (fstpp x) (fstpp z)
+++++
apply HTP with (fstpp(y)).
-----
Lemma lt_trans : Transitive lt.
Proof.
assert (HTP : Transitive Pos.lt).
idtac.
unfold Transitive in *.
intros x y z.
unfold lt.
case_eq (Pos.eqb (fstpp(x)) (fstpp(y))).
intro HNEqXY.
case_eq (Pos.eqb (fstpp(y)) (fstpp(z))).
intro HNEqYZ.
case_eq (Pos.eqb (fstpp(x)) (fstpp(z))).
intro HNEqXZ.
intros.
apply HTP with (fstpp(y)).

*****
H0 : Pos.lt (fstpp y) (fstpp z)
H : Pos.lt (fstpp x) (fstpp y)
HNEqXZ : Logic.eq (Pos.eqb (fstpp x) (fstpp z)) false
HNEqYZ : Logic.eq (Pos.eqb (fstpp y) (fstpp z)) false
HNEqXY : Logic.eq (Pos.eqb (fstpp x) (fstpp y)) false
x,y,z : True
HTP : forall (x y z : positive) (_ : Pos.lt x y) (_ : Pos.lt y z), Pos.lt x z
*****
Pos.lt (fstpp x) (fstpp y)
+++++
assumption.
-----
Lemma lt_trans : Transitive lt.
Proof.
assert (HTP : Transitive Pos.lt).
idtac.
unfold Transitive in *.
intros x y z.
unfold lt.
case_eq (Pos.eqb (fstpp(x)) (fstpp(y))).
intro HNEqXY.
case_eq (Pos.eqb (fstpp(y)) (fstpp(z))).
intro HNEqYZ.
case_eq (Pos.eqb (fstpp(x)) (fstpp(z))).
intro HNEqXZ.
intros.
apply HTP with (fstpp(y)).

*****
H0 : Pos.lt (fstpp y) (fstpp z)
H : Pos.lt (fstpp x) (fstpp y)
HNEqXZ : Logic.eq (Pos.eqb (fstpp x) (fstpp z)) false
HNEqYZ : Logic.eq (Pos.eqb (fstpp y) (fstpp z)) false
HNEqXY : Logic.eq (Pos.eqb (fstpp x) (fstpp y)) false
x,y,z : True
HTP : forall (x y z : positive) (_ : Pos.lt x y) (_ : Pos.lt y z), Pos.lt x z
*****
Pos.lt (fstpp y) (fstpp z)
+++++
assumption.
-----
Lemma lt_trans : Transitive lt.
Proof.
assert (HTP : Transitive Pos.lt).

*****

*****

+++++
Qed.
-----
Instance lt_compat : Proper (eq==>eq==>iff) lt.
-----
Instance lt_compat : Proper (eq==>eq==>iff) lt.

*****

*****
Proper (respectful eq (respectful eq iff)) lt
+++++
Proof.
-----
Instance lt_compat : Proper (eq==>eq==>iff) lt.
Proof.

*****

*****
Proper (respectful eq (respectful eq iff)) lt
+++++
intros x y HXY x' y' HX'Y'.
-----
Instance lt_compat : Proper (eq==>eq==>iff) lt.
Proof.
intros x y HXY x' y' HX'Y'.

*****
HX'Y' : eq x' y'
x',y' : True
HXY : eq x y
x,y : True
*****
iff (lt x x') (lt y y')
+++++
unfold lt.
-----
Instance lt_compat : Proper (eq==>eq==>iff) lt.
Proof.
intros x y HXY x' y' HX'Y'.
unfold lt.

*****
HX'Y' : eq x' y'
x',y' : True
HXY : eq x y
x,y : True
*****
iff (if Pos.eqb (fstpp x) (fstpp x') then Pos.lt (sndpp x) (sndpp x') else Pos.lt (fstpp x) (fstpp x')) (if Pos.eqb (fstpp y) (fstpp y') then Pos.lt (sndpp y) (sndpp y') else Pos.lt (fstpp y) (fstpp y'))
+++++
unfold eq in *.
-----
Instance lt_compat : Proper (eq==>eq==>iff) lt.
Proof.
intros x y HXY x' y' HX'Y'.
unfold lt.
unfold eq in *.

*****
HX'Y' : and (Pos.eq (fstpp x') (fstpp y')) (Pos.eq (sndpp x') (sndpp y'))
x',y' : True
HXY : and (Pos.eq (fstpp x) (fstpp y)) (Pos.eq (sndpp x) (sndpp y))
x,y : True
*****
iff (if Pos.eqb (fstpp x) (fstpp x') then Pos.lt (sndpp x) (sndpp x') else Pos.lt (fstpp x) (fstpp x')) (if Pos.eqb (fstpp y) (fstpp y') then Pos.lt (sndpp y) (sndpp y') else Pos.lt (fstpp y) (fstpp y'))
+++++
elim HXY.
-----
Instance lt_compat : Proper (eq==>eq==>iff) lt.
Proof.
intros x y HXY x' y' HX'Y'.
unfold lt.
unfold eq in *.
elim HXY.

*****
HX'Y' : and (Pos.eq (fstpp x') (fstpp y')) (Pos.eq (sndpp x') (sndpp y'))
x',y' : True
HXY : and (Pos.eq (fstpp x) (fstpp y)) (Pos.eq (sndpp x) (sndpp y))
x,y : True
*****
forall (_ : Pos.eq (fstpp x) (fstpp y)) (_ : Pos.eq (sndpp x) (sndpp y)), iff (if Pos.eqb (fstpp x) (fstpp x') then Pos.lt (sndpp x) (sndpp x') else Pos.lt (fstpp x) (fstpp x')) (if Pos.eqb (fstpp y) (fstpp y') then Pos.lt (sndpp y) (sndpp y') else Pos.lt (fstpp y) (fstpp y'))
+++++
intros HXYF HXYS.
-----
Instance lt_compat : Proper (eq==>eq==>iff) lt.
Proof.
intros x y HXY x' y' HX'Y'.
unfold lt.
unfold eq in *.
elim HXY.
intros HXYF HXYS.

*****
HXYS : Pos.eq (sndpp x) (sndpp y)
HXYF : Pos.eq (fstpp x) (fstpp y)
HX'Y' : and (Pos.eq (fstpp x') (fstpp y')) (Pos.eq (sndpp x') (sndpp y'))
x',y' : True
HXY : and (Pos.eq (fstpp x) (fstpp y)) (Pos.eq (sndpp x) (sndpp y))
x,y : True
*****
iff (if Pos.eqb (fstpp x) (fstpp x') then Pos.lt (sndpp x) (sndpp x') else Pos.lt (fstpp x) (fstpp x')) (if Pos.eqb (fstpp y) (fstpp y') then Pos.lt (sndpp y) (sndpp y') else Pos.lt (fstpp y) (fstpp y'))
+++++
elim HX'Y'.
-----
Instance lt_compat : Proper (eq==>eq==>iff) lt.
Proof.
intros x y HXY x' y' HX'Y'.
unfold lt.
unfold eq in *.
elim HXY.
intros HXYF HXYS.
elim HX'Y'.

*****
HXYS : Pos.eq (sndpp x) (sndpp y)
HXYF : Pos.eq (fstpp x) (fstpp y)
HX'Y' : and (Pos.eq (fstpp x') (fstpp y')) (Pos.eq (sndpp x') (sndpp y'))
x',y' : True
HXY : and (Pos.eq (fstpp x) (fstpp y)) (Pos.eq (sndpp x) (sndpp y))
x,y : True
*****
forall (_ : Pos.eq (fstpp x') (fstpp y')) (_ : Pos.eq (sndpp x') (sndpp y')), iff (if Pos.eqb (fstpp x) (fstpp x') then Pos.lt (sndpp x) (sndpp x') else Pos.lt (fstpp x) (fstpp x')) (if Pos.eqb (fstpp y) (fstpp y') then Pos.lt (sndpp y) (sndpp y') else Pos.lt (fstpp y) (fstpp y'))
+++++
intros HX'Y'F HX'Y'S.
-----
Instance lt_compat : Proper (eq==>eq==>iff) lt.
Proof.
intros x y HXY x' y' HX'Y'.
unfold lt.
unfold eq in *.
elim HXY.
intros HXYF HXYS.
elim HX'Y'.
intros HX'Y'F HX'Y'S.

*****
HX'Y'S : Pos.eq (sndpp x') (sndpp y')
HX'Y'F : Pos.eq (fstpp x') (fstpp y')
HXYS : Pos.eq (sndpp x) (sndpp y)
HXYF : Pos.eq (fstpp x) (fstpp y)
HX'Y' : and (Pos.eq (fstpp x') (fstpp y')) (Pos.eq (sndpp x') (sndpp y'))
x',y' : True
HXY : and (Pos.eq (fstpp x) (fstpp y)) (Pos.eq (sndpp x) (sndpp y))
x,y : True
*****
iff (if Pos.eqb (fstpp x) (fstpp x') then Pos.lt (sndpp x) (sndpp x') else Pos.lt (fstpp x) (fstpp x')) (if Pos.eqb (fstpp y) (fstpp y') then Pos.lt (sndpp y) (sndpp y') else Pos.lt (fstpp y) (fstpp y'))
+++++
clear HXY.
-----
Instance lt_compat : Proper (eq==>eq==>iff) lt.
Proof.
intros x y HXY x' y' HX'Y'.
unfold lt.
unfold eq in *.
elim HXY.
intros HXYF HXYS.
elim HX'Y'.
intros HX'Y'F HX'Y'S.
clear HXY.

*****
HX'Y'S : Pos.eq (sndpp x') (sndpp y')
HX'Y'F : Pos.eq (fstpp x') (fstpp y')
HXYS : Pos.eq (sndpp x) (sndpp y)
HXYF : Pos.eq (fstpp x) (fstpp y)
HX'Y' : and (Pos.eq (fstpp x') (fstpp y')) (Pos.eq (sndpp x') (sndpp y'))
x,y,x',y' : True
*****
iff (if Pos.eqb (fstpp x) (fstpp x') then Pos.lt (sndpp x) (sndpp x') else Pos.lt (fstpp x) (fstpp x')) (if Pos.eqb (fstpp y) (fstpp y') then Pos.lt (sndpp y) (sndpp y') else Pos.lt (fstpp y) (fstpp y'))
+++++
clear HX'Y'.
-----
Instance lt_compat : Proper (eq==>eq==>iff) lt.
Proof.
intros x y HXY x' y' HX'Y'.
unfold lt.
unfold eq in *.
elim HXY.
intros HXYF HXYS.
elim HX'Y'.
intros HX'Y'F HX'Y'S.
clear HXY.
clear HX'Y'.

*****
HX'Y'S : Pos.eq (sndpp x') (sndpp y')
HX'Y'F : Pos.eq (fstpp x') (fstpp y')
HXYS : Pos.eq (sndpp x) (sndpp y)
HXYF : Pos.eq (fstpp x) (fstpp y)
x,y,x',y' : True
*****
iff (if Pos.eqb (fstpp x) (fstpp x') then Pos.lt (sndpp x) (sndpp x') else Pos.lt (fstpp x) (fstpp x')) (if Pos.eqb (fstpp y) (fstpp y') then Pos.lt (sndpp y) (sndpp y') else Pos.lt (fstpp y) (fstpp y'))
+++++
unfold Pos.eq in *.
-----
Instance lt_compat : Proper (eq==>eq==>iff) lt.
Proof.
intros x y HXY x' y' HX'Y'.
unfold lt.
unfold eq in *.
elim HXY.
intros HXYF HXYS.
elim HX'Y'.
intros HX'Y'F HX'Y'S.
clear HXY.
clear HX'Y'.
unfold Pos.eq in *.

*****
HX'Y'S : Logic.eq (sndpp x') (sndpp y')
HX'Y'F : Logic.eq (fstpp x') (fstpp y')
HXYS : Logic.eq (sndpp x) (sndpp y)
HXYF : Logic.eq (fstpp x) (fstpp y)
x,y,x',y' : True
*****
iff (if Pos.eqb (fstpp x) (fstpp x') then Pos.lt (sndpp x) (sndpp x') else Pos.lt (fstpp x) (fstpp x')) (if Pos.eqb (fstpp y) (fstpp y') then Pos.lt (sndpp y) (sndpp y') else Pos.lt (fstpp y) (fstpp y'))
+++++
case_eq (Pos.eqb (fstpp(x)) (fstpp(x'))).
-----
Instance lt_compat : Proper (eq==>eq==>iff) lt.
Proof.
intros x y HXY x' y' HX'Y'.
unfold lt.
unfold eq in *.
elim HXY.
intros HXYF HXYS.
elim HX'Y'.
intros HX'Y'F HX'Y'S.
clear HXY.
clear HX'Y'.
unfold Pos.eq in *.
case_eq (Pos.eqb (fstpp(x)) (fstpp(x'))).

*****
HX'Y'S : Logic.eq (sndpp x') (sndpp y')
HX'Y'F : Logic.eq (fstpp x') (fstpp y')
HXYS : Logic.eq (sndpp x) (sndpp y)
HXYF : Logic.eq (fstpp x) (fstpp y)
x,y,x',y' : True
*****
forall _ : Logic.eq (Pos.eqb (fstpp x) (fstpp x')) true, iff (Pos.lt (sndpp x) (sndpp x')) (if Pos.eqb (fstpp y) (fstpp y') then Pos.lt (sndpp y) (sndpp y') else Pos.lt (fstpp y) (fstpp y'))
+++++
intro HXX'F.
-----
Instance lt_compat : Proper (eq==>eq==>iff) lt.
Proof.
intros x y HXY x' y' HX'Y'.
unfold lt.
unfold eq in *.
elim HXY.
intros HXYF HXYS.
elim HX'Y'.
intros HX'Y'F HX'Y'S.
clear HXY.
clear HX'Y'.
unfold Pos.eq in *.
case_eq (Pos.eqb (fstpp(x)) (fstpp(x'))).
intro HXX'F.

*****
HXX'F : Logic.eq (Pos.eqb (fstpp x) (fstpp x')) true
HX'Y'S : Logic.eq (sndpp x') (sndpp y')
HX'Y'F : Logic.eq (fstpp x') (fstpp y')
HXYS : Logic.eq (sndpp x) (sndpp y)
HXYF : Logic.eq (fstpp x) (fstpp y)
x,y,x',y' : True
*****
iff (Pos.lt (sndpp x) (sndpp x')) (if Pos.eqb (fstpp y) (fstpp y') then Pos.lt (sndpp y) (sndpp y') else Pos.lt (fstpp y) (fstpp y'))
+++++
assert (HYY'F : Pos.eqb (fstpp(y)) (fstpp(y')) = true).
-----
Instance lt_compat : Proper (eq==>eq==>iff) lt.
Proof.
intros x y HXY x' y' HX'Y'.
unfold lt.
unfold eq in *.
elim HXY.
intros HXYF HXYS.
elim HX'Y'.
intros HX'Y'F HX'Y'S.
clear HXY.
clear HX'Y'.
unfold Pos.eq in *.
case_eq (Pos.eqb (fstpp(x)) (fstpp(x'))).
intro HXX'F.
assert (HYY'F : Pos.eqb (fstpp(y)) (fstpp(y')) = true).

*****
HXX'F : Logic.eq (Pos.eqb (fstpp x) (fstpp x')) true
HX'Y'S : Logic.eq (sndpp x') (sndpp y')
HX'Y'F : Logic.eq (fstpp x') (fstpp y')
HXYS : Logic.eq (sndpp x) (sndpp y)
HXYF : Logic.eq (fstpp x) (fstpp y)
x,y,x',y' : True
*****
Logic.eq (Pos.eqb (fstpp y) (fstpp y')) true
+++++
apply Pos.eqb_eq in HXX'F.
-----
Instance lt_compat : Proper (eq==>eq==>iff) lt.
Proof.
intros x y HXY x' y' HX'Y'.
unfold lt.
unfold eq in *.
elim HXY.
intros HXYF HXYS.
elim HX'Y'.
intros HX'Y'F HX'Y'S.
clear HXY.
clear HX'Y'.
unfold Pos.eq in *.
case_eq (Pos.eqb (fstpp(x)) (fstpp(x'))).
intro HXX'F.
assert (HYY'F : Pos.eqb (fstpp(y)) (fstpp(y')) = true).
apply Pos.eqb_eq in HXX'F.

*****
HXX'F : Logic.eq (fstpp x) (fstpp x')
HX'Y'S : Logic.eq (sndpp x') (sndpp y')
HX'Y'F : Logic.eq (fstpp x') (fstpp y')
HXYS : Logic.eq (sndpp x) (sndpp y)
HXYF : Logic.eq (fstpp x) (fstpp y)
x,y,x',y' : True
*****
Logic.eq (Pos.eqb (fstpp y) (fstpp y')) true
+++++
apply Pos.eqb_eq.
-----
Instance lt_compat : Proper (eq==>eq==>iff) lt.
Proof.
intros x y HXY x' y' HX'Y'.
unfold lt.
unfold eq in *.
elim HXY.
intros HXYF HXYS.
elim HX'Y'.
intros HX'Y'F HX'Y'S.
clear HXY.
clear HX'Y'.
unfold Pos.eq in *.
case_eq (Pos.eqb (fstpp(x)) (fstpp(x'))).
intro HXX'F.
assert (HYY'F : Pos.eqb (fstpp(y)) (fstpp(y')) = true).
apply Pos.eqb_eq in HXX'F.
apply Pos.eqb_eq.

*****
HXX'F : Logic.eq (fstpp x) (fstpp x')
HX'Y'S : Logic.eq (sndpp x') (sndpp y')
HX'Y'F : Logic.eq (fstpp x') (fstpp y')
HXYS : Logic.eq (sndpp x) (sndpp y)
HXYF : Logic.eq (fstpp x) (fstpp y)
x,y,x',y' : True
*****
Logic.eq (fstpp y) (fstpp y')
+++++
rewrite <- HXYF.
-----
Instance lt_compat : Proper (eq==>eq==>iff) lt.
Proof.
intros x y HXY x' y' HX'Y'.
unfold lt.
unfold eq in *.
elim HXY.
intros HXYF HXYS.
elim HX'Y'.
intros HX'Y'F HX'Y'S.
clear HXY.
clear HX'Y'.
unfold Pos.eq in *.
case_eq (Pos.eqb (fstpp(x)) (fstpp(x'))).
intro HXX'F.
assert (HYY'F : Pos.eqb (fstpp(y)) (fstpp(y')) = true).
apply Pos.eqb_eq in HXX'F.
apply Pos.eqb_eq.
rewrite <- HXYF.

*****
HXX'F : Logic.eq (fstpp x) (fstpp x')
HX'Y'S : Logic.eq (sndpp x') (sndpp y')
HX'Y'F : Logic.eq (fstpp x') (fstpp y')
HXYS : Logic.eq (sndpp x) (sndpp y)
HXYF : Logic.eq (fstpp x) (fstpp y)
x,y,x',y' : True
*****
Logic.eq (fstpp x) (fstpp y')
+++++
rewrite <- HX'Y'F.
-----
Instance lt_compat : Proper (eq==>eq==>iff) lt.
Proof.
intros x y HXY x' y' HX'Y'.
unfold lt.
unfold eq in *.
elim HXY.
intros HXYF HXYS.
elim HX'Y'.
intros HX'Y'F HX'Y'S.
clear HXY.
clear HX'Y'.
unfold Pos.eq in *.
case_eq (Pos.eqb (fstpp(x)) (fstpp(x'))).
intro HXX'F.
assert (HYY'F : Pos.eqb (fstpp(y)) (fstpp(y')) = true).
apply Pos.eqb_eq in HXX'F.
apply Pos.eqb_eq.
rewrite <- HXYF.
rewrite <- HX'Y'F.

*****
HXX'F : Logic.eq (fstpp x) (fstpp x')
HX'Y'S : Logic.eq (sndpp x') (sndpp y')
HX'Y'F : Logic.eq (fstpp x') (fstpp y')
HXYS : Logic.eq (sndpp x) (sndpp y)
HXYF : Logic.eq (fstpp x) (fstpp y)
x,y,x',y' : True
*****
Logic.eq (fstpp x) (fstpp x')
+++++
assumption.
-----
Instance lt_compat : Proper (eq==>eq==>iff) lt.
Proof.
intros x y HXY x' y' HX'Y'.
unfold lt.
unfold eq in *.
elim HXY.
intros HXYF HXYS.
elim HX'Y'.
intros HX'Y'F HX'Y'S.
clear HXY.
clear HX'Y'.
unfold Pos.eq in *.
case_eq (Pos.eqb (fstpp(x)) (fstpp(x'))).
intro HXX'F.
assert (HYY'F : Pos.eqb (fstpp(y)) (fstpp(y')) = true).

*****
HYY'F : Logic.eq (Pos.eqb (fstpp y) (fstpp y')) true
HXX'F : Logic.eq (Pos.eqb (fstpp x) (fstpp x')) true
HX'Y'S : Logic.eq (sndpp x') (sndpp y')
HX'Y'F : Logic.eq (fstpp x') (fstpp y')
HXYS : Logic.eq (sndpp x) (sndpp y)
HXYF : Logic.eq (fstpp x) (fstpp y)
x,y,x',y' : True
*****
iff (Pos.lt (sndpp x) (sndpp x')) (if Pos.eqb (fstpp y) (fstpp y') then Pos.lt (sndpp y) (sndpp y') else Pos.lt (fstpp y) (fstpp y'))
+++++
rewrite HYY'F.
-----
Instance lt_compat : Proper (eq==>eq==>iff) lt.
Proof.
intros x y HXY x' y' HX'Y'.
unfold lt.
unfold eq in *.
elim HXY.
intros HXYF HXYS.
elim HX'Y'.
intros HX'Y'F HX'Y'S.
clear HXY.
clear HX'Y'.
unfold Pos.eq in *.
case_eq (Pos.eqb (fstpp(x)) (fstpp(x'))).
intro HXX'F.
assert (HYY'F : Pos.eqb (fstpp(y)) (fstpp(y')) = true).
rewrite HYY'F.

*****
HYY'F : Logic.eq (Pos.eqb (fstpp y) (fstpp y')) true
HXX'F : Logic.eq (Pos.eqb (fstpp x) (fstpp x')) true
HX'Y'S : Logic.eq (sndpp x') (sndpp y')
HX'Y'F : Logic.eq (fstpp x') (fstpp y')
HXYS : Logic.eq (sndpp x) (sndpp y)
HXYF : Logic.eq (fstpp x) (fstpp y)
x,y,x',y' : True
*****
iff (Pos.lt (sndpp x) (sndpp x')) (Pos.lt (sndpp y) (sndpp y'))
+++++
case_eq (Pos.eqb (sndpp(x)) (sndpp(x'))).
-----
Instance lt_compat : Proper (eq==>eq==>iff) lt.
Proof.
intros x y HXY x' y' HX'Y'.
unfold lt.
unfold eq in *.
elim HXY.
intros HXYF HXYS.
elim HX'Y'.
intros HX'Y'F HX'Y'S.
clear HXY.
clear HX'Y'.
unfold Pos.eq in *.
case_eq (Pos.eqb (fstpp(x)) (fstpp(x'))).
intro HXX'F.
assert (HYY'F : Pos.eqb (fstpp(y)) (fstpp(y')) = true).
rewrite HYY'F.
case_eq (Pos.eqb (sndpp(x)) (sndpp(x'))).

*****
HYY'F : Logic.eq (Pos.eqb (fstpp y) (fstpp y')) true
HXX'F : Logic.eq (Pos.eqb (fstpp x) (fstpp x')) true
HX'Y'S : Logic.eq (sndpp x') (sndpp y')
HX'Y'F : Logic.eq (fstpp x') (fstpp y')
HXYS : Logic.eq (sndpp x) (sndpp y)
HXYF : Logic.eq (fstpp x) (fstpp y)
x,y,x',y' : True
*****
forall _ : Logic.eq (Pos.eqb (sndpp x) (sndpp x')) true, iff (Pos.lt (sndpp x) (sndpp x')) (Pos.lt (sndpp y) (sndpp y'))
+++++
intro HXX'S.
-----
Instance lt_compat : Proper (eq==>eq==>iff) lt.
Proof.
intros x y HXY x' y' HX'Y'.
unfold lt.
unfold eq in *.
elim HXY.
intros HXYF HXYS.
elim HX'Y'.
intros HX'Y'F HX'Y'S.
clear HXY.
clear HX'Y'.
unfold Pos.eq in *.
case_eq (Pos.eqb (fstpp(x)) (fstpp(x'))).
intro HXX'F.
assert (HYY'F : Pos.eqb (fstpp(y)) (fstpp(y')) = true).
rewrite HYY'F.
case_eq (Pos.eqb (sndpp(x)) (sndpp(x'))).
intro HXX'S.

*****
HXX'S : Logic.eq (Pos.eqb (sndpp x) (sndpp x')) true
HYY'F : Logic.eq (Pos.eqb (fstpp y) (fstpp y')) true
HXX'F : Logic.eq (Pos.eqb (fstpp x) (fstpp x')) true
HX'Y'S : Logic.eq (sndpp x') (sndpp y')
HX'Y'F : Logic.eq (fstpp x') (fstpp y')
HXYS : Logic.eq (sndpp x) (sndpp y)
HXYF : Logic.eq (fstpp x) (fstpp y)
x,y,x',y' : True
*****
iff (Pos.lt (sndpp x) (sndpp x')) (Pos.lt (sndpp y) (sndpp y'))
+++++
apply Pos.eqb_eq in HXX'S.
-----
Instance lt_compat : Proper (eq==>eq==>iff) lt.
Proof.
intros x y HXY x' y' HX'Y'.
unfold lt.
unfold eq in *.
elim HXY.
intros HXYF HXYS.
elim HX'Y'.
intros HX'Y'F HX'Y'S.
clear HXY.
clear HX'Y'.
unfold Pos.eq in *.
case_eq (Pos.eqb (fstpp(x)) (fstpp(x'))).
intro HXX'F.
assert (HYY'F : Pos.eqb (fstpp(y)) (fstpp(y')) = true).
rewrite HYY'F.
case_eq (Pos.eqb (sndpp(x)) (sndpp(x'))).
intro HXX'S.
apply Pos.eqb_eq in HXX'S.

*****
HXX'S : Logic.eq (sndpp x) (sndpp x')
HYY'F : Logic.eq (Pos.eqb (fstpp y) (fstpp y')) true
HXX'F : Logic.eq (Pos.eqb (fstpp x) (fstpp x')) true
HX'Y'S : Logic.eq (sndpp x') (sndpp y')
HX'Y'F : Logic.eq (fstpp x') (fstpp y')
HXYS : Logic.eq (sndpp x) (sndpp y)
HXYF : Logic.eq (fstpp x) (fstpp y)
x,y,x',y' : True
*****
iff (Pos.lt (sndpp x) (sndpp x')) (Pos.lt (sndpp y) (sndpp y'))
+++++
assert (HYY'S : Pos.eqb (sndpp(y)) (sndpp(y')) = true).
-----
Instance lt_compat : Proper (eq==>eq==>iff) lt.
Proof.
intros x y HXY x' y' HX'Y'.
unfold lt.
unfold eq in *.
elim HXY.
intros HXYF HXYS.
elim HX'Y'.
intros HX'Y'F HX'Y'S.
clear HXY.
clear HX'Y'.
unfold Pos.eq in *.
case_eq (Pos.eqb (fstpp(x)) (fstpp(x'))).
intro HXX'F.
assert (HYY'F : Pos.eqb (fstpp(y)) (fstpp(y')) = true).
rewrite HYY'F.
case_eq (Pos.eqb (sndpp(x)) (sndpp(x'))).
intro HXX'S.
apply Pos.eqb_eq in HXX'S.
assert (HYY'S : Pos.eqb (sndpp(y)) (sndpp(y')) = true).

*****
HXX'S : Logic.eq (sndpp x) (sndpp x')
HYY'F : Logic.eq (Pos.eqb (fstpp y) (fstpp y')) true
HXX'F : Logic.eq (Pos.eqb (fstpp x) (fstpp x')) true
HX'Y'S : Logic.eq (sndpp x') (sndpp y')
HX'Y'F : Logic.eq (fstpp x') (fstpp y')
HXYS : Logic.eq (sndpp x) (sndpp y)
HXYF : Logic.eq (fstpp x) (fstpp y)
x,y,x',y' : True
*****
Logic.eq (Pos.eqb (sndpp y) (sndpp y')) true
+++++
apply Pos.eqb_eq.
-----
Instance lt_compat : Proper (eq==>eq==>iff) lt.
Proof.
intros x y HXY x' y' HX'Y'.
unfold lt.
unfold eq in *.
elim HXY.
intros HXYF HXYS.
elim HX'Y'.
intros HX'Y'F HX'Y'S.
clear HXY.
clear HX'Y'.
unfold Pos.eq in *.
case_eq (Pos.eqb (fstpp(x)) (fstpp(x'))).
intro HXX'F.
assert (HYY'F : Pos.eqb (fstpp(y)) (fstpp(y')) = true).
rewrite HYY'F.
case_eq (Pos.eqb (sndpp(x)) (sndpp(x'))).
intro HXX'S.
apply Pos.eqb_eq in HXX'S.
assert (HYY'S : Pos.eqb (sndpp(y)) (sndpp(y')) = true).
apply Pos.eqb_eq.

*****
HXX'S : Logic.eq (sndpp x) (sndpp x')
HYY'F : Logic.eq (Pos.eqb (fstpp y) (fstpp y')) true
HXX'F : Logic.eq (Pos.eqb (fstpp x) (fstpp x')) true
HX'Y'S : Logic.eq (sndpp x') (sndpp y')
HX'Y'F : Logic.eq (fstpp x') (fstpp y')
HXYS : Logic.eq (sndpp x) (sndpp y)
HXYF : Logic.eq (fstpp x) (fstpp y)
x,y,x',y' : True
*****
Logic.eq (sndpp y) (sndpp y')
+++++
rewrite <- HXYS.
-----
Instance lt_compat : Proper (eq==>eq==>iff) lt.
Proof.
intros x y HXY x' y' HX'Y'.
unfold lt.
unfold eq in *.
elim HXY.
intros HXYF HXYS.
elim HX'Y'.
intros HX'Y'F HX'Y'S.
clear HXY.
clear HX'Y'.
unfold Pos.eq in *.
case_eq (Pos.eqb (fstpp(x)) (fstpp(x'))).
intro HXX'F.
assert (HYY'F : Pos.eqb (fstpp(y)) (fstpp(y')) = true).
rewrite HYY'F.
case_eq (Pos.eqb (sndpp(x)) (sndpp(x'))).
intro HXX'S.
apply Pos.eqb_eq in HXX'S.
assert (HYY'S : Pos.eqb (sndpp(y)) (sndpp(y')) = true).
apply Pos.eqb_eq.
rewrite <- HXYS.

*****
HXX'S : Logic.eq (sndpp x) (sndpp x')
HYY'F : Logic.eq (Pos.eqb (fstpp y) (fstpp y')) true
HXX'F : Logic.eq (Pos.eqb (fstpp x) (fstpp x')) true
HX'Y'S : Logic.eq (sndpp x') (sndpp y')
HX'Y'F : Logic.eq (fstpp x') (fstpp y')
HXYS : Logic.eq (sndpp x) (sndpp y)
HXYF : Logic.eq (fstpp x) (fstpp y)
x,y,x',y' : True
*****
Logic.eq (sndpp x) (sndpp y')
+++++
rewrite <- HX'Y'S.
-----
Instance lt_compat : Proper (eq==>eq==>iff) lt.
Proof.
intros x y HXY x' y' HX'Y'.
unfold lt.
unfold eq in *.
elim HXY.
intros HXYF HXYS.
elim HX'Y'.
intros HX'Y'F HX'Y'S.
clear HXY.
clear HX'Y'.
unfold Pos.eq in *.
case_eq (Pos.eqb (fstpp(x)) (fstpp(x'))).
intro HXX'F.
assert (HYY'F : Pos.eqb (fstpp(y)) (fstpp(y')) = true).
rewrite HYY'F.
case_eq (Pos.eqb (sndpp(x)) (sndpp(x'))).
intro HXX'S.
apply Pos.eqb_eq in HXX'S.
assert (HYY'S : Pos.eqb (sndpp(y)) (sndpp(y')) = true).
apply Pos.eqb_eq.
rewrite <- HXYS.
rewrite <- HX'Y'S.

*****
HXX'S : Logic.eq (sndpp x) (sndpp x')
HYY'F : Logic.eq (Pos.eqb (fstpp y) (fstpp y')) true
HXX'F : Logic.eq (Pos.eqb (fstpp x) (fstpp x')) true
HX'Y'S : Logic.eq (sndpp x') (sndpp y')
HX'Y'F : Logic.eq (fstpp x') (fstpp y')
HXYS : Logic.eq (sndpp x) (sndpp y)
HXYF : Logic.eq (fstpp x) (fstpp y)
x,y,x',y' : True
*****
Logic.eq (sndpp x) (sndpp x')
+++++
assumption.
-----
Instance lt_compat : Proper (eq==>eq==>iff) lt.
Proof.
intros x y HXY x' y' HX'Y'.
unfold lt.
unfold eq in *.
elim HXY.
intros HXYF HXYS.
elim HX'Y'.
intros HX'Y'F HX'Y'S.
clear HXY.
clear HX'Y'.
unfold Pos.eq in *.
case_eq (Pos.eqb (fstpp(x)) (fstpp(x'))).
intro HXX'F.
assert (HYY'F : Pos.eqb (fstpp(y)) (fstpp(y')) = true).
rewrite HYY'F.
case_eq (Pos.eqb (sndpp(x)) (sndpp(x'))).
intro HXX'S.
apply Pos.eqb_eq in HXX'S.
assert (HYY'S : Pos.eqb (sndpp(y)) (sndpp(y')) = true).

*****
HYY'S : Logic.eq (Pos.eqb (sndpp y) (sndpp y')) true
HXX'S : Logic.eq (sndpp x) (sndpp x')
HYY'F : Logic.eq (Pos.eqb (fstpp y) (fstpp y')) true
HXX'F : Logic.eq (Pos.eqb (fstpp x) (fstpp x')) true
HX'Y'S : Logic.eq (sndpp x') (sndpp y')
HX'Y'F : Logic.eq (fstpp x') (fstpp y')
HXYS : Logic.eq (sndpp x) (sndpp y)
HXYF : Logic.eq (fstpp x) (fstpp y)
x,y,x',y' : True
*****
iff (Pos.lt (sndpp x) (sndpp x')) (Pos.lt (sndpp y) (sndpp y'))
+++++
apply Pos.eqb_eq in HYY'S.
-----
Instance lt_compat : Proper (eq==>eq==>iff) lt.
Proof.
intros x y HXY x' y' HX'Y'.
unfold lt.
unfold eq in *.
elim HXY.
intros HXYF HXYS.
elim HX'Y'.
intros HX'Y'F HX'Y'S.
clear HXY.
clear HX'Y'.
unfold Pos.eq in *.
case_eq (Pos.eqb (fstpp(x)) (fstpp(x'))).
intro HXX'F.
assert (HYY'F : Pos.eqb (fstpp(y)) (fstpp(y')) = true).
rewrite HYY'F.
case_eq (Pos.eqb (sndpp(x)) (sndpp(x'))).
intro HXX'S.
apply Pos.eqb_eq in HXX'S.
assert (HYY'S : Pos.eqb (sndpp(y)) (sndpp(y')) = true).
apply Pos.eqb_eq in HYY'S.

*****
HYY'S : Logic.eq (sndpp y) (sndpp y')
HXX'S : Logic.eq (sndpp x) (sndpp x')
HYY'F : Logic.eq (Pos.eqb (fstpp y) (fstpp y')) true
HXX'F : Logic.eq (Pos.eqb (fstpp x) (fstpp x')) true
HX'Y'S : Logic.eq (sndpp x') (sndpp y')
HX'Y'F : Logic.eq (fstpp x') (fstpp y')
HXYS : Logic.eq (sndpp x) (sndpp y)
HXYF : Logic.eq (fstpp x) (fstpp y)
x,y,x',y' : True
*****
iff (Pos.lt (sndpp x) (sndpp x')) (Pos.lt (sndpp y) (sndpp y'))
+++++
rewrite HYY'S.
-----
Instance lt_compat : Proper (eq==>eq==>iff) lt.
Proof.
intros x y HXY x' y' HX'Y'.
unfold lt.
unfold eq in *.
elim HXY.
intros HXYF HXYS.
elim HX'Y'.
intros HX'Y'F HX'Y'S.
clear HXY.
clear HX'Y'.
unfold Pos.eq in *.
case_eq (Pos.eqb (fstpp(x)) (fstpp(x'))).
intro HXX'F.
assert (HYY'F : Pos.eqb (fstpp(y)) (fstpp(y')) = true).
rewrite HYY'F.
case_eq (Pos.eqb (sndpp(x)) (sndpp(x'))).
intro HXX'S.
apply Pos.eqb_eq in HXX'S.
assert (HYY'S : Pos.eqb (sndpp(y)) (sndpp(y')) = true).
apply Pos.eqb_eq in HYY'S.
rewrite HYY'S.

*****
HYY'S : Logic.eq (sndpp y) (sndpp y')
HXX'S : Logic.eq (sndpp x) (sndpp x')
HYY'F : Logic.eq (Pos.eqb (fstpp y) (fstpp y')) true
HXX'F : Logic.eq (Pos.eqb (fstpp x) (fstpp x')) true
HX'Y'S : Logic.eq (sndpp x') (sndpp y')
HX'Y'F : Logic.eq (fstpp x') (fstpp y')
HXYS : Logic.eq (sndpp x) (sndpp y)
HXYF : Logic.eq (fstpp x) (fstpp y)
x,y,x',y' : True
*****
iff (Pos.lt (sndpp x) (sndpp x')) (Pos.lt (sndpp y') (sndpp y'))
+++++
rewrite HXX'S.
-----
Instance lt_compat : Proper (eq==>eq==>iff) lt.
Proof.
intros x y HXY x' y' HX'Y'.
unfold lt.
unfold eq in *.
elim HXY.
intros HXYF HXYS.
elim HX'Y'.
intros HX'Y'F HX'Y'S.
clear HXY.
clear HX'Y'.
unfold Pos.eq in *.
case_eq (Pos.eqb (fstpp(x)) (fstpp(x'))).
intro HXX'F.
assert (HYY'F : Pos.eqb (fstpp(y)) (fstpp(y')) = true).
rewrite HYY'F.
case_eq (Pos.eqb (sndpp(x)) (sndpp(x'))).
intro HXX'S.
apply Pos.eqb_eq in HXX'S.
assert (HYY'S : Pos.eqb (sndpp(y)) (sndpp(y')) = true).
apply Pos.eqb_eq in HYY'S.
rewrite HYY'S.
rewrite HXX'S.

*****
HYY'S : Logic.eq (sndpp y) (sndpp y')
HXX'S : Logic.eq (sndpp x) (sndpp x')
HYY'F : Logic.eq (Pos.eqb (fstpp y) (fstpp y')) true
HXX'F : Logic.eq (Pos.eqb (fstpp x) (fstpp x')) true
HX'Y'S : Logic.eq (sndpp x') (sndpp y')
HX'Y'F : Logic.eq (fstpp x') (fstpp y')
HXYS : Logic.eq (sndpp x) (sndpp y)
HXYF : Logic.eq (fstpp x) (fstpp y)
x,y,x',y' : True
*****
iff (Pos.lt (sndpp x') (sndpp x')) (Pos.lt (sndpp y') (sndpp y'))
+++++
rewrite HX'Y'S.
-----
Instance lt_compat : Proper (eq==>eq==>iff) lt.
Proof.
intros x y HXY x' y' HX'Y'.
unfold lt.
unfold eq in *.
elim HXY.
intros HXYF HXYS.
elim HX'Y'.
intros HX'Y'F HX'Y'S.
clear HXY.
clear HX'Y'.
unfold Pos.eq in *.
case_eq (Pos.eqb (fstpp(x)) (fstpp(x'))).
intro HXX'F.
assert (HYY'F : Pos.eqb (fstpp(y)) (fstpp(y')) = true).
rewrite HYY'F.
case_eq (Pos.eqb (sndpp(x)) (sndpp(x'))).
intro HXX'S.
apply Pos.eqb_eq in HXX'S.
assert (HYY'S : Pos.eqb (sndpp(y)) (sndpp(y')) = true).
apply Pos.eqb_eq in HYY'S.
rewrite HYY'S.
rewrite HXX'S.
rewrite HX'Y'S.

*****
HYY'S : Logic.eq (sndpp y) (sndpp y')
HXX'S : Logic.eq (sndpp x) (sndpp x')
HYY'F : Logic.eq (Pos.eqb (fstpp y) (fstpp y')) true
HXX'F : Logic.eq (Pos.eqb (fstpp x) (fstpp x')) true
HX'Y'S : Logic.eq (sndpp x') (sndpp y')
HX'Y'F : Logic.eq (fstpp x') (fstpp y')
HXYS : Logic.eq (sndpp x) (sndpp y)
HXYF : Logic.eq (fstpp x) (fstpp y)
x,y,x',y' : True
*****
iff (Pos.lt (sndpp y') (sndpp y')) (Pos.lt (sndpp y') (sndpp y'))
+++++
intuition.
-----
Instance lt_compat : Proper (eq==>eq==>iff) lt.
Proof.
intros x y HXY x' y' HX'Y'.
unfold lt.
unfold eq in *.
elim HXY.
intros HXYF HXYS.
elim HX'Y'.
intros HX'Y'F HX'Y'S.
clear HXY.
clear HX'Y'.
unfold Pos.eq in *.
case_eq (Pos.eqb (fstpp(x)) (fstpp(x'))).
intro HXX'F.
assert (HYY'F : Pos.eqb (fstpp(y)) (fstpp(y')) = true).
rewrite HYY'F.
case_eq (Pos.eqb (sndpp(x)) (sndpp(x'))).

*****
HYY'F : Logic.eq (Pos.eqb (fstpp y) (fstpp y')) true
HXX'F : Logic.eq (Pos.eqb (fstpp x) (fstpp x')) true
HX'Y'S : Logic.eq (sndpp x') (sndpp y')
HX'Y'F : Logic.eq (fstpp x') (fstpp y')
HXYS : Logic.eq (sndpp x) (sndpp y)
HXYF : Logic.eq (fstpp x) (fstpp y)
x,y,x',y' : True
*****
forall _ : Logic.eq (Pos.eqb (sndpp x) (sndpp x')) false, iff (Pos.lt (sndpp x) (sndpp x')) (Pos.lt (sndpp y) (sndpp y'))
+++++
intro HXX'S.
-----
Instance lt_compat : Proper (eq==>eq==>iff) lt.
Proof.
intros x y HXY x' y' HX'Y'.
unfold lt.
unfold eq in *.
elim HXY.
intros HXYF HXYS.
elim HX'Y'.
intros HX'Y'F HX'Y'S.
clear HXY.
clear HX'Y'.
unfold Pos.eq in *.
case_eq (Pos.eqb (fstpp(x)) (fstpp(x'))).
intro HXX'F.
assert (HYY'F : Pos.eqb (fstpp(y)) (fstpp(y')) = true).
rewrite HYY'F.
case_eq (Pos.eqb (sndpp(x)) (sndpp(x'))).
intro HXX'S.

*****
HXX'S : Logic.eq (Pos.eqb (sndpp x) (sndpp x')) false
HYY'F : Logic.eq (Pos.eqb (fstpp y) (fstpp y')) true
HXX'F : Logic.eq (Pos.eqb (fstpp x) (fstpp x')) true
HX'Y'S : Logic.eq (sndpp x') (sndpp y')
HX'Y'F : Logic.eq (fstpp x') (fstpp y')
HXYS : Logic.eq (sndpp x) (sndpp y)
HXYF : Logic.eq (fstpp x) (fstpp y)
x,y,x',y' : True
*****
iff (Pos.lt (sndpp x) (sndpp x')) (Pos.lt (sndpp y) (sndpp y'))
+++++
rewrite HXYS.
-----
Instance lt_compat : Proper (eq==>eq==>iff) lt.
Proof.
intros x y HXY x' y' HX'Y'.
unfold lt.
unfold eq in *.
elim HXY.
intros HXYF HXYS.
elim HX'Y'.
intros HX'Y'F HX'Y'S.
clear HXY.
clear HX'Y'.
unfold Pos.eq in *.
case_eq (Pos.eqb (fstpp(x)) (fstpp(x'))).
intro HXX'F.
assert (HYY'F : Pos.eqb (fstpp(y)) (fstpp(y')) = true).
rewrite HYY'F.
case_eq (Pos.eqb (sndpp(x)) (sndpp(x'))).
intro HXX'S.
rewrite HXYS.

*****
HXX'S : Logic.eq (Pos.eqb (sndpp x) (sndpp x')) false
HYY'F : Logic.eq (Pos.eqb (fstpp y) (fstpp y')) true
HXX'F : Logic.eq (Pos.eqb (fstpp x) (fstpp x')) true
HX'Y'S : Logic.eq (sndpp x') (sndpp y')
HX'Y'F : Logic.eq (fstpp x') (fstpp y')
HXYS : Logic.eq (sndpp x) (sndpp y)
HXYF : Logic.eq (fstpp x) (fstpp y)
x,y,x',y' : True
*****
iff (Pos.lt (sndpp y) (sndpp x')) (Pos.lt (sndpp y) (sndpp y'))
+++++
rewrite HX'Y'S.
-----
Instance lt_compat : Proper (eq==>eq==>iff) lt.
Proof.
intros x y HXY x' y' HX'Y'.
unfold lt.
unfold eq in *.
elim HXY.
intros HXYF HXYS.
elim HX'Y'.
intros HX'Y'F HX'Y'S.
clear HXY.
clear HX'Y'.
unfold Pos.eq in *.
case_eq (Pos.eqb (fstpp(x)) (fstpp(x'))).
intro HXX'F.
assert (HYY'F : Pos.eqb (fstpp(y)) (fstpp(y')) = true).
rewrite HYY'F.
case_eq (Pos.eqb (sndpp(x)) (sndpp(x'))).
intro HXX'S.
rewrite HXYS.
rewrite HX'Y'S.

*****
HXX'S : Logic.eq (Pos.eqb (sndpp x) (sndpp x')) false
HYY'F : Logic.eq (Pos.eqb (fstpp y) (fstpp y')) true
HXX'F : Logic.eq (Pos.eqb (fstpp x) (fstpp x')) true
HX'Y'S : Logic.eq (sndpp x') (sndpp y')
HX'Y'F : Logic.eq (fstpp x') (fstpp y')
HXYS : Logic.eq (sndpp x) (sndpp y)
HXYF : Logic.eq (fstpp x) (fstpp y)
x,y,x',y' : True
*****
iff (Pos.lt (sndpp y) (sndpp y')) (Pos.lt (sndpp y) (sndpp y'))
+++++
intuition.
-----
Instance lt_compat : Proper (eq==>eq==>iff) lt.
Proof.
intros x y HXY x' y' HX'Y'.
unfold lt.
unfold eq in *.
elim HXY.
intros HXYF HXYS.
elim HX'Y'.
intros HX'Y'F HX'Y'S.
clear HXY.
clear HX'Y'.
unfold Pos.eq in *.
case_eq (Pos.eqb (fstpp(x)) (fstpp(x'))).

*****
HX'Y'S : Logic.eq (sndpp x') (sndpp y')
HX'Y'F : Logic.eq (fstpp x') (fstpp y')
HXYS : Logic.eq (sndpp x) (sndpp y)
HXYF : Logic.eq (fstpp x) (fstpp y)
x,y,x',y' : True
*****
forall _ : Logic.eq (Pos.eqb (fstpp x) (fstpp x')) false, iff (Pos.lt (fstpp x) (fstpp x')) (if Pos.eqb (fstpp y) (fstpp y') then Pos.lt (sndpp y) (sndpp y') else Pos.lt (fstpp y) (fstpp y'))
+++++
intro HXX'F.
-----
Instance lt_compat : Proper (eq==>eq==>iff) lt.
Proof.
intros x y HXY x' y' HX'Y'.
unfold lt.
unfold eq in *.
elim HXY.
intros HXYF HXYS.
elim HX'Y'.
intros HX'Y'F HX'Y'S.
clear HXY.
clear HX'Y'.
unfold Pos.eq in *.
case_eq (Pos.eqb (fstpp(x)) (fstpp(x'))).
intro HXX'F.

*****
HXX'F : Logic.eq (Pos.eqb (fstpp x) (fstpp x')) false
HX'Y'S : Logic.eq (sndpp x') (sndpp y')
HX'Y'F : Logic.eq (fstpp x') (fstpp y')
HXYS : Logic.eq (sndpp x) (sndpp y)
HXYF : Logic.eq (fstpp x) (fstpp y)
x,y,x',y' : True
*****
iff (Pos.lt (fstpp x) (fstpp x')) (if Pos.eqb (fstpp y) (fstpp y') then Pos.lt (sndpp y) (sndpp y') else Pos.lt (fstpp y) (fstpp y'))
+++++
assert (HYY'F : Pos.eqb (fstpp(y)) (fstpp(y')) = false).
-----
Instance lt_compat : Proper (eq==>eq==>iff) lt.
Proof.
intros x y HXY x' y' HX'Y'.
unfold lt.
unfold eq in *.
elim HXY.
intros HXYF HXYS.
elim HX'Y'.
intros HX'Y'F HX'Y'S.
clear HXY.
clear HX'Y'.
unfold Pos.eq in *.
case_eq (Pos.eqb (fstpp(x)) (fstpp(x'))).
intro HXX'F.
assert (HYY'F : Pos.eqb (fstpp(y)) (fstpp(y')) = false).

*****
HXX'F : Logic.eq (Pos.eqb (fstpp x) (fstpp x')) false
HX'Y'S : Logic.eq (sndpp x') (sndpp y')
HX'Y'F : Logic.eq (fstpp x') (fstpp y')
HXYS : Logic.eq (sndpp x) (sndpp y)
HXYF : Logic.eq (fstpp x) (fstpp y)
x,y,x',y' : True
*****
Logic.eq (Pos.eqb (fstpp y) (fstpp y')) false
+++++
rewrite <- HXYF.
-----
Instance lt_compat : Proper (eq==>eq==>iff) lt.
Proof.
intros x y HXY x' y' HX'Y'.
unfold lt.
unfold eq in *.
elim HXY.
intros HXYF HXYS.
elim HX'Y'.
intros HX'Y'F HX'Y'S.
clear HXY.
clear HX'Y'.
unfold Pos.eq in *.
case_eq (Pos.eqb (fstpp(x)) (fstpp(x'))).
intro HXX'F.
assert (HYY'F : Pos.eqb (fstpp(y)) (fstpp(y')) = false).
rewrite <- HXYF.

*****
HXX'F : Logic.eq (Pos.eqb (fstpp x) (fstpp x')) false
HX'Y'S : Logic.eq (sndpp x') (sndpp y')
HX'Y'F : Logic.eq (fstpp x') (fstpp y')
HXYS : Logic.eq (sndpp x) (sndpp y)
HXYF : Logic.eq (fstpp x) (fstpp y)
x,y,x',y' : True
*****
Logic.eq (Pos.eqb (fstpp x) (fstpp y')) false
+++++
rewrite <- HX'Y'F.
-----
Instance lt_compat : Proper (eq==>eq==>iff) lt.
Proof.
intros x y HXY x' y' HX'Y'.
unfold lt.
unfold eq in *.
elim HXY.
intros HXYF HXYS.
elim HX'Y'.
intros HX'Y'F HX'Y'S.
clear HXY.
clear HX'Y'.
unfold Pos.eq in *.
case_eq (Pos.eqb (fstpp(x)) (fstpp(x'))).
intro HXX'F.
assert (HYY'F : Pos.eqb (fstpp(y)) (fstpp(y')) = false).
rewrite <- HXYF.
rewrite <- HX'Y'F.

*****
HXX'F : Logic.eq (Pos.eqb (fstpp x) (fstpp x')) false
HX'Y'S : Logic.eq (sndpp x') (sndpp y')
HX'Y'F : Logic.eq (fstpp x') (fstpp y')
HXYS : Logic.eq (sndpp x) (sndpp y)
HXYF : Logic.eq (fstpp x) (fstpp y)
x,y,x',y' : True
*****
Logic.eq (Pos.eqb (fstpp x) (fstpp x')) false
+++++
assumption.
-----
Instance lt_compat : Proper (eq==>eq==>iff) lt.
Proof.
intros x y HXY x' y' HX'Y'.
unfold lt.
unfold eq in *.
elim HXY.
intros HXYF HXYS.
elim HX'Y'.
intros HX'Y'F HX'Y'S.
clear HXY.
clear HX'Y'.
unfold Pos.eq in *.
case_eq (Pos.eqb (fstpp(x)) (fstpp(x'))).
intro HXX'F.
assert (HYY'F : Pos.eqb (fstpp(y)) (fstpp(y')) = false).

*****
HYY'F : Logic.eq (Pos.eqb (fstpp y) (fstpp y')) false
HXX'F : Logic.eq (Pos.eqb (fstpp x) (fstpp x')) false
HX'Y'S : Logic.eq (sndpp x') (sndpp y')
HX'Y'F : Logic.eq (fstpp x') (fstpp y')
HXYS : Logic.eq (sndpp x) (sndpp y)
HXYF : Logic.eq (fstpp x) (fstpp y)
x,y,x',y' : True
*****
iff (Pos.lt (fstpp x) (fstpp x')) (if Pos.eqb (fstpp y) (fstpp y') then Pos.lt (sndpp y) (sndpp y') else Pos.lt (fstpp y) (fstpp y'))
+++++
rewrite HYY'F.
-----
Instance lt_compat : Proper (eq==>eq==>iff) lt.
Proof.
intros x y HXY x' y' HX'Y'.
unfold lt.
unfold eq in *.
elim HXY.
intros HXYF HXYS.
elim HX'Y'.
intros HX'Y'F HX'Y'S.
clear HXY.
clear HX'Y'.
unfold Pos.eq in *.
case_eq (Pos.eqb (fstpp(x)) (fstpp(x'))).
intro HXX'F.
assert (HYY'F : Pos.eqb (fstpp(y)) (fstpp(y')) = false).
rewrite HYY'F.

*****
HYY'F : Logic.eq (Pos.eqb (fstpp y) (fstpp y')) false
HXX'F : Logic.eq (Pos.eqb (fstpp x) (fstpp x')) false
HX'Y'S : Logic.eq (sndpp x') (sndpp y')
HX'Y'F : Logic.eq (fstpp x') (fstpp y')
HXYS : Logic.eq (sndpp x) (sndpp y)
HXYF : Logic.eq (fstpp x) (fstpp y)
x,y,x',y' : True
*****
iff (Pos.lt (fstpp x) (fstpp x')) (Pos.lt (fstpp y) (fstpp y'))
+++++
rewrite HXYF.
-----
Instance lt_compat : Proper (eq==>eq==>iff) lt.
Proof.
intros x y HXY x' y' HX'Y'.
unfold lt.
unfold eq in *.
elim HXY.
intros HXYF HXYS.
elim HX'Y'.
intros HX'Y'F HX'Y'S.
clear HXY.
clear HX'Y'.
unfold Pos.eq in *.
case_eq (Pos.eqb (fstpp(x)) (fstpp(x'))).
intro HXX'F.
assert (HYY'F : Pos.eqb (fstpp(y)) (fstpp(y')) = false).
rewrite HYY'F.
rewrite HXYF.

*****
HYY'F : Logic.eq (Pos.eqb (fstpp y) (fstpp y')) false
HXX'F : Logic.eq (Pos.eqb (fstpp x) (fstpp x')) false
HX'Y'S : Logic.eq (sndpp x') (sndpp y')
HX'Y'F : Logic.eq (fstpp x') (fstpp y')
HXYS : Logic.eq (sndpp x) (sndpp y)
HXYF : Logic.eq (fstpp x) (fstpp y)
x,y,x',y' : True
*****
iff (Pos.lt (fstpp y) (fstpp x')) (Pos.lt (fstpp y) (fstpp y'))
+++++
rewrite HX'Y'F.
-----
Instance lt_compat : Proper (eq==>eq==>iff) lt.
Proof.
intros x y HXY x' y' HX'Y'.
unfold lt.
unfold eq in *.
elim HXY.
intros HXYF HXYS.
elim HX'Y'.
intros HX'Y'F HX'Y'S.
clear HXY.
clear HX'Y'.
unfold Pos.eq in *.
case_eq (Pos.eqb (fstpp(x)) (fstpp(x'))).
intro HXX'F.
assert (HYY'F : Pos.eqb (fstpp(y)) (fstpp(y')) = false).
rewrite HYY'F.
rewrite HXYF.
rewrite HX'Y'F.

*****
HYY'F : Logic.eq (Pos.eqb (fstpp y) (fstpp y')) false
HXX'F : Logic.eq (Pos.eqb (fstpp x) (fstpp x')) false
HX'Y'S : Logic.eq (sndpp x') (sndpp y')
HX'Y'F : Logic.eq (fstpp x') (fstpp y')
HXYS : Logic.eq (sndpp x) (sndpp y)
HXYF : Logic.eq (fstpp x) (fstpp y)
x,y,x',y' : True
*****
iff (Pos.lt (fstpp y) (fstpp y')) (Pos.lt (fstpp y) (fstpp y'))
+++++
intuition.
-----
Instance lt_compat : Proper (eq==>eq==>iff) lt.
Proof.
intros x y HXY x' y' HX'Y'.
unfold lt.
unfold eq in *.
elim HXY.
intros HXYF HXYS.
elim HX'Y'.
intros HX'Y'F HX'Y'S.
clear HXY.
clear HX'Y'.
unfold Pos.eq in *.
case_eq (Pos.eqb (fstpp(x)) (fstpp(x'))).

*****

*****

+++++
Qed.
-----
Instance lt_strorder : StrictOrder lt.
-----
Instance lt_strorder : StrictOrder lt.

*****

*****
StrictOrder lt
+++++
Proof.
-----
Instance lt_strorder : StrictOrder lt.
Proof.

*****

*****
StrictOrder lt
+++++
apply Build_StrictOrder.
-----
Instance lt_strorder : StrictOrder lt.
Proof.
apply Build_StrictOrder.

*****

*****
Irreflexive lt
+++++
apply lt_irrefl.
-----
Instance lt_strorder : StrictOrder lt.
Proof.
apply Build_StrictOrder.

*****

*****
Transitive lt
+++++
apply lt_trans.
-----
Instance lt_strorder : StrictOrder lt.
Proof.
apply Build_StrictOrder.

*****

*****

+++++
Qed.
-----
Definition compare t1 t2 :=\n    let ft1 := fstpp(t1) in\n    let ft2 := fstpp(t2) in\n    let st1 := sndpp(t1) in\n    let st2 := sndpp(t2) in\n    match (Pos.compare ft1 ft2) with\n      | Lt => Lt\n      | Eq => Pos.compare st1 st2\n      | Gt => Gt\n    end.
-----
Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).
-----
Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).

*****

*****
forall t1 t2 : t, CompSpec eq lt t1 t2 (compare t1 t2)
+++++
Proof.
-----
Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).
Proof.

*****

*****
forall t1 t2 : t, CompSpec eq lt t1 t2 (compare t1 t2)
+++++
intros t1 t2.
-----
Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).
Proof.
intros t1 t2.

*****
t1,t2 : True
*****
CompSpec eq lt t1 t2 (compare t1 t2)
+++++
case_eq (Pos.eqb (fstpp(t1)) (fstpp(t2))).
-----
Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).
Proof.
intros t1 t2.
case_eq (Pos.eqb (fstpp(t1)) (fstpp(t2))).

*****
t1,t2 : True
*****
forall _ : Logic.eq (Pos.eqb (fstpp t1) (fstpp t2)) true, CompSpec eq lt t1 t2 (compare t1 t2)
+++++
intro HF.
-----
Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).
Proof.
intros t1 t2.
case_eq (Pos.eqb (fstpp(t1)) (fstpp(t2))).
intro HF.

*****
HF : Logic.eq (Pos.eqb (fstpp t1) (fstpp t2)) true
t1,t2 : True
*****
CompSpec eq lt t1 t2 (compare t1 t2)
+++++
apply Pos.eqb_eq in HF.
-----
Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).
Proof.
intros t1 t2.
case_eq (Pos.eqb (fstpp(t1)) (fstpp(t2))).
intro HF.
apply Pos.eqb_eq in HF.

*****
HF : Logic.eq (fstpp t1) (fstpp t2)
t1,t2 : True
*****
CompSpec eq lt t1 t2 (compare t1 t2)
+++++
case_eq (Pos.eqb (sndpp(t1)) (sndpp(t2))).
-----
Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).
Proof.
intros t1 t2.
case_eq (Pos.eqb (fstpp(t1)) (fstpp(t2))).
intro HF.
apply Pos.eqb_eq in HF.
case_eq (Pos.eqb (sndpp(t1)) (sndpp(t2))).

*****
HF : Logic.eq (fstpp t1) (fstpp t2)
t1,t2 : True
*****
forall _ : Logic.eq (Pos.eqb (sndpp t1) (sndpp t2)) true, CompSpec eq lt t1 t2 (compare t1 t2)
+++++
intro HS.
-----
Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).
Proof.
intros t1 t2.
case_eq (Pos.eqb (fstpp(t1)) (fstpp(t2))).
intro HF.
apply Pos.eqb_eq in HF.
case_eq (Pos.eqb (sndpp(t1)) (sndpp(t2))).
intro HS.

*****
HS : Logic.eq (Pos.eqb (sndpp t1) (sndpp t2)) true
HF : Logic.eq (fstpp t1) (fstpp t2)
t1,t2 : True
*****
CompSpec eq lt t1 t2 (compare t1 t2)
+++++
apply Pos.eqb_eq in HS.
-----
Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).
Proof.
intros t1 t2.
case_eq (Pos.eqb (fstpp(t1)) (fstpp(t2))).
intro HF.
apply Pos.eqb_eq in HF.
case_eq (Pos.eqb (sndpp(t1)) (sndpp(t2))).
intro HS.
apply Pos.eqb_eq in HS.

*****
HS : Logic.eq (sndpp t1) (sndpp t2)
HF : Logic.eq (fstpp t1) (fstpp t2)
t1,t2 : True
*****
CompSpec eq lt t1 t2 (compare t1 t2)
+++++
unfold CompSpec.
-----
Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).
Proof.
intros t1 t2.
case_eq (Pos.eqb (fstpp(t1)) (fstpp(t2))).
intro HF.
apply Pos.eqb_eq in HF.
case_eq (Pos.eqb (sndpp(t1)) (sndpp(t2))).
intro HS.
apply Pos.eqb_eq in HS.
unfold CompSpec.

*****
HS : Logic.eq (sndpp t1) (sndpp t2)
HF : Logic.eq (fstpp t1) (fstpp t2)
t1,t2 : True
*****
CompareSpec (eq t1 t2) (lt t1 t2) (lt t2 t1) (compare t1 t2)
+++++
assert (HC : compare t1 t2 = Eq).
-----
Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).
Proof.
intros t1 t2.
case_eq (Pos.eqb (fstpp(t1)) (fstpp(t2))).
intro HF.
apply Pos.eqb_eq in HF.
case_eq (Pos.eqb (sndpp(t1)) (sndpp(t2))).
intro HS.
apply Pos.eqb_eq in HS.
unfold CompSpec.
assert (HC : compare t1 t2 = Eq).

*****
HS : Logic.eq (sndpp t1) (sndpp t2)
HF : Logic.eq (fstpp t1) (fstpp t2)
t1,t2 : True
*****
Logic.eq (compare t1 t2) Eq
+++++
unfold compare.
-----
Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).
Proof.
intros t1 t2.
case_eq (Pos.eqb (fstpp(t1)) (fstpp(t2))).
intro HF.
apply Pos.eqb_eq in HF.
case_eq (Pos.eqb (sndpp(t1)) (sndpp(t2))).
intro HS.
apply Pos.eqb_eq in HS.
unfold CompSpec.
assert (HC : compare t1 t2 = Eq).
unfold compare.

*****
HS : Logic.eq (sndpp t1) (sndpp t2)
HF : Logic.eq (fstpp t1) (fstpp t2)
t1,t2 : True
*****
Logic.eq match Pos.compare (fstpp t1) (fstpp t2) with | Eq => Pos.compare (sndpp t1) (sndpp t2) | Lt => Lt | Gt => Gt end Eq
+++++
assert (HCF : Pos.compare (fstpp(t1)) (fstpp(t2)) = Eq).
-----
Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).
Proof.
intros t1 t2.
case_eq (Pos.eqb (fstpp(t1)) (fstpp(t2))).
intro HF.
apply Pos.eqb_eq in HF.
case_eq (Pos.eqb (sndpp(t1)) (sndpp(t2))).
intro HS.
apply Pos.eqb_eq in HS.
unfold CompSpec.
assert (HC : compare t1 t2 = Eq).
unfold compare.
assert (HCF : Pos.compare (fstpp(t1)) (fstpp(t2)) = Eq).

*****
HS : Logic.eq (sndpp t1) (sndpp t2)
HF : Logic.eq (fstpp t1) (fstpp t2)
t1,t2 : True
*****
Logic.eq (Pos.compare (fstpp t1) (fstpp t2)) Eq
+++++
unfold Pos.compare.
-----
Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).
Proof.
intros t1 t2.
case_eq (Pos.eqb (fstpp(t1)) (fstpp(t2))).
intro HF.
apply Pos.eqb_eq in HF.
case_eq (Pos.eqb (sndpp(t1)) (sndpp(t2))).
intro HS.
apply Pos.eqb_eq in HS.
unfold CompSpec.
assert (HC : compare t1 t2 = Eq).
unfold compare.
assert (HCF : Pos.compare (fstpp(t1)) (fstpp(t2)) = Eq).
unfold Pos.compare.

*****
HS : Logic.eq (sndpp t1) (sndpp t2)
HF : Logic.eq (fstpp t1) (fstpp t2)
t1,t2 : True
*****
Logic.eq (Pos.compare_cont Eq (fstpp t1) (fstpp t2)) Eq
+++++
rewrite HF.
-----
Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).
Proof.
intros t1 t2.
case_eq (Pos.eqb (fstpp(t1)) (fstpp(t2))).
intro HF.
apply Pos.eqb_eq in HF.
case_eq (Pos.eqb (sndpp(t1)) (sndpp(t2))).
intro HS.
apply Pos.eqb_eq in HS.
unfold CompSpec.
assert (HC : compare t1 t2 = Eq).
unfold compare.
assert (HCF : Pos.compare (fstpp(t1)) (fstpp(t2)) = Eq).
unfold Pos.compare.
rewrite HF.

*****
HS : Logic.eq (sndpp t1) (sndpp t2)
HF : Logic.eq (fstpp t1) (fstpp t2)
t1,t2 : True
*****
Logic.eq (Pos.compare_cont Eq (fstpp t2) (fstpp t2)) Eq
+++++
apply Pos.compare_cont_refl.
-----
Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).
Proof.
intros t1 t2.
case_eq (Pos.eqb (fstpp(t1)) (fstpp(t2))).
intro HF.
apply Pos.eqb_eq in HF.
case_eq (Pos.eqb (sndpp(t1)) (sndpp(t2))).
intro HS.
apply Pos.eqb_eq in HS.
unfold CompSpec.
assert (HC : compare t1 t2 = Eq).
unfold compare.
assert (HCF : Pos.compare (fstpp(t1)) (fstpp(t2)) = Eq).

*****
HCF : Logic.eq (Pos.compare (fstpp t1) (fstpp t2)) Eq
HS : Logic.eq (sndpp t1) (sndpp t2)
HF : Logic.eq (fstpp t1) (fstpp t2)
t1,t2 : True
*****
Logic.eq match Pos.compare (fstpp t1) (fstpp t2) with | Eq => Pos.compare (sndpp t1) (sndpp t2) | Lt => Lt | Gt => Gt end Eq
+++++
assert (HCS : Pos.compare (sndpp(t1)) (sndpp(t2)) = Eq).
-----
Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).
Proof.
intros t1 t2.
case_eq (Pos.eqb (fstpp(t1)) (fstpp(t2))).
intro HF.
apply Pos.eqb_eq in HF.
case_eq (Pos.eqb (sndpp(t1)) (sndpp(t2))).
intro HS.
apply Pos.eqb_eq in HS.
unfold CompSpec.
assert (HC : compare t1 t2 = Eq).
unfold compare.
assert (HCF : Pos.compare (fstpp(t1)) (fstpp(t2)) = Eq).
assert (HCS : Pos.compare (sndpp(t1)) (sndpp(t2)) = Eq).

*****
HCF : Logic.eq (Pos.compare (fstpp t1) (fstpp t2)) Eq
HS : Logic.eq (sndpp t1) (sndpp t2)
HF : Logic.eq (fstpp t1) (fstpp t2)
t1,t2 : True
*****
Logic.eq (Pos.compare (sndpp t1) (sndpp t2)) Eq
+++++
unfold Pos.compare.
-----
Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).
Proof.
intros t1 t2.
case_eq (Pos.eqb (fstpp(t1)) (fstpp(t2))).
intro HF.
apply Pos.eqb_eq in HF.
case_eq (Pos.eqb (sndpp(t1)) (sndpp(t2))).
intro HS.
apply Pos.eqb_eq in HS.
unfold CompSpec.
assert (HC : compare t1 t2 = Eq).
unfold compare.
assert (HCF : Pos.compare (fstpp(t1)) (fstpp(t2)) = Eq).
assert (HCS : Pos.compare (sndpp(t1)) (sndpp(t2)) = Eq).
unfold Pos.compare.

*****
HCF : Logic.eq (Pos.compare (fstpp t1) (fstpp t2)) Eq
HS : Logic.eq (sndpp t1) (sndpp t2)
HF : Logic.eq (fstpp t1) (fstpp t2)
t1,t2 : True
*****
Logic.eq (Pos.compare_cont Eq (sndpp t1) (sndpp t2)) Eq
+++++
rewrite HS.
-----
Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).
Proof.
intros t1 t2.
case_eq (Pos.eqb (fstpp(t1)) (fstpp(t2))).
intro HF.
apply Pos.eqb_eq in HF.
case_eq (Pos.eqb (sndpp(t1)) (sndpp(t2))).
intro HS.
apply Pos.eqb_eq in HS.
unfold CompSpec.
assert (HC : compare t1 t2 = Eq).
unfold compare.
assert (HCF : Pos.compare (fstpp(t1)) (fstpp(t2)) = Eq).
assert (HCS : Pos.compare (sndpp(t1)) (sndpp(t2)) = Eq).
unfold Pos.compare.
rewrite HS.

*****
HCF : Logic.eq (Pos.compare (fstpp t1) (fstpp t2)) Eq
HS : Logic.eq (sndpp t1) (sndpp t2)
HF : Logic.eq (fstpp t1) (fstpp t2)
t1,t2 : True
*****
Logic.eq (Pos.compare_cont Eq (sndpp t2) (sndpp t2)) Eq
+++++
apply Pos.compare_cont_refl.
-----
Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).
Proof.
intros t1 t2.
case_eq (Pos.eqb (fstpp(t1)) (fstpp(t2))).
intro HF.
apply Pos.eqb_eq in HF.
case_eq (Pos.eqb (sndpp(t1)) (sndpp(t2))).
intro HS.
apply Pos.eqb_eq in HS.
unfold CompSpec.
assert (HC : compare t1 t2 = Eq).
unfold compare.
assert (HCF : Pos.compare (fstpp(t1)) (fstpp(t2)) = Eq).
assert (HCS : Pos.compare (sndpp(t1)) (sndpp(t2)) = Eq).

*****
HCS : Logic.eq (Pos.compare (sndpp t1) (sndpp t2)) Eq
HCF : Logic.eq (Pos.compare (fstpp t1) (fstpp t2)) Eq
HS : Logic.eq (sndpp t1) (sndpp t2)
HF : Logic.eq (fstpp t1) (fstpp t2)
t1,t2 : True
*****
Logic.eq match Pos.compare (fstpp t1) (fstpp t2) with | Eq => Pos.compare (sndpp t1) (sndpp t2) | Lt => Lt | Gt => Gt end Eq
+++++
rewrite HCF.
-----
Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).
Proof.
intros t1 t2.
case_eq (Pos.eqb (fstpp(t1)) (fstpp(t2))).
intro HF.
apply Pos.eqb_eq in HF.
case_eq (Pos.eqb (sndpp(t1)) (sndpp(t2))).
intro HS.
apply Pos.eqb_eq in HS.
unfold CompSpec.
assert (HC : compare t1 t2 = Eq).
unfold compare.
assert (HCF : Pos.compare (fstpp(t1)) (fstpp(t2)) = Eq).
assert (HCS : Pos.compare (sndpp(t1)) (sndpp(t2)) = Eq).
rewrite HCF.

*****
HCS : Logic.eq (Pos.compare (sndpp t1) (sndpp t2)) Eq
HCF : Logic.eq (Pos.compare (fstpp t1) (fstpp t2)) Eq
HS : Logic.eq (sndpp t1) (sndpp t2)
HF : Logic.eq (fstpp t1) (fstpp t2)
t1,t2 : True
*****
Logic.eq (Pos.compare (sndpp t1) (sndpp t2)) Eq
+++++
rewrite HCS.
-----
Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).
Proof.
intros t1 t2.
case_eq (Pos.eqb (fstpp(t1)) (fstpp(t2))).
intro HF.
apply Pos.eqb_eq in HF.
case_eq (Pos.eqb (sndpp(t1)) (sndpp(t2))).
intro HS.
apply Pos.eqb_eq in HS.
unfold CompSpec.
assert (HC : compare t1 t2 = Eq).
unfold compare.
assert (HCF : Pos.compare (fstpp(t1)) (fstpp(t2)) = Eq).
assert (HCS : Pos.compare (sndpp(t1)) (sndpp(t2)) = Eq).
rewrite HCF.
rewrite HCS.

*****
HCS : Logic.eq (Pos.compare (sndpp t1) (sndpp t2)) Eq
HCF : Logic.eq (Pos.compare (fstpp t1) (fstpp t2)) Eq
HS : Logic.eq (sndpp t1) (sndpp t2)
HF : Logic.eq (fstpp t1) (fstpp t2)
t1,t2 : True
*****
Logic.eq Eq Eq
+++++
intuition.
-----
Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).
Proof.
intros t1 t2.
case_eq (Pos.eqb (fstpp(t1)) (fstpp(t2))).
intro HF.
apply Pos.eqb_eq in HF.
case_eq (Pos.eqb (sndpp(t1)) (sndpp(t2))).
intro HS.
apply Pos.eqb_eq in HS.
unfold CompSpec.
assert (HC : compare t1 t2 = Eq).

*****
HC : Logic.eq (compare t1 t2) Eq
HS : Logic.eq (sndpp t1) (sndpp t2)
HF : Logic.eq (fstpp t1) (fstpp t2)
t1,t2 : True
*****
CompareSpec (eq t1 t2) (lt t1 t2) (lt t2 t1) (compare t1 t2)
+++++
rewrite HC.
-----
Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).
Proof.
intros t1 t2.
case_eq (Pos.eqb (fstpp(t1)) (fstpp(t2))).
intro HF.
apply Pos.eqb_eq in HF.
case_eq (Pos.eqb (sndpp(t1)) (sndpp(t2))).
intro HS.
apply Pos.eqb_eq in HS.
unfold CompSpec.
assert (HC : compare t1 t2 = Eq).
rewrite HC.

*****
HC : Logic.eq (compare t1 t2) Eq
HS : Logic.eq (sndpp t1) (sndpp t2)
HF : Logic.eq (fstpp t1) (fstpp t2)
t1,t2 : True
*****
CompareSpec (eq t1 t2) (lt t1 t2) (lt t2 t1) Eq
+++++
apply CompEq.
-----
Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).
Proof.
intros t1 t2.
case_eq (Pos.eqb (fstpp(t1)) (fstpp(t2))).
intro HF.
apply Pos.eqb_eq in HF.
case_eq (Pos.eqb (sndpp(t1)) (sndpp(t2))).
intro HS.
apply Pos.eqb_eq in HS.
unfold CompSpec.
assert (HC : compare t1 t2 = Eq).
rewrite HC.
apply CompEq.

*****
HC : Logic.eq (compare t1 t2) Eq
HS : Logic.eq (sndpp t1) (sndpp t2)
HF : Logic.eq (fstpp t1) (fstpp t2)
t1,t2 : True
*****
eq t1 t2
+++++
unfold eq.
-----
Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).
Proof.
intros t1 t2.
case_eq (Pos.eqb (fstpp(t1)) (fstpp(t2))).
intro HF.
apply Pos.eqb_eq in HF.
case_eq (Pos.eqb (sndpp(t1)) (sndpp(t2))).
intro HS.
apply Pos.eqb_eq in HS.
unfold CompSpec.
assert (HC : compare t1 t2 = Eq).
rewrite HC.
apply CompEq.
unfold eq.

*****
HC : Logic.eq (compare t1 t2) Eq
HS : Logic.eq (sndpp t1) (sndpp t2)
HF : Logic.eq (fstpp t1) (fstpp t2)
t1,t2 : True
*****
and (Pos.eq (fstpp t1) (fstpp t2)) (Pos.eq (sndpp t1) (sndpp t2))
+++++
rewrite HF.
-----
Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).
Proof.
intros t1 t2.
case_eq (Pos.eqb (fstpp(t1)) (fstpp(t2))).
intro HF.
apply Pos.eqb_eq in HF.
case_eq (Pos.eqb (sndpp(t1)) (sndpp(t2))).
intro HS.
apply Pos.eqb_eq in HS.
unfold CompSpec.
assert (HC : compare t1 t2 = Eq).
rewrite HC.
apply CompEq.
unfold eq.
rewrite HF.

*****
HC : Logic.eq (compare t1 t2) Eq
HS : Logic.eq (sndpp t1) (sndpp t2)
HF : Logic.eq (fstpp t1) (fstpp t2)
t1,t2 : True
*****
and (Pos.eq (fstpp t2) (fstpp t2)) (Pos.eq (sndpp t1) (sndpp t2))
+++++
rewrite HS.
-----
Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).
Proof.
intros t1 t2.
case_eq (Pos.eqb (fstpp(t1)) (fstpp(t2))).
intro HF.
apply Pos.eqb_eq in HF.
case_eq (Pos.eqb (sndpp(t1)) (sndpp(t2))).
intro HS.
apply Pos.eqb_eq in HS.
unfold CompSpec.
assert (HC : compare t1 t2 = Eq).
rewrite HC.
apply CompEq.
unfold eq.
rewrite HF.
rewrite HS.

*****
HC : Logic.eq (compare t1 t2) Eq
HS : Logic.eq (sndpp t1) (sndpp t2)
HF : Logic.eq (fstpp t1) (fstpp t2)
t1,t2 : True
*****
and (Pos.eq (fstpp t2) (fstpp t2)) (Pos.eq (sndpp t2) (sndpp t2))
+++++
split.
-----
Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).
Proof.
intros t1 t2.
case_eq (Pos.eqb (fstpp(t1)) (fstpp(t2))).
intro HF.
apply Pos.eqb_eq in HF.
case_eq (Pos.eqb (sndpp(t1)) (sndpp(t2))).
intro HS.
apply Pos.eqb_eq in HS.
unfold CompSpec.
assert (HC : compare t1 t2 = Eq).
rewrite HC.
apply CompEq.
unfold eq.
rewrite HF.
rewrite HS.
split.

*****
HC : Logic.eq (compare t1 t2) Eq
HS : Logic.eq (sndpp t1) (sndpp t2)
HF : Logic.eq (fstpp t1) (fstpp t2)
t1,t2 : True
*****
Pos.eq (fstpp t2) (fstpp t2)
+++++
intuition.
-----
Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).
Proof.
intros t1 t2.
case_eq (Pos.eqb (fstpp(t1)) (fstpp(t2))).
intro HF.
apply Pos.eqb_eq in HF.
case_eq (Pos.eqb (sndpp(t1)) (sndpp(t2))).
intro HS.
apply Pos.eqb_eq in HS.
unfold CompSpec.
assert (HC : compare t1 t2 = Eq).
rewrite HC.
apply CompEq.
unfold eq.
rewrite HF.
rewrite HS.
split.

*****
HC : Logic.eq (compare t1 t2) Eq
HS : Logic.eq (sndpp t1) (sndpp t2)
HF : Logic.eq (fstpp t1) (fstpp t2)
t1,t2 : True
*****
Pos.eq (sndpp t2) (sndpp t2)
+++++
intuition.
-----
Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).
Proof.
intros t1 t2.
case_eq (Pos.eqb (fstpp(t1)) (fstpp(t2))).
intro HF.
apply Pos.eqb_eq in HF.
case_eq (Pos.eqb (sndpp(t1)) (sndpp(t2))).

*****
HF : Logic.eq (fstpp t1) (fstpp t2)
t1,t2 : True
*****
forall _ : Logic.eq (Pos.eqb (sndpp t1) (sndpp t2)) false, CompSpec eq lt t1 t2 (compare t1 t2)
+++++
intro HS.
-----
Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).
Proof.
intros t1 t2.
case_eq (Pos.eqb (fstpp(t1)) (fstpp(t2))).
intro HF.
apply Pos.eqb_eq in HF.
case_eq (Pos.eqb (sndpp(t1)) (sndpp(t2))).
intro HS.

*****
HS : Logic.eq (Pos.eqb (sndpp t1) (sndpp t2)) false
HF : Logic.eq (fstpp t1) (fstpp t2)
t1,t2 : True
*****
CompSpec eq lt t1 t2 (compare t1 t2)
+++++
case_eq (Pos.ltb (sndpp(t1)) (sndpp(t2))).
-----
Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).
Proof.
intros t1 t2.
case_eq (Pos.eqb (fstpp(t1)) (fstpp(t2))).
intro HF.
apply Pos.eqb_eq in HF.
case_eq (Pos.eqb (sndpp(t1)) (sndpp(t2))).
intro HS.
case_eq (Pos.ltb (sndpp(t1)) (sndpp(t2))).

*****
HS : Logic.eq (Pos.eqb (sndpp t1) (sndpp t2)) false
HF : Logic.eq (fstpp t1) (fstpp t2)
t1,t2 : True
*****
forall _ : Logic.eq (Pos.ltb (sndpp t1) (sndpp t2)) true, CompSpec eq lt t1 t2 (compare t1 t2)
+++++
intro HLS.
-----
Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).
Proof.
intros t1 t2.
case_eq (Pos.eqb (fstpp(t1)) (fstpp(t2))).
intro HF.
apply Pos.eqb_eq in HF.
case_eq (Pos.eqb (sndpp(t1)) (sndpp(t2))).
intro HS.
case_eq (Pos.ltb (sndpp(t1)) (sndpp(t2))).
intro HLS.

*****
HLS : Logic.eq (Pos.ltb (sndpp t1) (sndpp t2)) true
HS : Logic.eq (Pos.eqb (sndpp t1) (sndpp t2)) false
HF : Logic.eq (fstpp t1) (fstpp t2)
t1,t2 : True
*****
CompSpec eq lt t1 t2 (compare t1 t2)
+++++
assert (HC : compare t1 t2 = Lt).
-----
Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).
Proof.
intros t1 t2.
case_eq (Pos.eqb (fstpp(t1)) (fstpp(t2))).
intro HF.
apply Pos.eqb_eq in HF.
case_eq (Pos.eqb (sndpp(t1)) (sndpp(t2))).
intro HS.
case_eq (Pos.ltb (sndpp(t1)) (sndpp(t2))).
intro HLS.
assert (HC : compare t1 t2 = Lt).

*****
HLS : Logic.eq (Pos.ltb (sndpp t1) (sndpp t2)) true
HS : Logic.eq (Pos.eqb (sndpp t1) (sndpp t2)) false
HF : Logic.eq (fstpp t1) (fstpp t2)
t1,t2 : True
*****
Logic.eq (compare t1 t2) Lt
+++++
unfold compare.
-----
Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).
Proof.
intros t1 t2.
case_eq (Pos.eqb (fstpp(t1)) (fstpp(t2))).
intro HF.
apply Pos.eqb_eq in HF.
case_eq (Pos.eqb (sndpp(t1)) (sndpp(t2))).
intro HS.
case_eq (Pos.ltb (sndpp(t1)) (sndpp(t2))).
intro HLS.
assert (HC : compare t1 t2 = Lt).
unfold compare.

*****
HLS : Logic.eq (Pos.ltb (sndpp t1) (sndpp t2)) true
HS : Logic.eq (Pos.eqb (sndpp t1) (sndpp t2)) false
HF : Logic.eq (fstpp t1) (fstpp t2)
t1,t2 : True
*****
Logic.eq match Pos.compare (fstpp t1) (fstpp t2) with | Eq => Pos.compare (sndpp t1) (sndpp t2) | Lt => Lt | Gt => Gt end Lt
+++++
assert (HCF : Pos.compare (fstpp(t1)) (fstpp(t2)) = Eq).
-----
Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).
Proof.
intros t1 t2.
case_eq (Pos.eqb (fstpp(t1)) (fstpp(t2))).
intro HF.
apply Pos.eqb_eq in HF.
case_eq (Pos.eqb (sndpp(t1)) (sndpp(t2))).
intro HS.
case_eq (Pos.ltb (sndpp(t1)) (sndpp(t2))).
intro HLS.
assert (HC : compare t1 t2 = Lt).
unfold compare.
assert (HCF : Pos.compare (fstpp(t1)) (fstpp(t2)) = Eq).

*****
HLS : Logic.eq (Pos.ltb (sndpp t1) (sndpp t2)) true
HS : Logic.eq (Pos.eqb (sndpp t1) (sndpp t2)) false
HF : Logic.eq (fstpp t1) (fstpp t2)
t1,t2 : True
*****
Logic.eq (Pos.compare (fstpp t1) (fstpp t2)) Eq
+++++
unfold Pos.compare.
-----
Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).
Proof.
intros t1 t2.
case_eq (Pos.eqb (fstpp(t1)) (fstpp(t2))).
intro HF.
apply Pos.eqb_eq in HF.
case_eq (Pos.eqb (sndpp(t1)) (sndpp(t2))).
intro HS.
case_eq (Pos.ltb (sndpp(t1)) (sndpp(t2))).
intro HLS.
assert (HC : compare t1 t2 = Lt).
unfold compare.
assert (HCF : Pos.compare (fstpp(t1)) (fstpp(t2)) = Eq).
unfold Pos.compare.

*****
HLS : Logic.eq (Pos.ltb (sndpp t1) (sndpp t2)) true
HS : Logic.eq (Pos.eqb (sndpp t1) (sndpp t2)) false
HF : Logic.eq (fstpp t1) (fstpp t2)
t1,t2 : True
*****
Logic.eq (Pos.compare_cont Eq (fstpp t1) (fstpp t2)) Eq
+++++
rewrite HF.
-----
Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).
Proof.
intros t1 t2.
case_eq (Pos.eqb (fstpp(t1)) (fstpp(t2))).
intro HF.
apply Pos.eqb_eq in HF.
case_eq (Pos.eqb (sndpp(t1)) (sndpp(t2))).
intro HS.
case_eq (Pos.ltb (sndpp(t1)) (sndpp(t2))).
intro HLS.
assert (HC : compare t1 t2 = Lt).
unfold compare.
assert (HCF : Pos.compare (fstpp(t1)) (fstpp(t2)) = Eq).
unfold Pos.compare.
rewrite HF.

*****
HLS : Logic.eq (Pos.ltb (sndpp t1) (sndpp t2)) true
HS : Logic.eq (Pos.eqb (sndpp t1) (sndpp t2)) false
HF : Logic.eq (fstpp t1) (fstpp t2)
t1,t2 : True
*****
Logic.eq (Pos.compare_cont Eq (fstpp t2) (fstpp t2)) Eq
+++++
apply Pos.compare_cont_refl.
-----
Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).
Proof.
intros t1 t2.
case_eq (Pos.eqb (fstpp(t1)) (fstpp(t2))).
intro HF.
apply Pos.eqb_eq in HF.
case_eq (Pos.eqb (sndpp(t1)) (sndpp(t2))).
intro HS.
case_eq (Pos.ltb (sndpp(t1)) (sndpp(t2))).
intro HLS.
assert (HC : compare t1 t2 = Lt).
unfold compare.
assert (HCF : Pos.compare (fstpp(t1)) (fstpp(t2)) = Eq).

*****
HCF : Logic.eq (Pos.compare (fstpp t1) (fstpp t2)) Eq
HLS : Logic.eq (Pos.ltb (sndpp t1) (sndpp t2)) true
HS : Logic.eq (Pos.eqb (sndpp t1) (sndpp t2)) false
HF : Logic.eq (fstpp t1) (fstpp t2)
t1,t2 : True
*****
Logic.eq match Pos.compare (fstpp t1) (fstpp t2) with | Eq => Pos.compare (sndpp t1) (sndpp t2) | Lt => Lt | Gt => Gt end Lt
+++++
assert (HCS : Pos.compare (sndpp(t1)) (sndpp(t2)) = Lt).
-----
Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).
Proof.
intros t1 t2.
case_eq (Pos.eqb (fstpp(t1)) (fstpp(t2))).
intro HF.
apply Pos.eqb_eq in HF.
case_eq (Pos.eqb (sndpp(t1)) (sndpp(t2))).
intro HS.
case_eq (Pos.ltb (sndpp(t1)) (sndpp(t2))).
intro HLS.
assert (HC : compare t1 t2 = Lt).
unfold compare.
assert (HCF : Pos.compare (fstpp(t1)) (fstpp(t2)) = Eq).
assert (HCS : Pos.compare (sndpp(t1)) (sndpp(t2)) = Lt).

*****
HCF : Logic.eq (Pos.compare (fstpp t1) (fstpp t2)) Eq
HLS : Logic.eq (Pos.ltb (sndpp t1) (sndpp t2)) true
HS : Logic.eq (Pos.eqb (sndpp t1) (sndpp t2)) false
HF : Logic.eq (fstpp t1) (fstpp t2)
t1,t2 : True
*****
Logic.eq (Pos.compare (sndpp t1) (sndpp t2)) Lt
+++++
unfold Pos.compare.
-----
Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).
Proof.
intros t1 t2.
case_eq (Pos.eqb (fstpp(t1)) (fstpp(t2))).
intro HF.
apply Pos.eqb_eq in HF.
case_eq (Pos.eqb (sndpp(t1)) (sndpp(t2))).
intro HS.
case_eq (Pos.ltb (sndpp(t1)) (sndpp(t2))).
intro HLS.
assert (HC : compare t1 t2 = Lt).
unfold compare.
assert (HCF : Pos.compare (fstpp(t1)) (fstpp(t2)) = Eq).
assert (HCS : Pos.compare (sndpp(t1)) (sndpp(t2)) = Lt).
unfold Pos.compare.

*****
HCF : Logic.eq (Pos.compare (fstpp t1) (fstpp t2)) Eq
HLS : Logic.eq (Pos.ltb (sndpp t1) (sndpp t2)) true
HS : Logic.eq (Pos.eqb (sndpp t1) (sndpp t2)) false
HF : Logic.eq (fstpp t1) (fstpp t2)
t1,t2 : True
*****
Logic.eq (Pos.compare_cont Eq (sndpp t1) (sndpp t2)) Lt
+++++
apply Pos.ltb_lt in HLS.
-----
Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).
Proof.
intros t1 t2.
case_eq (Pos.eqb (fstpp(t1)) (fstpp(t2))).
intro HF.
apply Pos.eqb_eq in HF.
case_eq (Pos.eqb (sndpp(t1)) (sndpp(t2))).
intro HS.
case_eq (Pos.ltb (sndpp(t1)) (sndpp(t2))).
intro HLS.
assert (HC : compare t1 t2 = Lt).
unfold compare.
assert (HCF : Pos.compare (fstpp(t1)) (fstpp(t2)) = Eq).
assert (HCS : Pos.compare (sndpp(t1)) (sndpp(t2)) = Lt).
unfold Pos.compare.
apply Pos.ltb_lt in HLS.

*****
HCF : Logic.eq (Pos.compare (fstpp t1) (fstpp t2)) Eq
HLS : Pos.lt (sndpp t1) (sndpp t2)
HS : Logic.eq (Pos.eqb (sndpp t1) (sndpp t2)) false
HF : Logic.eq (fstpp t1) (fstpp t2)
t1,t2 : True
*****
Logic.eq (Pos.compare_cont Eq (sndpp t1) (sndpp t2)) Lt
+++++
apply Pnat.nat_of_P_lt_Lt_compare_complement_morphism.
-----
Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).
Proof.
intros t1 t2.
case_eq (Pos.eqb (fstpp(t1)) (fstpp(t2))).
intro HF.
apply Pos.eqb_eq in HF.
case_eq (Pos.eqb (sndpp(t1)) (sndpp(t2))).
intro HS.
case_eq (Pos.ltb (sndpp(t1)) (sndpp(t2))).
intro HLS.
assert (HC : compare t1 t2 = Lt).
unfold compare.
assert (HCF : Pos.compare (fstpp(t1)) (fstpp(t2)) = Eq).
assert (HCS : Pos.compare (sndpp(t1)) (sndpp(t2)) = Lt).
unfold Pos.compare.
apply Pos.ltb_lt in HLS.
apply Pnat.nat_of_P_lt_Lt_compare_complement_morphism.

*****
HCF : Logic.eq (Pos.compare (fstpp t1) (fstpp t2)) Eq
HLS : Pos.lt (sndpp t1) (sndpp t2)
HS : Logic.eq (Pos.eqb (sndpp t1) (sndpp t2)) false
HF : Logic.eq (fstpp t1) (fstpp t2)
t1,t2 : True
*****
Peano.lt (Pos.to_nat (sndpp t1)) (Pos.to_nat (sndpp t2))
+++++
apply Pnat.Pos2Nat.inj_lt.
-----
Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).
Proof.
intros t1 t2.
case_eq (Pos.eqb (fstpp(t1)) (fstpp(t2))).
intro HF.
apply Pos.eqb_eq in HF.
case_eq (Pos.eqb (sndpp(t1)) (sndpp(t2))).
intro HS.
case_eq (Pos.ltb (sndpp(t1)) (sndpp(t2))).
intro HLS.
assert (HC : compare t1 t2 = Lt).
unfold compare.
assert (HCF : Pos.compare (fstpp(t1)) (fstpp(t2)) = Eq).
assert (HCS : Pos.compare (sndpp(t1)) (sndpp(t2)) = Lt).
unfold Pos.compare.
apply Pos.ltb_lt in HLS.
apply Pnat.nat_of_P_lt_Lt_compare_complement_morphism.
apply Pnat.Pos2Nat.inj_lt.

*****
HCF : Logic.eq (Pos.compare (fstpp t1) (fstpp t2)) Eq
HLS : Pos.lt (sndpp t1) (sndpp t2)
HS : Logic.eq (Pos.eqb (sndpp t1) (sndpp t2)) false
HF : Logic.eq (fstpp t1) (fstpp t2)
t1,t2 : True
*****
Pos.lt (sndpp t1) (sndpp t2)
+++++
assumption.
-----
Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).
Proof.
intros t1 t2.
case_eq (Pos.eqb (fstpp(t1)) (fstpp(t2))).
intro HF.
apply Pos.eqb_eq in HF.
case_eq (Pos.eqb (sndpp(t1)) (sndpp(t2))).
intro HS.
case_eq (Pos.ltb (sndpp(t1)) (sndpp(t2))).
intro HLS.
assert (HC : compare t1 t2 = Lt).
unfold compare.
assert (HCF : Pos.compare (fstpp(t1)) (fstpp(t2)) = Eq).
assert (HCS : Pos.compare (sndpp(t1)) (sndpp(t2)) = Lt).

*****
HCS : Logic.eq (Pos.compare (sndpp t1) (sndpp t2)) Lt
HCF : Logic.eq (Pos.compare (fstpp t1) (fstpp t2)) Eq
HLS : Logic.eq (Pos.ltb (sndpp t1) (sndpp t2)) true
HS : Logic.eq (Pos.eqb (sndpp t1) (sndpp t2)) false
HF : Logic.eq (fstpp t1) (fstpp t2)
t1,t2 : True
*****
Logic.eq match Pos.compare (fstpp t1) (fstpp t2) with | Eq => Pos.compare (sndpp t1) (sndpp t2) | Lt => Lt | Gt => Gt end Lt
+++++
rewrite HCF.
-----
Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).
Proof.
intros t1 t2.
case_eq (Pos.eqb (fstpp(t1)) (fstpp(t2))).
intro HF.
apply Pos.eqb_eq in HF.
case_eq (Pos.eqb (sndpp(t1)) (sndpp(t2))).
intro HS.
case_eq (Pos.ltb (sndpp(t1)) (sndpp(t2))).
intro HLS.
assert (HC : compare t1 t2 = Lt).
unfold compare.
assert (HCF : Pos.compare (fstpp(t1)) (fstpp(t2)) = Eq).
assert (HCS : Pos.compare (sndpp(t1)) (sndpp(t2)) = Lt).
rewrite HCF.

*****
HCS : Logic.eq (Pos.compare (sndpp t1) (sndpp t2)) Lt
HCF : Logic.eq (Pos.compare (fstpp t1) (fstpp t2)) Eq
HLS : Logic.eq (Pos.ltb (sndpp t1) (sndpp t2)) true
HS : Logic.eq (Pos.eqb (sndpp t1) (sndpp t2)) false
HF : Logic.eq (fstpp t1) (fstpp t2)
t1,t2 : True
*****
Logic.eq (Pos.compare (sndpp t1) (sndpp t2)) Lt
+++++
rewrite HCS.
-----
Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).
Proof.
intros t1 t2.
case_eq (Pos.eqb (fstpp(t1)) (fstpp(t2))).
intro HF.
apply Pos.eqb_eq in HF.
case_eq (Pos.eqb (sndpp(t1)) (sndpp(t2))).
intro HS.
case_eq (Pos.ltb (sndpp(t1)) (sndpp(t2))).
intro HLS.
assert (HC : compare t1 t2 = Lt).
unfold compare.
assert (HCF : Pos.compare (fstpp(t1)) (fstpp(t2)) = Eq).
assert (HCS : Pos.compare (sndpp(t1)) (sndpp(t2)) = Lt).
rewrite HCF.
rewrite HCS.

*****
HCS : Logic.eq (Pos.compare (sndpp t1) (sndpp t2)) Lt
HCF : Logic.eq (Pos.compare (fstpp t1) (fstpp t2)) Eq
HLS : Logic.eq (Pos.ltb (sndpp t1) (sndpp t2)) true
HS : Logic.eq (Pos.eqb (sndpp t1) (sndpp t2)) false
HF : Logic.eq (fstpp t1) (fstpp t2)
t1,t2 : True
*****
Logic.eq Lt Lt
+++++
intuition.
-----
Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).
Proof.
intros t1 t2.
case_eq (Pos.eqb (fstpp(t1)) (fstpp(t2))).
intro HF.
apply Pos.eqb_eq in HF.
case_eq (Pos.eqb (sndpp(t1)) (sndpp(t2))).
intro HS.
case_eq (Pos.ltb (sndpp(t1)) (sndpp(t2))).
intro HLS.
assert (HC : compare t1 t2 = Lt).

*****
HC : Logic.eq (compare t1 t2) Lt
HLS : Logic.eq (Pos.ltb (sndpp t1) (sndpp t2)) true
HS : Logic.eq (Pos.eqb (sndpp t1) (sndpp t2)) false
HF : Logic.eq (fstpp t1) (fstpp t2)
t1,t2 : True
*****
CompSpec eq lt t1 t2 (compare t1 t2)
+++++
rewrite HC.
-----
Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).
Proof.
intros t1 t2.
case_eq (Pos.eqb (fstpp(t1)) (fstpp(t2))).
intro HF.
apply Pos.eqb_eq in HF.
case_eq (Pos.eqb (sndpp(t1)) (sndpp(t2))).
intro HS.
case_eq (Pos.ltb (sndpp(t1)) (sndpp(t2))).
intro HLS.
assert (HC : compare t1 t2 = Lt).
rewrite HC.

*****
HC : Logic.eq (compare t1 t2) Lt
HLS : Logic.eq (Pos.ltb (sndpp t1) (sndpp t2)) true
HS : Logic.eq (Pos.eqb (sndpp t1) (sndpp t2)) false
HF : Logic.eq (fstpp t1) (fstpp t2)
t1,t2 : True
*****
CompSpec eq lt t1 t2 Lt
+++++
apply CompLt.
-----
Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).
Proof.
intros t1 t2.
case_eq (Pos.eqb (fstpp(t1)) (fstpp(t2))).
intro HF.
apply Pos.eqb_eq in HF.
case_eq (Pos.eqb (sndpp(t1)) (sndpp(t2))).
intro HS.
case_eq (Pos.ltb (sndpp(t1)) (sndpp(t2))).
intro HLS.
assert (HC : compare t1 t2 = Lt).
rewrite HC.
apply CompLt.

*****
HC : Logic.eq (compare t1 t2) Lt
HLS : Logic.eq (Pos.ltb (sndpp t1) (sndpp t2)) true
HS : Logic.eq (Pos.eqb (sndpp t1) (sndpp t2)) false
HF : Logic.eq (fstpp t1) (fstpp t2)
t1,t2 : True
*****
lt t1 t2
+++++
unfold lt.
-----
Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).
Proof.
intros t1 t2.
case_eq (Pos.eqb (fstpp(t1)) (fstpp(t2))).
intro HF.
apply Pos.eqb_eq in HF.
case_eq (Pos.eqb (sndpp(t1)) (sndpp(t2))).
intro HS.
case_eq (Pos.ltb (sndpp(t1)) (sndpp(t2))).
intro HLS.
assert (HC : compare t1 t2 = Lt).
rewrite HC.
apply CompLt.
unfold lt.

*****
HC : Logic.eq (compare t1 t2) Lt
HLS : Logic.eq (Pos.ltb (sndpp t1) (sndpp t2)) true
HS : Logic.eq (Pos.eqb (sndpp t1) (sndpp t2)) false
HF : Logic.eq (fstpp t1) (fstpp t2)
t1,t2 : True
*****
if Pos.eqb (fstpp t1) (fstpp t2) then Pos.lt (sndpp t1) (sndpp t2) else Pos.lt (fstpp t1) (fstpp t2)
+++++
apply Pos.eqb_eq in HF.
-----
Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).
Proof.
intros t1 t2.
case_eq (Pos.eqb (fstpp(t1)) (fstpp(t2))).
intro HF.
apply Pos.eqb_eq in HF.
case_eq (Pos.eqb (sndpp(t1)) (sndpp(t2))).
intro HS.
case_eq (Pos.ltb (sndpp(t1)) (sndpp(t2))).
intro HLS.
assert (HC : compare t1 t2 = Lt).
rewrite HC.
apply CompLt.
unfold lt.
apply Pos.eqb_eq in HF.

*****
HC : Logic.eq (compare t1 t2) Lt
HLS : Logic.eq (Pos.ltb (sndpp t1) (sndpp t2)) true
HS : Logic.eq (Pos.eqb (sndpp t1) (sndpp t2)) false
HF : Logic.eq (Pos.eqb (fstpp t1) (fstpp t2)) true
t1,t2 : True
*****
if Pos.eqb (fstpp t1) (fstpp t2) then Pos.lt (sndpp t1) (sndpp t2) else Pos.lt (fstpp t1) (fstpp t2)
+++++
rewrite HF.
-----
Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).
Proof.
intros t1 t2.
case_eq (Pos.eqb (fstpp(t1)) (fstpp(t2))).
intro HF.
apply Pos.eqb_eq in HF.
case_eq (Pos.eqb (sndpp(t1)) (sndpp(t2))).
intro HS.
case_eq (Pos.ltb (sndpp(t1)) (sndpp(t2))).
intro HLS.
assert (HC : compare t1 t2 = Lt).
rewrite HC.
apply CompLt.
unfold lt.
apply Pos.eqb_eq in HF.
rewrite HF.

*****
HC : Logic.eq (compare t1 t2) Lt
HLS : Logic.eq (Pos.ltb (sndpp t1) (sndpp t2)) true
HS : Logic.eq (Pos.eqb (sndpp t1) (sndpp t2)) false
HF : Logic.eq (Pos.eqb (fstpp t1) (fstpp t2)) true
t1,t2 : True
*****
Pos.lt (sndpp t1) (sndpp t2)
+++++
apply Pos.ltb_lt in HLS.
-----
Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).
Proof.
intros t1 t2.
case_eq (Pos.eqb (fstpp(t1)) (fstpp(t2))).
intro HF.
apply Pos.eqb_eq in HF.
case_eq (Pos.eqb (sndpp(t1)) (sndpp(t2))).
intro HS.
case_eq (Pos.ltb (sndpp(t1)) (sndpp(t2))).
intro HLS.
assert (HC : compare t1 t2 = Lt).
rewrite HC.
apply CompLt.
unfold lt.
apply Pos.eqb_eq in HF.
rewrite HF.
apply Pos.ltb_lt in HLS.

*****
HC : Logic.eq (compare t1 t2) Lt
HLS : Pos.lt (sndpp t1) (sndpp t2)
HS : Logic.eq (Pos.eqb (sndpp t1) (sndpp t2)) false
HF : Logic.eq (Pos.eqb (fstpp t1) (fstpp t2)) true
t1,t2 : True
*****
Pos.lt (sndpp t1) (sndpp t2)
+++++
assumption.
-----
Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).
Proof.
intros t1 t2.
case_eq (Pos.eqb (fstpp(t1)) (fstpp(t2))).
intro HF.
apply Pos.eqb_eq in HF.
case_eq (Pos.eqb (sndpp(t1)) (sndpp(t2))).
intro HS.
case_eq (Pos.ltb (sndpp(t1)) (sndpp(t2))).

*****
HS : Logic.eq (Pos.eqb (sndpp t1) (sndpp t2)) false
HF : Logic.eq (fstpp t1) (fstpp t2)
t1,t2 : True
*****
forall _ : Logic.eq (Pos.ltb (sndpp t1) (sndpp t2)) false, CompSpec eq lt t1 t2 (compare t1 t2)
+++++
intro HLS.
-----
Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).
Proof.
intros t1 t2.
case_eq (Pos.eqb (fstpp(t1)) (fstpp(t2))).
intro HF.
apply Pos.eqb_eq in HF.
case_eq (Pos.eqb (sndpp(t1)) (sndpp(t2))).
intro HS.
case_eq (Pos.ltb (sndpp(t1)) (sndpp(t2))).
intro HLS.

*****
HLS : Logic.eq (Pos.ltb (sndpp t1) (sndpp t2)) false
HS : Logic.eq (Pos.eqb (sndpp t1) (sndpp t2)) false
HF : Logic.eq (fstpp t1) (fstpp t2)
t1,t2 : True
*****
CompSpec eq lt t1 t2 (compare t1 t2)
+++++
assert (HLS2 : Pos.ltb (sndpp(t2)) (sndpp(t1)) = true).
-----
Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).
Proof.
intros t1 t2.
case_eq (Pos.eqb (fstpp(t1)) (fstpp(t2))).
intro HF.
apply Pos.eqb_eq in HF.
case_eq (Pos.eqb (sndpp(t1)) (sndpp(t2))).
intro HS.
case_eq (Pos.ltb (sndpp(t1)) (sndpp(t2))).
intro HLS.
assert (HLS2 : Pos.ltb (sndpp(t2)) (sndpp(t1)) = true).

*****
HLS : Logic.eq (Pos.ltb (sndpp t1) (sndpp t2)) false
HS : Logic.eq (Pos.eqb (sndpp t1) (sndpp t2)) false
HF : Logic.eq (fstpp t1) (fstpp t2)
t1,t2 : True
*****
Logic.eq (Pos.ltb (sndpp t2) (sndpp t1)) true
+++++
apply Pos.ltb_nlt in HLS.
-----
Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).
Proof.
intros t1 t2.
case_eq (Pos.eqb (fstpp(t1)) (fstpp(t2))).
intro HF.
apply Pos.eqb_eq in HF.
case_eq (Pos.eqb (sndpp(t1)) (sndpp(t2))).
intro HS.
case_eq (Pos.ltb (sndpp(t1)) (sndpp(t2))).
intro HLS.
assert (HLS2 : Pos.ltb (sndpp(t2)) (sndpp(t1)) = true).
apply Pos.ltb_nlt in HLS.

*****
HLS : not (Pos.lt (sndpp t1) (sndpp t2))
HS : Logic.eq (Pos.eqb (sndpp t1) (sndpp t2)) false
HF : Logic.eq (fstpp t1) (fstpp t2)
t1,t2 : True
*****
Logic.eq (Pos.ltb (sndpp t2) (sndpp t1)) true
+++++
apply Pos.le_nlt in HLS.
-----
Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).
Proof.
intros t1 t2.
case_eq (Pos.eqb (fstpp(t1)) (fstpp(t2))).
intro HF.
apply Pos.eqb_eq in HF.
case_eq (Pos.eqb (sndpp(t1)) (sndpp(t2))).
intro HS.
case_eq (Pos.ltb (sndpp(t1)) (sndpp(t2))).
intro HLS.
assert (HLS2 : Pos.ltb (sndpp(t2)) (sndpp(t1)) = true).
apply Pos.ltb_nlt in HLS.
apply Pos.le_nlt in HLS.

*****
HLS : Pos.le (sndpp t2) (sndpp t1)
HS : Logic.eq (Pos.eqb (sndpp t1) (sndpp t2)) false
HF : Logic.eq (fstpp t1) (fstpp t2)
t1,t2 : True
*****
Logic.eq (Pos.ltb (sndpp t2) (sndpp t1)) true
+++++
apply Pos.lt_eq_cases in HLS.
-----
Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).
Proof.
intros t1 t2.
case_eq (Pos.eqb (fstpp(t1)) (fstpp(t2))).
intro HF.
apply Pos.eqb_eq in HF.
case_eq (Pos.eqb (sndpp(t1)) (sndpp(t2))).
intro HS.
case_eq (Pos.ltb (sndpp(t1)) (sndpp(t2))).
intro HLS.
assert (HLS2 : Pos.ltb (sndpp(t2)) (sndpp(t1)) = true).
apply Pos.ltb_nlt in HLS.
apply Pos.le_nlt in HLS.
apply Pos.lt_eq_cases in HLS.

*****
HLS : or (Pos.lt (sndpp t2) (sndpp t1)) (Logic.eq (sndpp t2) (sndpp t1))
HS : Logic.eq (Pos.eqb (sndpp t1) (sndpp t2)) false
HF : Logic.eq (fstpp t1) (fstpp t2)
t1,t2 : True
*****
Logic.eq (Pos.ltb (sndpp t2) (sndpp t1)) true
+++++
elim HLS.
-----
Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).
Proof.
intros t1 t2.
case_eq (Pos.eqb (fstpp(t1)) (fstpp(t2))).
intro HF.
apply Pos.eqb_eq in HF.
case_eq (Pos.eqb (sndpp(t1)) (sndpp(t2))).
intro HS.
case_eq (Pos.ltb (sndpp(t1)) (sndpp(t2))).
intro HLS.
assert (HLS2 : Pos.ltb (sndpp(t2)) (sndpp(t1)) = true).
apply Pos.ltb_nlt in HLS.
apply Pos.le_nlt in HLS.
apply Pos.lt_eq_cases in HLS.
elim HLS.

*****
HLS : or (Pos.lt (sndpp t2) (sndpp t1)) (Logic.eq (sndpp t2) (sndpp t1))
HS : Logic.eq (Pos.eqb (sndpp t1) (sndpp t2)) false
HF : Logic.eq (fstpp t1) (fstpp t2)
t1,t2 : True
*****
forall _ : Pos.lt (sndpp t2) (sndpp t1), Logic.eq (Pos.ltb (sndpp t2) (sndpp t1)) true
+++++
intro HLS2.
-----
Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).
Proof.
intros t1 t2.
case_eq (Pos.eqb (fstpp(t1)) (fstpp(t2))).
intro HF.
apply Pos.eqb_eq in HF.
case_eq (Pos.eqb (sndpp(t1)) (sndpp(t2))).
intro HS.
case_eq (Pos.ltb (sndpp(t1)) (sndpp(t2))).
intro HLS.
assert (HLS2 : Pos.ltb (sndpp(t2)) (sndpp(t1)) = true).
apply Pos.ltb_nlt in HLS.
apply Pos.le_nlt in HLS.
apply Pos.lt_eq_cases in HLS.
elim HLS.
intro HLS2.

*****
HLS2 : Pos.lt (sndpp t2) (sndpp t1)
HLS : or (Pos.lt (sndpp t2) (sndpp t1)) (Logic.eq (sndpp t2) (sndpp t1))
HS : Logic.eq (Pos.eqb (sndpp t1) (sndpp t2)) false
HF : Logic.eq (fstpp t1) (fstpp t2)
t1,t2 : True
*****
Logic.eq (Pos.ltb (sndpp t2) (sndpp t1)) true
+++++
apply Pos.ltb_lt.
-----
Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).
Proof.
intros t1 t2.
case_eq (Pos.eqb (fstpp(t1)) (fstpp(t2))).
intro HF.
apply Pos.eqb_eq in HF.
case_eq (Pos.eqb (sndpp(t1)) (sndpp(t2))).
intro HS.
case_eq (Pos.ltb (sndpp(t1)) (sndpp(t2))).
intro HLS.
assert (HLS2 : Pos.ltb (sndpp(t2)) (sndpp(t1)) = true).
apply Pos.ltb_nlt in HLS.
apply Pos.le_nlt in HLS.
apply Pos.lt_eq_cases in HLS.
elim HLS.
intro HLS2.
apply Pos.ltb_lt.

*****
HLS2 : Pos.lt (sndpp t2) (sndpp t1)
HLS : or (Pos.lt (sndpp t2) (sndpp t1)) (Logic.eq (sndpp t2) (sndpp t1))
HS : Logic.eq (Pos.eqb (sndpp t1) (sndpp t2)) false
HF : Logic.eq (fstpp t1) (fstpp t2)
t1,t2 : True
*****
Pos.lt (sndpp t2) (sndpp t1)
+++++
assumption.
-----
Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).
Proof.
intros t1 t2.
case_eq (Pos.eqb (fstpp(t1)) (fstpp(t2))).
intro HF.
apply Pos.eqb_eq in HF.
case_eq (Pos.eqb (sndpp(t1)) (sndpp(t2))).
intro HS.
case_eq (Pos.ltb (sndpp(t1)) (sndpp(t2))).
intro HLS.
assert (HLS2 : Pos.ltb (sndpp(t2)) (sndpp(t1)) = true).
apply Pos.ltb_nlt in HLS.
apply Pos.le_nlt in HLS.
apply Pos.lt_eq_cases in HLS.
elim HLS.

*****
HLS : or (Pos.lt (sndpp t2) (sndpp t1)) (Logic.eq (sndpp t2) (sndpp t1))
HS : Logic.eq (Pos.eqb (sndpp t1) (sndpp t2)) false
HF : Logic.eq (fstpp t1) (fstpp t2)
t1,t2 : True
*****
forall _ : Logic.eq (sndpp t2) (sndpp t1), Logic.eq (Pos.ltb (sndpp t2) (sndpp t1)) true
+++++
intro HLS2.
-----
Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).
Proof.
intros t1 t2.
case_eq (Pos.eqb (fstpp(t1)) (fstpp(t2))).
intro HF.
apply Pos.eqb_eq in HF.
case_eq (Pos.eqb (sndpp(t1)) (sndpp(t2))).
intro HS.
case_eq (Pos.ltb (sndpp(t1)) (sndpp(t2))).
intro HLS.
assert (HLS2 : Pos.ltb (sndpp(t2)) (sndpp(t1)) = true).
apply Pos.ltb_nlt in HLS.
apply Pos.le_nlt in HLS.
apply Pos.lt_eq_cases in HLS.
elim HLS.
intro HLS2.

*****
HLS2 : Logic.eq (sndpp t2) (sndpp t1)
HLS : or (Pos.lt (sndpp t2) (sndpp t1)) (Logic.eq (sndpp t2) (sndpp t1))
HS : Logic.eq (Pos.eqb (sndpp t1) (sndpp t2)) false
HF : Logic.eq (fstpp t1) (fstpp t2)
t1,t2 : True
*****
Logic.eq (Pos.ltb (sndpp t2) (sndpp t1)) true
+++++
apply Pos.eqb_neq in HS.
-----
Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).
Proof.
intros t1 t2.
case_eq (Pos.eqb (fstpp(t1)) (fstpp(t2))).
intro HF.
apply Pos.eqb_eq in HF.
case_eq (Pos.eqb (sndpp(t1)) (sndpp(t2))).
intro HS.
case_eq (Pos.ltb (sndpp(t1)) (sndpp(t2))).
intro HLS.
assert (HLS2 : Pos.ltb (sndpp(t2)) (sndpp(t1)) = true).
apply Pos.ltb_nlt in HLS.
apply Pos.le_nlt in HLS.
apply Pos.lt_eq_cases in HLS.
elim HLS.
intro HLS2.
apply Pos.eqb_neq in HS.

*****
HLS2 : Logic.eq (sndpp t2) (sndpp t1)
HLS : or (Pos.lt (sndpp t2) (sndpp t1)) (Logic.eq (sndpp t2) (sndpp t1))
HS : not (Logic.eq (sndpp t1) (sndpp t2))
HF : Logic.eq (fstpp t1) (fstpp t2)
t1,t2 : True
*****
Logic.eq (Pos.ltb (sndpp t2) (sndpp t1)) true
+++++
rewrite HLS2 in HS.
-----
Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).
Proof.
intros t1 t2.
case_eq (Pos.eqb (fstpp(t1)) (fstpp(t2))).
intro HF.
apply Pos.eqb_eq in HF.
case_eq (Pos.eqb (sndpp(t1)) (sndpp(t2))).
intro HS.
case_eq (Pos.ltb (sndpp(t1)) (sndpp(t2))).
intro HLS.
assert (HLS2 : Pos.ltb (sndpp(t2)) (sndpp(t1)) = true).
apply Pos.ltb_nlt in HLS.
apply Pos.le_nlt in HLS.
apply Pos.lt_eq_cases in HLS.
elim HLS.
intro HLS2.
apply Pos.eqb_neq in HS.
rewrite HLS2 in HS.

*****
HLS2 : Logic.eq (sndpp t2) (sndpp t1)
HLS : or (Pos.lt (sndpp t2) (sndpp t1)) (Logic.eq (sndpp t2) (sndpp t1))
HS : not (Logic.eq (sndpp t1) (sndpp t1))
HF : Logic.eq (fstpp t1) (fstpp t2)
t1,t2 : True
*****
Logic.eq (Pos.ltb (sndpp t2) (sndpp t1)) true
+++++
intuition.
-----
Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).
Proof.
intros t1 t2.
case_eq (Pos.eqb (fstpp(t1)) (fstpp(t2))).
intro HF.
apply Pos.eqb_eq in HF.
case_eq (Pos.eqb (sndpp(t1)) (sndpp(t2))).
intro HS.
case_eq (Pos.ltb (sndpp(t1)) (sndpp(t2))).
intro HLS.
assert (HLS2 : Pos.ltb (sndpp(t2)) (sndpp(t1)) = true).

*****
HLS2 : Logic.eq (Pos.ltb (sndpp t2) (sndpp t1)) true
HLS : Logic.eq (Pos.ltb (sndpp t1) (sndpp t2)) false
HS : Logic.eq (Pos.eqb (sndpp t1) (sndpp t2)) false
HF : Logic.eq (fstpp t1) (fstpp t2)
t1,t2 : True
*****
CompSpec eq lt t1 t2 (compare t1 t2)
+++++
assert (HC : compare t1 t2 = Gt).
-----
Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).
Proof.
intros t1 t2.
case_eq (Pos.eqb (fstpp(t1)) (fstpp(t2))).
intro HF.
apply Pos.eqb_eq in HF.
case_eq (Pos.eqb (sndpp(t1)) (sndpp(t2))).
intro HS.
case_eq (Pos.ltb (sndpp(t1)) (sndpp(t2))).
intro HLS.
assert (HLS2 : Pos.ltb (sndpp(t2)) (sndpp(t1)) = true).
assert (HC : compare t1 t2 = Gt).

*****
HLS2 : Logic.eq (Pos.ltb (sndpp t2) (sndpp t1)) true
HLS : Logic.eq (Pos.ltb (sndpp t1) (sndpp t2)) false
HS : Logic.eq (Pos.eqb (sndpp t1) (sndpp t2)) false
HF : Logic.eq (fstpp t1) (fstpp t2)
t1,t2 : True
*****
Logic.eq (compare t1 t2) Gt
+++++
unfold compare.
-----
Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).
Proof.
intros t1 t2.
case_eq (Pos.eqb (fstpp(t1)) (fstpp(t2))).
intro HF.
apply Pos.eqb_eq in HF.
case_eq (Pos.eqb (sndpp(t1)) (sndpp(t2))).
intro HS.
case_eq (Pos.ltb (sndpp(t1)) (sndpp(t2))).
intro HLS.
assert (HLS2 : Pos.ltb (sndpp(t2)) (sndpp(t1)) = true).
assert (HC : compare t1 t2 = Gt).
unfold compare.

*****
HLS2 : Logic.eq (Pos.ltb (sndpp t2) (sndpp t1)) true
HLS : Logic.eq (Pos.ltb (sndpp t1) (sndpp t2)) false
HS : Logic.eq (Pos.eqb (sndpp t1) (sndpp t2)) false
HF : Logic.eq (fstpp t1) (fstpp t2)
t1,t2 : True
*****
Logic.eq match Pos.compare (fstpp t1) (fstpp t2) with | Eq => Pos.compare (sndpp t1) (sndpp t2) | Lt => Lt | Gt => Gt end Gt
+++++
assert (HCF : Pos.compare (fstpp(t1)) (fstpp(t2)) = Eq).
-----
Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).
Proof.
intros t1 t2.
case_eq (Pos.eqb (fstpp(t1)) (fstpp(t2))).
intro HF.
apply Pos.eqb_eq in HF.
case_eq (Pos.eqb (sndpp(t1)) (sndpp(t2))).
intro HS.
case_eq (Pos.ltb (sndpp(t1)) (sndpp(t2))).
intro HLS.
assert (HLS2 : Pos.ltb (sndpp(t2)) (sndpp(t1)) = true).
assert (HC : compare t1 t2 = Gt).
unfold compare.
assert (HCF : Pos.compare (fstpp(t1)) (fstpp(t2)) = Eq).

*****
HLS2 : Logic.eq (Pos.ltb (sndpp t2) (sndpp t1)) true
HLS : Logic.eq (Pos.ltb (sndpp t1) (sndpp t2)) false
HS : Logic.eq (Pos.eqb (sndpp t1) (sndpp t2)) false
HF : Logic.eq (fstpp t1) (fstpp t2)
t1,t2 : True
*****
Logic.eq (Pos.compare (fstpp t1) (fstpp t2)) Eq
+++++
unfold Pos.compare.
-----
Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).
Proof.
intros t1 t2.
case_eq (Pos.eqb (fstpp(t1)) (fstpp(t2))).
intro HF.
apply Pos.eqb_eq in HF.
case_eq (Pos.eqb (sndpp(t1)) (sndpp(t2))).
intro HS.
case_eq (Pos.ltb (sndpp(t1)) (sndpp(t2))).
intro HLS.
assert (HLS2 : Pos.ltb (sndpp(t2)) (sndpp(t1)) = true).
assert (HC : compare t1 t2 = Gt).
unfold compare.
assert (HCF : Pos.compare (fstpp(t1)) (fstpp(t2)) = Eq).
unfold Pos.compare.

*****
HLS2 : Logic.eq (Pos.ltb (sndpp t2) (sndpp t1)) true
HLS : Logic.eq (Pos.ltb (sndpp t1) (sndpp t2)) false
HS : Logic.eq (Pos.eqb (sndpp t1) (sndpp t2)) false
HF : Logic.eq (fstpp t1) (fstpp t2)
t1,t2 : True
*****
Logic.eq (Pos.compare_cont Eq (fstpp t1) (fstpp t2)) Eq
+++++
rewrite HF.
-----
Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).
Proof.
intros t1 t2.
case_eq (Pos.eqb (fstpp(t1)) (fstpp(t2))).
intro HF.
apply Pos.eqb_eq in HF.
case_eq (Pos.eqb (sndpp(t1)) (sndpp(t2))).
intro HS.
case_eq (Pos.ltb (sndpp(t1)) (sndpp(t2))).
intro HLS.
assert (HLS2 : Pos.ltb (sndpp(t2)) (sndpp(t1)) = true).
assert (HC : compare t1 t2 = Gt).
unfold compare.
assert (HCF : Pos.compare (fstpp(t1)) (fstpp(t2)) = Eq).
unfold Pos.compare.
rewrite HF.

*****
HLS2 : Logic.eq (Pos.ltb (sndpp t2) (sndpp t1)) true
HLS : Logic.eq (Pos.ltb (sndpp t1) (sndpp t2)) false
HS : Logic.eq (Pos.eqb (sndpp t1) (sndpp t2)) false
HF : Logic.eq (fstpp t1) (fstpp t2)
t1,t2 : True
*****
Logic.eq (Pos.compare_cont Eq (fstpp t2) (fstpp t2)) Eq
+++++
apply Pos.compare_cont_refl.
-----
Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).
Proof.
intros t1 t2.
case_eq (Pos.eqb (fstpp(t1)) (fstpp(t2))).
intro HF.
apply Pos.eqb_eq in HF.
case_eq (Pos.eqb (sndpp(t1)) (sndpp(t2))).
intro HS.
case_eq (Pos.ltb (sndpp(t1)) (sndpp(t2))).
intro HLS.
assert (HLS2 : Pos.ltb (sndpp(t2)) (sndpp(t1)) = true).
assert (HC : compare t1 t2 = Gt).
unfold compare.
assert (HCF : Pos.compare (fstpp(t1)) (fstpp(t2)) = Eq).

*****
HCF : Logic.eq (Pos.compare (fstpp t1) (fstpp t2)) Eq
HLS2 : Logic.eq (Pos.ltb (sndpp t2) (sndpp t1)) true
HLS : Logic.eq (Pos.ltb (sndpp t1) (sndpp t2)) false
HS : Logic.eq (Pos.eqb (sndpp t1) (sndpp t2)) false
HF : Logic.eq (fstpp t1) (fstpp t2)
t1,t2 : True
*****
Logic.eq match Pos.compare (fstpp t1) (fstpp t2) with | Eq => Pos.compare (sndpp t1) (sndpp t2) | Lt => Lt | Gt => Gt end Gt
+++++
assert (HCS : Pos.compare (sndpp(t1)) (sndpp(t2)) = Gt).
-----
Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).
Proof.
intros t1 t2.
case_eq (Pos.eqb (fstpp(t1)) (fstpp(t2))).
intro HF.
apply Pos.eqb_eq in HF.
case_eq (Pos.eqb (sndpp(t1)) (sndpp(t2))).
intro HS.
case_eq (Pos.ltb (sndpp(t1)) (sndpp(t2))).
intro HLS.
assert (HLS2 : Pos.ltb (sndpp(t2)) (sndpp(t1)) = true).
assert (HC : compare t1 t2 = Gt).
unfold compare.
assert (HCF : Pos.compare (fstpp(t1)) (fstpp(t2)) = Eq).
assert (HCS : Pos.compare (sndpp(t1)) (sndpp(t2)) = Gt).

*****
HCF : Logic.eq (Pos.compare (fstpp t1) (fstpp t2)) Eq
HLS2 : Logic.eq (Pos.ltb (sndpp t2) (sndpp t1)) true
HLS : Logic.eq (Pos.ltb (sndpp t1) (sndpp t2)) false
HS : Logic.eq (Pos.eqb (sndpp t1) (sndpp t2)) false
HF : Logic.eq (fstpp t1) (fstpp t2)
t1,t2 : True
*****
Logic.eq (Pos.compare (sndpp t1) (sndpp t2)) Gt
+++++
unfold Pos.compare.
-----
Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).
Proof.
intros t1 t2.
case_eq (Pos.eqb (fstpp(t1)) (fstpp(t2))).
intro HF.
apply Pos.eqb_eq in HF.
case_eq (Pos.eqb (sndpp(t1)) (sndpp(t2))).
intro HS.
case_eq (Pos.ltb (sndpp(t1)) (sndpp(t2))).
intro HLS.
assert (HLS2 : Pos.ltb (sndpp(t2)) (sndpp(t1)) = true).
assert (HC : compare t1 t2 = Gt).
unfold compare.
assert (HCF : Pos.compare (fstpp(t1)) (fstpp(t2)) = Eq).
assert (HCS : Pos.compare (sndpp(t1)) (sndpp(t2)) = Gt).
unfold Pos.compare.

*****
HCF : Logic.eq (Pos.compare (fstpp t1) (fstpp t2)) Eq
HLS2 : Logic.eq (Pos.ltb (sndpp t2) (sndpp t1)) true
HLS : Logic.eq (Pos.ltb (sndpp t1) (sndpp t2)) false
HS : Logic.eq (Pos.eqb (sndpp t1) (sndpp t2)) false
HF : Logic.eq (fstpp t1) (fstpp t2)
t1,t2 : True
*****
Logic.eq (Pos.compare_cont Eq (sndpp t1) (sndpp t2)) Gt
+++++
apply Pos.ltb_lt in HLS2.
-----
Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).
Proof.
intros t1 t2.
case_eq (Pos.eqb (fstpp(t1)) (fstpp(t2))).
intro HF.
apply Pos.eqb_eq in HF.
case_eq (Pos.eqb (sndpp(t1)) (sndpp(t2))).
intro HS.
case_eq (Pos.ltb (sndpp(t1)) (sndpp(t2))).
intro HLS.
assert (HLS2 : Pos.ltb (sndpp(t2)) (sndpp(t1)) = true).
assert (HC : compare t1 t2 = Gt).
unfold compare.
assert (HCF : Pos.compare (fstpp(t1)) (fstpp(t2)) = Eq).
assert (HCS : Pos.compare (sndpp(t1)) (sndpp(t2)) = Gt).
unfold Pos.compare.
apply Pos.ltb_lt in HLS2.

*****
HCF : Logic.eq (Pos.compare (fstpp t1) (fstpp t2)) Eq
HLS2 : Pos.lt (sndpp t2) (sndpp t1)
HLS : Logic.eq (Pos.ltb (sndpp t1) (sndpp t2)) false
HS : Logic.eq (Pos.eqb (sndpp t1) (sndpp t2)) false
HF : Logic.eq (fstpp t1) (fstpp t2)
t1,t2 : True
*****
Logic.eq (Pos.compare_cont Eq (sndpp t1) (sndpp t2)) Gt
+++++
apply Pnat.nat_of_P_gt_Gt_compare_complement_morphism.
-----
Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).
Proof.
intros t1 t2.
case_eq (Pos.eqb (fstpp(t1)) (fstpp(t2))).
intro HF.
apply Pos.eqb_eq in HF.
case_eq (Pos.eqb (sndpp(t1)) (sndpp(t2))).
intro HS.
case_eq (Pos.ltb (sndpp(t1)) (sndpp(t2))).
intro HLS.
assert (HLS2 : Pos.ltb (sndpp(t2)) (sndpp(t1)) = true).
assert (HC : compare t1 t2 = Gt).
unfold compare.
assert (HCF : Pos.compare (fstpp(t1)) (fstpp(t2)) = Eq).
assert (HCS : Pos.compare (sndpp(t1)) (sndpp(t2)) = Gt).
unfold Pos.compare.
apply Pos.ltb_lt in HLS2.
apply Pnat.nat_of_P_gt_Gt_compare_complement_morphism.

*****
HCF : Logic.eq (Pos.compare (fstpp t1) (fstpp t2)) Eq
HLS2 : Pos.lt (sndpp t2) (sndpp t1)
HLS : Logic.eq (Pos.ltb (sndpp t1) (sndpp t2)) false
HS : Logic.eq (Pos.eqb (sndpp t1) (sndpp t2)) false
HF : Logic.eq (fstpp t1) (fstpp t2)
t1,t2 : True
*****
gt (Pos.to_nat (sndpp t1)) (Pos.to_nat (sndpp t2))
+++++
apply Pnat.Pos2Nat.inj_gt.
-----
Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).
Proof.
intros t1 t2.
case_eq (Pos.eqb (fstpp(t1)) (fstpp(t2))).
intro HF.
apply Pos.eqb_eq in HF.
case_eq (Pos.eqb (sndpp(t1)) (sndpp(t2))).
intro HS.
case_eq (Pos.ltb (sndpp(t1)) (sndpp(t2))).
intro HLS.
assert (HLS2 : Pos.ltb (sndpp(t2)) (sndpp(t1)) = true).
assert (HC : compare t1 t2 = Gt).
unfold compare.
assert (HCF : Pos.compare (fstpp(t1)) (fstpp(t2)) = Eq).
assert (HCS : Pos.compare (sndpp(t1)) (sndpp(t2)) = Gt).
unfold Pos.compare.
apply Pos.ltb_lt in HLS2.
apply Pnat.nat_of_P_gt_Gt_compare_complement_morphism.
apply Pnat.Pos2Nat.inj_gt.

*****
HCF : Logic.eq (Pos.compare (fstpp t1) (fstpp t2)) Eq
HLS2 : Pos.lt (sndpp t2) (sndpp t1)
HLS : Logic.eq (Pos.ltb (sndpp t1) (sndpp t2)) false
HS : Logic.eq (Pos.eqb (sndpp t1) (sndpp t2)) false
HF : Logic.eq (fstpp t1) (fstpp t2)
t1,t2 : True
*****
Pos.gt (sndpp t1) (sndpp t2)
+++++
apply Pos.gt_lt_iff.
-----
Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).
Proof.
intros t1 t2.
case_eq (Pos.eqb (fstpp(t1)) (fstpp(t2))).
intro HF.
apply Pos.eqb_eq in HF.
case_eq (Pos.eqb (sndpp(t1)) (sndpp(t2))).
intro HS.
case_eq (Pos.ltb (sndpp(t1)) (sndpp(t2))).
intro HLS.
assert (HLS2 : Pos.ltb (sndpp(t2)) (sndpp(t1)) = true).
assert (HC : compare t1 t2 = Gt).
unfold compare.
assert (HCF : Pos.compare (fstpp(t1)) (fstpp(t2)) = Eq).
assert (HCS : Pos.compare (sndpp(t1)) (sndpp(t2)) = Gt).
unfold Pos.compare.
apply Pos.ltb_lt in HLS2.
apply Pnat.nat_of_P_gt_Gt_compare_complement_morphism.
apply Pnat.Pos2Nat.inj_gt.
apply Pos.gt_lt_iff.

*****
HCF : Logic.eq (Pos.compare (fstpp t1) (fstpp t2)) Eq
HLS2 : Pos.lt (sndpp t2) (sndpp t1)
HLS : Logic.eq (Pos.ltb (sndpp t1) (sndpp t2)) false
HS : Logic.eq (Pos.eqb (sndpp t1) (sndpp t2)) false
HF : Logic.eq (fstpp t1) (fstpp t2)
t1,t2 : True
*****
Pos.lt (sndpp t2) (sndpp t1)
+++++
assumption.
-----
Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).
Proof.
intros t1 t2.
case_eq (Pos.eqb (fstpp(t1)) (fstpp(t2))).
intro HF.
apply Pos.eqb_eq in HF.
case_eq (Pos.eqb (sndpp(t1)) (sndpp(t2))).
intro HS.
case_eq (Pos.ltb (sndpp(t1)) (sndpp(t2))).
intro HLS.
assert (HLS2 : Pos.ltb (sndpp(t2)) (sndpp(t1)) = true).
assert (HC : compare t1 t2 = Gt).
unfold compare.
assert (HCF : Pos.compare (fstpp(t1)) (fstpp(t2)) = Eq).
assert (HCS : Pos.compare (sndpp(t1)) (sndpp(t2)) = Gt).

*****
HCS : Logic.eq (Pos.compare (sndpp t1) (sndpp t2)) Gt
HCF : Logic.eq (Pos.compare (fstpp t1) (fstpp t2)) Eq
HLS2 : Logic.eq (Pos.ltb (sndpp t2) (sndpp t1)) true
HLS : Logic.eq (Pos.ltb (sndpp t1) (sndpp t2)) false
HS : Logic.eq (Pos.eqb (sndpp t1) (sndpp t2)) false
HF : Logic.eq (fstpp t1) (fstpp t2)
t1,t2 : True
*****
Logic.eq match Pos.compare (fstpp t1) (fstpp t2) with | Eq => Pos.compare (sndpp t1) (sndpp t2) | Lt => Lt | Gt => Gt end Gt
+++++
rewrite HCF.
-----
Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).
Proof.
intros t1 t2.
case_eq (Pos.eqb (fstpp(t1)) (fstpp(t2))).
intro HF.
apply Pos.eqb_eq in HF.
case_eq (Pos.eqb (sndpp(t1)) (sndpp(t2))).
intro HS.
case_eq (Pos.ltb (sndpp(t1)) (sndpp(t2))).
intro HLS.
assert (HLS2 : Pos.ltb (sndpp(t2)) (sndpp(t1)) = true).
assert (HC : compare t1 t2 = Gt).
unfold compare.
assert (HCF : Pos.compare (fstpp(t1)) (fstpp(t2)) = Eq).
assert (HCS : Pos.compare (sndpp(t1)) (sndpp(t2)) = Gt).
rewrite HCF.

*****
HCS : Logic.eq (Pos.compare (sndpp t1) (sndpp t2)) Gt
HCF : Logic.eq (Pos.compare (fstpp t1) (fstpp t2)) Eq
HLS2 : Logic.eq (Pos.ltb (sndpp t2) (sndpp t1)) true
HLS : Logic.eq (Pos.ltb (sndpp t1) (sndpp t2)) false
HS : Logic.eq (Pos.eqb (sndpp t1) (sndpp t2)) false
HF : Logic.eq (fstpp t1) (fstpp t2)
t1,t2 : True
*****
Logic.eq (Pos.compare (sndpp t1) (sndpp t2)) Gt
+++++
rewrite HCS.
-----
Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).
Proof.
intros t1 t2.
case_eq (Pos.eqb (fstpp(t1)) (fstpp(t2))).
intro HF.
apply Pos.eqb_eq in HF.
case_eq (Pos.eqb (sndpp(t1)) (sndpp(t2))).
intro HS.
case_eq (Pos.ltb (sndpp(t1)) (sndpp(t2))).
intro HLS.
assert (HLS2 : Pos.ltb (sndpp(t2)) (sndpp(t1)) = true).
assert (HC : compare t1 t2 = Gt).
unfold compare.
assert (HCF : Pos.compare (fstpp(t1)) (fstpp(t2)) = Eq).
assert (HCS : Pos.compare (sndpp(t1)) (sndpp(t2)) = Gt).
rewrite HCF.
rewrite HCS.

*****
HCS : Logic.eq (Pos.compare (sndpp t1) (sndpp t2)) Gt
HCF : Logic.eq (Pos.compare (fstpp t1) (fstpp t2)) Eq
HLS2 : Logic.eq (Pos.ltb (sndpp t2) (sndpp t1)) true
HLS : Logic.eq (Pos.ltb (sndpp t1) (sndpp t2)) false
HS : Logic.eq (Pos.eqb (sndpp t1) (sndpp t2)) false
HF : Logic.eq (fstpp t1) (fstpp t2)
t1,t2 : True
*****
Logic.eq Gt Gt
+++++
intuition.
-----
Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).
Proof.
intros t1 t2.
case_eq (Pos.eqb (fstpp(t1)) (fstpp(t2))).
intro HF.
apply Pos.eqb_eq in HF.
case_eq (Pos.eqb (sndpp(t1)) (sndpp(t2))).
intro HS.
case_eq (Pos.ltb (sndpp(t1)) (sndpp(t2))).
intro HLS.
assert (HLS2 : Pos.ltb (sndpp(t2)) (sndpp(t1)) = true).
assert (HC : compare t1 t2 = Gt).

*****
HC : Logic.eq (compare t1 t2) Gt
HLS2 : Logic.eq (Pos.ltb (sndpp t2) (sndpp t1)) true
HLS : Logic.eq (Pos.ltb (sndpp t1) (sndpp t2)) false
HS : Logic.eq (Pos.eqb (sndpp t1) (sndpp t2)) false
HF : Logic.eq (fstpp t1) (fstpp t2)
t1,t2 : True
*****
CompSpec eq lt t1 t2 (compare t1 t2)
+++++
rewrite HC.
-----
Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).
Proof.
intros t1 t2.
case_eq (Pos.eqb (fstpp(t1)) (fstpp(t2))).
intro HF.
apply Pos.eqb_eq in HF.
case_eq (Pos.eqb (sndpp(t1)) (sndpp(t2))).
intro HS.
case_eq (Pos.ltb (sndpp(t1)) (sndpp(t2))).
intro HLS.
assert (HLS2 : Pos.ltb (sndpp(t2)) (sndpp(t1)) = true).
assert (HC : compare t1 t2 = Gt).
rewrite HC.

*****
HC : Logic.eq (compare t1 t2) Gt
HLS2 : Logic.eq (Pos.ltb (sndpp t2) (sndpp t1)) true
HLS : Logic.eq (Pos.ltb (sndpp t1) (sndpp t2)) false
HS : Logic.eq (Pos.eqb (sndpp t1) (sndpp t2)) false
HF : Logic.eq (fstpp t1) (fstpp t2)
t1,t2 : True
*****
CompSpec eq lt t1 t2 Gt
+++++
apply CompGt.
-----
Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).
Proof.
intros t1 t2.
case_eq (Pos.eqb (fstpp(t1)) (fstpp(t2))).
intro HF.
apply Pos.eqb_eq in HF.
case_eq (Pos.eqb (sndpp(t1)) (sndpp(t2))).
intro HS.
case_eq (Pos.ltb (sndpp(t1)) (sndpp(t2))).
intro HLS.
assert (HLS2 : Pos.ltb (sndpp(t2)) (sndpp(t1)) = true).
assert (HC : compare t1 t2 = Gt).
rewrite HC.
apply CompGt.

*****
HC : Logic.eq (compare t1 t2) Gt
HLS2 : Logic.eq (Pos.ltb (sndpp t2) (sndpp t1)) true
HLS : Logic.eq (Pos.ltb (sndpp t1) (sndpp t2)) false
HS : Logic.eq (Pos.eqb (sndpp t1) (sndpp t2)) false
HF : Logic.eq (fstpp t1) (fstpp t2)
t1,t2 : True
*****
lt t2 t1
+++++
unfold lt.
-----
Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).
Proof.
intros t1 t2.
case_eq (Pos.eqb (fstpp(t1)) (fstpp(t2))).
intro HF.
apply Pos.eqb_eq in HF.
case_eq (Pos.eqb (sndpp(t1)) (sndpp(t2))).
intro HS.
case_eq (Pos.ltb (sndpp(t1)) (sndpp(t2))).
intro HLS.
assert (HLS2 : Pos.ltb (sndpp(t2)) (sndpp(t1)) = true).
assert (HC : compare t1 t2 = Gt).
rewrite HC.
apply CompGt.
unfold lt.

*****
HC : Logic.eq (compare t1 t2) Gt
HLS2 : Logic.eq (Pos.ltb (sndpp t2) (sndpp t1)) true
HLS : Logic.eq (Pos.ltb (sndpp t1) (sndpp t2)) false
HS : Logic.eq (Pos.eqb (sndpp t1) (sndpp t2)) false
HF : Logic.eq (fstpp t1) (fstpp t2)
t1,t2 : True
*****
if Pos.eqb (fstpp t2) (fstpp t1) then Pos.lt (sndpp t2) (sndpp t1) else Pos.lt (fstpp t2) (fstpp t1)
+++++
apply Pos.eqb_eq in HF.
-----
Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).
Proof.
intros t1 t2.
case_eq (Pos.eqb (fstpp(t1)) (fstpp(t2))).
intro HF.
apply Pos.eqb_eq in HF.
case_eq (Pos.eqb (sndpp(t1)) (sndpp(t2))).
intro HS.
case_eq (Pos.ltb (sndpp(t1)) (sndpp(t2))).
intro HLS.
assert (HLS2 : Pos.ltb (sndpp(t2)) (sndpp(t1)) = true).
assert (HC : compare t1 t2 = Gt).
rewrite HC.
apply CompGt.
unfold lt.
apply Pos.eqb_eq in HF.

*****
HC : Logic.eq (compare t1 t2) Gt
HLS2 : Logic.eq (Pos.ltb (sndpp t2) (sndpp t1)) true
HLS : Logic.eq (Pos.ltb (sndpp t1) (sndpp t2)) false
HS : Logic.eq (Pos.eqb (sndpp t1) (sndpp t2)) false
HF : Logic.eq (Pos.eqb (fstpp t1) (fstpp t2)) true
t1,t2 : True
*****
if Pos.eqb (fstpp t2) (fstpp t1) then Pos.lt (sndpp t2) (sndpp t1) else Pos.lt (fstpp t2) (fstpp t1)
+++++
rewrite Pos.eqb_sym in HF.
-----
Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).
Proof.
intros t1 t2.
case_eq (Pos.eqb (fstpp(t1)) (fstpp(t2))).
intro HF.
apply Pos.eqb_eq in HF.
case_eq (Pos.eqb (sndpp(t1)) (sndpp(t2))).
intro HS.
case_eq (Pos.ltb (sndpp(t1)) (sndpp(t2))).
intro HLS.
assert (HLS2 : Pos.ltb (sndpp(t2)) (sndpp(t1)) = true).
assert (HC : compare t1 t2 = Gt).
rewrite HC.
apply CompGt.
unfold lt.
apply Pos.eqb_eq in HF.
rewrite Pos.eqb_sym in HF.

*****
HC : Logic.eq (compare t1 t2) Gt
HLS2 : Logic.eq (Pos.ltb (sndpp t2) (sndpp t1)) true
HLS : Logic.eq (Pos.ltb (sndpp t1) (sndpp t2)) false
HS : Logic.eq (Pos.eqb (sndpp t1) (sndpp t2)) false
HF : Logic.eq (Pos.eqb (fstpp t2) (fstpp t1)) true
t1,t2 : True
*****
if Pos.eqb (fstpp t2) (fstpp t1) then Pos.lt (sndpp t2) (sndpp t1) else Pos.lt (fstpp t2) (fstpp t1)
+++++
rewrite HF.
-----
Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).
Proof.
intros t1 t2.
case_eq (Pos.eqb (fstpp(t1)) (fstpp(t2))).
intro HF.
apply Pos.eqb_eq in HF.
case_eq (Pos.eqb (sndpp(t1)) (sndpp(t2))).
intro HS.
case_eq (Pos.ltb (sndpp(t1)) (sndpp(t2))).
intro HLS.
assert (HLS2 : Pos.ltb (sndpp(t2)) (sndpp(t1)) = true).
assert (HC : compare t1 t2 = Gt).
rewrite HC.
apply CompGt.
unfold lt.
apply Pos.eqb_eq in HF.
rewrite Pos.eqb_sym in HF.
rewrite HF.

*****
HC : Logic.eq (compare t1 t2) Gt
HLS2 : Logic.eq (Pos.ltb (sndpp t2) (sndpp t1)) true
HLS : Logic.eq (Pos.ltb (sndpp t1) (sndpp t2)) false
HS : Logic.eq (Pos.eqb (sndpp t1) (sndpp t2)) false
HF : Logic.eq (Pos.eqb (fstpp t2) (fstpp t1)) true
t1,t2 : True
*****
Pos.lt (sndpp t2) (sndpp t1)
+++++
apply Pos.ltb_lt in HLS2.
-----
Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).
Proof.
intros t1 t2.
case_eq (Pos.eqb (fstpp(t1)) (fstpp(t2))).
intro HF.
apply Pos.eqb_eq in HF.
case_eq (Pos.eqb (sndpp(t1)) (sndpp(t2))).
intro HS.
case_eq (Pos.ltb (sndpp(t1)) (sndpp(t2))).
intro HLS.
assert (HLS2 : Pos.ltb (sndpp(t2)) (sndpp(t1)) = true).
assert (HC : compare t1 t2 = Gt).
rewrite HC.
apply CompGt.
unfold lt.
apply Pos.eqb_eq in HF.
rewrite Pos.eqb_sym in HF.
rewrite HF.
apply Pos.ltb_lt in HLS2.

*****
HC : Logic.eq (compare t1 t2) Gt
HLS2 : Pos.lt (sndpp t2) (sndpp t1)
HLS : Logic.eq (Pos.ltb (sndpp t1) (sndpp t2)) false
HS : Logic.eq (Pos.eqb (sndpp t1) (sndpp t2)) false
HF : Logic.eq (Pos.eqb (fstpp t2) (fstpp t1)) true
t1,t2 : True
*****
Pos.lt (sndpp t2) (sndpp t1)
+++++
assumption.
-----
Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).
Proof.
intros t1 t2.
case_eq (Pos.eqb (fstpp(t1)) (fstpp(t2))).

*****
t1,t2 : True
*****
forall _ : Logic.eq (Pos.eqb (fstpp t1) (fstpp t2)) false, CompSpec eq lt t1 t2 (compare t1 t2)
+++++
intro HF.
-----
Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).
Proof.
intros t1 t2.
case_eq (Pos.eqb (fstpp(t1)) (fstpp(t2))).
intro HF.

*****
HF : Logic.eq (Pos.eqb (fstpp t1) (fstpp t2)) false
t1,t2 : True
*****
CompSpec eq lt t1 t2 (compare t1 t2)
+++++
case_eq (Pos.ltb (fstpp(t1)) (fstpp(t2))).
-----
Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).
Proof.
intros t1 t2.
case_eq (Pos.eqb (fstpp(t1)) (fstpp(t2))).
intro HF.
case_eq (Pos.ltb (fstpp(t1)) (fstpp(t2))).

*****
HF : Logic.eq (Pos.eqb (fstpp t1) (fstpp t2)) false
t1,t2 : True
*****
forall _ : Logic.eq (Pos.ltb (fstpp t1) (fstpp t2)) true, CompSpec eq lt t1 t2 (compare t1 t2)
+++++
intro HLF.
-----
Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).
Proof.
intros t1 t2.
case_eq (Pos.eqb (fstpp(t1)) (fstpp(t2))).
intro HF.
case_eq (Pos.ltb (fstpp(t1)) (fstpp(t2))).
intro HLF.

*****
HLF : Logic.eq (Pos.ltb (fstpp t1) (fstpp t2)) true
HF : Logic.eq (Pos.eqb (fstpp t1) (fstpp t2)) false
t1,t2 : True
*****
CompSpec eq lt t1 t2 (compare t1 t2)
+++++
assert (HC : compare t1 t2 = Lt).
-----
Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).
Proof.
intros t1 t2.
case_eq (Pos.eqb (fstpp(t1)) (fstpp(t2))).
intro HF.
case_eq (Pos.ltb (fstpp(t1)) (fstpp(t2))).
intro HLF.
assert (HC : compare t1 t2 = Lt).

*****
HLF : Logic.eq (Pos.ltb (fstpp t1) (fstpp t2)) true
HF : Logic.eq (Pos.eqb (fstpp t1) (fstpp t2)) false
t1,t2 : True
*****
Logic.eq (compare t1 t2) Lt
+++++
unfold compare.
-----
Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).
Proof.
intros t1 t2.
case_eq (Pos.eqb (fstpp(t1)) (fstpp(t2))).
intro HF.
case_eq (Pos.ltb (fstpp(t1)) (fstpp(t2))).
intro HLF.
assert (HC : compare t1 t2 = Lt).
unfold compare.

*****
HLF : Logic.eq (Pos.ltb (fstpp t1) (fstpp t2)) true
HF : Logic.eq (Pos.eqb (fstpp t1) (fstpp t2)) false
t1,t2 : True
*****
Logic.eq match Pos.compare (fstpp t1) (fstpp t2) with | Eq => Pos.compare (sndpp t1) (sndpp t2) | Lt => Lt | Gt => Gt end Lt
+++++
assert (HCF : Pos.compare (fstpp(t1)) (fstpp(t2)) = Lt).
-----
Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).
Proof.
intros t1 t2.
case_eq (Pos.eqb (fstpp(t1)) (fstpp(t2))).
intro HF.
case_eq (Pos.ltb (fstpp(t1)) (fstpp(t2))).
intro HLF.
assert (HC : compare t1 t2 = Lt).
unfold compare.
assert (HCF : Pos.compare (fstpp(t1)) (fstpp(t2)) = Lt).

*****
HLF : Logic.eq (Pos.ltb (fstpp t1) (fstpp t2)) true
HF : Logic.eq (Pos.eqb (fstpp t1) (fstpp t2)) false
t1,t2 : True
*****
Logic.eq (Pos.compare (fstpp t1) (fstpp t2)) Lt
+++++
unfold Pos.compare.
-----
Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).
Proof.
intros t1 t2.
case_eq (Pos.eqb (fstpp(t1)) (fstpp(t2))).
intro HF.
case_eq (Pos.ltb (fstpp(t1)) (fstpp(t2))).
intro HLF.
assert (HC : compare t1 t2 = Lt).
unfold compare.
assert (HCF : Pos.compare (fstpp(t1)) (fstpp(t2)) = Lt).
unfold Pos.compare.

*****
HLF : Logic.eq (Pos.ltb (fstpp t1) (fstpp t2)) true
HF : Logic.eq (Pos.eqb (fstpp t1) (fstpp t2)) false
t1,t2 : True
*****
Logic.eq (Pos.compare_cont Eq (fstpp t1) (fstpp t2)) Lt
+++++
apply Pos.ltb_lt in HLF.
-----
Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).
Proof.
intros t1 t2.
case_eq (Pos.eqb (fstpp(t1)) (fstpp(t2))).
intro HF.
case_eq (Pos.ltb (fstpp(t1)) (fstpp(t2))).
intro HLF.
assert (HC : compare t1 t2 = Lt).
unfold compare.
assert (HCF : Pos.compare (fstpp(t1)) (fstpp(t2)) = Lt).
unfold Pos.compare.
apply Pos.ltb_lt in HLF.

*****
HLF : Pos.lt (fstpp t1) (fstpp t2)
HF : Logic.eq (Pos.eqb (fstpp t1) (fstpp t2)) false
t1,t2 : True
*****
Logic.eq (Pos.compare_cont Eq (fstpp t1) (fstpp t2)) Lt
+++++
apply Pnat.nat_of_P_lt_Lt_compare_complement_morphism.
-----
Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).
Proof.
intros t1 t2.
case_eq (Pos.eqb (fstpp(t1)) (fstpp(t2))).
intro HF.
case_eq (Pos.ltb (fstpp(t1)) (fstpp(t2))).
intro HLF.
assert (HC : compare t1 t2 = Lt).
unfold compare.
assert (HCF : Pos.compare (fstpp(t1)) (fstpp(t2)) = Lt).
unfold Pos.compare.
apply Pos.ltb_lt in HLF.
apply Pnat.nat_of_P_lt_Lt_compare_complement_morphism.

*****
HLF : Pos.lt (fstpp t1) (fstpp t2)
HF : Logic.eq (Pos.eqb (fstpp t1) (fstpp t2)) false
t1,t2 : True
*****
Peano.lt (Pos.to_nat (fstpp t1)) (Pos.to_nat (fstpp t2))
+++++
apply Pnat.Pos2Nat.inj_lt.
-----
Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).
Proof.
intros t1 t2.
case_eq (Pos.eqb (fstpp(t1)) (fstpp(t2))).
intro HF.
case_eq (Pos.ltb (fstpp(t1)) (fstpp(t2))).
intro HLF.
assert (HC : compare t1 t2 = Lt).
unfold compare.
assert (HCF : Pos.compare (fstpp(t1)) (fstpp(t2)) = Lt).
unfold Pos.compare.
apply Pos.ltb_lt in HLF.
apply Pnat.nat_of_P_lt_Lt_compare_complement_morphism.
apply Pnat.Pos2Nat.inj_lt.

*****
HLF : Pos.lt (fstpp t1) (fstpp t2)
HF : Logic.eq (Pos.eqb (fstpp t1) (fstpp t2)) false
t1,t2 : True
*****
Pos.lt (fstpp t1) (fstpp t2)
+++++
assumption.
-----
Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).
Proof.
intros t1 t2.
case_eq (Pos.eqb (fstpp(t1)) (fstpp(t2))).
intro HF.
case_eq (Pos.ltb (fstpp(t1)) (fstpp(t2))).
intro HLF.
assert (HC : compare t1 t2 = Lt).
unfold compare.
assert (HCF : Pos.compare (fstpp(t1)) (fstpp(t2)) = Lt).

*****
HCF : Logic.eq (Pos.compare (fstpp t1) (fstpp t2)) Lt
HLF : Logic.eq (Pos.ltb (fstpp t1) (fstpp t2)) true
HF : Logic.eq (Pos.eqb (fstpp t1) (fstpp t2)) false
t1,t2 : True
*****
Logic.eq match Pos.compare (fstpp t1) (fstpp t2) with | Eq => Pos.compare (sndpp t1) (sndpp t2) | Lt => Lt | Gt => Gt end Lt
+++++
rewrite HCF.
-----
Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).
Proof.
intros t1 t2.
case_eq (Pos.eqb (fstpp(t1)) (fstpp(t2))).
intro HF.
case_eq (Pos.ltb (fstpp(t1)) (fstpp(t2))).
intro HLF.
assert (HC : compare t1 t2 = Lt).
unfold compare.
assert (HCF : Pos.compare (fstpp(t1)) (fstpp(t2)) = Lt).
rewrite HCF.

*****
HCF : Logic.eq (Pos.compare (fstpp t1) (fstpp t2)) Lt
HLF : Logic.eq (Pos.ltb (fstpp t1) (fstpp t2)) true
HF : Logic.eq (Pos.eqb (fstpp t1) (fstpp t2)) false
t1,t2 : True
*****
Logic.eq Lt Lt
+++++
intuition.
-----
Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).
Proof.
intros t1 t2.
case_eq (Pos.eqb (fstpp(t1)) (fstpp(t2))).
intro HF.
case_eq (Pos.ltb (fstpp(t1)) (fstpp(t2))).
intro HLF.
assert (HC : compare t1 t2 = Lt).

*****
HC : Logic.eq (compare t1 t2) Lt
HLF : Logic.eq (Pos.ltb (fstpp t1) (fstpp t2)) true
HF : Logic.eq (Pos.eqb (fstpp t1) (fstpp t2)) false
t1,t2 : True
*****
CompSpec eq lt t1 t2 (compare t1 t2)
+++++
rewrite HC.
-----
Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).
Proof.
intros t1 t2.
case_eq (Pos.eqb (fstpp(t1)) (fstpp(t2))).
intro HF.
case_eq (Pos.ltb (fstpp(t1)) (fstpp(t2))).
intro HLF.
assert (HC : compare t1 t2 = Lt).
rewrite HC.

*****
HC : Logic.eq (compare t1 t2) Lt
HLF : Logic.eq (Pos.ltb (fstpp t1) (fstpp t2)) true
HF : Logic.eq (Pos.eqb (fstpp t1) (fstpp t2)) false
t1,t2 : True
*****
CompSpec eq lt t1 t2 Lt
+++++
apply CompLt.
-----
Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).
Proof.
intros t1 t2.
case_eq (Pos.eqb (fstpp(t1)) (fstpp(t2))).
intro HF.
case_eq (Pos.ltb (fstpp(t1)) (fstpp(t2))).
intro HLF.
assert (HC : compare t1 t2 = Lt).
rewrite HC.
apply CompLt.

*****
HC : Logic.eq (compare t1 t2) Lt
HLF : Logic.eq (Pos.ltb (fstpp t1) (fstpp t2)) true
HF : Logic.eq (Pos.eqb (fstpp t1) (fstpp t2)) false
t1,t2 : True
*****
lt t1 t2
+++++
unfold lt.
-----
Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).
Proof.
intros t1 t2.
case_eq (Pos.eqb (fstpp(t1)) (fstpp(t2))).
intro HF.
case_eq (Pos.ltb (fstpp(t1)) (fstpp(t2))).
intro HLF.
assert (HC : compare t1 t2 = Lt).
rewrite HC.
apply CompLt.
unfold lt.

*****
HC : Logic.eq (compare t1 t2) Lt
HLF : Logic.eq (Pos.ltb (fstpp t1) (fstpp t2)) true
HF : Logic.eq (Pos.eqb (fstpp t1) (fstpp t2)) false
t1,t2 : True
*****
if Pos.eqb (fstpp t1) (fstpp t2) then Pos.lt (sndpp t1) (sndpp t2) else Pos.lt (fstpp t1) (fstpp t2)
+++++
rewrite HF.
-----
Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).
Proof.
intros t1 t2.
case_eq (Pos.eqb (fstpp(t1)) (fstpp(t2))).
intro HF.
case_eq (Pos.ltb (fstpp(t1)) (fstpp(t2))).
intro HLF.
assert (HC : compare t1 t2 = Lt).
rewrite HC.
apply CompLt.
unfold lt.
rewrite HF.

*****
HC : Logic.eq (compare t1 t2) Lt
HLF : Logic.eq (Pos.ltb (fstpp t1) (fstpp t2)) true
HF : Logic.eq (Pos.eqb (fstpp t1) (fstpp t2)) false
t1,t2 : True
*****
Pos.lt (fstpp t1) (fstpp t2)
+++++
apply Pos.ltb_lt in HLF.
-----
Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).
Proof.
intros t1 t2.
case_eq (Pos.eqb (fstpp(t1)) (fstpp(t2))).
intro HF.
case_eq (Pos.ltb (fstpp(t1)) (fstpp(t2))).
intro HLF.
assert (HC : compare t1 t2 = Lt).
rewrite HC.
apply CompLt.
unfold lt.
rewrite HF.
apply Pos.ltb_lt in HLF.

*****
HC : Logic.eq (compare t1 t2) Lt
HLF : Pos.lt (fstpp t1) (fstpp t2)
HF : Logic.eq (Pos.eqb (fstpp t1) (fstpp t2)) false
t1,t2 : True
*****
Pos.lt (fstpp t1) (fstpp t2)
+++++
assumption.
-----
Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).
Proof.
intros t1 t2.
case_eq (Pos.eqb (fstpp(t1)) (fstpp(t2))).
intro HF.
case_eq (Pos.ltb (fstpp(t1)) (fstpp(t2))).

*****
HF : Logic.eq (Pos.eqb (fstpp t1) (fstpp t2)) false
t1,t2 : True
*****
forall _ : Logic.eq (Pos.ltb (fstpp t1) (fstpp t2)) false, CompSpec eq lt t1 t2 (compare t1 t2)
+++++
intro HLF.
-----
Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).
Proof.
intros t1 t2.
case_eq (Pos.eqb (fstpp(t1)) (fstpp(t2))).
intro HF.
case_eq (Pos.ltb (fstpp(t1)) (fstpp(t2))).
intro HLF.

*****
HLF : Logic.eq (Pos.ltb (fstpp t1) (fstpp t2)) false
HF : Logic.eq (Pos.eqb (fstpp t1) (fstpp t2)) false
t1,t2 : True
*****
CompSpec eq lt t1 t2 (compare t1 t2)
+++++
assert (HLF2 : Pos.ltb (fstpp(t2)) (fstpp(t1)) = true).
-----
Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).
Proof.
intros t1 t2.
case_eq (Pos.eqb (fstpp(t1)) (fstpp(t2))).
intro HF.
case_eq (Pos.ltb (fstpp(t1)) (fstpp(t2))).
intro HLF.
assert (HLF2 : Pos.ltb (fstpp(t2)) (fstpp(t1)) = true).

*****
HLF : Logic.eq (Pos.ltb (fstpp t1) (fstpp t2)) false
HF : Logic.eq (Pos.eqb (fstpp t1) (fstpp t2)) false
t1,t2 : True
*****
Logic.eq (Pos.ltb (fstpp t2) (fstpp t1)) true
+++++
apply Pos.ltb_nlt in HLF.
-----
Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).
Proof.
intros t1 t2.
case_eq (Pos.eqb (fstpp(t1)) (fstpp(t2))).
intro HF.
case_eq (Pos.ltb (fstpp(t1)) (fstpp(t2))).
intro HLF.
assert (HLF2 : Pos.ltb (fstpp(t2)) (fstpp(t1)) = true).
apply Pos.ltb_nlt in HLF.

*****
HLF : not (Pos.lt (fstpp t1) (fstpp t2))
HF : Logic.eq (Pos.eqb (fstpp t1) (fstpp t2)) false
t1,t2 : True
*****
Logic.eq (Pos.ltb (fstpp t2) (fstpp t1)) true
+++++
apply Pos.le_nlt in HLF.
-----
Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).
Proof.
intros t1 t2.
case_eq (Pos.eqb (fstpp(t1)) (fstpp(t2))).
intro HF.
case_eq (Pos.ltb (fstpp(t1)) (fstpp(t2))).
intro HLF.
assert (HLF2 : Pos.ltb (fstpp(t2)) (fstpp(t1)) = true).
apply Pos.ltb_nlt in HLF.
apply Pos.le_nlt in HLF.

*****
HLF : Pos.le (fstpp t2) (fstpp t1)
HF : Logic.eq (Pos.eqb (fstpp t1) (fstpp t2)) false
t1,t2 : True
*****
Logic.eq (Pos.ltb (fstpp t2) (fstpp t1)) true
+++++
apply Pos.lt_eq_cases in HLF.
-----
Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).
Proof.
intros t1 t2.
case_eq (Pos.eqb (fstpp(t1)) (fstpp(t2))).
intro HF.
case_eq (Pos.ltb (fstpp(t1)) (fstpp(t2))).
intro HLF.
assert (HLF2 : Pos.ltb (fstpp(t2)) (fstpp(t1)) = true).
apply Pos.ltb_nlt in HLF.
apply Pos.le_nlt in HLF.
apply Pos.lt_eq_cases in HLF.

*****
HLF : or (Pos.lt (fstpp t2) (fstpp t1)) (Logic.eq (fstpp t2) (fstpp t1))
HF : Logic.eq (Pos.eqb (fstpp t1) (fstpp t2)) false
t1,t2 : True
*****
Logic.eq (Pos.ltb (fstpp t2) (fstpp t1)) true
+++++
elim HLF.
-----
Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).
Proof.
intros t1 t2.
case_eq (Pos.eqb (fstpp(t1)) (fstpp(t2))).
intro HF.
case_eq (Pos.ltb (fstpp(t1)) (fstpp(t2))).
intro HLF.
assert (HLF2 : Pos.ltb (fstpp(t2)) (fstpp(t1)) = true).
apply Pos.ltb_nlt in HLF.
apply Pos.le_nlt in HLF.
apply Pos.lt_eq_cases in HLF.
elim HLF.

*****
HLF : or (Pos.lt (fstpp t2) (fstpp t1)) (Logic.eq (fstpp t2) (fstpp t1))
HF : Logic.eq (Pos.eqb (fstpp t1) (fstpp t2)) false
t1,t2 : True
*****
forall _ : Pos.lt (fstpp t2) (fstpp t1), Logic.eq (Pos.ltb (fstpp t2) (fstpp t1)) true
+++++
intro HLF2.
-----
Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).
Proof.
intros t1 t2.
case_eq (Pos.eqb (fstpp(t1)) (fstpp(t2))).
intro HF.
case_eq (Pos.ltb (fstpp(t1)) (fstpp(t2))).
intro HLF.
assert (HLF2 : Pos.ltb (fstpp(t2)) (fstpp(t1)) = true).
apply Pos.ltb_nlt in HLF.
apply Pos.le_nlt in HLF.
apply Pos.lt_eq_cases in HLF.
elim HLF.
intro HLF2.

*****
HLF2 : Pos.lt (fstpp t2) (fstpp t1)
HLF : or (Pos.lt (fstpp t2) (fstpp t1)) (Logic.eq (fstpp t2) (fstpp t1))
HF : Logic.eq (Pos.eqb (fstpp t1) (fstpp t2)) false
t1,t2 : True
*****
Logic.eq (Pos.ltb (fstpp t2) (fstpp t1)) true
+++++
apply Pos.ltb_lt.
-----
Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).
Proof.
intros t1 t2.
case_eq (Pos.eqb (fstpp(t1)) (fstpp(t2))).
intro HF.
case_eq (Pos.ltb (fstpp(t1)) (fstpp(t2))).
intro HLF.
assert (HLF2 : Pos.ltb (fstpp(t2)) (fstpp(t1)) = true).
apply Pos.ltb_nlt in HLF.
apply Pos.le_nlt in HLF.
apply Pos.lt_eq_cases in HLF.
elim HLF.
intro HLF2.
apply Pos.ltb_lt.

*****
HLF2 : Pos.lt (fstpp t2) (fstpp t1)
HLF : or (Pos.lt (fstpp t2) (fstpp t1)) (Logic.eq (fstpp t2) (fstpp t1))
HF : Logic.eq (Pos.eqb (fstpp t1) (fstpp t2)) false
t1,t2 : True
*****
Pos.lt (fstpp t2) (fstpp t1)
+++++
assumption.
-----
Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).
Proof.
intros t1 t2.
case_eq (Pos.eqb (fstpp(t1)) (fstpp(t2))).
intro HF.
case_eq (Pos.ltb (fstpp(t1)) (fstpp(t2))).
intro HLF.
assert (HLF2 : Pos.ltb (fstpp(t2)) (fstpp(t1)) = true).
apply Pos.ltb_nlt in HLF.
apply Pos.le_nlt in HLF.
apply Pos.lt_eq_cases in HLF.
elim HLF.

*****
HLF : or (Pos.lt (fstpp t2) (fstpp t1)) (Logic.eq (fstpp t2) (fstpp t1))
HF : Logic.eq (Pos.eqb (fstpp t1) (fstpp t2)) false
t1,t2 : True
*****
forall _ : Logic.eq (fstpp t2) (fstpp t1), Logic.eq (Pos.ltb (fstpp t2) (fstpp t1)) true
+++++
intro HLF2.
-----
Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).
Proof.
intros t1 t2.
case_eq (Pos.eqb (fstpp(t1)) (fstpp(t2))).
intro HF.
case_eq (Pos.ltb (fstpp(t1)) (fstpp(t2))).
intro HLF.
assert (HLF2 : Pos.ltb (fstpp(t2)) (fstpp(t1)) = true).
apply Pos.ltb_nlt in HLF.
apply Pos.le_nlt in HLF.
apply Pos.lt_eq_cases in HLF.
elim HLF.
intro HLF2.

*****
HLF2 : Logic.eq (fstpp t2) (fstpp t1)
HLF : or (Pos.lt (fstpp t2) (fstpp t1)) (Logic.eq (fstpp t2) (fstpp t1))
HF : Logic.eq (Pos.eqb (fstpp t1) (fstpp t2)) false
t1,t2 : True
*****
Logic.eq (Pos.ltb (fstpp t2) (fstpp t1)) true
+++++
apply Pos.eqb_neq in HF.
-----
Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).
Proof.
intros t1 t2.
case_eq (Pos.eqb (fstpp(t1)) (fstpp(t2))).
intro HF.
case_eq (Pos.ltb (fstpp(t1)) (fstpp(t2))).
intro HLF.
assert (HLF2 : Pos.ltb (fstpp(t2)) (fstpp(t1)) = true).
apply Pos.ltb_nlt in HLF.
apply Pos.le_nlt in HLF.
apply Pos.lt_eq_cases in HLF.
elim HLF.
intro HLF2.
apply Pos.eqb_neq in HF.

*****
HLF2 : Logic.eq (fstpp t2) (fstpp t1)
HLF : or (Pos.lt (fstpp t2) (fstpp t1)) (Logic.eq (fstpp t2) (fstpp t1))
HF : not (Logic.eq (fstpp t1) (fstpp t2))
t1,t2 : True
*****
Logic.eq (Pos.ltb (fstpp t2) (fstpp t1)) true
+++++
rewrite HLF2 in HF.
-----
Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).
Proof.
intros t1 t2.
case_eq (Pos.eqb (fstpp(t1)) (fstpp(t2))).
intro HF.
case_eq (Pos.ltb (fstpp(t1)) (fstpp(t2))).
intro HLF.
assert (HLF2 : Pos.ltb (fstpp(t2)) (fstpp(t1)) = true).
apply Pos.ltb_nlt in HLF.
apply Pos.le_nlt in HLF.
apply Pos.lt_eq_cases in HLF.
elim HLF.
intro HLF2.
apply Pos.eqb_neq in HF.
rewrite HLF2 in HF.

*****
HLF2 : Logic.eq (fstpp t2) (fstpp t1)
HLF : or (Pos.lt (fstpp t2) (fstpp t1)) (Logic.eq (fstpp t2) (fstpp t1))
HF : not (Logic.eq (fstpp t1) (fstpp t1))
t1,t2 : True
*****
Logic.eq (Pos.ltb (fstpp t2) (fstpp t1)) true
+++++
intuition.
-----
Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).
Proof.
intros t1 t2.
case_eq (Pos.eqb (fstpp(t1)) (fstpp(t2))).
intro HF.
case_eq (Pos.ltb (fstpp(t1)) (fstpp(t2))).
intro HLF.
assert (HLF2 : Pos.ltb (fstpp(t2)) (fstpp(t1)) = true).

*****
HLF2 : Logic.eq (Pos.ltb (fstpp t2) (fstpp t1)) true
HLF : Logic.eq (Pos.ltb (fstpp t1) (fstpp t2)) false
HF : Logic.eq (Pos.eqb (fstpp t1) (fstpp t2)) false
t1,t2 : True
*****
CompSpec eq lt t1 t2 (compare t1 t2)
+++++
assert (HC : compare t1 t2 = Gt).
-----
Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).
Proof.
intros t1 t2.
case_eq (Pos.eqb (fstpp(t1)) (fstpp(t2))).
intro HF.
case_eq (Pos.ltb (fstpp(t1)) (fstpp(t2))).
intro HLF.
assert (HLF2 : Pos.ltb (fstpp(t2)) (fstpp(t1)) = true).
assert (HC : compare t1 t2 = Gt).

*****
HLF2 : Logic.eq (Pos.ltb (fstpp t2) (fstpp t1)) true
HLF : Logic.eq (Pos.ltb (fstpp t1) (fstpp t2)) false
HF : Logic.eq (Pos.eqb (fstpp t1) (fstpp t2)) false
t1,t2 : True
*****
Logic.eq (compare t1 t2) Gt
+++++
unfold compare.
-----
Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).
Proof.
intros t1 t2.
case_eq (Pos.eqb (fstpp(t1)) (fstpp(t2))).
intro HF.
case_eq (Pos.ltb (fstpp(t1)) (fstpp(t2))).
intro HLF.
assert (HLF2 : Pos.ltb (fstpp(t2)) (fstpp(t1)) = true).
assert (HC : compare t1 t2 = Gt).
unfold compare.

*****
HLF2 : Logic.eq (Pos.ltb (fstpp t2) (fstpp t1)) true
HLF : Logic.eq (Pos.ltb (fstpp t1) (fstpp t2)) false
HF : Logic.eq (Pos.eqb (fstpp t1) (fstpp t2)) false
t1,t2 : True
*****
Logic.eq match Pos.compare (fstpp t1) (fstpp t2) with | Eq => Pos.compare (sndpp t1) (sndpp t2) | Lt => Lt | Gt => Gt end Gt
+++++
assert (HCF : Pos.compare (fstpp(t1)) (fstpp(t2)) = Gt).
-----
Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).
Proof.
intros t1 t2.
case_eq (Pos.eqb (fstpp(t1)) (fstpp(t2))).
intro HF.
case_eq (Pos.ltb (fstpp(t1)) (fstpp(t2))).
intro HLF.
assert (HLF2 : Pos.ltb (fstpp(t2)) (fstpp(t1)) = true).
assert (HC : compare t1 t2 = Gt).
unfold compare.
assert (HCF : Pos.compare (fstpp(t1)) (fstpp(t2)) = Gt).

*****
HLF2 : Logic.eq (Pos.ltb (fstpp t2) (fstpp t1)) true
HLF : Logic.eq (Pos.ltb (fstpp t1) (fstpp t2)) false
HF : Logic.eq (Pos.eqb (fstpp t1) (fstpp t2)) false
t1,t2 : True
*****
Logic.eq (Pos.compare (fstpp t1) (fstpp t2)) Gt
+++++
unfold Pos.compare.
-----
Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).
Proof.
intros t1 t2.
case_eq (Pos.eqb (fstpp(t1)) (fstpp(t2))).
intro HF.
case_eq (Pos.ltb (fstpp(t1)) (fstpp(t2))).
intro HLF.
assert (HLF2 : Pos.ltb (fstpp(t2)) (fstpp(t1)) = true).
assert (HC : compare t1 t2 = Gt).
unfold compare.
assert (HCF : Pos.compare (fstpp(t1)) (fstpp(t2)) = Gt).
unfold Pos.compare.

*****
HLF2 : Logic.eq (Pos.ltb (fstpp t2) (fstpp t1)) true
HLF : Logic.eq (Pos.ltb (fstpp t1) (fstpp t2)) false
HF : Logic.eq (Pos.eqb (fstpp t1) (fstpp t2)) false
t1,t2 : True
*****
Logic.eq (Pos.compare_cont Eq (fstpp t1) (fstpp t2)) Gt
+++++
apply Pos.ltb_lt in HLF2.
-----
Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).
Proof.
intros t1 t2.
case_eq (Pos.eqb (fstpp(t1)) (fstpp(t2))).
intro HF.
case_eq (Pos.ltb (fstpp(t1)) (fstpp(t2))).
intro HLF.
assert (HLF2 : Pos.ltb (fstpp(t2)) (fstpp(t1)) = true).
assert (HC : compare t1 t2 = Gt).
unfold compare.
assert (HCF : Pos.compare (fstpp(t1)) (fstpp(t2)) = Gt).
unfold Pos.compare.
apply Pos.ltb_lt in HLF2.

*****
HLF2 : Pos.lt (fstpp t2) (fstpp t1)
HLF : Logic.eq (Pos.ltb (fstpp t1) (fstpp t2)) false
HF : Logic.eq (Pos.eqb (fstpp t1) (fstpp t2)) false
t1,t2 : True
*****
Logic.eq (Pos.compare_cont Eq (fstpp t1) (fstpp t2)) Gt
+++++
apply Pnat.nat_of_P_gt_Gt_compare_complement_morphism.
-----
Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).
Proof.
intros t1 t2.
case_eq (Pos.eqb (fstpp(t1)) (fstpp(t2))).
intro HF.
case_eq (Pos.ltb (fstpp(t1)) (fstpp(t2))).
intro HLF.
assert (HLF2 : Pos.ltb (fstpp(t2)) (fstpp(t1)) = true).
assert (HC : compare t1 t2 = Gt).
unfold compare.
assert (HCF : Pos.compare (fstpp(t1)) (fstpp(t2)) = Gt).
unfold Pos.compare.
apply Pos.ltb_lt in HLF2.
apply Pnat.nat_of_P_gt_Gt_compare_complement_morphism.

*****
HLF2 : Pos.lt (fstpp t2) (fstpp t1)
HLF : Logic.eq (Pos.ltb (fstpp t1) (fstpp t2)) false
HF : Logic.eq (Pos.eqb (fstpp t1) (fstpp t2)) false
t1,t2 : True
*****
gt (Pos.to_nat (fstpp t1)) (Pos.to_nat (fstpp t2))
+++++
apply Pnat.Pos2Nat.inj_gt.
-----
Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).
Proof.
intros t1 t2.
case_eq (Pos.eqb (fstpp(t1)) (fstpp(t2))).
intro HF.
case_eq (Pos.ltb (fstpp(t1)) (fstpp(t2))).
intro HLF.
assert (HLF2 : Pos.ltb (fstpp(t2)) (fstpp(t1)) = true).
assert (HC : compare t1 t2 = Gt).
unfold compare.
assert (HCF : Pos.compare (fstpp(t1)) (fstpp(t2)) = Gt).
unfold Pos.compare.
apply Pos.ltb_lt in HLF2.
apply Pnat.nat_of_P_gt_Gt_compare_complement_morphism.
apply Pnat.Pos2Nat.inj_gt.

*****
HLF2 : Pos.lt (fstpp t2) (fstpp t1)
HLF : Logic.eq (Pos.ltb (fstpp t1) (fstpp t2)) false
HF : Logic.eq (Pos.eqb (fstpp t1) (fstpp t2)) false
t1,t2 : True
*****
Pos.gt (fstpp t1) (fstpp t2)
+++++
apply Pos.gt_lt_iff.
-----
Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).
Proof.
intros t1 t2.
case_eq (Pos.eqb (fstpp(t1)) (fstpp(t2))).
intro HF.
case_eq (Pos.ltb (fstpp(t1)) (fstpp(t2))).
intro HLF.
assert (HLF2 : Pos.ltb (fstpp(t2)) (fstpp(t1)) = true).
assert (HC : compare t1 t2 = Gt).
unfold compare.
assert (HCF : Pos.compare (fstpp(t1)) (fstpp(t2)) = Gt).
unfold Pos.compare.
apply Pos.ltb_lt in HLF2.
apply Pnat.nat_of_P_gt_Gt_compare_complement_morphism.
apply Pnat.Pos2Nat.inj_gt.
apply Pos.gt_lt_iff.

*****
HLF2 : Pos.lt (fstpp t2) (fstpp t1)
HLF : Logic.eq (Pos.ltb (fstpp t1) (fstpp t2)) false
HF : Logic.eq (Pos.eqb (fstpp t1) (fstpp t2)) false
t1,t2 : True
*****
Pos.lt (fstpp t2) (fstpp t1)
+++++
assumption.
-----
Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).
Proof.
intros t1 t2.
case_eq (Pos.eqb (fstpp(t1)) (fstpp(t2))).
intro HF.
case_eq (Pos.ltb (fstpp(t1)) (fstpp(t2))).
intro HLF.
assert (HLF2 : Pos.ltb (fstpp(t2)) (fstpp(t1)) = true).
assert (HC : compare t1 t2 = Gt).
unfold compare.
assert (HCF : Pos.compare (fstpp(t1)) (fstpp(t2)) = Gt).

*****
HCF : Logic.eq (Pos.compare (fstpp t1) (fstpp t2)) Gt
HLF2 : Logic.eq (Pos.ltb (fstpp t2) (fstpp t1)) true
HLF : Logic.eq (Pos.ltb (fstpp t1) (fstpp t2)) false
HF : Logic.eq (Pos.eqb (fstpp t1) (fstpp t2)) false
t1,t2 : True
*****
Logic.eq match Pos.compare (fstpp t1) (fstpp t2) with | Eq => Pos.compare (sndpp t1) (sndpp t2) | Lt => Lt | Gt => Gt end Gt
+++++
rewrite HCF.
-----
Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).
Proof.
intros t1 t2.
case_eq (Pos.eqb (fstpp(t1)) (fstpp(t2))).
intro HF.
case_eq (Pos.ltb (fstpp(t1)) (fstpp(t2))).
intro HLF.
assert (HLF2 : Pos.ltb (fstpp(t2)) (fstpp(t1)) = true).
assert (HC : compare t1 t2 = Gt).
unfold compare.
assert (HCF : Pos.compare (fstpp(t1)) (fstpp(t2)) = Gt).
rewrite HCF.

*****
HCF : Logic.eq (Pos.compare (fstpp t1) (fstpp t2)) Gt
HLF2 : Logic.eq (Pos.ltb (fstpp t2) (fstpp t1)) true
HLF : Logic.eq (Pos.ltb (fstpp t1) (fstpp t2)) false
HF : Logic.eq (Pos.eqb (fstpp t1) (fstpp t2)) false
t1,t2 : True
*****
Logic.eq Gt Gt
+++++
intuition.
-----
Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).
Proof.
intros t1 t2.
case_eq (Pos.eqb (fstpp(t1)) (fstpp(t2))).
intro HF.
case_eq (Pos.ltb (fstpp(t1)) (fstpp(t2))).
intro HLF.
assert (HLF2 : Pos.ltb (fstpp(t2)) (fstpp(t1)) = true).
assert (HC : compare t1 t2 = Gt).

*****
HC : Logic.eq (compare t1 t2) Gt
HLF2 : Logic.eq (Pos.ltb (fstpp t2) (fstpp t1)) true
HLF : Logic.eq (Pos.ltb (fstpp t1) (fstpp t2)) false
HF : Logic.eq (Pos.eqb (fstpp t1) (fstpp t2)) false
t1,t2 : True
*****
CompSpec eq lt t1 t2 (compare t1 t2)
+++++
rewrite HC.
-----
Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).
Proof.
intros t1 t2.
case_eq (Pos.eqb (fstpp(t1)) (fstpp(t2))).
intro HF.
case_eq (Pos.ltb (fstpp(t1)) (fstpp(t2))).
intro HLF.
assert (HLF2 : Pos.ltb (fstpp(t2)) (fstpp(t1)) = true).
assert (HC : compare t1 t2 = Gt).
rewrite HC.

*****
HC : Logic.eq (compare t1 t2) Gt
HLF2 : Logic.eq (Pos.ltb (fstpp t2) (fstpp t1)) true
HLF : Logic.eq (Pos.ltb (fstpp t1) (fstpp t2)) false
HF : Logic.eq (Pos.eqb (fstpp t1) (fstpp t2)) false
t1,t2 : True
*****
CompSpec eq lt t1 t2 Gt
+++++
apply CompGt.
-----
Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).
Proof.
intros t1 t2.
case_eq (Pos.eqb (fstpp(t1)) (fstpp(t2))).
intro HF.
case_eq (Pos.ltb (fstpp(t1)) (fstpp(t2))).
intro HLF.
assert (HLF2 : Pos.ltb (fstpp(t2)) (fstpp(t1)) = true).
assert (HC : compare t1 t2 = Gt).
rewrite HC.
apply CompGt.

*****
HC : Logic.eq (compare t1 t2) Gt
HLF2 : Logic.eq (Pos.ltb (fstpp t2) (fstpp t1)) true
HLF : Logic.eq (Pos.ltb (fstpp t1) (fstpp t2)) false
HF : Logic.eq (Pos.eqb (fstpp t1) (fstpp t2)) false
t1,t2 : True
*****
lt t2 t1
+++++
unfold lt.
-----
Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).
Proof.
intros t1 t2.
case_eq (Pos.eqb (fstpp(t1)) (fstpp(t2))).
intro HF.
case_eq (Pos.ltb (fstpp(t1)) (fstpp(t2))).
intro HLF.
assert (HLF2 : Pos.ltb (fstpp(t2)) (fstpp(t1)) = true).
assert (HC : compare t1 t2 = Gt).
rewrite HC.
apply CompGt.
unfold lt.

*****
HC : Logic.eq (compare t1 t2) Gt
HLF2 : Logic.eq (Pos.ltb (fstpp t2) (fstpp t1)) true
HLF : Logic.eq (Pos.ltb (fstpp t1) (fstpp t2)) false
HF : Logic.eq (Pos.eqb (fstpp t1) (fstpp t2)) false
t1,t2 : True
*****
if Pos.eqb (fstpp t2) (fstpp t1) then Pos.lt (sndpp t2) (sndpp t1) else Pos.lt (fstpp t2) (fstpp t1)
+++++
rewrite Pos.eqb_sym in HF.
-----
Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).
Proof.
intros t1 t2.
case_eq (Pos.eqb (fstpp(t1)) (fstpp(t2))).
intro HF.
case_eq (Pos.ltb (fstpp(t1)) (fstpp(t2))).
intro HLF.
assert (HLF2 : Pos.ltb (fstpp(t2)) (fstpp(t1)) = true).
assert (HC : compare t1 t2 = Gt).
rewrite HC.
apply CompGt.
unfold lt.
rewrite Pos.eqb_sym in HF.

*****
HC : Logic.eq (compare t1 t2) Gt
HLF2 : Logic.eq (Pos.ltb (fstpp t2) (fstpp t1)) true
HLF : Logic.eq (Pos.ltb (fstpp t1) (fstpp t2)) false
HF : Logic.eq (Pos.eqb (fstpp t2) (fstpp t1)) false
t1,t2 : True
*****
if Pos.eqb (fstpp t2) (fstpp t1) then Pos.lt (sndpp t2) (sndpp t1) else Pos.lt (fstpp t2) (fstpp t1)
+++++
rewrite HF.
-----
Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).
Proof.
intros t1 t2.
case_eq (Pos.eqb (fstpp(t1)) (fstpp(t2))).
intro HF.
case_eq (Pos.ltb (fstpp(t1)) (fstpp(t2))).
intro HLF.
assert (HLF2 : Pos.ltb (fstpp(t2)) (fstpp(t1)) = true).
assert (HC : compare t1 t2 = Gt).
rewrite HC.
apply CompGt.
unfold lt.
rewrite Pos.eqb_sym in HF.
rewrite HF.

*****
HC : Logic.eq (compare t1 t2) Gt
HLF2 : Logic.eq (Pos.ltb (fstpp t2) (fstpp t1)) true
HLF : Logic.eq (Pos.ltb (fstpp t1) (fstpp t2)) false
HF : Logic.eq (Pos.eqb (fstpp t2) (fstpp t1)) false
t1,t2 : True
*****
Pos.lt (fstpp t2) (fstpp t1)
+++++
apply Pos.ltb_lt in HLF2.
-----
Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).
Proof.
intros t1 t2.
case_eq (Pos.eqb (fstpp(t1)) (fstpp(t2))).
intro HF.
case_eq (Pos.ltb (fstpp(t1)) (fstpp(t2))).
intro HLF.
assert (HLF2 : Pos.ltb (fstpp(t2)) (fstpp(t1)) = true).
assert (HC : compare t1 t2 = Gt).
rewrite HC.
apply CompGt.
unfold lt.
rewrite Pos.eqb_sym in HF.
rewrite HF.
apply Pos.ltb_lt in HLF2.

*****
HC : Logic.eq (compare t1 t2) Gt
HLF2 : Pos.lt (fstpp t2) (fstpp t1)
HLF : Logic.eq (Pos.ltb (fstpp t1) (fstpp t2)) false
HF : Logic.eq (Pos.eqb (fstpp t2) (fstpp t1)) false
t1,t2 : True
*****
Pos.lt (fstpp t2) (fstpp t1)
+++++
assumption.
-----
Lemma compare_spec : forall t1 t2, CompSpec eq lt t1 t2 (compare t1 t2).
Proof.
intros t1 t2.
case_eq (Pos.eqb (fstpp(t1)) (fstpp(t2))).

*****

*****

+++++
Qed.
-----
End SetOfPairsOfPositiveOrderedType.
-----
Module SP := MSetList.Make SetOfPairsOfPositiveOrderedType.
-----
Module PosOrder <: TotalLeBool.
-----
Definition t := positive.
-----
Definition leb := Pos.leb.
-----
Lemma leb_total : forall p1 p2,\n    leb p1 p2 = true \/ leb p2 p1 = true.
-----
Lemma leb_total : forall p1 p2, leb p1 p2 = true \\/ leb p2 p1 = true.

*****

*****
forall p1 p2 : positive, or (eq (leb p1 p2) true) (eq (leb p2 p1) true)
+++++
Proof.
-----
Lemma leb_total : forall p1 p2, leb p1 p2 = true \\/ leb p2 p1 = true.
Proof.

*****

*****
forall p1 p2 : positive, or (eq (leb p1 p2) true) (eq (leb p2 p1) true)
+++++
intros.
-----
Lemma leb_total : forall p1 p2, leb p1 p2 = true \\/ leb p2 p1 = true.
Proof.
intros.

*****
p1,p2 : positive
*****
or (eq (leb p1 p2) true) (eq (leb p2 p1) true)
+++++
do 2 (rewrite Pos.leb_le).
-----
Lemma leb_total : forall p1 p2, leb p1 p2 = true \\/ leb p2 p1 = true.
Proof.
intros.
do 2 (rewrite Pos.leb_le).

*****
p1,p2 : positive
*****
or (Pos.le p1 p2) (Pos.le p2 p1)
+++++
do 2 (rewrite Pos.le_lteq).
-----
Lemma leb_total : forall p1 p2, leb p1 p2 = true \\/ leb p2 p1 = true.
Proof.
intros.
do 2 (rewrite Pos.leb_le).
do 2 (rewrite Pos.le_lteq).

*****
p1,p2 : positive
*****
or (or (Pos.lt p1 p2) (eq p1 p2)) (or (Pos.lt p2 p1) (eq p2 p1))
+++++
assert (HElim := Pos.lt_total p1 p2).
-----
Lemma leb_total : forall p1 p2, leb p1 p2 = true \\/ leb p2 p1 = true.
Proof.
intros.
do 2 (rewrite Pos.leb_le).
do 2 (rewrite Pos.le_lteq).
assert (HElim := Pos.lt_total p1 p2).

*****
HElim : or (Pos.lt p1 p2) (or (eq p1 p2) (Pos.lt p2 p1))
p1,p2 : positive
*****
or (or (Pos.lt p1 p2) (eq p1 p2)) (or (Pos.lt p2 p1) (eq p2 p1))
+++++
elim HElim.
-----
Lemma leb_total : forall p1 p2, leb p1 p2 = true \\/ leb p2 p1 = true.
Proof.
intros.
do 2 (rewrite Pos.leb_le).
do 2 (rewrite Pos.le_lteq).
assert (HElim := Pos.lt_total p1 p2).
elim HElim.

*****
HElim : or (Pos.lt p1 p2) (or (eq p1 p2) (Pos.lt p2 p1))
p1,p2 : positive
*****
forall _ : Pos.lt p1 p2, or (or (Pos.lt p1 p2) (eq p1 p2)) (or (Pos.lt p2 p1) (eq p2 p1))
+++++
clear HElim.
-----
Lemma leb_total : forall p1 p2, leb p1 p2 = true \\/ leb p2 p1 = true.
Proof.
intros.
do 2 (rewrite Pos.leb_le).
do 2 (rewrite Pos.le_lteq).
assert (HElim := Pos.lt_total p1 p2).
elim HElim.
clear HElim.

*****
p1,p2 : positive
*****
forall _ : Pos.lt p1 p2, or (or (Pos.lt p1 p2) (eq p1 p2)) (or (Pos.lt p2 p1) (eq p2 p1))
+++++
intro HElim.
-----
Lemma leb_total : forall p1 p2, leb p1 p2 = true \\/ leb p2 p1 = true.
Proof.
intros.
do 2 (rewrite Pos.leb_le).
do 2 (rewrite Pos.le_lteq).
assert (HElim := Pos.lt_total p1 p2).
elim HElim.
clear HElim.
intro HElim.

*****
HElim : Pos.lt p1 p2
p1,p2 : positive
*****
or (or (Pos.lt p1 p2) (eq p1 p2)) (or (Pos.lt p2 p1) (eq p2 p1))
+++++
left.
-----
Lemma leb_total : forall p1 p2, leb p1 p2 = true \\/ leb p2 p1 = true.
Proof.
intros.
do 2 (rewrite Pos.leb_le).
do 2 (rewrite Pos.le_lteq).
assert (HElim := Pos.lt_total p1 p2).
elim HElim.
clear HElim.
intro HElim.
left.

*****
HElim : Pos.lt p1 p2
p1,p2 : positive
*****
or (Pos.lt p1 p2) (eq p1 p2)
+++++
left.
-----
Lemma leb_total : forall p1 p2, leb p1 p2 = true \\/ leb p2 p1 = true.
Proof.
intros.
do 2 (rewrite Pos.leb_le).
do 2 (rewrite Pos.le_lteq).
assert (HElim := Pos.lt_total p1 p2).
elim HElim.
clear HElim.
intro HElim.
left.
left.

*****
HElim : Pos.lt p1 p2
p1,p2 : positive
*****
Pos.lt p1 p2
+++++
assumption.
-----
Lemma leb_total : forall p1 p2, leb p1 p2 = true \\/ leb p2 p1 = true.
Proof.
intros.
do 2 (rewrite Pos.leb_le).
do 2 (rewrite Pos.le_lteq).
assert (HElim := Pos.lt_total p1 p2).
elim HElim.

*****
HElim : or (Pos.lt p1 p2) (or (eq p1 p2) (Pos.lt p2 p1))
p1,p2 : positive
*****
forall _ : or (eq p1 p2) (Pos.lt p2 p1), or (or (Pos.lt p1 p2) (eq p1 p2)) (or (Pos.lt p2 p1) (eq p2 p1))
+++++
clear HElim.
-----
Lemma leb_total : forall p1 p2, leb p1 p2 = true \\/ leb p2 p1 = true.
Proof.
intros.
do 2 (rewrite Pos.leb_le).
do 2 (rewrite Pos.le_lteq).
assert (HElim := Pos.lt_total p1 p2).
elim HElim.
clear HElim.

*****
p1,p2 : positive
*****
forall _ : or (eq p1 p2) (Pos.lt p2 p1), or (or (Pos.lt p1 p2) (eq p1 p2)) (or (Pos.lt p2 p1) (eq p2 p1))
+++++
intro HElim.
-----
Lemma leb_total : forall p1 p2, leb p1 p2 = true \\/ leb p2 p1 = true.
Proof.
intros.
do 2 (rewrite Pos.leb_le).
do 2 (rewrite Pos.le_lteq).
assert (HElim := Pos.lt_total p1 p2).
elim HElim.
clear HElim.
intro HElim.

*****
HElim : or (eq p1 p2) (Pos.lt p2 p1)
p1,p2 : positive
*****
or (or (Pos.lt p1 p2) (eq p1 p2)) (or (Pos.lt p2 p1) (eq p2 p1))
+++++
elim HElim.
-----
Lemma leb_total : forall p1 p2, leb p1 p2 = true \\/ leb p2 p1 = true.
Proof.
intros.
do 2 (rewrite Pos.leb_le).
do 2 (rewrite Pos.le_lteq).
assert (HElim := Pos.lt_total p1 p2).
elim HElim.
clear HElim.
intro HElim.
elim HElim.

*****
HElim : or (eq p1 p2) (Pos.lt p2 p1)
p1,p2 : positive
*****
forall _ : eq p1 p2, or (or (Pos.lt p1 p2) (eq p1 p2)) (or (Pos.lt p2 p1) (eq p2 p1))
+++++
clear HElim.
-----
Lemma leb_total : forall p1 p2, leb p1 p2 = true \\/ leb p2 p1 = true.
Proof.
intros.
do 2 (rewrite Pos.leb_le).
do 2 (rewrite Pos.le_lteq).
assert (HElim := Pos.lt_total p1 p2).
elim HElim.
clear HElim.
intro HElim.
elim HElim.
clear HElim.

*****
p1,p2 : positive
*****
forall _ : eq p1 p2, or (or (Pos.lt p1 p2) (eq p1 p2)) (or (Pos.lt p2 p1) (eq p2 p1))
+++++
intro HElim.
-----
Lemma leb_total : forall p1 p2, leb p1 p2 = true \\/ leb p2 p1 = true.
Proof.
intros.
do 2 (rewrite Pos.leb_le).
do 2 (rewrite Pos.le_lteq).
assert (HElim := Pos.lt_total p1 p2).
elim HElim.
clear HElim.
intro HElim.
elim HElim.
clear HElim.
intro HElim.

*****
HElim : eq p1 p2
p1,p2 : positive
*****
or (or (Pos.lt p1 p2) (eq p1 p2)) (or (Pos.lt p2 p1) (eq p2 p1))
+++++
left.
-----
Lemma leb_total : forall p1 p2, leb p1 p2 = true \\/ leb p2 p1 = true.
Proof.
intros.
do 2 (rewrite Pos.leb_le).
do 2 (rewrite Pos.le_lteq).
assert (HElim := Pos.lt_total p1 p2).
elim HElim.
clear HElim.
intro HElim.
elim HElim.
clear HElim.
intro HElim.
left.

*****
HElim : eq p1 p2
p1,p2 : positive
*****
or (Pos.lt p1 p2) (eq p1 p2)
+++++
right.
-----
Lemma leb_total : forall p1 p2, leb p1 p2 = true \\/ leb p2 p1 = true.
Proof.
intros.
do 2 (rewrite Pos.leb_le).
do 2 (rewrite Pos.le_lteq).
assert (HElim := Pos.lt_total p1 p2).
elim HElim.
clear HElim.
intro HElim.
elim HElim.
clear HElim.
intro HElim.
left.
right.

*****
HElim : eq p1 p2
p1,p2 : positive
*****
eq p1 p2
+++++
assumption.
-----
Lemma leb_total : forall p1 p2, leb p1 p2 = true \\/ leb p2 p1 = true.
Proof.
intros.
do 2 (rewrite Pos.leb_le).
do 2 (rewrite Pos.le_lteq).
assert (HElim := Pos.lt_total p1 p2).
elim HElim.
clear HElim.
intro HElim.
elim HElim.

*****
HElim : or (eq p1 p2) (Pos.lt p2 p1)
p1,p2 : positive
*****
forall _ : Pos.lt p2 p1, or (or (Pos.lt p1 p2) (eq p1 p2)) (or (Pos.lt p2 p1) (eq p2 p1))
+++++
clear HElim.
-----
Lemma leb_total : forall p1 p2, leb p1 p2 = true \\/ leb p2 p1 = true.
Proof.
intros.
do 2 (rewrite Pos.leb_le).
do 2 (rewrite Pos.le_lteq).
assert (HElim := Pos.lt_total p1 p2).
elim HElim.
clear HElim.
intro HElim.
elim HElim.
clear HElim.

*****
p1,p2 : positive
*****
forall _ : Pos.lt p2 p1, or (or (Pos.lt p1 p2) (eq p1 p2)) (or (Pos.lt p2 p1) (eq p2 p1))
+++++
intro HElim.
-----
Lemma leb_total : forall p1 p2, leb p1 p2 = true \\/ leb p2 p1 = true.
Proof.
intros.
do 2 (rewrite Pos.leb_le).
do 2 (rewrite Pos.le_lteq).
assert (HElim := Pos.lt_total p1 p2).
elim HElim.
clear HElim.
intro HElim.
elim HElim.
clear HElim.
intro HElim.

*****
HElim : Pos.lt p2 p1
p1,p2 : positive
*****
or (or (Pos.lt p1 p2) (eq p1 p2)) (or (Pos.lt p2 p1) (eq p2 p1))
+++++
right.
-----
Lemma leb_total : forall p1 p2, leb p1 p2 = true \\/ leb p2 p1 = true.
Proof.
intros.
do 2 (rewrite Pos.leb_le).
do 2 (rewrite Pos.le_lteq).
assert (HElim := Pos.lt_total p1 p2).
elim HElim.
clear HElim.
intro HElim.
elim HElim.
clear HElim.
intro HElim.
right.

*****
HElim : Pos.lt p2 p1
p1,p2 : positive
*****
or (Pos.lt p2 p1) (eq p2 p1)
+++++
left.
-----
Lemma leb_total : forall p1 p2, leb p1 p2 = true \\/ leb p2 p1 = true.
Proof.
intros.
do 2 (rewrite Pos.leb_le).
do 2 (rewrite Pos.le_lteq).
assert (HElim := Pos.lt_total p1 p2).
elim HElim.
clear HElim.
intro HElim.
elim HElim.
clear HElim.
intro HElim.
right.
left.

*****
HElim : Pos.lt p2 p1
p1,p2 : positive
*****
Pos.lt p2 p1
+++++
assumption.
-----
Lemma leb_total : forall p1 p2, leb p1 p2 = true \\/ leb p2 p1 = true.
Proof.
intros.
do 2 (rewrite Pos.leb_le).
do 2 (rewrite Pos.le_lteq).
assert (HElim := Pos.lt_total p1 p2).
elim HElim.

*****

*****

+++++
Qed.
-----
Lemma leb_dec : forall p1 p2,\n    leb p1 p2 = true \/ leb p1 p2 = false.
-----
Lemma leb_dec : forall p1 p2, leb p1 p2 = true \\/ leb p1 p2 = false.

*****

*****
forall p1 p2 : positive, or (eq (leb p1 p2) true) (eq (leb p1 p2) false)
+++++
Proof.
-----
Lemma leb_dec : forall p1 p2, leb p1 p2 = true \\/ leb p1 p2 = false.
Proof.

*****

*****
forall p1 p2 : positive, or (eq (leb p1 p2) true) (eq (leb p1 p2) false)
+++++
intros.
-----
Lemma leb_dec : forall p1 p2, leb p1 p2 = true \\/ leb p1 p2 = false.
Proof.
intros.

*****
p1,p2 : positive
*****
or (eq (leb p1 p2) true) (eq (leb p1 p2) false)
+++++
elim Pos.eq_dec with p1 p2.
-----
Lemma leb_dec : forall p1 p2, leb p1 p2 = true \\/ leb p1 p2 = false.
Proof.
intros.
elim Pos.eq_dec with p1 p2.

*****
p1,p2 : positive
*****
forall _ : eq p1 p2, or (eq (leb p1 p2) true) (eq (leb p1 p2) false)
+++++
intro.
-----
Lemma leb_dec : forall p1 p2, leb p1 p2 = true \\/ leb p1 p2 = false.
Proof.
intros.
elim Pos.eq_dec with p1 p2.
intro.

*****
a : eq p1 p2
p1,p2 : positive
*****
or (eq (leb p1 p2) true) (eq (leb p1 p2) false)
+++++
subst.
-----
Lemma leb_dec : forall p1 p2, leb p1 p2 = true \\/ leb p1 p2 = false.
Proof.
intros.
elim Pos.eq_dec with p1 p2.
intro.
subst.

*****
p2 : positive
*****
or (eq (leb p2 p2) true) (eq (leb p2 p2) false)
+++++
left.
-----
Lemma leb_dec : forall p1 p2, leb p1 p2 = true \\/ leb p1 p2 = false.
Proof.
intros.
elim Pos.eq_dec with p1 p2.
intro.
subst.
left.

*****
p2 : positive
*****
eq (leb p2 p2) true
+++++
apply POrderedType.Positive_as_DT.leb_refl.
-----
Lemma leb_dec : forall p1 p2, leb p1 p2 = true \\/ leb p1 p2 = false.
Proof.
intros.
elim Pos.eq_dec with p1 p2.

*****
p1,p2 : positive
*****
forall _ : not (eq p1 p2), or (eq (leb p1 p2) true) (eq (leb p1 p2) false)
+++++
intro HNeq.
-----
Lemma leb_dec : forall p1 p2, leb p1 p2 = true \\/ leb p1 p2 = false.
Proof.
intros.
elim Pos.eq_dec with p1 p2.
intro HNeq.

*****
HNeq : not (eq p1 p2)
p1,p2 : positive
*****
or (eq (leb p1 p2) true) (eq (leb p1 p2) false)
+++++
elim leb_total with p1 p2.
-----
Lemma leb_dec : forall p1 p2, leb p1 p2 = true \\/ leb p1 p2 = false.
Proof.
intros.
elim Pos.eq_dec with p1 p2.
intro HNeq.
elim leb_total with p1 p2.

*****
HNeq : not (eq p1 p2)
p1,p2 : positive
*****
forall _ : eq (leb p1 p2) true, or (eq (leb p1 p2) true) (eq (leb p1 p2) false)
+++++
intro Hp1p2.
-----
Lemma leb_dec : forall p1 p2, leb p1 p2 = true \\/ leb p1 p2 = false.
Proof.
intros.
elim Pos.eq_dec with p1 p2.
intro HNeq.
elim leb_total with p1 p2.
intro Hp1p2.

*****
Hp1p2 : eq (leb p1 p2) true
HNeq : not (eq p1 p2)
p1,p2 : positive
*****
or (eq (leb p1 p2) true) (eq (leb p1 p2) false)
+++++
left.
-----
Lemma leb_dec : forall p1 p2, leb p1 p2 = true \\/ leb p1 p2 = false.
Proof.
intros.
elim Pos.eq_dec with p1 p2.
intro HNeq.
elim leb_total with p1 p2.
intro Hp1p2.
left.

*****
Hp1p2 : eq (leb p1 p2) true
HNeq : not (eq p1 p2)
p1,p2 : positive
*****
eq (leb p1 p2) true
+++++
assumption.
-----
Lemma leb_dec : forall p1 p2, leb p1 p2 = true \\/ leb p1 p2 = false.
Proof.
intros.
elim Pos.eq_dec with p1 p2.
intro HNeq.
elim leb_total with p1 p2.

*****
HNeq : not (eq p1 p2)
p1,p2 : positive
*****
forall _ : eq (leb p2 p1) true, or (eq (leb p1 p2) true) (eq (leb p1 p2) false)
+++++
intro Hp1p2.
-----
Lemma leb_dec : forall p1 p2, leb p1 p2 = true \\/ leb p1 p2 = false.
Proof.
intros.
elim Pos.eq_dec with p1 p2.
intro HNeq.
elim leb_total with p1 p2.
intro Hp1p2.

*****
Hp1p2 : eq (leb p2 p1) true
HNeq : not (eq p1 p2)
p1,p2 : positive
*****
or (eq (leb p1 p2) true) (eq (leb p1 p2) false)
+++++
right.
-----
Lemma leb_dec : forall p1 p2, leb p1 p2 = true \\/ leb p1 p2 = false.
Proof.
intros.
elim Pos.eq_dec with p1 p2.
intro HNeq.
elim leb_total with p1 p2.
intro Hp1p2.
right.

*****
Hp1p2 : eq (leb p2 p1) true
HNeq : not (eq p1 p2)
p1,p2 : positive
*****
eq (leb p1 p2) false
+++++
rewrite Positive_as_DT.leb_gt.
-----
Lemma leb_dec : forall p1 p2, leb p1 p2 = true \\/ leb p1 p2 = false.
Proof.
intros.
elim Pos.eq_dec with p1 p2.
intro HNeq.
elim leb_total with p1 p2.
intro Hp1p2.
right.
rewrite Positive_as_DT.leb_gt.

*****
Hp1p2 : eq (leb p2 p1) true
HNeq : not (eq p1 p2)
p1,p2 : positive
*****
Positive_as_DT.lt p2 p1
+++++
rewrite Positive_as_DT.leb_le in Hp1p2.
-----
Lemma leb_dec : forall p1 p2, leb p1 p2 = true \\/ leb p1 p2 = false.
Proof.
intros.
elim Pos.eq_dec with p1 p2.
intro HNeq.
elim leb_total with p1 p2.
intro Hp1p2.
right.
rewrite Positive_as_DT.leb_gt.
rewrite Positive_as_DT.leb_le in Hp1p2.

*****
Hp1p2 : Positive_as_DT.le p2 p1
HNeq : not (eq p1 p2)
p1,p2 : positive
*****
Positive_as_DT.lt p2 p1
+++++
rewrite Pos.lt_eq_cases in Hp1p2.
-----
Lemma leb_dec : forall p1 p2, leb p1 p2 = true \\/ leb p1 p2 = false.
Proof.
intros.
elim Pos.eq_dec with p1 p2.
intro HNeq.
elim leb_total with p1 p2.
intro Hp1p2.
right.
rewrite Positive_as_DT.leb_gt.
rewrite Positive_as_DT.leb_le in Hp1p2.
rewrite Pos.lt_eq_cases in Hp1p2.

*****
Hp1p2 : or (Pos.lt p2 p1) (eq p2 p1)
HNeq : not (eq p1 p2)
p1,p2 : positive
*****
Positive_as_DT.lt p2 p1
+++++
elim Hp1p2.
-----
Lemma leb_dec : forall p1 p2, leb p1 p2 = true \\/ leb p1 p2 = false.
Proof.
intros.
elim Pos.eq_dec with p1 p2.
intro HNeq.
elim leb_total with p1 p2.
intro Hp1p2.
right.
rewrite Positive_as_DT.leb_gt.
rewrite Positive_as_DT.leb_le in Hp1p2.
rewrite Pos.lt_eq_cases in Hp1p2.
elim Hp1p2.

*****
Hp1p2 : or (Pos.lt p2 p1) (eq p2 p1)
HNeq : not (eq p1 p2)
p1,p2 : positive
*****
forall _ : Pos.lt p2 p1, Positive_as_DT.lt p2 p1
+++++
intro.
-----
Lemma leb_dec : forall p1 p2, leb p1 p2 = true \\/ leb p1 p2 = false.
Proof.
intros.
elim Pos.eq_dec with p1 p2.
intro HNeq.
elim leb_total with p1 p2.
intro Hp1p2.
right.
rewrite Positive_as_DT.leb_gt.
rewrite Positive_as_DT.leb_le in Hp1p2.
rewrite Pos.lt_eq_cases in Hp1p2.
elim Hp1p2.
intro.

*****
H : Pos.lt p2 p1
Hp1p2 : or (Pos.lt p2 p1) (eq p2 p1)
HNeq : not (eq p1 p2)
p1,p2 : positive
*****
Positive_as_DT.lt p2 p1
+++++
assumption.
-----
Lemma leb_dec : forall p1 p2, leb p1 p2 = true \\/ leb p1 p2 = false.
Proof.
intros.
elim Pos.eq_dec with p1 p2.
intro HNeq.
elim leb_total with p1 p2.
intro Hp1p2.
right.
rewrite Positive_as_DT.leb_gt.
rewrite Positive_as_DT.leb_le in Hp1p2.
rewrite Pos.lt_eq_cases in Hp1p2.
elim Hp1p2.

*****
Hp1p2 : or (Pos.lt p2 p1) (eq p2 p1)
HNeq : not (eq p1 p2)
p1,p2 : positive
*****
forall _ : eq p2 p1, Positive_as_DT.lt p2 p1
+++++
intro.
-----
Lemma leb_dec : forall p1 p2, leb p1 p2 = true \\/ leb p1 p2 = false.
Proof.
intros.
elim Pos.eq_dec with p1 p2.
intro HNeq.
elim leb_total with p1 p2.
intro Hp1p2.
right.
rewrite Positive_as_DT.leb_gt.
rewrite Positive_as_DT.leb_le in Hp1p2.
rewrite Pos.lt_eq_cases in Hp1p2.
elim Hp1p2.
intro.

*****
H : eq p2 p1
Hp1p2 : or (Pos.lt p2 p1) (eq p2 p1)
HNeq : not (eq p1 p2)
p1,p2 : positive
*****
Positive_as_DT.lt p2 p1
+++++
subst.
-----
Lemma leb_dec : forall p1 p2, leb p1 p2 = true \\/ leb p1 p2 = false.
Proof.
intros.
elim Pos.eq_dec with p1 p2.
intro HNeq.
elim leb_total with p1 p2.
intro Hp1p2.
right.
rewrite Positive_as_DT.leb_gt.
rewrite Positive_as_DT.leb_le in Hp1p2.
rewrite Pos.lt_eq_cases in Hp1p2.
elim Hp1p2.
intro.
subst.

*****
HNeq : not (eq p1 p1)
Hp1p2 : or (Pos.lt p1 p1) (eq p1 p1)
p1 : positive
*****
Positive_as_DT.lt p1 p1
+++++
intuition.
-----
Lemma leb_dec : forall p1 p2, leb p1 p2 = true \\/ leb p1 p2 = false.
Proof.
intros.
elim Pos.eq_dec with p1 p2.

*****

*****

+++++
Qed.
-----
End PosOrder.
-----
Module Import PosSort := Sort PosOrder.
-----
Definition OCPAux {n : nat} (cp : cartesianPower positive (S (S n))) := (PosSort.sort (CPToList cp)).
-----
Lemma OCPALengthOK {n : nat} : forall (cp : cartesianPower positive (S (S n))), (length (OCPAux cp)) = (S (S n)).
-----
Lemma OCPALengthOK {n : nat} : forall (cp : cartesianPower positive (S (S n))), (length (OCPAux cp)) = (S (S n)).

*****
n : nat
*****
forall cp : cartesianPower positive (S (S n)), eq (length (OCPAux cp)) (S (S n))
+++++
Proof.
-----
Lemma OCPALengthOK {n : nat} : forall (cp : cartesianPower positive (S (S n))), (length (OCPAux cp)) = (S (S n)).
Proof.

*****
n : nat
*****
forall cp : cartesianPower positive (S (S n)), eq (length (OCPAux cp)) (S (S n))
+++++
intro cp.
-----
Lemma OCPALengthOK {n : nat} : forall (cp : cartesianPower positive (S (S n))), (length (OCPAux cp)) = (S (S n)).
Proof.
intro cp.

*****
cp : cartesianPower positive (S (S n))
n : nat
*****
eq (length (OCPAux cp)) (S (S n))
+++++
unfold OCPAux.
-----
Lemma OCPALengthOK {n : nat} : forall (cp : cartesianPower positive (S (S n))), (length (OCPAux cp)) = (S (S n)).
Proof.
intro cp.
unfold OCPAux.

*****
cp : cartesianPower positive (S (S n))
n : nat
*****
eq (length (sort (CPToList cp))) (S (S n))
+++++
assert (HPerm := Permuted_sort (CPToList cp)).
-----
Lemma OCPALengthOK {n : nat} : forall (cp : cartesianPower positive (S (S n))), (length (OCPAux cp)) = (S (S n)).
Proof.
intro cp.
unfold OCPAux.
assert (HPerm := Permuted_sort (CPToList cp)).

*****
HPerm : Permutation.Permutation (CPToList cp) (sort (CPToList cp))
cp : cartesianPower positive (S (S n))
n : nat
*****
eq (length (sort (CPToList cp))) (S (S n))
+++++
apply Permutation.Permutation_length in HPerm.
-----
Lemma OCPALengthOK {n : nat} : forall (cp : cartesianPower positive (S (S n))), (length (OCPAux cp)) = (S (S n)).
Proof.
intro cp.
unfold OCPAux.
assert (HPerm := Permuted_sort (CPToList cp)).
apply Permutation.Permutation_length in HPerm.

*****
HPerm : eq (length (CPToList cp)) (length (sort (CPToList cp)))
cp : cartesianPower positive (S (S n))
n : nat
*****
eq (length (sort (CPToList cp))) (S (S n))
+++++
rewrite <- HPerm.
-----
Lemma OCPALengthOK {n : nat} : forall (cp : cartesianPower positive (S (S n))), (length (OCPAux cp)) = (S (S n)).
Proof.
intro cp.
unfold OCPAux.
assert (HPerm := Permuted_sort (CPToList cp)).
apply Permutation.Permutation_length in HPerm.
rewrite <- HPerm.

*****
HPerm : eq (length (CPToList cp)) (length (sort (CPToList cp)))
cp : cartesianPower positive (S (S n))
n : nat
*****
eq (length (CPToList cp)) (S (S n))
+++++
apply eq_sym.
-----
Lemma OCPALengthOK {n : nat} : forall (cp : cartesianPower positive (S (S n))), (length (OCPAux cp)) = (S (S n)).
Proof.
intro cp.
unfold OCPAux.
assert (HPerm := Permuted_sort (CPToList cp)).
apply Permutation.Permutation_length in HPerm.
rewrite <- HPerm.
apply eq_sym.

*****
HPerm : eq (length (CPToList cp)) (length (sort (CPToList cp)))
cp : cartesianPower positive (S (S n))
n : nat
*****
eq (S (S n)) (length (CPToList cp))
+++++
apply lengthOfCPToList.
-----
Lemma OCPALengthOK {n : nat} : forall (cp : cartesianPower positive (S (S n))), (length (OCPAux cp)) = (S (S n)).
Proof.
intro cp.
unfold OCPAux.
assert (HPerm := Permuted_sort (CPToList cp)).
apply Permutation.Permutation_length in HPerm.
rewrite <- HPerm.
apply eq_sym.
apply lengthOfCPToList.

*****

*****

+++++
Defined.
-----
Lemma OCPSortedTl :\n  forall (l : list positive),\n  StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l ->\n  StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) (tl l).
-----
Lemma OCPSortedTl : forall (l : list positive), StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) (tl l).

*****

*****
forall (l : list positive) (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) l), StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) (tl l)
+++++
Proof.
-----
Lemma OCPSortedTl : forall (l : list positive), StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) (tl l).
Proof.

*****

*****
forall (l : list positive) (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) l), StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) (tl l)
+++++
intros l HSorted.
-----
Lemma OCPSortedTl : forall (l : list positive), StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) (tl l).
Proof.
intros l HSorted.

*****
HSorted : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) l
l : list positive
*****
StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) (tl l)
+++++
induction l.
-----
Lemma OCPSortedTl : forall (l : list positive), StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) (tl l).
Proof.
intros l HSorted.
induction l.

*****
HSorted : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) nil
*****
StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) (tl nil)
+++++
simpl.
-----
Lemma OCPSortedTl : forall (l : list positive), StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) (tl l).
Proof.
intros l HSorted.
induction l.
simpl.

*****
HSorted : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) nil
*****
StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) nil
+++++
apply SSorted_nil.
-----
Lemma OCPSortedTl : forall (l : list positive), StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) (tl l).
Proof.
intros l HSorted.
induction l.

*****
IHl : forall\n _ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) l,\nStronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) (tl l)
HSorted : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l)
l : list positive
a : positive
*****
StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) (tl (cons a l))
+++++
clear IHl.
-----
Lemma OCPSortedTl : forall (l : list positive), StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) (tl l).
Proof.
intros l HSorted.
induction l.
clear IHl.

*****
HSorted : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l)
l : list positive
a : positive
*****
StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) (tl (cons a l))
+++++
simpl.
-----
Lemma OCPSortedTl : forall (l : list positive), StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) (tl l).
Proof.
intros l HSorted.
induction l.
clear IHl.
simpl.

*****
HSorted : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l)
l : list positive
a : positive
*****
StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) l
+++++
apply StronglySorted_inv in HSorted.
-----
Lemma OCPSortedTl : forall (l : list positive), StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) (tl l).
Proof.
intros l HSorted.
induction l.
clear IHl.
simpl.
apply StronglySorted_inv in HSorted.

*****
HSorted : and (StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) l)\n (Forall (fun x0 : positive => is_true (Pos.leb a x0)) l)
l : list positive
a : positive
*****
StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) l
+++++
destruct HSorted as [HSorted Hhd].
-----
Lemma OCPSortedTl : forall (l : list positive), StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) (tl l).
Proof.
intros l HSorted.
induction l.
clear IHl.
simpl.
apply StronglySorted_inv in HSorted.
destruct HSorted as [HSorted Hhd].

*****
Hhd : Forall (fun x0 : positive => is_true (Pos.leb a x0)) l
HSorted : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) l
l : list positive
a : positive
*****
StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) l
+++++
assumption.
-----
Lemma OCPSortedTl : forall (l : list positive), StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) (tl l).
Proof.
intros l HSorted.
induction l.

*****

*****

+++++
Qed.
-----
Lemma PermSorted : forall (l l' : list positive),\n  Permutation.Permutation l l' ->\n  StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l ->\n  StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l' ->\n  l = l'.
-----
Lemma PermSorted : forall (l l' : list positive), Permutation.Permutation l l' -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l' -> l = l'.

*****

*****
forall (l l' : list positive) (_ : Permutation.Permutation l l') (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) l) (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) l'), eq l l'
+++++
Proof.
-----
Lemma PermSorted : forall (l l' : list positive), Permutation.Permutation l l' -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l' -> l = l'.
Proof.

*****

*****
forall (l l' : list positive) (_ : Permutation.Permutation l l') (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) l) (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) l'), eq l l'
+++++
intro l.
-----
Lemma PermSorted : forall (l l' : list positive), Permutation.Permutation l l' -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l' -> l = l'.
Proof.
intro l.

*****
l : list positive
*****
forall (l' : list positive) (_ : Permutation.Permutation l l') (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) l) (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) l'), eq l l'
+++++
induction l.
-----
Lemma PermSorted : forall (l l' : list positive), Permutation.Permutation l l' -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l' -> l = l'.
Proof.
intro l.
induction l.

*****

*****
forall (l' : list positive) (_ : Permutation.Permutation nil l') (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) nil) (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) l'), eq nil l'
+++++
intro l'.
-----
Lemma PermSorted : forall (l l' : list positive), Permutation.Permutation l l' -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l' -> l = l'.
Proof.
intro l.
induction l.
intro l'.

*****
l' : list positive
*****
forall (_ : Permutation.Permutation nil l') (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) nil) (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) l'), eq nil l'
+++++
induction l'.
-----
Lemma PermSorted : forall (l l' : list positive), Permutation.Permutation l l' -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l' -> l = l'.
Proof.
intro l.
induction l.
intro l'.
induction l'.

*****

*****
forall (_ : Permutation.Permutation nil nil) (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) nil) (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) nil), eq nil nil
+++++
reflexivity.
-----
Lemma PermSorted : forall (l l' : list positive), Permutation.Permutation l l' -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l' -> l = l'.
Proof.
intro l.
induction l.
intro l'.
induction l'.

*****
IHl' : forall (_ : Permutation.Permutation nil l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n nil)\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq nil l'
l' : list positive
a : positive
*****
forall (_ : Permutation.Permutation nil (cons a l')) (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) nil) (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) (cons a l')), eq nil (cons a l')
+++++
intro HPerm.
-----
Lemma PermSorted : forall (l l' : list positive), Permutation.Permutation l l' -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l' -> l = l'.
Proof.
intro l.
induction l.
intro l'.
induction l'.
intro HPerm.

*****
HPerm : Permutation.Permutation nil (cons a l')
IHl' : forall (_ : Permutation.Permutation nil l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n nil)\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq nil l'
l' : list positive
a : positive
*****
forall (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) nil) (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) (cons a l')), eq nil (cons a l')
+++++
apply Permutation.Permutation_nil_cons in HPerm.
-----
Lemma PermSorted : forall (l l' : list positive), Permutation.Permutation l l' -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l' -> l = l'.
Proof.
intro l.
induction l.
intro l'.
induction l'.
intro HPerm.
apply Permutation.Permutation_nil_cons in HPerm.

*****
HPerm : False
IHl' : forall (_ : Permutation.Permutation nil l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n nil)\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq nil l'
l' : list positive
a : positive
*****
forall (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) nil) (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) (cons a l')), eq nil (cons a l')
+++++
intuition.
-----
Lemma PermSorted : forall (l l' : list positive), Permutation.Permutation l l' -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l' -> l = l'.
Proof.
intro l.
induction l.

*****
IHl : forall (l' : list positive) (_ : Permutation.Permutation l l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) l)\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq l l'
l : list positive
a : positive
*****
forall (l' : list positive) (_ : Permutation.Permutation (cons a l) l') (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) (cons a l)) (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) l'), eq (cons a l) l'
+++++
intro l'.
-----
Lemma PermSorted : forall (l l' : list positive), Permutation.Permutation l l' -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l' -> l = l'.
Proof.
intro l.
induction l.
intro l'.

*****
l' : list positive
IHl : forall (l' : list positive) (_ : Permutation.Permutation l l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) l)\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq l l'
l : list positive
a : positive
*****
forall (_ : Permutation.Permutation (cons a l) l') (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) (cons a l)) (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) l'), eq (cons a l) l'
+++++
induction l'.
-----
Lemma PermSorted : forall (l l' : list positive), Permutation.Permutation l l' -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l' -> l = l'.
Proof.
intro l.
induction l.
intro l'.
induction l'.

*****
IHl : forall (l' : list positive) (_ : Permutation.Permutation l l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) l)\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq l l'
l : list positive
a : positive
*****
forall (_ : Permutation.Permutation (cons a l) nil) (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) (cons a l)) (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) nil), eq (cons a l) nil
+++++
intro HPerm.
-----
Lemma PermSorted : forall (l l' : list positive), Permutation.Permutation l l' -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l' -> l = l'.
Proof.
intro l.
induction l.
intro l'.
induction l'.
intro HPerm.

*****
HPerm : Permutation.Permutation (cons a l) nil
IHl : forall (l' : list positive) (_ : Permutation.Permutation l l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) l)\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq l l'
l : list positive
a : positive
*****
forall (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) (cons a l)) (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) nil), eq (cons a l) nil
+++++
apply Permutation.Permutation_sym in HPerm.
-----
Lemma PermSorted : forall (l l' : list positive), Permutation.Permutation l l' -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l' -> l = l'.
Proof.
intro l.
induction l.
intro l'.
induction l'.
intro HPerm.
apply Permutation.Permutation_sym in HPerm.

*****
HPerm : Permutation.Permutation nil (cons a l)
IHl : forall (l' : list positive) (_ : Permutation.Permutation l l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) l)\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq l l'
l : list positive
a : positive
*****
forall (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) (cons a l)) (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) nil), eq (cons a l) nil
+++++
apply Permutation.Permutation_nil_cons in HPerm.
-----
Lemma PermSorted : forall (l l' : list positive), Permutation.Permutation l l' -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l' -> l = l'.
Proof.
intro l.
induction l.
intro l'.
induction l'.
intro HPerm.
apply Permutation.Permutation_sym in HPerm.
apply Permutation.Permutation_nil_cons in HPerm.

*****
HPerm : False
IHl : forall (l' : list positive) (_ : Permutation.Permutation l l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) l)\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq l l'
l : list positive
a : positive
*****
forall (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) (cons a l)) (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) nil), eq (cons a l) nil
+++++
intuition.
-----
Lemma PermSorted : forall (l l' : list positive), Permutation.Permutation l l' -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l' -> l = l'.
Proof.
intro l.
induction l.
intro l'.
induction l'.

*****
IHl' : forall (_ : Permutation.Permutation (cons a l) l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l))\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq (cons a l) l'
l' : list positive
a0 : positive
IHl : forall (l' : list positive) (_ : Permutation.Permutation l l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) l)\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq l l'
l : list positive
a : positive
*****
forall (_ : Permutation.Permutation (cons a l) (cons a0 l')) (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) (cons a l)) (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) (cons a0 l')), eq (cons a l) (cons a0 l')
+++++
intros HPerm Hl Hl'.
-----
Lemma PermSorted : forall (l l' : list positive), Permutation.Permutation l l' -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l' -> l = l'.
Proof.
intro l.
induction l.
intro l'.
induction l'.
intros HPerm Hl Hl'.

*****
Hl' : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a0 l')
Hl : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l)
HPerm : Permutation.Permutation (cons a l) (cons a0 l')
IHl' : forall (_ : Permutation.Permutation (cons a l) l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l))\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq (cons a l) l'
l' : list positive
a0 : positive
IHl : forall (l' : list positive) (_ : Permutation.Permutation l l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) l)\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq l l'
l : list positive
a : positive
*****
eq (cons a l) (cons a0 l')
+++++
assert (HIna' : In a (a :: l)).
-----
Lemma PermSorted : forall (l l' : list positive), Permutation.Permutation l l' -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l' -> l = l'.
Proof.
intro l.
induction l.
intro l'.
induction l'.
intros HPerm Hl Hl'.
assert (HIna' : In a (a :: l)).

*****
Hl' : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a0 l')
Hl : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l)
HPerm : Permutation.Permutation (cons a l) (cons a0 l')
IHl' : forall (_ : Permutation.Permutation (cons a l) l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l))\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq (cons a l) l'
l' : list positive
a0 : positive
IHl : forall (l' : list positive) (_ : Permutation.Permutation l l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) l)\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq l l'
l : list positive
a : positive
*****
In a (cons a l)
+++++
apply in_eq.
-----
Lemma PermSorted : forall (l l' : list positive), Permutation.Permutation l l' -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l' -> l = l'.
Proof.
intro l.
induction l.
intro l'.
induction l'.
intros HPerm Hl Hl'.
assert (HIna' : In a (a :: l)).

*****
HIna' : In a (cons a l)
Hl' : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a0 l')
Hl : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l)
HPerm : Permutation.Permutation (cons a l) (cons a0 l')
IHl' : forall (_ : Permutation.Permutation (cons a l) l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l))\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq (cons a l) l'
l' : list positive
a0 : positive
IHl : forall (l' : list positive) (_ : Permutation.Permutation l l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) l)\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq l l'
l : list positive
a : positive
*****
eq (cons a l) (cons a0 l')
+++++
idtac.
-----
Lemma PermSorted : forall (l l' : list positive), Permutation.Permutation l l' -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l' -> l = l'.
Proof.
intro l.
induction l.
intro l'.
induction l'.
intros HPerm Hl Hl'.
assert (HIna' : In a (a :: l)).
idtac.

*****
HIna' : In a (cons a l)
Hl' : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a0 l')
Hl : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l)
HPerm : Permutation.Permutation (cons a l) (cons a0 l')
IHl' : forall (_ : Permutation.Permutation (cons a l) l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l))\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq (cons a l) l'
l' : list positive
a0 : positive
IHl : forall (l' : list positive) (_ : Permutation.Permutation l l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) l)\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq l l'
l : list positive
a : positive
*****
eq (cons a l) (cons a0 l')
+++++
assert (HIna : In a (a0 :: l')).
-----
Lemma PermSorted : forall (l l' : list positive), Permutation.Permutation l l' -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l' -> l = l'.
Proof.
intro l.
induction l.
intro l'.
induction l'.
intros HPerm Hl Hl'.
assert (HIna' : In a (a :: l)).
idtac.
assert (HIna : In a (a0 :: l')).

*****
HIna' : In a (cons a l)
Hl' : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a0 l')
Hl : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l)
HPerm : Permutation.Permutation (cons a l) (cons a0 l')
IHl' : forall (_ : Permutation.Permutation (cons a l) l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l))\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq (cons a l) l'
l' : list positive
a0 : positive
IHl : forall (l' : list positive) (_ : Permutation.Permutation l l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) l)\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq l l'
l : list positive
a : positive
*****
In a (cons a0 l')
+++++
apply Permutation.Permutation_in with (a :: l).
-----
Lemma PermSorted : forall (l l' : list positive), Permutation.Permutation l l' -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l' -> l = l'.
Proof.
intro l.
induction l.
intro l'.
induction l'.
intros HPerm Hl Hl'.
assert (HIna' : In a (a :: l)).
idtac.
assert (HIna : In a (a0 :: l')).
apply Permutation.Permutation_in with (a :: l).

*****
HIna' : In a (cons a l)
Hl' : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a0 l')
Hl : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l)
HPerm : Permutation.Permutation (cons a l) (cons a0 l')
IHl' : forall (_ : Permutation.Permutation (cons a l) l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l))\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq (cons a l) l'
l' : list positive
a0 : positive
IHl : forall (l' : list positive) (_ : Permutation.Permutation l l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) l)\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq l l'
l : list positive
a : positive
*****
Permutation.Permutation (cons a l) (cons a0 l')
+++++
assumption.
-----
Lemma PermSorted : forall (l l' : list positive), Permutation.Permutation l l' -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l' -> l = l'.
Proof.
intro l.
induction l.
intro l'.
induction l'.
intros HPerm Hl Hl'.
assert (HIna' : In a (a :: l)).
idtac.
assert (HIna : In a (a0 :: l')).
apply Permutation.Permutation_in with (a :: l).

*****
HIna' : In a (cons a l)
Hl' : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a0 l')
Hl : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l)
HPerm : Permutation.Permutation (cons a l) (cons a0 l')
IHl' : forall (_ : Permutation.Permutation (cons a l) l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l))\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq (cons a l) l'
l' : list positive
a0 : positive
IHl : forall (l' : list positive) (_ : Permutation.Permutation l l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) l)\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq l l'
l : list positive
a : positive
*****
In a (cons a l)
+++++
assumption.
-----
Lemma PermSorted : forall (l l' : list positive), Permutation.Permutation l l' -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l' -> l = l'.
Proof.
intro l.
induction l.
intro l'.
induction l'.
intros HPerm Hl Hl'.
assert (HIna' : In a (a :: l)).
idtac.
assert (HIna : In a (a0 :: l')).

*****
HIna : In a (cons a0 l')
HIna' : In a (cons a l)
Hl' : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a0 l')
Hl : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l)
HPerm : Permutation.Permutation (cons a l) (cons a0 l')
IHl' : forall (_ : Permutation.Permutation (cons a l) l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l))\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq (cons a l) l'
l' : list positive
a0 : positive
IHl : forall (l' : list positive) (_ : Permutation.Permutation l l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) l)\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq l l'
l : list positive
a : positive
*****
eq (cons a l) (cons a0 l')
+++++
idtac.
-----
Lemma PermSorted : forall (l l' : list positive), Permutation.Permutation l l' -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l' -> l = l'.
Proof.
intro l.
induction l.
intro l'.
induction l'.
intros HPerm Hl Hl'.
assert (HIna' : In a (a :: l)).
idtac.
assert (HIna : In a (a0 :: l')).
idtac.

*****
HIna : In a (cons a0 l')
HIna' : In a (cons a l)
Hl' : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a0 l')
Hl : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l)
HPerm : Permutation.Permutation (cons a l) (cons a0 l')
IHl' : forall (_ : Permutation.Permutation (cons a l) l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l))\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq (cons a l) l'
l' : list positive
a0 : positive
IHl : forall (l' : list positive) (_ : Permutation.Permutation l l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) l)\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq l l'
l : list positive
a : positive
*****
eq (cons a l) (cons a0 l')
+++++
assert (HIna0' : In a0 (a0 :: l')).
-----
Lemma PermSorted : forall (l l' : list positive), Permutation.Permutation l l' -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l' -> l = l'.
Proof.
intro l.
induction l.
intro l'.
induction l'.
intros HPerm Hl Hl'.
assert (HIna' : In a (a :: l)).
idtac.
assert (HIna : In a (a0 :: l')).
idtac.
assert (HIna0' : In a0 (a0 :: l')).

*****
HIna : In a (cons a0 l')
HIna' : In a (cons a l)
Hl' : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a0 l')
Hl : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l)
HPerm : Permutation.Permutation (cons a l) (cons a0 l')
IHl' : forall (_ : Permutation.Permutation (cons a l) l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l))\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq (cons a l) l'
l' : list positive
a0 : positive
IHl : forall (l' : list positive) (_ : Permutation.Permutation l l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) l)\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq l l'
l : list positive
a : positive
*****
In a0 (cons a0 l')
+++++
apply in_eq.
-----
Lemma PermSorted : forall (l l' : list positive), Permutation.Permutation l l' -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l' -> l = l'.
Proof.
intro l.
induction l.
intro l'.
induction l'.
intros HPerm Hl Hl'.
assert (HIna' : In a (a :: l)).
idtac.
assert (HIna : In a (a0 :: l')).
idtac.
assert (HIna0' : In a0 (a0 :: l')).

*****
HIna0' : In a0 (cons a0 l')
HIna : In a (cons a0 l')
HIna' : In a (cons a l)
Hl' : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a0 l')
Hl : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l)
HPerm : Permutation.Permutation (cons a l) (cons a0 l')
IHl' : forall (_ : Permutation.Permutation (cons a l) l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l))\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq (cons a l) l'
l' : list positive
a0 : positive
IHl : forall (l' : list positive) (_ : Permutation.Permutation l l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) l)\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq l l'
l : list positive
a : positive
*****
eq (cons a l) (cons a0 l')
+++++
idtac.
-----
Lemma PermSorted : forall (l l' : list positive), Permutation.Permutation l l' -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l' -> l = l'.
Proof.
intro l.
induction l.
intro l'.
induction l'.
intros HPerm Hl Hl'.
assert (HIna' : In a (a :: l)).
idtac.
assert (HIna : In a (a0 :: l')).
idtac.
assert (HIna0' : In a0 (a0 :: l')).
idtac.

*****
HIna0' : In a0 (cons a0 l')
HIna : In a (cons a0 l')
HIna' : In a (cons a l)
Hl' : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a0 l')
Hl : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l)
HPerm : Permutation.Permutation (cons a l) (cons a0 l')
IHl' : forall (_ : Permutation.Permutation (cons a l) l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l))\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq (cons a l) l'
l' : list positive
a0 : positive
IHl : forall (l' : list positive) (_ : Permutation.Permutation l l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) l)\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq l l'
l : list positive
a : positive
*****
eq (cons a l) (cons a0 l')
+++++
assert (HIna0 : In a0 (a :: l)).
-----
Lemma PermSorted : forall (l l' : list positive), Permutation.Permutation l l' -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l' -> l = l'.
Proof.
intro l.
induction l.
intro l'.
induction l'.
intros HPerm Hl Hl'.
assert (HIna' : In a (a :: l)).
idtac.
assert (HIna : In a (a0 :: l')).
idtac.
assert (HIna0' : In a0 (a0 :: l')).
idtac.
assert (HIna0 : In a0 (a :: l)).

*****
HIna0' : In a0 (cons a0 l')
HIna : In a (cons a0 l')
HIna' : In a (cons a l)
Hl' : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a0 l')
Hl : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l)
HPerm : Permutation.Permutation (cons a l) (cons a0 l')
IHl' : forall (_ : Permutation.Permutation (cons a l) l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l))\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq (cons a l) l'
l' : list positive
a0 : positive
IHl : forall (l' : list positive) (_ : Permutation.Permutation l l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) l)\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq l l'
l : list positive
a : positive
*****
In a0 (cons a l)
+++++
apply Permutation.Permutation_in with (a0 :: l').
-----
Lemma PermSorted : forall (l l' : list positive), Permutation.Permutation l l' -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l' -> l = l'.
Proof.
intro l.
induction l.
intro l'.
induction l'.
intros HPerm Hl Hl'.
assert (HIna' : In a (a :: l)).
idtac.
assert (HIna : In a (a0 :: l')).
idtac.
assert (HIna0' : In a0 (a0 :: l')).
idtac.
assert (HIna0 : In a0 (a :: l)).
apply Permutation.Permutation_in with (a0 :: l').

*****
HIna0' : In a0 (cons a0 l')
HIna : In a (cons a0 l')
HIna' : In a (cons a l)
Hl' : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a0 l')
Hl : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l)
HPerm : Permutation.Permutation (cons a l) (cons a0 l')
IHl' : forall (_ : Permutation.Permutation (cons a l) l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l))\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq (cons a l) l'
l' : list positive
a0 : positive
IHl : forall (l' : list positive) (_ : Permutation.Permutation l l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) l)\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq l l'
l : list positive
a : positive
*****
Permutation.Permutation (cons a0 l') (cons a l)
+++++
apply Permutation.Permutation_sym in HPerm.
-----
Lemma PermSorted : forall (l l' : list positive), Permutation.Permutation l l' -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l' -> l = l'.
Proof.
intro l.
induction l.
intro l'.
induction l'.
intros HPerm Hl Hl'.
assert (HIna' : In a (a :: l)).
idtac.
assert (HIna : In a (a0 :: l')).
idtac.
assert (HIna0' : In a0 (a0 :: l')).
idtac.
assert (HIna0 : In a0 (a :: l)).
apply Permutation.Permutation_in with (a0 :: l').
apply Permutation.Permutation_sym in HPerm.

*****
HIna0' : In a0 (cons a0 l')
HIna : In a (cons a0 l')
HIna' : In a (cons a l)
Hl' : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a0 l')
Hl : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l)
HPerm : Permutation.Permutation (cons a0 l') (cons a l)
IHl' : forall (_ : Permutation.Permutation (cons a l) l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l))\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq (cons a l) l'
l' : list positive
a0 : positive
IHl : forall (l' : list positive) (_ : Permutation.Permutation l l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) l)\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq l l'
l : list positive
a : positive
*****
Permutation.Permutation (cons a0 l') (cons a l)
+++++
assumption.
-----
Lemma PermSorted : forall (l l' : list positive), Permutation.Permutation l l' -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l' -> l = l'.
Proof.
intro l.
induction l.
intro l'.
induction l'.
intros HPerm Hl Hl'.
assert (HIna' : In a (a :: l)).
idtac.
assert (HIna : In a (a0 :: l')).
idtac.
assert (HIna0' : In a0 (a0 :: l')).
idtac.
assert (HIna0 : In a0 (a :: l)).
apply Permutation.Permutation_in with (a0 :: l').

*****
HIna0' : In a0 (cons a0 l')
HIna : In a (cons a0 l')
HIna' : In a (cons a l)
Hl' : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a0 l')
Hl : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l)
HPerm : Permutation.Permutation (cons a l) (cons a0 l')
IHl' : forall (_ : Permutation.Permutation (cons a l) l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l))\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq (cons a l) l'
l' : list positive
a0 : positive
IHl : forall (l' : list positive) (_ : Permutation.Permutation l l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) l)\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq l l'
l : list positive
a : positive
*****
In a0 (cons a0 l')
+++++
apply Permutation.Permutation_sym in HPerm.
-----
Lemma PermSorted : forall (l l' : list positive), Permutation.Permutation l l' -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l' -> l = l'.
Proof.
intro l.
induction l.
intro l'.
induction l'.
intros HPerm Hl Hl'.
assert (HIna' : In a (a :: l)).
idtac.
assert (HIna : In a (a0 :: l')).
idtac.
assert (HIna0' : In a0 (a0 :: l')).
idtac.
assert (HIna0 : In a0 (a :: l)).
apply Permutation.Permutation_in with (a0 :: l').
apply Permutation.Permutation_sym in HPerm.

*****
HIna0' : In a0 (cons a0 l')
HIna : In a (cons a0 l')
HIna' : In a (cons a l)
Hl' : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a0 l')
Hl : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l)
HPerm : Permutation.Permutation (cons a0 l') (cons a l)
IHl' : forall (_ : Permutation.Permutation (cons a l) l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l))\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq (cons a l) l'
l' : list positive
a0 : positive
IHl : forall (l' : list positive) (_ : Permutation.Permutation l l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) l)\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq l l'
l : list positive
a : positive
*****
In a0 (cons a0 l')
+++++
assumption.
-----
Lemma PermSorted : forall (l l' : list positive), Permutation.Permutation l l' -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l' -> l = l'.
Proof.
intro l.
induction l.
intro l'.
induction l'.
intros HPerm Hl Hl'.
assert (HIna' : In a (a :: l)).
idtac.
assert (HIna : In a (a0 :: l')).
idtac.
assert (HIna0' : In a0 (a0 :: l')).
idtac.
assert (HIna0 : In a0 (a :: l)).

*****
HIna0 : In a0 (cons a l)
HIna0' : In a0 (cons a0 l')
HIna : In a (cons a0 l')
HIna' : In a (cons a l)
Hl' : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a0 l')
Hl : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l)
HPerm : Permutation.Permutation (cons a l) (cons a0 l')
IHl' : forall (_ : Permutation.Permutation (cons a l) l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l))\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq (cons a l) l'
l' : list positive
a0 : positive
IHl : forall (l' : list positive) (_ : Permutation.Permutation l l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) l)\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq l l'
l : list positive
a : positive
*****
eq (cons a l) (cons a0 l')
+++++
idtac.
-----
Lemma PermSorted : forall (l l' : list positive), Permutation.Permutation l l' -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l' -> l = l'.
Proof.
intro l.
induction l.
intro l'.
induction l'.
intros HPerm Hl Hl'.
assert (HIna' : In a (a :: l)).
idtac.
assert (HIna : In a (a0 :: l')).
idtac.
assert (HIna0' : In a0 (a0 :: l')).
idtac.
assert (HIna0 : In a0 (a :: l)).
idtac.

*****
HIna0 : In a0 (cons a l)
HIna0' : In a0 (cons a0 l')
HIna : In a (cons a0 l')
HIna' : In a (cons a l)
Hl' : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a0 l')
Hl : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l)
HPerm : Permutation.Permutation (cons a l) (cons a0 l')
IHl' : forall (_ : Permutation.Permutation (cons a l) l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l))\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq (cons a l) l'
l' : list positive
a0 : positive
IHl : forall (l' : list positive) (_ : Permutation.Permutation l l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) l)\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq l l'
l : list positive
a : positive
*****
eq (cons a l) (cons a0 l')
+++++
clear HIna'.
-----
Lemma PermSorted : forall (l l' : list positive), Permutation.Permutation l l' -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l' -> l = l'.
Proof.
intro l.
induction l.
intro l'.
induction l'.
intros HPerm Hl Hl'.
assert (HIna' : In a (a :: l)).
idtac.
assert (HIna : In a (a0 :: l')).
idtac.
assert (HIna0' : In a0 (a0 :: l')).
idtac.
assert (HIna0 : In a0 (a :: l)).
idtac.
clear HIna'.

*****
HIna0 : In a0 (cons a l)
HIna0' : In a0 (cons a0 l')
HIna : In a (cons a0 l')
Hl' : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a0 l')
Hl : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l)
HPerm : Permutation.Permutation (cons a l) (cons a0 l')
IHl' : forall (_ : Permutation.Permutation (cons a l) l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l))\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq (cons a l) l'
l' : list positive
a0 : positive
IHl : forall (l' : list positive) (_ : Permutation.Permutation l l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) l)\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq l l'
l : list positive
a : positive
*****
eq (cons a l) (cons a0 l')
+++++
clear HIna0'.
-----
Lemma PermSorted : forall (l l' : list positive), Permutation.Permutation l l' -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l' -> l = l'.
Proof.
intro l.
induction l.
intro l'.
induction l'.
intros HPerm Hl Hl'.
assert (HIna' : In a (a :: l)).
idtac.
assert (HIna : In a (a0 :: l')).
idtac.
assert (HIna0' : In a0 (a0 :: l')).
idtac.
assert (HIna0 : In a0 (a :: l)).
idtac.
clear HIna'.
clear HIna0'.

*****
HIna0 : In a0 (cons a l)
HIna : In a (cons a0 l')
Hl' : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a0 l')
Hl : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l)
HPerm : Permutation.Permutation (cons a l) (cons a0 l')
IHl' : forall (_ : Permutation.Permutation (cons a l) l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l))\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq (cons a l) l'
l' : list positive
a0 : positive
IHl : forall (l' : list positive) (_ : Permutation.Permutation l l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) l)\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq l l'
l : list positive
a : positive
*****
eq (cons a l) (cons a0 l')
+++++
apply in_inv in HIna.
-----
Lemma PermSorted : forall (l l' : list positive), Permutation.Permutation l l' -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l' -> l = l'.
Proof.
intro l.
induction l.
intro l'.
induction l'.
intros HPerm Hl Hl'.
assert (HIna' : In a (a :: l)).
idtac.
assert (HIna : In a (a0 :: l')).
idtac.
assert (HIna0' : In a0 (a0 :: l')).
idtac.
assert (HIna0 : In a0 (a :: l)).
idtac.
clear HIna'.
clear HIna0'.
apply in_inv in HIna.

*****
HIna0 : In a0 (cons a l)
HIna : or (eq a0 a) (In a l')
Hl' : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a0 l')
Hl : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l)
HPerm : Permutation.Permutation (cons a l) (cons a0 l')
IHl' : forall (_ : Permutation.Permutation (cons a l) l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l))\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq (cons a l) l'
l' : list positive
a0 : positive
IHl : forall (l' : list positive) (_ : Permutation.Permutation l l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) l)\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq l l'
l : list positive
a : positive
*****
eq (cons a l) (cons a0 l')
+++++
apply in_inv in HIna0.
-----
Lemma PermSorted : forall (l l' : list positive), Permutation.Permutation l l' -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l' -> l = l'.
Proof.
intro l.
induction l.
intro l'.
induction l'.
intros HPerm Hl Hl'.
assert (HIna' : In a (a :: l)).
idtac.
assert (HIna : In a (a0 :: l')).
idtac.
assert (HIna0' : In a0 (a0 :: l')).
idtac.
assert (HIna0 : In a0 (a :: l)).
idtac.
clear HIna'.
clear HIna0'.
apply in_inv in HIna.
apply in_inv in HIna0.

*****
HIna0 : or (eq a a0) (In a0 l)
HIna : or (eq a0 a) (In a l')
Hl' : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a0 l')
Hl : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l)
HPerm : Permutation.Permutation (cons a l) (cons a0 l')
IHl' : forall (_ : Permutation.Permutation (cons a l) l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l))\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq (cons a l) l'
l' : list positive
a0 : positive
IHl : forall (l' : list positive) (_ : Permutation.Permutation l l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) l)\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq l l'
l : list positive
a : positive
*****
eq (cons a l) (cons a0 l')
+++++
elim HIna.
-----
Lemma PermSorted : forall (l l' : list positive), Permutation.Permutation l l' -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l' -> l = l'.
Proof.
intro l.
induction l.
intro l'.
induction l'.
intros HPerm Hl Hl'.
assert (HIna' : In a (a :: l)).
idtac.
assert (HIna : In a (a0 :: l')).
idtac.
assert (HIna0' : In a0 (a0 :: l')).
idtac.
assert (HIna0 : In a0 (a :: l)).
idtac.
clear HIna'.
clear HIna0'.
apply in_inv in HIna.
apply in_inv in HIna0.
elim HIna.

*****
HIna0 : or (eq a a0) (In a0 l)
HIna : or (eq a0 a) (In a l')
Hl' : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a0 l')
Hl : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l)
HPerm : Permutation.Permutation (cons a l) (cons a0 l')
IHl' : forall (_ : Permutation.Permutation (cons a l) l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l))\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq (cons a l) l'
l' : list positive
a0 : positive
IHl : forall (l' : list positive) (_ : Permutation.Permutation l l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) l)\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq l l'
l : list positive
a : positive
*****
forall _ : eq a0 a, eq (cons a l) (cons a0 l')
+++++
clear HIna.
-----
Lemma PermSorted : forall (l l' : list positive), Permutation.Permutation l l' -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l' -> l = l'.
Proof.
intro l.
induction l.
intro l'.
induction l'.
intros HPerm Hl Hl'.
assert (HIna' : In a (a :: l)).
idtac.
assert (HIna : In a (a0 :: l')).
idtac.
assert (HIna0' : In a0 (a0 :: l')).
idtac.
assert (HIna0 : In a0 (a :: l)).
idtac.
clear HIna'.
clear HIna0'.
apply in_inv in HIna.
apply in_inv in HIna0.
elim HIna.
clear HIna.

*****
HIna0 : or (eq a a0) (In a0 l)
Hl' : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a0 l')
Hl : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l)
HPerm : Permutation.Permutation (cons a l) (cons a0 l')
IHl' : forall (_ : Permutation.Permutation (cons a l) l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l))\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq (cons a l) l'
l' : list positive
a0 : positive
IHl : forall (l' : list positive) (_ : Permutation.Permutation l l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) l)\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq l l'
l : list positive
a : positive
*****
forall _ : eq a0 a, eq (cons a l) (cons a0 l')
+++++
intro HIna.
-----
Lemma PermSorted : forall (l l' : list positive), Permutation.Permutation l l' -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l' -> l = l'.
Proof.
intro l.
induction l.
intro l'.
induction l'.
intros HPerm Hl Hl'.
assert (HIna' : In a (a :: l)).
idtac.
assert (HIna : In a (a0 :: l')).
idtac.
assert (HIna0' : In a0 (a0 :: l')).
idtac.
assert (HIna0 : In a0 (a :: l)).
idtac.
clear HIna'.
clear HIna0'.
apply in_inv in HIna.
apply in_inv in HIna0.
elim HIna.
clear HIna.
intro HIna.

*****
HIna : eq a0 a
HIna0 : or (eq a a0) (In a0 l)
Hl' : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a0 l')
Hl : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l)
HPerm : Permutation.Permutation (cons a l) (cons a0 l')
IHl' : forall (_ : Permutation.Permutation (cons a l) l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l))\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq (cons a l) l'
l' : list positive
a0 : positive
IHl : forall (l' : list positive) (_ : Permutation.Permutation l l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) l)\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq l l'
l : list positive
a : positive
*****
eq (cons a l) (cons a0 l')
+++++
elim HIna0.
-----
Lemma PermSorted : forall (l l' : list positive), Permutation.Permutation l l' -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l' -> l = l'.
Proof.
intro l.
induction l.
intro l'.
induction l'.
intros HPerm Hl Hl'.
assert (HIna' : In a (a :: l)).
idtac.
assert (HIna : In a (a0 :: l')).
idtac.
assert (HIna0' : In a0 (a0 :: l')).
idtac.
assert (HIna0 : In a0 (a :: l)).
idtac.
clear HIna'.
clear HIna0'.
apply in_inv in HIna.
apply in_inv in HIna0.
elim HIna.
clear HIna.
intro HIna.
elim HIna0.

*****
HIna : eq a0 a
HIna0 : or (eq a a0) (In a0 l)
Hl' : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a0 l')
Hl : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l)
HPerm : Permutation.Permutation (cons a l) (cons a0 l')
IHl' : forall (_ : Permutation.Permutation (cons a l) l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l))\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq (cons a l) l'
l' : list positive
a0 : positive
IHl : forall (l' : list positive) (_ : Permutation.Permutation l l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) l)\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq l l'
l : list positive
a : positive
*****
forall _ : eq a a0, eq (cons a l) (cons a0 l')
+++++
clear HIna0.
-----
Lemma PermSorted : forall (l l' : list positive), Permutation.Permutation l l' -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l' -> l = l'.
Proof.
intro l.
induction l.
intro l'.
induction l'.
intros HPerm Hl Hl'.
assert (HIna' : In a (a :: l)).
idtac.
assert (HIna : In a (a0 :: l')).
idtac.
assert (HIna0' : In a0 (a0 :: l')).
idtac.
assert (HIna0 : In a0 (a :: l)).
idtac.
clear HIna'.
clear HIna0'.
apply in_inv in HIna.
apply in_inv in HIna0.
elim HIna.
clear HIna.
intro HIna.
elim HIna0.
clear HIna0.

*****
HIna : eq a0 a
Hl' : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a0 l')
Hl : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l)
HPerm : Permutation.Permutation (cons a l) (cons a0 l')
IHl' : forall (_ : Permutation.Permutation (cons a l) l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l))\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq (cons a l) l'
l' : list positive
a0 : positive
IHl : forall (l' : list positive) (_ : Permutation.Permutation l l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) l)\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq l l'
l : list positive
a : positive
*****
forall _ : eq a a0, eq (cons a l) (cons a0 l')
+++++
intro HIna0.
-----
Lemma PermSorted : forall (l l' : list positive), Permutation.Permutation l l' -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l' -> l = l'.
Proof.
intro l.
induction l.
intro l'.
induction l'.
intros HPerm Hl Hl'.
assert (HIna' : In a (a :: l)).
idtac.
assert (HIna : In a (a0 :: l')).
idtac.
assert (HIna0' : In a0 (a0 :: l')).
idtac.
assert (HIna0 : In a0 (a :: l)).
idtac.
clear HIna'.
clear HIna0'.
apply in_inv in HIna.
apply in_inv in HIna0.
elim HIna.
clear HIna.
intro HIna.
elim HIna0.
clear HIna0.
intro HIna0.

*****
HIna0 : eq a a0
HIna : eq a0 a
Hl' : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a0 l')
Hl : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l)
HPerm : Permutation.Permutation (cons a l) (cons a0 l')
IHl' : forall (_ : Permutation.Permutation (cons a l) l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l))\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq (cons a l) l'
l' : list positive
a0 : positive
IHl : forall (l' : list positive) (_ : Permutation.Permutation l l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) l)\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq l l'
l : list positive
a : positive
*****
eq (cons a l) (cons a0 l')
+++++
try (rewrite HIna in *).
-----
Lemma PermSorted : forall (l l' : list positive), Permutation.Permutation l l' -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l' -> l = l'.
Proof.
intro l.
induction l.
intro l'.
induction l'.
intros HPerm Hl Hl'.
assert (HIna' : In a (a :: l)).
idtac.
assert (HIna : In a (a0 :: l')).
idtac.
assert (HIna0' : In a0 (a0 :: l')).
idtac.
assert (HIna0 : In a0 (a :: l)).
idtac.
clear HIna'.
clear HIna0'.
apply in_inv in HIna.
apply in_inv in HIna0.
elim HIna.
clear HIna.
intro HIna.
elim HIna0.
clear HIna0.
intro HIna0.
try (rewrite HIna in *).

*****
HIna0 : eq a a
HIna : eq a0 a
Hl' : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l')
Hl : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l)
HPerm : Permutation.Permutation (cons a l) (cons a l')
IHl' : forall (_ : Permutation.Permutation (cons a l) l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l))\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq (cons a l) l'
l' : list positive
a0 : positive
IHl : forall (l' : list positive) (_ : Permutation.Permutation l l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) l)\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq l l'
l : list positive
a : positive
*****
eq (cons a l) (cons a l')
+++++
try (rewrite <- HIna0 in *).
-----
Lemma PermSorted : forall (l l' : list positive), Permutation.Permutation l l' -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l' -> l = l'.
Proof.
intro l.
induction l.
intro l'.
induction l'.
intros HPerm Hl Hl'.
assert (HIna' : In a (a :: l)).
idtac.
assert (HIna : In a (a0 :: l')).
idtac.
assert (HIna0' : In a0 (a0 :: l')).
idtac.
assert (HIna0 : In a0 (a :: l)).
idtac.
clear HIna'.
clear HIna0'.
apply in_inv in HIna.
apply in_inv in HIna0.
elim HIna.
clear HIna.
intro HIna.
elim HIna0.
clear HIna0.
intro HIna0.
try (rewrite HIna in *).
try (rewrite <- HIna0 in *).

*****
HIna0 : eq a a
HIna : eq a0 a
Hl' : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l')
Hl : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l)
HPerm : Permutation.Permutation (cons a l) (cons a l')
IHl' : forall (_ : Permutation.Permutation (cons a l) l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l))\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq (cons a l) l'
l' : list positive
a0 : positive
IHl : forall (l' : list positive) (_ : Permutation.Permutation l l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) l)\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq l l'
l : list positive
a : positive
*****
eq (cons a l) (cons a l')
+++++
assert (HPerm' : Permutation.Permutation l l').
-----
Lemma PermSorted : forall (l l' : list positive), Permutation.Permutation l l' -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l' -> l = l'.
Proof.
intro l.
induction l.
intro l'.
induction l'.
intros HPerm Hl Hl'.
assert (HIna' : In a (a :: l)).
idtac.
assert (HIna : In a (a0 :: l')).
idtac.
assert (HIna0' : In a0 (a0 :: l')).
idtac.
assert (HIna0 : In a0 (a :: l)).
idtac.
clear HIna'.
clear HIna0'.
apply in_inv in HIna.
apply in_inv in HIna0.
elim HIna.
clear HIna.
intro HIna.
elim HIna0.
clear HIna0.
intro HIna0.
try (rewrite HIna in *).
try (rewrite <- HIna0 in *).
assert (HPerm' : Permutation.Permutation l l').

*****
HIna0 : eq a a
HIna : eq a0 a
Hl' : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l')
Hl : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l)
HPerm : Permutation.Permutation (cons a l) (cons a l')
IHl' : forall (_ : Permutation.Permutation (cons a l) l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l))\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq (cons a l) l'
l' : list positive
a0 : positive
IHl : forall (l' : list positive) (_ : Permutation.Permutation l l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) l)\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq l l'
l : list positive
a : positive
*****
Permutation.Permutation l l'
+++++
apply Permutation.Permutation_app_inv_l with (a :: nil).
-----
Lemma PermSorted : forall (l l' : list positive), Permutation.Permutation l l' -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l' -> l = l'.
Proof.
intro l.
induction l.
intro l'.
induction l'.
intros HPerm Hl Hl'.
assert (HIna' : In a (a :: l)).
idtac.
assert (HIna : In a (a0 :: l')).
idtac.
assert (HIna0' : In a0 (a0 :: l')).
idtac.
assert (HIna0 : In a0 (a :: l)).
idtac.
clear HIna'.
clear HIna0'.
apply in_inv in HIna.
apply in_inv in HIna0.
elim HIna.
clear HIna.
intro HIna.
elim HIna0.
clear HIna0.
intro HIna0.
try (rewrite HIna in *).
try (rewrite <- HIna0 in *).
assert (HPerm' : Permutation.Permutation l l').
apply Permutation.Permutation_app_inv_l with (a :: nil).

*****
HIna0 : eq a a
HIna : eq a0 a
Hl' : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l')
Hl : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l)
HPerm : Permutation.Permutation (cons a l) (cons a l')
IHl' : forall (_ : Permutation.Permutation (cons a l) l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l))\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq (cons a l) l'
l' : list positive
a0 : positive
IHl : forall (l' : list positive) (_ : Permutation.Permutation l l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) l)\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq l l'
l : list positive
a : positive
*****
Permutation.Permutation (Datatypes.app (cons a nil) l) (Datatypes.app (cons a nil) l')
+++++
simpl.
-----
Lemma PermSorted : forall (l l' : list positive), Permutation.Permutation l l' -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l' -> l = l'.
Proof.
intro l.
induction l.
intro l'.
induction l'.
intros HPerm Hl Hl'.
assert (HIna' : In a (a :: l)).
idtac.
assert (HIna : In a (a0 :: l')).
idtac.
assert (HIna0' : In a0 (a0 :: l')).
idtac.
assert (HIna0 : In a0 (a :: l)).
idtac.
clear HIna'.
clear HIna0'.
apply in_inv in HIna.
apply in_inv in HIna0.
elim HIna.
clear HIna.
intro HIna.
elim HIna0.
clear HIna0.
intro HIna0.
try (rewrite HIna in *).
try (rewrite <- HIna0 in *).
assert (HPerm' : Permutation.Permutation l l').
apply Permutation.Permutation_app_inv_l with (a :: nil).
simpl.

*****
HIna0 : eq a a
HIna : eq a0 a
Hl' : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l')
Hl : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l)
HPerm : Permutation.Permutation (cons a l) (cons a l')
IHl' : forall (_ : Permutation.Permutation (cons a l) l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l))\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq (cons a l) l'
l' : list positive
a0 : positive
IHl : forall (l' : list positive) (_ : Permutation.Permutation l l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) l)\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq l l'
l : list positive
a : positive
*****
Permutation.Permutation (cons a l) (cons a l')
+++++
assumption.
-----
Lemma PermSorted : forall (l l' : list positive), Permutation.Permutation l l' -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l' -> l = l'.
Proof.
intro l.
induction l.
intro l'.
induction l'.
intros HPerm Hl Hl'.
assert (HIna' : In a (a :: l)).
idtac.
assert (HIna : In a (a0 :: l')).
idtac.
assert (HIna0' : In a0 (a0 :: l')).
idtac.
assert (HIna0 : In a0 (a :: l)).
idtac.
clear HIna'.
clear HIna0'.
apply in_inv in HIna.
apply in_inv in HIna0.
elim HIna.
clear HIna.
intro HIna.
elim HIna0.
clear HIna0.
intro HIna0.
try (rewrite HIna in *).
try (rewrite <- HIna0 in *).
assert (HPerm' : Permutation.Permutation l l').

*****
HPerm' : Permutation.Permutation l l'
HIna0 : eq a a
HIna : eq a0 a
Hl' : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l')
Hl : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l)
HPerm : Permutation.Permutation (cons a l) (cons a l')
IHl' : forall (_ : Permutation.Permutation (cons a l) l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l))\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq (cons a l) l'
l' : list positive
a0 : positive
IHl : forall (l' : list positive) (_ : Permutation.Permutation l l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) l)\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq l l'
l : list positive
a : positive
*****
eq (cons a l) (cons a l')
+++++
idtac.
-----
Lemma PermSorted : forall (l l' : list positive), Permutation.Permutation l l' -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l' -> l = l'.
Proof.
intro l.
induction l.
intro l'.
induction l'.
intros HPerm Hl Hl'.
assert (HIna' : In a (a :: l)).
idtac.
assert (HIna : In a (a0 :: l')).
idtac.
assert (HIna0' : In a0 (a0 :: l')).
idtac.
assert (HIna0 : In a0 (a :: l)).
idtac.
clear HIna'.
clear HIna0'.
apply in_inv in HIna.
apply in_inv in HIna0.
elim HIna.
clear HIna.
intro HIna.
elim HIna0.
clear HIna0.
intro HIna0.
try (rewrite HIna in *).
try (rewrite <- HIna0 in *).
assert (HPerm' : Permutation.Permutation l l').
idtac.

*****
HPerm' : Permutation.Permutation l l'
HIna0 : eq a a
HIna : eq a0 a
Hl' : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l')
Hl : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l)
HPerm : Permutation.Permutation (cons a l) (cons a l')
IHl' : forall (_ : Permutation.Permutation (cons a l) l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l))\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq (cons a l) l'
l' : list positive
a0 : positive
IHl : forall (l' : list positive) (_ : Permutation.Permutation l l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) l)\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq l l'
l : list positive
a : positive
*****
eq (cons a l) (cons a l')
+++++
apply OCPSortedTl in Hl.
-----
Lemma PermSorted : forall (l l' : list positive), Permutation.Permutation l l' -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l' -> l = l'.
Proof.
intro l.
induction l.
intro l'.
induction l'.
intros HPerm Hl Hl'.
assert (HIna' : In a (a :: l)).
idtac.
assert (HIna : In a (a0 :: l')).
idtac.
assert (HIna0' : In a0 (a0 :: l')).
idtac.
assert (HIna0 : In a0 (a :: l)).
idtac.
clear HIna'.
clear HIna0'.
apply in_inv in HIna.
apply in_inv in HIna0.
elim HIna.
clear HIna.
intro HIna.
elim HIna0.
clear HIna0.
intro HIna0.
try (rewrite HIna in *).
try (rewrite <- HIna0 in *).
assert (HPerm' : Permutation.Permutation l l').
idtac.
apply OCPSortedTl in Hl.

*****
HPerm' : Permutation.Permutation l l'
HIna0 : eq a a
HIna : eq a0 a
Hl' : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l')
Hl : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (tl (cons a l))
HPerm : Permutation.Permutation (cons a l) (cons a l')
IHl' : forall (_ : Permutation.Permutation (cons a l) l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l))\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq (cons a l) l'
l' : list positive
a0 : positive
IHl : forall (l' : list positive) (_ : Permutation.Permutation l l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) l)\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq l l'
l : list positive
a : positive
*****
eq (cons a l) (cons a l')
+++++
apply OCPSortedTl in Hl'.
-----
Lemma PermSorted : forall (l l' : list positive), Permutation.Permutation l l' -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l' -> l = l'.
Proof.
intro l.
induction l.
intro l'.
induction l'.
intros HPerm Hl Hl'.
assert (HIna' : In a (a :: l)).
idtac.
assert (HIna : In a (a0 :: l')).
idtac.
assert (HIna0' : In a0 (a0 :: l')).
idtac.
assert (HIna0 : In a0 (a :: l)).
idtac.
clear HIna'.
clear HIna0'.
apply in_inv in HIna.
apply in_inv in HIna0.
elim HIna.
clear HIna.
intro HIna.
elim HIna0.
clear HIna0.
intro HIna0.
try (rewrite HIna in *).
try (rewrite <- HIna0 in *).
assert (HPerm' : Permutation.Permutation l l').
idtac.
apply OCPSortedTl in Hl.
apply OCPSortedTl in Hl'.

*****
HPerm' : Permutation.Permutation l l'
HIna0 : eq a a
HIna : eq a0 a
Hl' : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (tl (cons a l'))
Hl : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (tl (cons a l))
HPerm : Permutation.Permutation (cons a l) (cons a l')
IHl' : forall (_ : Permutation.Permutation (cons a l) l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l))\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq (cons a l) l'
l' : list positive
a0 : positive
IHl : forall (l' : list positive) (_ : Permutation.Permutation l l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) l)\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq l l'
l : list positive
a : positive
*****
eq (cons a l) (cons a l')
+++++
apply IHl in HPerm'.
-----
Lemma PermSorted : forall (l l' : list positive), Permutation.Permutation l l' -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l' -> l = l'.
Proof.
intro l.
induction l.
intro l'.
induction l'.
intros HPerm Hl Hl'.
assert (HIna' : In a (a :: l)).
idtac.
assert (HIna : In a (a0 :: l')).
idtac.
assert (HIna0' : In a0 (a0 :: l')).
idtac.
assert (HIna0 : In a0 (a :: l)).
idtac.
clear HIna'.
clear HIna0'.
apply in_inv in HIna.
apply in_inv in HIna0.
elim HIna.
clear HIna.
intro HIna.
elim HIna0.
clear HIna0.
intro HIna0.
try (rewrite HIna in *).
try (rewrite <- HIna0 in *).
assert (HPerm' : Permutation.Permutation l l').
idtac.
apply OCPSortedTl in Hl.
apply OCPSortedTl in Hl'.
apply IHl in HPerm'.

*****
HPerm' : eq l l'
HIna0 : eq a a
HIna : eq a0 a
Hl' : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (tl (cons a l'))
Hl : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (tl (cons a l))
HPerm : Permutation.Permutation (cons a l) (cons a l')
IHl' : forall (_ : Permutation.Permutation (cons a l) l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l))\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq (cons a l) l'
l' : list positive
a0 : positive
IHl : forall (l' : list positive) (_ : Permutation.Permutation l l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) l)\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq l l'
l : list positive
a : positive
*****
eq (cons a l) (cons a l')
+++++
try assumption.
-----
Lemma PermSorted : forall (l l' : list positive), Permutation.Permutation l l' -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l' -> l = l'.
Proof.
intro l.
induction l.
intro l'.
induction l'.
intros HPerm Hl Hl'.
assert (HIna' : In a (a :: l)).
idtac.
assert (HIna : In a (a0 :: l')).
idtac.
assert (HIna0' : In a0 (a0 :: l')).
idtac.
assert (HIna0 : In a0 (a :: l)).
idtac.
clear HIna'.
clear HIna0'.
apply in_inv in HIna.
apply in_inv in HIna0.
elim HIna.
clear HIna.
intro HIna.
elim HIna0.
clear HIna0.
intro HIna0.
try (rewrite HIna in *).
try (rewrite <- HIna0 in *).
assert (HPerm' : Permutation.Permutation l l').
idtac.
apply OCPSortedTl in Hl.
apply OCPSortedTl in Hl'.
apply IHl in HPerm'.
try assumption.

*****
HPerm' : eq l l'
HIna0 : eq a a
HIna : eq a0 a
Hl' : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (tl (cons a l'))
Hl : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (tl (cons a l))
HPerm : Permutation.Permutation (cons a l) (cons a l')
IHl' : forall (_ : Permutation.Permutation (cons a l) l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l))\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq (cons a l) l'
l' : list positive
a0 : positive
IHl : forall (l' : list positive) (_ : Permutation.Permutation l l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) l)\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq l l'
l : list positive
a : positive
*****
eq (cons a l) (cons a l')
+++++
rewrite HPerm'.
-----
Lemma PermSorted : forall (l l' : list positive), Permutation.Permutation l l' -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l' -> l = l'.
Proof.
intro l.
induction l.
intro l'.
induction l'.
intros HPerm Hl Hl'.
assert (HIna' : In a (a :: l)).
idtac.
assert (HIna : In a (a0 :: l')).
idtac.
assert (HIna0' : In a0 (a0 :: l')).
idtac.
assert (HIna0 : In a0 (a :: l)).
idtac.
clear HIna'.
clear HIna0'.
apply in_inv in HIna.
apply in_inv in HIna0.
elim HIna.
clear HIna.
intro HIna.
elim HIna0.
clear HIna0.
intro HIna0.
try (rewrite HIna in *).
try (rewrite <- HIna0 in *).
assert (HPerm' : Permutation.Permutation l l').
idtac.
apply OCPSortedTl in Hl.
apply OCPSortedTl in Hl'.
apply IHl in HPerm'.
try assumption.
rewrite HPerm'.

*****
HPerm' : eq l l'
HIna0 : eq a a
HIna : eq a0 a
Hl' : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (tl (cons a l'))
Hl : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (tl (cons a l))
HPerm : Permutation.Permutation (cons a l) (cons a l')
IHl' : forall (_ : Permutation.Permutation (cons a l) l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l))\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq (cons a l) l'
l' : list positive
a0 : positive
IHl : forall (l' : list positive) (_ : Permutation.Permutation l l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) l)\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq l l'
l : list positive
a : positive
*****
eq (cons a l') (cons a l')
+++++
reflexivity.
-----
Lemma PermSorted : forall (l l' : list positive), Permutation.Permutation l l' -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l' -> l = l'.
Proof.
intro l.
induction l.
intro l'.
induction l'.
intros HPerm Hl Hl'.
assert (HIna' : In a (a :: l)).
idtac.
assert (HIna : In a (a0 :: l')).
idtac.
assert (HIna0' : In a0 (a0 :: l')).
idtac.
assert (HIna0 : In a0 (a :: l)).
idtac.
clear HIna'.
clear HIna0'.
apply in_inv in HIna.
apply in_inv in HIna0.
elim HIna.
clear HIna.
intro HIna.
elim HIna0.
clear HIna0.
intro HIna0.
try (rewrite HIna in *).
try (rewrite <- HIna0 in *).
assert (HPerm' : Permutation.Permutation l l').
idtac.
apply OCPSortedTl in Hl.
apply OCPSortedTl in Hl'.
apply IHl in HPerm'.

*****
HPerm' : Permutation.Permutation l l'
HIna0 : eq a a
HIna : eq a0 a
Hl' : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (tl (cons a l'))
Hl : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (tl (cons a l))
HPerm : Permutation.Permutation (cons a l) (cons a l')
IHl' : forall (_ : Permutation.Permutation (cons a l) l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l))\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq (cons a l) l'
l' : list positive
a0 : positive
IHl : forall (l' : list positive) (_ : Permutation.Permutation l l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) l)\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq l l'
l : list positive
a : positive
*****
StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) l
+++++
try assumption.
-----
Lemma PermSorted : forall (l l' : list positive), Permutation.Permutation l l' -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l' -> l = l'.
Proof.
intro l.
induction l.
intro l'.
induction l'.
intros HPerm Hl Hl'.
assert (HIna' : In a (a :: l)).
idtac.
assert (HIna : In a (a0 :: l')).
idtac.
assert (HIna0' : In a0 (a0 :: l')).
idtac.
assert (HIna0 : In a0 (a :: l)).
idtac.
clear HIna'.
clear HIna0'.
apply in_inv in HIna.
apply in_inv in HIna0.
elim HIna.
clear HIna.
intro HIna.
elim HIna0.
clear HIna0.
intro HIna0.
try (rewrite HIna in *).
try (rewrite <- HIna0 in *).
assert (HPerm' : Permutation.Permutation l l').
idtac.
apply OCPSortedTl in Hl.
apply OCPSortedTl in Hl'.
apply IHl in HPerm'.

*****
HPerm' : Permutation.Permutation l l'
HIna0 : eq a a
HIna : eq a0 a
Hl' : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (tl (cons a l'))
Hl : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (tl (cons a l))
HPerm : Permutation.Permutation (cons a l) (cons a l')
IHl' : forall (_ : Permutation.Permutation (cons a l) l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l))\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq (cons a l) l'
l' : list positive
a0 : positive
IHl : forall (l' : list positive) (_ : Permutation.Permutation l l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) l)\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq l l'
l : list positive
a : positive
*****
StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) l'
+++++
try assumption.
-----
Lemma PermSorted : forall (l l' : list positive), Permutation.Permutation l l' -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l' -> l = l'.
Proof.
intro l.
induction l.
intro l'.
induction l'.
intros HPerm Hl Hl'.
assert (HIna' : In a (a :: l)).
idtac.
assert (HIna : In a (a0 :: l')).
idtac.
assert (HIna0' : In a0 (a0 :: l')).
idtac.
assert (HIna0 : In a0 (a :: l)).
idtac.
clear HIna'.
clear HIna0'.
apply in_inv in HIna.
apply in_inv in HIna0.
elim HIna.
clear HIna.
intro HIna.
elim HIna0.

*****
HIna : eq a0 a
HIna0 : or (eq a a0) (In a0 l)
Hl' : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a0 l')
Hl : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l)
HPerm : Permutation.Permutation (cons a l) (cons a0 l')
IHl' : forall (_ : Permutation.Permutation (cons a l) l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l))\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq (cons a l) l'
l' : list positive
a0 : positive
IHl : forall (l' : list positive) (_ : Permutation.Permutation l l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) l)\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq l l'
l : list positive
a : positive
*****
forall _ : In a0 l, eq (cons a l) (cons a0 l')
+++++
clear HIna0.
-----
Lemma PermSorted : forall (l l' : list positive), Permutation.Permutation l l' -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l' -> l = l'.
Proof.
intro l.
induction l.
intro l'.
induction l'.
intros HPerm Hl Hl'.
assert (HIna' : In a (a :: l)).
idtac.
assert (HIna : In a (a0 :: l')).
idtac.
assert (HIna0' : In a0 (a0 :: l')).
idtac.
assert (HIna0 : In a0 (a :: l)).
idtac.
clear HIna'.
clear HIna0'.
apply in_inv in HIna.
apply in_inv in HIna0.
elim HIna.
clear HIna.
intro HIna.
elim HIna0.
clear HIna0.

*****
HIna : eq a0 a
Hl' : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a0 l')
Hl : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l)
HPerm : Permutation.Permutation (cons a l) (cons a0 l')
IHl' : forall (_ : Permutation.Permutation (cons a l) l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l))\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq (cons a l) l'
l' : list positive
a0 : positive
IHl : forall (l' : list positive) (_ : Permutation.Permutation l l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) l)\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq l l'
l : list positive
a : positive
*****
forall _ : In a0 l, eq (cons a l) (cons a0 l')
+++++
intro HIna0.
-----
Lemma PermSorted : forall (l l' : list positive), Permutation.Permutation l l' -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l' -> l = l'.
Proof.
intro l.
induction l.
intro l'.
induction l'.
intros HPerm Hl Hl'.
assert (HIna' : In a (a :: l)).
idtac.
assert (HIna : In a (a0 :: l')).
idtac.
assert (HIna0' : In a0 (a0 :: l')).
idtac.
assert (HIna0 : In a0 (a :: l)).
idtac.
clear HIna'.
clear HIna0'.
apply in_inv in HIna.
apply in_inv in HIna0.
elim HIna.
clear HIna.
intro HIna.
elim HIna0.
clear HIna0.
intro HIna0.

*****
HIna0 : In a0 l
HIna : eq a0 a
Hl' : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a0 l')
Hl : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l)
HPerm : Permutation.Permutation (cons a l) (cons a0 l')
IHl' : forall (_ : Permutation.Permutation (cons a l) l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l))\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq (cons a l) l'
l' : list positive
a0 : positive
IHl : forall (l' : list positive) (_ : Permutation.Permutation l l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) l)\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq l l'
l : list positive
a : positive
*****
eq (cons a l) (cons a0 l')
+++++
try (rewrite HIna in *).
-----
Lemma PermSorted : forall (l l' : list positive), Permutation.Permutation l l' -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l' -> l = l'.
Proof.
intro l.
induction l.
intro l'.
induction l'.
intros HPerm Hl Hl'.
assert (HIna' : In a (a :: l)).
idtac.
assert (HIna : In a (a0 :: l')).
idtac.
assert (HIna0' : In a0 (a0 :: l')).
idtac.
assert (HIna0 : In a0 (a :: l)).
idtac.
clear HIna'.
clear HIna0'.
apply in_inv in HIna.
apply in_inv in HIna0.
elim HIna.
clear HIna.
intro HIna.
elim HIna0.
clear HIna0.
intro HIna0.
try (rewrite HIna in *).

*****
HIna0 : In a l
HIna : eq a0 a
Hl' : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l')
Hl : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l)
HPerm : Permutation.Permutation (cons a l) (cons a l')
IHl' : forall (_ : Permutation.Permutation (cons a l) l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l))\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq (cons a l) l'
l' : list positive
a0 : positive
IHl : forall (l' : list positive) (_ : Permutation.Permutation l l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) l)\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq l l'
l : list positive
a : positive
*****
eq (cons a l) (cons a l')
+++++
try (rewrite <- HIna0 in *).
-----
Lemma PermSorted : forall (l l' : list positive), Permutation.Permutation l l' -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l' -> l = l'.
Proof.
intro l.
induction l.
intro l'.
induction l'.
intros HPerm Hl Hl'.
assert (HIna' : In a (a :: l)).
idtac.
assert (HIna : In a (a0 :: l')).
idtac.
assert (HIna0' : In a0 (a0 :: l')).
idtac.
assert (HIna0 : In a0 (a :: l)).
idtac.
clear HIna'.
clear HIna0'.
apply in_inv in HIna.
apply in_inv in HIna0.
elim HIna.
clear HIna.
intro HIna.
elim HIna0.
clear HIna0.
intro HIna0.
try (rewrite HIna in *).
try (rewrite <- HIna0 in *).

*****
HIna0 : In a l
HIna : eq a0 a
Hl' : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l')
Hl : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l)
HPerm : Permutation.Permutation (cons a l) (cons a l')
IHl' : forall (_ : Permutation.Permutation (cons a l) l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l))\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq (cons a l) l'
l' : list positive
a0 : positive
IHl : forall (l' : list positive) (_ : Permutation.Permutation l l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) l)\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq l l'
l : list positive
a : positive
*****
eq (cons a l) (cons a l')
+++++
assert (HPerm' : Permutation.Permutation l l').
-----
Lemma PermSorted : forall (l l' : list positive), Permutation.Permutation l l' -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l' -> l = l'.
Proof.
intro l.
induction l.
intro l'.
induction l'.
intros HPerm Hl Hl'.
assert (HIna' : In a (a :: l)).
idtac.
assert (HIna : In a (a0 :: l')).
idtac.
assert (HIna0' : In a0 (a0 :: l')).
idtac.
assert (HIna0 : In a0 (a :: l)).
idtac.
clear HIna'.
clear HIna0'.
apply in_inv in HIna.
apply in_inv in HIna0.
elim HIna.
clear HIna.
intro HIna.
elim HIna0.
clear HIna0.
intro HIna0.
try (rewrite HIna in *).
try (rewrite <- HIna0 in *).
assert (HPerm' : Permutation.Permutation l l').

*****
HIna0 : In a l
HIna : eq a0 a
Hl' : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l')
Hl : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l)
HPerm : Permutation.Permutation (cons a l) (cons a l')
IHl' : forall (_ : Permutation.Permutation (cons a l) l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l))\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq (cons a l) l'
l' : list positive
a0 : positive
IHl : forall (l' : list positive) (_ : Permutation.Permutation l l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) l)\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq l l'
l : list positive
a : positive
*****
Permutation.Permutation l l'
+++++
apply Permutation.Permutation_app_inv_l with (a :: nil).
-----
Lemma PermSorted : forall (l l' : list positive), Permutation.Permutation l l' -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l' -> l = l'.
Proof.
intro l.
induction l.
intro l'.
induction l'.
intros HPerm Hl Hl'.
assert (HIna' : In a (a :: l)).
idtac.
assert (HIna : In a (a0 :: l')).
idtac.
assert (HIna0' : In a0 (a0 :: l')).
idtac.
assert (HIna0 : In a0 (a :: l)).
idtac.
clear HIna'.
clear HIna0'.
apply in_inv in HIna.
apply in_inv in HIna0.
elim HIna.
clear HIna.
intro HIna.
elim HIna0.
clear HIna0.
intro HIna0.
try (rewrite HIna in *).
try (rewrite <- HIna0 in *).
assert (HPerm' : Permutation.Permutation l l').
apply Permutation.Permutation_app_inv_l with (a :: nil).

*****
HIna0 : In a l
HIna : eq a0 a
Hl' : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l')
Hl : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l)
HPerm : Permutation.Permutation (cons a l) (cons a l')
IHl' : forall (_ : Permutation.Permutation (cons a l) l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l))\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq (cons a l) l'
l' : list positive
a0 : positive
IHl : forall (l' : list positive) (_ : Permutation.Permutation l l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) l)\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq l l'
l : list positive
a : positive
*****
Permutation.Permutation (Datatypes.app (cons a nil) l) (Datatypes.app (cons a nil) l')
+++++
simpl.
-----
Lemma PermSorted : forall (l l' : list positive), Permutation.Permutation l l' -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l' -> l = l'.
Proof.
intro l.
induction l.
intro l'.
induction l'.
intros HPerm Hl Hl'.
assert (HIna' : In a (a :: l)).
idtac.
assert (HIna : In a (a0 :: l')).
idtac.
assert (HIna0' : In a0 (a0 :: l')).
idtac.
assert (HIna0 : In a0 (a :: l)).
idtac.
clear HIna'.
clear HIna0'.
apply in_inv in HIna.
apply in_inv in HIna0.
elim HIna.
clear HIna.
intro HIna.
elim HIna0.
clear HIna0.
intro HIna0.
try (rewrite HIna in *).
try (rewrite <- HIna0 in *).
assert (HPerm' : Permutation.Permutation l l').
apply Permutation.Permutation_app_inv_l with (a :: nil).
simpl.

*****
HIna0 : In a l
HIna : eq a0 a
Hl' : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l')
Hl : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l)
HPerm : Permutation.Permutation (cons a l) (cons a l')
IHl' : forall (_ : Permutation.Permutation (cons a l) l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l))\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq (cons a l) l'
l' : list positive
a0 : positive
IHl : forall (l' : list positive) (_ : Permutation.Permutation l l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) l)\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq l l'
l : list positive
a : positive
*****
Permutation.Permutation (cons a l) (cons a l')
+++++
assumption.
-----
Lemma PermSorted : forall (l l' : list positive), Permutation.Permutation l l' -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l' -> l = l'.
Proof.
intro l.
induction l.
intro l'.
induction l'.
intros HPerm Hl Hl'.
assert (HIna' : In a (a :: l)).
idtac.
assert (HIna : In a (a0 :: l')).
idtac.
assert (HIna0' : In a0 (a0 :: l')).
idtac.
assert (HIna0 : In a0 (a :: l)).
idtac.
clear HIna'.
clear HIna0'.
apply in_inv in HIna.
apply in_inv in HIna0.
elim HIna.
clear HIna.
intro HIna.
elim HIna0.
clear HIna0.
intro HIna0.
try (rewrite HIna in *).
try (rewrite <- HIna0 in *).
assert (HPerm' : Permutation.Permutation l l').

*****
HPerm' : Permutation.Permutation l l'
HIna0 : In a l
HIna : eq a0 a
Hl' : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l')
Hl : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l)
HPerm : Permutation.Permutation (cons a l) (cons a l')
IHl' : forall (_ : Permutation.Permutation (cons a l) l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l))\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq (cons a l) l'
l' : list positive
a0 : positive
IHl : forall (l' : list positive) (_ : Permutation.Permutation l l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) l)\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq l l'
l : list positive
a : positive
*****
eq (cons a l) (cons a l')
+++++
idtac.
-----
Lemma PermSorted : forall (l l' : list positive), Permutation.Permutation l l' -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l' -> l = l'.
Proof.
intro l.
induction l.
intro l'.
induction l'.
intros HPerm Hl Hl'.
assert (HIna' : In a (a :: l)).
idtac.
assert (HIna : In a (a0 :: l')).
idtac.
assert (HIna0' : In a0 (a0 :: l')).
idtac.
assert (HIna0 : In a0 (a :: l)).
idtac.
clear HIna'.
clear HIna0'.
apply in_inv in HIna.
apply in_inv in HIna0.
elim HIna.
clear HIna.
intro HIna.
elim HIna0.
clear HIna0.
intro HIna0.
try (rewrite HIna in *).
try (rewrite <- HIna0 in *).
assert (HPerm' : Permutation.Permutation l l').
idtac.

*****
HPerm' : Permutation.Permutation l l'
HIna0 : In a l
HIna : eq a0 a
Hl' : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l')
Hl : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l)
HPerm : Permutation.Permutation (cons a l) (cons a l')
IHl' : forall (_ : Permutation.Permutation (cons a l) l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l))\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq (cons a l) l'
l' : list positive
a0 : positive
IHl : forall (l' : list positive) (_ : Permutation.Permutation l l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) l)\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq l l'
l : list positive
a : positive
*****
eq (cons a l) (cons a l')
+++++
apply OCPSortedTl in Hl.
-----
Lemma PermSorted : forall (l l' : list positive), Permutation.Permutation l l' -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l' -> l = l'.
Proof.
intro l.
induction l.
intro l'.
induction l'.
intros HPerm Hl Hl'.
assert (HIna' : In a (a :: l)).
idtac.
assert (HIna : In a (a0 :: l')).
idtac.
assert (HIna0' : In a0 (a0 :: l')).
idtac.
assert (HIna0 : In a0 (a :: l)).
idtac.
clear HIna'.
clear HIna0'.
apply in_inv in HIna.
apply in_inv in HIna0.
elim HIna.
clear HIna.
intro HIna.
elim HIna0.
clear HIna0.
intro HIna0.
try (rewrite HIna in *).
try (rewrite <- HIna0 in *).
assert (HPerm' : Permutation.Permutation l l').
idtac.
apply OCPSortedTl in Hl.

*****
HPerm' : Permutation.Permutation l l'
HIna0 : In a l
HIna : eq a0 a
Hl' : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l')
Hl : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (tl (cons a l))
HPerm : Permutation.Permutation (cons a l) (cons a l')
IHl' : forall (_ : Permutation.Permutation (cons a l) l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l))\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq (cons a l) l'
l' : list positive
a0 : positive
IHl : forall (l' : list positive) (_ : Permutation.Permutation l l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) l)\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq l l'
l : list positive
a : positive
*****
eq (cons a l) (cons a l')
+++++
apply OCPSortedTl in Hl'.
-----
Lemma PermSorted : forall (l l' : list positive), Permutation.Permutation l l' -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l' -> l = l'.
Proof.
intro l.
induction l.
intro l'.
induction l'.
intros HPerm Hl Hl'.
assert (HIna' : In a (a :: l)).
idtac.
assert (HIna : In a (a0 :: l')).
idtac.
assert (HIna0' : In a0 (a0 :: l')).
idtac.
assert (HIna0 : In a0 (a :: l)).
idtac.
clear HIna'.
clear HIna0'.
apply in_inv in HIna.
apply in_inv in HIna0.
elim HIna.
clear HIna.
intro HIna.
elim HIna0.
clear HIna0.
intro HIna0.
try (rewrite HIna in *).
try (rewrite <- HIna0 in *).
assert (HPerm' : Permutation.Permutation l l').
idtac.
apply OCPSortedTl in Hl.
apply OCPSortedTl in Hl'.

*****
HPerm' : Permutation.Permutation l l'
HIna0 : In a l
HIna : eq a0 a
Hl' : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (tl (cons a l'))
Hl : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (tl (cons a l))
HPerm : Permutation.Permutation (cons a l) (cons a l')
IHl' : forall (_ : Permutation.Permutation (cons a l) l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l))\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq (cons a l) l'
l' : list positive
a0 : positive
IHl : forall (l' : list positive) (_ : Permutation.Permutation l l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) l)\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq l l'
l : list positive
a : positive
*****
eq (cons a l) (cons a l')
+++++
apply IHl in HPerm'.
-----
Lemma PermSorted : forall (l l' : list positive), Permutation.Permutation l l' -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l' -> l = l'.
Proof.
intro l.
induction l.
intro l'.
induction l'.
intros HPerm Hl Hl'.
assert (HIna' : In a (a :: l)).
idtac.
assert (HIna : In a (a0 :: l')).
idtac.
assert (HIna0' : In a0 (a0 :: l')).
idtac.
assert (HIna0 : In a0 (a :: l)).
idtac.
clear HIna'.
clear HIna0'.
apply in_inv in HIna.
apply in_inv in HIna0.
elim HIna.
clear HIna.
intro HIna.
elim HIna0.
clear HIna0.
intro HIna0.
try (rewrite HIna in *).
try (rewrite <- HIna0 in *).
assert (HPerm' : Permutation.Permutation l l').
idtac.
apply OCPSortedTl in Hl.
apply OCPSortedTl in Hl'.
apply IHl in HPerm'.

*****
HPerm' : eq l l'
HIna0 : In a l
HIna : eq a0 a
Hl' : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (tl (cons a l'))
Hl : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (tl (cons a l))
HPerm : Permutation.Permutation (cons a l) (cons a l')
IHl' : forall (_ : Permutation.Permutation (cons a l) l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l))\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq (cons a l) l'
l' : list positive
a0 : positive
IHl : forall (l' : list positive) (_ : Permutation.Permutation l l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) l)\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq l l'
l : list positive
a : positive
*****
eq (cons a l) (cons a l')
+++++
try assumption.
-----
Lemma PermSorted : forall (l l' : list positive), Permutation.Permutation l l' -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l' -> l = l'.
Proof.
intro l.
induction l.
intro l'.
induction l'.
intros HPerm Hl Hl'.
assert (HIna' : In a (a :: l)).
idtac.
assert (HIna : In a (a0 :: l')).
idtac.
assert (HIna0' : In a0 (a0 :: l')).
idtac.
assert (HIna0 : In a0 (a :: l)).
idtac.
clear HIna'.
clear HIna0'.
apply in_inv in HIna.
apply in_inv in HIna0.
elim HIna.
clear HIna.
intro HIna.
elim HIna0.
clear HIna0.
intro HIna0.
try (rewrite HIna in *).
try (rewrite <- HIna0 in *).
assert (HPerm' : Permutation.Permutation l l').
idtac.
apply OCPSortedTl in Hl.
apply OCPSortedTl in Hl'.
apply IHl in HPerm'.
try assumption.

*****
HPerm' : eq l l'
HIna0 : In a l
HIna : eq a0 a
Hl' : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (tl (cons a l'))
Hl : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (tl (cons a l))
HPerm : Permutation.Permutation (cons a l) (cons a l')
IHl' : forall (_ : Permutation.Permutation (cons a l) l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l))\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq (cons a l) l'
l' : list positive
a0 : positive
IHl : forall (l' : list positive) (_ : Permutation.Permutation l l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) l)\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq l l'
l : list positive
a : positive
*****
eq (cons a l) (cons a l')
+++++
rewrite HPerm'.
-----
Lemma PermSorted : forall (l l' : list positive), Permutation.Permutation l l' -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l' -> l = l'.
Proof.
intro l.
induction l.
intro l'.
induction l'.
intros HPerm Hl Hl'.
assert (HIna' : In a (a :: l)).
idtac.
assert (HIna : In a (a0 :: l')).
idtac.
assert (HIna0' : In a0 (a0 :: l')).
idtac.
assert (HIna0 : In a0 (a :: l)).
idtac.
clear HIna'.
clear HIna0'.
apply in_inv in HIna.
apply in_inv in HIna0.
elim HIna.
clear HIna.
intro HIna.
elim HIna0.
clear HIna0.
intro HIna0.
try (rewrite HIna in *).
try (rewrite <- HIna0 in *).
assert (HPerm' : Permutation.Permutation l l').
idtac.
apply OCPSortedTl in Hl.
apply OCPSortedTl in Hl'.
apply IHl in HPerm'.
try assumption.
rewrite HPerm'.

*****
HPerm' : eq l l'
HIna0 : In a l
HIna : eq a0 a
Hl' : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (tl (cons a l'))
Hl : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (tl (cons a l))
HPerm : Permutation.Permutation (cons a l) (cons a l')
IHl' : forall (_ : Permutation.Permutation (cons a l) l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l))\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq (cons a l) l'
l' : list positive
a0 : positive
IHl : forall (l' : list positive) (_ : Permutation.Permutation l l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) l)\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq l l'
l : list positive
a : positive
*****
eq (cons a l') (cons a l')
+++++
reflexivity.
-----
Lemma PermSorted : forall (l l' : list positive), Permutation.Permutation l l' -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l' -> l = l'.
Proof.
intro l.
induction l.
intro l'.
induction l'.
intros HPerm Hl Hl'.
assert (HIna' : In a (a :: l)).
idtac.
assert (HIna : In a (a0 :: l')).
idtac.
assert (HIna0' : In a0 (a0 :: l')).
idtac.
assert (HIna0 : In a0 (a :: l)).
idtac.
clear HIna'.
clear HIna0'.
apply in_inv in HIna.
apply in_inv in HIna0.
elim HIna.
clear HIna.
intro HIna.
elim HIna0.
clear HIna0.
intro HIna0.
try (rewrite HIna in *).
try (rewrite <- HIna0 in *).
assert (HPerm' : Permutation.Permutation l l').
idtac.
apply OCPSortedTl in Hl.
apply OCPSortedTl in Hl'.
apply IHl in HPerm'.

*****
HPerm' : Permutation.Permutation l l'
HIna0 : In a l
HIna : eq a0 a
Hl' : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (tl (cons a l'))
Hl : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (tl (cons a l))
HPerm : Permutation.Permutation (cons a l) (cons a l')
IHl' : forall (_ : Permutation.Permutation (cons a l) l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l))\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq (cons a l) l'
l' : list positive
a0 : positive
IHl : forall (l' : list positive) (_ : Permutation.Permutation l l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) l)\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq l l'
l : list positive
a : positive
*****
StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) l
+++++
try assumption.
-----
Lemma PermSorted : forall (l l' : list positive), Permutation.Permutation l l' -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l' -> l = l'.
Proof.
intro l.
induction l.
intro l'.
induction l'.
intros HPerm Hl Hl'.
assert (HIna' : In a (a :: l)).
idtac.
assert (HIna : In a (a0 :: l')).
idtac.
assert (HIna0' : In a0 (a0 :: l')).
idtac.
assert (HIna0 : In a0 (a :: l)).
idtac.
clear HIna'.
clear HIna0'.
apply in_inv in HIna.
apply in_inv in HIna0.
elim HIna.
clear HIna.
intro HIna.
elim HIna0.
clear HIna0.
intro HIna0.
try (rewrite HIna in *).
try (rewrite <- HIna0 in *).
assert (HPerm' : Permutation.Permutation l l').
idtac.
apply OCPSortedTl in Hl.
apply OCPSortedTl in Hl'.
apply IHl in HPerm'.

*****
HPerm' : Permutation.Permutation l l'
HIna0 : In a l
HIna : eq a0 a
Hl' : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (tl (cons a l'))
Hl : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (tl (cons a l))
HPerm : Permutation.Permutation (cons a l) (cons a l')
IHl' : forall (_ : Permutation.Permutation (cons a l) l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l))\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq (cons a l) l'
l' : list positive
a0 : positive
IHl : forall (l' : list positive) (_ : Permutation.Permutation l l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) l)\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq l l'
l : list positive
a : positive
*****
StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) l'
+++++
try assumption.
-----
Lemma PermSorted : forall (l l' : list positive), Permutation.Permutation l l' -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l' -> l = l'.
Proof.
intro l.
induction l.
intro l'.
induction l'.
intros HPerm Hl Hl'.
assert (HIna' : In a (a :: l)).
idtac.
assert (HIna : In a (a0 :: l')).
idtac.
assert (HIna0' : In a0 (a0 :: l')).
idtac.
assert (HIna0 : In a0 (a :: l)).
idtac.
clear HIna'.
clear HIna0'.
apply in_inv in HIna.
apply in_inv in HIna0.
elim HIna.

*****
HIna0 : or (eq a a0) (In a0 l)
HIna : or (eq a0 a) (In a l')
Hl' : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a0 l')
Hl : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l)
HPerm : Permutation.Permutation (cons a l) (cons a0 l')
IHl' : forall (_ : Permutation.Permutation (cons a l) l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l))\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq (cons a l) l'
l' : list positive
a0 : positive
IHl : forall (l' : list positive) (_ : Permutation.Permutation l l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) l)\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq l l'
l : list positive
a : positive
*****
forall _ : In a l', eq (cons a l) (cons a0 l')
+++++
clear HIna.
-----
Lemma PermSorted : forall (l l' : list positive), Permutation.Permutation l l' -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l' -> l = l'.
Proof.
intro l.
induction l.
intro l'.
induction l'.
intros HPerm Hl Hl'.
assert (HIna' : In a (a :: l)).
idtac.
assert (HIna : In a (a0 :: l')).
idtac.
assert (HIna0' : In a0 (a0 :: l')).
idtac.
assert (HIna0 : In a0 (a :: l)).
idtac.
clear HIna'.
clear HIna0'.
apply in_inv in HIna.
apply in_inv in HIna0.
elim HIna.
clear HIna.

*****
HIna0 : or (eq a a0) (In a0 l)
Hl' : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a0 l')
Hl : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l)
HPerm : Permutation.Permutation (cons a l) (cons a0 l')
IHl' : forall (_ : Permutation.Permutation (cons a l) l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l))\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq (cons a l) l'
l' : list positive
a0 : positive
IHl : forall (l' : list positive) (_ : Permutation.Permutation l l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) l)\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq l l'
l : list positive
a : positive
*****
forall _ : In a l', eq (cons a l) (cons a0 l')
+++++
intro HIna.
-----
Lemma PermSorted : forall (l l' : list positive), Permutation.Permutation l l' -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l' -> l = l'.
Proof.
intro l.
induction l.
intro l'.
induction l'.
intros HPerm Hl Hl'.
assert (HIna' : In a (a :: l)).
idtac.
assert (HIna : In a (a0 :: l')).
idtac.
assert (HIna0' : In a0 (a0 :: l')).
idtac.
assert (HIna0 : In a0 (a :: l)).
idtac.
clear HIna'.
clear HIna0'.
apply in_inv in HIna.
apply in_inv in HIna0.
elim HIna.
clear HIna.
intro HIna.

*****
HIna : In a l'
HIna0 : or (eq a a0) (In a0 l)
Hl' : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a0 l')
Hl : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l)
HPerm : Permutation.Permutation (cons a l) (cons a0 l')
IHl' : forall (_ : Permutation.Permutation (cons a l) l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l))\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq (cons a l) l'
l' : list positive
a0 : positive
IHl : forall (l' : list positive) (_ : Permutation.Permutation l l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) l)\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq l l'
l : list positive
a : positive
*****
eq (cons a l) (cons a0 l')
+++++
elim HIna0.
-----
Lemma PermSorted : forall (l l' : list positive), Permutation.Permutation l l' -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l' -> l = l'.
Proof.
intro l.
induction l.
intro l'.
induction l'.
intros HPerm Hl Hl'.
assert (HIna' : In a (a :: l)).
idtac.
assert (HIna : In a (a0 :: l')).
idtac.
assert (HIna0' : In a0 (a0 :: l')).
idtac.
assert (HIna0 : In a0 (a :: l)).
idtac.
clear HIna'.
clear HIna0'.
apply in_inv in HIna.
apply in_inv in HIna0.
elim HIna.
clear HIna.
intro HIna.
elim HIna0.

*****
HIna : In a l'
HIna0 : or (eq a a0) (In a0 l)
Hl' : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a0 l')
Hl : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l)
HPerm : Permutation.Permutation (cons a l) (cons a0 l')
IHl' : forall (_ : Permutation.Permutation (cons a l) l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l))\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq (cons a l) l'
l' : list positive
a0 : positive
IHl : forall (l' : list positive) (_ : Permutation.Permutation l l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) l)\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq l l'
l : list positive
a : positive
*****
forall _ : eq a a0, eq (cons a l) (cons a0 l')
+++++
clear HIna0.
-----
Lemma PermSorted : forall (l l' : list positive), Permutation.Permutation l l' -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l' -> l = l'.
Proof.
intro l.
induction l.
intro l'.
induction l'.
intros HPerm Hl Hl'.
assert (HIna' : In a (a :: l)).
idtac.
assert (HIna : In a (a0 :: l')).
idtac.
assert (HIna0' : In a0 (a0 :: l')).
idtac.
assert (HIna0 : In a0 (a :: l)).
idtac.
clear HIna'.
clear HIna0'.
apply in_inv in HIna.
apply in_inv in HIna0.
elim HIna.
clear HIna.
intro HIna.
elim HIna0.
clear HIna0.

*****
HIna : In a l'
Hl' : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a0 l')
Hl : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l)
HPerm : Permutation.Permutation (cons a l) (cons a0 l')
IHl' : forall (_ : Permutation.Permutation (cons a l) l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l))\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq (cons a l) l'
l' : list positive
a0 : positive
IHl : forall (l' : list positive) (_ : Permutation.Permutation l l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) l)\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq l l'
l : list positive
a : positive
*****
forall _ : eq a a0, eq (cons a l) (cons a0 l')
+++++
intro HIna0.
-----
Lemma PermSorted : forall (l l' : list positive), Permutation.Permutation l l' -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l' -> l = l'.
Proof.
intro l.
induction l.
intro l'.
induction l'.
intros HPerm Hl Hl'.
assert (HIna' : In a (a :: l)).
idtac.
assert (HIna : In a (a0 :: l')).
idtac.
assert (HIna0' : In a0 (a0 :: l')).
idtac.
assert (HIna0 : In a0 (a :: l)).
idtac.
clear HIna'.
clear HIna0'.
apply in_inv in HIna.
apply in_inv in HIna0.
elim HIna.
clear HIna.
intro HIna.
elim HIna0.
clear HIna0.
intro HIna0.

*****
HIna0 : eq a a0
HIna : In a l'
Hl' : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a0 l')
Hl : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l)
HPerm : Permutation.Permutation (cons a l) (cons a0 l')
IHl' : forall (_ : Permutation.Permutation (cons a l) l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l))\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq (cons a l) l'
l' : list positive
a0 : positive
IHl : forall (l' : list positive) (_ : Permutation.Permutation l l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) l)\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq l l'
l : list positive
a : positive
*****
eq (cons a l) (cons a0 l')
+++++
try (rewrite HIna in *).
-----
Lemma PermSorted : forall (l l' : list positive), Permutation.Permutation l l' -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l' -> l = l'.
Proof.
intro l.
induction l.
intro l'.
induction l'.
intros HPerm Hl Hl'.
assert (HIna' : In a (a :: l)).
idtac.
assert (HIna : In a (a0 :: l')).
idtac.
assert (HIna0' : In a0 (a0 :: l')).
idtac.
assert (HIna0 : In a0 (a :: l)).
idtac.
clear HIna'.
clear HIna0'.
apply in_inv in HIna.
apply in_inv in HIna0.
elim HIna.
clear HIna.
intro HIna.
elim HIna0.
clear HIna0.
intro HIna0.
try (rewrite HIna in *).

*****
HIna0 : eq a a0
HIna : In a l'
Hl' : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a0 l')
Hl : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l)
HPerm : Permutation.Permutation (cons a l) (cons a0 l')
IHl' : forall (_ : Permutation.Permutation (cons a l) l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l))\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq (cons a l) l'
l' : list positive
a0 : positive
IHl : forall (l' : list positive) (_ : Permutation.Permutation l l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) l)\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq l l'
l : list positive
a : positive
*****
eq (cons a l) (cons a0 l')
+++++
try (rewrite <- HIna0 in *).
-----
Lemma PermSorted : forall (l l' : list positive), Permutation.Permutation l l' -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l' -> l = l'.
Proof.
intro l.
induction l.
intro l'.
induction l'.
intros HPerm Hl Hl'.
assert (HIna' : In a (a :: l)).
idtac.
assert (HIna : In a (a0 :: l')).
idtac.
assert (HIna0' : In a0 (a0 :: l')).
idtac.
assert (HIna0 : In a0 (a :: l)).
idtac.
clear HIna'.
clear HIna0'.
apply in_inv in HIna.
apply in_inv in HIna0.
elim HIna.
clear HIna.
intro HIna.
elim HIna0.
clear HIna0.
intro HIna0.
try (rewrite HIna in *).
try (rewrite <- HIna0 in *).

*****
HIna0 : eq a a0
HIna : In a l'
Hl' : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l')
Hl : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l)
HPerm : Permutation.Permutation (cons a l) (cons a l')
IHl' : forall (_ : Permutation.Permutation (cons a l) l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l))\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq (cons a l) l'
l' : list positive
a0 : positive
IHl : forall (l' : list positive) (_ : Permutation.Permutation l l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) l)\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq l l'
l : list positive
a : positive
*****
eq (cons a l) (cons a l')
+++++
assert (HPerm' : Permutation.Permutation l l').
-----
Lemma PermSorted : forall (l l' : list positive), Permutation.Permutation l l' -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l' -> l = l'.
Proof.
intro l.
induction l.
intro l'.
induction l'.
intros HPerm Hl Hl'.
assert (HIna' : In a (a :: l)).
idtac.
assert (HIna : In a (a0 :: l')).
idtac.
assert (HIna0' : In a0 (a0 :: l')).
idtac.
assert (HIna0 : In a0 (a :: l)).
idtac.
clear HIna'.
clear HIna0'.
apply in_inv in HIna.
apply in_inv in HIna0.
elim HIna.
clear HIna.
intro HIna.
elim HIna0.
clear HIna0.
intro HIna0.
try (rewrite HIna in *).
try (rewrite <- HIna0 in *).
assert (HPerm' : Permutation.Permutation l l').

*****
HIna0 : eq a a0
HIna : In a l'
Hl' : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l')
Hl : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l)
HPerm : Permutation.Permutation (cons a l) (cons a l')
IHl' : forall (_ : Permutation.Permutation (cons a l) l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l))\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq (cons a l) l'
l' : list positive
a0 : positive
IHl : forall (l' : list positive) (_ : Permutation.Permutation l l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) l)\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq l l'
l : list positive
a : positive
*****
Permutation.Permutation l l'
+++++
apply Permutation.Permutation_app_inv_l with (a :: nil).
-----
Lemma PermSorted : forall (l l' : list positive), Permutation.Permutation l l' -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l' -> l = l'.
Proof.
intro l.
induction l.
intro l'.
induction l'.
intros HPerm Hl Hl'.
assert (HIna' : In a (a :: l)).
idtac.
assert (HIna : In a (a0 :: l')).
idtac.
assert (HIna0' : In a0 (a0 :: l')).
idtac.
assert (HIna0 : In a0 (a :: l)).
idtac.
clear HIna'.
clear HIna0'.
apply in_inv in HIna.
apply in_inv in HIna0.
elim HIna.
clear HIna.
intro HIna.
elim HIna0.
clear HIna0.
intro HIna0.
try (rewrite HIna in *).
try (rewrite <- HIna0 in *).
assert (HPerm' : Permutation.Permutation l l').
apply Permutation.Permutation_app_inv_l with (a :: nil).

*****
HIna0 : eq a a0
HIna : In a l'
Hl' : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l')
Hl : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l)
HPerm : Permutation.Permutation (cons a l) (cons a l')
IHl' : forall (_ : Permutation.Permutation (cons a l) l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l))\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq (cons a l) l'
l' : list positive
a0 : positive
IHl : forall (l' : list positive) (_ : Permutation.Permutation l l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) l)\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq l l'
l : list positive
a : positive
*****
Permutation.Permutation (Datatypes.app (cons a nil) l) (Datatypes.app (cons a nil) l')
+++++
simpl.
-----
Lemma PermSorted : forall (l l' : list positive), Permutation.Permutation l l' -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l' -> l = l'.
Proof.
intro l.
induction l.
intro l'.
induction l'.
intros HPerm Hl Hl'.
assert (HIna' : In a (a :: l)).
idtac.
assert (HIna : In a (a0 :: l')).
idtac.
assert (HIna0' : In a0 (a0 :: l')).
idtac.
assert (HIna0 : In a0 (a :: l)).
idtac.
clear HIna'.
clear HIna0'.
apply in_inv in HIna.
apply in_inv in HIna0.
elim HIna.
clear HIna.
intro HIna.
elim HIna0.
clear HIna0.
intro HIna0.
try (rewrite HIna in *).
try (rewrite <- HIna0 in *).
assert (HPerm' : Permutation.Permutation l l').
apply Permutation.Permutation_app_inv_l with (a :: nil).
simpl.

*****
HIna0 : eq a a0
HIna : In a l'
Hl' : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l')
Hl : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l)
HPerm : Permutation.Permutation (cons a l) (cons a l')
IHl' : forall (_ : Permutation.Permutation (cons a l) l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l))\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq (cons a l) l'
l' : list positive
a0 : positive
IHl : forall (l' : list positive) (_ : Permutation.Permutation l l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) l)\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq l l'
l : list positive
a : positive
*****
Permutation.Permutation (cons a l) (cons a l')
+++++
assumption.
-----
Lemma PermSorted : forall (l l' : list positive), Permutation.Permutation l l' -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l' -> l = l'.
Proof.
intro l.
induction l.
intro l'.
induction l'.
intros HPerm Hl Hl'.
assert (HIna' : In a (a :: l)).
idtac.
assert (HIna : In a (a0 :: l')).
idtac.
assert (HIna0' : In a0 (a0 :: l')).
idtac.
assert (HIna0 : In a0 (a :: l)).
idtac.
clear HIna'.
clear HIna0'.
apply in_inv in HIna.
apply in_inv in HIna0.
elim HIna.
clear HIna.
intro HIna.
elim HIna0.
clear HIna0.
intro HIna0.
try (rewrite HIna in *).
try (rewrite <- HIna0 in *).
assert (HPerm' : Permutation.Permutation l l').

*****
HPerm' : Permutation.Permutation l l'
HIna0 : eq a a0
HIna : In a l'
Hl' : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l')
Hl : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l)
HPerm : Permutation.Permutation (cons a l) (cons a l')
IHl' : forall (_ : Permutation.Permutation (cons a l) l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l))\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq (cons a l) l'
l' : list positive
a0 : positive
IHl : forall (l' : list positive) (_ : Permutation.Permutation l l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) l)\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq l l'
l : list positive
a : positive
*****
eq (cons a l) (cons a l')
+++++
idtac.
-----
Lemma PermSorted : forall (l l' : list positive), Permutation.Permutation l l' -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l' -> l = l'.
Proof.
intro l.
induction l.
intro l'.
induction l'.
intros HPerm Hl Hl'.
assert (HIna' : In a (a :: l)).
idtac.
assert (HIna : In a (a0 :: l')).
idtac.
assert (HIna0' : In a0 (a0 :: l')).
idtac.
assert (HIna0 : In a0 (a :: l)).
idtac.
clear HIna'.
clear HIna0'.
apply in_inv in HIna.
apply in_inv in HIna0.
elim HIna.
clear HIna.
intro HIna.
elim HIna0.
clear HIna0.
intro HIna0.
try (rewrite HIna in *).
try (rewrite <- HIna0 in *).
assert (HPerm' : Permutation.Permutation l l').
idtac.

*****
HPerm' : Permutation.Permutation l l'
HIna0 : eq a a0
HIna : In a l'
Hl' : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l')
Hl : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l)
HPerm : Permutation.Permutation (cons a l) (cons a l')
IHl' : forall (_ : Permutation.Permutation (cons a l) l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l))\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq (cons a l) l'
l' : list positive
a0 : positive
IHl : forall (l' : list positive) (_ : Permutation.Permutation l l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) l)\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq l l'
l : list positive
a : positive
*****
eq (cons a l) (cons a l')
+++++
apply OCPSortedTl in Hl.
-----
Lemma PermSorted : forall (l l' : list positive), Permutation.Permutation l l' -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l' -> l = l'.
Proof.
intro l.
induction l.
intro l'.
induction l'.
intros HPerm Hl Hl'.
assert (HIna' : In a (a :: l)).
idtac.
assert (HIna : In a (a0 :: l')).
idtac.
assert (HIna0' : In a0 (a0 :: l')).
idtac.
assert (HIna0 : In a0 (a :: l)).
idtac.
clear HIna'.
clear HIna0'.
apply in_inv in HIna.
apply in_inv in HIna0.
elim HIna.
clear HIna.
intro HIna.
elim HIna0.
clear HIna0.
intro HIna0.
try (rewrite HIna in *).
try (rewrite <- HIna0 in *).
assert (HPerm' : Permutation.Permutation l l').
idtac.
apply OCPSortedTl in Hl.

*****
HPerm' : Permutation.Permutation l l'
HIna0 : eq a a0
HIna : In a l'
Hl' : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l')
Hl : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (tl (cons a l))
HPerm : Permutation.Permutation (cons a l) (cons a l')
IHl' : forall (_ : Permutation.Permutation (cons a l) l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l))\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq (cons a l) l'
l' : list positive
a0 : positive
IHl : forall (l' : list positive) (_ : Permutation.Permutation l l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) l)\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq l l'
l : list positive
a : positive
*****
eq (cons a l) (cons a l')
+++++
apply OCPSortedTl in Hl'.
-----
Lemma PermSorted : forall (l l' : list positive), Permutation.Permutation l l' -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l' -> l = l'.
Proof.
intro l.
induction l.
intro l'.
induction l'.
intros HPerm Hl Hl'.
assert (HIna' : In a (a :: l)).
idtac.
assert (HIna : In a (a0 :: l')).
idtac.
assert (HIna0' : In a0 (a0 :: l')).
idtac.
assert (HIna0 : In a0 (a :: l)).
idtac.
clear HIna'.
clear HIna0'.
apply in_inv in HIna.
apply in_inv in HIna0.
elim HIna.
clear HIna.
intro HIna.
elim HIna0.
clear HIna0.
intro HIna0.
try (rewrite HIna in *).
try (rewrite <- HIna0 in *).
assert (HPerm' : Permutation.Permutation l l').
idtac.
apply OCPSortedTl in Hl.
apply OCPSortedTl in Hl'.

*****
HPerm' : Permutation.Permutation l l'
HIna0 : eq a a0
HIna : In a l'
Hl' : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (tl (cons a l'))
Hl : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (tl (cons a l))
HPerm : Permutation.Permutation (cons a l) (cons a l')
IHl' : forall (_ : Permutation.Permutation (cons a l) l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l))\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq (cons a l) l'
l' : list positive
a0 : positive
IHl : forall (l' : list positive) (_ : Permutation.Permutation l l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) l)\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq l l'
l : list positive
a : positive
*****
eq (cons a l) (cons a l')
+++++
apply IHl in HPerm'.
-----
Lemma PermSorted : forall (l l' : list positive), Permutation.Permutation l l' -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l' -> l = l'.
Proof.
intro l.
induction l.
intro l'.
induction l'.
intros HPerm Hl Hl'.
assert (HIna' : In a (a :: l)).
idtac.
assert (HIna : In a (a0 :: l')).
idtac.
assert (HIna0' : In a0 (a0 :: l')).
idtac.
assert (HIna0 : In a0 (a :: l)).
idtac.
clear HIna'.
clear HIna0'.
apply in_inv in HIna.
apply in_inv in HIna0.
elim HIna.
clear HIna.
intro HIna.
elim HIna0.
clear HIna0.
intro HIna0.
try (rewrite HIna in *).
try (rewrite <- HIna0 in *).
assert (HPerm' : Permutation.Permutation l l').
idtac.
apply OCPSortedTl in Hl.
apply OCPSortedTl in Hl'.
apply IHl in HPerm'.

*****
HPerm' : eq l l'
HIna0 : eq a a0
HIna : In a l'
Hl' : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (tl (cons a l'))
Hl : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (tl (cons a l))
HPerm : Permutation.Permutation (cons a l) (cons a l')
IHl' : forall (_ : Permutation.Permutation (cons a l) l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l))\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq (cons a l) l'
l' : list positive
a0 : positive
IHl : forall (l' : list positive) (_ : Permutation.Permutation l l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) l)\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq l l'
l : list positive
a : positive
*****
eq (cons a l) (cons a l')
+++++
try assumption.
-----
Lemma PermSorted : forall (l l' : list positive), Permutation.Permutation l l' -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l' -> l = l'.
Proof.
intro l.
induction l.
intro l'.
induction l'.
intros HPerm Hl Hl'.
assert (HIna' : In a (a :: l)).
idtac.
assert (HIna : In a (a0 :: l')).
idtac.
assert (HIna0' : In a0 (a0 :: l')).
idtac.
assert (HIna0 : In a0 (a :: l)).
idtac.
clear HIna'.
clear HIna0'.
apply in_inv in HIna.
apply in_inv in HIna0.
elim HIna.
clear HIna.
intro HIna.
elim HIna0.
clear HIna0.
intro HIna0.
try (rewrite HIna in *).
try (rewrite <- HIna0 in *).
assert (HPerm' : Permutation.Permutation l l').
idtac.
apply OCPSortedTl in Hl.
apply OCPSortedTl in Hl'.
apply IHl in HPerm'.
try assumption.

*****
HPerm' : eq l l'
HIna0 : eq a a0
HIna : In a l'
Hl' : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (tl (cons a l'))
Hl : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (tl (cons a l))
HPerm : Permutation.Permutation (cons a l) (cons a l')
IHl' : forall (_ : Permutation.Permutation (cons a l) l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l))\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq (cons a l) l'
l' : list positive
a0 : positive
IHl : forall (l' : list positive) (_ : Permutation.Permutation l l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) l)\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq l l'
l : list positive
a : positive
*****
eq (cons a l) (cons a l')
+++++
rewrite HPerm'.
-----
Lemma PermSorted : forall (l l' : list positive), Permutation.Permutation l l' -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l' -> l = l'.
Proof.
intro l.
induction l.
intro l'.
induction l'.
intros HPerm Hl Hl'.
assert (HIna' : In a (a :: l)).
idtac.
assert (HIna : In a (a0 :: l')).
idtac.
assert (HIna0' : In a0 (a0 :: l')).
idtac.
assert (HIna0 : In a0 (a :: l)).
idtac.
clear HIna'.
clear HIna0'.
apply in_inv in HIna.
apply in_inv in HIna0.
elim HIna.
clear HIna.
intro HIna.
elim HIna0.
clear HIna0.
intro HIna0.
try (rewrite HIna in *).
try (rewrite <- HIna0 in *).
assert (HPerm' : Permutation.Permutation l l').
idtac.
apply OCPSortedTl in Hl.
apply OCPSortedTl in Hl'.
apply IHl in HPerm'.
try assumption.
rewrite HPerm'.

*****
HPerm' : eq l l'
HIna0 : eq a a0
HIna : In a l'
Hl' : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (tl (cons a l'))
Hl : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (tl (cons a l))
HPerm : Permutation.Permutation (cons a l) (cons a l')
IHl' : forall (_ : Permutation.Permutation (cons a l) l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l))\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq (cons a l) l'
l' : list positive
a0 : positive
IHl : forall (l' : list positive) (_ : Permutation.Permutation l l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) l)\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq l l'
l : list positive
a : positive
*****
eq (cons a l') (cons a l')
+++++
reflexivity.
-----
Lemma PermSorted : forall (l l' : list positive), Permutation.Permutation l l' -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l' -> l = l'.
Proof.
intro l.
induction l.
intro l'.
induction l'.
intros HPerm Hl Hl'.
assert (HIna' : In a (a :: l)).
idtac.
assert (HIna : In a (a0 :: l')).
idtac.
assert (HIna0' : In a0 (a0 :: l')).
idtac.
assert (HIna0 : In a0 (a :: l)).
idtac.
clear HIna'.
clear HIna0'.
apply in_inv in HIna.
apply in_inv in HIna0.
elim HIna.
clear HIna.
intro HIna.
elim HIna0.
clear HIna0.
intro HIna0.
try (rewrite HIna in *).
try (rewrite <- HIna0 in *).
assert (HPerm' : Permutation.Permutation l l').
idtac.
apply OCPSortedTl in Hl.
apply OCPSortedTl in Hl'.
apply IHl in HPerm'.

*****
HPerm' : Permutation.Permutation l l'
HIna0 : eq a a0
HIna : In a l'
Hl' : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (tl (cons a l'))
Hl : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (tl (cons a l))
HPerm : Permutation.Permutation (cons a l) (cons a l')
IHl' : forall (_ : Permutation.Permutation (cons a l) l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l))\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq (cons a l) l'
l' : list positive
a0 : positive
IHl : forall (l' : list positive) (_ : Permutation.Permutation l l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) l)\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq l l'
l : list positive
a : positive
*****
StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) l
+++++
try assumption.
-----
Lemma PermSorted : forall (l l' : list positive), Permutation.Permutation l l' -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l' -> l = l'.
Proof.
intro l.
induction l.
intro l'.
induction l'.
intros HPerm Hl Hl'.
assert (HIna' : In a (a :: l)).
idtac.
assert (HIna : In a (a0 :: l')).
idtac.
assert (HIna0' : In a0 (a0 :: l')).
idtac.
assert (HIna0 : In a0 (a :: l)).
idtac.
clear HIna'.
clear HIna0'.
apply in_inv in HIna.
apply in_inv in HIna0.
elim HIna.
clear HIna.
intro HIna.
elim HIna0.
clear HIna0.
intro HIna0.
try (rewrite HIna in *).
try (rewrite <- HIna0 in *).
assert (HPerm' : Permutation.Permutation l l').
idtac.
apply OCPSortedTl in Hl.
apply OCPSortedTl in Hl'.
apply IHl in HPerm'.

*****
HPerm' : Permutation.Permutation l l'
HIna0 : eq a a0
HIna : In a l'
Hl' : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (tl (cons a l'))
Hl : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (tl (cons a l))
HPerm : Permutation.Permutation (cons a l) (cons a l')
IHl' : forall (_ : Permutation.Permutation (cons a l) l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l))\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq (cons a l) l'
l' : list positive
a0 : positive
IHl : forall (l' : list positive) (_ : Permutation.Permutation l l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) l)\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq l l'
l : list positive
a : positive
*****
StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) l'
+++++
try assumption.
-----
Lemma PermSorted : forall (l l' : list positive), Permutation.Permutation l l' -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l' -> l = l'.
Proof.
intro l.
induction l.
intro l'.
induction l'.
intros HPerm Hl Hl'.
assert (HIna' : In a (a :: l)).
idtac.
assert (HIna : In a (a0 :: l')).
idtac.
assert (HIna0' : In a0 (a0 :: l')).
idtac.
assert (HIna0 : In a0 (a :: l)).
idtac.
clear HIna'.
clear HIna0'.
apply in_inv in HIna.
apply in_inv in HIna0.
elim HIna.
clear HIna.
intro HIna.
elim HIna0.

*****
HIna : In a l'
HIna0 : or (eq a a0) (In a0 l)
Hl' : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a0 l')
Hl : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l)
HPerm : Permutation.Permutation (cons a l) (cons a0 l')
IHl' : forall (_ : Permutation.Permutation (cons a l) l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l))\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq (cons a l) l'
l' : list positive
a0 : positive
IHl : forall (l' : list positive) (_ : Permutation.Permutation l l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) l)\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq l l'
l : list positive
a : positive
*****
forall _ : In a0 l, eq (cons a l) (cons a0 l')
+++++
clear HIna0.
-----
Lemma PermSorted : forall (l l' : list positive), Permutation.Permutation l l' -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l' -> l = l'.
Proof.
intro l.
induction l.
intro l'.
induction l'.
intros HPerm Hl Hl'.
assert (HIna' : In a (a :: l)).
idtac.
assert (HIna : In a (a0 :: l')).
idtac.
assert (HIna0' : In a0 (a0 :: l')).
idtac.
assert (HIna0 : In a0 (a :: l)).
idtac.
clear HIna'.
clear HIna0'.
apply in_inv in HIna.
apply in_inv in HIna0.
elim HIna.
clear HIna.
intro HIna.
elim HIna0.
clear HIna0.

*****
HIna : In a l'
Hl' : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a0 l')
Hl : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l)
HPerm : Permutation.Permutation (cons a l) (cons a0 l')
IHl' : forall (_ : Permutation.Permutation (cons a l) l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l))\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq (cons a l) l'
l' : list positive
a0 : positive
IHl : forall (l' : list positive) (_ : Permutation.Permutation l l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) l)\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq l l'
l : list positive
a : positive
*****
forall _ : In a0 l, eq (cons a l) (cons a0 l')
+++++
intro HIna0.
-----
Lemma PermSorted : forall (l l' : list positive), Permutation.Permutation l l' -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l' -> l = l'.
Proof.
intro l.
induction l.
intro l'.
induction l'.
intros HPerm Hl Hl'.
assert (HIna' : In a (a :: l)).
idtac.
assert (HIna : In a (a0 :: l')).
idtac.
assert (HIna0' : In a0 (a0 :: l')).
idtac.
assert (HIna0 : In a0 (a :: l)).
idtac.
clear HIna'.
clear HIna0'.
apply in_inv in HIna.
apply in_inv in HIna0.
elim HIna.
clear HIna.
intro HIna.
elim HIna0.
clear HIna0.
intro HIna0.

*****
HIna0 : In a0 l
HIna : In a l'
Hl' : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a0 l')
Hl : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l)
HPerm : Permutation.Permutation (cons a l) (cons a0 l')
IHl' : forall (_ : Permutation.Permutation (cons a l) l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l))\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq (cons a l) l'
l' : list positive
a0 : positive
IHl : forall (l' : list positive) (_ : Permutation.Permutation l l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) l)\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq l l'
l : list positive
a : positive
*****
eq (cons a l) (cons a0 l')
+++++
try (rewrite HIna in *).
-----
Lemma PermSorted : forall (l l' : list positive), Permutation.Permutation l l' -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l' -> l = l'.
Proof.
intro l.
induction l.
intro l'.
induction l'.
intros HPerm Hl Hl'.
assert (HIna' : In a (a :: l)).
idtac.
assert (HIna : In a (a0 :: l')).
idtac.
assert (HIna0' : In a0 (a0 :: l')).
idtac.
assert (HIna0 : In a0 (a :: l)).
idtac.
clear HIna'.
clear HIna0'.
apply in_inv in HIna.
apply in_inv in HIna0.
elim HIna.
clear HIna.
intro HIna.
elim HIna0.
clear HIna0.
intro HIna0.
try (rewrite HIna in *).

*****
HIna0 : In a0 l
HIna : In a l'
Hl' : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a0 l')
Hl : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l)
HPerm : Permutation.Permutation (cons a l) (cons a0 l')
IHl' : forall (_ : Permutation.Permutation (cons a l) l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l))\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq (cons a l) l'
l' : list positive
a0 : positive
IHl : forall (l' : list positive) (_ : Permutation.Permutation l l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) l)\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq l l'
l : list positive
a : positive
*****
eq (cons a l) (cons a0 l')
+++++
try (rewrite <- HIna0 in *).
-----
Lemma PermSorted : forall (l l' : list positive), Permutation.Permutation l l' -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l' -> l = l'.
Proof.
intro l.
induction l.
intro l'.
induction l'.
intros HPerm Hl Hl'.
assert (HIna' : In a (a :: l)).
idtac.
assert (HIna : In a (a0 :: l')).
idtac.
assert (HIna0' : In a0 (a0 :: l')).
idtac.
assert (HIna0 : In a0 (a :: l)).
idtac.
clear HIna'.
clear HIna0'.
apply in_inv in HIna.
apply in_inv in HIna0.
elim HIna.
clear HIna.
intro HIna.
elim HIna0.
clear HIna0.
intro HIna0.
try (rewrite HIna in *).
try (rewrite <- HIna0 in *).

*****
HIna0 : In a0 l
HIna : In a l'
Hl' : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a0 l')
Hl : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l)
HPerm : Permutation.Permutation (cons a l) (cons a0 l')
IHl' : forall (_ : Permutation.Permutation (cons a l) l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l))\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq (cons a l) l'
l' : list positive
a0 : positive
IHl : forall (l' : list positive) (_ : Permutation.Permutation l l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) l)\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq l l'
l : list positive
a : positive
*****
eq (cons a l) (cons a0 l')
+++++
assert (Hle1 := Hl).
-----
Lemma PermSorted : forall (l l' : list positive), Permutation.Permutation l l' -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l' -> l = l'.
Proof.
intro l.
induction l.
intro l'.
induction l'.
intros HPerm Hl Hl'.
assert (HIna' : In a (a :: l)).
idtac.
assert (HIna : In a (a0 :: l')).
idtac.
assert (HIna0' : In a0 (a0 :: l')).
idtac.
assert (HIna0 : In a0 (a :: l)).
idtac.
clear HIna'.
clear HIna0'.
apply in_inv in HIna.
apply in_inv in HIna0.
elim HIna.
clear HIna.
intro HIna.
elim HIna0.
clear HIna0.
intro HIna0.
try (rewrite HIna in *).
try (rewrite <- HIna0 in *).
assert (Hle1 := Hl).

*****
Hle1 : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l)
HIna0 : In a0 l
HIna : In a l'
Hl' : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a0 l')
Hl : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l)
HPerm : Permutation.Permutation (cons a l) (cons a0 l')
IHl' : forall (_ : Permutation.Permutation (cons a l) l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l))\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq (cons a l) l'
l' : list positive
a0 : positive
IHl : forall (l' : list positive) (_ : Permutation.Permutation l l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) l)\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq l l'
l : list positive
a : positive
*****
eq (cons a l) (cons a0 l')
+++++
assert (Hle2 := Hl').
-----
Lemma PermSorted : forall (l l' : list positive), Permutation.Permutation l l' -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l' -> l = l'.
Proof.
intro l.
induction l.
intro l'.
induction l'.
intros HPerm Hl Hl'.
assert (HIna' : In a (a :: l)).
idtac.
assert (HIna : In a (a0 :: l')).
idtac.
assert (HIna0' : In a0 (a0 :: l')).
idtac.
assert (HIna0 : In a0 (a :: l)).
idtac.
clear HIna'.
clear HIna0'.
apply in_inv in HIna.
apply in_inv in HIna0.
elim HIna.
clear HIna.
intro HIna.
elim HIna0.
clear HIna0.
intro HIna0.
try (rewrite HIna in *).
try (rewrite <- HIna0 in *).
assert (Hle1 := Hl).
assert (Hle2 := Hl').

*****
Hle2 : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a0 l')
Hle1 : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l)
HIna0 : In a0 l
HIna : In a l'
Hl' : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a0 l')
Hl : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l)
HPerm : Permutation.Permutation (cons a l) (cons a0 l')
IHl' : forall (_ : Permutation.Permutation (cons a l) l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l))\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq (cons a l) l'
l' : list positive
a0 : positive
IHl : forall (l' : list positive) (_ : Permutation.Permutation l l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) l)\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq l l'
l : list positive
a : positive
*****
eq (cons a l) (cons a0 l')
+++++
apply StronglySorted_inv in Hle1.
-----
Lemma PermSorted : forall (l l' : list positive), Permutation.Permutation l l' -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l' -> l = l'.
Proof.
intro l.
induction l.
intro l'.
induction l'.
intros HPerm Hl Hl'.
assert (HIna' : In a (a :: l)).
idtac.
assert (HIna : In a (a0 :: l')).
idtac.
assert (HIna0' : In a0 (a0 :: l')).
idtac.
assert (HIna0 : In a0 (a :: l)).
idtac.
clear HIna'.
clear HIna0'.
apply in_inv in HIna.
apply in_inv in HIna0.
elim HIna.
clear HIna.
intro HIna.
elim HIna0.
clear HIna0.
intro HIna0.
try (rewrite HIna in *).
try (rewrite <- HIna0 in *).
assert (Hle1 := Hl).
assert (Hle2 := Hl').
apply StronglySorted_inv in Hle1.

*****
Hle2 : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a0 l')
Hle1 : and (StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) l)\n (Forall (fun x0 : positive => is_true (Pos.leb a x0)) l)
HIna0 : In a0 l
HIna : In a l'
Hl' : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a0 l')
Hl : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l)
HPerm : Permutation.Permutation (cons a l) (cons a0 l')
IHl' : forall (_ : Permutation.Permutation (cons a l) l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l))\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq (cons a l) l'
l' : list positive
a0 : positive
IHl : forall (l' : list positive) (_ : Permutation.Permutation l l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) l)\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq l l'
l : list positive
a : positive
*****
eq (cons a l) (cons a0 l')
+++++
apply StronglySorted_inv in Hle2.
-----
Lemma PermSorted : forall (l l' : list positive), Permutation.Permutation l l' -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l' -> l = l'.
Proof.
intro l.
induction l.
intro l'.
induction l'.
intros HPerm Hl Hl'.
assert (HIna' : In a (a :: l)).
idtac.
assert (HIna : In a (a0 :: l')).
idtac.
assert (HIna0' : In a0 (a0 :: l')).
idtac.
assert (HIna0 : In a0 (a :: l)).
idtac.
clear HIna'.
clear HIna0'.
apply in_inv in HIna.
apply in_inv in HIna0.
elim HIna.
clear HIna.
intro HIna.
elim HIna0.
clear HIna0.
intro HIna0.
try (rewrite HIna in *).
try (rewrite <- HIna0 in *).
assert (Hle1 := Hl).
assert (Hle2 := Hl').
apply StronglySorted_inv in Hle1.
apply StronglySorted_inv in Hle2.

*****
Hle2 : and (StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) l')\n (Forall (fun x0 : positive => is_true (Pos.leb a0 x0)) l')
Hle1 : and (StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) l)\n (Forall (fun x0 : positive => is_true (Pos.leb a x0)) l)
HIna0 : In a0 l
HIna : In a l'
Hl' : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a0 l')
Hl : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l)
HPerm : Permutation.Permutation (cons a l) (cons a0 l')
IHl' : forall (_ : Permutation.Permutation (cons a l) l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l))\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq (cons a l) l'
l' : list positive
a0 : positive
IHl : forall (l' : list positive) (_ : Permutation.Permutation l l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) l)\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq l l'
l : list positive
a : positive
*****
eq (cons a l) (cons a0 l')
+++++
destruct Hle1 as [Hclear Hle1].
-----
Lemma PermSorted : forall (l l' : list positive), Permutation.Permutation l l' -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l' -> l = l'.
Proof.
intro l.
induction l.
intro l'.
induction l'.
intros HPerm Hl Hl'.
assert (HIna' : In a (a :: l)).
idtac.
assert (HIna : In a (a0 :: l')).
idtac.
assert (HIna0' : In a0 (a0 :: l')).
idtac.
assert (HIna0 : In a0 (a :: l)).
idtac.
clear HIna'.
clear HIna0'.
apply in_inv in HIna.
apply in_inv in HIna0.
elim HIna.
clear HIna.
intro HIna.
elim HIna0.
clear HIna0.
intro HIna0.
try (rewrite HIna in *).
try (rewrite <- HIna0 in *).
assert (Hle1 := Hl).
assert (Hle2 := Hl').
apply StronglySorted_inv in Hle1.
apply StronglySorted_inv in Hle2.
destruct Hle1 as [Hclear Hle1].

*****
Hle2 : and (StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) l')\n (Forall (fun x0 : positive => is_true (Pos.leb a0 x0)) l')
Hle1 : Forall (fun x0 : positive => is_true (Pos.leb a x0)) l
Hclear : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) l
HIna0 : In a0 l
HIna : In a l'
Hl' : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a0 l')
Hl : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l)
HPerm : Permutation.Permutation (cons a l) (cons a0 l')
IHl' : forall (_ : Permutation.Permutation (cons a l) l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l))\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq (cons a l) l'
l' : list positive
a0 : positive
IHl : forall (l' : list positive) (_ : Permutation.Permutation l l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) l)\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq l l'
l : list positive
a : positive
*****
eq (cons a l) (cons a0 l')
+++++
clear Hclear.
-----
Lemma PermSorted : forall (l l' : list positive), Permutation.Permutation l l' -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l' -> l = l'.
Proof.
intro l.
induction l.
intro l'.
induction l'.
intros HPerm Hl Hl'.
assert (HIna' : In a (a :: l)).
idtac.
assert (HIna : In a (a0 :: l')).
idtac.
assert (HIna0' : In a0 (a0 :: l')).
idtac.
assert (HIna0 : In a0 (a :: l)).
idtac.
clear HIna'.
clear HIna0'.
apply in_inv in HIna.
apply in_inv in HIna0.
elim HIna.
clear HIna.
intro HIna.
elim HIna0.
clear HIna0.
intro HIna0.
try (rewrite HIna in *).
try (rewrite <- HIna0 in *).
assert (Hle1 := Hl).
assert (Hle2 := Hl').
apply StronglySorted_inv in Hle1.
apply StronglySorted_inv in Hle2.
destruct Hle1 as [Hclear Hle1].
clear Hclear.

*****
Hle2 : and (StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) l')\n (Forall (fun x0 : positive => is_true (Pos.leb a0 x0)) l')
Hle1 : Forall (fun x0 : positive => is_true (Pos.leb a x0)) l
HIna0 : In a0 l
HIna : In a l'
Hl' : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a0 l')
Hl : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l)
HPerm : Permutation.Permutation (cons a l) (cons a0 l')
IHl' : forall (_ : Permutation.Permutation (cons a l) l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l))\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq (cons a l) l'
l' : list positive
a0 : positive
IHl : forall (l' : list positive) (_ : Permutation.Permutation l l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) l)\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq l l'
l : list positive
a : positive
*****
eq (cons a l) (cons a0 l')
+++++
destruct Hle2 as [Hclear Hle2].
-----
Lemma PermSorted : forall (l l' : list positive), Permutation.Permutation l l' -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l' -> l = l'.
Proof.
intro l.
induction l.
intro l'.
induction l'.
intros HPerm Hl Hl'.
assert (HIna' : In a (a :: l)).
idtac.
assert (HIna : In a (a0 :: l')).
idtac.
assert (HIna0' : In a0 (a0 :: l')).
idtac.
assert (HIna0 : In a0 (a :: l)).
idtac.
clear HIna'.
clear HIna0'.
apply in_inv in HIna.
apply in_inv in HIna0.
elim HIna.
clear HIna.
intro HIna.
elim HIna0.
clear HIna0.
intro HIna0.
try (rewrite HIna in *).
try (rewrite <- HIna0 in *).
assert (Hle1 := Hl).
assert (Hle2 := Hl').
apply StronglySorted_inv in Hle1.
apply StronglySorted_inv in Hle2.
destruct Hle1 as [Hclear Hle1].
clear Hclear.
destruct Hle2 as [Hclear Hle2].

*****
Hle2 : Forall (fun x0 : positive => is_true (Pos.leb a0 x0)) l'
Hclear : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) l'
Hle1 : Forall (fun x0 : positive => is_true (Pos.leb a x0)) l
HIna0 : In a0 l
HIna : In a l'
Hl' : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a0 l')
Hl : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l)
HPerm : Permutation.Permutation (cons a l) (cons a0 l')
IHl' : forall (_ : Permutation.Permutation (cons a l) l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l))\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq (cons a l) l'
l' : list positive
a0 : positive
IHl : forall (l' : list positive) (_ : Permutation.Permutation l l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) l)\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq l l'
l : list positive
a : positive
*****
eq (cons a l) (cons a0 l')
+++++
clear Hclear.
-----
Lemma PermSorted : forall (l l' : list positive), Permutation.Permutation l l' -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l' -> l = l'.
Proof.
intro l.
induction l.
intro l'.
induction l'.
intros HPerm Hl Hl'.
assert (HIna' : In a (a :: l)).
idtac.
assert (HIna : In a (a0 :: l')).
idtac.
assert (HIna0' : In a0 (a0 :: l')).
idtac.
assert (HIna0 : In a0 (a :: l)).
idtac.
clear HIna'.
clear HIna0'.
apply in_inv in HIna.
apply in_inv in HIna0.
elim HIna.
clear HIna.
intro HIna.
elim HIna0.
clear HIna0.
intro HIna0.
try (rewrite HIna in *).
try (rewrite <- HIna0 in *).
assert (Hle1 := Hl).
assert (Hle2 := Hl').
apply StronglySorted_inv in Hle1.
apply StronglySorted_inv in Hle2.
destruct Hle1 as [Hclear Hle1].
clear Hclear.
destruct Hle2 as [Hclear Hle2].
clear Hclear.

*****
Hle2 : Forall (fun x0 : positive => is_true (Pos.leb a0 x0)) l'
Hle1 : Forall (fun x0 : positive => is_true (Pos.leb a x0)) l
HIna0 : In a0 l
HIna : In a l'
Hl' : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a0 l')
Hl : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l)
HPerm : Permutation.Permutation (cons a l) (cons a0 l')
IHl' : forall (_ : Permutation.Permutation (cons a l) l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l))\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq (cons a l) l'
l' : list positive
a0 : positive
IHl : forall (l' : list positive) (_ : Permutation.Permutation l l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) l)\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq l l'
l : list positive
a : positive
*****
eq (cons a l) (cons a0 l')
+++++
assert (Haa0 : (forall x, In x l -> is_true (Pos.leb a x))).
-----
Lemma PermSorted : forall (l l' : list positive), Permutation.Permutation l l' -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l' -> l = l'.
Proof.
intro l.
induction l.
intro l'.
induction l'.
intros HPerm Hl Hl'.
assert (HIna' : In a (a :: l)).
idtac.
assert (HIna : In a (a0 :: l')).
idtac.
assert (HIna0' : In a0 (a0 :: l')).
idtac.
assert (HIna0 : In a0 (a :: l)).
idtac.
clear HIna'.
clear HIna0'.
apply in_inv in HIna.
apply in_inv in HIna0.
elim HIna.
clear HIna.
intro HIna.
elim HIna0.
clear HIna0.
intro HIna0.
try (rewrite HIna in *).
try (rewrite <- HIna0 in *).
assert (Hle1 := Hl).
assert (Hle2 := Hl').
apply StronglySorted_inv in Hle1.
apply StronglySorted_inv in Hle2.
destruct Hle1 as [Hclear Hle1].
clear Hclear.
destruct Hle2 as [Hclear Hle2].
clear Hclear.
assert (Haa0 : (forall x, In x l -> is_true (Pos.leb a x))).

*****
Hle2 : Forall (fun x0 : positive => is_true (Pos.leb a0 x0)) l'
Hle1 : Forall (fun x0 : positive => is_true (Pos.leb a x0)) l
HIna0 : In a0 l
HIna : In a l'
Hl' : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a0 l')
Hl : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l)
HPerm : Permutation.Permutation (cons a l) (cons a0 l')
IHl' : forall (_ : Permutation.Permutation (cons a l) l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l))\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq (cons a l) l'
l' : list positive
a0 : positive
IHl : forall (l' : list positive) (_ : Permutation.Permutation l l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) l)\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq l l'
l : list positive
a : positive
*****
forall (x : positive) (_ : In x l), is_true (Pos.leb a x)
+++++
apply Forall_forall.
-----
Lemma PermSorted : forall (l l' : list positive), Permutation.Permutation l l' -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l' -> l = l'.
Proof.
intro l.
induction l.
intro l'.
induction l'.
intros HPerm Hl Hl'.
assert (HIna' : In a (a :: l)).
idtac.
assert (HIna : In a (a0 :: l')).
idtac.
assert (HIna0' : In a0 (a0 :: l')).
idtac.
assert (HIna0 : In a0 (a :: l)).
idtac.
clear HIna'.
clear HIna0'.
apply in_inv in HIna.
apply in_inv in HIna0.
elim HIna.
clear HIna.
intro HIna.
elim HIna0.
clear HIna0.
intro HIna0.
try (rewrite HIna in *).
try (rewrite <- HIna0 in *).
assert (Hle1 := Hl).
assert (Hle2 := Hl').
apply StronglySorted_inv in Hle1.
apply StronglySorted_inv in Hle2.
destruct Hle1 as [Hclear Hle1].
clear Hclear.
destruct Hle2 as [Hclear Hle2].
clear Hclear.
assert (Haa0 : (forall x, In x l -> is_true (Pos.leb a x))).
apply Forall_forall.

*****
Hle2 : Forall (fun x0 : positive => is_true (Pos.leb a0 x0)) l'
Hle1 : Forall (fun x0 : positive => is_true (Pos.leb a x0)) l
HIna0 : In a0 l
HIna : In a l'
Hl' : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a0 l')
Hl : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l)
HPerm : Permutation.Permutation (cons a l) (cons a0 l')
IHl' : forall (_ : Permutation.Permutation (cons a l) l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l))\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq (cons a l) l'
l' : list positive
a0 : positive
IHl : forall (l' : list positive) (_ : Permutation.Permutation l l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) l)\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq l l'
l : list positive
a : positive
*****
Forall (fun x : positive => is_true (Pos.leb a x)) l
+++++
assumption.
-----
Lemma PermSorted : forall (l l' : list positive), Permutation.Permutation l l' -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l' -> l = l'.
Proof.
intro l.
induction l.
intro l'.
induction l'.
intros HPerm Hl Hl'.
assert (HIna' : In a (a :: l)).
idtac.
assert (HIna : In a (a0 :: l')).
idtac.
assert (HIna0' : In a0 (a0 :: l')).
idtac.
assert (HIna0 : In a0 (a :: l)).
idtac.
clear HIna'.
clear HIna0'.
apply in_inv in HIna.
apply in_inv in HIna0.
elim HIna.
clear HIna.
intro HIna.
elim HIna0.
clear HIna0.
intro HIna0.
try (rewrite HIna in *).
try (rewrite <- HIna0 in *).
assert (Hle1 := Hl).
assert (Hle2 := Hl').
apply StronglySorted_inv in Hle1.
apply StronglySorted_inv in Hle2.
destruct Hle1 as [Hclear Hle1].
clear Hclear.
destruct Hle2 as [Hclear Hle2].
clear Hclear.
assert (Haa0 : (forall x, In x l -> is_true (Pos.leb a x))).

*****
Haa0 : forall (x : positive) (_ : In x l), is_true (Pos.leb a x)
Hle2 : Forall (fun x0 : positive => is_true (Pos.leb a0 x0)) l'
Hle1 : Forall (fun x0 : positive => is_true (Pos.leb a x0)) l
HIna0 : In a0 l
HIna : In a l'
Hl' : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a0 l')
Hl : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l)
HPerm : Permutation.Permutation (cons a l) (cons a0 l')
IHl' : forall (_ : Permutation.Permutation (cons a l) l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l))\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq (cons a l) l'
l' : list positive
a0 : positive
IHl : forall (l' : list positive) (_ : Permutation.Permutation l l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) l)\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq l l'
l : list positive
a : positive
*****
eq (cons a l) (cons a0 l')
+++++
idtac.
-----
Lemma PermSorted : forall (l l' : list positive), Permutation.Permutation l l' -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l' -> l = l'.
Proof.
intro l.
induction l.
intro l'.
induction l'.
intros HPerm Hl Hl'.
assert (HIna' : In a (a :: l)).
idtac.
assert (HIna : In a (a0 :: l')).
idtac.
assert (HIna0' : In a0 (a0 :: l')).
idtac.
assert (HIna0 : In a0 (a :: l)).
idtac.
clear HIna'.
clear HIna0'.
apply in_inv in HIna.
apply in_inv in HIna0.
elim HIna.
clear HIna.
intro HIna.
elim HIna0.
clear HIna0.
intro HIna0.
try (rewrite HIna in *).
try (rewrite <- HIna0 in *).
assert (Hle1 := Hl).
assert (Hle2 := Hl').
apply StronglySorted_inv in Hle1.
apply StronglySorted_inv in Hle2.
destruct Hle1 as [Hclear Hle1].
clear Hclear.
destruct Hle2 as [Hclear Hle2].
clear Hclear.
assert (Haa0 : (forall x, In x l -> is_true (Pos.leb a x))).
idtac.

*****
Haa0 : forall (x : positive) (_ : In x l), is_true (Pos.leb a x)
Hle2 : Forall (fun x0 : positive => is_true (Pos.leb a0 x0)) l'
Hle1 : Forall (fun x0 : positive => is_true (Pos.leb a x0)) l
HIna0 : In a0 l
HIna : In a l'
Hl' : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a0 l')
Hl : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l)
HPerm : Permutation.Permutation (cons a l) (cons a0 l')
IHl' : forall (_ : Permutation.Permutation (cons a l) l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l))\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq (cons a l) l'
l' : list positive
a0 : positive
IHl : forall (l' : list positive) (_ : Permutation.Permutation l l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) l)\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq l l'
l : list positive
a : positive
*****
eq (cons a l) (cons a0 l')
+++++
assert (Ha0a : (forall x, In x l' -> is_true (Pos.leb a0 x))).
-----
Lemma PermSorted : forall (l l' : list positive), Permutation.Permutation l l' -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l' -> l = l'.
Proof.
intro l.
induction l.
intro l'.
induction l'.
intros HPerm Hl Hl'.
assert (HIna' : In a (a :: l)).
idtac.
assert (HIna : In a (a0 :: l')).
idtac.
assert (HIna0' : In a0 (a0 :: l')).
idtac.
assert (HIna0 : In a0 (a :: l)).
idtac.
clear HIna'.
clear HIna0'.
apply in_inv in HIna.
apply in_inv in HIna0.
elim HIna.
clear HIna.
intro HIna.
elim HIna0.
clear HIna0.
intro HIna0.
try (rewrite HIna in *).
try (rewrite <- HIna0 in *).
assert (Hle1 := Hl).
assert (Hle2 := Hl').
apply StronglySorted_inv in Hle1.
apply StronglySorted_inv in Hle2.
destruct Hle1 as [Hclear Hle1].
clear Hclear.
destruct Hle2 as [Hclear Hle2].
clear Hclear.
assert (Haa0 : (forall x, In x l -> is_true (Pos.leb a x))).
idtac.
assert (Ha0a : (forall x, In x l' -> is_true (Pos.leb a0 x))).

*****
Haa0 : forall (x : positive) (_ : In x l), is_true (Pos.leb a x)
Hle2 : Forall (fun x0 : positive => is_true (Pos.leb a0 x0)) l'
Hle1 : Forall (fun x0 : positive => is_true (Pos.leb a x0)) l
HIna0 : In a0 l
HIna : In a l'
Hl' : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a0 l')
Hl : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l)
HPerm : Permutation.Permutation (cons a l) (cons a0 l')
IHl' : forall (_ : Permutation.Permutation (cons a l) l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l))\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq (cons a l) l'
l' : list positive
a0 : positive
IHl : forall (l' : list positive) (_ : Permutation.Permutation l l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) l)\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq l l'
l : list positive
a : positive
*****
forall (x : positive) (_ : In x l'), is_true (Pos.leb a0 x)
+++++
apply Forall_forall.
-----
Lemma PermSorted : forall (l l' : list positive), Permutation.Permutation l l' -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l' -> l = l'.
Proof.
intro l.
induction l.
intro l'.
induction l'.
intros HPerm Hl Hl'.
assert (HIna' : In a (a :: l)).
idtac.
assert (HIna : In a (a0 :: l')).
idtac.
assert (HIna0' : In a0 (a0 :: l')).
idtac.
assert (HIna0 : In a0 (a :: l)).
idtac.
clear HIna'.
clear HIna0'.
apply in_inv in HIna.
apply in_inv in HIna0.
elim HIna.
clear HIna.
intro HIna.
elim HIna0.
clear HIna0.
intro HIna0.
try (rewrite HIna in *).
try (rewrite <- HIna0 in *).
assert (Hle1 := Hl).
assert (Hle2 := Hl').
apply StronglySorted_inv in Hle1.
apply StronglySorted_inv in Hle2.
destruct Hle1 as [Hclear Hle1].
clear Hclear.
destruct Hle2 as [Hclear Hle2].
clear Hclear.
assert (Haa0 : (forall x, In x l -> is_true (Pos.leb a x))).
idtac.
assert (Ha0a : (forall x, In x l' -> is_true (Pos.leb a0 x))).
apply Forall_forall.

*****
Haa0 : forall (x : positive) (_ : In x l), is_true (Pos.leb a x)
Hle2 : Forall (fun x0 : positive => is_true (Pos.leb a0 x0)) l'
Hle1 : Forall (fun x0 : positive => is_true (Pos.leb a x0)) l
HIna0 : In a0 l
HIna : In a l'
Hl' : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a0 l')
Hl : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l)
HPerm : Permutation.Permutation (cons a l) (cons a0 l')
IHl' : forall (_ : Permutation.Permutation (cons a l) l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l))\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq (cons a l) l'
l' : list positive
a0 : positive
IHl : forall (l' : list positive) (_ : Permutation.Permutation l l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) l)\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq l l'
l : list positive
a : positive
*****
Forall (fun x : positive => is_true (Pos.leb a0 x)) l'
+++++
assumption.
-----
Lemma PermSorted : forall (l l' : list positive), Permutation.Permutation l l' -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l' -> l = l'.
Proof.
intro l.
induction l.
intro l'.
induction l'.
intros HPerm Hl Hl'.
assert (HIna' : In a (a :: l)).
idtac.
assert (HIna : In a (a0 :: l')).
idtac.
assert (HIna0' : In a0 (a0 :: l')).
idtac.
assert (HIna0 : In a0 (a :: l)).
idtac.
clear HIna'.
clear HIna0'.
apply in_inv in HIna.
apply in_inv in HIna0.
elim HIna.
clear HIna.
intro HIna.
elim HIna0.
clear HIna0.
intro HIna0.
try (rewrite HIna in *).
try (rewrite <- HIna0 in *).
assert (Hle1 := Hl).
assert (Hle2 := Hl').
apply StronglySorted_inv in Hle1.
apply StronglySorted_inv in Hle2.
destruct Hle1 as [Hclear Hle1].
clear Hclear.
destruct Hle2 as [Hclear Hle2].
clear Hclear.
assert (Haa0 : (forall x, In x l -> is_true (Pos.leb a x))).
idtac.
assert (Ha0a : (forall x, In x l' -> is_true (Pos.leb a0 x))).

*****
Ha0a : forall (x : positive) (_ : In x l'), is_true (Pos.leb a0 x)
Haa0 : forall (x : positive) (_ : In x l), is_true (Pos.leb a x)
Hle2 : Forall (fun x0 : positive => is_true (Pos.leb a0 x0)) l'
Hle1 : Forall (fun x0 : positive => is_true (Pos.leb a x0)) l
HIna0 : In a0 l
HIna : In a l'
Hl' : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a0 l')
Hl : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l)
HPerm : Permutation.Permutation (cons a l) (cons a0 l')
IHl' : forall (_ : Permutation.Permutation (cons a l) l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l))\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq (cons a l) l'
l' : list positive
a0 : positive
IHl : forall (l' : list positive) (_ : Permutation.Permutation l l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) l)\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq l l'
l : list positive
a : positive
*****
eq (cons a l) (cons a0 l')
+++++
idtac.
-----
Lemma PermSorted : forall (l l' : list positive), Permutation.Permutation l l' -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l' -> l = l'.
Proof.
intro l.
induction l.
intro l'.
induction l'.
intros HPerm Hl Hl'.
assert (HIna' : In a (a :: l)).
idtac.
assert (HIna : In a (a0 :: l')).
idtac.
assert (HIna0' : In a0 (a0 :: l')).
idtac.
assert (HIna0 : In a0 (a :: l)).
idtac.
clear HIna'.
clear HIna0'.
apply in_inv in HIna.
apply in_inv in HIna0.
elim HIna.
clear HIna.
intro HIna.
elim HIna0.
clear HIna0.
intro HIna0.
try (rewrite HIna in *).
try (rewrite <- HIna0 in *).
assert (Hle1 := Hl).
assert (Hle2 := Hl').
apply StronglySorted_inv in Hle1.
apply StronglySorted_inv in Hle2.
destruct Hle1 as [Hclear Hle1].
clear Hclear.
destruct Hle2 as [Hclear Hle2].
clear Hclear.
assert (Haa0 : (forall x, In x l -> is_true (Pos.leb a x))).
idtac.
assert (Ha0a : (forall x, In x l' -> is_true (Pos.leb a0 x))).
idtac.

*****
Ha0a : forall (x : positive) (_ : In x l'), is_true (Pos.leb a0 x)
Haa0 : forall (x : positive) (_ : In x l), is_true (Pos.leb a x)
Hle2 : Forall (fun x0 : positive => is_true (Pos.leb a0 x0)) l'
Hle1 : Forall (fun x0 : positive => is_true (Pos.leb a x0)) l
HIna0 : In a0 l
HIna : In a l'
Hl' : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a0 l')
Hl : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l)
HPerm : Permutation.Permutation (cons a l) (cons a0 l')
IHl' : forall (_ : Permutation.Permutation (cons a l) l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l))\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq (cons a l) l'
l' : list positive
a0 : positive
IHl : forall (l' : list positive) (_ : Permutation.Permutation l l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) l)\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq l l'
l : list positive
a : positive
*****
eq (cons a l) (cons a0 l')
+++++
apply Ha0a in HIna.
-----
Lemma PermSorted : forall (l l' : list positive), Permutation.Permutation l l' -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l' -> l = l'.
Proof.
intro l.
induction l.
intro l'.
induction l'.
intros HPerm Hl Hl'.
assert (HIna' : In a (a :: l)).
idtac.
assert (HIna : In a (a0 :: l')).
idtac.
assert (HIna0' : In a0 (a0 :: l')).
idtac.
assert (HIna0 : In a0 (a :: l)).
idtac.
clear HIna'.
clear HIna0'.
apply in_inv in HIna.
apply in_inv in HIna0.
elim HIna.
clear HIna.
intro HIna.
elim HIna0.
clear HIna0.
intro HIna0.
try (rewrite HIna in *).
try (rewrite <- HIna0 in *).
assert (Hle1 := Hl).
assert (Hle2 := Hl').
apply StronglySorted_inv in Hle1.
apply StronglySorted_inv in Hle2.
destruct Hle1 as [Hclear Hle1].
clear Hclear.
destruct Hle2 as [Hclear Hle2].
clear Hclear.
assert (Haa0 : (forall x, In x l -> is_true (Pos.leb a x))).
idtac.
assert (Ha0a : (forall x, In x l' -> is_true (Pos.leb a0 x))).
idtac.
apply Ha0a in HIna.

*****
Ha0a : forall (x : positive) (_ : In x l'), is_true (Pos.leb a0 x)
Haa0 : forall (x : positive) (_ : In x l), is_true (Pos.leb a x)
Hle2 : Forall (fun x0 : positive => is_true (Pos.leb a0 x0)) l'
Hle1 : Forall (fun x0 : positive => is_true (Pos.leb a x0)) l
HIna0 : In a0 l
HIna : is_true (Pos.leb a0 a)
Hl' : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a0 l')
Hl : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l)
HPerm : Permutation.Permutation (cons a l) (cons a0 l')
IHl' : forall (_ : Permutation.Permutation (cons a l) l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l))\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq (cons a l) l'
l' : list positive
a0 : positive
IHl : forall (l' : list positive) (_ : Permutation.Permutation l l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) l)\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq l l'
l : list positive
a : positive
*****
eq (cons a l) (cons a0 l')
+++++
apply Haa0 in HIna0.
-----
Lemma PermSorted : forall (l l' : list positive), Permutation.Permutation l l' -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l' -> l = l'.
Proof.
intro l.
induction l.
intro l'.
induction l'.
intros HPerm Hl Hl'.
assert (HIna' : In a (a :: l)).
idtac.
assert (HIna : In a (a0 :: l')).
idtac.
assert (HIna0' : In a0 (a0 :: l')).
idtac.
assert (HIna0 : In a0 (a :: l)).
idtac.
clear HIna'.
clear HIna0'.
apply in_inv in HIna.
apply in_inv in HIna0.
elim HIna.
clear HIna.
intro HIna.
elim HIna0.
clear HIna0.
intro HIna0.
try (rewrite HIna in *).
try (rewrite <- HIna0 in *).
assert (Hle1 := Hl).
assert (Hle2 := Hl').
apply StronglySorted_inv in Hle1.
apply StronglySorted_inv in Hle2.
destruct Hle1 as [Hclear Hle1].
clear Hclear.
destruct Hle2 as [Hclear Hle2].
clear Hclear.
assert (Haa0 : (forall x, In x l -> is_true (Pos.leb a x))).
idtac.
assert (Ha0a : (forall x, In x l' -> is_true (Pos.leb a0 x))).
idtac.
apply Ha0a in HIna.
apply Haa0 in HIna0.

*****
Ha0a : forall (x : positive) (_ : In x l'), is_true (Pos.leb a0 x)
Haa0 : forall (x : positive) (_ : In x l), is_true (Pos.leb a x)
Hle2 : Forall (fun x0 : positive => is_true (Pos.leb a0 x0)) l'
Hle1 : Forall (fun x0 : positive => is_true (Pos.leb a x0)) l
HIna0 : is_true (Pos.leb a a0)
HIna : is_true (Pos.leb a0 a)
Hl' : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a0 l')
Hl : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l)
HPerm : Permutation.Permutation (cons a l) (cons a0 l')
IHl' : forall (_ : Permutation.Permutation (cons a l) l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (cons a l))\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq (cons a l) l'
l' : list positive
a0 : positive
IHl : forall (l' : list positive) (_ : Permutation.Permutation l l')\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) l)\n (_ : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n l'), eq l l'
l : list positive
a : positive
*****
eq (cons a l) (cons a0 l')
+++++
unfold is_true in *.
-----
Lemma PermSorted : forall (l l' : list positive), Permutation.Permutation l l' -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l' -> l = l'.
Proof.
intro l.
induction l.
intro l'.
induction l'.
intros HPerm Hl Hl'.
assert (HIna' : In a (a :: l)).
idtac.
assert (HIna : In a (a0 :: l')).
idtac.
assert (HIna0' : In a0 (a0 :: l')).
idtac.
assert (HIna0 : In a0 (a :: l)).
idtac.
clear HIna'.
clear HIna0'.
apply in_inv in HIna.
apply in_inv in HIna0.
elim HIna.
clear HIna.
intro HIna.
elim HIna0.
clear HIna0.
intro HIna0.
try (rewrite HIna in *).
try (rewrite <- HIna0 in *).
assert (Hle1 := Hl).
assert (Hle2 := Hl').
apply StronglySorted_inv in Hle1.
apply StronglySorted_inv in Hle2.
destruct Hle1 as [Hclear Hle1].
clear Hclear.
destruct Hle2 as [Hclear Hle2].
clear Hclear.
assert (Haa0 : (forall x, In x l -> is_true (Pos.leb a x))).
idtac.
assert (Ha0a : (forall x, In x l' -> is_true (Pos.leb a0 x))).
idtac.
apply Ha0a in HIna.
apply Haa0 in HIna0.
unfold is_true in *.

*****
Ha0a : forall (x : positive) (_ : In x l'), eq (Pos.leb a0 x) true
Haa0 : forall (x : positive) (_ : In x l), eq (Pos.leb a x) true
Hle2 : Forall (fun x0 : positive => eq (Pos.leb a0 x0) true) l'
Hle1 : Forall (fun x0 : positive => eq (Pos.leb a x0) true) l
HIna0 : eq (Pos.leb a a0) true
HIna : eq (Pos.leb a0 a) true
Hl' : StronglySorted (fun x x0 : positive => eq (Pos.leb x x0) true)\n (cons a0 l')
Hl : StronglySorted (fun x x0 : positive => eq (Pos.leb x x0) true)\n (cons a l)
HPerm : Permutation.Permutation (cons a l) (cons a0 l')
IHl' : forall (_ : Permutation.Permutation (cons a l) l')\n (_ : StronglySorted (fun x x0 : positive => eq (Pos.leb x x0) true)\n (cons a l))\n (_ : StronglySorted (fun x x0 : positive => eq (Pos.leb x x0) true)\n l'), eq (cons a l) l'
l' : list positive
a0 : positive
IHl : forall (l' : list positive) (_ : Permutation.Permutation l l')\n (_ : StronglySorted (fun x x0 : positive => eq (Pos.leb x x0) true) l)\n (_ : StronglySorted (fun x x0 : positive => eq (Pos.leb x x0) true)\n l'), eq l l'
l : list positive
a : positive
*****
eq (cons a l) (cons a0 l')
+++++
apply Pos.leb_le in HIna.
-----
Lemma PermSorted : forall (l l' : list positive), Permutation.Permutation l l' -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l' -> l = l'.
Proof.
intro l.
induction l.
intro l'.
induction l'.
intros HPerm Hl Hl'.
assert (HIna' : In a (a :: l)).
idtac.
assert (HIna : In a (a0 :: l')).
idtac.
assert (HIna0' : In a0 (a0 :: l')).
idtac.
assert (HIna0 : In a0 (a :: l)).
idtac.
clear HIna'.
clear HIna0'.
apply in_inv in HIna.
apply in_inv in HIna0.
elim HIna.
clear HIna.
intro HIna.
elim HIna0.
clear HIna0.
intro HIna0.
try (rewrite HIna in *).
try (rewrite <- HIna0 in *).
assert (Hle1 := Hl).
assert (Hle2 := Hl').
apply StronglySorted_inv in Hle1.
apply StronglySorted_inv in Hle2.
destruct Hle1 as [Hclear Hle1].
clear Hclear.
destruct Hle2 as [Hclear Hle2].
clear Hclear.
assert (Haa0 : (forall x, In x l -> is_true (Pos.leb a x))).
idtac.
assert (Ha0a : (forall x, In x l' -> is_true (Pos.leb a0 x))).
idtac.
apply Ha0a in HIna.
apply Haa0 in HIna0.
unfold is_true in *.
apply Pos.leb_le in HIna.

*****
Ha0a : forall (x : positive) (_ : In x l'), eq (Pos.leb a0 x) true
Haa0 : forall (x : positive) (_ : In x l), eq (Pos.leb a x) true
Hle2 : Forall (fun x0 : positive => eq (Pos.leb a0 x0) true) l'
Hle1 : Forall (fun x0 : positive => eq (Pos.leb a x0) true) l
HIna0 : eq (Pos.leb a a0) true
HIna : Pos.le a0 a
Hl' : StronglySorted (fun x x0 : positive => eq (Pos.leb x x0) true)\n (cons a0 l')
Hl : StronglySorted (fun x x0 : positive => eq (Pos.leb x x0) true)\n (cons a l)
HPerm : Permutation.Permutation (cons a l) (cons a0 l')
IHl' : forall (_ : Permutation.Permutation (cons a l) l')\n (_ : StronglySorted (fun x x0 : positive => eq (Pos.leb x x0) true)\n (cons a l))\n (_ : StronglySorted (fun x x0 : positive => eq (Pos.leb x x0) true)\n l'), eq (cons a l) l'
l' : list positive
a0 : positive
IHl : forall (l' : list positive) (_ : Permutation.Permutation l l')\n (_ : StronglySorted (fun x x0 : positive => eq (Pos.leb x x0) true) l)\n (_ : StronglySorted (fun x x0 : positive => eq (Pos.leb x x0) true)\n l'), eq l l'
l : list positive
a : positive
*****
eq (cons a l) (cons a0 l')
+++++
apply Pos.leb_le in HIna0.
-----
Lemma PermSorted : forall (l l' : list positive), Permutation.Permutation l l' -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l' -> l = l'.
Proof.
intro l.
induction l.
intro l'.
induction l'.
intros HPerm Hl Hl'.
assert (HIna' : In a (a :: l)).
idtac.
assert (HIna : In a (a0 :: l')).
idtac.
assert (HIna0' : In a0 (a0 :: l')).
idtac.
assert (HIna0 : In a0 (a :: l)).
idtac.
clear HIna'.
clear HIna0'.
apply in_inv in HIna.
apply in_inv in HIna0.
elim HIna.
clear HIna.
intro HIna.
elim HIna0.
clear HIna0.
intro HIna0.
try (rewrite HIna in *).
try (rewrite <- HIna0 in *).
assert (Hle1 := Hl).
assert (Hle2 := Hl').
apply StronglySorted_inv in Hle1.
apply StronglySorted_inv in Hle2.
destruct Hle1 as [Hclear Hle1].
clear Hclear.
destruct Hle2 as [Hclear Hle2].
clear Hclear.
assert (Haa0 : (forall x, In x l -> is_true (Pos.leb a x))).
idtac.
assert (Ha0a : (forall x, In x l' -> is_true (Pos.leb a0 x))).
idtac.
apply Ha0a in HIna.
apply Haa0 in HIna0.
unfold is_true in *.
apply Pos.leb_le in HIna.
apply Pos.leb_le in HIna0.

*****
Ha0a : forall (x : positive) (_ : In x l'), eq (Pos.leb a0 x) true
Haa0 : forall (x : positive) (_ : In x l), eq (Pos.leb a x) true
Hle2 : Forall (fun x0 : positive => eq (Pos.leb a0 x0) true) l'
Hle1 : Forall (fun x0 : positive => eq (Pos.leb a x0) true) l
HIna0 : Pos.le a a0
HIna : Pos.le a0 a
Hl' : StronglySorted (fun x x0 : positive => eq (Pos.leb x x0) true)\n (cons a0 l')
Hl : StronglySorted (fun x x0 : positive => eq (Pos.leb x x0) true)\n (cons a l)
HPerm : Permutation.Permutation (cons a l) (cons a0 l')
IHl' : forall (_ : Permutation.Permutation (cons a l) l')\n (_ : StronglySorted (fun x x0 : positive => eq (Pos.leb x x0) true)\n (cons a l))\n (_ : StronglySorted (fun x x0 : positive => eq (Pos.leb x x0) true)\n l'), eq (cons a l) l'
l' : list positive
a0 : positive
IHl : forall (l' : list positive) (_ : Permutation.Permutation l l')\n (_ : StronglySorted (fun x x0 : positive => eq (Pos.leb x x0) true) l)\n (_ : StronglySorted (fun x x0 : positive => eq (Pos.leb x x0) true)\n l'), eq l l'
l : list positive
a : positive
*****
eq (cons a l) (cons a0 l')
+++++
assert (H := Pos.le_antisym a0 a HIna HIna0).
-----
Lemma PermSorted : forall (l l' : list positive), Permutation.Permutation l l' -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l' -> l = l'.
Proof.
intro l.
induction l.
intro l'.
induction l'.
intros HPerm Hl Hl'.
assert (HIna' : In a (a :: l)).
idtac.
assert (HIna : In a (a0 :: l')).
idtac.
assert (HIna0' : In a0 (a0 :: l')).
idtac.
assert (HIna0 : In a0 (a :: l)).
idtac.
clear HIna'.
clear HIna0'.
apply in_inv in HIna.
apply in_inv in HIna0.
elim HIna.
clear HIna.
intro HIna.
elim HIna0.
clear HIna0.
intro HIna0.
try (rewrite HIna in *).
try (rewrite <- HIna0 in *).
assert (Hle1 := Hl).
assert (Hle2 := Hl').
apply StronglySorted_inv in Hle1.
apply StronglySorted_inv in Hle2.
destruct Hle1 as [Hclear Hle1].
clear Hclear.
destruct Hle2 as [Hclear Hle2].
clear Hclear.
assert (Haa0 : (forall x, In x l -> is_true (Pos.leb a x))).
idtac.
assert (Ha0a : (forall x, In x l' -> is_true (Pos.leb a0 x))).
idtac.
apply Ha0a in HIna.
apply Haa0 in HIna0.
unfold is_true in *.
apply Pos.leb_le in HIna.
apply Pos.leb_le in HIna0.
assert (H := Pos.le_antisym a0 a HIna HIna0).

*****
H : eq a0 a
Ha0a : forall (x : positive) (_ : In x l'), eq (Pos.leb a0 x) true
Haa0 : forall (x : positive) (_ : In x l), eq (Pos.leb a x) true
Hle2 : Forall (fun x0 : positive => eq (Pos.leb a0 x0) true) l'
Hle1 : Forall (fun x0 : positive => eq (Pos.leb a x0) true) l
HIna0 : Pos.le a a0
HIna : Pos.le a0 a
Hl' : StronglySorted (fun x x0 : positive => eq (Pos.leb x x0) true)\n (cons a0 l')
Hl : StronglySorted (fun x x0 : positive => eq (Pos.leb x x0) true)\n (cons a l)
HPerm : Permutation.Permutation (cons a l) (cons a0 l')
IHl' : forall (_ : Permutation.Permutation (cons a l) l')\n (_ : StronglySorted (fun x x0 : positive => eq (Pos.leb x x0) true)\n (cons a l))\n (_ : StronglySorted (fun x x0 : positive => eq (Pos.leb x x0) true)\n l'), eq (cons a l) l'
l' : list positive
a0 : positive
IHl : forall (l' : list positive) (_ : Permutation.Permutation l l')\n (_ : StronglySorted (fun x x0 : positive => eq (Pos.leb x x0) true) l)\n (_ : StronglySorted (fun x x0 : positive => eq (Pos.leb x x0) true)\n l'), eq l l'
l : list positive
a : positive
*****
eq (cons a l) (cons a0 l')
+++++
rewrite H in *.
-----
Lemma PermSorted : forall (l l' : list positive), Permutation.Permutation l l' -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l' -> l = l'.
Proof.
intro l.
induction l.
intro l'.
induction l'.
intros HPerm Hl Hl'.
assert (HIna' : In a (a :: l)).
idtac.
assert (HIna : In a (a0 :: l')).
idtac.
assert (HIna0' : In a0 (a0 :: l')).
idtac.
assert (HIna0 : In a0 (a :: l)).
idtac.
clear HIna'.
clear HIna0'.
apply in_inv in HIna.
apply in_inv in HIna0.
elim HIna.
clear HIna.
intro HIna.
elim HIna0.
clear HIna0.
intro HIna0.
try (rewrite HIna in *).
try (rewrite <- HIna0 in *).
assert (Hle1 := Hl).
assert (Hle2 := Hl').
apply StronglySorted_inv in Hle1.
apply StronglySorted_inv in Hle2.
destruct Hle1 as [Hclear Hle1].
clear Hclear.
destruct Hle2 as [Hclear Hle2].
clear Hclear.
assert (Haa0 : (forall x, In x l -> is_true (Pos.leb a x))).
idtac.
assert (Ha0a : (forall x, In x l' -> is_true (Pos.leb a0 x))).
idtac.
apply Ha0a in HIna.
apply Haa0 in HIna0.
unfold is_true in *.
apply Pos.leb_le in HIna.
apply Pos.leb_le in HIna0.
assert (H := Pos.le_antisym a0 a HIna HIna0).
rewrite H in *.

*****
H : eq a0 a
Ha0a : forall (x : positive) (_ : In x l'), eq (Pos.leb a x) true
Haa0 : forall (x : positive) (_ : In x l), eq (Pos.leb a x) true
Hle2 : Forall (fun x0 : positive => eq (Pos.leb a x0) true) l'
Hle1 : Forall (fun x0 : positive => eq (Pos.leb a x0) true) l
HIna,HIna0 : Pos.le a a
Hl' : StronglySorted (fun x x0 : positive => eq (Pos.leb x x0) true)\n (cons a l')
Hl : StronglySorted (fun x x0 : positive => eq (Pos.leb x x0) true)\n (cons a l)
HPerm : Permutation.Permutation (cons a l) (cons a l')
IHl' : forall (_ : Permutation.Permutation (cons a l) l')\n (_ : StronglySorted (fun x x0 : positive => eq (Pos.leb x x0) true)\n (cons a l))\n (_ : StronglySorted (fun x x0 : positive => eq (Pos.leb x x0) true)\n l'), eq (cons a l) l'
l' : list positive
a0 : positive
IHl : forall (l' : list positive) (_ : Permutation.Permutation l l')\n (_ : StronglySorted (fun x x0 : positive => eq (Pos.leb x x0) true) l)\n (_ : StronglySorted (fun x x0 : positive => eq (Pos.leb x x0) true)\n l'), eq l l'
l : list positive
a : positive
*****
eq (cons a l) (cons a l')
+++++
assert (HPerm' : Permutation.Permutation l l').
-----
Lemma PermSorted : forall (l l' : list positive), Permutation.Permutation l l' -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l' -> l = l'.
Proof.
intro l.
induction l.
intro l'.
induction l'.
intros HPerm Hl Hl'.
assert (HIna' : In a (a :: l)).
idtac.
assert (HIna : In a (a0 :: l')).
idtac.
assert (HIna0' : In a0 (a0 :: l')).
idtac.
assert (HIna0 : In a0 (a :: l)).
idtac.
clear HIna'.
clear HIna0'.
apply in_inv in HIna.
apply in_inv in HIna0.
elim HIna.
clear HIna.
intro HIna.
elim HIna0.
clear HIna0.
intro HIna0.
try (rewrite HIna in *).
try (rewrite <- HIna0 in *).
assert (Hle1 := Hl).
assert (Hle2 := Hl').
apply StronglySorted_inv in Hle1.
apply StronglySorted_inv in Hle2.
destruct Hle1 as [Hclear Hle1].
clear Hclear.
destruct Hle2 as [Hclear Hle2].
clear Hclear.
assert (Haa0 : (forall x, In x l -> is_true (Pos.leb a x))).
idtac.
assert (Ha0a : (forall x, In x l' -> is_true (Pos.leb a0 x))).
idtac.
apply Ha0a in HIna.
apply Haa0 in HIna0.
unfold is_true in *.
apply Pos.leb_le in HIna.
apply Pos.leb_le in HIna0.
assert (H := Pos.le_antisym a0 a HIna HIna0).
rewrite H in *.
assert (HPerm' : Permutation.Permutation l l').

*****
H : eq a0 a
Ha0a : forall (x : positive) (_ : In x l'), eq (Pos.leb a x) true
Haa0 : forall (x : positive) (_ : In x l), eq (Pos.leb a x) true
Hle2 : Forall (fun x0 : positive => eq (Pos.leb a x0) true) l'
Hle1 : Forall (fun x0 : positive => eq (Pos.leb a x0) true) l
HIna,HIna0 : Pos.le a a
Hl' : StronglySorted (fun x x0 : positive => eq (Pos.leb x x0) true)\n (cons a l')
Hl : StronglySorted (fun x x0 : positive => eq (Pos.leb x x0) true)\n (cons a l)
HPerm : Permutation.Permutation (cons a l) (cons a l')
IHl' : forall (_ : Permutation.Permutation (cons a l) l')\n (_ : StronglySorted (fun x x0 : positive => eq (Pos.leb x x0) true)\n (cons a l))\n (_ : StronglySorted (fun x x0 : positive => eq (Pos.leb x x0) true)\n l'), eq (cons a l) l'
l' : list positive
a0 : positive
IHl : forall (l' : list positive) (_ : Permutation.Permutation l l')\n (_ : StronglySorted (fun x x0 : positive => eq (Pos.leb x x0) true) l)\n (_ : StronglySorted (fun x x0 : positive => eq (Pos.leb x x0) true)\n l'), eq l l'
l : list positive
a : positive
*****
Permutation.Permutation l l'
+++++
apply Permutation.Permutation_app_inv_l with (a :: nil).
-----
Lemma PermSorted : forall (l l' : list positive), Permutation.Permutation l l' -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l' -> l = l'.
Proof.
intro l.
induction l.
intro l'.
induction l'.
intros HPerm Hl Hl'.
assert (HIna' : In a (a :: l)).
idtac.
assert (HIna : In a (a0 :: l')).
idtac.
assert (HIna0' : In a0 (a0 :: l')).
idtac.
assert (HIna0 : In a0 (a :: l)).
idtac.
clear HIna'.
clear HIna0'.
apply in_inv in HIna.
apply in_inv in HIna0.
elim HIna.
clear HIna.
intro HIna.
elim HIna0.
clear HIna0.
intro HIna0.
try (rewrite HIna in *).
try (rewrite <- HIna0 in *).
assert (Hle1 := Hl).
assert (Hle2 := Hl').
apply StronglySorted_inv in Hle1.
apply StronglySorted_inv in Hle2.
destruct Hle1 as [Hclear Hle1].
clear Hclear.
destruct Hle2 as [Hclear Hle2].
clear Hclear.
assert (Haa0 : (forall x, In x l -> is_true (Pos.leb a x))).
idtac.
assert (Ha0a : (forall x, In x l' -> is_true (Pos.leb a0 x))).
idtac.
apply Ha0a in HIna.
apply Haa0 in HIna0.
unfold is_true in *.
apply Pos.leb_le in HIna.
apply Pos.leb_le in HIna0.
assert (H := Pos.le_antisym a0 a HIna HIna0).
rewrite H in *.
assert (HPerm' : Permutation.Permutation l l').
apply Permutation.Permutation_app_inv_l with (a :: nil).

*****
H : eq a0 a
Ha0a : forall (x : positive) (_ : In x l'), eq (Pos.leb a x) true
Haa0 : forall (x : positive) (_ : In x l), eq (Pos.leb a x) true
Hle2 : Forall (fun x0 : positive => eq (Pos.leb a x0) true) l'
Hle1 : Forall (fun x0 : positive => eq (Pos.leb a x0) true) l
HIna,HIna0 : Pos.le a a
Hl' : StronglySorted (fun x x0 : positive => eq (Pos.leb x x0) true)\n (cons a l')
Hl : StronglySorted (fun x x0 : positive => eq (Pos.leb x x0) true)\n (cons a l)
HPerm : Permutation.Permutation (cons a l) (cons a l')
IHl' : forall (_ : Permutation.Permutation (cons a l) l')\n (_ : StronglySorted (fun x x0 : positive => eq (Pos.leb x x0) true)\n (cons a l))\n (_ : StronglySorted (fun x x0 : positive => eq (Pos.leb x x0) true)\n l'), eq (cons a l) l'
l' : list positive
a0 : positive
IHl : forall (l' : list positive) (_ : Permutation.Permutation l l')\n (_ : StronglySorted (fun x x0 : positive => eq (Pos.leb x x0) true) l)\n (_ : StronglySorted (fun x x0 : positive => eq (Pos.leb x x0) true)\n l'), eq l l'
l : list positive
a : positive
*****
Permutation.Permutation (Datatypes.app (cons a nil) l) (Datatypes.app (cons a nil) l')
+++++
simpl.
-----
Lemma PermSorted : forall (l l' : list positive), Permutation.Permutation l l' -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l' -> l = l'.
Proof.
intro l.
induction l.
intro l'.
induction l'.
intros HPerm Hl Hl'.
assert (HIna' : In a (a :: l)).
idtac.
assert (HIna : In a (a0 :: l')).
idtac.
assert (HIna0' : In a0 (a0 :: l')).
idtac.
assert (HIna0 : In a0 (a :: l)).
idtac.
clear HIna'.
clear HIna0'.
apply in_inv in HIna.
apply in_inv in HIna0.
elim HIna.
clear HIna.
intro HIna.
elim HIna0.
clear HIna0.
intro HIna0.
try (rewrite HIna in *).
try (rewrite <- HIna0 in *).
assert (Hle1 := Hl).
assert (Hle2 := Hl').
apply StronglySorted_inv in Hle1.
apply StronglySorted_inv in Hle2.
destruct Hle1 as [Hclear Hle1].
clear Hclear.
destruct Hle2 as [Hclear Hle2].
clear Hclear.
assert (Haa0 : (forall x, In x l -> is_true (Pos.leb a x))).
idtac.
assert (Ha0a : (forall x, In x l' -> is_true (Pos.leb a0 x))).
idtac.
apply Ha0a in HIna.
apply Haa0 in HIna0.
unfold is_true in *.
apply Pos.leb_le in HIna.
apply Pos.leb_le in HIna0.
assert (H := Pos.le_antisym a0 a HIna HIna0).
rewrite H in *.
assert (HPerm' : Permutation.Permutation l l').
apply Permutation.Permutation_app_inv_l with (a :: nil).
simpl.

*****
H : eq a0 a
Ha0a : forall (x : positive) (_ : In x l'), eq (Pos.leb a x) true
Haa0 : forall (x : positive) (_ : In x l), eq (Pos.leb a x) true
Hle2 : Forall (fun x0 : positive => eq (Pos.leb a x0) true) l'
Hle1 : Forall (fun x0 : positive => eq (Pos.leb a x0) true) l
HIna,HIna0 : Pos.le a a
Hl' : StronglySorted (fun x x0 : positive => eq (Pos.leb x x0) true)\n (cons a l')
Hl : StronglySorted (fun x x0 : positive => eq (Pos.leb x x0) true)\n (cons a l)
HPerm : Permutation.Permutation (cons a l) (cons a l')
IHl' : forall (_ : Permutation.Permutation (cons a l) l')\n (_ : StronglySorted (fun x x0 : positive => eq (Pos.leb x x0) true)\n (cons a l))\n (_ : StronglySorted (fun x x0 : positive => eq (Pos.leb x x0) true)\n l'), eq (cons a l) l'
l' : list positive
a0 : positive
IHl : forall (l' : list positive) (_ : Permutation.Permutation l l')\n (_ : StronglySorted (fun x x0 : positive => eq (Pos.leb x x0) true) l)\n (_ : StronglySorted (fun x x0 : positive => eq (Pos.leb x x0) true)\n l'), eq l l'
l : list positive
a : positive
*****
Permutation.Permutation (cons a l) (cons a l')
+++++
assumption.
-----
Lemma PermSorted : forall (l l' : list positive), Permutation.Permutation l l' -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l' -> l = l'.
Proof.
intro l.
induction l.
intro l'.
induction l'.
intros HPerm Hl Hl'.
assert (HIna' : In a (a :: l)).
idtac.
assert (HIna : In a (a0 :: l')).
idtac.
assert (HIna0' : In a0 (a0 :: l')).
idtac.
assert (HIna0 : In a0 (a :: l)).
idtac.
clear HIna'.
clear HIna0'.
apply in_inv in HIna.
apply in_inv in HIna0.
elim HIna.
clear HIna.
intro HIna.
elim HIna0.
clear HIna0.
intro HIna0.
try (rewrite HIna in *).
try (rewrite <- HIna0 in *).
assert (Hle1 := Hl).
assert (Hle2 := Hl').
apply StronglySorted_inv in Hle1.
apply StronglySorted_inv in Hle2.
destruct Hle1 as [Hclear Hle1].
clear Hclear.
destruct Hle2 as [Hclear Hle2].
clear Hclear.
assert (Haa0 : (forall x, In x l -> is_true (Pos.leb a x))).
idtac.
assert (Ha0a : (forall x, In x l' -> is_true (Pos.leb a0 x))).
idtac.
apply Ha0a in HIna.
apply Haa0 in HIna0.
unfold is_true in *.
apply Pos.leb_le in HIna.
apply Pos.leb_le in HIna0.
assert (H := Pos.le_antisym a0 a HIna HIna0).
rewrite H in *.
assert (HPerm' : Permutation.Permutation l l').

*****
HPerm' : Permutation.Permutation l l'
H : eq a0 a
Ha0a : forall (x : positive) (_ : In x l'), eq (Pos.leb a x) true
Haa0 : forall (x : positive) (_ : In x l), eq (Pos.leb a x) true
Hle2 : Forall (fun x0 : positive => eq (Pos.leb a x0) true) l'
Hle1 : Forall (fun x0 : positive => eq (Pos.leb a x0) true) l
HIna,HIna0 : Pos.le a a
Hl' : StronglySorted (fun x x0 : positive => eq (Pos.leb x x0) true)\n (cons a l')
Hl : StronglySorted (fun x x0 : positive => eq (Pos.leb x x0) true)\n (cons a l)
HPerm : Permutation.Permutation (cons a l) (cons a l')
IHl' : forall (_ : Permutation.Permutation (cons a l) l')\n (_ : StronglySorted (fun x x0 : positive => eq (Pos.leb x x0) true)\n (cons a l))\n (_ : StronglySorted (fun x x0 : positive => eq (Pos.leb x x0) true)\n l'), eq (cons a l) l'
l' : list positive
a0 : positive
IHl : forall (l' : list positive) (_ : Permutation.Permutation l l')\n (_ : StronglySorted (fun x x0 : positive => eq (Pos.leb x x0) true) l)\n (_ : StronglySorted (fun x x0 : positive => eq (Pos.leb x x0) true)\n l'), eq l l'
l : list positive
a : positive
*****
eq (cons a l) (cons a l')
+++++
idtac.
-----
Lemma PermSorted : forall (l l' : list positive), Permutation.Permutation l l' -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l' -> l = l'.
Proof.
intro l.
induction l.
intro l'.
induction l'.
intros HPerm Hl Hl'.
assert (HIna' : In a (a :: l)).
idtac.
assert (HIna : In a (a0 :: l')).
idtac.
assert (HIna0' : In a0 (a0 :: l')).
idtac.
assert (HIna0 : In a0 (a :: l)).
idtac.
clear HIna'.
clear HIna0'.
apply in_inv in HIna.
apply in_inv in HIna0.
elim HIna.
clear HIna.
intro HIna.
elim HIna0.
clear HIna0.
intro HIna0.
try (rewrite HIna in *).
try (rewrite <- HIna0 in *).
assert (Hle1 := Hl).
assert (Hle2 := Hl').
apply StronglySorted_inv in Hle1.
apply StronglySorted_inv in Hle2.
destruct Hle1 as [Hclear Hle1].
clear Hclear.
destruct Hle2 as [Hclear Hle2].
clear Hclear.
assert (Haa0 : (forall x, In x l -> is_true (Pos.leb a x))).
idtac.
assert (Ha0a : (forall x, In x l' -> is_true (Pos.leb a0 x))).
idtac.
apply Ha0a in HIna.
apply Haa0 in HIna0.
unfold is_true in *.
apply Pos.leb_le in HIna.
apply Pos.leb_le in HIna0.
assert (H := Pos.le_antisym a0 a HIna HIna0).
rewrite H in *.
assert (HPerm' : Permutation.Permutation l l').
idtac.

*****
HPerm' : Permutation.Permutation l l'
H : eq a0 a
Ha0a : forall (x : positive) (_ : In x l'), eq (Pos.leb a x) true
Haa0 : forall (x : positive) (_ : In x l), eq (Pos.leb a x) true
Hle2 : Forall (fun x0 : positive => eq (Pos.leb a x0) true) l'
Hle1 : Forall (fun x0 : positive => eq (Pos.leb a x0) true) l
HIna,HIna0 : Pos.le a a
Hl' : StronglySorted (fun x x0 : positive => eq (Pos.leb x x0) true)\n (cons a l')
Hl : StronglySorted (fun x x0 : positive => eq (Pos.leb x x0) true)\n (cons a l)
HPerm : Permutation.Permutation (cons a l) (cons a l')
IHl' : forall (_ : Permutation.Permutation (cons a l) l')\n (_ : StronglySorted (fun x x0 : positive => eq (Pos.leb x x0) true)\n (cons a l))\n (_ : StronglySorted (fun x x0 : positive => eq (Pos.leb x x0) true)\n l'), eq (cons a l) l'
l' : list positive
a0 : positive
IHl : forall (l' : list positive) (_ : Permutation.Permutation l l')\n (_ : StronglySorted (fun x x0 : positive => eq (Pos.leb x x0) true) l)\n (_ : StronglySorted (fun x x0 : positive => eq (Pos.leb x x0) true)\n l'), eq l l'
l : list positive
a : positive
*****
eq (cons a l) (cons a l')
+++++
apply OCPSortedTl in Hl.
-----
Lemma PermSorted : forall (l l' : list positive), Permutation.Permutation l l' -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l' -> l = l'.
Proof.
intro l.
induction l.
intro l'.
induction l'.
intros HPerm Hl Hl'.
assert (HIna' : In a (a :: l)).
idtac.
assert (HIna : In a (a0 :: l')).
idtac.
assert (HIna0' : In a0 (a0 :: l')).
idtac.
assert (HIna0 : In a0 (a :: l)).
idtac.
clear HIna'.
clear HIna0'.
apply in_inv in HIna.
apply in_inv in HIna0.
elim HIna.
clear HIna.
intro HIna.
elim HIna0.
clear HIna0.
intro HIna0.
try (rewrite HIna in *).
try (rewrite <- HIna0 in *).
assert (Hle1 := Hl).
assert (Hle2 := Hl').
apply StronglySorted_inv in Hle1.
apply StronglySorted_inv in Hle2.
destruct Hle1 as [Hclear Hle1].
clear Hclear.
destruct Hle2 as [Hclear Hle2].
clear Hclear.
assert (Haa0 : (forall x, In x l -> is_true (Pos.leb a x))).
idtac.
assert (Ha0a : (forall x, In x l' -> is_true (Pos.leb a0 x))).
idtac.
apply Ha0a in HIna.
apply Haa0 in HIna0.
unfold is_true in *.
apply Pos.leb_le in HIna.
apply Pos.leb_le in HIna0.
assert (H := Pos.le_antisym a0 a HIna HIna0).
rewrite H in *.
assert (HPerm' : Permutation.Permutation l l').
idtac.
apply OCPSortedTl in Hl.

*****
HPerm' : Permutation.Permutation l l'
H : eq a0 a
Ha0a : forall (x : positive) (_ : In x l'), eq (Pos.leb a x) true
Haa0 : forall (x : positive) (_ : In x l), eq (Pos.leb a x) true
Hle2 : Forall (fun x0 : positive => eq (Pos.leb a x0) true) l'
Hle1 : Forall (fun x0 : positive => eq (Pos.leb a x0) true) l
HIna,HIna0 : Pos.le a a
Hl' : StronglySorted (fun x x0 : positive => eq (Pos.leb x x0) true)\n (cons a l')
Hl : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (tl (cons a l))
HPerm : Permutation.Permutation (cons a l) (cons a l')
IHl' : forall (_ : Permutation.Permutation (cons a l) l')\n (_ : StronglySorted (fun x x0 : positive => eq (Pos.leb x x0) true)\n (cons a l))\n (_ : StronglySorted (fun x x0 : positive => eq (Pos.leb x x0) true)\n l'), eq (cons a l) l'
l' : list positive
a0 : positive
IHl : forall (l' : list positive) (_ : Permutation.Permutation l l')\n (_ : StronglySorted (fun x x0 : positive => eq (Pos.leb x x0) true) l)\n (_ : StronglySorted (fun x x0 : positive => eq (Pos.leb x x0) true)\n l'), eq l l'
l : list positive
a : positive
*****
eq (cons a l) (cons a l')
+++++
apply OCPSortedTl in Hl'.
-----
Lemma PermSorted : forall (l l' : list positive), Permutation.Permutation l l' -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l' -> l = l'.
Proof.
intro l.
induction l.
intro l'.
induction l'.
intros HPerm Hl Hl'.
assert (HIna' : In a (a :: l)).
idtac.
assert (HIna : In a (a0 :: l')).
idtac.
assert (HIna0' : In a0 (a0 :: l')).
idtac.
assert (HIna0 : In a0 (a :: l)).
idtac.
clear HIna'.
clear HIna0'.
apply in_inv in HIna.
apply in_inv in HIna0.
elim HIna.
clear HIna.
intro HIna.
elim HIna0.
clear HIna0.
intro HIna0.
try (rewrite HIna in *).
try (rewrite <- HIna0 in *).
assert (Hle1 := Hl).
assert (Hle2 := Hl').
apply StronglySorted_inv in Hle1.
apply StronglySorted_inv in Hle2.
destruct Hle1 as [Hclear Hle1].
clear Hclear.
destruct Hle2 as [Hclear Hle2].
clear Hclear.
assert (Haa0 : (forall x, In x l -> is_true (Pos.leb a x))).
idtac.
assert (Ha0a : (forall x, In x l' -> is_true (Pos.leb a0 x))).
idtac.
apply Ha0a in HIna.
apply Haa0 in HIna0.
unfold is_true in *.
apply Pos.leb_le in HIna.
apply Pos.leb_le in HIna0.
assert (H := Pos.le_antisym a0 a HIna HIna0).
rewrite H in *.
assert (HPerm' : Permutation.Permutation l l').
idtac.
apply OCPSortedTl in Hl.
apply OCPSortedTl in Hl'.

*****
HPerm' : Permutation.Permutation l l'
H : eq a0 a
Ha0a : forall (x : positive) (_ : In x l'), eq (Pos.leb a x) true
Haa0 : forall (x : positive) (_ : In x l), eq (Pos.leb a x) true
Hle2 : Forall (fun x0 : positive => eq (Pos.leb a x0) true) l'
Hle1 : Forall (fun x0 : positive => eq (Pos.leb a x0) true) l
HIna,HIna0 : Pos.le a a
Hl' : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (tl (cons a l'))
Hl : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (tl (cons a l))
HPerm : Permutation.Permutation (cons a l) (cons a l')
IHl' : forall (_ : Permutation.Permutation (cons a l) l')\n (_ : StronglySorted (fun x x0 : positive => eq (Pos.leb x x0) true)\n (cons a l))\n (_ : StronglySorted (fun x x0 : positive => eq (Pos.leb x x0) true)\n l'), eq (cons a l) l'
l' : list positive
a0 : positive
IHl : forall (l' : list positive) (_ : Permutation.Permutation l l')\n (_ : StronglySorted (fun x x0 : positive => eq (Pos.leb x x0) true) l)\n (_ : StronglySorted (fun x x0 : positive => eq (Pos.leb x x0) true)\n l'), eq l l'
l : list positive
a : positive
*****
eq (cons a l) (cons a l')
+++++
apply IHl in HPerm'.
-----
Lemma PermSorted : forall (l l' : list positive), Permutation.Permutation l l' -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l' -> l = l'.
Proof.
intro l.
induction l.
intro l'.
induction l'.
intros HPerm Hl Hl'.
assert (HIna' : In a (a :: l)).
idtac.
assert (HIna : In a (a0 :: l')).
idtac.
assert (HIna0' : In a0 (a0 :: l')).
idtac.
assert (HIna0 : In a0 (a :: l)).
idtac.
clear HIna'.
clear HIna0'.
apply in_inv in HIna.
apply in_inv in HIna0.
elim HIna.
clear HIna.
intro HIna.
elim HIna0.
clear HIna0.
intro HIna0.
try (rewrite HIna in *).
try (rewrite <- HIna0 in *).
assert (Hle1 := Hl).
assert (Hle2 := Hl').
apply StronglySorted_inv in Hle1.
apply StronglySorted_inv in Hle2.
destruct Hle1 as [Hclear Hle1].
clear Hclear.
destruct Hle2 as [Hclear Hle2].
clear Hclear.
assert (Haa0 : (forall x, In x l -> is_true (Pos.leb a x))).
idtac.
assert (Ha0a : (forall x, In x l' -> is_true (Pos.leb a0 x))).
idtac.
apply Ha0a in HIna.
apply Haa0 in HIna0.
unfold is_true in *.
apply Pos.leb_le in HIna.
apply Pos.leb_le in HIna0.
assert (H := Pos.le_antisym a0 a HIna HIna0).
rewrite H in *.
assert (HPerm' : Permutation.Permutation l l').
idtac.
apply OCPSortedTl in Hl.
apply OCPSortedTl in Hl'.
apply IHl in HPerm'.

*****
HPerm' : eq l l'
H : eq a0 a
Ha0a : forall (x : positive) (_ : In x l'), eq (Pos.leb a x) true
Haa0 : forall (x : positive) (_ : In x l), eq (Pos.leb a x) true
Hle2 : Forall (fun x0 : positive => eq (Pos.leb a x0) true) l'
Hle1 : Forall (fun x0 : positive => eq (Pos.leb a x0) true) l
HIna,HIna0 : Pos.le a a
Hl' : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (tl (cons a l'))
Hl : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (tl (cons a l))
HPerm : Permutation.Permutation (cons a l) (cons a l')
IHl' : forall (_ : Permutation.Permutation (cons a l) l')\n (_ : StronglySorted (fun x x0 : positive => eq (Pos.leb x x0) true)\n (cons a l))\n (_ : StronglySorted (fun x x0 : positive => eq (Pos.leb x x0) true)\n l'), eq (cons a l) l'
l' : list positive
a0 : positive
IHl : forall (l' : list positive) (_ : Permutation.Permutation l l')\n (_ : StronglySorted (fun x x0 : positive => eq (Pos.leb x x0) true) l)\n (_ : StronglySorted (fun x x0 : positive => eq (Pos.leb x x0) true)\n l'), eq l l'
l : list positive
a : positive
*****
eq (cons a l) (cons a l')
+++++
try assumption.
-----
Lemma PermSorted : forall (l l' : list positive), Permutation.Permutation l l' -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l' -> l = l'.
Proof.
intro l.
induction l.
intro l'.
induction l'.
intros HPerm Hl Hl'.
assert (HIna' : In a (a :: l)).
idtac.
assert (HIna : In a (a0 :: l')).
idtac.
assert (HIna0' : In a0 (a0 :: l')).
idtac.
assert (HIna0 : In a0 (a :: l)).
idtac.
clear HIna'.
clear HIna0'.
apply in_inv in HIna.
apply in_inv in HIna0.
elim HIna.
clear HIna.
intro HIna.
elim HIna0.
clear HIna0.
intro HIna0.
try (rewrite HIna in *).
try (rewrite <- HIna0 in *).
assert (Hle1 := Hl).
assert (Hle2 := Hl').
apply StronglySorted_inv in Hle1.
apply StronglySorted_inv in Hle2.
destruct Hle1 as [Hclear Hle1].
clear Hclear.
destruct Hle2 as [Hclear Hle2].
clear Hclear.
assert (Haa0 : (forall x, In x l -> is_true (Pos.leb a x))).
idtac.
assert (Ha0a : (forall x, In x l' -> is_true (Pos.leb a0 x))).
idtac.
apply Ha0a in HIna.
apply Haa0 in HIna0.
unfold is_true in *.
apply Pos.leb_le in HIna.
apply Pos.leb_le in HIna0.
assert (H := Pos.le_antisym a0 a HIna HIna0).
rewrite H in *.
assert (HPerm' : Permutation.Permutation l l').
idtac.
apply OCPSortedTl in Hl.
apply OCPSortedTl in Hl'.
apply IHl in HPerm'.
try assumption.

*****
HPerm' : eq l l'
H : eq a0 a
Ha0a : forall (x : positive) (_ : In x l'), eq (Pos.leb a x) true
Haa0 : forall (x : positive) (_ : In x l), eq (Pos.leb a x) true
Hle2 : Forall (fun x0 : positive => eq (Pos.leb a x0) true) l'
Hle1 : Forall (fun x0 : positive => eq (Pos.leb a x0) true) l
HIna,HIna0 : Pos.le a a
Hl' : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (tl (cons a l'))
Hl : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (tl (cons a l))
HPerm : Permutation.Permutation (cons a l) (cons a l')
IHl' : forall (_ : Permutation.Permutation (cons a l) l')\n (_ : StronglySorted (fun x x0 : positive => eq (Pos.leb x x0) true)\n (cons a l))\n (_ : StronglySorted (fun x x0 : positive => eq (Pos.leb x x0) true)\n l'), eq (cons a l) l'
l' : list positive
a0 : positive
IHl : forall (l' : list positive) (_ : Permutation.Permutation l l')\n (_ : StronglySorted (fun x x0 : positive => eq (Pos.leb x x0) true) l)\n (_ : StronglySorted (fun x x0 : positive => eq (Pos.leb x x0) true)\n l'), eq l l'
l : list positive
a : positive
*****
eq (cons a l) (cons a l')
+++++
rewrite HPerm'.
-----
Lemma PermSorted : forall (l l' : list positive), Permutation.Permutation l l' -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l' -> l = l'.
Proof.
intro l.
induction l.
intro l'.
induction l'.
intros HPerm Hl Hl'.
assert (HIna' : In a (a :: l)).
idtac.
assert (HIna : In a (a0 :: l')).
idtac.
assert (HIna0' : In a0 (a0 :: l')).
idtac.
assert (HIna0 : In a0 (a :: l)).
idtac.
clear HIna'.
clear HIna0'.
apply in_inv in HIna.
apply in_inv in HIna0.
elim HIna.
clear HIna.
intro HIna.
elim HIna0.
clear HIna0.
intro HIna0.
try (rewrite HIna in *).
try (rewrite <- HIna0 in *).
assert (Hle1 := Hl).
assert (Hle2 := Hl').
apply StronglySorted_inv in Hle1.
apply StronglySorted_inv in Hle2.
destruct Hle1 as [Hclear Hle1].
clear Hclear.
destruct Hle2 as [Hclear Hle2].
clear Hclear.
assert (Haa0 : (forall x, In x l -> is_true (Pos.leb a x))).
idtac.
assert (Ha0a : (forall x, In x l' -> is_true (Pos.leb a0 x))).
idtac.
apply Ha0a in HIna.
apply Haa0 in HIna0.
unfold is_true in *.
apply Pos.leb_le in HIna.
apply Pos.leb_le in HIna0.
assert (H := Pos.le_antisym a0 a HIna HIna0).
rewrite H in *.
assert (HPerm' : Permutation.Permutation l l').
idtac.
apply OCPSortedTl in Hl.
apply OCPSortedTl in Hl'.
apply IHl in HPerm'.
try assumption.
rewrite HPerm'.

*****
HPerm' : eq l l'
H : eq a0 a
Ha0a : forall (x : positive) (_ : In x l'), eq (Pos.leb a x) true
Haa0 : forall (x : positive) (_ : In x l), eq (Pos.leb a x) true
Hle2 : Forall (fun x0 : positive => eq (Pos.leb a x0) true) l'
Hle1 : Forall (fun x0 : positive => eq (Pos.leb a x0) true) l
HIna,HIna0 : Pos.le a a
Hl' : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (tl (cons a l'))
Hl : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (tl (cons a l))
HPerm : Permutation.Permutation (cons a l) (cons a l')
IHl' : forall (_ : Permutation.Permutation (cons a l) l')\n (_ : StronglySorted (fun x x0 : positive => eq (Pos.leb x x0) true)\n (cons a l))\n (_ : StronglySorted (fun x x0 : positive => eq (Pos.leb x x0) true)\n l'), eq (cons a l) l'
l' : list positive
a0 : positive
IHl : forall (l' : list positive) (_ : Permutation.Permutation l l')\n (_ : StronglySorted (fun x x0 : positive => eq (Pos.leb x x0) true) l)\n (_ : StronglySorted (fun x x0 : positive => eq (Pos.leb x x0) true)\n l'), eq l l'
l : list positive
a : positive
*****
eq (cons a l') (cons a l')
+++++
reflexivity.
-----
Lemma PermSorted : forall (l l' : list positive), Permutation.Permutation l l' -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l' -> l = l'.
Proof.
intro l.
induction l.
intro l'.
induction l'.
intros HPerm Hl Hl'.
assert (HIna' : In a (a :: l)).
idtac.
assert (HIna : In a (a0 :: l')).
idtac.
assert (HIna0' : In a0 (a0 :: l')).
idtac.
assert (HIna0 : In a0 (a :: l)).
idtac.
clear HIna'.
clear HIna0'.
apply in_inv in HIna.
apply in_inv in HIna0.
elim HIna.
clear HIna.
intro HIna.
elim HIna0.
clear HIna0.
intro HIna0.
try (rewrite HIna in *).
try (rewrite <- HIna0 in *).
assert (Hle1 := Hl).
assert (Hle2 := Hl').
apply StronglySorted_inv in Hle1.
apply StronglySorted_inv in Hle2.
destruct Hle1 as [Hclear Hle1].
clear Hclear.
destruct Hle2 as [Hclear Hle2].
clear Hclear.
assert (Haa0 : (forall x, In x l -> is_true (Pos.leb a x))).
idtac.
assert (Ha0a : (forall x, In x l' -> is_true (Pos.leb a0 x))).
idtac.
apply Ha0a in HIna.
apply Haa0 in HIna0.
unfold is_true in *.
apply Pos.leb_le in HIna.
apply Pos.leb_le in HIna0.
assert (H := Pos.le_antisym a0 a HIna HIna0).
rewrite H in *.
assert (HPerm' : Permutation.Permutation l l').
idtac.
apply OCPSortedTl in Hl.
apply OCPSortedTl in Hl'.
apply IHl in HPerm'.

*****
HPerm' : Permutation.Permutation l l'
H : eq a0 a
Ha0a : forall (x : positive) (_ : In x l'), eq (Pos.leb a x) true
Haa0 : forall (x : positive) (_ : In x l), eq (Pos.leb a x) true
Hle2 : Forall (fun x0 : positive => eq (Pos.leb a x0) true) l'
Hle1 : Forall (fun x0 : positive => eq (Pos.leb a x0) true) l
HIna,HIna0 : Pos.le a a
Hl' : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (tl (cons a l'))
Hl : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (tl (cons a l))
HPerm : Permutation.Permutation (cons a l) (cons a l')
IHl' : forall (_ : Permutation.Permutation (cons a l) l')\n (_ : StronglySorted (fun x x0 : positive => eq (Pos.leb x x0) true)\n (cons a l))\n (_ : StronglySorted (fun x x0 : positive => eq (Pos.leb x x0) true)\n l'), eq (cons a l) l'
l' : list positive
a0 : positive
IHl : forall (l' : list positive) (_ : Permutation.Permutation l l')\n (_ : StronglySorted (fun x x0 : positive => eq (Pos.leb x x0) true) l)\n (_ : StronglySorted (fun x x0 : positive => eq (Pos.leb x x0) true)\n l'), eq l l'
l : list positive
a : positive
*****
StronglySorted (fun x x0 : positive => eq (Pos.leb x x0) true) l
+++++
try assumption.
-----
Lemma PermSorted : forall (l l' : list positive), Permutation.Permutation l l' -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l' -> l = l'.
Proof.
intro l.
induction l.
intro l'.
induction l'.
intros HPerm Hl Hl'.
assert (HIna' : In a (a :: l)).
idtac.
assert (HIna : In a (a0 :: l')).
idtac.
assert (HIna0' : In a0 (a0 :: l')).
idtac.
assert (HIna0 : In a0 (a :: l)).
idtac.
clear HIna'.
clear HIna0'.
apply in_inv in HIna.
apply in_inv in HIna0.
elim HIna.
clear HIna.
intro HIna.
elim HIna0.
clear HIna0.
intro HIna0.
try (rewrite HIna in *).
try (rewrite <- HIna0 in *).
assert (Hle1 := Hl).
assert (Hle2 := Hl').
apply StronglySorted_inv in Hle1.
apply StronglySorted_inv in Hle2.
destruct Hle1 as [Hclear Hle1].
clear Hclear.
destruct Hle2 as [Hclear Hle2].
clear Hclear.
assert (Haa0 : (forall x, In x l -> is_true (Pos.leb a x))).
idtac.
assert (Ha0a : (forall x, In x l' -> is_true (Pos.leb a0 x))).
idtac.
apply Ha0a in HIna.
apply Haa0 in HIna0.
unfold is_true in *.
apply Pos.leb_le in HIna.
apply Pos.leb_le in HIna0.
assert (H := Pos.le_antisym a0 a HIna HIna0).
rewrite H in *.
assert (HPerm' : Permutation.Permutation l l').
idtac.
apply OCPSortedTl in Hl.
apply OCPSortedTl in Hl'.
apply IHl in HPerm'.

*****
HPerm' : Permutation.Permutation l l'
H : eq a0 a
Ha0a : forall (x : positive) (_ : In x l'), eq (Pos.leb a x) true
Haa0 : forall (x : positive) (_ : In x l), eq (Pos.leb a x) true
Hle2 : Forall (fun x0 : positive => eq (Pos.leb a x0) true) l'
Hle1 : Forall (fun x0 : positive => eq (Pos.leb a x0) true) l
HIna,HIna0 : Pos.le a a
Hl' : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (tl (cons a l'))
Hl : StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0))\n (tl (cons a l))
HPerm : Permutation.Permutation (cons a l) (cons a l')
IHl' : forall (_ : Permutation.Permutation (cons a l) l')\n (_ : StronglySorted (fun x x0 : positive => eq (Pos.leb x x0) true)\n (cons a l))\n (_ : StronglySorted (fun x x0 : positive => eq (Pos.leb x x0) true)\n l'), eq (cons a l) l'
l' : list positive
a0 : positive
IHl : forall (l' : list positive) (_ : Permutation.Permutation l l')\n (_ : StronglySorted (fun x x0 : positive => eq (Pos.leb x x0) true) l)\n (_ : StronglySorted (fun x x0 : positive => eq (Pos.leb x x0) true)\n l'), eq l l'
l : list positive
a : positive
*****
StronglySorted (fun x x0 : positive => eq (Pos.leb x x0) true) l'
+++++
try assumption.
-----
Lemma PermSorted : forall (l l' : list positive), Permutation.Permutation l l' -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l -> StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) l' -> l = l'.
Proof.
intro l.
induction l.

*****

*****

+++++
Qed.
-----
Definition OCP {n : nat} (cp : cartesianPower positive (S (S n))) : cartesianPower positive (S (S n)).
-----
Definition OCP {n : nat} (cp : cartesianPower positive (S (S n))) : cartesianPower positive (S (S n)).

*****
cp : cartesianPower positive (S (S n))
n : nat
*****
cartesianPower positive (S (S n))
+++++
Proof.
-----
Definition OCP {n : nat} (cp : cartesianPower positive (S (S n))) : cartesianPower positive (S (S n)).
Proof.

*****
cp : cartesianPower positive (S (S n))
n : nat
*****
cartesianPower positive (S (S n))
+++++
assert (H := OCPALengthOK cp).
-----
Definition OCP {n : nat} (cp : cartesianPower positive (S (S n))) : cartesianPower positive (S (S n)).
Proof.
assert (H := OCPALengthOK cp).

*****
H : eq (length (OCPAux cp)) (S (S n))
cp : cartesianPower positive (S (S n))
n : nat
*****
cartesianPower positive (S (S n))
+++++
rewrite <- H.
-----
Definition OCP {n : nat} (cp : cartesianPower positive (S (S n))) : cartesianPower positive (S (S n)).
Proof.
assert (H := OCPALengthOK cp).
rewrite <- H.

*****
H : eq (length (OCPAux cp)) (S (S n))
cp : cartesianPower positive (S (S n))
n : nat
*****
cartesianPower positive (length (OCPAux cp))
+++++
exact (ListToCP (OCPAux cp) (fst cp)).
-----
Definition OCP {n : nat} (cp : cartesianPower positive (S (S n))) : cartesianPower positive (S (S n)).
Proof.
assert (H := OCPALengthOK cp).
rewrite <- H.
exact (ListToCP (OCPAux cp) (fst cp)).

*****

*****

+++++
Defined.
-----
Lemma OCPSortedAux {n : nat} :\n  forall (cp : cartesianPower positive (S (S n))),\n  StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) (CPToList (OCP cp)).
-----
Lemma OCPSortedAux {n : nat} : forall (cp : cartesianPower positive (S (S n))), StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) (CPToList (OCP cp)).

*****
n : nat
*****
forall cp : cartesianPower positive (S (S n)), StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) (CPToList (OCP cp))
+++++
Proof.
-----
Lemma OCPSortedAux {n : nat} : forall (cp : cartesianPower positive (S (S n))), StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) (CPToList (OCP cp)).
Proof.

*****
n : nat
*****
forall cp : cartesianPower positive (S (S n)), StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) (CPToList (OCP cp))
+++++
intros cp.
-----
Lemma OCPSortedAux {n : nat} : forall (cp : cartesianPower positive (S (S n))), StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) (CPToList (OCP cp)).
Proof.
intros cp.

*****
cp : cartesianPower positive (S (S n))
n : nat
*****
StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) (CPToList (OCP cp))
+++++
unfold OCP.
-----
Lemma OCPSortedAux {n : nat} : forall (cp : cartesianPower positive (S (S n))), StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) (CPToList (OCP cp)).
Proof.
intros cp.
unfold OCP.

*****
cp : cartesianPower positive (S (S n))
n : nat
*****
StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) (CPToList (eq_rect (length (OCPAux cp)) (fun n : nat => cartesianPower positive n) (ListToCP (OCPAux cp) (fst cp)) (S (S n)) (OCPALengthOK cp)))
+++++
unfold OCPAux.
-----
Lemma OCPSortedAux {n : nat} : forall (cp : cartesianPower positive (S (S n))), StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) (CPToList (OCP cp)).
Proof.
intros cp.
unfold OCP.
unfold OCPAux.

*****
cp : cartesianPower positive (S (S n))
n : nat
*****
StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) (CPToList (eq_rect (length (sort (CPToList cp))) (fun n : nat => cartesianPower positive n) (ListToCP (sort (CPToList cp)) (fst cp)) (S (S n)) (OCPALengthOK cp)))
+++++
elim_eq_rect.
-----
Lemma OCPSortedAux {n : nat} : forall (cp : cartesianPower positive (S (S n))), StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) (CPToList (OCP cp)).
Proof.
intros cp.
unfold OCP.
unfold OCPAux.
elim_eq_rect.

*****
cp : cartesianPower positive (S (S n))
n : nat
*****
StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) (CPToList (eq_rect (length (sort (CPToList cp))) (fun n : nat => cartesianPower positive n) (ListToCP (sort (CPToList cp)) (fst cp)) (length (OCPAux cp)) eq_refl))
+++++
simpl.
-----
Lemma OCPSortedAux {n : nat} : forall (cp : cartesianPower positive (S (S n))), StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) (CPToList (OCP cp)).
Proof.
intros cp.
unfold OCP.
unfold OCPAux.
elim_eq_rect.
simpl.

*****
cp : cartesianPower positive (S (S n))
n : nat
*****
StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) (CPToList (ListToCP (sort (cons (fst cp) (nat_rect (fun n : nat => forall _ : cartesianPower positive (S n), list positive) (fun cp : cartesianPower positive (S O) => cons cp nil) (fun (n : nat) (IHn : forall _ : cartesianPower positive (S n), list positive) (cp : cartesianPower positive (S (S n))) => cons (fst cp) (IHn (tailCP cp))) n (tailCP cp)))) (fst cp)))
+++++
rewrite CPLOK.
-----
Lemma OCPSortedAux {n : nat} : forall (cp : cartesianPower positive (S (S n))), StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) (CPToList (OCP cp)).
Proof.
intros cp.
unfold OCP.
unfold OCPAux.
elim_eq_rect.
simpl.
rewrite CPLOK.

*****
cp : cartesianPower positive (S (S n))
n : nat
*****
StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) (sort (cons (fst cp) (nat_rect (fun n : nat => forall _ : cartesianPower positive (S n), list positive) (fun cp : cartesianPower positive (S O) => cons cp nil) (fun (n : nat) (IHn : forall _ : cartesianPower positive (S n), list positive) (cp : cartesianPower positive (S (S n))) => cons (fst cp) (IHn (tailCP cp))) n (tailCP cp))))
+++++
apply StronglySorted_sort.
-----
Lemma OCPSortedAux {n : nat} : forall (cp : cartesianPower positive (S (S n))), StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) (CPToList (OCP cp)).
Proof.
intros cp.
unfold OCP.
unfold OCPAux.
elim_eq_rect.
simpl.
rewrite CPLOK.
apply StronglySorted_sort.

*****
cp : cartesianPower positive (S (S n))
n : nat
*****
Transitive (fun x x0 : positive => is_true (Pos.leb x x0))
+++++
intros x1 x2 x3.
-----
Lemma OCPSortedAux {n : nat} : forall (cp : cartesianPower positive (S (S n))), StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) (CPToList (OCP cp)).
Proof.
intros cp.
unfold OCP.
unfold OCPAux.
elim_eq_rect.
simpl.
rewrite CPLOK.
apply StronglySorted_sort.
intros x1 x2 x3.

*****
x1,x2,x3 : positive
cp : cartesianPower positive (S (S n))
n : nat
*****
forall (_ : is_true (Pos.leb x1 x2)) (_ : is_true (Pos.leb x2 x3)), is_true (Pos.leb x1 x3)
+++++
unfold is_true.
-----
Lemma OCPSortedAux {n : nat} : forall (cp : cartesianPower positive (S (S n))), StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) (CPToList (OCP cp)).
Proof.
intros cp.
unfold OCP.
unfold OCPAux.
elim_eq_rect.
simpl.
rewrite CPLOK.
apply StronglySorted_sort.
intros x1 x2 x3.
unfold is_true.

*****
x1,x2,x3 : positive
cp : cartesianPower positive (S (S n))
n : nat
*****
forall (_ : eq (Pos.leb x1 x2) true) (_ : eq (Pos.leb x2 x3) true), eq (Pos.leb x1 x3) true
+++++
intros Hx1x2 Hx2x3.
-----
Lemma OCPSortedAux {n : nat} : forall (cp : cartesianPower positive (S (S n))), StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) (CPToList (OCP cp)).
Proof.
intros cp.
unfold OCP.
unfold OCPAux.
elim_eq_rect.
simpl.
rewrite CPLOK.
apply StronglySorted_sort.
intros x1 x2 x3.
unfold is_true.
intros Hx1x2 Hx2x3.

*****
Hx2x3 : eq (Pos.leb x2 x3) true
Hx1x2 : eq (Pos.leb x1 x2) true
x1,x2,x3 : positive
cp : cartesianPower positive (S (S n))
n : nat
*****
eq (Pos.leb x1 x3) true
+++++
apply Pos.leb_le in Hx1x2.
-----
Lemma OCPSortedAux {n : nat} : forall (cp : cartesianPower positive (S (S n))), StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) (CPToList (OCP cp)).
Proof.
intros cp.
unfold OCP.
unfold OCPAux.
elim_eq_rect.
simpl.
rewrite CPLOK.
apply StronglySorted_sort.
intros x1 x2 x3.
unfold is_true.
intros Hx1x2 Hx2x3.
apply Pos.leb_le in Hx1x2.

*****
Hx2x3 : eq (Pos.leb x2 x3) true
Hx1x2 : Pos.le x1 x2
x1,x2,x3 : positive
cp : cartesianPower positive (S (S n))
n : nat
*****
eq (Pos.leb x1 x3) true
+++++
apply Pos.leb_le in Hx2x3.
-----
Lemma OCPSortedAux {n : nat} : forall (cp : cartesianPower positive (S (S n))), StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) (CPToList (OCP cp)).
Proof.
intros cp.
unfold OCP.
unfold OCPAux.
elim_eq_rect.
simpl.
rewrite CPLOK.
apply StronglySorted_sort.
intros x1 x2 x3.
unfold is_true.
intros Hx1x2 Hx2x3.
apply Pos.leb_le in Hx1x2.
apply Pos.leb_le in Hx2x3.

*****
Hx2x3 : Pos.le x2 x3
Hx1x2 : Pos.le x1 x2
x1,x2,x3 : positive
cp : cartesianPower positive (S (S n))
n : nat
*****
eq (Pos.leb x1 x3) true
+++++
apply Pos.leb_le.
-----
Lemma OCPSortedAux {n : nat} : forall (cp : cartesianPower positive (S (S n))), StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) (CPToList (OCP cp)).
Proof.
intros cp.
unfold OCP.
unfold OCPAux.
elim_eq_rect.
simpl.
rewrite CPLOK.
apply StronglySorted_sort.
intros x1 x2 x3.
unfold is_true.
intros Hx1x2 Hx2x3.
apply Pos.leb_le in Hx1x2.
apply Pos.leb_le in Hx2x3.
apply Pos.leb_le.

*****
Hx2x3 : Pos.le x2 x3
Hx1x2 : Pos.le x1 x2
x1,x2,x3 : positive
cp : cartesianPower positive (S (S n))
n : nat
*****
Pos.le x1 x3
+++++
transitivity x2.
-----
Lemma OCPSortedAux {n : nat} : forall (cp : cartesianPower positive (S (S n))), StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) (CPToList (OCP cp)).
Proof.
intros cp.
unfold OCP.
unfold OCPAux.
elim_eq_rect.
simpl.
rewrite CPLOK.
apply StronglySorted_sort.
intros x1 x2 x3.
unfold is_true.
intros Hx1x2 Hx2x3.
apply Pos.leb_le in Hx1x2.
apply Pos.leb_le in Hx2x3.
apply Pos.leb_le.
transitivity x2.

*****
Hx2x3 : Pos.le x2 x3
Hx1x2 : Pos.le x1 x2
x1,x2,x3 : positive
cp : cartesianPower positive (S (S n))
n : nat
*****
Pos.le x1 x2
+++++
assumption.
-----
Lemma OCPSortedAux {n : nat} : forall (cp : cartesianPower positive (S (S n))), StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) (CPToList (OCP cp)).
Proof.
intros cp.
unfold OCP.
unfold OCPAux.
elim_eq_rect.
simpl.
rewrite CPLOK.
apply StronglySorted_sort.
intros x1 x2 x3.
unfold is_true.
intros Hx1x2 Hx2x3.
apply Pos.leb_le in Hx1x2.
apply Pos.leb_le in Hx2x3.
apply Pos.leb_le.
transitivity x2.

*****
Hx2x3 : Pos.le x2 x3
Hx1x2 : Pos.le x1 x2
x1,x2,x3 : positive
cp : cartesianPower positive (S (S n))
n : nat
*****
Pos.le x2 x3
+++++
assumption.
-----
Lemma OCPSortedAux {n : nat} : forall (cp : cartesianPower positive (S (S n))), StronglySorted (fun x x0 : positive => is_true (x <=? x0)%positive) (CPToList (OCP cp)).
Proof.
intros cp.
unfold OCP.
unfold OCPAux.
elim_eq_rect.
simpl.
rewrite CPLOK.
apply StronglySorted_sort.
intros x1 x2 x3.
unfold is_true.
intros Hx1x2 Hx2x3.
apply Pos.leb_le in Hx1x2.
apply Pos.leb_le in Hx2x3.
apply Pos.leb_le.
transitivity x2.

*****

*****

+++++
Qed.
-----
Lemma OCPPerm {n : nat} :\n  forall (cp : cartesianPower positive (S (S n))),\n  Permutation.Permutation (CPToList cp) (CPToList (OCP cp)).
-----
Lemma OCPPerm {n : nat} : forall (cp : cartesianPower positive (S (S n))), Permutation.Permutation (CPToList cp) (CPToList (OCP cp)).

*****
n : nat
*****
forall cp : cartesianPower positive (S (S n)), Permutation.Permutation (CPToList cp) (CPToList (OCP cp))
+++++
Proof.
-----
Lemma OCPPerm {n : nat} : forall (cp : cartesianPower positive (S (S n))), Permutation.Permutation (CPToList cp) (CPToList (OCP cp)).
Proof.

*****
n : nat
*****
forall cp : cartesianPower positive (S (S n)), Permutation.Permutation (CPToList cp) (CPToList (OCP cp))
+++++
intro cp.
-----
Lemma OCPPerm {n : nat} : forall (cp : cartesianPower positive (S (S n))), Permutation.Permutation (CPToList cp) (CPToList (OCP cp)).
Proof.
intro cp.

*****
cp : cartesianPower positive (S (S n))
n : nat
*****
Permutation.Permutation (CPToList cp) (CPToList (OCP cp))
+++++
unfold OCP.
-----
Lemma OCPPerm {n : nat} : forall (cp : cartesianPower positive (S (S n))), Permutation.Permutation (CPToList cp) (CPToList (OCP cp)).
Proof.
intro cp.
unfold OCP.

*****
cp : cartesianPower positive (S (S n))
n : nat
*****
Permutation.Permutation (CPToList cp) (CPToList (eq_rect (length (OCPAux cp)) (fun n : nat => cartesianPower positive n) (ListToCP (OCPAux cp) (fst cp)) (S (S n)) (OCPALengthOK cp)))
+++++
unfold OCPAux.
-----
Lemma OCPPerm {n : nat} : forall (cp : cartesianPower positive (S (S n))), Permutation.Permutation (CPToList cp) (CPToList (OCP cp)).
Proof.
intro cp.
unfold OCP.
unfold OCPAux.

*****
cp : cartesianPower positive (S (S n))
n : nat
*****
Permutation.Permutation (CPToList cp) (CPToList (eq_rect (length (sort (CPToList cp))) (fun n : nat => cartesianPower positive n) (ListToCP (sort (CPToList cp)) (fst cp)) (S (S n)) (OCPALengthOK cp)))
+++++
elim_eq_rect.
-----
Lemma OCPPerm {n : nat} : forall (cp : cartesianPower positive (S (S n))), Permutation.Permutation (CPToList cp) (CPToList (OCP cp)).
Proof.
intro cp.
unfold OCP.
unfold OCPAux.
elim_eq_rect.

*****
cp : cartesianPower positive (S (S n))
n : nat
*****
Permutation.Permutation (CPToList cp) (CPToList (eq_rect (length (sort (CPToList cp))) (fun n : nat => cartesianPower positive n) (ListToCP (sort (CPToList cp)) (fst cp)) (length (OCPAux cp)) eq_refl))
+++++
simpl.
-----
Lemma OCPPerm {n : nat} : forall (cp : cartesianPower positive (S (S n))), Permutation.Permutation (CPToList cp) (CPToList (OCP cp)).
Proof.
intro cp.
unfold OCP.
unfold OCPAux.
elim_eq_rect.
simpl.

*****
cp : cartesianPower positive (S (S n))
n : nat
*****
Permutation.Permutation (cons (fst cp) (nat_rect (fun n : nat => forall _ : cartesianPower positive (S n), list positive) (fun cp : cartesianPower positive (S O) => cons cp nil) (fun (n : nat) (IHn : forall _ : cartesianPower positive (S n), list positive) (cp : cartesianPower positive (S (S n))) => cons (fst cp) (IHn (tailCP cp))) n (tailCP cp))) (CPToList (ListToCP (sort (cons (fst cp) (nat_rect (fun n : nat => forall _ : cartesianPower positive (S n), list positive) (fun cp : cartesianPower positive (S O) => cons cp nil) (fun (n : nat) (IHn : forall _ : cartesianPower positive (S n), list positive) (cp : cartesianPower positive (S (S n))) => cons (fst cp) (IHn (tailCP cp))) n (tailCP cp)))) (fst cp)))
+++++
rewrite CPLOK.
-----
Lemma OCPPerm {n : nat} : forall (cp : cartesianPower positive (S (S n))), Permutation.Permutation (CPToList cp) (CPToList (OCP cp)).
Proof.
intro cp.
unfold OCP.
unfold OCPAux.
elim_eq_rect.
simpl.
rewrite CPLOK.

*****
cp : cartesianPower positive (S (S n))
n : nat
*****
Permutation.Permutation (cons (fst cp) (nat_rect (fun n : nat => forall _ : cartesianPower positive (S n), list positive) (fun cp : cartesianPower positive (S O) => cons cp nil) (fun (n : nat) (IHn : forall _ : cartesianPower positive (S n), list positive) (cp : cartesianPower positive (S (S n))) => cons (fst cp) (IHn (tailCP cp))) n (tailCP cp))) (sort (cons (fst cp) (nat_rect (fun n : nat => forall _ : cartesianPower positive (S n), list positive) (fun cp : cartesianPower positive (S O) => cons cp nil) (fun (n : nat) (IHn : forall _ : cartesianPower positive (S n), list positive) (cp : cartesianPower positive (S (S n))) => cons (fst cp) (IHn (tailCP cp))) n (tailCP cp))))
+++++
apply Permuted_sort.
-----
Lemma OCPPerm {n : nat} : forall (cp : cartesianPower positive (S (S n))), Permutation.Permutation (CPToList cp) (CPToList (OCP cp)).
Proof.
intro cp.
unfold OCP.
unfold OCPAux.
elim_eq_rect.
simpl.
rewrite CPLOK.
apply Permuted_sort.

*****

*****

+++++
Qed.
-----
Lemma CPLOCPTlOK {n : nat} :\n  forall (cp : cartesianPower positive (S (S (S n)))),\n  headCP cp = headCP (OCP cp) ->\n  CPToList (OCP (tailCP cp)) = CPToList (tailCP (OCP cp)).
-----
Lemma CPLOCPTlOK {n : nat} : forall (cp : cartesianPower positive (S (S (S n)))), headCP cp = headCP (OCP cp) -> CPToList (OCP (tailCP cp)) = CPToList (tailCP (OCP cp)).

*****
n : nat
*****
forall (cp : cartesianPower positive (S (S (S n)))) (_ : eq (headCP cp) (headCP (OCP cp))), eq (CPToList (OCP (tailCP cp))) (CPToList (tailCP (OCP cp)))
+++++
Proof.
-----
Lemma CPLOCPTlOK {n : nat} : forall (cp : cartesianPower positive (S (S (S n)))), headCP cp = headCP (OCP cp) -> CPToList (OCP (tailCP cp)) = CPToList (tailCP (OCP cp)).
Proof.

*****
n : nat
*****
forall (cp : cartesianPower positive (S (S (S n)))) (_ : eq (headCP cp) (headCP (OCP cp))), eq (CPToList (OCP (tailCP cp))) (CPToList (tailCP (OCP cp)))
+++++
intros cp Hhd.
-----
Lemma CPLOCPTlOK {n : nat} : forall (cp : cartesianPower positive (S (S (S n)))), headCP cp = headCP (OCP cp) -> CPToList (OCP (tailCP cp)) = CPToList (tailCP (OCP cp)).
Proof.
intros cp Hhd.

*****
Hhd : eq (headCP cp) (headCP (OCP cp))
cp : cartesianPower positive (S (S (S n)))
n : nat
*****
eq (CPToList (OCP (tailCP cp))) (CPToList (tailCP (OCP cp)))
+++++
apply PermSorted.
-----
Lemma CPLOCPTlOK {n : nat} : forall (cp : cartesianPower positive (S (S (S n)))), headCP cp = headCP (OCP cp) -> CPToList (OCP (tailCP cp)) = CPToList (tailCP (OCP cp)).
Proof.
intros cp Hhd.
apply PermSorted.

*****
Hhd : eq (headCP cp) (headCP (OCP cp))
cp : cartesianPower positive (S (S (S n)))
n : nat
*****
Permutation.Permutation (CPToList (OCP (tailCP cp))) (CPToList (tailCP (OCP cp)))
+++++
assert (H := OCPPerm cp).
-----
Lemma CPLOCPTlOK {n : nat} : forall (cp : cartesianPower positive (S (S (S n)))), headCP cp = headCP (OCP cp) -> CPToList (OCP (tailCP cp)) = CPToList (tailCP (OCP cp)).
Proof.
intros cp Hhd.
apply PermSorted.
assert (H := OCPPerm cp).

*****
H : Permutation.Permutation (CPToList cp) (CPToList (OCP cp))
Hhd : eq (headCP cp) (headCP (OCP cp))
cp : cartesianPower positive (S (S (S n)))
n : nat
*****
Permutation.Permutation (CPToList (OCP (tailCP cp))) (CPToList (tailCP (OCP cp)))
+++++
rewrite CPToListOK in H.
-----
Lemma CPLOCPTlOK {n : nat} : forall (cp : cartesianPower positive (S (S (S n)))), headCP cp = headCP (OCP cp) -> CPToList (OCP (tailCP cp)) = CPToList (tailCP (OCP cp)).
Proof.
intros cp Hhd.
apply PermSorted.
assert (H := OCPPerm cp).
rewrite CPToListOK in H.

*****
H : Permutation.Permutation (cons (headCP cp) (CPToList (tailCP cp)))\n (CPToList (OCP cp))
Hhd : eq (headCP cp) (headCP (OCP cp))
cp : cartesianPower positive (S (S (S n)))
n : nat
*****
Permutation.Permutation (CPToList (OCP (tailCP cp))) (CPToList (tailCP (OCP cp)))
+++++
apply Permutation.Permutation_sym in H.
-----
Lemma CPLOCPTlOK {n : nat} : forall (cp : cartesianPower positive (S (S (S n)))), headCP cp = headCP (OCP cp) -> CPToList (OCP (tailCP cp)) = CPToList (tailCP (OCP cp)).
Proof.
intros cp Hhd.
apply PermSorted.
assert (H := OCPPerm cp).
rewrite CPToListOK in H.
apply Permutation.Permutation_sym in H.

*****
H : Permutation.Permutation (CPToList (OCP cp))\n (cons (headCP cp) (CPToList (tailCP cp)))
Hhd : eq (headCP cp) (headCP (OCP cp))
cp : cartesianPower positive (S (S (S n)))
n : nat
*****
Permutation.Permutation (CPToList (OCP (tailCP cp))) (CPToList (tailCP (OCP cp)))
+++++
rewrite CPToListOK in H.
-----
Lemma CPLOCPTlOK {n : nat} : forall (cp : cartesianPower positive (S (S (S n)))), headCP cp = headCP (OCP cp) -> CPToList (OCP (tailCP cp)) = CPToList (tailCP (OCP cp)).
Proof.
intros cp Hhd.
apply PermSorted.
assert (H := OCPPerm cp).
rewrite CPToListOK in H.
apply Permutation.Permutation_sym in H.
rewrite CPToListOK in H.

*****
H : Permutation.Permutation\n (cons (headCP (OCP cp)) (CPToList (tailCP (OCP cp))))\n (cons (headCP cp) (CPToList (tailCP cp)))
Hhd : eq (headCP cp) (headCP (OCP cp))
cp : cartesianPower positive (S (S (S n)))
n : nat
*****
Permutation.Permutation (CPToList (OCP (tailCP cp))) (CPToList (tailCP (OCP cp)))
+++++
rewrite <- Hhd in H.
-----
Lemma CPLOCPTlOK {n : nat} : forall (cp : cartesianPower positive (S (S (S n)))), headCP cp = headCP (OCP cp) -> CPToList (OCP (tailCP cp)) = CPToList (tailCP (OCP cp)).
Proof.
intros cp Hhd.
apply PermSorted.
assert (H := OCPPerm cp).
rewrite CPToListOK in H.
apply Permutation.Permutation_sym in H.
rewrite CPToListOK in H.
rewrite <- Hhd in H.

*****
H : Permutation.Permutation (cons (headCP cp) (CPToList (tailCP (OCP cp))))\n (cons (headCP cp) (CPToList (tailCP cp)))
Hhd : eq (headCP cp) (headCP (OCP cp))
cp : cartesianPower positive (S (S (S n)))
n : nat
*****
Permutation.Permutation (CPToList (OCP (tailCP cp))) (CPToList (tailCP (OCP cp)))
+++++
apply Permutation.Permutation_app_inv_l with ((headCP cp) :: nil).
-----
Lemma CPLOCPTlOK {n : nat} : forall (cp : cartesianPower positive (S (S (S n)))), headCP cp = headCP (OCP cp) -> CPToList (OCP (tailCP cp)) = CPToList (tailCP (OCP cp)).
Proof.
intros cp Hhd.
apply PermSorted.
assert (H := OCPPerm cp).
rewrite CPToListOK in H.
apply Permutation.Permutation_sym in H.
rewrite CPToListOK in H.
rewrite <- Hhd in H.
apply Permutation.Permutation_app_inv_l with ((headCP cp) :: nil).

*****
H : Permutation.Permutation (cons (headCP cp) (CPToList (tailCP (OCP cp))))\n (cons (headCP cp) (CPToList (tailCP cp)))
Hhd : eq (headCP cp) (headCP (OCP cp))
cp : cartesianPower positive (S (S (S n)))
n : nat
*****
Permutation.Permutation (Datatypes.app (cons (headCP cp) nil) (CPToList (OCP (tailCP cp)))) (Datatypes.app (cons (headCP cp) nil) (CPToList (tailCP (OCP cp))))
+++++
assert (H' : (headCP cp :: nil) ++ CPToList (OCP (tailCP cp)) = headCP cp :: (CPToList (OCP (tailCP cp)))) by (simpl; reflexivity); rewrite H'; clear H'.
-----
Lemma CPLOCPTlOK {n : nat} : forall (cp : cartesianPower positive (S (S (S n)))), headCP cp = headCP (OCP cp) -> CPToList (OCP (tailCP cp)) = CPToList (tailCP (OCP cp)).
Proof.
intros cp Hhd.
apply PermSorted.
assert (H := OCPPerm cp).
rewrite CPToListOK in H.
apply Permutation.Permutation_sym in H.
rewrite CPToListOK in H.
rewrite <- Hhd in H.
apply Permutation.Permutation_app_inv_l with ((headCP cp) :: nil).
assert (H' : (headCP cp :: nil) ++ CPToList (OCP (tailCP cp)) = headCP cp :: (CPToList (OCP (tailCP cp)))) by (simpl; reflexivity); rewrite H'; clear H'.

*****
H : Permutation.Permutation (cons (headCP cp) (CPToList (tailCP (OCP cp))))\n (cons (headCP cp) (CPToList (tailCP cp)))
Hhd : eq (headCP cp) (headCP (OCP cp))
cp : cartesianPower positive (S (S (S n)))
n : nat
*****
Permutation.Permutation (cons (headCP cp) (CPToList (OCP (tailCP cp)))) (Datatypes.app (cons (headCP cp) nil) (CPToList (tailCP (OCP cp))))
+++++
assert (H' : (headCP cp :: nil) ++ CPToList (tailCP (OCP cp)) = headCP cp :: (CPToList (tailCP (OCP cp)))) by (simpl; reflexivity); rewrite H'; clear H'.
-----
Lemma CPLOCPTlOK {n : nat} : forall (cp : cartesianPower positive (S (S (S n)))), headCP cp = headCP (OCP cp) -> CPToList (OCP (tailCP cp)) = CPToList (tailCP (OCP cp)).
Proof.
intros cp Hhd.
apply PermSorted.
assert (H := OCPPerm cp).
rewrite CPToListOK in H.
apply Permutation.Permutation_sym in H.
rewrite CPToListOK in H.
rewrite <- Hhd in H.
apply Permutation.Permutation_app_inv_l with ((headCP cp) :: nil).
assert (H' : (headCP cp :: nil) ++ CPToList (OCP (tailCP cp)) = headCP cp :: (CPToList (OCP (tailCP cp)))) by (simpl; reflexivity); rewrite H'; clear H'.
assert (H' : (headCP cp :: nil) ++ CPToList (tailCP (OCP cp)) = headCP cp :: (CPToList (tailCP (OCP cp)))) by (simpl; reflexivity); rewrite H'; clear H'.

*****
H : Permutation.Permutation (cons (headCP cp) (CPToList (tailCP (OCP cp))))\n (cons (headCP cp) (CPToList (tailCP cp)))
Hhd : eq (headCP cp) (headCP (OCP cp))
cp : cartesianPower positive (S (S (S n)))
n : nat
*****
Permutation.Permutation (cons (headCP cp) (CPToList (OCP (tailCP cp)))) (cons (headCP cp) (CPToList (tailCP (OCP cp))))
+++++
apply Permutation.Permutation_sym in H.
-----
Lemma CPLOCPTlOK {n : nat} : forall (cp : cartesianPower positive (S (S (S n)))), headCP cp = headCP (OCP cp) -> CPToList (OCP (tailCP cp)) = CPToList (tailCP (OCP cp)).
Proof.
intros cp Hhd.
apply PermSorted.
assert (H := OCPPerm cp).
rewrite CPToListOK in H.
apply Permutation.Permutation_sym in H.
rewrite CPToListOK in H.
rewrite <- Hhd in H.
apply Permutation.Permutation_app_inv_l with ((headCP cp) :: nil).
assert (H' : (headCP cp :: nil) ++ CPToList (OCP (tailCP cp)) = headCP cp :: (CPToList (OCP (tailCP cp)))) by (simpl; reflexivity); rewrite H'; clear H'.
assert (H' : (headCP cp :: nil) ++ CPToList (tailCP (OCP cp)) = headCP cp :: (CPToList (tailCP (OCP cp)))) by (simpl; reflexivity); rewrite H'; clear H'.
apply Permutation.Permutation_sym in H.

*****
H : Permutation.Permutation (cons (headCP cp) (CPToList (tailCP cp)))\n (cons (headCP cp) (CPToList (tailCP (OCP cp))))
Hhd : eq (headCP cp) (headCP (OCP cp))
cp : cartesianPower positive (S (S (S n)))
n : nat
*****
Permutation.Permutation (cons (headCP cp) (CPToList (OCP (tailCP cp)))) (cons (headCP cp) (CPToList (tailCP (OCP cp))))
+++++
apply Permutation.perm_trans with (headCP cp :: CPToList (tailCP cp)); try assumption; clear H.
-----
Lemma CPLOCPTlOK {n : nat} : forall (cp : cartesianPower positive (S (S (S n)))), headCP cp = headCP (OCP cp) -> CPToList (OCP (tailCP cp)) = CPToList (tailCP (OCP cp)).
Proof.
intros cp Hhd.
apply PermSorted.
assert (H := OCPPerm cp).
rewrite CPToListOK in H.
apply Permutation.Permutation_sym in H.
rewrite CPToListOK in H.
rewrite <- Hhd in H.
apply Permutation.Permutation_app_inv_l with ((headCP cp) :: nil).
assert (H' : (headCP cp :: nil) ++ CPToList (OCP (tailCP cp)) = headCP cp :: (CPToList (OCP (tailCP cp)))) by (simpl; reflexivity); rewrite H'; clear H'.
assert (H' : (headCP cp :: nil) ++ CPToList (tailCP (OCP cp)) = headCP cp :: (CPToList (tailCP (OCP cp)))) by (simpl; reflexivity); rewrite H'; clear H'.
apply Permutation.Permutation_sym in H.
apply Permutation.perm_trans with (headCP cp :: CPToList (tailCP cp)); try assumption; clear H.

*****
Hhd : eq (headCP cp) (headCP (OCP cp))
cp : cartesianPower positive (S (S (S n)))
n : nat
*****
Permutation.Permutation (cons (headCP cp) (CPToList (OCP (tailCP cp)))) (cons (headCP cp) (CPToList (tailCP cp)))
+++++
assert (H := OCPPerm (tailCP cp)).
-----
Lemma CPLOCPTlOK {n : nat} : forall (cp : cartesianPower positive (S (S (S n)))), headCP cp = headCP (OCP cp) -> CPToList (OCP (tailCP cp)) = CPToList (tailCP (OCP cp)).
Proof.
intros cp Hhd.
apply PermSorted.
assert (H := OCPPerm cp).
rewrite CPToListOK in H.
apply Permutation.Permutation_sym in H.
rewrite CPToListOK in H.
rewrite <- Hhd in H.
apply Permutation.Permutation_app_inv_l with ((headCP cp) :: nil).
assert (H' : (headCP cp :: nil) ++ CPToList (OCP (tailCP cp)) = headCP cp :: (CPToList (OCP (tailCP cp)))) by (simpl; reflexivity); rewrite H'; clear H'.
assert (H' : (headCP cp :: nil) ++ CPToList (tailCP (OCP cp)) = headCP cp :: (CPToList (tailCP (OCP cp)))) by (simpl; reflexivity); rewrite H'; clear H'.
apply Permutation.Permutation_sym in H.
apply Permutation.perm_trans with (headCP cp :: CPToList (tailCP cp)); try assumption; clear H.
assert (H := OCPPerm (tailCP cp)).

*****
H : Permutation.Permutation (CPToList (tailCP cp))\n (CPToList (OCP (tailCP cp)))
Hhd : eq (headCP cp) (headCP (OCP cp))
cp : cartesianPower positive (S (S (S n)))
n : nat
*****
Permutation.Permutation (cons (headCP cp) (CPToList (OCP (tailCP cp)))) (cons (headCP cp) (CPToList (tailCP cp)))
+++++
apply Permutation.Permutation_sym in H.
-----
Lemma CPLOCPTlOK {n : nat} : forall (cp : cartesianPower positive (S (S (S n)))), headCP cp = headCP (OCP cp) -> CPToList (OCP (tailCP cp)) = CPToList (tailCP (OCP cp)).
Proof.
intros cp Hhd.
apply PermSorted.
assert (H := OCPPerm cp).
rewrite CPToListOK in H.
apply Permutation.Permutation_sym in H.
rewrite CPToListOK in H.
rewrite <- Hhd in H.
apply Permutation.Permutation_app_inv_l with ((headCP cp) :: nil).
assert (H' : (headCP cp :: nil) ++ CPToList (OCP (tailCP cp)) = headCP cp :: (CPToList (OCP (tailCP cp)))) by (simpl; reflexivity); rewrite H'; clear H'.
assert (H' : (headCP cp :: nil) ++ CPToList (tailCP (OCP cp)) = headCP cp :: (CPToList (tailCP (OCP cp)))) by (simpl; reflexivity); rewrite H'; clear H'.
apply Permutation.Permutation_sym in H.
apply Permutation.perm_trans with (headCP cp :: CPToList (tailCP cp)); try assumption; clear H.
assert (H := OCPPerm (tailCP cp)).
apply Permutation.Permutation_sym in H.

*****
H : Permutation.Permutation (CPToList (OCP (tailCP cp)))\n (CPToList (tailCP cp))
Hhd : eq (headCP cp) (headCP (OCP cp))
cp : cartesianPower positive (S (S (S n)))
n : nat
*****
Permutation.Permutation (cons (headCP cp) (CPToList (OCP (tailCP cp)))) (cons (headCP cp) (CPToList (tailCP cp)))
+++++
apply Permutation.perm_skip.
-----
Lemma CPLOCPTlOK {n : nat} : forall (cp : cartesianPower positive (S (S (S n)))), headCP cp = headCP (OCP cp) -> CPToList (OCP (tailCP cp)) = CPToList (tailCP (OCP cp)).
Proof.
intros cp Hhd.
apply PermSorted.
assert (H := OCPPerm cp).
rewrite CPToListOK in H.
apply Permutation.Permutation_sym in H.
rewrite CPToListOK in H.
rewrite <- Hhd in H.
apply Permutation.Permutation_app_inv_l with ((headCP cp) :: nil).
assert (H' : (headCP cp :: nil) ++ CPToList (OCP (tailCP cp)) = headCP cp :: (CPToList (OCP (tailCP cp)))) by (simpl; reflexivity); rewrite H'; clear H'.
assert (H' : (headCP cp :: nil) ++ CPToList (tailCP (OCP cp)) = headCP cp :: (CPToList (tailCP (OCP cp)))) by (simpl; reflexivity); rewrite H'; clear H'.
apply Permutation.Permutation_sym in H.
apply Permutation.perm_trans with (headCP cp :: CPToList (tailCP cp)); try assumption; clear H.
assert (H := OCPPerm (tailCP cp)).
apply Permutation.Permutation_sym in H.
apply Permutation.perm_skip.

*****
H : Permutation.Permutation (CPToList (OCP (tailCP cp)))\n (CPToList (tailCP cp))
Hhd : eq (headCP cp) (headCP (OCP cp))
cp : cartesianPower positive (S (S (S n)))
n : nat
*****
Permutation.Permutation (CPToList (OCP (tailCP cp))) (CPToList (tailCP cp))
+++++
assumption.
-----
Lemma CPLOCPTlOK {n : nat} : forall (cp : cartesianPower positive (S (S (S n)))), headCP cp = headCP (OCP cp) -> CPToList (OCP (tailCP cp)) = CPToList (tailCP (OCP cp)).
Proof.
intros cp Hhd.
apply PermSorted.
assert (H := OCPPerm cp).
rewrite CPToListOK in H.
apply Permutation.Permutation_sym in H.
rewrite CPToListOK in H.
rewrite <- Hhd in H.
apply Permutation.Permutation_app_inv_l with ((headCP cp) :: nil).
assert (H' : (headCP cp :: nil) ++ CPToList (OCP (tailCP cp)) = headCP cp :: (CPToList (OCP (tailCP cp)))) by (simpl; reflexivity); rewrite H'; clear H'.
assert (H' : (headCP cp :: nil) ++ CPToList (tailCP (OCP cp)) = headCP cp :: (CPToList (tailCP (OCP cp)))) by (simpl; reflexivity); rewrite H'; clear H'.
apply Permutation.Permutation_sym in H.
apply Permutation.perm_trans with (headCP cp :: CPToList (tailCP cp)); try assumption; clear H.
assert (H := OCPPerm (tailCP cp)).
apply Permutation.Permutation_sym in H.
apply Permutation.perm_skip.
assumption.

*****
Hhd : eq (headCP cp) (headCP (OCP cp))
cp : cartesianPower positive (S (S (S n)))
n : nat
*****
StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) (CPToList (OCP (tailCP cp)))
+++++
apply OCPSortedAux.
-----
Lemma CPLOCPTlOK {n : nat} : forall (cp : cartesianPower positive (S (S (S n)))), headCP cp = headCP (OCP cp) -> CPToList (OCP (tailCP cp)) = CPToList (tailCP (OCP cp)).
Proof.
intros cp Hhd.
apply PermSorted.
assert (H := OCPPerm cp).
rewrite CPToListOK in H.
apply Permutation.Permutation_sym in H.
rewrite CPToListOK in H.
rewrite <- Hhd in H.
apply Permutation.Permutation_app_inv_l with ((headCP cp) :: nil).
assert (H' : (headCP cp :: nil) ++ CPToList (OCP (tailCP cp)) = headCP cp :: (CPToList (OCP (tailCP cp)))) by (simpl; reflexivity); rewrite H'; clear H'.
assert (H' : (headCP cp :: nil) ++ CPToList (tailCP (OCP cp)) = headCP cp :: (CPToList (tailCP (OCP cp)))) by (simpl; reflexivity); rewrite H'; clear H'.
apply Permutation.Permutation_sym in H.
apply Permutation.perm_trans with (headCP cp :: CPToList (tailCP cp)); try assumption; clear H.
assert (H := OCPPerm (tailCP cp)).
apply Permutation.Permutation_sym in H.
apply Permutation.perm_skip.
assumption.
apply OCPSortedAux.

*****
Hhd : eq (headCP cp) (headCP (OCP cp))
cp : cartesianPower positive (S (S (S n)))
n : nat
*****
StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) (CPToList (tailCP (OCP cp)))
+++++
rewrite <- CPToListTl2.
-----
Lemma CPLOCPTlOK {n : nat} : forall (cp : cartesianPower positive (S (S (S n)))), headCP cp = headCP (OCP cp) -> CPToList (OCP (tailCP cp)) = CPToList (tailCP (OCP cp)).
Proof.
intros cp Hhd.
apply PermSorted.
assert (H := OCPPerm cp).
rewrite CPToListOK in H.
apply Permutation.Permutation_sym in H.
rewrite CPToListOK in H.
rewrite <- Hhd in H.
apply Permutation.Permutation_app_inv_l with ((headCP cp) :: nil).
assert (H' : (headCP cp :: nil) ++ CPToList (OCP (tailCP cp)) = headCP cp :: (CPToList (OCP (tailCP cp)))) by (simpl; reflexivity); rewrite H'; clear H'.
assert (H' : (headCP cp :: nil) ++ CPToList (tailCP (OCP cp)) = headCP cp :: (CPToList (tailCP (OCP cp)))) by (simpl; reflexivity); rewrite H'; clear H'.
apply Permutation.Permutation_sym in H.
apply Permutation.perm_trans with (headCP cp :: CPToList (tailCP cp)); try assumption; clear H.
assert (H := OCPPerm (tailCP cp)).
apply Permutation.Permutation_sym in H.
apply Permutation.perm_skip.
assumption.
apply OCPSortedAux.
rewrite <- CPToListTl2.

*****
Hhd : eq (headCP cp) (headCP (OCP cp))
cp : cartesianPower positive (S (S (S n)))
n : nat
*****
StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) (tl (CPToList (OCP cp)))
+++++
apply OCPSortedTl.
-----
Lemma CPLOCPTlOK {n : nat} : forall (cp : cartesianPower positive (S (S (S n)))), headCP cp = headCP (OCP cp) -> CPToList (OCP (tailCP cp)) = CPToList (tailCP (OCP cp)).
Proof.
intros cp Hhd.
apply PermSorted.
assert (H := OCPPerm cp).
rewrite CPToListOK in H.
apply Permutation.Permutation_sym in H.
rewrite CPToListOK in H.
rewrite <- Hhd in H.
apply Permutation.Permutation_app_inv_l with ((headCP cp) :: nil).
assert (H' : (headCP cp :: nil) ++ CPToList (OCP (tailCP cp)) = headCP cp :: (CPToList (OCP (tailCP cp)))) by (simpl; reflexivity); rewrite H'; clear H'.
assert (H' : (headCP cp :: nil) ++ CPToList (tailCP (OCP cp)) = headCP cp :: (CPToList (tailCP (OCP cp)))) by (simpl; reflexivity); rewrite H'; clear H'.
apply Permutation.Permutation_sym in H.
apply Permutation.perm_trans with (headCP cp :: CPToList (tailCP cp)); try assumption; clear H.
assert (H := OCPPerm (tailCP cp)).
apply Permutation.Permutation_sym in H.
apply Permutation.perm_skip.
assumption.
apply OCPSortedAux.
rewrite <- CPToListTl2.
apply OCPSortedTl.

*****
Hhd : eq (headCP cp) (headCP (OCP cp))
cp : cartesianPower positive (S (S (S n)))
n : nat
*****
StronglySorted (fun x x0 : positive => is_true (Pos.leb x x0)) (CPToList (OCP cp))
+++++
apply OCPSortedAux.
-----
Lemma CPLOCPTlOK {n : nat} : forall (cp : cartesianPower positive (S (S (S n)))), headCP cp = headCP (OCP cp) -> CPToList (OCP (tailCP cp)) = CPToList (tailCP (OCP cp)).
Proof.
intros cp Hhd.
apply PermSorted.
assert (H := OCPPerm cp).
rewrite CPToListOK in H.
apply Permutation.Permutation_sym in H.
rewrite CPToListOK in H.
rewrite <- Hhd in H.
apply Permutation.Permutation_app_inv_l with ((headCP cp) :: nil).
assert (H' : (headCP cp :: nil) ++ CPToList (OCP (tailCP cp)) = headCP cp :: (CPToList (OCP (tailCP cp)))) by (simpl; reflexivity); rewrite H'; clear H'.
assert (H' : (headCP cp :: nil) ++ CPToList (tailCP (OCP cp)) = headCP cp :: (CPToList (tailCP (OCP cp)))) by (simpl; reflexivity); rewrite H'; clear H'.
apply Permutation.Permutation_sym in H.
apply Permutation.perm_trans with (headCP cp :: CPToList (tailCP cp)); try assumption; clear H.
assert (H := OCPPerm (tailCP cp)).
apply Permutation.Permutation_sym in H.
apply Permutation.perm_skip.
assumption.
apply OCPSortedAux.
rewrite <- CPToListTl2.
apply OCPSortedTl.
apply OCPSortedAux.

*****

*****

+++++
Qed.
-----
Lemma OCPTlOK {n : nat} :\n  forall (cp : cartesianPower positive (S (S (S n)))),\n  headCP cp = headCP (OCP cp) ->\n  OCP (tailCP cp) = tailCP (OCP cp).
-----
Lemma OCPTlOK {n : nat} : forall (cp : cartesianPower positive (S (S (S n)))), headCP cp = headCP (OCP cp) -> OCP (tailCP cp) = tailCP (OCP cp).

*****
n : nat
*****
forall (cp : cartesianPower positive (S (S (S n)))) (_ : eq (headCP cp) (headCP (OCP cp))), eq (OCP (tailCP cp)) (tailCP (OCP cp))
+++++
Proof.
-----
Lemma OCPTlOK {n : nat} : forall (cp : cartesianPower positive (S (S (S n)))), headCP cp = headCP (OCP cp) -> OCP (tailCP cp) = tailCP (OCP cp).
Proof.

*****
n : nat
*****
forall (cp : cartesianPower positive (S (S (S n)))) (_ : eq (headCP cp) (headCP (OCP cp))), eq (OCP (tailCP cp)) (tailCP (OCP cp))
+++++
intros cp Hhd.
-----
Lemma OCPTlOK {n : nat} : forall (cp : cartesianPower positive (S (S (S n)))), headCP cp = headCP (OCP cp) -> OCP (tailCP cp) = tailCP (OCP cp).
Proof.
intros cp Hhd.

*****
Hhd : eq (headCP cp) (headCP (OCP cp))
cp : cartesianPower positive (S (S (S n)))
n : nat
*****
eq (OCP (tailCP cp)) (tailCP (OCP cp))
+++++
apply CPLOCPTlOK in Hhd.
-----
Lemma OCPTlOK {n : nat} : forall (cp : cartesianPower positive (S (S (S n)))), headCP cp = headCP (OCP cp) -> OCP (tailCP cp) = tailCP (OCP cp).
Proof.
intros cp Hhd.
apply CPLOCPTlOK in Hhd.

*****
Hhd : eq (CPToList (OCP (tailCP cp))) (CPToList (tailCP (OCP cp)))
cp : cartesianPower positive (S (S (S n)))
n : nat
*****
eq (OCP (tailCP cp)) (tailCP (OCP cp))
+++++
apply CPLCP.
-----
Lemma OCPTlOK {n : nat} : forall (cp : cartesianPower positive (S (S (S n)))), headCP cp = headCP (OCP cp) -> OCP (tailCP cp) = tailCP (OCP cp).
Proof.
intros cp Hhd.
apply CPLOCPTlOK in Hhd.
apply CPLCP.

*****
Hhd : eq (CPToList (OCP (tailCP cp))) (CPToList (tailCP (OCP cp)))
cp : cartesianPower positive (S (S (S n)))
n : nat
*****
eq (CPToList (OCP (tailCP cp))) (CPToList (tailCP (OCP cp)))
+++++
assumption.
-----
Lemma OCPTlOK {n : nat} : forall (cp : cartesianPower positive (S (S (S n)))), headCP cp = headCP (OCP cp) -> OCP (tailCP cp) = tailCP (OCP cp).
Proof.
intros cp Hhd.
apply CPLOCPTlOK in Hhd.
apply CPLCP.
assumption.

*****

*****

+++++
Qed.
-----
Lemma InCPOCP {n : nat} : forall p (cp : cartesianPower positive (S (S n))),\n  InCP p cp <-> InCP p (OCP cp).
-----
Lemma InCPOCP {n : nat} : forall p (cp : cartesianPower positive (S (S n))), InCP p cp <-> InCP p (OCP cp).

*****
n : nat
*****
forall (p : positive) (cp : cartesianPower positive (S (S n))), iff (InCP p cp) (InCP p (OCP cp))
+++++
Proof.
-----
Lemma InCPOCP {n : nat} : forall p (cp : cartesianPower positive (S (S n))), InCP p cp <-> InCP p (OCP cp).
Proof.

*****
n : nat
*****
forall (p : positive) (cp : cartesianPower positive (S (S n))), iff (InCP p cp) (InCP p (OCP cp))
+++++
intros p cp.
-----
Lemma InCPOCP {n : nat} : forall p (cp : cartesianPower positive (S (S n))), InCP p cp <-> InCP p (OCP cp).
Proof.
intros p cp.

*****
cp : cartesianPower positive (S (S n))
p : positive
n : nat
*****
iff (InCP p cp) (InCP p (OCP cp))
+++++
unfold OCP.
-----
Lemma InCPOCP {n : nat} : forall p (cp : cartesianPower positive (S (S n))), InCP p cp <-> InCP p (OCP cp).
Proof.
intros p cp.
unfold OCP.

*****
cp : cartesianPower positive (S (S n))
p : positive
n : nat
*****
iff (InCP p cp) (InCP p (eq_rect (length (OCPAux cp)) (fun n : nat => cartesianPower positive n) (ListToCP (OCPAux cp) (fst cp)) (S (S n)) (OCPALengthOK cp)))
+++++
unfold OCPAux.
-----
Lemma InCPOCP {n : nat} : forall p (cp : cartesianPower positive (S (S n))), InCP p cp <-> InCP p (OCP cp).
Proof.
intros p cp.
unfold OCP.
unfold OCPAux.

*****
cp : cartesianPower positive (S (S n))
p : positive
n : nat
*****
iff (InCP p cp) (InCP p (eq_rect (length (sort (CPToList cp))) (fun n : nat => cartesianPower positive n) (ListToCP (sort (CPToList cp)) (fst cp)) (S (S n)) (OCPALengthOK cp)))
+++++
unfold InCP.
-----
Lemma InCPOCP {n : nat} : forall p (cp : cartesianPower positive (S (S n))), InCP p cp <-> InCP p (OCP cp).
Proof.
intros p cp.
unfold OCP.
unfold OCPAux.
unfold InCP.

*****
cp : cartesianPower positive (S (S n))
p : positive
n : nat
*****
iff (In p (CPToList cp)) (In p (CPToList (eq_rect (length (sort (CPToList cp))) (fun n : nat => cartesianPower positive n) (ListToCP (sort (CPToList cp)) (fst cp)) (S (S n)) (OCPALengthOK cp))))
+++++
elim_eq_rect.
-----
Lemma InCPOCP {n : nat} : forall p (cp : cartesianPower positive (S (S n))), InCP p cp <-> InCP p (OCP cp).
Proof.
intros p cp.
unfold OCP.
unfold OCPAux.
unfold InCP.
elim_eq_rect.

*****
cp : cartesianPower positive (S (S n))
p : positive
n : nat
*****
iff (In p (CPToList cp)) (In p (CPToList (eq_rect (length (sort (CPToList cp))) (fun n : nat => cartesianPower positive n) (ListToCP (sort (CPToList cp)) (fst cp)) (length (OCPAux cp)) eq_refl)))
+++++
simpl.
-----
Lemma InCPOCP {n : nat} : forall p (cp : cartesianPower positive (S (S n))), InCP p cp <-> InCP p (OCP cp).
Proof.
intros p cp.
unfold OCP.
unfold OCPAux.
unfold InCP.
elim_eq_rect.
simpl.

*****
cp : cartesianPower positive (S (S n))
p : positive
n : nat
*****
iff (or (eq (fst cp) p) (In p (nat_rect (fun n : nat => forall _ : cartesianPower positive (S n), list positive) (fun cp : cartesianPower positive (S O) => cons cp nil) (fun (n : nat) (IHn : forall _ : cartesianPower positive (S n), list positive) (cp : cartesianPower positive (S (S n))) => cons (fst cp) (IHn (tailCP cp))) n (tailCP cp)))) (In p (CPToList (ListToCP (sort (cons (fst cp) (nat_rect (fun n : nat => forall _ : cartesianPower positive (S n), list positive) (fun cp : cartesianPower positive (S O) => cons cp nil) (fun (n : nat) (IHn : forall _ : cartesianPower positive (S n), list positive) (cp : cartesianPower positive (S (S n))) => cons (fst cp) (IHn (tailCP cp))) n (tailCP cp)))) (fst cp))))
+++++
induction n.
-----
Lemma InCPOCP {n : nat} : forall p (cp : cartesianPower positive (S (S n))), InCP p cp <-> InCP p (OCP cp).
Proof.
intros p cp.
unfold OCP.
unfold OCPAux.
unfold InCP.
elim_eq_rect.
simpl.
induction n.

*****
cp : cartesianPower positive (S (S O))
p : positive
*****
iff (or (eq (fst cp) p) (In p (nat_rect (fun n : nat => forall _ : cartesianPower positive (S n), list positive) (fun cp : cartesianPower positive (S O) => cons cp nil) (fun (n : nat) (IHn : forall _ : cartesianPower positive (S n), list positive) (cp : cartesianPower positive (S (S n))) => cons (fst cp) (IHn (tailCP cp))) O (tailCP cp)))) (In p (CPToList (ListToCP (sort (cons (fst cp) (nat_rect (fun n : nat => forall _ : cartesianPower positive (S n), list positive) (fun cp : cartesianPower positive (S O) => cons cp nil) (fun (n : nat) (IHn : forall _ : cartesianPower positive (S n), list positive) (cp : cartesianPower positive (S (S n))) => cons (fst cp) (IHn (tailCP cp))) O (tailCP cp)))) (fst cp))))
+++++
rewrite CPLOK.
-----
Lemma InCPOCP {n : nat} : forall p (cp : cartesianPower positive (S (S n))), InCP p cp <-> InCP p (OCP cp).
Proof.
intros p cp.
unfold OCP.
unfold OCPAux.
unfold InCP.
elim_eq_rect.
simpl.
induction n.
rewrite CPLOK.

*****
cp : cartesianPower positive (S (S O))
p : positive
*****
iff (or (eq (fst cp) p) (In p (nat_rect (fun n : nat => forall _ : cartesianPower positive (S n), list positive) (fun cp : cartesianPower positive (S O) => cons cp nil) (fun (n : nat) (IHn : forall _ : cartesianPower positive (S n), list positive) (cp : cartesianPower positive (S (S n))) => cons (fst cp) (IHn (tailCP cp))) O (tailCP cp)))) (In p (sort (cons (fst cp) (nat_rect (fun n : nat => forall _ : cartesianPower positive (S n), list positive) (fun cp : cartesianPower positive (S O) => cons cp nil) (fun (n : nat) (IHn : forall _ : cartesianPower positive (S n), list positive) (cp : cartesianPower positive (S (S n))) => cons (fst cp) (IHn (tailCP cp))) O (tailCP cp)))))
+++++
assert (HPerm1 := Permuted_sort (CPToList cp)).
-----
Lemma InCPOCP {n : nat} : forall p (cp : cartesianPower positive (S (S n))), InCP p cp <-> InCP p (OCP cp).
Proof.
intros p cp.
unfold OCP.
unfold OCPAux.
unfold InCP.
elim_eq_rect.
simpl.
induction n.
rewrite CPLOK.
assert (HPerm1 := Permuted_sort (CPToList cp)).

*****
HPerm1 : Permutation.Permutation (CPToList cp) (sort (CPToList cp))
cp : cartesianPower positive (S (S O))
p : positive
*****
iff (or (eq (fst cp) p) (In p (nat_rect (fun n : nat => forall _ : cartesianPower positive (S n), list positive) (fun cp : cartesianPower positive (S O) => cons cp nil) (fun (n : nat) (IHn : forall _ : cartesianPower positive (S n), list positive) (cp : cartesianPower positive (S (S n))) => cons (fst cp) (IHn (tailCP cp))) O (tailCP cp)))) (In p (sort (cons (fst cp) (nat_rect (fun n : nat => forall _ : cartesianPower positive (S n), list positive) (fun cp : cartesianPower positive (S O) => cons cp nil) (fun (n : nat) (IHn : forall _ : cartesianPower positive (S n), list positive) (cp : cartesianPower positive (S (S n))) => cons (fst cp) (IHn (tailCP cp))) O (tailCP cp)))))
+++++
simpl in HPerm1.
-----
Lemma InCPOCP {n : nat} : forall p (cp : cartesianPower positive (S (S n))), InCP p cp <-> InCP p (OCP cp).
Proof.
intros p cp.
unfold OCP.
unfold OCPAux.
unfold InCP.
elim_eq_rect.
simpl.
induction n.
rewrite CPLOK.
assert (HPerm1 := Permuted_sort (CPToList cp)).
simpl in HPerm1.

*****
HPerm1 : Permutation.Permutation (cons (fst cp) (cons (snd cp) nil))\n (sort (cons (fst cp) (cons (snd cp) nil)))
cp : cartesianPower positive (S (S O))
p : positive
*****
iff (or (eq (fst cp) p) (In p (nat_rect (fun n : nat => forall _ : cartesianPower positive (S n), list positive) (fun cp : cartesianPower positive (S O) => cons cp nil) (fun (n : nat) (IHn : forall _ : cartesianPower positive (S n), list positive) (cp : cartesianPower positive (S (S n))) => cons (fst cp) (IHn (tailCP cp))) O (tailCP cp)))) (In p (sort (cons (fst cp) (nat_rect (fun n : nat => forall _ : cartesianPower positive (S n), list positive) (fun cp : cartesianPower positive (S O) => cons cp nil) (fun (n : nat) (IHn : forall _ : cartesianPower positive (S n), list positive) (cp : cartesianPower positive (S (S n))) => cons (fst cp) (IHn (tailCP cp))) O (tailCP cp)))))
+++++
assert (HPerm2 := HPerm1).
-----
Lemma InCPOCP {n : nat} : forall p (cp : cartesianPower positive (S (S n))), InCP p cp <-> InCP p (OCP cp).
Proof.
intros p cp.
unfold OCP.
unfold OCPAux.
unfold InCP.
elim_eq_rect.
simpl.
induction n.
rewrite CPLOK.
assert (HPerm1 := Permuted_sort (CPToList cp)).
simpl in HPerm1.
assert (HPerm2 := HPerm1).

*****
HPerm1,HPerm2 : Permutation.Permutation (cons (fst cp) (cons (snd cp) nil))\n (sort (cons (fst cp) (cons (snd cp) nil)))
cp : cartesianPower positive (S (S O))
p : positive
*****
iff (or (eq (fst cp) p) (In p (nat_rect (fun n : nat => forall _ : cartesianPower positive (S n), list positive) (fun cp : cartesianPower positive (S O) => cons cp nil) (fun (n : nat) (IHn : forall _ : cartesianPower positive (S n), list positive) (cp : cartesianPower positive (S (S n))) => cons (fst cp) (IHn (tailCP cp))) O (tailCP cp)))) (In p (sort (cons (fst cp) (nat_rect (fun n : nat => forall _ : cartesianPower positive (S n), list positive) (fun cp : cartesianPower positive (S O) => cons cp nil) (fun (n : nat) (IHn : forall _ : cartesianPower positive (S n), list positive) (cp : cartesianPower positive (S (S n))) => cons (fst cp) (IHn (tailCP cp))) O (tailCP cp)))))
+++++
apply Permutation.Permutation_sym in HPerm2.
-----
Lemma InCPOCP {n : nat} : forall p (cp : cartesianPower positive (S (S n))), InCP p cp <-> InCP p (OCP cp).
Proof.
intros p cp.
unfold OCP.
unfold OCPAux.
unfold InCP.
elim_eq_rect.
simpl.
induction n.
rewrite CPLOK.
assert (HPerm1 := Permuted_sort (CPToList cp)).
simpl in HPerm1.
assert (HPerm2 := HPerm1).
apply Permutation.Permutation_sym in HPerm2.

*****
HPerm2 : Permutation.Permutation (sort (cons (fst cp) (cons (snd cp) nil)))\n (cons (fst cp) (cons (snd cp) nil))
HPerm1 : Permutation.Permutation (cons (fst cp) (cons (snd cp) nil))\n (sort (cons (fst cp) (cons (snd cp) nil)))
cp : cartesianPower positive (S (S O))
p : positive
*****
iff (or (eq (fst cp) p) (In p (nat_rect (fun n : nat => forall _ : cartesianPower positive (S n), list positive) (fun cp : cartesianPower positive (S O) => cons cp nil) (fun (n : nat) (IHn : forall _ : cartesianPower positive (S n), list positive) (cp : cartesianPower positive (S (S n))) => cons (fst cp) (IHn (tailCP cp))) O (tailCP cp)))) (In p (sort (cons (fst cp) (nat_rect (fun n : nat => forall _ : cartesianPower positive (S n), list positive) (fun cp : cartesianPower positive (S O) => cons cp nil) (fun (n : nat) (IHn : forall _ : cartesianPower positive (S n), list positive) (cp : cartesianPower positive (S (S n))) => cons (fst cp) (IHn (tailCP cp))) O (tailCP cp)))))
+++++
assert (HInOK : In p (sort (fst cp :: snd cp :: nil)) <-> In p (fst cp :: snd cp :: nil)).
-----
Lemma InCPOCP {n : nat} : forall p (cp : cartesianPower positive (S (S n))), InCP p cp <-> InCP p (OCP cp).
Proof.
intros p cp.
unfold OCP.
unfold OCPAux.
unfold InCP.
elim_eq_rect.
simpl.
induction n.
rewrite CPLOK.
assert (HPerm1 := Permuted_sort (CPToList cp)).
simpl in HPerm1.
assert (HPerm2 := HPerm1).
apply Permutation.Permutation_sym in HPerm2.
assert (HInOK : In p (sort (fst cp :: snd cp :: nil)) <-> In p (fst cp :: snd cp :: nil)).

*****
HPerm2 : Permutation.Permutation (sort (cons (fst cp) (cons (snd cp) nil)))\n (cons (fst cp) (cons (snd cp) nil))
HPerm1 : Permutation.Permutation (cons (fst cp) (cons (snd cp) nil))\n (sort (cons (fst cp) (cons (snd cp) nil)))
cp : cartesianPower positive (S (S O))
p : positive
*****
iff (In p (sort (cons (fst cp) (cons (snd cp) nil)))) (In p (cons (fst cp) (cons (snd cp) nil)))
+++++
split.
-----
Lemma InCPOCP {n : nat} : forall p (cp : cartesianPower positive (S (S n))), InCP p cp <-> InCP p (OCP cp).
Proof.
intros p cp.
unfold OCP.
unfold OCPAux.
unfold InCP.
elim_eq_rect.
simpl.
induction n.
rewrite CPLOK.
assert (HPerm1 := Permuted_sort (CPToList cp)).
simpl in HPerm1.
assert (HPerm2 := HPerm1).
apply Permutation.Permutation_sym in HPerm2.
assert (HInOK : In p (sort (fst cp :: snd cp :: nil)) <-> In p (fst cp :: snd cp :: nil)).
split.

*****
HPerm2 : Permutation.Permutation (sort (cons (fst cp) (cons (snd cp) nil)))\n (cons (fst cp) (cons (snd cp) nil))
HPerm1 : Permutation.Permutation (cons (fst cp) (cons (snd cp) nil))\n (sort (cons (fst cp) (cons (snd cp) nil)))
cp : cartesianPower positive (S (S O))
p : positive
*****
forall _ : In p (sort (cons (fst cp) (cons (snd cp) nil))), In p (cons (fst cp) (cons (snd cp) nil))
+++++
intro HIn.
-----
Lemma InCPOCP {n : nat} : forall p (cp : cartesianPower positive (S (S n))), InCP p cp <-> InCP p (OCP cp).
Proof.
intros p cp.
unfold OCP.
unfold OCPAux.
unfold InCP.
elim_eq_rect.
simpl.
induction n.
rewrite CPLOK.
assert (HPerm1 := Permuted_sort (CPToList cp)).
simpl in HPerm1.
assert (HPerm2 := HPerm1).
apply Permutation.Permutation_sym in HPerm2.
assert (HInOK : In p (sort (fst cp :: snd cp :: nil)) <-> In p (fst cp :: snd cp :: nil)).
split.
intro HIn.

*****
HIn : In p (sort (cons (fst cp) (cons (snd cp) nil)))
HPerm2 : Permutation.Permutation (sort (cons (fst cp) (cons (snd cp) nil)))\n (cons (fst cp) (cons (snd cp) nil))
HPerm1 : Permutation.Permutation (cons (fst cp) (cons (snd cp) nil))\n (sort (cons (fst cp) (cons (snd cp) nil)))
cp : cartesianPower positive (S (S O))
p : positive
*****
In p (cons (fst cp) (cons (snd cp) nil))
+++++
try (apply Permutation.Permutation_in with (sort (fst cp :: snd cp :: nil)); assumption).
-----
Lemma InCPOCP {n : nat} : forall p (cp : cartesianPower positive (S (S n))), InCP p cp <-> InCP p (OCP cp).
Proof.
intros p cp.
unfold OCP.
unfold OCPAux.
unfold InCP.
elim_eq_rect.
simpl.
induction n.
rewrite CPLOK.
assert (HPerm1 := Permuted_sort (CPToList cp)).
simpl in HPerm1.
assert (HPerm2 := HPerm1).
apply Permutation.Permutation_sym in HPerm2.
assert (HInOK : In p (sort (fst cp :: snd cp :: nil)) <-> In p (fst cp :: snd cp :: nil)).
split.

*****
HPerm2 : Permutation.Permutation (sort (cons (fst cp) (cons (snd cp) nil)))\n (cons (fst cp) (cons (snd cp) nil))
HPerm1 : Permutation.Permutation (cons (fst cp) (cons (snd cp) nil))\n (sort (cons (fst cp) (cons (snd cp) nil)))
cp : cartesianPower positive (S (S O))
p : positive
*****
forall _ : In p (cons (fst cp) (cons (snd cp) nil)), In p (sort (cons (fst cp) (cons (snd cp) nil)))
+++++
intro HIn.
-----
Lemma InCPOCP {n : nat} : forall p (cp : cartesianPower positive (S (S n))), InCP p cp <-> InCP p (OCP cp).
Proof.
intros p cp.
unfold OCP.
unfold OCPAux.
unfold InCP.
elim_eq_rect.
simpl.
induction n.
rewrite CPLOK.
assert (HPerm1 := Permuted_sort (CPToList cp)).
simpl in HPerm1.
assert (HPerm2 := HPerm1).
apply Permutation.Permutation_sym in HPerm2.
assert (HInOK : In p (sort (fst cp :: snd cp :: nil)) <-> In p (fst cp :: snd cp :: nil)).
split.
intro HIn.

*****
HIn : In p (cons (fst cp) (cons (snd cp) nil))
HPerm2 : Permutation.Permutation (sort (cons (fst cp) (cons (snd cp) nil)))\n (cons (fst cp) (cons (snd cp) nil))
HPerm1 : Permutation.Permutation (cons (fst cp) (cons (snd cp) nil))\n (sort (cons (fst cp) (cons (snd cp) nil)))
cp : cartesianPower positive (S (S O))
p : positive
*****
In p (sort (cons (fst cp) (cons (snd cp) nil)))
+++++
try (apply Permutation.Permutation_in with (sort (fst cp :: snd cp :: nil)); assumption).
-----
Lemma InCPOCP {n : nat} : forall p (cp : cartesianPower positive (S (S n))), InCP p cp <-> InCP p (OCP cp).
Proof.
intros p cp.
unfold OCP.
unfold OCPAux.
unfold InCP.
elim_eq_rect.
simpl.
induction n.
rewrite CPLOK.
assert (HPerm1 := Permuted_sort (CPToList cp)).
simpl in HPerm1.
assert (HPerm2 := HPerm1).
apply Permutation.Permutation_sym in HPerm2.
assert (HInOK : In p (sort (fst cp :: snd cp :: nil)) <-> In p (fst cp :: snd cp :: nil)).
split.
intro HIn.
try (apply Permutation.Permutation_in with (sort (fst cp :: snd cp :: nil)); assumption).

*****
HIn : In p (cons (fst cp) (cons (snd cp) nil))
HPerm2 : Permutation.Permutation (sort (cons (fst cp) (cons (snd cp) nil)))\n (cons (fst cp) (cons (snd cp) nil))
HPerm1 : Permutation.Permutation (cons (fst cp) (cons (snd cp) nil))\n (sort (cons (fst cp) (cons (snd cp) nil)))
cp : cartesianPower positive (S (S O))
p : positive
*****
In p (sort (cons (fst cp) (cons (snd cp) nil)))
+++++
apply Permutation.Permutation_in with (fst cp :: snd cp :: nil).
-----
Lemma InCPOCP {n : nat} : forall p (cp : cartesianPower positive (S (S n))), InCP p cp <-> InCP p (OCP cp).
Proof.
intros p cp.
unfold OCP.
unfold OCPAux.
unfold InCP.
elim_eq_rect.
simpl.
induction n.
rewrite CPLOK.
assert (HPerm1 := Permuted_sort (CPToList cp)).
simpl in HPerm1.
assert (HPerm2 := HPerm1).
apply Permutation.Permutation_sym in HPerm2.
assert (HInOK : In p (sort (fst cp :: snd cp :: nil)) <-> In p (fst cp :: snd cp :: nil)).
split.
intro HIn.
try (apply Permutation.Permutation_in with (sort (fst cp :: snd cp :: nil)); assumption).
apply Permutation.Permutation_in with (fst cp :: snd cp :: nil).

*****
HIn : In p (cons (fst cp) (cons (snd cp) nil))
HPerm2 : Permutation.Permutation (sort (cons (fst cp) (cons (snd cp) nil)))\n (cons (fst cp) (cons (snd cp) nil))
HPerm1 : Permutation.Permutation (cons (fst cp) (cons (snd cp) nil))\n (sort (cons (fst cp) (cons (snd cp) nil)))
cp : cartesianPower positive (S (S O))
p : positive
*****
Permutation.Permutation (cons (fst cp) (cons (snd cp) nil)) (sort (cons (fst cp) (cons (snd cp) nil)))
+++++
assumption...
-----
Lemma InCPOCP {n : nat} : forall p (cp : cartesianPower positive (S (S n))), InCP p cp <-> InCP p (OCP cp).
Proof.
intros p cp.
unfold OCP.
unfold OCPAux.
unfold InCP.
elim_eq_rect.
simpl.
induction n.
rewrite CPLOK.
assert (HPerm1 := Permuted_sort (CPToList cp)).
simpl in HPerm1.
assert (HPerm2 := HPerm1).
apply Permutation.Permutation_sym in HPerm2.
assert (HInOK : In p (sort (fst cp :: snd cp :: nil)) <-> In p (fst cp :: snd cp :: nil)).
split.
intro HIn.
try (apply Permutation.Permutation_in with (sort (fst cp :: snd cp :: nil)); assumption).
apply Permutation.Permutation_in with (fst cp :: snd cp :: nil).

*****
HIn : In p (cons (fst cp) (cons (snd cp) nil))
HPerm2 : Permutation.Permutation (sort (cons (fst cp) (cons (snd cp) nil)))\n (cons (fst cp) (cons (snd cp) nil))
HPerm1 : Permutation.Permutation (cons (fst cp) (cons (snd cp) nil))\n (sort (cons (fst cp) (cons (snd cp) nil)))
cp : cartesianPower positive (S (S O))
p : positive
*****
In p (cons (fst cp) (cons (snd cp) nil))
+++++
assumption...
-----
Lemma InCPOCP {n : nat} : forall p (cp : cartesianPower positive (S (S n))), InCP p cp <-> InCP p (OCP cp).
Proof.
intros p cp.
unfold OCP.
unfold OCPAux.
unfold InCP.
elim_eq_rect.
simpl.
induction n.
rewrite CPLOK.
assert (HPerm1 := Permuted_sort (CPToList cp)).
simpl in HPerm1.
assert (HPerm2 := HPerm1).
apply Permutation.Permutation_sym in HPerm2.
assert (HInOK : In p (sort (fst cp :: snd cp :: nil)) <-> In p (fst cp :: snd cp :: nil)).

*****
HInOK : iff (In p (sort (cons (fst cp) (cons (snd cp) nil))))\n (In p (cons (fst cp) (cons (snd cp) nil)))
HPerm2 : Permutation.Permutation (sort (cons (fst cp) (cons (snd cp) nil)))\n (cons (fst cp) (cons (snd cp) nil))
HPerm1 : Permutation.Permutation (cons (fst cp) (cons (snd cp) nil))\n (sort (cons (fst cp) (cons (snd cp) nil)))
cp : cartesianPower positive (S (S O))
p : positive
*****
iff (or (eq (fst cp) p) (In p (nat_rect (fun n : nat => forall _ : cartesianPower positive (S n), list positive) (fun cp : cartesianPower positive (S O) => cons cp nil) (fun (n : nat) (IHn : forall _ : cartesianPower positive (S n), list positive) (cp : cartesianPower positive (S (S n))) => cons (fst cp) (IHn (tailCP cp))) O (tailCP cp)))) (In p (sort (cons (fst cp) (nat_rect (fun n : nat => forall _ : cartesianPower positive (S n), list positive) (fun cp : cartesianPower positive (S O) => cons cp nil) (fun (n : nat) (IHn : forall _ : cartesianPower positive (S n), list positive) (cp : cartesianPower positive (S (S n))) => cons (fst cp) (IHn (tailCP cp))) O (tailCP cp)))))
+++++
idtac.
-----
Lemma InCPOCP {n : nat} : forall p (cp : cartesianPower positive (S (S n))), InCP p cp <-> InCP p (OCP cp).
Proof.
intros p cp.
unfold OCP.
unfold OCPAux.
unfold InCP.
elim_eq_rect.
simpl.
induction n.
rewrite CPLOK.
assert (HPerm1 := Permuted_sort (CPToList cp)).
simpl in HPerm1.
assert (HPerm2 := HPerm1).
apply Permutation.Permutation_sym in HPerm2.
assert (HInOK : In p (sort (fst cp :: snd cp :: nil)) <-> In p (fst cp :: snd cp :: nil)).
idtac.

*****
HInOK : iff (In p (sort (cons (fst cp) (cons (snd cp) nil))))\n (In p (cons (fst cp) (cons (snd cp) nil)))
HPerm2 : Permutation.Permutation (sort (cons (fst cp) (cons (snd cp) nil)))\n (cons (fst cp) (cons (snd cp) nil))
HPerm1 : Permutation.Permutation (cons (fst cp) (cons (snd cp) nil))\n (sort (cons (fst cp) (cons (snd cp) nil)))
cp : cartesianPower positive (S (S O))
p : positive
*****
iff (or (eq (fst cp) p) (In p (nat_rect (fun n : nat => forall _ : cartesianPower positive (S n), list positive) (fun cp : cartesianPower positive (S O) => cons cp nil) (fun (n : nat) (IHn : forall _ : cartesianPower positive (S n), list positive) (cp : cartesianPower positive (S (S n))) => cons (fst cp) (IHn (tailCP cp))) O (tailCP cp)))) (In p (sort (cons (fst cp) (nat_rect (fun n : nat => forall _ : cartesianPower positive (S n), list positive) (fun cp : cartesianPower positive (S O) => cons cp nil) (fun (n : nat) (IHn : forall _ : cartesianPower positive (S n), list positive) (cp : cartesianPower positive (S (S n))) => cons (fst cp) (IHn (tailCP cp))) O (tailCP cp)))))
+++++
split.
-----
Lemma InCPOCP {n : nat} : forall p (cp : cartesianPower positive (S (S n))), InCP p cp <-> InCP p (OCP cp).
Proof.
intros p cp.
unfold OCP.
unfold OCPAux.
unfold InCP.
elim_eq_rect.
simpl.
induction n.
rewrite CPLOK.
assert (HPerm1 := Permuted_sort (CPToList cp)).
simpl in HPerm1.
assert (HPerm2 := HPerm1).
apply Permutation.Permutation_sym in HPerm2.
assert (HInOK : In p (sort (fst cp :: snd cp :: nil)) <-> In p (fst cp :: snd cp :: nil)).
idtac.
split.

*****
HInOK : iff (In p (sort (cons (fst cp) (cons (snd cp) nil))))\n (In p (cons (fst cp) (cons (snd cp) nil)))
HPerm2 : Permutation.Permutation (sort (cons (fst cp) (cons (snd cp) nil)))\n (cons (fst cp) (cons (snd cp) nil))
HPerm1 : Permutation.Permutation (cons (fst cp) (cons (snd cp) nil))\n (sort (cons (fst cp) (cons (snd cp) nil)))
cp : cartesianPower positive (S (S O))
p : positive
*****
forall _ : or (eq (fst cp) p) (In p (nat_rect (fun n : nat => forall _ : cartesianPower positive (S n), list positive) (fun cp : cartesianPower positive (S O) => cons cp nil) (fun (n : nat) (IHn : forall _ : cartesianPower positive (S n), list positive) (cp : cartesianPower positive (S (S n))) => cons (fst cp) (IHn (tailCP cp))) O (tailCP cp))), In p (sort (cons (fst cp) (nat_rect (fun n : nat => forall _ : cartesianPower positive (S n), list positive) (fun cp : cartesianPower positive (S O) => cons cp nil) (fun (n : nat) (IHn : forall _ : cartesianPower positive (S n), list positive) (cp : cartesianPower positive (S (S n))) => cons (fst cp) (IHn (tailCP cp))) O (tailCP cp))))
+++++
intro HIn.
-----
Lemma InCPOCP {n : nat} : forall p (cp : cartesianPower positive (S (S n))), InCP p cp <-> InCP p (OCP cp).
Proof.
intros p cp.
unfold OCP.
unfold OCPAux.
unfold InCP.
elim_eq_rect.
simpl.
induction n.
rewrite CPLOK.
assert (HPerm1 := Permuted_sort (CPToList cp)).
simpl in HPerm1.
assert (HPerm2 := HPerm1).
apply Permutation.Permutation_sym in HPerm2.
assert (HInOK : In p (sort (fst cp :: snd cp :: nil)) <-> In p (fst cp :: snd cp :: nil)).
idtac.
split.
intro HIn.

*****
HIn : or (eq (fst cp) p)\n (In p\n (nat_rect\n (fun n : nat =>\n forall _ : cartesianPower positive (S n), list positive)\n (fun cp : cartesianPower positive (S O) => cons cp nil)\n (fun (n : nat)\n (IHn : forall _ : cartesianPower positive (S n),\n list positive)\n (cp : cartesianPower positive (S (S n))) =>\n cons (fst cp) (IHn (tailCP cp))) O (tailCP cp)))
HInOK : iff (In p (sort (cons (fst cp) (cons (snd cp) nil))))\n (In p (cons (fst cp) (cons (snd cp) nil)))
HPerm2 : Permutation.Permutation (sort (cons (fst cp) (cons (snd cp) nil)))\n (cons (fst cp) (cons (snd cp) nil))
HPerm1 : Permutation.Permutation (cons (fst cp) (cons (snd cp) nil))\n (sort (cons (fst cp) (cons (snd cp) nil)))
cp : cartesianPower positive (S (S O))
p : positive
*****
In p (sort (cons (fst cp) (nat_rect (fun n : nat => forall _ : cartesianPower positive (S n), list positive) (fun cp : cartesianPower positive (S O) => cons cp nil) (fun (n : nat) (IHn : forall _ : cartesianPower positive (S n), list positive) (cp : cartesianPower positive (S (S n))) => cons (fst cp) (IHn (tailCP cp))) O (tailCP cp))))
+++++
apply HInOK.
-----
Lemma InCPOCP {n : nat} : forall p (cp : cartesianPower positive (S (S n))), InCP p cp <-> InCP p (OCP cp).
Proof.
intros p cp.
unfold OCP.
unfold OCPAux.
unfold InCP.
elim_eq_rect.
simpl.
induction n.
rewrite CPLOK.
assert (HPerm1 := Permuted_sort (CPToList cp)).
simpl in HPerm1.
assert (HPerm2 := HPerm1).
apply Permutation.Permutation_sym in HPerm2.
assert (HInOK : In p (sort (fst cp :: snd cp :: nil)) <-> In p (fst cp :: snd cp :: nil)).
idtac.
split.
intro HIn.
apply HInOK.

*****
HIn : or (eq (fst cp) p)\n (In p\n (nat_rect\n (fun n : nat =>\n forall _ : cartesianPower positive (S n), list positive)\n (fun cp : cartesianPower positive (S O) => cons cp nil)\n (fun (n : nat)\n (IHn : forall _ : cartesianPower positive (S n),\n list positive)\n (cp : cartesianPower positive (S (S n))) =>\n cons (fst cp) (IHn (tailCP cp))) O (tailCP cp)))
HInOK : iff (In p (sort (cons (fst cp) (cons (snd cp) nil))))\n (In p (cons (fst cp) (cons (snd cp) nil)))
HPerm2 : Permutation.Permutation (sort (cons (fst cp) (cons (snd cp) nil)))\n (cons (fst cp) (cons (snd cp) nil))
HPerm1 : Permutation.Permutation (cons (fst cp) (cons (snd cp) nil))\n (sort (cons (fst cp) (cons (snd cp) nil)))
cp : cartesianPower positive (S (S O))
p : positive
*****
In p (cons (fst cp) (cons (snd cp) nil))
+++++
simpl.
-----
Lemma InCPOCP {n : nat} : forall p (cp : cartesianPower positive (S (S n))), InCP p cp <-> InCP p (OCP cp).
Proof.
intros p cp.
unfold OCP.
unfold OCPAux.
unfold InCP.
elim_eq_rect.
simpl.
induction n.
rewrite CPLOK.
assert (HPerm1 := Permuted_sort (CPToList cp)).
simpl in HPerm1.
assert (HPerm2 := HPerm1).
apply Permutation.Permutation_sym in HPerm2.
assert (HInOK : In p (sort (fst cp :: snd cp :: nil)) <-> In p (fst cp :: snd cp :: nil)).
idtac.
split.
intro HIn.
apply HInOK.
simpl.

*****
HIn : or (eq (fst cp) p)\n (In p\n (nat_rect\n (fun n : nat =>\n forall _ : cartesianPower positive (S n), list positive)\n (fun cp : cartesianPower positive (S O) => cons cp nil)\n (fun (n : nat)\n (IHn : forall _ : cartesianPower positive (S n),\n list positive)\n (cp : cartesianPower positive (S (S n))) =>\n cons (fst cp) (IHn (tailCP cp))) O (tailCP cp)))
HInOK : iff (In p (sort (cons (fst cp) (cons (snd cp) nil))))\n (In p (cons (fst cp) (cons (snd cp) nil)))
HPerm2 : Permutation.Permutation (sort (cons (fst cp) (cons (snd cp) nil)))\n (cons (fst cp) (cons (snd cp) nil))
HPerm1 : Permutation.Permutation (cons (fst cp) (cons (snd cp) nil))\n (sort (cons (fst cp) (cons (snd cp) nil)))
cp : cartesianPower positive (S (S O))
p : positive
*****
or (eq (fst cp) p) (or (eq (snd cp) p) False)
+++++
assumption.
-----
Lemma InCPOCP {n : nat} : forall p (cp : cartesianPower positive (S (S n))), InCP p cp <-> InCP p (OCP cp).
Proof.
intros p cp.
unfold OCP.
unfold OCPAux.
unfold InCP.
elim_eq_rect.
simpl.
induction n.
rewrite CPLOK.
assert (HPerm1 := Permuted_sort (CPToList cp)).
simpl in HPerm1.
assert (HPerm2 := HPerm1).
apply Permutation.Permutation_sym in HPerm2.
assert (HInOK : In p (sort (fst cp :: snd cp :: nil)) <-> In p (fst cp :: snd cp :: nil)).
idtac.
split.

*****
HInOK : iff (In p (sort (cons (fst cp) (cons (snd cp) nil))))\n (In p (cons (fst cp) (cons (snd cp) nil)))
HPerm2 : Permutation.Permutation (sort (cons (fst cp) (cons (snd cp) nil)))\n (cons (fst cp) (cons (snd cp) nil))
HPerm1 : Permutation.Permutation (cons (fst cp) (cons (snd cp) nil))\n (sort (cons (fst cp) (cons (snd cp) nil)))
cp : cartesianPower positive (S (S O))
p : positive
*****
forall _ : In p (sort (cons (fst cp) (nat_rect (fun n : nat => forall _ : cartesianPower positive (S n), list positive) (fun cp : cartesianPower positive (S O) => cons cp nil) (fun (n : nat) (IHn : forall _ : cartesianPower positive (S n), list positive) (cp : cartesianPower positive (S (S n))) => cons (fst cp) (IHn (tailCP cp))) O (tailCP cp)))), or (eq (fst cp) p) (In p (nat_rect (fun n : nat => forall _ : cartesianPower positive (S n), list positive) (fun cp : cartesianPower positive (S O) => cons cp nil) (fun (n : nat) (IHn : forall _ : cartesianPower positive (S n), list positive) (cp : cartesianPower positive (S (S n))) => cons (fst cp) (IHn (tailCP cp))) O (tailCP cp)))
+++++
intro HIn.
-----
Lemma InCPOCP {n : nat} : forall p (cp : cartesianPower positive (S (S n))), InCP p cp <-> InCP p (OCP cp).
Proof.
intros p cp.
unfold OCP.
unfold OCPAux.
unfold InCP.
elim_eq_rect.
simpl.
induction n.
rewrite CPLOK.
assert (HPerm1 := Permuted_sort (CPToList cp)).
simpl in HPerm1.
assert (HPerm2 := HPerm1).
apply Permutation.Permutation_sym in HPerm2.
assert (HInOK : In p (sort (fst cp :: snd cp :: nil)) <-> In p (fst cp :: snd cp :: nil)).
idtac.
split.
intro HIn.

*****
HIn : In p\n (sort\n (cons (fst cp)\n (nat_rect\n (fun n : nat =>\n forall _ : cartesianPower positive (S n), list positive)\n (fun cp : cartesianPower positive (S O) => cons cp nil)\n (fun (n : nat)\n (IHn : forall _ : cartesianPower positive (S n),\n list positive)\n (cp : cartesianPower positive (S (S n))) =>\n cons (fst cp) (IHn (tailCP cp))) O (tailCP cp))))
HInOK : iff (In p (sort (cons (fst cp) (cons (snd cp) nil))))\n (In p (cons (fst cp) (cons (snd cp) nil)))
HPerm2 : Permutation.Permutation (sort (cons (fst cp) (cons (snd cp) nil)))\n (cons (fst cp) (cons (snd cp) nil))
HPerm1 : Permutation.Permutation (cons (fst cp) (cons (snd cp) nil))\n (sort (cons (fst cp) (cons (snd cp) nil)))
cp : cartesianPower positive (S (S O))
p : positive
*****
or (eq (fst cp) p) (In p (nat_rect (fun n : nat => forall _ : cartesianPower positive (S n), list positive) (fun cp : cartesianPower positive (S O) => cons cp nil) (fun (n : nat) (IHn : forall _ : cartesianPower positive (S n), list positive) (cp : cartesianPower positive (S (S n))) => cons (fst cp) (IHn (tailCP cp))) O (tailCP cp)))
+++++
apply HInOK in HIn.
-----
Lemma InCPOCP {n : nat} : forall p (cp : cartesianPower positive (S (S n))), InCP p cp <-> InCP p (OCP cp).
Proof.
intros p cp.
unfold OCP.
unfold OCPAux.
unfold InCP.
elim_eq_rect.
simpl.
induction n.
rewrite CPLOK.
assert (HPerm1 := Permuted_sort (CPToList cp)).
simpl in HPerm1.
assert (HPerm2 := HPerm1).
apply Permutation.Permutation_sym in HPerm2.
assert (HInOK : In p (sort (fst cp :: snd cp :: nil)) <-> In p (fst cp :: snd cp :: nil)).
idtac.
split.
intro HIn.
apply HInOK in HIn.

*****
HIn : In p (cons (fst cp) (cons (snd cp) nil))
HInOK : iff (In p (sort (cons (fst cp) (cons (snd cp) nil))))\n (In p (cons (fst cp) (cons (snd cp) nil)))
HPerm2 : Permutation.Permutation (sort (cons (fst cp) (cons (snd cp) nil)))\n (cons (fst cp) (cons (snd cp) nil))
HPerm1 : Permutation.Permutation (cons (fst cp) (cons (snd cp) nil))\n (sort (cons (fst cp) (cons (snd cp) nil)))
cp : cartesianPower positive (S (S O))
p : positive
*****
or (eq (fst cp) p) (In p (nat_rect (fun n : nat => forall _ : cartesianPower positive (S n), list positive) (fun cp : cartesianPower positive (S O) => cons cp nil) (fun (n : nat) (IHn : forall _ : cartesianPower positive (S n), list positive) (cp : cartesianPower positive (S (S n))) => cons (fst cp) (IHn (tailCP cp))) O (tailCP cp)))
+++++
simpl in HIn.
-----
Lemma InCPOCP {n : nat} : forall p (cp : cartesianPower positive (S (S n))), InCP p cp <-> InCP p (OCP cp).
Proof.
intros p cp.
unfold OCP.
unfold OCPAux.
unfold InCP.
elim_eq_rect.
simpl.
induction n.
rewrite CPLOK.
assert (HPerm1 := Permuted_sort (CPToList cp)).
simpl in HPerm1.
assert (HPerm2 := HPerm1).
apply Permutation.Permutation_sym in HPerm2.
assert (HInOK : In p (sort (fst cp :: snd cp :: nil)) <-> In p (fst cp :: snd cp :: nil)).
idtac.
split.
intro HIn.
apply HInOK in HIn.
simpl in HIn.

*****
HIn : or (eq (fst cp) p) (or (eq (snd cp) p) False)
HInOK : iff (In p (sort (cons (fst cp) (cons (snd cp) nil))))\n (In p (cons (fst cp) (cons (snd cp) nil)))
HPerm2 : Permutation.Permutation (sort (cons (fst cp) (cons (snd cp) nil)))\n (cons (fst cp) (cons (snd cp) nil))
HPerm1 : Permutation.Permutation (cons (fst cp) (cons (snd cp) nil))\n (sort (cons (fst cp) (cons (snd cp) nil)))
cp : cartesianPower positive (S (S O))
p : positive
*****
or (eq (fst cp) p) (In p (nat_rect (fun n : nat => forall _ : cartesianPower positive (S n), list positive) (fun cp : cartesianPower positive (S O) => cons cp nil) (fun (n : nat) (IHn : forall _ : cartesianPower positive (S n), list positive) (cp : cartesianPower positive (S (S n))) => cons (fst cp) (IHn (tailCP cp))) O (tailCP cp)))
+++++
assumption.
-----
Lemma InCPOCP {n : nat} : forall p (cp : cartesianPower positive (S (S n))), InCP p cp <-> InCP p (OCP cp).
Proof.
intros p cp.
unfold OCP.
unfold OCPAux.
unfold InCP.
elim_eq_rect.
simpl.
induction n.

*****
IHn : forall cp : cartesianPower positive (S (S n)),\niff\n (or (eq (fst cp) p)\n (In p\n (nat_rect\n (fun n : nat =>\n forall _ : cartesianPower positive (S n), list positive)\n (fun cp0 : cartesianPower positive (S O) => cons cp0 nil)\n (fun (n : nat)\n (IHn : forall _ : cartesianPower positive (S n),\n list positive)\n (cp0 : cartesianPower positive (S (S n))) =>\n cons (fst cp0) (IHn (tailCP cp0))) n (tailCP cp))))\n (In p\n (CPToList\n (ListToCP\n (sort\n (cons (fst cp)\n (nat_rect\n (fun n : nat =>\n forall _ : cartesianPower positive (S n),\n list positive)\n (fun cp0 : cartesianPower positive (S O) =>\n cons cp0 nil)\n (fun (n : nat)\n (IHn : forall _ : cartesianPower positive (S n),\n list positive)\n (cp0 : cartesianPower positive (S (S n))) =>\n cons (fst cp0) (IHn (tailCP cp0))) n \n (tailCP cp)))) (fst cp))))
cp : cartesianPower positive (S (S (S n)))
p : positive
n : nat
*****
iff (or (eq (fst cp) p) (In p (nat_rect (fun n : nat => forall _ : cartesianPower positive (S n), list positive) (fun cp : cartesianPower positive (S O) => cons cp nil) (fun (n : nat) (IHn : forall _ : cartesianPower positive (S n), list positive) (cp : cartesianPower positive (S (S n))) => cons (fst cp) (IHn (tailCP cp))) (S n) (tailCP cp)))) (In p (CPToList (ListToCP (sort (cons (fst cp) (nat_rect (fun n : nat => forall _ : cartesianPower positive (S n), list positive) (fun cp : cartesianPower positive (S O) => cons cp nil) (fun (n : nat) (IHn : forall _ : cartesianPower positive (S n), list positive) (cp : cartesianPower positive (S (S n))) => cons (fst cp) (IHn (tailCP cp))) (S n) (tailCP cp)))) (fst cp))))
+++++
clear IHn.
-----
Lemma InCPOCP {n : nat} : forall p (cp : cartesianPower positive (S (S n))), InCP p cp <-> InCP p (OCP cp).
Proof.
intros p cp.
unfold OCP.
unfold OCPAux.
unfold InCP.
elim_eq_rect.
simpl.
induction n.
clear IHn.

*****
cp : cartesianPower positive (S (S (S n)))
p : positive
n : nat
*****
iff (or (eq (fst cp) p) (In p (nat_rect (fun n : nat => forall _ : cartesianPower positive (S n), list positive) (fun cp : cartesianPower positive (S O) => cons cp nil) (fun (n : nat) (IHn : forall _ : cartesianPower positive (S n), list positive) (cp : cartesianPower positive (S (S n))) => cons (fst cp) (IHn (tailCP cp))) (S n) (tailCP cp)))) (In p (CPToList (ListToCP (sort (cons (fst cp) (nat_rect (fun n : nat => forall _ : cartesianPower positive (S n), list positive) (fun cp : cartesianPower positive (S O) => cons cp nil) (fun (n : nat) (IHn : forall _ : cartesianPower positive (S n), list positive) (cp : cartesianPower positive (S (S n))) => cons (fst cp) (IHn (tailCP cp))) (S n) (tailCP cp)))) (fst cp))))
+++++
rewrite CPLOK.
-----
Lemma InCPOCP {n : nat} : forall p (cp : cartesianPower positive (S (S n))), InCP p cp <-> InCP p (OCP cp).
Proof.
intros p cp.
unfold OCP.
unfold OCPAux.
unfold InCP.
elim_eq_rect.
simpl.
induction n.
clear IHn.
rewrite CPLOK.

*****
cp : cartesianPower positive (S (S (S n)))
p : positive
n : nat
*****
iff (or (eq (fst cp) p) (In p (nat_rect (fun n : nat => forall _ : cartesianPower positive (S n), list positive) (fun cp : cartesianPower positive (S O) => cons cp nil) (fun (n : nat) (IHn : forall _ : cartesianPower positive (S n), list positive) (cp : cartesianPower positive (S (S n))) => cons (fst cp) (IHn (tailCP cp))) (S n) (tailCP cp)))) (In p (sort (cons (fst cp) (nat_rect (fun n : nat => forall _ : cartesianPower positive (S n), list positive) (fun cp : cartesianPower positive (S O) => cons cp nil) (fun (n : nat) (IHn : forall _ : cartesianPower positive (S n), list positive) (cp : cartesianPower positive (S (S n))) => cons (fst cp) (IHn (tailCP cp))) (S n) (tailCP cp)))))
+++++
set (sscp := (nat_rect (fun n : nat => cartesianPower positive (S n) -> list positive) (fun cp0 : cartesianPower positive 1 => cp0 :: nil) (fun (n : nat) (IHn : cartesianPower positive (S n) -> list positive) (cp0 : cartesianPower positive (S (S n))) => fst cp0 :: IHn (tailCP cp0)) n (tailCP (snd cp)))).
-----
Lemma InCPOCP {n : nat} : forall p (cp : cartesianPower positive (S (S n))), InCP p cp <-> InCP p (OCP cp).
Proof.
intros p cp.
unfold OCP.
unfold OCPAux.
unfold InCP.
elim_eq_rect.
simpl.
induction n.
clear IHn.
rewrite CPLOK.
set (sscp := (nat_rect (fun n : nat => cartesianPower positive (S n) -> list positive) (fun cp0 : cartesianPower positive 1 => cp0 :: nil) (fun (n : nat) (IHn : cartesianPower positive (S n) -> list positive) (cp0 : cartesianPower positive (S (S n))) => fst cp0 :: IHn (tailCP cp0)) n (tailCP (snd cp)))).

*****
sscp : list positive
cp : cartesianPower positive (S (S (S n)))
p : positive
n : nat
*****
iff (or (eq (fst cp) p) (In p (nat_rect (fun n : nat => forall _ : cartesianPower positive (S n), list positive) (fun cp : cartesianPower positive (S O) => cons cp nil) (fun (n : nat) (IHn : forall _ : cartesianPower positive (S n), list positive) (cp : cartesianPower positive (S (S n))) => cons (fst cp) (IHn (tailCP cp))) (S n) (tailCP cp)))) (In p (sort (cons (fst cp) (nat_rect (fun n : nat => forall _ : cartesianPower positive (S n), list positive) (fun cp : cartesianPower positive (S O) => cons cp nil) (fun (n : nat) (IHn : forall _ : cartesianPower positive (S n), list positive) (cp : cartesianPower positive (S (S n))) => cons (fst cp) (IHn (tailCP cp))) (S n) (tailCP cp)))))
+++++
assert (HPerm := Permuted_sort (fst cp :: fst (snd cp) :: sscp)).
-----
Lemma InCPOCP {n : nat} : forall p (cp : cartesianPower positive (S (S n))), InCP p cp <-> InCP p (OCP cp).
Proof.
intros p cp.
unfold OCP.
unfold OCPAux.
unfold InCP.
elim_eq_rect.
simpl.
induction n.
clear IHn.
rewrite CPLOK.
set (sscp := (nat_rect (fun n : nat => cartesianPower positive (S n) -> list positive) (fun cp0 : cartesianPower positive 1 => cp0 :: nil) (fun (n : nat) (IHn : cartesianPower positive (S n) -> list positive) (cp0 : cartesianPower positive (S (S n))) => fst cp0 :: IHn (tailCP cp0)) n (tailCP (snd cp)))).
assert (HPerm := Permuted_sort (fst cp :: fst (snd cp) :: sscp)).

*****
HPerm : Permutation.Permutation (cons (fst cp) (cons (fst (snd cp)) sscp))\n (sort (cons (fst cp) (cons (fst (snd cp)) sscp)))
sscp : list positive
cp : cartesianPower positive (S (S (S n)))
p : positive
n : nat
*****
iff (or (eq (fst cp) p) (In p (nat_rect (fun n : nat => forall _ : cartesianPower positive (S n), list positive) (fun cp : cartesianPower positive (S O) => cons cp nil) (fun (n : nat) (IHn : forall _ : cartesianPower positive (S n), list positive) (cp : cartesianPower positive (S (S n))) => cons (fst cp) (IHn (tailCP cp))) (S n) (tailCP cp)))) (In p (sort (cons (fst cp) (nat_rect (fun n : nat => forall _ : cartesianPower positive (S n), list positive) (fun cp : cartesianPower positive (S O) => cons cp nil) (fun (n : nat) (IHn : forall _ : cartesianPower positive (S n), list positive) (cp : cartesianPower positive (S (S n))) => cons (fst cp) (IHn (tailCP cp))) (S n) (tailCP cp)))))
+++++
split.
-----
Lemma InCPOCP {n : nat} : forall p (cp : cartesianPower positive (S (S n))), InCP p cp <-> InCP p (OCP cp).
Proof.
intros p cp.
unfold OCP.
unfold OCPAux.
unfold InCP.
elim_eq_rect.
simpl.
induction n.
clear IHn.
rewrite CPLOK.
set (sscp := (nat_rect (fun n : nat => cartesianPower positive (S n) -> list positive) (fun cp0 : cartesianPower positive 1 => cp0 :: nil) (fun (n : nat) (IHn : cartesianPower positive (S n) -> list positive) (cp0 : cartesianPower positive (S (S n))) => fst cp0 :: IHn (tailCP cp0)) n (tailCP (snd cp)))).
assert (HPerm := Permuted_sort (fst cp :: fst (snd cp) :: sscp)).
split.

*****
HPerm : Permutation.Permutation (cons (fst cp) (cons (fst (snd cp)) sscp))\n (sort (cons (fst cp) (cons (fst (snd cp)) sscp)))
sscp : list positive
cp : cartesianPower positive (S (S (S n)))
p : positive
n : nat
*****
forall _ : or (eq (fst cp) p) (In p (nat_rect (fun n : nat => forall _ : cartesianPower positive (S n), list positive) (fun cp : cartesianPower positive (S O) => cons cp nil) (fun (n : nat) (IHn : forall _ : cartesianPower positive (S n), list positive) (cp : cartesianPower positive (S (S n))) => cons (fst cp) (IHn (tailCP cp))) (S n) (tailCP cp))), In p (sort (cons (fst cp) (nat_rect (fun n : nat => forall _ : cartesianPower positive (S n), list positive) (fun cp : cartesianPower positive (S O) => cons cp nil) (fun (n : nat) (IHn : forall _ : cartesianPower positive (S n), list positive) (cp : cartesianPower positive (S (S n))) => cons (fst cp) (IHn (tailCP cp))) (S n) (tailCP cp))))
+++++
intro HIn.
-----
Lemma InCPOCP {n : nat} : forall p (cp : cartesianPower positive (S (S n))), InCP p cp <-> InCP p (OCP cp).
Proof.
intros p cp.
unfold OCP.
unfold OCPAux.
unfold InCP.
elim_eq_rect.
simpl.
induction n.
clear IHn.
rewrite CPLOK.
set (sscp := (nat_rect (fun n : nat => cartesianPower positive (S n) -> list positive) (fun cp0 : cartesianPower positive 1 => cp0 :: nil) (fun (n : nat) (IHn : cartesianPower positive (S n) -> list positive) (cp0 : cartesianPower positive (S (S n))) => fst cp0 :: IHn (tailCP cp0)) n (tailCP (snd cp)))).
assert (HPerm := Permuted_sort (fst cp :: fst (snd cp) :: sscp)).
split.
intro HIn.

*****
HIn : or (eq (fst cp) p)\n (In p\n (nat_rect\n (fun n : nat =>\n forall _ : cartesianPower positive (S n), list positive)\n (fun cp : cartesianPower positive (S O) => cons cp nil)\n (fun (n : nat)\n (IHn : forall _ : cartesianPower positive (S n),\n list positive)\n (cp : cartesianPower positive (S (S n))) =>\n cons (fst cp) (IHn (tailCP cp))) (S n) (tailCP cp)))
HPerm : Permutation.Permutation (cons (fst cp) (cons (fst (snd cp)) sscp))\n (sort (cons (fst cp) (cons (fst (snd cp)) sscp)))
sscp : list positive
cp : cartesianPower positive (S (S (S n)))
p : positive
n : nat
*****
In p (sort (cons (fst cp) (nat_rect (fun n : nat => forall _ : cartesianPower positive (S n), list positive) (fun cp : cartesianPower positive (S O) => cons cp nil) (fun (n : nat) (IHn : forall _ : cartesianPower positive (S n), list positive) (cp : cartesianPower positive (S (S n))) => cons (fst cp) (IHn (tailCP cp))) (S n) (tailCP cp))))
+++++
elim HIn.
-----
Lemma InCPOCP {n : nat} : forall p (cp : cartesianPower positive (S (S n))), InCP p cp <-> InCP p (OCP cp).
Proof.
intros p cp.
unfold OCP.
unfold OCPAux.
unfold InCP.
elim_eq_rect.
simpl.
induction n.
clear IHn.
rewrite CPLOK.
set (sscp := (nat_rect (fun n : nat => cartesianPower positive (S n) -> list positive) (fun cp0 : cartesianPower positive 1 => cp0 :: nil) (fun (n : nat) (IHn : cartesianPower positive (S n) -> list positive) (cp0 : cartesianPower positive (S (S n))) => fst cp0 :: IHn (tailCP cp0)) n (tailCP (snd cp)))).
assert (HPerm := Permuted_sort (fst cp :: fst (snd cp) :: sscp)).
split.
intro HIn.
elim HIn.

*****
HIn : or (eq (fst cp) p)\n (In p\n (nat_rect\n (fun n : nat =>\n forall _ : cartesianPower positive (S n), list positive)\n (fun cp : cartesianPower positive (S O) => cons cp nil)\n (fun (n : nat)\n (IHn : forall _ : cartesianPower positive (S n),\n list positive)\n (cp : cartesianPower positive (S (S n))) =>\n cons (fst cp) (IHn (tailCP cp))) (S n) (tailCP cp)))
HPerm : Permutation.Permutation (cons (fst cp) (cons (fst (snd cp)) sscp))\n (sort (cons (fst cp) (cons (fst (snd cp)) sscp)))
sscp : list positive
cp : cartesianPower positive (S (S (S n)))
p : positive
n : nat
*****
forall _ : eq (fst cp) p, In p (sort (cons (fst cp) (nat_rect (fun n : nat => forall _ : cartesianPower positive (S n), list positive) (fun cp : cartesianPower positive (S O) => cons cp nil) (fun (n : nat) (IHn : forall _ : cartesianPower positive (S n), list positive) (cp : cartesianPower positive (S (S n))) => cons (fst cp) (IHn (tailCP cp))) (S n) (tailCP cp))))
+++++
clear HIn.
-----
Lemma InCPOCP {n : nat} : forall p (cp : cartesianPower positive (S (S n))), InCP p cp <-> InCP p (OCP cp).
Proof.
intros p cp.
unfold OCP.
unfold OCPAux.
unfold InCP.
elim_eq_rect.
simpl.
induction n.
clear IHn.
rewrite CPLOK.
set (sscp := (nat_rect (fun n : nat => cartesianPower positive (S n) -> list positive) (fun cp0 : cartesianPower positive 1 => cp0 :: nil) (fun (n : nat) (IHn : cartesianPower positive (S n) -> list positive) (cp0 : cartesianPower positive (S (S n))) => fst cp0 :: IHn (tailCP cp0)) n (tailCP (snd cp)))).
assert (HPerm := Permuted_sort (fst cp :: fst (snd cp) :: sscp)).
split.
intro HIn.
elim HIn.
clear HIn.

*****
HPerm : Permutation.Permutation (cons (fst cp) (cons (fst (snd cp)) sscp))\n (sort (cons (fst cp) (cons (fst (snd cp)) sscp)))
sscp : list positive
cp : cartesianPower positive (S (S (S n)))
p : positive
n : nat
*****
forall _ : eq (fst cp) p, In p (sort (cons (fst cp) (nat_rect (fun n : nat => forall _ : cartesianPower positive (S n), list positive) (fun cp : cartesianPower positive (S O) => cons cp nil) (fun (n : nat) (IHn : forall _ : cartesianPower positive (S n), list positive) (cp : cartesianPower positive (S (S n))) => cons (fst cp) (IHn (tailCP cp))) (S n) (tailCP cp))))
+++++
intro HIn.
-----
Lemma InCPOCP {n : nat} : forall p (cp : cartesianPower positive (S (S n))), InCP p cp <-> InCP p (OCP cp).
Proof.
intros p cp.
unfold OCP.
unfold OCPAux.
unfold InCP.
elim_eq_rect.
simpl.
induction n.
clear IHn.
rewrite CPLOK.
set (sscp := (nat_rect (fun n : nat => cartesianPower positive (S n) -> list positive) (fun cp0 : cartesianPower positive 1 => cp0 :: nil) (fun (n : nat) (IHn : cartesianPower positive (S n) -> list positive) (cp0 : cartesianPower positive (S (S n))) => fst cp0 :: IHn (tailCP cp0)) n (tailCP (snd cp)))).
assert (HPerm := Permuted_sort (fst cp :: fst (snd cp) :: sscp)).
split.
intro HIn.
elim HIn.
clear HIn.
intro HIn.

*****
HIn : eq (fst cp) p
HPerm : Permutation.Permutation (cons (fst cp) (cons (fst (snd cp)) sscp))\n (sort (cons (fst cp) (cons (fst (snd cp)) sscp)))
sscp : list positive
cp : cartesianPower positive (S (S (S n)))
p : positive
n : nat
*****
In p (sort (cons (fst cp) (nat_rect (fun n : nat => forall _ : cartesianPower positive (S n), list positive) (fun cp : cartesianPower positive (S O) => cons cp nil) (fun (n : nat) (IHn : forall _ : cartesianPower positive (S n), list positive) (cp : cartesianPower positive (S (S n))) => cons (fst cp) (IHn (tailCP cp))) (S n) (tailCP cp))))
+++++
subst.
-----
Lemma InCPOCP {n : nat} : forall p (cp : cartesianPower positive (S (S n))), InCP p cp <-> InCP p (OCP cp).
Proof.
intros p cp.
unfold OCP.
unfold OCPAux.
unfold InCP.
elim_eq_rect.
simpl.
induction n.
clear IHn.
rewrite CPLOK.
set (sscp := (nat_rect (fun n : nat => cartesianPower positive (S n) -> list positive) (fun cp0 : cartesianPower positive 1 => cp0 :: nil) (fun (n : nat) (IHn : cartesianPower positive (S n) -> list positive) (cp0 : cartesianPower positive (S (S n))) => fst cp0 :: IHn (tailCP cp0)) n (tailCP (snd cp)))).
assert (HPerm := Permuted_sort (fst cp :: fst (snd cp) :: sscp)).
split.
intro HIn.
elim HIn.
clear HIn.
intro HIn.
subst.

*****
HPerm : Permutation.Permutation (cons (fst cp) (cons (fst (snd cp)) sscp))\n (sort (cons (fst cp) (cons (fst (snd cp)) sscp)))
sscp : list positive
cp : cartesianPower positive (S (S (S n)))
n : nat
*****
In (fst cp) (sort (cons (fst cp) (nat_rect (fun n : nat => forall _ : cartesianPower positive (S n), list positive) (fun cp : cartesianPower positive (S O) => cons cp nil) (fun (n : nat) (IHn : forall _ : cartesianPower positive (S n), list positive) (cp : cartesianPower positive (S (S n))) => cons (fst cp) (IHn (tailCP cp))) (S n) (tailCP cp))))
+++++
apply Permutation.Permutation_in with (fst cp :: fst (snd cp) :: sscp).
-----
Lemma InCPOCP {n : nat} : forall p (cp : cartesianPower positive (S (S n))), InCP p cp <-> InCP p (OCP cp).
Proof.
intros p cp.
unfold OCP.
unfold OCPAux.
unfold InCP.
elim_eq_rect.
simpl.
induction n.
clear IHn.
rewrite CPLOK.
set (sscp := (nat_rect (fun n : nat => cartesianPower positive (S n) -> list positive) (fun cp0 : cartesianPower positive 1 => cp0 :: nil) (fun (n : nat) (IHn : cartesianPower positive (S n) -> list positive) (cp0 : cartesianPower positive (S (S n))) => fst cp0 :: IHn (tailCP cp0)) n (tailCP (snd cp)))).
assert (HPerm := Permuted_sort (fst cp :: fst (snd cp) :: sscp)).
split.
intro HIn.
elim HIn.
clear HIn.
intro HIn.
subst.
apply Permutation.Permutation_in with (fst cp :: fst (snd cp) :: sscp).

*****
HPerm : Permutation.Permutation (cons (fst cp) (cons (fst (snd cp)) sscp))\n (sort (cons (fst cp) (cons (fst (snd cp)) sscp)))
sscp : list positive
cp : cartesianPower positive (S (S (S n)))
n : nat
*****
Permutation.Permutation (cons (fst cp) (cons (fst (snd cp)) sscp)) (sort (cons (fst cp) (nat_rect (fun n : nat => forall _ : cartesianPower positive (S n), list positive) (fun cp : cartesianPower positive (S O) => cons cp nil) (fun (n : nat) (IHn : forall _ : cartesianPower positive (S n), list positive) (cp : cartesianPower positive (S (S n))) => cons (fst cp) (IHn (tailCP cp))) (S n) (tailCP cp))))
+++++
try assumption.
-----
Lemma InCPOCP {n : nat} : forall p (cp : cartesianPower positive (S (S n))), InCP p cp <-> InCP p (OCP cp).
Proof.
intros p cp.
unfold OCP.
unfold OCPAux.
unfold InCP.
elim_eq_rect.
simpl.
induction n.
clear IHn.
rewrite CPLOK.
set (sscp := (nat_rect (fun n : nat => cartesianPower positive (S n) -> list positive) (fun cp0 : cartesianPower positive 1 => cp0 :: nil) (fun (n : nat) (IHn : cartesianPower positive (S n) -> list positive) (cp0 : cartesianPower positive (S (S n))) => fst cp0 :: IHn (tailCP cp0)) n (tailCP (snd cp)))).
assert (HPerm := Permuted_sort (fst cp :: fst (snd cp) :: sscp)).
split.
intro HIn.
elim HIn.
clear HIn.
intro HIn.
subst.
apply Permutation.Permutation_in with (fst cp :: fst (snd cp) :: sscp).

*****
HPerm : Permutation.Permutation (cons (fst cp) (cons (fst (snd cp)) sscp))\n (sort (cons (fst cp) (cons (fst (snd cp)) sscp)))
sscp : list positive
cp : cartesianPower positive (S (S (S n)))
n : nat
*****
In (fst cp) (cons (fst cp) (cons (fst (snd cp)) sscp))
+++++
try assumption.
-----
Lemma InCPOCP {n : nat} : forall p (cp : cartesianPower positive (S (S n))), InCP p cp <-> InCP p (OCP cp).
Proof.
intros p cp.
unfold OCP.
unfold OCPAux.
unfold InCP.
elim_eq_rect.
simpl.
induction n.
clear IHn.
rewrite CPLOK.
set (sscp := (nat_rect (fun n : nat => cartesianPower positive (S n) -> list positive) (fun cp0 : cartesianPower positive 1 => cp0 :: nil) (fun (n : nat) (IHn : cartesianPower positive (S n) -> list positive) (cp0 : cartesianPower positive (S (S n))) => fst cp0 :: IHn (tailCP cp0)) n (tailCP (snd cp)))).
assert (HPerm := Permuted_sort (fst cp :: fst (snd cp) :: sscp)).
split.
intro HIn.
elim HIn.
clear HIn.
intro HIn.
subst.
apply Permutation.Permutation_in with (fst cp :: fst (snd cp) :: sscp).
try assumption.

*****
HPerm : Permutation.Permutation (cons (fst cp) (cons (fst (snd cp)) sscp))\n (sort (cons (fst cp) (cons (fst (snd cp)) sscp)))
sscp : list positive
cp : cartesianPower positive (S (S (S n)))
n : nat
*****
In (fst cp) (cons (fst cp) (cons (fst (snd cp)) sscp))
+++++
apply in_eq.
-----
Lemma InCPOCP {n : nat} : forall p (cp : cartesianPower positive (S (S n))), InCP p cp <-> InCP p (OCP cp).
Proof.
intros p cp.
unfold OCP.
unfold OCPAux.
unfold InCP.
elim_eq_rect.
simpl.
induction n.
clear IHn.
rewrite CPLOK.
set (sscp := (nat_rect (fun n : nat => cartesianPower positive (S n) -> list positive) (fun cp0 : cartesianPower positive 1 => cp0 :: nil) (fun (n : nat) (IHn : cartesianPower positive (S n) -> list positive) (cp0 : cartesianPower positive (S (S n))) => fst cp0 :: IHn (tailCP cp0)) n (tailCP (snd cp)))).
assert (HPerm := Permuted_sort (fst cp :: fst (snd cp) :: sscp)).
split.
intro HIn.
elim HIn.

*****
HIn : or (eq (fst cp) p)\n (In p\n (nat_rect\n (fun n : nat =>\n forall _ : cartesianPower positive (S n), list positive)\n (fun cp : cartesianPower positive (S O) => cons cp nil)\n (fun (n : nat)\n (IHn : forall _ : cartesianPower positive (S n),\n list positive)\n (cp : cartesianPower positive (S (S n))) =>\n cons (fst cp) (IHn (tailCP cp))) (S n) (tailCP cp)))
HPerm : Permutation.Permutation (cons (fst cp) (cons (fst (snd cp)) sscp))\n (sort (cons (fst cp) (cons (fst (snd cp)) sscp)))
sscp : list positive
cp : cartesianPower positive (S (S (S n)))
p : positive
n : nat
*****
forall _ : In p (nat_rect (fun n : nat => forall _ : cartesianPower positive (S n), list positive) (fun cp : cartesianPower positive (S O) => cons cp nil) (fun (n : nat) (IHn : forall _ : cartesianPower positive (S n), list positive) (cp : cartesianPower positive (S (S n))) => cons (fst cp) (IHn (tailCP cp))) (S n) (tailCP cp)), In p (sort (cons (fst cp) (nat_rect (fun n : nat => forall _ : cartesianPower positive (S n), list positive) (fun cp : cartesianPower positive (S O) => cons cp nil) (fun (n : nat) (IHn : forall _ : cartesianPower positive (S n), list positive) (cp : cartesianPower positive (S (S n))) => cons (fst cp) (IHn (tailCP cp))) (S n) (tailCP cp))))
+++++
clear HIn.
-----
Lemma InCPOCP {n : nat} : forall p (cp : cartesianPower positive (S (S n))), InCP p cp <-> InCP p (OCP cp).
Proof.
intros p cp.
unfold OCP.
unfold OCPAux.
unfold InCP.
elim_eq_rect.
simpl.
induction n.
clear IHn.
rewrite CPLOK.
set (sscp := (nat_rect (fun n : nat => cartesianPower positive (S n) -> list positive) (fun cp0 : cartesianPower positive 1 => cp0 :: nil) (fun (n : nat) (IHn : cartesianPower positive (S n) -> list positive) (cp0 : cartesianPower positive (S (S n))) => fst cp0 :: IHn (tailCP cp0)) n (tailCP (snd cp)))).
assert (HPerm := Permuted_sort (fst cp :: fst (snd cp) :: sscp)).
split.
intro HIn.
elim HIn.
clear HIn.

*****
HPerm : Permutation.Permutation (cons (fst cp) (cons (fst (snd cp)) sscp))\n (sort (cons (fst cp) (cons (fst (snd cp)) sscp)))
sscp : list positive
cp : cartesianPower positive (S (S (S n)))
p : positive
n : nat
*****
forall _ : In p (nat_rect (fun n : nat => forall _ : cartesianPower positive (S n), list positive) (fun cp : cartesianPower positive (S O) => cons cp nil) (fun (n : nat) (IHn : forall _ : cartesianPower positive (S n), list positive) (cp : cartesianPower positive (S (S n))) => cons (fst cp) (IHn (tailCP cp))) (S n) (tailCP cp)), In p (sort (cons (fst cp) (nat_rect (fun n : nat => forall _ : cartesianPower positive (S n), list positive) (fun cp : cartesianPower positive (S O) => cons cp nil) (fun (n : nat) (IHn : forall _ : cartesianPower positive (S n), list positive) (cp : cartesianPower positive (S (S n))) => cons (fst cp) (IHn (tailCP cp))) (S n) (tailCP cp))))
+++++
intro HIn.
-----
Lemma InCPOCP {n : nat} : forall p (cp : cartesianPower positive (S (S n))), InCP p cp <-> InCP p (OCP cp).
Proof.
intros p cp.
unfold OCP.
unfold OCPAux.
unfold InCP.
elim_eq_rect.
simpl.
induction n.
clear IHn.
rewrite CPLOK.
set (sscp := (nat_rect (fun n : nat => cartesianPower positive (S n) -> list positive) (fun cp0 : cartesianPower positive 1 => cp0 :: nil) (fun (n : nat) (IHn : cartesianPower positive (S n) -> list positive) (cp0 : cartesianPower positive (S (S n))) => fst cp0 :: IHn (tailCP cp0)) n (tailCP (snd cp)))).
assert (HPerm := Permuted_sort (fst cp :: fst (snd cp) :: sscp)).
split.
intro HIn.
elim HIn.
clear HIn.
intro HIn.

*****
HIn : In p\n (nat_rect\n (fun n : nat =>\n forall _ : cartesianPower positive (S n), list positive)\n (fun cp : cartesianPower positive (S O) => cons cp nil)\n (fun (n : nat)\n (IHn : forall _ : cartesianPower positive (S n), list positive)\n (cp : cartesianPower positive (S (S n))) =>\n cons (fst cp) (IHn (tailCP cp))) (S n) (tailCP cp))
HPerm : Permutation.Permutation (cons (fst cp) (cons (fst (snd cp)) sscp))\n (sort (cons (fst cp) (cons (fst (snd cp)) sscp)))
sscp : list positive
cp : cartesianPower positive (S (S (S n)))
p : positive
n : nat
*****
In p (sort (cons (fst cp) (nat_rect (fun n : nat => forall _ : cartesianPower positive (S n), list positive) (fun cp : cartesianPower positive (S O) => cons cp nil) (fun (n : nat) (IHn : forall _ : cartesianPower positive (S n), list positive) (cp : cartesianPower positive (S (S n))) => cons (fst cp) (IHn (tailCP cp))) (S n) (tailCP cp))))
+++++
elim HIn.
-----
Lemma InCPOCP {n : nat} : forall p (cp : cartesianPower positive (S (S n))), InCP p cp <-> InCP p (OCP cp).
Proof.
intros p cp.
unfold OCP.
unfold OCPAux.
unfold InCP.
elim_eq_rect.
simpl.
induction n.
clear IHn.
rewrite CPLOK.
set (sscp := (nat_rect (fun n : nat => cartesianPower positive (S n) -> list positive) (fun cp0 : cartesianPower positive 1 => cp0 :: nil) (fun (n : nat) (IHn : cartesianPower positive (S n) -> list positive) (cp0 : cartesianPower positive (S (S n))) => fst cp0 :: IHn (tailCP cp0)) n (tailCP (snd cp)))).
assert (HPerm := Permuted_sort (fst cp :: fst (snd cp) :: sscp)).
split.
intro HIn.
elim HIn.
clear HIn.
intro HIn.
elim HIn.

*****
HIn : In p\n (nat_rect\n (fun n : nat =>\n forall _ : cartesianPower positive (S n), list positive)\n (fun cp : cartesianPower positive (S O) => cons cp nil)\n (fun (n : nat)\n (IHn : forall _ : cartesianPower positive (S n), list positive)\n (cp : cartesianPower positive (S (S n))) =>\n cons (fst cp) (IHn (tailCP cp))) (S n) (tailCP cp))
HPerm : Permutation.Permutation (cons (fst cp) (cons (fst (snd cp)) sscp))\n (sort (cons (fst cp) (cons (fst (snd cp)) sscp)))
sscp : list positive
cp : cartesianPower positive (S (S (S n)))
p : positive
n : nat
*****
forall _ : eq (fst (tailCP cp)) p, In p (sort (cons (fst cp) (nat_rect (fun n : nat => forall _ : cartesianPower positive (S n), list positive) (fun cp : cartesianPower positive (S O) => cons cp nil) (fun (n : nat) (IHn : forall _ : cartesianPower positive (S n), list positive) (cp : cartesianPower positive (S (S n))) => cons (fst cp) (IHn (tailCP cp))) (S n) (tailCP cp))))
+++++
clear HIn.
-----
Lemma InCPOCP {n : nat} : forall p (cp : cartesianPower positive (S (S n))), InCP p cp <-> InCP p (OCP cp).
Proof.
intros p cp.
unfold OCP.
unfold OCPAux.
unfold InCP.
elim_eq_rect.
simpl.
induction n.
clear IHn.
rewrite CPLOK.
set (sscp := (nat_rect (fun n : nat => cartesianPower positive (S n) -> list positive) (fun cp0 : cartesianPower positive 1 => cp0 :: nil) (fun (n : nat) (IHn : cartesianPower positive (S n) -> list positive) (cp0 : cartesianPower positive (S (S n))) => fst cp0 :: IHn (tailCP cp0)) n (tailCP (snd cp)))).
assert (HPerm := Permuted_sort (fst cp :: fst (snd cp) :: sscp)).
split.
intro HIn.
elim HIn.
clear HIn.
intro HIn.
elim HIn.
clear HIn.

*****
HPerm : Permutation.Permutation (cons (fst cp) (cons (fst (snd cp)) sscp))\n (sort (cons (fst cp) (cons (fst (snd cp)) sscp)))
sscp : list positive
cp : cartesianPower positive (S (S (S n)))
p : positive
n : nat
*****
forall _ : eq (fst (tailCP cp)) p, In p (sort (cons (fst cp) (nat_rect (fun n : nat => forall _ : cartesianPower positive (S n), list positive) (fun cp : cartesianPower positive (S O) => cons cp nil) (fun (n : nat) (IHn : forall _ : cartesianPower positive (S n), list positive) (cp : cartesianPower positive (S (S n))) => cons (fst cp) (IHn (tailCP cp))) (S n) (tailCP cp))))
+++++
intro HIn.
-----
Lemma InCPOCP {n : nat} : forall p (cp : cartesianPower positive (S (S n))), InCP p cp <-> InCP p (OCP cp).
Proof.
intros p cp.
unfold OCP.
unfold OCPAux.
unfold InCP.
elim_eq_rect.
simpl.
induction n.
clear IHn.
rewrite CPLOK.
set (sscp := (nat_rect (fun n : nat => cartesianPower positive (S n) -> list positive) (fun cp0 : cartesianPower positive 1 => cp0 :: nil) (fun (n : nat) (IHn : cartesianPower positive (S n) -> list positive) (cp0 : cartesianPower positive (S (S n))) => fst cp0 :: IHn (tailCP cp0)) n (tailCP (snd cp)))).
assert (HPerm := Permuted_sort (fst cp :: fst (snd cp) :: sscp)).
split.
intro HIn.
elim HIn.
clear HIn.
intro HIn.
elim HIn.
clear HIn.
intro HIn.

*****
HIn : eq (fst (tailCP cp)) p
HPerm : Permutation.Permutation (cons (fst cp) (cons (fst (snd cp)) sscp))\n (sort (cons (fst cp) (cons (fst (snd cp)) sscp)))
sscp : list positive
cp : cartesianPower positive (S (S (S n)))
p : positive
n : nat
*****
In p (sort (cons (fst cp) (nat_rect (fun n : nat => forall _ : cartesianPower positive (S n), list positive) (fun cp : cartesianPower positive (S O) => cons cp nil) (fun (n : nat) (IHn : forall _ : cartesianPower positive (S n), list positive) (cp : cartesianPower positive (S (S n))) => cons (fst cp) (IHn (tailCP cp))) (S n) (tailCP cp))))
+++++
subst.
-----
Lemma InCPOCP {n : nat} : forall p (cp : cartesianPower positive (S (S n))), InCP p cp <-> InCP p (OCP cp).
Proof.
intros p cp.
unfold OCP.
unfold OCPAux.
unfold InCP.
elim_eq_rect.
simpl.
induction n.
clear IHn.
rewrite CPLOK.
set (sscp := (nat_rect (fun n : nat => cartesianPower positive (S n) -> list positive) (fun cp0 : cartesianPower positive 1 => cp0 :: nil) (fun (n : nat) (IHn : cartesianPower positive (S n) -> list positive) (cp0 : cartesianPower positive (S (S n))) => fst cp0 :: IHn (tailCP cp0)) n (tailCP (snd cp)))).
assert (HPerm := Permuted_sort (fst cp :: fst (snd cp) :: sscp)).
split.
intro HIn.
elim HIn.
clear HIn.
intro HIn.
elim HIn.
clear HIn.
intro HIn.
subst.

*****
HPerm : Permutation.Permutation (cons (fst cp) (cons (fst (snd cp)) sscp))\n (sort (cons (fst cp) (cons (fst (snd cp)) sscp)))
sscp : list positive
cp : cartesianPower positive (S (S (S n)))
n : nat
*****
In (fst (tailCP cp)) (sort (cons (fst cp) (nat_rect (fun n : nat => forall _ : cartesianPower positive (S n), list positive) (fun cp : cartesianPower positive (S O) => cons cp nil) (fun (n : nat) (IHn : forall _ : cartesianPower positive (S n), list positive) (cp : cartesianPower positive (S (S n))) => cons (fst cp) (IHn (tailCP cp))) (S n) (tailCP cp))))
+++++
apply Permutation.Permutation_in with (fst cp :: fst (snd cp) :: sscp).
-----
Lemma InCPOCP {n : nat} : forall p (cp : cartesianPower positive (S (S n))), InCP p cp <-> InCP p (OCP cp).
Proof.
intros p cp.
unfold OCP.
unfold OCPAux.
unfold InCP.
elim_eq_rect.
simpl.
induction n.
clear IHn.
rewrite CPLOK.
set (sscp := (nat_rect (fun n : nat => cartesianPower positive (S n) -> list positive) (fun cp0 : cartesianPower positive 1 => cp0 :: nil) (fun (n : nat) (IHn : cartesianPower positive (S n) -> list positive) (cp0 : cartesianPower positive (S (S n))) => fst cp0 :: IHn (tailCP cp0)) n (tailCP (snd cp)))).
assert (HPerm := Permuted_sort (fst cp :: fst (snd cp) :: sscp)).
split.
intro HIn.
elim HIn.
clear HIn.
intro HIn.
elim HIn.
clear HIn.
intro HIn.
subst.
apply Permutation.Permutation_in with (fst cp :: fst (snd cp) :: sscp).

*****
HPerm : Permutation.Permutation (cons (fst cp) (cons (fst (snd cp)) sscp))\n (sort (cons (fst cp) (cons (fst (snd cp)) sscp)))
sscp : list positive
cp : cartesianPower positive (S (S (S n)))
n : nat
*****
Permutation.Permutation (cons (fst cp) (cons (fst (snd cp)) sscp)) (sort (cons (fst cp) (nat_rect (fun n : nat => forall _ : cartesianPower positive (S n), list positive) (fun cp : cartesianPower positive (S O) => cons cp nil) (fun (n : nat) (IHn : forall _ : cartesianPower positive (S n), list positive) (cp : cartesianPower positive (S (S n))) => cons (fst cp) (IHn (tailCP cp))) (S n) (tailCP cp))))
+++++
try assumption.
-----
Lemma InCPOCP {n : nat} : forall p (cp : cartesianPower positive (S (S n))), InCP p cp <-> InCP p (OCP cp).
Proof.
intros p cp.
unfold OCP.
unfold OCPAux.
unfold InCP.
elim_eq_rect.
simpl.
induction n.
clear IHn.
rewrite CPLOK.
set (sscp := (nat_rect (fun n : nat => cartesianPower positive (S n) -> list positive) (fun cp0 : cartesianPower positive 1 => cp0 :: nil) (fun (n : nat) (IHn : cartesianPower positive (S n) -> list positive) (cp0 : cartesianPower positive (S (S n))) => fst cp0 :: IHn (tailCP cp0)) n (tailCP (snd cp)))).
assert (HPerm := Permuted_sort (fst cp :: fst (snd cp) :: sscp)).
split.
intro HIn.
elim HIn.
clear HIn.
intro HIn.
elim HIn.
clear HIn.
intro HIn.
subst.
apply Permutation.Permutation_in with (fst cp :: fst (snd cp) :: sscp).

*****
HPerm : Permutation.Permutation (cons (fst cp) (cons (fst (snd cp)) sscp))\n (sort (cons (fst cp) (cons (fst (snd cp)) sscp)))
sscp : list positive
cp : cartesianPower positive (S (S (S n)))
n : nat
*****
In (fst (tailCP cp)) (cons (fst cp) (cons (fst (snd cp)) sscp))
+++++
try assumption.
-----
Lemma InCPOCP {n : nat} : forall p (cp : cartesianPower positive (S (S n))), InCP p cp <-> InCP p (OCP cp).
Proof.
intros p cp.
unfold OCP.
unfold OCPAux.
unfold InCP.
elim_eq_rect.
simpl.
induction n.
clear IHn.
rewrite CPLOK.
set (sscp := (nat_rect (fun n : nat => cartesianPower positive (S n) -> list positive) (fun cp0 : cartesianPower positive 1 => cp0 :: nil) (fun (n : nat) (IHn : cartesianPower positive (S n) -> list positive) (cp0 : cartesianPower positive (S (S n))) => fst cp0 :: IHn (tailCP cp0)) n (tailCP (snd cp)))).
assert (HPerm := Permuted_sort (fst cp :: fst (snd cp) :: sscp)).
split.
intro HIn.
elim HIn.
clear HIn.
intro HIn.
elim HIn.
clear HIn.
intro HIn.
subst.
apply Permutation.Permutation_in with (fst cp :: fst (snd cp) :: sscp).
try assumption.

*****
HPerm : Permutation.Permutation (cons (fst cp) (cons (fst (snd cp)) sscp))\n (sort (cons (fst cp) (cons (fst (snd cp)) sscp)))
sscp : list positive
cp : cartesianPower positive (S (S (S n)))
n : nat
*****
In (fst (tailCP cp)) (cons (fst cp) (cons (fst (snd cp)) sscp))
+++++
apply in_cons.
-----
Lemma InCPOCP {n : nat} : forall p (cp : cartesianPower positive (S (S n))), InCP p cp <-> InCP p (OCP cp).
Proof.
intros p cp.
unfold OCP.
unfold OCPAux.
unfold InCP.
elim_eq_rect.
simpl.
induction n.
clear IHn.
rewrite CPLOK.
set (sscp := (nat_rect (fun n : nat => cartesianPower positive (S n) -> list positive) (fun cp0 : cartesianPower positive 1 => cp0 :: nil) (fun (n : nat) (IHn : cartesianPower positive (S n) -> list positive) (cp0 : cartesianPower positive (S (S n))) => fst cp0 :: IHn (tailCP cp0)) n (tailCP (snd cp)))).
assert (HPerm := Permuted_sort (fst cp :: fst (snd cp) :: sscp)).
split.
intro HIn.
elim HIn.
clear HIn.
intro HIn.
elim HIn.
clear HIn.
intro HIn.
subst.
apply Permutation.Permutation_in with (fst cp :: fst (snd cp) :: sscp).
try assumption.
apply in_cons.

*****
HPerm : Permutation.Permutation (cons (fst cp) (cons (fst (snd cp)) sscp))\n (sort (cons (fst cp) (cons (fst (snd cp)) sscp)))
sscp : list positive
cp : cartesianPower positive (S (S (S n)))
n : nat
*****
In (fst (tailCP cp)) (cons (fst (snd cp)) sscp)
+++++
apply in_eq.
-----
Lemma InCPOCP {n : nat} : forall p (cp : cartesianPower positive (S (S n))), InCP p cp <-> InCP p (OCP cp).
Proof.
intros p cp.
unfold OCP.
unfold OCPAux.
unfold InCP.
elim_eq_rect.
simpl.
induction n.
clear IHn.
rewrite CPLOK.
set (sscp := (nat_rect (fun n : nat => cartesianPower positive (S n) -> list positive) (fun cp0 : cartesianPower positive 1 => cp0 :: nil) (fun (n : nat) (IHn : cartesianPower positive (S n) -> list positive) (cp0 : cartesianPower positive (S (S n))) => fst cp0 :: IHn (tailCP cp0)) n (tailCP (snd cp)))).
assert (HPerm := Permuted_sort (fst cp :: fst (snd cp) :: sscp)).
split.
intro HIn.
elim HIn.
clear HIn.
intro HIn.
elim HIn.

*****
HIn : In p\n (nat_rect\n (fun n : nat =>\n forall _ : cartesianPower positive (S n), list positive)\n (fun cp : cartesianPower positive (S O) => cons cp nil)\n (fun (n : nat)\n (IHn : forall _ : cartesianPower positive (S n), list positive)\n (cp : cartesianPower positive (S (S n))) =>\n cons (fst cp) (IHn (tailCP cp))) (S n) (tailCP cp))
HPerm : Permutation.Permutation (cons (fst cp) (cons (fst (snd cp)) sscp))\n (sort (cons (fst cp) (cons (fst (snd cp)) sscp)))
sscp : list positive
cp : cartesianPower positive (S (S (S n)))
p : positive
n : nat
*****
forall _ : In p (nat_rect (fun n : nat => forall _ : cartesianPower positive (S n), list positive) (fun cp : cartesianPower positive (S O) => cons cp nil) (fun (n : nat) (IHn : forall _ : cartesianPower positive (S n), list positive) (cp : cartesianPower positive (S (S n))) => cons (fst cp) (IHn (tailCP cp))) n (tailCP (tailCP cp))), In p (sort (cons (fst cp) (nat_rect (fun n : nat => forall _ : cartesianPower positive (S n), list positive) (fun cp : cartesianPower positive (S O) => cons cp nil) (fun (n : nat) (IHn : forall _ : cartesianPower positive (S n), list positive) (cp : cartesianPower positive (S (S n))) => cons (fst cp) (IHn (tailCP cp))) (S n) (tailCP cp))))
+++++
clear HIn.
-----
Lemma InCPOCP {n : nat} : forall p (cp : cartesianPower positive (S (S n))), InCP p cp <-> InCP p (OCP cp).
Proof.
intros p cp.
unfold OCP.
unfold OCPAux.
unfold InCP.
elim_eq_rect.
simpl.
induction n.
clear IHn.
rewrite CPLOK.
set (sscp := (nat_rect (fun n : nat => cartesianPower positive (S n) -> list positive) (fun cp0 : cartesianPower positive 1 => cp0 :: nil) (fun (n : nat) (IHn : cartesianPower positive (S n) -> list positive) (cp0 : cartesianPower positive (S (S n))) => fst cp0 :: IHn (tailCP cp0)) n (tailCP (snd cp)))).
assert (HPerm := Permuted_sort (fst cp :: fst (snd cp) :: sscp)).
split.
intro HIn.
elim HIn.
clear HIn.
intro HIn.
elim HIn.
clear HIn.

*****
HPerm : Permutation.Permutation (cons (fst cp) (cons (fst (snd cp)) sscp))\n (sort (cons (fst cp) (cons (fst (snd cp)) sscp)))
sscp : list positive
cp : cartesianPower positive (S (S (S n)))
p : positive
n : nat
*****
forall _ : In p (nat_rect (fun n : nat => forall _ : cartesianPower positive (S n), list positive) (fun cp : cartesianPower positive (S O) => cons cp nil) (fun (n : nat) (IHn : forall _ : cartesianPower positive (S n), list positive) (cp : cartesianPower positive (S (S n))) => cons (fst cp) (IHn (tailCP cp))) n (tailCP (tailCP cp))), In p (sort (cons (fst cp) (nat_rect (fun n : nat => forall _ : cartesianPower positive (S n), list positive) (fun cp : cartesianPower positive (S O) => cons cp nil) (fun (n : nat) (IHn : forall _ : cartesianPower positive (S n), list positive) (cp : cartesianPower positive (S (S n))) => cons (fst cp) (IHn (tailCP cp))) (S n) (tailCP cp))))
+++++
intro HIn.
-----
Lemma InCPOCP {n : nat} : forall p (cp : cartesianPower positive (S (S n))), InCP p cp <-> InCP p (OCP cp).
Proof.
intros p cp.
unfold OCP.
unfold OCPAux.
unfold InCP.
elim_eq_rect.
simpl.
induction n.
clear IHn.
rewrite CPLOK.
set (sscp := (nat_rect (fun n : nat => cartesianPower positive (S n) -> list positive) (fun cp0 : cartesianPower positive 1 => cp0 :: nil) (fun (n : nat) (IHn : cartesianPower positive (S n) -> list positive) (cp0 : cartesianPower positive (S (S n))) => fst cp0 :: IHn (tailCP cp0)) n (tailCP (snd cp)))).
assert (HPerm := Permuted_sort (fst cp :: fst (snd cp) :: sscp)).
split.
intro HIn.
elim HIn.
clear HIn.
intro HIn.
elim HIn.
clear HIn.
intro HIn.

*****
HIn : In p\n (nat_rect\n (fun n : nat =>\n forall _ : cartesianPower positive (S n), list positive)\n (fun cp : cartesianPower positive (S O) => cons cp nil)\n (fun (n : nat)\n (IHn : forall _ : cartesianPower positive (S n), list positive)\n (cp : cartesianPower positive (S (S n))) =>\n cons (fst cp) (IHn (tailCP cp))) n (tailCP (tailCP cp)))
HPerm : Permutation.Permutation (cons (fst cp) (cons (fst (snd cp)) sscp))\n (sort (cons (fst cp) (cons (fst (snd cp)) sscp)))
sscp : list positive
cp : cartesianPower positive (S (S (S n)))
p : positive
n : nat
*****
In p (sort (cons (fst cp) (nat_rect (fun n : nat => forall _ : cartesianPower positive (S n), list positive) (fun cp : cartesianPower positive (S O) => cons cp nil) (fun (n : nat) (IHn : forall _ : cartesianPower positive (S n), list positive) (cp : cartesianPower positive (S (S n))) => cons (fst cp) (IHn (tailCP cp))) (S n) (tailCP cp))))
+++++
apply Permutation.Permutation_in with (fst cp :: fst (snd cp) :: sscp).
-----
Lemma InCPOCP {n : nat} : forall p (cp : cartesianPower positive (S (S n))), InCP p cp <-> InCP p (OCP cp).
Proof.
intros p cp.
unfold OCP.
unfold OCPAux.
unfold InCP.
elim_eq_rect.
simpl.
induction n.
clear IHn.
rewrite CPLOK.
set (sscp := (nat_rect (fun n : nat => cartesianPower positive (S n) -> list positive) (fun cp0 : cartesianPower positive 1 => cp0 :: nil) (fun (n : nat) (IHn : cartesianPower positive (S n) -> list positive) (cp0 : cartesianPower positive (S (S n))) => fst cp0 :: IHn (tailCP cp0)) n (tailCP (snd cp)))).
assert (HPerm := Permuted_sort (fst cp :: fst (snd cp) :: sscp)).
split.
intro HIn.
elim HIn.
clear HIn.
intro HIn.
elim HIn.
clear HIn.
intro HIn.
apply Permutation.Permutation_in with (fst cp :: fst (snd cp) :: sscp).

*****
HIn : In p\n (nat_rect\n (fun n : nat =>\n forall _ : cartesianPower positive (S n), list positive)\n (fun cp : cartesianPower positive (S O) => cons cp nil)\n (fun (n : nat)\n (IHn : forall _ : cartesianPower positive (S n), list positive)\n (cp : cartesianPower positive (S (S n))) =>\n cons (fst cp) (IHn (tailCP cp))) n (tailCP (tailCP cp)))
HPerm : Permutation.Permutation (cons (fst cp) (cons (fst (snd cp)) sscp))\n (sort (cons (fst cp) (cons (fst (snd cp)) sscp)))
sscp : list positive
cp : cartesianPower positive (S (S (S n)))
p : positive
n : nat
*****
Permutation.Permutation (cons (fst cp) (cons (fst (snd cp)) sscp)) (sort (cons (fst cp) (nat_rect (fun n : nat => forall _ : cartesianPower positive (S n), list positive) (fun cp : cartesianPower positive (S O) => cons cp nil) (fun (n : nat) (IHn : forall _ : cartesianPower positive (S n), list positive) (cp : cartesianPower positive (S (S n))) => cons (fst cp) (IHn (tailCP cp))) (S n) (tailCP cp))))
+++++
try assumption.
-----
Lemma InCPOCP {n : nat} : forall p (cp : cartesianPower positive (S (S n))), InCP p cp <-> InCP p (OCP cp).
Proof.
intros p cp.
unfold OCP.
unfold OCPAux.
unfold InCP.
elim_eq_rect.
simpl.
induction n.
clear IHn.
rewrite CPLOK.
set (sscp := (nat_rect (fun n : nat => cartesianPower positive (S n) -> list positive) (fun cp0 : cartesianPower positive 1 => cp0 :: nil) (fun (n : nat) (IHn : cartesianPower positive (S n) -> list positive) (cp0 : cartesianPower positive (S (S n))) => fst cp0 :: IHn (tailCP cp0)) n (tailCP (snd cp)))).
assert (HPerm := Permuted_sort (fst cp :: fst (snd cp) :: sscp)).
split.
intro HIn.
elim HIn.
clear HIn.
intro HIn.
elim HIn.
clear HIn.
intro HIn.
apply Permutation.Permutation_in with (fst cp :: fst (snd cp) :: sscp).

*****
HIn : In p\n (nat_rect\n (fun n : nat =>\n forall _ : cartesianPower positive (S n), list positive)\n (fun cp : cartesianPower positive (S O) => cons cp nil)\n (fun (n : nat)\n (IHn : forall _ : cartesianPower positive (S n), list positive)\n (cp : cartesianPower positive (S (S n))) =>\n cons (fst cp) (IHn (tailCP cp))) n (tailCP (tailCP cp)))
HPerm : Permutation.Permutation (cons (fst cp) (cons (fst (snd cp)) sscp))\n (sort (cons (fst cp) (cons (fst (snd cp)) sscp)))
sscp : list positive
cp : cartesianPower positive (S (S (S n)))
p : positive
n : nat
*****
In p (cons (fst cp) (cons (fst (snd cp)) sscp))
+++++
try assumption.
-----
Lemma InCPOCP {n : nat} : forall p (cp : cartesianPower positive (S (S n))), InCP p cp <-> InCP p (OCP cp).
Proof.
intros p cp.
unfold OCP.
unfold OCPAux.
unfold InCP.
elim_eq_rect.
simpl.
induction n.
clear IHn.
rewrite CPLOK.
set (sscp := (nat_rect (fun n : nat => cartesianPower positive (S n) -> list positive) (fun cp0 : cartesianPower positive 1 => cp0 :: nil) (fun (n : nat) (IHn : cartesianPower positive (S n) -> list positive) (cp0 : cartesianPower positive (S (S n))) => fst cp0 :: IHn (tailCP cp0)) n (tailCP (snd cp)))).
assert (HPerm := Permuted_sort (fst cp :: fst (snd cp) :: sscp)).
split.
intro HIn.
elim HIn.
clear HIn.
intro HIn.
elim HIn.
clear HIn.
intro HIn.
apply Permutation.Permutation_in with (fst cp :: fst (snd cp) :: sscp).
try assumption.

*****
HIn : In p\n (nat_rect\n (fun n : nat =>\n forall _ : cartesianPower positive (S n), list positive)\n (fun cp : cartesianPower positive (S O) => cons cp nil)\n (fun (n : nat)\n (IHn : forall _ : cartesianPower positive (S n), list positive)\n (cp : cartesianPower positive (S (S n))) =>\n cons (fst cp) (IHn (tailCP cp))) n (tailCP (tailCP cp)))
HPerm : Permutation.Permutation (cons (fst cp) (cons (fst (snd cp)) sscp))\n (sort (cons (fst cp) (cons (fst (snd cp)) sscp)))
sscp : list positive
cp : cartesianPower positive (S (S (S n)))
p : positive
n : nat
*****
In p (cons (fst cp) (cons (fst (snd cp)) sscp))
+++++
do 2 (apply in_cons).
-----
Lemma InCPOCP {n : nat} : forall p (cp : cartesianPower positive (S (S n))), InCP p cp <-> InCP p (OCP cp).
Proof.
intros p cp.
unfold OCP.
unfold OCPAux.
unfold InCP.
elim_eq_rect.
simpl.
induction n.
clear IHn.
rewrite CPLOK.
set (sscp := (nat_rect (fun n : nat => cartesianPower positive (S n) -> list positive) (fun cp0 : cartesianPower positive 1 => cp0 :: nil) (fun (n : nat) (IHn : cartesianPower positive (S n) -> list positive) (cp0 : cartesianPower positive (S (S n))) => fst cp0 :: IHn (tailCP cp0)) n (tailCP (snd cp)))).
assert (HPerm := Permuted_sort (fst cp :: fst (snd cp) :: sscp)).
split.
intro HIn.
elim HIn.
clear HIn.
intro HIn.
elim HIn.
clear HIn.
intro HIn.
apply Permutation.Permutation_in with (fst cp :: fst (snd cp) :: sscp).
try assumption.
do 2 (apply in_cons).

*****
HIn : In p\n (nat_rect\n (fun n : nat =>\n forall _ : cartesianPower positive (S n), list positive)\n (fun cp : cartesianPower positive (S O) => cons cp nil)\n (fun (n : nat)\n (IHn : forall _ : cartesianPower positive (S n), list positive)\n (cp : cartesianPower positive (S (S n))) =>\n cons (fst cp) (IHn (tailCP cp))) n (tailCP (tailCP cp)))
HPerm : Permutation.Permutation (cons (fst cp) (cons (fst (snd cp)) sscp))\n (sort (cons (fst cp) (cons (fst (snd cp)) sscp)))
sscp : list positive
cp : cartesianPower positive (S (S (S n)))
p : positive
n : nat
*****
In p sscp
+++++
assumption.
-----
Lemma InCPOCP {n : nat} : forall p (cp : cartesianPower positive (S (S n))), InCP p cp <-> InCP p (OCP cp).
Proof.
intros p cp.
unfold OCP.
unfold OCPAux.
unfold InCP.
elim_eq_rect.
simpl.
induction n.
clear IHn.
rewrite CPLOK.
set (sscp := (nat_rect (fun n : nat => cartesianPower positive (S n) -> list positive) (fun cp0 : cartesianPower positive 1 => cp0 :: nil) (fun (n : nat) (IHn : cartesianPower positive (S n) -> list positive) (cp0 : cartesianPower positive (S (S n))) => fst cp0 :: IHn (tailCP cp0)) n (tailCP (snd cp)))).
assert (HPerm := Permuted_sort (fst cp :: fst (snd cp) :: sscp)).
split.

*****
HPerm : Permutation.Permutation (cons (fst cp) (cons (fst (snd cp)) sscp))\n (sort (cons (fst cp) (cons (fst (snd cp)) sscp)))
sscp : list positive
cp : cartesianPower positive (S (S (S n)))
p : positive
n : nat
*****
forall _ : In p (sort (cons (fst cp) (nat_rect (fun n : nat => forall _ : cartesianPower positive (S n), list positive) (fun cp : cartesianPower positive (S O) => cons cp nil) (fun (n : nat) (IHn : forall _ : cartesianPower positive (S n), list positive) (cp : cartesianPower positive (S (S n))) => cons (fst cp) (IHn (tailCP cp))) (S n) (tailCP cp)))), or (eq (fst cp) p) (In p (nat_rect (fun n : nat => forall _ : cartesianPower positive (S n), list positive) (fun cp : cartesianPower positive (S O) => cons cp nil) (fun (n : nat) (IHn : forall _ : cartesianPower positive (S n), list positive) (cp : cartesianPower positive (S (S n))) => cons (fst cp) (IHn (tailCP cp))) (S n) (tailCP cp)))
+++++
intro HIn.
-----
Lemma InCPOCP {n : nat} : forall p (cp : cartesianPower positive (S (S n))), InCP p cp <-> InCP p (OCP cp).
Proof.
intros p cp.
unfold OCP.
unfold OCPAux.
unfold InCP.
elim_eq_rect.
simpl.
induction n.
clear IHn.
rewrite CPLOK.
set (sscp := (nat_rect (fun n : nat => cartesianPower positive (S n) -> list positive) (fun cp0 : cartesianPower positive 1 => cp0 :: nil) (fun (n : nat) (IHn : cartesianPower positive (S n) -> list positive) (cp0 : cartesianPower positive (S (S n))) => fst cp0 :: IHn (tailCP cp0)) n (tailCP (snd cp)))).
assert (HPerm := Permuted_sort (fst cp :: fst (snd cp) :: sscp)).
split.
intro HIn.

*****
HIn : In p\n (sort\n (cons (fst cp)\n (nat_rect\n (fun n : nat =>\n forall _ : cartesianPower positive (S n), list positive)\n (fun cp : cartesianPower positive (S O) => cons cp nil)\n (fun (n : nat)\n (IHn : forall _ : cartesianPower positive (S n),\n list positive)\n (cp : cartesianPower positive (S (S n))) =>\n cons (fst cp) (IHn (tailCP cp))) (S n) \n (tailCP cp))))
HPerm : Permutation.Permutation (cons (fst cp) (cons (fst (snd cp)) sscp))\n (sort (cons (fst cp) (cons (fst (snd cp)) sscp)))
sscp : list positive
cp : cartesianPower positive (S (S (S n)))
p : positive
n : nat
*****
or (eq (fst cp) p) (In p (nat_rect (fun n : nat => forall _ : cartesianPower positive (S n), list positive) (fun cp : cartesianPower positive (S O) => cons cp nil) (fun (n : nat) (IHn : forall _ : cartesianPower positive (S n), list positive) (cp : cartesianPower positive (S (S n))) => cons (fst cp) (IHn (tailCP cp))) (S n) (tailCP cp)))
+++++
apply Permutation.Permutation_sym in HPerm.
-----
Lemma InCPOCP {n : nat} : forall p (cp : cartesianPower positive (S (S n))), InCP p cp <-> InCP p (OCP cp).
Proof.
intros p cp.
unfold OCP.
unfold OCPAux.
unfold InCP.
elim_eq_rect.
simpl.
induction n.
clear IHn.
rewrite CPLOK.
set (sscp := (nat_rect (fun n : nat => cartesianPower positive (S n) -> list positive) (fun cp0 : cartesianPower positive 1 => cp0 :: nil) (fun (n : nat) (IHn : cartesianPower positive (S n) -> list positive) (cp0 : cartesianPower positive (S (S n))) => fst cp0 :: IHn (tailCP cp0)) n (tailCP (snd cp)))).
assert (HPerm := Permuted_sort (fst cp :: fst (snd cp) :: sscp)).
split.
intro HIn.
apply Permutation.Permutation_sym in HPerm.

*****
HIn : In p\n (sort\n (cons (fst cp)\n (nat_rect\n (fun n : nat =>\n forall _ : cartesianPower positive (S n), list positive)\n (fun cp : cartesianPower positive (S O) => cons cp nil)\n (fun (n : nat)\n (IHn : forall _ : cartesianPower positive (S n),\n list positive)\n (cp : cartesianPower positive (S (S n))) =>\n cons (fst cp) (IHn (tailCP cp))) (S n) \n (tailCP cp))))
HPerm : Permutation.Permutation\n (sort (cons (fst cp) (cons (fst (snd cp)) sscp)))\n (cons (fst cp) (cons (fst (snd cp)) sscp))
sscp : list positive
cp : cartesianPower positive (S (S (S n)))
p : positive
n : nat
*****
or (eq (fst cp) p) (In p (nat_rect (fun n : nat => forall _ : cartesianPower positive (S n), list positive) (fun cp : cartesianPower positive (S O) => cons cp nil) (fun (n : nat) (IHn : forall _ : cartesianPower positive (S n), list positive) (cp : cartesianPower positive (S (S n))) => cons (fst cp) (IHn (tailCP cp))) (S n) (tailCP cp)))
+++++
assert (HInOKAux := Permutation.Permutation_in).
-----
Lemma InCPOCP {n : nat} : forall p (cp : cartesianPower positive (S (S n))), InCP p cp <-> InCP p (OCP cp).
Proof.
intros p cp.
unfold OCP.
unfold OCPAux.
unfold InCP.
elim_eq_rect.
simpl.
induction n.
clear IHn.
rewrite CPLOK.
set (sscp := (nat_rect (fun n : nat => cartesianPower positive (S n) -> list positive) (fun cp0 : cartesianPower positive 1 => cp0 :: nil) (fun (n : nat) (IHn : cartesianPower positive (S n) -> list positive) (cp0 : cartesianPower positive (S (S n))) => fst cp0 :: IHn (tailCP cp0)) n (tailCP (snd cp)))).
assert (HPerm := Permuted_sort (fst cp :: fst (snd cp) :: sscp)).
split.
intro HIn.
apply Permutation.Permutation_sym in HPerm.
assert (HInOKAux := Permutation.Permutation_in).

*****
HInOKAux : forall (A : Type) (l l' : list A) (x : A)\n (_ : Permutation.Permutation l l') (_ : In x l), \nIn x l'
HIn : In p\n (sort\n (cons (fst cp)\n (nat_rect\n (fun n : nat =>\n forall _ : cartesianPower positive (S n), list positive)\n (fun cp : cartesianPower positive (S O) => cons cp nil)\n (fun (n : nat)\n (IHn : forall _ : cartesianPower positive (S n),\n list positive)\n (cp : cartesianPower positive (S (S n))) =>\n cons (fst cp) (IHn (tailCP cp))) (S n) \n (tailCP cp))))
HPerm : Permutation.Permutation\n (sort (cons (fst cp) (cons (fst (snd cp)) sscp)))\n (cons (fst cp) (cons (fst (snd cp)) sscp))
sscp : list positive
cp : cartesianPower positive (S (S (S n)))
p : positive
n : nat
*****
or (eq (fst cp) p) (In p (nat_rect (fun n : nat => forall _ : cartesianPower positive (S n), list positive) (fun cp : cartesianPower positive (S O) => cons cp nil) (fun (n : nat) (IHn : forall _ : cartesianPower positive (S n), list positive) (cp : cartesianPower positive (S (S n))) => cons (fst cp) (IHn (tailCP cp))) (S n) (tailCP cp)))
+++++
assert (HInOK := HInOKAux positive (sort (fst cp :: fst (snd cp) :: sscp)) (fst cp :: fst (snd cp) :: sscp) p HPerm HIn).
-----
Lemma InCPOCP {n : nat} : forall p (cp : cartesianPower positive (S (S n))), InCP p cp <-> InCP p (OCP cp).
Proof.
intros p cp.
unfold OCP.
unfold OCPAux.
unfold InCP.
elim_eq_rect.
simpl.
induction n.
clear IHn.
rewrite CPLOK.
set (sscp := (nat_rect (fun n : nat => cartesianPower positive (S n) -> list positive) (fun cp0 : cartesianPower positive 1 => cp0 :: nil) (fun (n : nat) (IHn : cartesianPower positive (S n) -> list positive) (cp0 : cartesianPower positive (S (S n))) => fst cp0 :: IHn (tailCP cp0)) n (tailCP (snd cp)))).
assert (HPerm := Permuted_sort (fst cp :: fst (snd cp) :: sscp)).
split.
intro HIn.
apply Permutation.Permutation_sym in HPerm.
assert (HInOKAux := Permutation.Permutation_in).
assert (HInOK := HInOKAux positive (sort (fst cp :: fst (snd cp) :: sscp)) (fst cp :: fst (snd cp) :: sscp) p HPerm HIn).

*****
HInOK : In p (cons (fst cp) (cons (fst (snd cp)) sscp))
HInOKAux : forall (A : Type) (l l' : list A) (x : A)\n (_ : Permutation.Permutation l l') (_ : In x l), \nIn x l'
HIn : In p\n (sort\n (cons (fst cp)\n (nat_rect\n (fun n : nat =>\n forall _ : cartesianPower positive (S n), list positive)\n (fun cp : cartesianPower positive (S O) => cons cp nil)\n (fun (n : nat)\n (IHn : forall _ : cartesianPower positive (S n),\n list positive)\n (cp : cartesianPower positive (S (S n))) =>\n cons (fst cp) (IHn (tailCP cp))) (S n) \n (tailCP cp))))
HPerm : Permutation.Permutation\n (sort (cons (fst cp) (cons (fst (snd cp)) sscp)))\n (cons (fst cp) (cons (fst (snd cp)) sscp))
sscp : list positive
cp : cartesianPower positive (S (S (S n)))
p : positive
n : nat
*****
or (eq (fst cp) p) (In p (nat_rect (fun n : nat => forall _ : cartesianPower positive (S n), list positive) (fun cp : cartesianPower positive (S O) => cons cp nil) (fun (n : nat) (IHn : forall _ : cartesianPower positive (S n), list positive) (cp : cartesianPower positive (S (S n))) => cons (fst cp) (IHn (tailCP cp))) (S n) (tailCP cp)))
+++++
clear HInOKAux.
-----
Lemma InCPOCP {n : nat} : forall p (cp : cartesianPower positive (S (S n))), InCP p cp <-> InCP p (OCP cp).
Proof.
intros p cp.
unfold OCP.
unfold OCPAux.
unfold InCP.
elim_eq_rect.
simpl.
induction n.
clear IHn.
rewrite CPLOK.
set (sscp := (nat_rect (fun n : nat => cartesianPower positive (S n) -> list positive) (fun cp0 : cartesianPower positive 1 => cp0 :: nil) (fun (n : nat) (IHn : cartesianPower positive (S n) -> list positive) (cp0 : cartesianPower positive (S (S n))) => fst cp0 :: IHn (tailCP cp0)) n (tailCP (snd cp)))).
assert (HPerm := Permuted_sort (fst cp :: fst (snd cp) :: sscp)).
split.
intro HIn.
apply Permutation.Permutation_sym in HPerm.
assert (HInOKAux := Permutation.Permutation_in).
assert (HInOK := HInOKAux positive (sort (fst cp :: fst (snd cp) :: sscp)) (fst cp :: fst (snd cp) :: sscp) p HPerm HIn).
clear HInOKAux.

*****
HInOK : In p (cons (fst cp) (cons (fst (snd cp)) sscp))
HIn : In p\n (sort\n (cons (fst cp)\n (nat_rect\n (fun n : nat =>\n forall _ : cartesianPower positive (S n), list positive)\n (fun cp : cartesianPower positive (S O) => cons cp nil)\n (fun (n : nat)\n (IHn : forall _ : cartesianPower positive (S n),\n list positive)\n (cp : cartesianPower positive (S (S n))) =>\n cons (fst cp) (IHn (tailCP cp))) (S n) \n (tailCP cp))))
HPerm : Permutation.Permutation\n (sort (cons (fst cp) (cons (fst (snd cp)) sscp)))\n (cons (fst cp) (cons (fst (snd cp)) sscp))
sscp : list positive
cp : cartesianPower positive (S (S (S n)))
p : positive
n : nat
*****
or (eq (fst cp) p) (In p (nat_rect (fun n : nat => forall _ : cartesianPower positive (S n), list positive) (fun cp : cartesianPower positive (S O) => cons cp nil) (fun (n : nat) (IHn : forall _ : cartesianPower positive (S n), list positive) (cp : cartesianPower positive (S (S n))) => cons (fst cp) (IHn (tailCP cp))) (S n) (tailCP cp)))
+++++
clear HIn.
-----
Lemma InCPOCP {n : nat} : forall p (cp : cartesianPower positive (S (S n))), InCP p cp <-> InCP p (OCP cp).
Proof.
intros p cp.
unfold OCP.
unfold OCPAux.
unfold InCP.
elim_eq_rect.
simpl.
induction n.
clear IHn.
rewrite CPLOK.
set (sscp := (nat_rect (fun n : nat => cartesianPower positive (S n) -> list positive) (fun cp0 : cartesianPower positive 1 => cp0 :: nil) (fun (n : nat) (IHn : cartesianPower positive (S n) -> list positive) (cp0 : cartesianPower positive (S (S n))) => fst cp0 :: IHn (tailCP cp0)) n (tailCP (snd cp)))).
assert (HPerm := Permuted_sort (fst cp :: fst (snd cp) :: sscp)).
split.
intro HIn.
apply Permutation.Permutation_sym in HPerm.
assert (HInOKAux := Permutation.Permutation_in).
assert (HInOK := HInOKAux positive (sort (fst cp :: fst (snd cp) :: sscp)) (fst cp :: fst (snd cp) :: sscp) p HPerm HIn).
clear HInOKAux.
clear HIn.

*****
HInOK : In p (cons (fst cp) (cons (fst (snd cp)) sscp))
HPerm : Permutation.Permutation\n (sort (cons (fst cp) (cons (fst (snd cp)) sscp)))\n (cons (fst cp) (cons (fst (snd cp)) sscp))
sscp : list positive
cp : cartesianPower positive (S (S (S n)))
p : positive
n : nat
*****
or (eq (fst cp) p) (In p (nat_rect (fun n : nat => forall _ : cartesianPower positive (S n), list positive) (fun cp : cartesianPower positive (S O) => cons cp nil) (fun (n : nat) (IHn : forall _ : cartesianPower positive (S n), list positive) (cp : cartesianPower positive (S (S n))) => cons (fst cp) (IHn (tailCP cp))) (S n) (tailCP cp)))
+++++
rename HInOK into HIn.
-----
Lemma InCPOCP {n : nat} : forall p (cp : cartesianPower positive (S (S n))), InCP p cp <-> InCP p (OCP cp).
Proof.
intros p cp.
unfold OCP.
unfold OCPAux.
unfold InCP.
elim_eq_rect.
simpl.
induction n.
clear IHn.
rewrite CPLOK.
set (sscp := (nat_rect (fun n : nat => cartesianPower positive (S n) -> list positive) (fun cp0 : cartesianPower positive 1 => cp0 :: nil) (fun (n : nat) (IHn : cartesianPower positive (S n) -> list positive) (cp0 : cartesianPower positive (S (S n))) => fst cp0 :: IHn (tailCP cp0)) n (tailCP (snd cp)))).
assert (HPerm := Permuted_sort (fst cp :: fst (snd cp) :: sscp)).
split.
intro HIn.
apply Permutation.Permutation_sym in HPerm.
assert (HInOKAux := Permutation.Permutation_in).
assert (HInOK := HInOKAux positive (sort (fst cp :: fst (snd cp) :: sscp)) (fst cp :: fst (snd cp) :: sscp) p HPerm HIn).
clear HInOKAux.
clear HIn.
rename HInOK into HIn.

*****
HIn : In p (cons (fst cp) (cons (fst (snd cp)) sscp))
HPerm : Permutation.Permutation\n (sort (cons (fst cp) (cons (fst (snd cp)) sscp)))\n (cons (fst cp) (cons (fst (snd cp)) sscp))
sscp : list positive
cp : cartesianPower positive (S (S (S n)))
p : positive
n : nat
*****
or (eq (fst cp) p) (In p (nat_rect (fun n : nat => forall _ : cartesianPower positive (S n), list positive) (fun cp : cartesianPower positive (S O) => cons cp nil) (fun (n : nat) (IHn : forall _ : cartesianPower positive (S n), list positive) (cp : cartesianPower positive (S (S n))) => cons (fst cp) (IHn (tailCP cp))) (S n) (tailCP cp)))
+++++
assumption.
-----
Lemma InCPOCP {n : nat} : forall p (cp : cartesianPower positive (S (S n))), InCP p cp <-> InCP p (OCP cp).
Proof.
intros p cp.
unfold OCP.
unfold OCPAux.
unfold InCP.
elim_eq_rect.
simpl.
induction n.

*****

*****

+++++
Qed.
-----
Section Set_of_tuple_of_positive.
-----
Context {Ar : Arity}.
-----
Fixpoint eqList (l1 l2 : list positive) :=\n    match l1, l2 with\n      | nil, nil => True\n      | (hd1 :: tl1), (hd2 :: tl2) => (Pos.eq hd1 hd2) /\ (eqList tl1 tl2)\n      | _, _ => False\n    end.
-----
Lemma eqListRefl : forall l, eqList l l.
-----
Lemma eqListRefl : forall l, eqList l l.

*****
Ar : Arity
*****
forall l : list positive, eqList l l
+++++
Proof.
-----
Lemma eqListRefl : forall l, eqList l l.
Proof.

*****
Ar : Arity
*****
forall l : list positive, eqList l l
+++++
intro l.
-----
Lemma eqListRefl : forall l, eqList l l.
Proof.
intro l.

*****
l : list positive
Ar : Arity
*****
eqList l l
+++++
induction l.
-----
Lemma eqListRefl : forall l, eqList l l.
Proof.
intro l.
induction l.

*****
Ar : Arity
*****
eqList nil nil
+++++
simpl.
-----
Lemma eqListRefl : forall l, eqList l l.
Proof.
intro l.
induction l.
simpl.

*****
Ar : Arity
*****
True
+++++
trivial.
-----
Lemma eqListRefl : forall l, eqList l l.
Proof.
intro l.
induction l.

*****
IHl : eqList l l
l : list positive
a : positive
Ar : Arity
*****
eqList (cons a l) (cons a l)
+++++
simpl.
-----
Lemma eqListRefl : forall l, eqList l l.
Proof.
intro l.
induction l.
simpl.

*****
IHl : eqList l l
l : list positive
a : positive
Ar : Arity
*****
and (Pos.eq a a) (eqList l l)
+++++
split.
-----
Lemma eqListRefl : forall l, eqList l l.
Proof.
intro l.
induction l.
simpl.
split.

*****
IHl : eqList l l
l : list positive
a : positive
Ar : Arity
*****
Pos.eq a a
+++++
try assumption.
-----
Lemma eqListRefl : forall l, eqList l l.
Proof.
intro l.
induction l.
simpl.
split.
try assumption.

*****
IHl : eqList l l
l : list positive
a : positive
Ar : Arity
*****
Pos.eq a a
+++++
reflexivity.
-----
Lemma eqListRefl : forall l, eqList l l.
Proof.
intro l.
induction l.
simpl.
split.

*****
IHl : eqList l l
l : list positive
a : positive
Ar : Arity
*****
eqList l l
+++++
try assumption.
-----
Lemma eqListRefl : forall l, eqList l l.
Proof.
intro l.
induction l.

*****

*****

+++++
Qed.
-----
Lemma eqListSym : forall l l', eqList l l' -> eqList l' l.
-----
Lemma eqListSym : forall l l', eqList l l' -> eqList l' l.

*****
Ar : Arity
*****
forall (l l' : list positive) (_ : eqList l l'), eqList l' l
+++++
Proof.
-----
Lemma eqListSym : forall l l', eqList l l' -> eqList l' l.
Proof.

*****
Ar : Arity
*****
forall (l l' : list positive) (_ : eqList l l'), eqList l' l
+++++
intro l.
-----
Lemma eqListSym : forall l l', eqList l l' -> eqList l' l.
Proof.
intro l.

*****
l : list positive
Ar : Arity
*****
forall (l' : list positive) (_ : eqList l l'), eqList l' l
+++++
induction l.
-----
Lemma eqListSym : forall l l', eqList l l' -> eqList l' l.
Proof.
intro l.
induction l.

*****
Ar : Arity
*****
forall (l' : list positive) (_ : eqList nil l'), eqList l' nil
+++++
intro l'.
-----
Lemma eqListSym : forall l l', eqList l l' -> eqList l' l.
Proof.
intro l.
induction l.
intro l'.

*****
l' : list positive
Ar : Arity
*****
forall _ : eqList nil l', eqList l' nil
+++++
induction l'.
-----
Lemma eqListSym : forall l l', eqList l l' -> eqList l' l.
Proof.
intro l.
induction l.
intro l'.
induction l'.

*****
Ar : Arity
*****
forall _ : eqList nil nil, eqList nil nil
+++++
auto.
-----
Lemma eqListSym : forall l l', eqList l l' -> eqList l' l.
Proof.
intro l.
induction l.
intro l'.
induction l'.

*****
IHl' : forall _ : eqList nil l', eqList l' nil
l' : list positive
a : positive
Ar : Arity
*****
forall _ : eqList nil (cons a l'), eqList (cons a l') nil
+++++
auto.
-----
Lemma eqListSym : forall l l', eqList l l' -> eqList l' l.
Proof.
intro l.
induction l.

*****
IHl : forall (l' : list positive) (_ : eqList l l'), eqList l' l
l : list positive
a : positive
Ar : Arity
*****
forall (l' : list positive) (_ : eqList (cons a l) l'), eqList l' (cons a l)
+++++
intro l'.
-----
Lemma eqListSym : forall l l', eqList l l' -> eqList l' l.
Proof.
intro l.
induction l.
intro l'.

*****
l' : list positive
IHl : forall (l' : list positive) (_ : eqList l l'), eqList l' l
l : list positive
a : positive
Ar : Arity
*****
forall _ : eqList (cons a l) l', eqList l' (cons a l)
+++++
induction l'.
-----
Lemma eqListSym : forall l l', eqList l l' -> eqList l' l.
Proof.
intro l.
induction l.
intro l'.
induction l'.

*****
IHl : forall (l' : list positive) (_ : eqList l l'), eqList l' l
l : list positive
a : positive
Ar : Arity
*****
forall _ : eqList (cons a l) nil, eqList nil (cons a l)
+++++
auto.
-----
Lemma eqListSym : forall l l', eqList l l' -> eqList l' l.
Proof.
intro l.
induction l.
intro l'.
induction l'.

*****
IHl' : forall _ : eqList (cons a l) l', eqList l' (cons a l)
l' : list positive
a0 : positive
IHl : forall (l' : list positive) (_ : eqList l l'), eqList l' l
l : list positive
a : positive
Ar : Arity
*****
forall _ : eqList (cons a l) (cons a0 l'), eqList (cons a0 l') (cons a l)
+++++
auto.
-----
Lemma eqListSym : forall l l', eqList l l' -> eqList l' l.
Proof.
intro l.
induction l.
intro l'.
induction l'.
auto.

*****
IHl' : forall _ : eqList (cons a l) l', eqList l' (cons a l)
l' : list positive
a0 : positive
IHl : forall (l' : list positive) (_ : eqList l l'), eqList l' l
l : list positive
a : positive
Ar : Arity
*****
forall _ : eqList (cons a l) (cons a0 l'), eqList (cons a0 l') (cons a l)
+++++
simpl.
-----
Lemma eqListSym : forall l l', eqList l l' -> eqList l' l.
Proof.
intro l.
induction l.
intro l'.
induction l'.
auto.
simpl.

*****
IHl' : forall _ : eqList (cons a l) l', eqList l' (cons a l)
l' : list positive
a0 : positive
IHl : forall (l' : list positive) (_ : eqList l l'), eqList l' l
l : list positive
a : positive
Ar : Arity
*****
forall _ : and (Pos.eq a a0) (eqList l l'), and (Pos.eq a0 a) (eqList l' l)
+++++
intro H.
-----
Lemma eqListSym : forall l l', eqList l l' -> eqList l' l.
Proof.
intro l.
induction l.
intro l'.
induction l'.
auto.
simpl.
intro H.

*****
H : and (Pos.eq a a0) (eqList l l')
IHl' : forall _ : eqList (cons a l) l', eqList l' (cons a l)
l' : list positive
a0 : positive
IHl : forall (l' : list positive) (_ : eqList l l'), eqList l' l
l : list positive
a : positive
Ar : Arity
*****
and (Pos.eq a0 a) (eqList l' l)
+++++
destruct H as [Haa0 Hll'].
-----
Lemma eqListSym : forall l l', eqList l l' -> eqList l' l.
Proof.
intro l.
induction l.
intro l'.
induction l'.
auto.
simpl.
intro H.
destruct H as [Haa0 Hll'].

*****
Hll' : eqList l l'
Haa0 : Pos.eq a a0
IHl' : forall _ : eqList (cons a l) l', eqList l' (cons a l)
l' : list positive
a0 : positive
IHl : forall (l' : list positive) (_ : eqList l l'), eqList l' l
l : list positive
a : positive
Ar : Arity
*****
and (Pos.eq a0 a) (eqList l' l)
+++++
split.
-----
Lemma eqListSym : forall l l', eqList l l' -> eqList l' l.
Proof.
intro l.
induction l.
intro l'.
induction l'.
auto.
simpl.
intro H.
destruct H as [Haa0 Hll'].
split.

*****
Hll' : eqList l l'
Haa0 : Pos.eq a a0
IHl' : forall _ : eqList (cons a l) l', eqList l' (cons a l)
l' : list positive
a0 : positive
IHl : forall (l' : list positive) (_ : eqList l l'), eqList l' l
l : list positive
a : positive
Ar : Arity
*****
Pos.eq a0 a
+++++
intuition.
-----
Lemma eqListSym : forall l l', eqList l l' -> eqList l' l.
Proof.
intro l.
induction l.
intro l'.
induction l'.
auto.
simpl.
intro H.
destruct H as [Haa0 Hll'].
split.

*****
Hll' : eqList l l'
Haa0 : Pos.eq a a0
IHl' : forall _ : eqList (cons a l) l', eqList l' (cons a l)
l' : list positive
a0 : positive
IHl : forall (l' : list positive) (_ : eqList l l'), eqList l' l
l : list positive
a : positive
Ar : Arity
*****
eqList l' l
+++++
intuition.
-----
Lemma eqListSym : forall l l', eqList l l' -> eqList l' l.
Proof.
intro l.
induction l.

*****

*****

+++++
Qed.
-----
Lemma eqListTrans : forall l1 l2 l3, eqList l1 l2 -> eqList l2 l3 -> eqList l1 l3.
-----
Lemma eqListTrans : forall l1 l2 l3, eqList l1 l2 -> eqList l2 l3 -> eqList l1 l3.

*****
Ar : Arity
*****
forall (l1 l2 l3 : list positive) (_ : eqList l1 l2) (_ : eqList l2 l3), eqList l1 l3
+++++
Proof.
-----
Lemma eqListTrans : forall l1 l2 l3, eqList l1 l2 -> eqList l2 l3 -> eqList l1 l3.
Proof.

*****
Ar : Arity
*****
forall (l1 l2 l3 : list positive) (_ : eqList l1 l2) (_ : eqList l2 l3), eqList l1 l3
+++++
intro l1.
-----
Lemma eqListTrans : forall l1 l2 l3, eqList l1 l2 -> eqList l2 l3 -> eqList l1 l3.
Proof.
intro l1.

*****
l1 : list positive
Ar : Arity
*****
forall (l2 l3 : list positive) (_ : eqList l1 l2) (_ : eqList l2 l3), eqList l1 l3
+++++
induction l1.
-----
Lemma eqListTrans : forall l1 l2 l3, eqList l1 l2 -> eqList l2 l3 -> eqList l1 l3.
Proof.
intro l1.
induction l1.

*****
Ar : Arity
*****
forall (l2 l3 : list positive) (_ : eqList nil l2) (_ : eqList l2 l3), eqList nil l3
+++++
intro l2.
-----
Lemma eqListTrans : forall l1 l2 l3, eqList l1 l2 -> eqList l2 l3 -> eqList l1 l3.
Proof.
intro l1.
induction l1.
intro l2.

*****
l2 : list positive
Ar : Arity
*****
forall (l3 : list positive) (_ : eqList nil l2) (_ : eqList l2 l3), eqList nil l3
+++++
induction l2.
-----
Lemma eqListTrans : forall l1 l2 l3, eqList l1 l2 -> eqList l2 l3 -> eqList l1 l3.
Proof.
intro l1.
induction l1.
intro l2.
induction l2.

*****
Ar : Arity
*****
forall (l3 : list positive) (_ : eqList nil nil) (_ : eqList nil l3), eqList nil l3
+++++
intro l3.
-----
Lemma eqListTrans : forall l1 l2 l3, eqList l1 l2 -> eqList l2 l3 -> eqList l1 l3.
Proof.
intro l1.
induction l1.
intro l2.
induction l2.
intro l3.

*****
l3 : list positive
Ar : Arity
*****
forall (_ : eqList nil nil) (_ : eqList nil l3), eqList nil l3
+++++
induction l3.
-----
Lemma eqListTrans : forall l1 l2 l3, eqList l1 l2 -> eqList l2 l3 -> eqList l1 l3.
Proof.
intro l1.
induction l1.
intro l2.
induction l2.
intro l3.
induction l3.

*****
Ar : Arity
*****
forall (_ : eqList nil nil) (_ : eqList nil nil), eqList nil nil
+++++
simpl.
-----
Lemma eqListTrans : forall l1 l2 l3, eqList l1 l2 -> eqList l2 l3 -> eqList l1 l3.
Proof.
intro l1.
induction l1.
intro l2.
induction l2.
intro l3.
induction l3.
simpl.

*****
Ar : Arity
*****
forall (_ : True) (_ : True), True
+++++
trivial.
-----
Lemma eqListTrans : forall l1 l2 l3, eqList l1 l2 -> eqList l2 l3 -> eqList l1 l3.
Proof.
intro l1.
induction l1.
intro l2.
induction l2.
intro l3.
induction l3.

*****
IHl3 : forall (_ : eqList nil nil) (_ : eqList nil l3), eqList nil l3
l3 : list positive
a : positive
Ar : Arity
*****
forall (_ : eqList nil nil) (_ : eqList nil (cons a l3)), eqList nil (cons a l3)
+++++
simpl.
-----
Lemma eqListTrans : forall l1 l2 l3, eqList l1 l2 -> eqList l2 l3 -> eqList l1 l3.
Proof.
intro l1.
induction l1.
intro l2.
induction l2.
intro l3.
induction l3.
simpl.

*****
IHl3 : forall (_ : eqList nil nil) (_ : eqList nil l3), eqList nil l3
l3 : list positive
a : positive
Ar : Arity
*****
forall (_ : True) (_ : False), False
+++++
intuition.
-----
Lemma eqListTrans : forall l1 l2 l3, eqList l1 l2 -> eqList l2 l3 -> eqList l1 l3.
Proof.
intro l1.
induction l1.
intro l2.
induction l2.

*****
IHl2 : forall (l3 : list positive) (_ : eqList nil l2) (_ : eqList l2 l3),\neqList nil l3
l2 : list positive
a : positive
Ar : Arity
*****
forall (l3 : list positive) (_ : eqList nil (cons a l2)) (_ : eqList (cons a l2) l3), eqList nil l3
+++++
simpl.
-----
Lemma eqListTrans : forall l1 l2 l3, eqList l1 l2 -> eqList l2 l3 -> eqList l1 l3.
Proof.
intro l1.
induction l1.
intro l2.
induction l2.
simpl.

*****
IHl2 : forall (l3 : list positive) (_ : eqList nil l2) (_ : eqList l2 l3),\neqList nil l3
l2 : list positive
a : positive
Ar : Arity
*****
forall (l3 : list positive) (_ : False) (_ : match l3 with | nil => False | cons hd2 tl2 => and (Pos.eq a hd2) (eqList l2 tl2) end), match l3 with | nil => True | cons _ _ => False end
+++++
intuition.
-----
Lemma eqListTrans : forall l1 l2 l3, eqList l1 l2 -> eqList l2 l3 -> eqList l1 l3.
Proof.
intro l1.
induction l1.

*****
IHl1 : forall (l2 l3 : list positive) (_ : eqList l1 l2) (_ : eqList l2 l3),\neqList l1 l3
l1 : list positive
a : positive
Ar : Arity
*****
forall (l2 l3 : list positive) (_ : eqList (cons a l1) l2) (_ : eqList l2 l3), eqList (cons a l1) l3
+++++
intro l2.
-----
Lemma eqListTrans : forall l1 l2 l3, eqList l1 l2 -> eqList l2 l3 -> eqList l1 l3.
Proof.
intro l1.
induction l1.
intro l2.

*****
l2 : list positive
IHl1 : forall (l2 l3 : list positive) (_ : eqList l1 l2) (_ : eqList l2 l3),\neqList l1 l3
l1 : list positive
a : positive
Ar : Arity
*****
forall (l3 : list positive) (_ : eqList (cons a l1) l2) (_ : eqList l2 l3), eqList (cons a l1) l3
+++++
induction l2.
-----
Lemma eqListTrans : forall l1 l2 l3, eqList l1 l2 -> eqList l2 l3 -> eqList l1 l3.
Proof.
intro l1.
induction l1.
intro l2.
induction l2.

*****
IHl1 : forall (l2 l3 : list positive) (_ : eqList l1 l2) (_ : eqList l2 l3),\neqList l1 l3
l1 : list positive
a : positive
Ar : Arity
*****
forall (l3 : list positive) (_ : eqList (cons a l1) nil) (_ : eqList nil l3), eqList (cons a l1) l3
+++++
intro l3.
-----
Lemma eqListTrans : forall l1 l2 l3, eqList l1 l2 -> eqList l2 l3 -> eqList l1 l3.
Proof.
intro l1.
induction l1.
intro l2.
induction l2.
intro l3.

*****
l3 : list positive
IHl1 : forall (l2 l3 : list positive) (_ : eqList l1 l2) (_ : eqList l2 l3),\neqList l1 l3
l1 : list positive
a : positive
Ar : Arity
*****
forall (_ : eqList (cons a l1) nil) (_ : eqList nil l3), eqList (cons a l1) l3
+++++
induction l3.
-----
Lemma eqListTrans : forall l1 l2 l3, eqList l1 l2 -> eqList l2 l3 -> eqList l1 l3.
Proof.
intro l1.
induction l1.
intro l2.
induction l2.
intro l3.
induction l3.

*****
IHl1 : forall (l2 l3 : list positive) (_ : eqList l1 l2) (_ : eqList l2 l3),\neqList l1 l3
l1 : list positive
a : positive
Ar : Arity
*****
forall (_ : eqList (cons a l1) nil) (_ : eqList nil nil), eqList (cons a l1) nil
+++++
simpl.
-----
Lemma eqListTrans : forall l1 l2 l3, eqList l1 l2 -> eqList l2 l3 -> eqList l1 l3.
Proof.
intro l1.
induction l1.
intro l2.
induction l2.
intro l3.
induction l3.
simpl.

*****
IHl1 : forall (l2 l3 : list positive) (_ : eqList l1 l2) (_ : eqList l2 l3),\neqList l1 l3
l1 : list positive
a : positive
Ar : Arity
*****
forall (_ : False) (_ : True), False
+++++
trivial.
-----
Lemma eqListTrans : forall l1 l2 l3, eqList l1 l2 -> eqList l2 l3 -> eqList l1 l3.
Proof.
intro l1.
induction l1.
intro l2.
induction l2.
intro l3.
induction l3.

*****
IHl3 : forall (_ : eqList (cons a l1) nil) (_ : eqList nil l3),\neqList (cons a l1) l3
l3 : list positive
a0 : positive
IHl1 : forall (l2 l3 : list positive) (_ : eqList l1 l2) (_ : eqList l2 l3),\neqList l1 l3
l1 : list positive
a : positive
Ar : Arity
*****
forall (_ : eqList (cons a l1) nil) (_ : eqList nil (cons a0 l3)), eqList (cons a l1) (cons a0 l3)
+++++
simpl.
-----
Lemma eqListTrans : forall l1 l2 l3, eqList l1 l2 -> eqList l2 l3 -> eqList l1 l3.
Proof.
intro l1.
induction l1.
intro l2.
induction l2.
intro l3.
induction l3.
simpl.

*****
IHl3 : forall (_ : eqList (cons a l1) nil) (_ : eqList nil l3),\neqList (cons a l1) l3
l3 : list positive
a0 : positive
IHl1 : forall (l2 l3 : list positive) (_ : eqList l1 l2) (_ : eqList l2 l3),\neqList l1 l3
l1 : list positive
a : positive
Ar : Arity
*****
forall (_ : False) (_ : False), and (Pos.eq a a0) (eqList l1 l3)
+++++
intuition.
-----
Lemma eqListTrans : forall l1 l2 l3, eqList l1 l2 -> eqList l2 l3 -> eqList l1 l3.
Proof.
intro l1.
induction l1.
intro l2.
induction l2.

*****
IHl2 : forall (l3 : list positive) (_ : eqList (cons a l1) l2)\n (_ : eqList l2 l3), eqList (cons a l1) l3
l2 : list positive
a0 : positive
IHl1 : forall (l2 l3 : list positive) (_ : eqList l1 l2) (_ : eqList l2 l3),\neqList l1 l3
l1 : list positive
a : positive
Ar : Arity
*****
forall (l3 : list positive) (_ : eqList (cons a l1) (cons a0 l2)) (_ : eqList (cons a0 l2) l3), eqList (cons a l1) l3
+++++
intro l3.
-----
Lemma eqListTrans : forall l1 l2 l3, eqList l1 l2 -> eqList l2 l3 -> eqList l1 l3.
Proof.
intro l1.
induction l1.
intro l2.
induction l2.
intro l3.

*****
l3 : list positive
IHl2 : forall (l3 : list positive) (_ : eqList (cons a l1) l2)\n (_ : eqList l2 l3), eqList (cons a l1) l3
l2 : list positive
a0 : positive
IHl1 : forall (l2 l3 : list positive) (_ : eqList l1 l2) (_ : eqList l2 l3),\neqList l1 l3
l1 : list positive
a : positive
Ar : Arity
*****
forall (_ : eqList (cons a l1) (cons a0 l2)) (_ : eqList (cons a0 l2) l3), eqList (cons a l1) l3
+++++
induction l3.
-----
Lemma eqListTrans : forall l1 l2 l3, eqList l1 l2 -> eqList l2 l3 -> eqList l1 l3.
Proof.
intro l1.
induction l1.
intro l2.
induction l2.
intro l3.
induction l3.

*****
IHl2 : forall (l3 : list positive) (_ : eqList (cons a l1) l2)\n (_ : eqList l2 l3), eqList (cons a l1) l3
l2 : list positive
a0 : positive
IHl1 : forall (l2 l3 : list positive) (_ : eqList l1 l2) (_ : eqList l2 l3),\neqList l1 l3
l1 : list positive
a : positive
Ar : Arity
*****
forall (_ : eqList (cons a l1) (cons a0 l2)) (_ : eqList (cons a0 l2) nil), eqList (cons a l1) nil
+++++
simpl.
-----
Lemma eqListTrans : forall l1 l2 l3, eqList l1 l2 -> eqList l2 l3 -> eqList l1 l3.
Proof.
intro l1.
induction l1.
intro l2.
induction l2.
intro l3.
induction l3.
simpl.

*****
IHl2 : forall (l3 : list positive) (_ : eqList (cons a l1) l2)\n (_ : eqList l2 l3), eqList (cons a l1) l3
l2 : list positive
a0 : positive
IHl1 : forall (l2 l3 : list positive) (_ : eqList l1 l2) (_ : eqList l2 l3),\neqList l1 l3
l1 : list positive
a : positive
Ar : Arity
*****
forall (_ : and (Pos.eq a a0) (eqList l1 l2)) (_ : False), False
+++++
trivial.
-----
Lemma eqListTrans : forall l1 l2 l3, eqList l1 l2 -> eqList l2 l3 -> eqList l1 l3.
Proof.
intro l1.
induction l1.
intro l2.
induction l2.
intro l3.
induction l3.

*****
IHl3 : forall (_ : eqList (cons a l1) (cons a0 l2))\n (_ : eqList (cons a0 l2) l3), eqList (cons a l1) l3
l3 : list positive
a1 : positive
IHl2 : forall (l3 : list positive) (_ : eqList (cons a l1) l2)\n (_ : eqList l2 l3), eqList (cons a l1) l3
l2 : list positive
a0 : positive
IHl1 : forall (l2 l3 : list positive) (_ : eqList l1 l2) (_ : eqList l2 l3),\neqList l1 l3
l1 : list positive
a : positive
Ar : Arity
*****
forall (_ : eqList (cons a l1) (cons a0 l2)) (_ : eqList (cons a0 l2) (cons a1 l3)), eqList (cons a l1) (cons a1 l3)
+++++
simpl.
-----
Lemma eqListTrans : forall l1 l2 l3, eqList l1 l2 -> eqList l2 l3 -> eqList l1 l3.
Proof.
intro l1.
induction l1.
intro l2.
induction l2.
intro l3.
induction l3.
simpl.

*****
IHl3 : forall (_ : eqList (cons a l1) (cons a0 l2))\n (_ : eqList (cons a0 l2) l3), eqList (cons a l1) l3
l3 : list positive
a1 : positive
IHl2 : forall (l3 : list positive) (_ : eqList (cons a l1) l2)\n (_ : eqList l2 l3), eqList (cons a l1) l3
l2 : list positive
a0 : positive
IHl1 : forall (l2 l3 : list positive) (_ : eqList l1 l2) (_ : eqList l2 l3),\neqList l1 l3
l1 : list positive
a : positive
Ar : Arity
*****
forall (_ : and (Pos.eq a a0) (eqList l1 l2)) (_ : and (Pos.eq a0 a1) (eqList l2 l3)), and (Pos.eq a a1) (eqList l1 l3)
+++++
intros Hl1l2 Hl2l3.
-----
Lemma eqListTrans : forall l1 l2 l3, eqList l1 l2 -> eqList l2 l3 -> eqList l1 l3.
Proof.
intro l1.
induction l1.
intro l2.
induction l2.
intro l3.
induction l3.
simpl.
intros Hl1l2 Hl2l3.

*****
Hl2l3 : and (Pos.eq a0 a1) (eqList l2 l3)
Hl1l2 : and (Pos.eq a a0) (eqList l1 l2)
IHl3 : forall (_ : eqList (cons a l1) (cons a0 l2))\n (_ : eqList (cons a0 l2) l3), eqList (cons a l1) l3
l3 : list positive
a1 : positive
IHl2 : forall (l3 : list positive) (_ : eqList (cons a l1) l2)\n (_ : eqList l2 l3), eqList (cons a l1) l3
l2 : list positive
a0 : positive
IHl1 : forall (l2 l3 : list positive) (_ : eqList l1 l2) (_ : eqList l2 l3),\neqList l1 l3
l1 : list positive
a : positive
Ar : Arity
*****
and (Pos.eq a a1) (eqList l1 l3)
+++++
destruct Hl1l2 as [Haa0 Hl1l2].
-----
Lemma eqListTrans : forall l1 l2 l3, eqList l1 l2 -> eqList l2 l3 -> eqList l1 l3.
Proof.
intro l1.
induction l1.
intro l2.
induction l2.
intro l3.
induction l3.
simpl.
intros Hl1l2 Hl2l3.
destruct Hl1l2 as [Haa0 Hl1l2].

*****
Hl2l3 : and (Pos.eq a0 a1) (eqList l2 l3)
Hl1l2 : eqList l1 l2
Haa0 : Pos.eq a a0
IHl3 : forall (_ : eqList (cons a l1) (cons a0 l2))\n (_ : eqList (cons a0 l2) l3), eqList (cons a l1) l3
l3 : list positive
a1 : positive
IHl2 : forall (l3 : list positive) (_ : eqList (cons a l1) l2)\n (_ : eqList l2 l3), eqList (cons a l1) l3
l2 : list positive
a0 : positive
IHl1 : forall (l2 l3 : list positive) (_ : eqList l1 l2) (_ : eqList l2 l3),\neqList l1 l3
l1 : list positive
a : positive
Ar : Arity
*****
and (Pos.eq a a1) (eqList l1 l3)
+++++
destruct Hl2l3 as [Ha0a1 Hl2l3].
-----
Lemma eqListTrans : forall l1 l2 l3, eqList l1 l2 -> eqList l2 l3 -> eqList l1 l3.
Proof.
intro l1.
induction l1.
intro l2.
induction l2.
intro l3.
induction l3.
simpl.
intros Hl1l2 Hl2l3.
destruct Hl1l2 as [Haa0 Hl1l2].
destruct Hl2l3 as [Ha0a1 Hl2l3].

*****
Hl2l3 : eqList l2 l3
Ha0a1 : Pos.eq a0 a1
Hl1l2 : eqList l1 l2
Haa0 : Pos.eq a a0
IHl3 : forall (_ : eqList (cons a l1) (cons a0 l2))\n (_ : eqList (cons a0 l2) l3), eqList (cons a l1) l3
l3 : list positive
a1 : positive
IHl2 : forall (l3 : list positive) (_ : eqList (cons a l1) l2)\n (_ : eqList l2 l3), eqList (cons a l1) l3
l2 : list positive
a0 : positive
IHl1 : forall (l2 l3 : list positive) (_ : eqList l1 l2) (_ : eqList l2 l3),\neqList l1 l3
l1 : list positive
a : positive
Ar : Arity
*****
and (Pos.eq a a1) (eqList l1 l3)
+++++
split.
-----
Lemma eqListTrans : forall l1 l2 l3, eqList l1 l2 -> eqList l2 l3 -> eqList l1 l3.
Proof.
intro l1.
induction l1.
intro l2.
induction l2.
intro l3.
induction l3.
simpl.
intros Hl1l2 Hl2l3.
destruct Hl1l2 as [Haa0 Hl1l2].
destruct Hl2l3 as [Ha0a1 Hl2l3].
split.

*****
Hl2l3 : eqList l2 l3
Ha0a1 : Pos.eq a0 a1
Hl1l2 : eqList l1 l2
Haa0 : Pos.eq a a0
IHl3 : forall (_ : eqList (cons a l1) (cons a0 l2))\n (_ : eqList (cons a0 l2) l3), eqList (cons a l1) l3
l3 : list positive
a1 : positive
IHl2 : forall (l3 : list positive) (_ : eqList (cons a l1) l2)\n (_ : eqList l2 l3), eqList (cons a l1) l3
l2 : list positive
a0 : positive
IHl1 : forall (l2 l3 : list positive) (_ : eqList l1 l2) (_ : eqList l2 l3),\neqList l1 l3
l1 : list positive
a : positive
Ar : Arity
*****
Pos.eq a a1
+++++
transitivity a0.
-----
Lemma eqListTrans : forall l1 l2 l3, eqList l1 l2 -> eqList l2 l3 -> eqList l1 l3.
Proof.
intro l1.
induction l1.
intro l2.
induction l2.
intro l3.
induction l3.
simpl.
intros Hl1l2 Hl2l3.
destruct Hl1l2 as [Haa0 Hl1l2].
destruct Hl2l3 as [Ha0a1 Hl2l3].
split.
transitivity a0.

*****
Hl2l3 : eqList l2 l3
Ha0a1 : Pos.eq a0 a1
Hl1l2 : eqList l1 l2
Haa0 : Pos.eq a a0
IHl3 : forall (_ : eqList (cons a l1) (cons a0 l2))\n (_ : eqList (cons a0 l2) l3), eqList (cons a l1) l3
l3 : list positive
a1 : positive
IHl2 : forall (l3 : list positive) (_ : eqList (cons a l1) l2)\n (_ : eqList l2 l3), eqList (cons a l1) l3
l2 : list positive
a0 : positive
IHl1 : forall (l2 l3 : list positive) (_ : eqList l1 l2) (_ : eqList l2 l3),\neqList l1 l3
l1 : list positive
a : positive
Ar : Arity
*****
Pos.eq a a0
+++++
assumption.
-----
Lemma eqListTrans : forall l1 l2 l3, eqList l1 l2 -> eqList l2 l3 -> eqList l1 l3.
Proof.
intro l1.
induction l1.
intro l2.
induction l2.
intro l3.
induction l3.
simpl.
intros Hl1l2 Hl2l3.
destruct Hl1l2 as [Haa0 Hl1l2].
destruct Hl2l3 as [Ha0a1 Hl2l3].
split.
transitivity a0.

*****
Hl2l3 : eqList l2 l3
Ha0a1 : Pos.eq a0 a1
Hl1l2 : eqList l1 l2
Haa0 : Pos.eq a a0
IHl3 : forall (_ : eqList (cons a l1) (cons a0 l2))\n (_ : eqList (cons a0 l2) l3), eqList (cons a l1) l3
l3 : list positive
a1 : positive
IHl2 : forall (l3 : list positive) (_ : eqList (cons a l1) l2)\n (_ : eqList l2 l3), eqList (cons a l1) l3
l2 : list positive
a0 : positive
IHl1 : forall (l2 l3 : list positive) (_ : eqList l1 l2) (_ : eqList l2 l3),\neqList l1 l3
l1 : list positive
a : positive
Ar : Arity
*****
Pos.eq a0 a1
+++++
assumption.
-----
Lemma eqListTrans : forall l1 l2 l3, eqList l1 l2 -> eqList l2 l3 -> eqList l1 l3.
Proof.
intro l1.
induction l1.
intro l2.
induction l2.
intro l3.
induction l3.
simpl.
intros Hl1l2 Hl2l3.
destruct Hl1l2 as [Haa0 Hl1l2].
destruct Hl2l3 as [Ha0a1 Hl2l3].
split.

*****
Hl2l3 : eqList l2 l3
Ha0a1 : Pos.eq a0 a1
Hl1l2 : eqList l1 l2
Haa0 : Pos.eq a a0
IHl3 : forall (_ : eqList (cons a l1) (cons a0 l2))\n (_ : eqList (cons a0 l2) l3), eqList (cons a l1) l3
l3 : list positive
a1 : positive
IHl2 : forall (l3 : list positive) (_ : eqList (cons a l1) l2)\n (_ : eqList l2 l3), eqList (cons a l1) l3
l2 : list positive
a0 : positive
IHl1 : forall (l2 l3 : list positive) (_ : eqList l1 l2) (_ : eqList l2 l3),\neqList l1 l3
l1 : list positive
a : positive
Ar : Arity
*****
eqList l1 l3
+++++
apply IHl1 with l2.
-----
Lemma eqListTrans : forall l1 l2 l3, eqList l1 l2 -> eqList l2 l3 -> eqList l1 l3.
Proof.
intro l1.
induction l1.
intro l2.
induction l2.
intro l3.
induction l3.
simpl.
intros Hl1l2 Hl2l3.
destruct Hl1l2 as [Haa0 Hl1l2].
destruct Hl2l3 as [Ha0a1 Hl2l3].
split.
apply IHl1 with l2.

*****
Hl2l3 : eqList l2 l3
Ha0a1 : Pos.eq a0 a1
Hl1l2 : eqList l1 l2
Haa0 : Pos.eq a a0
IHl3 : forall (_ : eqList (cons a l1) (cons a0 l2))\n (_ : eqList (cons a0 l2) l3), eqList (cons a l1) l3
l3 : list positive
a1 : positive
IHl2 : forall (l3 : list positive) (_ : eqList (cons a l1) l2)\n (_ : eqList l2 l3), eqList (cons a l1) l3
l2 : list positive
a0 : positive
IHl1 : forall (l2 l3 : list positive) (_ : eqList l1 l2) (_ : eqList l2 l3),\neqList l1 l3
l1 : list positive
a : positive
Ar : Arity
*****
eqList l1 l2
+++++
assumption.
-----
Lemma eqListTrans : forall l1 l2 l3, eqList l1 l2 -> eqList l2 l3 -> eqList l1 l3.
Proof.
intro l1.
induction l1.
intro l2.
induction l2.
intro l3.
induction l3.
simpl.
intros Hl1l2 Hl2l3.
destruct Hl1l2 as [Haa0 Hl1l2].
destruct Hl2l3 as [Ha0a1 Hl2l3].
split.
apply IHl1 with l2.

*****
Hl2l3 : eqList l2 l3
Ha0a1 : Pos.eq a0 a1
Hl1l2 : eqList l1 l2
Haa0 : Pos.eq a a0
IHl3 : forall (_ : eqList (cons a l1) (cons a0 l2))\n (_ : eqList (cons a0 l2) l3), eqList (cons a l1) l3
l3 : list positive
a1 : positive
IHl2 : forall (l3 : list positive) (_ : eqList (cons a l1) l2)\n (_ : eqList l2 l3), eqList (cons a l1) l3
l2 : list positive
a0 : positive
IHl1 : forall (l2 l3 : list positive) (_ : eqList l1 l2) (_ : eqList l2 l3),\neqList l1 l3
l1 : list positive
a : positive
Ar : Arity
*****
eqList l2 l3
+++++
assumption.
-----
Lemma eqListTrans : forall l1 l2 l3, eqList l1 l2 -> eqList l2 l3 -> eqList l1 l3.
Proof.
intro l1.
induction l1.

*****

*****

+++++
Qed.
-----
Definition tST := cartesianPower positive (S (S n)).
-----
Definition eqST (cp1 cp2 : tST) :=\n    eqList (PosSort.sort (CPToList cp1)) (PosSort.sort (CPToList cp2)).
-----
Lemma eqListSortOCP : forall (cp : tST), eqList (CPToList (OCP cp)) (PosSort.sort (CPToList cp)).
-----
Lemma eqListSortOCP : forall (cp : tST), eqList (CPToList (OCP cp)) (PosSort.sort (CPToList cp)).

*****
Ar : Arity
*****
forall cp : tST, eqList (CPToList (OCP cp)) (sort (CPToList cp))
+++++
Proof.
-----
Lemma eqListSortOCP : forall (cp : tST), eqList (CPToList (OCP cp)) (PosSort.sort (CPToList cp)).
Proof.

*****
Ar : Arity
*****
forall cp : tST, eqList (CPToList (OCP cp)) (sort (CPToList cp))
+++++
intro cp.
-----
Lemma eqListSortOCP : forall (cp : tST), eqList (CPToList (OCP cp)) (PosSort.sort (CPToList cp)).
Proof.
intro cp.

*****
cp : tST
Ar : Arity
*****
eqList (CPToList (OCP cp)) (sort (CPToList cp))
+++++
unfold OCP.
-----
Lemma eqListSortOCP : forall (cp : tST), eqList (CPToList (OCP cp)) (PosSort.sort (CPToList cp)).
Proof.
intro cp.
unfold OCP.

*****
cp : tST
Ar : Arity
*****
eqList (CPToList (eq_rect (length (OCPAux cp)) (fun n : nat => cartesianPower positive n) (ListToCP (OCPAux cp) (fst cp)) (S (S n)) (OCPALengthOK cp))) (sort (CPToList cp))
+++++
unfold OCPAux.
-----
Lemma eqListSortOCP : forall (cp : tST), eqList (CPToList (OCP cp)) (PosSort.sort (CPToList cp)).
Proof.
intro cp.
unfold OCP.
unfold OCPAux.

*****
cp : tST
Ar : Arity
*****
eqList (CPToList (eq_rect (length (sort (CPToList cp))) (fun n : nat => cartesianPower positive n) (ListToCP (sort (CPToList cp)) (fst cp)) (S (S n)) (OCPALengthOK cp))) (sort (CPToList cp))
+++++
elim_eq_rect.
-----
Lemma eqListSortOCP : forall (cp : tST), eqList (CPToList (OCP cp)) (PosSort.sort (CPToList cp)).
Proof.
intro cp.
unfold OCP.
unfold OCPAux.
elim_eq_rect.

*****
cp : tST
Ar : Arity
*****
eqList (CPToList (eq_rect (length (sort (CPToList cp))) (fun n : nat => cartesianPower positive n) (ListToCP (sort (CPToList cp)) (fst cp)) (length (OCPAux cp)) eq_refl)) (sort (CPToList cp))
+++++
simpl.
-----
Lemma eqListSortOCP : forall (cp : tST), eqList (CPToList (OCP cp)) (PosSort.sort (CPToList cp)).
Proof.
intro cp.
unfold OCP.
unfold OCPAux.
elim_eq_rect.
simpl.

*****
cp : tST
Ar : Arity
*****
eqList (CPToList (ListToCP (sort (cons (fst cp) (nat_rect (fun n : nat => forall _ : cartesianPower positive (S n), list positive) (fun cp : cartesianPower positive (S O) => cons cp nil) (fun (n : nat) (IHn : forall _ : cartesianPower positive (S n), list positive) (cp : cartesianPower positive (S (S n))) => cons (fst cp) (IHn (tailCP cp))) n (tailCP cp)))) (fst cp))) (sort (cons (fst cp) (nat_rect (fun n : nat => forall _ : cartesianPower positive (S n), list positive) (fun cp : cartesianPower positive (S O) => cons cp nil) (fun (n : nat) (IHn : forall _ : cartesianPower positive (S n), list positive) (cp : cartesianPower positive (S (S n))) => cons (fst cp) (IHn (tailCP cp))) n (tailCP cp))))
+++++
rewrite CPLOK.
-----
Lemma eqListSortOCP : forall (cp : tST), eqList (CPToList (OCP cp)) (PosSort.sort (CPToList cp)).
Proof.
intro cp.
unfold OCP.
unfold OCPAux.
elim_eq_rect.
simpl.
rewrite CPLOK.

*****
cp : tST
Ar : Arity
*****
eqList (sort (cons (fst cp) (nat_rect (fun n : nat => forall _ : cartesianPower positive (S n), list positive) (fun cp : cartesianPower positive (S O) => cons cp nil) (fun (n : nat) (IHn : forall _ : cartesianPower positive (S n), list positive) (cp : cartesianPower positive (S (S n))) => cons (fst cp) (IHn (tailCP cp))) n (tailCP cp)))) (sort (cons (fst cp) (nat_rect (fun n : nat => forall _ : cartesianPower positive (S n), list positive) (fun cp : cartesianPower positive (S O) => cons cp nil) (fun (n : nat) (IHn : forall _ : cartesianPower positive (S n), list positive) (cp : cartesianPower positive (S (S n))) => cons (fst cp) (IHn (tailCP cp))) n (tailCP cp))))
+++++
apply eqListRefl.
-----
Lemma eqListSortOCP : forall (cp : tST), eqList (CPToList (OCP cp)) (PosSort.sort (CPToList cp)).
Proof.
intro cp.
unfold OCP.
unfold OCPAux.
elim_eq_rect.
simpl.
rewrite CPLOK.
apply eqListRefl.

*****

*****

+++++
Qed.
-----
Fixpoint eqbList (l1 l2 : list positive) :=\n    match l1, l2 with\n      | nil         , nil          => true\n      | (hd1 :: tl1), (hd2 :: tl2) => (Pos.eqb hd1 hd2) && (eqbList tl1 tl2)\n      | _           , _            => false\n    end.
-----
Lemma eqbListEqList : forall l1 l2, eqbList l1 l2 = true <-> eqList l1 l2.
-----
Lemma eqbListEqList : forall l1 l2, eqbList l1 l2 = true <-> eqList l1 l2.

*****
Ar : Arity
*****
forall l1 l2 : list positive, iff (eq (eqbList l1 l2) true) (eqList l1 l2)
+++++
Proof.
-----
Lemma eqbListEqList : forall l1 l2, eqbList l1 l2 = true <-> eqList l1 l2.
Proof.

*****
Ar : Arity
*****
forall l1 l2 : list positive, iff (eq (eqbList l1 l2) true) (eqList l1 l2)
+++++
intro l1.
-----
Lemma eqbListEqList : forall l1 l2, eqbList l1 l2 = true <-> eqList l1 l2.
Proof.
intro l1.

*****
l1 : list positive
Ar : Arity
*****
forall l2 : list positive, iff (eq (eqbList l1 l2) true) (eqList l1 l2)
+++++
induction l1.
-----
Lemma eqbListEqList : forall l1 l2, eqbList l1 l2 = true <-> eqList l1 l2.
Proof.
intro l1.
induction l1.

*****
Ar : Arity
*****
forall l2 : list positive, iff (eq (eqbList nil l2) true) (eqList nil l2)
+++++
intro l2.
-----
Lemma eqbListEqList : forall l1 l2, eqbList l1 l2 = true <-> eqList l1 l2.
Proof.
intro l1.
induction l1.
intro l2.

*****
l2 : list positive
Ar : Arity
*****
iff (eq (eqbList nil l2) true) (eqList nil l2)
+++++
induction l2.
-----
Lemma eqbListEqList : forall l1 l2, eqbList l1 l2 = true <-> eqList l1 l2.
Proof.
intro l1.
induction l1.
intro l2.
induction l2.

*****
Ar : Arity
*****
iff (eq (eqbList nil nil) true) (eqList nil nil)
+++++
simpl.
-----
Lemma eqbListEqList : forall l1 l2, eqbList l1 l2 = true <-> eqList l1 l2.
Proof.
intro l1.
induction l1.
intro l2.
induction l2.
simpl.

*****
Ar : Arity
*****
iff (eq true true) True
+++++
unfold eqList.
-----
Lemma eqbListEqList : forall l1 l2, eqbList l1 l2 = true <-> eqList l1 l2.
Proof.
intro l1.
induction l1.
intro l2.
induction l2.
simpl.
unfold eqList.

*****
Ar : Arity
*****
iff (eq true true) True
+++++
intuition.
-----
Lemma eqbListEqList : forall l1 l2, eqbList l1 l2 = true <-> eqList l1 l2.
Proof.
intro l1.
induction l1.
intro l2.
induction l2.

*****
IHl2 : iff (eq (eqbList nil l2) true) (eqList nil l2)
l2 : list positive
a : positive
Ar : Arity
*****
iff (eq (eqbList nil (cons a l2)) true) (eqList nil (cons a l2))
+++++
simpl.
-----
Lemma eqbListEqList : forall l1 l2, eqbList l1 l2 = true <-> eqList l1 l2.
Proof.
intro l1.
induction l1.
intro l2.
induction l2.
simpl.

*****
IHl2 : iff (eq (eqbList nil l2) true) (eqList nil l2)
l2 : list positive
a : positive
Ar : Arity
*****
iff (eq false true) False
+++++
unfold eqList.
-----
Lemma eqbListEqList : forall l1 l2, eqbList l1 l2 = true <-> eqList l1 l2.
Proof.
intro l1.
induction l1.
intro l2.
induction l2.
simpl.
unfold eqList.

*****
IHl2 : iff (eq (eqbList nil l2) true) (eqList nil l2)
l2 : list positive
a : positive
Ar : Arity
*****
iff (eq false true) False
+++++
split.
-----
Lemma eqbListEqList : forall l1 l2, eqbList l1 l2 = true <-> eqList l1 l2.
Proof.
intro l1.
induction l1.
intro l2.
induction l2.
simpl.
unfold eqList.
split.

*****
IHl2 : iff (eq (eqbList nil l2) true) (eqList nil l2)
l2 : list positive
a : positive
Ar : Arity
*****
forall _ : eq false true, False
+++++
intro.
-----
Lemma eqbListEqList : forall l1 l2, eqbList l1 l2 = true <-> eqList l1 l2.
Proof.
intro l1.
induction l1.
intro l2.
induction l2.
simpl.
unfold eqList.
split.
intro.

*****
H : eq false true
IHl2 : iff (eq (eqbList nil l2) true) (eqList nil l2)
l2 : list positive
a : positive
Ar : Arity
*****
False
+++++
intuition.
-----
Lemma eqbListEqList : forall l1 l2, eqbList l1 l2 = true <-> eqList l1 l2.
Proof.
intro l1.
induction l1.
intro l2.
induction l2.
simpl.
unfold eqList.
split.

*****
IHl2 : iff (eq (eqbList nil l2) true) (eqList nil l2)
l2 : list positive
a : positive
Ar : Arity
*****
forall _ : False, eq false true
+++++
intro.
-----
Lemma eqbListEqList : forall l1 l2, eqbList l1 l2 = true <-> eqList l1 l2.
Proof.
intro l1.
induction l1.
intro l2.
induction l2.
simpl.
unfold eqList.
split.
intro.

*****
H : False
IHl2 : iff (eq (eqbList nil l2) true) (eqList nil l2)
l2 : list positive
a : positive
Ar : Arity
*****
eq false true
+++++
intuition.
-----
Lemma eqbListEqList : forall l1 l2, eqbList l1 l2 = true <-> eqList l1 l2.
Proof.
intro l1.
induction l1.

*****
IHl1 : forall l2 : list positive, iff (eq (eqbList l1 l2) true) (eqList l1 l2)
l1 : list positive
a : positive
Ar : Arity
*****
forall l2 : list positive, iff (eq (eqbList (cons a l1) l2) true) (eqList (cons a l1) l2)
+++++
intro l2.
-----
Lemma eqbListEqList : forall l1 l2, eqbList l1 l2 = true <-> eqList l1 l2.
Proof.
intro l1.
induction l1.
intro l2.

*****
l2 : list positive
IHl1 : forall l2 : list positive, iff (eq (eqbList l1 l2) true) (eqList l1 l2)
l1 : list positive
a : positive
Ar : Arity
*****
iff (eq (eqbList (cons a l1) l2) true) (eqList (cons a l1) l2)
+++++
induction l2.
-----
Lemma eqbListEqList : forall l1 l2, eqbList l1 l2 = true <-> eqList l1 l2.
Proof.
intro l1.
induction l1.
intro l2.
induction l2.

*****
IHl1 : forall l2 : list positive, iff (eq (eqbList l1 l2) true) (eqList l1 l2)
l1 : list positive
a : positive
Ar : Arity
*****
iff (eq (eqbList (cons a l1) nil) true) (eqList (cons a l1) nil)
+++++
simpl.
-----
Lemma eqbListEqList : forall l1 l2, eqbList l1 l2 = true <-> eqList l1 l2.
Proof.
intro l1.
induction l1.
intro l2.
induction l2.
simpl.

*****
IHl1 : forall l2 : list positive, iff (eq (eqbList l1 l2) true) (eqList l1 l2)
l1 : list positive
a : positive
Ar : Arity
*****
iff (eq false true) False
+++++
unfold eqList.
-----
Lemma eqbListEqList : forall l1 l2, eqbList l1 l2 = true <-> eqList l1 l2.
Proof.
intro l1.
induction l1.
intro l2.
induction l2.
simpl.
unfold eqList.

*****
IHl1 : forall l2 : list positive, iff (eq (eqbList l1 l2) true) (eqList l1 l2)
l1 : list positive
a : positive
Ar : Arity
*****
iff (eq false true) False
+++++
split.
-----
Lemma eqbListEqList : forall l1 l2, eqbList l1 l2 = true <-> eqList l1 l2.
Proof.
intro l1.
induction l1.
intro l2.
induction l2.
simpl.
unfold eqList.
split.

*****
IHl1 : forall l2 : list positive, iff (eq (eqbList l1 l2) true) (eqList l1 l2)
l1 : list positive
a : positive
Ar : Arity
*****
forall _ : eq false true, False
+++++
intro.
-----
Lemma eqbListEqList : forall l1 l2, eqbList l1 l2 = true <-> eqList l1 l2.
Proof.
intro l1.
induction l1.
intro l2.
induction l2.
simpl.
unfold eqList.
split.
intro.

*****
H : eq false true
IHl1 : forall l2 : list positive, iff (eq (eqbList l1 l2) true) (eqList l1 l2)
l1 : list positive
a : positive
Ar : Arity
*****
False
+++++
intuition.
-----
Lemma eqbListEqList : forall l1 l2, eqbList l1 l2 = true <-> eqList l1 l2.
Proof.
intro l1.
induction l1.
intro l2.
induction l2.
simpl.
unfold eqList.
split.

*****
IHl1 : forall l2 : list positive, iff (eq (eqbList l1 l2) true) (eqList l1 l2)
l1 : list positive
a : positive
Ar : Arity
*****
forall _ : False, eq false true
+++++
intro.
-----
Lemma eqbListEqList : forall l1 l2, eqbList l1 l2 = true <-> eqList l1 l2.
Proof.
intro l1.
induction l1.
intro l2.
induction l2.
simpl.
unfold eqList.
split.
intro.

*****
H : False
IHl1 : forall l2 : list positive, iff (eq (eqbList l1 l2) true) (eqList l1 l2)
l1 : list positive
a : positive
Ar : Arity
*****
eq false true
+++++
intuition.
-----
Lemma eqbListEqList : forall l1 l2, eqbList l1 l2 = true <-> eqList l1 l2.
Proof.
intro l1.
induction l1.
intro l2.
induction l2.

*****
IHl2 : iff (eq (eqbList (cons a l1) l2) true) (eqList (cons a l1) l2)
l2 : list positive
a0 : positive
IHl1 : forall l2 : list positive, iff (eq (eqbList l1 l2) true) (eqList l1 l2)
l1 : list positive
a : positive
Ar : Arity
*****
iff (eq (eqbList (cons a l1) (cons a0 l2)) true) (eqList (cons a l1) (cons a0 l2))
+++++
split.
-----
Lemma eqbListEqList : forall l1 l2, eqbList l1 l2 = true <-> eqList l1 l2.
Proof.
intro l1.
induction l1.
intro l2.
induction l2.
split.

*****
IHl2 : iff (eq (eqbList (cons a l1) l2) true) (eqList (cons a l1) l2)
l2 : list positive
a0 : positive
IHl1 : forall l2 : list positive, iff (eq (eqbList l1 l2) true) (eqList l1 l2)
l1 : list positive
a : positive
Ar : Arity
*****
forall _ : eq (eqbList (cons a l1) (cons a0 l2)) true, eqList (cons a l1) (cons a0 l2)
+++++
intro H.
-----
Lemma eqbListEqList : forall l1 l2, eqbList l1 l2 = true <-> eqList l1 l2.
Proof.
intro l1.
induction l1.
intro l2.
induction l2.
split.
intro H.

*****
H : eq (eqbList (cons a l1) (cons a0 l2)) true
IHl2 : iff (eq (eqbList (cons a l1) l2) true) (eqList (cons a l1) l2)
l2 : list positive
a0 : positive
IHl1 : forall l2 : list positive, iff (eq (eqbList l1 l2) true) (eqList l1 l2)
l1 : list positive
a : positive
Ar : Arity
*****
eqList (cons a l1) (cons a0 l2)
+++++
unfold eqbList in H.
-----
Lemma eqbListEqList : forall l1 l2, eqbList l1 l2 = true <-> eqList l1 l2.
Proof.
intro l1.
induction l1.
intro l2.
induction l2.
split.
intro H.
unfold eqbList in H.

*****
H : eq\n (andb (Pos.eqb a a0)\n ((fix eqbList (l1 l2 : list positive) {struct l1} : bool :=\n match l1 with\n | nil => match l2 with\n | nil => true\n | cons _ _ => false\n end\n | cons hd1 tl1 =>\n match l2 with\n | nil => false\n | cons hd2 tl2 => andb (Pos.eqb hd1 hd2) (eqbList tl1 tl2)\n end\n end) l1 l2)) true
IHl2 : iff (eq (eqbList (cons a l1) l2) true) (eqList (cons a l1) l2)
l2 : list positive
a0 : positive
IHl1 : forall l2 : list positive, iff (eq (eqbList l1 l2) true) (eqList l1 l2)
l1 : list positive
a : positive
Ar : Arity
*****
eqList (cons a l1) (cons a0 l2)
+++++
apply andb_true_iff in H.
-----
Lemma eqbListEqList : forall l1 l2, eqbList l1 l2 = true <-> eqList l1 l2.
Proof.
intro l1.
induction l1.
intro l2.
induction l2.
split.
intro H.
unfold eqbList in H.
apply andb_true_iff in H.

*****
H : and (eq (Pos.eqb a a0) true)\n (eq\n ((fix eqbList (l1 l2 : list positive) {struct l1} : bool :=\n match l1 with\n | nil => match l2 with\n | nil => true\n | cons _ _ => false\n end\n | cons hd1 tl1 =>\n match l2 with\n | nil => false\n | cons hd2 tl2 => andb (Pos.eqb hd1 hd2) (eqbList tl1 tl2)\n end\n end) l1 l2) true)
IHl2 : iff (eq (eqbList (cons a l1) l2) true) (eqList (cons a l1) l2)
l2 : list positive
a0 : positive
IHl1 : forall l2 : list positive, iff (eq (eqbList l1 l2) true) (eqList l1 l2)
l1 : list positive
a : positive
Ar : Arity
*****
eqList (cons a l1) (cons a0 l2)
+++++
destruct H as [Hhd Htl].
-----
Lemma eqbListEqList : forall l1 l2, eqbList l1 l2 = true <-> eqList l1 l2.
Proof.
intro l1.
induction l1.
intro l2.
induction l2.
split.
intro H.
unfold eqbList in H.
apply andb_true_iff in H.
destruct H as [Hhd Htl].

*****
Htl : eq\n ((fix eqbList (l1 l2 : list positive) {struct l1} : bool :=\n match l1 with\n | nil => match l2 with\n | nil => true\n | cons _ _ => false\n end\n | cons hd1 tl1 =>\n match l2 with\n | nil => false\n | cons hd2 tl2 => andb (Pos.eqb hd1 hd2) (eqbList tl1 tl2)\n end\n end) l1 l2) true
Hhd : eq (Pos.eqb a a0) true
IHl2 : iff (eq (eqbList (cons a l1) l2) true) (eqList (cons a l1) l2)
l2 : list positive
a0 : positive
IHl1 : forall l2 : list positive, iff (eq (eqbList l1 l2) true) (eqList l1 l2)
l1 : list positive
a : positive
Ar : Arity
*****
eqList (cons a l1) (cons a0 l2)
+++++
fold eqbList in Htl.
-----
Lemma eqbListEqList : forall l1 l2, eqbList l1 l2 = true <-> eqList l1 l2.
Proof.
intro l1.
induction l1.
intro l2.
induction l2.
split.
intro H.
unfold eqbList in H.
apply andb_true_iff in H.
destruct H as [Hhd Htl].
fold eqbList in Htl.

*****
Htl : eq (eqbList l1 l2) true
Hhd : eq (Pos.eqb a a0) true
IHl2 : iff (eq (eqbList (cons a l1) l2) true) (eqList (cons a l1) l2)
l2 : list positive
a0 : positive
IHl1 : forall l2 : list positive, iff (eq (eqbList l1 l2) true) (eqList l1 l2)
l1 : list positive
a : positive
Ar : Arity
*****
eqList (cons a l1) (cons a0 l2)
+++++
assert (H := IHl1 l2).
-----
Lemma eqbListEqList : forall l1 l2, eqbList l1 l2 = true <-> eqList l1 l2.
Proof.
intro l1.
induction l1.
intro l2.
induction l2.
split.
intro H.
unfold eqbList in H.
apply andb_true_iff in H.
destruct H as [Hhd Htl].
fold eqbList in Htl.
assert (H := IHl1 l2).

*****
H : iff (eq (eqbList l1 l2) true) (eqList l1 l2)
Htl : eq (eqbList l1 l2) true
Hhd : eq (Pos.eqb a a0) true
IHl2 : iff (eq (eqbList (cons a l1) l2) true) (eqList (cons a l1) l2)
l2 : list positive
a0 : positive
IHl1 : forall l2 : list positive, iff (eq (eqbList l1 l2) true) (eqList l1 l2)
l1 : list positive
a : positive
Ar : Arity
*****
eqList (cons a l1) (cons a0 l2)
+++++
rewrite H in Htl.
-----
Lemma eqbListEqList : forall l1 l2, eqbList l1 l2 = true <-> eqList l1 l2.
Proof.
intro l1.
induction l1.
intro l2.
induction l2.
split.
intro H.
unfold eqbList in H.
apply andb_true_iff in H.
destruct H as [Hhd Htl].
fold eqbList in Htl.
assert (H := IHl1 l2).
rewrite H in Htl.

*****
H : iff (eq (eqbList l1 l2) true) (eqList l1 l2)
Htl : eqList l1 l2
Hhd : eq (Pos.eqb a a0) true
IHl2 : iff (eq (eqbList (cons a l1) l2) true) (eqList (cons a l1) l2)
l2 : list positive
a0 : positive
IHl1 : forall l2 : list positive, iff (eq (eqbList l1 l2) true) (eqList l1 l2)
l1 : list positive
a : positive
Ar : Arity
*****
eqList (cons a l1) (cons a0 l2)
+++++
unfold eqList.
-----
Lemma eqbListEqList : forall l1 l2, eqbList l1 l2 = true <-> eqList l1 l2.
Proof.
intro l1.
induction l1.
intro l2.
induction l2.
split.
intro H.
unfold eqbList in H.
apply andb_true_iff in H.
destruct H as [Hhd Htl].
fold eqbList in Htl.
assert (H := IHl1 l2).
rewrite H in Htl.
unfold eqList.

*****
H : iff (eq (eqbList l1 l2) true) (eqList l1 l2)
Htl : eqList l1 l2
Hhd : eq (Pos.eqb a a0) true
IHl2 : iff (eq (eqbList (cons a l1) l2) true) (eqList (cons a l1) l2)
l2 : list positive
a0 : positive
IHl1 : forall l2 : list positive, iff (eq (eqbList l1 l2) true) (eqList l1 l2)
l1 : list positive
a : positive
Ar : Arity
*****
and (Pos.eq a a0) ((fix eqList (l1 l2 : list positive) {struct l1} : Prop := match l1 with | nil => match l2 with | nil => True | cons _ _ => False end | cons hd1 tl1 => match l2 with | nil => False | cons hd2 tl2 => and (Pos.eq hd1 hd2) (eqList tl1 tl2) end end) l1 l2)
+++++
split.
-----
Lemma eqbListEqList : forall l1 l2, eqbList l1 l2 = true <-> eqList l1 l2.
Proof.
intro l1.
induction l1.
intro l2.
induction l2.
split.
intro H.
unfold eqbList in H.
apply andb_true_iff in H.
destruct H as [Hhd Htl].
fold eqbList in Htl.
assert (H := IHl1 l2).
rewrite H in Htl.
unfold eqList.
split.

*****
H : iff (eq (eqbList l1 l2) true) (eqList l1 l2)
Htl : eqList l1 l2
Hhd : eq (Pos.eqb a a0) true
IHl2 : iff (eq (eqbList (cons a l1) l2) true) (eqList (cons a l1) l2)
l2 : list positive
a0 : positive
IHl1 : forall l2 : list positive, iff (eq (eqbList l1 l2) true) (eqList l1 l2)
l1 : list positive
a : positive
Ar : Arity
*****
Pos.eq a a0
+++++
try assumption.
-----
Lemma eqbListEqList : forall l1 l2, eqbList l1 l2 = true <-> eqList l1 l2.
Proof.
intro l1.
induction l1.
intro l2.
induction l2.
split.
intro H.
unfold eqbList in H.
apply andb_true_iff in H.
destruct H as [Hhd Htl].
fold eqbList in Htl.
assert (H := IHl1 l2).
rewrite H in Htl.
unfold eqList.
split.
try assumption.

*****
H : iff (eq (eqbList l1 l2) true) (eqList l1 l2)
Htl : eqList l1 l2
Hhd : eq (Pos.eqb a a0) true
IHl2 : iff (eq (eqbList (cons a l1) l2) true) (eqList (cons a l1) l2)
l2 : list positive
a0 : positive
IHl1 : forall l2 : list positive, iff (eq (eqbList l1 l2) true) (eqList l1 l2)
l1 : list positive
a : positive
Ar : Arity
*****
Pos.eq a a0
+++++
rewrite PositiveSet.E.eqb_eq in Hhd.
-----
Lemma eqbListEqList : forall l1 l2, eqbList l1 l2 = true <-> eqList l1 l2.
Proof.
intro l1.
induction l1.
intro l2.
induction l2.
split.
intro H.
unfold eqbList in H.
apply andb_true_iff in H.
destruct H as [Hhd Htl].
fold eqbList in Htl.
assert (H := IHl1 l2).
rewrite H in Htl.
unfold eqList.
split.
try assumption.
rewrite PositiveSet.E.eqb_eq in Hhd.

*****
H : iff (eq (eqbList l1 l2) true) (eqList l1 l2)
Htl : eqList l1 l2
Hhd : eq a a0
IHl2 : iff (eq (eqbList (cons a l1) l2) true) (eqList (cons a l1) l2)
l2 : list positive
a0 : positive
IHl1 : forall l2 : list positive, iff (eq (eqbList l1 l2) true) (eqList l1 l2)
l1 : list positive
a : positive
Ar : Arity
*****
Pos.eq a a0
+++++
subst.
-----
Lemma eqbListEqList : forall l1 l2, eqbList l1 l2 = true <-> eqList l1 l2.
Proof.
intro l1.
induction l1.
intro l2.
induction l2.
split.
intro H.
unfold eqbList in H.
apply andb_true_iff in H.
destruct H as [Hhd Htl].
fold eqbList in Htl.
assert (H := IHl1 l2).
rewrite H in Htl.
unfold eqList.
split.
try assumption.
rewrite PositiveSet.E.eqb_eq in Hhd.
subst.

*****
H : iff (eq (eqbList l1 l2) true) (eqList l1 l2)
Htl : eqList l1 l2
IHl2 : iff (eq (eqbList (cons a0 l1) l2) true) (eqList (cons a0 l1) l2)
l2 : list positive
a0 : positive
IHl1 : forall l2 : list positive, iff (eq (eqbList l1 l2) true) (eqList l1 l2)
l1 : list positive
Ar : Arity
*****
Pos.eq a0 a0
+++++
reflexivity.
-----
Lemma eqbListEqList : forall l1 l2, eqbList l1 l2 = true <-> eqList l1 l2.
Proof.
intro l1.
induction l1.
intro l2.
induction l2.
split.
intro H.
unfold eqbList in H.
apply andb_true_iff in H.
destruct H as [Hhd Htl].
fold eqbList in Htl.
assert (H := IHl1 l2).
rewrite H in Htl.
unfold eqList.
split.

*****
H : iff (eq (eqbList l1 l2) true) (eqList l1 l2)
Htl : eqList l1 l2
Hhd : eq (Pos.eqb a a0) true
IHl2 : iff (eq (eqbList (cons a l1) l2) true) (eqList (cons a l1) l2)
l2 : list positive
a0 : positive
IHl1 : forall l2 : list positive, iff (eq (eqbList l1 l2) true) (eqList l1 l2)
l1 : list positive
a : positive
Ar : Arity
*****
(fix eqList (l1 l2 : list positive) {struct l1} : Prop := match l1 with | nil => match l2 with | nil => True | cons _ _ => False end | cons hd1 tl1 => match l2 with | nil => False | cons hd2 tl2 => and (Pos.eq hd1 hd2) (eqList tl1 tl2) end end) l1 l2
+++++
try assumption.
-----
Lemma eqbListEqList : forall l1 l2, eqbList l1 l2 = true <-> eqList l1 l2.
Proof.
intro l1.
induction l1.
intro l2.
induction l2.
split.

*****
IHl2 : iff (eq (eqbList (cons a l1) l2) true) (eqList (cons a l1) l2)
l2 : list positive
a0 : positive
IHl1 : forall l2 : list positive, iff (eq (eqbList l1 l2) true) (eqList l1 l2)
l1 : list positive
a : positive
Ar : Arity
*****
forall _ : eqList (cons a l1) (cons a0 l2), eq (eqbList (cons a l1) (cons a0 l2)) true
+++++
intro H.
-----
Lemma eqbListEqList : forall l1 l2, eqbList l1 l2 = true <-> eqList l1 l2.
Proof.
intro l1.
induction l1.
intro l2.
induction l2.
split.
intro H.

*****
H : eqList (cons a l1) (cons a0 l2)
IHl2 : iff (eq (eqbList (cons a l1) l2) true) (eqList (cons a l1) l2)
l2 : list positive
a0 : positive
IHl1 : forall l2 : list positive, iff (eq (eqbList l1 l2) true) (eqList l1 l2)
l1 : list positive
a : positive
Ar : Arity
*****
eq (eqbList (cons a l1) (cons a0 l2)) true
+++++
apply andb_true_iff.
-----
Lemma eqbListEqList : forall l1 l2, eqbList l1 l2 = true <-> eqList l1 l2.
Proof.
intro l1.
induction l1.
intro l2.
induction l2.
split.
intro H.
apply andb_true_iff.

*****
H : eqList (cons a l1) (cons a0 l2)
IHl2 : iff (eq (eqbList (cons a l1) l2) true) (eqList (cons a l1) l2)
l2 : list positive
a0 : positive
IHl1 : forall l2 : list positive, iff (eq (eqbList l1 l2) true) (eqList l1 l2)
l1 : list positive
a : positive
Ar : Arity
*****
and (eq (Pos.eqb a a0) true) (eq ((fix eqbList (l1 l2 : list positive) {struct l1} : bool := match l1 with | nil => match l2 with | nil => true | cons _ _ => false end | cons hd1 tl1 => match l2 with | nil => false | cons hd2 tl2 => andb (Pos.eqb hd1 hd2) (eqbList tl1 tl2) end end) l1 l2) true)
+++++
rewrite PositiveSet.E.eqb_eq.
-----
Lemma eqbListEqList : forall l1 l2, eqbList l1 l2 = true <-> eqList l1 l2.
Proof.
intro l1.
induction l1.
intro l2.
induction l2.
split.
intro H.
apply andb_true_iff.
rewrite PositiveSet.E.eqb_eq.

*****
H : eqList (cons a l1) (cons a0 l2)
IHl2 : iff (eq (eqbList (cons a l1) l2) true) (eqList (cons a l1) l2)
l2 : list positive
a0 : positive
IHl1 : forall l2 : list positive, iff (eq (eqbList l1 l2) true) (eqList l1 l2)
l1 : list positive
a : positive
Ar : Arity
*****
and (eq a a0) (eq ((fix eqbList (l1 l2 : list positive) {struct l1} : bool := match l1 with | nil => match l2 with | nil => true | cons _ _ => false end | cons hd1 tl1 => match l2 with | nil => false | cons hd2 tl2 => andb (Pos.eqb hd1 hd2) (eqbList tl1 tl2) end end) l1 l2) true)
+++++
fold eqbList.
-----
Lemma eqbListEqList : forall l1 l2, eqbList l1 l2 = true <-> eqList l1 l2.
Proof.
intro l1.
induction l1.
intro l2.
induction l2.
split.
intro H.
apply andb_true_iff.
rewrite PositiveSet.E.eqb_eq.
fold eqbList.

*****
H : eqList (cons a l1) (cons a0 l2)
IHl2 : iff (eq (eqbList (cons a l1) l2) true) (eqList (cons a l1) l2)
l2 : list positive
a0 : positive
IHl1 : forall l2 : list positive, iff (eq (eqbList l1 l2) true) (eqList l1 l2)
l1 : list positive
a : positive
Ar : Arity
*****
and (eq a a0) (eq (eqbList l1 l2) true)
+++++
unfold eqList in H.
-----
Lemma eqbListEqList : forall l1 l2, eqbList l1 l2 = true <-> eqList l1 l2.
Proof.
intro l1.
induction l1.
intro l2.
induction l2.
split.
intro H.
apply andb_true_iff.
rewrite PositiveSet.E.eqb_eq.
fold eqbList.
unfold eqList in H.

*****
H : and (Pos.eq a a0)\n ((fix eqList (l1 l2 : list positive) {struct l1} : Prop :=\n match l1 with\n | nil => match l2 with\n | nil => True\n | cons _ _ => False\n end\n | cons hd1 tl1 =>\n match l2 with\n | nil => False\n | cons hd2 tl2 => and (Pos.eq hd1 hd2) (eqList tl1 tl2)\n end\n end) l1 l2)
IHl2 : iff (eq (eqbList (cons a l1) l2) true) (eqList (cons a l1) l2)
l2 : list positive
a0 : positive
IHl1 : forall l2 : list positive, iff (eq (eqbList l1 l2) true) (eqList l1 l2)
l1 : list positive
a : positive
Ar : Arity
*****
and (eq a a0) (eq (eqbList l1 l2) true)
+++++
destruct H as [Hhd Htl].
-----
Lemma eqbListEqList : forall l1 l2, eqbList l1 l2 = true <-> eqList l1 l2.
Proof.
intro l1.
induction l1.
intro l2.
induction l2.
split.
intro H.
apply andb_true_iff.
rewrite PositiveSet.E.eqb_eq.
fold eqbList.
unfold eqList in H.
destruct H as [Hhd Htl].

*****
Htl : (fix eqList (l1 l2 : list positive) {struct l1} : Prop :=\n match l1 with\n | nil => match l2 with\n | nil => True\n | cons _ _ => False\n end\n | cons hd1 tl1 =>\n match l2 with\n | nil => False\n | cons hd2 tl2 => and (Pos.eq hd1 hd2) (eqList tl1 tl2)\n end\n end) l1 l2
Hhd : Pos.eq a a0
IHl2 : iff (eq (eqbList (cons a l1) l2) true) (eqList (cons a l1) l2)
l2 : list positive
a0 : positive
IHl1 : forall l2 : list positive, iff (eq (eqbList l1 l2) true) (eqList l1 l2)
l1 : list positive
a : positive
Ar : Arity
*****
and (eq a a0) (eq (eqbList l1 l2) true)
+++++
fold eqList in Htl.
-----
Lemma eqbListEqList : forall l1 l2, eqbList l1 l2 = true <-> eqList l1 l2.
Proof.
intro l1.
induction l1.
intro l2.
induction l2.
split.
intro H.
apply andb_true_iff.
rewrite PositiveSet.E.eqb_eq.
fold eqbList.
unfold eqList in H.
destruct H as [Hhd Htl].
fold eqList in Htl.

*****
Htl : eqList l1 l2
Hhd : Pos.eq a a0
IHl2 : iff (eq (eqbList (cons a l1) l2) true) (eqList (cons a l1) l2)
l2 : list positive
a0 : positive
IHl1 : forall l2 : list positive, iff (eq (eqbList l1 l2) true) (eqList l1 l2)
l1 : list positive
a : positive
Ar : Arity
*****
and (eq a a0) (eq (eqbList l1 l2) true)
+++++
assert (H := IHl1 l2).
-----
Lemma eqbListEqList : forall l1 l2, eqbList l1 l2 = true <-> eqList l1 l2.
Proof.
intro l1.
induction l1.
intro l2.
induction l2.
split.
intro H.
apply andb_true_iff.
rewrite PositiveSet.E.eqb_eq.
fold eqbList.
unfold eqList in H.
destruct H as [Hhd Htl].
fold eqList in Htl.
assert (H := IHl1 l2).

*****
H : iff (eq (eqbList l1 l2) true) (eqList l1 l2)
Htl : eqList l1 l2
Hhd : Pos.eq a a0
IHl2 : iff (eq (eqbList (cons a l1) l2) true) (eqList (cons a l1) l2)
l2 : list positive
a0 : positive
IHl1 : forall l2 : list positive, iff (eq (eqbList l1 l2) true) (eqList l1 l2)
l1 : list positive
a : positive
Ar : Arity
*****
and (eq a a0) (eq (eqbList l1 l2) true)
+++++
rewrite <- H in Htl.
-----
Lemma eqbListEqList : forall l1 l2, eqbList l1 l2 = true <-> eqList l1 l2.
Proof.
intro l1.
induction l1.
intro l2.
induction l2.
split.
intro H.
apply andb_true_iff.
rewrite PositiveSet.E.eqb_eq.
fold eqbList.
unfold eqList in H.
destruct H as [Hhd Htl].
fold eqList in Htl.
assert (H := IHl1 l2).
rewrite <- H in Htl.

*****
H : iff (eq (eqbList l1 l2) true) (eqList l1 l2)
Htl : eq (eqbList l1 l2) true
Hhd : Pos.eq a a0
IHl2 : iff (eq (eqbList (cons a l1) l2) true) (eqList (cons a l1) l2)
l2 : list positive
a0 : positive
IHl1 : forall l2 : list positive, iff (eq (eqbList l1 l2) true) (eqList l1 l2)
l1 : list positive
a : positive
Ar : Arity
*****
and (eq a a0) (eq (eqbList l1 l2) true)
+++++
split.
-----
Lemma eqbListEqList : forall l1 l2, eqbList l1 l2 = true <-> eqList l1 l2.
Proof.
intro l1.
induction l1.
intro l2.
induction l2.
split.
intro H.
apply andb_true_iff.
rewrite PositiveSet.E.eqb_eq.
fold eqbList.
unfold eqList in H.
destruct H as [Hhd Htl].
fold eqList in Htl.
assert (H := IHl1 l2).
rewrite <- H in Htl.
split.

*****
H : iff (eq (eqbList l1 l2) true) (eqList l1 l2)
Htl : eq (eqbList l1 l2) true
Hhd : Pos.eq a a0
IHl2 : iff (eq (eqbList (cons a l1) l2) true) (eqList (cons a l1) l2)
l2 : list positive
a0 : positive
IHl1 : forall l2 : list positive, iff (eq (eqbList l1 l2) true) (eqList l1 l2)
l1 : list positive
a : positive
Ar : Arity
*****
eq a a0
+++++
assumption.
-----
Lemma eqbListEqList : forall l1 l2, eqbList l1 l2 = true <-> eqList l1 l2.
Proof.
intro l1.
induction l1.
intro l2.
induction l2.
split.
intro H.
apply andb_true_iff.
rewrite PositiveSet.E.eqb_eq.
fold eqbList.
unfold eqList in H.
destruct H as [Hhd Htl].
fold eqList in Htl.
assert (H := IHl1 l2).
rewrite <- H in Htl.
split.

*****
H : iff (eq (eqbList l1 l2) true) (eqList l1 l2)
Htl : eq (eqbList l1 l2) true
Hhd : Pos.eq a a0
IHl2 : iff (eq (eqbList (cons a l1) l2) true) (eqList (cons a l1) l2)
l2 : list positive
a0 : positive
IHl1 : forall l2 : list positive, iff (eq (eqbList l1 l2) true) (eqList l1 l2)
l1 : list positive
a : positive
Ar : Arity
*****
eq (eqbList l1 l2) true
+++++
assumption.
-----
Lemma eqbListEqList : forall l1 l2, eqbList l1 l2 = true <-> eqList l1 l2.
Proof.
intro l1.
induction l1.

*****

*****

+++++
Qed.
-----
Definition eqbST (cp1 cp2 : tST) :=\n    eqbList (PosSort.sort (CPToList cp1)) (PosSort.sort (CPToList cp2)).
-----
Lemma eqbST_eqST : forall cp1 cp2, eqbST cp1 cp2 = true <-> eqST cp1 cp2.
-----
Lemma eqbST_eqST : forall cp1 cp2, eqbST cp1 cp2 = true <-> eqST cp1 cp2.

*****
Ar : Arity
*****
forall cp1 cp2 : tST, iff (eq (eqbST cp1 cp2) true) (eqST cp1 cp2)
+++++
Proof.
-----
Lemma eqbST_eqST : forall cp1 cp2, eqbST cp1 cp2 = true <-> eqST cp1 cp2.
Proof.

*****
Ar : Arity
*****
forall cp1 cp2 : tST, iff (eq (eqbST cp1 cp2) true) (eqST cp1 cp2)
+++++
intros.
-----
Lemma eqbST_eqST : forall cp1 cp2, eqbST cp1 cp2 = true <-> eqST cp1 cp2.
Proof.
intros.

*****
cp1,cp2 : tST
Ar : Arity
*****
iff (eq (eqbST cp1 cp2) true) (eqST cp1 cp2)
+++++
unfold eqbST.
-----
Lemma eqbST_eqST : forall cp1 cp2, eqbST cp1 cp2 = true <-> eqST cp1 cp2.
Proof.
intros.
unfold eqbST.

*****
cp1,cp2 : tST
Ar : Arity
*****
iff (eq (eqbList (sort (CPToList cp1)) (sort (CPToList cp2))) true) (eqST cp1 cp2)
+++++
unfold eqST.
-----
Lemma eqbST_eqST : forall cp1 cp2, eqbST cp1 cp2 = true <-> eqST cp1 cp2.
Proof.
intros.
unfold eqbST.
unfold eqST.

*****
cp1,cp2 : tST
Ar : Arity
*****
iff (eq (eqbList (sort (CPToList cp1)) (sort (CPToList cp2))) true) (eqList (sort (CPToList cp1)) (sort (CPToList cp2)))
+++++
apply eqbListEqList.
-----
Lemma eqbST_eqST : forall cp1 cp2, eqbST cp1 cp2 = true <-> eqST cp1 cp2.
Proof.
intros.
unfold eqbST.
unfold eqST.
apply eqbListEqList.

*****

*****

+++++
Qed.
-----
Fixpoint ltList (l1 l2 : list positive) :=\n    match l1, l2 with\n      | nil, nil => False\n      | (hd1 :: tl1), (hd2 :: tl2) => if (Pos.ltb hd1 hd2) then True\n                                      else if (Pos.ltb hd2 hd1) then False\n                                           else (ltList tl1 tl2)\n      | nil, _ => True\n      | _, nil => False\n    end.
-----
Lemma lengthOne : forall (l : list positive),\n    length l = 1 -> exists a, l = a :: nil.
-----
Lemma lengthOne : forall (l : list positive), length l = 1 -> exists a, l = a :: nil.

*****
Ar : Arity
*****
forall (l : list positive) (_ : eq (length l) (S O)), ex (fun a : positive => eq l (cons a nil))
+++++
Proof.
-----
Lemma lengthOne : forall (l : list positive), length l = 1 -> exists a, l = a :: nil.
Proof.

*****
Ar : Arity
*****
forall (l : list positive) (_ : eq (length l) (S O)), ex (fun a : positive => eq l (cons a nil))
+++++
intros l Hl.
-----
Lemma lengthOne : forall (l : list positive), length l = 1 -> exists a, l = a :: nil.
Proof.
intros l Hl.

*****
Hl : eq (length l) (S O)
l : list positive
Ar : Arity
*****
ex (fun a : positive => eq l (cons a nil))
+++++
induction l.
-----
Lemma lengthOne : forall (l : list positive), length l = 1 -> exists a, l = a :: nil.
Proof.
intros l Hl.
induction l.

*****
Hl : eq (length nil) (S O)
Ar : Arity
*****
ex (fun a : positive => eq nil (cons a nil))
+++++
simpl in Hl.
-----
Lemma lengthOne : forall (l : list positive), length l = 1 -> exists a, l = a :: nil.
Proof.
intros l Hl.
induction l.
simpl in Hl.

*****
Hl : eq O (S O)
Ar : Arity
*****
ex (fun a : positive => eq nil (cons a nil))
+++++
discriminate.
-----
Lemma lengthOne : forall (l : list positive), length l = 1 -> exists a, l = a :: nil.
Proof.
intros l Hl.
induction l.

*****
IHl : forall _ : eq (length l) (S O),\nex (fun a : positive => eq l (cons a nil))
Hl : eq (length (cons a l)) (S O)
l : list positive
a : positive
Ar : Arity
*****
ex (fun a0 : positive => eq (cons a l) (cons a0 nil))
+++++
induction l.
-----
Lemma lengthOne : forall (l : list positive), length l = 1 -> exists a, l = a :: nil.
Proof.
intros l Hl.
induction l.
induction l.

*****
IHl : forall _ : eq (length nil) (S O),\nex (fun a : positive => eq nil (cons a nil))
Hl : eq (length (cons a nil)) (S O)
a : positive
Ar : Arity
*****
ex (fun a0 : positive => eq (cons a nil) (cons a0 nil))
+++++
exists a.
-----
Lemma lengthOne : forall (l : list positive), length l = 1 -> exists a, l = a :: nil.
Proof.
intros l Hl.
induction l.
induction l.
exists a.

*****
IHl : forall _ : eq (length nil) (S O),\nex (fun a : positive => eq nil (cons a nil))
Hl : eq (length (cons a nil)) (S O)
a : positive
Ar : Arity
*****
eq (cons a nil) (cons a nil)
+++++
reflexivity.
-----
Lemma lengthOne : forall (l : list positive), length l = 1 -> exists a, l = a :: nil.
Proof.
intros l Hl.
induction l.
induction l.

*****
IHl0 : forall (_ : eq (length (cons a l)) (S O))\n (_ : forall _ : eq (length l) (S O),\n ex (fun a : positive => eq l (cons a nil))),\nex (fun a0 : positive => eq (cons a l) (cons a0 nil))
IHl : forall _ : eq (length (cons a0 l)) (S O),\nex (fun a : positive => eq (cons a0 l) (cons a nil))
Hl : eq (length (cons a (cons a0 l))) (S O)
l : list positive
a,a0 : positive
Ar : Arity
*****
ex (fun a1 : positive => eq (cons a (cons a0 l)) (cons a1 nil))
+++++
simpl in Hl.
-----
Lemma lengthOne : forall (l : list positive), length l = 1 -> exists a, l = a :: nil.
Proof.
intros l Hl.
induction l.
induction l.
simpl in Hl.

*****
IHl0 : forall (_ : eq (length (cons a l)) (S O))\n (_ : forall _ : eq (length l) (S O),\n ex (fun a : positive => eq l (cons a nil))),\nex (fun a0 : positive => eq (cons a l) (cons a0 nil))
IHl : forall _ : eq (length (cons a0 l)) (S O),\nex (fun a : positive => eq (cons a0 l) (cons a nil))
Hl : eq (S (S (length l))) (S O)
l : list positive
a,a0 : positive
Ar : Arity
*****
ex (fun a1 : positive => eq (cons a (cons a0 l)) (cons a1 nil))
+++++
discriminate.
-----
Lemma lengthOne : forall (l : list positive), length l = 1 -> exists a, l = a :: nil.
Proof.
intros l Hl.
induction l.

*****

*****

+++++
Qed.
-----
Lemma lengthAtLeastOne : forall (l : list positive) n,\n    length l = (S n) -> exists a0 l0, l = a0 :: l0.
-----
Lemma lengthAtLeastOne : forall (l : list positive) n, length l = (S n) -> exists a0 l0, l = a0 :: l0.

*****
Ar : Arity
*****
forall (l : list positive) (n : nat) (_ : eq (length l) (S n)), ex (fun a0 : positive => ex (fun l0 : list positive => eq l (cons a0 l0)))
+++++
Proof.
-----
Lemma lengthAtLeastOne : forall (l : list positive) n, length l = (S n) -> exists a0 l0, l = a0 :: l0.
Proof.

*****
Ar : Arity
*****
forall (l : list positive) (n : nat) (_ : eq (length l) (S n)), ex (fun a0 : positive => ex (fun l0 : list positive => eq l (cons a0 l0)))
+++++
intros l n Hl.
-----
Lemma lengthAtLeastOne : forall (l : list positive) n, length l = (S n) -> exists a0 l0, l = a0 :: l0.
Proof.
intros l n Hl.

*****
Hl : eq (length l) (S n)
n : nat
l : list positive
Ar : Arity
*****
ex (fun a0 : positive => ex (fun l0 : list positive => eq l (cons a0 l0)))
+++++
induction l.
-----
Lemma lengthAtLeastOne : forall (l : list positive) n, length l = (S n) -> exists a0 l0, l = a0 :: l0.
Proof.
intros l n Hl.
induction l.

*****
Hl : eq (length nil) (S n)
n : nat
Ar : Arity
*****
ex (fun a0 : positive => ex (fun l0 : list positive => eq nil (cons a0 l0)))
+++++
simpl in Hl.
-----
Lemma lengthAtLeastOne : forall (l : list positive) n, length l = (S n) -> exists a0 l0, l = a0 :: l0.
Proof.
intros l n Hl.
induction l.
simpl in Hl.

*****
Hl : eq O (S n)
n : nat
Ar : Arity
*****
ex (fun a0 : positive => ex (fun l0 : list positive => eq nil (cons a0 l0)))
+++++
discriminate.
-----
Lemma lengthAtLeastOne : forall (l : list positive) n, length l = (S n) -> exists a0 l0, l = a0 :: l0.
Proof.
intros l n Hl.
induction l.

*****
IHl : forall _ : eq (length l) (S n),\nex\n (fun a0 : positive =>\n ex (fun l0 : list positive => eq l (cons a0 l0)))
Hl : eq (length (cons a l)) (S n)
n : nat
l : list positive
a : positive
Ar : Arity
*****
ex (fun a0 : positive => ex (fun l0 : list positive => eq (cons a l) (cons a0 l0)))
+++++
exists a.
-----
Lemma lengthAtLeastOne : forall (l : list positive) n, length l = (S n) -> exists a0 l0, l = a0 :: l0.
Proof.
intros l n Hl.
induction l.
exists a.

*****
IHl : forall _ : eq (length l) (S n),\nex\n (fun a0 : positive =>\n ex (fun l0 : list positive => eq l (cons a0 l0)))
Hl : eq (length (cons a l)) (S n)
n : nat
l : list positive
a : positive
Ar : Arity
*****
ex (fun l0 : list positive => eq (cons a l) (cons a l0))
+++++
exists l.
-----
Lemma lengthAtLeastOne : forall (l : list positive) n, length l = (S n) -> exists a0 l0, l = a0 :: l0.
Proof.
intros l n Hl.
induction l.
exists a.
exists l.

*****
IHl : forall _ : eq (length l) (S n),\nex\n (fun a0 : positive =>\n ex (fun l0 : list positive => eq l (cons a0 l0)))
Hl : eq (length (cons a l)) (S n)
n : nat
l : list positive
a : positive
Ar : Arity
*****
eq (cons a l) (cons a l)
+++++
reflexivity.
-----
Lemma lengthAtLeastOne : forall (l : list positive) n, length l = (S n) -> exists a0 l0, l = a0 :: l0.
Proof.
intros l n Hl.
induction l.

*****

*****

+++++
Qed.
-----
Lemma ltListTrans : forall m x y z,\n    length x = (S m) ->\n    length y = (S m) ->\n    length z = (S m) ->\n    ltList x y -> ltList y z -> ltList x z.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.

*****
Ar : Arity
*****
forall (m : nat) (x y z : list positive) (_ : eq (length x) (S m)) (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) (_ : ltList x y) (_ : ltList y z), ltList x z
+++++
Proof.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.

*****
Ar : Arity
*****
forall (m : nat) (x y z : list positive) (_ : eq (length x) (S m)) (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) (_ : ltList x y) (_ : ltList y z), ltList x z
+++++
intro m.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.

*****
m : nat
Ar : Arity
*****
forall (x y z : list positive) (_ : eq (length x) (S m)) (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) (_ : ltList x y) (_ : ltList y z), ltList x z
+++++
induction m.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.

*****
Ar : Arity
*****
forall (x y z : list positive) (_ : eq (length x) (S O)) (_ : eq (length y) (S O)) (_ : eq (length z) (S O)) (_ : ltList x y) (_ : ltList y z), ltList x z
+++++
intros x y z lx ly lz Hxy Hyz.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.

*****
Hyz : ltList y z
Hxy : ltList x y
lz : eq (length z) (S O)
ly : eq (length y) (S O)
lx : eq (length x) (S O)
x,y,z : list positive
Ar : Arity
*****
ltList x z
+++++
assert (Hx := lengthOne x lx).
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthOne x lx).

*****
Hx : ex (fun a : positive => eq x (cons a nil))
Hyz : ltList y z
Hxy : ltList x y
lz : eq (length z) (S O)
ly : eq (length y) (S O)
lx : eq (length x) (S O)
x,y,z : list positive
Ar : Arity
*****
ltList x z
+++++
destruct Hx as [hdx Hx].
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthOne x lx).
destruct Hx as [hdx Hx].

*****
Hx : eq x (cons hdx nil)
hdx : positive
Hyz : ltList y z
Hxy : ltList x y
lz : eq (length z) (S O)
ly : eq (length y) (S O)
lx : eq (length x) (S O)
x,y,z : list positive
Ar : Arity
*****
ltList x z
+++++
assert (Hy := lengthOne y ly).
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthOne x lx).
destruct Hx as [hdx Hx].
assert (Hy := lengthOne y ly).

*****
Hy : ex (fun a : positive => eq y (cons a nil))
Hx : eq x (cons hdx nil)
hdx : positive
Hyz : ltList y z
Hxy : ltList x y
lz : eq (length z) (S O)
ly : eq (length y) (S O)
lx : eq (length x) (S O)
x,y,z : list positive
Ar : Arity
*****
ltList x z
+++++
destruct Hy as [hdy Hy].
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthOne x lx).
destruct Hx as [hdx Hx].
assert (Hy := lengthOne y ly).
destruct Hy as [hdy Hy].

*****
Hy : eq y (cons hdy nil)
hdy : positive
Hx : eq x (cons hdx nil)
hdx : positive
Hyz : ltList y z
Hxy : ltList x y
lz : eq (length z) (S O)
ly : eq (length y) (S O)
lx : eq (length x) (S O)
x,y,z : list positive
Ar : Arity
*****
ltList x z
+++++
assert (Hz := lengthOne z lz).
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthOne x lx).
destruct Hx as [hdx Hx].
assert (Hy := lengthOne y ly).
destruct Hy as [hdy Hy].
assert (Hz := lengthOne z lz).

*****
Hz : ex (fun a : positive => eq z (cons a nil))
Hy : eq y (cons hdy nil)
hdy : positive
Hx : eq x (cons hdx nil)
hdx : positive
Hyz : ltList y z
Hxy : ltList x y
lz : eq (length z) (S O)
ly : eq (length y) (S O)
lx : eq (length x) (S O)
x,y,z : list positive
Ar : Arity
*****
ltList x z
+++++
destruct Hz as [hdz Hz].
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthOne x lx).
destruct Hx as [hdx Hx].
assert (Hy := lengthOne y ly).
destruct Hy as [hdy Hy].
assert (Hz := lengthOne z lz).
destruct Hz as [hdz Hz].

*****
Hz : eq z (cons hdz nil)
hdz : positive
Hy : eq y (cons hdy nil)
hdy : positive
Hx : eq x (cons hdx nil)
hdx : positive
Hyz : ltList y z
Hxy : ltList x y
lz : eq (length z) (S O)
ly : eq (length y) (S O)
lx : eq (length x) (S O)
x,y,z : list positive
Ar : Arity
*****
ltList x z
+++++
subst.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthOne x lx).
destruct Hx as [hdx Hx].
assert (Hy := lengthOne y ly).
destruct Hy as [hdy Hy].
assert (Hz := lengthOne z lz).
destruct Hz as [hdz Hz].
subst.

*****
Hxy : ltList (cons hdx nil) (cons hdy nil)
lz : eq (length (cons hdz nil)) (S O)
Hyz : ltList (cons hdy nil) (cons hdz nil)
hdz : positive
ly : eq (length (cons hdy nil)) (S O)
hdy : positive
lx : eq (length (cons hdx nil)) (S O)
hdx : positive
Ar : Arity
*****
ltList (cons hdx nil) (cons hdz nil)
+++++
simpl in *.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthOne x lx).
destruct Hx as [hdx Hx].
assert (Hy := lengthOne y ly).
destruct Hy as [hdy Hy].
assert (Hz := lengthOne z lz).
destruct Hz as [hdz Hz].
subst.
simpl in *.

*****
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else False
lz : eq (S O) (S O)
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else False
hdz : positive
ly : eq (S O) (S O)
hdy : positive
lx : eq (S O) (S O)
hdx : positive
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else False
+++++
assert (H : Pos.ltb hdx hdz = true).
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthOne x lx).
destruct Hx as [hdx Hx].
assert (Hy := lengthOne y ly).
destruct Hy as [hdy Hy].
assert (Hz := lengthOne z lz).
destruct Hz as [hdz Hz].
subst.
simpl in *.
assert (H : Pos.ltb hdx hdz = true).

*****
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else False
lz : eq (S O) (S O)
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else False
hdz : positive
ly : eq (S O) (S O)
hdy : positive
lx : eq (S O) (S O)
hdx : positive
Ar : Arity
*****
eq (Pos.ltb hdx hdz) true
+++++
rewrite Pos.ltb_lt.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthOne x lx).
destruct Hx as [hdx Hx].
assert (Hy := lengthOne y ly).
destruct Hy as [hdy Hy].
assert (Hz := lengthOne z lz).
destruct Hz as [hdz Hz].
subst.
simpl in *.
assert (H : Pos.ltb hdx hdz = true).
rewrite Pos.ltb_lt.

*****
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else False
lz : eq (S O) (S O)
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else False
hdz : positive
ly : eq (S O) (S O)
hdy : positive
lx : eq (S O) (S O)
hdx : positive
Ar : Arity
*****
Pos.lt hdx hdz
+++++
transitivity hdy.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthOne x lx).
destruct Hx as [hdx Hx].
assert (Hy := lengthOne y ly).
destruct Hy as [hdy Hy].
assert (Hz := lengthOne z lz).
destruct Hz as [hdz Hz].
subst.
simpl in *.
assert (H : Pos.ltb hdx hdz = true).
rewrite Pos.ltb_lt.
transitivity hdy.

*****
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else False
lz : eq (S O) (S O)
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else False
hdz : positive
ly : eq (S O) (S O)
hdy : positive
lx : eq (S O) (S O)
hdx : positive
Ar : Arity
*****
Pos.lt hdx hdy
+++++
rewrite <- Pos.ltb_lt.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthOne x lx).
destruct Hx as [hdx Hx].
assert (Hy := lengthOne y ly).
destruct Hy as [hdy Hy].
assert (Hz := lengthOne z lz).
destruct Hz as [hdz Hz].
subst.
simpl in *.
assert (H : Pos.ltb hdx hdz = true).
rewrite Pos.ltb_lt.
transitivity hdy.
rewrite <- Pos.ltb_lt.

*****
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else False
lz : eq (S O) (S O)
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else False
hdz : positive
ly : eq (S O) (S O)
hdy : positive
lx : eq (S O) (S O)
hdx : positive
Ar : Arity
*****
eq (Pos.ltb hdx hdy) true
+++++
induction (Pos.ltb hdx hdy).
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthOne x lx).
destruct Hx as [hdx Hx].
assert (Hy := lengthOne y ly).
destruct Hy as [hdy Hy].
assert (Hz := lengthOne z lz).
destruct Hz as [hdz Hz].
subst.
simpl in *.
assert (H : Pos.ltb hdx hdz = true).
rewrite Pos.ltb_lt.
transitivity hdy.
rewrite <- Pos.ltb_lt.
induction (Pos.ltb hdx hdy).

*****
Hxy : True
lz : eq (S O) (S O)
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else False
hdz : positive
ly : eq (S O) (S O)
hdy : positive
lx : eq (S O) (S O)
hdx : positive
Ar : Arity
*****
eq true true
+++++
intuition.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthOne x lx).
destruct Hx as [hdx Hx].
assert (Hy := lengthOne y ly).
destruct Hy as [hdy Hy].
assert (Hz := lengthOne z lz).
destruct Hz as [hdz Hz].
subst.
simpl in *.
assert (H : Pos.ltb hdx hdz = true).
rewrite Pos.ltb_lt.
transitivity hdy.
rewrite <- Pos.ltb_lt.
induction (Pos.ltb hdx hdy).

*****
Hxy : if Pos.ltb hdy hdx then False else False
lz : eq (S O) (S O)
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else False
hdz : positive
ly : eq (S O) (S O)
hdy : positive
lx : eq (S O) (S O)
hdx : positive
Ar : Arity
*****
eq false true
+++++
intuition.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthOne x lx).
destruct Hx as [hdx Hx].
assert (Hy := lengthOne y ly).
destruct Hy as [hdy Hy].
assert (Hz := lengthOne z lz).
destruct Hz as [hdz Hz].
subst.
simpl in *.
assert (H : Pos.ltb hdx hdz = true).
rewrite Pos.ltb_lt.
transitivity hdy.
rewrite <- Pos.ltb_lt.
induction (Pos.ltb hdx hdy).
intuition.

*****
Hxy : if Pos.ltb hdy hdx then False else False
lz : eq (S O) (S O)
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else False
hdz : positive
ly : eq (S O) (S O)
hdy : positive
lx : eq (S O) (S O)
hdx : positive
Ar : Arity
*****
eq false true
+++++
induction (Pos.ltb hdy hdx).
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthOne x lx).
destruct Hx as [hdx Hx].
assert (Hy := lengthOne y ly).
destruct Hy as [hdy Hy].
assert (Hz := lengthOne z lz).
destruct Hz as [hdz Hz].
subst.
simpl in *.
assert (H : Pos.ltb hdx hdz = true).
rewrite Pos.ltb_lt.
transitivity hdy.
rewrite <- Pos.ltb_lt.
induction (Pos.ltb hdx hdy).
intuition.
induction (Pos.ltb hdy hdx).

*****
Hxy : False
lz : eq (S O) (S O)
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else False
hdz : positive
ly : eq (S O) (S O)
hdy : positive
lx : eq (S O) (S O)
hdx : positive
Ar : Arity
*****
eq false true
+++++
intuition.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthOne x lx).
destruct Hx as [hdx Hx].
assert (Hy := lengthOne y ly).
destruct Hy as [hdy Hy].
assert (Hz := lengthOne z lz).
destruct Hz as [hdz Hz].
subst.
simpl in *.
assert (H : Pos.ltb hdx hdz = true).
rewrite Pos.ltb_lt.
transitivity hdy.
rewrite <- Pos.ltb_lt.
induction (Pos.ltb hdx hdy).
intuition.
induction (Pos.ltb hdy hdx).

*****
Hxy : False
lz : eq (S O) (S O)
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else False
hdz : positive
ly : eq (S O) (S O)
hdy : positive
lx : eq (S O) (S O)
hdx : positive
Ar : Arity
*****
eq false true
+++++
intuition.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthOne x lx).
destruct Hx as [hdx Hx].
assert (Hy := lengthOne y ly).
destruct Hy as [hdy Hy].
assert (Hz := lengthOne z lz).
destruct Hz as [hdz Hz].
subst.
simpl in *.
assert (H : Pos.ltb hdx hdz = true).
rewrite Pos.ltb_lt.
transitivity hdy.

*****
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else False
lz : eq (S O) (S O)
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else False
hdz : positive
ly : eq (S O) (S O)
hdy : positive
lx : eq (S O) (S O)
hdx : positive
Ar : Arity
*****
Pos.lt hdy hdz
+++++
rewrite <- Pos.ltb_lt.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthOne x lx).
destruct Hx as [hdx Hx].
assert (Hy := lengthOne y ly).
destruct Hy as [hdy Hy].
assert (Hz := lengthOne z lz).
destruct Hz as [hdz Hz].
subst.
simpl in *.
assert (H : Pos.ltb hdx hdz = true).
rewrite Pos.ltb_lt.
transitivity hdy.
rewrite <- Pos.ltb_lt.

*****
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else False
lz : eq (S O) (S O)
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else False
hdz : positive
ly : eq (S O) (S O)
hdy : positive
lx : eq (S O) (S O)
hdx : positive
Ar : Arity
*****
eq (Pos.ltb hdy hdz) true
+++++
induction (Pos.ltb hdy hdz).
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthOne x lx).
destruct Hx as [hdx Hx].
assert (Hy := lengthOne y ly).
destruct Hy as [hdy Hy].
assert (Hz := lengthOne z lz).
destruct Hz as [hdz Hz].
subst.
simpl in *.
assert (H : Pos.ltb hdx hdz = true).
rewrite Pos.ltb_lt.
transitivity hdy.
rewrite <- Pos.ltb_lt.
induction (Pos.ltb hdy hdz).

*****
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else False
lz : eq (S O) (S O)
Hyz : True
hdz : positive
ly : eq (S O) (S O)
hdy : positive
lx : eq (S O) (S O)
hdx : positive
Ar : Arity
*****
eq true true
+++++
intuition.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthOne x lx).
destruct Hx as [hdx Hx].
assert (Hy := lengthOne y ly).
destruct Hy as [hdy Hy].
assert (Hz := lengthOne z lz).
destruct Hz as [hdz Hz].
subst.
simpl in *.
assert (H : Pos.ltb hdx hdz = true).
rewrite Pos.ltb_lt.
transitivity hdy.
rewrite <- Pos.ltb_lt.
induction (Pos.ltb hdy hdz).

*****
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else False
lz : eq (S O) (S O)
Hyz : if Pos.ltb hdz hdy then False else False
hdz : positive
ly : eq (S O) (S O)
hdy : positive
lx : eq (S O) (S O)
hdx : positive
Ar : Arity
*****
eq false true
+++++
intuition.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthOne x lx).
destruct Hx as [hdx Hx].
assert (Hy := lengthOne y ly).
destruct Hy as [hdy Hy].
assert (Hz := lengthOne z lz).
destruct Hz as [hdz Hz].
subst.
simpl in *.
assert (H : Pos.ltb hdx hdz = true).
rewrite Pos.ltb_lt.
transitivity hdy.
rewrite <- Pos.ltb_lt.
induction (Pos.ltb hdy hdz).
intuition.

*****
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else False
lz : eq (S O) (S O)
Hyz : if Pos.ltb hdz hdy then False else False
hdz : positive
ly : eq (S O) (S O)
hdy : positive
lx : eq (S O) (S O)
hdx : positive
Ar : Arity
*****
eq false true
+++++
induction (Pos.ltb hdz hdy).
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthOne x lx).
destruct Hx as [hdx Hx].
assert (Hy := lengthOne y ly).
destruct Hy as [hdy Hy].
assert (Hz := lengthOne z lz).
destruct Hz as [hdz Hz].
subst.
simpl in *.
assert (H : Pos.ltb hdx hdz = true).
rewrite Pos.ltb_lt.
transitivity hdy.
rewrite <- Pos.ltb_lt.
induction (Pos.ltb hdy hdz).
intuition.
induction (Pos.ltb hdz hdy).

*****
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else False
lz : eq (S O) (S O)
Hyz : False
hdz : positive
ly : eq (S O) (S O)
hdy : positive
lx : eq (S O) (S O)
hdx : positive
Ar : Arity
*****
eq false true
+++++
intuition.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthOne x lx).
destruct Hx as [hdx Hx].
assert (Hy := lengthOne y ly).
destruct Hy as [hdy Hy].
assert (Hz := lengthOne z lz).
destruct Hz as [hdz Hz].
subst.
simpl in *.
assert (H : Pos.ltb hdx hdz = true).
rewrite Pos.ltb_lt.
transitivity hdy.
rewrite <- Pos.ltb_lt.
induction (Pos.ltb hdy hdz).
intuition.
induction (Pos.ltb hdz hdy).

*****
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else False
lz : eq (S O) (S O)
Hyz : False
hdz : positive
ly : eq (S O) (S O)
hdy : positive
lx : eq (S O) (S O)
hdx : positive
Ar : Arity
*****
eq false true
+++++
intuition.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthOne x lx).
destruct Hx as [hdx Hx].
assert (Hy := lengthOne y ly).
destruct Hy as [hdy Hy].
assert (Hz := lengthOne z lz).
destruct Hz as [hdz Hz].
subst.
simpl in *.
assert (H : Pos.ltb hdx hdz = true).

*****
H : eq (Pos.ltb hdx hdz) true
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else False
lz : eq (S O) (S O)
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else False
hdz : positive
ly : eq (S O) (S O)
hdy : positive
lx : eq (S O) (S O)
hdx : positive
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else False
+++++
rewrite H.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthOne x lx).
destruct Hx as [hdx Hx].
assert (Hy := lengthOne y ly).
destruct Hy as [hdy Hy].
assert (Hz := lengthOne z lz).
destruct Hz as [hdz Hz].
subst.
simpl in *.
assert (H : Pos.ltb hdx hdz = true).
rewrite H.

*****
H : eq (Pos.ltb hdx hdz) true
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else False
lz : eq (S O) (S O)
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else False
hdz : positive
ly : eq (S O) (S O)
hdy : positive
lx : eq (S O) (S O)
hdx : positive
Ar : Arity
*****
True
+++++
trivial.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.

*****
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
forall (x y z : list positive) (_ : eq (length x) (S (S m))) (_ : eq (length y) (S (S m))) (_ : eq (length z) (S (S m))) (_ : ltList x y) (_ : ltList y z), ltList x z
+++++
intros x y z lx ly lz Hxy Hyz.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.

*****
Hyz : ltList y z
Hxy : ltList x y
lz : eq (length z) (S (S m))
ly : eq (length y) (S (S m))
lx : eq (length x) (S (S m))
x,y,z : list positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
ltList x z
+++++
assert (Hx := lengthAtLeastOne x (S m) lx).
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).

*****
Hx : ex\n (fun a0 : positive =>\n ex (fun l0 : list positive => eq x (cons a0 l0)))
Hyz : ltList y z
Hxy : ltList x y
lz : eq (length z) (S (S m))
ly : eq (length y) (S (S m))
lx : eq (length x) (S (S m))
x,y,z : list positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
ltList x z
+++++
destruct Hx as [hdx [tlx Hx]].
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].

*****
Hx : eq x (cons hdx tlx)
tlx : list positive
hdx : positive
Hyz : ltList y z
Hxy : ltList x y
lz : eq (length z) (S (S m))
ly : eq (length y) (S (S m))
lx : eq (length x) (S (S m))
x,y,z : list positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
ltList x z
+++++
assert (Hy := lengthAtLeastOne y (S m) ly).
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).

*****
Hy : ex\n (fun a0 : positive =>\n ex (fun l0 : list positive => eq y (cons a0 l0)))
Hx : eq x (cons hdx tlx)
tlx : list positive
hdx : positive
Hyz : ltList y z
Hxy : ltList x y
lz : eq (length z) (S (S m))
ly : eq (length y) (S (S m))
lx : eq (length x) (S (S m))
x,y,z : list positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
ltList x z
+++++
destruct Hy as [hdy [tly Hy]].
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].

*****
Hy : eq y (cons hdy tly)
tly : list positive
hdy : positive
Hx : eq x (cons hdx tlx)
tlx : list positive
hdx : positive
Hyz : ltList y z
Hxy : ltList x y
lz : eq (length z) (S (S m))
ly : eq (length y) (S (S m))
lx : eq (length x) (S (S m))
x,y,z : list positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
ltList x z
+++++
assert (Hz := lengthAtLeastOne z (S m) lz).
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).

*****
Hz : ex\n (fun a0 : positive =>\n ex (fun l0 : list positive => eq z (cons a0 l0)))
Hy : eq y (cons hdy tly)
tly : list positive
hdy : positive
Hx : eq x (cons hdx tlx)
tlx : list positive
hdx : positive
Hyz : ltList y z
Hxy : ltList x y
lz : eq (length z) (S (S m))
ly : eq (length y) (S (S m))
lx : eq (length x) (S (S m))
x,y,z : list positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
ltList x z
+++++
destruct Hz as [hdz [tlz Hz]].
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].

*****
Hz : eq z (cons hdz tlz)
tlz : list positive
hdz : positive
Hy : eq y (cons hdy tly)
tly : list positive
hdy : positive
Hx : eq x (cons hdx tlx)
tlx : list positive
hdx : positive
Hyz : ltList y z
Hxy : ltList x y
lz : eq (length z) (S (S m))
ly : eq (length y) (S (S m))
lx : eq (length x) (S (S m))
x,y,z : list positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
ltList x z
+++++
subst.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.

*****
Hxy : ltList (cons hdx tlx) (cons hdy tly)
lz : eq (length (cons hdz tlz)) (S (S m))
Hyz : ltList (cons hdy tly) (cons hdz tlz)
tlz : list positive
hdz : positive
ly : eq (length (cons hdy tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (length (cons hdx tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
ltList (cons hdx tlx) (cons hdz tlz)
+++++
simpl in *.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.

*****
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
assert (HEqxy := Pos.compare_eq hdx hdy).
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).

*****
HEqxy : forall _ : eq (Pos.compare hdx hdy) Eq, eq hdx hdy
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
assert (HEqyz := Pos.compare_eq hdy hdz).
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).

*****
HEqyz : forall _ : eq (Pos.compare hdy hdz) Eq, eq hdy hdz
HEqxy : forall _ : eq (Pos.compare hdx hdy) Eq, eq hdx hdy
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).

*****
HLtxy : iff (eq (Pos.compare hdx hdy) Lt) (not (Pos.le hdy hdx))
HEqyz : forall _ : eq (Pos.compare hdy hdz) Eq, eq hdy hdz
HEqxy : forall _ : eq (Pos.compare hdx hdy) Eq, eq hdx hdy
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).

*****
HLtyz : iff (eq (Pos.compare hdy hdz) Lt) (not (Pos.le hdz hdy))
HLtxy : iff (eq (Pos.compare hdx hdy) Lt) (not (Pos.le hdy hdx))
HEqyz : forall _ : eq (Pos.compare hdy hdz) Eq, eq hdy hdz
HEqxy : forall _ : eq (Pos.compare hdx hdy) Eq, eq hdx hdy
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).

*****
HGtxy : iff (eq (Pos.compare hdx hdy) Gt) (Pos.lt hdy hdx)
HLtyz : iff (eq (Pos.compare hdy hdz) Lt) (not (Pos.le hdz hdy))
HLtxy : iff (eq (Pos.compare hdx hdy) Lt) (not (Pos.le hdy hdx))
HEqyz : forall _ : eq (Pos.compare hdy hdz) Eq, eq hdy hdz
HEqxy : forall _ : eq (Pos.compare hdx hdy) Eq, eq hdx hdy
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).

*****
HGtyz : iff (eq (Pos.compare hdy hdz) Gt) (Pos.lt hdz hdy)
HGtxy : iff (eq (Pos.compare hdx hdy) Gt) (Pos.lt hdy hdx)
HLtyz : iff (eq (Pos.compare hdy hdz) Lt) (not (Pos.le hdz hdy))
HLtxy : iff (eq (Pos.compare hdx hdy) Lt) (not (Pos.le hdy hdx))
HEqyz : forall _ : eq (Pos.compare hdy hdz) Eq, eq hdy hdz
HEqxy : forall _ : eq (Pos.compare hdx hdy) Eq, eq hdx hdy
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
induction (Pos.compare hdx hdy).
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).

*****
HGtyz : iff (eq (Pos.compare hdy hdz) Gt) (Pos.lt hdz hdy)
HGtxy : iff (eq Eq Gt) (Pos.lt hdy hdx)
HLtyz : iff (eq (Pos.compare hdy hdz) Lt) (not (Pos.le hdz hdy))
HLtxy : iff (eq Eq Lt) (not (Pos.le hdy hdx))
HEqyz : forall _ : eq (Pos.compare hdy hdz) Eq, eq hdy hdz
HEqxy : forall _ : eq Eq Eq, eq hdx hdy
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
induction (Pos.compare hdy hdz).
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).

*****
HGtyz : iff (eq Eq Gt) (Pos.lt hdz hdy)
HGtxy : iff (eq Eq Gt) (Pos.lt hdy hdx)
HLtyz : iff (eq Eq Lt) (not (Pos.le hdz hdy))
HLtxy : iff (eq Eq Lt) (not (Pos.le hdy hdx))
HEqyz : forall _ : eq Eq Eq, eq hdy hdz
HEqxy : forall _ : eq Eq Eq, eq hdx hdy
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
assert (H : Eq = Eq).
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
assert (H : Eq = Eq).

*****
HGtyz : iff (eq Eq Gt) (Pos.lt hdz hdy)
HGtxy : iff (eq Eq Gt) (Pos.lt hdy hdx)
HLtyz : iff (eq Eq Lt) (not (Pos.le hdz hdy))
HLtxy : iff (eq Eq Lt) (not (Pos.le hdy hdx))
HEqyz : forall _ : eq Eq Eq, eq hdy hdz
HEqxy : forall _ : eq Eq Eq, eq hdx hdy
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
eq Eq Eq
+++++
reflexivity.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
assert (H : Eq = Eq).

*****
H : eq Eq Eq
HGtyz : iff (eq Eq Gt) (Pos.lt hdz hdy)
HGtxy : iff (eq Eq Gt) (Pos.lt hdy hdx)
HLtyz : iff (eq Eq Lt) (not (Pos.le hdz hdy))
HLtxy : iff (eq Eq Lt) (not (Pos.le hdy hdx))
HEqyz : forall _ : eq Eq Eq, eq hdy hdz
HEqxy : forall _ : eq Eq Eq, eq hdx hdy
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
idtac.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
assert (H : Eq = Eq).
idtac.

*****
H : eq Eq Eq
HGtyz : iff (eq Eq Gt) (Pos.lt hdz hdy)
HGtxy : iff (eq Eq Gt) (Pos.lt hdy hdx)
HLtyz : iff (eq Eq Lt) (not (Pos.le hdz hdy))
HLtxy : iff (eq Eq Lt) (not (Pos.le hdy hdx))
HEqyz : forall _ : eq Eq Eq, eq hdy hdz
HEqxy : forall _ : eq Eq Eq, eq hdx hdy
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
apply HEqxy in H.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
assert (H : Eq = Eq).
idtac.
apply HEqxy in H.

*****
H : eq hdx hdy
HGtyz : iff (eq Eq Gt) (Pos.lt hdz hdy)
HGtxy : iff (eq Eq Gt) (Pos.lt hdy hdx)
HLtyz : iff (eq Eq Lt) (not (Pos.le hdz hdy))
HLtxy : iff (eq Eq Lt) (not (Pos.le hdy hdx))
HEqyz : forall _ : eq Eq Eq, eq hdy hdz
HEqxy : forall _ : eq Eq Eq, eq hdx hdy
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
clear HEqxy.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
assert (H : Eq = Eq).
idtac.
apply HEqxy in H.
clear HEqxy.

*****
H : eq hdx hdy
HGtyz : iff (eq Eq Gt) (Pos.lt hdz hdy)
HGtxy : iff (eq Eq Gt) (Pos.lt hdy hdx)
HLtyz : iff (eq Eq Lt) (not (Pos.le hdz hdy))
HLtxy : iff (eq Eq Lt) (not (Pos.le hdy hdx))
HEqyz : forall _ : eq Eq Eq, eq hdy hdz
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
clear HLtxy.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
assert (H : Eq = Eq).
idtac.
apply HEqxy in H.
clear HEqxy.
clear HLtxy.

*****
H : eq hdx hdy
HGtyz : iff (eq Eq Gt) (Pos.lt hdz hdy)
HGtxy : iff (eq Eq Gt) (Pos.lt hdy hdx)
HLtyz : iff (eq Eq Lt) (not (Pos.le hdz hdy))
HEqyz : forall _ : eq Eq Eq, eq hdy hdz
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
clear HGtxy.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
assert (H : Eq = Eq).
idtac.
apply HEqxy in H.
clear HEqxy.
clear HLtxy.
clear HGtxy.

*****
H : eq hdx hdy
HGtyz : iff (eq Eq Gt) (Pos.lt hdz hdy)
HLtyz : iff (eq Eq Lt) (not (Pos.le hdz hdy))
HEqyz : forall _ : eq Eq Eq, eq hdy hdz
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
assert (H' : Eq = Eq).
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
assert (H : Eq = Eq).
idtac.
apply HEqxy in H.
clear HEqxy.
clear HLtxy.
clear HGtxy.
assert (H' : Eq = Eq).

*****
H : eq hdx hdy
HGtyz : iff (eq Eq Gt) (Pos.lt hdz hdy)
HLtyz : iff (eq Eq Lt) (not (Pos.le hdz hdy))
HEqyz : forall _ : eq Eq Eq, eq hdy hdz
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
eq Eq Eq
+++++
reflexivity.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
assert (H : Eq = Eq).
idtac.
apply HEqxy in H.
clear HEqxy.
clear HLtxy.
clear HGtxy.
assert (H' : Eq = Eq).

*****
H' : eq Eq Eq
H : eq hdx hdy
HGtyz : iff (eq Eq Gt) (Pos.lt hdz hdy)
HLtyz : iff (eq Eq Lt) (not (Pos.le hdz hdy))
HEqyz : forall _ : eq Eq Eq, eq hdy hdz
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
idtac.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
assert (H : Eq = Eq).
idtac.
apply HEqxy in H.
clear HEqxy.
clear HLtxy.
clear HGtxy.
assert (H' : Eq = Eq).
idtac.

*****
H' : eq Eq Eq
H : eq hdx hdy
HGtyz : iff (eq Eq Gt) (Pos.lt hdz hdy)
HLtyz : iff (eq Eq Lt) (not (Pos.le hdz hdy))
HEqyz : forall _ : eq Eq Eq, eq hdy hdz
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
apply HEqyz in H'.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
assert (H : Eq = Eq).
idtac.
apply HEqxy in H.
clear HEqxy.
clear HLtxy.
clear HGtxy.
assert (H' : Eq = Eq).
idtac.
apply HEqyz in H'.

*****
H' : eq hdy hdz
H : eq hdx hdy
HGtyz : iff (eq Eq Gt) (Pos.lt hdz hdy)
HLtyz : iff (eq Eq Lt) (not (Pos.le hdz hdy))
HEqyz : forall _ : eq Eq Eq, eq hdy hdz
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
clear HEqyz.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
assert (H : Eq = Eq).
idtac.
apply HEqxy in H.
clear HEqxy.
clear HLtxy.
clear HGtxy.
assert (H' : Eq = Eq).
idtac.
apply HEqyz in H'.
clear HEqyz.

*****
H' : eq hdy hdz
H : eq hdx hdy
HGtyz : iff (eq Eq Gt) (Pos.lt hdz hdy)
HLtyz : iff (eq Eq Lt) (not (Pos.le hdz hdy))
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
clear HLtyz.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
assert (H : Eq = Eq).
idtac.
apply HEqxy in H.
clear HEqxy.
clear HLtxy.
clear HGtxy.
assert (H' : Eq = Eq).
idtac.
apply HEqyz in H'.
clear HEqyz.
clear HLtyz.

*****
H' : eq hdy hdz
H : eq hdx hdy
HGtyz : iff (eq Eq Gt) (Pos.lt hdz hdy)
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
clear HGtyz.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
assert (H : Eq = Eq).
idtac.
apply HEqxy in H.
clear HEqxy.
clear HLtxy.
clear HGtxy.
assert (H' : Eq = Eq).
idtac.
apply HEqyz in H'.
clear HEqyz.
clear HLtyz.
clear HGtyz.

*****
H' : eq hdy hdz
H : eq hdx hdy
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
subst.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
assert (H : Eq = Eq).
idtac.
apply HEqxy in H.
clear HEqxy.
clear HLtxy.
clear HGtxy.
assert (H' : Eq = Eq).
idtac.
apply HEqyz in H'.
clear HEqyz.
clear HLtyz.
clear HGtyz.
subst.

*****
Hxy : if Pos.ltb hdz hdz\nthen True\nelse if Pos.ltb hdz hdz then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdz hdz\nthen True\nelse if Pos.ltb hdz hdz then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdz hdz then True else if Pos.ltb hdz hdz then False else ltList tlx tlz
+++++
assert (H := Pos.ltb_irrefl hdz).
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
assert (H : Eq = Eq).
idtac.
apply HEqxy in H.
clear HEqxy.
clear HLtxy.
clear HGtxy.
assert (H' : Eq = Eq).
idtac.
apply HEqyz in H'.
clear HEqyz.
clear HLtyz.
clear HGtyz.
subst.
assert (H := Pos.ltb_irrefl hdz).

*****
H : eq (Pos.ltb hdz hdz) false
Hxy : if Pos.ltb hdz hdz\nthen True\nelse if Pos.ltb hdz hdz then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdz hdz\nthen True\nelse if Pos.ltb hdz hdz then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdz hdz then True else if Pos.ltb hdz hdz then False else ltList tlx tlz
+++++
rewrite H in *.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
assert (H : Eq = Eq).
idtac.
apply HEqxy in H.
clear HEqxy.
clear HLtxy.
clear HGtxy.
assert (H' : Eq = Eq).
idtac.
apply HEqyz in H'.
clear HEqyz.
clear HLtyz.
clear HGtyz.
subst.
assert (H := Pos.ltb_irrefl hdz).
rewrite H in *.

*****
H : eq (Pos.ltb hdz hdz) false
Hxy : ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
ltList tlx tlz
+++++
clear H.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
assert (H : Eq = Eq).
idtac.
apply HEqxy in H.
clear HEqxy.
clear HLtxy.
clear HGtxy.
assert (H' : Eq = Eq).
idtac.
apply HEqyz in H'.
clear HEqyz.
clear HLtyz.
clear HGtyz.
subst.
assert (H := Pos.ltb_irrefl hdz).
rewrite H in *.
clear H.

*****
Hxy : ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
ltList tlx tlz
+++++
apply eq_add_S in lx.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
assert (H : Eq = Eq).
idtac.
apply HEqxy in H.
clear HEqxy.
clear HLtxy.
clear HGtxy.
assert (H' : Eq = Eq).
idtac.
apply HEqyz in H'.
clear HEqyz.
clear HLtyz.
clear HGtyz.
subst.
assert (H := Pos.ltb_irrefl hdz).
rewrite H in *.
clear H.
apply eq_add_S in lx.

*****
Hxy : ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
lx : eq (length tlx) (S m)
tlx : list positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
ltList tlx tlz
+++++
apply eq_add_S in ly.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
assert (H : Eq = Eq).
idtac.
apply HEqxy in H.
clear HEqxy.
clear HLtxy.
clear HGtxy.
assert (H' : Eq = Eq).
idtac.
apply HEqyz in H'.
clear HEqyz.
clear HLtyz.
clear HGtyz.
subst.
assert (H := Pos.ltb_irrefl hdz).
rewrite H in *.
clear H.
apply eq_add_S in lx.
apply eq_add_S in ly.

*****
Hxy : ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (length tly) (S m)
tly : list positive
lx : eq (length tlx) (S m)
tlx : list positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
ltList tlx tlz
+++++
apply eq_add_S in lz.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
assert (H : Eq = Eq).
idtac.
apply HEqxy in H.
clear HEqxy.
clear HLtxy.
clear HGtxy.
assert (H' : Eq = Eq).
idtac.
apply HEqyz in H'.
clear HEqyz.
clear HLtyz.
clear HGtyz.
subst.
assert (H := Pos.ltb_irrefl hdz).
rewrite H in *.
clear H.
apply eq_add_S in lx.
apply eq_add_S in ly.
apply eq_add_S in lz.

*****
Hxy : ltList tlx tly
lz : eq (length tlz) (S m)
Hyz : ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (length tly) (S m)
tly : list positive
lx : eq (length tlx) (S m)
tlx : list positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
ltList tlx tlz
+++++
apply IHm with tly.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
assert (H : Eq = Eq).
idtac.
apply HEqxy in H.
clear HEqxy.
clear HLtxy.
clear HGtxy.
assert (H' : Eq = Eq).
idtac.
apply HEqyz in H'.
clear HEqyz.
clear HLtyz.
clear HGtyz.
subst.
assert (H := Pos.ltb_irrefl hdz).
rewrite H in *.
clear H.
apply eq_add_S in lx.
apply eq_add_S in ly.
apply eq_add_S in lz.
apply IHm with tly.

*****
Hxy : ltList tlx tly
lz : eq (length tlz) (S m)
Hyz : ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (length tly) (S m)
tly : list positive
lx : eq (length tlx) (S m)
tlx : list positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
eq (length tlx) (S m)
+++++
assumption.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
assert (H : Eq = Eq).
idtac.
apply HEqxy in H.
clear HEqxy.
clear HLtxy.
clear HGtxy.
assert (H' : Eq = Eq).
idtac.
apply HEqyz in H'.
clear HEqyz.
clear HLtyz.
clear HGtyz.
subst.
assert (H := Pos.ltb_irrefl hdz).
rewrite H in *.
clear H.
apply eq_add_S in lx.
apply eq_add_S in ly.
apply eq_add_S in lz.
apply IHm with tly.

*****
Hxy : ltList tlx tly
lz : eq (length tlz) (S m)
Hyz : ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (length tly) (S m)
tly : list positive
lx : eq (length tlx) (S m)
tlx : list positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
eq (length tly) (S m)
+++++
assumption.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
assert (H : Eq = Eq).
idtac.
apply HEqxy in H.
clear HEqxy.
clear HLtxy.
clear HGtxy.
assert (H' : Eq = Eq).
idtac.
apply HEqyz in H'.
clear HEqyz.
clear HLtyz.
clear HGtyz.
subst.
assert (H := Pos.ltb_irrefl hdz).
rewrite H in *.
clear H.
apply eq_add_S in lx.
apply eq_add_S in ly.
apply eq_add_S in lz.
apply IHm with tly.

*****
Hxy : ltList tlx tly
lz : eq (length tlz) (S m)
Hyz : ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (length tly) (S m)
tly : list positive
lx : eq (length tlx) (S m)
tlx : list positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
eq (length tlz) (S m)
+++++
assumption.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
assert (H : Eq = Eq).
idtac.
apply HEqxy in H.
clear HEqxy.
clear HLtxy.
clear HGtxy.
assert (H' : Eq = Eq).
idtac.
apply HEqyz in H'.
clear HEqyz.
clear HLtyz.
clear HGtyz.
subst.
assert (H := Pos.ltb_irrefl hdz).
rewrite H in *.
clear H.
apply eq_add_S in lx.
apply eq_add_S in ly.
apply eq_add_S in lz.
apply IHm with tly.

*****
Hxy : ltList tlx tly
lz : eq (length tlz) (S m)
Hyz : ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (length tly) (S m)
tly : list positive
lx : eq (length tlx) (S m)
tlx : list positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
ltList tlx tly
+++++
assumption.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
assert (H : Eq = Eq).
idtac.
apply HEqxy in H.
clear HEqxy.
clear HLtxy.
clear HGtxy.
assert (H' : Eq = Eq).
idtac.
apply HEqyz in H'.
clear HEqyz.
clear HLtyz.
clear HGtyz.
subst.
assert (H := Pos.ltb_irrefl hdz).
rewrite H in *.
clear H.
apply eq_add_S in lx.
apply eq_add_S in ly.
apply eq_add_S in lz.
apply IHm with tly.

*****
Hxy : ltList tlx tly
lz : eq (length tlz) (S m)
Hyz : ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (length tly) (S m)
tly : list positive
lx : eq (length tlx) (S m)
tlx : list positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
ltList tly tlz
+++++
assumption.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).

*****
HGtyz : iff (eq Lt Gt) (Pos.lt hdz hdy)
HGtxy : iff (eq Eq Gt) (Pos.lt hdy hdx)
HLtyz : iff (eq Lt Lt) (not (Pos.le hdz hdy))
HLtxy : iff (eq Eq Lt) (not (Pos.le hdy hdx))
HEqyz : forall _ : eq Lt Eq, eq hdy hdz
HEqxy : forall _ : eq Eq Eq, eq hdx hdy
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
assert (H : Eq = Eq).
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
assert (H : Eq = Eq).

*****
HGtyz : iff (eq Lt Gt) (Pos.lt hdz hdy)
HGtxy : iff (eq Eq Gt) (Pos.lt hdy hdx)
HLtyz : iff (eq Lt Lt) (not (Pos.le hdz hdy))
HLtxy : iff (eq Eq Lt) (not (Pos.le hdy hdx))
HEqyz : forall _ : eq Lt Eq, eq hdy hdz
HEqxy : forall _ : eq Eq Eq, eq hdx hdy
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
eq Eq Eq
+++++
reflexivity.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
assert (H : Eq = Eq).

*****
H : eq Eq Eq
HGtyz : iff (eq Lt Gt) (Pos.lt hdz hdy)
HGtxy : iff (eq Eq Gt) (Pos.lt hdy hdx)
HLtyz : iff (eq Lt Lt) (not (Pos.le hdz hdy))
HLtxy : iff (eq Eq Lt) (not (Pos.le hdy hdx))
HEqyz : forall _ : eq Lt Eq, eq hdy hdz
HEqxy : forall _ : eq Eq Eq, eq hdx hdy
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
idtac.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
assert (H : Eq = Eq).
idtac.

*****
H : eq Eq Eq
HGtyz : iff (eq Lt Gt) (Pos.lt hdz hdy)
HGtxy : iff (eq Eq Gt) (Pos.lt hdy hdx)
HLtyz : iff (eq Lt Lt) (not (Pos.le hdz hdy))
HLtxy : iff (eq Eq Lt) (not (Pos.le hdy hdx))
HEqyz : forall _ : eq Lt Eq, eq hdy hdz
HEqxy : forall _ : eq Eq Eq, eq hdx hdy
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
apply HEqxy in H.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
assert (H : Eq = Eq).
idtac.
apply HEqxy in H.

*****
H : eq hdx hdy
HGtyz : iff (eq Lt Gt) (Pos.lt hdz hdy)
HGtxy : iff (eq Eq Gt) (Pos.lt hdy hdx)
HLtyz : iff (eq Lt Lt) (not (Pos.le hdz hdy))
HLtxy : iff (eq Eq Lt) (not (Pos.le hdy hdx))
HEqyz : forall _ : eq Lt Eq, eq hdy hdz
HEqxy : forall _ : eq Eq Eq, eq hdx hdy
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
clear HEqxy.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
assert (H : Eq = Eq).
idtac.
apply HEqxy in H.
clear HEqxy.

*****
H : eq hdx hdy
HGtyz : iff (eq Lt Gt) (Pos.lt hdz hdy)
HGtxy : iff (eq Eq Gt) (Pos.lt hdy hdx)
HLtyz : iff (eq Lt Lt) (not (Pos.le hdz hdy))
HLtxy : iff (eq Eq Lt) (not (Pos.le hdy hdx))
HEqyz : forall _ : eq Lt Eq, eq hdy hdz
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
clear HLtxy.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
assert (H : Eq = Eq).
idtac.
apply HEqxy in H.
clear HEqxy.
clear HLtxy.

*****
H : eq hdx hdy
HGtyz : iff (eq Lt Gt) (Pos.lt hdz hdy)
HGtxy : iff (eq Eq Gt) (Pos.lt hdy hdx)
HLtyz : iff (eq Lt Lt) (not (Pos.le hdz hdy))
HEqyz : forall _ : eq Lt Eq, eq hdy hdz
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
clear HGtxy.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
assert (H : Eq = Eq).
idtac.
apply HEqxy in H.
clear HEqxy.
clear HLtxy.
clear HGtxy.

*****
H : eq hdx hdy
HGtyz : iff (eq Lt Gt) (Pos.lt hdz hdy)
HLtyz : iff (eq Lt Lt) (not (Pos.le hdz hdy))
HEqyz : forall _ : eq Lt Eq, eq hdy hdz
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
assert (H' : Lt = Lt).
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
assert (H : Eq = Eq).
idtac.
apply HEqxy in H.
clear HEqxy.
clear HLtxy.
clear HGtxy.
assert (H' : Lt = Lt).

*****
H : eq hdx hdy
HGtyz : iff (eq Lt Gt) (Pos.lt hdz hdy)
HLtyz : iff (eq Lt Lt) (not (Pos.le hdz hdy))
HEqyz : forall _ : eq Lt Eq, eq hdy hdz
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
eq Lt Lt
+++++
reflexivity.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
assert (H : Eq = Eq).
idtac.
apply HEqxy in H.
clear HEqxy.
clear HLtxy.
clear HGtxy.
assert (H' : Lt = Lt).

*****
H' : eq Lt Lt
H : eq hdx hdy
HGtyz : iff (eq Lt Gt) (Pos.lt hdz hdy)
HLtyz : iff (eq Lt Lt) (not (Pos.le hdz hdy))
HEqyz : forall _ : eq Lt Eq, eq hdy hdz
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
idtac.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
assert (H : Eq = Eq).
idtac.
apply HEqxy in H.
clear HEqxy.
clear HLtxy.
clear HGtxy.
assert (H' : Lt = Lt).
idtac.

*****
H' : eq Lt Lt
H : eq hdx hdy
HGtyz : iff (eq Lt Gt) (Pos.lt hdz hdy)
HLtyz : iff (eq Lt Lt) (not (Pos.le hdz hdy))
HEqyz : forall _ : eq Lt Eq, eq hdy hdz
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
apply HLtyz in H'.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
assert (H : Eq = Eq).
idtac.
apply HEqxy in H.
clear HEqxy.
clear HLtxy.
clear HGtxy.
assert (H' : Lt = Lt).
idtac.
apply HLtyz in H'.

*****
H' : not (Pos.le hdz hdy)
H : eq hdx hdy
HGtyz : iff (eq Lt Gt) (Pos.lt hdz hdy)
HLtyz : iff (eq Lt Lt) (not (Pos.le hdz hdy))
HEqyz : forall _ : eq Lt Eq, eq hdy hdz
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
clear HEqyz.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
assert (H : Eq = Eq).
idtac.
apply HEqxy in H.
clear HEqxy.
clear HLtxy.
clear HGtxy.
assert (H' : Lt = Lt).
idtac.
apply HLtyz in H'.
clear HEqyz.

*****
H' : not (Pos.le hdz hdy)
H : eq hdx hdy
HGtyz : iff (eq Lt Gt) (Pos.lt hdz hdy)
HLtyz : iff (eq Lt Lt) (not (Pos.le hdz hdy))
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
clear HLtyz.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
assert (H : Eq = Eq).
idtac.
apply HEqxy in H.
clear HEqxy.
clear HLtxy.
clear HGtxy.
assert (H' : Lt = Lt).
idtac.
apply HLtyz in H'.
clear HEqyz.
clear HLtyz.

*****
H' : not (Pos.le hdz hdy)
H : eq hdx hdy
HGtyz : iff (eq Lt Gt) (Pos.lt hdz hdy)
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
clear HGtyz.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
assert (H : Eq = Eq).
idtac.
apply HEqxy in H.
clear HEqxy.
clear HLtxy.
clear HGtxy.
assert (H' : Lt = Lt).
idtac.
apply HLtyz in H'.
clear HEqyz.
clear HLtyz.
clear HGtyz.

*****
H' : not (Pos.le hdz hdy)
H : eq hdx hdy
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
subst.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
assert (H : Eq = Eq).
idtac.
apply HEqxy in H.
clear HEqxy.
clear HLtxy.
clear HGtxy.
assert (H' : Lt = Lt).
idtac.
apply HLtyz in H'.
clear HEqyz.
clear HLtyz.
clear HGtyz.
subst.

*****
H' : not (Pos.le hdz hdy)
Hxy : if Pos.ltb hdy hdy\nthen True\nelse if Pos.ltb hdy hdy then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdy hdz then True else if Pos.ltb hdz hdy then False else ltList tlx tlz
+++++
rewrite <- Pos.lt_nle in H'.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
assert (H : Eq = Eq).
idtac.
apply HEqxy in H.
clear HEqxy.
clear HLtxy.
clear HGtxy.
assert (H' : Lt = Lt).
idtac.
apply HLtyz in H'.
clear HEqyz.
clear HLtyz.
clear HGtyz.
subst.
rewrite <- Pos.lt_nle in H'.

*****
H' : Pos.lt hdy hdz
Hxy : if Pos.ltb hdy hdy\nthen True\nelse if Pos.ltb hdy hdy then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdy hdz then True else if Pos.ltb hdz hdy then False else ltList tlx tlz
+++++
rewrite <- Pos.ltb_lt in H'.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
assert (H : Eq = Eq).
idtac.
apply HEqxy in H.
clear HEqxy.
clear HLtxy.
clear HGtxy.
assert (H' : Lt = Lt).
idtac.
apply HLtyz in H'.
clear HEqyz.
clear HLtyz.
clear HGtyz.
subst.
rewrite <- Pos.lt_nle in H'.
rewrite <- Pos.ltb_lt in H'.

*****
H' : eq (Pos.ltb hdy hdz) true
Hxy : if Pos.ltb hdy hdy\nthen True\nelse if Pos.ltb hdy hdy then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdy hdz then True else if Pos.ltb hdz hdy then False else ltList tlx tlz
+++++
rewrite H' in *.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
assert (H : Eq = Eq).
idtac.
apply HEqxy in H.
clear HEqxy.
clear HLtxy.
clear HGtxy.
assert (H' : Lt = Lt).
idtac.
apply HLtyz in H'.
clear HEqyz.
clear HLtyz.
clear HGtyz.
subst.
rewrite <- Pos.lt_nle in H'.
rewrite <- Pos.ltb_lt in H'.
rewrite H' in *.

*****
H' : eq (Pos.ltb hdy hdz) true
Hxy : if Pos.ltb hdy hdy\nthen True\nelse if Pos.ltb hdy hdy then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : True
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
True
+++++
trivial.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).

*****
HGtyz : iff (eq Gt Gt) (Pos.lt hdz hdy)
HGtxy : iff (eq Eq Gt) (Pos.lt hdy hdx)
HLtyz : iff (eq Gt Lt) (not (Pos.le hdz hdy))
HLtxy : iff (eq Eq Lt) (not (Pos.le hdy hdx))
HEqyz : forall _ : eq Gt Eq, eq hdy hdz
HEqxy : forall _ : eq Eq Eq, eq hdx hdy
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
assert (H : Eq = Eq).
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
assert (H : Eq = Eq).

*****
HGtyz : iff (eq Gt Gt) (Pos.lt hdz hdy)
HGtxy : iff (eq Eq Gt) (Pos.lt hdy hdx)
HLtyz : iff (eq Gt Lt) (not (Pos.le hdz hdy))
HLtxy : iff (eq Eq Lt) (not (Pos.le hdy hdx))
HEqyz : forall _ : eq Gt Eq, eq hdy hdz
HEqxy : forall _ : eq Eq Eq, eq hdx hdy
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
eq Eq Eq
+++++
reflexivity.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
assert (H : Eq = Eq).

*****
H : eq Eq Eq
HGtyz : iff (eq Gt Gt) (Pos.lt hdz hdy)
HGtxy : iff (eq Eq Gt) (Pos.lt hdy hdx)
HLtyz : iff (eq Gt Lt) (not (Pos.le hdz hdy))
HLtxy : iff (eq Eq Lt) (not (Pos.le hdy hdx))
HEqyz : forall _ : eq Gt Eq, eq hdy hdz
HEqxy : forall _ : eq Eq Eq, eq hdx hdy
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
idtac.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
assert (H : Eq = Eq).
idtac.

*****
H : eq Eq Eq
HGtyz : iff (eq Gt Gt) (Pos.lt hdz hdy)
HGtxy : iff (eq Eq Gt) (Pos.lt hdy hdx)
HLtyz : iff (eq Gt Lt) (not (Pos.le hdz hdy))
HLtxy : iff (eq Eq Lt) (not (Pos.le hdy hdx))
HEqyz : forall _ : eq Gt Eq, eq hdy hdz
HEqxy : forall _ : eq Eq Eq, eq hdx hdy
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
apply HEqxy in H.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
assert (H : Eq = Eq).
idtac.
apply HEqxy in H.

*****
H : eq hdx hdy
HGtyz : iff (eq Gt Gt) (Pos.lt hdz hdy)
HGtxy : iff (eq Eq Gt) (Pos.lt hdy hdx)
HLtyz : iff (eq Gt Lt) (not (Pos.le hdz hdy))
HLtxy : iff (eq Eq Lt) (not (Pos.le hdy hdx))
HEqyz : forall _ : eq Gt Eq, eq hdy hdz
HEqxy : forall _ : eq Eq Eq, eq hdx hdy
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
clear HEqxy.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
assert (H : Eq = Eq).
idtac.
apply HEqxy in H.
clear HEqxy.

*****
H : eq hdx hdy
HGtyz : iff (eq Gt Gt) (Pos.lt hdz hdy)
HGtxy : iff (eq Eq Gt) (Pos.lt hdy hdx)
HLtyz : iff (eq Gt Lt) (not (Pos.le hdz hdy))
HLtxy : iff (eq Eq Lt) (not (Pos.le hdy hdx))
HEqyz : forall _ : eq Gt Eq, eq hdy hdz
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
clear HLtxy.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
assert (H : Eq = Eq).
idtac.
apply HEqxy in H.
clear HEqxy.
clear HLtxy.

*****
H : eq hdx hdy
HGtyz : iff (eq Gt Gt) (Pos.lt hdz hdy)
HGtxy : iff (eq Eq Gt) (Pos.lt hdy hdx)
HLtyz : iff (eq Gt Lt) (not (Pos.le hdz hdy))
HEqyz : forall _ : eq Gt Eq, eq hdy hdz
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
clear HGtxy.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
assert (H : Eq = Eq).
idtac.
apply HEqxy in H.
clear HEqxy.
clear HLtxy.
clear HGtxy.

*****
H : eq hdx hdy
HGtyz : iff (eq Gt Gt) (Pos.lt hdz hdy)
HLtyz : iff (eq Gt Lt) (not (Pos.le hdz hdy))
HEqyz : forall _ : eq Gt Eq, eq hdy hdz
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
assert (H' : Gt = Gt).
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
assert (H : Eq = Eq).
idtac.
apply HEqxy in H.
clear HEqxy.
clear HLtxy.
clear HGtxy.
assert (H' : Gt = Gt).

*****
H : eq hdx hdy
HGtyz : iff (eq Gt Gt) (Pos.lt hdz hdy)
HLtyz : iff (eq Gt Lt) (not (Pos.le hdz hdy))
HEqyz : forall _ : eq Gt Eq, eq hdy hdz
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
eq Gt Gt
+++++
reflexivity.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
assert (H : Eq = Eq).
idtac.
apply HEqxy in H.
clear HEqxy.
clear HLtxy.
clear HGtxy.
assert (H' : Gt = Gt).

*****
H' : eq Gt Gt
H : eq hdx hdy
HGtyz : iff (eq Gt Gt) (Pos.lt hdz hdy)
HLtyz : iff (eq Gt Lt) (not (Pos.le hdz hdy))
HEqyz : forall _ : eq Gt Eq, eq hdy hdz
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
idtac.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
assert (H : Eq = Eq).
idtac.
apply HEqxy in H.
clear HEqxy.
clear HLtxy.
clear HGtxy.
assert (H' : Gt = Gt).
idtac.

*****
H' : eq Gt Gt
H : eq hdx hdy
HGtyz : iff (eq Gt Gt) (Pos.lt hdz hdy)
HLtyz : iff (eq Gt Lt) (not (Pos.le hdz hdy))
HEqyz : forall _ : eq Gt Eq, eq hdy hdz
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
apply HGtyz in H'.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
assert (H : Eq = Eq).
idtac.
apply HEqxy in H.
clear HEqxy.
clear HLtxy.
clear HGtxy.
assert (H' : Gt = Gt).
idtac.
apply HGtyz in H'.

*****
H' : Pos.lt hdz hdy
H : eq hdx hdy
HGtyz : iff (eq Gt Gt) (Pos.lt hdz hdy)
HLtyz : iff (eq Gt Lt) (not (Pos.le hdz hdy))
HEqyz : forall _ : eq Gt Eq, eq hdy hdz
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
clear HEqyz.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
assert (H : Eq = Eq).
idtac.
apply HEqxy in H.
clear HEqxy.
clear HLtxy.
clear HGtxy.
assert (H' : Gt = Gt).
idtac.
apply HGtyz in H'.
clear HEqyz.

*****
H' : Pos.lt hdz hdy
H : eq hdx hdy
HGtyz : iff (eq Gt Gt) (Pos.lt hdz hdy)
HLtyz : iff (eq Gt Lt) (not (Pos.le hdz hdy))
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
clear HLtyz.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
assert (H : Eq = Eq).
idtac.
apply HEqxy in H.
clear HEqxy.
clear HLtxy.
clear HGtxy.
assert (H' : Gt = Gt).
idtac.
apply HGtyz in H'.
clear HEqyz.
clear HLtyz.

*****
H' : Pos.lt hdz hdy
H : eq hdx hdy
HGtyz : iff (eq Gt Gt) (Pos.lt hdz hdy)
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
clear HGtyz.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
assert (H : Eq = Eq).
idtac.
apply HEqxy in H.
clear HEqxy.
clear HLtxy.
clear HGtxy.
assert (H' : Gt = Gt).
idtac.
apply HGtyz in H'.
clear HEqyz.
clear HLtyz.
clear HGtyz.

*****
H' : Pos.lt hdz hdy
H : eq hdx hdy
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
subst.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
assert (H : Eq = Eq).
idtac.
apply HEqxy in H.
clear HEqxy.
clear HLtxy.
clear HGtxy.
assert (H' : Gt = Gt).
idtac.
apply HGtyz in H'.
clear HEqyz.
clear HLtyz.
clear HGtyz.
subst.

*****
H' : Pos.lt hdz hdy
Hxy : if Pos.ltb hdy hdy\nthen True\nelse if Pos.ltb hdy hdy then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdy hdz then True else if Pos.ltb hdz hdy then False else ltList tlx tlz
+++++
rewrite <- Pos.ltb_lt in H'.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
assert (H : Eq = Eq).
idtac.
apply HEqxy in H.
clear HEqxy.
clear HLtxy.
clear HGtxy.
assert (H' : Gt = Gt).
idtac.
apply HGtyz in H'.
clear HEqyz.
clear HLtyz.
clear HGtyz.
subst.
rewrite <- Pos.ltb_lt in H'.

*****
H' : eq (Pos.ltb hdz hdy) true
Hxy : if Pos.ltb hdy hdy\nthen True\nelse if Pos.ltb hdy hdy then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdy hdz then True else if Pos.ltb hdz hdy then False else ltList tlx tlz
+++++
rewrite H' in *.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
assert (H : Eq = Eq).
idtac.
apply HEqxy in H.
clear HEqxy.
clear HLtxy.
clear HGtxy.
assert (H' : Gt = Gt).
idtac.
apply HGtyz in H'.
clear HEqyz.
clear HLtyz.
clear HGtyz.
subst.
rewrite <- Pos.ltb_lt in H'.
rewrite H' in *.

*****
H' : eq (Pos.ltb hdz hdy) true
Hxy : if Pos.ltb hdy hdy\nthen True\nelse if Pos.ltb hdy hdy then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz then True else False
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdy hdz then True else False
+++++
trivial.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).

*****
HGtyz : iff (eq (Pos.compare hdy hdz) Gt) (Pos.lt hdz hdy)
HGtxy : iff (eq Lt Gt) (Pos.lt hdy hdx)
HLtyz : iff (eq (Pos.compare hdy hdz) Lt) (not (Pos.le hdz hdy))
HLtxy : iff (eq Lt Lt) (not (Pos.le hdy hdx))
HEqyz : forall _ : eq (Pos.compare hdy hdz) Eq, eq hdy hdz
HEqxy : forall _ : eq Lt Eq, eq hdx hdy
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
induction (Pos.compare hdy hdz).
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).

*****
HGtyz : iff (eq Eq Gt) (Pos.lt hdz hdy)
HGtxy : iff (eq Lt Gt) (Pos.lt hdy hdx)
HLtyz : iff (eq Eq Lt) (not (Pos.le hdz hdy))
HLtxy : iff (eq Lt Lt) (not (Pos.le hdy hdx))
HEqyz : forall _ : eq Eq Eq, eq hdy hdz
HEqxy : forall _ : eq Lt Eq, eq hdx hdy
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
assert (H : Lt = Lt).
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
assert (H : Lt = Lt).

*****
HGtyz : iff (eq Eq Gt) (Pos.lt hdz hdy)
HGtxy : iff (eq Lt Gt) (Pos.lt hdy hdx)
HLtyz : iff (eq Eq Lt) (not (Pos.le hdz hdy))
HLtxy : iff (eq Lt Lt) (not (Pos.le hdy hdx))
HEqyz : forall _ : eq Eq Eq, eq hdy hdz
HEqxy : forall _ : eq Lt Eq, eq hdx hdy
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
eq Lt Lt
+++++
reflexivity.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
assert (H : Lt = Lt).

*****
H : eq Lt Lt
HGtyz : iff (eq Eq Gt) (Pos.lt hdz hdy)
HGtxy : iff (eq Lt Gt) (Pos.lt hdy hdx)
HLtyz : iff (eq Eq Lt) (not (Pos.le hdz hdy))
HLtxy : iff (eq Lt Lt) (not (Pos.le hdy hdx))
HEqyz : forall _ : eq Eq Eq, eq hdy hdz
HEqxy : forall _ : eq Lt Eq, eq hdx hdy
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
idtac.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
assert (H : Lt = Lt).
idtac.

*****
H : eq Lt Lt
HGtyz : iff (eq Eq Gt) (Pos.lt hdz hdy)
HGtxy : iff (eq Lt Gt) (Pos.lt hdy hdx)
HLtyz : iff (eq Eq Lt) (not (Pos.le hdz hdy))
HLtxy : iff (eq Lt Lt) (not (Pos.le hdy hdx))
HEqyz : forall _ : eq Eq Eq, eq hdy hdz
HEqxy : forall _ : eq Lt Eq, eq hdx hdy
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
apply HLtxy in H.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
assert (H : Lt = Lt).
idtac.
apply HLtxy in H.

*****
H : not (Pos.le hdy hdx)
HGtyz : iff (eq Eq Gt) (Pos.lt hdz hdy)
HGtxy : iff (eq Lt Gt) (Pos.lt hdy hdx)
HLtyz : iff (eq Eq Lt) (not (Pos.le hdz hdy))
HLtxy : iff (eq Lt Lt) (not (Pos.le hdy hdx))
HEqyz : forall _ : eq Eq Eq, eq hdy hdz
HEqxy : forall _ : eq Lt Eq, eq hdx hdy
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
clear HEqxy.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
assert (H : Lt = Lt).
idtac.
apply HLtxy in H.
clear HEqxy.

*****
H : not (Pos.le hdy hdx)
HGtyz : iff (eq Eq Gt) (Pos.lt hdz hdy)
HGtxy : iff (eq Lt Gt) (Pos.lt hdy hdx)
HLtyz : iff (eq Eq Lt) (not (Pos.le hdz hdy))
HLtxy : iff (eq Lt Lt) (not (Pos.le hdy hdx))
HEqyz : forall _ : eq Eq Eq, eq hdy hdz
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
clear HLtxy.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
assert (H : Lt = Lt).
idtac.
apply HLtxy in H.
clear HEqxy.
clear HLtxy.

*****
H : not (Pos.le hdy hdx)
HGtyz : iff (eq Eq Gt) (Pos.lt hdz hdy)
HGtxy : iff (eq Lt Gt) (Pos.lt hdy hdx)
HLtyz : iff (eq Eq Lt) (not (Pos.le hdz hdy))
HEqyz : forall _ : eq Eq Eq, eq hdy hdz
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
clear HGtxy.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
assert (H : Lt = Lt).
idtac.
apply HLtxy in H.
clear HEqxy.
clear HLtxy.
clear HGtxy.

*****
H : not (Pos.le hdy hdx)
HGtyz : iff (eq Eq Gt) (Pos.lt hdz hdy)
HLtyz : iff (eq Eq Lt) (not (Pos.le hdz hdy))
HEqyz : forall _ : eq Eq Eq, eq hdy hdz
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
assert (H' : Eq = Eq).
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
assert (H : Lt = Lt).
idtac.
apply HLtxy in H.
clear HEqxy.
clear HLtxy.
clear HGtxy.
assert (H' : Eq = Eq).

*****
H : not (Pos.le hdy hdx)
HGtyz : iff (eq Eq Gt) (Pos.lt hdz hdy)
HLtyz : iff (eq Eq Lt) (not (Pos.le hdz hdy))
HEqyz : forall _ : eq Eq Eq, eq hdy hdz
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
eq Eq Eq
+++++
reflexivity.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
assert (H : Lt = Lt).
idtac.
apply HLtxy in H.
clear HEqxy.
clear HLtxy.
clear HGtxy.
assert (H' : Eq = Eq).

*****
H' : eq Eq Eq
H : not (Pos.le hdy hdx)
HGtyz : iff (eq Eq Gt) (Pos.lt hdz hdy)
HLtyz : iff (eq Eq Lt) (not (Pos.le hdz hdy))
HEqyz : forall _ : eq Eq Eq, eq hdy hdz
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
idtac.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
assert (H : Lt = Lt).
idtac.
apply HLtxy in H.
clear HEqxy.
clear HLtxy.
clear HGtxy.
assert (H' : Eq = Eq).
idtac.

*****
H' : eq Eq Eq
H : not (Pos.le hdy hdx)
HGtyz : iff (eq Eq Gt) (Pos.lt hdz hdy)
HLtyz : iff (eq Eq Lt) (not (Pos.le hdz hdy))
HEqyz : forall _ : eq Eq Eq, eq hdy hdz
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
apply HEqyz in H'.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
assert (H : Lt = Lt).
idtac.
apply HLtxy in H.
clear HEqxy.
clear HLtxy.
clear HGtxy.
assert (H' : Eq = Eq).
idtac.
apply HEqyz in H'.

*****
H' : eq hdy hdz
H : not (Pos.le hdy hdx)
HGtyz : iff (eq Eq Gt) (Pos.lt hdz hdy)
HLtyz : iff (eq Eq Lt) (not (Pos.le hdz hdy))
HEqyz : forall _ : eq Eq Eq, eq hdy hdz
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
clear HEqyz.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
assert (H : Lt = Lt).
idtac.
apply HLtxy in H.
clear HEqxy.
clear HLtxy.
clear HGtxy.
assert (H' : Eq = Eq).
idtac.
apply HEqyz in H'.
clear HEqyz.

*****
H' : eq hdy hdz
H : not (Pos.le hdy hdx)
HGtyz : iff (eq Eq Gt) (Pos.lt hdz hdy)
HLtyz : iff (eq Eq Lt) (not (Pos.le hdz hdy))
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
clear HLtyz.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
assert (H : Lt = Lt).
idtac.
apply HLtxy in H.
clear HEqxy.
clear HLtxy.
clear HGtxy.
assert (H' : Eq = Eq).
idtac.
apply HEqyz in H'.
clear HEqyz.
clear HLtyz.

*****
H' : eq hdy hdz
H : not (Pos.le hdy hdx)
HGtyz : iff (eq Eq Gt) (Pos.lt hdz hdy)
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
clear HGtyz.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
assert (H : Lt = Lt).
idtac.
apply HLtxy in H.
clear HEqxy.
clear HLtxy.
clear HGtxy.
assert (H' : Eq = Eq).
idtac.
apply HEqyz in H'.
clear HEqyz.
clear HLtyz.
clear HGtyz.

*****
H' : eq hdy hdz
H : not (Pos.le hdy hdx)
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
subst.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
assert (H : Lt = Lt).
idtac.
apply HLtxy in H.
clear HEqxy.
clear HLtxy.
clear HGtxy.
assert (H' : Eq = Eq).
idtac.
apply HEqyz in H'.
clear HEqyz.
clear HLtyz.
clear HGtyz.
subst.

*****
Hxy : if Pos.ltb hdx hdz\nthen True\nelse if Pos.ltb hdz hdx then False else ltList tlx tly
H : not (Pos.le hdz hdx)
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdz hdz\nthen True\nelse if Pos.ltb hdz hdz then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
rewrite <- Pos.lt_nle in H.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
assert (H : Lt = Lt).
idtac.
apply HLtxy in H.
clear HEqxy.
clear HLtxy.
clear HGtxy.
assert (H' : Eq = Eq).
idtac.
apply HEqyz in H'.
clear HEqyz.
clear HLtyz.
clear HGtyz.
subst.
rewrite <- Pos.lt_nle in H.

*****
Hxy : if Pos.ltb hdx hdz\nthen True\nelse if Pos.ltb hdz hdx then False else ltList tlx tly
H : Pos.lt hdx hdz
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdz hdz\nthen True\nelse if Pos.ltb hdz hdz then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
rewrite <- Pos.ltb_lt in H.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
assert (H : Lt = Lt).
idtac.
apply HLtxy in H.
clear HEqxy.
clear HLtxy.
clear HGtxy.
assert (H' : Eq = Eq).
idtac.
apply HEqyz in H'.
clear HEqyz.
clear HLtyz.
clear HGtyz.
subst.
rewrite <- Pos.lt_nle in H.
rewrite <- Pos.ltb_lt in H.

*****
Hxy : if Pos.ltb hdx hdz\nthen True\nelse if Pos.ltb hdz hdx then False else ltList tlx tly
H : eq (Pos.ltb hdx hdz) true
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdz hdz\nthen True\nelse if Pos.ltb hdz hdz then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
rewrite H in *.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
assert (H : Lt = Lt).
idtac.
apply HLtxy in H.
clear HEqxy.
clear HLtxy.
clear HGtxy.
assert (H' : Eq = Eq).
idtac.
apply HEqyz in H'.
clear HEqyz.
clear HLtyz.
clear HGtyz.
subst.
rewrite <- Pos.lt_nle in H.
rewrite <- Pos.ltb_lt in H.
rewrite H in *.

*****
Hxy : True
H : eq (Pos.ltb hdx hdz) true
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdz hdz\nthen True\nelse if Pos.ltb hdz hdz then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
True
+++++
trivial.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).

*****
HGtyz : iff (eq Lt Gt) (Pos.lt hdz hdy)
HGtxy : iff (eq Lt Gt) (Pos.lt hdy hdx)
HLtyz : iff (eq Lt Lt) (not (Pos.le hdz hdy))
HLtxy : iff (eq Lt Lt) (not (Pos.le hdy hdx))
HEqyz : forall _ : eq Lt Eq, eq hdy hdz
HEqxy : forall _ : eq Lt Eq, eq hdx hdy
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
assert (H : Lt = Lt).
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
assert (H : Lt = Lt).

*****
HGtyz : iff (eq Lt Gt) (Pos.lt hdz hdy)
HGtxy : iff (eq Lt Gt) (Pos.lt hdy hdx)
HLtyz : iff (eq Lt Lt) (not (Pos.le hdz hdy))
HLtxy : iff (eq Lt Lt) (not (Pos.le hdy hdx))
HEqyz : forall _ : eq Lt Eq, eq hdy hdz
HEqxy : forall _ : eq Lt Eq, eq hdx hdy
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
eq Lt Lt
+++++
reflexivity.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
assert (H : Lt = Lt).

*****
H : eq Lt Lt
HGtyz : iff (eq Lt Gt) (Pos.lt hdz hdy)
HGtxy : iff (eq Lt Gt) (Pos.lt hdy hdx)
HLtyz : iff (eq Lt Lt) (not (Pos.le hdz hdy))
HLtxy : iff (eq Lt Lt) (not (Pos.le hdy hdx))
HEqyz : forall _ : eq Lt Eq, eq hdy hdz
HEqxy : forall _ : eq Lt Eq, eq hdx hdy
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
idtac.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
assert (H : Lt = Lt).
idtac.

*****
H : eq Lt Lt
HGtyz : iff (eq Lt Gt) (Pos.lt hdz hdy)
HGtxy : iff (eq Lt Gt) (Pos.lt hdy hdx)
HLtyz : iff (eq Lt Lt) (not (Pos.le hdz hdy))
HLtxy : iff (eq Lt Lt) (not (Pos.le hdy hdx))
HEqyz : forall _ : eq Lt Eq, eq hdy hdz
HEqxy : forall _ : eq Lt Eq, eq hdx hdy
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
apply HLtxy in H.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
assert (H : Lt = Lt).
idtac.
apply HLtxy in H.

*****
H : not (Pos.le hdy hdx)
HGtyz : iff (eq Lt Gt) (Pos.lt hdz hdy)
HGtxy : iff (eq Lt Gt) (Pos.lt hdy hdx)
HLtyz : iff (eq Lt Lt) (not (Pos.le hdz hdy))
HLtxy : iff (eq Lt Lt) (not (Pos.le hdy hdx))
HEqyz : forall _ : eq Lt Eq, eq hdy hdz
HEqxy : forall _ : eq Lt Eq, eq hdx hdy
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
clear HEqxy.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
assert (H : Lt = Lt).
idtac.
apply HLtxy in H.
clear HEqxy.

*****
H : not (Pos.le hdy hdx)
HGtyz : iff (eq Lt Gt) (Pos.lt hdz hdy)
HGtxy : iff (eq Lt Gt) (Pos.lt hdy hdx)
HLtyz : iff (eq Lt Lt) (not (Pos.le hdz hdy))
HLtxy : iff (eq Lt Lt) (not (Pos.le hdy hdx))
HEqyz : forall _ : eq Lt Eq, eq hdy hdz
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
clear HLtxy.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
assert (H : Lt = Lt).
idtac.
apply HLtxy in H.
clear HEqxy.
clear HLtxy.

*****
H : not (Pos.le hdy hdx)
HGtyz : iff (eq Lt Gt) (Pos.lt hdz hdy)
HGtxy : iff (eq Lt Gt) (Pos.lt hdy hdx)
HLtyz : iff (eq Lt Lt) (not (Pos.le hdz hdy))
HEqyz : forall _ : eq Lt Eq, eq hdy hdz
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
clear HGtxy.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
assert (H : Lt = Lt).
idtac.
apply HLtxy in H.
clear HEqxy.
clear HLtxy.
clear HGtxy.

*****
H : not (Pos.le hdy hdx)
HGtyz : iff (eq Lt Gt) (Pos.lt hdz hdy)
HLtyz : iff (eq Lt Lt) (not (Pos.le hdz hdy))
HEqyz : forall _ : eq Lt Eq, eq hdy hdz
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
assert (H' : Lt = Lt).
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
assert (H : Lt = Lt).
idtac.
apply HLtxy in H.
clear HEqxy.
clear HLtxy.
clear HGtxy.
assert (H' : Lt = Lt).

*****
H : not (Pos.le hdy hdx)
HGtyz : iff (eq Lt Gt) (Pos.lt hdz hdy)
HLtyz : iff (eq Lt Lt) (not (Pos.le hdz hdy))
HEqyz : forall _ : eq Lt Eq, eq hdy hdz
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
eq Lt Lt
+++++
reflexivity.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
assert (H : Lt = Lt).
idtac.
apply HLtxy in H.
clear HEqxy.
clear HLtxy.
clear HGtxy.
assert (H' : Lt = Lt).

*****
H' : eq Lt Lt
H : not (Pos.le hdy hdx)
HGtyz : iff (eq Lt Gt) (Pos.lt hdz hdy)
HLtyz : iff (eq Lt Lt) (not (Pos.le hdz hdy))
HEqyz : forall _ : eq Lt Eq, eq hdy hdz
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
idtac.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
assert (H : Lt = Lt).
idtac.
apply HLtxy in H.
clear HEqxy.
clear HLtxy.
clear HGtxy.
assert (H' : Lt = Lt).
idtac.

*****
H' : eq Lt Lt
H : not (Pos.le hdy hdx)
HGtyz : iff (eq Lt Gt) (Pos.lt hdz hdy)
HLtyz : iff (eq Lt Lt) (not (Pos.le hdz hdy))
HEqyz : forall _ : eq Lt Eq, eq hdy hdz
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
apply HLtyz in H'.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
assert (H : Lt = Lt).
idtac.
apply HLtxy in H.
clear HEqxy.
clear HLtxy.
clear HGtxy.
assert (H' : Lt = Lt).
idtac.
apply HLtyz in H'.

*****
H' : not (Pos.le hdz hdy)
H : not (Pos.le hdy hdx)
HGtyz : iff (eq Lt Gt) (Pos.lt hdz hdy)
HLtyz : iff (eq Lt Lt) (not (Pos.le hdz hdy))
HEqyz : forall _ : eq Lt Eq, eq hdy hdz
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
clear HEqyz.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
assert (H : Lt = Lt).
idtac.
apply HLtxy in H.
clear HEqxy.
clear HLtxy.
clear HGtxy.
assert (H' : Lt = Lt).
idtac.
apply HLtyz in H'.
clear HEqyz.

*****
H' : not (Pos.le hdz hdy)
H : not (Pos.le hdy hdx)
HGtyz : iff (eq Lt Gt) (Pos.lt hdz hdy)
HLtyz : iff (eq Lt Lt) (not (Pos.le hdz hdy))
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
clear HLtyz.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
assert (H : Lt = Lt).
idtac.
apply HLtxy in H.
clear HEqxy.
clear HLtxy.
clear HGtxy.
assert (H' : Lt = Lt).
idtac.
apply HLtyz in H'.
clear HEqyz.
clear HLtyz.

*****
H' : not (Pos.le hdz hdy)
H : not (Pos.le hdy hdx)
HGtyz : iff (eq Lt Gt) (Pos.lt hdz hdy)
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
clear HGtyz.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
assert (H : Lt = Lt).
idtac.
apply HLtxy in H.
clear HEqxy.
clear HLtxy.
clear HGtxy.
assert (H' : Lt = Lt).
idtac.
apply HLtyz in H'.
clear HEqyz.
clear HLtyz.
clear HGtyz.

*****
H' : not (Pos.le hdz hdy)
H : not (Pos.le hdy hdx)
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
rewrite <- Pos.lt_nle in H.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
assert (H : Lt = Lt).
idtac.
apply HLtxy in H.
clear HEqxy.
clear HLtxy.
clear HGtxy.
assert (H' : Lt = Lt).
idtac.
apply HLtyz in H'.
clear HEqyz.
clear HLtyz.
clear HGtyz.
rewrite <- Pos.lt_nle in H.

*****
H' : not (Pos.le hdz hdy)
H : Pos.lt hdx hdy
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
rewrite <- Pos.lt_nle in H'.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
assert (H : Lt = Lt).
idtac.
apply HLtxy in H.
clear HEqxy.
clear HLtxy.
clear HGtxy.
assert (H' : Lt = Lt).
idtac.
apply HLtyz in H'.
clear HEqyz.
clear HLtyz.
clear HGtyz.
rewrite <- Pos.lt_nle in H.
rewrite <- Pos.lt_nle in H'.

*****
H' : Pos.lt hdy hdz
H : Pos.lt hdx hdy
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
assert (H'' : Pos.lt hdx hdz).
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
assert (H : Lt = Lt).
idtac.
apply HLtxy in H.
clear HEqxy.
clear HLtxy.
clear HGtxy.
assert (H' : Lt = Lt).
idtac.
apply HLtyz in H'.
clear HEqyz.
clear HLtyz.
clear HGtyz.
rewrite <- Pos.lt_nle in H.
rewrite <- Pos.lt_nle in H'.
assert (H'' : Pos.lt hdx hdz).

*****
H' : Pos.lt hdy hdz
H : Pos.lt hdx hdy
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
Pos.lt hdx hdz
+++++
transitivity hdy.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
assert (H : Lt = Lt).
idtac.
apply HLtxy in H.
clear HEqxy.
clear HLtxy.
clear HGtxy.
assert (H' : Lt = Lt).
idtac.
apply HLtyz in H'.
clear HEqyz.
clear HLtyz.
clear HGtyz.
rewrite <- Pos.lt_nle in H.
rewrite <- Pos.lt_nle in H'.
assert (H'' : Pos.lt hdx hdz).
transitivity hdy.

*****
H' : Pos.lt hdy hdz
H : Pos.lt hdx hdy
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
Pos.lt hdx hdy
+++++
assumption.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
assert (H : Lt = Lt).
idtac.
apply HLtxy in H.
clear HEqxy.
clear HLtxy.
clear HGtxy.
assert (H' : Lt = Lt).
idtac.
apply HLtyz in H'.
clear HEqyz.
clear HLtyz.
clear HGtyz.
rewrite <- Pos.lt_nle in H.
rewrite <- Pos.lt_nle in H'.
assert (H'' : Pos.lt hdx hdz).
transitivity hdy.

*****
H' : Pos.lt hdy hdz
H : Pos.lt hdx hdy
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
Pos.lt hdy hdz
+++++
assumption.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
assert (H : Lt = Lt).
idtac.
apply HLtxy in H.
clear HEqxy.
clear HLtxy.
clear HGtxy.
assert (H' : Lt = Lt).
idtac.
apply HLtyz in H'.
clear HEqyz.
clear HLtyz.
clear HGtyz.
rewrite <- Pos.lt_nle in H.
rewrite <- Pos.lt_nle in H'.
assert (H'' : Pos.lt hdx hdz).

*****
H'' : Pos.lt hdx hdz
H' : Pos.lt hdy hdz
H : Pos.lt hdx hdy
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
idtac.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
assert (H : Lt = Lt).
idtac.
apply HLtxy in H.
clear HEqxy.
clear HLtxy.
clear HGtxy.
assert (H' : Lt = Lt).
idtac.
apply HLtyz in H'.
clear HEqyz.
clear HLtyz.
clear HGtyz.
rewrite <- Pos.lt_nle in H.
rewrite <- Pos.lt_nle in H'.
assert (H'' : Pos.lt hdx hdz).
idtac.

*****
H'' : Pos.lt hdx hdz
H' : Pos.lt hdy hdz
H : Pos.lt hdx hdy
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
rewrite <- Pos.ltb_lt in H''.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
assert (H : Lt = Lt).
idtac.
apply HLtxy in H.
clear HEqxy.
clear HLtxy.
clear HGtxy.
assert (H' : Lt = Lt).
idtac.
apply HLtyz in H'.
clear HEqyz.
clear HLtyz.
clear HGtyz.
rewrite <- Pos.lt_nle in H.
rewrite <- Pos.lt_nle in H'.
assert (H'' : Pos.lt hdx hdz).
idtac.
rewrite <- Pos.ltb_lt in H''.

*****
H'' : eq (Pos.ltb hdx hdz) true
H' : Pos.lt hdy hdz
H : Pos.lt hdx hdy
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
rewrite H''.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
assert (H : Lt = Lt).
idtac.
apply HLtxy in H.
clear HEqxy.
clear HLtxy.
clear HGtxy.
assert (H' : Lt = Lt).
idtac.
apply HLtyz in H'.
clear HEqyz.
clear HLtyz.
clear HGtyz.
rewrite <- Pos.lt_nle in H.
rewrite <- Pos.lt_nle in H'.
assert (H'' : Pos.lt hdx hdz).
idtac.
rewrite <- Pos.ltb_lt in H''.
rewrite H''.

*****
H'' : eq (Pos.ltb hdx hdz) true
H' : Pos.lt hdy hdz
H : Pos.lt hdx hdy
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
True
+++++
trivial.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).

*****
HGtyz : iff (eq Gt Gt) (Pos.lt hdz hdy)
HGtxy : iff (eq Lt Gt) (Pos.lt hdy hdx)
HLtyz : iff (eq Gt Lt) (not (Pos.le hdz hdy))
HLtxy : iff (eq Lt Lt) (not (Pos.le hdy hdx))
HEqyz : forall _ : eq Gt Eq, eq hdy hdz
HEqxy : forall _ : eq Lt Eq, eq hdx hdy
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
clear HEqxy.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
clear HEqxy.

*****
HGtyz : iff (eq Gt Gt) (Pos.lt hdz hdy)
HGtxy : iff (eq Lt Gt) (Pos.lt hdy hdx)
HLtyz : iff (eq Gt Lt) (not (Pos.le hdz hdy))
HLtxy : iff (eq Lt Lt) (not (Pos.le hdy hdx))
HEqyz : forall _ : eq Gt Eq, eq hdy hdz
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
clear HLtxy.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
clear HEqxy.
clear HLtxy.

*****
HGtyz : iff (eq Gt Gt) (Pos.lt hdz hdy)
HGtxy : iff (eq Lt Gt) (Pos.lt hdy hdx)
HLtyz : iff (eq Gt Lt) (not (Pos.le hdz hdy))
HEqyz : forall _ : eq Gt Eq, eq hdy hdz
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
clear HGtxy.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
clear HEqxy.
clear HLtxy.
clear HGtxy.

*****
HGtyz : iff (eq Gt Gt) (Pos.lt hdz hdy)
HLtyz : iff (eq Gt Lt) (not (Pos.le hdz hdy))
HEqyz : forall _ : eq Gt Eq, eq hdy hdz
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
assert (H : Gt = Gt).
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
clear HEqxy.
clear HLtxy.
clear HGtxy.
assert (H : Gt = Gt).

*****
HGtyz : iff (eq Gt Gt) (Pos.lt hdz hdy)
HLtyz : iff (eq Gt Lt) (not (Pos.le hdz hdy))
HEqyz : forall _ : eq Gt Eq, eq hdy hdz
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
eq Gt Gt
+++++
reflexivity.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
clear HEqxy.
clear HLtxy.
clear HGtxy.
assert (H : Gt = Gt).

*****
H : eq Gt Gt
HGtyz : iff (eq Gt Gt) (Pos.lt hdz hdy)
HLtyz : iff (eq Gt Lt) (not (Pos.le hdz hdy))
HEqyz : forall _ : eq Gt Eq, eq hdy hdz
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
idtac.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
clear HEqxy.
clear HLtxy.
clear HGtxy.
assert (H : Gt = Gt).
idtac.

*****
H : eq Gt Gt
HGtyz : iff (eq Gt Gt) (Pos.lt hdz hdy)
HLtyz : iff (eq Gt Lt) (not (Pos.le hdz hdy))
HEqyz : forall _ : eq Gt Eq, eq hdy hdz
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
apply HGtyz in H.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
clear HEqxy.
clear HLtxy.
clear HGtxy.
assert (H : Gt = Gt).
idtac.
apply HGtyz in H.

*****
H : Pos.lt hdz hdy
HGtyz : iff (eq Gt Gt) (Pos.lt hdz hdy)
HLtyz : iff (eq Gt Lt) (not (Pos.le hdz hdy))
HEqyz : forall _ : eq Gt Eq, eq hdy hdz
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
clear HEqyz.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
clear HEqxy.
clear HLtxy.
clear HGtxy.
assert (H : Gt = Gt).
idtac.
apply HGtyz in H.
clear HEqyz.

*****
H : Pos.lt hdz hdy
HGtyz : iff (eq Gt Gt) (Pos.lt hdz hdy)
HLtyz : iff (eq Gt Lt) (not (Pos.le hdz hdy))
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
clear HLtyz.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
clear HEqxy.
clear HLtxy.
clear HGtxy.
assert (H : Gt = Gt).
idtac.
apply HGtyz in H.
clear HEqyz.
clear HLtyz.

*****
H : Pos.lt hdz hdy
HGtyz : iff (eq Gt Gt) (Pos.lt hdz hdy)
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
clear HGtyz.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
clear HEqxy.
clear HLtxy.
clear HGtxy.
assert (H : Gt = Gt).
idtac.
apply HGtyz in H.
clear HEqyz.
clear HLtyz.
clear HGtyz.

*****
H : Pos.lt hdz hdy
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
rewrite <- Pos.ltb_lt in H.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
clear HEqxy.
clear HLtxy.
clear HGtxy.
assert (H : Gt = Gt).
idtac.
apply HGtyz in H.
clear HEqyz.
clear HLtyz.
clear HGtyz.
rewrite <- Pos.ltb_lt in H.

*****
H : eq (Pos.ltb hdz hdy) true
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
rewrite H in *.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
clear HEqxy.
clear HLtxy.
clear HGtxy.
assert (H : Gt = Gt).
idtac.
apply HGtyz in H.
clear HEqyz.
clear HLtyz.
clear HGtyz.
rewrite <- Pos.ltb_lt in H.
rewrite H in *.

*****
H : eq (Pos.ltb hdz hdy) true
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz then True else False
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
rewrite Pos.ltb_lt in H.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
clear HEqxy.
clear HLtxy.
clear HGtxy.
assert (H : Gt = Gt).
idtac.
apply HGtyz in H.
clear HEqyz.
clear HLtyz.
clear HGtyz.
rewrite <- Pos.ltb_lt in H.
rewrite H in *.
rewrite Pos.ltb_lt in H.

*****
H : Pos.lt hdz hdy
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz then True else False
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
rewrite Pos.lt_nle in H.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
clear HEqxy.
clear HLtxy.
clear HGtxy.
assert (H : Gt = Gt).
idtac.
apply HGtyz in H.
clear HEqyz.
clear HLtyz.
clear HGtyz.
rewrite <- Pos.ltb_lt in H.
rewrite H in *.
rewrite Pos.ltb_lt in H.
rewrite Pos.lt_nle in H.

*****
H : not (Pos.le hdy hdz)
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz then True else False
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
assert (H' : Pos.ltb hdy hdz = false).
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
clear HEqxy.
clear HLtxy.
clear HGtxy.
assert (H : Gt = Gt).
idtac.
apply HGtyz in H.
clear HEqyz.
clear HLtyz.
clear HGtyz.
rewrite <- Pos.ltb_lt in H.
rewrite H in *.
rewrite Pos.ltb_lt in H.
rewrite Pos.lt_nle in H.
assert (H' : Pos.ltb hdy hdz = false).

*****
H : not (Pos.le hdy hdz)
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz then True else False
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
eq (Pos.ltb hdy hdz) false
+++++
rewrite Pos.ltb_nlt.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
clear HEqxy.
clear HLtxy.
clear HGtxy.
assert (H : Gt = Gt).
idtac.
apply HGtyz in H.
clear HEqyz.
clear HLtyz.
clear HGtyz.
rewrite <- Pos.ltb_lt in H.
rewrite H in *.
rewrite Pos.ltb_lt in H.
rewrite Pos.lt_nle in H.
assert (H' : Pos.ltb hdy hdz = false).
rewrite Pos.ltb_nlt.

*****
H : not (Pos.le hdy hdz)
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz then True else False
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
not (Pos.lt hdy hdz)
+++++
intro H'.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
clear HEqxy.
clear HLtxy.
clear HGtxy.
assert (H : Gt = Gt).
idtac.
apply HGtyz in H.
clear HEqyz.
clear HLtyz.
clear HGtyz.
rewrite <- Pos.ltb_lt in H.
rewrite H in *.
rewrite Pos.ltb_lt in H.
rewrite Pos.lt_nle in H.
assert (H' : Pos.ltb hdy hdz = false).
rewrite Pos.ltb_nlt.
intro H'.

*****
H' : Pos.lt hdy hdz
H : not (Pos.le hdy hdz)
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz then True else False
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
False
+++++
apply H.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
clear HEqxy.
clear HLtxy.
clear HGtxy.
assert (H : Gt = Gt).
idtac.
apply HGtyz in H.
clear HEqyz.
clear HLtyz.
clear HGtyz.
rewrite <- Pos.ltb_lt in H.
rewrite H in *.
rewrite Pos.ltb_lt in H.
rewrite Pos.lt_nle in H.
assert (H' : Pos.ltb hdy hdz = false).
rewrite Pos.ltb_nlt.
intro H'.
apply H.

*****
H' : Pos.lt hdy hdz
H : not (Pos.le hdy hdz)
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz then True else False
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
Pos.le hdy hdz
+++++
apply Pos.lt_eq_cases.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
clear HEqxy.
clear HLtxy.
clear HGtxy.
assert (H : Gt = Gt).
idtac.
apply HGtyz in H.
clear HEqyz.
clear HLtyz.
clear HGtyz.
rewrite <- Pos.ltb_lt in H.
rewrite H in *.
rewrite Pos.ltb_lt in H.
rewrite Pos.lt_nle in H.
assert (H' : Pos.ltb hdy hdz = false).
rewrite Pos.ltb_nlt.
intro H'.
apply H.
apply Pos.lt_eq_cases.

*****
H' : Pos.lt hdy hdz
H : not (Pos.le hdy hdz)
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz then True else False
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
or (Pos.lt hdy hdz) (eq hdy hdz)
+++++
left.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
clear HEqxy.
clear HLtxy.
clear HGtxy.
assert (H : Gt = Gt).
idtac.
apply HGtyz in H.
clear HEqyz.
clear HLtyz.
clear HGtyz.
rewrite <- Pos.ltb_lt in H.
rewrite H in *.
rewrite Pos.ltb_lt in H.
rewrite Pos.lt_nle in H.
assert (H' : Pos.ltb hdy hdz = false).
rewrite Pos.ltb_nlt.
intro H'.
apply H.
apply Pos.lt_eq_cases.
left.

*****
H' : Pos.lt hdy hdz
H : not (Pos.le hdy hdz)
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz then True else False
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
Pos.lt hdy hdz
+++++
assumption.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
clear HEqxy.
clear HLtxy.
clear HGtxy.
assert (H : Gt = Gt).
idtac.
apply HGtyz in H.
clear HEqyz.
clear HLtyz.
clear HGtyz.
rewrite <- Pos.ltb_lt in H.
rewrite H in *.
rewrite Pos.ltb_lt in H.
rewrite Pos.lt_nle in H.
assert (H' : Pos.ltb hdy hdz = false).

*****
H' : eq (Pos.ltb hdy hdz) false
H : not (Pos.le hdy hdz)
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz then True else False
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
rewrite H' in *.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
clear HEqxy.
clear HLtxy.
clear HGtxy.
assert (H : Gt = Gt).
idtac.
apply HGtyz in H.
clear HEqyz.
clear HLtyz.
clear HGtyz.
rewrite <- Pos.ltb_lt in H.
rewrite H in *.
rewrite Pos.ltb_lt in H.
rewrite Pos.lt_nle in H.
assert (H' : Pos.ltb hdy hdz = false).
rewrite H' in *.

*****
H' : eq (Pos.ltb hdy hdz) false
H : not (Pos.le hdy hdz)
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : False
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
intuition.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).

*****
HGtyz : iff (eq (Pos.compare hdy hdz) Gt) (Pos.lt hdz hdy)
HGtxy : iff (eq Gt Gt) (Pos.lt hdy hdx)
HLtyz : iff (eq (Pos.compare hdy hdz) Lt) (not (Pos.le hdz hdy))
HLtxy : iff (eq Gt Lt) (not (Pos.le hdy hdx))
HEqyz : forall _ : eq (Pos.compare hdy hdz) Eq, eq hdy hdz
HEqxy : forall _ : eq Gt Eq, eq hdx hdy
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
induction (Pos.compare hdy hdz).
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).

*****
HGtyz : iff (eq Eq Gt) (Pos.lt hdz hdy)
HGtxy : iff (eq Gt Gt) (Pos.lt hdy hdx)
HLtyz : iff (eq Eq Lt) (not (Pos.le hdz hdy))
HLtxy : iff (eq Gt Lt) (not (Pos.le hdy hdx))
HEqyz : forall _ : eq Eq Eq, eq hdy hdz
HEqxy : forall _ : eq Gt Eq, eq hdx hdy
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
clear HEqyz.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
clear HEqyz.

*****
HGtyz : iff (eq Eq Gt) (Pos.lt hdz hdy)
HGtxy : iff (eq Gt Gt) (Pos.lt hdy hdx)
HLtyz : iff (eq Eq Lt) (not (Pos.le hdz hdy))
HLtxy : iff (eq Gt Lt) (not (Pos.le hdy hdx))
HEqxy : forall _ : eq Gt Eq, eq hdx hdy
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
clear HLtyz.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
clear HEqyz.
clear HLtyz.

*****
HGtyz : iff (eq Eq Gt) (Pos.lt hdz hdy)
HGtxy : iff (eq Gt Gt) (Pos.lt hdy hdx)
HLtxy : iff (eq Gt Lt) (not (Pos.le hdy hdx))
HEqxy : forall _ : eq Gt Eq, eq hdx hdy
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
clear HGtyz.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
clear HEqyz.
clear HLtyz.
clear HGtyz.

*****
HGtxy : iff (eq Gt Gt) (Pos.lt hdy hdx)
HLtxy : iff (eq Gt Lt) (not (Pos.le hdy hdx))
HEqxy : forall _ : eq Gt Eq, eq hdx hdy
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
assert (H : Gt = Gt).
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
clear HEqyz.
clear HLtyz.
clear HGtyz.
assert (H : Gt = Gt).

*****
HGtxy : iff (eq Gt Gt) (Pos.lt hdy hdx)
HLtxy : iff (eq Gt Lt) (not (Pos.le hdy hdx))
HEqxy : forall _ : eq Gt Eq, eq hdx hdy
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
eq Gt Gt
+++++
reflexivity.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
clear HEqyz.
clear HLtyz.
clear HGtyz.
assert (H : Gt = Gt).

*****
H : eq Gt Gt
HGtxy : iff (eq Gt Gt) (Pos.lt hdy hdx)
HLtxy : iff (eq Gt Lt) (not (Pos.le hdy hdx))
HEqxy : forall _ : eq Gt Eq, eq hdx hdy
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
idtac.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
clear HEqyz.
clear HLtyz.
clear HGtyz.
assert (H : Gt = Gt).
idtac.

*****
H : eq Gt Gt
HGtxy : iff (eq Gt Gt) (Pos.lt hdy hdx)
HLtxy : iff (eq Gt Lt) (not (Pos.le hdy hdx))
HEqxy : forall _ : eq Gt Eq, eq hdx hdy
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
apply HGtxy in H.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
clear HEqyz.
clear HLtyz.
clear HGtyz.
assert (H : Gt = Gt).
idtac.
apply HGtxy in H.

*****
H : Pos.lt hdy hdx
HGtxy : iff (eq Gt Gt) (Pos.lt hdy hdx)
HLtxy : iff (eq Gt Lt) (not (Pos.le hdy hdx))
HEqxy : forall _ : eq Gt Eq, eq hdx hdy
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
clear HEqxy.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
clear HEqyz.
clear HLtyz.
clear HGtyz.
assert (H : Gt = Gt).
idtac.
apply HGtxy in H.
clear HEqxy.

*****
H : Pos.lt hdy hdx
HGtxy : iff (eq Gt Gt) (Pos.lt hdy hdx)
HLtxy : iff (eq Gt Lt) (not (Pos.le hdy hdx))
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
clear HLtxy.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
clear HEqyz.
clear HLtyz.
clear HGtyz.
assert (H : Gt = Gt).
idtac.
apply HGtxy in H.
clear HEqxy.
clear HLtxy.

*****
H : Pos.lt hdy hdx
HGtxy : iff (eq Gt Gt) (Pos.lt hdy hdx)
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
clear HGtxy.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
clear HEqyz.
clear HLtyz.
clear HGtyz.
assert (H : Gt = Gt).
idtac.
apply HGtxy in H.
clear HEqxy.
clear HLtxy.
clear HGtxy.

*****
H : Pos.lt hdy hdx
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
rewrite <- Pos.ltb_lt in H.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
clear HEqyz.
clear HLtyz.
clear HGtyz.
assert (H : Gt = Gt).
idtac.
apply HGtxy in H.
clear HEqxy.
clear HLtxy.
clear HGtxy.
rewrite <- Pos.ltb_lt in H.

*****
H : eq (Pos.ltb hdy hdx) true
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
rewrite H in *.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
clear HEqyz.
clear HLtyz.
clear HGtyz.
assert (H : Gt = Gt).
idtac.
apply HGtxy in H.
clear HEqxy.
clear HLtxy.
clear HGtxy.
rewrite <- Pos.ltb_lt in H.
rewrite H in *.

*****
H : eq (Pos.ltb hdy hdx) true
Hxy : if Pos.ltb hdx hdy then True else False
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
rewrite Pos.ltb_lt in H.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
clear HEqyz.
clear HLtyz.
clear HGtyz.
assert (H : Gt = Gt).
idtac.
apply HGtxy in H.
clear HEqxy.
clear HLtxy.
clear HGtxy.
rewrite <- Pos.ltb_lt in H.
rewrite H in *.
rewrite Pos.ltb_lt in H.

*****
H : Pos.lt hdy hdx
Hxy : if Pos.ltb hdx hdy then True else False
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
rewrite Pos.lt_nle in H.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
clear HEqyz.
clear HLtyz.
clear HGtyz.
assert (H : Gt = Gt).
idtac.
apply HGtxy in H.
clear HEqxy.
clear HLtxy.
clear HGtxy.
rewrite <- Pos.ltb_lt in H.
rewrite H in *.
rewrite Pos.ltb_lt in H.
rewrite Pos.lt_nle in H.

*****
H : not (Pos.le hdx hdy)
Hxy : if Pos.ltb hdx hdy then True else False
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
assert (H' : Pos.ltb hdx hdy = false).
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
clear HEqyz.
clear HLtyz.
clear HGtyz.
assert (H : Gt = Gt).
idtac.
apply HGtxy in H.
clear HEqxy.
clear HLtxy.
clear HGtxy.
rewrite <- Pos.ltb_lt in H.
rewrite H in *.
rewrite Pos.ltb_lt in H.
rewrite Pos.lt_nle in H.
assert (H' : Pos.ltb hdx hdy = false).

*****
H : not (Pos.le hdx hdy)
Hxy : if Pos.ltb hdx hdy then True else False
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
eq (Pos.ltb hdx hdy) false
+++++
rewrite Pos.ltb_nlt.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
clear HEqyz.
clear HLtyz.
clear HGtyz.
assert (H : Gt = Gt).
idtac.
apply HGtxy in H.
clear HEqxy.
clear HLtxy.
clear HGtxy.
rewrite <- Pos.ltb_lt in H.
rewrite H in *.
rewrite Pos.ltb_lt in H.
rewrite Pos.lt_nle in H.
assert (H' : Pos.ltb hdx hdy = false).
rewrite Pos.ltb_nlt.

*****
H : not (Pos.le hdx hdy)
Hxy : if Pos.ltb hdx hdy then True else False
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
not (Pos.lt hdx hdy)
+++++
intro H'.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
clear HEqyz.
clear HLtyz.
clear HGtyz.
assert (H : Gt = Gt).
idtac.
apply HGtxy in H.
clear HEqxy.
clear HLtxy.
clear HGtxy.
rewrite <- Pos.ltb_lt in H.
rewrite H in *.
rewrite Pos.ltb_lt in H.
rewrite Pos.lt_nle in H.
assert (H' : Pos.ltb hdx hdy = false).
rewrite Pos.ltb_nlt.
intro H'.

*****
H' : Pos.lt hdx hdy
H : not (Pos.le hdx hdy)
Hxy : if Pos.ltb hdx hdy then True else False
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
False
+++++
apply H.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
clear HEqyz.
clear HLtyz.
clear HGtyz.
assert (H : Gt = Gt).
idtac.
apply HGtxy in H.
clear HEqxy.
clear HLtxy.
clear HGtxy.
rewrite <- Pos.ltb_lt in H.
rewrite H in *.
rewrite Pos.ltb_lt in H.
rewrite Pos.lt_nle in H.
assert (H' : Pos.ltb hdx hdy = false).
rewrite Pos.ltb_nlt.
intro H'.
apply H.

*****
H' : Pos.lt hdx hdy
H : not (Pos.le hdx hdy)
Hxy : if Pos.ltb hdx hdy then True else False
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
Pos.le hdx hdy
+++++
apply Pos.lt_eq_cases.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
clear HEqyz.
clear HLtyz.
clear HGtyz.
assert (H : Gt = Gt).
idtac.
apply HGtxy in H.
clear HEqxy.
clear HLtxy.
clear HGtxy.
rewrite <- Pos.ltb_lt in H.
rewrite H in *.
rewrite Pos.ltb_lt in H.
rewrite Pos.lt_nle in H.
assert (H' : Pos.ltb hdx hdy = false).
rewrite Pos.ltb_nlt.
intro H'.
apply H.
apply Pos.lt_eq_cases.

*****
H' : Pos.lt hdx hdy
H : not (Pos.le hdx hdy)
Hxy : if Pos.ltb hdx hdy then True else False
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
or (Pos.lt hdx hdy) (eq hdx hdy)
+++++
left.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
clear HEqyz.
clear HLtyz.
clear HGtyz.
assert (H : Gt = Gt).
idtac.
apply HGtxy in H.
clear HEqxy.
clear HLtxy.
clear HGtxy.
rewrite <- Pos.ltb_lt in H.
rewrite H in *.
rewrite Pos.ltb_lt in H.
rewrite Pos.lt_nle in H.
assert (H' : Pos.ltb hdx hdy = false).
rewrite Pos.ltb_nlt.
intro H'.
apply H.
apply Pos.lt_eq_cases.
left.

*****
H' : Pos.lt hdx hdy
H : not (Pos.le hdx hdy)
Hxy : if Pos.ltb hdx hdy then True else False
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
Pos.lt hdx hdy
+++++
assumption.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
clear HEqyz.
clear HLtyz.
clear HGtyz.
assert (H : Gt = Gt).
idtac.
apply HGtxy in H.
clear HEqxy.
clear HLtxy.
clear HGtxy.
rewrite <- Pos.ltb_lt in H.
rewrite H in *.
rewrite Pos.ltb_lt in H.
rewrite Pos.lt_nle in H.
assert (H' : Pos.ltb hdx hdy = false).

*****
H' : eq (Pos.ltb hdx hdy) false
H : not (Pos.le hdx hdy)
Hxy : if Pos.ltb hdx hdy then True else False
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
rewrite H' in *.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
clear HEqyz.
clear HLtyz.
clear HGtyz.
assert (H : Gt = Gt).
idtac.
apply HGtxy in H.
clear HEqxy.
clear HLtxy.
clear HGtxy.
rewrite <- Pos.ltb_lt in H.
rewrite H in *.
rewrite Pos.ltb_lt in H.
rewrite Pos.lt_nle in H.
assert (H' : Pos.ltb hdx hdy = false).
rewrite H' in *.

*****
H' : eq (Pos.ltb hdx hdy) false
H : not (Pos.le hdx hdy)
Hxy : False
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
intuition.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).

*****
HGtyz : iff (eq Lt Gt) (Pos.lt hdz hdy)
HGtxy : iff (eq Gt Gt) (Pos.lt hdy hdx)
HLtyz : iff (eq Lt Lt) (not (Pos.le hdz hdy))
HLtxy : iff (eq Gt Lt) (not (Pos.le hdy hdx))
HEqyz : forall _ : eq Lt Eq, eq hdy hdz
HEqxy : forall _ : eq Gt Eq, eq hdx hdy
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
clear HEqyz.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
clear HEqyz.

*****
HGtyz : iff (eq Lt Gt) (Pos.lt hdz hdy)
HGtxy : iff (eq Gt Gt) (Pos.lt hdy hdx)
HLtyz : iff (eq Lt Lt) (not (Pos.le hdz hdy))
HLtxy : iff (eq Gt Lt) (not (Pos.le hdy hdx))
HEqxy : forall _ : eq Gt Eq, eq hdx hdy
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
clear HLtyz.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
clear HEqyz.
clear HLtyz.

*****
HGtyz : iff (eq Lt Gt) (Pos.lt hdz hdy)
HGtxy : iff (eq Gt Gt) (Pos.lt hdy hdx)
HLtxy : iff (eq Gt Lt) (not (Pos.le hdy hdx))
HEqxy : forall _ : eq Gt Eq, eq hdx hdy
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
clear HGtyz.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
clear HEqyz.
clear HLtyz.
clear HGtyz.

*****
HGtxy : iff (eq Gt Gt) (Pos.lt hdy hdx)
HLtxy : iff (eq Gt Lt) (not (Pos.le hdy hdx))
HEqxy : forall _ : eq Gt Eq, eq hdx hdy
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
assert (H : Gt = Gt).
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
clear HEqyz.
clear HLtyz.
clear HGtyz.
assert (H : Gt = Gt).

*****
HGtxy : iff (eq Gt Gt) (Pos.lt hdy hdx)
HLtxy : iff (eq Gt Lt) (not (Pos.le hdy hdx))
HEqxy : forall _ : eq Gt Eq, eq hdx hdy
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
eq Gt Gt
+++++
reflexivity.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
clear HEqyz.
clear HLtyz.
clear HGtyz.
assert (H : Gt = Gt).

*****
H : eq Gt Gt
HGtxy : iff (eq Gt Gt) (Pos.lt hdy hdx)
HLtxy : iff (eq Gt Lt) (not (Pos.le hdy hdx))
HEqxy : forall _ : eq Gt Eq, eq hdx hdy
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
idtac.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
clear HEqyz.
clear HLtyz.
clear HGtyz.
assert (H : Gt = Gt).
idtac.

*****
H : eq Gt Gt
HGtxy : iff (eq Gt Gt) (Pos.lt hdy hdx)
HLtxy : iff (eq Gt Lt) (not (Pos.le hdy hdx))
HEqxy : forall _ : eq Gt Eq, eq hdx hdy
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
apply HGtxy in H.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
clear HEqyz.
clear HLtyz.
clear HGtyz.
assert (H : Gt = Gt).
idtac.
apply HGtxy in H.

*****
H : Pos.lt hdy hdx
HGtxy : iff (eq Gt Gt) (Pos.lt hdy hdx)
HLtxy : iff (eq Gt Lt) (not (Pos.le hdy hdx))
HEqxy : forall _ : eq Gt Eq, eq hdx hdy
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
clear HEqxy.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
clear HEqyz.
clear HLtyz.
clear HGtyz.
assert (H : Gt = Gt).
idtac.
apply HGtxy in H.
clear HEqxy.

*****
H : Pos.lt hdy hdx
HGtxy : iff (eq Gt Gt) (Pos.lt hdy hdx)
HLtxy : iff (eq Gt Lt) (not (Pos.le hdy hdx))
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
clear HLtxy.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
clear HEqyz.
clear HLtyz.
clear HGtyz.
assert (H : Gt = Gt).
idtac.
apply HGtxy in H.
clear HEqxy.
clear HLtxy.

*****
H : Pos.lt hdy hdx
HGtxy : iff (eq Gt Gt) (Pos.lt hdy hdx)
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
clear HGtxy.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
clear HEqyz.
clear HLtyz.
clear HGtyz.
assert (H : Gt = Gt).
idtac.
apply HGtxy in H.
clear HEqxy.
clear HLtxy.
clear HGtxy.

*****
H : Pos.lt hdy hdx
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
rewrite <- Pos.ltb_lt in H.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
clear HEqyz.
clear HLtyz.
clear HGtyz.
assert (H : Gt = Gt).
idtac.
apply HGtxy in H.
clear HEqxy.
clear HLtxy.
clear HGtxy.
rewrite <- Pos.ltb_lt in H.

*****
H : eq (Pos.ltb hdy hdx) true
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
rewrite H in *.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
clear HEqyz.
clear HLtyz.
clear HGtyz.
assert (H : Gt = Gt).
idtac.
apply HGtxy in H.
clear HEqxy.
clear HLtxy.
clear HGtxy.
rewrite <- Pos.ltb_lt in H.
rewrite H in *.

*****
H : eq (Pos.ltb hdy hdx) true
Hxy : if Pos.ltb hdx hdy then True else False
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
rewrite Pos.ltb_lt in H.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
clear HEqyz.
clear HLtyz.
clear HGtyz.
assert (H : Gt = Gt).
idtac.
apply HGtxy in H.
clear HEqxy.
clear HLtxy.
clear HGtxy.
rewrite <- Pos.ltb_lt in H.
rewrite H in *.
rewrite Pos.ltb_lt in H.

*****
H : Pos.lt hdy hdx
Hxy : if Pos.ltb hdx hdy then True else False
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
rewrite Pos.lt_nle in H.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
clear HEqyz.
clear HLtyz.
clear HGtyz.
assert (H : Gt = Gt).
idtac.
apply HGtxy in H.
clear HEqxy.
clear HLtxy.
clear HGtxy.
rewrite <- Pos.ltb_lt in H.
rewrite H in *.
rewrite Pos.ltb_lt in H.
rewrite Pos.lt_nle in H.

*****
H : not (Pos.le hdx hdy)
Hxy : if Pos.ltb hdx hdy then True else False
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
assert (H' : Pos.ltb hdx hdy = false).
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
clear HEqyz.
clear HLtyz.
clear HGtyz.
assert (H : Gt = Gt).
idtac.
apply HGtxy in H.
clear HEqxy.
clear HLtxy.
clear HGtxy.
rewrite <- Pos.ltb_lt in H.
rewrite H in *.
rewrite Pos.ltb_lt in H.
rewrite Pos.lt_nle in H.
assert (H' : Pos.ltb hdx hdy = false).

*****
H : not (Pos.le hdx hdy)
Hxy : if Pos.ltb hdx hdy then True else False
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
eq (Pos.ltb hdx hdy) false
+++++
rewrite Pos.ltb_nlt.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
clear HEqyz.
clear HLtyz.
clear HGtyz.
assert (H : Gt = Gt).
idtac.
apply HGtxy in H.
clear HEqxy.
clear HLtxy.
clear HGtxy.
rewrite <- Pos.ltb_lt in H.
rewrite H in *.
rewrite Pos.ltb_lt in H.
rewrite Pos.lt_nle in H.
assert (H' : Pos.ltb hdx hdy = false).
rewrite Pos.ltb_nlt.

*****
H : not (Pos.le hdx hdy)
Hxy : if Pos.ltb hdx hdy then True else False
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
not (Pos.lt hdx hdy)
+++++
intro H'.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
clear HEqyz.
clear HLtyz.
clear HGtyz.
assert (H : Gt = Gt).
idtac.
apply HGtxy in H.
clear HEqxy.
clear HLtxy.
clear HGtxy.
rewrite <- Pos.ltb_lt in H.
rewrite H in *.
rewrite Pos.ltb_lt in H.
rewrite Pos.lt_nle in H.
assert (H' : Pos.ltb hdx hdy = false).
rewrite Pos.ltb_nlt.
intro H'.

*****
H' : Pos.lt hdx hdy
H : not (Pos.le hdx hdy)
Hxy : if Pos.ltb hdx hdy then True else False
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
False
+++++
apply H.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
clear HEqyz.
clear HLtyz.
clear HGtyz.
assert (H : Gt = Gt).
idtac.
apply HGtxy in H.
clear HEqxy.
clear HLtxy.
clear HGtxy.
rewrite <- Pos.ltb_lt in H.
rewrite H in *.
rewrite Pos.ltb_lt in H.
rewrite Pos.lt_nle in H.
assert (H' : Pos.ltb hdx hdy = false).
rewrite Pos.ltb_nlt.
intro H'.
apply H.

*****
H' : Pos.lt hdx hdy
H : not (Pos.le hdx hdy)
Hxy : if Pos.ltb hdx hdy then True else False
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
Pos.le hdx hdy
+++++
apply Pos.lt_eq_cases.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
clear HEqyz.
clear HLtyz.
clear HGtyz.
assert (H : Gt = Gt).
idtac.
apply HGtxy in H.
clear HEqxy.
clear HLtxy.
clear HGtxy.
rewrite <- Pos.ltb_lt in H.
rewrite H in *.
rewrite Pos.ltb_lt in H.
rewrite Pos.lt_nle in H.
assert (H' : Pos.ltb hdx hdy = false).
rewrite Pos.ltb_nlt.
intro H'.
apply H.
apply Pos.lt_eq_cases.

*****
H' : Pos.lt hdx hdy
H : not (Pos.le hdx hdy)
Hxy : if Pos.ltb hdx hdy then True else False
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
or (Pos.lt hdx hdy) (eq hdx hdy)
+++++
left.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
clear HEqyz.
clear HLtyz.
clear HGtyz.
assert (H : Gt = Gt).
idtac.
apply HGtxy in H.
clear HEqxy.
clear HLtxy.
clear HGtxy.
rewrite <- Pos.ltb_lt in H.
rewrite H in *.
rewrite Pos.ltb_lt in H.
rewrite Pos.lt_nle in H.
assert (H' : Pos.ltb hdx hdy = false).
rewrite Pos.ltb_nlt.
intro H'.
apply H.
apply Pos.lt_eq_cases.
left.

*****
H' : Pos.lt hdx hdy
H : not (Pos.le hdx hdy)
Hxy : if Pos.ltb hdx hdy then True else False
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
Pos.lt hdx hdy
+++++
assumption.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
clear HEqyz.
clear HLtyz.
clear HGtyz.
assert (H : Gt = Gt).
idtac.
apply HGtxy in H.
clear HEqxy.
clear HLtxy.
clear HGtxy.
rewrite <- Pos.ltb_lt in H.
rewrite H in *.
rewrite Pos.ltb_lt in H.
rewrite Pos.lt_nle in H.
assert (H' : Pos.ltb hdx hdy = false).

*****
H' : eq (Pos.ltb hdx hdy) false
H : not (Pos.le hdx hdy)
Hxy : if Pos.ltb hdx hdy then True else False
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
rewrite H' in *.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
clear HEqyz.
clear HLtyz.
clear HGtyz.
assert (H : Gt = Gt).
idtac.
apply HGtxy in H.
clear HEqxy.
clear HLtxy.
clear HGtxy.
rewrite <- Pos.ltb_lt in H.
rewrite H in *.
rewrite Pos.ltb_lt in H.
rewrite Pos.lt_nle in H.
assert (H' : Pos.ltb hdx hdy = false).
rewrite H' in *.

*****
H' : eq (Pos.ltb hdx hdy) false
H : not (Pos.le hdx hdy)
Hxy : False
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
intuition.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).

*****
HGtyz : iff (eq Gt Gt) (Pos.lt hdz hdy)
HGtxy : iff (eq Gt Gt) (Pos.lt hdy hdx)
HLtyz : iff (eq Gt Lt) (not (Pos.le hdz hdy))
HLtxy : iff (eq Gt Lt) (not (Pos.le hdy hdx))
HEqyz : forall _ : eq Gt Eq, eq hdy hdz
HEqxy : forall _ : eq Gt Eq, eq hdx hdy
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
clear HEqyz.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
clear HEqyz.

*****
HGtyz : iff (eq Gt Gt) (Pos.lt hdz hdy)
HGtxy : iff (eq Gt Gt) (Pos.lt hdy hdx)
HLtyz : iff (eq Gt Lt) (not (Pos.le hdz hdy))
HLtxy : iff (eq Gt Lt) (not (Pos.le hdy hdx))
HEqxy : forall _ : eq Gt Eq, eq hdx hdy
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
clear HLtyz.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
clear HEqyz.
clear HLtyz.

*****
HGtyz : iff (eq Gt Gt) (Pos.lt hdz hdy)
HGtxy : iff (eq Gt Gt) (Pos.lt hdy hdx)
HLtxy : iff (eq Gt Lt) (not (Pos.le hdy hdx))
HEqxy : forall _ : eq Gt Eq, eq hdx hdy
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
clear HGtyz.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
clear HEqyz.
clear HLtyz.
clear HGtyz.

*****
HGtxy : iff (eq Gt Gt) (Pos.lt hdy hdx)
HLtxy : iff (eq Gt Lt) (not (Pos.le hdy hdx))
HEqxy : forall _ : eq Gt Eq, eq hdx hdy
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
assert (H : Gt = Gt).
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
clear HEqyz.
clear HLtyz.
clear HGtyz.
assert (H : Gt = Gt).

*****
HGtxy : iff (eq Gt Gt) (Pos.lt hdy hdx)
HLtxy : iff (eq Gt Lt) (not (Pos.le hdy hdx))
HEqxy : forall _ : eq Gt Eq, eq hdx hdy
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
eq Gt Gt
+++++
reflexivity.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
clear HEqyz.
clear HLtyz.
clear HGtyz.
assert (H : Gt = Gt).

*****
H : eq Gt Gt
HGtxy : iff (eq Gt Gt) (Pos.lt hdy hdx)
HLtxy : iff (eq Gt Lt) (not (Pos.le hdy hdx))
HEqxy : forall _ : eq Gt Eq, eq hdx hdy
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
idtac.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
clear HEqyz.
clear HLtyz.
clear HGtyz.
assert (H : Gt = Gt).
idtac.

*****
H : eq Gt Gt
HGtxy : iff (eq Gt Gt) (Pos.lt hdy hdx)
HLtxy : iff (eq Gt Lt) (not (Pos.le hdy hdx))
HEqxy : forall _ : eq Gt Eq, eq hdx hdy
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
apply HGtxy in H.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
clear HEqyz.
clear HLtyz.
clear HGtyz.
assert (H : Gt = Gt).
idtac.
apply HGtxy in H.

*****
H : Pos.lt hdy hdx
HGtxy : iff (eq Gt Gt) (Pos.lt hdy hdx)
HLtxy : iff (eq Gt Lt) (not (Pos.le hdy hdx))
HEqxy : forall _ : eq Gt Eq, eq hdx hdy
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
clear HEqxy.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
clear HEqyz.
clear HLtyz.
clear HGtyz.
assert (H : Gt = Gt).
idtac.
apply HGtxy in H.
clear HEqxy.

*****
H : Pos.lt hdy hdx
HGtxy : iff (eq Gt Gt) (Pos.lt hdy hdx)
HLtxy : iff (eq Gt Lt) (not (Pos.le hdy hdx))
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
clear HLtxy.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
clear HEqyz.
clear HLtyz.
clear HGtyz.
assert (H : Gt = Gt).
idtac.
apply HGtxy in H.
clear HEqxy.
clear HLtxy.

*****
H : Pos.lt hdy hdx
HGtxy : iff (eq Gt Gt) (Pos.lt hdy hdx)
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
clear HGtxy.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
clear HEqyz.
clear HLtyz.
clear HGtyz.
assert (H : Gt = Gt).
idtac.
apply HGtxy in H.
clear HEqxy.
clear HLtxy.
clear HGtxy.

*****
H : Pos.lt hdy hdx
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
rewrite <- Pos.ltb_lt in H.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
clear HEqyz.
clear HLtyz.
clear HGtyz.
assert (H : Gt = Gt).
idtac.
apply HGtxy in H.
clear HEqxy.
clear HLtxy.
clear HGtxy.
rewrite <- Pos.ltb_lt in H.

*****
H : eq (Pos.ltb hdy hdx) true
Hxy : if Pos.ltb hdx hdy\nthen True\nelse if Pos.ltb hdy hdx then False else ltList tlx tly
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
rewrite H in *.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
clear HEqyz.
clear HLtyz.
clear HGtyz.
assert (H : Gt = Gt).
idtac.
apply HGtxy in H.
clear HEqxy.
clear HLtxy.
clear HGtxy.
rewrite <- Pos.ltb_lt in H.
rewrite H in *.

*****
H : eq (Pos.ltb hdy hdx) true
Hxy : if Pos.ltb hdx hdy then True else False
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
rewrite Pos.ltb_lt in H.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
clear HEqyz.
clear HLtyz.
clear HGtyz.
assert (H : Gt = Gt).
idtac.
apply HGtxy in H.
clear HEqxy.
clear HLtxy.
clear HGtxy.
rewrite <- Pos.ltb_lt in H.
rewrite H in *.
rewrite Pos.ltb_lt in H.

*****
H : Pos.lt hdy hdx
Hxy : if Pos.ltb hdx hdy then True else False
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
rewrite Pos.lt_nle in H.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
clear HEqyz.
clear HLtyz.
clear HGtyz.
assert (H : Gt = Gt).
idtac.
apply HGtxy in H.
clear HEqxy.
clear HLtxy.
clear HGtxy.
rewrite <- Pos.ltb_lt in H.
rewrite H in *.
rewrite Pos.ltb_lt in H.
rewrite Pos.lt_nle in H.

*****
H : not (Pos.le hdx hdy)
Hxy : if Pos.ltb hdx hdy then True else False
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
assert (H' : Pos.ltb hdx hdy = false).
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
clear HEqyz.
clear HLtyz.
clear HGtyz.
assert (H : Gt = Gt).
idtac.
apply HGtxy in H.
clear HEqxy.
clear HLtxy.
clear HGtxy.
rewrite <- Pos.ltb_lt in H.
rewrite H in *.
rewrite Pos.ltb_lt in H.
rewrite Pos.lt_nle in H.
assert (H' : Pos.ltb hdx hdy = false).

*****
H : not (Pos.le hdx hdy)
Hxy : if Pos.ltb hdx hdy then True else False
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
eq (Pos.ltb hdx hdy) false
+++++
rewrite Pos.ltb_nlt.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
clear HEqyz.
clear HLtyz.
clear HGtyz.
assert (H : Gt = Gt).
idtac.
apply HGtxy in H.
clear HEqxy.
clear HLtxy.
clear HGtxy.
rewrite <- Pos.ltb_lt in H.
rewrite H in *.
rewrite Pos.ltb_lt in H.
rewrite Pos.lt_nle in H.
assert (H' : Pos.ltb hdx hdy = false).
rewrite Pos.ltb_nlt.

*****
H : not (Pos.le hdx hdy)
Hxy : if Pos.ltb hdx hdy then True else False
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
not (Pos.lt hdx hdy)
+++++
intro H'.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
clear HEqyz.
clear HLtyz.
clear HGtyz.
assert (H : Gt = Gt).
idtac.
apply HGtxy in H.
clear HEqxy.
clear HLtxy.
clear HGtxy.
rewrite <- Pos.ltb_lt in H.
rewrite H in *.
rewrite Pos.ltb_lt in H.
rewrite Pos.lt_nle in H.
assert (H' : Pos.ltb hdx hdy = false).
rewrite Pos.ltb_nlt.
intro H'.

*****
H' : Pos.lt hdx hdy
H : not (Pos.le hdx hdy)
Hxy : if Pos.ltb hdx hdy then True else False
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
False
+++++
apply H.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
clear HEqyz.
clear HLtyz.
clear HGtyz.
assert (H : Gt = Gt).
idtac.
apply HGtxy in H.
clear HEqxy.
clear HLtxy.
clear HGtxy.
rewrite <- Pos.ltb_lt in H.
rewrite H in *.
rewrite Pos.ltb_lt in H.
rewrite Pos.lt_nle in H.
assert (H' : Pos.ltb hdx hdy = false).
rewrite Pos.ltb_nlt.
intro H'.
apply H.

*****
H' : Pos.lt hdx hdy
H : not (Pos.le hdx hdy)
Hxy : if Pos.ltb hdx hdy then True else False
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
Pos.le hdx hdy
+++++
apply Pos.lt_eq_cases.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
clear HEqyz.
clear HLtyz.
clear HGtyz.
assert (H : Gt = Gt).
idtac.
apply HGtxy in H.
clear HEqxy.
clear HLtxy.
clear HGtxy.
rewrite <- Pos.ltb_lt in H.
rewrite H in *.
rewrite Pos.ltb_lt in H.
rewrite Pos.lt_nle in H.
assert (H' : Pos.ltb hdx hdy = false).
rewrite Pos.ltb_nlt.
intro H'.
apply H.
apply Pos.lt_eq_cases.

*****
H' : Pos.lt hdx hdy
H : not (Pos.le hdx hdy)
Hxy : if Pos.ltb hdx hdy then True else False
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
or (Pos.lt hdx hdy) (eq hdx hdy)
+++++
left.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
clear HEqyz.
clear HLtyz.
clear HGtyz.
assert (H : Gt = Gt).
idtac.
apply HGtxy in H.
clear HEqxy.
clear HLtxy.
clear HGtxy.
rewrite <- Pos.ltb_lt in H.
rewrite H in *.
rewrite Pos.ltb_lt in H.
rewrite Pos.lt_nle in H.
assert (H' : Pos.ltb hdx hdy = false).
rewrite Pos.ltb_nlt.
intro H'.
apply H.
apply Pos.lt_eq_cases.
left.

*****
H' : Pos.lt hdx hdy
H : not (Pos.le hdx hdy)
Hxy : if Pos.ltb hdx hdy then True else False
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
Pos.lt hdx hdy
+++++
assumption.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
clear HEqyz.
clear HLtyz.
clear HGtyz.
assert (H : Gt = Gt).
idtac.
apply HGtxy in H.
clear HEqxy.
clear HLtxy.
clear HGtxy.
rewrite <- Pos.ltb_lt in H.
rewrite H in *.
rewrite Pos.ltb_lt in H.
rewrite Pos.lt_nle in H.
assert (H' : Pos.ltb hdx hdy = false).

*****
H' : eq (Pos.ltb hdx hdy) false
H : not (Pos.le hdx hdy)
Hxy : if Pos.ltb hdx hdy then True else False
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
rewrite H' in *.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.
intros x y z lx ly lz Hxy Hyz.
assert (Hx := lengthAtLeastOne x (S m) lx).
destruct Hx as [hdx [tlx Hx]].
assert (Hy := lengthAtLeastOne y (S m) ly).
destruct Hy as [hdy [tly Hy]].
assert (Hz := lengthAtLeastOne z (S m) lz).
destruct Hz as [hdz [tlz Hz]].
subst.
simpl in *.
assert (HEqxy := Pos.compare_eq hdx hdy).
assert (HEqyz := Pos.compare_eq hdy hdz).
assert (HLtxy := Pos.compare_nge_iff hdx hdy).
assert (HLtyz := Pos.compare_nge_iff hdy hdz).
assert (HGtxy := Pos.compare_gt_iff hdx hdy).
assert (HGtyz := Pos.compare_gt_iff hdy hdz).
induction (Pos.compare hdx hdy).
induction (Pos.compare hdy hdz).
clear HEqyz.
clear HLtyz.
clear HGtyz.
assert (H : Gt = Gt).
idtac.
apply HGtxy in H.
clear HEqxy.
clear HLtxy.
clear HGtxy.
rewrite <- Pos.ltb_lt in H.
rewrite H in *.
rewrite Pos.ltb_lt in H.
rewrite Pos.lt_nle in H.
assert (H' : Pos.ltb hdx hdy = false).
rewrite H' in *.

*****
H' : eq (Pos.ltb hdx hdy) false
H : not (Pos.le hdx hdy)
Hxy : False
lz : eq (S (length tlz)) (S (S m))
Hyz : if Pos.ltb hdy hdz\nthen True\nelse if Pos.ltb hdz hdy then False else ltList tly tlz
tlz : list positive
hdz : positive
ly : eq (S (length tly)) (S (S m))
tly : list positive
hdy : positive
lx : eq (S (length tlx)) (S (S m))
tlx : list positive
hdx : positive
IHm : forall (x y z : list positive) (_ : eq (length x) (S m))\n (_ : eq (length y) (S m)) (_ : eq (length z) (S m)) \n (_ : ltList x y) (_ : ltList y z), ltList x z
m : nat
Ar : Arity
*****
if Pos.ltb hdx hdz then True else if Pos.ltb hdz hdx then False else ltList tlx tlz
+++++
intuition.
-----
Lemma ltListTrans : forall m x y z, length x = (S m) -> length y = (S m) -> length z = (S m) -> ltList x y -> ltList y z -> ltList x z.
Proof.
intro m.
induction m.

*****

*****

+++++
Qed.
-----
Lemma sortOK : forall m l, length l = m -> length (sort l) = m.
-----
Lemma sortOK : forall m l, length l = m -> length (sort l) = m.

*****
Ar : Arity
*****
forall (m : nat) (l : list positive) (_ : eq (length l) m), eq (length (sort l)) m
+++++
Proof.
-----
Lemma sortOK : forall m l, length l = m -> length (sort l) = m.
Proof.

*****
Ar : Arity
*****
forall (m : nat) (l : list positive) (_ : eq (length l) m), eq (length (sort l)) m
+++++
intros m l Hl.
-----
Lemma sortOK : forall m l, length l = m -> length (sort l) = m.
Proof.
intros m l Hl.

*****
Hl : eq (length l) m
l : list positive
m : nat
Ar : Arity
*****
eq (length (sort l)) m
+++++
assert (H := Permuted_iter_merge l nil).
-----
Lemma sortOK : forall m l, length l = m -> length (sort l) = m.
Proof.
intros m l Hl.
assert (H := Permuted_iter_merge l nil).

*****
H : Permutation.Permutation (Datatypes.app (flatten_stack nil) l)\n (iter_merge nil l)
Hl : eq (length l) m
l : list positive
m : nat
Ar : Arity
*****
eq (length (sort l)) m
+++++
apply Permutation.Permutation_length in H.
-----
Lemma sortOK : forall m l, length l = m -> length (sort l) = m.
Proof.
intros m l Hl.
assert (H := Permuted_iter_merge l nil).
apply Permutation.Permutation_length in H.

*****
H : eq (length (Datatypes.app (flatten_stack nil) l))\n (length (iter_merge nil l))
Hl : eq (length l) m
l : list positive
m : nat
Ar : Arity
*****
eq (length (sort l)) m
+++++
unfold flatten_stack in H.
-----
Lemma sortOK : forall m l, length l = m -> length (sort l) = m.
Proof.
intros m l Hl.
assert (H := Permuted_iter_merge l nil).
apply Permutation.Permutation_length in H.
unfold flatten_stack in H.

*****
H : eq (length (Datatypes.app nil l)) (length (iter_merge nil l))
Hl : eq (length l) m
l : list positive
m : nat
Ar : Arity
*****
eq (length (sort l)) m
+++++
simpl in H.
-----
Lemma sortOK : forall m l, length l = m -> length (sort l) = m.
Proof.
intros m l Hl.
assert (H := Permuted_iter_merge l nil).
apply Permutation.Permutation_length in H.
unfold flatten_stack in H.
simpl in H.

*****
H : eq (length l) (length (iter_merge nil l))
Hl : eq (length l) m
l : list positive
m : nat
Ar : Arity
*****
eq (length (sort l)) m
+++++
rewrite <- Hl.
-----
Lemma sortOK : forall m l, length l = m -> length (sort l) = m.
Proof.
intros m l Hl.
assert (H := Permuted_iter_merge l nil).
apply Permutation.Permutation_length in H.
unfold flatten_stack in H.
simpl in H.
rewrite <- Hl.

*****
H : eq (length l) (length (iter_merge nil l))
Hl : eq (length l) m
l : list positive
m : nat
Ar : Arity
*****
eq (length (sort l)) (length l)
+++++
rewrite H.
-----
Lemma sortOK : forall m l, length l = m -> length (sort l) = m.
Proof.
intros m l Hl.
assert (H := Permuted_iter_merge l nil).
apply Permutation.Permutation_length in H.
unfold flatten_stack in H.
simpl in H.
rewrite <- Hl.
rewrite H.

*****
H : eq (length l) (length (iter_merge nil l))
Hl : eq (length l) m
l : list positive
m : nat
Ar : Arity
*****
eq (length (sort l)) (length (iter_merge nil l))
+++++
unfold sort.
-----
Lemma sortOK : forall m l, length l = m -> length (sort l) = m.
Proof.
intros m l Hl.
assert (H := Permuted_iter_merge l nil).
apply Permutation.Permutation_length in H.
unfold flatten_stack in H.
simpl in H.
rewrite <- Hl.
rewrite H.
unfold sort.

*****
H : eq (length l) (length (iter_merge nil l))
Hl : eq (length l) m
l : list positive
m : nat
Ar : Arity
*****
eq (length (iter_merge nil l)) (length (iter_merge nil l))
+++++
reflexivity.
-----
Lemma sortOK : forall m l, length l = m -> length (sort l) = m.
Proof.
intros m l Hl.
assert (H := Permuted_iter_merge l nil).
apply Permutation.Permutation_length in H.
unfold flatten_stack in H.
simpl in H.
rewrite <- Hl.
rewrite H.
unfold sort.
reflexivity.

*****

*****

+++++
Qed.
-----
Definition ltST (cp1 cp2 : tST) :=\n    ltList (PosSort.sort (CPToList cp1)) (PosSort.sort (CPToList cp2)).
-----
Lemma ltTrans : Transitive ltST.
-----
Lemma ltTrans : Transitive ltST.

*****
Ar : Arity
*****
Transitive ltST
+++++
Proof.
-----
Lemma ltTrans : Transitive ltST.
Proof.

*****
Ar : Arity
*****
Transitive ltST
+++++
unfold lt.
-----
Lemma ltTrans : Transitive ltST.
Proof.
unfold lt.

*****
Ar : Arity
*****
Transitive ltST
+++++
intros x y z Hxy Hyz.
-----
Lemma ltTrans : Transitive ltST.
Proof.
unfold lt.
intros x y z Hxy Hyz.

*****
Hyz : ltST y z
Hxy : ltST x y
x,y,z : tST
Ar : Arity
*****
ltST x z
+++++
assert (lx : (S (S n)) = (S (S n))).
-----
Lemma ltTrans : Transitive ltST.
Proof.
unfold lt.
intros x y z Hxy Hyz.
assert (lx : (S (S n)) = (S (S n))).

*****
Hyz : ltST y z
Hxy : ltST x y
x,y,z : tST
Ar : Arity
*****
eq (S (S n)) (S (S n))
+++++
reflexivity.
-----
Lemma ltTrans : Transitive ltST.
Proof.
unfold lt.
intros x y z Hxy Hyz.
assert (lx : (S (S n)) = (S (S n))).

*****
lx : eq (S (S n)) (S (S n))
Hyz : ltST y z
Hxy : ltST x y
x,y,z : tST
Ar : Arity
*****
ltST x z
+++++
idtac.
-----
Lemma ltTrans : Transitive ltST.
Proof.
unfold lt.
intros x y z Hxy Hyz.
assert (lx : (S (S n)) = (S (S n))).
idtac.

*****
lx : eq (S (S n)) (S (S n))
Hyz : ltST y z
Hxy : ltST x y
x,y,z : tST
Ar : Arity
*****
ltST x z
+++++
assert (lx' := lengthOfCPToList x).
-----
Lemma ltTrans : Transitive ltST.
Proof.
unfold lt.
intros x y z Hxy Hyz.
assert (lx : (S (S n)) = (S (S n))).
idtac.
assert (lx' := lengthOfCPToList x).

*****
lx' : eq (S (S n)) (length (CPToList x))
lx : eq (S (S n)) (S (S n))
Hyz : ltST y z
Hxy : ltST x y
x,y,z : tST
Ar : Arity
*****
ltST x z
+++++
assert (lx'' := sortOK (S (S n)) (CPToList x)).
-----
Lemma ltTrans : Transitive ltST.
Proof.
unfold lt.
intros x y z Hxy Hyz.
assert (lx : (S (S n)) = (S (S n))).
idtac.
assert (lx' := lengthOfCPToList x).
assert (lx'' := sortOK (S (S n)) (CPToList x)).

*****
lx'' : forall _ : eq (length (CPToList x)) (S (S n)),\neq (length (sort (CPToList x))) (S (S n))
lx' : eq (S (S n)) (length (CPToList x))
lx : eq (S (S n)) (S (S n))
Hyz : ltST y z
Hxy : ltST x y
x,y,z : tST
Ar : Arity
*****
ltST x z
+++++
rewrite <- lx' in lx''.
-----
Lemma ltTrans : Transitive ltST.
Proof.
unfold lt.
intros x y z Hxy Hyz.
assert (lx : (S (S n)) = (S (S n))).
idtac.
assert (lx' := lengthOfCPToList x).
assert (lx'' := sortOK (S (S n)) (CPToList x)).
rewrite <- lx' in lx''.

*****
lx'' : forall _ : eq (S (S n)) (S (S n)),\neq (length (sort (CPToList x))) (S (S n))
lx' : eq (S (S n)) (length (CPToList x))
lx : eq (S (S n)) (S (S n))
Hyz : ltST y z
Hxy : ltST x y
x,y,z : tST
Ar : Arity
*****
ltST x z
+++++
clear lx'.
-----
Lemma ltTrans : Transitive ltST.
Proof.
unfold lt.
intros x y z Hxy Hyz.
assert (lx : (S (S n)) = (S (S n))).
idtac.
assert (lx' := lengthOfCPToList x).
assert (lx'' := sortOK (S (S n)) (CPToList x)).
rewrite <- lx' in lx''.
clear lx'.

*****
lx'' : forall _ : eq (S (S n)) (S (S n)),\neq (length (sort (CPToList x))) (S (S n))
lx : eq (S (S n)) (S (S n))
Hyz : ltST y z
Hxy : ltST x y
x,y,z : tST
Ar : Arity
*****
ltST x z
+++++
apply lx'' in lx.
-----
Lemma ltTrans : Transitive ltST.
Proof.
unfold lt.
intros x y z Hxy Hyz.
assert (lx : (S (S n)) = (S (S n))).
idtac.
assert (lx' := lengthOfCPToList x).
assert (lx'' := sortOK (S (S n)) (CPToList x)).
rewrite <- lx' in lx''.
clear lx'.
apply lx'' in lx.

*****
lx'' : forall _ : eq (S (S n)) (S (S n)),\neq (length (sort (CPToList x))) (S (S n))
lx : eq (length (sort (CPToList x))) (S (S n))
Hyz : ltST y z
Hxy : ltST x y
x,y,z : tST
Ar : Arity
*****
ltST x z
+++++
clear lx''.
-----
Lemma ltTrans : Transitive ltST.
Proof.
unfold lt.
intros x y z Hxy Hyz.
assert (lx : (S (S n)) = (S (S n))).
idtac.
assert (lx' := lengthOfCPToList x).
assert (lx'' := sortOK (S (S n)) (CPToList x)).
rewrite <- lx' in lx''.
clear lx'.
apply lx'' in lx.
clear lx''.

*****
lx : eq (length (sort (CPToList x))) (S (S n))
Hyz : ltST y z
Hxy : ltST x y
x,y,z : tST
Ar : Arity
*****
ltST x z
+++++
assert (ly : (S (S n)) = (S (S n))).
-----
Lemma ltTrans : Transitive ltST.
Proof.
unfold lt.
intros x y z Hxy Hyz.
assert (lx : (S (S n)) = (S (S n))).
idtac.
assert (lx' := lengthOfCPToList x).
assert (lx'' := sortOK (S (S n)) (CPToList x)).
rewrite <- lx' in lx''.
clear lx'.
apply lx'' in lx.
clear lx''.
assert (ly : (S (S n)) = (S (S n))).

*****
lx : eq (length (sort (CPToList x))) (S (S n))
Hyz : ltST y z
Hxy : ltST x y
x,y,z : tST
Ar : Arity
*****
eq (S (S n)) (S (S n))
+++++
reflexivity.
-----
Lemma ltTrans : Transitive ltST.
Proof.
unfold lt.
intros x y z Hxy Hyz.
assert (lx : (S (S n)) = (S (S n))).
idtac.
assert (lx' := lengthOfCPToList x).
assert (lx'' := sortOK (S (S n)) (CPToList x)).
rewrite <- lx' in lx''.
clear lx'.
apply lx'' in lx.
clear lx''.
assert (ly : (S (S n)) = (S (S n))).

*****
ly : eq (S (S n)) (S (S n))
lx : eq (length (sort (CPToList x))) (S (S n))
Hyz : ltST y z
Hxy : ltST x y
x,y,z : tST
Ar : Arity
*****
ltST x z
+++++
idtac.
-----
Lemma ltTrans : Transitive ltST.
Proof.
unfold lt.
intros x y z Hxy Hyz.
assert (lx : (S (S n)) = (S (S n))).
idtac.
assert (lx' := lengthOfCPToList x).
assert (lx'' := sortOK (S (S n)) (CPToList x)).
rewrite <- lx' in lx''.
clear lx'.
apply lx'' in lx.
clear lx''.
assert (ly : (S (S n)) = (S (S n))).
idtac.

*****
ly : eq (S (S n)) (S (S n))
lx : eq (length (sort (CPToList x))) (S (S n))
Hyz : ltST y z
Hxy : ltST x y
x,y,z : tST
Ar : Arity
*****
ltST x z
+++++
assert (ly' := lengthOfCPToList y).
-----
Lemma ltTrans : Transitive ltST.
Proof.
unfold lt.
intros x y z Hxy Hyz.
assert (lx : (S (S n)) = (S (S n))).
idtac.
assert (lx' := lengthOfCPToList x).
assert (lx'' := sortOK (S (S n)) (CPToList x)).
rewrite <- lx' in lx''.
clear lx'.
apply lx'' in lx.
clear lx''.
assert (ly : (S (S n)) = (S (S n))).
idtac.
assert (ly' := lengthOfCPToList y).

*****
ly' : eq (S (S n)) (length (CPToList y))
ly : eq (S (S n)) (S (S n))
lx : eq (length (sort (CPToList x))) (S (S n))
Hyz : ltST y z
Hxy : ltST x y
x,y,z : tST
Ar : Arity
*****
ltST x z
+++++
assert (ly'' := sortOK (S (S n)) (CPToList y)).
-----
Lemma ltTrans : Transitive ltST.
Proof.
unfold lt.
intros x y z Hxy Hyz.
assert (lx : (S (S n)) = (S (S n))).
idtac.
assert (lx' := lengthOfCPToList x).
assert (lx'' := sortOK (S (S n)) (CPToList x)).
rewrite <- lx' in lx''.
clear lx'.
apply lx'' in lx.
clear lx''.
assert (ly : (S (S n)) = (S (S n))).
idtac.
assert (ly' := lengthOfCPToList y).
assert (ly'' := sortOK (S (S n)) (CPToList y)).

*****
ly'' : forall _ : eq (length (CPToList y)) (S (S n)),\neq (length (sort (CPToList y))) (S (S n))
ly' : eq (S (S n)) (length (CPToList y))
ly : eq (S (S n)) (S (S n))
lx : eq (length (sort (CPToList x))) (S (S n))
Hyz : ltST y z
Hxy : ltST x y
x,y,z : tST
Ar : Arity
*****
ltST x z
+++++
rewrite <- ly' in ly''.
-----
Lemma ltTrans : Transitive ltST.
Proof.
unfold lt.
intros x y z Hxy Hyz.
assert (lx : (S (S n)) = (S (S n))).
idtac.
assert (lx' := lengthOfCPToList x).
assert (lx'' := sortOK (S (S n)) (CPToList x)).
rewrite <- lx' in lx''.
clear lx'.
apply lx'' in lx.
clear lx''.
assert (ly : (S (S n)) = (S (S n))).
idtac.
assert (ly' := lengthOfCPToList y).
assert (ly'' := sortOK (S (S n)) (CPToList y)).
rewrite <- ly' in ly''.

*****
ly'' : forall _ : eq (S (S n)) (S (S n)),\neq (length (sort (CPToList y))) (S (S n))
ly' : eq (S (S n)) (length (CPToList y))
ly : eq (S (S n)) (S (S n))
lx : eq (length (sort (CPToList x))) (S (S n))
Hyz : ltST y z
Hxy : ltST x y
x,y,z : tST
Ar : Arity
*****
ltST x z
+++++
clear ly'.
-----
Lemma ltTrans : Transitive ltST.
Proof.
unfold lt.
intros x y z Hxy Hyz.
assert (lx : (S (S n)) = (S (S n))).
idtac.
assert (lx' := lengthOfCPToList x).
assert (lx'' := sortOK (S (S n)) (CPToList x)).
rewrite <- lx' in lx''.
clear lx'.
apply lx'' in lx.
clear lx''.
assert (ly : (S (S n)) = (S (S n))).
idtac.
assert (ly' := lengthOfCPToList y).
assert (ly'' := sortOK (S (S n)) (CPToList y)).
rewrite <- ly' in ly''.
clear ly'.

*****
ly'' : forall _ : eq (S (S n)) (S (S n)),\neq (length (sort (CPToList y))) (S (S n))
ly : eq (S (S n)) (S (S n))
lx : eq (length (sort (CPToList x))) (S (S n))
Hyz : ltST y z
Hxy : ltST x y
x,y,z : tST
Ar : Arity
*****
ltST x z
+++++
apply ly'' in ly.
-----
Lemma ltTrans : Transitive ltST.
Proof.
unfold lt.
intros x y z Hxy Hyz.
assert (lx : (S (S n)) = (S (S n))).
idtac.
assert (lx' := lengthOfCPToList x).
assert (lx'' := sortOK (S (S n)) (CPToList x)).
rewrite <- lx' in lx''.
clear lx'.
apply lx'' in lx.
clear lx''.
assert (ly : (S (S n)) = (S (S n))).
idtac.
assert (ly' := lengthOfCPToList y).
assert (ly'' := sortOK (S (S n)) (CPToList y)).
rewrite <- ly' in ly''.
clear ly'.
apply ly'' in ly.

*****
ly'' : forall _ : eq (S (S n)) (S (S n)),\neq (length (sort (CPToList y))) (S (S n))
ly : eq (length (sort (CPToList y))) (S (S n))
lx : eq (length (sort (CPToList x))) (S (S n))
Hyz : ltST y z
Hxy : ltST x y
x,y,z : tST
Ar : Arity
*****
ltST x z
+++++
clear ly''.
-----
Lemma ltTrans : Transitive ltST.
Proof.
unfold lt.
intros x y z Hxy Hyz.
assert (lx : (S (S n)) = (S (S n))).
idtac.
assert (lx' := lengthOfCPToList x).
assert (lx'' := sortOK (S (S n)) (CPToList x)).
rewrite <- lx' in lx''.
clear lx'.
apply lx'' in lx.
clear lx''.
assert (ly : (S (S n)) = (S (S n))).
idtac.
assert (ly' := lengthOfCPToList y).
assert (ly'' := sortOK (S (S n)) (CPToList y)).
rewrite <- ly' in ly''.
clear ly'.
apply ly'' in ly.
clear ly''.

*****
ly : eq (length (sort (CPToList y))) (S (S n))
lx : eq (length (sort (CPToList x))) (S (S n))
Hyz : ltST y z
Hxy : ltST x y
x,y,z : tST
Ar : Arity
*****
ltST x z
+++++
assert (lz : (S (S n)) = (S (S n))).
-----
Lemma ltTrans : Transitive ltST.
Proof.
unfold lt.
intros x y z Hxy Hyz.
assert (lx : (S (S n)) = (S (S n))).
idtac.
assert (lx' := lengthOfCPToList x).
assert (lx'' := sortOK (S (S n)) (CPToList x)).
rewrite <- lx' in lx''.
clear lx'.
apply lx'' in lx.
clear lx''.
assert (ly : (S (S n)) = (S (S n))).
idtac.
assert (ly' := lengthOfCPToList y).
assert (ly'' := sortOK (S (S n)) (CPToList y)).
rewrite <- ly' in ly''.
clear ly'.
apply ly'' in ly.
clear ly''.
assert (lz : (S (S n)) = (S (S n))).

*****
ly : eq (length (sort (CPToList y))) (S (S n))
lx : eq (length (sort (CPToList x))) (S (S n))
Hyz : ltST y z
Hxy : ltST x y
x,y,z : tST
Ar : Arity
*****
eq (S (S n)) (S (S n))
+++++
reflexivity.
-----
Lemma ltTrans : Transitive ltST.
Proof.
unfold lt.
intros x y z Hxy Hyz.
assert (lx : (S (S n)) = (S (S n))).
idtac.
assert (lx' := lengthOfCPToList x).
assert (lx'' := sortOK (S (S n)) (CPToList x)).
rewrite <- lx' in lx''.
clear lx'.
apply lx'' in lx.
clear lx''.
assert (ly : (S (S n)) = (S (S n))).
idtac.
assert (ly' := lengthOfCPToList y).
assert (ly'' := sortOK (S (S n)) (CPToList y)).
rewrite <- ly' in ly''.
clear ly'.
apply ly'' in ly.
clear ly''.
assert (lz : (S (S n)) = (S (S n))).

*****
lz : eq (S (S n)) (S (S n))
ly : eq (length (sort (CPToList y))) (S (S n))
lx : eq (length (sort (CPToList x))) (S (S n))
Hyz : ltST y z
Hxy : ltST x y
x,y,z : tST
Ar : Arity
*****
ltST x z
+++++
idtac.
-----
Lemma ltTrans : Transitive ltST.
Proof.
unfold lt.
intros x y z Hxy Hyz.
assert (lx : (S (S n)) = (S (S n))).
idtac.
assert (lx' := lengthOfCPToList x).
assert (lx'' := sortOK (S (S n)) (CPToList x)).
rewrite <- lx' in lx''.
clear lx'.
apply lx'' in lx.
clear lx''.
assert (ly : (S (S n)) = (S (S n))).
idtac.
assert (ly' := lengthOfCPToList y).
assert (ly'' := sortOK (S (S n)) (CPToList y)).
rewrite <- ly' in ly''.
clear ly'.
apply ly'' in ly.
clear ly''.
assert (lz : (S (S n)) = (S (S n))).
idtac.

*****
lz : eq (S (S n)) (S (S n))
ly : eq (length (sort (CPToList y))) (S (S n))
lx : eq (length (sort (CPToList x))) (S (S n))
Hyz : ltST y z
Hxy : ltST x y
x,y,z : tST
Ar : Arity
*****
ltST x z
+++++
assert (lz' := lengthOfCPToList z).
-----
Lemma ltTrans : Transitive ltST.
Proof.
unfold lt.
intros x y z Hxy Hyz.
assert (lx : (S (S n)) = (S (S n))).
idtac.
assert (lx' := lengthOfCPToList x).
assert (lx'' := sortOK (S (S n)) (CPToList x)).
rewrite <- lx' in lx''.
clear lx'.
apply lx'' in lx.
clear lx''.
assert (ly : (S (S n)) = (S (S n))).
idtac.
assert (ly' := lengthOfCPToList y).
assert (ly'' := sortOK (S (S n)) (CPToList y)).
rewrite <- ly' in ly''.
clear ly'.
apply ly'' in ly.
clear ly''.
assert (lz : (S (S n)) = (S (S n))).
idtac.
assert (lz' := lengthOfCPToList z).

*****
lz' : eq (S (S n)) (length (CPToList z))
lz : eq (S (S n)) (S (S n))
ly : eq (length (sort (CPToList y))) (S (S n))
lx : eq (length (sort (CPToList x))) (S (S n))
Hyz : ltST y z
Hxy : ltST x y
x,y,z : tST
Ar : Arity
*****
ltST x z
+++++
assert (lz'' := sortOK (S (S n)) (CPToList z)).
-----
Lemma ltTrans : Transitive ltST.
Proof.
unfold lt.
intros x y z Hxy Hyz.
assert (lx : (S (S n)) = (S (S n))).
idtac.
assert (lx' := lengthOfCPToList x).
assert (lx'' := sortOK (S (S n)) (CPToList x)).
rewrite <- lx' in lx''.
clear lx'.
apply lx'' in lx.
clear lx''.
assert (ly : (S (S n)) = (S (S n))).
idtac.
assert (ly' := lengthOfCPToList y).
assert (ly'' := sortOK (S (S n)) (CPToList y)).
rewrite <- ly' in ly''.
clear ly'.
apply ly'' in ly.
clear ly''.
assert (lz : (S (S n)) = (S (S n))).
idtac.
assert (lz' := lengthOfCPToList z).
assert (lz'' := sortOK (S (S n)) (CPToList z)).

*****
lz'' : forall _ : eq (length (CPToList z)) (S (S n)),\neq (length (sort (CPToList z))) (S (S n))
lz' : eq (S (S n)) (length (CPToList z))
lz : eq (S (S n)) (S (S n))
ly : eq (length (sort (CPToList y))) (S (S n))
lx : eq (length (sort (CPToList x))) (S (S n))
Hyz : ltST y z
Hxy : ltST x y
x,y,z : tST
Ar : Arity
*****
ltST x z
+++++
rewrite <- lz' in lz''.
-----
Lemma ltTrans : Transitive ltST.
Proof.
unfold lt.
intros x y z Hxy Hyz.
assert (lx : (S (S n)) = (S (S n))).
idtac.
assert (lx' := lengthOfCPToList x).
assert (lx'' := sortOK (S (S n)) (CPToList x)).
rewrite <- lx' in lx''.
clear lx'.
apply lx'' in lx.
clear lx''.
assert (ly : (S (S n)) = (S (S n))).
idtac.
assert (ly' := lengthOfCPToList y).
assert (ly'' := sortOK (S (S n)) (CPToList y)).
rewrite <- ly' in ly''.
clear ly'.
apply ly'' in ly.
clear ly''.
assert (lz : (S (S n)) = (S (S n))).
idtac.
assert (lz' := lengthOfCPToList z).
assert (lz'' := sortOK (S (S n)) (CPToList z)).
rewrite <- lz' in lz''.

*****
lz'' : forall _ : eq (S (S n)) (S (S n)),\neq (length (sort (CPToList z))) (S (S n))
lz' : eq (S (S n)) (length (CPToList z))
lz : eq (S (S n)) (S (S n))
ly : eq (length (sort (CPToList y))) (S (S n))
lx : eq (length (sort (CPToList x))) (S (S n))
Hyz : ltST y z
Hxy : ltST x y
x,y,z : tST
Ar : Arity
*****
ltST x z
+++++
clear lz'.
-----
Lemma ltTrans : Transitive ltST.
Proof.
unfold lt.
intros x y z Hxy Hyz.
assert (lx : (S (S n)) = (S (S n))).
idtac.
assert (lx' := lengthOfCPToList x).
assert (lx'' := sortOK (S (S n)) (CPToList x)).
rewrite <- lx' in lx''.
clear lx'.
apply lx'' in lx.
clear lx''.
assert (ly : (S (S n)) = (S (S n))).
idtac.
assert (ly' := lengthOfCPToList y).
assert (ly'' := sortOK (S (S n)) (CPToList y)).
rewrite <- ly' in ly''.
clear ly'.
apply ly'' in ly.
clear ly''.
assert (lz : (S (S n)) = (S (S n))).
idtac.
assert (lz' := lengthOfCPToList z).
assert (lz'' := sortOK (S (S n)) (CPToList z)).
rewrite <- lz' in lz''.
clear lz'.

*****
lz'' : forall _ : eq (S (S n)) (S (S n)),\neq (length (sort (CPToList z))) (S (S n))
lz : eq (S (S n)) (S (S n))
ly : eq (length (sort (CPToList y))) (S (S n))
lx : eq (length (sort (CPToList x))) (S (S n))
Hyz : ltST y z
Hxy : ltST x y
x,y,z : tST
Ar : Arity
*****
ltST x z
+++++
apply lz'' in lz.
-----
Lemma ltTrans : Transitive ltST.
Proof.
unfold lt.
intros x y z Hxy Hyz.
assert (lx : (S (S n)) = (S (S n))).
idtac.
assert (lx' := lengthOfCPToList x).
assert (lx'' := sortOK (S (S n)) (CPToList x)).
rewrite <- lx' in lx''.
clear lx'.
apply lx'' in lx.
clear lx''.
assert (ly : (S (S n)) = (S (S n))).
idtac.
assert (ly' := lengthOfCPToList y).
assert (ly'' := sortOK (S (S n)) (CPToList y)).
rewrite <- ly' in ly''.
clear ly'.
apply ly'' in ly.
clear ly''.
assert (lz : (S (S n)) = (S (S n))).
idtac.
assert (lz' := lengthOfCPToList z).
assert (lz'' := sortOK (S (S n)) (CPToList z)).
rewrite <- lz' in lz''.
clear lz'.
apply lz'' in lz.

*****
lz'' : forall _ : eq (S (S n)) (S (S n)),\neq (length (sort (CPToList z))) (S (S n))
lz : eq (length (sort (CPToList z))) (S (S n))
ly : eq (length (sort (CPToList y))) (S (S n))
lx : eq (length (sort (CPToList x))) (S (S n))
Hyz : ltST y z
Hxy : ltST x y
x,y,z : tST
Ar : Arity
*****
ltST x z
+++++
clear lz''.
-----
Lemma ltTrans : Transitive ltST.
Proof.
unfold lt.
intros x y z Hxy Hyz.
assert (lx : (S (S n)) = (S (S n))).
idtac.
assert (lx' := lengthOfCPToList x).
assert (lx'' := sortOK (S (S n)) (CPToList x)).
rewrite <- lx' in lx''.
clear lx'.
apply lx'' in lx.
clear lx''.
assert (ly : (S (S n)) = (S (S n))).
idtac.
assert (ly' := lengthOfCPToList y).
assert (ly'' := sortOK (S (S n)) (CPToList y)).
rewrite <- ly' in ly''.
clear ly'.
apply ly'' in ly.
clear ly''.
assert (lz : (S (S n)) = (S (S n))).
idtac.
assert (lz' := lengthOfCPToList z).
assert (lz'' := sortOK (S (S n)) (CPToList z)).
rewrite <- lz' in lz''.
clear lz'.
apply lz'' in lz.
clear lz''.

*****
lz : eq (length (sort (CPToList z))) (S (S n))
ly : eq (length (sort (CPToList y))) (S (S n))
lx : eq (length (sort (CPToList x))) (S (S n))
Hyz : ltST y z
Hxy : ltST x y
x,y,z : tST
Ar : Arity
*****
ltST x z
+++++
assert (H := ltListTrans (S n) (sort (CPToList x)) (sort (CPToList y)) (sort (CPToList z))).
-----
Lemma ltTrans : Transitive ltST.
Proof.
unfold lt.
intros x y z Hxy Hyz.
assert (lx : (S (S n)) = (S (S n))).
idtac.
assert (lx' := lengthOfCPToList x).
assert (lx'' := sortOK (S (S n)) (CPToList x)).
rewrite <- lx' in lx''.
clear lx'.
apply lx'' in lx.
clear lx''.
assert (ly : (S (S n)) = (S (S n))).
idtac.
assert (ly' := lengthOfCPToList y).
assert (ly'' := sortOK (S (S n)) (CPToList y)).
rewrite <- ly' in ly''.
clear ly'.
apply ly'' in ly.
clear ly''.
assert (lz : (S (S n)) = (S (S n))).
idtac.
assert (lz' := lengthOfCPToList z).
assert (lz'' := sortOK (S (S n)) (CPToList z)).
rewrite <- lz' in lz''.
clear lz'.
apply lz'' in lz.
clear lz''.
assert (H := ltListTrans (S n) (sort (CPToList x)) (sort (CPToList y)) (sort (CPToList z))).

*****
H : forall (_ : eq (length (sort (CPToList x))) (S (S n)))\n (_ : eq (length (sort (CPToList y))) (S (S n)))\n (_ : eq (length (sort (CPToList z))) (S (S n)))\n (_ : ltList (sort (CPToList x)) (sort (CPToList y)))\n (_ : ltList (sort (CPToList y)) (sort (CPToList z))),\nltList (sort (CPToList x)) (sort (CPToList z))
lz : eq (length (sort (CPToList z))) (S (S n))
ly : eq (length (sort (CPToList y))) (S (S n))
lx : eq (length (sort (CPToList x))) (S (S n))
Hyz : ltST y z
Hxy : ltST x y
x,y,z : tST
Ar : Arity
*****
ltST x z
+++++
apply H.
-----
Lemma ltTrans : Transitive ltST.
Proof.
unfold lt.
intros x y z Hxy Hyz.
assert (lx : (S (S n)) = (S (S n))).
idtac.
assert (lx' := lengthOfCPToList x).
assert (lx'' := sortOK (S (S n)) (CPToList x)).
rewrite <- lx' in lx''.
clear lx'.
apply lx'' in lx.
clear lx''.
assert (ly : (S (S n)) = (S (S n))).
idtac.
assert (ly' := lengthOfCPToList y).
assert (ly'' := sortOK (S (S n)) (CPToList y)).
rewrite <- ly' in ly''.
clear ly'.
apply ly'' in ly.
clear ly''.
assert (lz : (S (S n)) = (S (S n))).
idtac.
assert (lz' := lengthOfCPToList z).
assert (lz'' := sortOK (S (S n)) (CPToList z)).
rewrite <- lz' in lz''.
clear lz'.
apply lz'' in lz.
clear lz''.
assert (H := ltListTrans (S n) (sort (CPToList x)) (sort (CPToList y)) (sort (CPToList z))).
apply H.

*****
H : forall (_ : eq (length (sort (CPToList x))) (S (S n)))\n (_ : eq (length (sort (CPToList y))) (S (S n)))\n (_ : eq (length (sort (CPToList z))) (S (S n)))\n (_ : ltList (sort (CPToList x)) (sort (CPToList y)))\n (_ : ltList (sort (CPToList y)) (sort (CPToList z))),\nltList (sort (CPToList x)) (sort (CPToList z))
lz : eq (length (sort (CPToList z))) (S (S n))
ly : eq (length (sort (CPToList y))) (S (S n))
lx : eq (length (sort (CPToList x))) (S (S n))
Hyz : ltST y z
Hxy : ltST x y
x,y,z : tST
Ar : Arity
*****
eq (length (sort (CPToList x))) (S (S n))
+++++
assumption.
-----
Lemma ltTrans : Transitive ltST.
Proof.
unfold lt.
intros x y z Hxy Hyz.
assert (lx : (S (S n)) = (S (S n))).
idtac.
assert (lx' := lengthOfCPToList x).
assert (lx'' := sortOK (S (S n)) (CPToList x)).
rewrite <- lx' in lx''.
clear lx'.
apply lx'' in lx.
clear lx''.
assert (ly : (S (S n)) = (S (S n))).
idtac.
assert (ly' := lengthOfCPToList y).
assert (ly'' := sortOK (S (S n)) (CPToList y)).
rewrite <- ly' in ly''.
clear ly'.
apply ly'' in ly.
clear ly''.
assert (lz : (S (S n)) = (S (S n))).
idtac.
assert (lz' := lengthOfCPToList z).
assert (lz'' := sortOK (S (S n)) (CPToList z)).
rewrite <- lz' in lz''.
clear lz'.
apply lz'' in lz.
clear lz''.
assert (H := ltListTrans (S n) (sort (CPToList x)) (sort (CPToList y)) (sort (CPToList z))).
apply H.

*****
H : forall (_ : eq (length (sort (CPToList x))) (S (S n)))\n (_ : eq (length (sort (CPToList y))) (S (S n)))\n (_ : eq (length (sort (CPToList z))) (S (S n)))\n (_ : ltList (sort (CPToList x)) (sort (CPToList y)))\n (_ : ltList (sort (CPToList y)) (sort (CPToList z))),\nltList (sort (CPToList x)) (sort (CPToList z))
lz : eq (length (sort (CPToList z))) (S (S n))
ly : eq (length (sort (CPToList y))) (S (S n))
lx : eq (length (sort (CPToList x))) (S (S n))
Hyz : ltST y z
Hxy : ltST x y
x,y,z : tST
Ar : Arity
*****
eq (length (sort (CPToList y))) (S (S n))
+++++
assumption.
-----
Lemma ltTrans : Transitive ltST.
Proof.
unfold lt.
intros x y z Hxy Hyz.
assert (lx : (S (S n)) = (S (S n))).
idtac.
assert (lx' := lengthOfCPToList x).
assert (lx'' := sortOK (S (S n)) (CPToList x)).
rewrite <- lx' in lx''.
clear lx'.
apply lx'' in lx.
clear lx''.
assert (ly : (S (S n)) = (S (S n))).
idtac.
assert (ly' := lengthOfCPToList y).
assert (ly'' := sortOK (S (S n)) (CPToList y)).
rewrite <- ly' in ly''.
clear ly'.
apply ly'' in ly.
clear ly''.
assert (lz : (S (S n)) = (S (S n))).
idtac.
assert (lz' := lengthOfCPToList z).
assert (lz'' := sortOK (S (S n)) (CPToList z)).
rewrite <- lz' in lz''.
clear lz'.
apply lz'' in lz.
clear lz''.
assert (H := ltListTrans (S n) (sort (CPToList x)) (sort (CPToList y)) (sort (CPToList z))).
apply H.

*****
H : forall (_ : eq (length (sort (CPToList x))) (S (S n)))\n (_ : eq (length (sort (CPToList y))) (S (S n)))\n (_ : eq (length (sort (CPToList z))) (S (S n)))\n (_ : ltList (sort (CPToList x)) (sort (CPToList y)))\n (_ : ltList (sort (CPToList y)) (sort (CPToList z))),\nltList (sort (CPToList x)) (sort (CPToList z))
lz : eq (length (sort (CPToList z))) (S (S n))
ly : eq (length (sort (CPToList y))) (S (S n))
lx : eq (length (sort (CPToList x))) (S (S n))
Hyz : ltST y z
Hxy : ltST x y
x,y,z : tST
Ar : Arity
*****
eq (length (sort (CPToList z))) (S (S n))
+++++
assumption.
-----
Lemma ltTrans : Transitive ltST.
Proof.
unfold lt.
intros x y z Hxy Hyz.
assert (lx : (S (S n)) = (S (S n))).
idtac.
assert (lx' := lengthOfCPToList x).
assert (lx'' := sortOK (S (S n)) (CPToList x)).
rewrite <- lx' in lx''.
clear lx'.
apply lx'' in lx.
clear lx''.
assert (ly : (S (S n)) = (S (S n))).
idtac.
assert (ly' := lengthOfCPToList y).
assert (ly'' := sortOK (S (S n)) (CPToList y)).
rewrite <- ly' in ly''.
clear ly'.
apply ly'' in ly.
clear ly''.
assert (lz : (S (S n)) = (S (S n))).
idtac.
assert (lz' := lengthOfCPToList z).
assert (lz'' := sortOK (S (S n)) (CPToList z)).
rewrite <- lz' in lz''.
clear lz'.
apply lz'' in lz.
clear lz''.
assert (H := ltListTrans (S n) (sort (CPToList x)) (sort (CPToList y)) (sort (CPToList z))).
apply H.

*****
H : forall (_ : eq (length (sort (CPToList x))) (S (S n)))\n (_ : eq (length (sort (CPToList y))) (S (S n)))\n (_ : eq (length (sort (CPToList z))) (S (S n)))\n (_ : ltList (sort (CPToList x)) (sort (CPToList y)))\n (_ : ltList (sort (CPToList y)) (sort (CPToList z))),\nltList (sort (CPToList x)) (sort (CPToList z))
lz : eq (length (sort (CPToList z))) (S (S n))
ly : eq (length (sort (CPToList y))) (S (S n))
lx : eq (length (sort (CPToList x))) (S (S n))
Hyz : ltST y z
Hxy : ltST x y
x,y,z : tST
Ar : Arity
*****
ltList (sort (CPToList x)) (sort (CPToList y))
+++++
assumption.
-----
Lemma ltTrans : Transitive ltST.
Proof.
unfold lt.
intros x y z Hxy Hyz.
assert (lx : (S (S n)) = (S (S n))).
idtac.
assert (lx' := lengthOfCPToList x).
assert (lx'' := sortOK (S (S n)) (CPToList x)).
rewrite <- lx' in lx''.
clear lx'.
apply lx'' in lx.
clear lx''.
assert (ly : (S (S n)) = (S (S n))).
idtac.
assert (ly' := lengthOfCPToList y).
assert (ly'' := sortOK (S (S n)) (CPToList y)).
rewrite <- ly' in ly''.
clear ly'.
apply ly'' in ly.
clear ly''.
assert (lz : (S (S n)) = (S (S n))).
idtac.
assert (lz' := lengthOfCPToList z).
assert (lz'' := sortOK (S (S n)) (CPToList z)).
rewrite <- lz' in lz''.
clear lz'.
apply lz'' in lz.
clear lz''.
assert (H := ltListTrans (S n) (sort (CPToList x)) (sort (CPToList y)) (sort (CPToList z))).
apply H.

*****
H : forall (_ : eq (length (sort (CPToList x))) (S (S n)))\n (_ : eq (length (sort (CPToList y))) (S (S n)))\n (_ : eq (length (sort (CPToList z))) (S (S n)))\n (_ : ltList (sort (CPToList x)) (sort (CPToList y)))\n (_ : ltList (sort (CPToList y)) (sort (CPToList z))),\nltList (sort (CPToList x)) (sort (CPToList z))
lz : eq (length (sort (CPToList z))) (S (S n))
ly : eq (length (sort (CPToList y))) (S (S n))
lx : eq (length (sort (CPToList x))) (S (S n))
Hyz : ltST y z
Hxy : ltST x y
x,y,z : tST
Ar : Arity
*****
ltList (sort (CPToList y)) (sort (CPToList z))
+++++
assumption.
-----
Lemma ltTrans : Transitive ltST.
Proof.
unfold lt.
intros x y z Hxy Hyz.
assert (lx : (S (S n)) = (S (S n))).

*****

*****

+++++
Qed.
-----
Lemma ltListIrrefl : forall l, ltList l l -> False.
-----
Lemma ltListIrrefl : forall l, ltList l l -> False.

*****
Ar : Arity
*****
forall (l : list positive) (_ : ltList l l), False
+++++
Proof.
-----
Lemma ltListIrrefl : forall l, ltList l l -> False.
Proof.

*****
Ar : Arity
*****
forall (l : list positive) (_ : ltList l l), False
+++++
intro l.
-----
Lemma ltListIrrefl : forall l, ltList l l -> False.
Proof.
intro l.

*****
l : list positive
Ar : Arity
*****
forall _ : ltList l l, False
+++++
induction l.
-----
Lemma ltListIrrefl : forall l, ltList l l -> False.
Proof.
intro l.
induction l.

*****
Ar : Arity
*****
forall _ : ltList nil nil, False
+++++
simpl.
-----
Lemma ltListIrrefl : forall l, ltList l l -> False.
Proof.
intro l.
induction l.
simpl.

*****
Ar : Arity
*****
forall _ : False, False
+++++
intuition.
-----
Lemma ltListIrrefl : forall l, ltList l l -> False.
Proof.
intro l.
induction l.

*****
IHl : forall _ : ltList l l, False
l : list positive
a : positive
Ar : Arity
*****
forall _ : ltList (cons a l) (cons a l), False
+++++
assert (H := Pos.lt_irrefl a).
-----
Lemma ltListIrrefl : forall l, ltList l l -> False.
Proof.
intro l.
induction l.
assert (H := Pos.lt_irrefl a).

*****
H : not (Pos.lt a a)
IHl : forall _ : ltList l l, False
l : list positive
a : positive
Ar : Arity
*****
forall _ : ltList (cons a l) (cons a l), False
+++++
rewrite <- Pos.ltb_nlt in H.
-----
Lemma ltListIrrefl : forall l, ltList l l -> False.
Proof.
intro l.
induction l.
assert (H := Pos.lt_irrefl a).
rewrite <- Pos.ltb_nlt in H.

*****
H : eq (Pos.ltb a a) false
IHl : forall _ : ltList l l, False
l : list positive
a : positive
Ar : Arity
*****
forall _ : ltList (cons a l) (cons a l), False
+++++
simpl.
-----
Lemma ltListIrrefl : forall l, ltList l l -> False.
Proof.
intro l.
induction l.
assert (H := Pos.lt_irrefl a).
rewrite <- Pos.ltb_nlt in H.
simpl.

*****
H : eq (Pos.ltb a a) false
IHl : forall _ : ltList l l, False
l : list positive
a : positive
Ar : Arity
*****
forall _ : if Pos.ltb a a then True else if Pos.ltb a a then False else ltList l l, False
+++++
rewrite H.
-----
Lemma ltListIrrefl : forall l, ltList l l -> False.
Proof.
intro l.
induction l.
assert (H := Pos.lt_irrefl a).
rewrite <- Pos.ltb_nlt in H.
simpl.
rewrite H.

*****
H : eq (Pos.ltb a a) false
IHl : forall _ : ltList l l, False
l : list positive
a : positive
Ar : Arity
*****
forall _ : ltList l l, False
+++++
apply IHl.
-----
Lemma ltListIrrefl : forall l, ltList l l -> False.
Proof.
intro l.
induction l.

*****

*****

+++++
Qed.
-----
Lemma eqListOK : forall l1 l2, eqList l1 l2 -> l1 = l2.
-----
Lemma eqListOK : forall l1 l2, eqList l1 l2 -> l1 = l2.

*****
Ar : Arity
*****
forall (l1 l2 : list positive) (_ : eqList l1 l2), eq l1 l2
+++++
Proof.
-----
Lemma eqListOK : forall l1 l2, eqList l1 l2 -> l1 = l2.
Proof.

*****
Ar : Arity
*****
forall (l1 l2 : list positive) (_ : eqList l1 l2), eq l1 l2
+++++
intro l1.
-----
Lemma eqListOK : forall l1 l2, eqList l1 l2 -> l1 = l2.
Proof.
intro l1.

*****
l1 : list positive
Ar : Arity
*****
forall (l2 : list positive) (_ : eqList l1 l2), eq l1 l2
+++++
induction l1.
-----
Lemma eqListOK : forall l1 l2, eqList l1 l2 -> l1 = l2.
Proof.
intro l1.
induction l1.

*****
Ar : Arity
*****
forall (l2 : list positive) (_ : eqList nil l2), eq nil l2
+++++
intro l2.
-----
Lemma eqListOK : forall l1 l2, eqList l1 l2 -> l1 = l2.
Proof.
intro l1.
induction l1.
intro l2.

*****
l2 : list positive
Ar : Arity
*****
forall _ : eqList nil l2, eq nil l2
+++++
induction l2.
-----
Lemma eqListOK : forall l1 l2, eqList l1 l2 -> l1 = l2.
Proof.
intro l1.
induction l1.
intro l2.
induction l2.

*****
Ar : Arity
*****
forall _ : eqList nil nil, eq nil nil
+++++
trivial.
-----
Lemma eqListOK : forall l1 l2, eqList l1 l2 -> l1 = l2.
Proof.
intro l1.
induction l1.
intro l2.
induction l2.

*****
IHl2 : forall _ : eqList nil l2, eq nil l2
l2 : list positive
a : positive
Ar : Arity
*****
forall _ : eqList nil (cons a l2), eq nil (cons a l2)
+++++
simpl.
-----
Lemma eqListOK : forall l1 l2, eqList l1 l2 -> l1 = l2.
Proof.
intro l1.
induction l1.
intro l2.
induction l2.
simpl.

*****
IHl2 : forall _ : eqList nil l2, eq nil l2
l2 : list positive
a : positive
Ar : Arity
*****
forall _ : False, eq nil (cons a l2)
+++++
intuition.
-----
Lemma eqListOK : forall l1 l2, eqList l1 l2 -> l1 = l2.
Proof.
intro l1.
induction l1.

*****
IHl1 : forall (l2 : list positive) (_ : eqList l1 l2), eq l1 l2
l1 : list positive
a : positive
Ar : Arity
*****
forall (l2 : list positive) (_ : eqList (cons a l1) l2), eq (cons a l1) l2
+++++
intro l2.
-----
Lemma eqListOK : forall l1 l2, eqList l1 l2 -> l1 = l2.
Proof.
intro l1.
induction l1.
intro l2.

*****
l2 : list positive
IHl1 : forall (l2 : list positive) (_ : eqList l1 l2), eq l1 l2
l1 : list positive
a : positive
Ar : Arity
*****
forall _ : eqList (cons a l1) l2, eq (cons a l1) l2
+++++
induction l2.
-----
Lemma eqListOK : forall l1 l2, eqList l1 l2 -> l1 = l2.
Proof.
intro l1.
induction l1.
intro l2.
induction l2.

*****
IHl1 : forall (l2 : list positive) (_ : eqList l1 l2), eq l1 l2
l1 : list positive
a : positive
Ar : Arity
*****
forall _ : eqList (cons a l1) nil, eq (cons a l1) nil
+++++
simpl.
-----
Lemma eqListOK : forall l1 l2, eqList l1 l2 -> l1 = l2.
Proof.
intro l1.
induction l1.
intro l2.
induction l2.
simpl.

*****
IHl1 : forall (l2 : list positive) (_ : eqList l1 l2), eq l1 l2
l1 : list positive
a : positive
Ar : Arity
*****
forall _ : False, eq (cons a l1) nil
+++++
intuition.
-----
Lemma eqListOK : forall l1 l2, eqList l1 l2 -> l1 = l2.
Proof.
intro l1.
induction l1.
intro l2.
induction l2.

*****
IHl2 : forall _ : eqList (cons a l1) l2, eq (cons a l1) l2
l2 : list positive
a0 : positive
IHl1 : forall (l2 : list positive) (_ : eqList l1 l2), eq l1 l2
l1 : list positive
a : positive
Ar : Arity
*****
forall _ : eqList (cons a l1) (cons a0 l2), eq (cons a l1) (cons a0 l2)
+++++
simpl.
-----
Lemma eqListOK : forall l1 l2, eqList l1 l2 -> l1 = l2.
Proof.
intro l1.
induction l1.
intro l2.
induction l2.
simpl.

*****
IHl2 : forall _ : eqList (cons a l1) l2, eq (cons a l1) l2
l2 : list positive
a0 : positive
IHl1 : forall (l2 : list positive) (_ : eqList l1 l2), eq l1 l2
l1 : list positive
a : positive
Ar : Arity
*****
forall _ : and (Pos.eq a a0) (eqList l1 l2), eq (cons a l1) (cons a0 l2)
+++++
intro HEq.
-----
Lemma eqListOK : forall l1 l2, eqList l1 l2 -> l1 = l2.
Proof.
intro l1.
induction l1.
intro l2.
induction l2.
simpl.
intro HEq.

*****
HEq : and (Pos.eq a a0) (eqList l1 l2)
IHl2 : forall _ : eqList (cons a l1) l2, eq (cons a l1) l2
l2 : list positive
a0 : positive
IHl1 : forall (l2 : list positive) (_ : eqList l1 l2), eq l1 l2
l1 : list positive
a : positive
Ar : Arity
*****
eq (cons a l1) (cons a0 l2)
+++++
destruct HEq as [Hhd Htl].
-----
Lemma eqListOK : forall l1 l2, eqList l1 l2 -> l1 = l2.
Proof.
intro l1.
induction l1.
intro l2.
induction l2.
simpl.
intro HEq.
destruct HEq as [Hhd Htl].

*****
Htl : eqList l1 l2
Hhd : Pos.eq a a0
IHl2 : forall _ : eqList (cons a l1) l2, eq (cons a l1) l2
l2 : list positive
a0 : positive
IHl1 : forall (l2 : list positive) (_ : eqList l1 l2), eq l1 l2
l1 : list positive
a : positive
Ar : Arity
*****
eq (cons a l1) (cons a0 l2)
+++++
unfold Pos.eq in Hhd.
-----
Lemma eqListOK : forall l1 l2, eqList l1 l2 -> l1 = l2.
Proof.
intro l1.
induction l1.
intro l2.
induction l2.
simpl.
intro HEq.
destruct HEq as [Hhd Htl].
unfold Pos.eq in Hhd.

*****
Htl : eqList l1 l2
Hhd : eq a a0
IHl2 : forall _ : eqList (cons a l1) l2, eq (cons a l1) l2
l2 : list positive
a0 : positive
IHl1 : forall (l2 : list positive) (_ : eqList l1 l2), eq l1 l2
l1 : list positive
a : positive
Ar : Arity
*****
eq (cons a l1) (cons a0 l2)
+++++
apply IHl1 in Htl.
-----
Lemma eqListOK : forall l1 l2, eqList l1 l2 -> l1 = l2.
Proof.
intro l1.
induction l1.
intro l2.
induction l2.
simpl.
intro HEq.
destruct HEq as [Hhd Htl].
unfold Pos.eq in Hhd.
apply IHl1 in Htl.

*****
Htl : eq l1 l2
Hhd : eq a a0
IHl2 : forall _ : eqList (cons a l1) l2, eq (cons a l1) l2
l2 : list positive
a0 : positive
IHl1 : forall (l2 : list positive) (_ : eqList l1 l2), eq l1 l2
l1 : list positive
a : positive
Ar : Arity
*****
eq (cons a l1) (cons a0 l2)
+++++
subst.
-----
Lemma eqListOK : forall l1 l2, eqList l1 l2 -> l1 = l2.
Proof.
intro l1.
induction l1.
intro l2.
induction l2.
simpl.
intro HEq.
destruct HEq as [Hhd Htl].
unfold Pos.eq in Hhd.
apply IHl1 in Htl.
subst.

*****
IHl1 : forall (l3 : list positive) (_ : eqList l2 l3), eq l2 l3
IHl2 : forall _ : eqList (cons a0 l2) l2, eq (cons a0 l2) l2
a0 : positive
l2 : list positive
Ar : Arity
*****
eq (cons a0 l2) (cons a0 l2)
+++++
reflexivity.
-----
Lemma eqListOK : forall l1 l2, eqList l1 l2 -> l1 = l2.
Proof.
intro l1.
induction l1.

*****

*****

+++++
Qed.
-----
Fixpoint compareList (l1 l2 : list positive) :=\n    match l1, l2 with\n    | nil, nil => Eq\n    | (hd1 :: tl1), (hd2 :: tl2) => match Pos.compare hd1 hd2 with\n                                    | Lt => Lt\n                                    | Eq => compareList tl1 tl2\n                                    | Gt => Gt\n                                    end\n    | nil, _ => Lt\n    | _, nil => Gt\n    end.
-----
Lemma compareListSpec : forall l1 l2,\n    CompSpec eqList ltList l1 l2 (compareList l1 l2).
-----
Lemma compareListSpec : forall l1 l2, CompSpec eqList ltList l1 l2 (compareList l1 l2).

*****
Ar : Arity
*****
forall l1 l2 : list positive, CompSpec eqList ltList l1 l2 (compareList l1 l2)
+++++
Proof.
-----
Lemma compareListSpec : forall l1 l2, CompSpec eqList ltList l1 l2 (compareList l1 l2).
Proof.

*****
Ar : Arity
*****
forall l1 l2 : list positive, CompSpec eqList ltList l1 l2 (compareList l1 l2)
+++++
intro l1.
-----
Lemma compareListSpec : forall l1 l2, CompSpec eqList ltList l1 l2 (compareList l1 l2).
Proof.
intro l1.

*****
l1 : list positive
Ar : Arity
*****
forall l2 : list positive, CompSpec eqList ltList l1 l2 (compareList l1 l2)
+++++
unfold eqST.
-----
Lemma compareListSpec : forall l1 l2, CompSpec eqList ltList l1 l2 (compareList l1 l2).
Proof.
intro l1.
unfold eqST.

*****
l1 : list positive
Ar : Arity
*****
forall l2 : list positive, CompSpec eqList ltList l1 l2 (compareList l1 l2)
+++++
unfold lt.
-----
Lemma compareListSpec : forall l1 l2, CompSpec eqList ltList l1 l2 (compareList l1 l2).
Proof.
intro l1.
unfold eqST.
unfold lt.

*****
l1 : list positive
Ar : Arity
*****
forall l2 : list positive, CompSpec eqList ltList l1 l2 (compareList l1 l2)
+++++
induction l1.
-----
Lemma compareListSpec : forall l1 l2, CompSpec eqList ltList l1 l2 (compareList l1 l2).
Proof.
intro l1.
unfold eqST.
unfold lt.
induction l1.

*****
Ar : Arity
*****
forall l2 : list positive, CompSpec eqList ltList nil l2 (compareList nil l2)
+++++
intro l2.
-----
Lemma compareListSpec : forall l1 l2, CompSpec eqList ltList l1 l2 (compareList l1 l2).
Proof.
intro l1.
unfold eqST.
unfold lt.
induction l1.
intro l2.

*****
l2 : list positive
Ar : Arity
*****
CompSpec eqList ltList nil l2 (compareList nil l2)
+++++
induction l2.
-----
Lemma compareListSpec : forall l1 l2, CompSpec eqList ltList l1 l2 (compareList l1 l2).
Proof.
intro l1.
unfold eqST.
unfold lt.
induction l1.
intro l2.
induction l2.

*****
Ar : Arity
*****
CompSpec eqList ltList nil nil (compareList nil nil)
+++++
simpl.
-----
Lemma compareListSpec : forall l1 l2, CompSpec eqList ltList l1 l2 (compareList l1 l2).
Proof.
intro l1.
unfold eqST.
unfold lt.
induction l1.
intro l2.
induction l2.
simpl.

*****
Ar : Arity
*****
CompSpec eqList ltList nil nil Eq
+++++
apply CompEq.
-----
Lemma compareListSpec : forall l1 l2, CompSpec eqList ltList l1 l2 (compareList l1 l2).
Proof.
intro l1.
unfold eqST.
unfold lt.
induction l1.
intro l2.
induction l2.
simpl.
apply CompEq.

*****
Ar : Arity
*****
eqList nil nil
+++++
simpl.
-----
Lemma compareListSpec : forall l1 l2, CompSpec eqList ltList l1 l2 (compareList l1 l2).
Proof.
intro l1.
unfold eqST.
unfold lt.
induction l1.
intro l2.
induction l2.
simpl.
apply CompEq.
simpl.

*****
Ar : Arity
*****
True
+++++
trivial.
-----
Lemma compareListSpec : forall l1 l2, CompSpec eqList ltList l1 l2 (compareList l1 l2).
Proof.
intro l1.
unfold eqST.
unfold lt.
induction l1.
intro l2.
induction l2.

*****
IHl2 : CompSpec eqList ltList nil l2 (compareList nil l2)
l2 : list positive
a : positive
Ar : Arity
*****
CompSpec eqList ltList nil (cons a l2) (compareList nil (cons a l2))
+++++
simpl.
-----
Lemma compareListSpec : forall l1 l2, CompSpec eqList ltList l1 l2 (compareList l1 l2).
Proof.
intro l1.
unfold eqST.
unfold lt.
induction l1.
intro l2.
induction l2.
simpl.

*****
IHl2 : CompSpec eqList ltList nil l2 (compareList nil l2)
l2 : list positive
a : positive
Ar : Arity
*****
CompSpec eqList ltList nil (cons a l2) Lt
+++++
apply CompLt.
-----
Lemma compareListSpec : forall l1 l2, CompSpec eqList ltList l1 l2 (compareList l1 l2).
Proof.
intro l1.
unfold eqST.
unfold lt.
induction l1.
intro l2.
induction l2.
simpl.
apply CompLt.

*****
IHl2 : CompSpec eqList ltList nil l2 (compareList nil l2)
l2 : list positive
a : positive
Ar : Arity
*****
ltList nil (cons a l2)
+++++
simpl.
-----
Lemma compareListSpec : forall l1 l2, CompSpec eqList ltList l1 l2 (compareList l1 l2).
Proof.
intro l1.
unfold eqST.
unfold lt.
induction l1.
intro l2.
induction l2.
simpl.
apply CompLt.
simpl.

*****
IHl2 : CompSpec eqList ltList nil l2 (compareList nil l2)
l2 : list positive
a : positive
Ar : Arity
*****
True
+++++
trivial.
-----
Lemma compareListSpec : forall l1 l2, CompSpec eqList ltList l1 l2 (compareList l1 l2).
Proof.
intro l1.
unfold eqST.
unfold lt.
induction l1.

*****
IHl1 : forall l2 : list positive,\nCompSpec eqList ltList l1 l2 (compareList l1 l2)
l1 : list positive
a : positive
Ar : Arity
*****
forall l2 : list positive, CompSpec eqList ltList (cons a l1) l2 (compareList (cons a l1) l2)
+++++
intro l2.
-----
Lemma compareListSpec : forall l1 l2, CompSpec eqList ltList l1 l2 (compareList l1 l2).
Proof.
intro l1.
unfold eqST.
unfold lt.
induction l1.
intro l2.

*****
l2 : list positive
IHl1 : forall l2 : list positive,\nCompSpec eqList ltList l1 l2 (compareList l1 l2)
l1 : list positive
a : positive
Ar : Arity
*****
CompSpec eqList ltList (cons a l1) l2 (compareList (cons a l1) l2)
+++++
induction l2.
-----
Lemma compareListSpec : forall l1 l2, CompSpec eqList ltList l1 l2 (compareList l1 l2).
Proof.
intro l1.
unfold eqST.
unfold lt.
induction l1.
intro l2.
induction l2.

*****
IHl1 : forall l2 : list positive,\nCompSpec eqList ltList l1 l2 (compareList l1 l2)
l1 : list positive
a : positive
Ar : Arity
*****
CompSpec eqList ltList (cons a l1) nil (compareList (cons a l1) nil)
+++++
simpl.
-----
Lemma compareListSpec : forall l1 l2, CompSpec eqList ltList l1 l2 (compareList l1 l2).
Proof.
intro l1.
unfold eqST.
unfold lt.
induction l1.
intro l2.
induction l2.
simpl.

*****
IHl1 : forall l2 : list positive,\nCompSpec eqList ltList l1 l2 (compareList l1 l2)
l1 : list positive
a : positive
Ar : Arity
*****
CompSpec eqList ltList (cons a l1) nil Gt
+++++
apply CompGt.
-----
Lemma compareListSpec : forall l1 l2, CompSpec eqList ltList l1 l2 (compareList l1 l2).
Proof.
intro l1.
unfold eqST.
unfold lt.
induction l1.
intro l2.
induction l2.
simpl.
apply CompGt.

*****
IHl1 : forall l2 : list positive,\nCompSpec eqList ltList l1 l2 (compareList l1 l2)
l1 : list positive
a : positive
Ar : Arity
*****
ltList nil (cons a l1)
+++++
simpl.
-----
Lemma compareListSpec : forall l1 l2, CompSpec eqList ltList l1 l2 (compareList l1 l2).
Proof.
intro l1.
unfold eqST.
unfold lt.
induction l1.
intro l2.
induction l2.
simpl.
apply CompGt.
simpl.

*****
IHl1 : forall l2 : list positive,\nCompSpec eqList ltList l1 l2 (compareList l1 l2)
l1 : list positive
a : positive
Ar : Arity
*****
True
+++++
trivial.
-----
Lemma compareListSpec : forall l1 l2, CompSpec eqList ltList l1 l2 (compareList l1 l2).
Proof.
intro l1.
unfold eqST.
unfold lt.
induction l1.
intro l2.
induction l2.

*****
IHl2 : CompSpec eqList ltList (cons a l1) l2 (compareList (cons a l1) l2)
l2 : list positive
a0 : positive
IHl1 : forall l2 : list positive,\nCompSpec eqList ltList l1 l2 (compareList l1 l2)
l1 : list positive
a : positive
Ar : Arity
*****
CompSpec eqList ltList (cons a l1) (cons a0 l2) (compareList (cons a l1) (cons a0 l2))
+++++
clear IHl2.
-----
Lemma compareListSpec : forall l1 l2, CompSpec eqList ltList l1 l2 (compareList l1 l2).
Proof.
intro l1.
unfold eqST.
unfold lt.
induction l1.
intro l2.
induction l2.
clear IHl2.

*****
l2 : list positive
a0 : positive
IHl1 : forall l2 : list positive,\nCompSpec eqList ltList l1 l2 (compareList l1 l2)
l1 : list positive
a : positive
Ar : Arity
*****
CompSpec eqList ltList (cons a l1) (cons a0 l2) (compareList (cons a l1) (cons a0 l2))
+++++
assert (HEq := Pos.compare_eq a a0).
-----
Lemma compareListSpec : forall l1 l2, CompSpec eqList ltList l1 l2 (compareList l1 l2).
Proof.
intro l1.
unfold eqST.
unfold lt.
induction l1.
intro l2.
induction l2.
clear IHl2.
assert (HEq := Pos.compare_eq a a0).

*****
HEq : forall _ : eq (Pos.compare a a0) Eq, eq a a0
l2 : list positive
a0 : positive
IHl1 : forall l2 : list positive,\nCompSpec eqList ltList l1 l2 (compareList l1 l2)
l1 : list positive
a : positive
Ar : Arity
*****
CompSpec eqList ltList (cons a l1) (cons a0 l2) (compareList (cons a l1) (cons a0 l2))
+++++
assert (HLt := Pos.compare_nge_iff a a0).
-----
Lemma compareListSpec : forall l1 l2, CompSpec eqList ltList l1 l2 (compareList l1 l2).
Proof.
intro l1.
unfold eqST.
unfold lt.
induction l1.
intro l2.
induction l2.
clear IHl2.
assert (HEq := Pos.compare_eq a a0).
assert (HLt := Pos.compare_nge_iff a a0).

*****
HLt : iff (eq (Pos.compare a a0) Lt) (not (Pos.le a0 a))
HEq : forall _ : eq (Pos.compare a a0) Eq, eq a a0
l2 : list positive
a0 : positive
IHl1 : forall l2 : list positive,\nCompSpec eqList ltList l1 l2 (compareList l1 l2)
l1 : list positive
a : positive
Ar : Arity
*****
CompSpec eqList ltList (cons a l1) (cons a0 l2) (compareList (cons a l1) (cons a0 l2))
+++++
assert (HGt := Pos.compare_gt_iff a a0).
-----
Lemma compareListSpec : forall l1 l2, CompSpec eqList ltList l1 l2 (compareList l1 l2).
Proof.
intro l1.
unfold eqST.
unfold lt.
induction l1.
intro l2.
induction l2.
clear IHl2.
assert (HEq := Pos.compare_eq a a0).
assert (HLt := Pos.compare_nge_iff a a0).
assert (HGt := Pos.compare_gt_iff a a0).

*****
HGt : iff (eq (Pos.compare a a0) Gt) (Pos.lt a0 a)
HLt : iff (eq (Pos.compare a a0) Lt) (not (Pos.le a0 a))
HEq : forall _ : eq (Pos.compare a a0) Eq, eq a a0
l2 : list positive
a0 : positive
IHl1 : forall l2 : list positive,\nCompSpec eqList ltList l1 l2 (compareList l1 l2)
l1 : list positive
a : positive
Ar : Arity
*****
CompSpec eqList ltList (cons a l1) (cons a0 l2) (compareList (cons a l1) (cons a0 l2))
+++++
induction (Pos.compare a a0).
-----
Lemma compareListSpec : forall l1 l2, CompSpec eqList ltList l1 l2 (compareList l1 l2).
Proof.
intro l1.
unfold eqST.
unfold lt.
induction l1.
intro l2.
induction l2.
clear IHl2.
assert (HEq := Pos.compare_eq a a0).
assert (HLt := Pos.compare_nge_iff a a0).
assert (HGt := Pos.compare_gt_iff a a0).
induction (Pos.compare a a0).

*****
HGt : iff (eq Eq Gt) (Pos.lt a0 a)
HLt : iff (eq Eq Lt) (not (Pos.le a0 a))
HEq : forall _ : eq Eq Eq, eq a a0
l2 : list positive
a0 : positive
IHl1 : forall l2 : list positive,\nCompSpec eqList ltList l1 l2 (compareList l1 l2)
l1 : list positive
a : positive
Ar : Arity
*****
CompSpec eqList ltList (cons a l1) (cons a0 l2) (compareList (cons a l1) (cons a0 l2))
+++++
assert (H : Eq = Eq).
-----
Lemma compareListSpec : forall l1 l2, CompSpec eqList ltList l1 l2 (compareList l1 l2).
Proof.
intro l1.
unfold eqST.
unfold lt.
induction l1.
intro l2.
induction l2.
clear IHl2.
assert (HEq := Pos.compare_eq a a0).
assert (HLt := Pos.compare_nge_iff a a0).
assert (HGt := Pos.compare_gt_iff a a0).
induction (Pos.compare a a0).
assert (H : Eq = Eq).

*****
HGt : iff (eq Eq Gt) (Pos.lt a0 a)
HLt : iff (eq Eq Lt) (not (Pos.le a0 a))
HEq : forall _ : eq Eq Eq, eq a a0
l2 : list positive
a0 : positive
IHl1 : forall l2 : list positive,\nCompSpec eqList ltList l1 l2 (compareList l1 l2)
l1 : list positive
a : positive
Ar : Arity
*****
eq Eq Eq
+++++
reflexivity.
-----
Lemma compareListSpec : forall l1 l2, CompSpec eqList ltList l1 l2 (compareList l1 l2).
Proof.
intro l1.
unfold eqST.
unfold lt.
induction l1.
intro l2.
induction l2.
clear IHl2.
assert (HEq := Pos.compare_eq a a0).
assert (HLt := Pos.compare_nge_iff a a0).
assert (HGt := Pos.compare_gt_iff a a0).
induction (Pos.compare a a0).
assert (H : Eq = Eq).

*****
H : eq Eq Eq
HGt : iff (eq Eq Gt) (Pos.lt a0 a)
HLt : iff (eq Eq Lt) (not (Pos.le a0 a))
HEq : forall _ : eq Eq Eq, eq a a0
l2 : list positive
a0 : positive
IHl1 : forall l2 : list positive,\nCompSpec eqList ltList l1 l2 (compareList l1 l2)
l1 : list positive
a : positive
Ar : Arity
*****
CompSpec eqList ltList (cons a l1) (cons a0 l2) (compareList (cons a l1) (cons a0 l2))
+++++
idtac.
-----
Lemma compareListSpec : forall l1 l2, CompSpec eqList ltList l1 l2 (compareList l1 l2).
Proof.
intro l1.
unfold eqST.
unfold lt.
induction l1.
intro l2.
induction l2.
clear IHl2.
assert (HEq := Pos.compare_eq a a0).
assert (HLt := Pos.compare_nge_iff a a0).
assert (HGt := Pos.compare_gt_iff a a0).
induction (Pos.compare a a0).
assert (H : Eq = Eq).
idtac.

*****
H : eq Eq Eq
HGt : iff (eq Eq Gt) (Pos.lt a0 a)
HLt : iff (eq Eq Lt) (not (Pos.le a0 a))
HEq : forall _ : eq Eq Eq, eq a a0
l2 : list positive
a0 : positive
IHl1 : forall l2 : list positive,\nCompSpec eqList ltList l1 l2 (compareList l1 l2)
l1 : list positive
a : positive
Ar : Arity
*****
CompSpec eqList ltList (cons a l1) (cons a0 l2) (compareList (cons a l1) (cons a0 l2))
+++++
apply HEq in H.
-----
Lemma compareListSpec : forall l1 l2, CompSpec eqList ltList l1 l2 (compareList l1 l2).
Proof.
intro l1.
unfold eqST.
unfold lt.
induction l1.
intro l2.
induction l2.
clear IHl2.
assert (HEq := Pos.compare_eq a a0).
assert (HLt := Pos.compare_nge_iff a a0).
assert (HGt := Pos.compare_gt_iff a a0).
induction (Pos.compare a a0).
assert (H : Eq = Eq).
idtac.
apply HEq in H.

*****
H : eq a a0
HGt : iff (eq Eq Gt) (Pos.lt a0 a)
HLt : iff (eq Eq Lt) (not (Pos.le a0 a))
HEq : forall _ : eq Eq Eq, eq a a0
l2 : list positive
a0 : positive
IHl1 : forall l2 : list positive,\nCompSpec eqList ltList l1 l2 (compareList l1 l2)
l1 : list positive
a : positive
Ar : Arity
*****
CompSpec eqList ltList (cons a l1) (cons a0 l2) (compareList (cons a l1) (cons a0 l2))
+++++
clear HEq.
-----
Lemma compareListSpec : forall l1 l2, CompSpec eqList ltList l1 l2 (compareList l1 l2).
Proof.
intro l1.
unfold eqST.
unfold lt.
induction l1.
intro l2.
induction l2.
clear IHl2.
assert (HEq := Pos.compare_eq a a0).
assert (HLt := Pos.compare_nge_iff a a0).
assert (HGt := Pos.compare_gt_iff a a0).
induction (Pos.compare a a0).
assert (H : Eq = Eq).
idtac.
apply HEq in H.
clear HEq.

*****
H : eq a a0
HGt : iff (eq Eq Gt) (Pos.lt a0 a)
HLt : iff (eq Eq Lt) (not (Pos.le a0 a))
l2 : list positive
a0 : positive
IHl1 : forall l2 : list positive,\nCompSpec eqList ltList l1 l2 (compareList l1 l2)
l1 : list positive
a : positive
Ar : Arity
*****
CompSpec eqList ltList (cons a l1) (cons a0 l2) (compareList (cons a l1) (cons a0 l2))
+++++
clear HLt.
-----
Lemma compareListSpec : forall l1 l2, CompSpec eqList ltList l1 l2 (compareList l1 l2).
Proof.
intro l1.
unfold eqST.
unfold lt.
induction l1.
intro l2.
induction l2.
clear IHl2.
assert (HEq := Pos.compare_eq a a0).
assert (HLt := Pos.compare_nge_iff a a0).
assert (HGt := Pos.compare_gt_iff a a0).
induction (Pos.compare a a0).
assert (H : Eq = Eq).
idtac.
apply HEq in H.
clear HEq.
clear HLt.

*****
H : eq a a0
HGt : iff (eq Eq Gt) (Pos.lt a0 a)
l2 : list positive
a0 : positive
IHl1 : forall l2 : list positive,\nCompSpec eqList ltList l1 l2 (compareList l1 l2)
l1 : list positive
a : positive
Ar : Arity
*****
CompSpec eqList ltList (cons a l1) (cons a0 l2) (compareList (cons a l1) (cons a0 l2))
+++++
clear HGt.
-----
Lemma compareListSpec : forall l1 l2, CompSpec eqList ltList l1 l2 (compareList l1 l2).
Proof.
intro l1.
unfold eqST.
unfold lt.
induction l1.
intro l2.
induction l2.
clear IHl2.
assert (HEq := Pos.compare_eq a a0).
assert (HLt := Pos.compare_nge_iff a a0).
assert (HGt := Pos.compare_gt_iff a a0).
induction (Pos.compare a a0).
assert (H : Eq = Eq).
idtac.
apply HEq in H.
clear HEq.
clear HLt.
clear HGt.

*****
H : eq a a0
l2 : list positive
a0 : positive
IHl1 : forall l2 : list positive,\nCompSpec eqList ltList l1 l2 (compareList l1 l2)
l1 : list positive
a : positive
Ar : Arity
*****
CompSpec eqList ltList (cons a l1) (cons a0 l2) (compareList (cons a l1) (cons a0 l2))
+++++
subst.
-----
Lemma compareListSpec : forall l1 l2, CompSpec eqList ltList l1 l2 (compareList l1 l2).
Proof.
intro l1.
unfold eqST.
unfold lt.
induction l1.
intro l2.
induction l2.
clear IHl2.
assert (HEq := Pos.compare_eq a a0).
assert (HLt := Pos.compare_nge_iff a a0).
assert (HGt := Pos.compare_gt_iff a a0).
induction (Pos.compare a a0).
assert (H : Eq = Eq).
idtac.
apply HEq in H.
clear HEq.
clear HLt.
clear HGt.
subst.

*****
l2 : list positive
a0 : positive
IHl1 : forall l2 : list positive,\nCompSpec eqList ltList l1 l2 (compareList l1 l2)
l1 : list positive
Ar : Arity
*****
CompSpec eqList ltList (cons a0 l1) (cons a0 l2) (compareList (cons a0 l1) (cons a0 l2))
+++++
simpl.
-----
Lemma compareListSpec : forall l1 l2, CompSpec eqList ltList l1 l2 (compareList l1 l2).
Proof.
intro l1.
unfold eqST.
unfold lt.
induction l1.
intro l2.
induction l2.
clear IHl2.
assert (HEq := Pos.compare_eq a a0).
assert (HLt := Pos.compare_nge_iff a a0).
assert (HGt := Pos.compare_gt_iff a a0).
induction (Pos.compare a a0).
assert (H : Eq = Eq).
idtac.
apply HEq in H.
clear HEq.
clear HLt.
clear HGt.
subst.
simpl.

*****
l2 : list positive
a0 : positive
IHl1 : forall l2 : list positive,\nCompSpec eqList ltList l1 l2 (compareList l1 l2)
l1 : list positive
Ar : Arity
*****
CompSpec eqList ltList (cons a0 l1) (cons a0 l2) match Pos.compare a0 a0 with | Eq => compareList l1 l2 | Lt => Lt | Gt => Gt end
+++++
rewrite POrderedType.Positive_as_OT.compare_refl.
-----
Lemma compareListSpec : forall l1 l2, CompSpec eqList ltList l1 l2 (compareList l1 l2).
Proof.
intro l1.
unfold eqST.
unfold lt.
induction l1.
intro l2.
induction l2.
clear IHl2.
assert (HEq := Pos.compare_eq a a0).
assert (HLt := Pos.compare_nge_iff a a0).
assert (HGt := Pos.compare_gt_iff a a0).
induction (Pos.compare a a0).
assert (H : Eq = Eq).
idtac.
apply HEq in H.
clear HEq.
clear HLt.
clear HGt.
subst.
simpl.
rewrite POrderedType.Positive_as_OT.compare_refl.

*****
l2 : list positive
a0 : positive
IHl1 : forall l2 : list positive,\nCompSpec eqList ltList l1 l2 (compareList l1 l2)
l1 : list positive
Ar : Arity
*****
CompSpec eqList ltList (cons a0 l1) (cons a0 l2) (compareList l1 l2)
+++++
assert (H := IHl1 l2).
-----
Lemma compareListSpec : forall l1 l2, CompSpec eqList ltList l1 l2 (compareList l1 l2).
Proof.
intro l1.
unfold eqST.
unfold lt.
induction l1.
intro l2.
induction l2.
clear IHl2.
assert (HEq := Pos.compare_eq a a0).
assert (HLt := Pos.compare_nge_iff a a0).
assert (HGt := Pos.compare_gt_iff a a0).
induction (Pos.compare a a0).
assert (H : Eq = Eq).
idtac.
apply HEq in H.
clear HEq.
clear HLt.
clear HGt.
subst.
simpl.
rewrite POrderedType.Positive_as_OT.compare_refl.
assert (H := IHl1 l2).

*****
H : CompSpec eqList ltList l1 l2 (compareList l1 l2)
l2 : list positive
a0 : positive
IHl1 : forall l2 : list positive,\nCompSpec eqList ltList l1 l2 (compareList l1 l2)
l1 : list positive
Ar : Arity
*****
CompSpec eqList ltList (cons a0 l1) (cons a0 l2) (compareList l1 l2)
+++++
clear IHl1.
-----
Lemma compareListSpec : forall l1 l2, CompSpec eqList ltList l1 l2 (compareList l1 l2).
Proof.
intro l1.
unfold eqST.
unfold lt.
induction l1.
intro l2.
induction l2.
clear IHl2.
assert (HEq := Pos.compare_eq a a0).
assert (HLt := Pos.compare_nge_iff a a0).
assert (HGt := Pos.compare_gt_iff a a0).
induction (Pos.compare a a0).
assert (H : Eq = Eq).
idtac.
apply HEq in H.
clear HEq.
clear HLt.
clear HGt.
subst.
simpl.
rewrite POrderedType.Positive_as_OT.compare_refl.
assert (H := IHl1 l2).
clear IHl1.

*****
H : CompSpec eqList ltList l1 l2 (compareList l1 l2)
l2 : list positive
a0 : positive
l1 : list positive
Ar : Arity
*****
CompSpec eqList ltList (cons a0 l1) (cons a0 l2) (compareList l1 l2)
+++++
induction H.
-----
Lemma compareListSpec : forall l1 l2, CompSpec eqList ltList l1 l2 (compareList l1 l2).
Proof.
intro l1.
unfold eqST.
unfold lt.
induction l1.
intro l2.
induction l2.
clear IHl2.
assert (HEq := Pos.compare_eq a a0).
assert (HLt := Pos.compare_nge_iff a a0).
assert (HGt := Pos.compare_gt_iff a a0).
induction (Pos.compare a a0).
assert (H : Eq = Eq).
idtac.
apply HEq in H.
clear HEq.
clear HLt.
clear HGt.
subst.
simpl.
rewrite POrderedType.Positive_as_OT.compare_refl.
assert (H := IHl1 l2).
clear IHl1.
induction H.

*****
H : eqList l1 l2
l2 : list positive
a0 : positive
l1 : list positive
Ar : Arity
*****
CompSpec eqList ltList (cons a0 l1) (cons a0 l2) Eq
+++++
apply CompEq.
-----
Lemma compareListSpec : forall l1 l2, CompSpec eqList ltList l1 l2 (compareList l1 l2).
Proof.
intro l1.
unfold eqST.
unfold lt.
induction l1.
intro l2.
induction l2.
clear IHl2.
assert (HEq := Pos.compare_eq a a0).
assert (HLt := Pos.compare_nge_iff a a0).
assert (HGt := Pos.compare_gt_iff a a0).
induction (Pos.compare a a0).
assert (H : Eq = Eq).
idtac.
apply HEq in H.
clear HEq.
clear HLt.
clear HGt.
subst.
simpl.
rewrite POrderedType.Positive_as_OT.compare_refl.
assert (H := IHl1 l2).
clear IHl1.
induction H.
apply CompEq.

*****
H : eqList l1 l2
l2 : list positive
a0 : positive
l1 : list positive
Ar : Arity
*****
eqList (cons a0 l1) (cons a0 l2)
+++++
simpl.
-----
Lemma compareListSpec : forall l1 l2, CompSpec eqList ltList l1 l2 (compareList l1 l2).
Proof.
intro l1.
unfold eqST.
unfold lt.
induction l1.
intro l2.
induction l2.
clear IHl2.
assert (HEq := Pos.compare_eq a a0).
assert (HLt := Pos.compare_nge_iff a a0).
assert (HGt := Pos.compare_gt_iff a a0).
induction (Pos.compare a a0).
assert (H : Eq = Eq).
idtac.
apply HEq in H.
clear HEq.
clear HLt.
clear HGt.
subst.
simpl.
rewrite POrderedType.Positive_as_OT.compare_refl.
assert (H := IHl1 l2).
clear IHl1.
induction H.
apply CompEq.
simpl.

*****
H : eqList l1 l2
l2 : list positive
a0 : positive
l1 : list positive
Ar : Arity
*****
and (Pos.eq a0 a0) (eqList l1 l2)
+++++
split.
-----
Lemma compareListSpec : forall l1 l2, CompSpec eqList ltList l1 l2 (compareList l1 l2).
Proof.
intro l1.
unfold eqST.
unfold lt.
induction l1.
intro l2.
induction l2.
clear IHl2.
assert (HEq := Pos.compare_eq a a0).
assert (HLt := Pos.compare_nge_iff a a0).
assert (HGt := Pos.compare_gt_iff a a0).
induction (Pos.compare a a0).
assert (H : Eq = Eq).
idtac.
apply HEq in H.
clear HEq.
clear HLt.
clear HGt.
subst.
simpl.
rewrite POrderedType.Positive_as_OT.compare_refl.
assert (H := IHl1 l2).
clear IHl1.
induction H.
apply CompEq.
simpl.
split.

*****
H : eqList l1 l2
l2 : list positive
a0 : positive
l1 : list positive
Ar : Arity
*****
Pos.eq a0 a0
+++++
auto.
-----
Lemma compareListSpec : forall l1 l2, CompSpec eqList ltList l1 l2 (compareList l1 l2).
Proof.
intro l1.
unfold eqST.
unfold lt.
induction l1.
intro l2.
induction l2.
clear IHl2.
assert (HEq := Pos.compare_eq a a0).
assert (HLt := Pos.compare_nge_iff a a0).
assert (HGt := Pos.compare_gt_iff a a0).
induction (Pos.compare a a0).
assert (H : Eq = Eq).
idtac.
apply HEq in H.
clear HEq.
clear HLt.
clear HGt.
subst.
simpl.
rewrite POrderedType.Positive_as_OT.compare_refl.
assert (H := IHl1 l2).
clear IHl1.
induction H.
apply CompEq.
simpl.
split.
auto.

*****
H : eqList l1 l2
l2 : list positive
a0 : positive
l1 : list positive
Ar : Arity
*****
Pos.eq a0 a0
+++++
apply Pos.eq_refl.
-----
Lemma compareListSpec : forall l1 l2, CompSpec eqList ltList l1 l2 (compareList l1 l2).
Proof.
intro l1.
unfold eqST.
unfold lt.
induction l1.
intro l2.
induction l2.
clear IHl2.
assert (HEq := Pos.compare_eq a a0).
assert (HLt := Pos.compare_nge_iff a a0).
assert (HGt := Pos.compare_gt_iff a a0).
induction (Pos.compare a a0).
assert (H : Eq = Eq).
idtac.
apply HEq in H.
clear HEq.
clear HLt.
clear HGt.
subst.
simpl.
rewrite POrderedType.Positive_as_OT.compare_refl.
assert (H := IHl1 l2).
clear IHl1.
induction H.
apply CompEq.
simpl.
split.

*****
H : eqList l1 l2
l2 : list positive
a0 : positive
l1 : list positive
Ar : Arity
*****
eqList l1 l2
+++++
auto.
-----
Lemma compareListSpec : forall l1 l2, CompSpec eqList ltList l1 l2 (compareList l1 l2).
Proof.
intro l1.
unfold eqST.
unfold lt.
induction l1.
intro l2.
induction l2.
clear IHl2.
assert (HEq := Pos.compare_eq a a0).
assert (HLt := Pos.compare_nge_iff a a0).
assert (HGt := Pos.compare_gt_iff a a0).
induction (Pos.compare a a0).
assert (H : Eq = Eq).
idtac.
apply HEq in H.
clear HEq.
clear HLt.
clear HGt.
subst.
simpl.
rewrite POrderedType.Positive_as_OT.compare_refl.
assert (H := IHl1 l2).
clear IHl1.
induction H.

*****
H : ltList l1 l2
l2 : list positive
a0 : positive
l1 : list positive
Ar : Arity
*****
CompSpec eqList ltList (cons a0 l1) (cons a0 l2) Lt
+++++
apply CompLt.
-----
Lemma compareListSpec : forall l1 l2, CompSpec eqList ltList l1 l2 (compareList l1 l2).
Proof.
intro l1.
unfold eqST.
unfold lt.
induction l1.
intro l2.
induction l2.
clear IHl2.
assert (HEq := Pos.compare_eq a a0).
assert (HLt := Pos.compare_nge_iff a a0).
assert (HGt := Pos.compare_gt_iff a a0).
induction (Pos.compare a a0).
assert (H : Eq = Eq).
idtac.
apply HEq in H.
clear HEq.
clear HLt.
clear HGt.
subst.
simpl.
rewrite POrderedType.Positive_as_OT.compare_refl.
assert (H := IHl1 l2).
clear IHl1.
induction H.
apply CompLt.

*****
H : ltList l1 l2
l2 : list positive
a0 : positive
l1 : list positive
Ar : Arity
*****
ltList (cons a0 l1) (cons a0 l2)
+++++
simpl.
-----
Lemma compareListSpec : forall l1 l2, CompSpec eqList ltList l1 l2 (compareList l1 l2).
Proof.
intro l1.
unfold eqST.
unfold lt.
induction l1.
intro l2.
induction l2.
clear IHl2.
assert (HEq := Pos.compare_eq a a0).
assert (HLt := Pos.compare_nge_iff a a0).
assert (HGt := Pos.compare_gt_iff a a0).
induction (Pos.compare a a0).
assert (H : Eq = Eq).
idtac.
apply HEq in H.
clear HEq.
clear HLt.
clear HGt.
subst.
simpl.
rewrite POrderedType.Positive_as_OT.compare_refl.
assert (H := IHl1 l2).
clear IHl1.
induction H.
apply CompLt.
simpl.

*****
H : ltList l1 l2
l2 : list positive
a0 : positive
l1 : list positive
Ar : Arity
*****
if Pos.ltb a0 a0 then True else if Pos.ltb a0 a0 then False else ltList l1 l2
+++++
rewrite Pos.ltb_irrefl.
-----
Lemma compareListSpec : forall l1 l2, CompSpec eqList ltList l1 l2 (compareList l1 l2).
Proof.
intro l1.
unfold eqST.
unfold lt.
induction l1.
intro l2.
induction l2.
clear IHl2.
assert (HEq := Pos.compare_eq a a0).
assert (HLt := Pos.compare_nge_iff a a0).
assert (HGt := Pos.compare_gt_iff a a0).
induction (Pos.compare a a0).
assert (H : Eq = Eq).
idtac.
apply HEq in H.
clear HEq.
clear HLt.
clear HGt.
subst.
simpl.
rewrite POrderedType.Positive_as_OT.compare_refl.
assert (H := IHl1 l2).
clear IHl1.
induction H.
apply CompLt.
simpl.
rewrite Pos.ltb_irrefl.

*****
H : ltList l1 l2
l2 : list positive
a0 : positive
l1 : list positive
Ar : Arity
*****
ltList l1 l2
+++++
auto.
-----
Lemma compareListSpec : forall l1 l2, CompSpec eqList ltList l1 l2 (compareList l1 l2).
Proof.
intro l1.
unfold eqST.
unfold lt.
induction l1.
intro l2.
induction l2.
clear IHl2.
assert (HEq := Pos.compare_eq a a0).
assert (HLt := Pos.compare_nge_iff a a0).
assert (HGt := Pos.compare_gt_iff a a0).
induction (Pos.compare a a0).
assert (H : Eq = Eq).
idtac.
apply HEq in H.
clear HEq.
clear HLt.
clear HGt.
subst.
simpl.
rewrite POrderedType.Positive_as_OT.compare_refl.
assert (H := IHl1 l2).
clear IHl1.
induction H.

*****
H : ltList l2 l1
l2 : list positive
a0 : positive
l1 : list positive
Ar : Arity
*****
CompSpec eqList ltList (cons a0 l1) (cons a0 l2) Gt
+++++
apply CompGt.
-----
Lemma compareListSpec : forall l1 l2, CompSpec eqList ltList l1 l2 (compareList l1 l2).
Proof.
intro l1.
unfold eqST.
unfold lt.
induction l1.
intro l2.
induction l2.
clear IHl2.
assert (HEq := Pos.compare_eq a a0).
assert (HLt := Pos.compare_nge_iff a a0).
assert (HGt := Pos.compare_gt_iff a a0).
induction (Pos.compare a a0).
assert (H : Eq = Eq).
idtac.
apply HEq in H.
clear HEq.
clear HLt.
clear HGt.
subst.
simpl.
rewrite POrderedType.Positive_as_OT.compare_refl.
assert (H := IHl1 l2).
clear IHl1.
induction H.
apply CompGt.

*****
H : ltList l2 l1
l2 : list positive
a0 : positive
l1 : list positive
Ar : Arity
*****
ltList (cons a0 l2) (cons a0 l1)
+++++
simpl.
-----
Lemma compareListSpec : forall l1 l2, CompSpec eqList ltList l1 l2 (compareList l1 l2).
Proof.
intro l1.
unfold eqST.
unfold lt.
induction l1.
intro l2.
induction l2.
clear IHl2.
assert (HEq := Pos.compare_eq a a0).
assert (HLt := Pos.compare_nge_iff a a0).
assert (HGt := Pos.compare_gt_iff a a0).
induction (Pos.compare a a0).
assert (H : Eq = Eq).
idtac.
apply HEq in H.
clear HEq.
clear HLt.
clear HGt.
subst.
simpl.
rewrite POrderedType.Positive_as_OT.compare_refl.
assert (H := IHl1 l2).
clear IHl1.
induction H.
apply CompGt.
simpl.

*****
H : ltList l2 l1
l2 : list positive
a0 : positive
l1 : list positive
Ar : Arity
*****
if Pos.ltb a0 a0 then True else if Pos.ltb a0 a0 then False else ltList l2 l1
+++++
rewrite Pos.ltb_irrefl.
-----
Lemma compareListSpec : forall l1 l2, CompSpec eqList ltList l1 l2 (compareList l1 l2).
Proof.
intro l1.
unfold eqST.
unfold lt.
induction l1.
intro l2.
induction l2.
clear IHl2.
assert (HEq := Pos.compare_eq a a0).
assert (HLt := Pos.compare_nge_iff a a0).
assert (HGt := Pos.compare_gt_iff a a0).
induction (Pos.compare a a0).
assert (H : Eq = Eq).
idtac.
apply HEq in H.
clear HEq.
clear HLt.
clear HGt.
subst.
simpl.
rewrite POrderedType.Positive_as_OT.compare_refl.
assert (H := IHl1 l2).
clear IHl1.
induction H.
apply CompGt.
simpl.
rewrite Pos.ltb_irrefl.

*****
H : ltList l2 l1
l2 : list positive
a0 : positive
l1 : list positive
Ar : Arity
*****
ltList l2 l1
+++++
auto.
-----
Lemma compareListSpec : forall l1 l2, CompSpec eqList ltList l1 l2 (compareList l1 l2).
Proof.
intro l1.
unfold eqST.
unfold lt.
induction l1.
intro l2.
induction l2.
clear IHl2.
assert (HEq := Pos.compare_eq a a0).
assert (HLt := Pos.compare_nge_iff a a0).
assert (HGt := Pos.compare_gt_iff a a0).
induction (Pos.compare a a0).

*****
HGt : iff (eq Lt Gt) (Pos.lt a0 a)
HLt : iff (eq Lt Lt) (not (Pos.le a0 a))
HEq : forall _ : eq Lt Eq, eq a a0
l2 : list positive
a0 : positive
IHl1 : forall l2 : list positive,\nCompSpec eqList ltList l1 l2 (compareList l1 l2)
l1 : list positive
a : positive
Ar : Arity
*****
CompSpec eqList ltList (cons a l1) (cons a0 l2) (compareList (cons a l1) (cons a0 l2))
+++++
assert (H : Lt = Lt).
-----
Lemma compareListSpec : forall l1 l2, CompSpec eqList ltList l1 l2 (compareList l1 l2).
Proof.
intro l1.
unfold eqST.
unfold lt.
induction l1.
intro l2.
induction l2.
clear IHl2.
assert (HEq := Pos.compare_eq a a0).
assert (HLt := Pos.compare_nge_iff a a0).
assert (HGt := Pos.compare_gt_iff a a0).
induction (Pos.compare a a0).
assert (H : Lt = Lt).

*****
HGt : iff (eq Lt Gt) (Pos.lt a0 a)
HLt : iff (eq Lt Lt) (not (Pos.le a0 a))
HEq : forall _ : eq Lt Eq, eq a a0
l2 : list positive
a0 : positive
IHl1 : forall l2 : list positive,\nCompSpec eqList ltList l1 l2 (compareList l1 l2)
l1 : list positive
a : positive
Ar : Arity
*****
eq Lt Lt
+++++
reflexivity.
-----
Lemma compareListSpec : forall l1 l2, CompSpec eqList ltList l1 l2 (compareList l1 l2).
Proof.
intro l1.
unfold eqST.
unfold lt.
induction l1.
intro l2.
induction l2.
clear IHl2.
assert (HEq := Pos.compare_eq a a0).
assert (HLt := Pos.compare_nge_iff a a0).
assert (HGt := Pos.compare_gt_iff a a0).
induction (Pos.compare a a0).
assert (H : Lt = Lt).

*****
H : eq Lt Lt
HGt : iff (eq Lt Gt) (Pos.lt a0 a)
HLt : iff (eq Lt Lt) (not (Pos.le a0 a))
HEq : forall _ : eq Lt Eq, eq a a0
l2 : list positive
a0 : positive
IHl1 : forall l2 : list positive,\nCompSpec eqList ltList l1 l2 (compareList l1 l2)
l1 : list positive
a : positive
Ar : Arity
*****
CompSpec eqList ltList (cons a l1) (cons a0 l2) (compareList (cons a l1) (cons a0 l2))
+++++
idtac.
-----
Lemma compareListSpec : forall l1 l2, CompSpec eqList ltList l1 l2 (compareList l1 l2).
Proof.
intro l1.
unfold eqST.
unfold lt.
induction l1.
intro l2.
induction l2.
clear IHl2.
assert (HEq := Pos.compare_eq a a0).
assert (HLt := Pos.compare_nge_iff a a0).
assert (HGt := Pos.compare_gt_iff a a0).
induction (Pos.compare a a0).
assert (H : Lt = Lt).
idtac.

*****
H : eq Lt Lt
HGt : iff (eq Lt Gt) (Pos.lt a0 a)
HLt : iff (eq Lt Lt) (not (Pos.le a0 a))
HEq : forall _ : eq Lt Eq, eq a a0
l2 : list positive
a0 : positive
IHl1 : forall l2 : list positive,\nCompSpec eqList ltList l1 l2 (compareList l1 l2)
l1 : list positive
a : positive
Ar : Arity
*****
CompSpec eqList ltList (cons a l1) (cons a0 l2) (compareList (cons a l1) (cons a0 l2))
+++++
apply HLt in H.
-----
Lemma compareListSpec : forall l1 l2, CompSpec eqList ltList l1 l2 (compareList l1 l2).
Proof.
intro l1.
unfold eqST.
unfold lt.
induction l1.
intro l2.
induction l2.
clear IHl2.
assert (HEq := Pos.compare_eq a a0).
assert (HLt := Pos.compare_nge_iff a a0).
assert (HGt := Pos.compare_gt_iff a a0).
induction (Pos.compare a a0).
assert (H : Lt = Lt).
idtac.
apply HLt in H.

*****
H : not (Pos.le a0 a)
HGt : iff (eq Lt Gt) (Pos.lt a0 a)
HLt : iff (eq Lt Lt) (not (Pos.le a0 a))
HEq : forall _ : eq Lt Eq, eq a a0
l2 : list positive
a0 : positive
IHl1 : forall l2 : list positive,\nCompSpec eqList ltList l1 l2 (compareList l1 l2)
l1 : list positive
a : positive
Ar : Arity
*****
CompSpec eqList ltList (cons a l1) (cons a0 l2) (compareList (cons a l1) (cons a0 l2))
+++++
clear HEq.
-----
Lemma compareListSpec : forall l1 l2, CompSpec eqList ltList l1 l2 (compareList l1 l2).
Proof.
intro l1.
unfold eqST.
unfold lt.
induction l1.
intro l2.
induction l2.
clear IHl2.
assert (HEq := Pos.compare_eq a a0).
assert (HLt := Pos.compare_nge_iff a a0).
assert (HGt := Pos.compare_gt_iff a a0).
induction (Pos.compare a a0).
assert (H : Lt = Lt).
idtac.
apply HLt in H.
clear HEq.

*****
H : not (Pos.le a0 a)
HGt : iff (eq Lt Gt) (Pos.lt a0 a)
HLt : iff (eq Lt Lt) (not (Pos.le a0 a))
l2 : list positive
a0 : positive
IHl1 : forall l2 : list positive,\nCompSpec eqList ltList l1 l2 (compareList l1 l2)
l1 : list positive
a : positive
Ar : Arity
*****
CompSpec eqList ltList (cons a l1) (cons a0 l2) (compareList (cons a l1) (cons a0 l2))
+++++
clear HLt.
-----
Lemma compareListSpec : forall l1 l2, CompSpec eqList ltList l1 l2 (compareList l1 l2).
Proof.
intro l1.
unfold eqST.
unfold lt.
induction l1.
intro l2.
induction l2.
clear IHl2.
assert (HEq := Pos.compare_eq a a0).
assert (HLt := Pos.compare_nge_iff a a0).
assert (HGt := Pos.compare_gt_iff a a0).
induction (Pos.compare a a0).
assert (H : Lt = Lt).
idtac.
apply HLt in H.
clear HEq.
clear HLt.

*****
H : not (Pos.le a0 a)
HGt : iff (eq Lt Gt) (Pos.lt a0 a)
l2 : list positive
a0 : positive
IHl1 : forall l2 : list positive,\nCompSpec eqList ltList l1 l2 (compareList l1 l2)
l1 : list positive
a : positive
Ar : Arity
*****
CompSpec eqList ltList (cons a l1) (cons a0 l2) (compareList (cons a l1) (cons a0 l2))
+++++
clear HGt.
-----
Lemma compareListSpec : forall l1 l2, CompSpec eqList ltList l1 l2 (compareList l1 l2).
Proof.
intro l1.
unfold eqST.
unfold lt.
induction l1.
intro l2.
induction l2.
clear IHl2.
assert (HEq := Pos.compare_eq a a0).
assert (HLt := Pos.compare_nge_iff a a0).
assert (HGt := Pos.compare_gt_iff a a0).
induction (Pos.compare a a0).
assert (H : Lt = Lt).
idtac.
apply HLt in H.
clear HEq.
clear HLt.
clear HGt.

*****
H : not (Pos.le a0 a)
l2 : list positive
a0 : positive
IHl1 : forall l2 : list positive,\nCompSpec eqList ltList l1 l2 (compareList l1 l2)
l1 : list positive
a : positive
Ar : Arity
*****
CompSpec eqList ltList (cons a l1) (cons a0 l2) (compareList (cons a l1) (cons a0 l2))
+++++
rewrite <- Pos.lt_nle in H.
-----
Lemma compareListSpec : forall l1 l2, CompSpec eqList ltList l1 l2 (compareList l1 l2).
Proof.
intro l1.
unfold eqST.
unfold lt.
induction l1.
intro l2.
induction l2.
clear IHl2.
assert (HEq := Pos.compare_eq a a0).
assert (HLt := Pos.compare_nge_iff a a0).
assert (HGt := Pos.compare_gt_iff a a0).
induction (Pos.compare a a0).
assert (H : Lt = Lt).
idtac.
apply HLt in H.
clear HEq.
clear HLt.
clear HGt.
rewrite <- Pos.lt_nle in H.

*****
H : Pos.lt a a0
l2 : list positive
a0 : positive
IHl1 : forall l2 : list positive,\nCompSpec eqList ltList l1 l2 (compareList l1 l2)
l1 : list positive
a : positive
Ar : Arity
*****
CompSpec eqList ltList (cons a l1) (cons a0 l2) (compareList (cons a l1) (cons a0 l2))
+++++
apply Pos.compare_lt_iff in H.
-----
Lemma compareListSpec : forall l1 l2, CompSpec eqList ltList l1 l2 (compareList l1 l2).
Proof.
intro l1.
unfold eqST.
unfold lt.
induction l1.
intro l2.
induction l2.
clear IHl2.
assert (HEq := Pos.compare_eq a a0).
assert (HLt := Pos.compare_nge_iff a a0).
assert (HGt := Pos.compare_gt_iff a a0).
induction (Pos.compare a a0).
assert (H : Lt = Lt).
idtac.
apply HLt in H.
clear HEq.
clear HLt.
clear HGt.
rewrite <- Pos.lt_nle in H.
apply Pos.compare_lt_iff in H.

*****
H : eq (Pos.compare a a0) Lt
l2 : list positive
a0 : positive
IHl1 : forall l2 : list positive,\nCompSpec eqList ltList l1 l2 (compareList l1 l2)
l1 : list positive
a : positive
Ar : Arity
*****
CompSpec eqList ltList (cons a l1) (cons a0 l2) (compareList (cons a l1) (cons a0 l2))
+++++
simpl.
-----
Lemma compareListSpec : forall l1 l2, CompSpec eqList ltList l1 l2 (compareList l1 l2).
Proof.
intro l1.
unfold eqST.
unfold lt.
induction l1.
intro l2.
induction l2.
clear IHl2.
assert (HEq := Pos.compare_eq a a0).
assert (HLt := Pos.compare_nge_iff a a0).
assert (HGt := Pos.compare_gt_iff a a0).
induction (Pos.compare a a0).
assert (H : Lt = Lt).
idtac.
apply HLt in H.
clear HEq.
clear HLt.
clear HGt.
rewrite <- Pos.lt_nle in H.
apply Pos.compare_lt_iff in H.
simpl.

*****
H : eq (Pos.compare a a0) Lt
l2 : list positive
a0 : positive
IHl1 : forall l2 : list positive,\nCompSpec eqList ltList l1 l2 (compareList l1 l2)
l1 : list positive
a : positive
Ar : Arity
*****
CompSpec eqList ltList (cons a l1) (cons a0 l2) match Pos.compare a a0 with | Eq => compareList l1 l2 | Lt => Lt | Gt => Gt end
+++++
rewrite H.
-----
Lemma compareListSpec : forall l1 l2, CompSpec eqList ltList l1 l2 (compareList l1 l2).
Proof.
intro l1.
unfold eqST.
unfold lt.
induction l1.
intro l2.
induction l2.
clear IHl2.
assert (HEq := Pos.compare_eq a a0).
assert (HLt := Pos.compare_nge_iff a a0).
assert (HGt := Pos.compare_gt_iff a a0).
induction (Pos.compare a a0).
assert (H : Lt = Lt).
idtac.
apply HLt in H.
clear HEq.
clear HLt.
clear HGt.
rewrite <- Pos.lt_nle in H.
apply Pos.compare_lt_iff in H.
simpl.
rewrite H.

*****
H : eq (Pos.compare a a0) Lt
l2 : list positive
a0 : positive
IHl1 : forall l2 : list positive,\nCompSpec eqList ltList l1 l2 (compareList l1 l2)
l1 : list positive
a : positive
Ar : Arity
*****
CompSpec eqList ltList (cons a l1) (cons a0 l2) Lt
+++++
apply CompLt.
-----
Lemma compareListSpec : forall l1 l2, CompSpec eqList ltList l1 l2 (compareList l1 l2).
Proof.
intro l1.
unfold eqST.
unfold lt.
induction l1.
intro l2.
induction l2.
clear IHl2.
assert (HEq := Pos.compare_eq a a0).
assert (HLt := Pos.compare_nge_iff a a0).
assert (HGt := Pos.compare_gt_iff a a0).
induction (Pos.compare a a0).
assert (H : Lt = Lt).
idtac.
apply HLt in H.
clear HEq.
clear HLt.
clear HGt.
rewrite <- Pos.lt_nle in H.
apply Pos.compare_lt_iff in H.
simpl.
rewrite H.
apply CompLt.

*****
H : eq (Pos.compare a a0) Lt
l2 : list positive
a0 : positive
IHl1 : forall l2 : list positive,\nCompSpec eqList ltList l1 l2 (compareList l1 l2)
l1 : list positive
a : positive
Ar : Arity
*****
ltList (cons a l1) (cons a0 l2)
+++++
rewrite Pos.compare_lt_iff in H.
-----
Lemma compareListSpec : forall l1 l2, CompSpec eqList ltList l1 l2 (compareList l1 l2).
Proof.
intro l1.
unfold eqST.
unfold lt.
induction l1.
intro l2.
induction l2.
clear IHl2.
assert (HEq := Pos.compare_eq a a0).
assert (HLt := Pos.compare_nge_iff a a0).
assert (HGt := Pos.compare_gt_iff a a0).
induction (Pos.compare a a0).
assert (H : Lt = Lt).
idtac.
apply HLt in H.
clear HEq.
clear HLt.
clear HGt.
rewrite <- Pos.lt_nle in H.
apply Pos.compare_lt_iff in H.
simpl.
rewrite H.
apply CompLt.
rewrite Pos.compare_lt_iff in H.

*****
H : Pos.lt a a0
l2 : list positive
a0 : positive
IHl1 : forall l2 : list positive,\nCompSpec eqList ltList l1 l2 (compareList l1 l2)
l1 : list positive
a : positive
Ar : Arity
*****
ltList (cons a l1) (cons a0 l2)
+++++
rewrite <- Pos.ltb_lt in H.
-----
Lemma compareListSpec : forall l1 l2, CompSpec eqList ltList l1 l2 (compareList l1 l2).
Proof.
intro l1.
unfold eqST.
unfold lt.
induction l1.
intro l2.
induction l2.
clear IHl2.
assert (HEq := Pos.compare_eq a a0).
assert (HLt := Pos.compare_nge_iff a a0).
assert (HGt := Pos.compare_gt_iff a a0).
induction (Pos.compare a a0).
assert (H : Lt = Lt).
idtac.
apply HLt in H.
clear HEq.
clear HLt.
clear HGt.
rewrite <- Pos.lt_nle in H.
apply Pos.compare_lt_iff in H.
simpl.
rewrite H.
apply CompLt.
rewrite Pos.compare_lt_iff in H.
rewrite <- Pos.ltb_lt in H.

*****
H : eq (Pos.ltb a a0) true
l2 : list positive
a0 : positive
IHl1 : forall l2 : list positive,\nCompSpec eqList ltList l1 l2 (compareList l1 l2)
l1 : list positive
a : positive
Ar : Arity
*****
ltList (cons a l1) (cons a0 l2)
+++++
simpl.
-----
Lemma compareListSpec : forall l1 l2, CompSpec eqList ltList l1 l2 (compareList l1 l2).
Proof.
intro l1.
unfold eqST.
unfold lt.
induction l1.
intro l2.
induction l2.
clear IHl2.
assert (HEq := Pos.compare_eq a a0).
assert (HLt := Pos.compare_nge_iff a a0).
assert (HGt := Pos.compare_gt_iff a a0).
induction (Pos.compare a a0).
assert (H : Lt = Lt).
idtac.
apply HLt in H.
clear HEq.
clear HLt.
clear HGt.
rewrite <- Pos.lt_nle in H.
apply Pos.compare_lt_iff in H.
simpl.
rewrite H.
apply CompLt.
rewrite Pos.compare_lt_iff in H.
rewrite <- Pos.ltb_lt in H.
simpl.

*****
H : eq (Pos.ltb a a0) true
l2 : list positive
a0 : positive
IHl1 : forall l2 : list positive,\nCompSpec eqList ltList l1 l2 (compareList l1 l2)
l1 : list positive
a : positive
Ar : Arity
*****
if Pos.ltb a a0 then True else if Pos.ltb a0 a then False else ltList l1 l2
+++++
rewrite H.
-----
Lemma compareListSpec : forall l1 l2, CompSpec eqList ltList l1 l2 (compareList l1 l2).
Proof.
intro l1.
unfold eqST.
unfold lt.
induction l1.
intro l2.
induction l2.
clear IHl2.
assert (HEq := Pos.compare_eq a a0).
assert (HLt := Pos.compare_nge_iff a a0).
assert (HGt := Pos.compare_gt_iff a a0).
induction (Pos.compare a a0).
assert (H : Lt = Lt).
idtac.
apply HLt in H.
clear HEq.
clear HLt.
clear HGt.
rewrite <- Pos.lt_nle in H.
apply Pos.compare_lt_iff in H.
simpl.
rewrite H.
apply CompLt.
rewrite Pos.compare_lt_iff in H.
rewrite <- Pos.ltb_lt in H.
simpl.
rewrite H.

*****
H : eq (Pos.ltb a a0) true
l2 : list positive
a0 : positive
IHl1 : forall l2 : list positive,\nCompSpec eqList ltList l1 l2 (compareList l1 l2)
l1 : list positive
a : positive
Ar : Arity
*****
True
+++++
trivial.
-----
Lemma compareListSpec : forall l1 l2, CompSpec eqList ltList l1 l2 (compareList l1 l2).
Proof.
intro l1.
unfold eqST.
unfold lt.
induction l1.
intro l2.
induction l2.
clear IHl2.
assert (HEq := Pos.compare_eq a a0).
assert (HLt := Pos.compare_nge_iff a a0).
assert (HGt := Pos.compare_gt_iff a a0).
induction (Pos.compare a a0).

*****
HGt : iff (eq Gt Gt) (Pos.lt a0 a)
HLt : iff (eq Gt Lt) (not (Pos.le a0 a))
HEq : forall _ : eq Gt Eq, eq a a0
l2 : list positive
a0 : positive
IHl1 : forall l2 : list positive,\nCompSpec eqList ltList l1 l2 (compareList l1 l2)
l1 : list positive
a : positive
Ar : Arity
*****
CompSpec eqList ltList (cons a l1) (cons a0 l2) (compareList (cons a l1) (cons a0 l2))
+++++
assert (H : Gt = Gt).
-----
Lemma compareListSpec : forall l1 l2, CompSpec eqList ltList l1 l2 (compareList l1 l2).
Proof.
intro l1.
unfold eqST.
unfold lt.
induction l1.
intro l2.
induction l2.
clear IHl2.
assert (HEq := Pos.compare_eq a a0).
assert (HLt := Pos.compare_nge_iff a a0).
assert (HGt := Pos.compare_gt_iff a a0).
induction (Pos.compare a a0).
assert (H : Gt = Gt).

*****
HGt : iff (eq Gt Gt) (Pos.lt a0 a)
HLt : iff (eq Gt Lt) (not (Pos.le a0 a))
HEq : forall _ : eq Gt Eq, eq a a0
l2 : list positive
a0 : positive
IHl1 : forall l2 : list positive,\nCompSpec eqList ltList l1 l2 (compareList l1 l2)
l1 : list positive
a : positive
Ar : Arity
*****
eq Gt Gt
+++++
reflexivity.
-----
Lemma compareListSpec : forall l1 l2, CompSpec eqList ltList l1 l2 (compareList l1 l2).
Proof.
intro l1.
unfold eqST.
unfold lt.
induction l1.
intro l2.
induction l2.
clear IHl2.
assert (HEq := Pos.compare_eq a a0).
assert (HLt := Pos.compare_nge_iff a a0).
assert (HGt := Pos.compare_gt_iff a a0).
induction (Pos.compare a a0).
assert (H : Gt = Gt).

*****
H : eq Gt Gt
HGt : iff (eq Gt Gt) (Pos.lt a0 a)
HLt : iff (eq Gt Lt) (not (Pos.le a0 a))
HEq : forall _ : eq Gt Eq, eq a a0
l2 : list positive
a0 : positive
IHl1 : forall l2 : list positive,\nCompSpec eqList ltList l1 l2 (compareList l1 l2)
l1 : list positive
a : positive
Ar : Arity
*****
CompSpec eqList ltList (cons a l1) (cons a0 l2) (compareList (cons a l1) (cons a0 l2))
+++++
idtac.
-----
Lemma compareListSpec : forall l1 l2, CompSpec eqList ltList l1 l2 (compareList l1 l2).
Proof.
intro l1.
unfold eqST.
unfold lt.
induction l1.
intro l2.
induction l2.
clear IHl2.
assert (HEq := Pos.compare_eq a a0).
assert (HLt := Pos.compare_nge_iff a a0).
assert (HGt := Pos.compare_gt_iff a a0).
induction (Pos.compare a a0).
assert (H : Gt = Gt).
idtac.

*****
H : eq Gt Gt
HGt : iff (eq Gt Gt) (Pos.lt a0 a)
HLt : iff (eq Gt Lt) (not (Pos.le a0 a))
HEq : forall _ : eq Gt Eq, eq a a0
l2 : list positive
a0 : positive
IHl1 : forall l2 : list positive,\nCompSpec eqList ltList l1 l2 (compareList l1 l2)
l1 : list positive
a : positive
Ar : Arity
*****
CompSpec eqList ltList (cons a l1) (cons a0 l2) (compareList (cons a l1) (cons a0 l2))
+++++
apply HGt in H.
-----
Lemma compareListSpec : forall l1 l2, CompSpec eqList ltList l1 l2 (compareList l1 l2).
Proof.
intro l1.
unfold eqST.
unfold lt.
induction l1.
intro l2.
induction l2.
clear IHl2.
assert (HEq := Pos.compare_eq a a0).
assert (HLt := Pos.compare_nge_iff a a0).
assert (HGt := Pos.compare_gt_iff a a0).
induction (Pos.compare a a0).
assert (H : Gt = Gt).
idtac.
apply HGt in H.

*****
H : Pos.lt a0 a
HGt : iff (eq Gt Gt) (Pos.lt a0 a)
HLt : iff (eq Gt Lt) (not (Pos.le a0 a))
HEq : forall _ : eq Gt Eq, eq a a0
l2 : list positive
a0 : positive
IHl1 : forall l2 : list positive,\nCompSpec eqList ltList l1 l2 (compareList l1 l2)
l1 : list positive
a : positive
Ar : Arity
*****
CompSpec eqList ltList (cons a l1) (cons a0 l2) (compareList (cons a l1) (cons a0 l2))
+++++
clear HEq.
-----
Lemma compareListSpec : forall l1 l2, CompSpec eqList ltList l1 l2 (compareList l1 l2).
Proof.
intro l1.
unfold eqST.
unfold lt.
induction l1.
intro l2.
induction l2.
clear IHl2.
assert (HEq := Pos.compare_eq a a0).
assert (HLt := Pos.compare_nge_iff a a0).
assert (HGt := Pos.compare_gt_iff a a0).
induction (Pos.compare a a0).
assert (H : Gt = Gt).
idtac.
apply HGt in H.
clear HEq.

*****
H : Pos.lt a0 a
HGt : iff (eq Gt Gt) (Pos.lt a0 a)
HLt : iff (eq Gt Lt) (not (Pos.le a0 a))
l2 : list positive
a0 : positive
IHl1 : forall l2 : list positive,\nCompSpec eqList ltList l1 l2 (compareList l1 l2)
l1 : list positive
a : positive
Ar : Arity
*****
CompSpec eqList ltList (cons a l1) (cons a0 l2) (compareList (cons a l1) (cons a0 l2))
+++++
clear HLt.
-----
Lemma compareListSpec : forall l1 l2, CompSpec eqList ltList l1 l2 (compareList l1 l2).
Proof.
intro l1.
unfold eqST.
unfold lt.
induction l1.
intro l2.
induction l2.
clear IHl2.
assert (HEq := Pos.compare_eq a a0).
assert (HLt := Pos.compare_nge_iff a a0).
assert (HGt := Pos.compare_gt_iff a a0).
induction (Pos.compare a a0).
assert (H : Gt = Gt).
idtac.
apply HGt in H.
clear HEq.
clear HLt.

*****
H : Pos.lt a0 a
HGt : iff (eq Gt Gt) (Pos.lt a0 a)
l2 : list positive
a0 : positive
IHl1 : forall l2 : list positive,\nCompSpec eqList ltList l1 l2 (compareList l1 l2)
l1 : list positive
a : positive
Ar : Arity
*****
CompSpec eqList ltList (cons a l1) (cons a0 l2) (compareList (cons a l1) (cons a0 l2))
+++++
clear HGt.
-----
Lemma compareListSpec : forall l1 l2, CompSpec eqList ltList l1 l2 (compareList l1 l2).
Proof.
intro l1.
unfold eqST.
unfold lt.
induction l1.
intro l2.
induction l2.
clear IHl2.
assert (HEq := Pos.compare_eq a a0).
assert (HLt := Pos.compare_nge_iff a a0).
assert (HGt := Pos.compare_gt_iff a a0).
induction (Pos.compare a a0).
assert (H : Gt = Gt).
idtac.
apply HGt in H.
clear HEq.
clear HLt.
clear HGt.

*****
H : Pos.lt a0 a
l2 : list positive
a0 : positive
IHl1 : forall l2 : list positive,\nCompSpec eqList ltList l1 l2 (compareList l1 l2)
l1 : list positive
a : positive
Ar : Arity
*****
CompSpec eqList ltList (cons a l1) (cons a0 l2) (compareList (cons a l1) (cons a0 l2))
+++++
apply Pos.compare_gt_iff in H.
-----
Lemma compareListSpec : forall l1 l2, CompSpec eqList ltList l1 l2 (compareList l1 l2).
Proof.
intro l1.
unfold eqST.
unfold lt.
induction l1.
intro l2.
induction l2.
clear IHl2.
assert (HEq := Pos.compare_eq a a0).
assert (HLt := Pos.compare_nge_iff a a0).
assert (HGt := Pos.compare_gt_iff a a0).
induction (Pos.compare a a0).
assert (H : Gt = Gt).
idtac.
apply HGt in H.
clear HEq.
clear HLt.
clear HGt.
apply Pos.compare_gt_iff in H.

*****
H : eq (Pos.compare a a0) Gt
l2 : list positive
a0 : positive
IHl1 : forall l2 : list positive,\nCompSpec eqList ltList l1 l2 (compareList l1 l2)
l1 : list positive
a : positive
Ar : Arity
*****
CompSpec eqList ltList (cons a l1) (cons a0 l2) (compareList (cons a l1) (cons a0 l2))
+++++
simpl.
-----
Lemma compareListSpec : forall l1 l2, CompSpec eqList ltList l1 l2 (compareList l1 l2).
Proof.
intro l1.
unfold eqST.
unfold lt.
induction l1.
intro l2.
induction l2.
clear IHl2.
assert (HEq := Pos.compare_eq a a0).
assert (HLt := Pos.compare_nge_iff a a0).
assert (HGt := Pos.compare_gt_iff a a0).
induction (Pos.compare a a0).
assert (H : Gt = Gt).
idtac.
apply HGt in H.
clear HEq.
clear HLt.
clear HGt.
apply Pos.compare_gt_iff in H.
simpl.

*****
H : eq (Pos.compare a a0) Gt
l2 : list positive
a0 : positive
IHl1 : forall l2 : list positive,\nCompSpec eqList ltList l1 l2 (compareList l1 l2)
l1 : list positive
a : positive
Ar : Arity
*****
CompSpec eqList ltList (cons a l1) (cons a0 l2) match Pos.compare a a0 with | Eq => compareList l1 l2 | Lt => Lt | Gt => Gt end
+++++
rewrite H.
-----
Lemma compareListSpec : forall l1 l2, CompSpec eqList ltList l1 l2 (compareList l1 l2).
Proof.
intro l1.
unfold eqST.
unfold lt.
induction l1.
intro l2.
induction l2.
clear IHl2.
assert (HEq := Pos.compare_eq a a0).
assert (HLt := Pos.compare_nge_iff a a0).
assert (HGt := Pos.compare_gt_iff a a0).
induction (Pos.compare a a0).
assert (H : Gt = Gt).
idtac.
apply HGt in H.
clear HEq.
clear HLt.
clear HGt.
apply Pos.compare_gt_iff in H.
simpl.
rewrite H.

*****
H : eq (Pos.compare a a0) Gt
l2 : list positive
a0 : positive
IHl1 : forall l2 : list positive,\nCompSpec eqList ltList l1 l2 (compareList l1 l2)
l1 : list positive
a : positive
Ar : Arity
*****
CompSpec eqList ltList (cons a l1) (cons a0 l2) Gt
+++++
apply CompGt.
-----
Lemma compareListSpec : forall l1 l2, CompSpec eqList ltList l1 l2 (compareList l1 l2).
Proof.
intro l1.
unfold eqST.
unfold lt.
induction l1.
intro l2.
induction l2.
clear IHl2.
assert (HEq := Pos.compare_eq a a0).
assert (HLt := Pos.compare_nge_iff a a0).
assert (HGt := Pos.compare_gt_iff a a0).
induction (Pos.compare a a0).
assert (H : Gt = Gt).
idtac.
apply HGt in H.
clear HEq.
clear HLt.
clear HGt.
apply Pos.compare_gt_iff in H.
simpl.
rewrite H.
apply CompGt.

*****
H : eq (Pos.compare a a0) Gt
l2 : list positive
a0 : positive
IHl1 : forall l2 : list positive,\nCompSpec eqList ltList l1 l2 (compareList l1 l2)
l1 : list positive
a : positive
Ar : Arity
*****
ltList (cons a0 l2) (cons a l1)
+++++
rewrite Pos.compare_gt_iff in H.
-----
Lemma compareListSpec : forall l1 l2, CompSpec eqList ltList l1 l2 (compareList l1 l2).
Proof.
intro l1.
unfold eqST.
unfold lt.
induction l1.
intro l2.
induction l2.
clear IHl2.
assert (HEq := Pos.compare_eq a a0).
assert (HLt := Pos.compare_nge_iff a a0).
assert (HGt := Pos.compare_gt_iff a a0).
induction (Pos.compare a a0).
assert (H : Gt = Gt).
idtac.
apply HGt in H.
clear HEq.
clear HLt.
clear HGt.
apply Pos.compare_gt_iff in H.
simpl.
rewrite H.
apply CompGt.
rewrite Pos.compare_gt_iff in H.

*****
H : Pos.lt a0 a
l2 : list positive
a0 : positive
IHl1 : forall l2 : list positive,\nCompSpec eqList ltList l1 l2 (compareList l1 l2)
l1 : list positive
a : positive
Ar : Arity
*****
ltList (cons a0 l2) (cons a l1)
+++++
rewrite <- Pos.ltb_lt in H.
-----
Lemma compareListSpec : forall l1 l2, CompSpec eqList ltList l1 l2 (compareList l1 l2).
Proof.
intro l1.
unfold eqST.
unfold lt.
induction l1.
intro l2.
induction l2.
clear IHl2.
assert (HEq := Pos.compare_eq a a0).
assert (HLt := Pos.compare_nge_iff a a0).
assert (HGt := Pos.compare_gt_iff a a0).
induction (Pos.compare a a0).
assert (H : Gt = Gt).
idtac.
apply HGt in H.
clear HEq.
clear HLt.
clear HGt.
apply Pos.compare_gt_iff in H.
simpl.
rewrite H.
apply CompGt.
rewrite Pos.compare_gt_iff in H.
rewrite <- Pos.ltb_lt in H.

*****
H : eq (Pos.ltb a0 a) true
l2 : list positive
a0 : positive
IHl1 : forall l2 : list positive,\nCompSpec eqList ltList l1 l2 (compareList l1 l2)
l1 : list positive
a : positive
Ar : Arity
*****
ltList (cons a0 l2) (cons a l1)
+++++
simpl.
-----
Lemma compareListSpec : forall l1 l2, CompSpec eqList ltList l1 l2 (compareList l1 l2).
Proof.
intro l1.
unfold eqST.
unfold lt.
induction l1.
intro l2.
induction l2.
clear IHl2.
assert (HEq := Pos.compare_eq a a0).
assert (HLt := Pos.compare_nge_iff a a0).
assert (HGt := Pos.compare_gt_iff a a0).
induction (Pos.compare a a0).
assert (H : Gt = Gt).
idtac.
apply HGt in H.
clear HEq.
clear HLt.
clear HGt.
apply Pos.compare_gt_iff in H.
simpl.
rewrite H.
apply CompGt.
rewrite Pos.compare_gt_iff in H.
rewrite <- Pos.ltb_lt in H.
simpl.

*****
H : eq (Pos.ltb a0 a) true
l2 : list positive
a0 : positive
IHl1 : forall l2 : list positive,\nCompSpec eqList ltList l1 l2 (compareList l1 l2)
l1 : list positive
a : positive
Ar : Arity
*****
if Pos.ltb a0 a then True else if Pos.ltb a a0 then False else ltList l2 l1
+++++
rewrite H.
-----
Lemma compareListSpec : forall l1 l2, CompSpec eqList ltList l1 l2 (compareList l1 l2).
Proof.
intro l1.
unfold eqST.
unfold lt.
induction l1.
intro l2.
induction l2.
clear IHl2.
assert (HEq := Pos.compare_eq a a0).
assert (HLt := Pos.compare_nge_iff a a0).
assert (HGt := Pos.compare_gt_iff a a0).
induction (Pos.compare a a0).
assert (H : Gt = Gt).
idtac.
apply HGt in H.
clear HEq.
clear HLt.
clear HGt.
apply Pos.compare_gt_iff in H.
simpl.
rewrite H.
apply CompGt.
rewrite Pos.compare_gt_iff in H.
rewrite <- Pos.ltb_lt in H.
simpl.
rewrite H.

*****
H : eq (Pos.ltb a0 a) true
l2 : list positive
a0 : positive
IHl1 : forall l2 : list positive,\nCompSpec eqList ltList l1 l2 (compareList l1 l2)
l1 : list positive
a : positive
Ar : Arity
*****
True
+++++
trivial.
-----
Lemma compareListSpec : forall l1 l2, CompSpec eqList ltList l1 l2 (compareList l1 l2).
Proof.
intro l1.
unfold eqST.
unfold lt.
induction l1.

*****

*****

+++++
Qed.
-----
Definition compareST (cp1 cp2 : tST) :=\n    compareList (PosSort.sort (CPToList cp1)) (PosSort.sort (CPToList cp2)).
-----
Lemma compare_spec : forall cp1 cp2,\n    CompSpec eqST ltST cp1 cp2 (compareST cp1 cp2).
-----
Lemma compare_spec : forall cp1 cp2, CompSpec eqST ltST cp1 cp2 (compareST cp1 cp2).

*****
Ar : Arity
*****
forall cp1 cp2 : tST, CompSpec eqST ltST cp1 cp2 (compareST cp1 cp2)
+++++
Proof.
-----
Lemma compare_spec : forall cp1 cp2, CompSpec eqST ltST cp1 cp2 (compareST cp1 cp2).
Proof.

*****
Ar : Arity
*****
forall cp1 cp2 : tST, CompSpec eqST ltST cp1 cp2 (compareST cp1 cp2)
+++++
intros cp1 cp2.
-----
Lemma compare_spec : forall cp1 cp2, CompSpec eqST ltST cp1 cp2 (compareST cp1 cp2).
Proof.
intros cp1 cp2.

*****
cp1,cp2 : tST
Ar : Arity
*****
CompSpec eqST ltST cp1 cp2 (compareST cp1 cp2)
+++++
unfold eqST.
-----
Lemma compare_spec : forall cp1 cp2, CompSpec eqST ltST cp1 cp2 (compareST cp1 cp2).
Proof.
intros cp1 cp2.
unfold eqST.

*****
cp1,cp2 : tST
Ar : Arity
*****
CompSpec (fun cp1 cp2 : tST => eqList (sort (CPToList cp1)) (sort (CPToList cp2))) ltST cp1 cp2 (compareST cp1 cp2)
+++++
unfold ltST.
-----
Lemma compare_spec : forall cp1 cp2, CompSpec eqST ltST cp1 cp2 (compareST cp1 cp2).
Proof.
intros cp1 cp2.
unfold eqST.
unfold ltST.

*****
cp1,cp2 : tST
Ar : Arity
*****
CompSpec (fun cp1 cp2 : tST => eqList (sort (CPToList cp1)) (sort (CPToList cp2))) (fun cp1 cp2 : tST => ltList (sort (CPToList cp1)) (sort (CPToList cp2))) cp1 cp2 (compareST cp1 cp2)
+++++
unfold compareST.
-----
Lemma compare_spec : forall cp1 cp2, CompSpec eqST ltST cp1 cp2 (compareST cp1 cp2).
Proof.
intros cp1 cp2.
unfold eqST.
unfold ltST.
unfold compareST.

*****
cp1,cp2 : tST
Ar : Arity
*****
CompSpec (fun cp1 cp2 : tST => eqList (sort (CPToList cp1)) (sort (CPToList cp2))) (fun cp1 cp2 : tST => ltList (sort (CPToList cp1)) (sort (CPToList cp2))) cp1 cp2 (compareList (sort (CPToList cp1)) (sort (CPToList cp2)))
+++++
apply compareListSpec.
-----
Lemma compare_spec : forall cp1 cp2, CompSpec eqST ltST cp1 cp2 (compareST cp1 cp2).
Proof.
intros cp1 cp2.
unfold eqST.
unfold ltST.
unfold compareST.
apply compareListSpec.

*****

*****

+++++
Qed.
-----
Definition STelt := tST.
-----
Definition STt := list tST.
-----
Definition STempty : STt := nil.
-----
Lemma eqST_dec : forall x y, {eqST x y} + {~ eqST x y}.
-----
Lemma eqST_dec : forall x y, {eqST x y} + {~ eqST x y}.

*****
Ar : Arity
*****
forall x y : tST, sumbool (eqST x y) (not (eqST x y))
+++++
Proof.
-----
Lemma eqST_dec : forall x y, {eqST x y} + {~ eqST x y}.
Proof.

*****
Ar : Arity
*****
forall x y : tST, sumbool (eqST x y) (not (eqST x y))
+++++
intros x y.
-----
Lemma eqST_dec : forall x y, {eqST x y} + {~ eqST x y}.
Proof.
intros x y.

*****
x,y : tST
Ar : Arity
*****
sumbool (eqST x y) (not (eqST x y))
+++++
case_eq (eqbST x y).
-----
Lemma eqST_dec : forall x y, {eqST x y} + {~ eqST x y}.
Proof.
intros x y.
case_eq (eqbST x y).

*****
x,y : tST
Ar : Arity
*****
forall _ : eq (eqbST x y) true, sumbool (eqST x y) (not (eqST x y))
+++++
intro HEq.
-----
Lemma eqST_dec : forall x y, {eqST x y} + {~ eqST x y}.
Proof.
intros x y.
case_eq (eqbST x y).
intro HEq.

*****
HEq : eq (eqbST x y) true
x,y : tST
Ar : Arity
*****
sumbool (eqST x y) (not (eqST x y))
+++++
apply eqbST_eqST in HEq.
-----
Lemma eqST_dec : forall x y, {eqST x y} + {~ eqST x y}.
Proof.
intros x y.
case_eq (eqbST x y).
intro HEq.
apply eqbST_eqST in HEq.

*****
HEq : eqST x y
x,y : tST
Ar : Arity
*****
sumbool (eqST x y) (not (eqST x y))
+++++
left.
-----
Lemma eqST_dec : forall x y, {eqST x y} + {~ eqST x y}.
Proof.
intros x y.
case_eq (eqbST x y).
intro HEq.
apply eqbST_eqST in HEq.
left.

*****
HEq : eqST x y
x,y : tST
Ar : Arity
*****
eqST x y
+++++
auto.
-----
Lemma eqST_dec : forall x y, {eqST x y} + {~ eqST x y}.
Proof.
intros x y.
case_eq (eqbST x y).

*****
x,y : tST
Ar : Arity
*****
forall _ : eq (eqbST x y) false, sumbool (eqST x y) (not (eqST x y))
+++++
intro HEq.
-----
Lemma eqST_dec : forall x y, {eqST x y} + {~ eqST x y}.
Proof.
intros x y.
case_eq (eqbST x y).
intro HEq.

*****
HEq : eq (eqbST x y) false
x,y : tST
Ar : Arity
*****
sumbool (eqST x y) (not (eqST x y))
+++++
right.
-----
Lemma eqST_dec : forall x y, {eqST x y} + {~ eqST x y}.
Proof.
intros x y.
case_eq (eqbST x y).
intro HEq.
right.

*****
HEq : eq (eqbST x y) false
x,y : tST
Ar : Arity
*****
not (eqST x y)
+++++
intro HEqST.
-----
Lemma eqST_dec : forall x y, {eqST x y} + {~ eqST x y}.
Proof.
intros x y.
case_eq (eqbST x y).
intro HEq.
right.
intro HEqST.

*****
HEqST : eqST x y
HEq : eq (eqbST x y) false
x,y : tST
Ar : Arity
*****
False
+++++
apply eqbST_eqST in HEqST.
-----
Lemma eqST_dec : forall x y, {eqST x y} + {~ eqST x y}.
Proof.
intros x y.
case_eq (eqbST x y).
intro HEq.
right.
intro HEqST.
apply eqbST_eqST in HEqST.

*****
HEqST : eq (eqbST x y) true
HEq : eq (eqbST x y) false
x,y : tST
Ar : Arity
*****
False
+++++
rewrite HEq in *.
-----
Lemma eqST_dec : forall x y, {eqST x y} + {~ eqST x y}.
Proof.
intros x y.
case_eq (eqbST x y).
intro HEq.
right.
intro HEqST.
apply eqbST_eqST in HEqST.
rewrite HEq in *.

*****
HEqST : eq false true
HEq : eq (eqbST x y) false
x,y : tST
Ar : Arity
*****
False
+++++
discriminate.
-----
Lemma eqST_dec : forall x y, {eqST x y} + {~ eqST x y}.
Proof.
intros x y.
case_eq (eqbST x y).

*****

*****

+++++
Qed.
-----
Definition STadd (x : STelt) (s : STt) := cons x s.
-----
Fixpoint STexists_ (f : STelt -> bool) (s : STt) :=\n    match s with\n      | nil      => false\n      | hd :: tl => f hd || STexists_ f tl\n    end.
-----
Fixpoint STmem elt l :=\n    match l with\n      | nil      => false\n      | hd :: tl => if eqST_dec hd elt then true else STmem elt tl\n    end.
-----
Lemma STempty_b : forall y : STelt, STmem y STempty = false.
-----
Lemma STempty_b : forall y : STelt, STmem y STempty = false.

*****
Ar : Arity
*****
forall y : STelt, eq (STmem y STempty) false
+++++
Proof.
-----
Lemma STempty_b : forall y : STelt, STmem y STempty = false.
Proof.

*****
Ar : Arity
*****
forall y : STelt, eq (STmem y STempty) false
+++++
intros.
-----
Lemma STempty_b : forall y : STelt, STmem y STempty = false.
Proof.
intros.

*****
y : STelt
Ar : Arity
*****
eq (STmem y STempty) false
+++++
reflexivity.
-----
Lemma STempty_b : forall y : STelt, STmem y STempty = false.
Proof.
intros.
reflexivity.

*****

*****

+++++
Qed.
-----
Lemma STexists_mem_4 :\n    forall f (s : STt),\n      STexists_ f s = true ->\n      exists x : STelt ,  STmem x s = true /\ f x = true.
-----
Lemma STexists_mem_4 : forall f (s : STt), STexists_ f s = true -> exists x : STelt , STmem x s = true /\\ f x = true.

*****
Ar : Arity
*****
forall (f : forall _ : STelt, bool) (s : STt) (_ : eq (STexists_ f s) true), ex (fun x : STelt => and (eq (STmem x s) true) (eq (f x) true))
+++++
Proof.
-----
Lemma STexists_mem_4 : forall f (s : STt), STexists_ f s = true -> exists x : STelt , STmem x s = true /\\ f x = true.
Proof.

*****
Ar : Arity
*****
forall (f : forall _ : STelt, bool) (s : STt) (_ : eq (STexists_ f s) true), ex (fun x : STelt => and (eq (STmem x s) true) (eq (f x) true))
+++++
intros f s HEx; induction s; simpl in *; [discriminate|].
-----
Lemma STexists_mem_4 : forall f (s : STt), STexists_ f s = true -> exists x : STelt , STmem x s = true /\\ f x = true.
Proof.
intros f s HEx; induction s; simpl in *; [discriminate|].

*****
IHs : forall _ : eq (STexists_ f s) true,\nex (fun x : STelt => and (eq (STmem x s) true) (eq (f x) true))
HEx : eq (orb (f a) (STexists_ f s)) true
s : list tST
a : tST
f : forall _ : STelt, bool
Ar : Arity
*****
ex (fun x : STelt => and (eq (if eqST_dec a x then true else STmem x s) true) (eq (f x) true))
+++++
case_eq (f a); intro Hfa; rewrite Hfa in *; simpl in *.
-----
Lemma STexists_mem_4 : forall f (s : STt), STexists_ f s = true -> exists x : STelt , STmem x s = true /\\ f x = true.
Proof.
intros f s HEx; induction s; simpl in *; [discriminate|].
case_eq (f a); intro Hfa; rewrite Hfa in *; simpl in *.

*****
Hfa : eq (f a) true
IHs : forall _ : eq (STexists_ f s) true,\nex (fun x : STelt => and (eq (STmem x s) true) (eq (f x) true))
HEx : eq true true
s : list tST
a : tST
f : forall _ : STelt, bool
Ar : Arity
*****
ex (fun x : STelt => and (eq (if eqST_dec a x then true else STmem x s) true) (eq (f x) true))
+++++
exists a; elim (eqST_dec a a); [intuition|intro H; exfalso; apply H; unfold eqST; apply eqListRefl].
-----
Lemma STexists_mem_4 : forall f (s : STt), STexists_ f s = true -> exists x : STelt , STmem x s = true /\\ f x = true.
Proof.
intros f s HEx; induction s; simpl in *; [discriminate|].
case_eq (f a); intro Hfa; rewrite Hfa in *; simpl in *.
exists a; elim (eqST_dec a a); [intuition|intro H; exfalso; apply H; unfold eqST; apply eqListRefl].

*****
Hfa : eq (f a) false
IHs : forall _ : eq (STexists_ f s) true,\nex (fun x : STelt => and (eq (STmem x s) true) (eq (f x) true))
HEx : eq (STexists_ f s) true
s : list tST
a : tST
f : forall _ : STelt, bool
Ar : Arity
*****
ex (fun x : STelt => and (eq (if eqST_dec a x then true else STmem x s) true) (eq (f x) true))
+++++
destruct (IHs HEx) as [x [Hmem Hfx]]; exists x.
-----
Lemma STexists_mem_4 : forall f (s : STt), STexists_ f s = true -> exists x : STelt , STmem x s = true /\\ f x = true.
Proof.
intros f s HEx; induction s; simpl in *; [discriminate|].
case_eq (f a); intro Hfa; rewrite Hfa in *; simpl in *.
exists a; elim (eqST_dec a a); [intuition|intro H; exfalso; apply H; unfold eqST; apply eqListRefl].
destruct (IHs HEx) as [x [Hmem Hfx]]; exists x.

*****
Hfx : eq (f x) true
Hmem : eq (STmem x s) true
x : STelt
Hfa : eq (f a) false
IHs : forall _ : eq (STexists_ f s) true,\nex (fun x : STelt => and (eq (STmem x s) true) (eq (f x) true))
HEx : eq (STexists_ f s) true
s : list tST
a : tST
f : forall _ : STelt, bool
Ar : Arity
*****
and (eq (if eqST_dec a x then true else STmem x s) true) (eq (f x) true)
+++++
elim (eqST_dec a x); intro; intuition.
-----
Lemma STexists_mem_4 : forall f (s : STt), STexists_ f s = true -> exists x : STelt , STmem x s = true /\\ f x = true.
Proof.
intros f s HEx; induction s; simpl in *; [discriminate|].
case_eq (f a); intro Hfa; rewrite Hfa in *; simpl in *.
exists a; elim (eqST_dec a a); [intuition|intro H; exfalso; apply H; unfold eqST; apply eqListRefl].
destruct (IHs HEx) as [x [Hmem Hfx]]; exists x.
elim (eqST_dec a x); intro; intuition.

*****

*****

+++++
Qed.
-----
Lemma STadd_iff : forall (s : STt) (x y : STelt),\n    STmem y (STadd x s) = true <-> (eqST x y \/ STmem y s = true).
-----
Lemma STadd_iff : forall (s : STt) (x y : STelt), STmem y (STadd x s) = true <-> (eqST x y \\/ STmem y s = true).

*****
Ar : Arity
*****
forall (s : STt) (x y : STelt), iff (eq (STmem y (STadd x s)) true) (or (eqST x y) (eq (STmem y s) true))
+++++
Proof.
-----
Lemma STadd_iff : forall (s : STt) (x y : STelt), STmem y (STadd x s) = true <-> (eqST x y \\/ STmem y s = true).
Proof.

*****
Ar : Arity
*****
forall (s : STt) (x y : STelt), iff (eq (STmem y (STadd x s)) true) (or (eqST x y) (eq (STmem y s) true))
+++++
intros.
-----
Lemma STadd_iff : forall (s : STt) (x y : STelt), STmem y (STadd x s) = true <-> (eqST x y \\/ STmem y s = true).
Proof.
intros.

*****
x,y : STelt
s : STt
Ar : Arity
*****
iff (eq (STmem y (STadd x s)) true) (or (eqST x y) (eq (STmem y s) true))
+++++
simpl.
-----
Lemma STadd_iff : forall (s : STt) (x y : STelt), STmem y (STadd x s) = true <-> (eqST x y \\/ STmem y s = true).
Proof.
intros.
simpl.

*****
x,y : STelt
s : STt
Ar : Arity
*****
iff (eq (if eqST_dec x y then true else STmem y s) true) (or (eqST x y) (eq (STmem y s) true))
+++++
elim (eqST_dec x y).
-----
Lemma STadd_iff : forall (s : STt) (x y : STelt), STmem y (STadd x s) = true <-> (eqST x y \\/ STmem y s = true).
Proof.
intros.
simpl.
elim (eqST_dec x y).

*****
x,y : STelt
s : STt
Ar : Arity
*****
forall _ : eqST x y, iff (eq true true) (or (eqST x y) (eq (STmem y s) true))
+++++
intro.
-----
Lemma STadd_iff : forall (s : STt) (x y : STelt), STmem y (STadd x s) = true <-> (eqST x y \\/ STmem y s = true).
Proof.
intros.
simpl.
elim (eqST_dec x y).
intro.

*****
a : eqST x y
x,y : STelt
s : STt
Ar : Arity
*****
iff (eq true true) (or (eqST x y) (eq (STmem y s) true))
+++++
intuition.
-----
Lemma STadd_iff : forall (s : STt) (x y : STelt), STmem y (STadd x s) = true <-> (eqST x y \\/ STmem y s = true).
Proof.
intros.
simpl.
elim (eqST_dec x y).

*****
x,y : STelt
s : STt
Ar : Arity
*****
forall _ : not (eqST x y), iff (eq (STmem y s) true) (or (eqST x y) (eq (STmem y s) true))
+++++
intro.
-----
Lemma STadd_iff : forall (s : STt) (x y : STelt), STmem y (STadd x s) = true <-> (eqST x y \\/ STmem y s = true).
Proof.
intros.
simpl.
elim (eqST_dec x y).
intro.

*****
b : not (eqST x y)
x,y : STelt
s : STt
Ar : Arity
*****
iff (eq (STmem y s) true) (or (eqST x y) (eq (STmem y s) true))
+++++
intuition.
-----
Lemma STadd_iff : forall (s : STt) (x y : STelt), STmem y (STadd x s) = true <-> (eqST x y \\/ STmem y s = true).
Proof.
intros.
simpl.
elim (eqST_dec x y).

*****

*****

+++++
Qed.
-----
End Set_of_tuple_of_positive.
-----
